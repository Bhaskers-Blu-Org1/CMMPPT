head	1.250;
access;
symbols
	sce_5_01_20080919:1.210
	latest_sce_4_20_20060523:1.125.0.2
	sce_4_20_20060523:1.125
	latest_sce4_20_OSL:1.123.0.2
	sce_4_20_OSL:1.123
	sce_410_withVa:1.98
	sce_4_05_20040511:1.71
	sce_4_00_20040201:1.33
	nextGenBranch:1.28.0.2
	nextGenRoot:1.28
	sce_3_30_20030627:1.28
	EndRw-branch:1.24.0.4
	Root-of-EndRw:1.24
	rwToStl:1.24.0.2
	latest_sce_3_10_20010924:1.13.0.2
	sce_3_10_20010924:1.13
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.250
date	2011.09.28.23.50.40;	author rjw;	state Exp;
branches;
next	1.249;

1.249
date	2011.09.24.00.28.56;	author rjw;	state Exp;
branches;
next	1.248;

1.248
date	2011.08.30.20.18.23;	author rjw;	state Exp;
branches;
next	1.247;

1.247
date	2010.11.12.22.23.20;	author rjw;	state Exp;
branches;
next	1.246;

1.246
date	2010.10.29.18.07.08;	author rjw;	state Exp;
branches;
next	1.245;

1.245
date	2010.10.12.22.02.22;	author rjw;	state Exp;
branches;
next	1.244;

1.244
date	2010.10.07.15.41.01;	author rjw;	state Exp;
branches;
next	1.243;

1.243
date	2010.09.30.22.04.58;	author rjw;	state Exp;
branches;
next	1.242;

1.242
date	2010.09.24.18.17.23;	author rjw;	state Exp;
branches;
next	1.241;

1.241
date	2010.09.24.15.46.15;	author rjw;	state Exp;
branches;
next	1.240;

1.240
date	2010.09.22.20.21.53;	author rjw;	state Exp;
branches;
next	1.239;

1.239
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.238;

1.238
date	2010.09.13.21.13.20;	author rjw;	state Exp;
branches;
next	1.237;

1.237
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2010.09.07.16.38.59;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2010.09.02.20.16.25;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2010.09.02.18.58.25;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2010.09.01.22.12.09;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2010.09.01.21.53.35;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2010.09.01.18.21.43;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2010.05.28.14.40.37;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2010.05.20.23.39.50;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2010.05.20.23.18.43;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2010.05.14.21.20.56;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2010.05.12.18.38.07;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2010.05.11.22.36.48;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2010.05.11.22.26.28;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2010.02.24.00.24.08;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2010.02.01.22.10.15;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2009.12.14.22.54.55;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2009.12.14.21.57.45;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2009.11.17.23.45.48;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2009.11.17.22.54.50;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2009.10.08.16.06.03;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2009.10.08.15.35.36;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2009.10.07.22.08.38;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2009.01.05.16.09.41;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2008.11.12.19.52.25;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2008.03.01.00.01.04;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2008.01.09.22.33.56;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2007.12.26.23.58.00;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2007.12.06.22.53.02;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2007.11.02.21.13.33;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2007.10.30.21.44.18;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2007.10.12.23.04.58;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2007.10.02.22.23.07;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2007.09.27.19.57.41;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2007.08.28.17.38.36;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2007.07.17.22.10.26;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2007.07.13.23.05.33;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2007.06.20.19.07.53;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2007.06.19.21.45.51;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2007.06.15.22.15.26;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2007.06.15.17.44.36;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2007.06.07.17.08.58;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2007.05.30.22.05.52;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2007.05.21.15.20.10;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2007.05.14.20.25.17;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2007.05.14.19.48.42;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2007.05.04.17.44.58;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2007.04.30.21.52.10;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2007.04.23.21.03.21;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2007.04.20.20.51.14;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2007.04.09.16.05.08;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2007.04.04.22.15.34;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2007.04.03.22.04.05;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2007.04.02.23.01.16;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2007.03.22.20.01.17;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2007.03.20.22.07.23;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2007.02.28.20.04.59;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2007.01.26.20.56.57;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2007.01.24.20.52.56;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2007.01.22.23.44.41;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2007.01.22.23.08.18;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2007.01.22.22.31.55;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2007.01.22.21.27.54;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2007.01.16.00.25.06;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2007.01.15.23.06.08;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.12.23.50.21;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2007.01.12.20.00.37;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2007.01.11.18.38.32;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2007.01.09.21.07.48;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2007.01.09.15.55.25;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2007.01.08.20.28.50;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2007.01.08.18.38.25;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2007.01.03.18.42.21;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2006.12.28.22.05.44;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2006.12.28.21.03.21;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2006.12.28.20.40.37;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2006.12.28.16.39.35;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2006.12.27.22.45.40;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2006.12.26.22.24.07;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2006.12.19.19.26.46;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2006.11.20.18.25.29;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2006.11.20.17.19.20;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2006.11.17.16.57.47;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2006.11.02.23.07.13;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2006.10.31.22.58.32;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2006.10.26.20.53.48;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.10.26.19.03.16;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.10.19.21.54.30;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.10.13.21.42.12;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.10.13.20.47.03;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.10.12.19.43.44;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.10.12.16.22.12;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.10.11.22.37.21;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.10.11.18.08.12;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2006.10.10.19.10.46;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2006.10.09.23.25.23;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2006.10.05.21.25.06;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2006.10.05.20.54.53;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2006.10.05.18.19.15;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2006.10.04.18.45.07;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2006.10.02.19.27.35;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2006.09.19.17.50.56;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2006.09.15.22.00.37;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2006.08.24.20.50.27;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2006.08.22.21.26.54;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2006.08.18.22.29.02;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2006.04.21.20.06.32;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.28.15.59.00;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.28.15.44.13;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.02.21.15.44.15;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.02.17.17.07.18;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2005.11.04.20.42.55;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2005.11.01.21.58.10;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2005.10.18.16.19.02;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2005.10.17.22.32.25;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2005.10.17.22.07.39;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2005.10.17.15.02.06;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2005.10.13.20.51.50;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2005.10.11.17.40.16;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2005.10.10.19.48.29;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2005.10.10.14.59.57;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2005.10.07.21.42.47;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2005.10.07.20.01.22;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2005.10.07.15.21.44;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2005.10.06.17.10.33;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2005.09.21.14.53.00;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2005.09.20.21.15.11;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2005.09.20.19.48.19;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2005.09.15.15.27.21;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2005.09.14.21.54.46;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2005.09.08.21.16.37;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.09.08.19.29.45;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.09.06.21.30.28;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.09.01.21.45.03;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.08.30.21.43.12;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.30.18.13.59;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.08.30.16.03.48;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.08.25.21.58.37;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.08.25.21.47.40;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.08.23.17.38.58;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.08.22.21.37.04;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.08.22.21.17.58;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.08.19.21.38.03;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.16.18.35.21;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.12.20.32.08;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.08.12.19.35.29;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.07.11.22.53.49;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.08.20.48.20;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.07.08.15.59.42;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.07.07.15.16.24;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.07.05.22.04.25;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.02.24.23.23.57;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.02.08.22.33.25;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.08.20.36.19;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.01.28.19.34.28;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.04.16.30.13;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.13.20.53.56;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.07.19.21.32;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.06.18.16.57;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.06.15.42.17;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.30.23.46.55;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.29.23.31.45;	author fasano;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.29.22.25.14;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.29.19.36.55;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.27.00.08.20;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.26.17.03.33;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.26.16.07.23;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.25.22.00.36;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.25.19.59.37;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.24.22.21.33;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.24.19.17.34;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.24.16.50.35;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.23.19.14.26;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.22.16.37.19;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.12.17.21.56;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.04.16.44.30;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.02.19.17.52;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.24.19.37.22;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.18.00.05.25;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.14.00.45.35;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.07.00.12.10;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.04.22.31.27;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.30.23.07.51;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.31.21.44.54;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.30.16.24.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.02.16.39.32;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.25.23.49.57;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.23.22.48.14;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.16.22.50.39;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.02.23.40.53;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.55;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.11.18.53.18;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.04.19.15.00;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.23.18.09.17;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.19.52.38;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.08.19.21.57;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.07.20.15.06;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.03.23.16.43;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.25.21.48.12;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.25.19.14.53;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.24.18.26.10;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.14.02.48;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.06.17.31.09;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.03.18.40.43;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.30.15.12.12;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.28.00.48.36;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.27.21.28.40;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.25.16.08.21;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.14.19.35.23;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.20.03.29;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.21.22.48;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.23.17.47;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.11;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.32;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.32;	author wit;	state Exp;
branches;
next	;


desc
@@


1.250
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "WitRun.C"
//
// Contains some of the implementation of class WitRun.
// The full implementation of class WitRun is in this file plus the source files
// whose names end in "Api.C", e.g., partApi.C.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <Pre.h>
#include <Post.h>
#include <DelCompItr.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <DelComp.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <StochImpMgr.h>
#include <OSRealArg.h>
#include <OVRealArg.h>
#include <HeurImp.h>
#include <HeurAllMgr.h>
#include <HeurModifier.h>
#include <OrigMrp.h>
#include <DataRead.h>
#include <DataWrit.h>
#include <SolnWrit.h>
#include <Part.h>
#include <Demand.h>
#include <Operation.h>
#include <BoundSet.h>
#include <PipMgr.h>
#include <FlexVec.h>
#include <SaeMgr.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// VALID_SIGNATURE
//
// The value of the signature_ data member of any valid WitRun.
//------------------------------------------------------------------------------

#define VALID_SIGNATURE 1234567890

//------------------------------------------------------------------------------

WitRun::~WitRun ()
   {
   delete myApiMgr_;

   signature_ = 0;
   }

//------------------------------------------------------------------------------
// witAdvanceObjItr
// API function to advance object iteration.
//------------------------------------------------------------------------------

void WitRun::witAdvanceObjItr ()
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   myCompMgr ()->myDelCompItr ()->advance ();
   }

//------------------------------------------------------------------------------

void WitRun::witBuildPip ()
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPipMgr ()->buildPegging ();
   }

//------------------------------------------------------------------------------

void WitRun::witClearPegging ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");
      
   myProblem ()->myHeurAllMgr ()->clearPegging ();
   }

//------------------------------------------------------------------------------

void WitRun::witCopyData (WitRun * origWitRun)
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   if (mySession_->active ())
      if (myDetOptImpMgr ()->extOptActive ())
         myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "dupWitRun");

   forbidNullArg (origWitRun, "origWitRun");

   myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);

   if (not origWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg", "witCopyData", "origWitRun");

   if (origWitRun->myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "origWitRun");

   mySession ()->copyData (origWitRun->mySession_);
   }

//------------------------------------------------------------------------------
// witDeleteRun
//------------------------------------------------------------------------------

void WitRun::witDeleteRun ()
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   mySession_->deactivate ();
   }

//------------------------------------------------------------------------------
// witGetDevMode ()
//------------------------------------------------------------------------------

void WitRun::witGetDevMode (WitBoolean * devMode)
   {
   myApiMgr_->allowPreInit   ();
   myApiMgr_->startInnerFunc ();

   apiGet (devMode, "devMode", DEVELOPMENT);
   }

//------------------------------------------------------------------------------
// witDisplayData
// API callable routine to print a formatted output of the input data.
//------------------------------------------------------------------------------

void WitRun::witDisplayData (const char * filename)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->displayData (filename);
   }

//------------------------------------------------------------------------------
// witEvalObjectives ()
// API callable routine to evaluate objective function values
//------------------------------------------------------------------------------

void WitRun::witEvalObjectives ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myDetOptImpMgr ()->evalObjectives ();
   }

//------------------------------------------------------------------------------
// witFinishExtOpt
// WIT API to conclude external optimizing implosion.
//------------------------------------------------------------------------------

void WitRun::witFinishExtOpt ()
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   if (not myDetOptImpMgr ()->myExtOptMgr ()->solnProvided ())
      myMsgFac () ("finishExtOptWoSolnSmsg");

   myDetOptImpMgr ()->finishExtOpt ();
   }

//------------------------------------------------------------------------------
// witFinishHeurAlloc
// API function to conclude heuristic allocation.
//------------------------------------------------------------------------------

void WitRun::witFinishHeurAlloc ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   myProblem ()->myHeurAllMgr ()->finish ();
   }

//------------------------------------------------------------------------------
// witGeneratePriorities ()
// API callable routine to generate priorities
//------------------------------------------------------------------------------

void WitRun::witGeneratePriorities ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   WitDemand::genPriorities (myProblem ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetExpCycle (
      int *      lenLists,
      char * * * partNameList,
      char * * * operationNameList)
   {
   WitObjStack <WitPart>      theParts (myProblem ());
   WitObjStack <WitOperation> theOpns  (myProblem ());
   int                        theIdx;
   WitPart *                  thePart;
   WitOperation *             theOpn;
   
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPreprocessor ()->getExpCycle (theParts, theOpns);

   apiGet (lenLists, "lenLists", theOpns.nElements ());

   forbidNullArg (partNameList,      "partNameList");
   forbidNullArg (operationNameList, "operationNameList");

   apiAlloc (partNameList,      theParts.nElements ());
   apiAlloc (operationNameList, theOpns .nElements ());

   theIdx = -1;

   while (theParts.pop (thePart))
      {
      theIdx ++;

      (* partNameList)[theIdx] = thePart->partName ().apiDupCstring ();
      }

   theIdx = -1;

   while (theOpns.pop (theOpn))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetExtOptIntVarIndices (int * * indices, int * len)
   {
   WitVector <int> indicesLoc;

   myApiMgr_->startInnerFunc ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   myDetOptImpMgr ()->
      myExtOptMgr ()->
         getIntVarIndices (indicesLoc);

   apiGet (indices, "indices", indicesLoc);
   apiGet (len,     "len",     indicesLoc.length ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetExtOptLpProb (
      int *                numcols,
      int *                numrows,
      int * *              start,
      int * *              index,
      const WitOVRealArg & value,
      const WitOVRealArg & collb,
      const WitOVRealArg & colub,
      const WitOVRealArg & obj,
      const WitOVRealArg & rowlb,
      const WitOVRealArg & rowub)
   {
   WitVector <int>    startLoc;
   WitVector <int>    indexLoc;
   WitVector <double> valueLoc;
   WitVector <double> collbLoc;
   WitVector <double> colubLoc;
   WitVector <double> objLoc;
   WitVector <double> rowlbLoc;
   WitVector <double> rowubLoc;

   myApiMgr_->startInnerFunc ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   myDetOptImpMgr ()->
      myExtOptMgr ()->
         getLpProb (
            startLoc,
            indexLoc,
            valueLoc,
            collbLoc,
            colubLoc,
            objLoc,
            rowlbLoc,
            rowubLoc);

   apiGet (numcols, "numcols", collbLoc.length ());
   apiGet (numrows, "numrows", rowlbLoc.length ());
   apiGet (start,   "start",   startLoc);
   apiGet (index,   "index",   indexLoc);
   apiGet (value,   "value",   valueLoc);
   apiGet (collb,   "collb",   collbLoc);
   apiGet (colub,   "colub",   colubLoc);
   apiGet (obj,     "obj",     objLoc);
   apiGet (rowlb,   "rowlb",   rowlbLoc);
   apiGet (rowub,   "rowub",   rowubLoc);
   }

//------------------------------------------------------------------------------
// witGetObjItrState
// API function retrieve the object type of data object at which object
// iteration is currently located.
//------------------------------------------------------------------------------

void WitRun::witGetObjItrState (WitAttr * objItrState)
   {
   myApiMgr_->startInnerFunc ();

   apiGet (
      objItrState, 
      "objItrState", 
      myCompMgr ()->myDelCompItr ()->apiObjItrState ());
   }

//------------------------------------------------------------------------------
// WIT API for heuristic implosion
//------------------------------------------------------------------------------

void WitRun::witHeurImplode ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myProblem ()->myHeurImploder ()->implode ();
   }

//------------------------------------------------------------------------------
// witInitialize
// API function to put this WitRun into its initial state, excluding the
// message facility.
//------------------------------------------------------------------------------

void WitRun::witInitialize ()
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   mySession ()->activate ();
   }

//------------------------------------------------------------------------------
// witIssueFatalMesg
//
// Issues a fatal message.
// To be used for testing.
//------------------------------------------------------------------------------

void WitRun::witIssueFatalMesg ()
   {
   myApiMgr_->startInnerFunc ();

   stronglyAssert (false);
   }

//------------------------------------------------------------------------------
// API entry point for WIT-MRP.
//------------------------------------------------------------------------------

void WitRun::witMrp ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myProblem ()->myOrigMrpExp ()->mrp ();
   }

//------------------------------------------------------------------------------
// witNewRun
//
// This function is just a place-holder to be called by the expansion of the
// STANDARD_API_IMPL macro in api.C.
//------------------------------------------------------------------------------

void WitRun::witNewRun ()
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
   }

//------------------------------------------------------------------------------
// witOptImplode
// WIT API to perform implosion by optimization.
//------------------------------------------------------------------------------

void WitRun::witOptImplode ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myDetOptImpMgr ()->implode ();
   }

//------------------------------------------------------------------------------
// witOptPreprocess ()
// Same as witPreprocess.
// No longer documented.
//------------------------------------------------------------------------------

void WitRun::witOptPreprocess ()
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPreprocessor ()->preprocess ();
   }

//------------------------------------------------------------------------------
// witPostprocess ()
// API callable routine to perform general postprocess of data.
//------------------------------------------------------------------------------

void WitRun::witPostprocess ()
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------
// witPreprocess ()
// API callable routine to perform general preprocessing of data.
//------------------------------------------------------------------------------

void WitRun::witPreprocess ()
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPreprocessor ()->preprocess ();
   }

//------------------------------------------------------------------------------

void WitRun::witPurgeData ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myCompMgr ()->purgeData ();
   }

//------------------------------------------------------------------------------
// witReadData
// API callable routine to read the input data file.
//------------------------------------------------------------------------------

void WitRun::witReadData (const char * fileName)
   {
   myApiMgr_->startInnerFunc ();

   forbidNullArg (fileName, "fileName");

   myProblem ()->myDataReader ()->readData (fileName);
   }

//------------------------------------------------------------------------------
// witResetObjItr
// API function to reset object iteration.
//------------------------------------------------------------------------------

void WitRun::witResetObjItr ()
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   myCompMgr ()->myDelCompItr ()->reset ();
   }

//------------------------------------------------------------------------------
// witSetExtOptSoln
// Sets the primal solution in ext opt implosion mode.
//------------------------------------------------------------------------------

void WitRun::witSetExtOptSoln (const WitIVRealArg & colsol)
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   myDetOptImpMgr ()->myExtOptMgr ()->setSoln (colsol);
   }

//------------------------------------------------------------------------------
// witShutDownExtOpt
// WIT API to conclude external optimizing implosion.
//------------------------------------------------------------------------------

void WitRun::witShutDownExtOpt ()
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   myDetOptImpMgr ()->shutDownExtOpt ();
   }

//------------------------------------------------------------------------------
// witShutDownHeurAlloc
// API function to shut down heuristic allocation without post-processing.
//------------------------------------------------------------------------------

void WitRun::witShutDownHeurAlloc ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   myProblem ()->myHeurAllMgr ()->reset ();
   }

//------------------------------------------------------------------------------
// witStartExtOpt
// WIT API to initiate external optimizing implosion.
//------------------------------------------------------------------------------

void WitRun::witStartExtOpt ()
   {
   myApiMgr_->startInnerFunc ();

   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "compPrices");

   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "accAfterOptImp");

   if (myOptComp ()->multiObjMode ())
      myMsgFac () ("startExtOptMultiObjSmsg");

   forbidStochMode ();

   myDetOptImpMgr ()->startExtOpt ();
   }

//------------------------------------------------------------------------------
// witStartHeurAlloc
// API function to initiate heuristic allocation.
//------------------------------------------------------------------------------

void WitRun::witStartHeurAlloc ()
   {
   myApiMgr_->startInnerFunc ();

   forbidStochMode ();

   myProblem ()->myHeurAllMgr ()->start ();
   }

//------------------------------------------------------------------------------
// witWriteCriticalList: Writes the critical part list.
//------------------------------------------------------------------------------

void WitRun::witWriteCriticalList (
   const char *  filename,
   WitFileFormat fileFormat,
   int           maxListLength)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->
      mySolnWriter ()->
         writeCriticalList (
            filename,
            fileFormat,
            maxListLength);
   }

//------------------------------------------------------------------------------
// witWriteData
// API callable routine to write the input data file.
//------------------------------------------------------------------------------

void WitRun::witWriteData (const char * filename)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->myDataWriter ()->writeData (filename);
   }

//------------------------------------------------------------------------------
// witWriteExecSched: Prints execution schedule.
//------------------------------------------------------------------------------

void WitRun::witWriteExecSched (
      const char *  filename,
      WitFileFormat fileFormat)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->mySolnWriter ()->writeExecSched (filename, fileFormat);
   }

//------------------------------------------------------------------------------
// witWriteProdSched: Prints production schedule.
//------------------------------------------------------------------------------

void WitRun::witWriteProdSched (
   const char * filename,
   WitFileFormat fileFormat )
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("witWriteProdSchedWithCompatibility");

      witWriteExecSched (filename, fileFormat);
      }

   else
      myMsgFac () ("witWriteProdSchedWithoutCompatibility");
   }

//------------------------------------------------------------------------------
// witWriteReqSched: Prints supply requirements schedule.
//------------------------------------------------------------------------------

void WitRun::witWriteReqSched (
      const char * filename,
      WitFileFormat fileFormat)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->mySolnWriter ()->writeReqSched (filename, fileFormat);
   }

//------------------------------------------------------------------------------
// witWriteShipSched: Prints the shipment schedule.
//------------------------------------------------------------------------------

void WitRun::witWriteShipSched (
   const char * filename,
   WitFileFormat fileFormat )
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->mySolnWriter ()->writeShipSched (filename, fileFormat);
   }

//------------------------------------------------------------------------------

void WitRun::witNoDependantWitRunVeneersIsOne (int * isOne)
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   apiGet (
      isOne,
      "isOne",
      (nDepVeneers_ == 1)? 1: 0);
   }

//------------------------------------------------------------------------------

void WitRun::witNoDependantWitRunVeneersDecr ()
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   -- nDepVeneers_;
   }

//------------------------------------------------------------------------------

void WitRun::witNoDependantWitRunVeneersIncr ()
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   ++ nDepVeneers_;
   }

//------------------------------------------------------------------------------

void WitRun::witExhaustMemory ()
   {
   int    totDiscarded;
   char * theMem;

   myApiMgr_->startInnerFunc ();

   for (totDiscarded = 100; alwaysTrue (); totDiscarded += 100)
      {
      theMem = NULL;

      theMem = new char[104857600];

      if (theMem == NULL)
         myMsgFac () ("newRetNullFmsg");

      myMsgFac () ("discardMemoryMsg", totDiscarded);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witExecStandAlone (int argc, char * argv[])
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   if (WitSaeMgr::standAloneMode ())
      myMsgFac () ("overlapStandAloneSmsg");

   if (mySession_->active ())
      forbidStochMode ();

   WitSaeMgr::execute (this, argc, argv);
   }

//------------------------------------------------------------------------------

void WitRun::witInterpretDevCmd (const char * theDevCmd)
   {
   WitString theDevCmdString;

   myApiMgr_->startInnerFunc ();

   if (not DEVELOPMENT)
      myMsgFac () ("intDevCmdWoDevModeSmsg");

   theDevCmdString = theDevCmd;

   myMsgFac () ("intDevCmdMsg", theDevCmdString);

   if (theDevCmdString      == "Throw an exception of unknown type.")
      throw bool ();

   else if (theDevCmdString == "Print availability schedule.")
      myProblem ()->
         myHeurAllMgr ()->
            printAvailSched ();

   else
      myMsgFac () ("invalidDevCmdSmsg");
   }

//------------------------------------------------------------------------------

WitInputID * WitRun::myInputID () const
   {
   return myApiMgr ()->myInputID ();
   }

//------------------------------------------------------------------------------

WitRun * WitRun::newInstance ()
   {
   WitRun * theWitRun;

   void (* appNewHandler) ();

   try
      {
      theWitRun = new WitRun;
      }

   catch (std::bad_alloc)
      {
      handleBadAllocForCtor ();
      }

   return theWitRun;
   }

//------------------------------------------------------------------------------

void WitRun::validateWitRun (WitRun * theWitRun, const char * theFuncName)
   {
   if (theWitRun == NULL)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "   A WIT function was called with a NULL pointer for the WitRun "
            "argument.\n"
         "\n"
         "      Function: %s\n",
         theFuncName);

      finishNonMsgSevereError ();
      }

   if (theWitRun->signature_ != VALID_SIGNATURE)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "   A WIT function was called with an invalid (possibly deleted) "
            "WitRun argument.\n"
         "\n"
         "      Function: %s\n",
         theFuncName);

      finishNonMsgSevereError ();
      }
   }

//------------------------------------------------------------------------------

void WitRun::forbidNullArg (const void * theArg, const char * argName)
   {
   witAssert (argName != NULL);

   if (theArg == NULL)
      {
      myInputID ()->setArgName (argName);

      myMsgFac () ("nullPointerSmsg");
      }
   }

//------------------------------------------------------------------------------

void WitRun::apiVoidAlloc (void * * theCVecPtr, int nElems, size_t elSize)
   {
   * theCVecPtr = NULL;

   if (nElems == 0)
      return;

   * theCVecPtr = calloc (nElems, elSize);

   if (* theCVecPtr == NULL)
      WitMsgFacility::issueByException ("callocSmsg", nElems * elSize);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      int *        theVarPtr,
      const char * argName,
      int          theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      WitBoolean * theVarPtr,
      const char * argName,
      bool         theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      const WitOSRealArg & theArg,
      const char *         argName,
      double               theValue)
   {
   forbidNullArg (theArg, argName);

   theArg = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      WitAttr *    theVarPtr,
      const char * argName,
      WitAttr      theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      FILE * *     theVarPtr,
      const char * argName,
      FILE *       theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      void * *     theVarPtr,
      const char * argName,
      void *       theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      char * *          theVarPtr,
      const char *      argName,
      const WitString & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue.apiDupCstring ();
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      const WitOVRealArg &       theArg,
      const char *               argName,
      const WitVector <double> & theValue)
   {
   forbidNullArg (theArg, argName);

   apiAlloc (theArg, theValue.length ());

   theArg = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      int * *                 theVarPtr,
      const char *            argName,
      const WitVector <int> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, theValue.length ());

   theValue.copyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      WitBoolean * *           theVarPtr,
      const char *             argName,
      const WitVector <bool> & theValue)
   {
   WitPeriod thePer;

   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, theValue.length ());

   forEachPeriod (thePer, this)
      (* theVarPtr)[thePer] = theValue[thePer];
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      const WitOVRealArg &  theArg,
      const char *          argName,
      const WitDblFlexVec & theValue)
   {
   forbidNullArg (theArg, argName);

   apiAlloc (theArg, nPeriods ());

   theArg = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      WitBoolean * *            theVarPtr,
      const char *              argName,
      const WitFlexVec <bool> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, nPeriods ());

   copy (* theVarPtr, theValue);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      int * *                  theVarPtr,
      const char *             argName,
      const WitFlexVec <int> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, nPeriods ());

   theValue.copyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      const WitOVRealArg & hardLBVec,
      const WitOVRealArg & softLBVec,
      const WitOVRealArg & hardUBVec,
      WitBoundSet *        theValue)
   {
   apiGet (hardLBVec, "hardLB", theValue->hardLB ());
   apiGet (softLBVec, "softLB", theValue->softLB ());
   apiGet (hardUBVec, "hardUB", theValue->hardUB ());
   }

//------------------------------------------------------------------------------

WitRun::WitRun ():
      signature_   (VALID_SIGNATURE),
      myApiMgr_    (NULL),
      mySession_   (NULL),
      nDepVeneers_ (0)
   {
   myApiMgr_  = new WitApiMgr (this);

   mySession_ = myApiMgr ()->mySession ();
   }

//------------------------------------------------------------------------------

WitDelComp * WitRun::curItrDelCompForGet (
      WitAttr      objItrStateVal,
      WitMsgFragID theObjTypeFragID)
   {
   WitDelComp * theDelComp;

   if (not myCompMgr ()->myDelCompItr ()->active ())
      myMsgFac () ("getObjWhileItrInactiveSmsg");

   theDelComp = myCompMgr ()->myDelCompItr ()->curDelComp ();

   if (objItrStateVal != theDelComp->apiObjItrState ())
      myMsgFac () ("getObjObjTypeMismatchSmsg",
         myMsgFac ().myFrag (theObjTypeFragID),
         theDelComp->objTypeMsgFrag ());

   return theDelComp;
   }

//------------------------------------------------------------------------------

void WitRun::handleBadAllocForCtor ()
   {
   startNonMsgSevereError ();

   fprintf (stderr,
      "Memory allocation error.\n"
      "There is not enough memory available for WIT to create a new WitRun.\n"
      "\n"
      "   Function           : witNewRun\n");

   finishNonMsgSevereError ();
   }

//------------------------------------------------------------------------------

void WitRun::startCopyObjData (WitRun * origWitRun)
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   forbidNullArg (origWitRun, "origWitRun");

   myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);


   if (not mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "dupWitRun");

   if (not origWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "origWitRun");


   if (myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "dupWitRun");

   if (origWitRun->myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "origWitRun");


   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "dupWitRun");

   if (origWitRun->myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "origWitRun");


   if (myOptComp ()->multiObjMode ())
      myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "dupWitRun");

   if (origWitRun->myOptComp ()->multiObjMode ())
      myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "origWitRun");


   checkGlobAttsForCopy (origWitRun);

   if (this == origWitRun)
      myMsgFac () ("sameWitRunMsg");
   else
      myMsgFac () ("distinctWitRunsMsg");
   }

//------------------------------------------------------------------------------

void WitRun::checkGlobAttsForCopy (WitRun * origWitRun)
   {
   WitGlobalComp *  dupGlobal;
   WitGlobalComp * origGlobal;

    dupGlobal =             myGlobalComp ();
   origGlobal = origWitRun->myGlobalComp ();

   if (dupGlobal->nPeriods () != origGlobal->nPeriods ())
      {
      myMsgFac () ("copyObjDiffNPeriodsSmsg",
         apiFuncName (),
          dupGlobal->nPeriods (),
         origGlobal->nPeriods ());
      }
 
   if (dupGlobal->wit34Compatible () != origGlobal->wit34Compatible ())
      {
      myMsgFac () ("copyObjDiffBoolAttSmsg",
         apiFuncName (),
                    "wit34Compatible",
          dupGlobal->wit34Compatible (),
         origGlobal->wit34Compatible ());
      }

   if (dupGlobal->independentOffsets () != origGlobal->independentOffsets ())
      {
      myMsgFac () ("copyObjDiffBoolAttSmsg",
         apiFuncName (),
                    "independentOffsets",
          dupGlobal->independentOffsets (),
         origGlobal->independentOffsets ());
      }
   }

//------------------------------------------------------------------------------

void WitRun::prepSet34Attr (
      const char * the34Object,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute)
   {
   if (wit34Compatible ())
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   }

//------------------------------------------------------------------------------

void WitRun::prepGet34Attr (
      const char * the34Object,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute)
   {
   if (wit34Compatible ())
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   }

//------------------------------------------------------------------------------

void WitRun::prepGetIndex (int thePer)
   {
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", thePer);

   if (not ((thePer >= 0) and (thePer < nPeriods ())))
      {
      myInputID ()->setArgName ("thePer");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", thePer, 0, nPeriods ());
      }

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
   }

//------------------------------------------------------------------------------

void WitRun::addingDelComp (WitMsgFragID theObjTypeFragID)
   {
   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("addStochModeSmsg", myMsgFac ().myFrag (theObjTypeFragID));
   }

//------------------------------------------------------------------------------

void WitRun::forbidStochMode ()
   {
   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeSmsg", apiFuncName ());
   }

//------------------------------------------------------------------------------

const char * WitRun::apiFuncName ()
   {
   return myApiMgr ()->apiFuncName ();
   }

//------------------------------------------------------------------------------
// Implementation and explicit instantiation of function template
// NonClass::apiAlloc.
//------------------------------------------------------------------------------

template <typename Elem>
      void WitNonClass::apiAlloc (Elem * * theCVecPtr, int nElems)
   {
   WitRun::apiVoidAlloc (
      reinterpret_cast <void * *> (theCVecPtr),
      nElems,
      sizeof (Elem));
   }

//------------------------------------------------------------------------------

template void WitNonClass::apiAlloc <int>      (int    * *,   int);
template void WitNonClass::apiAlloc <float>    (float  * *,   int);
template void WitNonClass::apiAlloc <double>   (double * *,   int);
template void WitNonClass::apiAlloc <char>     (char   * *,   int);
template void WitNonClass::apiAlloc <float  *> (float  * * *, int);
template void WitNonClass::apiAlloc <double *> (double * * *, int);
template void WitNonClass::apiAlloc <char   *> (char   * * *, int);

//------------------------------------------------------------------------------

void WitNonClass::apiAlloc (const WitOVRealArg & theOVRealArg, int nElems)
   {
   theOVRealArg.apiAlloc (nElems);
   }
@


1.249
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.248
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d63 2
a64 2
{
delete myApiMgr_;
d66 2
a67 2
signature_ = 0;
}
d75 3
a77 3
{
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d79 2
a80 2
myCompMgr ()->myDelCompItr ()->advance ();
}
d85 2
a86 2
{
myApiMgr_->startInnerFunc ();
d88 2
a89 2
myProblem ()->myPipMgr ()->buildPegging ();
}
d94 2
a95 2
{
myApiMgr_->startInnerFunc ();
d97 5
a101 5
if (not myGlobalComp ()->perfPegging ())
myMsgFac () ("reqPerfPeggingSmsg");

myProblem ()->myHeurAllMgr ()->clearPegging ();
}
d106 4
a109 4
{
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d111 3
a113 3
if (mySession_->active ())
if (myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "dupWitRun");
d115 1
a115 1
forbidNullArg (origWitRun, "origWitRun");
d117 1
a117 1
myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);
d119 2
a120 2
if (not origWitRun->mySession_->active ())
myMsgFac () ("uninitWitRun2Smsg", "witCopyData", "origWitRun");
d122 2
a123 2
if (origWitRun->myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "origWitRun");
d125 2
a126 2
mySession ()->copyData (origWitRun->mySession_);
}
d133 5
a137 5
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d139 2
a140 2
mySession_->deactivate ();
}
d147 3
a149 3
{
myApiMgr_->allowPreInit   ();
myApiMgr_->startInnerFunc ();
d151 2
a152 2
apiGet (devMode, "devMode", DEVELOPMENT);
}
d160 2
a161 2
{
myApiMgr_->startInnerFunc ();
d163 2
a164 2
myProblem ()->displayData (filename);
}
d172 2
a173 2
{
myApiMgr_->startInnerFunc ();
d175 1
a175 1
forbidStochMode ();
d177 2
a178 2
myDetOptImpMgr ()->evalObjectives ();
}
d186 3
a188 3
{
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d190 2
a191 2
if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d193 2
a194 2
if (not myDetOptImpMgr ()->myExtOptMgr ()->solnProvided ())
myMsgFac () ("finishExtOptWoSolnSmsg");
d196 2
a197 2
myDetOptImpMgr ()->finishExtOpt ();
}
d205 2
a206 2
{
myApiMgr_->startInnerFunc ();
d208 2
a209 2
if (not myProblem ()->myHeurAllMgr ()->active ())
myMsgFac () ("inactiveHeurAllocSmsg");
d211 2
a212 2
myProblem ()->myHeurAllMgr ()->finish ();
}
d220 2
a221 2
{
myApiMgr_->startInnerFunc ();
d223 1
a223 1
forbidStochMode ();
d225 2
a226 2
WitDemand::genPriorities (myProblem ());
}
d231 40
a270 40
int *      lenLists,
char * * * partNameList,
char * * * operationNameList)
{
WitObjStack <WitPart>      theParts (myProblem ());
WitObjStack <WitOperation> theOpns  (myProblem ());
int                        theIdx;
WitPart *                  thePart;
WitOperation *             theOpn;

myApiMgr_->startInnerFunc ();

myProblem ()->myPreprocessor ()->getExpCycle (theParts, theOpns);

apiGet (lenLists, "lenLists", theOpns.nElements ());

forbidNullArg (partNameList,      "partNameList");
forbidNullArg (operationNameList, "operationNameList");

apiAlloc (partNameList,      theParts.nElements ());
apiAlloc (operationNameList, theOpns .nElements ());

theIdx = -1;

while (theParts.pop (thePart))
{
theIdx ++;

(* partNameList)[theIdx] = thePart->partName ().apiDupCstring ();
}

theIdx = -1;

while (theOpns.pop (theOpn))
{
theIdx ++;

(* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();
}
}
d275 2
a276 2
{
WitVector <int> indicesLoc;
d278 1
a278 1
myApiMgr_->startInnerFunc ();
d280 2
a281 2
if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d283 3
a285 3
myDetOptImpMgr ()->
myExtOptMgr ()->
getIntVarIndices (indicesLoc);
d287 3
a289 3
apiGet (indices, "indices", indicesLoc);
apiGet (len,     "len",     indicesLoc.length ());
}
d294 48
a341 48
int *                numcols,
int *                numrows,
int * *              start,
int * *              index,
const WitOVRealArg & value,
const WitOVRealArg & collb,
const WitOVRealArg & colub,
const WitOVRealArg & obj,
const WitOVRealArg & rowlb,
const WitOVRealArg & rowub)
{
WitVector <int>    startLoc;
WitVector <int>    indexLoc;
WitVector <double> valueLoc;
WitVector <double> collbLoc;
WitVector <double> colubLoc;
WitVector <double> objLoc;
WitVector <double> rowlbLoc;
WitVector <double> rowubLoc;

myApiMgr_->startInnerFunc ();

if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

myDetOptImpMgr ()->
myExtOptMgr ()->
getLpProb (
startLoc,
indexLoc,
valueLoc,
collbLoc,
colubLoc,
objLoc,
rowlbLoc,
rowubLoc);

apiGet (numcols, "numcols", collbLoc.length ());
apiGet (numrows, "numrows", rowlbLoc.length ());
apiGet (start,   "start",   startLoc);
apiGet (index,   "index",   indexLoc);
apiGet (value,   "value",   valueLoc);
apiGet (collb,   "collb",   collbLoc);
apiGet (colub,   "colub",   colubLoc);
apiGet (obj,     "obj",     objLoc);
apiGet (rowlb,   "rowlb",   rowlbLoc);
apiGet (rowub,   "rowub",   rowubLoc);
}
d350 2
a351 2
{
myApiMgr_->startInnerFunc ();
d353 5
a357 5
apiGet (
objItrState,
"objItrState",
myCompMgr ()->myDelCompItr ()->apiObjItrState ());
}
d364 2
a365 2
{
myApiMgr_->startInnerFunc ();
d367 1
a367 1
forbidStochMode ();
d369 2
a370 2
myProblem ()->myHeurImploder ()->implode ();
}
d379 4
a382 4
{
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d384 2
a385 2
mySession ()->activate ();
}
d395 2
a396 2
{
myApiMgr_->startInnerFunc ();
d398 2
a399 2
stronglyAssert (false);
}
d406 2
a407 2
{
myApiMgr_->startInnerFunc ();
d409 1
a409 1
forbidStochMode ();
d411 2
a412 2
myProblem ()->myOrigMrpExp ()->mrp ();
}
d422 6
a427 6
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
}
d435 2
a436 2
{
myApiMgr_->startInnerFunc ();
d438 1
a438 1
forbidStochMode ();
d440 2
a441 2
myDetOptImpMgr ()->implode ();
}
d450 2
a451 2
{
myApiMgr_->startInnerFunc ();
d453 2
a454 2
myProblem ()->myPreprocessor ()->preprocess ();
}
d462 2
a463 2
{
myApiMgr_->startInnerFunc ();
d465 2
a466 2
myProblem ()->myPostprocessor ()->postprocess ();
}
d474 2
a475 2
{
myApiMgr_->startInnerFunc ();
d477 2
a478 2
myProblem ()->myPreprocessor ()->preprocess ();
}
d483 2
a484 2
{
myApiMgr_->startInnerFunc ();
d486 1
a486 1
forbidStochMode ();
d488 2
a489 2
myCompMgr ()->purgeData ();
}
d497 2
a498 2
{
myApiMgr_->startInnerFunc ();
d500 1
a500 1
forbidNullArg (fileName, "fileName");
d502 2
a503 2
myProblem ()->myDataReader ()->readData (fileName);
}
d511 3
a513 3
{
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d515 2
a516 2
myCompMgr ()->myDelCompItr ()->reset ();
}
d524 3
a526 3
{
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d528 2
a529 2
if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d531 2
a532 2
myDetOptImpMgr ()->myExtOptMgr ()->setSoln (colsol);
}
d540 3
a542 3
{
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d544 2
a545 2
if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d547 2
a548 2
myDetOptImpMgr ()->shutDownExtOpt ();
}
d556 2
a557 2
{
myApiMgr_->startInnerFunc ();
d559 2
a560 2
if (not myProblem ()->myHeurAllMgr ()->active ())
myMsgFac () ("inactiveHeurAllocSmsg");
d562 2
a563 2
myProblem ()->myHeurAllMgr ()->reset ();
}
d571 2
a572 2
{
myApiMgr_->startInnerFunc ();
d574 2
a575 2
if (myGlobalComp ()->computeCriticalList ())
myMsgFac () ("invalidAttrForStartExtSmsg", "computeCriticalList");
d577 2
a578 2
if (myOptComp ()->compPrices ())
myMsgFac () ("invalidAttrForStartExtSmsg", "compPrices");
d580 2
a581 2
if (myOptComp ()->accAfterOptImp ())
myMsgFac () ("invalidAttrForStartExtSmsg", "accAfterOptImp");
d583 2
a584 2
if (myOptComp ()->multiObjMode ())
myMsgFac () ("startExtOptMultiObjSmsg");
d586 1
a586 1
forbidStochMode ();
d588 2
a589 2
myDetOptImpMgr ()->startExtOpt ();
}
d597 2
a598 2
{
myApiMgr_->startInnerFunc ();
d600 1
a600 1
forbidStochMode ();
d602 2
a603 2
myProblem ()->myHeurAllMgr ()->start ();
}
d610 13
a622 13
const char *  filename,
WitFileFormat fileFormat,
int           maxListLength)
{
myApiMgr_->startInnerFunc ();

myProblem ()->
mySolnWriter ()->
writeCriticalList (
filename,
fileFormat,
maxListLength);
}
d630 2
a631 2
{
myApiMgr_->startInnerFunc ();
d633 2
a634 2
myProblem ()->myDataWriter ()->writeData (filename);
}
d641 4
a644 4
const char *  filename,
WitFileFormat fileFormat)
{
myApiMgr_->startInnerFunc ();
d646 2
a647 2
myProblem ()->mySolnWriter ()->writeExecSched (filename, fileFormat);
}
d654 15
a668 15
const char * filename,
WitFileFormat fileFormat )
{
myApiMgr_->startInnerFunc ();

if (wit34Compatible ())
{
myMsgFac () ("witWriteProdSchedWithCompatibility");

witWriteExecSched (filename, fileFormat);
}

else
myMsgFac () ("witWriteProdSchedWithoutCompatibility");
}
d675 4
a678 4
const char * filename,
WitFileFormat fileFormat)
{
myApiMgr_->startInnerFunc ();
d680 2
a681 2
myProblem ()->mySolnWriter ()->writeReqSched (filename, fileFormat);
}
d688 4
a691 4
const char * filename,
WitFileFormat fileFormat )
{
myApiMgr_->startInnerFunc ();
d693 2
a694 2
myProblem ()->mySolnWriter ()->writeShipSched (filename, fileFormat);
}
d699 11
a709 11
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();

apiGet (
isOne,
"isOne",
(nDepVeneers_ == 1)? 1: 0);
}
d714 5
a718 5
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d720 2
a721 2
-- nDepVeneers_;
}
d726 5
a730 5
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d732 2
a733 2
++ nDepVeneers_;
}
d738 3
a740 3
{
int    totDiscarded;
char * theMem;
d742 1
a742 1
myApiMgr_->startInnerFunc ();
d744 3
a746 3
for (totDiscarded = 100; alwaysTrue (); totDiscarded += 100)
{
theMem = NULL;
d748 1
a748 1
theMem = new char[104857600];
d750 2
a751 2
if (theMem == NULL)
myMsgFac () ("newRetNullFmsg");
d753 3
a755 3
myMsgFac () ("discardMemoryMsg", totDiscarded);
}
}
d760 5
a764 5
{
myApiMgr_->skipCallMsg       ();
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d766 2
a767 2
if (WitSaeMgr::standAloneMode ())
myMsgFac () ("overlapStandAloneSmsg");
d769 2
a770 2
if (mySession_->active ())
forbidStochMode ();
d772 2
a773 2
WitSaeMgr::execute (this, argc, argv);
}
d778 2
a779 2
{
WitString theDevCmdString;
d781 1
a781 1
myApiMgr_->startInnerFunc ();
d783 2
a784 2
if (not DEVELOPMENT)
myMsgFac () ("intDevCmdWoDevModeSmsg");
d786 1
a786 1
theDevCmdString = theDevCmd;
d788 1
a788 1
myMsgFac () ("intDevCmdMsg", theDevCmdString);
d790 2
a791 2
if (theDevCmdString      == "Throw an exception of unknown type.")
throw bool ();
d793 4
a796 4
else if (theDevCmdString == "Print availability schedule.")
myProblem ()->
myHeurAllMgr ()->
printAvailSched ();
d798 3
a800 3
else
myMsgFac () ("invalidDevCmdSmsg");
}
d805 3
a807 3
{
return myApiMgr ()->myInputID ();
}
d812 2
a813 2
{
WitRun * theWitRun;
d815 1
a815 1
void (* appNewHandler) ();
d817 9
a825 9
try
{
theWitRun = new WitRun;
}

catch (std::bad_alloc)
{
handleBadAllocForCtor ();
}
d827 2
a828 2
return theWitRun;
}
d833 29
a861 29
{
if (theWitRun == NULL)
{
startNonMsgSevereError ();

fprintf (stderr,
"   A WIT function was called with a NULL pointer for the WitRun "
"argument.\n"
"\n"
"      Function: %s\n",
theFuncName);

finishNonMsgSevereError ();
}

if (theWitRun->signature_ != VALID_SIGNATURE)
{
startNonMsgSevereError ();

fprintf (stderr,
"   A WIT function was called with an invalid (possibly deleted) "
"WitRun argument.\n"
"\n"
"      Function: %s\n",
theFuncName);

finishNonMsgSevereError ();
}
}
d866 2
a867 2
{
witAssert (argName != NULL);
d869 7
a875 7
if (theArg == NULL)
{
myInputID ()->setArgName (argName);

myMsgFac () ("nullPointerSmsg");
}
}
d880 2
a881 2
{
* theCVecPtr = NULL;
d883 2
a884 2
if (nElems == 0)
return;
d886 1
a886 1
* theCVecPtr = calloc (nElems, elSize);
d888 3
a890 3
if (* theCVecPtr == NULL)
WitMsgFacility::issueByException ("callocSmsg", nElems * elSize);
}
d895 5
a899 5
int *        theVarPtr,
const char * argName,
int          theValue)
{
forbidNullArg (theVarPtr, argName);
d901 2
a902 2
* theVarPtr = theValue;
}
d907 5
a911 5
WitBoolean * theVarPtr,
const char * argName,
bool         theValue)
{
forbidNullArg (theVarPtr, argName);
d913 2
a914 2
* theVarPtr = theValue;
}
d919 5
a923 5
const WitOSRealArg & theArg,
const char *         argName,
double               theValue)
{
forbidNullArg (theArg, argName);
d925 2
a926 2
theArg = theValue;
}
d931 5
a935 5
WitAttr *    theVarPtr,
const char * argName,
WitAttr      theValue)
{
forbidNullArg (theVarPtr, argName);
d937 2
a938 2
* theVarPtr = theValue;
}
d943 5
a947 5
FILE * *     theVarPtr,
const char * argName,
FILE *       theValue)
{
forbidNullArg (theVarPtr, argName);
d949 2
a950 2
* theVarPtr = theValue;
}
d955 5
a959 5
void * *     theVarPtr,
const char * argName,
void *       theValue)
{
forbidNullArg (theVarPtr, argName);
d961 2
a962 2
* theVarPtr = theValue;
}
d967 5
a971 5
char * *          theVarPtr,
const char *      argName,
const WitString & theValue)
{
forbidNullArg (theVarPtr, argName);
d973 2
a974 2
* theVarPtr = theValue.apiDupCstring ();
}
d979 5
a983 5
const WitOVRealArg &       theArg,
const char *               argName,
const WitVector <double> & theValue)
{
forbidNullArg (theArg, argName);
d985 1
a985 1
apiAlloc (theArg, theValue.length ());
d987 2
a988 2
theArg = theValue;
}
d993 5
a997 5
int * *                 theVarPtr,
const char *            argName,
const WitVector <int> & theValue)
{
forbidNullArg (theVarPtr, argName);
d999 1
a999 1
apiAlloc (theVarPtr, theValue.length ());
d1001 2
a1002 2
theValue.copyInto (* theVarPtr);
}
d1007 13
a1019 13
WitBoolean * *           theVarPtr,
const char *             argName,
const WitVector <bool> & theValue)
{
WitPeriod thePer;

forbidNullArg (theVarPtr, argName);

apiAlloc (theVarPtr, theValue.length ());

forEachPeriod (thePer, this)
(* theVarPtr)[thePer] = theValue[thePer];
}
d1024 5
a1028 5
const WitOVRealArg &  theArg,
const char *          argName,
const WitDblFlexVec & theValue)
{
forbidNullArg (theArg, argName);
d1030 1
a1030 1
apiAlloc (theArg, nPeriods ());
d1032 2
a1033 2
theArg = theValue;
}
d1038 5
a1042 5
WitBoolean * *            theVarPtr,
const char *              argName,
const WitFlexVec <bool> & theValue)
{
forbidNullArg (theVarPtr, argName);
d1044 1
a1044 1
apiAlloc (theVarPtr, nPeriods ());
d1046 2
a1047 2
copy (* theVarPtr, theValue);
}
d1052 5
a1056 5
int * *                  theVarPtr,
const char *             argName,
const WitFlexVec <int> & theValue)
{
forbidNullArg (theVarPtr, argName);
d1058 1
a1058 1
apiAlloc (theVarPtr, nPeriods ());
d1060 2
a1061 2
theValue.copyInto (* theVarPtr);
}
d1066 9
a1074 9
const WitOVRealArg & hardLBVec,
const WitOVRealArg & softLBVec,
const WitOVRealArg & hardUBVec,
WitBoundSet *        theValue)
{
apiGet (hardLBVec, "hardLB", theValue->hardLB ());
apiGet (softLBVec, "softLB", theValue->softLB ());
apiGet (hardUBVec, "hardUB", theValue->hardUB ());
}
d1079 6
a1084 6
signature_   (VALID_SIGNATURE),
myApiMgr_    (NULL),
mySession_   (NULL),
nDepVeneers_ (0)
{
myApiMgr_  = new WitApiMgr (this);
d1086 2
a1087 2
mySession_ = myApiMgr ()->mySession ();
}
d1092 14
a1105 14
WitAttr      objItrStateVal,
WitMsgFragID theObjTypeFragID)
{
WitDelComp * theDelComp;

if (not myCompMgr ()->myDelCompItr ()->active ())
myMsgFac () ("getObjWhileItrInactiveSmsg");

theDelComp = myCompMgr ()->myDelCompItr ()->curDelComp ();

if (objItrStateVal != theDelComp->apiObjItrState ())
myMsgFac () ("getObjObjTypeMismatchSmsg",
myMsgFac ().myFrag (theObjTypeFragID),
theDelComp->objTypeMsgFrag ());
d1107 2
a1108 2
return theDelComp;
}
d1113 2
a1114 2
{
startNonMsgSevereError ();
d1116 5
a1120 5
fprintf (stderr,
"Memory allocation error.\n"
"There is not enough memory available for WIT to create a new WitRun.\n"
"\n"
"   Function           : witNewRun\n");
d1122 2
a1123 2
finishNonMsgSevereError ();
}
d1128 4
a1131 4
{
myApiMgr_->allowPreInit      ();
myApiMgr_->allowExtOptActive ();
myApiMgr_->startInnerFunc    ();
d1133 1
a1133 1
forbidNullArg (origWitRun, "origWitRun");
d1135 1
a1135 1
myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);
d1138 2
a1139 2
if (not mySession_->active ())
myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "dupWitRun");
d1141 2
a1142 2
if (not origWitRun->mySession_->active ())
myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "origWitRun");
d1145 2
a1146 2
if (myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "dupWitRun");
d1148 2
a1149 2
if (origWitRun->myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "origWitRun");
d1152 2
a1153 2
if (myStochImpMgr ()->stochMode ())
myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "dupWitRun");
d1155 2
a1156 2
if (origWitRun->myStochImpMgr ()->stochMode ())
myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "origWitRun");
d1159 2
a1160 2
if (myOptComp ()->multiObjMode ())
myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "dupWitRun");
d1162 2
a1163 2
if (origWitRun->myOptComp ()->multiObjMode ())
myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "origWitRun");
d1166 1
a1166 1
checkGlobAttsForCopy (origWitRun);
d1168 5
a1172 5
if (this == origWitRun)
myMsgFac () ("sameWitRunMsg");
else
myMsgFac () ("distinctWitRunsMsg");
}
d1177 33
a1209 33
{
WitGlobalComp *  dupGlobal;
WitGlobalComp * origGlobal;

dupGlobal =             myGlobalComp ();
origGlobal = origWitRun->myGlobalComp ();

if (dupGlobal->nPeriods () != origGlobal->nPeriods ())
{
myMsgFac () ("copyObjDiffNPeriodsSmsg",
apiFuncName (),
dupGlobal->nPeriods (),
origGlobal->nPeriods ());
}

if (dupGlobal->wit34Compatible () != origGlobal->wit34Compatible ())
{
myMsgFac () ("copyObjDiffBoolAttSmsg",
apiFuncName (),
"wit34Compatible",
dupGlobal->wit34Compatible (),
origGlobal->wit34Compatible ());
}

if (dupGlobal->independentOffsets () != origGlobal->independentOffsets ())
{
myMsgFac () ("copyObjDiffBoolAttSmsg",
apiFuncName (),
"independentOffsets",
dupGlobal->independentOffsets (),
origGlobal->independentOffsets ());
}
}
d1214 20
a1233 20
const char * the34Object,
const char * the34Attribute,
const char * the40Object,
const char * the40Attribute)
{
if (wit34Compatible ())
myMsgFac () ("setting34AttributeWithCompatibilityMode",
apiFuncName (),
the34Object,
the34Attribute,
the40Object,
the40Attribute);
else
myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
apiFuncName (),
the34Object,
the34Attribute,
the40Object,
the40Attribute);
}
d1238 20
a1257 20
const char * the34Object,
const char * the34Attribute,
const char * the40Object,
const char * the40Attribute)
{
if (wit34Compatible ())
myMsgFac () ("getting34AttributeWithCompatibilityMode",
apiFuncName (),
the34Object,
the34Attribute,
the40Object,
the40Attribute);
else
myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
apiFuncName (),
the34Object,
the34Attribute,
the40Object,
the40Attribute);
}
d1262 14
a1275 14
{
if (myMsgFac ().mayIssue ("periodMsg"))
myMsgFac () ("periodMsg", thePer);

if (not ((thePer >= 0) and (thePer < nPeriods ())))
{
myInputID ()->setArgName ("thePer");

myMsgFac () ("argRangeIntLeValLtIntSmsg", thePer, 0, nPeriods ());
}

if (not myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
}
d1280 4
a1283 4
{
if (myStochImpMgr ()->stochMode ())
myMsgFac () ("addStochModeSmsg", myMsgFac ().myFrag (theObjTypeFragID));
}
d1288 4
a1291 4
{
if (myStochImpMgr ()->stochMode ())
myMsgFac () ("funcInStochModeSmsg", apiFuncName ());
}
d1296 3
a1298 3
{
return myApiMgr ()->apiFuncName ();
}
d1306 7
a1312 7
void WitNonClass::apiAlloc (Elem * * theCVecPtr, int nElems)
{
WitRun::apiVoidAlloc (
reinterpret_cast <void * *> (theCVecPtr),
nElems,
sizeof (Elem));
}
d1327 3
a1329 3
{
theOVRealArg.apiAlloc (nElems);
}
@


1.247
log
@CPLEX
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d63 2
a64 2
   {
   delete myApiMgr_;
d66 2
a67 2
   signature_ = 0;
   }
d75 3
a77 3
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d79 2
a80 2
   myCompMgr ()->myDelCompItr ()->advance ();
   }
d85 2
a86 2
   {
   myApiMgr_->startInnerFunc ();
d88 2
a89 2
   myProblem ()->myPipMgr ()->buildPegging ();
   }
d94 2
a95 2
   {
   myApiMgr_->startInnerFunc ();
d97 5
a101 5
   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");
      
   myProblem ()->myHeurAllMgr ()->clearPegging ();
   }
d106 4
a109 4
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d111 3
a113 3
   if (mySession_->active ())
      if (myDetOptImpMgr ()->extOptActive ())
         myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "dupWitRun");
d115 1
a115 1
   forbidNullArg (origWitRun, "origWitRun");
d117 1
a117 1
   myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);
d119 2
a120 2
   if (not origWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg", "witCopyData", "origWitRun");
d122 2
a123 2
   if (origWitRun->myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "origWitRun");
d125 2
a126 2
   mySession ()->copyData (origWitRun->mySession_);
   }
d133 5
a137 5
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d139 2
a140 2
   mySession_->deactivate ();
   }
d147 3
a149 3
   {
   myApiMgr_->allowPreInit   ();
   myApiMgr_->startInnerFunc ();
d151 2
a152 2
   apiGet (devMode, "devMode", DEVELOPMENT);
   }
d160 2
a161 2
   {
   myApiMgr_->startInnerFunc ();
d163 2
a164 2
   myProblem ()->displayData (filename);
   }
d172 2
a173 2
   {
   myApiMgr_->startInnerFunc ();
d175 1
a175 1
   forbidStochMode ();
d177 2
a178 2
   myDetOptImpMgr ()->evalObjectives ();
   }
d186 3
a188 3
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d190 2
a191 2
   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d193 2
a194 2
   if (not myDetOptImpMgr ()->myExtOptMgr ()->solnProvided ())
      myMsgFac () ("finishExtOptWoSolnSmsg");
d196 2
a197 2
   myDetOptImpMgr ()->finishExtOpt ();
   }
d205 2
a206 2
   {
   myApiMgr_->startInnerFunc ();
d208 2
a209 2
   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");
d211 2
a212 2
   myProblem ()->myHeurAllMgr ()->finish ();
   }
d220 2
a221 2
   {
   myApiMgr_->startInnerFunc ();
d223 1
a223 1
   forbidStochMode ();
d225 2
a226 2
   WitDemand::genPriorities (myProblem ());
   }
d231 40
a270 40
      int *      lenLists,
      char * * * partNameList,
      char * * * operationNameList)
   {
   WitObjStack <WitPart>      theParts (myProblem ());
   WitObjStack <WitOperation> theOpns  (myProblem ());
   int                        theIdx;
   WitPart *                  thePart;
   WitOperation *             theOpn;
   
   myApiMgr_->startInnerFunc ();

   myProblem ()->myPreprocessor ()->getExpCycle (theParts, theOpns);

   apiGet (lenLists, "lenLists", theOpns.nElements ());

   forbidNullArg (partNameList,      "partNameList");
   forbidNullArg (operationNameList, "operationNameList");

   apiAlloc (partNameList,      theParts.nElements ());
   apiAlloc (operationNameList, theOpns .nElements ());

   theIdx = -1;

   while (theParts.pop (thePart))
      {
      theIdx ++;

      (* partNameList)[theIdx] = thePart->partName ().apiDupCstring ();
      }

   theIdx = -1;

   while (theOpns.pop (theOpn))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();
      }
   }
d275 2
a276 2
   {
   WitVector <int> indicesLoc;
d278 1
a278 1
   myApiMgr_->startInnerFunc ();
d280 2
a281 2
   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d283 3
a285 3
   myDetOptImpMgr ()->
      myExtOptMgr ()->
         getIntVarIndices (indicesLoc);
d287 3
a289 3
   apiGet (indices, "indices", indicesLoc);
   apiGet (len,     "len",     indicesLoc.length ());
   }
d294 48
a341 48
      int *                numcols,
      int *                numrows,
      int * *              start,
      int * *              index,
      const WitOVRealArg & value,
      const WitOVRealArg & collb,
      const WitOVRealArg & colub,
      const WitOVRealArg & obj,
      const WitOVRealArg & rowlb,
      const WitOVRealArg & rowub)
   {
   WitVector <int>    startLoc;
   WitVector <int>    indexLoc;
   WitVector <double> valueLoc;
   WitVector <double> collbLoc;
   WitVector <double> colubLoc;
   WitVector <double> objLoc;
   WitVector <double> rowlbLoc;
   WitVector <double> rowubLoc;

   myApiMgr_->startInnerFunc ();

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());

   myDetOptImpMgr ()->
      myExtOptMgr ()->
         getLpProb (
            startLoc,
            indexLoc,
            valueLoc,
            collbLoc,
            colubLoc,
            objLoc,
            rowlbLoc,
            rowubLoc);

   apiGet (numcols, "numcols", collbLoc.length ());
   apiGet (numrows, "numrows", rowlbLoc.length ());
   apiGet (start,   "start",   startLoc);
   apiGet (index,   "index",   indexLoc);
   apiGet (value,   "value",   valueLoc);
   apiGet (collb,   "collb",   collbLoc);
   apiGet (colub,   "colub",   colubLoc);
   apiGet (obj,     "obj",     objLoc);
   apiGet (rowlb,   "rowlb",   rowlbLoc);
   apiGet (rowub,   "rowub",   rowubLoc);
   }
d350 2
a351 2
   {
   myApiMgr_->startInnerFunc ();
d353 5
a357 5
   apiGet (
      objItrState, 
      "objItrState", 
      myCompMgr ()->myDelCompItr ()->apiObjItrState ());
   }
d364 2
a365 2
   {
   myApiMgr_->startInnerFunc ();
d367 1
a367 1
   forbidStochMode ();
d369 2
a370 2
   myProblem ()->myHeurImploder ()->implode ();
   }
d379 4
a382 4
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d384 2
a385 2
   mySession ()->activate ();
   }
d395 2
a396 2
   {
   myApiMgr_->startInnerFunc ();
d398 2
a399 2
   stronglyAssert (false);
   }
d406 2
a407 2
   {
   myApiMgr_->startInnerFunc ();
d409 1
a409 1
   forbidStochMode ();
d411 2
a412 2
   myProblem ()->myOrigMrpExp ()->mrp ();
   }
d422 6
a427 6
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
   }
d435 2
a436 2
   {
   myApiMgr_->startInnerFunc ();
d438 1
a438 1
   forbidStochMode ();
d440 2
a441 2
   myDetOptImpMgr ()->implode ();
   }
d450 2
a451 2
   {
   myApiMgr_->startInnerFunc ();
d453 2
a454 2
   myProblem ()->myPreprocessor ()->preprocess ();
   }
d462 2
a463 2
   {
   myApiMgr_->startInnerFunc ();
d465 2
a466 2
   myProblem ()->myPostprocessor ()->postprocess ();
   }
d474 2
a475 2
   {
   myApiMgr_->startInnerFunc ();
d477 2
a478 2
   myProblem ()->myPreprocessor ()->preprocess ();
   }
d483 2
a484 2
   {
   myApiMgr_->startInnerFunc ();
d486 1
a486 1
   forbidStochMode ();
d488 2
a489 2
   myCompMgr ()->purgeData ();
   }
d497 2
a498 2
   {
   myApiMgr_->startInnerFunc ();
d500 1
a500 1
   forbidNullArg (fileName, "fileName");
d502 2
a503 2
   myProblem ()->myDataReader ()->readData (fileName);
   }
d511 3
a513 3
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d515 2
a516 2
   myCompMgr ()->myDelCompItr ()->reset ();
   }
d524 3
a526 3
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d528 2
a529 2
   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d531 2
a532 2
   myDetOptImpMgr ()->myExtOptMgr ()->setSoln (colsol);
   }
d540 3
a542 3
   {
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d544 2
a545 2
   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d547 2
a548 2
   myDetOptImpMgr ()->shutDownExtOpt ();
   }
d556 2
a557 2
   {
   myApiMgr_->startInnerFunc ();
d559 2
a560 2
   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");
d562 2
a563 2
   myProblem ()->myHeurAllMgr ()->reset ();
   }
d571 2
a572 2
   {
   myApiMgr_->startInnerFunc ();
d574 2
a575 2
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "computeCriticalList");
d577 2
a578 2
   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "compPrices");
d580 2
a581 2
   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForStartExtSmsg", "accAfterOptImp");
d583 2
a584 2
   if (myOptComp ()->multiObjMode ())
      myMsgFac () ("startExtOptMultiObjSmsg");
d586 1
a586 1
   forbidStochMode ();
d588 2
a589 2
   myDetOptImpMgr ()->startExtOpt ();
   }
d597 2
a598 2
   {
   myApiMgr_->startInnerFunc ();
d600 1
a600 1
   forbidStochMode ();
d602 2
a603 2
   myProblem ()->myHeurAllMgr ()->start ();
   }
d610 13
a622 13
   const char *  filename,
   WitFileFormat fileFormat,
   int           maxListLength)
   {
   myApiMgr_->startInnerFunc ();

   myProblem ()->
      mySolnWriter ()->
         writeCriticalList (
            filename,
            fileFormat,
            maxListLength);
   }
d630 2
a631 2
   {
   myApiMgr_->startInnerFunc ();
d633 2
a634 2
   myProblem ()->myDataWriter ()->writeData (filename);
   }
d641 4
a644 4
      const char *  filename,
      WitFileFormat fileFormat)
   {
   myApiMgr_->startInnerFunc ();
d646 2
a647 2
   myProblem ()->mySolnWriter ()->writeExecSched (filename, fileFormat);
   }
d654 15
a668 15
   const char * filename,
   WitFileFormat fileFormat )
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("witWriteProdSchedWithCompatibility");

      witWriteExecSched (filename, fileFormat);
      }

   else
      myMsgFac () ("witWriteProdSchedWithoutCompatibility");
   }
d675 4
a678 4
      const char * filename,
      WitFileFormat fileFormat)
   {
   myApiMgr_->startInnerFunc ();
d680 2
a681 2
   myProblem ()->mySolnWriter ()->writeReqSched (filename, fileFormat);
   }
d688 4
a691 4
   const char * filename,
   WitFileFormat fileFormat )
   {
   myApiMgr_->startInnerFunc ();
d693 2
a694 2
   myProblem ()->mySolnWriter ()->writeShipSched (filename, fileFormat);
   }
d699 11
a709 11
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();

   apiGet (
      isOne,
      "isOne",
      (nDepVeneers_ == 1)? 1: 0);
   }
d714 5
a718 5
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d720 2
a721 2
   -- nDepVeneers_;
   }
d726 5
a730 5
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d732 2
a733 2
   ++ nDepVeneers_;
   }
d738 3
a740 3
   {
   int    totDiscarded;
   char * theMem;
d742 1
a742 1
   myApiMgr_->startInnerFunc ();
d744 3
a746 3
   for (totDiscarded = 100; alwaysTrue (); totDiscarded += 100)
      {
      theMem = NULL;
d748 1
a748 1
      theMem = new char[104857600];
d750 2
a751 2
      if (theMem == NULL)
         myMsgFac () ("newRetNullFmsg");
d753 3
a755 3
      myMsgFac () ("discardMemoryMsg", totDiscarded);
      }
   }
d760 5
a764 5
   {
   myApiMgr_->skipCallMsg       ();
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d766 2
a767 2
   if (WitSaeMgr::standAloneMode ())
      myMsgFac () ("overlapStandAloneSmsg");
d769 2
a770 2
   if (mySession_->active ())
      forbidStochMode ();
d772 2
a773 2
   WitSaeMgr::execute (this, argc, argv);
   }
d778 2
a779 2
   {
   WitString theDevCmdString;
d781 1
a781 1
   myApiMgr_->startInnerFunc ();
d783 2
a784 2
   if (not DEVELOPMENT)
      myMsgFac () ("intDevCmdWoDevModeSmsg");
d786 1
a786 1
   theDevCmdString = theDevCmd;
d788 1
a788 1
   myMsgFac () ("intDevCmdMsg", theDevCmdString);
d790 2
a791 2
   if (theDevCmdString      == "Throw an exception of unknown type.")
      throw bool ();
d793 4
a796 4
   else if (theDevCmdString == "Print availability schedule.")
      myProblem ()->
         myHeurAllMgr ()->
            printAvailSched ();
d798 3
a800 3
   else
      myMsgFac () ("invalidDevCmdSmsg");
   }
d805 3
a807 3
   {
   return myApiMgr ()->myInputID ();
   }
d812 2
a813 2
   {
   WitRun * theWitRun;
d815 1
a815 1
   void (* appNewHandler) ();
d817 9
a825 9
   try
      {
      theWitRun = new WitRun;
      }

   catch (std::bad_alloc)
      {
      handleBadAllocForCtor ();
      }
d827 2
a828 2
   return theWitRun;
   }
d833 29
a861 29
   {
   if (theWitRun == NULL)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "   A WIT function was called with a NULL pointer for the WitRun "
            "argument.\n"
         "\n"
         "      Function: %s\n",
         theFuncName);

      finishNonMsgSevereError ();
      }

   if (theWitRun->signature_ != VALID_SIGNATURE)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "   A WIT function was called with an invalid (possibly deleted) "
            "WitRun argument.\n"
         "\n"
         "      Function: %s\n",
         theFuncName);

      finishNonMsgSevereError ();
      }
   }
d866 2
a867 2
   {
   witAssert (argName != NULL);
d869 7
a875 7
   if (theArg == NULL)
      {
      myInputID ()->setArgName (argName);

      myMsgFac () ("nullPointerSmsg");
      }
   }
d880 2
a881 2
   {
   * theCVecPtr = NULL;
d883 2
a884 2
   if (nElems == 0)
      return;
d886 1
a886 1
   * theCVecPtr = calloc (nElems, elSize);
d888 3
a890 3
   if (* theCVecPtr == NULL)
      WitMsgFacility::issueByException ("callocSmsg", nElems * elSize);
   }
d895 5
a899 5
      int *        theVarPtr,
      const char * argName,
      int          theValue)
   {
   forbidNullArg (theVarPtr, argName);
d901 2
a902 2
   * theVarPtr = theValue;
   }
d907 5
a911 5
      WitBoolean * theVarPtr,
      const char * argName,
      bool         theValue)
   {
   forbidNullArg (theVarPtr, argName);
d913 2
a914 2
   * theVarPtr = theValue;
   }
d919 5
a923 5
      const WitOSRealArg & theArg,
      const char *         argName,
      double               theValue)
   {
   forbidNullArg (theArg, argName);
d925 2
a926 2
   theArg = theValue;
   }
d931 5
a935 5
      WitAttr *    theVarPtr,
      const char * argName,
      WitAttr      theValue)
   {
   forbidNullArg (theVarPtr, argName);
d937 2
a938 2
   * theVarPtr = theValue;
   }
d943 5
a947 5
      FILE * *     theVarPtr,
      const char * argName,
      FILE *       theValue)
   {
   forbidNullArg (theVarPtr, argName);
d949 2
a950 2
   * theVarPtr = theValue;
   }
d955 5
a959 5
      void * *     theVarPtr,
      const char * argName,
      void *       theValue)
   {
   forbidNullArg (theVarPtr, argName);
d961 2
a962 2
   * theVarPtr = theValue;
   }
d967 5
a971 5
      char * *          theVarPtr,
      const char *      argName,
      const WitString & theValue)
   {
   forbidNullArg (theVarPtr, argName);
d973 2
a974 2
   * theVarPtr = theValue.apiDupCstring ();
   }
d979 5
a983 5
      const WitOVRealArg &       theArg,
      const char *               argName,
      const WitVector <double> & theValue)
   {
   forbidNullArg (theArg, argName);
d985 1
a985 1
   apiAlloc (theArg, theValue.length ());
d987 2
a988 2
   theArg = theValue;
   }
d993 5
a997 5
      int * *                 theVarPtr,
      const char *            argName,
      const WitVector <int> & theValue)
   {
   forbidNullArg (theVarPtr, argName);
d999 1
a999 1
   apiAlloc (theVarPtr, theValue.length ());
d1001 2
a1002 2
   theValue.copyInto (* theVarPtr);
   }
d1007 13
a1019 13
      WitBoolean * *           theVarPtr,
      const char *             argName,
      const WitVector <bool> & theValue)
   {
   WitPeriod thePer;

   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, theValue.length ());

   forEachPeriod (thePer, this)
      (* theVarPtr)[thePer] = theValue[thePer];
   }
d1024 5
a1028 5
      const WitOVRealArg &  theArg,
      const char *          argName,
      const WitDblFlexVec & theValue)
   {
   forbidNullArg (theArg, argName);
d1030 1
a1030 1
   apiAlloc (theArg, nPeriods ());
d1032 2
a1033 2
   theArg = theValue;
   }
d1038 5
a1042 5
      WitBoolean * *            theVarPtr,
      const char *              argName,
      const WitFlexVec <bool> & theValue)
   {
   forbidNullArg (theVarPtr, argName);
d1044 1
a1044 1
   apiAlloc (theVarPtr, nPeriods ());
d1046 2
a1047 2
   copy (* theVarPtr, theValue);
   }
d1052 5
a1056 5
      int * *                  theVarPtr,
      const char *             argName,
      const WitFlexVec <int> & theValue)
   {
   forbidNullArg (theVarPtr, argName);
d1058 1
a1058 1
   apiAlloc (theVarPtr, nPeriods ());
d1060 2
a1061 2
   theValue.copyInto (* theVarPtr);
   }
d1066 9
a1074 9
      const WitOVRealArg & hardLBVec,
      const WitOVRealArg & softLBVec,
      const WitOVRealArg & hardUBVec,
      WitBoundSet *        theValue)
   {
   apiGet (hardLBVec, "hardLB", theValue->hardLB ());
   apiGet (softLBVec, "softLB", theValue->softLB ());
   apiGet (hardUBVec, "hardUB", theValue->hardUB ());
   }
d1079 6
a1084 6
      signature_   (VALID_SIGNATURE),
      myApiMgr_    (NULL),
      mySession_   (NULL),
      nDepVeneers_ (0)
   {
   myApiMgr_  = new WitApiMgr (this);
d1086 2
a1087 2
   mySession_ = myApiMgr ()->mySession ();
   }
d1092 14
a1105 14
      WitAttr      objItrStateVal,
      WitMsgFragID theObjTypeFragID)
   {
   WitDelComp * theDelComp;

   if (not myCompMgr ()->myDelCompItr ()->active ())
      myMsgFac () ("getObjWhileItrInactiveSmsg");

   theDelComp = myCompMgr ()->myDelCompItr ()->curDelComp ();

   if (objItrStateVal != theDelComp->apiObjItrState ())
      myMsgFac () ("getObjObjTypeMismatchSmsg",
         myMsgFac ().myFrag (theObjTypeFragID),
         theDelComp->objTypeMsgFrag ());
d1107 2
a1108 2
   return theDelComp;
   }
d1113 2
a1114 2
   {
   startNonMsgSevereError ();
d1116 5
a1120 5
   fprintf (stderr,
      "Memory allocation error.\n"
      "There is not enough memory available for WIT to create a new WitRun.\n"
      "\n"
      "   Function           : witNewRun\n");
d1122 2
a1123 2
   finishNonMsgSevereError ();
   }
d1128 4
a1131 4
   {
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d1133 1
a1133 1
   forbidNullArg (origWitRun, "origWitRun");
d1135 1
a1135 1
   myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);
d1138 2
a1139 2
   if (not mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "dupWitRun");
d1141 2
a1142 2
   if (not origWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "origWitRun");
d1145 2
a1146 2
   if (myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "dupWitRun");
d1148 2
a1149 2
   if (origWitRun->myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "origWitRun");
d1152 2
a1153 2
   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "dupWitRun");
d1155 2
a1156 2
   if (origWitRun->myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "origWitRun");
d1159 2
a1160 2
   if (myOptComp ()->multiObjMode ())
      myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "dupWitRun");
d1162 2
a1163 2
   if (origWitRun->myOptComp ()->multiObjMode ())
      myMsgFac () ("funcInMultiObjModeWR2Smsg", apiFuncName (), "origWitRun");
d1166 1
a1166 1
   checkGlobAttsForCopy (origWitRun);
d1168 5
a1172 5
   if (this == origWitRun)
      myMsgFac () ("sameWitRunMsg");
   else
      myMsgFac () ("distinctWitRunsMsg");
   }
d1177 33
a1209 33
   {
   WitGlobalComp *  dupGlobal;
   WitGlobalComp * origGlobal;

    dupGlobal =             myGlobalComp ();
   origGlobal = origWitRun->myGlobalComp ();

   if (dupGlobal->nPeriods () != origGlobal->nPeriods ())
      {
      myMsgFac () ("copyObjDiffNPeriodsSmsg",
         apiFuncName (),
          dupGlobal->nPeriods (),
         origGlobal->nPeriods ());
      }
 
   if (dupGlobal->wit34Compatible () != origGlobal->wit34Compatible ())
      {
      myMsgFac () ("copyObjDiffBoolAttSmsg",
         apiFuncName (),
                    "wit34Compatible",
          dupGlobal->wit34Compatible (),
         origGlobal->wit34Compatible ());
      }

   if (dupGlobal->independentOffsets () != origGlobal->independentOffsets ())
      {
      myMsgFac () ("copyObjDiffBoolAttSmsg",
         apiFuncName (),
                    "independentOffsets",
          dupGlobal->independentOffsets (),
         origGlobal->independentOffsets ());
      }
   }
d1214 20
a1233 20
      const char * the34Object,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute)
   {
   if (wit34Compatible ())
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   }
d1238 20
a1257 20
      const char * the34Object,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute)
   {
   if (wit34Compatible ())
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
   }
d1262 14
a1275 14
   {
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", thePer);

   if (not ((thePer >= 0) and (thePer < nPeriods ())))
      {
      myInputID ()->setArgName ("thePer");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", thePer, 0, nPeriods ());
      }

   if (not myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
   }
d1280 4
a1283 4
   {
   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("addStochModeSmsg", myMsgFac ().myFrag (theObjTypeFragID));
   }
d1288 4
a1291 4
   {
   if (myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeSmsg", apiFuncName ());
   }
d1296 3
a1298 3
   {
   return myApiMgr ()->apiFuncName ();
   }
d1306 7
a1312 7
      void WitNonClass::apiAlloc (Elem * * theCVecPtr, int nElems)
   {
   WitRun::apiVoidAlloc (
      reinterpret_cast <void * *> (theCVecPtr),
      nElems,
      sizeof (Elem));
   }
d1327 3
a1329 3
   {
   theOVRealArg.apiAlloc (nElems);
   }
@


1.246
log
@CPLEX
@
text
@a792 5
   if (theDevCmdString      == "Allow accelerated CPLEX.")
      myProblem ()->
         myOptComp ()->
            setAccCplexAllowed (true);

@


1.245
log
@CPLEX
@
text
@d790 1
a790 1
   if (theDevCmdString == "Throw an exception of unknown type.")
d793 5
@


1.244
log
@CPLEX
@
text
@a437 3
   if (not solverEmbedded ())
      myMsgFac () ("invalidWoSolverSmsg", "witOptImplode");

@


1.243
log
@Modifiable Heuristic Allocation
@
text
@a795 4
   else if (theDevCmdString == "Allow CPLEX.")
      myOptComp ()->
         setCplexAllowed (true);

@


1.242
log
@Modifiable heuristic allocation
@
text
@a804 4
   else if (theDevCmdString == "Allow modifiable heuristic.")
      myGlobalComp ()->
         setModHeurAllowed (true);

@


1.241
log
@Heuristic Adjustment
@
text
@d35 1
a35 1
#include <HeurAdjuster.h>
d805 1
a805 1
   else if (theDevCmdString == "Allow heuristic adjustment.")
d807 1
a807 1
         setHeurAdjustAllowed (true);
@


1.240
log
@Heuristic Adjustment
@
text
@a199 25
// witFinishHeurAdjust
// API function to conclude heuristic adjustment.
//------------------------------------------------------------------------------

void WitRun::witFinishHeurAdjust ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->heurAdjustAllowed ())
      {
      myMsgFac () ("funcNYASmsg", "witFinishHeurAdjust");
      }

   if (not myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
      {
      myMsgFac () ("globBoolAttReqSmsg",
         "heurAdjustActive",
         true,
         "witFinishHeurAdjust");
      }

   myProblem ()->myHeurAdjuster ()->finish ();
   }

//------------------------------------------------------------------------------
a594 41
// witStartHeurAdjust
// API function to initiate heuristic adjustment.
//------------------------------------------------------------------------------

void WitRun::witStartHeurAdjust ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->heurAdjustAllowed ())
      {
      myMsgFac () ("funcNYASmsg", "witStartHeurAdjust");
      }

   if (myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
      {
      myMsgFac () ("globBoolAttReqSmsg",
         "heurAdjustActive",
         false,
         "witStartHeurAdjust");
      }

   if (not myGlobalComp ()->heurAdjustEnabled ())
      {
      myMsgFac () ("globBoolAttReqSmsg",
         "heurAdjustEnabled",
         true,
         "witStartHeurAdjust");
      }

   if (not myProblem ()->myHeurAllMgr ()->active ())
      {
      myMsgFac () ("globBoolAttReqSmsg",
         "heurAllocActive",
         true,
         "witStartHeurAdjust");
      }

   myProblem ()->myHeurAdjuster ()->start ();
   }

//------------------------------------------------------------------------------
@


1.239
log
@Heuristic Adjustment
@
text
@d208 1
a208 1
   if (not myProblem ()->myHeurAdjuster ()->heurAdjustAllowed ())
d213 1
a213 1
   if (not myProblem ()->myHeurAdjuster ()->active ())
d628 1
a628 1
   if (not myProblem ()->myHeurAdjuster ()->heurAdjustAllowed ())
d633 24
d872 2
a873 3
      myProblem ()->
         myHeurAdjuster ()->
            setHeurAdjustAllowed (true);
@


1.238
log
@Heuristic Adjustment
@
text
@d35 1
a35 1
#include <HeurAdjMgr.h>
d208 1
a208 1
   if (not myProblem ()->myHeurAdjMgr ()->heurAdjustAllowed ())
d213 1
a213 1
   if (not myProblem ()->myHeurAdjMgr ()->active ())
d221 1
a221 1
   myProblem ()->myHeurAdjMgr ()->finish ();
d628 1
a628 1
   if (not myProblem ()->myHeurAdjMgr ()->heurAdjustAllowed ())
d633 1
a633 1
   myProblem ()->myHeurAdjMgr ()->start ();
d849 1
a849 1
         myHeurAdjMgr ()->
@


1.237
log
@Heuristic Adjustment
@
text
@d842 5
@


1.236
log
@Heuristic Adjustment
@
text
@d42 1
a42 1
#include <Opn.h>
@


1.235
log
@Pause/Resume
@
text
@d35 1
a35 1
#include <HeurPauseMgr.h>
d200 25
a484 14

void WitRun::witPauseHeurAlloc ()
   {
   myApiMgr_->startInnerFunc ();

   if (not myProblem ()->myHeurPauseMgr ()->pauseResumeAllowed ())
      {
      myMsgFac () ("funcNYASmsg", "witPauseHeurAlloc");
      }

   myProblem ()->myHeurPauseMgr ()->pause ();
   }

//------------------------------------------------------------------------------
d620 17
d842 1
a842 1
   else if (theDevCmdString == "Allow pause/resume.")
d844 2
a845 2
         myHeurPauseMgr ()->
            setPauseResumeAllowed (true);
@


1.234
log
@Pause/Resume
@
text
@d460 14
@


1.233
log
@CPLEX
@
text
@d35 1
d797 2
a798 1
      myOptComp ()->setCplexAllowed (true);
d801 3
a803 1
      myGlobalComp ()->setPauseResumeAllowed (true);
@


1.232
log
@Pause/Resume
@
text
@d795 1
a795 1
   else if (theDevCmdString == "Allow CPLEX")
@


1.231
log
@Pause / Resume
@
text
@d798 2
a799 2
   else if (theDevCmdString == "Allow pause heur-alloc.")
      myGlobalComp ()->setPauseHeurAllowed (true);
@


1.230
log
@CPLEX
@
text
@d798 3
@


1.229
log
@CPLEX
@
text
@d437 1
a437 1
   if (not WitOptComp::solverEmbedded ())
@


1.228
log
@CPLEX
@
text
@a439 4
   if (not WitOptComp::coinEmbedded ())
      if (WitOptComp::cplexEmbedded ())
         myMsgFac () ("optWCplexWoCoinSmsg");

@


1.227
log
@Preparing for embedded CPLEX.
@
text
@d440 4
d799 3
@


1.226
log
@Revising the build procedure.
@
text
@d437 1
a437 1
   if (not SOLVER_EMBEDDED)
@


1.225
log
@Revising the build procedure.
@
text
@d437 2
a438 2
   if (not COIN_EMBEDDED)
      myMsgFac () ("invalidWoCoinSmsg", "witOptImplode");
@


1.224
log
@Revising the build procedure.
@
text
@d437 1
a437 1
   if (not WIT_EMBEDS_COIN)
@


1.223
log
@Revising the build process.
@
text
@d438 1
a438 1
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witOptImplode");
@


1.222
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d437 1
a437 1
   if (not WitOptComp::optImpAllowed ())
@


1.221
log
@Multi-Obj Mode
@
text
@d25 1
a25 1
#include <Global.h>
@


1.220
log
@Multi-objective mode
@
text
@d1130 5
d1138 4
d1145 4
d1152 2
a1153 1
   forbidNullArg (origWitRun, "origWitRun");
a1154 1
   myApiMgr_->start2WitRunFunc (origWitRun->myApiMgr_);
d1156 2
a1157 2
   if (not origWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "origWitRun");
d1159 2
a1160 2
   if (origWitRun->myDetOptImpMgr ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "origWitRun");
a1161 2
   if (origWitRun->myStochImpMgr ()->stochMode ())
      myMsgFac () ("funcInStochModeWR2Smsg", apiFuncName (), "origWitRun");
@


1.219
log
@Multi-Objective Mode.
@
text
@a794 4
   if (theDevCmdString == "Allow multiObjMode.")
      myProblem ()->
         myOptComp ()->setAllowMultiObj (true);

@


1.218
log
@Multi-Objective Mode.
@
text
@d795 4
@


1.217
log
@Removing objective #2.
@
text
@d585 3
@


1.216
log
@Removing objective #2.
@
text
@a797 7
WitObjFunc * WitRun::objChoice () const
   {
   return myOptComp ()->objChoice ();
   }

//------------------------------------------------------------------------------

@


1.215
log
@Removed multiThread.
@
text
@d40 1
d224 1
a224 1
   myProblem ()->genPriorities ();
@


1.214
log
@Minor revision.
@
text
@a341 11
// witGetMultiThread ()
//------------------------------------------------------------------------------

void WitRun::witGetMultiThread (WitBoolean * multiThread)
   {
   myApiMgr_->startInnerFunc ();

   apiGet (multiThread, "multiThread", WitApiMgr::multiThread ());
   }

//------------------------------------------------------------------------------
a535 21
// witSetMultiThread
// Sets the value of the multiThread attribute.
//------------------------------------------------------------------------------

void WitRun::witSetMultiThread (WitBoolean multiThread)
   {
   myApiMgr_->startInnerFunc ();

   if (not multiThread)
      myMsgFac () ("setMultiThreadFalseSmsg");

   if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
      myMsgFac () ("setBooleanAttrMsg",
         "multiThread",
         WitApiMgr::multiThread (),
         WitTRUE);

   WitApiMgr::setMultiThread ();
   }

//------------------------------------------------------------------------------
@


1.213
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@d797 1
a797 1
      myMsgFac () ("overlappingStandAloneSmsg");
@


1.212
log
@Implemented witIssueFatalMesg.
@
text
@d796 2
a797 2
   if (WitApiMgr::multiThread ())
      myMsgFac () ("notAllowedWMultiThreadSmsg", "witExecStandAlone");
@


1.211
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d397 14
@


1.210
log
@Stochastic Implosion
@
text
@d48 2
@


1.209
log
@Stochastic Implosion
@
text
@a806 3
   if (theDevCmdString == "Allow stage-by-period.")
      myStochImpMgr ()->setAllowStageByPer (true);

@


1.208
log
@Stochastic Implosion
@
text
@d807 3
a912 13
WitRun::WitRun ():
      signature_   (VALID_SIGNATURE),
      myApiMgr_    (NULL),
      mySession_   (NULL),
      nDepVeneers_ (0)
   {
   myApiMgr_  = new WitApiMgr (this);

   mySession_ = myApiMgr ()->mySession ();
   }

//------------------------------------------------------------------------------

d1097 13
@


1.207
log
@Stochastic Implosion
@
text
@a83 2
   forbidStochMode ();

@


1.206
log
@Stochastic Implosion
@
text
@d1100 1
a1100 1
      const WitBoundSet *  theValue)
@


1.205
log
@witGetExpCycle
@
text
@d84 2
d221 2
d404 2
@


1.204
log
@Stochastic Implosion
@
text
@d39 2
d224 44
@


1.203
log
@Stochastic Implosion
@
text
@d878 1
a878 1
   prepApiGet (theVarPtr, argName);
d890 1
a890 1
   prepApiGet (theVarPtr, argName);
d902 1
a902 1
   prepApiGet (theArg, argName);
d914 1
a914 1
   prepApiGet (theVarPtr, argName);
d926 1
a926 1
   prepApiGet (theVarPtr, argName);
d938 1
a938 1
   prepApiGet (theVarPtr, argName);
d950 1
a950 1
   prepApiGet (theVarPtr, argName);
d962 1
a962 1
   prepApiGet (theArg, argName);
d976 1
a976 1
   prepApiGet (theVarPtr, argName);
d992 1
a992 1
   prepApiGet (theVarPtr, argName);
d1007 1
a1007 1
   prepApiGet (theArg, argName);
d1021 1
a1021 1
   prepApiGet (theVarPtr, argName);
d1035 1
a1035 1
   prepApiGet (theVarPtr, argName);
a1056 15
void WitRun::prepApiGet (
      void *       theVarPtr,
      const char * argName)
   {
   forbidNullArg (theVarPtr, argName);

   if (mySession_->active ())
      if (myStochImpMgr ()->stochMode ())
         if (myStochImpMgr ()->isaScenSpecAtt (argName))
            myMsgFac () ("scenSpecificMsg",
               myStochImpMgr ()->curScenarioNo ());
   }

//------------------------------------------------------------------------------

@


1.202
log
@Stochastic Implosion
@
text
@a756 3
   else if (theDevCmdString == "Allow stochastic implosion.")
      myStochImpMgr ()->setStochImpAllowed (true);

@


1.201
log
@Stochastic Implosion
@
text
@d1068 1
a1068 1
         if (myStochImpMgr ()->isScenSpecAtt (argName))
@


1.200
log
@Stochastic Implosion
@
text
@d1069 2
a1070 1
            myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
@


1.199
log
@ASAP Pegging Order.
@
text
@d28 1
a28 1
#include <OptImp.h>
d106 1
a106 1
      if (myOptImploder ()->extOptActive ())
d116 1
a116 1
   if (origWitRun->myOptImploder ()->extOptActive ())
d171 1
a171 1
   myOptImploder ()->evalObjectives ();
d184 1
a184 1
   if (not myOptImploder ()->extOptActive ())
d187 1
a187 1
   if (not myOptImploder ()->myExtOptMgr ()->solnProvided ())
d190 1
a190 1
   myOptImploder ()->finishExtOpt ();
d228 1
a228 1
   if (not myOptImploder ()->extOptActive ())
d231 1
a231 1
   myOptImploder ()->
d264 1
a264 1
   if (not myOptImploder ()->extOptActive ())
d267 1
a267 1
   myOptImploder ()->
d386 1
a386 1
   myOptImploder ()->implode ();
d474 1
a474 1
   if (not myOptImploder ()->extOptActive ())
d477 1
a477 1
   myOptImploder ()->myExtOptMgr ()->setSoln (colsol);
d511 1
a511 1
   if (not myOptImploder ()->extOptActive ())
d514 1
a514 1
   myOptImploder ()->shutDownExtOpt ();
d552 1
a552 1
   myOptImploder ()->startExtOpt ();
d1119 1
a1119 1
   if (myOptImploder ()->extOptActive ())
d1132 1
a1132 1
   if (origWitRun->myOptImploder ()->extOptActive ())
d1245 1
a1245 1
   if (not myOptImploder ()->extOptActive ())
@


1.198
log
@ASAP pegging order
@
text
@a759 3
   else if (theDevCmdString == "Allow PIP with ASAP pegging order.")
      myGlobalComp ()->setAllowAsapPip (true);

@


1.197
log
@Stochastic Implosion
@
text
@d757 1
a757 1
   if (theDevCmdString == "Allow stochastic implosion.")
d760 3
@


1.196
log
@Stochastic Implosion
@
text
@d881 1
a881 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d893 1
a893 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d905 1
a905 3
   forbidNullArg (theArg, argName);

   issueScenMsgIfNeeded (argName);
d917 1
a917 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d929 1
a929 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d941 1
a941 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d953 1
a953 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d965 1
a965 3
   forbidNullArg (theArg, argName);

   issueScenMsgIfNeeded (argName);
d979 1
a979 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d995 1
a995 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d1010 1
a1010 3
   forbidNullArg (theArg, argName);

   issueScenMsgIfNeeded (argName);
d1024 1
a1024 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d1038 1
a1038 3
   forbidNullArg (theVarPtr, argName);

   issueScenMsgIfNeeded (argName);
d1060 14
a1266 10
void WitRun::issueScenMsgIfNeeded (const char * theAttName)
   {
   if (mySession_->active ())
      if (myStochImpMgr ()->stochMode ())
         if (myStochImpMgr ()->attIsScenSpec (theAttName))
            myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
   }

//------------------------------------------------------------------------------

@


1.195
log
@Stochastic Implosion.
@
text
@d883 1
a883 1
   issueSsiMsgIfNeeded (argName);
d897 1
a897 1
   issueSsiMsgIfNeeded (argName);
d911 1
a911 1
   issueSsiMsgIfNeeded (argName);
d925 1
a925 1
   issueSsiMsgIfNeeded (argName);
d939 1
a939 1
   issueSsiMsgIfNeeded (argName);
d953 1
a953 1
   issueSsiMsgIfNeeded (argName);
d967 1
a967 1
   issueSsiMsgIfNeeded (argName);
d981 1
a981 1
   issueSsiMsgIfNeeded (argName);
d997 1
a997 1
   issueSsiMsgIfNeeded (argName);
d1015 1
a1015 1
   issueSsiMsgIfNeeded (argName);
d1032 1
a1032 1
   issueSsiMsgIfNeeded (argName);
d1048 1
a1048 1
   issueSsiMsgIfNeeded (argName);
d1064 1
a1064 1
   issueSsiMsgIfNeeded (argName);
d1279 1
a1279 1
void WitRun::issueSsiMsgIfNeeded (const char * theAttName)
d1283 1
a1283 1
         if (myStochImpMgr ()->isSsiAttName (theAttName))
@


1.194
log
@Stochastic Implosion
@
text
@d1279 1
a1279 1
void WitRun::issueSsiMsgIfNeeded (const char * theAttrName)
d1283 1
a1283 1
         if (myStochImpMgr ()->isSsiAttrName (theAttrName))
@


1.193
log
@Stochastic Implosion
@
text
@d758 1
a758 1
      myProblem ()->myStochImpMgr ()->setStochImpAllowed (true);
d883 2
d897 2
d911 2
d925 2
d939 2
d953 2
d967 2
d981 2
d997 2
d1015 2
d1032 2
d1048 2
d1064 2
d1134 1
a1134 1
   if (myProblem ()->myStochImpMgr ()->stochMode ())
d1147 1
a1147 1
   if (origWitRun->myProblem ()->myStochImpMgr ()->stochMode ())
d1265 1
a1265 1
   if (myProblem ()->myStochImpMgr ()->stochMode ())
d1273 1
a1273 1
   if (myProblem ()->myStochImpMgr ()->stochMode ())
d1279 10
@


1.192
log
@Stochastic Implosion
@
text
@d391 2
a392 2
// API callable routine to perform general and optimization specific
// preprocessing of data.
@


1.191
log
@Stochastic Implosion
@
text
@d399 1
a399 1
   myProblem ()->myPreprocessor ()->optPreprocess ();
@


1.190
log
@Stochastic Implosion.
@
text
@d169 1
a169 1
   forbidStochDataMode ();
d326 1
a326 1
   forbidStochDataMode ();
d384 1
a384 1
   forbidStochDataMode ();
d432 1
a432 1
   forbidStochDataMode ();
d550 1
a550 1
   forbidStochDataMode ();
d564 1
a564 1
   forbidStochDataMode ();
d734 1
a734 1
      forbidStochDataMode ();
d1108 1
a1108 1
   if (myProblem ()->myStochImpMgr ()->stochDataMode ())
d1121 1
a1121 1
   if (origWitRun->myProblem ()->myStochImpMgr ()->stochDataMode ())
d1239 1
a1239 1
   if (myProblem ()->myStochImpMgr ()->stochDataMode ())
d1245 1
a1245 1
void WitRun::forbidStochDataMode ()
d1247 1
a1247 1
   if (myProblem ()->myStochImpMgr ()->stochDataMode ())
@


1.189
log
@Stochastic Implosion
@
text
@a759 8
   if (theDevCmdString == "Single stochastic LP problem.")
      {
      if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
         myMsgFac () ("globNeedsStochModeSmsg", "sglStochLP");

      myProblem ()->myStochImpMgr ()->setSglStochLP (true);
      }

@


1.188
log
@Stochastic Implosion
@
text
@d760 8
@


1.187
log
@Stochastic Implosion
@
text
@d169 2
d326 2
d384 2
d432 1
a432 2
   if (myProblem ()->myStochImpMgr ()->stochDataMode ())
      myMsgFac () ("purgeStochModeSmsg");
d550 2
d564 2
d733 3
d1108 3
d1121 3
a1170 7
const char * WitRun::apiFuncName ()
   {
   return myApiMgr ()->apiFuncName ();
   }

//------------------------------------------------------------------------------

d1244 15
@


1.186
log
@Stochastic Implosion
@
text
@d30 1
a30 1
#include <StochMgr.h>
d426 1
a426 1
   if (myProblem ()->myStochMgr ()->stochDataMode ())
d746 1
a746 1
      myProblem ()->myStochMgr ()->setStochImpAllowed (true);
d1228 1
a1228 1
   if (myProblem ()->myStochMgr ()->stochDataMode ())
@


1.185
log
@Stochastic Implosion
@
text
@d426 1
a426 1
   if (myProblem ()->myStochMgr ()->stochasticMode ())
d1228 1
a1228 1
   if (myProblem ()->myStochMgr ()->stochasticMode ())
@


1.184
log
@Stochastic implosion.
@
text
@d426 1
a426 1
   if (myProblem ()->myStochMgr ()->stochImpMode ())
d1228 1
a1228 1
   if (myProblem ()->myStochMgr ()->stochImpMode ())
@


1.183
log
@Stochastic Implosion.
@
text
@d426 2
a427 2
   if (myProblem ()->myStochMgr ()->active ())
      myMsgFac () ("purgeStochActSmsg");
d1228 2
a1229 2
   if (myProblem ()->myStochMgr ()->active ())
      myMsgFac () ("addStochActSmsg", myMsgFac ().myFrag (theObjTypeFragID));
@


1.182
log
@Stochastic Implosion.
@
text
@d426 3
@


1.181
log
@Stochastic Implosion.
@
text
@d1222 8
@


1.180
log
@Stochastic implosion.
@
text
@d1047 1
a1047 1
      WitMsgFragID theClassFragID)
d1058 2
a1059 2
         myMsgFac ().myFrag (theClassFragID),
         myMsgFac ().myFrag (theDelComp->classFragID ()));
@


1.179
log
@Stochastic implosion.
@
text
@d732 3
d742 1
a742 1
   if (DEVELOPMENT and (theDevCmdString == "Allow stochastic implosion."))
a1221 9

void WitRun::forbidAddStochAct (WitMsgFragID theMsgFragID)
   {
   if (myProblem ()->myStochMgr ()->stochImpActive ())
      myMsgFac () ("addObjectStochActiveSmsg",
         myMsgFac ().myFrag (theMsgFragID));
   }

//------------------------------------------------------------------------------
@


1.178
log
@Stochastic Implosion.
@
text
@d1219 9
@


1.177
log
@Removed witThrowUnknownExc.
@
text
@d30 1
d739 3
@


1.176
log
@[disallowed backlog]
@
text
@a724 9
void WitRun::witThrowUnknownExc ()
   {
   myApiMgr_->startInnerFunc ();

   throw bool ();
   }

//------------------------------------------------------------------------------

@


1.175
log
@witCopy<Object>Data
@
text
@d27 1
@


1.174
log
@witCopy<Object>Data
@
text
@d1104 1
a1104 1
   myGlobalComp ()->checkForCopyObjData (origWitRun->myGlobalComp ());
d1114 37
@


1.173
log
@witCopy<Object>Data
@
text
@d1104 1
a1104 25
   if (            myGlobalComp ()->nPeriods () !=
       origWitRun->myGlobalComp ()->nPeriods ())
      {
      myMsgFac () ("copyObjDiffNPeriodsSmsg",
                     myGlobalComp ()->nPeriods (),
         origWitRun->myGlobalComp ()->nPeriods ());
      }
 
   if (            myGlobalComp ()->wit34Compatible () !=
       origWitRun->myGlobalComp ()->wit34Compatible ())
      {
      myMsgFac () ("copyObjDiffBooAttSmsg",
                                     "wit34Compatible",
                     myGlobalComp ()->wit34Compatible (),
         origWitRun->myGlobalComp ()->wit34Compatible ());
      }

   if (            myGlobalComp ()->independentOffsets () !=
       origWitRun->myGlobalComp ()->independentOffsets ())
      {
      myMsgFac () ("copyObjDiffBooAttSmsg",
                                     "independentOffsets",
                     myGlobalComp ()->independentOffsets (),
         origWitRun->myGlobalComp ()->independentOffsets ());
      }
d1106 1
a1106 1
   if (origWitRun == this)
@


1.172
log
@witCopy<Object>Data
@
text
@d1115 2
a1116 1
      myMsgFac () ("copyObjDiff24CompatSmsg",
d1121 9
@


1.171
log
@witCopy<Object>Data
@
text
@d1104 3
a1106 1
   if (myGlobalComp ()->nPeriods () != origWitRun->myGlobalComp ()->nPeriods ())
d1110 9
@


1.170
log
@witCopy<Object>Data
@
text
@d1104 5
@


1.169
log
@witCopy<Object>Data
@
text
@d743 1
a743 4
   if      (theDevCmdString == "Allow witCopy<Object>Data.")
      myGlobalComp ()->setAllowCopyObjData (true);

   else if (theDevCmdString == "Throw an exception of unknown type.")
a1090 3
   if (not myGlobalComp ()->allowCopyObjData ())
      myMsgFac () ("funcNYASmsg",         apiFuncName ());

@


1.168
log
@witCopy<Object>Data
@
text
@d97 1
a97 1
void WitRun::witCopyData (WitRun * srcWitRun)
d105 1
a105 1
         myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "dstWitRun");
d107 1
a107 1
   forbidNullArg (srcWitRun, "srcWitRun");
d109 1
a109 1
   myApiMgr_->start2WitRunFunc (srcWitRun->myApiMgr_);
d111 2
a112 2
   if (not srcWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg", "witCopyData", "srcWitRun");
d114 2
a115 2
   if (srcWitRun->myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "srcWitRun");
d117 1
a117 1
   mySession ()->copyData (srcWitRun->mySession_);
d1085 1
a1085 1
void WitRun::startCopyObjData (WitRun * srcWitRun)
d1092 1
a1092 1
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "dstWitRun");
d1098 1
a1098 1
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "dstWitRun");
d1100 1
a1100 1
   forbidNullArg (srcWitRun, "srcWitRun");
d1102 1
a1102 1
   myApiMgr_->start2WitRunFunc (srcWitRun->myApiMgr_);
d1104 2
a1105 2
   if (not srcWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   apiFuncName (), "srcWitRun");
d1107 2
a1108 2
   if (srcWitRun->myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", apiFuncName (), "srcWitRun");
d1110 1
a1110 1
   if (srcWitRun == this)
@


1.167
log
@witCopy<Object>Data
@
text
@d1109 5
@


1.166
log
@witCopy<Object>Data
@
text
@d1085 28
@


1.165
log
@witCopy<Object>Data
@
text
@d111 2
a112 10
   try
      {
      if (not srcWitRun->mySession_->active ())
         myMsgFac () ("uninitWitRun2Smsg", "witCopyData", "srcWitRun");

      if (srcWitRun->myOptImploder ()->extOptActive ())
         myMsgFac () ("extOptActiveWR2Smsg", "witCopyData", "srcWitRun");

      mySession ()->copyData (srcWitRun->mySession_);
      }
d114 2
a115 8
   catch (...)
      {
      srcWitRun->myApiMgr_->setPrevApiAbort ();

      myApiMgr_->finish2WitRunFunc (srcWitRun->myApiMgr_);

      throw;
      }
d117 1
a117 1
   myApiMgr_->finish2WitRunFunc (srcWitRun->myApiMgr_);
@


1.164
log
@witCopy<Object>Data
@
text
@d103 4
d109 1
a109 1
   myApiMgr_->startCopyData (srcWitRun->myApiMgr_);
d114 1
a114 1
         myMsgFac () ("uninitSrcWitRunSmsg");
d117 1
a117 5
         myMsgFac () ("copyDataExtOptActiveSmsg");

      if (mySession_->active ())
         if (myOptImploder ()->extOptActive ())
            myMsgFac () ("copyDataExtOptActiveSmsg");
d126 1
a126 1
      myApiMgr_->finishCopyData (srcWitRun->myApiMgr_);
d131 1
a131 1
   myApiMgr_->finishCopyData (srcWitRun->myApiMgr_);
@


1.163
log
@witCopy<Object>Data
@
text
@d747 1
a747 1
void WitRun::witInterpDevCmd (const char * theCmd)
d749 1
a749 1
   WitString theCmdString;
d753 1
a753 1
   theCmdString = theCmd;
d755 1
a755 1
   myMsgFac () ("devCmdMsg", theCmdString);
d757 1
a757 1
   if      (theCmdString == "Allow witCopy<Object>Data.")
d760 1
a760 1
   else if (theCmdString == "Throw an exception of unknown type.")
@


1.162
log
@witCopy<Object>data.
@
text
@d757 4
a760 1
   if (theCmdString == "Throw an exception of unknown type.")
@


1.161
log
@witCopy<Object>Data
@
text
@d757 3
a759 2
   if (theCmdString == "Issue a fatal error message.")
      myMsgFac () ("requestedFmsg");
@


1.160
log
@External opt implosion.
@
text
@d747 18
@


1.159
log
@External opt implosion.
@
text
@d473 1
a473 1
void WitRun::witSetExtOptSoln (const WitIVRealArg & soln)
d481 1
a481 1
   myOptImploder ()->myExtOptMgr ()->setSoln (soln);
@


1.158
log
@External opt implosion.
@
text
@d197 3
@


1.157
log
@External opt implosion.
@
text
@d229 1
a229 1
void WitRun::witGetExtOptIntVars (int * * indices, int * len)
d240 1
a240 1
         getIntVars (indicesLoc);
@


1.156
log
@External opt implosion.
@
text
@d112 7
@


1.155
log
@External opt implosion.
@
text
@d496 16
@


1.154
log
@External opt implosion.
@
text
@d28 1
a28 1
#include <ExtOptHand.h>
d232 1
a232 1
      myExtOptHandler ()->
d268 1
a268 1
      myExtOptHandler ()->
d471 1
a471 1
   myOptImploder ()->myExtOptHandler ()->setSoln (soln);
@


1.153
log
@external optimzing implosion.
@
text
@d222 1
a222 1
void WitRun::witGetExtOptIntIndices (int * * intIndices, int * numIntCols)
d224 1
a224 1
   WitVector <int> intIndicesLoc;
d233 1
a233 1
         getIntIndices (intIndicesLoc);
d235 2
a236 2
   apiGet (intIndices, "intIndices", intIndicesLoc);
   apiGet (numIntCols, "numIntCols", intIndicesLoc.length ());
d459 1
a459 1
// witSetExtOptColSol
d463 1
a463 1
void WitRun::witSetExtOptColSol (const WitIVRealArg & colsol)
d471 1
a471 1
   myOptImploder ()->myExtOptHandler ()->setColSol (colsol);
@


1.152
log
@External opt implosion.
@
text
@d222 20
a241 1
void WitRun::witGetExtOptProb (
d251 1
a251 4
      const WitOVRealArg & rowub,
      int * *              intIndices,
      int *                numIntCols,
      const WitOSRealArg & objSense)
a260 2
   WitVector <int>    intIndicesLoc;
   double             objSenseLoc;
d269 1
a269 1
         getProb (
d277 12
a288 17
            rowubLoc,
            intIndicesLoc,
            objSenseLoc);

   apiGet (numcols,    "numcols",    collbLoc.length ());
   apiGet (numrows,    "numrows",    rowlbLoc.length ());
   apiGet (start,      "start",      startLoc);
   apiGet (index,      "index",      indexLoc);
   apiGet (value,      "value",      valueLoc);
   apiGet (collb,      "collb",      collbLoc);
   apiGet (colub,      "colub",      colubLoc);
   apiGet (obj,        "obj",        objLoc);
   apiGet (rowlb,      "rowlb",      rowlbLoc);
   apiGet (rowub,      "rowub",      rowubLoc);
   apiGet (intIndices, "intIndices", intIndicesLoc);
   apiGet (numIntCols, "numIntCols", intIndicesLoc.length ());
   apiGet (objSense,   "objSense",   objSenseLoc);
@


1.151
log
@External opt implosion.
@
text
@a186 3
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

a249 3
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

a458 3
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

a509 3
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

a1108 3
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

@


1.150
log
@External opt implosion.
@
text
@d147 1
@


1.149
log
@External opt implosion.
@
text
@d1107 21
@


1.148
log
@External opt implosion.
@
text
@d68 3
d78 2
d87 2
d99 3
a101 2
   if (myMsgFac ().mayIssue ("witFuncCalled"))
      myMsgFac () ("witFuncCalled", "witCopyData");
d133 5
d147 2
d159 2
d171 2
d183 3
d187 4
a190 1
      myMsgFac () ("funcNotAvailSmsg", "witFinishExtOpt");
d202 2
d217 2
d250 2
d253 4
a256 1
      myMsgFac () ("funcNotAvailSmsg", "witGetExtOptProb");
d293 2
d306 2
d320 2
d333 3
a335 2
   if (myMsgFac ().mayIssue ("witFuncCalled"))
      myMsgFac () ("witFuncCalled", "witInitialize");
d346 2
d360 4
d373 2
d389 2
d401 2
d413 2
d422 2
d434 2
d448 3
d461 3
d465 4
a468 1
      myMsgFac () ("funcNotAvailSmsg", "witSetExtOptColSol");
d480 2
d501 2
d516 2
d519 1
a519 1
      myMsgFac () ("funcNotAvailSmsg", "witStartExtOpt");
d540 2
d554 8
a561 4
   myProblem ()->mySolnWriter ()->writeCriticalList (
       filename,
       fileFormat,
       maxListLength);
d571 2
d584 2
d597 2
d618 2
d631 2
d640 5
d655 5
d667 5
d682 2
d701 5
d716 2
d1053 1
a1053 1
const WitString & WitRun::apiFuncName () const
@


1.147
log
@External opt implosion.
@
text
@d28 1
a28 1
#include <ExtOptPerf.h>
d225 1
a225 1
      myExtOptPerf ()->
d402 1
a402 1
   myOptImploder ()->myExtOptPerf ()->setColSol (colsol);
@


1.146
log
@External opt implosion.
@
text
@d402 1
a402 1
   myOptImploder ()->setExtOptColSol (colsol);
@


1.145
log
@External opt implosion.
@
text
@d28 1
d225 12
a236 11
      getExtOptProb (
         startLoc,
         indexLoc,
         valueLoc,
         collbLoc,
         colubLoc,
         objLoc,
         rowlbLoc,
         rowubLoc,
         intIndicesLoc,
         objSenseLoc);
@


1.144
log
@External opt implosion.
@
text
@d194 1
a194 1
void WitRun::witGetExtOptProblem (
d221 1
a221 1
      myMsgFac () ("funcNotAvailSmsg", "witGetExtOptProblem");
d224 1
a224 1
      getExtOptProblem (
d391 1
a391 1
// witSetExtOptColSolution
d395 1
a395 1
void WitRun::witSetExtOptColSolution (const WitIVRealArg & colsol)
d398 1
a398 1
      myMsgFac () ("funcNotAvailSmsg", "witSetExtOptColSolution");
d400 1
a400 1
   myOptImploder ()->setExtOptColSolution (colsol);
@


1.143
log
@External opt implosion.
@
text
@d445 6
d452 1
a452 1
      myMsgFac () ("startExtWithAccAfterSmsg");
@


1.142
log
@External opt implosion.
@
text
@a192 7
// witGetMultiThread ()
//------------------------------------------------------------------------------

void WitRun::witGetMultiThread (WitBoolean * multiThread)
   {
   apiGet (multiThread, "multiThread", WitApiMgr::multiThread ());
   }
d194 1
a194 17
//------------------------------------------------------------------------------
// witGetObjItrState
// API function retrieve the object type of data object at which object
// iteration is currently located.
//------------------------------------------------------------------------------

void WitRun::witGetObjItrState (WitAttr * objItrState)
   {
   apiGet (
      objItrState, 
      "objItrState", 
      myCompMgr ()->myDelCompItr ()->apiObjItrState ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOptProblem (
d221 1
a221 1
      myMsgFac () ("funcNotAvailSmsg", "witGetOptProblem");
d224 1
a224 1
      getOptProbData (
d252 23
d391 13
@


1.141
log
@External opt implosion.
@
text
@d157 2
a158 2
// witFinishAsstOpt
// WIT API to conclude assisted optimizing implosion.
d161 1
a161 1
void WitRun::witFinishAsstOpt ()
d164 1
a164 1
      myMsgFac () ("funcNotAvailSmsg", "witFinishAsstOpt");
d166 1
a166 1
   myOptImploder ()->finishAsstOpt ();
d423 2
a424 2
// witStartAsstOpt
// WIT API to initiate assisted optimizing implosion.
d427 1
a427 1
void WitRun::witStartAsstOpt ()
d430 1
a430 1
      myMsgFac () ("funcNotAvailSmsg", "witStartAsstOpt");
d433 1
a433 1
      myMsgFac () ("startAsstWithAccAfterSmsg");
d435 1
a435 1
   myOptImploder ()->startAsstOpt ();
@


1.140
log
@Assisted opt implosion.
@
text
@a422 16
// witSolveOptProblem
// WIT API to solve the implosion optimization problem.
//------------------------------------------------------------------------------

void WitRun::witSolveOptProblem ()
   {
   if (not WitOptComp::optImpAllowed ())
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witSolveOptProblem");

   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", "witSolveOptProblem");

   myOptImploder ()->solveOptProbAsst ();
   }

//------------------------------------------------------------------------------
@


1.139
log
@Assisted opt implosion.
@
text
@d227 4
a230 1
      const WitOVRealArg & rowub)
a231 2
   int                numcolsLoc;
   int                numrowsLoc;
d240 2
d244 1
a244 1
      myMsgFac () ("funcNotAvailSmsg",            "witGetOptProblem");
a247 2
         numcolsLoc,
         numrowsLoc,
d255 17
a271 12
         rowubLoc);

   apiGet (numcols, "numcols", numcolsLoc);
   apiGet (numrows, "numrows", numrowsLoc);
   apiGet (start,   "start",   startLoc);
   apiGet (index,   "index",   indexLoc);
   apiGet (value,   "value",   valueLoc);
   apiGet (collb,   "collb",   collbLoc);
   apiGet (colub,   "colub",   colubLoc);
   apiGet (obj,     "obj",     objLoc);
   apiGet (rowlb,   "rowlb",   rowlbLoc);
   apiGet (rowub,   "rowub",   rowubLoc);
@


1.138
log
@Assisted opt implosion.
@
text
@d442 3
@


1.137
log
@Custom opt implosion.
@
text
@d157 2
a158 2
// witFinishCustOptImp
// WIT API to conclude optimizing implosion.
d161 1
a161 1
void WitRun::witFinishCustOptImp ()
d164 1
a164 1
      myMsgFac () ("funcNotAvailSmsg", "witFinishCustOptImp");
d166 1
a166 1
   myOptImploder ()->finishCust ();
d429 1
a429 1
   myOptImploder ()->solveOptProbCust ();
d433 2
a434 2
// witStartCustOptImp
// WIT API to initiate custom optimizing implosion.
d437 1
a437 1
void WitRun::witStartCustOptImp ()
d440 1
a440 1
      myMsgFac () ("funcNotAvailSmsg", "witStartCustOptImp");
d442 1
a442 1
   myOptImploder ()->startCust ();
@


1.136
log
@App controlled opt implosion.
@
text
@d157 2
a158 2
// witFinishHeurAlloc
// API function to conclude heuristic allocation.
d161 1
a161 1
void WitRun::witFinishHeurAlloc ()
d163 2
a164 2
   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");
d166 1
a166 1
   myProblem ()->myHeurAllMgr ()->finish ();
d170 2
a171 2
// witFinishOptImp
// WIT API to conclude optimizing implosion.
d174 1
a174 1
void WitRun::witFinishOptImp ()
d176 2
a177 2
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", "witFinishOptImp");
d179 1
a179 1
   myOptImploder ()->finish ();
d429 1
a429 1
   myOptImploder ()->solveOptProb ();
d433 2
a434 2
// witStartHeurAlloc
// API function to initiate heuristic allocation.
d437 1
a437 1
void WitRun::witStartHeurAlloc ()
d439 4
a442 1
   myProblem ()->myHeurAllMgr ()->start ();
d446 2
a447 2
// witStartOptImp
// WIT API to initiate optimizing implosion.
d450 1
a450 1
void WitRun::witStartOptImp ()
d452 1
a452 4
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", "witStartOptImp");

   myOptImploder ()->start ();
@


1.135
log
@App controlled opt implosion.
@
text
@a175 3
   if (not WitOptComp::optImpAllowed ())
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witFinishOptImp");

a239 3
   if (not WitOptComp::optImpAllowed ())
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witGetOptProblem");

a448 3
   if (not WitOptComp::optImpAllowed ())
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witStartOptImp");

@


1.134
log
@App controlled opt implosion.
@
text
@d176 1
a176 1
   if (not OPT_IMP_MODE)
d243 1
a243 1
   if (not OPT_IMP_MODE)
d324 1
a324 1
   if (not OPT_IMP_MODE)
d429 1
a429 1
   if (not OPT_IMP_MODE)
d455 1
a455 1
   if (not OPT_IMP_MODE)
@


1.133
log
@App controlled opt implosion.
@
text
@d44 8
d56 2
d639 33
d702 1
@


1.132
log
@App controlled opt implosion.
@
text
@d209 56
d755 17
a771 3
      int * *               theVarPtr,
      const char *          argName,
      const WitTVec <int> & theValue)
d775 1
a775 1
   apiAlloc (theVarPtr, nPeriods ());
d783 3
a785 3
      WitBoolean * *         theVarPtr,
      const char *           argName,
      const WitTVec <bool> & theValue)
d791 1
a791 1
   apiAlloc (theVarPtr, nPeriods ());
@


1.131
log
@App controlled opt implosion.
@
text
@d357 1
a357 1
// witSolveOptImp
d361 1
a361 1
void WitRun::witSolveOptImp ()
d364 1
a364 1
      myMsgFac () ("invalidForNonOptImpModeSmsg", "witSolveOptImp");
d367 1
a367 1
      myMsgFac () ("funcNotAvailSmsg", "witSolveOptImp");
d369 1
a369 1
   myOptImploder ()->solve ();
@


1.130
log
@App controlled opt implosion.
@
text
@d160 16
d357 16
d383 16
@


1.129
log
@App controlled opt implosion.
@
text
@d22 2
d256 1
a256 1
   myProblem ()->optPreprocess ();
d266 1
a266 1
   myProblem ()->postprocess ();
d276 1
a276 1
   myProblem ()->preprocess ();
@


1.128
log
@App controlled opt implosion.
@
text
@d116 9
@


1.127
log
@App controlled opt implosion.
@
text
@a54 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a61 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a68 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a78 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a111 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a121 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a131 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a141 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a154 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a163 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a174 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a186 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a197 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a209 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a221 3
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);
a230 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a244 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a254 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a264 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a271 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a281 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a293 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a303 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a322 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a335 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a347 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a360 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a371 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a382 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a401 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a412 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a419 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a429 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a436 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a443 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a463 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a473 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a724 9
void WitRun::startInnerApiFunc (
      WitInitState::Tag   theInitStateTag,
      WitOptImpState::Tag theOptImpStateTag)
   {
   myApiMgr ()->startInnerApiFunc (theInitStateTag, theOptImpStateTag);
   }

//------------------------------------------------------------------------------

@


1.126
log
@App controlled opt implode.
@
text
@d55 4
d66 4
d77 4
d91 4
d128 4
d142 4
d156 4
d170 4
d187 4
d200 4
d215 4
d231 4
d246 4
d262 4
d278 3
d290 4
d308 4
d322 4
d336 4
d347 4
d361 4
d377 4
d391 4
d414 4
d431 4
d447 4
d464 4
d479 4
d494 4
d517 4
d532 4
d543 4
d557 4
d568 4
d579 4
d603 4
d617 4
d872 9
@


1.125
log
@Updated the copyright date on all source files.
@
text
@a129 2
#ifdef OPT_IMPLODE

a134 2
#endif

a228 2
#ifdef OPT_IMPLODE

d231 3
a236 2
#endif

a242 2
#ifdef OPT_IMPLODE

a247 2
#endif

@


1.124
log
@Removed some more OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.123
log
@Continued the effort to make the apparent infinite loop in witExhaustMemory
invisible to the compiler, in order to prevent the compiler from issuing a
warning about it.
@
text
@a236 5
   if (not WitOptImploder::coinMode ())
      if (WitApiMgr::multiThread ())
         myMsgFac () ("notAllowedWMultiThreadSmsg",
            "witOptImplode (in OSL mode)");

@


1.122
log
@Made the apparent infinite loop in witExhaustMemory invisible to the compiler,
in order to prevent a compiler warning about it.
@
text
@a828 7

bool WitRun::alwaysTrue ()
   {
   return true;
   }

//------------------------------------------------------------------------------
@


1.121
log
@[shared-resource pegging]
@
text
@d461 1
a461 1
   for (totDiscarded = 100; ; totDiscarded += 100)
d829 7
@


1.120
log
@[shared-resource pegging]
@
text
@d542 1
a542 1
void WitRun::apiVoidAlloc (void * * theCVecPtr, WitSiz nElems, size_t elSize)
d834 1
a834 1
      void WitNonClass::apiAlloc (Elem * * theCVecPtr, WitSiz nElems)
d844 7
a850 7
template void WitNonClass::apiAlloc <int>      (int    * *,   WitSiz);
template void WitNonClass::apiAlloc <float>    (float  * *,   WitSiz);
template void WitNonClass::apiAlloc <double>   (double * *,   WitSiz);
template void WitNonClass::apiAlloc <char>     (char   * *,   WitSiz);
template void WitNonClass::apiAlloc <float  *> (float  * * *, WitSiz);
template void WitNonClass::apiAlloc <double *> (double * * *, WitSiz);
template void WitNonClass::apiAlloc <char   *> (char   * * *, WitSiz);
d854 1
a854 1
void WitNonClass::apiAlloc (const WitOVRealArg & theOVRealArg, WitSiz nElems)
@


1.119
log
@[error recovery]
@
text
@d542 1
a542 1
void WitRun::apiVoidAlloc (void * * theCVecPtr, size_t nElems, size_t elSize)
a581 12
      int *        theVarPtr,
      const char * argName,
      size_t       theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
d834 1
a834 1
      void WitNonClass::apiAlloc (Elem * * theCVecPtr, size_t nElems)
d844 7
a850 7
template void WitNonClass::apiAlloc <int>      (int    * *,   size_t);
template void WitNonClass::apiAlloc <float>    (float  * *,   size_t);
template void WitNonClass::apiAlloc <double>   (double * *,   size_t);
template void WitNonClass::apiAlloc <char>     (char   * *,   size_t);
template void WitNonClass::apiAlloc <float  *> (float  * * *, size_t);
template void WitNonClass::apiAlloc <double *> (double * * *, size_t);
template void WitNonClass::apiAlloc <char   *> (char   * * *, size_t);
d854 1
a854 1
void WitNonClass::apiAlloc (const WitOVRealArg & theOVRealArg, size_t nElems)
@


1.118
log
@[error recovery]
@
text
@d96 1
a96 1
      srcWitRun->myApiMgr_->setPrevApiAbortMyWR ();
a492 13
void WitRun::witSetErrorRecovery ()
   {
   if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
      myMsgFac () ("setBooleanAttrMsg",
         "errorRecovery",
         WitApiMgr::errorRecovery (),
         WitTRUE);

   WitApiMgr::setErrorRecovery ();
   }

//------------------------------------------------------------------------------

@


1.117
log
@multi-thread follow-up
@
text
@d84 1
a84 2
   if (srcWitRun != this)
      myApiMgr_->startCopyData (srcWitRun->myApiMgr_);
d86 7
a92 2
   if (not srcWitRun->mySession_->active ())
      myMsgFac () ("uninitSrcWitRunSmsg");
d94 8
a101 1
   mySession ()->copyData (srcWitRun->mySession_);
d103 1
a103 2
   if (srcWitRun != this)
      myApiMgr_->finishCopyData ();
@


1.116
log
@[error recovery]
@
text
@d457 2
a458 1
      stronglyAssert (theMem != NULL);
@


1.115
log
@[error recovery]
@
text
@a40 2
#include <errno.h>

@


1.114
log
@[error recovery]
@
text
@d86 2
a87 1
   myApiMgr_->startCopyData (srcWitRun->myApiMgr_);
d94 2
a95 1
   myApiMgr_->finishCopyData ();
@


1.113
log
@[multi-thread]
@
text
@d86 2
a90 3
   if (this != srcWitRun)
      srcWitRun->myApiMgr_->lockMyWitRun ("witCopyData");

d93 1
a93 2
   if (this != srcWitRun)
      srcWitRun->myApiMgr_->unlockMyWitRun ();
d482 13
@


1.112
log
@[multi-thread]
@
text
@a309 3
   if (myMsgFac ().mayIssue ("witFuncCalled"))
      myMsgFac () ("witFuncCalled", "witSetMultiThread");

@


1.111
log
@[multi-thread]
@
text
@d453 2
a454 1
   int totDiscarded;
d458 5
a462 1
      new char[104857600];
@


1.110
log
@[multi-thread]
@
text
@a159 2
   myMsgFac () ("multiThreadUnrelWmsg");

a312 2
   myMsgFac () ("multiThreadUnrelWmsg");

@


1.109
log
@[multi-thread]
@
text
@d86 1
a86 1
   if (not srcWitRun->mySession ()->active ())
d90 1
a90 1
      srcWitRun->myApiMgr_->lockWitRun ("witCopyData");
d92 1
a92 1
   mySession ()->copyData (srcWitRun->mySession ());
d95 1
a95 1
      srcWitRun->myApiMgr_->unlockWitRun ();
@


1.108
log
@[multi-thread]
@
text
@a289 3
   if (WitApiMgr::multiThread ())
      myMsgFac () ("notAllowedWMultiThreadSmsg", "witReadData");

@


1.107
log
@[multi-thread]
@
text
@d81 3
d196 3
d315 3
@


1.106
log
@[mult-thread]
@
text
@a80 3
   if (WitApiMgr::multiThread ())
      myMsgFac () ("notAllowedWMultiThreadSmsg", "witCopyData");

d86 3
d90 3
@


1.105
log
@Ran make depend.
@
text
@a93 3
// 
// This function is just a place-holder to be called by the expansion of the
// STANDARD_API_IMPL macro in api.C.
d98 1
@


1.104
log
@[multi-thread]
@
text
@d467 1
a467 3
   WitSaeMgr theSaeMgr (this, argc, argv);

   theSaeMgr.execute ();
@


1.103
log
@[multi-thread]
@
text
@d464 3
@


1.102
log
@[multi-thread]
@
text
@d302 3
d306 1
a306 1
void WitRun::witSetMultiThread ()
d310 3
@


1.101
log
@[multi-thread]
@
text
@d465 7
@


1.100
log
@[multi-thread]
@
text
@d524 1
a524 1
      curMsgFac () ("callocSmsg", nElems * elSize);
@


1.99
log
@[multi-thread]
@
text
@d458 1
a458 1
   WitSaeMgr theSaeMgr (this);
d460 1
a460 1
   theSaeMgr.execute (argc, argv);
@


1.98
log
@[multi-thread]
@
text
@d37 1
d456 9
@


1.97
log
@[multi-thread]
@
text
@d475 9
a483 9
   appNewHandler = WitNonClass::set_new_handler (newErrorForCtor);
      //
      // If there's a memory error during construction, call newErrorForCtor.

   theWitRun = new WitRun;

   WitNonClass::set_new_handler (appNewHandler);
      //
      // Restore the application's new_handler.
d734 1
a734 1
void WitRun::newErrorForCtor ()
@


1.96
log
@[multi-thread]
@
text
@d92 11
d204 1
a204 1
// WitRun::witNewRun.
d206 2
a207 2
// The purpose of this function is to enable ::witNewRun to validly invoke the
// STANDARD_API_IMPL_QUIET macro.
d441 14
@


1.95
log
@[multi-thread]
@
text
@d271 3
@


1.94
log
@[multi-thread]
@
text
@d212 5
@


1.93
log
@[multi-thread]
@
text
@d21 1
d80 3
d287 6
@


1.92
log
@[multi-thread]
@
text
@d140 2
d281 2
@


1.91
log
@[multi-thread]
@
text
@d135 9
d276 7
@


1.90
log
@Minor change.
@
text
@a78 2
   myMsgFac () ("witFuncCalled", "witCopyData");

a165 2

   myMsgFac () ("witFuncCalled", "witInitialize");
@


1.89
log
@Fixed a bug:
   witCopyData (dstWitRun, srcWitRun) was not issuing a severe error
   message when srcWitRun was not initialized.
@
text
@d79 2
a86 2

   myMsgFac () ("witFuncCalled", "witCopyData");
@


1.88
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d81 3
@


1.87
log
@Minor change.
@
text
@a18 1
#include <ProEpilog.h>
d53 1
a53 1
WitReturnCode WitRun::witAdvanceObjItr ()
a54 2
   PROLOG ("witAdvanceObjItr");

a55 2

   EPILOG;
d60 1
a60 1
WitReturnCode WitRun::witBuildPip ()
a61 2
   PROLOG ("witBuildPip");

a62 2

   EPILOG;
d67 1
a67 1
WitReturnCode WitRun::witClearPegging ()
a68 2
   PROLOG ("witClearPegging");

a72 2

   EPILOG;
d77 2
a78 6
WitReturnCode WitRun::witCopyData(
   WitRun * srcWitRun
)
{
   QUIET_PROLOG("witCopyData");

a83 16

   EPILOG;
}

//------------------------------------------------------------------------------
// WitRun::witDeleteRun.
//
// The purpose of this function is to do standard API things before calling
// the WitRun dtor from ::witDeleteRun.
//------------------------------------------------------------------------------

WitReturnCode WitRun::witDeleteRun ()
   {
   QUIET_PROLOG ("witDeleteRun");

   EPILOG;
d91 1
a91 1
WitReturnCode WitRun::witDisplayData (const char * filename)
a92 2
   PROLOG ("witDisplayData");

a93 2

   EPILOG;
d103 1
a103 1
WitReturnCode WitRun::witEvalObjectives ()
a104 2
   PROLOG ("witEvalObjectives");

a105 2

   EPILOG;
d115 1
a115 1
WitReturnCode WitRun::witFinishHeurAlloc ()
a116 2
   PROLOG("witFinishHeurAlloc");

a120 2

   EPILOG;
d128 1
a128 1
WitReturnCode WitRun::witGeneratePriorities ()
a129 2
   PROLOG ("witGeneratePriorities");

a130 2

   EPILOG;
d139 1
a139 1
WitReturnCode WitRun::witGetObjItrState (WitAttr * objItrState)
a140 2
   PROLOG ("witGetObjItrState");

a144 2

   EPILOG;
d151 1
a151 1
WitReturnCode WitRun::witHeurImplode ()
a152 2
   PROLOG ("witHeurImplode");

a153 2

   EPILOG;
d162 1
a162 1
WitReturnCode WitRun::witInitialize ()
a163 2
   QUIET_PROLOG("witInitialize");

a166 2

   EPILOG;
d173 1
a173 1
WitReturnCode WitRun::witMrp ()
a174 2
   PROLOG ("witMrp");

a175 2

   EPILOG;
d181 2
a182 2
// The purpose of this function is to do standard API things after calling
// WitRun::newInstance from ::witNewRun.
d185 1
a185 1
WitReturnCode WitRun::witNewRun ()
a186 3
   QUIET_PROLOG ("witNewRun");

   EPILOG;
d196 1
a196 1
WitReturnCode WitRun::witOptImplode ()
a197 2
   PROLOG ("witOptImplode");

a198 2

   EPILOG;
d211 1
a211 1
WitReturnCode WitRun::witOptPreprocess ()
a212 2
   PROLOG ("witOptPreprocess");

a213 2

   EPILOG;
d223 1
a223 1
WitReturnCode WitRun::witPostprocess ()
a224 2
   PROLOG ("witPostprocess");

a225 2

   EPILOG;
d233 1
a233 1
WitReturnCode WitRun::witPreprocess ()
a234 2
   PROLOG ("witPreprocess");

a235 2

   EPILOG;
d240 1
a240 1
WitReturnCode WitRun::witPurgeData ()
a241 2
   PROLOG ("witPurgeData");

a242 2

   EPILOG;
d250 1
a250 1
WitReturnCode WitRun::witReadData (const char * fileName)
a251 2
   PROLOG("witReadData");

a254 2

   EPILOG;
d262 1
a262 1
WitReturnCode WitRun::witResetObjItr ()
a263 2
   PROLOG ("witResetObjItr");

a264 2

   EPILOG;
d272 1
a272 1
WitReturnCode WitRun::witShutDownHeurAlloc ()
a273 2
   PROLOG("witShutDownHeurAlloc");

a277 2

   EPILOG;
d285 1
a285 1
WitReturnCode WitRun::witStartHeurAlloc ()
a286 2
   PROLOG("witStartHeurAlloc");

a287 2

   EPILOG;
d294 1
a294 1
WitReturnCode WitRun::witWriteCriticalList (
a298 2
   PROLOG("witWriteCriticalList");

a302 2

   EPILOG;
d310 1
a310 1
WitReturnCode WitRun::witWriteData (const char * filename)
a311 2
   PROLOG("witWriteData");

a312 2

   EPILOG;
d319 3
a321 3
WitReturnCode  WitRun::witWriteExecSched (
   const char * filename,
   WitFileFormat fileFormat )
a322 2
   PROLOG("witWriteExecSched");

a323 2

   EPILOG;
d330 1
a330 1
WitReturnCode  WitRun::witWriteProdSched (
a333 2
   PROLOG("witWriteProdSched");

a342 2

   EPILOG;
d349 1
a349 1
WitReturnCode WitRun::witWriteReqSched (
a352 2
   PROLOG("witWriteReqSched");

a353 2

   EPILOG;
d360 1
a360 1
WitReturnCode WitRun::witWriteShipSched (
a363 2
   PROLOG("witWriteShipSched");

a364 2

   EPILOG;
d369 7
a375 12
WitReturnCode
WitRun::witNoDependantWitRunVeneersIsOne (int* isOne)
{
  QUIET_PROLOG("witNoDependantWitRunVeneersIsOne");

  apiGet (
     isOne,
     "isOne",
     (nDepVeneers_ == 1)? 1: 0);

  EPILOG;
}
d379 4
a382 9
WitReturnCode
WitRun::witNoDependantWitRunVeneersDecr ()
{
  QUIET_PROLOG("witNoDependantWitRunVeneersDecr");

  -- nDepVeneers_;

  EPILOG;
}
d386 4
a389 9
WitReturnCode
WitRun::witNoDependantWitRunVeneersIncr ()
{
  QUIET_PROLOG("witNoDependantWitRunVeneersIncr");

  ++ nDepVeneers_;

  EPILOG;
}
a427 17
void WitRun::reqNoActApiCalls ()
   {
   if (not myApiMgr ()->hasActCalls ())
      return;

   startNonMsgSevereError ();

   fprintf (stderr,
      "WIT Thread-safety error:\n\n"
      "   A WIT API function was called when a prior function\n"
      "   call to the same WitRun had not yet returned.\n");

   finishNonMsgSevereError ();
   }

//------------------------------------------------------------------------------

@


1.86
log
@[multi-thread]
@
text
@d579 3
a581 3
      "Thread-safety error:\n\n"
      "   An API function was called when a previous API\n"
      "   function call to the same WitRun had not yet returned.\n");
@


1.85
log
@[multi-threads]
@
text
@d571 1
a571 1
WitRun * WitRun::reqNoActApiCalls ()
d574 1
a574 1
      return this;
d580 2
a581 2
      "   An API function was called when another API function\n"
      "   call for the same WitRun had not yet returned.\n");
a583 2

   return NULL;
@


1.84
log
@[exceptions]
@
text
@a49 74

WitRun * WitRun::newInstance ()
   {
   WitRun * theWitRun;

   void (* appNewHandler) ();

   appNewHandler = WitNonClass::set_new_handler (newErrorForCtor);
      //
      // If there's a memory error during construction, call newErrorForCtor.

   theWitRun = new WitRun;

   WitNonClass::set_new_handler (appNewHandler);
      //
      // Restore the application's new_handler.

   return theWitRun;
   }

//------------------------------------------------------------------------------

WitReturnCode
WitRun::witNoDependantWitRunVeneersIsOne (int* isOne)
{
  QUIET_PROLOG("witNoDependantWitRunVeneersIsOne");

  apiGet (
     isOne,
     "isOne",
     (nDepVeneers_ == 1)? 1: 0);

  EPILOG;
}

//------------------------------------------------------------------------------

WitReturnCode
WitRun::witNoDependantWitRunVeneersDecr ()
{
  QUIET_PROLOG("witNoDependantWitRunVeneersDecr");

  -- nDepVeneers_;

  EPILOG;
}

//------------------------------------------------------------------------------

WitReturnCode
WitRun::witNoDependantWitRunVeneersIncr ()
{
  QUIET_PROLOG("witNoDependantWitRunVeneersIncr");

  ++ nDepVeneers_;

  EPILOG;
}

//------------------------------------------------------------------------------

void WitRun::forbidNullArg (const void * theArg, const char * argName)
   {
   witAssert (argName != NULL);

   if (theArg == NULL)
      {
      myInputID ()->setArgName (argName);

      myMsgFac () ("nullPointerSmsg");
      }
   }

//------------------------------------------------------------------------------
d497 26
a522 3
void WitRun::apiVoidAlloc (void * * theCVecPtr, size_t nElems, size_t elSize)
   {
   * theCVecPtr = NULL;
d524 4
a527 2
   if (nElems == 0)
      return;
d529 1
a529 1
   * theCVecPtr = calloc (nElems, elSize);
d531 2
a532 3
   if (* theCVecPtr == NULL)
      curMsgFac () ("callocSmsg", nElems * elSize);
   }
d550 69
@


1.83
log
@[exceptions]
@
text
@d19 1
d21 1
d117 1
a117 1
      myInputId ()->setArgName (argName);
d593 1
a593 1
WitInputId * WitRun::myInputId () const
d595 1
a595 1
   return myApiMgr ()->myInputId ();
@


1.82
log
@[exceptions]
@
text
@a272 15

WitReturnCode WitRun::witGetThrowExcOnError (WitBoolean * throwExcOnError)
   {
   PROLOG ("witGetThrowExcOnError");

   apiGet (      throwExcOnError, 
                "throwExcOnError", 
      myApiMgr_->throwExcOnError ());

   issueGetAttrMsg ("throwExcOnError");

   EPILOG;
   }

//------------------------------------------------------------------------------
a435 29

WitReturnCode WitRun::witSetThrowExcOnError (
      WitBoolean quiet,
      WitBoolean throwExcOnError)
   {
   QUIET_PROLOG ("witSetThrowExcOnError");

   myInputId ()->setMyAttr ("throwExcOnError");

   if (not quiet)
      {
      if (myMsgFac ().mayIssue ("witFuncCalled"))
         myMsgFac () ("witFuncCalled", apiFuncName ());

      if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
         myMsgFac () ("setBooleanAttrMsg",
            "throwExcOnError",
            myApiMgr_->throwExcOnError (),
            throwExcOnError);
      }

   myApiMgr_->setThrowExcOnError (asaBool (throwExcOnError));

   myInputId ()->setMyAttr (NULL);

   EPILOG;
   }

//------------------------------------------------------------------------------
@


1.81
log
@[exceptions]
@
text
@d273 15
d452 1
a452 1
WitReturnCode WitRun::witSetThrowOnErrors (
d454 1
a454 1
      WitBoolean throwOnErrors)
d456 1
a456 1
   QUIET_PROLOG ("witSetThrowOnErrors");
d458 1
a458 1
   myInputId ()->setMyAttr ("throwOnErrors");
d467 3
a469 3
            "throwOnErrors",
            myApiMgr_->throwOnErrors (),
            throwOnErrors);
d472 1
a472 1
   myApiMgr_->setThrowOnErrors (asaBool (throwOnErrors));
@


1.80
log
@[exceptions]
@
text
@d436 29
@


1.79
log
@[exceptions]
@
text
@d579 1
a579 1
      curMsgFac () ("callocError", nElems * elSize);
@


1.78
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d73 1
a73 1
  SHORT_PROLOG("witNoDependantWitRunVeneersIsOne",false);
d88 1
a88 1
  SHORT_PROLOG("witNoDependantWitRunVeneersDecr",false);
d100 1
a100 1
  SHORT_PROLOG("witNoDependantWitRunVeneersIncr",false);
d166 1
a166 1
   SHORT_PROLOG("witCopyData",false);
d186 1
a186 1
   SHORT_PROLOG ("witDeleteRun", false);
d293 1
a293 1
   SHORT_PROLOG("witInitialize",false);
d324 1
a324 1
   SHORT_PROLOG ("witNewRun", false);
@


1.77
log
@Vector PropRt.
@
text
@a791 12
void WitRun::apiGetObj1Vector (
      const WitOVRealArg &  theArg,
      const char *          argName,
      const WitDblFlexVec & theValue)
   {
   objChoice ()->reqObj1 ();

   apiGet (theArg, argName, theValue);
   }

//------------------------------------------------------------------------------

@


1.76
log
@Pegged Critical List.
@
text
@d24 2
a25 2
#include <OutScalRA.h>
#include <OutVecRA.h>
d647 1
a647 1
      const WitOutScalRA & theArg,
d738 1
a738 1
      const WitOutVecRA &   theArg,
d780 4
a783 4
      const WitOutVecRA & hardLBVec,
      const WitOutVecRA & softLBVec,
      const WitOutVecRA & hardUBVec,
      const WitBoundSet * theValue)
d793 1
a793 1
      const WitOutVecRA &   theArg,
d919 1
a919 1
void WitNonClass::apiAlloc (const WitOutVecRA & theOutVecRA, size_t nElems)
d921 1
a921 1
   theOutVecRA.apiAlloc (nElems);
@


1.75
log
@Pegged Critical List.
@
text
@d471 1
a471 1
   const char * filename,
d473 1
a473 1
   int maxListLength  )
@


1.74
log
@Tie Breaking Prop-Rt.
@
text
@d701 1
a701 1
   * theVarPtr = dupCstring (theValue);
a846 13
char * WitRun::dupCstring (const WitString & theString) const
   {
   char * theCstring;

   apiAlloc (& theCstring, theString.length () + 1);

   strcpy   (theCstring, theString.myCstring ());

   return theCstring;
   }

//------------------------------------------------------------------------------

d909 5
a913 4
template void WitNonClass::apiAlloc <int>      (int    * *  , size_t);
template void WitNonClass::apiAlloc <float>    (float  * *  , size_t);
template void WitNonClass::apiAlloc <double>   (double * *  , size_t);
template void WitNonClass::apiAlloc <float *>  (float  * * *, size_t);
d915 1
a915 1
template void WitNonClass::apiAlloc <char  *>  (char   * * *, size_t);
@


1.73
log
@Initial work on [vector propRouting attribute].
@
text
@d33 1
a33 1
#include <PipSysMgr.h>
d141 1
a141 1
   myProblem ()->myPipSysMgr ()->buildPegging ();
@


1.72
log
@More work on handling severe and fatal errors.
@
text
@d752 14
@


1.71
log
@Double Precision.
@
text
@d178 14
d303 1
a303 1
// API entry point for the portable MRP.
d311 14
@


1.70
log
@Double Precision.
@
text
@a618 12
      float *      theVarPtr,
      const char * argName,
      double       theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = fltFromDbl (theValue);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
a678 14
      float * *               theVarPtr,
      const char *            argName,
      const WitTVec <float> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, nPeriods ());

   theValue.copyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
a709 14
      float * *             theVarPtr,
      const char *          argName,
      const WitDblFlexVec & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (theVarPtr, nPeriods ());

   theValue.copyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
a737 13
      float * *           hardLBPtr,
      float * *           softLBPtr,
      float * *           hardUBPtr,
      const WitBoundSet * theValue)
   {
   apiGet (hardLBPtr, "hardLB", theValue->hardLB ());
   apiGet (softLBPtr, "softLB", theValue->softLB ());
   apiGet (hardUBPtr, "hardUB", theValue->hardUB ());
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
a745 12
   }

//------------------------------------------------------------------------------

void WitRun::apiGetObj1Vector (
      float * *             theVarPtr,
      const char *          argName,
      const WitDblFlexVec & theValue)
   {
   objChoice ()->reqObj1 ();

   apiGet (theVarPtr, argName, theValue);
@


1.69
log
@Double Precision.
@
text
@d699 1
a699 1
   theValue.convCopyInto (* theVarPtr);
d713 1
a713 1
   theValue.convCopyInto (* theVarPtr);
d744 1
a744 1
   theValue.convCopyInto (* theVarPtr);
d772 1
a772 1
   theValue.convCopyInto (* theVarPtr);
@


1.68
log
@Double Precision.
@
text
@d637 1
a637 1
   theArg.setTo (theValue);
d758 1
a758 1
   theArg.convCopy (theValue);
@


1.67
log
@Double Precision.
@
text
@d945 6
a950 5
template void WitNonClass::apiAlloc <int>     (int    * *  , size_t);
template void WitNonClass::apiAlloc <float>   (float  * *  , size_t);
template void WitNonClass::apiAlloc <double>  (double * *  , size_t);
template void WitNonClass::apiAlloc <float *> (float  * * *, size_t);
template void WitNonClass::apiAlloc <char  *> (char   * * *, size_t);
@


1.66
log
@Double Precision.
@
text
@d541 1
a541 1
void WitRun::apiVoidAlloc (void * & theCVec, size_t nElems, size_t elSize)
d543 1
a543 1
   theCVec = NULL;
d548 1
a548 1
   theCVec = calloc (nElems, elSize);
d550 1
a550 1
   if (theCVec == NULL)
d697 1
a697 1
   apiAlloc (* theVarPtr, nPeriods ());
d711 1
a711 1
   apiAlloc (* theVarPtr, nPeriods ());
d727 1
a727 1
   apiAlloc (* theVarPtr, nPeriods ());
d742 1
a742 1
   apiAlloc (* theVarPtr, nPeriods ());
d756 1
a756 1
   theArg.apiAlloc (nPeriods ());
d770 1
a770 1
   apiAlloc (* theVarPtr, nPeriods ());
d874 1
a874 1
   apiAlloc (theCstring, theString.length () + 1);
d935 1
a935 1
      void WitNonClass::apiAlloc (Elem * & theCVec, size_t nElems)
d938 1
a938 1
      reinterpret_cast <void * &> (theCVec),
d945 12
a956 5
template void WitNonClass::apiAlloc <int>     (int    *   &, size_t);
template void WitNonClass::apiAlloc <float>   (float  *   &, size_t);
template void WitNonClass::apiAlloc <double>  (double *   &, size_t);
template void WitNonClass::apiAlloc <float *> (float  * * &, size_t);
template void WitNonClass::apiAlloc <char  *> (char   * * &, size_t);
@


1.65
log
@Double Precision.
@
text
@d635 1
a635 1
   forbidNullArg (theArg.asaTlPtr (), argName);
d754 1
a754 1
   forbidNullArg (theArg.asaTlPtr (), argName);
@


1.64
log
@Double Precision.
@
text
@d882 48
@


1.63
log
@Modified to build on windows
@
text
@d803 1
a803 1
void WitRun::witGetObj1Vector (
d815 12
d897 1
a901 1
template void WitNonClass::apiAlloc <int>     (int    *   &, size_t);
@


1.62
log
@Double Precision.
@
text
@d889 1
@


1.61
log
@Double Precision.
@
text
@d635 1
a635 1
   forbidNullArg (theArg.myUnderArgAsTlPtr (), argName);
d754 1
a754 1
   forbidNullArg (theArg.myUnderArgAsTlPtr (), argName);
@


1.60
log
@Double Precision.
@
text
@d790 13
@


1.59
log
@Double Precision.
@
text
@d855 21
@


1.58
log
@Double Precision.
@
text
@d541 15
a853 15
   }

//------------------------------------------------------------------------------

void WitRun::apiVoidAlloc (void * & theCVec, size_t nElems, size_t elSize)
   {
   theCVec = NULL;

   if (nElems == 0)
      return;

   theCVec = calloc (nElems, elSize);

   if (theCVec == NULL)
      curMsgFac () ("callocError", nElems * elSize);
@


1.57
log
@Double Precision.
@
text
@d25 1
d730 14
@


1.56
log
@Double Precision.
@
text
@d828 1
a828 5
void WitRun::apiVoidAlloc (
      void * & theCVec,
      size_t   nElems,
      size_t   elSize)
      const
d838 1
a838 1
      myMsgFac () ("callocError", nElems * elSize);
@


1.55
log
@Double Precision.
@
text
@d615 3
a617 3
      WitOutScalRA & theArg,
      const char *   argName,
      double         theValue)
@


1.54
log
@Double Precision.
@
text
@d591 1
a591 1
      witBoolean * theVarPtr,
d703 1
a703 1
      witBoolean * *         theVarPtr,
@


1.53
log
@Double Precision.
@
text
@d720 3
a722 3
      float * *                   theVarPtr,
      const char *                argName,
      const WitFlexVec <double> & theValue)
d728 1
a728 1
   convCopy (* theVarPtr, theValue);
d761 3
a763 3
      float * *                   theVarPtr,
      const char *                argName,
      const WitFlexVec <double> & theValue)
@


1.52
log
@Double Precision.
@
text
@a719 14
      float * *                  theVarPtr,
      const char *               argName,
      const WitFlexVec <float> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (* theVarPtr, nPeriods ());

   theValue.convCopyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
a755 12
   }

//------------------------------------------------------------------------------

void WitRun::witGetObj1Vector (
      float * *                  theVarPtr,
      const char *               argName,
      const WitFlexVec <float> & theValue)
   {
   objChoice ()->reqObj1 ();

   apiGet (theVarPtr, argName, theValue);
@


1.51
log
@Double Precision.
@
text
@d619 1
a619 1
   forbidNullArg (theArg.myUnderArg (), argName);
@


1.50
log
@Double Precision.
@
text
@d33 1
a33 1
#include <RealVec.h>
a747 14
      float * *          theVarPtr,
      const char *       argName,
      const WitRealVec & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (* theVarPtr, nPeriods ());

   theValue.convCopyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
d787 3
a789 3
      float * *          theVarPtr,
      const char *       argName,
      const WitRealVec & theValue)
@


1.49
log
@Double Precision.
@
text
@d748 3
a750 31
      float * *             theVarPtr,
      const char *          argName,
      const WitFltRealVec & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (* theVarPtr, nPeriods ());

   theValue.convCopyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      float * *             theVarPtr,
      const char *          argName,
      const WitDblRealVec & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (* theVarPtr, nPeriods ());

   theValue.convCopyInto (* theVarPtr);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      float * *             theVarPtr,
      const char *          argName,
      const WitFltRealTVc & theValue)
@


1.48
log
@Double Precision.
@
text
@d748 31
a778 3
      float * *          theVarPtr,
      const char *       argName,
      const WitRealVec & theValue)
@


1.47
log
@Double Precision.
@
text
@d683 1
a683 1
   theValue.copyIntoCVec (* theVarPtr);
d697 1
a697 1
   theValue.copyIntoCVec (* theVarPtr);
d728 1
a728 1
   theValue.copyIntoCVec (* theVarPtr);
d756 1
a756 1
   theValue.copyIntoFltCVec (* theVarPtr);
d770 1
a770 1
   theValue.copyIntoCVec (* theVarPtr);
@


1.46
log
@Double Precision.
@
text
@d742 1
a742 1
   copyInto (* theVarPtr, theValue);
@


1.45
log
@Double Precision.
@
text
@d609 1
a609 1
   * theVarPtr = floatFromDouble (theValue);
@


1.44
log
@Double Precision.
@
text
@d683 1
a683 1
   theValue.copyIntoCvector (* theVarPtr);
d697 1
a697 1
   theValue.copyIntoCvector (* theVarPtr);
d728 1
a728 1
   theValue.copyIntoCvector (* theVarPtr);
d770 1
a770 1
   theValue.copyIntoCvector (* theVarPtr);
d869 1
a869 1
      void * & theCvector,
d874 1
a874 1
   theCvector = NULL;
d879 1
a879 1
   theCvector = calloc (nElems, elSize);
d881 1
a881 1
   if (theCvector == NULL)
@


1.43
log
@Double Precision.
@
text
@d800 12
@


1.42
log
@Double Precision.
@
text
@d33 1
a688 14
      float * *                   theVarPtr,
      const char *                argName,
      const WitFlexVec <double> & theValue)
   {
   forbidNullArg (theVarPtr, argName);

   apiAlloc (* theVarPtr, nPeriods ());

   copyInto (* theVarPtr, theValue);
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
d729 28
@


1.41
log
@Continued double precision.
@
text
@d614 3
a616 3
      OutScalRA &  theArg,
      const char * argName,
      double       theValue)
@


1.40
log
@Continued double precision.
@
text
@d24 1
a24 1
#include <RealSOutArg.h>
d614 3
a616 3
      RealSOutArg & theArg,
      const char *  argName,
      double        theValue)
@


1.39
log
@Continued double precision.
@
text
@d608 1
a608 1
   * theVarPtr = static_cast <float> (theValue);
@


1.38
log
@Continued double precision.
@
text
@d24 1
a24 1
#include <RealOutArg.h>
d614 3
a616 3
      RealOutArg & theArg,
      const char * argName,
      double       theValue)
d618 1
a618 1
   forbidNullArg (theArg.myUnderArgAsVoidPtr (), argName);
@


1.37
log
@Continued double precision.
@
text
@d24 1
d609 12
@


1.36
log
@Continued double precision.
@
text
@d603 1
a603 1
      StrDbl       theValue)
d607 1
a607 1
   * theVarPtr = theValue.asaFloat ();
@


1.35
log
@Continued double precision.
@
text
@a602 12
      float        theValue)
   {
   forbidNullArg (theVarPtr, argName);

   * theVarPtr = theValue;
   }

//------------------------------------------------------------------------------

void WitRun::apiGet (
      float *      theVarPtr,
      const char * argName,
@


1.34
log
@Continued double precision.
@
text
@d615 1
a615 1
      double       theValue)
d619 1
a619 1
   * theVarPtr = static_cast <float> (theValue);
@


1.33
log
@Continued implementation of PIP.
@
text
@d613 12
@


1.32
log
@Added API function witBuildPip.
@
text
@d31 1
a31 1
#include <PipMgr.h>
d138 1
a138 1
   myProblem ()->myPipMgr ()->buildPegging ();
@


1.31
log
@Continued implementation of PIP.
@
text
@d31 1
d128 11
@


1.30
log
@An attempt to fix some syntax errors on Windows.
@
text
@d51 1
a51 1
   appNewHandler = WitUtil::set_new_handler (newErrorForCtor);
d57 1
a57 1
   WitUtil::set_new_handler (appNewHandler);
@


1.29
log
@Continued implementation of post-implosion pegging.
@
text
@d51 1
a51 1
   appNewHandler = set_new_handler (newErrorForCtor);
d57 1
a57 1
   set_new_handler (appNewHandler);
@


1.28
log
@Added API function witShutDownHeurAlloc.
@
text
@a32 1
#include <FlexVecI.h>
@


1.27
log
@Added a function to convert from witBoolean to bool.
@
text
@d394 17
@


1.26
log
@Internal changes.
@
text
@d549 24
d674 1
a674 1
void WitRun::apiGetBoolVec (
@


1.25
log
@Internal changes.
@
text
@d138 1
a138 1
   if (! myGlobalComp ()->perfPegging ())
d204 1
a204 1
   if (! myProblem ()->myHeurAllMgr ()->active ())
d726 1
a726 1
   if (! myCompMgr ()->myDelCompItr ()->active ())
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d70 1
a70 1
  SHORT_PROLOG("witNoDependantWitRunVeneersIsOne",witFALSE);
d85 1
a85 1
  SHORT_PROLOG("witNoDependantWitRunVeneersDecr",witFALSE);
d97 1
a97 1
  SHORT_PROLOG("witNoDependantWitRunVeneersIncr",witFALSE);
d152 1
a152 1
   SHORT_PROLOG("witCopyData",witFALSE);
d265 1
a265 1
   SHORT_PROLOG("witInitialize",witFALSE);
d646 17
@


1.23
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d33 1
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a296 10
   #ifdef C370

      // Insure FORTRAN environment is initialized by top level routine.
      //
      #pragma linkage ( initftn, FORTRAN)

      initftn();

   #endif

@


1.21
log
@Continued implementation of single-source.
@
text
@d21 2
@


1.20
log
@Preliminary work on single source.
@
text
@d29 1
d723 2
a724 2
         myMsgFac ()[theClassFragID],
         myMsgFac ()[theDelComp->classFragID ()]);
@


1.19
log
@Continued preliminary work on single source.
@
text
@d623 1
a623 1
   theValue.copySelfInto (* theVarPtr);
d631 1
a631 1
      const WitFlexVec (double) & theValue)
d651 1
a651 1
   theValue.copySelfInto (* theVarPtr);
d659 1
a659 1
      const WitFlexVec (float) & theValue)
d665 1
a665 1
   theValue.copySelfInto (* theVarPtr);
d673 1
a673 1
      const WitFlexVec (int) & theValue)
d679 1
a679 1
   theValue.copySelfInto (* theVarPtr);
d700 1
a700 1
      const WitFlexVec (float) & theValue)
@


1.18
log
@Continued preliminary work on single source.
@
text
@d14 2
a15 2
// The full implementation of class WitRun is spread throughout many of WIT's
// source files.
d28 1
@


1.17
log
@Continued implementation of object iteration.
@
text
@d616 1
a616 1
      const WitTVec (float) & theValue)
d644 1
a644 1
      const WitTVec (int) & theValue)
@


1.16
log
@Continued implementation of object iteration.
@
text
@d118 1
a118 1
WitReturnCode WitRun::witAdvanceObjItr (WitAttr * objItrState)
a122 5

   apiGet (
      objItrState, 
      "objItrState", 
      myCompMgr ()->myDelCompItr ()->apiObjItrState ());
@


1.15
log
@Continued implementation of object iteration.
@
text
@d114 1
a114 1
// witAdvanceItr
d118 1
a118 1
WitReturnCode WitRun::witAdvanceItr (WitAttr * curItrState)
d120 1
a120 1
   PROLOG("witAdvanceItr");
d125 3
a127 3
      curItrState, 
      "curItrState", 
      myCompMgr ()->myDelCompItr ()->curApiItrState ());
d227 1
a227 1
// witGetCurItrState
d232 1
a232 1
WitReturnCode WitRun::witGetCurItrState (WitAttr * curItrState)
d234 1
a234 1
   PROLOG("witGetCurItrState");
d237 3
a239 3
      curItrState, 
      "curItrState", 
      myCompMgr ()->myDelCompItr ()->curApiItrState ());
d390 1
a390 1
// witResetItr
d394 1
a394 1
WitReturnCode WitRun::witResetItr ()
d396 1
a396 1
   PROLOG("witResetItr");
d714 1
a714 1
      WitAttr      theItrState,
d724 1
a724 1
   if (theItrState != theDelComp->apiItrState ())
@


1.14
log
@Began implementation of object iteration.
@
text
@d20 1
a61 14
WitObjFunc * WitRun::objChoice () const
   {
   return myOptComp ()->objChoice ();
   }

//------------------------------------------------------------------------------

WitInputId * WitRun::myInputId () const
   {
   return myApiMgr ()->myInputId ();
   }

//------------------------------------------------------------------------------

a99 4
// witInitialize
// API function to put this WitRun into its initial state, excluding the
// message facility.
//------------------------------------------------------------------------------
d101 1
a101 1
WitReturnCode WitRun::witInitialize ()
d103 1
a103 1
   SHORT_PROLOG("witInitialize",witFALSE);
d105 3
a107 1
   mySession ()->activate ();
d109 2
a110 17
   myMsgFac () ("witFuncCalled", "witInitialize");

   EPILOG;
   }

//------------------------------------------------------------------------------
// witStartHeurAlloc
// API function to initiate heuristic allocation.
//------------------------------------------------------------------------------

WitReturnCode WitRun::witStartHeurAlloc ()
   {
   PROLOG("witStartHeurAlloc");

   myProblem ()->myHeurAllMgr ()->start ();

   EPILOG;
d114 2
a115 2
// witFinishHeurAlloc
// API function to conclude heuristic allocation.
d118 1
a118 1
WitReturnCode WitRun::witFinishHeurAlloc ()
d120 1
a120 1
   PROLOG("witFinishHeurAlloc");
d122 1
a122 2
   if (! myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");
d124 4
a127 1
   myProblem ()->myHeurAllMgr ()->finish ();
a146 30
// witReadData
// API callable routine to read the input data file.
//------------------------------------------------------------------------------

WitReturnCode WitRun::witReadData (const char * fileName)
   {
   PROLOG("witReadData");

   forbidNullArg (fileName, "fileName");

   myProblem ()->myDataReader ()->readData (fileName);

   EPILOG;
   }

//------------------------------------------------------------------------------
// witWriteData
// API callable routine to write the input data file.
//------------------------------------------------------------------------------

WitReturnCode WitRun::witWriteData (const char * filename)
   {
   PROLOG("witWriteData");

   myProblem ()->myDataWriter ()->writeData (filename);

   EPILOG;
   }

//------------------------------------------------------------------------------
d178 2
a179 2
// witPostprocess ()
// API callable routine to perform general postprocess of data.
d182 3
a184 1
WitReturnCode WitRun::witPostprocess ()
d186 1
a186 1
   PROLOG ("witPostprocess");
d188 1
a188 1
   myProblem ()->postprocess ();
d193 2
d196 2
a197 2
// witPreprocess ()
// API callable routine to perform general preprocessing of data.
d200 1
a200 1
WitReturnCode WitRun::witPreprocess ()
d202 1
a202 1
   PROLOG ("witPreprocess");
d204 2
a205 1
   myProblem ()->preprocess ();
d207 1
a207 10
   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witPurgeData ()
   {
   PROLOG ("witPurgeData");

   myCompMgr ()->purgeData ();
d227 4
d232 11
a242 1
#ifdef OPT_IMPLODE
d245 1
a245 2
// witEvalObjectives ()
// API callable routine to evaluate objective function values
d248 1
a248 1
WitReturnCode WitRun::witEvalObjectives ()
d250 1
a250 1
   PROLOG ("witEvalObjectives");
d252 1
a252 1
   myOptImploder ()->evalObjectives ();
d258 3
a260 3
// witOptPreprocess ()
// API callable routine to perform general and optimization specific
// preprocessing of data.
d263 1
a263 1
WitReturnCode WitRun::witOptPreprocess ()
d265 3
a267 1
   PROLOG ("witOptPreprocess");
d269 1
a269 1
   myProblem ()->optPreprocess ();
a273 2
#endif

d275 1
a275 1
// WIT API for heuristic implosion
d278 1
a278 1
WitReturnCode WitRun::witHeurImplode ()
d280 1
a280 1
   PROLOG ("witHeurImplode");
d282 1
a282 1
   myProblem ()->myHeurImploder ()->implode ();
a286 2
#ifdef OPT_IMPLODE

d292 2
d316 90
a405 1
// API entry point for the portable MRP.
d408 1
a408 1
WitReturnCode WitRun::witMrp ()
d410 1
a410 1
   PROLOG ("witMrp");
d412 1
a412 1
   myProblem ()->myOrigMrpExp ()->mrp ();
d437 2
a438 1
// witWriteReqSched: Prints supply requirements schedule.
d441 1
a441 3
WitReturnCode WitRun::witWriteReqSched (
      const char * filename,
      WitFileFormat fileFormat)
d443 1
a443 1
   PROLOG("witWriteReqSched");
d445 1
a445 1
   myProblem ()->mySolnWriter ()->writeReqSched (filename, fileFormat);
d489 15
d520 1
a520 1
void WitRun::forbidNullArg (const void * theArg, const char * argName)
d522 2
a523 1
   witAssert (argName != NULL);
d525 1
a525 3
   if (theArg == NULL)
      {
      myInputId ()->setArgName (argName);
d527 3
a529 2
      myMsgFac () ("nullPointerSmsg");
      }
d709 21
@


1.13
log
@Minor change.
@
text
@d27 1
@


1.12
log
@Continued implementation of pegging.
@
text
@d165 2
a166 2
   if (! myGlobalComp ()->peggingNeeded ())
      myMsgFac () ("reqPeggingNeededSmsg");
@


1.11
log
@Continued implementation of pegging.
@
text
@d165 2
a166 2
   if (! myGlobalComp ()->pegging ())
      myMsgFac () ("needPeggingSmsg");
@


1.10
log
@Continued implementation of pegging.
@
text
@d165 2
a166 2
   if (! myGlobalComp ()->perfPegging ())
      myMsgFac () ("needPerfPeggingSmsg");
@


1.9
log
@Continued implementation of pegging.
@
text
@d165 2
a166 2
   if (! myGlobalComp ()->doPegging ())
      myMsgFac () ("needDoPeggingSmsg");
@


1.8
log
@Initial implementation of pegging.
@
text
@a22 1
#include <PegMgr.h>
d168 1
a168 1
   myProblem ()->myHeurAllMgr ()->myPegMgr ()->clear ();
@


1.7
log
@Implemented EBS lower bound adjustment for sel-split.
@
text
@d22 2
a23 1
#include <HeurAll.h>
d138 1
a138 1
   myProblem ()->myHeurAllocator ()->start ();
d152 1
a152 1
   if (! myProblem ()->myHeurAllocator ()->active ())
d155 15
a169 1
   myProblem ()->myHeurAllocator ()->finish ();
@


1.6
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d192 1
a192 1
   WitRun * rhsWitRun
d197 1
a197 1
   forbidNullArg (rhsWitRun, "rhsWitRun");
d199 1
a199 1
   mySession ()->copyData (rhsWitRun->mySession ());
@


1.5
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d558 1
a558 1
   theValue.copyInto (* theVarPtr);
d572 1
a572 1
   copyTo (* theVarPtr, theValue);
d586 1
a586 1
   theValue.copyInto (* theVarPtr);
d600 1
a600 1
   theValue.copyInto (* theVarPtr);
d614 1
a614 1
   theValue.copyInto (* theVarPtr);
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d564 14
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d45 1
a45 1
   appNewHandler = WitUtil::set_new_handler (newErrorForCtor);
d51 1
a51 1
   WitUtil::set_new_handler (appNewHandler);
d632 1
a632 1
   WitUtil::startNonMsgSevereError ();
d640 1
a640 1
   WitUtil::finishNonMsgSevereError ();
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d636 1
a636 1
      "There is not enough memory available for PRM to create a new WitRun.\n"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

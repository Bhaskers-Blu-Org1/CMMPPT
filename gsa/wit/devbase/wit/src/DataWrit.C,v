head	1.61;
access;
symbols
	sce_5_01_20080919:1.47
	latest_sce_4_20_20060523:1.34.0.2
	sce_4_20_20060523:1.34
	latest_sce4_20_OSL:1.33.0.2
	sce_4_20_OSL:1.33
	sce_410_withVa:1.33
	sce_4_05_20040511:1.31
	sce_4_00_20040201:1.18
	nextGenBranch:1.14.0.2
	nextGenRoot:1.14
	sce_3_30_20030627:1.14
	EndRw-branch:1.11.0.4
	Root-of-EndRw:1.11
	rwToStl:1.11.0.2
	latest_sce_3_10_20010924:1.3.0.8
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.6
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.3.0.4
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2011.09.28.23.49.13;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.24.00.27.30;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.30.20.17.24;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2011.01.20.00.26.44;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.19.00.20.48;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.09.14.40.18;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.08.21.07.40;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.25.19.45.17;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.29.22.53.17;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.29.20.42.57;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.24.22.58.55;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.21.23.09.55;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.18.23.14.44;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.26.22.52.51;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.14.22.08.52;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.30.21.52.08;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.19.20.22.30;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.18.21.18.20;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.17.21.27.10;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.17.20.19.01;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.02.21.21.19;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.28.22.14.31;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.02.17.33.56;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.16.18.25.02;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.28.19.34.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.19.22.16.28;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.16.17.42.49;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.24.22.21.29;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.24.19.17.33;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.12.17.21.54;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.05.22.19.57;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.19.17.52;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.07.00.12.10;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.04.22.31.27;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.30.23.07.51;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.27.16.43.23;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.06.21.13.28;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.06.18.59.28;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.23.18.12.33;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.02.23.40.38;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.22.18.22;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.11.18.53.06;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.23.18.09.11;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.02.17.03.33;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.01.20.16.35;	author austel;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.09.19.52.30;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.08.19.21.48;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.03.23.16.36;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.14.02.29;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.42;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.32;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.20;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.20;	author wit;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "DataWrit.C"
//
// Contains the implementation of the following classes and templates:
//
//    DataWriter
//    VecWriter <ArgVec, ArgScal>
//------------------------------------------------------------------------------

#include <DataWrit.h>
#include <VecWriter.h>
#include <DetOptImpMgr.h>
#include <Timing.h>
#include <Pre.h>
#include <CompMgr.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <MultiObjMgr.h>
#include <ObjVec.h>
#include <CpxParSpecMgr.h>
#include <PipMgr.h>
#include <StochImpMgr.h>
#include <FlexVec.h>
#include <TempMsgFile.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class DataWriter.
//------------------------------------------------------------------------------

WitDataWriter::WitDataWriter (WitProblem * theProblem):

      WitProbAssoc (theProblem),
      curComp_     (NULL),
      buffer_      ()
   {
   }

//------------------------------------------------------------------------------

WitDataWriter::~WitDataWriter ()
   {
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeData (const char * fileName)
   {
   writeData (fileName, false);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeEndCommand ()
   {
   myMsgFac () ("endCommandWdMsg");
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeFirstKeyWord (const char * theKeyWord)
   {
   myMsgFac () ("firstKeyWordWdMsg", theKeyWord);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeKeyWord (const char * theKeyWord)
   {
   myMsgFac () ("keyWordWdMsg", theKeyWord);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeFirstInFileKeyWord (const char * theKeyWord)
   {
   myMsgFac () ("firstInFileKeyWordWdMsg", theKeyWord);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeIntValue (int theInt)
   {
   myMsgFac () ("intWdMsg", theInt);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeStringValue (const WitString & theString)
   {
   writeCstringValue (theString.myCstring ());
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeCstringValue (const char * theCstring)
   {
   myMsgFac () ("stringWdMsg", withSlashes (theCstring));
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *              attrName,
      const WitFlexVec <bool> & theVector,
      bool                      defaultVal)
   {
   WitVecWriter <WitFlexVec <bool>, bool> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "boolSingleVectorWdMsg",
         "boolSparseVectorWdMsg",
          "boolDenseVectorWdMsg");
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *          attrName,
      const WitTVec <int> & theVector,
      int                   defaultVal)
   {
   WitVecWriter <WitTVec <int>, int> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "intSingleVectorWdMsg",
         "intSparseVectorWdMsg",
          "intDenseVectorWdMsg");
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *             attrName,
      const WitFlexVec <int> & theVector,
      int                      defaultVal)
   {
   WitVecWriter <WitFlexVec <int>, int> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "intSingleVectorWdMsg",
         "intSparseVectorWdMsg",
          "intDenseVectorWdMsg");
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *          attrName,
      const WitDblFlexVec & theVector,
      double                defaultVal)
   {
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem ());

   if (myStochImpMgr ()->skipWriteData (attrName, curComp_))
      return;

   theVecWriter.writeDblVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *              attrName,
      const WitTVec <double> &  theVector,
      double                    defaultVal)
   {
   WitVecWriter <WitTVec <double>, double> theVecWriter (myProblem ());

   theVecWriter.writeDblVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeDouble (
      const char * attrName,
      double       theValue,
      double       defaultVal)
   {
   if (theValue != defaultVal)
      writeDouble (attrName, theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeInt (
      const char * attrName,
      int          theValue,
      int          defaultVal)
   {
   if (theValue != defaultVal)
      writeInt (attrName, theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeBool (
      const char * attrName,
      bool         theValue,
      bool         defaultVal)
   {
   if (theValue != defaultVal)
      writeBool (attrName, theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeString (
      const char *      attrName,
      const WitString & theValue,
      const char *      defaultVal)
   {
   if (theValue != defaultVal)
      writeString (attrName, theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeDouble (const char * attrName, double theValue)
   {
   WitMsgID theMsgID;

   writeFirstKeyWord (attrName);

   theMsgID =
      myProblem ()->myGlobalComp ()->highPrecisionWD ()?
         "doubleHpWdMsg":
         "doubleWdMsg";

   myMsgFac () (theMsgID, theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeInt (const char * attrName, int theValue)
   {
   writeFirstKeyWord (attrName);

   myMsgFac () ("intWdMsg", theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeBool (const char * attrName, bool theValue)
   {
   writeFirstKeyWord (attrName);

   myMsgFac () ("boolWdMsg", theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeString (
      const char *      attrName,
      const WitString & theValue)
   {
   writeFirstKeyWord (attrName);
   writeStringValue  (theValue);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeObjVec (
      const char *      attrName,
      const WitObjVec & theObjVec,
      double            defaultVal)
   {
   if (not myOptComp ()->multiObjMode ())
      {
      writeVector (attrName, theObjVec.curDblFlexVec (), defaultVal);
      }
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeSolnData (const char * fileName)
   {
   writeData (fileName, true);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeData (const char * fileName, bool solnData)
   {
   int saveMsgLen;

   myPreprocessor ()->preprocess ();

   WitTimer::enterSection ("extra");

   myMsgFac () ("witFileParam",
      (fileName == NULL)?
         myMsgFac ().fileName ().myCstring ():
         fileName);

   WitTempMsgFile theTemp (myMsgFac (), fileName);

   saveMsgLen = myMsgFac ().lineLength ();

   myMsgFac ().setLineLength (3000);
      //
      // Prevents line breaks.

   myMsgFac ().
      setBoolMsgFrags (
         myMsgFac ().myFrag ( "trueWdFrag"),
         myMsgFac ().myFrag ("falseWdFrag"));

   writeFirstInFileKeyWord ("release");
   writeCstringValue       (RELEASE_NO);
   writeEndCommand         ();

   forEachEl (curComp_, myCompMgr ()->allComponents ())
      if (solnData)
         curComp_->writeSolnData ();
      else
         curComp_->writeData ();

   curComp_ = NULL;

   myOptComp ()->myCpxParSpecMgr ()->writeData ();

   myProblem ()->myPipMgr ()->writeShipSeqData ();

   myStochImpMgr ()->writeData ();

   if (myOptComp ()->multiObjMode ())
      {
      myOptComp ()->myMultiObjMgr ()->writeMultiObjVecs ();
      }

   myMsgFac ().
      setBoolMsgFrags (
         myMsgFac ().myFrag ( "trueFrag"),
         myMsgFac ().myFrag ("falseFrag"));

   myMsgFac ().setLineLength (saveMsgLen);

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

const char * WitDataWriter::withSlashes (const char * theCstring)
   {
   int  stringIndex;
   int  bufferIndex;
   int  stringLength = strlen (theCstring);
   bool specialFound = false;

   for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
      if (isSpecial (theCstring[stringIndex]))
         {
         specialFound = true;

         break;
         }

   if (not specialFound)
      return theCstring;
         //
         // No special chars; therefore no "\"s added. (The usual case.)

   if (buffer_.length () < stringLength * 2)
      buffer_.resize (stringLength * 4);
         //
         // buffer_ may need to be twice the size of theCstring, but we resize
         // it to 4 times, to avoid excessive repeated resizing.

   bufferIndex = -1;

   for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
      {
      if (isSpecial (theCstring[stringIndex]))
         buffer_[++ bufferIndex] = '\\';

      buffer_[++ bufferIndex] = theCstring[stringIndex];
      }

   buffer_[++ bufferIndex] = '\0';

   return buffer_.myCstring ();
   }

//------------------------------------------------------------------------------
// Implementation of class template VecWriter <ArgVec, ArgScal>.
//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      WitVecWriter <ArgVec, ArgScal>::WitVecWriter (WitProblem * theProblem):

      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      WitVecWriter <ArgVec, ArgScal>::~WitVecWriter ()
   {
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeDblVector (
         const char *   attrName,
         const ArgVec & theArgVec,
         ArgScal        defaultVal)
   {
   if (myProblem ()->myGlobalComp ()->highPrecisionWD ())
      writeVector (
         attrName,
         theArgVec,
         defaultVal,
         "doubleSingleVectorHpWdMsg",
         "doubleSparseVectorHpWdMsg",
          "doubleDenseVectorHpWdMsg");
   else
      writeVector (
         attrName,
         theArgVec,
         defaultVal,
         "doubleSingleVectorWdMsg",
         "doubleSparseVectorWdMsg",
          "doubleDenseVectorWdMsg");
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeVector (
         const char *   attrName,
         const ArgVec & theArgVec,
         ArgScal        defaultVal,
         WitMsgID       singleMsgID,
         WitMsgID       sparseMsgID,
         WitMsgID       denseMsgID)
   {
   bool vecWritten;

   if (theArgVec == defaultVal)
      return;

   myProblem ()->myDataWriter ()->writeFirstKeyWord (attrName);

   writeSingle (theArgVec, singleMsgID, vecWritten);

   if (vecWritten)
      return;

   writeSparse (theArgVec, defaultVal, sparseMsgID, vecWritten);

   if (vecWritten)
      return;

   writeDense (theArgVec, denseMsgID);
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeSingle (
         const ArgVec & theArgVec,
         WitMsgID       theMsgID,
         bool &         vecWritten)
   {
   WitPeriod thePer;

   vecWritten = false;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != theArgVec[0])
         return;

   myMsgFac () (theMsgID, theArgVec[0]);

   vecWritten = true;
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeSparse (
            const ArgVec & theArgVec,
            ArgScal        defaultVal,
            WitMsgID       theMsgID,
            bool &         vecWritten)
   {
   WitPeriod thePer;
   int       nNonDefaults; // # elements not at default value.
   bool      firstTime;

   vecWritten   = false;
   nNonDefaults = 0;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != defaultVal)
         {
         nNonDefaults ++;

         if (nNonDefaults >= nPeriods () / 2)
            return;
         }

   myMsgFac () ("startVectorWdMsg", "sparse");

   firstTime = true;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != defaultVal)
         {
         myMsgFac () (theMsgID,
            (firstTime? "": " "),
            thePer,
            theArgVec[thePer]);

         firstTime = false;
         }

   myMsgFac () ("endVectorWdMsg");

   vecWritten = true;
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeDense (
         const ArgVec & theArgVec,
         WitMsgID       theMsgID)
   {
   WitPeriod thePer;

   myMsgFac () ("startVectorWdMsg", "dense");

   forEachPeriod (thePer, myProblem ())
      myMsgFac () (theMsgID,
         ((thePer == 0)? "": " "),
         theArgVec[thePer]);

   myMsgFac () ("endVectorWdMsg");
   }
@


1.60
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.59
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d43 5
a47 5
WitProbAssoc (theProblem),
curComp_     (NULL),
buffer_      ()
{
}
d52 2
a53 2
{
}
d58 3
a60 3
{
writeData (fileName, false);
}
d65 3
a67 3
{
myMsgFac () ("endCommandWdMsg");
}
d72 3
a74 3
{
myMsgFac () ("firstKeyWordWdMsg", theKeyWord);
}
d79 3
a81 3
{
myMsgFac () ("keyWordWdMsg", theKeyWord);
}
d86 3
a88 3
{
myMsgFac () ("firstInFileKeyWordWdMsg", theKeyWord);
}
d93 3
a95 3
{
myMsgFac () ("intWdMsg", theInt);
}
d100 3
a102 3
{
writeCstringValue (theString.myCstring ());
}
d107 3
a109 3
{
myMsgFac () ("stringWdMsg", withSlashes (theCstring));
}
d114 15
a128 15
const char *              attrName,
const WitFlexVec <bool> & theVector,
bool                      defaultVal)
{
WitVecWriter <WitFlexVec <bool>, bool> theVecWriter (myProblem ());

theVecWriter.
writeVector (
attrName,
theVector,
defaultVal,
"boolSingleVectorWdMsg",
"boolSparseVectorWdMsg",
"boolDenseVectorWdMsg");
}
d133 15
a147 15
const char *          attrName,
const WitTVec <int> & theVector,
int                   defaultVal)
{
WitVecWriter <WitTVec <int>, int> theVecWriter (myProblem ());

theVecWriter.
writeVector (
attrName,
theVector,
defaultVal,
"intSingleVectorWdMsg",
"intSparseVectorWdMsg",
"intDenseVectorWdMsg");
}
d152 15
a166 15
const char *             attrName,
const WitFlexVec <int> & theVector,
int                      defaultVal)
{
WitVecWriter <WitFlexVec <int>, int> theVecWriter (myProblem ());

theVecWriter.
writeVector (
attrName,
theVector,
defaultVal,
"intSingleVectorWdMsg",
"intSparseVectorWdMsg",
"intDenseVectorWdMsg");
}
d171 5
a175 5
const char *          attrName,
const WitDblFlexVec & theVector,
double                defaultVal)
{
WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem ());
d177 2
a178 2
if (myStochImpMgr ()->skipWriteData (attrName, curComp_))
return;
d180 2
a181 2
theVecWriter.writeDblVector (attrName, theVector, defaultVal);
}
d186 5
a190 5
const char *              attrName,
const WitTVec <double> &  theVector,
double                    defaultVal)
{
WitVecWriter <WitTVec <double>, double> theVecWriter (myProblem ());
d192 2
a193 2
theVecWriter.writeDblVector (attrName, theVector, defaultVal);
}
d198 7
a204 7
const char * attrName,
double       theValue,
double       defaultVal)
{
if (theValue != defaultVal)
writeDouble (attrName, theValue);
}
d209 7
a215 7
const char * attrName,
int          theValue,
int          defaultVal)
{
if (theValue != defaultVal)
writeInt (attrName, theValue);
}
d220 7
a226 7
const char * attrName,
bool         theValue,
bool         defaultVal)
{
if (theValue != defaultVal)
writeBool (attrName, theValue);
}
d231 7
a237 7
const char *      attrName,
const WitString & theValue,
const char *      defaultVal)
{
if (theValue != defaultVal)
writeString (attrName, theValue);
}
d242 2
a243 2
{
WitMsgID theMsgID;
d245 1
a245 1
writeFirstKeyWord (attrName);
d247 4
a250 4
theMsgID =
myProblem ()->myGlobalComp ()->highPrecisionWD ()?
"doubleHpWdMsg":
"doubleWdMsg";
d252 2
a253 2
myMsgFac () (theMsgID, theValue);
}
d258 2
a259 2
{
writeFirstKeyWord (attrName);
d261 2
a262 2
myMsgFac () ("intWdMsg", theValue);
}
d267 2
a268 2
{
writeFirstKeyWord (attrName);
d270 2
a271 2
myMsgFac () ("boolWdMsg", theValue);
}
d276 6
a281 6
const char *      attrName,
const WitString & theValue)
{
writeFirstKeyWord (attrName);
writeStringValue  (theValue);
}
d286 9
a294 9
const char *      attrName,
const WitObjVec & theObjVec,
double            defaultVal)
{
if (not myOptComp ()->multiObjMode ())
{
writeVector (attrName, theObjVec.curDblFlexVec (), defaultVal);
}
}
d299 3
a301 3
{
writeData (fileName, true);
}
d306 2
a307 2
{
int saveMsgLen;
d309 1
a309 1
myPreprocessor ()->preprocess ();
d311 1
a311 1
WitTimer::enterSection ("extra");
d313 4
a316 4
myMsgFac () ("witFileParam",
(fileName == NULL)?
myMsgFac ().fileName ().myCstring ():
fileName);
d318 1
a318 1
WitTempMsgFile theTemp (myMsgFac (), fileName);
d320 1
a320 1
saveMsgLen = myMsgFac ().lineLength ();
d322 3
a324 3
myMsgFac ().setLineLength (3000);
//
// Prevents line breaks.
d326 4
a329 4
myMsgFac ().
setBoolMsgFrags (
myMsgFac ().myFrag ( "trueWdFrag"),
myMsgFac ().myFrag ("falseWdFrag"));
d331 3
a333 3
writeFirstInFileKeyWord ("release");
writeCstringValue       (RELEASE_NO);
writeEndCommand         ();
d335 5
a339 5
forEachEl (curComp_, myCompMgr ()->allComponents ())
if (solnData)
curComp_->writeSolnData ();
else
curComp_->writeData ();
d341 1
a341 1
curComp_ = NULL;
d343 1
a343 1
myOptComp ()->myCpxParSpecMgr ()->writeData ();
d345 1
a345 1
myProblem ()->myPipMgr ()->writeShipSeqData ();
d347 1
a347 1
myStochImpMgr ()->writeData ();
d349 4
a352 4
if (myOptComp ()->multiObjMode ())
{
myOptComp ()->myMultiObjMgr ()->writeMultiObjVecs ();
}
d354 4
a357 4
myMsgFac ().
setBoolMsgFrags (
myMsgFac ().myFrag ( "trueFrag"),
myMsgFac ().myFrag ("falseFrag"));
d359 1
a359 1
myMsgFac ().setLineLength (saveMsgLen);
d361 2
a362 2
WitTimer::leaveSection ("extra");
}
d367 31
a397 31
{
int  stringIndex;
int  bufferIndex;
int  stringLength = strlen (theCstring);
bool specialFound = false;

for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
if (isSpecial (theCstring[stringIndex]))
{
specialFound = true;

break;
}

if (not specialFound)
return theCstring;
//
// No special chars; therefore no "\"s added. (The usual case.)

if (buffer_.length () < stringLength * 2)
buffer_.resize (stringLength * 4);
//
// buffer_ may need to be twice the size of theCstring, but we resize
// it to 4 times, to avoid excessive repeated resizing.

bufferIndex = -1;

for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
{
if (isSpecial (theCstring[stringIndex]))
buffer_[++ bufferIndex] = '\\';
d399 2
a400 2
buffer_[++ bufferIndex] = theCstring[stringIndex];
}
d402 1
a402 1
buffer_[++ bufferIndex] = '\0';
d404 2
a405 2
return buffer_.myCstring ();
}
d412 1
a412 1
WitVecWriter <ArgVec, ArgScal>::WitVecWriter (WitProblem * theProblem):
d414 3
a416 3
WitProbAssoc (theProblem)
{
}
d421 3
a423 3
WitVecWriter <ArgVec, ArgScal>::~WitVecWriter ()
{
}
d428 22
a449 22
void WitVecWriter <ArgVec, ArgScal>::writeDblVector (
const char *   attrName,
const ArgVec & theArgVec,
ArgScal        defaultVal)
{
if (myProblem ()->myGlobalComp ()->highPrecisionWD ())
writeVector (
attrName,
theArgVec,
defaultVal,
"doubleSingleVectorHpWdMsg",
"doubleSparseVectorHpWdMsg",
"doubleDenseVectorHpWdMsg");
else
writeVector (
attrName,
theArgVec,
defaultVal,
"doubleSingleVectorWdMsg",
"doubleSparseVectorWdMsg",
"doubleDenseVectorWdMsg");
}
d454 9
a462 9
void WitVecWriter <ArgVec, ArgScal>::writeVector (
const char *   attrName,
const ArgVec & theArgVec,
ArgScal        defaultVal,
WitMsgID       singleMsgID,
WitMsgID       sparseMsgID,
WitMsgID       denseMsgID)
{
bool vecWritten;
d464 2
a465 2
if (theArgVec == defaultVal)
return;
d467 1
a467 1
myProblem ()->myDataWriter ()->writeFirstKeyWord (attrName);
d469 1
a469 1
writeSingle (theArgVec, singleMsgID, vecWritten);
d471 2
a472 2
if (vecWritten)
return;
d474 1
a474 1
writeSparse (theArgVec, defaultVal, sparseMsgID, vecWritten);
d476 2
a477 2
if (vecWritten)
return;
d479 2
a480 2
writeDense (theArgVec, denseMsgID);
}
d485 12
a496 12
void WitVecWriter <ArgVec, ArgScal>::writeSingle (
const ArgVec & theArgVec,
WitMsgID       theMsgID,
bool &         vecWritten)
{
WitPeriod thePer;

vecWritten = false;

forEachPeriod (thePer, myProblem ())
if (theArgVec[thePer] != theArgVec[0])
return;
d498 1
a498 1
myMsgFac () (theMsgID, theArgVec[0]);
d500 2
a501 2
vecWritten = true;
}
d506 33
a538 33
void WitVecWriter <ArgVec, ArgScal>::writeSparse (
const ArgVec & theArgVec,
ArgScal        defaultVal,
WitMsgID       theMsgID,
bool &         vecWritten)
{
WitPeriod thePer;
int       nNonDefaults; // # elements not at default value.
bool      firstTime;

vecWritten   = false;
nNonDefaults = 0;

forEachPeriod (thePer, myProblem ())
if (theArgVec[thePer] != defaultVal)
{
nNonDefaults ++;

if (nNonDefaults >= nPeriods () / 2)
return;
}

myMsgFac () ("startVectorWdMsg", "sparse");

firstTime = true;

forEachPeriod (thePer, myProblem ())
if (theArgVec[thePer] != defaultVal)
{
myMsgFac () (theMsgID,
(firstTime? "": " "),
thePer,
theArgVec[thePer]);
d540 2
a541 2
firstTime = false;
}
d543 1
a543 1
myMsgFac () ("endVectorWdMsg");
d545 2
a546 2
vecWritten = true;
}
d551 12
a562 12
void WitVecWriter <ArgVec, ArgScal>::writeDense (
const ArgVec & theArgVec,
WitMsgID       theMsgID)
{
WitPeriod thePer;

myMsgFac () ("startVectorWdMsg", "dense");

forEachPeriod (thePer, myProblem ())
myMsgFac () (theMsgID,
((thePer == 0)? "": " "),
theArgVec[thePer]);
d564 2
a565 2
myMsgFac () ("endVectorWdMsg");
}
@


1.58
log
@CPLEX Parameters
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d43 5
a47 5
      WitProbAssoc (theProblem),
      curComp_     (NULL),
      buffer_      ()
   {
   }
d52 2
a53 2
   {
   }
d58 3
a60 3
   {
   writeData (fileName, false);
   }
d65 3
a67 3
   {
   myMsgFac () ("endCommandWdMsg");
   }
d72 3
a74 3
   {
   myMsgFac () ("firstKeyWordWdMsg", theKeyWord);
   }
d79 3
a81 3
   {
   myMsgFac () ("keyWordWdMsg", theKeyWord);
   }
d86 3
a88 3
   {
   myMsgFac () ("firstInFileKeyWordWdMsg", theKeyWord);
   }
d93 3
a95 3
   {
   myMsgFac () ("intWdMsg", theInt);
   }
d100 3
a102 3
   {
   writeCstringValue (theString.myCstring ());
   }
d107 3
a109 3
   {
   myMsgFac () ("stringWdMsg", withSlashes (theCstring));
   }
d114 15
a128 15
      const char *              attrName,
      const WitFlexVec <bool> & theVector,
      bool                      defaultVal)
   {
   WitVecWriter <WitFlexVec <bool>, bool> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "boolSingleVectorWdMsg",
         "boolSparseVectorWdMsg",
          "boolDenseVectorWdMsg");
   }
d133 15
a147 15
      const char *          attrName,
      const WitTVec <int> & theVector,
      int                   defaultVal)
   {
   WitVecWriter <WitTVec <int>, int> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "intSingleVectorWdMsg",
         "intSparseVectorWdMsg",
          "intDenseVectorWdMsg");
   }
d152 15
a166 15
      const char *             attrName,
      const WitFlexVec <int> & theVector,
      int                      defaultVal)
   {
   WitVecWriter <WitFlexVec <int>, int> theVecWriter (myProblem ());

   theVecWriter.
      writeVector (
         attrName,
         theVector,
         defaultVal,
         "intSingleVectorWdMsg",
         "intSparseVectorWdMsg",
          "intDenseVectorWdMsg");
   }
d171 5
a175 5
      const char *          attrName,
      const WitDblFlexVec & theVector,
      double                defaultVal)
   {
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem ());
d177 2
a178 2
   if (myStochImpMgr ()->skipWriteData (attrName, curComp_))
      return;
d180 2
a181 2
   theVecWriter.writeDblVector (attrName, theVector, defaultVal);
   }
d186 5
a190 5
      const char *              attrName,
      const WitTVec <double> &  theVector,
      double                    defaultVal)
   {
   WitVecWriter <WitTVec <double>, double> theVecWriter (myProblem ());
d192 2
a193 2
   theVecWriter.writeDblVector (attrName, theVector, defaultVal);
   }
d198 7
a204 7
      const char * attrName,
      double       theValue,
      double       defaultVal)
   {
   if (theValue != defaultVal)
      writeDouble (attrName, theValue);
   }
d209 7
a215 7
      const char * attrName,
      int          theValue,
      int          defaultVal)
   {
   if (theValue != defaultVal)
      writeInt (attrName, theValue);
   }
d220 7
a226 7
      const char * attrName,
      bool         theValue,
      bool         defaultVal)
   {
   if (theValue != defaultVal)
      writeBool (attrName, theValue);
   }
d231 7
a237 7
      const char *      attrName,
      const WitString & theValue,
      const char *      defaultVal)
   {
   if (theValue != defaultVal)
      writeString (attrName, theValue);
   }
d242 2
a243 2
   {
   WitMsgID theMsgID;
d245 1
a245 1
   writeFirstKeyWord (attrName);
d247 4
a250 4
   theMsgID =
      myProblem ()->myGlobalComp ()->highPrecisionWD ()?
         "doubleHpWdMsg":
         "doubleWdMsg";
d252 2
a253 2
   myMsgFac () (theMsgID, theValue);
   }
d258 2
a259 2
   {
   writeFirstKeyWord (attrName);
d261 2
a262 2
   myMsgFac () ("intWdMsg", theValue);
   }
d267 2
a268 2
   {
   writeFirstKeyWord (attrName);
d270 2
a271 2
   myMsgFac () ("boolWdMsg", theValue);
   }
d276 6
a281 6
      const char *      attrName,
      const WitString & theValue)
   {
   writeFirstKeyWord (attrName);
   writeStringValue  (theValue);
   }
d286 9
a294 9
      const char *      attrName,
      const WitObjVec & theObjVec,
      double            defaultVal)
   {
   if (not myOptComp ()->multiObjMode ())
      {
      writeVector (attrName, theObjVec.curDblFlexVec (), defaultVal);
      }
   }
d299 3
a301 3
   {
   writeData (fileName, true);
   }
d306 2
a307 2
   {
   int saveMsgLen;
d309 1
a309 1
   myPreprocessor ()->preprocess ();
d311 1
a311 1
   WitTimer::enterSection ("extra");
d313 4
a316 4
   myMsgFac () ("witFileParam",
      (fileName == NULL)?
         myMsgFac ().fileName ().myCstring ():
         fileName);
d318 1
a318 1
   WitTempMsgFile theTemp (myMsgFac (), fileName);
d320 1
a320 1
   saveMsgLen = myMsgFac ().lineLength ();
d322 3
a324 3
   myMsgFac ().setLineLength (3000);
      //
      // Prevents line breaks.
d326 4
a329 4
   myMsgFac ().
      setBoolMsgFrags (
         myMsgFac ().myFrag ( "trueWdFrag"),
         myMsgFac ().myFrag ("falseWdFrag"));
d331 3
a333 3
   writeFirstInFileKeyWord ("release");
   writeCstringValue       (RELEASE_NO);
   writeEndCommand         ();
d335 5
a339 5
   forEachEl (curComp_, myCompMgr ()->allComponents ())
      if (solnData)
         curComp_->writeSolnData ();
      else
         curComp_->writeData ();
d341 1
a341 1
   curComp_ = NULL;
d343 1
a343 1
   myOptComp ()->myCpxParSpecMgr ()->writeData ();
d345 1
a345 1
   myProblem ()->myPipMgr ()->writeShipSeqData ();
d347 1
a347 1
   myStochImpMgr ()->writeData ();
d349 4
a352 4
   if (myOptComp ()->multiObjMode ())
      {
      myOptComp ()->myMultiObjMgr ()->writeMultiObjVecs ();
      }
d354 4
a357 4
   myMsgFac ().
      setBoolMsgFrags (
         myMsgFac ().myFrag ( "trueFrag"),
         myMsgFac ().myFrag ("falseFrag"));
d359 1
a359 1
   myMsgFac ().setLineLength (saveMsgLen);
d361 2
a362 2
   WitTimer::leaveSection ("extra");
   }
d367 31
a397 31
   {
   int  stringIndex;
   int  bufferIndex;
   int  stringLength = strlen (theCstring);
   bool specialFound = false;

   for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
      if (isSpecial (theCstring[stringIndex]))
         {
         specialFound = true;

         break;
         }

   if (not specialFound)
      return theCstring;
         //
         // No special chars; therefore no "\"s added. (The usual case.)

   if (buffer_.length () < stringLength * 2)
      buffer_.resize (stringLength * 4);
         //
         // buffer_ may need to be twice the size of theCstring, but we resize
         // it to 4 times, to avoid excessive repeated resizing.

   bufferIndex = -1;

   for (stringIndex = 0; stringIndex < stringLength; ++ stringIndex)
      {
      if (isSpecial (theCstring[stringIndex]))
         buffer_[++ bufferIndex] = '\\';
d399 2
a400 2
      buffer_[++ bufferIndex] = theCstring[stringIndex];
      }
d402 1
a402 1
   buffer_[++ bufferIndex] = '\0';
d404 2
a405 2
   return buffer_.myCstring ();
   }
d412 1
a412 1
      WitVecWriter <ArgVec, ArgScal>::WitVecWriter (WitProblem * theProblem):
d414 3
a416 3
      WitProbAssoc (theProblem)
   {
   }
d421 3
a423 3
      WitVecWriter <ArgVec, ArgScal>::~WitVecWriter ()
   {
   }
d428 22
a449 22
      void WitVecWriter <ArgVec, ArgScal>::writeDblVector (
         const char *   attrName,
         const ArgVec & theArgVec,
         ArgScal        defaultVal)
   {
   if (myProblem ()->myGlobalComp ()->highPrecisionWD ())
      writeVector (
         attrName,
         theArgVec,
         defaultVal,
         "doubleSingleVectorHpWdMsg",
         "doubleSparseVectorHpWdMsg",
          "doubleDenseVectorHpWdMsg");
   else
      writeVector (
         attrName,
         theArgVec,
         defaultVal,
         "doubleSingleVectorWdMsg",
         "doubleSparseVectorWdMsg",
          "doubleDenseVectorWdMsg");
   }
d454 9
a462 9
      void WitVecWriter <ArgVec, ArgScal>::writeVector (
         const char *   attrName,
         const ArgVec & theArgVec,
         ArgScal        defaultVal,
         WitMsgID       singleMsgID,
         WitMsgID       sparseMsgID,
         WitMsgID       denseMsgID)
   {
   bool vecWritten;
d464 2
a465 2
   if (theArgVec == defaultVal)
      return;
d467 1
a467 1
   myProblem ()->myDataWriter ()->writeFirstKeyWord (attrName);
d469 1
a469 1
   writeSingle (theArgVec, singleMsgID, vecWritten);
d471 2
a472 2
   if (vecWritten)
      return;
d474 1
a474 1
   writeSparse (theArgVec, defaultVal, sparseMsgID, vecWritten);
d476 2
a477 2
   if (vecWritten)
      return;
d479 2
a480 2
   writeDense (theArgVec, denseMsgID);
   }
d485 12
a496 12
      void WitVecWriter <ArgVec, ArgScal>::writeSingle (
         const ArgVec & theArgVec,
         WitMsgID       theMsgID,
         bool &         vecWritten)
   {
   WitPeriod thePer;

   vecWritten = false;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != theArgVec[0])
         return;
d498 1
a498 1
   myMsgFac () (theMsgID, theArgVec[0]);
d500 2
a501 2
   vecWritten = true;
   }
d506 33
a538 33
      void WitVecWriter <ArgVec, ArgScal>::writeSparse (
            const ArgVec & theArgVec,
            ArgScal        defaultVal,
            WitMsgID       theMsgID,
            bool &         vecWritten)
   {
   WitPeriod thePer;
   int       nNonDefaults; // # elements not at default value.
   bool      firstTime;

   vecWritten   = false;
   nNonDefaults = 0;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != defaultVal)
         {
         nNonDefaults ++;

         if (nNonDefaults >= nPeriods () / 2)
            return;
         }

   myMsgFac () ("startVectorWdMsg", "sparse");

   firstTime = true;

   forEachPeriod (thePer, myProblem ())
      if (theArgVec[thePer] != defaultVal)
         {
         myMsgFac () (theMsgID,
            (firstTime? "": " "),
            thePer,
            theArgVec[thePer]);
d540 2
a541 2
         firstTime = false;
         }
d543 1
a543 1
   myMsgFac () ("endVectorWdMsg");
d545 2
a546 2
   vecWritten = true;
   }
d551 12
a562 12
      void WitVecWriter <ArgVec, ArgScal>::writeDense (
         const ArgVec & theArgVec,
         WitMsgID       theMsgID)
   {
   WitPeriod thePer;

   myMsgFac () ("startVectorWdMsg", "dense");

   forEachPeriod (thePer, myProblem ())
      myMsgFac () (theMsgID,
         ((thePer == 0)? "": " "),
         theArgVec[thePer]);
d564 2
a565 2
   myMsgFac () ("endVectorWdMsg");
   }
@


1.57
log
@CPLEX Parameters
@
text
@d29 1
d343 2
@


1.56
log
@Revised the msg for writing a boolean scalar in writeData.
@
text
@d196 34
a229 1
void WitDataWriter::writeObjVec (
d231 2
a232 2
      const WitObjVec & theObjVec,
      double            defaultVal)
d234 2
a235 4
   if (not myOptComp ()->multiObjMode ())
      {
      writeVector (attrName, theObjVec.curDblFlexVec (), defaultVal);
      }
d240 1
a240 4
void WitDataWriter::writeDouble (
      const char * attrName,
      double       theValue,
      double       defaultVal)
a243 3
   if (theValue == defaultVal)
      return;

d256 1
a256 4
void WitDataWriter::writeInt (
      const char * attrName,
      int          theValue,
      int          defaultVal)
a257 3
   if (theValue == defaultVal)
      return;

d265 1
a265 4
void WitDataWriter::writeBool (
      const char * attrName,
      bool         theValue,
      bool         defaultVal)
a266 3
   if (theValue == defaultVal)
      return;

d276 1
a276 2
      const WitString & theValue,
      const char *      defaultVal)
a277 3
   if (theValue == defaultVal)
      return;

d284 13
@


1.55
log
@Fixed a bug:
   witWriteData was using upper case for true and false.
@
text
@d256 1
a256 1
   myMsgFac () ("boolWdMsg", theValue? "true": "false");
@


1.54
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d33 1
d303 5
d329 5
@


1.53
log
@Multi-objective mode
@
text
@d25 1
a25 1
#include <Global.h>
@


1.52
log
@Multi-Objective Mode
@
text
@d99 8
a106 1
   myMsgFac () ("stringWdMsg", withSlashes (theString));
d263 1
a263 1
      const WitString & defaultVal)
d303 1
a303 1
   writeStringValue        (RELEASE_NO);
d330 1
a330 1
const WitString & WitDataWriter::withSlashes (const WitString & theString)
d334 1
a334 1
   int  stringLength = theString.length ();
d338 1
a338 1
      if (isSpecial (theString[stringIndex]))
d346 1
a346 1
      return theString;
d353 1
a353 1
         // buffer_ may need to be twice the size of theString, but we resize
d360 1
a360 1
      if (isSpecial (theString[stringIndex]))
d363 1
a363 1
      buffer_[++ bufferIndex] = theString[stringIndex];
d368 1
a368 1
   return buffer_;
@


1.51
log
@Multi-Objective Mode
@
text
@d195 1
a195 1
      writeVector (attrName, theObjVec, defaultVal);
@


1.50
log
@Multi-Objective Mode
@
text
@d28 1
d188 13
@


1.49
log
@Multi-Objective Mode
@
text
@d299 1
a299 1
      myOptComp ()->myMultiObjMgr ()->writeObjVecs ();
@


1.48
log
@Multi-Objective Mode
@
text
@d26 2
d297 5
@


1.47
log
@Stochastic Implosion
@
text
@d37 1
a38 1

d87 1
a87 1
void WitDataWriter::writeIntValue (int i)
d89 1
a89 1
   myMsgFac () ("intWdMsg", i);
@


1.46
log
@Stochastic Implosion
@
text
@d39 1
d165 3
d260 1
a260 2
   int            saveMsgLen;
   WitComponent * theComp;
d283 1
a283 1
   forEachEl (theComp, myCompMgr ()->allComponents ())
d285 1
a285 1
         (theComp->writeSolnData) ();
d287 3
a289 1
         (theComp->writeData) ();
a399 3
   if (myStochImpMgr ()->skipWriteData (attrName))
      return;

@


1.45
log
@Stochastic Implosion
@
text
@a400 2
   myStochImpMgr ()->prepWriteVector ();

@


1.44
log
@Stochastic Implosion
@
text
@d21 1
a21 1
#include <OptImp.h>
@


1.43
log
@Stochastic Implosion
@
text
@d395 1
a395 1
   if (myStochImpMgr ()->skipVectorWrite ())
@


1.42
log
@Stochastic Implosion
@
text
@d27 1
a27 1
#include <StochMgr.h>
d288 1
a288 1
   myStochMgr ()->writeData ();
d395 1
a395 1
   if (myStochMgr ()->skipVectorWrite ())
d401 1
a401 1
   myStochMgr ()->prepWriteVector ();
@


1.41
log
@Stochastic Implosion
@
text
@d395 3
@


1.40
log
@Stochastic Implosion
@
text
@d398 1
a398 1
   myStochMgr ()->writingVector ();
@


1.39
log
@Stochastic Implosion
@
text
@d398 2
d402 1
a402 1
   vecWritten = writeSingle (theArgVec, singleMsgID);
d407 1
a407 1
   vecWritten = writeSparse (theArgVec, defaultVal, sparseMsgID);
d418 1
a418 1
      bool WitVecWriter <ArgVec, ArgScal>::writeSingle (
d420 2
a421 1
         WitMsgID       theMsgID)
d425 2
d429 1
a429 1
         return false;
d433 1
a433 1
   return true;
d439 5
a443 4
      bool WitVecWriter <ArgVec, ArgScal>::writeSparse (
         const ArgVec & theArgVec,
         ArgScal        defaultVal,
         WitMsgID       theMsgID)
d446 1
d449 2
a450 3
   int nNonDefaults = 0;
      //
      // # elements not at default value.
d454 6
a459 2
         if (++ nNonDefaults >= nPeriods () / 2)
            return false;
d478 1
a478 1
   return true;
@


1.38
log
@Stochastic Implosion
@
text
@d164 13
a176 18
   if (myProblem ()->myGlobalComp ()->highPrecisionWD ())
      theVecWriter.
         writeVector (
            attrName,
            theVector,
            defaultVal,
            "doubleSingleVectorHpWdMsg",
            "doubleSparseVectorHpWdMsg",
             "doubleDenseVectorHpWdMsg");
   else
      theVecWriter.
         writeVector (
            attrName,
            theVector,
            defaultVal,
            "doubleSingleVectorWdMsg",
            "doubleSparseVectorWdMsg",
             "doubleDenseVectorWdMsg");
d359 26
@


1.37
log
@Stochastic implosion.
@
text
@a185 29
void WitDataWriter::writeVectorUncond (
      const char *          attrName,
      const WitDblFlexVec & theVector,
      double                defaultVal)
   {
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem ());

   if (myProblem ()->myGlobalComp ()->highPrecisionWD ())
      theVecWriter.
         writeVectorUnCond (
            attrName,
            theVector,
            defaultVal,
            "doubleSingleVectorHpWdMsg",
            "doubleSparseVectorHpWdMsg",
             "doubleDenseVectorHpWdMsg");
   else
      theVecWriter.
         writeVectorUnCond (
            attrName,
            theVector,
            defaultVal,
            "doubleSingleVectorWdMsg",
            "doubleSparseVectorWdMsg",
             "doubleDenseVectorWdMsg");
   }

//------------------------------------------------------------------------------

d372 2
a376 22
   writeVectorUnCond (
      attrName,
      theArgVec,
      defaultVal,
      singleMsgID,
      sparseMsgID,
      denseMsgID);
   }

//------------------------------------------------------------------------------

template <typename ArgVec, typename ArgScal>
      void WitVecWriter <ArgVec, ArgScal>::writeVectorUnCond (
         const char *   attrName,
         const ArgVec & theArgVec,
         ArgScal        defaultVal,
         WitMsgID       singleMsgID,
         WitMsgID       sparseMsgID,
         WitMsgID       denseMsgID)
   {
   bool vecWritten;

@


1.36
log
@Stochastic implosion.
@
text
@d322 1
a322 1
   myProblem ()->myStochMgr ()->writeData ();
@


1.35
log
@App controlled opt implosion.
@
text
@d27 1
d322 2
@


1.34
log
@Updated the copyright date on all source files.
@
text
@d23 1
d292 1
a292 1
   myProblem ()->preprocess ();
@


1.33
log
@Vector Prop-Rt.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.32
log
@Tie Breaking Prop-Rt.
@
text
@d99 19
d122 1
a122 1
   WitVecWriter <WitTVec <int>, int> theVecWriter (myProblem (), true);
d124 8
a131 1
   theVecWriter.writeVector (attrName, theVector, defaultVal);
d141 1
a141 1
   WitVecWriter <WitFlexVec <int>, int> theVecWriter (myProblem (), true);
d143 8
a150 1
   theVecWriter.writeVector (attrName, theVector, defaultVal);
d160 1
a160 1
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem (), false);
d162 18
a179 1
   theVecWriter.writeVector (attrName, theVector, defaultVal);
d189 1
a189 1
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem (), false);
d191 18
a208 1
   theVecWriter.writeVector (attrName, theVector, defaultVal, true);
d218 1
a218 1
   WitMsgID  theMsgID;
d373 1
a373 3
      WitVecWriter <ArgVec, ArgScal>::WitVecWriter (
         WitProblem * theProblem,
         bool         intMsgsArg):
d375 1
a375 2
      WitProbAssoc (theProblem),
      intMsgs_     (intMsgsArg)
d393 26
a418 1
         bool           uncond)
a421 4
   if (not uncond)
      if (theArgVec == defaultVal)
         return;

d424 1
a424 1
   vecWritten = writeSingle (theArgVec);
d429 1
a429 1
   vecWritten = writeSparse (theArgVec, defaultVal);
d434 1
a434 1
   writeDense (theArgVec);
d441 2
a442 1
         const ArgVec & theArgVec)
a444 1
   WitMsgID  theMsgID;
a449 7
   theMsgID =
      intMsgs_?
         "intSingleVectorWdMsg":
         myProblem ()->myGlobalComp ()->highPrecisionWD ()?
            "doubleSingleVectorHpWdMsg":
            "doubleSingleVectorWdMsg";

d460 2
a461 1
         ArgScal        defaultVal)
a463 1
   WitMsgID  theMsgID;
a474 7
   theMsgID =
      intMsgs_?
         "intSparseVectorWdMsg":
         myProblem ()->myGlobalComp ()->highPrecisionWD ()?
            "doubleSparseVectorHpWdMsg":
            "doubleSparseVectorWdMsg";

d498 3
a500 1
      void WitVecWriter <ArgVec, ArgScal>::writeDense (const ArgVec & theArgVec)
a502 8
   WitMsgID  theMsgID;

   theMsgID =
      intMsgs_?
         "intDenseVectorWdMsg":
         myProblem ()->myGlobalComp ()->highPrecisionWD ()?
            "doubleDenseVectorHpWdMsg":
            "doubleDenseVectorWdMsg";
@


1.31
log
@Double Precision.
@
text
@d25 1
a25 1
#include <PipSysMgr.h>
d251 1
a251 1
   myProblem ()->myPipSysMgr ()->writeShipSeqData ();
@


1.30
log
@Double Precision.
@
text
@a122 12
      const char *            attrName,
      const WitTVec <float> & theVector,
      float                   defaultVal)
   {
   WitVecWriter <WitTVec <float>, float> theVecWriter (myProblem (), false);

   theVecWriter.writeVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
d137 1
a137 1
      float                 defaultVal)
d139 1
a139 1
   WitVecWriter <WitDblFlexVec, float> theVecWriter (myProblem (), false);
@


1.29
log
@Double Precision.
@
text
@d24 1
d103 1
a103 1
   WitVecWriter <WitTVec <int>, int> theVecWriter (myProblem (), false);
d115 1
a115 1
   WitVecWriter <WitFlexVec <int>, int> theVecWriter (myProblem (), false);
d127 1
a127 1
   WitVecWriter <WitTVec <float>, float> theVecWriter (myProblem (), true);
d139 1
a139 1
   WitVecWriter <WitDblFlexVec, double> theVecWriter (myProblem (), true);
d151 1
a151 1
   WitVecWriter <WitDblFlexVec, float> theVecWriter (myProblem (), true);
d163 2
d170 6
a175 1
   myMsgFac () ("floatWdMsg", theValue);
d320 1
a320 1
         bool         floatMsgsArg):
d323 1
a323 1
      floatMsgs_   (floatMsgsArg)
d378 5
a382 3
      floatMsgs_?
         "floatSingleVectorWdMsg":
           "intSingleVectorWdMsg";
d410 5
a414 3
      floatMsgs_?
         "floatSparseVectorWdMsg":
           "intSparseVectorWdMsg";
d445 5
a449 3
      floatMsgs_?
         "floatDenseVectorWdMsg":
           "intDenseVectorWdMsg";
@


1.28
log
@Double Precision.
@
text
@d134 3
a136 3
      const char *                attrName,
      const WitFlexVec <double> & theVector,
      double                      defaultVal)
d138 1
a138 1
   WitVecWriter <WitFlexVec <double>, double> theVecWriter (myProblem (), true);
d146 3
a148 3
      const char *                attrName,
      const WitFlexVec <double> & theVector,
      float                       defaultVal)
d150 1
a150 1
   WitVecWriter <WitFlexVec <double>, float> theVecWriter (myProblem (), true);
@


1.27
log
@Double Precision.
@
text
@a133 12
      const char *               attrName,
      const WitFlexVec <float> & theVector,
      float                      defaultVal)
   {
   WitVecWriter <WitFlexVec <float>, float> theVecWriter (myProblem (), true);

   theVecWriter.writeVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
@


1.26
log
@Double Precision.
@
text
@d25 1
a25 1
#include <RealVec.h>
a156 12
void WitDataWriter::writeVector (
      const char *       attrName,
      const WitRealVec & theVector,
      double             defaultVal)
   {
   WitVecWriter <WitRealVec, double> theVecWriter (myProblem (), true);

   theVecWriter.writeVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

d158 3
a160 3
      const char *       attrName,
      const WitRealVec & theVector,
      float              defaultVal)
d162 1
a162 1
   WitVecWriter <WitRealVec, float> theVecWriter (myProblem (), true);
@


1.25
log
@Double Precision.
@
text
@d158 3
a160 3
      const char *          attrName,
      const WitFltRealVec & theVector,
      double                defaultVal)
d162 1
a162 25
   WitVecWriter <WitFltRealVec, double> theVecWriter (myProblem (), true);

   theVecWriter.writeVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *          attrName,
      const WitDblRealVec & theVector,
      double                defaultVal)
   {
   WitVecWriter <WitDblRealVec, double> theVecWriter (myProblem (), true);

   theVecWriter.writeVector (attrName, theVector, defaultVal);
   }

//------------------------------------------------------------------------------

void WitDataWriter::writeVector (
      const char *          attrName,
      const WitFltRealTVc & theVector,
      double                defaultVal)
   {
   WitVecWriter <WitFltRealTVc, double> theVecWriter (myProblem (), true);
@


1.24
log
@Double Precision.
@
text
@d158 3
a160 3
      const char *       attrName,
      const WitRealVec & theVector,
      double             defaultVal)
d162 25
a186 1
   WitVecWriter <WitRealVec, double> theVecWriter (myProblem (), true);
@


1.23
log
@Double Precision.
@
text
@d170 3
a172 3
      const char *               attrName,
      const WitFlexVec <float> & theVector,
      float                      defaultVal)
d174 1
a174 1
   WitVecWriter <WitFlexVec <float>, float> theVecWriter (myProblem (), true);
@


1.22
log
@Continued double precision.
@
text
@d25 1
a25 1
#include <FlexVec.h>
d151 12
@


1.21
log
@Continued double precision.
@
text
@d169 1
a169 1
void WitDataWriter::writeStrDbl (
d171 2
a172 2
      StrDbl       theValue,
      StrDbl       defaultVal)
@


1.20
log
@Continued double precision.
@
text
@a168 15
void WitDataWriter::writeFloat (
      const char * attrName,
      float        theValue,
      float        defaultVal)
   {
   if (theValue == defaultVal)
      return;

   writeFirstKeyWord (attrName);

   myMsgFac () ("floatWdMsg", theValue);
   }

//------------------------------------------------------------------------------

@


1.19
log
@Continued double precision.
@
text
@d184 1
a184 1
void WitDataWriter::writeDouble (
d186 2
a187 2
      double       theValue,
      double       defaultVal)
@


1.18
log
@Continued implementation of PIP.
@
text
@d184 15
@


1.17
log
@Continued implementation of PIP.
@
text
@d13 4
a16 1
// Contains the implementation of class DataWriter.
d20 1
d30 2
d97 72
a274 128
// Macro implementWriteFuncs (TheVecClass, TheType)
//
// Implements the following functions:
//
//   writeVector       (const char *,        const WitTVec <float> &, TheType);
//   writeVectorUncond (const char *,        const WitTVec <float> &, TheType);
//   writeSingle       (const TheVecClass &)
//   writeSparse       (const TheVecClass,   TheType)
//   writeDense        (const TheVecClass &)
//  
// where TheVecClass is a class of vectors of TheType.
//------------------------------------------------------------------------------

#define implementWriteFuncs(TheVecClass, TheType)                              \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitDataWriter::writeVector (                                              \
      const char *        attrName,                                            \
      const TheVecClass & theVector,                                           \
      TheType             defaultVal)                                          \
   {                                                                           \
   if (theVector == defaultVal)                                                \
      return;                                                                  \
                                                                               \
   writeVectorUncond (attrName, theVector, defaultVal);                        \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitDataWriter::writeVectorUncond (                                        \
      const char *        attrName,                                            \
      const TheVecClass & theVector,                                           \
      TheType             defaultVal)                                          \
   {                                                                           \
   writeFirstKeyWord (attrName);                                               \
                                                                               \
   if (writeSingle (theVector))                                                \
      return;                                                                  \
                                                                               \
   if (writeSparse (theVector, defaultVal))                                    \
      return;                                                                  \
                                                                               \
   writeDense (theVector);                                                     \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
bool WitDataWriter::writeSingle (const TheVecClass & theVector)                \
   {                                                                           \
   WitPeriod t;                                                                \
                                                                               \
   forEachPeriod (t, myProblem ())                                             \
      if (theVector[t] != theVector[0])                                        \
         return false;                                                         \
                                                                               \
   myMsgFac () (#TheType "SingleVectorWdMsg", theVector[0]);                   \
                                                                               \
   return true;                                                                \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
bool WitDataWriter::writeSparse (                                              \
      const TheVecClass & theVector,                                           \
      TheType             defaultVal)                                          \
   {                                                                           \
   WitPeriod t;                                                                \
   bool      firstTime;                                                        \
                                                                               \
   int nNonDefaults = 0;                                                       \
      /*                                                                     */\
      /* # elements not at default value.                                    */\
                                                                               \
   forEachPeriod (t, myProblem ())                                             \
      if (theVector[t] != defaultVal)                                          \
         if (++ nNonDefaults >= nPeriods () / 2)                               \
            return false;                                                      \
                                                                               \
   myMsgFac () ("startVectorWdMsg", "sparse");                                 \
                                                                               \
   firstTime = true;                                                           \
                                                                               \
   forEachPeriod (t, myProblem ())                                             \
      if (theVector[t] != defaultVal)                                          \
         {                                                                     \
         myMsgFac () (#TheType "SparseVectorWdMsg",                            \
            (firstTime? "": " "),                                              \
            t,                                                                 \
            theVector[t]);                                                     \
                                                                               \
         firstTime = false;                                                    \
         }                                                                     \
                                                                               \
   myMsgFac () ("endVectorWdMsg");                                             \
                                                                               \
   return true;                                                                \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitDataWriter::writeDense (const TheVecClass & theVector)                 \
   {                                                                           \
   WitPeriod t;                                                                \
                                                                               \
   myMsgFac () ("startVectorWdMsg", "dense");                                  \
                                                                               \
   forEachPeriod (t, myProblem ())                                             \
      myMsgFac () (#TheType "DenseVectorWdMsg",                                \
         ((t == 0)? "": " "),                                                  \
         theVector[t]);                                                        \
                                                                               \
   myMsgFac () ("endVectorWdMsg");                                             \
   }                                                                           \

//------------------------------------------------------------------------------
// Calls to macro implementWriteFuncs.
//------------------------------------------------------------------------------

implementWriteFuncs (WitTVec    <float>,  float)
implementWriteFuncs (WitFlexVec <float>,  float)

implementWriteFuncs (WitFlexVec <double>, double)

implementWriteFuncs (WitTVec    <int>,    int)
implementWriteFuncs (WitFlexVec <int>,    int)

//------------------------------------------------------------------------------
d315 142
@


1.16
log
@Continued implementation of PIP.
@
text
@d20 1
d188 2
@


1.15
log
@Continued implementation of post-implosion pegging.
@
text
@d43 1
a43 1
   writeData (fileName, & WitComponent::writeData);
d151 1
a151 1
   writeData (fileName, & WitComponent::writeSolnData);
d156 1
a156 3
void WitDataWriter::writeData (
      const char *           fileName,
      void (WitComponent::* writeDataFunc) ())
d158 1
d172 1
a172 1
   const int saveMsgLen = myMsgFac ().lineLength ();
d183 4
a186 1
      (theComp->*writeDataFunc) ();
@


1.14
log
@Continued implementation of opt with COIN.
@
text
@a22 1
#include <FlexVecI.h>
@


1.13
log
@Internal changes.
@
text
@d165 1
a165 1
   WitTimingEvent theEvent ("extra");
d188 2
@


1.12
log
@Internal changes.
@
text
@d335 1
a335 1
   if (! specialFound)
@


1.11
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d121 1
a121 1
void WitDataWriter::writeBoolean (
d123 2
a124 2
      WitBoolean   theValue,
      WitBoolean   defaultVal)
d131 1
a131 4
   myMsgFac () ("booleanWdMsg",
      theValue?
         "true":
         "false");
d239 1
a239 1
WitBoolean WitDataWriter::writeSingle (const TheVecClass & theVector)          \
d245 1
a245 1
         return witFALSE;                                                      \
d249 1
a249 1
   return witTRUE;                                                             \
d254 1
a254 1
WitBoolean WitDataWriter::writeSparse (                                        \
d259 1
a259 1
   WitBoolean firstTime;                                                       \
d268 1
a268 1
            return witFALSE;                                                   \
d272 1
a272 1
   firstTime = witTRUE;                                                        \
d282 1
a282 1
         firstTime = witFALSE;                                                 \
d287 1
a287 1
   return witTRUE;                                                             \
d322 4
a325 4
   int        stringIndex;
   int        bufferIndex;
   int        stringLength = theString.length ();
   WitBoolean specialFound = witFALSE;
d330 1
a330 1
         specialFound = witTRUE;
@


1.10
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
@


1.9
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d20 1
@


1.8
log
@More minor changes for vacpp.

The compiler complains if member functions are passed without an ampersand:

1589c1589
<          WitRun::witSetOperationYield,
---
>          &WitRun::witSetOperationYield,

It complains if "friend" declarations don't also have the word "class":
diff -r1.1 MsgFrag.h
39,40c39,40
<       friend WitMsgArg;
<       friend WitMsgFacility;
---
>       friend class WitMsgArg;
>       friend class WitMsgFacility;

It now can't figure out that a statement after a loop may not be executed!
diff -r1.70 BuildAhd.C
575a576
>    return NULL; // unreachable, but compiler complains


It also complained about missing "template<>" in many cases,
but since this seems odd, we are just suppressing the message for now
(see config/p_power64v5).  This is an example of a change that was NOT
made, but (presumably) would have to be to avoid the compiler warning.
diff -r1.47 ConsMR.C
180a181
> template<>
@
text
@d42 1
a42 1
   writeData (fileName, &WitComponent::writeData);
d153 1
a153 1
   writeData (fileName, &WitComponent::writeSolnData);
@


1.7
log
@Continued implementation of single-source.
@
text
@d42 1
a42 1
   writeData (fileName, WitComponent::writeData);
d153 1
a153 1
   writeData (fileName, WitComponent::writeSolnData);
@


1.6
log
@Preliminary work on single source.
@
text
@d20 1
d28 1
a28 1
      buffer_      (* new WitString)
a35 1
   delete & buffer_;
@


1.5
log
@Continued preliminary work on single source.
@
text
@d312 1
a312 1
implementWriteFuncs (WitFlexVec (float),  float)
d314 1
a314 1
implementWriteFuncs (WitFlexVec (double), double)
d317 1
a317 1
implementWriteFuncs (WitFlexVec (int),    int)
@


1.4
log
@Began implementation of object iteration.
@
text
@d196 2
a197 2
//   writeVector       (const char *,        const WitTVec (float) &, TheType);
//   writeVectorUncond (const char *,        const WitTVec (float) &, TheType);
d311 1
a311 1
implementWriteFuncs (WitTVec    (float),  float)
d316 1
a316 1
implementWriteFuncs (WitTVec    (int),    int)
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d20 1
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d310 2
a311 2
implementWriteFuncs (WitTVec    (float), float)
implementWriteFuncs (WitFlexVec (float), float)
d313 4
a316 2
implementWriteFuncs (WitTVec    (int),   int)
implementWriteFuncs (WitFlexVec (int),   int)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.47;
access;
symbols
	sce_5_01_20080919:1.44
	latest_sce_4_20_20060523:1.44.0.2
	sce_4_20_20060523:1.44
	latest_sce4_20_OSL:1.43.0.2
	sce_4_20_OSL:1.43
	sce_410_withVa:1.39
	sce_4_05_20040511:1.37
	sce_4_00_20040201:1.27
	nextGenBranch:1.23.0.2
	nextGenRoot:1.23
	sce_3_30_20030627:1.23
	EndRw-branch:1.19.0.4
	Root-of-EndRw:1.19
	rwToStl:1.19.0.2
	latest_sce_3_10_20010924:1.13.0.2
	sce_3_10_20010924:1.13
	latest_sce_3_00_20010601:1.12.0.2
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.6.0.2
	sce_2_31_20001003:1.6
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2011.09.28.23.50.40;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.24.00.28.56;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.08.30.20.18.23;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.21.15.44.15;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.17.17.07.18;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.18.23.20.06;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.22.14.59.51;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.06.19.47.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.19.22.00.53;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.16.22.39.28;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.04.22.05.10;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.04.16.44.30;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.11.18.37.27;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.16.16.18.03;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.15.21.01.26;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.13.22.22.15;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.22.18.55;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.25.15.15.23;	author rwToStl;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.14.16.09.50;	author rjw;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.05.08.19.21.57;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.23.16.43;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.03.19.58.30;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.02.20.53.17;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.14.02.47;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.17.20.49.21;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.25.14.53.29;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.20.00.44.23;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.06.19.58.42;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.04.22.07.39;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.22.23.11.50;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.20.03.29;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.21.22.47;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.18.00.16.01;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.16.57.09;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.21.56.00;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.19.2.1
date	2002.11.08.16.11.33;	author rwToStl;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef VectorH
#define VectorH

//------------------------------------------------------------------------------
// Header file: "Vector.h"
//
// Contains the declaration of class template Vector <Elem>.
//------------------------------------------------------------------------------

#include <Util.h>

//------------------------------------------------------------------------------
// Class template Vector <Elem>
//
// A Vector whose elements are instances of Elem.
// The elements are stored and retrieved by value.
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

template <typename Elem> 
      class WitVector
   {
   public:

      //-----------------------------------------------------------------------
      // Constructor functions.
      //-----------------------------------------------------------------------

      WitVector ();
         //
         // Constructs an instance with 0 elements.

      WitVector (int nElems, Elem initValue);

         // Constructs an instance with nElems elements, each of which is
         // initialized to initValue.

      //-----------------------------------------------------------------------
      // Destructor function.
      //-----------------------------------------------------------------------

      ~WitVector ();

      //-----------------------------------------------------------------------
      // Other public member functions.
      //-----------------------------------------------------------------------

      void operator = (const WitVector &);
      void operator = (Elem);
      void operator = (const Elem *);
         //
         // Assignment operators.

      void copyInto (Elem * theCVec) const;
         //
         // Copies the elements of this Vector into the corresponding
         // elements of theCVec.
         // The length of theCVec is assumed match that of this Vector, but
         // this assumption cannot be verified.

      void clear ();
         //
         // Resizes this Vector to 0 elements.

      void resize (int nElems, Elem theScalar);
         //
         // Resizes this Vector to nElems elements.
         // The elements are all set to theScalar.

      void resize (int nElems);
         //
         // Resizes this WitVector to nElems elements.
         // The elements have undefined value.

      bool operator == (Elem theScalar) const;
         //
         // Returns true iff every element of this Vector == theScalar.

      inline bool isAllocated () const;

      inline Elem operator [] (int theIdx) const;
         //
         // Returns the indexed element of this Vector.
         // Bounds checking is performed (by WIT), iff the compile is in
         // DEBUG  mode.
         // Returned value is not an lvalue.

      inline Elem & operator [] (int theIdx);
         //
         // Same as the preceeding operator [], except that this Vector is
         // non-const and the returned value is an lvalue.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const Elem *, myCVec)
      accessFunc (int,          length)

      inline Elem * myCVecForUpdate ();
         //
         // Same as myCVec (), but returns non-const.
         // Use with discretion.

   private:

      //-----------------------------------------------------------------------
      // Private member functions.
      //-----------------------------------------------------------------------

      void checkBounds (int theIdx) const;
         //
         // Verifies that theIdx is within the bounds of this Vector.

      noCopyCtor (WitVector);

      //-----------------------------------------------------------------------
      // Private member data.
      //-----------------------------------------------------------------------

      Elem * myCVec_;
         //
         // The C style vector which stores the data for this Vector.

      int length_;
         //
         // The # of elements stored by this Vector.
   };

//------------------------------------------------------------------------------
// Implementation of inline functions of class template Vector <Elem>
//------------------------------------------------------------------------------

template <typename Elem> 
      inline bool WitVector <Elem>::isAllocated () const
   {
   return (length_ > 0);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline Elem WitVector <Elem>::operator [] (int theIdx) const
   {
   ifDebug (checkBounds (theIdx));

   return myCVec_[theIdx];
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline Elem & WitVector <Elem>::operator [] (int theIdx)
   {
   ifDebug (checkBounds (theIdx));

   return myCVec_[theIdx];
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      Elem * WitVector <Elem>::myCVecForUpdate ()
   {
   return myCVec_;
   }

//------------------------------------------------------------------------------
// NonClass functions with arguments belonging to specific Vector classes.
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   bool operator >= (const WitVector <double> & theVector, double theScalar);
      //
      // Returns true, iff each element of theVector >= theScalar.

   template <typename Elem> 
         void copy (Elem * dstCVec, const Elem * srcCVec, int nElems);
      //
      // Copies the elements of srcCVec into dstCVec.
      // nElems is the # of elements in each vector.

   template <typename Elem> 
         bool hasSingleValue (const Elem * theCVec, int nElems);
      //
      // Returns true, iff all the elements of theCVec have the same value.
      // theCVec is assumed to have length == nElems.
   };

#endif
@


1.46
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.45
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d30 109
a138 109
template <typename Elem>
class WitVector
{
public:

//-----------------------------------------------------------------------
// Constructor functions.
//-----------------------------------------------------------------------

WitVector ();
//
// Constructs an instance with 0 elements.

WitVector (int nElems, Elem initValue);

// Constructs an instance with nElems elements, each of which is
// initialized to initValue.

//-----------------------------------------------------------------------
// Destructor function.
//-----------------------------------------------------------------------

~WitVector ();

//-----------------------------------------------------------------------
// Other public member functions.
//-----------------------------------------------------------------------

void operator = (const WitVector &);
void operator = (Elem);
void operator = (const Elem *);
//
// Assignment operators.

void copyInto (Elem * theCVec) const;
//
// Copies the elements of this Vector into the corresponding
// elements of theCVec.
// The length of theCVec is assumed match that of this Vector, but
// this assumption cannot be verified.

void clear ();
//
// Resizes this Vector to 0 elements.

void resize (int nElems, Elem theScalar);
//
// Resizes this Vector to nElems elements.
// The elements are all set to theScalar.

void resize (int nElems);
//
// Resizes this WitVector to nElems elements.
// The elements have undefined value.

bool operator == (Elem theScalar) const;
//
// Returns true iff every element of this Vector == theScalar.

inline bool isAllocated () const;

inline Elem operator [] (int theIdx) const;
//
// Returns the indexed element of this Vector.
// Bounds checking is performed (by WIT), iff the compile is in
// DEBUG  mode.
// Returned value is not an lvalue.

inline Elem & operator [] (int theIdx);
//
// Same as the preceeding operator [], except that this Vector is
// non-const and the returned value is an lvalue.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (const Elem *, myCVec)
accessFunc (int,          length)

inline Elem * myCVecForUpdate ();
//
// Same as myCVec (), but returns non-const.
// Use with discretion.

private:

//-----------------------------------------------------------------------
// Private member functions.
//-----------------------------------------------------------------------

void checkBounds (int theIdx) const;
//
// Verifies that theIdx is within the bounds of this Vector.

noCopyCtor (WitVector);

//-----------------------------------------------------------------------
// Private member data.
//-----------------------------------------------------------------------

Elem * myCVec_;
//
// The C style vector which stores the data for this Vector.

int length_;
//
// The # of elements stored by this Vector.
};
d144 5
a148 5
template <typename Elem>
inline bool WitVector <Elem>::isAllocated () const
{
return (length_ > 0);
}
d152 4
a155 4
template <typename Elem>
inline Elem WitVector <Elem>::operator [] (int theIdx) const
{
ifDebug (checkBounds (theIdx));
d157 2
a158 2
return myCVec_[theIdx];
}
d162 4
a165 4
template <typename Elem>
inline Elem & WitVector <Elem>::operator [] (int theIdx)
{
ifDebug (checkBounds (theIdx));
d167 2
a168 2
return myCVec_[theIdx];
}
d172 5
a176 5
template <typename Elem>
Elem * WitVector <Elem>::myCVecForUpdate ()
{
return myCVec_;
}
d183 17
a199 17
{
bool operator >= (const WitVector <double> & theVector, double theScalar);
//
// Returns true, iff each element of theVector >= theScalar.

template <typename Elem>
void copy (Elem * dstCVec, const Elem * srcCVec, int nElems);
//
// Copies the elements of srcCVec into dstCVec.
// nElems is the # of elements in each vector.

template <typename Elem>
bool hasSingleValue (const Elem * theCVec, int nElems);
//
// Returns true, iff all the elements of theCVec have the same value.
// theCVec is assumed to have length == nElems.
};
@


1.44
log
@Updated the copyright date on all source files.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d30 109
a138 109
template <typename Elem> 
      class WitVector
   {
   public:

      //-----------------------------------------------------------------------
      // Constructor functions.
      //-----------------------------------------------------------------------

      WitVector ();
         //
         // Constructs an instance with 0 elements.

      WitVector (int nElems, Elem initValue);

         // Constructs an instance with nElems elements, each of which is
         // initialized to initValue.

      //-----------------------------------------------------------------------
      // Destructor function.
      //-----------------------------------------------------------------------

      ~WitVector ();

      //-----------------------------------------------------------------------
      // Other public member functions.
      //-----------------------------------------------------------------------

      void operator = (const WitVector &);
      void operator = (Elem);
      void operator = (const Elem *);
         //
         // Assignment operators.

      void copyInto (Elem * theCVec) const;
         //
         // Copies the elements of this Vector into the corresponding
         // elements of theCVec.
         // The length of theCVec is assumed match that of this Vector, but
         // this assumption cannot be verified.

      void clear ();
         //
         // Resizes this Vector to 0 elements.

      void resize (int nElems, Elem theScalar);
         //
         // Resizes this Vector to nElems elements.
         // The elements are all set to theScalar.

      void resize (int nElems);
         //
         // Resizes this WitVector to nElems elements.
         // The elements have undefined value.

      bool operator == (Elem theScalar) const;
         //
         // Returns true iff every element of this Vector == theScalar.

      inline bool isAllocated () const;

      inline Elem operator [] (int theIdx) const;
         //
         // Returns the indexed element of this Vector.
         // Bounds checking is performed (by WIT), iff the compile is in
         // DEBUG  mode.
         // Returned value is not an lvalue.

      inline Elem & operator [] (int theIdx);
         //
         // Same as the preceeding operator [], except that this Vector is
         // non-const and the returned value is an lvalue.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const Elem *, myCVec)
      accessFunc (int,          length)

      inline Elem * myCVecForUpdate ();
         //
         // Same as myCVec (), but returns non-const.
         // Use with discretion.

   private:

      //-----------------------------------------------------------------------
      // Private member functions.
      //-----------------------------------------------------------------------

      void checkBounds (int theIdx) const;
         //
         // Verifies that theIdx is within the bounds of this Vector.

      noCopyCtor (WitVector);

      //-----------------------------------------------------------------------
      // Private member data.
      //-----------------------------------------------------------------------

      Elem * myCVec_;
         //
         // The C style vector which stores the data for this Vector.

      int length_;
         //
         // The # of elements stored by this Vector.
   };
d144 5
a148 5
template <typename Elem> 
      inline bool WitVector <Elem>::isAllocated () const
   {
   return (length_ > 0);
   }
d152 4
a155 4
template <typename Elem> 
      inline Elem WitVector <Elem>::operator [] (int theIdx) const
   {
   ifDebug (checkBounds (theIdx));
d157 2
a158 2
   return myCVec_[theIdx];
   }
d162 4
a165 4
template <typename Elem> 
      inline Elem & WitVector <Elem>::operator [] (int theIdx)
   {
   ifDebug (checkBounds (theIdx));
d167 2
a168 2
   return myCVec_[theIdx];
   }
d172 5
a176 5
template <typename Elem> 
      Elem * WitVector <Elem>::myCVecForUpdate ()
   {
   return myCVec_;
   }
d183 17
a199 17
   {
   bool operator >= (const WitVector <double> & theVector, double theScalar);
      //
      // Returns true, iff each element of theVector >= theScalar.

   template <typename Elem> 
         void copy (Elem * dstCVec, const Elem * srcCVec, int nElems);
      //
      // Copies the elements of srcCVec into dstCVec.
      // nElems is the # of elements in each vector.

   template <typename Elem> 
         bool hasSingleValue (const Elem * theCVec, int nElems);
      //
      // Returns true, iff all the elements of theCVec have the same value.
      // theCVec is assumed to have length == nElems.
   };
@


1.43
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.42
log
@[shared-resource pegging]
@
text
@d43 1
a43 1
      WitVector (WitSiz nElems, Elem initValue);
d75 1
a75 1
      void resize (WitSiz nElems, Elem theScalar);
d80 1
a80 1
      void resize (WitSiz nElems);
d108 1
a108 1
      accessFunc (WitSiz,       length)
d135 1
a135 1
      WitSiz length_;
@


1.41
log
@[shared-resource pegging]
@
text
@d43 1
a43 1
      WitVector (size_t nElems, Elem initValue);
d75 1
a75 1
      void resize (size_t nElems, Elem theScalar);
d80 1
a80 1
      void resize (size_t nElems);
d108 1
a108 1
      accessFunc (size_t,       length)
d135 1
a135 1
      size_t length_;
@


1.40
log
@[multi-thread]
@
text
@d108 1
a108 1
      accessFunc (size_t,          length)
@


1.39
log
@[multi-thread]
@
text
@d16 1
a16 1
// Contains the declaration of class template Vector <TheType>.
d22 1
a22 1
// Class template Vector <TheType>
d24 1
a24 1
// A Vector whose elements are instances of TheType.
d30 1
a30 1
template <typename TheType> 
d43 1
a43 1
      WitVector (size_t nElems, TheType initValue);
d59 2
a60 2
      void operator = (TheType);
      void operator = (const TheType *);
d64 1
a64 1
      void copyInto (TheType * theCVec) const;
d75 1
a75 1
      void resize (size_t nElems, TheType theScalar);
d85 1
a85 1
      bool operator == (TheType theScalar) const;
d91 1
a91 1
      inline TheType operator [] (int theIdx) const;
d98 1
a98 1
      inline TheType & operator [] (int theIdx);
d107 1
a107 1
      accessFunc (const TheType *, myCVec)
d110 1
a110 1
      inline TheType * myCVecForUpdate ();
d131 1
a131 1
      TheType * myCVec_;
d141 1
a141 1
// Implementation of inline functions of class template Vector <TheType>
d144 2
a145 2
template <typename TheType> 
      inline bool WitVector <TheType>::isAllocated () const
d152 2
a153 2
template <typename TheType> 
      inline TheType WitVector <TheType>::operator [] (int theIdx) const
d162 2
a163 2
template <typename TheType> 
      inline TheType & WitVector <TheType>::operator [] (int theIdx)
d172 2
a173 2
template <typename TheType> 
      TheType * WitVector <TheType>::myCVecForUpdate ()
d188 2
a189 2
   template <typename TheType> 
         void copy (TheType * dstCVec, const TheType * srcCVec, int nElems);
d194 2
a195 2
   template <typename TheType> 
         bool hasSingleValue (const TheType * theCVec, int nElems);
@


1.38
log
@[multi-threads]
@
text
@d183 4
a186 1
{
d188 5
a192 3
bool operator >= (const WitVector <double> & theVector, double theScalar);
   //
   // Returns true, iff each element of theVector >= theScalar.
d194 6
a199 15
template <typename TheType> 
      void copy (TheType * dstCVec, const TheType * srcCVec, int nElems);
   //
   // Copies the elements of srcCVec into dstCVec.
   // nElems is the # of elements in each vector.

template <typename TheType> 
      bool hasSingleValue (const TheType * theCVec, int nElems);
   //
   // Returns true, iff all the elements of theCVec have the same value.
   // theCVec is assumed to have length == nElems.

};
   //
   // Leaving namespace NonClass.
@


1.37
log
@Double Precision.
@
text
@a200 1
// Leaving namespace NonClass.
d202 2
@


1.36
log
@Double Precision.
@
text
@a184 1
bool operator >= (const WitVector <float> &  theVector, float  theScalar);
a187 16

void copy (WitVector <double> &, const WitVector <float> &);
void copy (WitVector <double> &, const float *);
void copy (double *,             const WitVector <float> &);
void copy (WitVector <float> &,  const WitVector <double> &);
void copy (WitVector <float> &,  const double *);
void copy (float *,              const WitVector <double> &);
   //
   // Each of these functions copies the elements of the 2nd argument
   // into the corresponding elements of the 1st argument.

void copy (double *, const float *,  int);
void copy (float *,  const double *, int);
   //
   // copy functions for two CVec args.
   // The 3rd arg is the # of elements in each vector.
@


1.35
log
@Double Precision.
@
text
@d64 1
a64 1
      void convCopyInto (TheType * theCVec) const;
d190 6
a195 6
void convCopy (WitVector <double> &, const WitVector <float> &);
void convCopy (WitVector <double> &, const float *);
void convCopy (double *,             const WitVector <float> &);
void convCopy (WitVector <float> &,  const WitVector <double> &);
void convCopy (WitVector <float> &,  const double *);
void convCopy (float *,              const WitVector <double> &);
a196 1
   // "Convert Copy"
d200 2
a201 2
void convCopy (double *, const float *,  int);
void convCopy (float *,  const double *, int);
d203 1
a203 1
   // convCopy functions for two CVec args.
@


1.34
log
@Double Precision.
@
text
@d58 3
a60 1
      void setToScalar (TheType theValue);
d62 1
a62 14
         // Sets all elements of this Vector to theValue.

      void operator = (const WitVector & theVector);
         //
         // Copies the elements of theVector into the corresponding elements of
         // this Vector.
         // The length of theVector must match that of this Vector.

      void convCopy (const TheType * theCVec);
         //
         // Copies the elements of theCVec into the corresponding elements of
         // this Vector.
         // The length of theCVec is assumed match that of this Vector, but
         // this assumption cannot be verified.
d75 1
a75 1
      void resize (size_t nElems, TheType theValue);
d78 1
a78 1
         // The elements are all set to theValue.
d85 1
a85 1
      bool operator == (TheType theValue) const;
d87 1
a87 1
         // Returns true iff every element of this Vector == theValue.
d185 2
a186 2
bool operator >= (const WitVector <float> &  theVector, float  theValue);
bool operator >= (const WitVector <double> & theVector, double theValue);
d188 1
a188 1
   // Returns true, iff each element of theVector >= theValue.
d197 1
a197 1
   // "Convert-Copy"
@


1.33
log
@Double Precision.
@
text
@d62 1
a62 1
      void copy (const WitVector & theVector);
d136 1
a136 1
      noCopyCtorAssign (WitVector);
@


1.32
log
@Double Precision.
@
text
@a131 7
      void copyCVecIntoCVec (TheType * dstCVec, const TheType * srcCVec) const;
         //
         // Copies the elements of srcCVec into the corresponding elements of
         // dstCVec.
         // The length of dstCVector and of srcCVector are both assumed to match
         // that of this Vector, but this assumption cannot be verified.

d216 13
a228 1
   // The 3rd arg is the length of the two CVecs.
@


1.31
log
@Double Precision.
@
text
@d208 1
d210 1
a210 1
void convCopy (WitVector <double> &, const WitVector <float> &);
d212 2
d218 6
@


1.30
log
@Double Precision.
@
text
@a21 16
// Namespace VectorUtil.
//
// Functions used by class template Vector <TheType>.
//------------------------------------------------------------------------------

namespace WitVectorUtil
{

void checkBounds (int theIdx, size_t lengthVal);
   //
   // Verifies that theIdx is within the bounds of a Vector of length lengthVal.

// Leaving namespace NonClass.
};

//------------------------------------------------------------------------------
d27 1
a27 1
// All implementation is inline.
d39 1
a39 1
      inline WitVector ();
d43 1
a43 1
      inline WitVector (size_t nElems, TheType initValue);
d52 1
a52 1
      inline ~WitVector ();
d58 1
a58 1
      inline void setToScalar (TheType theValue);
d62 1
a62 1
      inline void copy (const WitVector & theVector);
d68 1
a68 1
      inline void convCopy (const TheType * theCVec);
d75 1
a75 1
      inline void convCopyInto (TheType * theCVec) const;
d82 1
a82 1
      inline void clear ();
d86 1
a86 1
      inline void resize (size_t nElems, TheType theValue);
d91 1
a91 1
      inline void resize (size_t nElems);
d96 1
a96 1
      inline bool operator == (TheType theValue) const;
d132 1
a132 4
      inline void copyCVecIntoCVec (
                  TheType * dstCVec, 
            const TheType * srcCVec)
            const;
d139 4
d159 1
a159 108
// Implementation of class template Vector <TheType>
//------------------------------------------------------------------------------

template <typename TheType> 
      inline WitVector <TheType>::WitVector ():
         myCVec_ (NULL),
         length_ (0)
   {
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline WitVector <TheType>::WitVector (size_t nElems, TheType initValue):
         myCVec_ (NULL),
         length_ (0)
   {
   resize (nElems, initValue);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline WitVector <TheType>::~WitVector ()
   {
   delete[] myCVec_;
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::setToScalar (TheType theValue)
   {
   size_t theIdx;

   for (theIdx = 0; theIdx < length_; theIdx ++)
      myCVec_[theIdx] = theValue;
   }  

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::copy (const WitVector & theVector)
   {
   witAssert (length_ == theVector.length_);

   copyCVecIntoCVec (myCVec_, theVector.myCVec_);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::convCopy (const TheType * theCVec)
   {
   copyCVecIntoCVec (myCVec_, theCVec);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::convCopyInto (TheType * theCVec) const
   {
   copyCVecIntoCVec (theCVec, myCVec_);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::clear ()
   {
   resize (0);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline void WitVector <TheType>::resize (size_t nElems, TheType theValue)
   {
   resize (nElems);

   setToScalar (theValue);
   }

//------------------------------------------------------------------------------

template <typename TheType> 
       inline void WitVector <TheType>::resize (size_t nElems)
   {
   delete[] myCVec_;

   myCVec_ = new TheType[nElems];
   length_ = nElems;
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      inline bool WitVector <TheType>::operator == (TheType theValue) const
   {
   size_t theIdx;

   for (theIdx = 0; theIdx < length (); theIdx ++)
      if (myCVec_[theIdx] != theValue)
         return false;

   return true;
   }

d173 1
a173 1
   ifDebug (WitVectorUtil::checkBounds (theIdx, length_));
d183 1
a183 1
   ifDebug (WitVectorUtil::checkBounds (theIdx, length_));
a196 17

template <typename TheType> 
      inline void WitVector <TheType>::copyCVecIntoCVec (
               TheType * dstCVec, 
         const TheType * srcCVec)
         const
   {
   size_t theIdx;

   witAssert (dstCVec != NULL);
   witAssert (srcCVec != NULL);

   for (theIdx = 0; theIdx < length_; theIdx ++)
      dstCVec[theIdx] = srcCVec[theIdx];
   }

//------------------------------------------------------------------------------
d203 2
a204 1
bool operator >= (const WitVector <float> & theVector, float theValue);
d208 7
a214 19
void convCopy (WitVector <double> & dstVec, const float * srcCVec);
   //
   // Copies the elements of srcCVec into dstVec.

void convCopy (
      WitVector <double> &      dstVec,
      const WitVector <float> & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

void convCopy (
      WitVector <float> &        dstVec,
      const WitVector <double> & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

bool operator >= (const WitVector <double> & theVector, double theValue);
   //
   // Returns true, iff each element of theVector >= theValue.
@


1.29
log
@Double Precision.
@
text
@d84 1
a84 1
      inline void copyCVec (const TheType * theCVec);
d91 1
a91 1
      inline void copyIntoCVec (TheType * theCVec) const;
d226 1
a226 1
      inline void WitVector <TheType>::copyCVec (const TheType * theCVec)
d234 1
a234 1
      inline void WitVector <TheType>::copyIntoCVec (TheType * theCVec) const
@


1.28
log
@Double Precision.
@
text
@d346 1
a346 1
void copyInto (WitVector <double> & dstVec, const float * srcCVec);
d350 1
a350 1
void copyInto (
d356 1
a356 1
void copyInto (
@


1.27
log
@Continued implementation of PIP.
@
text
@d84 1
a84 1
      inline void copyCvector (const TheType * theCvector);
d86 3
a88 3
         // Copies the elements of theCvector into the corresponding
         // elements of this Vector.
         // The length of theCvector is assumed match that of this Vector, but
d91 1
a91 1
      inline void copyIntoCvector (TheType * theCvector) const;
d94 2
a95 2
         // elements of this theCvector.
         // The length of theCvector is assumed match that of this Vector, but
d134 1
a134 1
      accessFunc (const TheType *, myCvector)
d137 1
a137 1
      inline TheType * myCvectorForUpdate ();
d139 1
a139 1
         // Same as myCvector (), but returns non-const.
d148 3
a150 3
      inline void copyCvectorIntoCvector (
                  TheType * dstCVector, 
            const TheType * srcCvector)
d153 2
a154 2
         // Copies the elements of srcCvector into the corresponding elements of
         // dstCvector.
d164 1
a164 1
      TheType * myCvector_;
d179 2
a180 2
         myCvector_ (NULL),
         length_    (0)
d188 2
a189 2
         myCvector_ (NULL),
         length_    (0)
d199 1
a199 1
   delete[] myCvector_;
d210 1
a210 1
      myCvector_[theIdx] = theValue;
d220 1
a220 1
   copyCvectorIntoCvector (myCvector_, theVector.myCvector_);
d226 1
a226 1
      inline void WitVector <TheType>::copyCvector (const TheType * theCvector)
d228 1
a228 1
   copyCvectorIntoCvector (myCvector_, theCvector);
d234 1
a234 3
      inline void WitVector <TheType>::copyIntoCvector (
         TheType * theCvector) 
         const
d236 1
a236 1
   copyCvectorIntoCvector (theCvector, myCvector_);
d262 1
a262 1
   delete[] myCvector_;
d264 2
a265 2
   myCvector_ = new TheType[nElems];
   length_    = nElems;
d276 1
a276 1
      if (myCvector_[theIdx] != theValue)
d297 1
a297 1
   return myCvector_[theIdx];
d307 1
a307 1
   return myCvector_[theIdx];
d313 1
a313 1
      TheType * WitVector <TheType>::myCvectorForUpdate ()
d315 1
a315 1
   return myCvector_;
d321 3
a323 3
      inline void WitVector <TheType>::copyCvectorIntoCvector (
               TheType * dstCvector, 
         const TheType * srcCvector)
d328 2
a329 2
   witAssert (dstCvector != NULL);
   witAssert (srcCvector != NULL);
d332 1
a332 1
      dstCvector[theIdx] = srcCvector[theIdx];
@


1.26
log
@Continued implementation of PIP.
@
text
@d28 8
a35 6
   {
   void checkBounds (int theIdx, size_t lengthVal);
      //
      // Verifies that theIdx is within the bounds of a Vector of length
      // lengthVal.
   };
d342 28
a369 25
   {
   bool operator >= (const WitVector <float> & theVector, float theValue);
      //
      // Returns true, iff each element of theVector >= theValue.

   void copyInto (WitVector <double> & dstVec, const float * srcCVec);
      //
      // Copies the elements of srcCVec into dstVec.

   void copyInto (
         WitVector <double> &      dstVec,
         const WitVector <float> & srcVec);
      //
      // Copies the elements of srcVec into dstVec.

   void copyInto (
         WitVector <float> &        dstVec,
         const WitVector <double> & srcVec);
      //
      // Copies the elements of srcVec into dstVec.

   bool operator >= (const WitVector <double> & theVector, double theValue);
      //
      // Returns true, iff each element of theVector >= theValue.
   };
@


1.25
log
@Continued implementation of PIP.
@
text
@d22 3
a24 1
// Global functions used by class template Vector <TheType>.
d27 7
a33 3
void witCheckBoundsForVector (int theIdx, size_t lengthVal);
   //
   // Verifies that theIdx is within the bounds of a Vector of length lengthVal.
d295 1
a295 1
   ifDebug (witCheckBoundsForVector (theIdx, length_));
d305 1
a305 1
   ifDebug (witCheckBoundsForVector (theIdx, length_));
d336 1
a336 1
// Global functions with arguments belonging to specific Vector classes.
d339 26
a364 19
bool operator >= (const WitVector <float> & theVector, float theValue);
   //
   // Returns true, iff each element of theVector >= theValue.

void copyInto (WitVector <double> & dstVec, const float * srcCVec);
   //
   // Copies the elements of srcCVec into dstVec.

void copyInto (WitVector <double> & dstVec, const WitVector <float> & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

void copyInto (WitVector <float> & dstVec, const WitVector <double> & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

bool operator >= (const WitVector <double> & theVector, double theValue);
   //
   // Returns true, iff each element of theVector >= theValue.
@


1.24
log
@Continued implementation of post-implosion pegging.
@
text
@d39 1
a39 1
      class WitVector: public WitUtil
@


1.23
log
@Various internal changes.
@
text
@d33 1
a33 1
// The elements are stored and retrieveb by value.
@


1.22
log
@Various internal changes.
@
text
@d70 1
a70 1
      inline void copy (const WitVector <TheType> & theVector);
d150 1
a150 1
      noCopyCtorAssignTemp (WitVector, TheType);
d208 1
a208 2
      inline void WitVector <TheType>::copy (
         const WitVector <TheType> & theVector)
@


1.21
log
@Internal changes.
@
text
@d38 1
a38 1
template <class TheType> 
d169 1
a169 1
template <class TheType> 
d178 1
a178 1
template <class TheType> 
d188 1
a188 1
template <class TheType> 
d196 1
a196 1
template <class TheType> 
d207 1
a207 1
template <class TheType> 
d218 1
a218 1
template <class TheType> 
d226 1
a226 1
template <class TheType> 
d236 1
a236 1
template <class TheType> 
d244 1
a244 1
template <class TheType> 
d254 1
a254 1
template <class TheType> 
d265 1
a265 1
template <class TheType> 
d279 1
a279 1
template <class TheType> 
d287 1
a287 1
template <class TheType> 
d297 1
a297 1
template <class TheType> 
d307 1
a307 1
template <class TheType> 
d315 1
a315 1
template <class TheType> 
@


1.20
log
@modications to change rogueWave tools.h++ to STL
@
text
@d104 1
a104 1
      inline WitBoolean operator == (TheType theValue) const;
d106 1
a106 1
         // Returns TRUE iff every element of this Vector == theValue.
d108 1
a108 1
      inline WitBoolean isAllocated () const;
d266 1
a266 3
      inline WitBoolean WitVector <TheType>::operator == (
         TheType theValue) 
         const
d272 1
a272 1
         return witFALSE;
d274 1
a274 1
   return witTRUE;
d280 1
a280 1
      inline WitBoolean WitVector <TheType>::isAllocated () const
d334 1
a334 1
WitBoolean operator >= (const WitVector <float> & theVector, float theValue);
d336 1
a336 1
   // Returns TRUE, iff each element of theVector >= theValue.
d350 1
a350 1
WitBoolean operator >= (const WitVector <double> & theVector, double theValue);
d352 1
a352 1
   // Returns TRUE, iff each element of theVector >= theValue.
@


1.19
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d199 1
a199 1
   int theIdx;
d270 1
a270 1
   int theIdx;
d323 1
a323 1
   int theIdx;
@


1.19.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d199 1
a199 1
   size_t theIdx;
d270 1
a270 1
   size_t theIdx;
d323 1
a323 1
   size_t theIdx;
@


1.18
log
@Preliminary work on single source.
@
text
@d191 1
a191 1
   delete myCvector_;
d257 1
a257 1
   delete myCvector_;
@


1.17
log
@Continued preliminary work on single source.
@
text
@d66 1
a66 1
      inline void setTo (TheType theValue);
d76 1
a76 1
      inline void copyFromCvector (const TheType * theCvector);
d83 1
a83 1
      inline void copySelfInto (TheType * theCvector) const;
d140 1
a140 1
      inline void copyInto (
d197 1
a197 1
      inline void WitVector <TheType>::setTo (TheType theValue)
d213 1
a213 1
   copyInto (myCvector_, theVector.myCvector_);
d219 1
a219 2
      inline void WitVector <TheType>::copyFromCvector (
         const TheType * theCvector)
d221 1
a221 1
   copyInto (myCvector_, theCvector);
d227 3
a229 1
      inline void WitVector <TheType>::copySelfInto (TheType * theCvector) const
d231 1
a231 1
   copyInto (theCvector, myCvector_);
d249 1
a249 1
   setTo (theValue);
d318 1
a318 1
      inline void WitVector <TheType>::copyInto (
d333 1
a333 1
// Global functions that use specific Vector <TheType> classes.
@


1.16
log
@More preliminary work on single source.
@
text
@d76 1
a76 1
      inline void copy (const TheType * theCvector);
d219 2
a220 1
      inline void WitVector <TheType>::copy (const TheType * theCvector)
@


1.15
log
@Preliminary work on single source.
@
text
@d166 1
a166 1
// Implementation class template Vector <TheType>
@


1.14
log
@Began implementation of object iteration.
@
text
@d16 1
a16 15
// Contains the declaration of generic class Vector (TheType).
//
// Notes:
//
// 1. The "type" argument to macros defining a generic class must be a single
//    symbol naming a type. This applies to all generics, not just RW wrappers.
//
// 2. The "declare" macro for the generic classes defined in this header
//    should only be invoked in this header, because the corresponding
//    "implement" macro invocations are in RWClient.C
//
// 3. The "declare" macro cannot be called from WIT's declaration
//    macros, because they themselves are called by the "declare" macro and
//    the C++ preprocessor does not allow recursion. Thus the RW declaration
//    macros must be called directly.
d21 7
a27 1
#include <rw/gvector.h>
d30 1
a30 1
// generic class Vector (TheType).
d32 2
a33 2
// A vector whose elements are instances of TheType.
// Implemented as a wrapper for RWGVector (TheType).
d35 260
a294 13
// Warning: This is a value-based collection class; its methods make heavy use
// of the copy constructor for TheType.
//
// To declare and implement WitVector (YourType), check the "Declarations of all
// specific cases of generic class Vector", which appears in this file, and
// look for the following line:
//
//     declare (WitVector, YourType)
//
// If this line is not there, add it. In this case, you must also add the
// following line to the list of "implement" macro invocations in RWClient.C
//
//     implement (WitVector, YourType)
d297 8
d306 7
a312 1
// Generic class declaration macro.
d315 14
a328 183
#define WitVectordeclare(TheType)                                              \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
RWGVectordeclare (TheType)                                                     \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitVector (TheType): public WitUtil                                      \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* The following functions and operators are wrappers around the       */\
      /* corresponding RWGVector member functions and operators.             */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitVector (TheType) ();                                                  \
         /*                                                                  */\
         /* Constructs an instance with 0 elements.                          */\
                                                                               \
      WitVector (TheType) (size_t nElems, TheType initValue);                  \
                                                                               \
         /* Constructs an instance with nElems elements, each of which is    */\
         /* initialized to initValue.                                        */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitVector (TheType) ();                                                 \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Public member operators.                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline TheType operator [] (int theIndex) const;                         \
         /*                                                                  */\
         /* Returns the indexed element of this WitVector.                   */\
         /* Bounds checking is performed (by WIT), iff the compile is in     */\
         /* DEBUG  mode.                                                     */\
         /* Returned value is not an lvalue.                                 */\
                                                                               \
      inline TheType & operator [] (int theIndex);                             \
         /*                                                                  */\
         /* Same as the preceeding operator [], except that this WitVector   */\
         /* is non-const and the returned value is an lvalue.                */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline size_t length () const                                            \
            /*                                                               */\
            /* Returns the length of this WitVector.                         */\
         {                                                                     \
         return myRWData_.length ();                                           \
         }                                                                     \
                                                                               \
      const TheType * myCvector () const;                                      \
         /*                                                                  */\
         /* Returns the c-vector which stores the elements of this vector.   */\
                                                                               \
      void operator = (TheType theValue);                                      \
         /*                                                                  */\
         /* Sets all elements of this WitVector to theValue.                 */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* The remaining functions are not wrappers around RWGVector member    */\
      /* functions.                                                          */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void operator = (const WitVector (TheType) & theVector);                 \
         /*                                                                  */\
         /* Copies the elements of theVector into the corresponding          */\
         /* elements of this WitVector.                                      */\
         /* The length of theVector must match that of this WitVector.       */\
         /* This is a different convention from the RW assignment operator,  */\
         /* which resizes this RWGVector to match theVector.                 */\
                                                                               \
      void operator = (const TheType * theCvector);                            \
         /*                                                                  */\
         /* Copies the elements of theCvector into the corresponding         */\
         /* elements of this WitVector.                                      */\
         /* The length of theCvector is assumed match that of this           */\
         /* WitVector, but this assumption cannot be verified.               */\
                                                                               \
      void copySelfInto (TheType * theCvector) const;                          \
         /*                                                                  */\
         /* Copies the elements of this Vector into the corresponding        */\
         /* elements of this theCvector.                                     */\
         /* The length of theCvector is assumed match that of this           */\
         /* WitVector, but this assumption cannot be verified.               */\
                                                                               \
      TheType * myCvectorForUpdate ();                                         \
         /*                                                                  */\
         /* Same as myCvector (), but returns non-const.                     */\
         /* Use with discretion.                                             */\
                                                                               \
      void clear ();                                                           \
         /*                                                                  */\
         /* Resizes this WitVector to 0 elements.                            */\
                                                                               \
      void resize (size_t nElems);                                             \
         /*                                                                  */\
         /* Resizes this WitVector to nElems elements. The first n elements  */\
         /* retain their current value, where = min (length (), nElems).     */\
         /* Any other elements have undefined value.                         */\
                                                                               \
      void resize (size_t nElems, TheType theValue);                           \
         /*                                                                  */\
         /* Resizes this WitVector to nElems elements.                       */\
         /* The elements are all set to theValue.                            */\
                                                                               \
      WitBoolean operator == (const WitVector (TheType) & theVector) const;    \
         /*                                                                  */\
         /* Returns TRUE iff this Vector == theVector.                       */\
                                                                               \
      WitBoolean operator == (TheType theValue) const;                         \
         /*                                                                  */\
         /* Returns TRUE iff every element of this Vector == theValue.       */\
                                                                               \
      inline WitBoolean isAllocated () const                                   \
         {                                                                     \
         return (length () > 0);                                               \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void checkBounds (int theIndex) const;                                   \
         /*                                                                  */\
         /* Verifies the theIndex is within the bounds of this               */\
         /* WitVector (TheType).                                             */\
                                                                               \
      noCopyCtor (WitVector (TheType));                                        \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      RWGVector (TheType) myRWData_;                                           \
         /*                                                                  */\
         /* The RWGVector (TheType) for which this Vector is a wrapper.      */\
   };                                                                          \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementations of inline member functions.                               */\
/*---------------------------------------------------------------------------*/\
                                                                               \
inline TheType WitVector (TheType)::operator [] (int theIndex) const           \
   {                                                                           \
   ifDebug (checkBounds (theIndex));                                           \
                                                                               \
   return myRWData_ (theIndex);                                                \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
inline TheType & WitVector (TheType)::operator [] (int theIndex)               \
   {                                                                           \
   ifDebug (checkBounds (theIndex));                                           \
                                                                               \
   return myRWData_ (theIndex);                                                \
   }                                                                           \

//------------------------------------------------------------------------------
// Declarations of all specific cases of generic class Vector.
//------------------------------------------------------------------------------

declare (WitVector, int)
declare (WitVector, long)
declare (WitVector, float)
declare (WitVector, double)
declare (WitVector, char)
declare (WitVector, WitTlObjPtr)
d331 1
a331 1
// Global functions that use specific cases of class Vector.
d334 1
a334 1
WitBoolean operator >= (const WitVector (float) & theVector, float theValue);
d338 1
a338 1
void copyInto (WitVector (double) & dstVec, const float * srcCVec);
d342 1
a342 1
void copyInto (WitVector (double) & dstVec, const WitVector (float) & srcVec);
d346 1
a346 1
void copyInto (WitVector (float) & dstVec, const WitVector (double) & srcVec);
d350 1
a350 1
WitBoolean operator >= (const WitVector (double) & theVector, double theValue);
@


1.13
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d33 1
a33 1
#include <MsgFac.h>
@


1.12
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d171 3
a173 2
         /* Resizes this WitVector to nElems elements.                       */\
         /* The resulting element values are undefined.                      */\
@


1.11
log
@Implemented and used class SelMgr.
@
text
@d243 1
a243 1
declare (WitVector, WitTlPtr)
@


1.10
log
@Some minor changes.
@
text
@d1 269
@


1.9
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@a0 987
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef VectorH
#define VectorH

//------------------------------------------------------------------------------
// Header file: "Vector.h"
//
// Contains the declaration of the following classes:
//
//    TVec      (TheType)
//    RefVector (TheType)
//    String
//    AbsDenseList
//    DenseList (TheType)
//    PtrVec    (TheType)
//    PtrTVec   (TheType)
//------------------------------------------------------------------------------

#include <RWClient.h>

//------------------------------------------------------------------------------
// generic class TVec (TheType)
//
// A WitVector (TheType) of length Problem::nPeriods, for some Problem.
// Implemented by inheriting from WitVector (TheType).
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Generic class declaration macro.
//------------------------------------------------------------------------------

#define WitTVecdeclare(TheType)                                                \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitTVec (TheType): public WitVector (TheType)                            \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitTVec (TheType) ();                                                    \
         /*                                                                  */\
         /* Constructs an instance with 0 elements.                          */\
                                                                               \
      WitTVec (TheType) (WitProblem * theProblem, TheType initValue);          \
                                                                               \
         /* Constructs an instance with theProblem->nPeriods () elements.    */\
         /* Each element is initialized to initValue.                        */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitTVec (TheType) ();                                                   \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Public member functions.                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void allocate (WitProblem * theProblem, TheType theValue);               \
         /*                                                                  */\
         /* Resizes this TVec to theProblem->nPeriods () elements.           */\
         /* The elements are all set to theValue.                            */\
                                                                               \
      inline void operator = (TheType theValue)                                \
         {                                                                     \
         WitVector (TheType)::operator = (theValue);                           \
         }                                                                     \
                                                                               \
      inline void operator = (const WitTVec (TheType) & theVector)             \
         {                                                                     \
         WitVector (TheType)::operator = (theVector);                          \
         }                                                                     \
                                                                               \
      inline void operator = (const TheType * theCvector)                      \
         {                                                                     \
         WitVector (TheType)::operator = (theCvector);                         \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitTVec (TheType));                                          \
   };                                                                          \

//------------------------------------------------------------------------------
// generic class RefVector (TheType).
//
// A vector whose elements are instances of TheType.
// Similar to WitVector, but subscripting is always done by reference, never
// by value. TheType need not have a copy constuctor, since it is not used;
// only the default constructor for TheType is used.
//
// Implemented as a WitVector (VoidPtr), which stores pointers to the elements
// of this RefVector (TheType). A RefVector is considered to "own" its
// elements, so when a RefVector gets constructed, destructed or resized,
// the default constructor and/or destructor for TheType is invoked as
// appropriate.
//
// In general, Vectors should be used for types for which making frequent
// copies is acceptable, such as intrinsic types and pointers, while
// RefVectors should be used for types for which making frequent copies is
// undesirable, such as most classes.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Generic class declaration macro.
//------------------------------------------------------------------------------

#define WitRefVectordeclare(TheType)                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitRefVector (TheType): public WitUtil                                   \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitRefVector (TheType) ();                                               \
         /*                                                                  */\
         /* Constructs an instance with 0 elements.                          */\
                                                                               \
      WitRefVector (TheType) (size_t nElems);                                  \
                                                                               \
         /* Constructs an instance with nElems elements, each of which is    */\
         /* contructed by its default constructor.                           */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitRefVector (TheType) ();                                              \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Public member operators.                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline const TheType & operator [] (int theIndex) const                  \
            /*                                                               */\
            /* Returns the indexed element of this RefVector.                */\
            /* Bounds checking is performed, iff compiled in DEBUG mode.     */\
            /* Returned value is not an lvalue.                              */\
         {                                                                     \
         return * (const TheType *) myVector_[theIndex];                       \
         }                                                                     \
                                                                               \
      inline TheType & operator [] (int theIndex)                              \
            /*                                                               */\
            /* Same as the preceeding operator [], except that this          */\
            /* RefVector is non-const and the returned value is an lvalue.   */\
         {                                                                     \
         return * (TheType *) myVector_[theIndex];                             \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline size_t length () const                                            \
            /*                                                               */\
            /* Returns the length of this RefVector.                         */\
         {                                                                     \
         return myVector_.length ();                                           \
         }                                                                     \
                                                                               \
      void clear ();                                                           \
         /*                                                                  */\
         /* Resizes this RefVector to 0 elements.                            */\
                                                                               \
      void resize (size_t nElems);                                             \
         /*                                                                  */\
         /* Resizes this RefVector to nElems elements.                       */\
         /* Each element is constructed by its default constructor.          */\
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitVector (WitTypelessPtr) myVector_;                                    \
         /*                                                                  */\
         /* Stores pointers to the elements of this RefVector.               */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtorAssign (WitRefVector (TheType));                               \
   };                                                                          \

//------------------------------------------------------------------------------
// class String.
// A character string.
// Implemented in terms of a Vector (char)
//------------------------------------------------------------------------------

class WitString: public WitUtil
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitString ();
         //
         // Constructs a null String.

      WitString (const char * theCstring);
         //
         // Constructs a copy of theCstring.

      WitString (const WitString & theString);
         //
         // Constructs a copy of theString.

      WitString (size_t nBlanks);
         //
         // Constructs a string containing nBlanks blanks.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitString ();

      //------------------------------------------------------------------------
      // Public member operators.
      //------------------------------------------------------------------------

      inline char operator [] (int theIndex) const
            //
            // Returns the indexed element of this WitVector.
            // Bounds checking is performed (by WIT), iff the compile is in
            // DEBUG  mode.
            // Returned value is not an lvalue.
         {
         return myVector_[theIndex];
         }

      inline char & operator [] (int theIndex)
            //
            // Same as the preceeding operator [], except that this WitVector
            // is non-const and the returned value is an lvalue.
         {
         return myVector_[theIndex];
         }

      void operator = (const char * theCstring);
         //
         // Copies theCstring into this String.

      void operator = (const WitString & theString);
         //
         // Copies theString into this String.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      inline const char * myCstring () const
         {
         return myVector_.myCvector ();
         }

      inline char * myCstringForUpdate ()
            //
            // Returns the (char *) representation of this String, for updating
            // purposes.
            // Use with discretion.
         {
         return myVector_.myCvectorForUpdate ();
         }

      inline WitBoolean isNull () const
            //
            // Returns TRUE iff this String is a null (0 length) String.
         {
         return ((* this)[0] == '\0');
         }

      inline size_t length () const
            //
            // Returns the length of this String.
         {
         return strlen (myVector_.myCvector ());
         }

      void resize (size_t nChars);
         //
         // Resizes this String to nChars blanks.

      inline int maxLength () const
         {
         return myVector_.length () - 1;
         }

      inline static const WitString & thisString (const WitString * pTheString)
            //
            // Used for List::find ().
         {
         return * pTheString;
         }

   private:

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitVector (char) myVector_;
         //
         // The Vector thru which this String is implemented.
         // Its length is normally one greater than the length of this String,
         // in order to store the terminating null character.
   };

//------------------------------------------------------------------------------
// Global operators that use Strings.
//------------------------------------------------------------------------------

inline WitBoolean operator == (const WitString & lhs, const char *      rhs)
   {
   return WitUtil::streq (lhs.myCstring (), rhs);
   }

inline WitBoolean operator == (const char *      lhs, const WitString & rhs)
   {
   return (rhs == lhs);
   }

inline WitBoolean operator == (const WitString & lhs, const WitString & rhs)
   {
   return (lhs == rhs.myCstring ());
   }

inline WitBoolean operator != (const WitString & lhs, const char *      rhs)
   {
   return ! (lhs == rhs);
   }

inline WitBoolean operator != (const char *      lhs, const WitString & rhs)
   {
   return ! (lhs == rhs);
   }

inline WitBoolean operator != (const WitString & lhs, const WitString & rhs)
   {
   return ! (lhs == rhs);
   }

//------------------------------------------------------------------------------

extern "C"
   {
   typedef int (* WitQsortCompareFunc) (const void *, const void *);
   }
   //
   // The type of compare function pointer that qsort requires.
   // (Used by AbsDenseList.)
   // The extern "C" linkage is necessary on C Set/2.

//------------------------------------------------------------------------------
// class WitAbsDenseList (Abstract Dense List)
//
// An AbsDenseList is a dense list whose elements are TypelessPtrs.
// In other words, it's a Vector with a list-like interface.
// Implemented in terms of Vector (TypelessPtr).
// This class functions as a base class for the generic class
//    DenseList (TheType).
// Its purpose is to implement all type-independent aspects of
//    DenseList (TheType).
// Since this function is intended to be used only as a base class, its
//    ctors and dtor are protected.
//------------------------------------------------------------------------------

class WitAbsDenseList: public WitUtil
   {
   public:

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (size_t, nElements)

      inline size_t storageCapacity () const
         {
         return myVector_.length ();
         }
         //
         // The maximum # elements this DenseList can hold.

      inline static WitTypelessPtr compareFuncForSort ()
         {
         witAssert (compareFuncForSort_ != NULL);

         return compareFuncForSort_;
         }

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      inline void clear ()
         {
         nElements_ = 0;
         }
         //
         // Removes all of the elements from this DenseList.

      inline WitBoolean isEmpty () const
         {
         return (nElements_ == 0);
         }
         //
         // Returns TRUE iff this DenseList is empty.

      void resize (size_t newStorageCapacity);
         //
         // Resizes this WitDenseList to allow it to hold newStorageCapacity
         // elements.
         // The list will be empty.

   protected:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsDenseList (size_t theStorageCapacity);
         //
         // Constructs an empty list.
         // The list cannot be expanded to more than theStorageCapacity
         // elements.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbsDenseList ();

      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      inline WitTypelessPtr append (WitTypelessPtr theInstance)
         {
         witAssert (nElements_ < storageCapacity ());

         witAssert (theInstance != NULL);

         myVector_[(int) nElements_] = theInstance;

         ++ nElements_;

         return theInstance;
         }
         //
         // Adds theInstance to the end of this List and returns it.

      inline WitTypelessPtr first () const
         {
         witAssert (! isEmpty ());

         return myVector_[0];
         }
         //
         // Returns the first element in this List.

      inline WitTypelessPtr last () const
         {
         witAssert (! isEmpty ());

         return myVector_[((int) nElements_) - 1];
         }
         //
         // Returns the last element in this List.

      inline WitBoolean advance (
            int &            theIndex, 
            WitTypelessPtr & theElement) 
            const
         {
         if (++ theIndex < (int) nElements_)
            {
            theElement = myVector_[theIndex];

            return witTRUE;
            }
         else
            {
            theElement = NULL;

            return witFALSE;
            }
         }
         //
         // Advances theIndex. If theIndex is still valid for this DenseList
         // after the advance, this function sets theElement to the indexed
         // element and returns TRUE. Otherwise, this function sets theElement
         // to NULL and returns FALSE. TheIndex is required to be >= -1.

      void sort (
            WitTypelessPtr      theCompareFunc,
            WitQsortCompareFunc theQsortCompareFunc);
         //
         // Sorts this AbsDenseList.
         // theCompareFunc is a pointer to the compare function that will be
         // used in the sort. See DenseList (TheType)::sort for details.
         // theQsortCompareFunc is the function pointer that will be passed to
         // qsort.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitAbsDenseList);

      //------------------------------------------------------------------------
      // Private static member data.
      //------------------------------------------------------------------------

      static WitTypelessPtr compareFuncForSort_;
         //
         // When a sort is in progress, this is the compare function that
         // was passed as an argument to DenseList (TheType)::sort.
         // NULL, when a sort in not in progress.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitVector (WitTypelessPtr) myVector_;
         //
         // The Vector thru which this AbsDenseList is implemented.

      size_t nElements_;
         //
         // # elements in this list.
         // Must be <= storageCapacity ().
   };

//------------------------------------------------------------------------------
// generic class DenseList (TheType)
//
// A DenseList (TheType) is a dense list whose elements are instances of
// TheType. Derived from class AbsDenseList.
//
// This is a pointer-based collection class: its methods do not use the copy
// constructor for TheType.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// macro WitCompareFunc(TheType)
//
// Used as the name of a generic typedef.
//------------------------------------------------------------------------------

#define WitCompareFunc(TheType)                                                \
                                                                               \
   name2 (WitCompareFunc, TheType)                                             \

//------------------------------------------------------------------------------
// Declaration macro for generic class DenseList (TheType).
//------------------------------------------------------------------------------

#define WitDenseListdeclare(TheType)                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Typedef WitCompareFunc(TheType).                                          */\
/*                                                                           */\
/* Used by "sort" to declare a compare function.                             */\
/*---------------------------------------------------------------------------*/\
                                                                               \
typedef int (* WitCompareFunc(TheType)) (TheType *, TheType *);                \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Declaration of class DenseList (TheType).                                 */\
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitDenseList (TheType): public WitAbsDenseList                           \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitDenseList (TheType) (size_t newStorageCapacity = 0);                  \
         /*                                                                  */\
         /* See AbsDenseList ctor.                                           */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitDenseList (TheType) ();                                              \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Wrappers around AbsDenseList member functions.                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline TheType * append (TheType * theInstance)                          \
         {                                                                     \
         return                                                                \
            (TheType *) WitAbsDenseList::append ((WitTypelessPtr) theInstance);\
         }                                                                     \
                                                                               \
      inline TheType * first () const                                          \
         {                                                                     \
         return (TheType *) WitAbsDenseList::first ();                         \
         }                                                                     \
                                                                               \
      inline TheType * last () const                                           \
         {                                                                     \
         return (TheType *) WitAbsDenseList::last ();                          \
         }                                                                     \
                                                                               \
      inline WitBoolean advance (                                              \
            int &       theIndex,                                              \
            TheType * & theElement)                                            \
            const                                                              \
         {                                                                     \
         return                                                                \
            WitAbsDenseList::advance (theIndex, (WitTypelessPtr &) theElement);\
         }                                                                     \
                                                                               \
      void sort (WitCompareFunc(TheType) theFunc);                             \
         /*                                                                  */\
         /* Sorts this DenseList.                                            */\
         /* theFunc is a pointer to the compare function that will be used   */\
         /* in the sort. It should be declared as follows:                   */\
         /*                                                                  */\
         /* int theFunc (                                                    */\
         /*    const TheType * element1,                                     */\
         /*    const TheType * element2);                                    */\
         /*                                                                  */\
         /* and should return -1, 0, or +1, depending whether element1 is    */\
         /* considered to be <, =, or > element2, complying with the qsort   */\
         /* convention.                                                      */\
         /*                                                                  */\
         /* This function makes use of static data members. Consequently,    */\
         /* it cannot be used recursively. I.e., "theFunc" must not          */\
         /* (directly or indirectly) invoke DenseList (TheType)::sort, for   */\
         /* any type. If it does, a fatal error is generated.                */\
         /*                                                                  */\
         /* This function is implemented by calling AbsDenseList::sort,      */\
         /* which calls qsort.                                               */\
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtorAssign (WitDenseList (TheType));                               \
   };                                                                          \

//------------------------------------------------------------------------------
// macro forEachElDense (theElement, theDenseList)
//
// Expands to a header of a for loop that iterates thru each element in
// theDenseList.
//
// Arguments:
//
//    theDenseList: Type: const DenseList (TheType), for some type, TheType.
//                  The dense list being iterated.
//
//    theElement:   Type: TheType *
//                  A pointer that will be set to each element of theDenseList,
//                  in sequence. The body of the for loop should normally make
//                  use of this pointer.
//
// Note: If theDenseList is empty, the forEachElDense loop does nothing (which
// is to be expected).
//
// Example:
//
// WitDenseList (WitDemand) theDemands;
//
// ...Fill up theDemands with Demands.
//
// WitDemand * theDemand;
//
// forEachElDense (theDemand, theDemands)
//    {
//    ...statements using theDemand...
//    }
//
// The implementation of this macro calls the macro forEachElDenseIndex
// (defined below), which expands to a name unique to the line of source code
// from which the forEachElDenseIndex macro was called. This name is used as
// the name of an int, which is used to implement the forEachElDense macro. It
// is necessary for the forEachElDense macro to use a different name for its
// index each time it is called, because it might get called more than once
// from within the same scope.
//------------------------------------------------------------------------------

#define forEachElDenseIndex name2 (forEachElDenseIndexOnLine, __LINE__)

//------------------------------------------------------------------------------

#define forEachElDense(theElement, theDenseList)                               \
                                                                               \
   for (                                                                       \
      int forEachElDenseIndex = -1;                                            \
      (theDenseList).advance (forEachElDenseIndex, theElement);                \
      )                                                                        \

//------------------------------------------------------------------------------
// Global generic function copyInto-DenseList-List (TheType).
//
// Makes theDenseList a shallow copy of theList.
// Assumes that theDenseList already has sufficient storage.
//------------------------------------------------------------------------------

#define copyIntoDenseListFromListdeclare(TheType)                              \
                                                                               \
void copyInto (                                                                \
      WitDenseList (TheType)  & theDenseList,                                  \
      const WitList (TheType) & theList);                                      \
                                                                               
//------------------------------------------------------------------------------
// Generic class PtrVec (TheType)
//
// A vector of pointers to TheType.
// This class is implemented as a typed wrapper for class Vector (TypelessPtr).
// See class Vector (TypelessPtr) for comments on the member functions.
//
// All implementation is inline.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Generic class declaration macro.
//------------------------------------------------------------------------------

#define WitPtrVecdeclare(TheType)                                              \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitPtrVec (TheType): public WitUtil                                      \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline WitPtrVec (TheType) ():                                           \
            myVector_ ()                                                       \
         {                                                                     \
         }                                                                     \
                                                                               \
      WitPtrVec (TheType) (size_t nElems):                                     \
            myVector_ (nElems, NULL)                                           \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline ~WitPtrVec (TheType) ()                                           \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline void resize (size_t nElems)                                       \
         {                                                                     \
         myVector_.resize (nElems, NULL);                                      \
         }                                                                     \
                                                                               \
      inline void clear ()                                                     \
         {                                                                     \
         myVector_.clear ();                                                   \
         }                                                                     \
                                                                               \
      inline void operator = (const WitPtrVec (TheType) & thePtrVec)           \
         {                                                                     \
         myVector_ = thePtrVec.myVector_;                                      \
         }                                                                     \
                                                                               \
      inline size_t length () const                                            \
         {                                                                     \
         return myVector_.length ();                                           \
         }                                                                     \
                                                                               \
      inline TheType * operator [] (int theIndex) const                        \
         {                                                                     \
         return (TheType *)   myVector_[theIndex];                             \
         }                                                                     \
                                                                               \
      inline TheType * & operator [] (int theIndex)                            \
         {                                                                     \
         return (TheType * &) myVector_[theIndex];                             \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitPtrVec (TheType));                                        \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitVector (WitTypelessPtr) myVector_;                                    \
         /*                                                                  */\
         /* The Vector that stores the data for this PtrVec.                 */\
   };                                                                          \

//------------------------------------------------------------------------------
// Generic class PtrTVec (TheType)
//
// A time vector of pointers to TheType.
// This class is implemented as a typed wrapper for class TVec (TypelessPtr).
// See class TVec (TypelessPtr) for comments on the member functions.
//
// All implementation is inline.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Generic class declaration macro.
//------------------------------------------------------------------------------

#define WitPtrTVecdeclare(TheType)                                             \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitPtrTVec (TheType): public WitUtil                                     \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitPtrTVec (TheType) ():                                                 \
            myTVec_ ()                                                         \
         {                                                                     \
         }                                                                     \
                                                                               \
      WitPtrTVec (TheType) (WitProblem * theProblem):                          \
            myTVec_ (theProblem, NULL)                                         \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline ~WitPtrTVec (TheType) ()                                          \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline void allocate (WitProblem * theProblem)                           \
         {                                                                     \
         myTVec_.allocate (theProblem, NULL);                                  \
         }                                                                     \
                                                                               \
      inline void clear ()                                                     \
         {                                                                     \
         myTVec_.clear ();                                                     \
         }                                                                     \
                                                                               \
      inline WitBoolean isAllocated () const                                   \
         {                                                                     \
         return myTVec_.isAllocated ();                                        \
         }                                                                     \
                                                                               \
      inline void operator = (TheType * theObject)                             \
         {                                                                     \
         myTVec_ = (WitTypelessPtr) theObject;                                 \
         }                                                                     \
                                                                               \
      inline TheType * operator [] (int theIndex) const                        \
         {                                                                     \
         return (TheType *)   myTVec_[theIndex];                               \
         }                                                                     \
                                                                               \
      inline TheType * & operator [] (int theIndex)                            \
         {                                                                     \
         return (TheType * &) myTVec_[theIndex];                               \
         }                                                                     \
                                                                               \
      inline TheType & operator () (int theIndex) const                        \
         {                                                                     \
         witAssert ((* this)[theIndex] != NULL);                               \
                                                                               \
         return   * (* this)[theIndex];                                        \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtorAssign (WitPtrTVec (TheType));                                 \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitTVec (WitTypelessPtr) myTVec_;                                        \
         /*                                                                  */\
         /* The TVec that stores the data for this PtrTVec.                  */\
   };                                                                          \

//------------------------------------------------------------------------------
// Declarations of all specific cases of the generic classes and functions
// declared in this file.
//------------------------------------------------------------------------------

declare (WitTVec,                   WitTypelessPtr)
declare (WitTVec,                   int)
declare (WitTVec,                   float)
declare (WitTVec,                   double)

declare (WitRefVector,              WitBoundPair)
declare (WitRefVector,              WitList (WitNode))
declare (WitRefVector,              WitList (int))
declare (WitRefVector,              WitString)
declare (WitRefVector,              WitVector (int))

declare (WitDenseList,              WitBopEntry)
declare (WitDenseList,              WitCoeff)
declare (WitDenseList,              WitComponent)
declare (WitDenseList,              WitDatedPart)
declare (WitDenseList,              WitDemand)
declare (WitDenseList,              WitMaterial)
declare (WitDenseList,              WitNode)
declare (WitDenseList,              WitOperation)
declare (WitDenseList,              WitPart)
declare (WitDenseList,              WitSubEntry)

declare (copyIntoDenseListFromList, WitBopEntry)
declare (copyIntoDenseListFromList, WitOperation)
declare (copyIntoDenseListFromList, WitPart)
declare (copyIntoDenseListFromList, WitSubEntry)

declare (WitPtrVec,                 WitBopEntry)
declare (WitPtrVec,                 WitCoeff)
declare (WitPtrVec,                 WitComponent)
declare (WitPtrVec,                 WitConsEntry)
declare (WitPtrVec,                 WitMeAltPt)
declare (WitPtrVec,                 WitMsg)

declare (WitPtrTVec,                WitBaAltPt)
declare (WitPtrTVec,                WitBopEntry)
declare (WitPtrTVec,                WitMeAltPt)
declare (WitPtrTVec,                WitMrAltPt)
declare (WitPtrTVec,                WitConsEntDblStack)

#endif
@


1.8
log
@Refactoring for selection splitting.
@
text
@d918 7
d985 1
@


1.7
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d18 1
a18 1
//    TVec (TheType)
d23 2
a33 17
//
// To declare and implement TVec (YourType):
//
// 1. First follow instructions in RWClient.h called "To declare and implement
//    WitVector (YourType)".
//
// 2. Then check the "Declarations of all specific cases of generic class
//    TVec", which appears in this file, and look for the following
//    line:
//
//       declare (WitTVec, YourType)
//
//    If this line is not there, add it. In this case, you must also add the
//    following line to the list of "implement" macro invocations in
//    Vector.C:
//
//       implement (WitTVec, YourType)
d76 1
a76 1
      inline WitTVec (TheType) & operator = (TheType theValue)                 \
a78 2
                                                                               \
         return * this;                                                        \
d81 1
a81 2
      inline WitTVec (TheType) & operator = (                                  \
            const WitTVec (TheType) & theVector)                               \
a83 2
                                                                               \
         return * this;                                                        \
d86 1
a86 1
      inline WitTVec (TheType) & operator = (const TheType * theCvector)       \
a88 2
                                                                               \
         return * this;                                                        \
d97 1
a97 3
      WitTVec (TheType) (const WitTVec (TheType) &);                           \
         /*                                                                  */\
         /* Not implemented: prevents accidental copying.                    */\
a100 9
// Declarations of all specific cases of generic class TVec
//------------------------------------------------------------------------------

declare (WitTVec, int)
declare (WitTVec, float)
declare (WitTVec, double)
declare (WitTVec, WitTypelessPtr)

//------------------------------------------------------------------------------
a117 11
//
// To declare and implement RefVector (YourType), check the "Declarations of
// all specific cases of generic class RefVector", which appears in this
// file, and look for the following line:
//
//     declare (WitRefVector, YourType)
//
// If this line is not there, add it. In this case, you must also add the
// following line to the list of "implement" macro invocations in Vector.C
//
//     implement (WitRefVector, YourType)
d206 1
a206 3
      copyCtorAndAssignment (WitRefVector (TheType));                          \
         /*                                                                  */\
         /* Prevents unintentional copying and assignment.                   */\
a209 10
// Declarations of all specific cases of generic class RefVector.
//------------------------------------------------------------------------------

declare (WitRefVector, WitString)
declare (WitRefVector, WitList (int))
declare (WitRefVector, WitList (WitNode))
declare (WitRefVector, WitVector (int))
declare (WitRefVector, WitBoundPair)

//------------------------------------------------------------------------------
d267 1
a267 1
      WitString & operator = (const char * theCstring);
d269 1
a269 1
         // Copies theCstring into this String and returns it.
d271 1
a271 1
      WitString & operator = (const WitString & theString);
d273 1
a273 1
         // Copies theString into this String and returns it.
d538 1
a538 3
      copyCtorAndAssignment (WitAbsDenseList);
         //
         // Prevents unintentional copying and assignment.
a571 13
//
// To declare and implement this generic class for YourType,
// check the "Declarations of all specific cases of generic class DenseList",
// which appears in this file, and look for the following line:
//
//     declare (WitDenseList, YourType)
//
// If this line is not there, add it. In this case, you must also add the
// following line to the list of "implement" macro invocations in Vector.C
//
//     implement (WitDenseList, YourType)
//
// These two macros declare and implement DenseList (YourType).
d677 1
a677 3
      copyCtorAndAssignment (WitDenseList (TheType));                          \
         /*                                                                  */\
         /* Prevents unintentional copying and assignment.                   */\
a680 17
// Declarations of all specific cases of generic class DenseList.
//------------------------------------------------------------------------------

declare (WitDenseList, WitComponent)
declare (WitDenseList, WitNode)
declare (WitDenseList, WitPart)
declare (WitDenseList, WitMaterial)
declare (WitDenseList, WitOperation)
declare (WitDenseList, WitSubEntry)
declare (WitDenseList, WitBopEntry)
declare (WitDenseList, WitDemand)
declare (WitDenseList, WitDatedPart)

declare (WitDenseList, WitCoeff)


//------------------------------------------------------------------------------
a736 11
// To declare and implement this generic function for YourType:
//
// 1. Be sure DenseList (YourType) and List (YourType) are declared.
//
// 2. Add the following line below:
//
//    declare (copyIntoDenseListFromList, YourType)
//
// 3. Add the following line to Vector.C:
//
//    implement (copyIntoDenseListFromList, YourType)
d746 106
a851 1
// Declarations of all specific cases of generic function copy-DenseList-list.
d854 108
d966 12
@


1.6
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d823 1
a823 1
// Global generic function copy-DenseList-List (TheType).
d833 1
a833 1
//    declare (copyToDenseListFromList, YourType)
d837 1
a837 1
//    implement (copyToDenseListFromList, YourType)
d840 1
a840 1
#define copyToDenseListFromListdeclare(TheType)                                \
d842 1
a842 1
void copyTo (                                                                  \
d850 4
a853 4
declare (copyToDenseListFromList, WitBopEntry)
declare (copyToDenseListFromList, WitOperation)
declare (copyToDenseListFromList, WitPart)
declare (copyToDenseListFromList, WitSubEntry)
@


1.5
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d833 1
a833 1
//    declare (copyDenseListList, YourType)
d837 1
a837 1
//    implement (copyDenseListList, YourType)
d840 1
a840 1
#define copyDenseListListdeclare(TheType)                                      \
d842 1
a842 1
void copy (                                                                    \
d850 4
a853 4
declare (copyDenseListList, WitBopEntry)
declare (copyDenseListList, WitOperation)
declare (copyDenseListList, WitPart)
declare (copyDenseListList, WitSubEntry)
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d242 1
a242 1
      WitVector (WitVoidStar) myVector_;                                       \
d440 1
a440 1
// An AbsDenseList is a dense list whose elements are void *'s.
d442 1
a442 1
// Implemented in terms of Vector (WitVoidStar).
d468 1
a468 1
      inline static const void * compareFuncForSort ()
d521 1
a521 1
      inline void * append (void * theInstance)
d536 1
a536 1
      inline void * first () const
d545 1
a545 1
      inline void * last () const
d554 4
a557 1
      inline WitBoolean advance (int & theIndex, void * & theElement) const
a577 21
      inline WitBoolean recede (int & theIndex, void * & theElement) const
         {
         if (-- theIndex >= 0)
            {
            theElement = myVector_[theIndex];

            return witTRUE;
            }
         else
            {
            theElement = NULL;

            return witFALSE;
            }
         }
         //
         // Recedes theIndex. If theIndex is still valid for this DenseList
         // after the receding, this function sets theElement to the indexed
         // element and returns TRUE. Otherwise, this function sets theElement
         // to NULL and returns FALSE. TheIndex is required to be <= nElements_.

d579 1
a579 1
            void *              theCompareFunc,
d602 1
a602 1
      static const void * compareFuncForSort_;
d612 1
a612 1
      WitVector (WitVoidStar) myVector_;
d697 2
a698 1
         return (TheType *) WitAbsDenseList::append (theInstance);             \
d716 2
a717 9
         return WitAbsDenseList::advance (theIndex, (void * &) theElement);    \
         }                                                                     \
                                                                               \
      inline WitBoolean recede (                                               \
            int &       theIndex,                                              \
            TheType * & theElement)                                            \
            const                                                              \
         {                                                                     \
         return WitAbsDenseList::recede (theIndex, (void * &) theElement);     \
a819 13
      )                                                                        \

//------------------------------------------------------------------------------
// macro forEachElDenseBackwards (theElement, theDenseList)
//
// Same as forEachElDense, but traverses the DenseList backwards.
//------------------------------------------------------------------------------

#define forEachElDenseBackwards(theElement, theDenseList)                      \
                                                                               \
   for (                                                                       \
      int forEachElDenseIndex = (theDenseList).nElements ();                   \
      (theDenseList).recede (forEachElDenseIndex, theElement);                 \
@


1.3
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d172 1
a172 1
class WitRefVector (TheType)                                                   \
d271 1
a271 1
class WitString
d451 1
a451 1
class WitAbsDenseList
@


1.2
log
@Bob's changes to
-fix Aix V4.1.5 compiler warning
-remove WitUtil::nonPortableFree macro which was causing problems in the
 lexx and yacc generated calls to free
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1
log
@Initial revision
@
text
@d791 1
a791 1
#ifdef OPT_IMPLODE
a792 3
   declare (WitDenseList, WitCoeff)

#endif
@


1.1.1.1
log
@Import wit
@
text
@@

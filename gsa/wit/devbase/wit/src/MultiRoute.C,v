head	1.86;
access;
symbols
	sce_5_01_20080919:1.64
	latest_sce_4_20_20060523:1.63.0.2
	sce_4_20_20060523:1.63
	latest_sce4_20_OSL:1.62.0.2
	sce_4_20_OSL:1.62
	sce_410_withVa:1.62
	sce_4_05_20040511:1.28
	sce_4_00_20040201:1.28
	nextGenBranch:1.27.0.2
	nextGenRoot:1.27
	sce_3_30_20030627:1.26
	EndRw-branch:1.8.0.2
	Root-of-EndRw:1.8
	rwToStl:1.6.0.2
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5;
locks; strict;
comment	@ * @;


1.86
date	2011.09.28.23.49.39;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.24.00.28.01;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.08.30.20.17.43;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2010.09.28.19.25.16;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.10.22.10.39;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.30.23.39.28;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.30.20.20.14;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.29.21.03.12;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.28.21.40.40;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.28.19.27.46;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.28.15.45.05;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.27.22.15.44;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.26.21.47.11;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.16.22.37.43;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.16.22.26.41;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.13.17.41.29;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.02.18.53.10;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2010.07.01.22.41.21;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2010.07.01.20.51.32;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.02.17.34.04;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.22.21.45.53;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.03.22.19.09.34;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.02.22.34.36;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.02.21.59.46;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.27.21.03.27;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.26.23.50.32;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.19.18.31.04;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.18.22.45.41;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.15.00.20.08;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.13.17.24.21;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.07.19.22.17;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.06.20.34.09;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.01.00.43.13;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.31.22.28.29;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.31.18.28.28;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.28.22.34.26;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.28.19.21.18;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.22.00.12.02;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.20.21.13.10;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.20.18.36.24;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.17.21.53.00;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.16.23.35.17;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.15.23.50.11;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.15.20.20.50;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.14.22.37.10;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.13.23.35.48;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.10.16.49.43;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.09.22.06.07;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.09.21.34.12;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.09.19.22.50;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.11.21.25.08;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.02.20.46.43;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.05.16.10.00;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.29.19.55.30;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.15.20.50.11;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.01.20.34.28;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.28.23.05.32;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.21.23.36.52;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.21.21.35.30;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.20.19.03.57;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.19.16.48.20;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.07.21.34.17;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.06.20.28.19;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.16.23.58.10;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.14.20.12.57;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.10.20.53.52;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.23.40.44;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.02.22.18.36;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.17.21.32.47;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.26.23.28.49;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.21.22.53.56;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.15.20.27.10;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.26.19.05.28;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.12.19.58.25;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.12.17.57.01;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.11.20.47.37;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.06.23.36.01;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.06.16.13.38;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MultiRoute.C"
//
// Contains the implementation of the following classes:
//
//    MrMgr
//    MrCoord
//    MrSelMgr
//    PmrSelMgr
//    CmrSelMgr
//    MrSite
//    MrPt
//    MrCand
//------------------------------------------------------------------------------

#include <MrMgr.h>
#include <MrCoord.h>
#include <MrSelMgr.h>
#include <MrCand.h>
#include <MrPt.h>
#include <Selector.h>
#include <MrSite.h>
#include <DetAltPt.h>
#include <RtMgr.h>
#include <RtSite.h>
#include <RtCand.h>
#include <SplitPt.h>
#include <SglSrcMgr.h>
#include <GlobalComp.h>
#include <Part.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class MrMgr.
//------------------------------------------------------------------------------

WitMrMgr::WitMrMgr (WitSelector * theSelector):

      WitProbAssoc (theSelector),
      myMrCoord_   (NULL),
      myRtMgr_     (theSelector->myRtMgr ())
   {
   myMsgFac () ("multiRouteMsg");

   myMrCoord_ = new WitMrCoord (theSelector);
   }

//------------------------------------------------------------------------------

WitMrMgr::~WitMrMgr ()
   {
   delete myMrCoord_;
   }

//------------------------------------------------------------------------------

bool WitMrMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiRoute ();
   }

//------------------------------------------------------------------------------

WitBopEntry * WitMrMgr::selBopEnt (WitPart * thePart, WitPeriod expPer)
   {
   WitRtSite * theRtSite;
   WitRtCand * theRtCand;

   theRtSite = myRtMgr_->myRtSiteFor (thePart);

   theRtCand = myMrCoord_->selRtCand (theRtSite, expPer);

   return theRtCand->myBopEnt ();
   }

//------------------------------------------------------------------------------

WitConsEntry * WitMrMgr::selConsEnt (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitRtSite * theRtSite;
   WitRtCand * theRtCand;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   theRtCand = myMrCoord_->selRtCand (theRtSite, execPer);

   return theRtCand->myConsEnt ();
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrMgr::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->selRtCand (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

bool WitMrMgr::activeForPE (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   if (not theRtCand->isEligible (thePer))
      return false;

   if (not theRtCand->usedByMr ())
      return false;

   if (not myMrCoord_->prevSel (theRtCand, thePer))
      return true;

   theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());

   if (theMrSite->myMrPt ()[thePer]->selRtCand () == NULL)
      if (theRtCand == theRtCand->myRtSite ()->mrDefaultRtCand (thePer))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitMrMgr::multiChoice (WitRtSite * theRtSite)
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->multiChoice ();
   }

//------------------------------------------------------------------------------

bool WitMrMgr::valid (WitRtCand * theRtCand, WitPeriod thePer)
   {
   if (theRtCand->isEligible (thePer))
      if (not myMrCoord_->prevSel (theRtCand, thePer))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitMrMgr::select (WitRtCand * theRtCand, WitPeriod thePer)
   {
   myMrCoord_->
      myMrSiteFor (theRtCand->myRtSite ())->
         myMrPt ()[thePer]->
            select (theRtCand);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr::mySelPtFor (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];
   }

//------------------------------------------------------------------------------

void WitMrMgr::print ()
   {
   WitRtSite * theRtSite;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Multi-Route Selection Points with Alternative(s):\n\n");

   forEachEl (theRtSite, myMrCoord_->mySelector ()->myRtMgr ()->myRtSites ())
      myMrCoord_->myMrSiteFor (theRtSite)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitMrMgr::storeRecoveryPair (WitRtSite * theRtSite, WitPeriod thePer)
   {
   myMrCoord_->storeRecoveryPair (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

void WitMrMgr::recoverInitState ()
   {
   myMrCoord_->recoverInitState ();
   }

//------------------------------------------------------------------------------

bool WitMrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   WitRtSite * theRtSite;

   theRtSite = myRtMgr_->myRtSiteFor (thePart);

   return myMrCoord_->selIsSplit (theRtSite, expPer);
   }

//------------------------------------------------------------------------------

bool WitMrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitRtSite * theRtSite;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   return myMrCoord_->selIsSplit (theRtSite, execPer);
   }

//------------------------------------------------------------------------------

void WitMrMgr::defineSplit (
      WitPart *           thePart,
      WitPeriod           expPer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitRtSite * theRtSite;

   theRtSite = myRtMgr_->myRtSiteFor (thePart);

   myMrCoord_->defineSplit (theRtSite, expPer, expVol, theSplitPairs, unbddVol);
   }

//------------------------------------------------------------------------------

void WitMrMgr::defineSplit (
      WitBomEntry *       theBomEnt,
      WitPeriod           execPer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitRtSite * theRtSite;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   myMrCoord_->
      defineSplit (theRtSite, execPer, expVol, theSplitPairs, unbddVol);
   }

//------------------------------------------------------------------------------

void WitMrMgr::recordFlowSS (
      WitBillEntry * theBillEnt,
      WitPeriod      thePer,
      double         incFlowVol)
   {
   WitRtSite * theRtSite;
   WitMrSite * theMrSite;

   theRtSite = myRtMgr_->myRtCandFor (theBillEnt)->myRtSite ();

   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);

   if (theMrSite->multiChoice ())
      theMrSite->myMrPt ()[thePer]->recordFlowSS (incFlowVol);
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrMgr::mySelMgrForProd ()
   {
   return myMrCoord_->myMrSelMgrForProd ();
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrMgr::mySelMgrForCons ()
   {
   return myMrCoord_->myMrSelMgrForCons ();
   }

//------------------------------------------------------------------------------
// Implementation of class MrCoord.
//------------------------------------------------------------------------------

WitMrCoord::WitMrCoord (WitSelector * theSelector):

      WitProbAssoc       (theSelector),
      myMrSelMgrForProd_ (NULL),
      myMrSelMgrForCons_ (NULL),
      myMrSiteFor_       (myProblem ()),
      mySelector_        (theSelector),
      prevSel_           (),
      savedRtCand_       (NULL),
      myRtSiteRecPairs_  (myProblem ()),
      myRtCandRecPairs_  (myProblem ())
   {
   WitRtSite * theRtSite;

   myMrSelMgrForProd_ = new WitPmrSelMgr (this);
   myMrSelMgrForCons_ = new WitCmrSelMgr (this);

   prevSel_.allocate1D (myProblem ());

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
   }

//------------------------------------------------------------------------------

WitMrCoord::~WitMrCoord ()
   {
   WitRtSite * theRtSite;

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      delete myMrSiteFor_ (theRtSite);

   delete myMrSelMgrForCons_;
   delete myMrSelMgrForProd_;
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrCoord::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrSiteFor_ (theRtSite)->selRtCand (thePer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitMrCoord::myAltPtFor (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;

   theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

   theMrPt   = theMrSite->myMrPtWithAlt (thePer);

   return
      (theMrPt != NULL)?
         theMrPt->myDetAltPt ():
         NULL;
   }

//------------------------------------------------------------------------------

bool WitMrCoord::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   if (not mySelector_->selSplit ())
      return false;

   theMrSite = myMrSiteFor_ (theRtSite);

   if (not theMrSite->multiChoice ())
      return false;

   return theMrSite->myMrPt ()[thePer]->isSplit ();
   }

//------------------------------------------------------------------------------

void WitMrCoord::defineSplit (
      WitRtSite *         theRtSite, 
      WitPeriod           thePer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitRtCand *        theRtCand;

   witAssert (selIsSplit (theRtSite, thePer));

   myMrSiteFor (theRtSite)->
      myMrPt ()[thePer]->
         mySplitPt ()->
            defineSplit (expVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getMrData (theRtCand);

      theSplitPairs.push (theRtCand, splitVol);
      }
   }

//------------------------------------------------------------------------------

void WitMrCoord::setPrevSel (
      WitRtCand * theRtCand, 
      WitPeriod   thePer, 
      bool        theVal)
   {
   if (not prevSel_ (theRtCand).isAllocated ())
      prevSel_ (theRtCand).allocate (myProblem (), false);

   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (prevSel_ (theRtCand)[thePer]);

   prevSel_ (theRtCand)[thePer] = theVal;

   if (myGlobalComp ()->selectionRecovery ())
      myRtCandRecPairs_.push (theRtCand, thePer);
   }


//------------------------------------------------------------------------------

void WitMrCoord::saveRtCand (WitRtCand * theRtCand)
   {
   witAssert (savedRtCand_ == NULL);
   witAssert (theRtCand    != NULL);

   savedRtCand_ = theRtCand;
   }

//------------------------------------------------------------------------------

void WitMrCoord::retrieveRtCand (WitRtCand * & theRtCand)
   {
   witAssert (savedRtCand_ != NULL);

   theRtCand    = savedRtCand_;
   savedRtCand_ = NULL;
   }

//------------------------------------------------------------------------------

void WitMrCoord::storeRecoveryPair (WitRtSite * theRtSite, WitPeriod thePer)
   {
   myRtSiteRecPairs_.push (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

void WitMrCoord::recoverInitState ()
   {
   WitRtCand * theRtCand;
   WitRtSite * theRtSite;
   WitPeriod   thePer;

   while (myRtCandRecPairs_.pop (theRtCand, thePer))
      {
      prevSel_ (theRtCand)[thePer] = false;

      if (selPrintLevelAt (3))
         prtRecover (theRtCand, thePer);
      }

   while (myRtSiteRecPairs_.pop (theRtSite, thePer))
      {
      myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitState ();
      }
   }

//------------------------------------------------------------------------------

void WitMrCoord::prtRecover (WitRtCand * theRtCand, WitPeriod thePer)
   {
   fprintf (msgFile (), "   Multi-Route Candidate Recovered:\n");

   theRtCand->myRtSite ()->printID          (7, 22);
   theRtCand->myRtSite ()->printPer (thePer, 7, 22);
   theRtCand             ->printID          (7, 22);

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------
// Implementation of class MrSelMgr.
//------------------------------------------------------------------------------

WitMrSelMgr::~WitMrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitMrSelMgr::WitMrSelMgr (WitMrCoord * theMrCoord):

      WitSelMgr  (theMrCoord->mySelector ()),
      myMrCoord_ (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

bool WitMrSelMgr::selSplitNeeded ()
   {
   return (myGlobalComp ()->selSplit ());
   }

//------------------------------------------------------------------------------
// Implementation of class PmrSelMgr.
//------------------------------------------------------------------------------

WitPmrSelMgr::WitPmrSelMgr (WitMrCoord * theMrCoord):

      WitMrSelMgr (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

WitPmrSelMgr::~WitPmrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAltPt * WitPmrSelMgr::myAltPtFor (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitRtCand * theRtCand;
   WitPeriod   expPer;

   theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theBopEnt);

   expPer    = theBopEnt->impactPeriod ()[execPer];

   return myMrCoord ()->myAltPtFor (theRtCand, expPer);
   }

//------------------------------------------------------------------------------

bool WitPmrSelMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitPmrSelMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitPmrSelMgr::validForLTBounds ()
   {
   return false;
   }

//------------------------------------------------------------------------------

const char * WitPmrSelMgr::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------
// Implementation of class CmrSelMgr.
//------------------------------------------------------------------------------

WitCmrSelMgr::WitCmrSelMgr (WitMrCoord * theMrCoord):

      WitMrSelMgr (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

WitCmrSelMgr::~WitCmrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAltPt * WitCmrSelMgr::myAltPtFor (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod)
   {
   WitRtCand * theRtCand;

   theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theConsEnt);

   return myMrCoord ()->myAltPtFor (theRtCand, execPer);
   }

//------------------------------------------------------------------------------

bool WitCmrSelMgr::validForNetting ()
   {
   return false;
   }

//------------------------------------------------------------------------------

bool WitCmrSelMgr::validForExecBounds ()
   {
   return false;
   }

//------------------------------------------------------------------------------

bool WitCmrSelMgr::validForLTBounds ()
   {
   return false;
   }

//------------------------------------------------------------------------------

const char * WitCmrSelMgr::selCaseName ()
   {
   return "Consumption Multi-Route";
   }

//------------------------------------------------------------------------------
// Implementation of class MrSite.
//------------------------------------------------------------------------------

WitMrSite::WitMrSite (WitRtSite * theRtSite, WitMrCoord * theMrCoord):

      WitProbAssoc (theMrCoord),
      myRtSite_    (theRtSite),
      myMrCoord_   (theMrCoord),
      myMrPt_      (),
      multiChoice_ (false)
   {
   multiChoice_ = compMultiChoice ();

   buildMrPts ();
   }

//------------------------------------------------------------------------------

WitMrSite::~WitMrSite ()
   {
   deleteContents (myMrPt_);
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrSite::selRtCand (WitPeriod thePer)
   {
   WitRtCand * theRtCand;

   if (multiChoice_)
      {
      theRtCand = myMrPt_[thePer]->selRtCand ();

      if (theRtCand != NULL)
         return theRtCand;
      }

   return myRtSite_->mrDefaultRtCand (thePer);
   }

//------------------------------------------------------------------------------

void WitMrSite::printHasAlt ()
   {
   WitPeriod thePer;
   WitMrPt * theMrPt;

   if (not multiChoice_)
      return;

   forEachPeriod (thePer, myProblem ())
      {
      theMrPt = myMrPt_[thePer];

      if (theMrPt != NULL)
         if (theMrPt->selRtCand () != NULL)
            {
            myRtSite_->printID          (4, 14);
            myRtSite_->printPer (thePer, 4, 14);

            fprintf (msgFile (), "\n");
            }
      }
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrSite::mySelMgr ()
   {
   return
      myRtSite_->isForProd ()?
         myMrCoord_->myMrSelMgrForProd ():
         myMrCoord_->myMrSelMgrForCons ();
   }

//------------------------------------------------------------------------------

bool WitMrSite::compMultiChoice ()
   {
   WitRtCand * theRtCand;
   bool        foundCand;

   foundCand = false;

   forEachEl (theRtCand, myRtSite_->myRtCands ())
      if (theRtCand->usedByMr ())
         {
         if (foundCand)
            return true;
         else
            foundCand = true;
         }

   return false;
   }

//------------------------------------------------------------------------------

void WitMrSite::buildMrPts ()
   {
   WitPeriod thePer;

   if (not multiChoice_)
      return;

   myMrPt_.allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      if (myRtSite_->mrDefaultRtCand (thePer) != NULL)
         myMrPt_[thePer] = new WitMrPt (this, thePer);
   }

//------------------------------------------------------------------------------

WitMrPt * WitMrSite::multiChoiceMrPtWithAlt (WitPeriod thePer)
   {
   WitMrPt * theMrPt;

   witAssert (multiChoice_);

   if (myRtSite_->propRtg ()[thePer])
      return NULL;

   theMrPt = myMrPt_[thePer];

   witAssert (theMrPt != NULL);

   return
      (theMrPt->selRtCand () != NULL)?
         theMrPt:
         NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class template MrPt.
//------------------------------------------------------------------------------

inline WitSelector * WitMrPt::mySelector ()
   {
   return myMrSite_->myMrCoord ()->mySelector ();
   }

//------------------------------------------------------------------------------

WitMrPt::WitMrPt (WitMrSite * theMrSite, WitPeriod thePer):

      WitDetSelPt (),

      myMrSite_   (theMrSite),
      myPer_      (thePer),
      selRtCand_  (NULL),
      hasResAlt_  (false)
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);

   refreshHasResAlt ();
   }

//------------------------------------------------------------------------------

WitMrPt::~WitMrPt ()
   {
   }

//------------------------------------------------------------------------------

void WitMrPt::select (WitRtCand * theRtCand)
   {
   if (mySelector ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveConfigVal (selRtCand_);

   selRtCand_ = theRtCand;
   }

//------------------------------------------------------------------------------

void WitMrPt::recoverInitState ()
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);

   refreshHasResAlt ();

   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrPt::mySelMgr ()
   {
   return myMrSite_->mySelMgr ();
   }

//------------------------------------------------------------------------------

void WitMrPt::prtID ()
   {
   myMrSite_->myRtSite ()->printID          (4, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);
   }

//------------------------------------------------------------------------------

bool WitMrPt::splittable ()
   {
   if (mySelector ()->sglSrc ())
      if (sglSrcMode ())
         return false;

   return (myMrSite_->myGlobalComp ()->selSplit ());
   }

//------------------------------------------------------------------------------

void WitMrPt::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   thePart = myMrSite_->myRtSite ()->mrSortPart ();

   thePer  = myPer_;
   }

//------------------------------------------------------------------------------

WitSelCand * WitMrPt::newSelCand ()
   {
   return new WitMrCand (selRtCand_);
   }

//------------------------------------------------------------------------------

bool WitMrPt::sglSrcMode ()
   {
   witAssert (mySelector ()->sglSrc ());

   return mySelector ()->mySglSrcMgr ()->sglSrcMode (myMrSite_->myRtSite ());
   }

//------------------------------------------------------------------------------

bool WitMrPt::hasResAlt ()
   {
   witAssert (selRtCand_ != NULL);

   return hasResAlt_;
   }

//------------------------------------------------------------------------------

void WitMrPt::alterSelection ()
   {
   witAssert (selRtCand_ != NULL);

   if (mySelector ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveConfigVal (hasResAlt_);

   myMrSite_->myMrCoord ()->setPrevSel (selRtCand_, myPer_, true);

   select (findNextRtCand ());

   refreshHasResAlt ();
   }

//------------------------------------------------------------------------------

void WitMrPt::storeRecoveryPt ()
   {
   myMrSite_->
      myMrCoord ()->
         storeRecoveryPair (myMrSite_->myRtSite (), myPer_);
   }

//------------------------------------------------------------------------------

void WitMrPt::tempAlterSel ()
   {
   myMrSite_->myMrCoord ()->saveRtCand (selRtCand_);

   alterSelection ();
   }

//------------------------------------------------------------------------------

void WitMrPt::cancelTempAlt ()
   {
   WitRtCand * theRtCand;

   myMrSite_->myMrCoord ()->retrieveRtCand (theRtCand);

   witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));

   myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);

   select (theRtCand);

   refreshHasResAlt ();
   }

//------------------------------------------------------------------------------

void WitMrPt::printAlteration ()
   {
   fprintf (msgFile (),
      "\n"
      "Multi-Route Alteration:\n");

   myMrSite_->myRtSite ()->printID          (4, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);

   fprintf (msgFile (), "   Selection:\n");

   if (selRtCand_ != NULL)
      selRtCand_->printID (7, 22);
   else
      fprintf (msgFile (), "      None\n");
   }

//------------------------------------------------------------------------------

void WitMrPt::refreshHasResAlt ()
   {
   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrPt::findNextRtCand ()
   {
   WitRtCand * theRtCand;

   forEachEl (theRtCand, myMrSite_->myRtSite ()->myRtCands ())
      if (theRtCand->usedByMr ())
         if (theRtCand->isEligible (myPer_))
            if (not myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_))
               if (theRtCand != selRtCand_)
                  return theRtCand;

   return NULL;
   }

//------------------------------------------------------------------------------

void WitMrPt::printRecovery ()
   {
   fprintf (msgFile (),
      "   Initial Multi-Route Selection Recovered:\n");

   myMrSite_->myRtSite ()->printID          (7, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 7, 22);
   selRtCand_            ->printID          (7, 22);

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

FILE * WitMrPt::msgFile ()
   {
   return myMrSite_->msgFile ();
   }

//------------------------------------------------------------------------------
// Implementation of class MrCand.
//------------------------------------------------------------------------------

WitMrCand::WitMrCand (WitRtCand * theRtCand):

      WitSelCand (theRtCand->myProblem ()),
      myRtCand_  (theRtCand)
   {
   }

//------------------------------------------------------------------------------

WitMrCand::~WitMrCand ()
   {
   }

//------------------------------------------------------------------------------

void WitMrCand::prtID ()
   {
   myRtCand_->printID (7, 22);
   }

//------------------------------------------------------------------------------

void WitMrCand::getMrData (WitRtCand * & theRtCand)
   {
   theRtCand = myRtCand_;
   }
@


1.85
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.84
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d51 5
a55 5
WitProbAssoc (theSelector),
myMrCoord_   (NULL),
myRtMgr_     (theSelector->myRtMgr ())
{
myMsgFac () ("multiRouteMsg");
d57 2
a58 2
myMrCoord_ = new WitMrCoord (theSelector);
}
d63 3
a65 3
{
delete myMrCoord_;
}
d70 3
a72 3
{
return theProblem->myGlobalComp ()->multiRoute ();
}
d77 3
a79 3
{
WitRtSite * theRtSite;
WitRtCand * theRtCand;
d81 1
a81 1
theRtSite = myRtMgr_->myRtSiteFor (thePart);
d83 1
a83 1
theRtCand = myMrCoord_->selRtCand (theRtSite, expPer);
d85 2
a86 2
return theRtCand->myBopEnt ();
}
d91 3
a93 3
{
WitRtSite * theRtSite;
WitRtCand * theRtCand;
d95 1
a95 1
theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d97 1
a97 1
theRtCand = myMrCoord_->selRtCand (theRtSite, execPer);
d99 2
a100 2
return theRtCand->myConsEnt ();
}
d105 3
a107 3
{
return myMrCoord_->selRtCand (theRtSite, thePer);
}
d112 2
a113 2
{
WitMrSite * theMrSite;
d115 2
a116 2
if (not theRtCand->isEligible (thePer))
return false;
d118 2
a119 2
if (not theRtCand->usedByMr ())
return false;
d121 2
a122 2
if (not myMrCoord_->prevSel (theRtCand, thePer))
return true;
d124 1
a124 1
theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());
d126 3
a128 3
if (theMrSite->myMrPt ()[thePer]->selRtCand () == NULL)
if (theRtCand == theRtCand->myRtSite ()->mrDefaultRtCand (thePer))
return true;
d130 2
a131 2
return false;
}
d136 3
a138 3
{
return myMrCoord_->myMrSiteFor (theRtSite)->multiChoice ();
}
d143 4
a146 4
{
if (theRtCand->isEligible (thePer))
if (not myMrCoord_->prevSel (theRtCand, thePer))
return true;
d148 2
a149 2
return false;
}
d154 6
a159 6
{
myMrCoord_->
myMrSiteFor (theRtCand->myRtSite ())->
myMrPt ()[thePer]->
select (theRtCand);
}
d164 3
a166 3
{
return myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];
}
d171 2
a172 2
{
WitRtSite * theRtSite;
d174 4
a177 4
fprintf (msgFile (),
"\n"
"\n"
"Multi-Route Selection Points with Alternative(s):\n\n");
d179 2
a180 2
forEachEl (theRtSite, myMrCoord_->mySelector ()->myRtMgr ()->myRtSites ())
myMrCoord_->myMrSiteFor (theRtSite)->printHasAlt ();
d182 2
a183 2
fprintf (msgFile (), "\n");
}
d188 3
a190 3
{
myMrCoord_->storeRecoveryPair (theRtSite, thePer);
}
d195 3
a197 3
{
myMrCoord_->recoverInitState ();
}
d202 2
a203 2
{
WitRtSite * theRtSite;
d205 1
a205 1
theRtSite = myRtMgr_->myRtSiteFor (thePart);
d207 2
a208 2
return myMrCoord_->selIsSplit (theRtSite, expPer);
}
d213 2
a214 2
{
WitRtSite * theRtSite;
d216 1
a216 1
theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d218 2
a219 2
return myMrCoord_->selIsSplit (theRtSite, execPer);
}
d224 7
a230 7
WitPart *           thePart,
WitPeriod           expPer,
double              expVol,
WitRtCandDblStack & theSplitPairs,
double &            unbddVol)
{
WitRtSite * theRtSite;
d232 1
a232 1
theRtSite = myRtMgr_->myRtSiteFor (thePart);
d234 2
a235 2
myMrCoord_->defineSplit (theRtSite, expPer, expVol, theSplitPairs, unbddVol);
}
d240 13
a252 13
WitBomEntry *       theBomEnt,
WitPeriod           execPer,
double              expVol,
WitRtCandDblStack & theSplitPairs,
double &            unbddVol)
{
WitRtSite * theRtSite;

theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

myMrCoord_->
defineSplit (theRtSite, execPer, expVol, theSplitPairs, unbddVol);
}
d257 14
a270 14
WitBillEntry * theBillEnt,
WitPeriod      thePer,
double         incFlowVol)
{
WitRtSite * theRtSite;
WitMrSite * theMrSite;

theRtSite = myRtMgr_->myRtCandFor (theBillEnt)->myRtSite ();

theMrSite = myMrCoord_->myMrSiteFor (theRtSite);

if (theMrSite->multiChoice ())
theMrSite->myMrPt ()[thePer]->recordFlowSS (incFlowVol);
}
d275 3
a277 3
{
return myMrCoord_->myMrSelMgrForProd ();
}
d282 3
a284 3
{
return myMrCoord_->myMrSelMgrForCons ();
}
d292 20
a311 20
WitProbAssoc       (theSelector),
myMrSelMgrForProd_ (NULL),
myMrSelMgrForCons_ (NULL),
myMrSiteFor_       (myProblem ()),
mySelector_        (theSelector),
prevSel_           (),
savedRtCand_       (NULL),
myRtSiteRecPairs_  (myProblem ()),
myRtCandRecPairs_  (myProblem ())
{
WitRtSite * theRtSite;

myMrSelMgrForProd_ = new WitPmrSelMgr (this);
myMrSelMgrForCons_ = new WitCmrSelMgr (this);

prevSel_.allocate1D (myProblem ());

forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
}
d316 2
a317 2
{
WitRtSite * theRtSite;
d319 2
a320 2
forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
delete myMrSiteFor_ (theRtSite);
d322 3
a324 3
delete myMrSelMgrForCons_;
delete myMrSelMgrForProd_;
}
d329 3
a331 3
{
return myMrSiteFor_ (theRtSite)->selRtCand (thePer);
}
d336 13
a348 13
{
WitMrSite * theMrSite;
WitMrPt *   theMrPt;

theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

theMrPt   = theMrSite->myMrPtWithAlt (thePer);

return
(theMrPt != NULL)?
theMrPt->myDetAltPt ():
NULL;
}
d353 2
a354 2
{
WitMrSite * theMrSite;
d356 2
a357 2
if (not mySelector_->selSplit ())
return false;
d359 1
a359 1
theMrSite = myMrSiteFor_ (theRtSite);
d361 2
a362 2
if (not theMrSite->multiChoice ())
return false;
d364 2
a365 2
return theMrSite->myMrPt ()[thePer]->isSplit ();
}
d370 27
a396 27
WitRtSite *         theRtSite,
WitPeriod           thePer,
double              expVol,
WitRtCandDblStack & theSplitPairs,
double &            unbddVol)
{
WitSelCandDblStack theAbsSplitPairs (myProblem ());
WitSelCand *       theSelCand;
double             splitVol;
WitRtCand *        theRtCand;

witAssert (selIsSplit (theRtSite, thePer));

myMrSiteFor (theRtSite)->
myMrPt ()[thePer]->
mySplitPt ()->
defineSplit (expVol, theAbsSplitPairs, unbddVol);

theSplitPairs.clear ();

while (theAbsSplitPairs.pop (theSelCand, splitVol))
{
theSelCand->getMrData (theRtCand);

theSplitPairs.push (theRtCand, splitVol);
}
}
d401 15
a415 15
WitRtCand * theRtCand,
WitPeriod   thePer,
bool        theVal)
{
if (not prevSel_ (theRtCand).isAllocated ())
prevSel_ (theRtCand).allocate (myProblem (), false);

if (mySelector_->sglSrc ())
mySelector_->mySglSrcMgr ()->saveConfigVal (prevSel_ (theRtCand)[thePer]);

prevSel_ (theRtCand)[thePer] = theVal;

if (myGlobalComp ()->selectionRecovery ())
myRtCandRecPairs_.push (theRtCand, thePer);
}
d421 3
a423 3
{
witAssert (savedRtCand_ == NULL);
witAssert (theRtCand    != NULL);
d425 2
a426 2
savedRtCand_ = theRtCand;
}
d431 2
a432 2
{
witAssert (savedRtCand_ != NULL);
d434 3
a436 3
theRtCand    = savedRtCand_;
savedRtCand_ = NULL;
}
d441 3
a443 3
{
myRtSiteRecPairs_.push (theRtSite, thePer);
}
d448 18
a465 18
{
WitRtCand * theRtCand;
WitRtSite * theRtSite;
WitPeriod   thePer;

while (myRtCandRecPairs_.pop (theRtCand, thePer))
{
prevSel_ (theRtCand)[thePer] = false;

if (selPrintLevelAt (3))
prtRecover (theRtCand, thePer);
}

while (myRtSiteRecPairs_.pop (theRtSite, thePer))
{
myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitState ();
}
}
d470 2
a471 2
{
fprintf (msgFile (), "   Multi-Route Candidate Recovered:\n");
d473 3
a475 3
theRtCand->myRtSite ()->printID          (7, 22);
theRtCand->myRtSite ()->printPer (thePer, 7, 22);
theRtCand             ->printID          (7, 22);
d477 2
a478 2
fprintf (msgFile (), "\n");
}
d485 2
a486 2
{
}
d492 4
a495 4
WitSelMgr  (theMrCoord->mySelector ()),
myMrCoord_ (theMrCoord)
{
}
d500 3
a502 3
{
return (myGlobalComp ()->selSplit ());
}
d510 3
a512 3
WitMrSelMgr (theMrCoord)
{
}
d517 2
a518 2
{
}
d523 7
a529 7
WitBopEntry * theBopEnt,
WitConsEntry *,
WitPeriod     execPer,
WitPeriod)
{
WitRtCand * theRtCand;
WitPeriod   expPer;
d531 1
a531 1
theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theBopEnt);
d533 1
a533 1
expPer    = theBopEnt->impactPeriod ()[execPer];
d535 2
a536 2
return myMrCoord ()->myAltPtFor (theRtCand, expPer);
}
d541 3
a543 3
{
return true;
}
d548 3
a550 3
{
return true;
}
d555 3
a557 3
{
return false;
}
d562 3
a564 3
{
return "Production Multi-Route";
}
d572 3
a574 3
WitMrSelMgr (theMrCoord)
{
}
d579 2
a580 2
{
}
d585 6
a590 6
WitBopEntry *,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod)
{
WitRtCand * theRtCand;
d592 1
a592 1
theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theConsEnt);
d594 2
a595 2
return myMrCoord ()->myAltPtFor (theRtCand, execPer);
}
d600 3
a602 3
{
return false;
}
d607 3
a609 3
{
return false;
}
d614 3
a616 3
{
return false;
}
d621 3
a623 3
{
return "Consumption Multi-Route";
}
d631 7
a637 7
WitProbAssoc (theMrCoord),
myRtSite_    (theRtSite),
myMrCoord_   (theMrCoord),
myMrPt_      (),
multiChoice_ (false)
{
multiChoice_ = compMultiChoice ();
d639 2
a640 2
buildMrPts ();
}
d645 3
a647 3
{
deleteContents (myMrPt_);
}
d652 2
a653 2
{
WitRtCand * theRtCand;
d655 7
a661 7
if (multiChoice_)
{
theRtCand = myMrPt_[thePer]->selRtCand ();

if (theRtCand != NULL)
return theRtCand;
}
d663 2
a664 2
return myRtSite_->mrDefaultRtCand (thePer);
}
d669 21
a689 21
{
WitPeriod thePer;
WitMrPt * theMrPt;

if (not multiChoice_)
return;

forEachPeriod (thePer, myProblem ())
{
theMrPt = myMrPt_[thePer];

if (theMrPt != NULL)
if (theMrPt->selRtCand () != NULL)
{
myRtSite_->printID          (4, 14);
myRtSite_->printPer (thePer, 4, 14);

fprintf (msgFile (), "\n");
}
}
}
d694 6
a699 6
{
return
myRtSite_->isForProd ()?
myMrCoord_->myMrSelMgrForProd ():
myMrCoord_->myMrSelMgrForCons ();
}
d704 14
a717 14
{
WitRtCand * theRtCand;
bool        foundCand;

foundCand = false;

forEachEl (theRtCand, myRtSite_->myRtCands ())
if (theRtCand->usedByMr ())
{
if (foundCand)
return true;
else
foundCand = true;
}
d719 2
a720 2
return false;
}
d725 2
a726 2
{
WitPeriod thePer;
d728 2
a729 2
if (not multiChoice_)
return;
d731 1
a731 1
myMrPt_.allocate (myProblem ());
d733 4
a736 4
forEachPeriod (thePer, myProblem ())
if (myRtSite_->mrDefaultRtCand (thePer) != NULL)
myMrPt_[thePer] = new WitMrPt (this, thePer);
}
d741 2
a742 2
{
WitMrPt * theMrPt;
d744 1
a744 1
witAssert (multiChoice_);
d746 2
a747 2
if (myRtSite_->propRtg ()[thePer])
return NULL;
d749 1
a749 1
theMrPt = myMrPt_[thePer];
d751 1
a751 1
witAssert (theMrPt != NULL);
d753 5
a757 5
return
(theMrPt->selRtCand () != NULL)?
theMrPt:
NULL;
}
d764 3
a766 3
{
return myMrSite_->myMrCoord ()->mySelector ();
}
d772 1
a772 1
WitDetSelPt (),
d774 6
a779 6
myMrSite_   (theMrSite),
myPer_      (thePer),
selRtCand_  (NULL),
hasResAlt_  (false)
{
selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);
d781 2
a782 2
refreshHasResAlt ();
}
d787 2
a788 2
{
}
d793 3
a795 3
{
if (mySelector ()->sglSrc ())
mySelector ()->mySglSrcMgr ()->saveConfigVal (selRtCand_);
d797 2
a798 2
selRtCand_ = theRtCand;
}
d803 2
a804 2
{
selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);
d806 1
a806 1
refreshHasResAlt ();
d808 3
a810 3
if (mySelMgr ()->selPrintLevelAt (3))
printRecovery ();
}
d815 3
a817 3
{
return myMrSite_->mySelMgr ();
}
d822 4
a825 4
{
myMrSite_->myRtSite ()->printID          (4, 22);
myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);
}
d830 4
a833 4
{
if (mySelector ()->sglSrc ())
if (sglSrcMode ())
return false;
d835 2
a836 2
return (myMrSite_->myGlobalComp ()->selSplit ());
}
d841 2
a842 2
{
thePart = myMrSite_->myRtSite ()->mrSortPart ();
d844 2
a845 2
thePer  = myPer_;
}
d850 3
a852 3
{
return new WitMrCand (selRtCand_);
}
d857 2
a858 2
{
witAssert (mySelector ()->sglSrc ());
d860 2
a861 2
return mySelector ()->mySglSrcMgr ()->sglSrcMode (myMrSite_->myRtSite ());
}
d866 2
a867 2
{
witAssert (selRtCand_ != NULL);
d869 2
a870 2
return hasResAlt_;
}
d875 2
a876 2
{
witAssert (selRtCand_ != NULL);
d878 2
a879 2
if (mySelector ()->sglSrc ())
mySelector ()->mySglSrcMgr ()->saveConfigVal (hasResAlt_);
d881 1
a881 1
myMrSite_->myMrCoord ()->setPrevSel (selRtCand_, myPer_, true);
d883 1
a883 1
select (findNextRtCand ());
d885 2
a886 2
refreshHasResAlt ();
}
d891 5
a895 5
{
myMrSite_->
myMrCoord ()->
storeRecoveryPair (myMrSite_->myRtSite (), myPer_);
}
d900 2
a901 2
{
myMrSite_->myMrCoord ()->saveRtCand (selRtCand_);
d903 2
a904 2
alterSelection ();
}
d909 2
a910 2
{
WitRtCand * theRtCand;
d912 1
a912 1
myMrSite_->myMrCoord ()->retrieveRtCand (theRtCand);
d914 1
a914 1
witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));
d916 1
a916 1
myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);
d918 1
a918 1
select (theRtCand);
d920 2
a921 2
refreshHasResAlt ();
}
d926 15
a940 15
{
fprintf (msgFile (),
"\n"
"Multi-Route Alteration:\n");

myMrSite_->myRtSite ()->printID          (4, 22);
myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);

fprintf (msgFile (), "   Selection:\n");

if (selRtCand_ != NULL)
selRtCand_->printID (7, 22);
else
fprintf (msgFile (), "      None\n");
}
d945 3
a947 3
{
hasResAlt_ = (findNextRtCand () != NULL);
}
d952 2
a953 2
{
WitRtCand * theRtCand;
d955 6
a960 6
forEachEl (theRtCand, myMrSite_->myRtSite ()->myRtCands ())
if (theRtCand->usedByMr ())
if (theRtCand->isEligible (myPer_))
if (not myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_))
if (theRtCand != selRtCand_)
return theRtCand;
d962 2
a963 2
return NULL;
}
d968 7
a974 7
{
fprintf (msgFile (),
"   Initial Multi-Route Selection Recovered:\n");

myMrSite_->myRtSite ()->printID          (7, 22);
myMrSite_->myRtSite ()->printPer (myPer_, 7, 22);
selRtCand_            ->printID          (7, 22);
d976 2
a977 2
fprintf (msgFile (), "\n");
}
d982 3
a984 3
{
return myMrSite_->msgFile ();
}
d992 4
a995 4
WitSelCand (theRtCand->myProblem ()),
myRtCand_  (theRtCand)
{
}
d1000 2
a1001 2
{
}
d1006 3
a1008 3
{
myRtCand_->printID (7, 22);
}
d1013 3
a1015 3
{
theRtCand = myRtCand_;
}
@


1.83
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d51 5
a55 5
      WitProbAssoc (theSelector),
      myMrCoord_   (NULL),
      myRtMgr_     (theSelector->myRtMgr ())
   {
   myMsgFac () ("multiRouteMsg");
d57 2
a58 2
   myMrCoord_ = new WitMrCoord (theSelector);
   }
d63 3
a65 3
   {
   delete myMrCoord_;
   }
d70 3
a72 3
   {
   return theProblem->myGlobalComp ()->multiRoute ();
   }
d77 3
a79 3
   {
   WitRtSite * theRtSite;
   WitRtCand * theRtCand;
d81 1
a81 1
   theRtSite = myRtMgr_->myRtSiteFor (thePart);
d83 1
a83 1
   theRtCand = myMrCoord_->selRtCand (theRtSite, expPer);
d85 2
a86 2
   return theRtCand->myBopEnt ();
   }
d91 3
a93 3
   {
   WitRtSite * theRtSite;
   WitRtCand * theRtCand;
d95 1
a95 1
   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d97 1
a97 1
   theRtCand = myMrCoord_->selRtCand (theRtSite, execPer);
d99 2
a100 2
   return theRtCand->myConsEnt ();
   }
d105 3
a107 3
   {
   return myMrCoord_->selRtCand (theRtSite, thePer);
   }
d112 2
a113 2
   {
   WitMrSite * theMrSite;
d115 2
a116 2
   if (not theRtCand->isEligible (thePer))
      return false;
d118 2
a119 2
   if (not theRtCand->usedByMr ())
      return false;
d121 2
a122 2
   if (not myMrCoord_->prevSel (theRtCand, thePer))
      return true;
d124 1
a124 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());
d126 3
a128 3
   if (theMrSite->myMrPt ()[thePer]->selRtCand () == NULL)
      if (theRtCand == theRtCand->myRtSite ()->mrDefaultRtCand (thePer))
         return true;
d130 2
a131 2
   return false;
   }
d136 3
a138 3
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->multiChoice ();
   }
d143 4
a146 4
   {
   if (theRtCand->isEligible (thePer))
      if (not myMrCoord_->prevSel (theRtCand, thePer))
         return true;
d148 2
a149 2
   return false;
   }
d154 6
a159 6
   {
   myMrCoord_->
      myMrSiteFor (theRtCand->myRtSite ())->
         myMrPt ()[thePer]->
            select (theRtCand);
   }
d164 3
a166 3
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];
   }
d171 2
a172 2
   {
   WitRtSite * theRtSite;
d174 4
a177 4
   fprintf (msgFile (),
      "\n"
      "\n"
      "Multi-Route Selection Points with Alternative(s):\n\n");
d179 2
a180 2
   forEachEl (theRtSite, myMrCoord_->mySelector ()->myRtMgr ()->myRtSites ())
      myMrCoord_->myMrSiteFor (theRtSite)->printHasAlt ();
d182 2
a183 2
   fprintf (msgFile (), "\n");
   }
d188 3
a190 3
   {
   myMrCoord_->storeRecoveryPair (theRtSite, thePer);
   }
d195 3
a197 3
   {
   myMrCoord_->recoverInitState ();
   }
d202 2
a203 2
   {
   WitRtSite * theRtSite;
d205 1
a205 1
   theRtSite = myRtMgr_->myRtSiteFor (thePart);
d207 2
a208 2
   return myMrCoord_->selIsSplit (theRtSite, expPer);
   }
d213 2
a214 2
   {
   WitRtSite * theRtSite;
d216 1
a216 1
   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d218 2
a219 2
   return myMrCoord_->selIsSplit (theRtSite, execPer);
   }
d224 7
a230 7
      WitPart *           thePart,
      WitPeriod           expPer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitRtSite * theRtSite;
d232 1
a232 1
   theRtSite = myRtMgr_->myRtSiteFor (thePart);
d234 2
a235 2
   myMrCoord_->defineSplit (theRtSite, expPer, expVol, theSplitPairs, unbddVol);
   }
d240 13
a252 13
      WitBomEntry *       theBomEnt,
      WitPeriod           execPer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitRtSite * theRtSite;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   myMrCoord_->
      defineSplit (theRtSite, execPer, expVol, theSplitPairs, unbddVol);
   }
d257 14
a270 14
      WitBillEntry * theBillEnt,
      WitPeriod      thePer,
      double         incFlowVol)
   {
   WitRtSite * theRtSite;
   WitMrSite * theMrSite;

   theRtSite = myRtMgr_->myRtCandFor (theBillEnt)->myRtSite ();

   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);

   if (theMrSite->multiChoice ())
      theMrSite->myMrPt ()[thePer]->recordFlowSS (incFlowVol);
   }
d275 3
a277 3
   {
   return myMrCoord_->myMrSelMgrForProd ();
   }
d282 3
a284 3
   {
   return myMrCoord_->myMrSelMgrForCons ();
   }
d292 20
a311 20
      WitProbAssoc       (theSelector),
      myMrSelMgrForProd_ (NULL),
      myMrSelMgrForCons_ (NULL),
      myMrSiteFor_       (myProblem ()),
      mySelector_        (theSelector),
      prevSel_           (),
      savedRtCand_       (NULL),
      myRtSiteRecPairs_  (myProblem ()),
      myRtCandRecPairs_  (myProblem ())
   {
   WitRtSite * theRtSite;

   myMrSelMgrForProd_ = new WitPmrSelMgr (this);
   myMrSelMgrForCons_ = new WitCmrSelMgr (this);

   prevSel_.allocate1D (myProblem ());

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
   }
d316 2
a317 2
   {
   WitRtSite * theRtSite;
d319 2
a320 2
   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      delete myMrSiteFor_ (theRtSite);
d322 3
a324 3
   delete myMrSelMgrForCons_;
   delete myMrSelMgrForProd_;
   }
d329 3
a331 3
   {
   return myMrSiteFor_ (theRtSite)->selRtCand (thePer);
   }
d336 13
a348 13
   {
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;

   theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

   theMrPt   = theMrSite->myMrPtWithAlt (thePer);

   return
      (theMrPt != NULL)?
         theMrPt->myDetAltPt ():
         NULL;
   }
d353 2
a354 2
   {
   WitMrSite * theMrSite;
d356 2
a357 2
   if (not mySelector_->selSplit ())
      return false;
d359 1
a359 1
   theMrSite = myMrSiteFor_ (theRtSite);
d361 2
a362 2
   if (not theMrSite->multiChoice ())
      return false;
d364 2
a365 2
   return theMrSite->myMrPt ()[thePer]->isSplit ();
   }
d370 27
a396 27
      WitRtSite *         theRtSite, 
      WitPeriod           thePer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      double &            unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitRtCand *        theRtCand;

   witAssert (selIsSplit (theRtSite, thePer));

   myMrSiteFor (theRtSite)->
      myMrPt ()[thePer]->
         mySplitPt ()->
            defineSplit (expVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getMrData (theRtCand);

      theSplitPairs.push (theRtCand, splitVol);
      }
   }
d401 15
a415 15
      WitRtCand * theRtCand, 
      WitPeriod   thePer, 
      bool        theVal)
   {
   if (not prevSel_ (theRtCand).isAllocated ())
      prevSel_ (theRtCand).allocate (myProblem (), false);

   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (prevSel_ (theRtCand)[thePer]);

   prevSel_ (theRtCand)[thePer] = theVal;

   if (myGlobalComp ()->selectionRecovery ())
      myRtCandRecPairs_.push (theRtCand, thePer);
   }
d421 3
a423 3
   {
   witAssert (savedRtCand_ == NULL);
   witAssert (theRtCand    != NULL);
d425 2
a426 2
   savedRtCand_ = theRtCand;
   }
d431 2
a432 2
   {
   witAssert (savedRtCand_ != NULL);
d434 3
a436 3
   theRtCand    = savedRtCand_;
   savedRtCand_ = NULL;
   }
d441 3
a443 3
   {
   myRtSiteRecPairs_.push (theRtSite, thePer);
   }
d448 18
a465 18
   {
   WitRtCand * theRtCand;
   WitRtSite * theRtSite;
   WitPeriod   thePer;

   while (myRtCandRecPairs_.pop (theRtCand, thePer))
      {
      prevSel_ (theRtCand)[thePer] = false;

      if (selPrintLevelAt (3))
         prtRecover (theRtCand, thePer);
      }

   while (myRtSiteRecPairs_.pop (theRtSite, thePer))
      {
      myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitState ();
      }
   }
d470 2
a471 2
   {
   fprintf (msgFile (), "   Multi-Route Candidate Recovered:\n");
d473 3
a475 3
   theRtCand->myRtSite ()->printID          (7, 22);
   theRtCand->myRtSite ()->printPer (thePer, 7, 22);
   theRtCand             ->printID          (7, 22);
d477 2
a478 2
   fprintf (msgFile (), "\n");
   }
d485 2
a486 2
   {
   }
d492 4
a495 4
      WitSelMgr  (theMrCoord->mySelector ()),
      myMrCoord_ (theMrCoord)
   {
   }
d500 3
a502 3
   {
   return (myGlobalComp ()->selSplit ());
   }
d510 3
a512 3
      WitMrSelMgr (theMrCoord)
   {
   }
d517 2
a518 2
   {
   }
d523 7
a529 7
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitRtCand * theRtCand;
   WitPeriod   expPer;
d531 1
a531 1
   theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theBopEnt);
d533 1
a533 1
   expPer    = theBopEnt->impactPeriod ()[execPer];
d535 2
a536 2
   return myMrCoord ()->myAltPtFor (theRtCand, expPer);
   }
d541 3
a543 3
   {
   return true;
   }
d548 3
a550 3
   {
   return true;
   }
d555 3
a557 3
   {
   return false;
   }
d562 3
a564 3
   {
   return "Production Multi-Route";
   }
d572 3
a574 3
      WitMrSelMgr (theMrCoord)
   {
   }
d579 2
a580 2
   {
   }
d585 6
a590 6
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod)
   {
   WitRtCand * theRtCand;
d592 1
a592 1
   theRtCand = mySelector ()->myRtMgr ()->myRtCandFor (theConsEnt);
d594 2
a595 2
   return myMrCoord ()->myAltPtFor (theRtCand, execPer);
   }
d600 3
a602 3
   {
   return false;
   }
d607 3
a609 3
   {
   return false;
   }
d614 3
a616 3
   {
   return false;
   }
d621 3
a623 3
   {
   return "Consumption Multi-Route";
   }
d631 7
a637 7
      WitProbAssoc (theMrCoord),
      myRtSite_    (theRtSite),
      myMrCoord_   (theMrCoord),
      myMrPt_      (),
      multiChoice_ (false)
   {
   multiChoice_ = compMultiChoice ();
d639 2
a640 2
   buildMrPts ();
   }
d645 3
a647 3
   {
   deleteContents (myMrPt_);
   }
d652 2
a653 2
   {
   WitRtCand * theRtCand;
d655 7
a661 7
   if (multiChoice_)
      {
      theRtCand = myMrPt_[thePer]->selRtCand ();

      if (theRtCand != NULL)
         return theRtCand;
      }
d663 2
a664 2
   return myRtSite_->mrDefaultRtCand (thePer);
   }
d669 21
a689 21
   {
   WitPeriod thePer;
   WitMrPt * theMrPt;

   if (not multiChoice_)
      return;

   forEachPeriod (thePer, myProblem ())
      {
      theMrPt = myMrPt_[thePer];

      if (theMrPt != NULL)
         if (theMrPt->selRtCand () != NULL)
            {
            myRtSite_->printID          (4, 14);
            myRtSite_->printPer (thePer, 4, 14);

            fprintf (msgFile (), "\n");
            }
      }
   }
d694 6
a699 6
   {
   return
      myRtSite_->isForProd ()?
         myMrCoord_->myMrSelMgrForProd ():
         myMrCoord_->myMrSelMgrForCons ();
   }
d704 14
a717 14
   {
   WitRtCand * theRtCand;
   bool        foundCand;

   foundCand = false;

   forEachEl (theRtCand, myRtSite_->myRtCands ())
      if (theRtCand->usedByMr ())
         {
         if (foundCand)
            return true;
         else
            foundCand = true;
         }
d719 2
a720 2
   return false;
   }
d725 2
a726 2
   {
   WitPeriod thePer;
d728 2
a729 2
   if (not multiChoice_)
      return;
d731 1
a731 1
   myMrPt_.allocate (myProblem ());
d733 4
a736 4
   forEachPeriod (thePer, myProblem ())
      if (myRtSite_->mrDefaultRtCand (thePer) != NULL)
         myMrPt_[thePer] = new WitMrPt (this, thePer);
   }
d741 2
a742 2
   {
   WitMrPt * theMrPt;
d744 1
a744 1
   witAssert (multiChoice_);
d746 2
a747 2
   if (myRtSite_->propRtg ()[thePer])
      return NULL;
d749 1
a749 1
   theMrPt = myMrPt_[thePer];
d751 1
a751 1
   witAssert (theMrPt != NULL);
d753 5
a757 5
   return
      (theMrPt->selRtCand () != NULL)?
         theMrPt:
         NULL;
   }
d764 3
a766 3
   {
   return myMrSite_->myMrCoord ()->mySelector ();
   }
d772 1
a772 1
      WitDetSelPt (),
d774 6
a779 6
      myMrSite_   (theMrSite),
      myPer_      (thePer),
      selRtCand_  (NULL),
      hasResAlt_  (false)
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);
d781 2
a782 2
   refreshHasResAlt ();
   }
d787 2
a788 2
   {
   }
d793 3
a795 3
   {
   if (mySelector ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveConfigVal (selRtCand_);
d797 2
a798 2
   selRtCand_ = theRtCand;
   }
d803 2
a804 2
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);
d806 1
a806 1
   refreshHasResAlt ();
d808 3
a810 3
   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }
d815 3
a817 3
   {
   return myMrSite_->mySelMgr ();
   }
d822 4
a825 4
   {
   myMrSite_->myRtSite ()->printID          (4, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);
   }
d830 4
a833 4
   {
   if (mySelector ()->sglSrc ())
      if (sglSrcMode ())
         return false;
d835 2
a836 2
   return (myMrSite_->myGlobalComp ()->selSplit ());
   }
d841 2
a842 2
   {
   thePart = myMrSite_->myRtSite ()->mrSortPart ();
d844 2
a845 2
   thePer  = myPer_;
   }
d850 3
a852 3
   {
   return new WitMrCand (selRtCand_);
   }
d857 2
a858 2
   {
   witAssert (mySelector ()->sglSrc ());
d860 2
a861 2
   return mySelector ()->mySglSrcMgr ()->sglSrcMode (myMrSite_->myRtSite ());
   }
d866 2
a867 2
   {
   witAssert (selRtCand_ != NULL);
d869 2
a870 2
   return hasResAlt_;
   }
d875 2
a876 2
   {
   witAssert (selRtCand_ != NULL);
d878 2
a879 2
   if (mySelector ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveConfigVal (hasResAlt_);
d881 1
a881 1
   myMrSite_->myMrCoord ()->setPrevSel (selRtCand_, myPer_, true);
d883 1
a883 1
   select (findNextRtCand ());
d885 2
a886 2
   refreshHasResAlt ();
   }
d891 5
a895 5
   {
   myMrSite_->
      myMrCoord ()->
         storeRecoveryPair (myMrSite_->myRtSite (), myPer_);
   }
d900 2
a901 2
   {
   myMrSite_->myMrCoord ()->saveRtCand (selRtCand_);
d903 2
a904 2
   alterSelection ();
   }
d909 2
a910 2
   {
   WitRtCand * theRtCand;
d912 1
a912 1
   myMrSite_->myMrCoord ()->retrieveRtCand (theRtCand);
d914 1
a914 1
   witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));
d916 1
a916 1
   myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);
d918 1
a918 1
   select (theRtCand);
d920 2
a921 2
   refreshHasResAlt ();
   }
d926 15
a940 15
   {
   fprintf (msgFile (),
      "\n"
      "Multi-Route Alteration:\n");

   myMrSite_->myRtSite ()->printID          (4, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);

   fprintf (msgFile (), "   Selection:\n");

   if (selRtCand_ != NULL)
      selRtCand_->printID (7, 22);
   else
      fprintf (msgFile (), "      None\n");
   }
d945 3
a947 3
   {
   hasResAlt_ = (findNextRtCand () != NULL);
   }
d952 2
a953 2
   {
   WitRtCand * theRtCand;
d955 6
a960 6
   forEachEl (theRtCand, myMrSite_->myRtSite ()->myRtCands ())
      if (theRtCand->usedByMr ())
         if (theRtCand->isEligible (myPer_))
            if (not myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_))
               if (theRtCand != selRtCand_)
                  return theRtCand;
d962 2
a963 2
   return NULL;
   }
d968 7
a974 7
   {
   fprintf (msgFile (),
      "   Initial Multi-Route Selection Recovered:\n");

   myMrSite_->myRtSite ()->printID          (7, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 7, 22);
   selRtCand_            ->printID          (7, 22);
d976 2
a977 2
   fprintf (msgFile (), "\n");
   }
d982 3
a984 3
   {
   return myMrSite_->msgFile ();
   }
d992 4
a995 4
      WitSelCand (theRtCand->myProblem ()),
      myRtCand_  (theRtCand)
   {
   }
d1000 2
a1001 2
   {
   }
d1006 3
a1008 3
   {
   myRtCand_->printID (7, 22);
   }
d1013 3
a1015 3
   {
   theRtCand = myRtCand_;
   }
@


1.82
log
@Heuristic Adjustment
@
text
@a30 1
#include <RecoverySet.h>
d187 1
a187 1
void WitMrMgr::storeRecoveryPt (WitRtSite * theRtSite, WitPeriod thePer)
d189 1
a189 1
   myMrCoord_->myRtSiteRecSet ()->storeRecoveryPt (theRtSite, thePer);
d299 2
a300 2
      myRtSiteRecSet_    (NULL),
      myRtCandRecSet_    (NULL)
a310 6

   if (myGlobalComp ()->selectionRecovery ())
      {
      myRtSiteRecSet_ = new WitRecoverySet <WitMrCoord, WitRtSite> (this);
      myRtCandRecSet_ = new WitRecoverySet <WitMrCoord, WitRtCand> (this);
      }
a318 3
   delete myRtCandRecSet_;
   delete myRtSiteRecSet_;

d414 1
a414 1
      myRtCandRecSet_->storeRecoveryPt (theRtCand, thePer);
d440 1
a440 1
void WitMrCoord::recoverInitState ()
d442 1
a442 2
   myRtCandRecSet_->recoverInitState ();
   myRtSiteRecSet_->recoverInitState ();
d447 1
a447 1
void WitMrCoord::recoverInitState (WitRtSite * theRtSite, WitPeriod thePer)
d449 3
a451 2
   myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitState ();
   }
d453 3
a455 1
//------------------------------------------------------------------------------
d457 3
a459 3
void WitMrCoord::recoverInitState (WitRtCand * theRtCand, WitPeriod thePer)
   {
   prevSel_ (theRtCand)[thePer] = false;
d461 4
a464 2
   if (selPrintLevelAt (3))
      prtRecover (theRtCand, thePer);
d894 1
a894 2
         myRtSiteRecSet ()->
            storeRecoveryPt (myMrSite_->myRtSite (), myPer_);
@


1.81
log
@Selection Recovery
@
text
@d41 1
a41 1
#include <Opn.h>
@


1.80
log
@Selection Recovery
@
text
@d190 1
a190 1
   myMrCoord_->myRecoverySet ()->storeRecoveryPt (theRtSite, thePer);
d300 2
a301 2
      myRecoverySet_     (NULL),
      prevSelPairs_      (myProblem ())
d315 2
a316 1
      myRecoverySet_ = new WitRecoverySet <WitMrCoord, WitRtSite> (this);
d326 2
a327 1
   delete myRecoverySet_;
d421 2
d424 2
a425 3
      if (theVal)
         if (not prevSel_ (theRtCand)[thePer])
            prevSelPairs_.push (theRtCand, thePer);
a426 2
   prevSel_ (theRtCand)[thePer] = theVal;
   }
d452 3
a454 2
   WitRtCand * theRtCand;
   WitPeriod   thePer;
d456 1
a456 3
   while (prevSelPairs_.pop (theRtCand, thePer))
      {
      prevSel_ (theRtCand)[thePer] = false;
d458 3
a460 5
      if (selPrintLevelAt (3))
         prtRecover (theRtCand, thePer);
      }

   myRecoverySet_->recoverInitState ();
d465 1
a465 1
void WitMrCoord::recoverInitState (WitRtSite * theRtSite, WitPeriod thePer)
d467 4
a470 1
   myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitState ();
d900 1
a900 1
         myRecoverySet ()->
@


1.79
log
@Selection Recovery
@
text
@d31 1
a31 1
#include <AltSet.h>
d188 1
a188 1
void WitMrMgr::recAltForRecovery (WitRtSite * theRtSite, WitPeriod thePer)
d190 1
a190 1
   myMrCoord_->myAltSet ()->recAltForRecovery (theRtSite, thePer);
d195 1
a195 1
void WitMrMgr::recoverSelections ()
d197 1
a197 1
   myMrCoord_->recoverSelections ();
d300 1
a300 1
      myAltSet_          (NULL),
d315 1
a315 1
      myAltSet_ = new WitAltSet <WitMrCoord, WitRtSite> (this);
d325 1
a325 1
   delete myAltSet_;
d449 1
a449 1
void WitMrCoord::recoverSelections ()
d462 1
a462 1
   myAltSet_->recoverSelections ();
d467 1
a467 1
void WitMrCoord::recoverInitSel (WitRtSite * theRtSite, WitPeriod thePer)
d469 1
a469 1
   myMrSiteFor_ (theRtSite)->myMrPt ()[thePer]->recoverInitSel ();
d807 1
a807 1
void WitMrPt::recoverInitSel ()
d895 1
a895 1
void WitMrPt::recAltForRecovery ()
d899 2
a900 2
         myAltSet ()->
            recAltForRecovery (myMrSite_->myRtSite (), myPer_);
@


1.78
log
@Selection Recovery
@
text
@d188 7
d895 1
a895 1
void WitMrPt::recordAlteration ()
d900 1
a900 1
            recordAlteration (myMrSite_->myRtSite (), myPer_);
@


1.77
log
@Selection Recovery
@
text
@a297 5
   if (myGlobalComp ()->selectionRecovery ())
      {
      myAltSet_ = new WitAltSet <WitMrCoord, WitRtSite> (this);
      }

d305 5
@


1.76
log
@Sleection Recovery
@
text
@a795 8

   if (mySelMgr ()->myGlobalComp ()->selectionRecovery ())
      {
      myMrSite_->
         myMrCoord ()->
            myAltSet ()->
               recordAlteration (myMrSite_->myRtSite (), myPer_);
      }
d888 10
@


1.75
log
@Selection Recovery
@
text
@d779 1
a779 1
   hasResAlt_ = (findNextRtCand () != NULL);
a807 11
void WitMrPt::restoreSel (WitRtCand * theRtCand)
   {
   witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));

   myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);

   selectAndResolve (theRtCand);
   }

//------------------------------------------------------------------------------

d812 1
a812 1
   hasResAlt_ = (findNextRtCand () != NULL);
d889 3
a891 1
   selectAndResolve (findNextRtCand ());
d915 3
a917 1
   selectAndResolve (theRtCand);
d941 1
a941 1
void WitMrPt::selectAndResolve (WitRtCand * theRtCand)
a942 2
   select (theRtCand);

@


1.74
log
@Selection Recovery
@
text
@d31 1
d293 1
a293 2
      alteredMrPts_      (myProblem ()),
      mrAlteredAt_       (),
d299 3
a301 1
      mrAlteredAt_.allocate (myProblem (), false);
d318 2
a441 20
void WitMrCoord::recordAlteration (WitMrPt * theMrPt)
   {
   WitRtSite * theRtSite;
   WitPeriod   thePer;

   witAssert (myGlobalComp ()->selectionRecovery ());

   theRtSite = theMrPt->myMrSite ()->myRtSite ();
   thePer    = theMrPt->myPer    ();

   if (mrAlteredAt_ (theRtSite)[thePer])
      return;

   mrAlteredAt_ (theRtSite)[thePer] = true;

   alteredMrPts_.push (theMrPt);
   }

//------------------------------------------------------------------------------

a445 2
   WitMrPt *   theMrPt;
   WitRtSite * theRtSite;
d455 2
a456 3
   while (alteredMrPts_.pop (theMrPt))
      {
      theMrPt->recoverInitSel ();
d458 1
a458 2
      theRtSite = theMrPt->myMrSite ()->myRtSite ();
      thePer    = theMrPt->myPer    ();
d460 3
a462 2
      mrAlteredAt_ (theRtSite)[thePer] = false;
      }
d799 4
a802 1
      myMrSite_->myMrCoord ()->recordAlteration (this);
@


1.73
log
@Selection Recovery.
@
text
@d187 7
d291 4
a294 2
      prevSelPairs_      (myProblem ()),
      savedRtCand_       (NULL)
d298 3
a407 2
   prevSel_ (theRtCand)[thePer] = theVal;

d410 4
a413 1
         prevSelPairs_.push (theRtCand, thePer);
d438 21
a458 1
void WitMrCoord::mrSelRecovery ()
d462 2
d467 2
d471 1
d473 8
a480 1
      prevSel_ (theRtCand)[thePer] = false;
a487 3
   if (not prevSel_ (theRtCand)[thePer])
      return;

a583 7

void WitPmrSelMgr::specSelRecoverO ()
   {
   myMrCoord ()->mrSelRecovery ();
   }

//------------------------------------------------------------------------------
d796 3
a798 1
   selectAndResolve (myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_));
d817 3
a819 1
      recAlteratOld ();
d835 12
a897 30
void WitMrPt::printRecoverO ()
   {
   WitRtCand * initRtCand;

   initRtCand = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);

   if (selRtCand_ == initRtCand)
      return;

   fprintf (msgFile (),
      "   Initial Multi-Route Selection Recovered:\n");

   myMrSite_->myRtSite ()->printID          (7, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 7, 22);
   initRtCand            ->printID          (7, 22);

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitMrPt::recoverInitSeO ()
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);

   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

d989 14
@


1.72
log
@Selection Recovery
@
text
@a548 6

void WitPmrSelMgr::recoverSelections ()
   {
   }

//------------------------------------------------------------------------------
a607 6

void WitCmrSelMgr::recoverSelections ()
   {
   }

//------------------------------------------------------------------------------
@


1.71
log
@Selection Recovery
@
text
@d792 1
a792 1
      recAlteration ();
@


1.70
log
@Selection Recovery.
@
text
@d543 1
a543 1
void WitPmrSelMgr::specSelRecovery ()
d549 6
d614 6
d859 1
a859 1
void WitMrPt::printRecovery ()
d880 1
a880 1
void WitMrPt::recoverInitSel ()
@


1.69
log
@Selection recovery.
@
text
@d847 1
a847 10
void WitMrPt::recoverInitSel ()
   {
   selRtCand_ = myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_);

   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

void WitMrPt::prtRecInitSel ()
d868 9
@


1.68
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d425 1
a425 1
void WitMrCoord::restoreSpecConfig ()
d433 1
a433 1
         prtRestore (theRtCand, thePer);
d441 1
a441 1
void WitMrCoord::prtRestore (WitRtCand * theRtCand, WitPeriod thePer)
d446 1
a446 1
   fprintf (msgFile (), "   Multi-Route Candidate Restored:\n");
d543 1
a543 1
void WitPmrSelMgr::restoreSpecConfig ()
d545 1
a545 1
   myMrCoord ()->restoreSpecConfig ();
d847 1
a847 1
void WitMrPt::restoreInitSel ()
d856 1
a856 1
void WitMrPt::prtRestInitSel ()
d866 1
a866 1
      "   Initial Multi-Route Selection Restored:\n");
@


1.67
log
@Selection Reuse
@
text
@d398 1
a398 1
   if (myGlobalComp ()->selectionReuse ())
d779 1
a779 1
   if (mySelMgr ()->myGlobalComp ()->selectionReuse ())
@


1.66
log
@Lead Time Bounds
@
text
@d284 1
d397 4
d424 32
d542 7
d745 7
a755 1
      mySelector_ (theMrSite->myMrCoord ()->mySelector ()),
d761 1
a761 3
   select (myMrSite_->myRtSite ()->mrDefaultRtCand (myPer_));

   hasResAlt_ = (findNextRtCand () != NULL);
d774 2
a775 2
   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (selRtCand_);
d778 3
d791 1
a791 3
   select (theRtCand);

   hasResAlt_ = (findNextRtCand () != NULL);
d813 1
a813 1
   if (mySelector_->sglSrc ())
d840 1
a840 1
   witAssert (mySelector_->sglSrc ());
d842 31
a872 1
   return mySelector_->mySglSrcMgr ()->sglSrcMode (myMrSite_->myRtSite ());
d890 2
a891 2
   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (hasResAlt_);
d895 1
a895 3
   select (findNextRtCand ());

   hasResAlt_ = (findNextRtCand () != NULL);
d919 1
a919 3
   select (theRtCand);

   hasResAlt_ = (findNextRtCand () != NULL);
d943 9
@


1.65
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d492 7
d551 7
@


1.64
log
@Stochastic Implosion
@
text
@d38 1
a38 1
#include <Global.h>
@


1.63
log
@Updated the copyright date on all source files.
@
text
@d51 1
a51 1
      WitProbAssoc (theSelector->myProblem ()),
d278 1
a278 1
      WitProbAssoc       (theSelector->myProblem ()),
d555 1
a555 1
      WitProbAssoc (theMrCoord->myProblem ()),
@


1.62
log
@Revised mappingIndex code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.61
log
@Second attempt to correct a problem with header file inclusion on
g++ 3.3.3.
@
text
@a43 1
#include <MapIdxI.h>
@


1.60
log
@An attempt to correct a problem with header file inclusion on g++ 3.3.3.
@
text
@d39 1
@


1.59
log
@Vector PropRtg.
@
text
@a38 1
#include <Part.h>
@


1.58
log
@Vector Prop-Rtg.
@
text
@d671 1
a671 1
   if (myRtSite_->propRt ()[thePer])
@


1.57
log
@Pegged critical list.
@
text
@a632 3
   if (myRtSite_->propRouting ())
      return false;

d671 3
@


1.56
log
@Pegged critical list.
@
text
@d244 3
a246 3
      WitRtCand * theRtCand,
      WitPeriod   thePer,
      double      incFlowVol)
d248 1
d251 3
a253 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());
d467 4
a470 1
   WitPeriod expPer;
d472 1
a472 1
   expPer = theBopEnt->impactPeriod ()[execPer];
d474 1
a474 1
   return myMrCoord ()->myAltPtFor (theBopEnt->myRtCand (), expPer);
d522 5
a526 1
   return myMrCoord ()->myAltPtFor (theConsEnt->myRtCand (), execPer);
@


1.55
log
@Low-Pri Prop-Rt.
@
text
@d53 2
a54 1
      myMrCoord_   (NULL)
d77 28
d188 1
a188 1
bool WitMrMgr::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
d190 16
a205 1
   return myMrCoord_->selIsSplit (theRtSite, thePer);
d211 2
a212 2
      WitRtSite *         theRtSite, 
      WitPeriod           thePer,
d217 3
a219 4
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitRtCand *        theRtCand;
d221 2
a222 1
   witAssert (myMrCoord_->selIsSplit (theRtSite, thePer));
d224 1
a224 5
   myMrCoord_->
      myMrSiteFor (theRtSite)->
         myMrPt ()[thePer]->
            mySplitPt ()->
               defineSplit (expVol, theAbsSplitPairs, unbddVol);
d226 8
a233 1
   theSplitPairs.clear ();
d235 1
a235 3
   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getMrData (theRtCand);
d237 2
a238 2
      theSplitPairs.push (theRtCand, splitVol);
      }
d244 1
a244 1
      WitRtSite * theRtSite,
d250 1
a250 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);
d351 31
@


1.54
log
@Low-Pri Prop-Rt.
@
text
@d535 1
a535 1
      (myRtSite_->myRtCase () == prodRtCase)?
@


1.53
log
@Low-Pri Prop-Rt.
@
text
@d213 1
a213 1
WitSelMgr * WitMrMgr::mySelMgrFor (WitRtCase theRtCase)
d215 8
a222 1
   return myMrCoord_->myMrSelMgrFor (theRtCase);
a340 10

WitMrSelMgr * WitMrCoord::myMrSelMgrFor (WitRtCase theRtCase)
   {
   return
      (theRtCase == prodRtCase)? myMrSelMgrForProd_:
      (theRtCase == consRtCase)? myMrSelMgrForCons_:
                                 NULL;
   }

//------------------------------------------------------------------------------
d534 4
a537 1
   return myMrCoord_->myMrSelMgrFor (myRtSite_->myRtCase ());
@


1.52
log
@Low-Pri Prop-Rt.
@
text
@a647 17
void WitMrPt::printSelection ()
   {
   fprintf (msgFile (), "\n");

   myMrSite_->myRtSite ()->printID          (4, 22);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 22);

   fprintf (msgFile (), "   Selection:\n");

   if (selRtCand_ != NULL)
      selRtCand_->printID (7, 22);
   else
      fprintf (msgFile (), "      None\n");
   }

//------------------------------------------------------------------------------

d750 19
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@d229 2
a230 1
      prevSel_           ()
d315 20
d743 2
d750 1
a750 1
void WitMrPt::cancelTempAlt (WitSelCand * theSelCand)
d754 1
a754 3
   witAssert (theSelCand != NULL);

   theSelCand->getMrData (theRtCand);
a766 7
bool WitMrPt::cancelNeedsSelCand ()
   {
   return true;
   }

//------------------------------------------------------------------------------

@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d653 2
a654 2
   myMrSite_->myRtSite ()->printID          (4, 14);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 14);
@


1.49
log
@Low-Pri Prop-Rt.
@
text
@a669 17
void WitMrPt::restoreSelTo (WitSelCand * theSelCand)
   {
   WitRtCand * theRtCand;

   theSelCand->getMrData (theRtCand);

   witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));

   myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);

   select (theRtCand);

   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

d727 26
@


1.48
log
@Low-Pri Prop-Rt.
@
text
@d670 17
d698 1
a698 1
   return new WitMrCand (this);
d769 1
a769 1
WitMrCand::WitMrCand (WitMrPt * theMrPt):
d771 2
a772 3
      WitSelCand (theMrPt->myMrSite ()->myProblem ()),
      myMrPt_    (theMrPt),
      myRtCand_  (theMrPt->selRtCand ())
a790 7
void WitMrCand::restoreSelToThis ()
   {
   myMrPt_->restoreSel (myRtCand_);
   }

//------------------------------------------------------------------------------

@


1.47
log
@Low-Pri Prop-Rt.
@
text
@d171 1
a171 1
      bool &              lastUnbdd)
a173 1
   double             unbddVol;
a185 2
   lastUnbdd = (unbddVol > 0.0);

a187 3
   if (lastUnbdd)
      theSplitPairs.push (selRtCand (theRtSite, thePer), unbddVol);

@


1.46
log
@Low-Pri Prop-Rt.
@
text
@a172 2
   WitMrSite *        theMrSite;
   WitSplitPt *       theSplitPt;
d174 1
d181 5
a185 1
   theMrSite  = myMrCoord_->myMrSiteFor (theRtSite);
d187 1
a187 1
   theSplitPt = theMrSite->myMrPt ()[thePer]->mySplitPt ();
d189 1
a189 1
   theSplitPt->defineSplit (expVol, theAbsSplitPairs, lastUnbdd);
d191 2
a192 1
   theSplitPairs.clear ();
a780 7
void WitMrCand::updateToCurSel ()
   {
   myRtCand_ = myMrPt_->selRtCand ();
   }

//------------------------------------------------------------------------------

@


1.45
log
@Low-Pri Prop-Rt.
@
text
@d32 1
d277 1
a277 1
         theMrPt->myAltPt ():
a628 9
bool WitMrPt::hasResAlt ()
   {
   witAssert (selRtCand_ != NULL);

   return hasResAlt_;
   }

//------------------------------------------------------------------------------

d697 9
@


1.44
log
@Low-Pri Prop-Rt.
@
text
@d265 1
a265 1
WitSelAlt * WitMrCoord::mySelAltFor (WitRtCand * theRtCand, WitPeriod thePer)
d276 1
a276 1
         theMrPt->mySelAlt ():
d365 1
a365 1
WitSelAlt * WitPmrSelMgr::mySelAltFor (
d375 1
a375 1
   return myMrCoord ()->mySelAltFor (theBopEnt->myRtCand (), expPer);
d417 1
a417 1
WitSelAlt * WitCmrSelMgr::mySelAltFor (
d423 1
a423 1
   return myMrCoord ()->mySelAltFor (theConsEnt->myRtCand (), execPer);
@


1.43
log
@Low-Pri Prop-Rt.
@
text
@a688 7
void WitMrPt::tempAlterSel ()
   {
   alterSelection ();
   }

//------------------------------------------------------------------------------

d721 7
@


1.42
log
@Low-Pri Prop-Rt.
@
text
@d630 1
a630 1
   witAssert (selRtCand () != NULL);
d646 2
a647 2
   if (selRtCand () != NULL)
      selRtCand ()->printID (7, 22);
d714 1
a714 1
   witAssert (selRtCand () != NULL);
d736 1
a736 1
               if (theRtCand != selRtCand ())
@


1.41
log
@Low-Pri Prop-Rt.
@
text
@d265 1
a265 1
WitSelPt * WitMrCoord::mySelPtForAlt (WitRtCand * theRtCand, WitPeriod thePer)
d268 1
d272 6
a277 1
   return theMrSite->myMrPtWithAlt (thePer);
d365 1
a365 1
WitSelPt * WitPmrSelMgr::mySelPtForAlt (
d375 1
a375 1
   return myMrCoord ()->mySelPtForAlt (theBopEnt->myRtCand (), expPer);
d417 1
a417 1
WitSelPt * WitCmrSelMgr::mySelPtForAlt (
d423 1
a423 1
   return myMrCoord ()->mySelPtForAlt (theConsEnt->myRtCand (), execPer);
a636 16
void WitMrPt::alterSelection ()
   {
   witAssert (selRtCand () != NULL);

   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (hasResAlt_);

   myMrSite_->myMrCoord ()->setPrevSel (selRtCand_, myPer_, true);

   select (findNextRtCand ());

   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

d712 16
@


1.40
log
@Low-Pri Prop-Rt.
@
text
@d578 1
a578 1
      WitSelPt    (),
@


1.39
log
@Low-Pri Prop-Rt.
@
text
@d191 1
a191 1
      theRtCand = theSelCand->myMrCand ()->myRtCand ();
d784 1
a784 1
WitMrCand * WitMrCand::myMrCand ()
d786 1
a786 1
   return this;
@


1.38
log
@Low-Pri Prop-Rt.
@
text
@a335 7
WitSelCand * WitMrSelMgr::newSelCand ()
   {
   return new WitMrCand (this);
   }

//------------------------------------------------------------------------------

d706 1
a706 1
void WitMrPt::setToMyCurSel (WitSelCand * theSelCand)
d708 1
a708 1
   theSelCand->setToCurSelOf (this);
d747 1
a747 1
WitMrCand::WitMrCand (WitMrSelMgr * theMrSelMgr):
d749 3
a751 3
      WitSelCand (theMrSelMgr),
      myMrPt_    (NULL),
      myRtCand_  (NULL)
d770 1
a770 1
void WitMrCand::restoreSelToThis ()
d772 1
a772 3
   witAssert (active ());

   myMrPt_->restoreSel (myRtCand_);
d777 1
a777 1
WitMrCand * WitMrCand::myMrCand ()
d779 1
a779 3
   witAssert (active ());

   return this;
d784 1
a784 1
void WitMrCand::setToCurSelOf (WitMrPt * theMrPt)
d786 1
a786 4
   witAssert (active ());

   myMrPt_   = theMrPt;
   myRtCand_ = theMrPt->selRtCand ();
@


1.37
log
@Low-Pri Prop-Rt.
@
text
@d616 13
a712 17
void WitMrPt::restoreSel (WitSelCand * theSelCand)
   {
   WitRtCand * theRtCand;

   theRtCand = theSelCand->myMrCand ()->myRtCand ();

   witAssert (myMrSite_->myMrCoord ()->prevSel (theRtCand, myPer_));

   myMrSite_->myMrCoord ()->setPrevSel (theRtCand, myPer_, false);

   select (theRtCand);

   hasResAlt_ = (findNextRtCand () != NULL);
   }

//------------------------------------------------------------------------------

d757 1
d777 9
d799 1
@


1.36
log
@Low-Pri Prop-Rt.
@
text
@d717 1
a717 1
void WitMrPt::setToCurSel (WitSelCand * theSelCand)
d719 1
a719 1
   theSelCand->myMrCand ()->setToCurSel (this);
d773 1
a773 1
void WitMrCand::setToCurSel (WitMrPt * theMrPt)
d775 1
a775 3
   witAssert (active ());

   myRtCand_ = theMrPt->selRtCand ();
d780 1
a780 1
void WitMrCand::prtID ()
d782 3
a784 1
   myRtCand_->printID (7, 22);
d789 1
a789 1
WitMrCand * WitMrCand::myMrCand ()
d793 1
a793 1
   return this;
@


1.35
log
@Low-Pri Prop-Rt.
@
text
@d775 2
d791 2
@


1.34
log
@Low-Pri Prop-Rt.
@
text
@a228 1
      myMrCandFor_       (myProblem ()),
a247 1
   WitRtCand * theRtCand;
a251 3
   forEachEl (theRtCand, mySelector_->myRtMgr ()->myRtCands ())
      delete myMrCandFor_ (theRtCand);

a275 16
WitMrCand * WitMrCoord::myMrCandFor (WitRtCand * theRtCand)
   {
   WitMrSelMgr * theMrSelMgr;

   if (myMrCandFor_ (theRtCand) == NULL)
      {
      theMrSelMgr = myMrSelMgrFor (theRtCand->myRtSite ()->myRtCase ());

      myMrCandFor_ (theRtCand) = new WitMrCand (theRtCand, theMrSelMgr);
      }

   return myMrCandFor_ (theRtCand);
   }

//------------------------------------------------------------------------------

d336 7
a672 10
WitSelCand * WitMrPt::curSelCand ()
   {
   return
      (selRtCand_ != NULL)?
         myMrSite_->myMrCoord ()->myMrCandFor (selRtCand_):
         NULL;
   }

//------------------------------------------------------------------------------

d717 7
d758 1
a758 1
WitMrCand::WitMrCand (WitRtCand * theRtCand, WitMrSelMgr * theMrSelMgr):
d761 1
a761 1
      myRtCand_  (theRtCand)
d773 7
@


1.33
log
@Low-Pri Prop-Rt.
@
text
@d214 1
a214 1
WitSelMgr * WitMrMgr::mySelMgr (WitRtCase theRtCase)
d216 1
a216 1
   return myMrCoord_->myMrSelMgr (theRtCase);
d283 2
d286 5
a290 1
       myMrCandFor_ (theRtCand) = new WitMrCand (theRtCand);
d330 1
a330 1
WitMrSelMgr * WitMrCoord::myMrSelMgr (WitRtCase theRtCase)
d532 1
a532 1
   return myMrCoord_->myMrSelMgr (myRtSite_->myRtCase ());
d775 1
a775 1
WitMrCand::WitMrCand (WitRtCand * theRtCand):
d777 1
a777 1
      WitSelCand (theRtCand->myProblem ()),
@


1.32
log
@Low-Pri Prop-Rt.
@
text
@d784 1
a784 1
WitMrCand * WitMrCand::myMrCand ()
d786 1
a786 1
   return this;
d791 1
a791 1
void WitMrCand::prtID ()
d793 1
a793 1
   myRtCand_->printID (7, 22);
@


1.31
log
@Low-Pri Prop-Rt.
@
text
@d614 10
d666 1
a666 1
void WitMrPt::prtID ()
d668 1
a668 2
   myMrSite_->myRtSite ()->printID          (4, 14);
   myMrSite_->myRtSite ()->printPer (myPer_, 4, 14);
d673 1
a673 1
void WitMrPt::getSortData (WitPart * & thePart, WitPeriod & thePer)
d675 2
a676 10
   thePart = myMrSite_->myRtSite ()->mrSortPart ();

   thePer  = myPer_;
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrPt::mySelMgr ()
   {
   return myMrSite_->mySelMgr ();
d702 9
a743 10
void WitMrPt::select (WitRtCand * theRtCand)
   {
   if (mySelector_->sglSrc ())
      mySelector_->mySglSrcMgr ()->saveConfigVal (selRtCand_);

   selRtCand_ = theRtCand;
   }

//------------------------------------------------------------------------------

@


1.30
log
@Low-Pri Prop-Rt.
@
text
@d89 1
a89 1
   if (not theRtCand->needsMrCand ())
a232 1
   WitRtCand * theRtCand;
a239 5
   forEachEl (theRtCand, mySelector_->myRtMgr ()->myRtCands ())
      if (not theRtCand->myRtSite ()->propRouting ())
         if (theRtCand->needsMrCand ())
            myMrCandFor_ (theRtCand) = new WitMrCand (theRtCand);

d281 10
d534 1
a534 1
   bool        foundMrCand;
d539 1
a539 1
   foundMrCand = false;
d542 1
a542 1
      if (myMrCoord_->myMrCandFor (theRtCand) != NULL)
d544 1
a544 1
         if (foundMrCand)
d546 2
a547 2

         foundMrCand = true;
d680 10
a735 2
   WitMrCand * theMrCand;

a739 7

   theMrCand  =
      (selRtCand_ != NULL)?
         myMrSite_->myMrCoord ()->myMrCandFor (selRtCand_):
         NULL;

   WitSelPt::select (theMrCand);
d749 1
a749 1
      if (theRtCand->needsMrCand ())
@


1.29
log
@Low-Pri Prop-Rt.
@
text
@d15 5
d21 1
a22 1
//    MrPt
d25 1
d27 1
a27 1
#include <MrSite.h>
d30 3
a32 1
#include <MrSelMgr.h>
d35 1
d37 1
a37 1
#include <Selector.h>
d40 1
a41 2
#include <SubEntry.h>
#include <Global.h>
d46 27
a72 1
// Implementation of class MrSite.
d75 6
a80 1
WitMrSite::WitMrSite (WitRtSite * theRtSite, WitMrCoord * theMrCoord):
d82 1
a82 6
      WitProbAssoc (theMrCoord->myProblem ()),
      myRtSite_    (theRtSite),
      myMrCoord_   (theMrCoord),
      myMrCands_   (myProblem ()),
      myMrPt_      (),
      multiChoice_ (false)
d84 1
a84 1
   buildMrCands ();
d86 23
a108 1
   buildMrPts ();
d113 1
a113 1
WitMrSite::~WitMrSite ()
d115 5
a119 2
   deleteContents (myMrPt_);
   deleteContents (myMrCands_);
d124 1
a124 1
WitMrCand * WitMrSite::defaultMrCand (WitPeriod thePer)
d126 5
a130 1
   WitRtCand * theRtCand;
d132 1
a132 1
   theRtCand = myRtSite_->mrDefaultRtCand (thePer);
d134 3
a136 4
   return
      (theRtCand != NULL)?
         myMrCoord_->myMrCandFor (theRtCand):
         NULL;
d141 1
a141 1
WitMrCand * WitMrSite::selMrCand (WitPeriod thePer)
d143 9
a151 1
   WitMrCand * theMrCand;
d153 2
a154 3
   if (multiChoice_)
      {
      theMrCand = myMrPt_[thePer]->selMrCand ();
d156 1
a156 3
      if (theMrCand != NULL)
         return theMrCand;
      }
d158 3
a160 1
   return defaultMrCand (thePer);
d165 6
a170 1
void WitMrSite::printHasAlt ()
d172 14
a185 2
   WitPeriod thePer;
   WitMrPt * theMrPt;
d187 1
a187 2
   if (not multiChoice_)
      return;
d189 1
a189 1
   forEachPeriod (thePer, myProblem ())
d191 14
a204 1
      theMrPt = myMrPt_[thePer];
d206 1
a206 5
      if (theMrPt != NULL)
         if (theMrPt->selMrCand () != NULL)
            {
            myRtSite_->printID          (4, 14);
            myRtSite_->printPer (thePer, 4, 14);
d208 2
a209 3
            fprintf (msgFile (), "\n");
            }
      }
d214 1
a214 1
WitSelMgr * WitMrSite::mySelMgr ()
d216 1
a216 1
   return myMrCoord_->myMrSelMgr (myRtSite_->myRtCase ());
d220 4
d225 7
a231 1
void WitMrSite::buildMrCands ()
d234 4
d239 4
a242 3
   if (not myRtSite_->propRouting ())
      {
      forEachEl (theRtCand, myRtSite_->myRtCands ())
d244 1
a244 1
            myMrCands_.push (new WitMrCand (theRtCand, this));
d246 35
a280 2
      myMrCands_.reverse ();
      }
d282 1
a282 1
   multiChoice_ = (myMrCands_.nElements () > 1);
d287 1
a287 1
void WitMrSite::buildMrPts ()
d289 4
a292 1
   WitPeriod thePer;
d294 1
a294 2
   if (not multiChoice_)
      return;
d296 2
a297 1
   myMrPt_.allocate (myProblem ());
d299 1
a299 3
   forEachPeriod (thePer, myProblem ())
      if (defaultMrCand (thePer) != NULL)
         myMrPt_[thePer] = new WitMrPt (this, thePer);
d304 4
a307 1
WitMrPt * WitMrSite::multiChoiceMrPtWithAlt (WitPeriod thePer)
d309 2
a310 1
   WitMrPt * theMrPt;
d312 2
a313 1
   witAssert (multiChoice_);
d315 2
a316 1
   theMrPt = myMrPt_[thePer];
d318 1
a318 1
   witAssert (theMrPt != NULL);
d320 2
d323 79
a401 3
      (theMrPt->selMrCand () != NULL)?
         theMrPt:
         NULL;
d405 1
a405 1
// Implementation of class MrCand.
d408 1
a408 1
WitMrCand::WitMrCand (WitRtCand * theRtCand, WitMrSite * theMrSite):
d410 1
a410 4
      WitSelCand (theMrSite->myProblem ()),
      myRtCand_  (theRtCand),
      myMrSite_  (theMrSite),
      prevSel_   ()
a411 1
   myMrSite_->myMrCoord ()->store (this);
d416 1
a416 1
WitMrCand::~WitMrCand ()
d422 5
a426 1
WitMrCand * WitMrCand::myMrCand ()
d428 1
a428 1
   return this;
d433 1
a433 1
bool WitMrCand::valid (WitPeriod thePer)
d435 4
a438 3
   if (myRtCand ()->isEligible (thePer))
      if (not prevSel (thePer))
         return true;
d440 2
d447 1
a447 1
void WitMrCand::setPrevSel (WitPeriod thePer, bool theVal)
d449 2
a450 1
   WitSelector * theSelector;
d452 3
a454 2
   if (not prevSel_.isAllocated ())
      prevSel_.allocate (myProblem (), false);
d456 1
a456 1
   theSelector = myMrSite_->myMrCoord ()->mySelector ();
d458 7
a464 2
   if (theSelector->sglSrc ())
      theSelector->mySglSrcMgr ()->saveConfigVal (prevSel_[thePer]);
d466 1
a466 1
   prevSel_[thePer] = theVal;
d471 50
a520 1
void WitMrCand::prtID ()
d522 1
a522 1
   myRtCand_->printID (7, 22);
d526 23
a548 1
// Implementation of class template MrPt.
d551 8
a558 1
WitMrPt::WitMrPt (WitMrSite * theMrSite, WitPeriod thePer):
d560 4
a563 1
      WitSelPt   (),
d565 3
a567 3
      myMrSite_  (theMrSite),
      myPer_     (thePer),
      hasResAlt_ (false)
d569 17
a585 1
   WitMrCand * theMrCand;
d587 1
a587 1
   theMrCand = theMrSite->defaultMrCand (myPer_);
d589 1
a589 1
   witAssert (theMrCand != NULL);
d591 7
a597 1
   WitSelPt::select (theMrCand);
d599 1
a599 1
   hasResAlt_ = (findNextMrCand () != NULL);
d612 1
a612 1
   witAssert (selMrCand () != NULL);
d621 1
a621 1
   WitSelector * theSelector;
d623 2
a624 1
   witAssert (selMrCand () != NULL);
d626 1
a626 1
   theSelector = myMrSite_->myMrCoord ()->mySelector ();
d628 1
a628 2
   if (theSelector->sglSrc ())
      theSelector->mySglSrcMgr ()->saveConfigVal (hasResAlt_);
d630 1
a630 5
   selMrCand ()->setPrevSel (myPer_, true);

   WitSelPt::select (findNextMrCand ());

   hasResAlt_ = (findNextMrCand () != NULL);
d644 3
a646 1
   if (selSelCand () == NULL)
a647 2
   else
      selSelCand ()->myMrCand ()->myRtCand ()->printID (7, 22);
d678 1
a678 5
   WitSelector * theSelector;

   theSelector = myMrSite_->myMrCoord ()->mySelector ();

   if (theSelector->sglSrc ())
d696 1
a696 1
   WitMrCand * theMrCand;
d698 1
a698 1
   theMrCand = theSelCand->myMrCand ();
d700 1
a700 1
   witAssert (theMrCand->prevSel (myPer_));
d702 1
a702 1
   theMrCand->setPrevSel (myPer_, false);
d704 1
a704 1
   WitSelPt::select (theSelCand);
d706 1
a706 1
   hasResAlt_ = (findNextMrCand () != NULL);
d713 3
a715 3
   return
      myMrSite_->myMrCoord ()->mySelector ()->mySglSrcMgr ()->sglSrcMode (
         myMrSite_->myRtSite ());
d720 1
a720 1
void WitMrPt::select (WitMrCand * theMrCand)
d722 1
a722 1
   witAssert (theMrCand != selMrCand ());
d724 9
a732 1
   witAssert (not theMrCand->prevSel (myPer_));
d739 1
a739 1
WitMrCand * WitMrPt::findNextMrCand ()
d741 1
a741 4
   WitObjStItr <WitMrCand> theItr;
   WitMrCand *             theMrCand;

   theItr.attachTo (myMrSite_->myMrCands ());
d743 6
a748 5
   while (theItr.advance (theMrCand))
      if (theMrCand->myRtCand ()->isEligible (myPer_))
         if (not theMrCand->prevSel (myPer_))
            if (theMrCand != selMrCand ())
               return theMrCand;
d759 31
@


1.28
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d111 2
a112 2
            myRtSite_->printID          (14);
            myRtSite_->printPer (thePer, 14);
d237 1
a237 1
   myRtCand_->printID (22);
d304 2
a305 2
   myMrSite_->myRtSite ()->printID          (22);
   myMrSite_->myRtSite ()->printPer (myPer_, 22);
d312 1
a312 1
      selSelCand ()->myMrCand ()->myRtCand ()->printID (22);
d319 2
a320 2
   myMrSite_->myRtSite ()->printID          (14);
   myMrSite_->myRtSite ()->printPer (myPer_, 14);
@


1.27
log
@Added some optional warnings on Linux.
@
text
@a33 1
#include <PtrMapI.h>
d35 1
@


1.26
log
@Continued implementation of proportionate routing.
@
text
@d47 2
a48 2
      multiChoice_ (false),
      myMrPt_      ()
@


1.25
log
@Continued implementation of proportionate routing.
@
text
@a355 7
WitPeriod WitMrPt::myPeriod ()
   {
   return myPer_;
   }

//------------------------------------------------------------------------------

@


1.24
log
@Continued implementation of proportionate routing.
@
text
@a428 1

@


1.23
log
@Continued implementation of proportionate routing.
@
text
@d123 1
a123 4
   if (myRtSite_->forProd ())
      return myMrCoord_->myMrSelMgrForProd ();
   else
      return myMrCoord_->myMrSelMgrForCons ();
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d24 1
a24 1
#include <MrSecMgr.h>
d124 1
a124 1
      return myMrCoord_->myPmrMgr ();
d126 1
a126 1
      return myMrCoord_->myCmrMgr ();
@


1.21
log
@Continued implementation of propotionate routing.
@
text
@a95 30
void WitMrSite::findExpRtCands (WitPeriod thePer, WitRtCandStack & theRtCands)
   {
   WitMrCandItr theItr;
   WitMrCand *  theMrCand;

   theRtCands.clear ();

   if (multiChoice ())
      {
      theItr.attachTo (myMrCands_);

      while (theItr.advance (theMrCand))
         if (theMrCand->myRtCand ()->isEligible (thePer))
            if (not theMrCand->prevSel (thePer))
               theRtCands.push (theMrCand->myRtCand ());

      theRtCands.reverse ();
      }

   if (theRtCands.isEmpty ())
      {
      theMrCand = defaultMrCand (thePer);

      if (theMrCand != NULL)
         theRtCands.push (theMrCand->myRtCand ());
      }
   }

//------------------------------------------------------------------------------

d412 2
a413 2
   WitMrCandItr theItr;
   WitMrCand *  theMrCand;
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d24 1
a24 1
#include <MrSelMgr.h>
d154 1
a154 1
      return myMrCoord_->myPmrSelMgr ();
d156 1
a156 1
      return myMrCoord_->myCmrSelMgr ();
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d96 1
a96 3
void WitMrSite::findExpMrCands (
      WitPeriod                 thePer,
      WitObjStack <WitMrCand> & theMrCands)
d101 1
a101 1
   theMrCands.clear ();
d110 3
a112 1
               theMrCands.push (theMrCand);
d115 1
a115 1
   if (theMrCands.isEmpty ())
d120 1
a120 1
         theMrCands.push (theMrCand);
@


1.18
log
@Continued implementation of proportionate routing.
@
text
@d96 1
a96 1
void WitMrSite::findMrCands (
d141 2
a142 1
            myRtSite_->printIDPer (thePer, 14);
d337 2
a338 1
   myMrSite_->myRtSite ()->printIDPer (myPer_, 22);
d352 2
a353 1
   myMrSite_->myRtSite ()->printIDPer (myPer_, 14);
@


1.17
log
@Continued implementation of proportionate routing.
@
text
@a15 2
//    PmrSite
//    CmrSite
a16 2
//    PmrCand
//    CmrCand
d20 1
d24 2
a25 1
#include <MrMgr.h>
d41 16
d65 1
a65 1
void WitMrSite::setUp ()
d67 1
a67 1
   buildMrCands (myMrCands_);
d69 1
a69 1
   multiChoice_ = (myMrCands_.nElements () > 1);
d71 4
a74 3
   storeMrCands ();

   buildMrPts ();
d140 5
a144 1
            printID (thePer);
d150 1
a150 8
WitMrSite::WitMrSite (WitMrMgr * theMrMgr):

      WitProbAssoc (theMrMgr->myProblem ()),

      myMrMgr_     (theMrMgr),
      myMrCands_   (myProblem ()),
      multiChoice_ (false),
      myMrPt_      ()
d152 4
d160 1
a160 1
void WitMrSite::storeMrCands ()
d162 7
a168 2
   WitMrCandItr theItr;
   WitMrCand *  theMrCand;
d170 2
a171 1
   theItr.attachTo (myMrCands_);
d173 1
a173 2
   while (theItr.advance (theMrCand))
      myMrMgr_->store (theMrCand);
d211 1
a211 1
// Implementation of class PmrSite.
d214 1
a214 1
WitPmrSite::WitPmrSite (WitPart * thePart, WitSpecMrMgr <Pmr> * theMrMgrPmr):
d216 4
a219 131
         WitMrSite (theMrMgrPmr),

         myPart_   (thePart)
   {
   setUp ();
   }

//------------------------------------------------------------------------------

WitPmrSite::~WitPmrSite ()
   {
   }

//------------------------------------------------------------------------------

WitMrCand * WitPmrSite::defaultMrCand (WitPeriod thePer)
   {
   WitBopEntry * theBopEnt;

   if (not myPart_->explodeable (thePer))
      return NULL;
               
   theBopEnt = myPart_->expBopEntry (thePer);

   return myMrMgr ()->mySelector ()->myPmrMgr ()->myMrCandFor (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitPmrSite::prtID (WitPeriod thePer)
   {
   fprintf (msgFile (),
      "   Part:             %s\n"
      "   Exp Per:          %d\n",
      myPart_->partName ().myCstring (),
      thePer);
   }

//------------------------------------------------------------------------------

void WitPmrSite::printID (WitPeriod thePer)
   {
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      myPart_->partName ().myCstring (),
      thePer);
   }

//------------------------------------------------------------------------------

WitPart * WitPmrSite::sortPart ()
   {
   return myPart_;
   }

//------------------------------------------------------------------------------

bool WitPmrSite::sglSrcMode ()
   {
   return
      myMrMgr ()->mySelector ()->mySglSrcMgr ()->sglSrcMode (
         myPart_->myRtSite ());
   }

//------------------------------------------------------------------------------

WitPart * WitPmrSite::myPmrPart ()
   {
   return myPart_;
   }

//------------------------------------------------------------------------------

WitBomEntry * WitPmrSite::myCmrBomEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

void WitPmrSite::buildMrCands (WitObjStack <WitMrCand> & theMrCands)
   {
   WitBopEntry * theBopEnt;

   if (myPart_->producingBopEntries ().isEmpty ())
      return;

   if (myPart_->propRouting ())
      return;

   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         theMrCands.push (new WitPmrCand (theBopEnt, this));

   theMrCands.reverse ();
   }

//------------------------------------------------------------------------------
// Implementation of class CmrSite.
//------------------------------------------------------------------------------

WitCmrSite::WitCmrSite (
            WitBomEntry *          theBomEnt, 
            WitSpecMrMgr <Cmr> * theMrMgrCmr):

         WitMrSite (theMrMgrCmr),

         myBomEnt_ (theBomEnt)
   {
   setUp ();
   }

//------------------------------------------------------------------------------

WitCmrSite::~WitCmrSite ()
   {
   }

//------------------------------------------------------------------------------

WitMrCand * WitCmrSite::defaultMrCand (WitPeriod thePer)
   {
   if (not myBomEnt_->inEffect (thePer))
      return NULL;

   return myMrMgr ()->mySelector ()->myCmrMgr ()->myMrCandFor (myBomEnt_);
   }

//------------------------------------------------------------------------------

void WitCmrSite::prtID (WitPeriod thePer)
d221 1
a221 9
   fprintf (msgFile (),
      "   Operation:        %s\n"
      "   BOM Entry #:      %d\n"
      "   Part:             %s\n"
      "   Exec Per:         %d\n",
      myBomEnt_->myOperationName ().myCstring (),
      myBomEnt_->localIndex (),
      myBomEnt_->myPartName ().myCstring (),
      thePer);
a225 90
void WitCmrSite::printID (WitPeriod thePer)
   {
   fprintf (msgFile (),
      "   BomEntry %s, #%d, Period %d\n", 
      myBomEnt_->myOperationName ().myCstring (),
      myBomEnt_->localIndex (),
      thePer);
   }

//------------------------------------------------------------------------------

WitPart * WitCmrSite::sortPart ()
   {
   WitOperation * theOpn;
   int            minIdx;
   WitPart *      thePart;
   WitBopEntry *  theBopEnt;

   theOpn  = myBomEnt_->myOperation ();

   minIdx  = theOpn->myCompMgr ()->nParts ();

   thePart = NULL;

   forEachEl (theBopEnt, theOpn->bop ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->myPart ()->sortedPartIndex () < minIdx)
            {
            thePart = theBopEnt->myPart ();

            minIdx  = thePart->sortedPartIndex ();
            }

   witAssert (thePart != NULL);

   return thePart;
   }


//------------------------------------------------------------------------------

bool WitCmrSite::sglSrcMode ()
   {
   return
      myMrMgr ()->mySelector ()->mySglSrcMgr ()->sglSrcMode (
         myBomEnt_->myRtSite ());
   }

//------------------------------------------------------------------------------

WitPart * WitCmrSite::myPmrPart ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitBomEntry * WitCmrSite::myCmrBomEnt ()
   {
   return myBomEnt_;
   }

//------------------------------------------------------------------------------

void WitCmrSite::buildMrCands (WitObjStack <WitMrCand> & theMrCands)
   {
   WitSubEntry * theSub;

   theMrCands.push (new WitCmrCand (myBomEnt_, this));

   forEachEl (theSub, myBomEnt_->mySubEntries ())
      {
      if (theSub->myPart ()->producingBopEntries ().isEmpty ())
         if (theSub->netAllowed ())
            if (not myBomEnt_->singleSource ())
               continue;

      if (not theSub->expAllowed ())
         continue;

      theMrCands.push (new WitCmrCand (theSub, this));
      }

   theMrCands.reverse ();
   }

//------------------------------------------------------------------------------
// Implementation of class MrCand.
//------------------------------------------------------------------------------

d257 1
a257 1
   theSelector = myMrSite_->myMrMgr ()->mySelector ();
a266 11
WitMrCand::WitMrCand (WitRtCand * theRtCand, WitMrSite * theMrSite):

      WitSelCand (theMrSite->myProblem ()),
      myRtCand_  (theRtCand),
      myMrSite_  (theMrSite),
      prevSel_   ()
   {
   }

//------------------------------------------------------------------------------

a272 62
// Implementation of template class PmrCand.
//------------------------------------------------------------------------------

WitPmrCand::WitPmrCand (WitBopEntry * theBopEnt, WitPmrSite * thePmrSite):

      WitMrCand (theBopEnt->myRtCand (), thePmrSite),
      myBopEnt_ (theBopEnt)
   {
   }

//------------------------------------------------------------------------------

WitPmrCand::~WitPmrCand ()
   {
   }

//------------------------------------------------------------------------------

void WitPmrCand::getMyComp (WitBopEntry * & theBopEnt)
   {
   theBopEnt = myBopEnt_;
   }

//------------------------------------------------------------------------------

void WitPmrCand::getMyComp (WitConsEntry * &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------
// Implementation of class CmrCand.
//------------------------------------------------------------------------------

WitCmrCand::WitCmrCand (WitConsEntry * theConsEnt, WitCmrSite * theCmrSite):

      WitMrCand  (theConsEnt->myRtCand (), theCmrSite),
      myConsEnt_ (theConsEnt)
   {
   }

//------------------------------------------------------------------------------

WitCmrCand::~WitCmrCand ()
   {
   }

//------------------------------------------------------------------------------

void WitCmrCand::getMyComp (WitBopEntry * &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitCmrCand::getMyComp (WitConsEntry * & theConsEnt)
   {
   theConsEnt = myConsEnt_;
   }

//------------------------------------------------------------------------------
d318 1
a318 1
   theSelector = myMrSite_->myMrMgr ()->mySelector ();
d336 1
a336 1
   myMrSite_->printID (myPer_);
d343 1
a343 1
      selSelCand ()->myMrCand ()->myRtCand ()->printID (0);
d350 1
a350 1
   myMrSite_->prtID (myPer_);
d357 1
a357 1
   thePart = myMrSite_->sortPart ();
d366 1
a366 1
   return myMrSite_->myMrMgr ();
d375 1
a375 1
   theSelector = myMrSite_->myMrMgr ()->mySelector ();
d419 3
a421 15
   return myMrSite_->sglSrcMode ();
   }

//------------------------------------------------------------------------------

WitPart * WitMrPt::myPmrPart ()
   {
   return myMrSite_->myPmrPart ();
   }

//------------------------------------------------------------------------------

WitBomEntry * WitMrPt::myCmrBomEnt ()
   {
   return myMrSite_->myCmrBomEnt ();
@


1.16
log
@Continued implementation of proportionate routing.
@
text
@d28 1
d95 1
a95 1
         if (theMrCand->isEligible (thePer))
d227 2
a228 2
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
a244 7
const char * WitPmrSite::candCompText ()
   {
   return "BopEntry";
   }

//------------------------------------------------------------------------------

d328 4
a331 4
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
a350 7
const char * WitCmrSite::candCompText ()
   {
   return "ConsEntry";
   }

//------------------------------------------------------------------------------

d445 1
a445 1
   if (isEligible (thePer))
d471 1
a471 1
WitMrCand::WitMrCand (WitMrSite * theMrSite):
d474 1
a474 1

a480 6
// Implementation of template class PmrCand.
//------------------------------------------------------------------------------

WitPmrCand::WitPmrCand (WitBopEntry * theBopEnt, WitPmrSite * thePmrSite):

      WitMrCand (thePmrSite),
d482 1
a482 1
      myBopEnt_ (theBopEnt)
d484 1
d488 1
a488 5

WitPmrCand::~WitPmrCand ()
   {
   }

d491 1
a491 8
void WitPmrCand::prtID ()
   {
   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      myBopEnt_->myOperationName ().myCstring (),
      myBopEnt_->localIndex ());
   }
d493 2
a494 3
//------------------------------------------------------------------------------

bool WitPmrCand::isEligible (WitPeriod expPer)
a495 1
   return myBopEnt_->expEligible (expPer);
d500 1
a500 1
void WitPmrCand::prtAsSel ()
a501 4
   fprintf (msgFile (),
      "%s #%d\n",
      myBopEnt_->myOperationName ().myCstring (),
      myBopEnt_->localIndex ());
d524 1
a524 2
      WitMrCand  (theCmrSite),

a536 38
void WitCmrCand::prtID ()
   {
   WitSubEntry * theSub;

   myConsEnt_->getSubEntry (theSub);

   if (theSub != NULL)
      fprintf (msgFile (), "   Sub #:       %d\n", theSub->localIndex ());
   else
      fprintf (msgFile (), "   Self\n");
                  
   fprintf    (msgFile (), "   Part:        %s\n",
      myConsEnt_->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------

bool WitCmrCand::isEligible (WitPeriod execPer)
   {
   return myConsEnt_->inEffect (execPer);
   }

//------------------------------------------------------------------------------

void WitCmrCand::prtAsSel ()
   {
   WitSubEntry * theSub;

   myConsEnt_->getSubEntry (theSub);

   if (theSub != NULL)
      fprintf (msgFile (), "SubEntry #%d\n", theSub->localIndex ());
   else
      fprintf (msgFile (), "The BomEntry Itself\n");
   }

//------------------------------------------------------------------------------

d615 1
a615 1
   fprintf (msgFile (), "   Selected %s: ", myMrSite_->candCompText ());
d618 1
a618 1
      fprintf (msgFile (), "None\n");
d620 1
a620 1
      selSelCand ()->myMrCand ()->prtAsSel ();
d734 1
a734 1
      if (theMrCand->isEligible (myPer_))
@


1.15
log
@Continued implementation of proportionate routing.
@
text
@d260 3
a262 1
   return myMrMgr ()->mySelector ()->mySglSrcMgr ()->sglSrcMode (myPart_);
d396 3
a398 1
   return myMrMgr ()->mySelector ()->mySglSrcMgr ()->sglSrcMode (myBomEnt_);
@


1.14
log
@Continued implementation of proportionate routing.
@
text
@d555 1
a555 1
      WitMrCand (theCmrSite),
d557 1
a557 1
      myConsEnt_(theConsEnt)
@


1.13
log
@Continued implementation of Proportionate Routing.
@
text
@d132 1
a132 1
      WitProbAssoc (theMrMgr),
d286 1
a286 1
   if (WitSelector::propRouting (myPart_))
d482 1
a482 1
      WitSelCand (theMrSite),
@


1.12
log
@Internal changes.
@
text
@d286 3
@


1.11
log
@Internal changes.
@
text
@d95 1
a95 1
            if (! theMrCand->prevSel (thePer))
d115 1
a115 1
   if (! multiChoice_)
d160 1
a160 1
   if (! multiChoice_)
d213 1
a213 1
   if (! myPart_->explodeable (thePer))
d318 1
a318 1
   if (! myBomEnt_->inEffect (thePer))
d420 1
a420 1
            if (! myBomEnt_->singleSource ())
d423 1
a423 1
      if (! theSub->expAllowed ())
d452 1
a452 1
      if (! prevSel (thePer))
d464 1
a464 1
   if (! prevSel_.isAllocated ())
d786 1
a786 1
   witAssert (! theMrCand->prevSel (myPer_));
d802 1
a802 1
         if (! theMrCand->prevSel (myPer_))
@


1.10
log
@Removed implementation of single-source by the old algorithm.
@
text
@d136 1
a136 1
      multiChoice_ (witFALSE),
d258 1
a258 1
WitBoolean WitPmrSite::sglSrcMode ()
d389 1
a389 1
WitBoolean WitCmrSite::sglSrcMode ()
d449 1
a449 1
WitBoolean WitMrCand::valid (WitPeriod thePer)
d453 1
a453 1
         return witTRUE;
d455 1
a455 1
   return witFALSE;
d460 1
a460 1
void WitMrCand::setPrevSel (WitPeriod thePer, WitBoolean theVal)
d465 1
a465 1
      prevSel_.allocate (myProblem (), witFALSE);
d517 1
a517 1
WitBoolean WitPmrCand::isEligible (WitPeriod expPer)
d543 1
a543 1
   stronglyAssert (witFALSE);
d583 1
a583 1
WitBoolean WitCmrCand::isEligible (WitPeriod execPer)
d606 1
a606 1
   stronglyAssert (witFALSE);
d626 1
a626 1
      hasResAlt_ (witFALSE)
d647 1
a647 1
WitBoolean WitMrPt::hasResAlt ()
d667 1
a667 1
   selMrCand ()->setPrevSel (myPer_, witTRUE);
d715 1
a715 1
WitBoolean WitMrPt::splittable ()
d723 1
a723 1
         return witFALSE;
d752 1
a752 1
   theMrCand->setPrevSel (myPer_, witFALSE);
d761 1
a761 1
WitBoolean WitMrPt::sglSrcMode ()
@


1.9
log
@Continued implementation of single-source by the new algorithm.
@
text
@a27 1
#include <OldSglMgr.h>
a468 3
   if (theSelector->oldSglSrc ())
      theSelector->myOldSglMgr ()->saveConfigVal (prevSel_[thePer]);

a663 3
   if (theSelector->oldSglSrc ())
      theSelector->myOldSglMgr ()->saveConfigVal (hasResAlt_);

a719 4

   if (theSelector->oldSglSrc ())
      if (theSelector->myOldSglMgr ()->sglSrcMode (this))
         return witFALSE;
@


1.8
log
@Continued implementation of single-source with the new algorithm.
@
text
@d259 7
d390 7
d732 4
d768 7
@


1.7
log
@Began implementation of the new single-source algorithm.
@
text
@d29 1
d459 3
d656 3
@


1.6
log
@Began implementation of multi-level lot sizes.
@
text
@d28 1
a28 1
#include <SglSrcMgr.h>
d455 2
a456 2
   if (theSelector->singleSource ())
      theSelector->mySglSrcMgr ()->saveConfigVal (prevSel_[thePer]);
d650 2
a651 2
   if (theSelector->singleSource ())
      theSelector->mySglSrcMgr ()->saveConfigVal (hasResAlt_);
d707 2
a708 2
   if (theSelector->singleSource ())
      if (theSelector->mySglSrcMgr ()->sglSrcMode (this))
@


1.5
log
@Refactoring.
@
text
@d1 794
@


1.4
log
@Templatized consumption multi-route.
@
text
@a0 1121
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MultiRoute.C"
//
// Contains the implementation of the following classes and class templates:
//
//    PmrMgr 
//    CmrMgr 
//
//    MrMgr      <MrArgs>
//    MrSelSite  <MrArgs>
//    MrCand     <MrArgs>
//    MrSelPt    <MrArgs>
//
//    MrMgr     <PmrArgs>
//    MrSelSite <PmrArgs>
//    MrCand    <PmrArgs>
//    MrSelPt   <PmrArgs>
//
//    MrMgr     <CmrArgs>
//    MrSelSite <CmrArgs>
//    MrCand    <CmrArgs>
//    MrSelPt   <CmrArgs>
//------------------------------------------------------------------------------

#include <MrSelPt.h>
#include <MrCand.h>
#include <MrSelSite.h>
#include <CmrMgr.h>
#include <PmrMgr.h>
#include <BopEntry.h>

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitMrMgr <PmrArgs> (theSelector),

      totExpVol_         (myProblem ())
   {
   myMsgFac () ("multiRouteMsg");
   }

//------------------------------------------------------------------------------

WitPmrMgr::~WitPmrMgr ()
   {
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return selCandComp (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitMrMgr <PmrArgs>::modifyRouting (theBopEntPers);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   findCandComps (thePart, expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   return WitMrMgr <PmrArgs>::selIsSplit (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
   {
   WitMrMgr <PmrArgs>::startSplitExp (thePart, expPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::findNextSplit (
      WitBopEntry * & theBopEnt, 
      double &        splitExpVol)
   {
   return WitMrMgr <PmrArgs>::findNextSplit (theBopEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------

void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double        expVol)
   {
   if (selSplit ())
      if (myMrSelSiteFor (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myMrSelSiteFor (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPmrMgr::setUpDerivedSS ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_.allocate1D ();

   forEachPart (thePart, myProblem ())
      if (myMrSelSiteFor (thePart)->multiChoice ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::adjustSplitBound (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double &      splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitCmrMgr::WitCmrMgr (WitSelector * theSelector):
      WitMrMgr <CmrArgs> (theSelector),

      totExecVol_        (myProblem ())
   {
   }

//------------------------------------------------------------------------------

WitCmrMgr::~WitCmrMgr ()
   {
   }

//------------------------------------------------------------------------------

WitConsEntry * WitCmrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
   {
   return selCandComp (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::modifyRouting (WitConsEntPerStack & theConsEntPers)
   {
   WitMrMgr <CmrArgs>::modifyRouting (theConsEntPers);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt, 
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   findCandComps (theBomEnt, execPer, theConsEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   return WitMrMgr <CmrArgs>::selIsSplit (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        expVol)
   {
   WitMrMgr <CmrArgs>::startSplitExp (theBomEnt, execPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::findNextSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExpVol)
   {
   return WitMrMgr <CmrArgs>::findNextSplit (theConsEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------

void WitCmrMgr::recExpConsEntSS (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double         deltaExecVol)
   {
   if (selSplit ())
      if (myMrSelSiteFor (theConsEnt->myBomEnt ())->multiChoice ())
         totExecVol_.incCell (theConsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::printHasAlt ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Consumption Multi-Route Selection Points with Alternative(s):\n\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrSelSiteFor (theBomEnt)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitCmrMgr::setUpDerivedSS ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   witAssert (selSplit ());

   totExecVol_.allocate1D ();

   forEachBomEntry (theBomEnt, myProblem ())
      if (myMrSelSiteFor (theBomEnt)->multiChoice ())
         {
         totExecVol_.allocateRow (theBomEnt);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->expAllowed ())
               totExecVol_.allocateRow (theSub);
         }
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExecVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::adjustSplitBound (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double &       splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExecVol_ (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------
// Implementation of class template MrMgr <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrMgr <MrArgs>::WitMrMgr (WitSelector * theSelector):
         WitSelMgr       (theSelector),

         myMrSelSiteFor_ (myProblem ())
   {
   buildMrSelSites ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      CandComp * WitMrMgr <MrArgs>::selCandComp (
         SelComp * theSelComp, 
         WitPeriod thePer)
   {
   return myMrSelSiteFor_ (theSelComp)->selCandComp (thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::modifyRouting (
         WitPairStack <CandComp, WitPeriod> & theCandCompPers)
   {
   CandComp *              theCandComp;
   WitPeriod               thePer;
   WitMrSelSite <MrArgs> * theMrSelSite;

   while (theCandCompPers.pop (theCandComp, thePer))
      {
      theMrSelSite = myMrSelSiteFor_ (theSelCompFor (theCandComp));

      theMrSelSite->myMrSelPt ()[thePer]->select (theCandComp);
      }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::findCandComps (
         SelComp *                theSelComp, 
         WitPeriod                thePer,
         WitObjStack <CandComp> & theCandComps)
   {
   myMrSelSiteFor_ (theSelComp)->findCandComps (thePer, theCandComps);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::selIsSplit (
         SelComp * theSelComp, 
         WitPeriod thePer)
   {
   WitMrSelSite <MrArgs> * theMrSelSite;

   if (! selSplit ())
      return witFALSE;

   theMrSelSite = myMrSelSiteFor_ (theSelComp);
      
   if (! theMrSelSite->multiChoice ())
      return witFALSE;

   return theMrSelSite->myMrSelPt ()[thePer]->isSplit ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::startSplitExp (
         SelComp * theSelComp, 
         WitPeriod thePer,
         double    expVol)
   {
   WitMrSelPt <MrArgs> * theMrSelPt;

   witAssert (selIsSplit (theSelComp, thePer));

   theMrSelPt = myMrSelSiteFor_ (theSelComp)->myMrSelPt ()[thePer];

   startSplitExpAbs (theMrSelPt, expVol);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::selSplitNeeded ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::postSplitCommit ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitSelPt * WitMrMgr <MrArgs>::mySelPt (
         CandComp *   theCandComp,
         WitPeriod    thePer,
         WitBoolean & resFound)
   {
   WitMrSelPt <MrArgs> * theMrSelPt;

   theMrSelPt = 
      myMrSelSiteFor (theSelCompFor (theCandComp))->myMrSelPtWithAlt (thePer);

   resFound   =
      (theMrSelPt != NULL)?
         theMrSelPt->hasResAlt ():
         witFALSE;

   return theMrSelPt;
   }

//------------------------------------------------------------------------------
// Implementation of class template MrSelSite <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelSite <MrArgs>::WitMrSelSite (
            SelComp *           theSelComp, 
            WitMrMgr <MrArgs> * theMrMgr):

         WitProbAssoc (theMrMgr),

         myMrMgr_     (theMrMgr),
         mySelComp_   (theSelComp),
         myMrCands_   (myProblem ()),
         multiChoice_ (witFALSE),
         myMrSelPt_   ()
   {
   if (! myGlobalComp ()->multiRoute ())
      return;

   buildMrCands ();

   buildMrSelPts ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelSite <MrArgs>::~WitMrSelSite ()
   {
   WitPeriod            thePer;
   WitMrCand <MrArgs> * theMrCand;

   if (multiChoice_)
      forEachPeriod (thePer, myProblem ())
         delete myMrSelPt_[thePer];

   while (myMrCands_.pop (theMrCand))
      delete theMrCand;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::printHasAlt ()
   {
   WitPeriod             thePer;
   WitMrSelPt <MrArgs> * theMrSelPt;

   if (! multiChoice_)
      return;

   forEachPeriod (thePer, myProblem ())
      {
      theMrSelPt = myMrSelPt_[thePer];

      if (theMrSelPt != NULL)
         if (theMrSelPt->selMrCand () != NULL)
            theMrSelPt->printID ();
      }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::findCandComps (
         WitPeriod                thePer, 
         WitObjStack <CandComp> & theCandComps)
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;
   CandComp *           theCandComp;

   theCandComps.clear ();

   if (multiChoice ())
      {
      theMrCandItr.attachTo (myMrCands_);

      while (theMrCandItr.advance (theMrCand))
         if (theMrCand->isEligible (thePer))
            if (! theMrCand->prevSel ()[thePer])
               theCandComps.push (theMrCand->myCandComp ());

      theCandComps.reverse ();
      }

   if (theCandComps.isEmpty ())
      {
      theCandComp = defaultCandComp (thePer);

      if (theCandComp != NULL)
         theCandComps.push (theCandComp);
      }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs> * WitMrSelSite <MrArgs>::myMrCandFor (
         CandComp * theCandComp)
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   theMrCandItr.attachTo (myMrCands_);

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->myCandComp () == theCandComp)
         return theMrCand;

   myMsgFac () ("internalErrorFmsg", "WitMrSelSite <MrArgs>::myMrCandFor");

   return NULL;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      CandComp * WitMrSelSite <MrArgs>::selCandComp (WitPeriod thePer)
   {
   WitMrCand <MrArgs> * theMrCand;

   witAssert (defaultCandComp (thePer) != NULL);

   if (multiChoice_)
      {
      theMrCand = myMrSelPt_[thePer]->selMrCand ();

      if (theMrCand != NULL)
         return theMrCand->myCandComp ();
      }

   return defaultCandComp (thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::buildMrSelPts ()
   {
   WitPeriod thePer;

   if (! multiChoice_)
      return;

   myMrSelPt_.allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      if (defaultCandComp (thePer) != NULL)
         myMrSelPt_[thePer] = new WitMrSelPt <MrArgs> (this, thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs> * WitMrSelSite <MrArgs>::multiChoiceMrSelPtWithAlt (
         WitPeriod thePer)
   {
   WitMrSelPt <MrArgs> * theMrSelPt;

   witAssert (multiChoice_);

   theMrSelPt = myMrSelPt_[thePer];

   witAssert (theMrSelPt != NULL);

   return
      (theMrSelPt->selMrCand () != NULL)?
         theMrSelPt:
         NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class template MrCand <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs>::WitMrCand (CandComp * theCandComp):

         WitSelCand  (theCandComp),

         myCandComp_ (theCandComp),
         prevSel_    (myProblem (), witFALSE)
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs>::~WitMrCand ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrCand <MrArgs>::setPrevSel (WitPeriod thePer)
   {
   prevSel_.elemRef (thePer) = witTRUE;
   }

//------------------------------------------------------------------------------
// Implementation of class template MrSelPt <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs>::WitMrSelPt (
            WitMrSelSite <MrArgs> * theMrSelSite, 
            WitPeriod               thePer):

         WitSelPt     (),

         myMrSelSite_ (theMrSelSite),
         myPer_       (thePer),
         selMrCand_   (NULL),
         hasResAlt_   (witFALSE)
   {
   CandComp *           theCandComp;
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   theCandComp = myMrSelSite_->defaultCandComp (myPer_);

   witAssert (theCandComp != NULL);

   selMrCand_  = myMrSelSite_->myMrCandFor (theCandComp);

   theMrCandItr.attachTo (myMrSelSite_->myMrCands ());

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->isEligible (myPer_))
         if (theMrCand != selMrCand_)
            {
            hasResAlt_ = witTRUE;

            break;
            }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs>::~WitMrSelPt ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitTlObj * WitMrSelPt <MrArgs>::selectedObj ()
   {
   CandComp * theCandComp;

   witAssert (selMrCand_ != NULL);

   theCandComp = selMrCand_->myCandComp ();

   return (WitTlObj *) theCandComp;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::alterSelection ()
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   witAssert (selMrCand_ != NULL);

   selMrCand_->setPrevSel (myPer_);

   selMrCand_ = NULL;
   hasResAlt_  = witFALSE;

   theMrCandItr.attachTo (myMrSelSite_->myMrCands ());

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->isEligible (myPer_))
         if (! theMrCand->prevSel ()[myPer_])
            if (selMrCand_ == NULL)
               selMrCand_ = theMrCand;
            else
               {
               hasResAlt_ = witTRUE;

               return;
               }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitSelMgr * WitMrSelPt <MrArgs>::mySelMgr ()
   {
   return myMrSelSite_->myMrMgr ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrSelPt <MrArgs>::splittable ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::adjustSplitBound (
         WitTlObj * theTlObj, 
         double & splitBound)
   {
   CandComp * theCandComp;

   theCandComp = (CandComp *) theTlObj;

   myMrSelSite_->myMrMgr ()->adjustSplitBound (theCandComp, myPer_, splitBound);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::select (CandComp * theCandComp)
   {
   WitMrCand <MrArgs> * theMrCand;

   theMrCand = myMrSelSite_->myMrCandFor (theCandComp);

   witAssert (theMrCand != selMrCand_);

   witAssert (! theMrCand->prevSel ()[myPer_]);

   selMrCand_ = theMrCand;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      FILE * WitMrSelPt <MrArgs>::msgFile ()
   {
   return myMrSelSite_->msgFile ();
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of Prod-MR template classes.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <PmrArgs>.
//------------------------------------------------------------------------------

WitMrMgr <PmrArgs>::~WitMrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myMrSelSiteFor_ (thePart);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr <PmrArgs>::mySelPt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod,
      WitBoolean &  resFound)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return mySelPt (theBopEnt, expPer, resFound);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <PmrArgs>::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <PmrArgs>::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <PmrArgs>::prtSelCandID (WitTlObj * theTlObj)
   {
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) theTlObj;

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------

void WitMrMgr <PmrArgs>::buildMrSelSites ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      myMrSelSiteFor_ (thePart) = 
         new WitMrSelSite <PmrArgs> (thePart, this);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelSite <PmrArgs>.
//------------------------------------------------------------------------------

WitBopEntry * WitMrSelSite <PmrArgs>::defaultCandComp (WitPeriod expPer)
   {
   return
      mySelComp_->explodeable (expPer)?
         mySelComp_->expBopEntry (expPer):
         NULL;
   }

//------------------------------------------------------------------------------

void WitMrSelSite <PmrArgs>::buildMrCands ()
   {
   WitBopEntry * theBopEnt;

   if (mySelComp_->producingBopEntries ().isEmpty ())
      return;

   forEachEl (theBopEnt, mySelComp_->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         myMrCands_.push (new WitMrCand <PmrArgs> (theBopEnt));

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrCand <PmrArgs>.
//------------------------------------------------------------------------------

WitBoolean WitMrCand <PmrArgs>::isEligible (WitPeriod expPer)
   {
   return myCandComp_->expEligible (expPer);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelPt <PmrArgs>.
//------------------------------------------------------------------------------

void WitMrSelPt <PmrArgs>::printID ()
   {
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrSelPt <PmrArgs>::printSelection ()
   {
   WitBopEntry * theBopEnt;

   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected BopEntry: ");

   if (selMrCand_ == NULL)
      fprintf (msgFile (), "None\n");
   else
      {
      theBopEnt = selMrCand_->myCandComp ();

      fprintf (msgFile (),
         "%s #%d\n",
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex ());
      }
   }

//------------------------------------------------------------------------------

void WitMrSelPt <PmrArgs>::prtID ()
   {
   fprintf (msgFile (),
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of Cons-MR template classes.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <CmrArgs>.
//------------------------------------------------------------------------------

WitMrMgr <CmrArgs>::~WitMrMgr ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      delete myMrSelSiteFor_ (theBomEnt);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr <CmrArgs>::mySelPt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod,
      WitBoolean &   resFound)
   {
   return mySelPt (theConsEnt, execPer, resFound);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <CmrArgs>::validForExecBounds ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <CmrArgs>::selCaseName ()
   {
   return "Consumption Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <CmrArgs>::prtSelCandID (WitTlObj * theTlObj)
   {
   WitConsEntry * theConsEnt;

   theConsEnt = (WitConsEntry *) theTlObj;

   if (theConsEnt == theConsEnt->myBomEnt ())
      fprintf (msgFile (), "   Self\n");
   else
      fprintf (msgFile (), "   Sub #:       %d\n", theConsEnt->localIndex ());
                  
   fprintf    (msgFile (), "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitMrMgr <CmrArgs>::buildMrSelSites ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      myMrSelSiteFor_ (theBomEnt) = 
         new WitMrSelSite <CmrArgs> (theBomEnt, this);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelSite <CmrArgs>.
//------------------------------------------------------------------------------

WitConsEntry * WitMrSelSite <CmrArgs>::defaultCandComp (WitPeriod execPer)
   {
   return
      mySelComp_->inEffect (execPer)?
         mySelComp_:
         NULL;
   }

//------------------------------------------------------------------------------

void WitMrSelSite <CmrArgs>::buildMrCands ()
   {
   WitSubEntry * theSub;

   myMrCands_.push (new WitMrCand <CmrArgs> (mySelComp_));

   forEachEl (theSub, mySelComp_->mySubEntries ())
      {
      if (theSub->myPart ()->producingBopEntries ().isEmpty ())
         if (theSub->netAllowed ())
            continue;

      if (! theSub->expAllowed ())
         continue;

      myMrCands_.push (new WitMrCand <CmrArgs> (theSub));
      }

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrCand <CmrArgs>.
//------------------------------------------------------------------------------

WitBoolean WitMrCand <CmrArgs>::isEligible (WitPeriod execPer)
   {
   return myCandComp_->inEffect (execPer);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelPt <CmrArgs>.
//------------------------------------------------------------------------------

void WitMrSelPt <CmrArgs>::printID ()
   {
   WitBomEntry * theBomEnt;

   theBomEnt = myMrSelSite_->mySelComp ();

   fprintf (msgFile (),
      "   BomEntry %s, #%d, Period %d\n", 
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrSelPt <CmrArgs>::printSelection ()
   {
   WitConsEntry * theConsEnt;

   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected ConsEntry: ");

   if (selMrCand_ == NULL)
      fprintf (msgFile (), "None\n");
   else
      {
      theConsEnt = selMrCand_->myCandComp ();

      if (theConsEnt->isaSubEntry ())
         fprintf (msgFile (), "SubEntry #%d\n", theConsEnt->localIndex ());
      else
         fprintf (msgFile (), "The BomEntry Itself\n");
      }
   }

//------------------------------------------------------------------------------

void WitMrSelPt <CmrArgs>::prtID ()
   {
   WitBomEntry * theBomEnt;

   theBomEnt = myMrSelSite_->mySelComp ();

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      theBomEnt->myPartName ().myCstring (),
      myPer_);
   }
@


1.3
log
@Continued refactoring.
@
text
@d16 7
a22 1
//    MrMgr     <MrArgs>
d24 8
a31 3
//    MrSelSite <MrArgs>
//    MrCand    <MrArgs>
//    MrSelPt   <MrArgs>
d37 1
d50 1
d80 1
a80 1
   findConsComps (thePart, expPer, theBopEnts);
d178 80
a257 2
// Non-parametric implementation of class template MrMgr <MrArgs> inline member
// functions.
d260 1
a260 1
inline WitPart * WitMrMgr <PmrArgs>::theSelCompFor (WitBopEntry * theBopEnt)
d262 53
a314 1
   return theBopEnt->myPart ();
d322 11
d361 1
a361 1
      void WitMrMgr <MrArgs>::findConsComps (
a408 32
      WitBoolean WitMrMgr <MrArgs>::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      const char * WitMrMgr <MrArgs>::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::prtSelCandID (WitTlObj * theTlObj)
   {
   CandComp * theCandComp;

   theCandComp = (CandComp *) theTlObj;

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theCandComp->myOperationName ().myCstring (),
      theCandComp->localIndex ());
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
a442 43
// Non-parametric implementation of template class MrMgr <PmrArgs> member
// functions.
//------------------------------------------------------------------------------

WitMrMgr <PmrArgs>::WitMrMgr (WitSelector * theSelector):
      WitSelMgr       (theSelector),

      myMrSelSiteFor_ (myProblem ())
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      myMrSelSiteFor_ (thePart) = 
         new WitMrSelSite <PmrArgs> (thePart, this);
   }

//------------------------------------------------------------------------------

WitMrMgr <PmrArgs>::~WitMrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myMrSelSiteFor_ (thePart);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr <PmrArgs>::mySelPt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod,
      WitBoolean &  resFound)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return mySelPt (theBopEnt, expPer, resFound);
   }

//------------------------------------------------------------------------------
d513 1
d530 6
a535 2
      if (mySelComp_->explodeable (thePer))
         theCandComps.push (mySelComp_->expBopEntry (thePer));
d565 1
a565 1
   witAssert (mySelComp_->explodeable (thePer));
d575 1
a575 1
   return mySelComp_->expBopEntry (thePer);
d591 1
a591 1
      if (mySelComp_->explodeable (thePer))
a615 19

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::buildMrCands ()
   {
   CandComp * theCandComp;

   if (mySelComp_->producingBopEntries ().isEmpty ())
      return;

   forEachEl (theCandComp, mySelComp_->producingBopEntries ())
      if (theCandComp->expAllowed ())
         myMrCands_.push (new WitMrCand <MrArgs> (theCandComp));

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
a638 8
      WitBoolean WitMrCand <MrArgs>::isEligible (WitPeriod thePer)
   {
   return myCandComp_->expEligible (thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
d664 1
a664 1
   witAssert (myMrSelSite_->mySelComp ()->explodeable (myPer_));
d666 1
a666 1
   theCandComp  = myMrSelSite_->mySelComp ()->expBopEntry (myPer_);
d668 1
a668 1
   selMrCand_   = myMrSelSite_->myMrCandFor (theCandComp);
d736 9
a744 1
      void WitMrSelPt <MrArgs>::printSelection ()
d746 170
d925 3
d930 14
a943 2
         selMrCand_->myCandComp ()->myOperationName ().myCstring (),
         selMrCand_->myCandComp ()->localIndex ());
d947 6
d954 1
a954 2
template <MrArgDecs>
      WitSelMgr * WitMrSelPt <MrArgs>::mySelMgr ()
d956 4
a959 1
   return myMrSelSite_->myMrMgr ();
d964 6
a969 2
template <MrArgDecs>
      void WitMrSelPt <MrArgs>::prtID ()
d971 1
a971 5
   fprintf (msgFile (),
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
      myPer_);
d976 1
a976 2
template <MrArgDecs>
      WitBoolean WitMrSelPt <MrArgs>::splittable ()
d983 48
a1030 4
template <MrArgDecs>
      void WitMrSelPt <MrArgs>::adjustSplitBound (
         WitTlObj * theTlObj, 
         double & splitBound)
d1032 20
a1051 1
   CandComp * theCandComp;
d1053 3
a1055 1
   theCandComp = (CandComp *) theTlObj;
d1057 3
a1059 1
   myMrSelSite_->myMrMgr ()->adjustSplitBound (theCandComp, myPer_, splitBound);
d1063 2
d1066 1
a1066 2
template <MrArgDecs>
      void WitMrSelPt <MrArgs>::printID ()
d1068 8
a1075 3
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
d1081 1
a1081 2
template <MrArgDecs>
      void WitMrSelPt <MrArgs>::select (CandComp * theCandComp)
d1083 3
a1085 1
   WitMrCand <MrArgs> * theMrCand;
d1087 1
a1087 1
   theMrCand = myMrSelSite_->myMrCandFor (theCandComp);
d1089 1
a1089 1
   witAssert (theMrCand != selMrCand_);
d1091 5
a1095 1
   witAssert (! theMrCand->prevSel ()[myPer_]);
d1097 5
a1101 1
   selMrCand_ = theMrCand;
d1106 1
a1106 2
template <MrArgDecs>
      FILE * WitMrSelPt <MrArgs>::msgFile ()
d1108 13
a1120 1
   return myMrSelSite_->msgFile ();
@


1.2
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@d17 1
d34 3
a36 1
      WitMrMgr <PmrArgs> (theSelector)
d50 1
a50 8
   return myMrMgr ()->selBopEntry (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   myMrMgr ()->printHasAlt ();
d57 1
a57 1
   myMrMgr ()->modifyRouting (theBopEntPers);
d67 1
a67 1
   myMrMgr ()->findExpBopEnts (thePart, expPer, theBopEnts);
d74 1
a74 1
   return myMrMgr ()->selIsSplit (thePart, expPer);
d84 1
a84 1
   myMrMgr ()->startSplitExp (thePart, expPer, expVol);
d93 1
a93 1
   return myMrMgr ()->findNextSplit (theBopEnt, splitExpVol);
d98 1
a98 1
void WitPmrMgr::adjustSplitBound (
d101 1
a101 1
      double &      splitBound)
d103 3
a105 1
   myMrMgr ()->adjustSplitBound (theBopEnt, expPer, splitBound);
d110 1
a110 4
void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double        expVol)
d112 6
a117 2
   myMrMgr ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);
   }
d119 2
a120 3
//------------------------------------------------------------------------------
// Implementation of class template MrMgr <MrArgs>.
//------------------------------------------------------------------------------
d122 1
a122 6
template <MrArgDecs>
      WitBopEntry * WitMrMgr <MrArgs>::selBopEntry (
         WitPart * thePart, 
         WitPeriod expPer)
   {
   return myMrSelSiteFor_ (thePart)->selCandComp (expPer);
d127 1
a127 7
template <MrArgDecs>
      WitSelPt * WitMrMgr <MrArgs>::mySelPt (
         WitBopEntry * theBopEnt,
         WitConsEntry *,
         WitPeriod     execPer,
         WitPeriod,
         WitBoolean &  resFound)
d129 2
a130 2
   WitPeriod             expPer;
   WitMrSelPt <MrArgs> * theMrSelPt;
d132 1
a132 1
   expPer     = theBopEnt->impactPeriod ()[execPer];
d134 1
a134 2
   theMrSelPt = 
      myMrSelSiteFor_ (theBopEnt->myPart ())->myMrSelPtWithAlt (expPer);
d136 5
a140 6
   resFound   =
      (theMrSelPt != NULL)?
         theMrSelPt->hasResAlt ():
         witFALSE;

   return theMrSelPt;
d145 1
a145 2
template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::validForExecBounds ()
d147 3
a149 1
   return witTRUE;
d154 4
a157 2
template <MrArgDecs>
      const char * WitMrMgr <MrArgs>::selCaseName ()
d159 3
a161 1
   return "Production Multi-Route";
d165 3
d169 1
a169 2
template <MrArgDecs>
      void WitMrMgr <MrArgs>::prtSelCandID (WitTlObj * theTlObj)
d171 1
a171 9
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) theTlObj;

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
d175 2
d179 3
a181 1
      void WitMrMgr <MrArgs>::printHasAlt ()
d183 1
a183 11
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myMrSelSiteFor_ (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
d189 2
a190 1
      void WitMrMgr <MrArgs>::modifyRouting (WitBopEntPerStack & theBopEntPers)
d192 2
a193 2
   WitBopEntry *           theBopEnt;
   WitPeriod               expPer;
d196 1
a196 1
   while (theBopEntPers.pop (theBopEnt, expPer))
d198 1
a198 1
      theMrSelSite = myMrSelSiteFor_ (theBopEnt->myPart ());
d200 1
a200 1
      theMrSelSite->myMrSelPt ()[expPer]->select (theBopEnt);
d207 4
a210 4
      void WitMrMgr <MrArgs>::findExpBopEnts (
         WitPart *        thePart, 
         WitPeriod        expPer,
         WitBopEntStack & theBopEnts)
d212 1
a212 9
   myMrSelSiteFor_ (thePart)->findCandComps (expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::selSplitNeeded ()
   {
   return witFALSE;
d219 2
a220 2
         WitPart * thePart, 
         WitPeriod expPer)
d227 1
a227 1
   theMrSelSite = myMrSelSiteFor_ (thePart);
d232 1
a232 1
   return theMrSelSite->myMrSelPt ()[expPer]->isSplit ();
d239 2
a240 2
         WitPart * thePart, 
         WitPeriod expPer,
d245 1
a245 1
   witAssert (selIsSplit (thePart, expPer));
d247 1
a247 1
   theMrSelPt = myMrSelSiteFor_ (thePart)->myMrSelPt ()[expPer];
d255 1
a255 4
      void WitMrMgr <MrArgs>::adjustSplitBound (
         WitBopEntry * theBopEnt, 
         WitPeriod     expPer, 
         double &      splitBound)
d257 4
a260 1
   witAssert (selSplit ());
d262 4
a265 1
   splitBound -= totExpVol_ (theBopEnt, expPer);
d271 1
a271 4
      void WitMrMgr <MrArgs>::recBopEntExpPerSS (
         WitBopEntry * theBopEnt,
         WitPeriod     expPer,
         double        expVol)
d273 9
a281 3
   if (selSplit ())
      if (myMrSelSiteFor_ (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
d287 1
a287 1
      void WitMrMgr <MrArgs>::postCommitSS ()
d289 1
a289 3
   witAssert (selSplit ());

   totExpVol_.clear ();
d302 14
a315 2
      WitMrMgr <MrArgs>::WitMrMgr (WitSelector * theSelector):
         WitSelMgr       (theSelector),
d317 12
a328 2
         myMrSelSiteFor_ (myProblem ()),
         totExpVol_      (myProblem ())
d333 2
a334 1
      myMrSelSiteFor_ (thePart) = new WitMrSelSite <MrArgs> (thePart, this);
d339 1
a339 2
template <MrArgDecs>
      WitMrMgr <MrArgs>::~WitMrMgr ()
d349 6
a354 2
template <MrArgDecs>
      void WitMrMgr <MrArgs>::setUpDerivedSS ()
d356 1
a356 2
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
d358 1
a358 3
   witAssert (selSplit ());

   totExpVol_.allocate1D ();
d360 1
a360 5
   forEachPart (thePart, myProblem ())
      if (myMrSelSiteFor_ (thePart)->multiChoice ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);
d429 2
a430 2
         WitPeriod                   thePer, 
         WitObjStack <WitBopEntry> & theCandComps)
@


1.1
log
@Minor modification.
@
text
@d129 1
a129 1
   return myMrSelSite (thePart)->selCandComp (expPer);
d147 2
a148 1
   theMrSelPt = myMrSelSite (theBopEnt->myPart ())->myMrSelPtWithAlt (expPer);
d203 1
a203 1
      myMrSelSite (thePart)->printHasAlt ();
d219 1
a219 1
      theMrSelSite = myMrSelSite (theBopEnt->myPart ());
d233 1
a233 1
   myMrSelSite (thePart)->findCandComps (expPer, theBopEnts);
d256 1
a256 1
   theMrSelSite = myMrSelSite (thePart);
d276 1
a276 1
   theMrSelPt = myMrSelSite (thePart)->myMrSelPt ()[expPer];
d303 1
a303 1
      if (myMrSelSite (theBopEnt->myPart ())->multiChoice ())
d328 1
a328 1
         WitSelMgr      (theSelector),
d330 2
a331 2
         myMrSelSiteTl_ (),
         totExpVol_     (myProblem ())
a334 2
   myMrSelSiteTl_.allocate (myProblem (), NULL);

d336 1
a336 1
      myMrSelSite (thePart) = new WitMrSelSite <MrArgs> (thePart, this);
d347 1
a347 1
      delete myMrSelSite (thePart);
d363 1
a363 1
      if (myMrSelSite (thePart)->multiChoice ())
@


head	1.45;
access;
symbols
	sce_5_01_20080919:1.38
	latest_sce_4_20_20060523:1.36.0.2
	sce_4_20_20060523:1.36
	latest_sce4_20_OSL:1.33.0.2
	sce_4_20_OSL:1.33
	sce_410_withVa:1.30
	sce_4_05_20040511:1.22
	sce_4_00_20040201:1.15
	nextGenBranch:1.13.0.2
	nextGenRoot:1.13
	sce_3_30_20030627:1.12
	EndRw-branch:1.4.0.4
	Root-of-EndRw:1.4
	rwToStl:1.4.0.2
	latest_sce_3_10_20010924:1.3.0.8
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.6
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.3.0.4
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2011.09.28.23.50.51;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.24.00.29.06;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.30.20.50.58;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.08.30.20.18.30;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.08.21.14.45;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.02.20.34.05;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.02.19.27.03;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.02.14.17.36;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.08.14.45.50;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.02.17.34.19;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.01.20.25.01;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.01.18.42.15;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.21.22.05.39;	author dpc;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.18.20.56.22;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.13.19.31.58;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.13.21.18.48;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.07.18.18.11;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.07.16.00.59;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.07.15.19.54;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.07.15.16.24;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.23.15.40.17;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.10.23.56.57;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.14.18.37.34;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.13.18.59.01;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.12.23.02.55;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.12.22.48.05;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.12.20.59.07;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.08.22.24.25;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.09.19.57.43;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.05.21.09.46;	author dpc;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.29.14.27.51;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.28.17.47.08;	author dpc;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.23.20.47.22;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.23.19.13.25;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.23.40.56;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.02.22.19.00;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.25.15.15.23;	author rwToStl;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.14.02.50;	author rjw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.03.10.23.17.50;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.30;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.35;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2002.11.08.18.50.39;	author fasano;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.13.53.35;	author wit;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Revised the source code proprietary statement.
@
text
@%{
//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

/*------------------------------------------------------------------------------
 *
 *     Source file:    witParse.y
 *
 *     Parser for WIT 4.0 Input Data File Format
 *
 *     To create an executable parser file:
 *
 *           yacc -d  witParse.y             (creates y.tab.c and y.tab.h)
 *           mv -f y.tab.c witParse.C
 *           mv -f y.tab.h ytab.h
 *           lex  witLexer.l                 (creates lex.yy.c)    
 *           mv -f lex.yy.c witLexer.C
 *           xlC witLexer.C witParse.C -o witParse -ly -ll
 *    
 *           Notes:
 *           
 *              -d   causes y.tab.h to be created.  This is the token
 *                   name definition file.
 *
 *              -ly  causes the yacc library to be included. This 
 *                   library is in /usr/lib/liby.a
 *
 *              -ll  causes the lex library to be included. This
 *                   library is in /usr/lib/libl.a      
 *
 *------------------------------------------------------------------------------
 *
 */

#include <Parser.h>
#include <Problem.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <VecBS.h>
#include <Entity.h>
#include <MsgFac.h>

#include <errno.h>

extern  FILE *yyin;

//#if defined(__GNUC__)
extern int yylex (void);
extern void yyrestart (FILE *);
//#endif

extern "C" void yyerror(const char *)
{
}

//#if defined (WIN32) or defined (__OS2__)
//extern void yy_reset(void);
//extern char yytext[];
//#else
extern char yytext[];
//#endif

void prterror();                     /* print line number and filename */ 

    /* variables used by the parser */
//RWCollectableString   *rulePtr;
WitSymTabEntry        *entryPtr;     /* ptr to current symbol table entry */
WitEntity::argVecDef  *argPtr;
WitVectorSpec         *vecPtr;       /* pointer to current vector format */
WitBoundSetSpec       *bndPtr;
WitParseRC            retcode;
WitEntity::eType      entityType;    /* type of the current entity */
WitAttribute::aType   attrType;      /* type of the current attribute */  
WitParser::PS         commandState;  /* current command state */
const char            *s1, *s2, *s3; /* temporary strings     */

const char * relnum[] = {"4.0", "5.0", "6.0", "7.0", "8.0"};
   //
   // Valid WIT release numbers
   // (i.e., valid values for the "release" specification)

#define   NRELS     (sizeof relnum / sizeof relnum[0])

const char * checkrel(char *);         /* check for a valid release number */   

%}

%union {
    int    intval;
    double doubleval;
    char * strval;
    bool   boolval;
    int    cval;
    int    pval;
    int    btype;
}

    /* literal keyword tokens */
%token RELEASE ADD SET READ PROBLEM
%token PART OPERATION BOM_ENTRY SUB_ENTRY BOP_ENTRY 
%token DEMAND PART_WITH_OPERATION
%token SINGLE SPARSE DENSE
%token END_BOUNDS HARDLB SOFTLB HARDUB
%token CAPACITY MATERIAL 

    /* tokens with values -- the values are returned by
       the lexer in yylval, which is a union */

%token <strval>    IDENTIFIER
%token <strval>    STRING
%token <doubleval> DOUBLE
%token <intval>    INTEGER
%token <boolval>   BOOLEAN
%token <cval>      CATEGORY
%token <strval>    EXEC_BOUNDS STOCK_BOUNDS CUM_SHIP_BOUNDS

    /* These are production names and corresponding types */
%type  <strval>   attribute_name  
%type  <strval>   bound_set_type
%type  <strval>   bound_set_attribute
%type  <cval>     category  
%type  <strval>   entity_name
%type  <pval>     simple_value
%type  <pval>     period_value
%type  <pval>     attribute_value
%type  <pval>     vector_value
%type  <pval>     argument
%type  <btype>    bound_type
%type  <btype>    bound_item
%type  <intval>   period

%%
    /* definition of grammar */

data_specification: release_specification command_list
    ;

command_list:  /* empty */    
    | command_list command
    ;

command: add_command
    {
      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    }
 
    | set_command
    { 
      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    } 
 
    | read_command
    {
      if (WitParser::instance ()->currentEntity_ != NULL)
        delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    }
    ;

release_specification: RELEASE
    { WitParser::instance ()->setParseState(WitParser::PS_release); }

    release_num
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
      free (yylval.strval);     
    }
    ;

release_num: STRING 
    { if (!checkrel(yylval.strval)) {    /* check table of valid releases */
         WitParser::instance ()->myMsgFac () ("invalidRelMsg", yylval.strval);

         int i;

         for (i = 0; i < NRELS; ++ i)
            WitParser::instance ()->myMsgFac () ("validRelSmsg", relnum[i]);

         prterror();
         WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }
    ;

add_command: ADD  
    { 
      WitParser::instance ()->setParseState(WitParser::PS_add);
      commandState = WitParser::PS_add;     /* save command state */
      WitParser::instance ()->currentRule_ = "add";
    }

    add_clause 
    {
      /* lookup rule for this entity and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule(
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* Issue error message if no entry found in symbol table */
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }

    entity_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
    ;

add_clause: entity_name
    {
      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval); 
      WitParser::instance ()->currentAttr_ = NULL;
    }

    | PART_WITH_OPERATION
    {
      WitParser::instance ()->setParseState(WitParser::PS_partOperation);
      WitParser::instance ()->currentRule_ = "add_partWithOperation";

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::partWithOperation);

      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;
      entityType = WitEntity::partWithOperation;
    }
    ;

set_command : SET PROBLEM
    {
      WitParser::instance ()->setParseState(WitParser::PS_setProblem);
      commandState = WitParser::PS_set;     /* save command state */

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::problem);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      WitParser::instance ()->currentRule_ = "set_problem";
    }
 
    global_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
   
    | SET 
    { 
      WitParser::instance ()->setParseState(WitParser::PS_set);
      commandState = WitParser::PS_set;     /* save command state */
      WitParser::instance ()->currentRule_ = "set";
    }
  
    set_clause entity_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
    ;

set_clause: entity_name
    {
      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      /* lookup rule for this entity and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule (
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* Issue error message if no entry found in symbol table */
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }
    ;

entity_name: PART
    {
      WitParser::instance ()->setParseState(WitParser::PS_part);
      WitParser::instance ()->currentRule_ += "_part";
      entityType = WitEntity::part;
    }

    | OPERATION
    {
      WitParser::instance ()->setParseState(WitParser::PS_operation);
      WitParser::instance ()->currentRule_ += "_operation";
      entityType = WitEntity::operation;
    }

    | BOM_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_bomEntry);
      WitParser::instance ()->currentRule_ += "_bomEntry";
      entityType = WitEntity::bomEntry;
    } 

    | SUB_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_subEntry);
      WitParser::instance ()->currentRule_ += "_subEntry";
      entityType = WitEntity::subEntry;
    }

    | BOP_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_bopEntry);
      WitParser::instance ()->currentRule_ += "_bopEntry";
      entityType = WitEntity::bopEntry;
    }

    | DEMAND
    {
      WitParser::instance ()->setParseState(WitParser::PS_demand);
      WitParser::instance ()->currentRule_ += "_demand";
      entityType = WitEntity::demand;
    }
    ; 

global_specification: attribute_list
    ;

entity_specification: argument_list
    {
      /*------------------------------------------------------*
       * we have created the entity object and the argument   *
       * vector; we also know the current rule; if there is   *
       * an entry for the rule, then invoke the function.     *
       *------------------------------------------------------*/

      if (entryPtr != NULL) {
        /* before invoking the function, check the validity of the arguments */
        /* by comparing the arg. types against the types in the symbol table */

        retcode = WitParser::instance ()->currentEntity_->checkArgs(entryPtr);
        if (retcode == BAD_NUM_ARGS) {
          if (entryPtr->nparms() == 1)
            s2 = "argument";
          else s2 = "arguments";
          if (WitParser::instance ()->currentEntity()->argc() == 1)
            s3 = "was found";
          else s3 = "were found";

          s1 = "";
          if (commandState == WitParser::PS_add)
            s1 = "add "; 
          if (commandState == WitParser::PS_set)
            s1 = "set ";

          WitParser::instance ()->myMsgFac () ("incorrectNumberArgMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2,
             WitParser::instance ()->currentEntity()->argc(),
             s3);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else
        if (retcode) {
          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }

        else                                    /* if arguments O.K.  */
        if (entryPtr->func() != NULL) {         /* if function exists */

          /* if entity has been invalidated because of an error,      */
          /* then, skip invocations of API functions for the entity   */
          if (!WitParser::instance ()->currentEntity_->invalid())
            (entryPtr->func())();               /* invoke function */
        }
      };  

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
    }

    attribute_list
    ;

category: CATEGORY
    { 
      if (WitParser::instance ()->parseState() == WitParser::PS_part)
      $$ = $1;
    }
    ; 

attribute_list:  /* empty */
    | attribute_list attribute
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextAttr);

      /* If an entry exists for the current rule, then invoke   */
      /* the function.                                          */

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      else
      {
        retcode = WitParser::instance ()->currentAttr_->checkArgs(entryPtr);
        if (retcode == PERIOD_ERROR) {
           WitParser::instance ()->currentAttr_->setInvalid(true);
           prterror();
        }            
        else
        if (retcode) {
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else 
        if (entryPtr->func() != NULL) {        /* if function exists  */

          /* if entity or attr has been invalidated because of error, */
          /* then, skip invocations of API function for attributes    */
          if (!WitParser::instance ()->currentEntity_->invalid() and
            !WitParser::instance ()->currentAttr_->invalid())
            retcode = (entryPtr->func())();    /* invoke wrapper function */
            if (retcode) {
              WitParser::instance ()->currentAttr_->setInvalid(true);
              prterror();
            }; 
        } 
      };                   

      WitParser::instance ()->currentRule_ =
         WitParser::instance ()->previousRule_;
    }  
    ;

argument_list: argument
    | argument_list argument
    ;

argument: simple_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      switch($1) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setDoubleArg(yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentEntity_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setStringArg(yylval.strval);

          /* string was created by the lexer and it's no longer needed */
          free (yylval.strval);
          break;
        default:
          return 0;
      };
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        /* if rule is not defined in symbol table, skip message now. */
        /* However, error message will be issued after all arguments */
        /* are processed.  We don't know the correct number of args. */

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    }

    | category
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      argPtr = WitParser::instance ()->currentEntity_->
        setCatArg (static_cast <WitDRPartCat::Tag> (yylval.cval));
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        /* If rule is not defined, skip message. See comment above */
        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
     }
    }
    ;

attribute: simple_attribute

    | bound_set_attribute
    ;

simple_attribute: attribute_name attribute_value
    ;

attribute_name: IDENTIFIER
    {
      WitParser::instance ()->setParseState(WitParser::PS_attr);
      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");

      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (WitParser::instance ()->myProblem (), yylval.strval);

      free (yylval.strval);

      /* lookup rule for this attribute and save symbol table pointer */
      /* this will be helpful to check the datatype of a vector       */
      entryPtr = WitParser::instance ()->currentAttr_->
        lookupRule(WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* if attribute name is not in the symbol table, we can't       */
      /* continue because we don't know the expected argument types   */
      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      $$ = $1;
    }
    ;

attribute_value: simple_value
    {
      switch($1) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setDoubleArg(
                yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentAttr_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentAttr_->setStringArg(yylval.strval);

          /* string was created by the lexer and it's no longer needed */
          free (yylval.strval);
          break;
        default:
          return 0;
      };

      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentAttr_->attrID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    }

    | vector_format
    { $$ = WitDRParmType::undefined; }
    ;

simple_value: STRING
    { $$ = WitDRParmType::string; }

    | INTEGER
    { $$ = WitDRParmType::intScalar; }

    | DOUBLE
    { $$ = WitDRParmType::doubleScalar; }

    | BOOLEAN
    { $$ = WitDRParmType::boolScalar; }
    ;

vector_format: SINGLE 
    {
      WitParser::instance ()->setParseState(WitParser::PS_single);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::single_,
                entryPtr->parmTypes()[0]);

          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else 
        vecPtr =
           new WitVectorSpec (
              WitParser::instance ()->myProblem (),
              WitVectorSpec::single_,
              WitDRParmType::doubleVector);
    }

    '('
    {
      WitParser::instance ()->setParseState(WitParser::PS_singleParen);
    }

    vector_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_singleValue);
    }

    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    | SPARSE 
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparse);

      /* Construct a VectorSpec object */
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::sparse_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::sparse_,
               WitDRParmType::doubleVector);
    }

    '(' 
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
    }

    sparse_list 
    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    | DENSE
    {
      WitParser::instance ()->setParseState(WitParser::PS_dense);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (WitParser::instance ()->myProblem (),
                WitVectorSpec::dense_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::dense_,
               WitDRParmType::doubleVector);
    }

    '(' 
    {
      WitParser::instance ()->setParseState(WitParser::PS_denseParen);
    }

    value_list 
    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }
    ;

sparse_list:   /* empty */
    | sparse_list period_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparseValue);
    }
    ;

period_value: period 
    ':'
    {
      WitParser::instance ()->setParseState(WitParser::PS_periodColon);
    }

    vector_value
    { 
      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
      $$ = $4; 
    }
    ;

value_list: vector_value
    | value_list vector_value
    ;

vector_value: simple_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_denseValue);

      if (entryPtr != NULL) {
      switch($1) {

        case WitDRParmType::intScalar:
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));

            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            retcode = vecPtr->addIntVal(yylval.intval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };
          
        case WitDRParmType::doubleScalar:
         if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            vecPtr->addIntVal(static_cast <int> (yylval.doubleval));
            retcode = SHOULD_BE_INT;
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };

        case WitDRParmType::boolScalar:
           {
           if (entryPtr->parmTypes()[0] == WitDRParmType::boolVector)
              {
              retcode = vecPtr->addBoolVal (yylval.boolval);

              break;
              };

           WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
              WitParser::instance ()->currentAttr_->attrID ());

           WitParser::instance ()->currentAttr_->setInvalid (true);

           prterror ();

           retcode = 0;

           WitParser::instance ()->myMsgFac () ("parsingStopsMsg");

           break;
           }

        case WitDRParmType::string:
          WitParser::instance ()->myMsgFac () ("stringVectorMsg",
             WitParser::instance ()->currentAttr_->attrID());
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          free (yylval.strval);
          retcode = 0;
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
          break;
      }

      if (retcode == WRONG_TYPE) {
        WitParser::instance ()->myMsgFac () ("vecTypeNotValidMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      if (retcode == SHOULD_BE_INT) {
        WitParser::instance ()->myMsgFac () ("vecValueNotIntMsg",
           WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      }
    }
    ;

period: INTEGER
    {
      WitParser::instance ()->setParseState(WitParser::PS_period);

      retcode = vecPtr->addPeriodVal(yylval.intval);
      if (retcode == PERIOD_ERROR) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
      if (retcode == PERIOD_DUP) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
    }
    ;

bound_set_attribute: bound_set_type 
    {  
      /* lookup rule for this attribute and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentAttr_->
         lookupRule (
            WitParser::instance ()->theSymTable_,
            WitParser::instance ()->currentRule_);

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }

    bounds_specification END_BOUNDS
    {
      bndPtr = NULL;
      WitParser::instance ()->setParseState(WitParser::PS_endBounds);
    }
    ;

bound_set_type: EXEC_BOUNDS
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::exec);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }

    | STOCK_BOUNDS
    { 
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::stock);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }

    | CUM_SHIP_BOUNDS
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::cumShip);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);
      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }
    ;

bounds_specification:   /* empty */
    | bounds_specification

    bound_item
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);
    }
    ;

bound_item: bound_type 
    {
      WitParser::instance ()->setParseState(WitParser::PS_boundType);
    }

    vector_format
    {
       switch ($1) {
         case WitBoundSetSpec::hardlb:
           bndPtr->setHardLBVec(vecPtr);
           break;

         case WitBoundSetSpec::softlb:
           bndPtr->setSoftLBVec(vecPtr);
           break;

         case WitBoundSetSpec::hardub:
           bndPtr->setHardUBVec(vecPtr);
           break;
       }
    }
    ;

bound_type: HARDLB
    {
      if (bndPtr->hardLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::hardlb;
    }

    | SOFTLB
    {
      if (bndPtr->softLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateSoftLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::softlb;
    }

    | HARDUB
    {
      if (bndPtr->hardUBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardUBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::hardub;
    }
    ;

read_command: READ 
    {
      WitParser::instance ()->setParseState(WitParser::PS_read);
      commandState = WitParser::PS_read;
      WitParser::instance ()->currentRule_ = "read";
      // printf("Current rule is: %s\n", WitParser::instance ()->currentRule_);
    }

    file_name 
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    ';'
    {
      /* save lexer state and shift input stream to new file */
      errno   = 0;
      retcode = WitParlex::saveFile(yylval.strval);
      if (retcode == FOPEN_ERROR) {
        yylval.strval[strlen(yylval.strval)-1] = '\0';
        WitParser::instance ()->myMsgFac () ("fopenSmsg",
           yylval.strval+1,
          "r",
          errno,
          strerror(errno));
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      if (retcode == STACK_OVERFLOW) {
        WitParser::instance ()->myMsgFac () ("stackOverflowMsg", STACKSIZE);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

//    printf("Lexer is now reading from file %s\n", WitParlex::fileName());

      WitParser::instance ()->setDataFileName   ();
      WitParser::instance ()->setDataFileLineNo ();

      //#if defined (__GNUC__)
      yyrestart(yyin);
      //#endif

      WitParser::instance ()->setParseState(WitParser::PS_initial);
      free (yylval.strval);
    }

    release_specification
    ;

file_name: STRING
    ;

%%

//------------------------------------------------------------------------------

WitParser * WitParser::instance_ = NULL;

//------------------------------------------------------------------------------

void WitParser::parse (WitProblem * theProblem, const char * fileName, FILE * f)
   {
   witAssert (instance_ == NULL);

   instance_ = new WitParser;

   instance ()->parseIt (theProblem, fileName, f);

   delete instance ();

   instance_ = NULL;
   }

//------------------------------------------------------------------------------

// accessors

WitParser::PS    WitParser::parseState() const
{ return parseState_; }

WitEntity     *WitParser::currentEntity() const
{ return currentEntity_; }

WitAttribute  *WitParser::currentAttr() const
{ return currentAttr_; }

WitMsgFacility & WitParser::myMsgFac () const
   {
   return myProblem ()->myMsgFac ();
   }

void WitParser::setParseState(PS st)
{ parseState_ = st; }


void prterror()
{
  WitParser::instance ()->myMsgFac () ("lineNumberMsg",
    reinterpret_cast <const char *> (yytext),
    WitParlex::lineno(), WitParlex::fileName());
}

//  check for a valid release number     
const char * checkrel(char *s)       /* s = char. string, in quotes */
{
  if (strlen(s) <= 2) return NULL;
  for (int i = 0; i < NRELS; i++)
    if (strncmp(s+1, relnum[i], strlen(s)-2) == 0)
      return relnum[i];
  return NULL;
}

//-----------------------------------------------------------------------------
// WitParser::prtSyntaxError
//
//     Implementation of syntax checker
//
//     Contains function to check the state of the parser and generate
//     a meaninful error message when a syntax error occurs.
//
// The parse states are defined in Parser.h:
//
//  PS_initial               // initial state, looking for "release"
//  PS_add                   // found "add", looking for <entity_name>
//  PS_set                   // found "set", looking for <entity_name>
//  PS_read                  // found "read", looking for <data_file>
//  PS_release               // found "release", looking for release_spec
//  PS_part                  // found "part", looking for <category>
//  PS_operation             // found "operation", looking for <arg>
//  PS_bomEntry              // found "bomEntry", looking for <arg>
//  PS_subEntry              // found "subEntry", looking for <arg>
//  PS_bopEntry              // found "bopEntry", looking for <arg>
//  PS_demand                // found "demand", looking for <arg>
//  PS_partOperation         // found "partWithOperation, looking for <arg>
//  PS_nextArg               // looking for another <arg> or a ";"
//  PS_attr                  // found <attr_name>, looking for <attr_value>
//  PS_single                // found "single", looking for "("
//  PS_dense                 // found "dense", looking for "("
//  PS_sparse                // found "sparse", looking for "("
//  PS_singleParen           // found "single (", looking for <vector_value>
//  PS_denseParen            // found "dense (", looking for <vector_value>
//  PS_sparseParen           // found "sparse (", looking for <period>
//  PS_singleValue           // found single value, looking for ")"
//  PS_denseValue            // found <value>, looking for <value> or ")"
//  PS_sparseValue           // found <period_val>, looking for <period> or ")"
//  PS_nextAttr              // looking for <attr_name> or ";"
//  PS_nextCommand           // found ";" and looking for <command>
//  PS_commandEnd            // looking for ";"
//  PS_period                // found <period>, looking for ":"
//  PS_periodColon	     // found ":", looking for <vector_value>
//  PS_nextBound             // found <bound_set_type>, looking for <bounds>
//  PS_boundType             // found <bound_type>, looking for <vector>
//  PS_endBounds             // found "endBounds", looking for ";" or next attr
//  PS_setProblem            // found "set problem", looking for
//                           //        <attribute name>
//-----------------------------------------------------------------------------

void WitParser::prtSyntaxError(WitSymTabEntry *pEntry,
                WitParser::PS parseState, const char * yytext) const
{
  const char * s1;

  // Print syntax error message, depending on current parser state
  switch (parseState) {
    case WitParser::PS_initial:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "\"release\"", yytext);
      break;
    case WitParser::PS_commandEnd:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg", "a \";\"", yytext);
      break;
    case WitParser::PS_nextCommand:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
      "a command name (e.g., set, add, read)", yytext);
      break;
    case WitParser::PS_add:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an addable object type after \"add\"", yytext);
      break;
    case WitParser::PS_set:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of a settable object type after \"set\"", yytext);
      break;
    case WitParser::PS_setProblem:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute after \"set problem\"", yytext);
      break;
    case WitParser::PS_read:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a string (the name of a file) after \"read\"", yytext);
      break;
    case WitParser::PS_release:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a quoted string (the release number) after \"release\"", yytext);
      break;
    case WitParser::PS_part:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "part", yytext);
      break;
    case WitParser::PS_operation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "operation", yytext);
      break;
    case WitParser::PS_bomEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bomEntry", yytext);
      break;
    case WitParser::PS_subEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "subEntry", yytext);
      break;
    case WitParser::PS_bopEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bopEntry", yytext);
      break;
    case WitParser::PS_demand:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "demand", yytext);
      break;
    case WitParser::PS_partOperation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "partWithOperation", yytext);
      break;
    case WitParser::PS_nextArg:

      // Check to see if we have the correct number of argumenta.
      // If so, we are looking for an attribute or a semicolon
      if (WitParser::instance ()->currentEntity()->argc() >= pEntry->nparms()) {
        WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
          "the name of an attribute or a \";\"", yytext);
        break;
      };

      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "another argument",
         yytext);
      break;
    case WitParser::PS_attr:
      switch (pEntry->parmTypes()[0]) {   // what the value should be
        case WitDRParmType::intScalar:
          s1 = "integer";	
          break;
        case WitDRParmType::doubleScalar:
          s1 = "double";
          break;
        case WitDRParmType::string:
          s1 = "string";
          break;
        case WitDRParmType::boolScalar:
          s1 = "boolean";
          break;
        case WitDRParmType::partCat:
          s1 = "\"category\"";
          break;
        case WitDRParmType::boolVector:
          s1 = "\"boolean vector\"";
          break;
        case WitDRParmType::intVector:
          s1 = "\"integer vector\"";
          break;
        case WitDRParmType::doubleVector:
          s1 = "\"double vector\"";
          break;
        case WitDRParmType::boundSet:
          s1 = "\"bound set\"";
          break;
        default:
          s1 = "unknown";
          break;
      };
      WitParser::instance ()->myMsgFac () ("attrValueNotFound",
        s1, WitParser::instance ()->currentAttr()->attrID(), yytext);
      break;
    case WitParser::PS_nextAttr:
    case WitParser::PS_endBounds:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute or a \";\"", yytext);
      break;
    case WitParser::PS_nextBound:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a bound set attribute (e.g., softLB, hardLB, hardUB)"
        " or \"endBounds\"", yytext);
      break;
    case WitParser::PS_boundType:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector format (e.g, single, dense, sparse)", yytext);
      break;
    case WitParser::PS_single:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"single\"", yytext);
      break;
    case WitParser::PS_dense:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"dense\"", yytext);
      break;
    case WitParser::PS_sparse:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"sparse\"", yytext);
      break;
    case WitParser::PS_singleParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector element for a \"single\" vector specification",
        yytext);
      break;
    case WitParser::PS_denseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector element for a \"dense\" vector specification",
        yytext);
      break;
    case WitParser::PS_sparseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_singleValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \")\" after the one vector value in a \"single\" vector "
        "specification", yytext);
      break;
    case WitParser::PS_denseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value or a \")\"", yytext);
      break;
    case WitParser::PS_sparseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) or a \")\"", yytext);
      break;
    case WitParser::PS_period:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \":\" in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_periodColon:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value (a number) after the \":\"", yytext);
      break;
  }
}

//------------------------------------------------------------------------------

void WitParser::setDataFileName () const
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileName (fileName ());
   }

//------------------------------------------------------------------------------

void WitParser::setDataFileLineNo () const
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileLineNo (lineno ());
   }

//-----------------------------------------------------------------------------

// Constructor and destructor

WitParser::WitParser ():
      theSymTable_   (NULL),
      currentRule_   (),
      previousRule_  (),
      currentEntity_ (NULL),
      currentAttr_   (NULL),
      parseState_    (PS_initial),
      myProblem_     (NULL)
   {
   commandState = PS_initial;
   }

WitParser::~WitParser ()
   {
   }

//------------------------------------------------------------------------------

// Parse the input stream
int WitParser::parseIt(WitProblem * theProblem, const char* fileName, FILE* f)
{
  int   rc;

  WitParlex::setFileName (fileName);   // save current file name
  yyin = f;                            // save pointer to FILE

  myProblem_   = theProblem;
  theSymTable_ = new WitSymTable (theProblem->myWitRun ());
  rc           = theSymTable_->registerRules ();

  if (rc)
     return rc;

  //#if defined (WIN32) or defined (__OS2__)

  //  yy_reset();

  //#endif

  rc = yyparse();

  if (rc)
  {
    WitParser::instance ()->prtSyntaxError(entryPtr,
       WitParser::instance ()->parseState(),
      reinterpret_cast <const char *> (yytext));
    WitParser::instance ()->myMsgFac () ("lineNumberMsg",
      reinterpret_cast <const char *> (yytext),
      WitParlex::lineno(), WitParlex::fileName());
    WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
  }

  delete theSymTable_;
  return rc;
}
@


1.44
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d2 14
a17 9
 *     (c) Copyright IBM Corp. 2006.
 *     (Unpublished)
 *     OCO Source Modules
 *     IBM Confidential
 *
 *------------------------------------------------------------------------------

 *------------------------------------------------------------------------------
 *
@


1.43
log
@Revised the release # to 8.0.
@
text
@d3 37
a39 37
*
*     (c) Copyright IBM Corp. 2011.
*     (Unpublished)
*     OCO Source Modules
*     IBM Confidential
*
*------------------------------------------------------------------------------

*------------------------------------------------------------------------------
*
*     Source file:    witParse.y
*
*     Parser for WIT 4.0 Input Data File Format
*
*     To create an executable parser file:
*
*           yacc -d  witParse.y             (creates y.tab.c and y.tab.h)
*           mv -f y.tab.c witParse.C
*           mv -f y.tab.h ytab.h
*           lex  witLexer.l                 (creates lex.yy.c)
*           mv -f lex.yy.c witLexer.C
*           xlC witLexer.C witParse.C -o witParse -ly -ll
*
*           Notes:
*
*              -d   causes y.tab.h to be created.  This is the token
*                   name definition file.
*
*              -ly  causes the yacc library to be included. This
*                   library is in /usr/lib/liby.a
*
*              -ll  causes the lex library to be included. This
*                   library is in /usr/lib/libl.a
*
*------------------------------------------------------------------------------
*
*/
d69 1
a69 1
void prterror();                     /* print line number and filename */
d71 1
a71 1
/* variables used by the parser */
d79 1
a79 1
WitAttribute::aType   attrType;      /* type of the current attribute */
d84 3
a86 3
//
// Valid WIT release numbers
// (i.e., valid values for the "release" specification)
d90 1
a90 1
const char * checkrel(char *);         /* check for a valid release number */
d95 7
a101 7
int    intval;
double doubleval;
char * strval;
bool   boolval;
int    cval;
int    pval;
int    btype;
d104 1
a104 1
/* literal keyword tokens */
d106 1
a106 1
%token PART OPERATION BOM_ENTRY SUB_ENTRY BOP_ENTRY
d110 1
a110 1
%token CAPACITY MATERIAL
d112 2
a113 2
/* tokens with values -- the values are returned by
the lexer in yylval, which is a union */
d123 2
a124 2
/* These are production names and corresponding types */
%type  <strval>   attribute_name
d127 1
a127 1
%type  <cval>     category
d139 1
a139 1
/* definition of grammar */
d142 1
a142 1
;
d144 3
a146 3
command_list:  /* empty */
| command_list command
;
d149 27
a175 27
{
delete WitParser::instance ()->currentEntity_;
WitParser::instance ()->currentEntity_ = NULL;
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ = NULL;
}

| set_command
{
delete WitParser::instance ()->currentEntity_;
WitParser::instance ()->currentEntity_ = NULL;
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ = NULL;
}

| read_command
{
if (WitParser::instance ()->currentEntity_ != NULL)
delete WitParser::instance ()->currentEntity_;
WitParser::instance ()->currentEntity_ = NULL;
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ = NULL;
}
;
d178 1
a178 17
{ WitParser::instance ()->setParseState(WitParser::PS_release); }

release_num
{
WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
}

';'
{
WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
free (yylval.strval);
}
;

release_num: STRING
{ if (!checkrel(yylval.strval)) {    /* check table of valid releases */
WitParser::instance ()->myMsgFac () ("invalidRelMsg", yylval.strval);
d180 65
a244 49
int i;

for (i = 0; i < NRELS; ++ i)
WitParser::instance ()->myMsgFac () ("validRelSmsg", relnum[i]);

prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
;

add_command: ADD
{
WitParser::instance ()->setParseState(WitParser::PS_add);
commandState = WitParser::PS_add;     /* save command state */
WitParser::instance ()->currentRule_ = "add";
}

add_clause
{
/* lookup rule for this entity and save symbol table pointer */
entryPtr = WitParser::instance ()->currentEntity_->
lookupRule(
WitParser::instance ()->theSymTable_,
WitParser::instance ()->currentRule_);

/* Issue error message if no entry found in symbol table */
if (entryPtr == NULL) {
switch (commandState) {
case WitParser::PS_add:
WitParser::instance ()->myMsgFac () ("noParamAddMsg",
WitParser::instance ()->currentEntity_->entityID());
break;
case WitParser::PS_set:
WitParser::instance ()->myMsgFac () ("noParamSetMsg",
WitParser::instance ()->currentEntity_->entityID());
break;
};
WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}

entity_specification ';'
{
WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
}
;
d247 28
a274 28
{
// create a WitEntity object
WitParser::instance ()->currentEntity_ =
new WitEntity (
WitParser::instance ()->myProblem (),
yylval.strval,
entityType);
free (yylval.strval);
WitParser::instance ()->currentAttr_ = NULL;
}

| PART_WITH_OPERATION
{
WitParser::instance ()->setParseState(WitParser::PS_partOperation);
WitParser::instance ()->currentRule_ = "add_partWithOperation";

// create a WitEntity object
WitParser::instance ()->currentEntity_ =
new WitEntity (
WitParser::instance ()->myProblem (),
yylval.strval,
WitEntity::partWithOperation);

free (yylval.strval);
WitParser::instance ()->currentAttr_ = NULL;
entityType = WitEntity::partWithOperation;
}
;
d277 33
a309 33
{
WitParser::instance ()->setParseState(WitParser::PS_setProblem);
commandState = WitParser::PS_set;     /* save command state */

// create a WitEntity object
WitParser::instance ()->currentEntity_ =
new WitEntity (
WitParser::instance ()->myProblem (),
yylval.strval,
WitEntity::problem);
free (yylval.strval);
WitParser::instance ()->currentAttr_ = NULL;

WitParser::instance ()->currentRule_ = "set_problem";
}

global_specification ';'
{
WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
}

| SET
{
WitParser::instance ()->setParseState(WitParser::PS_set);
commandState = WitParser::PS_set;     /* save command state */
WitParser::instance ()->currentRule_ = "set";
}

set_clause entity_specification ';'
{
WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
}
;
d312 34
a345 34
{
// create a WitEntity object
WitParser::instance ()->currentEntity_ =
new WitEntity (
WitParser::instance ()->myProblem (),
yylval.strval,
entityType);
free (yylval.strval);
WitParser::instance ()->currentAttr_ = NULL;

/* lookup rule for this entity and save symbol table pointer */
entryPtr = WitParser::instance ()->currentEntity_->
lookupRule (
WitParser::instance ()->theSymTable_,
WitParser::instance ()->currentRule_);

/* Issue error message if no entry found in symbol table */
if (entryPtr == NULL) {
switch (commandState) {
case WitParser::PS_add:
WitParser::instance ()->myMsgFac () ("noParamAddMsg",
WitParser::instance ()->currentEntity_->entityID());
break;
case WitParser::PS_set:
WitParser::instance ()->myMsgFac () ("noParamSetMsg",
WitParser::instance ()->currentEntity_->entityID());
break;
};
WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
;
d348 41
a388 41
{
WitParser::instance ()->setParseState(WitParser::PS_part);
WitParser::instance ()->currentRule_ += "_part";
entityType = WitEntity::part;
}

| OPERATION
{
WitParser::instance ()->setParseState(WitParser::PS_operation);
WitParser::instance ()->currentRule_ += "_operation";
entityType = WitEntity::operation;
}

| BOM_ENTRY
{
WitParser::instance ()->setParseState(WitParser::PS_bomEntry);
WitParser::instance ()->currentRule_ += "_bomEntry";
entityType = WitEntity::bomEntry;
}

| SUB_ENTRY
{
WitParser::instance ()->setParseState(WitParser::PS_subEntry);
WitParser::instance ()->currentRule_ += "_subEntry";
entityType = WitEntity::subEntry;
}

| BOP_ENTRY
{
WitParser::instance ()->setParseState(WitParser::PS_bopEntry);
WitParser::instance ()->currentRule_ += "_bopEntry";
entityType = WitEntity::bopEntry;
}

| DEMAND
{
WitParser::instance ()->setParseState(WitParser::PS_demand);
WitParser::instance ()->currentRule_ += "_demand";
entityType = WitEntity::demand;
}
;
d391 1
a391 1
;
d394 58
a451 44
{
/*------------------------------------------------------*
* we have created the entity object and the argument   *
* vector; we also know the current rule; if there is   *
* an entry for the rule, then invoke the function.     *
*------------------------------------------------------*/

if (entryPtr != NULL) {
/* before invoking the function, check the validity of the arguments */
/* by comparing the arg. types against the types in the symbol table */

retcode = WitParser::instance ()->currentEntity_->checkArgs(entryPtr);
if (retcode == BAD_NUM_ARGS) {
if (entryPtr->nparms() == 1)
s2 = "argument";
else s2 = "arguments";
if (WitParser::instance ()->currentEntity()->argc() == 1)
s3 = "was found";
else s3 = "were found";

s1 = "";
if (commandState == WitParser::PS_add)
s1 = "add ";
if (commandState == WitParser::PS_set)
s1 = "set ";

WitParser::instance ()->myMsgFac () ("incorrectNumberArgMsg",
s1,
WitParser::instance ()->currentEntity_->entityID(),
entryPtr->nparms(),
s2,
WitParser::instance ()->currentEntity()->argc(),
s3);

WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
else
if (retcode) {
WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
d453 2
a454 16
else                                    /* if arguments O.K.  */
if (entryPtr->func() != NULL) {         /* if function exists */

/* if entity has been invalidated because of an error,      */
/* then, skip invocations of API functions for the entity   */
if (!WitParser::instance ()->currentEntity_->invalid())
(entryPtr->func())();               /* invoke function */
}
};

WitParser::instance ()->previousRule_ =
WitParser::instance ()->currentRule_.replace(0, 3, "set");
}

attribute_list
;
d457 5
a461 5
{
if (WitParser::instance ()->parseState() == WitParser::PS_part)
$$ = $1;
}
;
d464 47
a510 47
| attribute_list attribute
{
WitParser::instance ()->setParseState(WitParser::PS_nextAttr);

/* If an entry exists for the current rule, then invoke   */
/* the function.                                          */

if (entryPtr == NULL) {
WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
WitParser::instance ()->currentAttr_->attrID(),
WitParser::instance ()->currentEntity_->entityID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
else
{
retcode = WitParser::instance ()->currentAttr_->checkArgs(entryPtr);
if (retcode == PERIOD_ERROR) {
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
}
else
if (retcode) {
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
else
if (entryPtr->func() != NULL) {        /* if function exists  */

/* if entity or attr has been invalidated because of error, */
/* then, skip invocations of API function for attributes    */
if (!WitParser::instance ()->currentEntity_->invalid() and
!WitParser::instance ()->currentAttr_->invalid())
retcode = (entryPtr->func())();    /* invoke wrapper function */
if (retcode) {
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
};
}
};

WitParser::instance ()->currentRule_ =
WitParser::instance ()->previousRule_;
}
;
d513 2
a514 2
| argument_list argument
;
d517 87
a603 87
{
WitParser::instance ()->setParseState(WitParser::PS_nextArg);
switch($1) {
case WitDRParmType::intScalar:
argPtr =
WitParser::instance ()->currentEntity_->setIntArg(yylval.intval);
break;
case WitDRParmType::doubleScalar:
argPtr =
WitParser::instance ()->currentEntity_->
setDoubleArg(yylval.doubleval);
break;
case WitDRParmType::boolScalar:
argPtr = WitParser::instance ()->currentEntity_->
setBoolArg(yylval.boolval);
break;
case WitDRParmType::string:
argPtr =
WitParser::instance ()->currentEntity_->
setStringArg(yylval.strval);

/* string was created by the lexer and it's no longer needed */
free (yylval.strval);
break;
default:
return 0;
};
if (argPtr == NULL) {
s1 = "";
if (commandState == WitParser::PS_add)
s1 = "add ";
if (commandState == WitParser::PS_set)
s1 = "set ";

/* if rule is not defined in symbol table, skip message now. */
/* However, error message will be issued after all arguments */
/* are processed.  We don't know the correct number of args. */

if (entryPtr != NULL) {
if (entryPtr->nparms() == 1)
s2 = "argument is";
else s2 = "arguments are";

WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
s1,
WitParser::instance ()->currentEntity_->entityID(),
entryPtr->nparms(),
s2);

WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
}

| category
{
WitParser::instance ()->setParseState(WitParser::PS_nextArg);
argPtr = WitParser::instance ()->currentEntity_->
setCatArg (static_cast <WitDRPartCat::Tag> (yylval.cval));
if (argPtr == NULL) {
s1 = "";
if (commandState == WitParser::PS_add)
s1 = "add ";
if (commandState == WitParser::PS_set)
s1 = "set ";

/* If rule is not defined, skip message. See comment above */
if (entryPtr != NULL) {
if (entryPtr->nparms() == 1)
s2 = "argument is";
else s2 = "arguments are";

WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
s1,
WitParser::instance ()->currentEntity_->entityID(),
entryPtr->nparms(),
s2);

WitParser::instance ()->currentEntity_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
}
;
d607 2
a608 2
| bound_set_attribute
;
d611 1
a611 1
;
d614 36
a649 36
{
WitParser::instance ()->setParseState(WitParser::PS_attr);
WitParser::instance ()->previousRule_ =
WitParser::instance ()->currentRule_.replace(0, 3, "set");

WitParser::instance ()->currentRule_ += "_";
WitParser::instance ()->currentRule_ += yylval.strval;

/* create a new WitAttribute object */
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ =
new WitAttribute (WitParser::instance ()->myProblem (), yylval.strval);

free (yylval.strval);

/* lookup rule for this attribute and save symbol table pointer */
/* this will be helpful to check the datatype of a vector       */
entryPtr = WitParser::instance ()->currentAttr_->
lookupRule(WitParser::instance ()->theSymTable_,
WitParser::instance ()->currentRule_);

/* if attribute name is not in the symbol table, we can't       */
/* continue because we don't know the expected argument types   */
if (entryPtr == NULL) {
WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
WitParser::instance ()->currentAttr_->attrID(),
WitParser::instance ()->currentEntity_->entityID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}

$$ = $1;
}
;
d652 54
a705 54
{
switch($1) {
case WitDRParmType::intScalar:
argPtr =
WitParser::instance ()->currentAttr_->setIntArg(yylval.intval);
break;
case WitDRParmType::doubleScalar:
argPtr =
WitParser::instance ()->currentAttr_->setDoubleArg(
yylval.doubleval);
break;
case WitDRParmType::boolScalar:
argPtr = WitParser::instance ()->currentAttr_->
setBoolArg(yylval.boolval);
break;
case WitDRParmType::string:
argPtr =
WitParser::instance ()->currentAttr_->setStringArg(yylval.strval);

/* string was created by the lexer and it's no longer needed */
free (yylval.strval);
break;
default:
return 0;
};

if (argPtr == NULL) {
s1 = "";
if (commandState == WitParser::PS_add)
s1 = "add ";
if (commandState == WitParser::PS_set)
s1 = "set ";

if (entryPtr != NULL) {
if (entryPtr->nparms() == 1)
s2 = "argument is";
else s2 = "arguments are";

WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
s1,
WitParser::instance ()->currentAttr_->attrID(),
entryPtr->nparms(),
s2);

WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
}

| vector_format
{ $$ = WitDRParmType::undefined; }
;
d708 1
a708 1
{ $$ = WitDRParmType::string; }
d710 2
a711 2
| INTEGER
{ $$ = WitDRParmType::intScalar; }
d713 2
a714 2
| DOUBLE
{ $$ = WitDRParmType::doubleScalar; }
d716 113
a828 113
| BOOLEAN
{ $$ = WitDRParmType::boolScalar; }
;

vector_format: SINGLE
{
WitParser::instance ()->setParseState(WitParser::PS_single);

// Construct a VectorSpec object
if (WitParser::instance ()->currentAttr_->attrType() ==
WitAttribute::simple) {
if (entryPtr != NULL) {
vecPtr =
new WitVectorSpec (
WitParser::instance ()->myProblem (),
WitVectorSpec::single_,
entryPtr->parmTypes()[0]);

argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
}
}
else
vecPtr =
new WitVectorSpec (
WitParser::instance ()->myProblem (),
WitVectorSpec::single_,
WitDRParmType::doubleVector);
}

'('
{
WitParser::instance ()->setParseState(WitParser::PS_singleParen);
}

vector_value
{
WitParser::instance ()->setParseState(WitParser::PS_singleValue);
}

')'
{
WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
}

| SPARSE
{
WitParser::instance ()->setParseState(WitParser::PS_sparse);

/* Construct a VectorSpec object */
if (WitParser::instance ()->currentAttr_->attrType() ==
WitAttribute::simple) {
if (entryPtr != NULL) {
vecPtr =
new WitVectorSpec (
WitParser::instance ()->myProblem (),
WitVectorSpec::sparse_,
entryPtr->parmTypes()[0]);
argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
}
}
else
vecPtr =
new WitVectorSpec (
WitParser::instance ()->myProblem (),
WitVectorSpec::sparse_,
WitDRParmType::doubleVector);
}

'('
{
WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
}

sparse_list
')'
{
WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
}

| DENSE
{
WitParser::instance ()->setParseState(WitParser::PS_dense);

// Construct a VectorSpec object
if (WitParser::instance ()->currentAttr_->attrType() ==
WitAttribute::simple) {
if (entryPtr != NULL) {
vecPtr =
new WitVectorSpec (WitParser::instance ()->myProblem (),
WitVectorSpec::dense_,
entryPtr->parmTypes()[0]);
argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
}
}
else
vecPtr =
new WitVectorSpec (
WitParser::instance ()->myProblem (),
WitVectorSpec::dense_,
WitDRParmType::doubleVector);
}

'('
{
WitParser::instance ()->setParseState(WitParser::PS_denseParen);
}

value_list
')'
{
WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
}
;
d831 18
a848 18
| sparse_list period_value
{
WitParser::instance ()->setParseState(WitParser::PS_sparseValue);
}
;

period_value: period
':'
{
WitParser::instance ()->setParseState(WitParser::PS_periodColon);
}

vector_value
{
WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
$$ = $4;
}
;
d851 2
a852 2
| value_list vector_value
;
d855 2
a856 2
{
WitParser::instance ()->setParseState(WitParser::PS_denseValue);
d858 2
a859 2
if (entryPtr != NULL) {
switch($1) {
d861 93
a953 93
case WitDRParmType::intScalar:
if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
retcode =
vecPtr->addDoubleVal(static_cast <double> (yylval.intval));

break;
};
if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
retcode = vecPtr->addIntVal(yylval.intval);
break;
};
if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
retcode =
vecPtr->addDoubleVal(static_cast <double> (yylval.intval));
break;
}
else {
retcode = WRONG_TYPE;
break;
};

case WitDRParmType::doubleScalar:
if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
vecPtr->addIntVal(static_cast <int> (yylval.doubleval));
retcode = SHOULD_BE_INT;
break;
};
if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
retcode = vecPtr->addDoubleVal(yylval.doubleval);
break;
};
if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
retcode = vecPtr->addDoubleVal(yylval.doubleval);
break;
}
else {
retcode = WRONG_TYPE;
break;
};

case WitDRParmType::boolScalar:
{
if (entryPtr->parmTypes()[0] == WitDRParmType::boolVector)
{
retcode = vecPtr->addBoolVal (yylval.boolval);

break;
};

WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
WitParser::instance ()->currentAttr_->attrID ());

WitParser::instance ()->currentAttr_->setInvalid (true);

prterror ();

retcode = 0;

WitParser::instance ()->myMsgFac () ("parsingStopsMsg");

break;
}

case WitDRParmType::string:
WitParser::instance ()->myMsgFac () ("stringVectorMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
free (yylval.strval);
retcode = 0;
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
break;
}

if (retcode == WRONG_TYPE) {
WitParser::instance ()->myMsgFac () ("vecTypeNotValidMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
retcode = 0;
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
if (retcode == SHOULD_BE_INT) {
WitParser::instance ()->myMsgFac () ("vecValueNotIntMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
retcode = 0;
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}
}
;
d956 2
a957 2
{
WitParser::instance ()->setParseState(WitParser::PS_period);
d959 36
a994 36
retcode = vecPtr->addPeriodVal(yylval.intval);
if (retcode == PERIOD_ERROR) {
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
}
if (retcode == PERIOD_DUP) {
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
}
}
;

bound_set_attribute: bound_set_type
{
/* lookup rule for this attribute and save symbol table pointer */
entryPtr = WitParser::instance ()->currentAttr_->
lookupRule (
WitParser::instance ()->theSymTable_,
WitParser::instance ()->currentRule_);

if (entryPtr == NULL) {
WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
WitParser::instance ()->currentAttr_->attrID(),
WitParser::instance ()->currentEntity_->entityID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
}

bounds_specification END_BOUNDS
{
bndPtr = NULL;
WitParser::instance ()->setParseState(WitParser::PS_endBounds);
}
;
d997 2
a998 5
{
WitParser::instance ()->setParseState(WitParser::PS_nextBound);

// Construct a BoundSetSpec object
bndPtr = new WitBoundSetSpec(WitBoundSetSpec::exec);
d1000 2
a1001 13
WitParser::instance ()->previousRule_ =
WitParser::instance ()->currentRule_.replace(0, 3, "set");
WitParser::instance ()->currentRule_ += "_";
WitParser::instance ()->currentRule_ += yylval.strval;

/* create a new WitAttribute object */
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ =
new WitAttribute (
WitParser::instance ()->myProblem (),
yylval.strval,
WitAttribute::boundSet);
d1003 73
a1075 59
argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

free (yylval.strval);
$$ = $1;
}

| STOCK_BOUNDS
{
WitParser::instance ()->setParseState(WitParser::PS_nextBound);

// Construct a BoundSetSpec object
bndPtr = new WitBoundSetSpec(WitBoundSetSpec::stock);

WitParser::instance ()->previousRule_ =
WitParser::instance ()->currentRule_.replace(0, 3, "set");
WitParser::instance ()->currentRule_ += "_";
WitParser::instance ()->currentRule_ += yylval.strval;

/* create a new WitAttribute object */
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ =
new WitAttribute (
WitParser::instance ()->myProblem (),
yylval.strval,
WitAttribute::boundSet);

argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

free (yylval.strval);
$$ = $1;
}

| CUM_SHIP_BOUNDS
{
WitParser::instance ()->setParseState(WitParser::PS_nextBound);

// Construct a BoundSetSpec object
bndPtr = new WitBoundSetSpec(WitBoundSetSpec::cumShip);

WitParser::instance ()->previousRule_ =
WitParser::instance ()->currentRule_.replace(0, 3, "set");
WitParser::instance ()->currentRule_ += "_";
WitParser::instance ()->currentRule_ += yylval.strval;

/* create a new WitAttribute object */
if (WitParser::instance ()->currentAttr_ != NULL)
delete WitParser::instance ()->currentAttr_;
WitParser::instance ()->currentAttr_ =
new WitAttribute (
WitParser::instance ()->myProblem (),
yylval.strval,
WitAttribute::boundSet);
argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

free (yylval.strval);
$$ = $1;
}
;
d1078 1
a1078 12
| bounds_specification

bound_item
{
WitParser::instance ()->setParseState(WitParser::PS_nextBound);
}
;

bound_item: bound_type
{
WitParser::instance ()->setParseState(WitParser::PS_boundType);
}
d1080 28
a1107 17
vector_format
{
switch ($1) {
case WitBoundSetSpec::hardlb:
bndPtr->setHardLBVec(vecPtr);
break;

case WitBoundSetSpec::softlb:
bndPtr->setSoftLBVec(vecPtr);
break;

case WitBoundSetSpec::hardub:
bndPtr->setHardUBVec(vecPtr);
break;
}
}
;
d1110 67
a1176 67
{
if (bndPtr->hardLBVec() != NULL) {
WitParser::instance ()->myMsgFac () ("duplicateHardLBMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
};
$$ = WitBoundSetSpec::hardlb;
}

| SOFTLB
{
if (bndPtr->softLBVec() != NULL) {
WitParser::instance ()->myMsgFac () ("duplicateSoftLBMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
};
$$ = WitBoundSetSpec::softlb;
}

| HARDUB
{
if (bndPtr->hardUBVec() != NULL) {
WitParser::instance ()->myMsgFac () ("duplicateHardUBMsg",
WitParser::instance ()->currentAttr_->attrID());
WitParser::instance ()->currentAttr_->setInvalid(true);
prterror();
};
$$ = WitBoundSetSpec::hardub;
}
;

read_command: READ
{
WitParser::instance ()->setParseState(WitParser::PS_read);
commandState = WitParser::PS_read;
WitParser::instance ()->currentRule_ = "read";
// printf("Current rule is: %s\n", WitParser::instance ()->currentRule_);
}

file_name
{
WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
}

';'
{
/* save lexer state and shift input stream to new file */
errno   = 0;
retcode = WitParlex::saveFile(yylval.strval);
if (retcode == FOPEN_ERROR) {
yylval.strval[strlen(yylval.strval)-1] = '\0';
WitParser::instance ()->myMsgFac () ("fopenSmsg",
yylval.strval+1,
"r",
errno,
strerror(errno));
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}

if (retcode == STACK_OVERFLOW) {
WitParser::instance ()->myMsgFac () ("stackOverflowMsg", STACKSIZE);
prterror();
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
d1180 2
a1181 6
WitParser::instance ()->setDataFileName   ();
WitParser::instance ()->setDataFileLineNo ();

//#if defined (__GNUC__)
yyrestart(yyin);
//#endif
d1183 7
a1189 3
WitParser::instance ()->setParseState(WitParser::PS_initial);
free (yylval.strval);
}
d1191 2
a1192 2
release_specification
;
d1195 1
a1195 1
;
d1206 2
a1207 2
{
witAssert (instance_ == NULL);
d1209 1
a1209 1
instance_ = new WitParser;
d1211 1
a1211 1
instance ()->parseIt (theProblem, fileName, f);
d1213 1
a1213 1
delete instance ();
d1215 2
a1216 2
instance_ = NULL;
}
d1232 3
a1234 3
{
return myProblem ()->myMsgFac ();
}
d1242 3
a1244 3
WitParser::instance ()->myMsgFac () ("lineNumberMsg",
reinterpret_cast <const char *> (yytext),
WitParlex::lineno(), WitParlex::fileName());
d1247 1
a1247 1
//  check for a valid release number
d1250 5
a1254 5
if (strlen(s) <= 2) return NULL;
for (int i = 0; i < NRELS; i++)
if (strncmp(s+1, relnum[i], strlen(s)-2) == 0)
return relnum[i];
return NULL;
d1303 1
a1303 1
WitParser::PS parseState, const char * yytext) const
d1305 1
a1305 1
const char * s1;
d1307 201
a1507 201
// Print syntax error message, depending on current parser state
switch (parseState) {
case WitParser::PS_initial:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"\"release\"", yytext);
break;
case WitParser::PS_commandEnd:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg", "a \";\"", yytext);
break;
case WitParser::PS_nextCommand:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a command name (e.g., set, add, read)", yytext);
break;
case WitParser::PS_add:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"the name of an addable object type after \"add\"", yytext);
break;
case WitParser::PS_set:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"the name of a settable object type after \"set\"", yytext);
break;
case WitParser::PS_setProblem:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"the name of an attribute after \"set problem\"", yytext);
break;
case WitParser::PS_read:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a string (the name of a file) after \"read\"", yytext);
break;
case WitParser::PS_release:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a quoted string (the release number) after \"release\"", yytext);
break;
case WitParser::PS_part:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"part", yytext);
break;
case WitParser::PS_operation:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"operation", yytext);
break;
case WitParser::PS_bomEntry:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"bomEntry", yytext);
break;
case WitParser::PS_subEntry:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"subEntry", yytext);
break;
case WitParser::PS_bopEntry:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"bopEntry", yytext);
break;
case WitParser::PS_demand:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"demand", yytext);
break;
case WitParser::PS_partOperation:
if (pEntry->nparms() == 1)
s1 = "argument";
else
s1 = "arguments";
WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
"partWithOperation", yytext);
break;
case WitParser::PS_nextArg:

// Check to see if we have the correct number of argumenta.
// If so, we are looking for an attribute or a semicolon
if (WitParser::instance ()->currentEntity()->argc() >= pEntry->nparms()) {
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"the name of an attribute or a \";\"", yytext);
break;
};

WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"another argument",
yytext);
break;
case WitParser::PS_attr:
switch (pEntry->parmTypes()[0]) {   // what the value should be
case WitDRParmType::intScalar:
s1 = "integer";
break;
case WitDRParmType::doubleScalar:
s1 = "double";
break;
case WitDRParmType::string:
s1 = "string";
break;
case WitDRParmType::boolScalar:
s1 = "boolean";
break;
case WitDRParmType::partCat:
s1 = "\"category\"";
break;
case WitDRParmType::boolVector:
s1 = "\"boolean vector\"";
break;
case WitDRParmType::intVector:
s1 = "\"integer vector\"";
break;
case WitDRParmType::doubleVector:
s1 = "\"double vector\"";
break;
case WitDRParmType::boundSet:
s1 = "\"bound set\"";
break;
default:
s1 = "unknown";
break;
};
WitParser::instance ()->myMsgFac () ("attrValueNotFound",
s1, WitParser::instance ()->currentAttr()->attrID(), yytext);
break;
case WitParser::PS_nextAttr:
case WitParser::PS_endBounds:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"the name of an attribute or a \";\"", yytext);
break;
case WitParser::PS_nextBound:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a bound set attribute (e.g., softLB, hardLB, hardUB)"
" or \"endBounds\"", yytext);
break;
case WitParser::PS_boundType:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a vector format (e.g, single, dense, sparse)", yytext);
break;
case WitParser::PS_single:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a \"(\" after \"single\"", yytext);
break;
case WitParser::PS_dense:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a \"(\" after \"dense\"", yytext);
break;
case WitParser::PS_sparse:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a \"(\" after \"sparse\"", yytext);
break;
case WitParser::PS_singleParen:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a vector element for a \"single\" vector specification",
yytext);
break;
case WitParser::PS_denseParen:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a vector element for a \"dense\" vector specification",
yytext);
break;
case WitParser::PS_sparseParen:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a period (an integer) in \"sparse\" vector specification", yytext);
break;
case WitParser::PS_singleValue:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a \")\" after the one vector value in a \"single\" vector "
"specification", yytext);
break;
case WitParser::PS_denseValue:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a vector value or a \")\"", yytext);
break;
case WitParser::PS_sparseValue:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a period (an integer) or a \")\"", yytext);
break;
case WitParser::PS_period:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a \":\" in \"sparse\" vector specification", yytext);
break;
case WitParser::PS_periodColon:
WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
"a vector value (a number) after the \":\"", yytext);
break;
}
d1513 3
a1515 3
{
myProblem ()->myApiMgr ()->myInputID ()->setDataFileName (fileName ());
}
d1520 3
a1522 3
{
myProblem ()->myApiMgr ()->myInputID ()->setDataFileLineNo (lineno ());
}
d1529 10
a1538 10
theSymTable_   (NULL),
currentRule_   (),
previousRule_  (),
currentEntity_ (NULL),
currentAttr_   (NULL),
parseState_    (PS_initial),
myProblem_     (NULL)
{
commandState = PS_initial;
}
d1541 2
a1542 2
{
}
d1549 1
a1549 1
int   rc;
d1551 2
a1552 2
WitParlex::setFileName (fileName);   // save current file name
yyin = f;                            // save pointer to FILE
d1554 3
a1556 3
myProblem_   = theProblem;
theSymTable_ = new WitSymTable (theProblem->myWitRun ());
rc           = theSymTable_->registerRules ();
d1558 2
a1559 2
if (rc)
return rc;
d1561 1
a1561 1
//#if defined (WIN32) or defined (__OS2__)
d1563 1
a1563 1
//  yy_reset();
d1565 1
a1565 1
//#endif
d1567 1
a1567 1
rc = yyparse();
d1569 10
a1578 10
if (rc)
{
WitParser::instance ()->prtSyntaxError(entryPtr,
WitParser::instance ()->parseState(),
reinterpret_cast <const char *> (yytext));
WitParser::instance ()->myMsgFac () ("lineNumberMsg",
reinterpret_cast <const char *> (yytext),
WitParlex::lineno(), WitParlex::fileName());
WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
}
d1580 2
a1581 2
delete theSymTable_;
return rc;
@


1.42
log
@Revised the copyright date.
@
text
@d83 1
a83 1
const char * relnum[] = {"4.0", "5.0", "6.0", "7.0"};
@


1.41
log
@Corrected an incorrect error message.
@
text
@d3 37
a39 37
 *
 *     (c) Copyright IBM Corp. 2006.
 *     (Unpublished)
 *     OCO Source Modules
 *     IBM Confidential
 *
 *------------------------------------------------------------------------------

 *------------------------------------------------------------------------------
 *
 *     Source file:    witParse.y
 *
 *     Parser for WIT 4.0 Input Data File Format
 *
 *     To create an executable parser file:
 *
 *           yacc -d  witParse.y             (creates y.tab.c and y.tab.h)
 *           mv -f y.tab.c witParse.C
 *           mv -f y.tab.h ytab.h
 *           lex  witLexer.l                 (creates lex.yy.c)    
 *           mv -f lex.yy.c witLexer.C
 *           xlC witLexer.C witParse.C -o witParse -ly -ll
 *    
 *           Notes:
 *           
 *              -d   causes y.tab.h to be created.  This is the token
 *                   name definition file.
 *
 *              -ly  causes the yacc library to be included. This 
 *                   library is in /usr/lib/liby.a
 *
 *              -ll  causes the lex library to be included. This
 *                   library is in /usr/lib/libl.a      
 *
 *------------------------------------------------------------------------------
 *
 */
d69 1
a69 1
void prterror();                     /* print line number and filename */ 
d71 1
a71 1
    /* variables used by the parser */
d79 1
a79 1
WitAttribute::aType   attrType;      /* type of the current attribute */  
d84 3
a86 3
   //
   // Valid WIT release numbers
   // (i.e., valid values for the "release" specification)
d90 1
a90 1
const char * checkrel(char *);         /* check for a valid release number */   
d95 7
a101 7
    int    intval;
    double doubleval;
    char * strval;
    bool   boolval;
    int    cval;
    int    pval;
    int    btype;
d104 1
a104 1
    /* literal keyword tokens */
d106 1
a106 1
%token PART OPERATION BOM_ENTRY SUB_ENTRY BOP_ENTRY 
d110 1
a110 1
%token CAPACITY MATERIAL 
d112 2
a113 2
    /* tokens with values -- the values are returned by
       the lexer in yylval, which is a union */
d123 2
a124 2
    /* These are production names and corresponding types */
%type  <strval>   attribute_name  
d127 1
a127 1
%type  <cval>     category  
d139 1
a139 1
    /* definition of grammar */
d142 1
a142 1
    ;
d144 3
a146 3
command_list:  /* empty */    
    | command_list command
    ;
d149 27
a175 27
    {
      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    }
 
    | set_command
    { 
      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    } 
 
    | read_command
    {
      if (WitParser::instance ()->currentEntity_ != NULL)
        delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    }
    ;
d178 17
a194 1
    { WitParser::instance ()->setParseState(WitParser::PS_release); }
d196 49
a244 65
    release_num
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
      free (yylval.strval);     
    }
    ;

release_num: STRING 
    { if (!checkrel(yylval.strval)) {    /* check table of valid releases */
         WitParser::instance ()->myMsgFac () ("invalidRelMsg", yylval.strval);

         int i;

         for (i = 0; i < NRELS; ++ i)
            WitParser::instance ()->myMsgFac () ("validRelSmsg", relnum[i]);

         prterror();
         WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }
    ;

add_command: ADD  
    { 
      WitParser::instance ()->setParseState(WitParser::PS_add);
      commandState = WitParser::PS_add;     /* save command state */
      WitParser::instance ()->currentRule_ = "add";
    }

    add_clause 
    {
      /* lookup rule for this entity and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule(
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* Issue error message if no entry found in symbol table */
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }

    entity_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
    ;
d247 28
a274 28
    {
      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval); 
      WitParser::instance ()->currentAttr_ = NULL;
    }

    | PART_WITH_OPERATION
    {
      WitParser::instance ()->setParseState(WitParser::PS_partOperation);
      WitParser::instance ()->currentRule_ = "add_partWithOperation";

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::partWithOperation);

      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;
      entityType = WitEntity::partWithOperation;
    }
    ;
d277 33
a309 33
    {
      WitParser::instance ()->setParseState(WitParser::PS_setProblem);
      commandState = WitParser::PS_set;     /* save command state */

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::problem);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      WitParser::instance ()->currentRule_ = "set_problem";
    }
 
    global_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
   
    | SET 
    { 
      WitParser::instance ()->setParseState(WitParser::PS_set);
      commandState = WitParser::PS_set;     /* save command state */
      WitParser::instance ()->currentRule_ = "set";
    }
  
    set_clause entity_specification ';'
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    }
    ;
d312 34
a345 34
    {
      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      /* lookup rule for this entity and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule (
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* Issue error message if no entry found in symbol table */
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }
    ;
d348 41
a388 41
    {
      WitParser::instance ()->setParseState(WitParser::PS_part);
      WitParser::instance ()->currentRule_ += "_part";
      entityType = WitEntity::part;
    }

    | OPERATION
    {
      WitParser::instance ()->setParseState(WitParser::PS_operation);
      WitParser::instance ()->currentRule_ += "_operation";
      entityType = WitEntity::operation;
    }

    | BOM_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_bomEntry);
      WitParser::instance ()->currentRule_ += "_bomEntry";
      entityType = WitEntity::bomEntry;
    } 

    | SUB_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_subEntry);
      WitParser::instance ()->currentRule_ += "_subEntry";
      entityType = WitEntity::subEntry;
    }

    | BOP_ENTRY
    {
      WitParser::instance ()->setParseState(WitParser::PS_bopEntry);
      WitParser::instance ()->currentRule_ += "_bopEntry";
      entityType = WitEntity::bopEntry;
    }

    | DEMAND
    {
      WitParser::instance ()->setParseState(WitParser::PS_demand);
      WitParser::instance ()->currentRule_ += "_demand";
      entityType = WitEntity::demand;
    }
    ; 
d391 1
a391 1
    ;
d394 44
a437 58
    {
      /*------------------------------------------------------*
       * we have created the entity object and the argument   *
       * vector; we also know the current rule; if there is   *
       * an entry for the rule, then invoke the function.     *
       *------------------------------------------------------*/

      if (entryPtr != NULL) {
        /* before invoking the function, check the validity of the arguments */
        /* by comparing the arg. types against the types in the symbol table */

        retcode = WitParser::instance ()->currentEntity_->checkArgs(entryPtr);
        if (retcode == BAD_NUM_ARGS) {
          if (entryPtr->nparms() == 1)
            s2 = "argument";
          else s2 = "arguments";
          if (WitParser::instance ()->currentEntity()->argc() == 1)
            s3 = "was found";
          else s3 = "were found";

          s1 = "";
          if (commandState == WitParser::PS_add)
            s1 = "add "; 
          if (commandState == WitParser::PS_set)
            s1 = "set ";

          WitParser::instance ()->myMsgFac () ("incorrectNumberArgMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2,
             WitParser::instance ()->currentEntity()->argc(),
             s3);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else
        if (retcode) {
          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }

        else                                    /* if arguments O.K.  */
        if (entryPtr->func() != NULL) {         /* if function exists */

          /* if entity has been invalidated because of an error,      */
          /* then, skip invocations of API functions for the entity   */
          if (!WitParser::instance ()->currentEntity_->invalid())
            (entryPtr->func())();               /* invoke function */
        }
      };  

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
    }
d439 16
a454 2
    attribute_list
    ;
d457 5
a461 5
    { 
      if (WitParser::instance ()->parseState() == WitParser::PS_part)
      $$ = $1;
    }
    ; 
d464 47
a510 47
    | attribute_list attribute
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextAttr);

      /* If an entry exists for the current rule, then invoke   */
      /* the function.                                          */

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      else
      {
        retcode = WitParser::instance ()->currentAttr_->checkArgs(entryPtr);
        if (retcode == PERIOD_ERROR) {
           WitParser::instance ()->currentAttr_->setInvalid(true);
           prterror();
        }            
        else
        if (retcode) {
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else 
        if (entryPtr->func() != NULL) {        /* if function exists  */

          /* if entity or attr has been invalidated because of error, */
          /* then, skip invocations of API function for attributes    */
          if (!WitParser::instance ()->currentEntity_->invalid() and
            !WitParser::instance ()->currentAttr_->invalid())
            retcode = (entryPtr->func())();    /* invoke wrapper function */
            if (retcode) {
              WitParser::instance ()->currentAttr_->setInvalid(true);
              prterror();
            }; 
        } 
      };                   

      WitParser::instance ()->currentRule_ =
         WitParser::instance ()->previousRule_;
    }  
    ;
d513 2
a514 2
    | argument_list argument
    ;
d517 87
a603 87
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      switch($1) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setDoubleArg(yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentEntity_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setStringArg(yylval.strval);

          /* string was created by the lexer and it's no longer needed */
          free (yylval.strval);
          break;
        default:
          return 0;
      };
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        /* if rule is not defined in symbol table, skip message now. */
        /* However, error message will be issued after all arguments */
        /* are processed.  We don't know the correct number of args. */

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    }

    | category
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      argPtr = WitParser::instance ()->currentEntity_->
        setCatArg (static_cast <WitDRPartCat::Tag> (yylval.cval));
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        /* If rule is not defined, skip message. See comment above */
        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
     }
    }
    ;
d607 2
a608 2
    | bound_set_attribute
    ;
d611 1
a611 1
    ;
d614 36
a649 36
    {
      WitParser::instance ()->setParseState(WitParser::PS_attr);
      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");

      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (WitParser::instance ()->myProblem (), yylval.strval);

      free (yylval.strval);

      /* lookup rule for this attribute and save symbol table pointer */
      /* this will be helpful to check the datatype of a vector       */
      entryPtr = WitParser::instance ()->currentAttr_->
        lookupRule(WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      /* if attribute name is not in the symbol table, we can't       */
      /* continue because we don't know the expected argument types   */
      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      $$ = $1;
    }
    ;
d652 54
a705 54
    {
      switch($1) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setDoubleArg(
                yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentAttr_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentAttr_->setStringArg(yylval.strval);

          /* string was created by the lexer and it's no longer needed */
          free (yylval.strval);
          break;
        default:
          return 0;
      };

      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentAttr_->attrID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    }

    | vector_format
    { $$ = WitDRParmType::undefined; }
    ;
d708 1
a708 1
    { $$ = WitDRParmType::string; }
d710 2
a711 2
    | INTEGER
    { $$ = WitDRParmType::intScalar; }
d713 2
a714 2
    | DOUBLE
    { $$ = WitDRParmType::doubleScalar; }
d716 113
a828 113
    | BOOLEAN
    { $$ = WitDRParmType::boolScalar; }
    ;

vector_format: SINGLE 
    {
      WitParser::instance ()->setParseState(WitParser::PS_single);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::single_,
                entryPtr->parmTypes()[0]);

          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else 
        vecPtr =
           new WitVectorSpec (
              WitParser::instance ()->myProblem (),
              WitVectorSpec::single_,
              WitDRParmType::doubleVector);
    }

    '('
    {
      WitParser::instance ()->setParseState(WitParser::PS_singleParen);
    }

    vector_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_singleValue);
    }

    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    | SPARSE 
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparse);

      /* Construct a VectorSpec object */
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::sparse_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::sparse_,
               WitDRParmType::doubleVector);
    }

    '(' 
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
    }

    sparse_list 
    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    | DENSE
    {
      WitParser::instance ()->setParseState(WitParser::PS_dense);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (WitParser::instance ()->myProblem (),
                WitVectorSpec::dense_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::dense_,
               WitDRParmType::doubleVector);
    }

    '(' 
    {
      WitParser::instance ()->setParseState(WitParser::PS_denseParen);
    }

    value_list 
    ')'
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }
    ;
d831 18
a848 18
    | sparse_list period_value
    {
      WitParser::instance ()->setParseState(WitParser::PS_sparseValue);
    }
    ;

period_value: period 
    ':'
    {
      WitParser::instance ()->setParseState(WitParser::PS_periodColon);
    }

    vector_value
    { 
      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
      $$ = $4; 
    }
    ;
d851 2
a852 2
    | value_list vector_value
    ;
d855 2
a856 2
    {
      WitParser::instance ()->setParseState(WitParser::PS_denseValue);
d858 2
a859 2
      if (entryPtr != NULL) {
      switch($1) {
d861 93
a953 93
        case WitDRParmType::intScalar:
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));

            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            retcode = vecPtr->addIntVal(yylval.intval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };
          
        case WitDRParmType::doubleScalar:
         if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            vecPtr->addIntVal(static_cast <int> (yylval.doubleval));
            retcode = SHOULD_BE_INT;
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };

        case WitDRParmType::boolScalar:
           {
           if (entryPtr->parmTypes()[0] == WitDRParmType::boolVector)
              {
              retcode = vecPtr->addBoolVal (yylval.boolval);

              break;
              };

           WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
              WitParser::instance ()->currentAttr_->attrID ());

           WitParser::instance ()->currentAttr_->setInvalid (true);

           prterror ();

           retcode = 0;

           WitParser::instance ()->myMsgFac () ("parsingStopsMsg");

           break;
           }

        case WitDRParmType::string:
          WitParser::instance ()->myMsgFac () ("stringVectorMsg",
             WitParser::instance ()->currentAttr_->attrID());
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          free (yylval.strval);
          retcode = 0;
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
          break;
      }

      if (retcode == WRONG_TYPE) {
        WitParser::instance ()->myMsgFac () ("vecTypeNotValidMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      if (retcode == SHOULD_BE_INT) {
        WitParser::instance ()->myMsgFac () ("vecValueNotIntMsg",
           WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      }
    }
    ;
d956 2
a957 2
    {
      WitParser::instance ()->setParseState(WitParser::PS_period);
d959 36
a994 36
      retcode = vecPtr->addPeriodVal(yylval.intval);
      if (retcode == PERIOD_ERROR) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
      if (retcode == PERIOD_DUP) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
    }
    ;

bound_set_attribute: bound_set_type 
    {  
      /* lookup rule for this attribute and save symbol table pointer */
      entryPtr = WitParser::instance ()->currentAttr_->
         lookupRule (
            WitParser::instance ()->theSymTable_,
            WitParser::instance ()->currentRule_);

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    }

    bounds_specification END_BOUNDS
    {
      bndPtr = NULL;
      WitParser::instance ()->setParseState(WitParser::PS_endBounds);
    }
    ;
d997 5
a1001 2
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);
d1003 13
a1015 2
      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::exec);
d1017 59
a1075 73
      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }

    | STOCK_BOUNDS
    { 
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::stock);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }

    | CUM_SHIP_BOUNDS
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::cumShip);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      /* create a new WitAttribute object */
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);
      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      $$ = $1;
    }
    ;
d1078 12
a1089 1
    | bounds_specification
d1091 17
a1107 28
    bound_item
    {
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);
    }
    ;

bound_item: bound_type 
    {
      WitParser::instance ()->setParseState(WitParser::PS_boundType);
    }

    vector_format
    {
       switch ($1) {
         case WitBoundSetSpec::hardlb:
           bndPtr->setHardLBVec(vecPtr);
           break;

         case WitBoundSetSpec::softlb:
           bndPtr->setSoftLBVec(vecPtr);
           break;

         case WitBoundSetSpec::hardub:
           bndPtr->setHardUBVec(vecPtr);
           break;
       }
    }
    ;
d1110 67
a1176 67
    {
      if (bndPtr->hardLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::hardlb;
    }

    | SOFTLB
    {
      if (bndPtr->softLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateSoftLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::softlb;
    }

    | HARDUB
    {
      if (bndPtr->hardUBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardUBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      $$ = WitBoundSetSpec::hardub;
    }
    ;

read_command: READ 
    {
      WitParser::instance ()->setParseState(WitParser::PS_read);
      commandState = WitParser::PS_read;
      WitParser::instance ()->currentRule_ = "read";
      // printf("Current rule is: %s\n", WitParser::instance ()->currentRule_);
    }

    file_name 
    {
      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    }

    ';'
    {
      /* save lexer state and shift input stream to new file */
      errno   = 0;
      retcode = WitParlex::saveFile(yylval.strval);
      if (retcode == FOPEN_ERROR) {
        yylval.strval[strlen(yylval.strval)-1] = '\0';
        WitParser::instance ()->myMsgFac () ("fopenSmsg",
           yylval.strval+1,
          "r",
          errno,
          strerror(errno));
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      if (retcode == STACK_OVERFLOW) {
        WitParser::instance ()->myMsgFac () ("stackOverflowMsg", STACKSIZE);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
d1180 6
a1185 2
      WitParser::instance ()->setDataFileName   ();
      WitParser::instance ()->setDataFileLineNo ();
d1187 3
a1189 7
      //#if defined (__GNUC__)
      yyrestart(yyin);
      //#endif

      WitParser::instance ()->setParseState(WitParser::PS_initial);
      free (yylval.strval);
    }
d1191 2
a1192 2
    release_specification
    ;
d1195 1
a1195 1
    ;
d1206 2
a1207 2
   {
   witAssert (instance_ == NULL);
d1209 1
a1209 1
   instance_ = new WitParser;
d1211 1
a1211 1
   instance ()->parseIt (theProblem, fileName, f);
d1213 1
a1213 1
   delete instance ();
d1215 2
a1216 2
   instance_ = NULL;
   }
d1232 3
a1234 3
   {
   return myProblem ()->myMsgFac ();
   }
d1242 3
a1244 3
  WitParser::instance ()->myMsgFac () ("lineNumberMsg",
    reinterpret_cast <const char *> (yytext),
    WitParlex::lineno(), WitParlex::fileName());
d1247 1
a1247 1
//  check for a valid release number     
d1250 5
a1254 5
  if (strlen(s) <= 2) return NULL;
  for (int i = 0; i < NRELS; i++)
    if (strncmp(s+1, relnum[i], strlen(s)-2) == 0)
      return relnum[i];
  return NULL;
d1303 1
a1303 1
                WitParser::PS parseState, const char * yytext) const
d1305 1
a1305 1
  const char * s1;
d1307 201
a1507 201
  // Print syntax error message, depending on current parser state
  switch (parseState) {
    case WitParser::PS_initial:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "\"release\"", yytext);
      break;
    case WitParser::PS_commandEnd:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg", "a \";\"", yytext);
      break;
    case WitParser::PS_nextCommand:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
      "a command name (e.g., set, add, read)", yytext);
      break;
    case WitParser::PS_add:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an addable object type after \"add\"", yytext);
      break;
    case WitParser::PS_set:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of a settable object type after \"set\"", yytext);
      break;
    case WitParser::PS_setProblem:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute after \"set problem\"", yytext);
      break;
    case WitParser::PS_read:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a string (the name of a file) after \"read\"", yytext);
      break;
    case WitParser::PS_release:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a quoted string (the release number) after \"release\"", yytext);
      break;
    case WitParser::PS_part:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "part", yytext);
      break;
    case WitParser::PS_operation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "operation", yytext);
      break;
    case WitParser::PS_bomEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bomEntry", yytext);
      break;
    case WitParser::PS_subEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "subEntry", yytext);
      break;
    case WitParser::PS_bopEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bopEntry", yytext);
      break;
    case WitParser::PS_demand:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "demand", yytext);
      break;
    case WitParser::PS_partOperation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "partWithOperation", yytext);
      break;
    case WitParser::PS_nextArg:

      // Check to see if we have the correct number of argumenta.
      // If so, we are looking for an attribute or a semicolon
      if (WitParser::instance ()->currentEntity()->argc() >= pEntry->nparms()) {
        WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
          "the name of an attribute or a \";\"", yytext);
        break;
      };

      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "another argument",
         yytext);
      break;
    case WitParser::PS_attr:
      switch (pEntry->parmTypes()[0]) {   // what the value should be
        case WitDRParmType::intScalar:
          s1 = "integer";	
          break;
        case WitDRParmType::doubleScalar:
          s1 = "double";
          break;
        case WitDRParmType::string:
          s1 = "string";
          break;
        case WitDRParmType::boolScalar:
          s1 = "boolean";
          break;
        case WitDRParmType::partCat:
          s1 = "\"category\"";
          break;
        case WitDRParmType::boolVector:
          s1 = "\"boolean vector\"";
          break;
        case WitDRParmType::intVector:
          s1 = "\"integer vector\"";
          break;
        case WitDRParmType::doubleVector:
          s1 = "\"double vector\"";
          break;
        case WitDRParmType::boundSet:
          s1 = "\"bound set\"";
          break;
        default:
          s1 = "unknown";
          break;
      };
      WitParser::instance ()->myMsgFac () ("attrValueNotFound",
        s1, WitParser::instance ()->currentAttr()->attrID(), yytext);
      break;
    case WitParser::PS_nextAttr:
    case WitParser::PS_endBounds:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute or a \";\"", yytext);
      break;
    case WitParser::PS_nextBound:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a bound set attribute (e.g., softLB, hardLB, hardUB)"
        " or \"endBounds\"", yytext);
      break;
    case WitParser::PS_boundType:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector format (e.g, single, dense, sparse)", yytext);
      break;
    case WitParser::PS_single:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"single\"", yytext);
      break;
    case WitParser::PS_dense:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"dense\"", yytext);
      break;
    case WitParser::PS_sparse:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"sparse\"", yytext);
      break;
    case WitParser::PS_singleParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector element for a \"single\" vector specification",
        yytext);
      break;
    case WitParser::PS_denseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector element for a \"dense\" vector specification",
        yytext);
      break;
    case WitParser::PS_sparseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_singleValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \")\" after the one vector value in a \"single\" vector "
        "specification", yytext);
      break;
    case WitParser::PS_denseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value or a \")\"", yytext);
      break;
    case WitParser::PS_sparseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) or a \")\"", yytext);
      break;
    case WitParser::PS_period:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \":\" in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_periodColon:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value (a number) after the \":\"", yytext);
      break;
  }
d1513 3
a1515 3
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileName (fileName ());
   }
d1520 3
a1522 3
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileLineNo (lineno ());
   }
d1529 10
a1538 10
      theSymTable_   (NULL),
      currentRule_   (),
      previousRule_  (),
      currentEntity_ (NULL),
      currentAttr_   (NULL),
      parseState_    (PS_initial),
      myProblem_     (NULL)
   {
   commandState = PS_initial;
   }
d1541 2
a1542 2
   {
   }
d1549 1
a1549 1
  int   rc;
d1551 2
a1552 2
  WitParlex::setFileName (fileName);   // save current file name
  yyin = f;                            // save pointer to FILE
d1554 3
a1556 3
  myProblem_   = theProblem;
  theSymTable_ = new WitSymTable (theProblem->myWitRun ());
  rc           = theSymTable_->registerRules ();
d1558 2
a1559 2
  if (rc)
     return rc;
d1561 1
a1561 1
  //#if defined (WIN32) or defined (__OS2__)
d1563 1
a1563 1
  //  yy_reset();
d1565 1
a1565 1
  //#endif
d1567 1
a1567 1
  rc = yyparse();
d1569 10
a1578 10
  if (rc)
  {
    WitParser::instance ()->prtSyntaxError(entryPtr,
       WitParser::instance ()->parseState(),
      reinterpret_cast <const char *> (yytext));
    WitParser::instance ()->myMsgFac () ("lineNumberMsg",
      reinterpret_cast <const char *> (yytext),
      WitParlex::lineno(), WitParlex::fileName());
    WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
  }
d1580 2
a1581 2
  delete theSymTable_;
  return rc;
@


1.40
log
@Removed some more conversions from string constant to char *.
@
text
@d1473 4
d1479 1
a1479 1
        "a vector value (a number) for a \"single\" vector specification",
@


1.39
log
@Removed some more conversions of string constants to char *.
@
text
@d58 1
a58 1
extern "C" void yyerror(char *)
@


1.38
log
@Removed some implicit conversions from string constant to char *.
@
text
@d1305 1
a1305 1
  char  *s1;
@


1.37
log
@Changed some #includes.
@
text
@d81 1
a81 1
char                  *s1, *s2, *s3; /* temporary strings     */
d83 1
a83 1
char * relnum[] = {"4.0", "5.0", "6.0", "7.0"};
d90 1
a90 1
char      *checkrel(char *);         /* check for a valid release number */   
d1248 1
a1248 1
char     *checkrel(char *s)       /* s = char. string, in quotes */
@


1.36
log
@Updated the copyright date on all source files.
@
text
@d41 7
a47 7
#include <wit/src/Parser.h>
#include <wit/src/Problem.h>
#include <wit/src/ApiMgr.h>
#include <wit/src/InputID.h>
#include <wit/src/VecBS.h>
#include <wit/src/Entity.h>
#include <wit/src/MsgFac.h>
@


1.35
log
@Changed a comment.
@
text
@d4 1
a4 1
 *     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.34
log
@Updated release number to 7.0.
@
text
@d86 1
a86 1
   // (i.e., valid values for the "release" statement)
@


1.33
log
@Adding witLexer.C, witParse.C and ytab.h to the src code.  Also modified
witLexer.l and witParse.y to remove gnu and win32 dependencies.
@
text
@d83 5
a87 2
    /* valid "release" numbers (i.e,, the version of the software) */
char      *relnum[] = {"4.0", "5.0", "6.0"};
@


1.32
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d53 1
a53 1
#if defined(__GNUC__)
d56 1
a56 1
#endif
d62 4
a65 2
#if defined (WIN32) or defined (__OS2__)
extern void yy_reset(void);
d67 1
a67 3
#else
extern  unsigned char yytext[];
#endif
d1180 1
a1180 1
#if defined (__GNUC__)
d1182 1
a1182 1
#endif
d1554 1
a1554 1
#if defined (WIN32) or defined (__OS2__)
d1556 1
a1556 1
  yy_reset();
d1558 1
a1558 1
#endif
@


1.31
log
@[multi-thread]
@
text
@d1156 1
@


1.30
log
@[multi-thread]
@
text
@d1163 1
a1163 1
          WitNonClass::strerror(errno));
@


1.29
log
@[exceptions]
@
text
@a48 4
#include <iostream>

#include <stdio.h>
#include <stdlib.h>
a49 1
#include <string.h>
@


1.28
log
@[exceptions]
@
text
@d41 1
d44 1
a44 2
#include <wit/src/Parlex.h>
#include <wit/src/SymTable.h>
a46 1
#include <wit/src/Parser.h>
d1511 1
a1511 1
   myProblem ()->myApiMgr ()->myInputId ()->setDataFileName (fileName ());
d1518 1
a1518 1
   myProblem ()->myApiMgr ()->myInputId ()->setDataFileLineNo (lineno ());
@


1.27
log
@[exceptions]
@
text
@d47 1
a47 1
#include <wit/src/witParse.h>
d1267 1
a1267 1
// The parse states are defined in witParse.h:
@


1.26
log
@[exceptions]
@
text
@a43 1
#include <wit/src/witLexer.h>
@


1.25
log
@[exceptions]
@
text
@a1527 1
      theLexer_      (NULL),
a1535 1
   theLexer_    = new WitLexer;
a1540 1
   delete theLexer_;
@


1.24
log
@Vector Prop-Rt.
@
text
@d215 1
a215 1
      WitParser::instance ()->currentRule = "add";
d224 1
a224 1
           WitParser::instance ()->currentRule);
d265 1
a265 1
      WitParser::instance ()->currentRule = "add_partWithOperation";
d294 1
a294 1
      WitParser::instance ()->currentRule = "set_problem";
d306 1
a306 1
      WitParser::instance ()->currentRule = "set";
d330 1
a330 1
           WitParser::instance ()->currentRule);
d354 1
a354 1
      WitParser::instance ()->currentRule += "_part";
d361 1
a361 1
      WitParser::instance ()->currentRule += "_operation";
d368 1
a368 1
      WitParser::instance ()->currentRule += "_bomEntry";
d375 1
a375 1
      WitParser::instance ()->currentRule += "_subEntry";
d382 1
a382 1
      WitParser::instance ()->currentRule += "_bopEntry";
d389 1
a389 1
      WitParser::instance ()->currentRule += "_demand";
d453 2
a454 2
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
d511 2
a512 2
      WitParser::instance ()->currentRule =
         WitParser::instance ()->previousRule;
d620 2
a621 2
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
d623 2
a624 2
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d638 1
a638 1
           WitParser::instance ()->currentRule);
d981 1
a981 1
            WitParser::instance ()->currentRule);
d1007 4
a1010 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d1034 4
a1037 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d1061 4
a1064 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d1151 2
a1152 2
      WitParser::instance ()->currentRule = "read";
      // printf("Current rule is: %s\n", WitParser::instance ()->currentRule);
d1166 5
a1170 2
        WitParser::instance ()->myMsgFac () ("fopenErrorMsg", yylval.strval+1,
          "r", errno, WitNonClass::strerror(errno));
d1528 1
a1528 1
      theLexer       (NULL),
d1530 2
a1531 2
      currentRule    (),
      previousRule   (),
d1537 1
a1537 1
   theLexer     = new WitLexer;
d1543 1
a1543 1
   delete theLexer;
@


1.23
log
@Vector PropRt.
@
text
@d736 1
a736 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d776 1
a776 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d810 1
a810 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d869 1
d909 1
a909 1
              retcode = vecPtr->addIntVal (yylval.boolval);
@


1.22
log
@Removed portableFree.
@
text
@d905 21
a925 7
          WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
            WitParser::instance ()->currentAttr_->attrID());
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          retcode = 0;
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
          break;
d1426 3
@


1.21
log
@Double Precision.
@
text
@d192 1
a192 1
      portableFree(yylval.strval);     
d258 1
a258 1
      portableFree(yylval.strval); 
d274 1
a274 1
      portableFree(yylval.strval);
d291 1
a291 1
      portableFree(yylval.strval);
d323 1
a323 1
      portableFree(yylval.strval);
d543 1
a543 1
          portableFree(yylval.strval);
d632 1
a632 1
      portableFree(yylval.strval);
d676 1
a676 1
          portableFree(yylval.strval);
d918 1
a918 1
          portableFree(yylval.strval);
d1008 1
a1008 1
      portableFree(yylval.strval);
d1035 1
a1035 1
      portableFree(yylval.strval);
d1061 1
a1061 1
      portableFree(yylval.strval);
d1173 1
a1173 1
      portableFree(yylval.strval);
@


1.20
log
@Double Precision.
@
text
@d99 7
a105 9
    int      intval;
    double   doubleval;
    char     *strval;
    int      boolval;
    int      subtok;
    int      cval;
    int      eval;
    int      pval;
    int      btype;
d535 1
a535 1
            setBoolArg(static_cast <bool> (yylval.boolval));
d669 1
a669 1
            setBoolArg(static_cast <bool> (yylval.boolval));
@


1.19
log
@Double Precision.
@
text
@d100 1
a100 1
    double   floatval;
d121 7
a127 7
%token <strval>   IDENTIFIER
%token <strval>   STRING
%token <floatval> FLOAT
%token <intval>   INTEGER
%token <boolval>  BOOLEAN
%token <cval>     CATEGORY
%token <strval>   EXEC_BOUNDS STOCK_BOUNDS CUM_SHIP_BOUNDS
d533 1
a533 1
                setFloatArg(yylval.floatval);
d666 2
a667 1
             WitParser::instance ()->currentAttr_->setFloatArg(yylval.floatval);
d719 1
a719 1
    | FLOAT
d869 2
a870 1
            retcode = vecPtr->addFloatVal(static_cast <double> (yylval.intval));
d878 2
a879 1
            retcode = vecPtr->addFloatVal(static_cast <double> (yylval.intval));
d889 1
a889 1
            vecPtr->addIntVal(static_cast <int> (yylval.floatval));
d894 1
a894 1
            retcode = vecPtr->addFloatVal(yylval.floatval);
d898 1
a898 1
            retcode = vecPtr->addFloatVal(yylval.floatval);
d1403 1
a1403 1
          s1 = "float";
d1418 1
a1418 1
          s1 = "\"float vector\"";
@


1.18
log
@Double Precision.
@
text
@d530 1
a530 1
        case WitDRParmType::floatScalar:
d664 1
a664 1
        case WitDRParmType::floatScalar:
d719 1
a719 1
    { $$ = WitDRParmType::floatScalar; }
d747 1
a747 1
              WitDRParmType::floatVector);
d786 1
a786 1
               WitDRParmType::floatVector);
d820 1
a820 1
               WitDRParmType::floatVector);
d867 1
a867 1
          if (entryPtr->parmTypes()[0] == WitDRParmType::floatVector) {
d884 1
a884 1
        case WitDRParmType::floatScalar:
d890 1
a890 1
          if (entryPtr->parmTypes()[0] == WitDRParmType::floatVector) {
d1399 1
a1399 1
        case WitDRParmType::floatScalar:
d1414 1
a1414 1
        case WitDRParmType::floatVector:
@


1.17
log
@Double Precision.
@
text
@d526 1
a526 1
        case Integer:
d530 1
a530 1
        case Float:
d535 1
a535 1
        case Boolean:
d539 1
a539 1
        case String:
d660 1
a660 1
        case Integer:
d664 1
a664 1
        case Float:
d668 1
a668 1
        case Boolean:
d672 1
a672 1
        case String:
d709 1
a709 1
    { $$ = Undefined; }
d713 1
a713 1
    { $$ = String; }
d716 1
a716 1
    { $$ = Integer; }
d719 1
a719 1
    { $$ = Float; }
d722 1
a722 1
    { $$ = Boolean; }
d737 1
a737 1
                static_cast <pType> (entryPtr->parmTypes()[0]));
d747 1
a747 1
              FloatVector);
d777 1
a777 1
                static_cast <pType> (entryPtr->parmTypes()[0]));
d786 1
a786 1
               FloatVector);
d811 1
a811 1
                static_cast <pType> (entryPtr->parmTypes()[0]));
d820 1
a820 1
               FloatVector);
d866 2
a867 2
        case Integer:
          if (entryPtr->parmTypes()[0] == FloatVector) {
d871 1
a871 1
          if (entryPtr->parmTypes()[0] == IntVector) {
d875 1
a875 1
          if (entryPtr->parmTypes()[0] == BoundSet) {
d884 2
a885 2
        case Float:
         if (entryPtr->parmTypes()[0] == IntVector) {
d890 1
a890 1
          if (entryPtr->parmTypes()[0] == FloatVector) {
d894 1
a894 1
          if (entryPtr->parmTypes()[0] == BoundSet) {
d903 1
a903 1
        case Boolean:
d912 1
a912 1
        case String:
d1396 1
a1396 1
        case Integer:
d1399 1
a1399 1
        case Float:
d1402 1
a1402 1
        case String:
d1405 1
a1405 1
        case Boolean:
d1408 1
a1408 1
        case Category:
d1411 1
a1411 1
        case IntVector:
d1414 1
a1414 1
        case FloatVector:
d1417 1
a1417 1
        case BoundSet:
@


1.16
log
@Double Precision.
@
text
@d583 1
a583 1
        setCatArg((category) yylval.cval);
d737 1
a737 1
               (pType) entryPtr->parmTypes()[0]);
d777 1
a777 1
                (pType) entryPtr->parmTypes()[0]);
d811 1
a811 1
                (pType) entryPtr->parmTypes()[0]);
@


1.15
log
@Continued implementation of PIP.
@
text
@d100 1
a100 1
    float    floatval;
d868 1
a868 1
            retcode = vecPtr->addFloatVal(static_cast <float> (yylval.intval));
d876 1
a876 1
            retcode = vecPtr->addFloatVal(static_cast <float> (yylval.intval));
@


1.14
log
@Continued implementation of PIP.
@
text
@d1151 1
a1151 1
          "r", errno, WitUtil::strerror(errno));
@


1.13
log
@Made changes to eliminate some of the compiler warnings on Linux.
@
text
@d194 1
a194 1
      WitUtil::portableFree(yylval.strval);     
d260 1
a260 1
      WitUtil::portableFree(yylval.strval); 
d276 1
a276 1
      WitUtil::portableFree(yylval.strval);
d293 1
a293 1
      WitUtil::portableFree(yylval.strval);
d325 1
a325 1
      WitUtil::portableFree(yylval.strval);
d545 1
a545 1
          WitUtil::portableFree(yylval.strval);
d634 1
a634 1
      WitUtil::portableFree(yylval.strval);
d677 1
a677 1
          WitUtil::portableFree(yylval.strval);
d917 1
a917 1
          WitUtil::portableFree(yylval.strval);
d1007 1
a1007 1
      WitUtil::portableFree(yylval.strval);
d1034 1
a1034 1
      WitUtil::portableFree(yylval.strval);
d1060 1
a1060 1
      WitUtil::portableFree(yylval.strval);
d1172 1
a1172 1
      WitUtil::portableFree(yylval.strval);
@


1.12
log
@added "yyrestart" for GNU
@
text
@d51 2
a53 1
#include <iostream.h>
@


1.11
log
@Continued implementation of proportionate routing.
@
text
@d61 1
d1165 4
@


1.10
log
@modifed to work with gnu yacc
@
text
@d20 1
a20 1
 *           mv -f y.tab.c ytab.C
d23 2
a24 2
 *           mv -f lex.yy.c witParse.C
 *           xlC witParse.C ytab.C -o witParse -ly -ll
@


1.9
log
@Changed some C style casts to C++ style.
@
text
@d59 4
@


1.8
log
@Replaced some C style casts with C++ style casts.
@
text
@d531 1
a531 1
            setBoolArg((bool) yylval.boolval);
d664 1
a664 1
            setBoolArg((bool) yylval.boolval);
d862 1
a862 1
            retcode = vecPtr->addFloatVal((float) yylval.intval);
d870 1
a870 1
            retcode = vecPtr->addFloatVal((float) yylval.intval);
d880 1
a880 1
            vecPtr->addIntVal((int) yylval.floatval);
@


1.7
log
@Internal changes.
@
text
@d1216 2
a1217 1
  WitParser::instance ()->myMsgFac () ("lineNumberMsg", (const char *) yytext,
d1543 3
a1545 2
      (const char *) yytext);
    WitParser::instance ()->myMsgFac () ("lineNumberMsg", (const char *) yytext,
@


1.6
log
@Internal changes.
@
text
@d63 1
a63 1
#if defined (WIN32) || defined (__OS2__)
d497 1
a497 1
          if (!WitParser::instance ()->currentEntity_->invalid() &&
d1530 1
a1530 1
#if defined (WIN32) || defined (__OS2__)
@


1.5
log
@modications to change rogueWave tools.h++ to STL
@
text
@d234 1
a234 1
        WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d340 1
a340 1
        WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d428 1
a428 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d434 1
a434 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d475 1
a475 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d483 1
a483 1
           WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d488 1
a488 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d501 1
a501 1
              WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d531 1
a531 1
            setBoolArg((WitBoolean) yylval.boolval);
d566 1
a566 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d597 1
a597 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d642 1
a642 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d664 1
a664 1
            setBoolArg((WitBoolean) yylval.boolval);
d695 1
a695 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d900 1
a900 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d909 1
a909 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d920 1
a920 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d928 1
a928 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d943 1
a943 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d947 1
a947 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d965 1
a965 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1096 1
a1096 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1107 1
a1107 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1118 1
a1118 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
@


1.4
log
@Began implementation of object iteration.
@
text
@d73 1
a73 1
RWCollectableString   *rulePtr;
@


1.4.2.1
log
@removed RWCollectable reference
@
text
@d73 1
a73 1
//RWCollectableString   *rulePtr;
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d49 1
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d84 1
a84 1
char      *relnum[] = {"4.0", "5.0"};
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 *     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.171;
access;
symbols
	sce_5_01_20080919:1.151
	latest_sce_4_20_20060523:1.72.0.2
	sce_4_20_20060523:1.72
	latest_sce4_20_OSL:1.71.0.2
	sce_4_20_OSL:1.71
	sce_410_withVa:1.66
	sce_4_05_20040511:1.60
	sce_4_00_20040201:1.43
	nextGenBranch:1.39.0.2
	nextGenRoot:1.39
	sce_3_30_20030627:1.39
	EndRw-branch:1.32.0.4
	Root-of-EndRw:1.32
	rwToStl:1.32.0.2
	latest_sce_3_10_20010924:1.14.0.2
	sce_3_10_20010924:1.14
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.171
date	2011.09.28.23.49.15;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2011.09.24.00.27.31;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2011.08.30.20.17.25;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2011.02.18.22.28.14;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2010.09.24.18.17.20;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2010.09.24.15.46.14;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2010.09.22.20.21.52;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2010.09.21.21.19.12;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2010.09.09.19.41.06;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2010.06.23.18.25.16;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2010.06.22.23.30.54;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.16.20.56.28;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2010.01.06.20.42.39;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2009.12.30.19.04.04;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2009.12.30.18.46.36;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2009.12.25.00.10.46;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2009.11.17.22.54.48;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2009.11.13.19.01.24;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2008.02.25.22.35.09;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2008.02.25.18.28.45;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.07.23.51.49;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2007.12.11.22.00.27;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.12.05.22.13.08;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.11.29.21.12.31;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.11.29.16.24.42;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.11.28.20.40.32;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.11.15.17.15.33;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.11.14.17.18.53;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.11.13.20.17.38;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.11.12.20.27.36;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.11.08.19.16.38;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.11.07.21.50.11;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.10.22.19.58.51;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.10.18.23.14.44;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.15.21.50.33;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.10.11.19.16.56;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.10.02.18.32.42;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.09.28.22.08.25;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.09.26.22.52.51;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.09.11.18.55.18;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.09.11.18.09.16;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.09.10.21.01.34;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.09.10.14.44.07;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.08.14.21.20.18;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.18.22.28.41;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.14.22.08.53;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.14.16.09.35;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.06.08.18.26.07;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.08.18.09.39;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.25.18.39.10;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.22.15.46.51;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.21.15.20.09;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.14.16.18.38;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.04.23.27.10;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.03.20.05.14;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.04.27.21.53.43;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.04.25.23.30.29;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.04.24.20.07.50;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.04.23.21.03.19;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.04.20.20.51.13;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.04.18.22.27.01;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.04.18.21.18.20;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.04.17.18.31.11;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.04.16.22.21.41;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.04.16.20.12.54;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.04.06.19.34.17;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.04.20.04.39;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.02.23.01.14;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.08.17.02.54;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.02.22.22.36;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.03.02.22.11.01;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.28.23.09.06;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.28.22.15.47;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.02.08.22.47.33;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.29.23.12.42;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.01.15.22.25.29;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.10.12.20.48.10;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.09.27.22.28.16;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.09.18.22.27.40;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.16.15.49.17;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.02.17.33.57;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.24.22.28.52;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2006.02.03.16.48.12;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.05.22.24.08;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.09.30.22.49.59;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.09.07.19.29.51;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.13.16.48.46;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.01.11.20.28.37;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.05.20.17.16;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.31.22.56.07;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.29.23.21.27;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.24.22.21.29;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.10.22.53.18;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.05.00.06.53;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.04.19.53.25;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.03.22.13.05;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.06.23.27.09;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.06.00.17.32;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.01.19.41.09;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.23.18.12.33;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.18.21.12.48;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.19.16.48.15;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.13.23.06.27;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.27.23.26.11;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.02.23.40.38;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.02.22.18.23;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.11.18.53.06;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.23.18.09.11;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.12.20.09.37;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.11.22.48.26;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.06.18.53.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.05.19.31.30;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.03.22.35.17;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.03.16.01.47;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.30.20.08.58;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.29.21.35.44;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.29.14.32.38;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.08.19.21.48;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.07.20.14.54;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.03.23.16.36;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.25.19.14.50;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.24.18.26.06;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.22.14.32.06;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.18.14.02.29;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.06.17.31.06;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.03.18.40.40;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.01.14.55.29;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.30.15.12.08;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.28.00.48.32;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.27.21.28.38;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.25.16.08.13;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.00.44.16;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.22.27.49;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.20;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.42;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.20;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.35;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.20;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.20;	author wit;	state Exp;
branches;
next	;


desc
@@


1.171
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Demand.C"
//
// Contains the implementation of class Demand.
//------------------------------------------------------------------------------

#include <Demand.h>
#include <CShipBS.h>
#include <OptComp.h>
#include <Timing.h>
#include <DataWrit.h>
#include <Post.h>
#include <FSS.h>
#include <OptStarter.h>
#include <PegEl.h>
#include <HeurImp.h>
#include <HeurAllMgr.h>
#include <HeurModifier.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <GlobalComp.h>
#include <Part.h>
#include <ObjStack.h>
#include <wit.h>
#include <IVRealArg.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Demand.
//------------------------------------------------------------------------------

WitDemand::WitDemand (const char * theName, WitPart * thePart):

      WitDelComp       (thePart->myCompMgr ()),
      mappingIndex_    (myCompMgr ()->nDemands ()),
      demandName_      (),
      demandedPart_    (thePart),
      demandVol_       (myProblem (), defDemandVol ()),
      priority_        (myProblem (), defPriority ()),
      searchInc_       (defSearchInc ()),
      buildAheadUB_    (myProblem (), defBuildAheadUB ()),
      leadTimeUB_      (myProblem (), defLeadTimeUB (myProblem ())),
      shipLateUB_      (myProblem (), defShipLateUB (myProblem ())),
      shipLateAllowed_ (defShipLateAllowed ()),
      prefBuildAhead_  (defPrefBuildAhead ()),
      intShipVols_     (defIntShipVols ()),
      cumShipBounds_   (NULL),
      shipReward_      (myProblem (), defShipReward ()),
      cumShipReward_   (myProblem (), defCumShipReward ()),
      shipVol_         (myProblem (), 0.0),
      focusHorizon_    (defFocusHorizon ()),
      fssShipVol_      (myProblem (), 0.0),
      cumDemandVol_    (myProblem (), 0.0),
      cumShipVol_      (myProblem (), 0.0),
      myPegElsFor_     ()
   {
   setDemandName (theName);

   cumShipBounds_ = new WitCumShipBoundSet (this);

   if (myGlobalComp ()->perfPegging ())
      buildPegEls ();

   myCompMgr    ()->insert (this);
   demandedPart ()->insert (this);
   }

//------------------------------------------------------------------------------

WitDemand::~WitDemand ()
   {
   deleteContents (myPegElsFor_);

   delete cumShipBounds_;
   }

//------------------------------------------------------------------------------

WitPeriod WitDemand::defLeadTimeUB (WitProblem * theProblem)
   {
   return theProblem->lastPeriod ();
   }

//------------------------------------------------------------------------------

WitPeriod WitDemand::defShipLateUB (WitProblem * theProblem)
   {
   return theProblem->lastPeriod ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitDemand::setDemandName (const char * theName)
   {
   WitDemand * priorDemand;

   witAssert (theName != NULL);

   witAssert (not isNullCstring (theName));

   prepSetNonUnpostAttr ();

   priorDemand = myCompMgr ()->findDemand (demandedPart_, theName);

   witAssert (priorDemand == NULL);

   demandName_ = theName;
   }

//------------------------------------------------------------------------------

void WitDemand::setDemandVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetScenSpecAttr ("demandVol");

   demandVol_ = theValue;

   compCumDemandVol ();
   }

//------------------------------------------------------------------------------

void WitDemand::setPriority (const int * theValue)
   {
   witAssert (theValue != NULL);

   prepSetUnpostAttr ();

   priority_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setSearchInc (double theValue)
   {
   witAssert (theValue >= 0.000999);

   prepSetUnpostAttr ();

   searchInc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setBuildAheadUB (const int * theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert    (theValue[thePer] >= 0);
         stronglyAssert    (theValue[thePer] <  nPeriods ());

         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }

   prepSetUnpostAttr ();

   buildAheadUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setLeadTimeUB (const int * theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert (theValue[thePer] >= 0);
         stronglyAssert (theValue[thePer] <  nPeriods ());

         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }

   prepSetUnpostAttr ();

   leadTimeUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setShipLateUB (const int * theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert (theValue[thePer] >= 0);
         stronglyAssert (theValue[thePer] <  nPeriods ());

         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] >= theValue[thePer] - 1);
         }

   prepSetUnpostAttr ();

   shipLateUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setShipLateAllowed (bool theValue)
   {
   prepSetUnpreAttr ();

   shipLateAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setPrefBuildAhead (bool theValue)
   {
   prepSetUnpostAttr ();

   prefBuildAhead_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setIntShipVols (bool theValue)
   {
   prepSetUnpreAttr ();

   intShipVols_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setShipReward (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("shipReward");

   shipReward_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setCumShipReward (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("cumShipReward");

   cumShipReward_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setShipVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   if (myProblem ()->myHeurAllMgr ()->modifiable ())
      {
      prepSetNonUnpostAttr ();

      myProblem ()->myHeurModifier ()->modifyForShipVol (this, theValue);
      }
   else
      {
      myDetOptImpMgr ()->shutDown ();

      myOptComp ()->schedOptStarter ()->beChosen ();

      prepSetUnpostAttr ();
      }

   shipVol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setFocusHorizon (int theValue)
   {
   witAssert (theValue >= -1);
   witAssert (theValue <= lastPeriod ());

   prepSetNonUnpostAttr ();

   myProblem ()->myFSS ()->uncompute ();

   focusHorizon_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::setFssShipVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetNonUnpostAttr ();

   myProblem ()->myFSS ()->uncompute ();

   fssShipVol_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitDemand::storePostCumShipVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   cumShipVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitDemand::storeOptShipVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   shipVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::storeOptCumShipVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   cumShipVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitDemand::storeStochDemandVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   demandVol_ = theFlexVec;

   compCumDemandVol ();
   }

//------------------------------------------------------------------------------

void WitDemand::storeStochShipReward (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   shipReward_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitDemand::storeStochCumShipReward (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   cumShipReward_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitDemand::storeStochShipVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   shipVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitDemand::storeStochCumShipVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   cumShipVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

bool WitDemand::inserted ()
   {
   return (demandedPart ()->myDemands ().contains (this));
   }

//------------------------------------------------------------------------------

void WitDemand::writeMultiObjVecs (WitObjective * theObj)
   {
   shipReward_   .writeDataMulti ("shipReward",    this, theObj);
   cumShipReward_.writeDataMulti ("cumShipReward", this, theObj);
   }

//------------------------------------------------------------------------------

void WitDemand::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("demandInstIDMsg"))
      myMsgFac () ("demandInstIDMsg", demandedPartName (), demandName ());
   }

//------------------------------------------------------------------------------

void WitDemand::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());
   }

//------------------------------------------------------------------------------

void WitDemand::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitPart *   thePart;
   WitDemand * theDemand;

   thePart   = theCompMgr->myMatchFor (demandedPart ());

   theDemand = new WitDemand (demandName ().myCstring (), thePart);

   theDemand->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitDemand::recount ()
   {
   mappingIndex_ = myCompMgr ()->nDemands ();

   myCompMgr ()->recountDemand (this);
   }

//------------------------------------------------------------------------------

void WitDemand::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   shipVol_    = 0.0;
   cumShipVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitDemand::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   shipVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitDemand * WitDemand::thisDemand ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitDemand::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("demandFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitDemand::apiObjItrState ()
   {
   return WitAT_DEMAND;
   }

//------------------------------------------------------------------------------

void WitDemand::copyAttrsFrom (WitDemand * theDemand)
   {
   WitDelComp::copyAttrsFrom (theDemand);

   demandVol_       = theDemand->demandVol_;
   priority_        = theDemand->priority_;
   searchInc_       = theDemand->searchInc_;
   buildAheadUB_    = theDemand->buildAheadUB_;
   leadTimeUB_      = theDemand->leadTimeUB_;
   shipLateUB_      = theDemand->shipLateUB_;
   shipLateAllowed_ = theDemand->shipLateAllowed_;
   prefBuildAhead_  = theDemand->prefBuildAhead_;
   intShipVols_     = theDemand->intShipVols_;
   shipReward_      = theDemand->shipReward_;
   cumShipReward_   = theDemand->cumShipReward_;
   focusHorizon_    = theDemand->focusHorizon_;
   cumDemandVol_    = theDemand->cumDemandVol_;
   cumShipBounds_->
      copyAttrsFrom  (theDemand->cumShipBounds_);
   }

//------------------------------------------------------------------------------

const WitString & WitDemand::demandName (const WitDemand * theDemand)
   {
   return theDemand->demandName ();
   }

//------------------------------------------------------------------------------

void WitDemand::setUpPegging ()
   {
   witAssert (myGlobalComp ()->perfPegging ());

   witAssert (not myPegElsFor_.isAllocated ());

   buildPegEls ();
   }

//------------------------------------------------------------------------------

void WitDemand::shutDownPegging ()
   {
   witAssert (not myGlobalComp ()->perfPegging ());

   witAssert (myPegElsFor_.isAllocated ());

   deleteContents (myPegElsFor_);
   }

//------------------------------------------------------------------------------

void WitDemand::extractPegEls (
      WitPeriod                shipPer,
      WitObjStack <WitPegEl> & thePegElStack)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   witAssert (thePegElStack.isEmpty ());

   thePegElStack.takeContentsFrom (myPegElsFor_ (shipPer));
   }

//------------------------------------------------------------------------------

void WitDemand::receivePegEls (
      WitPeriod                shipPer,
      WitObjStack <WitPegEl> & thePegElStack)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   witAssert (myPegElsFor_ (shipPer).isEmpty ());

   myPegElsFor_ (shipPer).takeContentsFrom (thePegElStack);
   }

//------------------------------------------------------------------------------

void WitDemand::getMyFixedPegEls (
      WitPeriod                     shipPer,
      WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   theFixedPegEls.clear ();

   myPegElsFor_ (shipPer).attachItr (theItr);

   while (theItr.advance (thePegEl))
      theFixedPegEls.push (thePegEl->myFixedPegEl ()); 
  }

//------------------------------------------------------------------------------

void WitDemand::clearPegging (WitPeriod shipPer)
   {
   deleteContents (myPegElsFor_ (shipPer));
   }

//------------------------------------------------------------------------------

double WitDemand::netRev () const
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

void WitDemand::writeSolnData ()
   {
   if (shipVol () == defShipVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());

   myDataWriter ()->writeVector       ("shipVol", shipVol (), defShipVol ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitDemand::display ()
   {
   myMsgFac () ("demandIdDdMsg",
      demandedPartName (),
      demandName_);

   myMsgFac () ("demandScalarsDdMsg",
      mappingIndex_,
      searchInc_,
      shipLateAllowed_,
      prefBuildAhead_,
      intShipVols_);

   myMsgFac ()           ("focusHorizonDdMsg",     focusHorizon_);

   myProblem ()->display ("demVolDdMsg",           demandVol_);
   myProblem ()->display ("demPriDdMsg",           priority_);
   myProblem ()->display ("buildAheadUBDdMsg",     buildAheadUB_);
   myProblem ()->display ("leadTimeUBDdMsg",       leadTimeUB_);
   myProblem ()->display ("shipLateUBDdMsg",       shipLateUB_);
   myProblem ()->display ("demShipRewardDdMsg",    shipReward_);
   myProblem ()->display ("demCumShipRewardDdMsg", cumShipReward_);

   cumShipBounds_->display ();

   WitDelComp::display ();
   }

//------------------------------------------------------------------------------

void WitDemand::genPriorities (WitProblem * theProblem)
   {
   WitDemand * theDemand;

   WitTimer::enterSection ("preproc");

   WitSchedule <WitDemand, int> newPriority (theProblem, 0);

   theProblem->prepSetUnpostAttr ();

   theProblem->myHeurImploder ()->genPriorities (newPriority);

   forEachDemand (theDemand, theProblem)
      theDemand->priority_ = newPriority (theDemand);

   WitTimer::leaveSection ("preproc");
   }

//------------------------------------------------------------------------------

void WitDemand::clearShipVolForHeur ()
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   shipVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitDemand::incShipVolForHeur (WitPeriod thePer, double incVol)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   shipVol_.elemRef (thePer) += incVol;
   }

//------------------------------------------------------------------------------

void WitDemand::initFssShipVolForPost ()
   {
   witAssert (myPostprocessor ()->postprocessing ());

   fssShipVol_ = shipVol_;
   }

//------------------------------------------------------------------------------

void WitDemand::compFssShipVol ()
   {
   myFSS ()->compFssShipVol (this, fssShipVol_);
   }

//------------------------------------------------------------------------------

void WitDemand::writeSoln ()
   {
   WitPeriod thePer;

   fprintf (solnFile (),
      "\nPart %s,  Demand %s:\n",
      demandedPartName ().myCstring (),
      demandName ().myCstring ());

   fprintf (solnFile (), "Period");

   fprintf (solnFile (),
       "    DemandVol"
       " CumDemandVol"
       "      ShipVol"
       "   CumShipVol");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (demandVol ()[thePer]);
      writeSolnValue (cumDemandVol ()[thePer]);
      writeSolnValue (shipVol ()[thePer]);
      writeSolnValue (cumShipVol ()[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

const WitString & WitDemand::demandedPartName ()
   {
   return demandedPart ()->partName ();
   }

//------------------------------------------------------------------------------

int WitDemand::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nDemands ();
   }

//------------------------------------------------------------------------------

void WitDemand::compCumDemandVol ()
   {
   double    cumSum;
   WitPeriod thePer;

   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
   }

//------------------------------------------------------------------------------

WitBoundSet * WitDemand::myBoundSet ()
   {
   return cumShipBounds_;
   }

//------------------------------------------------------------------------------

void WitDemand::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());
   }

//------------------------------------------------------------------------------

void WitDemand::writeDataAttrs ()
   {
   WitDelComp::writeDataAttrs ();

   myDataWriter ()->writeVector (
      "demandVol",
      demandVol (),
      defDemandVol ());

   myDataWriter ()->writeVector (
      "priority",
      priority (),
      defPriority ());

   myDataWriter ()->writeDouble (
      "searchInc",
      searchInc (),
      defSearchInc ());

   myDataWriter ()->writeVector (
        "buildAheadUB",
         buildAheadUB (),
      defBuildAheadUB ());

   myDataWriter ()->writeVector (
        "leadTimeUB",
         leadTimeUB (),
      defLeadTimeUB (myProblem ()));

   myDataWriter ()->writeVector (
        "shipLateUB",
         shipLateUB (),
      defShipLateUB (myProblem ()));

   myDataWriter ()->writeBool (
        "shipLateAllowed",
         shipLateAllowed (),
      defShipLateAllowed ());

   myDataWriter ()->writeBool (
        "prefBuildAhead",
         prefBuildAhead (),
      defPrefBuildAhead ());

   myDataWriter ()->writeBool (
        "intShipVols",
         intShipVols (),
      defIntShipVols ());

   cumShipBounds_->writeData ();

   myDataWriter ()->writeObjVec (
        "shipReward",
         shipReward_,
      defShipReward ());

   myDataWriter ()->writeObjVec (
        "cumShipReward",
         cumShipReward_,
      defCumShipReward ());

   myDataWriter ()->writeInt (
      "focusHorizon",
      focusHorizon (),
      defFocusHorizon ());
   }

//------------------------------------------------------------------------------

void WitDemand::findPrereqs (WitDelComp * & prereq1, WitDelComp * & prereq2)
   {
   prereq1 = demandedPart ();
   prereq2 = NULL;
   }

//------------------------------------------------------------------------------

void WitDemand::buildPegEls ()
   {
   WitPeriod shipPer;

   witAssert (myGlobalComp ()->perfPegging ());

   myPegElsFor_.allocate (myProblem ());

   forEachPeriod (shipPer, myProblem ())
      myPegElsFor_[shipPer] = new WitObjStack <WitPegEl> (myProblem ());
   }
@


1.170
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.169
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d44 33
a76 33
WitDelComp       (thePart->myCompMgr ()),
mappingIndex_    (myCompMgr ()->nDemands ()),
demandName_      (),
demandedPart_    (thePart),
demandVol_       (myProblem (), defDemandVol ()),
priority_        (myProblem (), defPriority ()),
searchInc_       (defSearchInc ()),
buildAheadUB_    (myProblem (), defBuildAheadUB ()),
leadTimeUB_      (myProblem (), defLeadTimeUB (myProblem ())),
shipLateUB_      (myProblem (), defShipLateUB (myProblem ())),
shipLateAllowed_ (defShipLateAllowed ()),
prefBuildAhead_  (defPrefBuildAhead ()),
intShipVols_     (defIntShipVols ()),
cumShipBounds_   (NULL),
shipReward_      (myProblem (), defShipReward ()),
cumShipReward_   (myProblem (), defCumShipReward ()),
shipVol_         (myProblem (), 0.0),
focusHorizon_    (defFocusHorizon ()),
fssShipVol_      (myProblem (), 0.0),
cumDemandVol_    (myProblem (), 0.0),
cumShipVol_      (myProblem (), 0.0),
myPegElsFor_     ()
{
setDemandName (theName);

cumShipBounds_ = new WitCumShipBoundSet (this);

if (myGlobalComp ()->perfPegging ())
buildPegEls ();

myCompMgr    ()->insert (this);
demandedPart ()->insert (this);
}
d81 2
a82 2
{
deleteContents (myPegElsFor_);
d84 2
a85 2
delete cumShipBounds_;
}
d90 3
a92 3
{
return theProblem->lastPeriod ();
}
d97 3
a99 3
{
return theProblem->lastPeriod ();
}
d106 2
a107 2
{
WitDemand * priorDemand;
d109 1
a109 1
witAssert (theName != NULL);
d111 1
a111 1
witAssert (not isNullCstring (theName));
d113 1
a113 1
prepSetNonUnpostAttr ();
d115 1
a115 1
priorDemand = myCompMgr ()->findDemand (demandedPart_, theName);
d117 1
a117 1
witAssert (priorDemand == NULL);
d119 2
a120 2
demandName_ = theName;
}
d125 2
a126 2
{
witAssert (theValue != NULL);
d128 1
a128 1
witAssert (theValue.isNonNeg (nPeriods ()));
d130 1
a130 1
prepSetScenSpecAttr ("demandVol");
d132 1
a132 1
demandVol_ = theValue;
d134 2
a135 2
compCumDemandVol ();
}
d140 2
a141 2
{
witAssert (theValue != NULL);
d143 1
a143 1
prepSetUnpostAttr ();
d145 2
a146 2
priority_ = theValue;
}
d151 2
a152 2
{
witAssert (theValue >= 0.000999);
d154 1
a154 1
prepSetUnpostAttr ();
d156 2
a157 2
searchInc_ = theValue;
}
d162 2
a163 2
{
WitPeriod thePer;
d165 1
a165 1
witAssert (theValue != NULL);
d167 5
a171 5
if (DEBUG_MODE)
forEachPeriod (thePer, myProblem ())
{
stronglyAssert    (theValue[thePer] >= 0);
stronglyAssert    (theValue[thePer] <  nPeriods ());
d173 3
a175 3
if (thePer <= nPeriods () - 2)
stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
}
d177 1
a177 1
prepSetUnpostAttr ();
d179 2
a180 2
buildAheadUB_ = theValue;
}
d185 2
a186 2
{
WitPeriod thePer;
d188 1
a188 1
witAssert (theValue != NULL);
d190 5
a194 5
if (DEBUG_MODE)
forEachPeriod (thePer, myProblem ())
{
stronglyAssert (theValue[thePer] >= 0);
stronglyAssert (theValue[thePer] <  nPeriods ());
d196 3
a198 3
if (thePer <= nPeriods () - 2)
stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
}
d200 1
a200 1
prepSetUnpostAttr ();
d202 2
a203 2
leadTimeUB_ = theValue;
}
d208 2
a209 2
{
WitPeriod thePer;
d211 1
a211 1
witAssert (theValue != NULL);
d213 5
a217 5
if (DEBUG_MODE)
forEachPeriod (thePer, myProblem ())
{
stronglyAssert (theValue[thePer] >= 0);
stronglyAssert (theValue[thePer] <  nPeriods ());
d219 3
a221 3
if (thePer <= nPeriods () - 2)
stronglyAssert (theValue[thePer + 1] >= theValue[thePer] - 1);
}
d223 1
a223 1
prepSetUnpostAttr ();
d225 2
a226 2
shipLateUB_ = theValue;
}
d231 2
a232 2
{
prepSetUnpreAttr ();
d234 2
a235 2
shipLateAllowed_ = theValue;
}
d240 2
a241 2
{
prepSetUnpostAttr ();
d243 2
a244 2
prefBuildAhead_ = theValue;
}
d249 2
a250 2
{
prepSetUnpreAttr ();
d252 2
a253 2
intShipVols_ = theValue;
}
d258 2
a259 2
{
witAssert (theValue != NULL);
d261 1
a261 1
prepSetScenSpecAttr ("shipReward");
d263 2
a264 2
shipReward_.curDblFlexVec () = theValue;
}
d269 2
a270 2
{
witAssert (theValue != NULL);
d272 1
a272 1
prepSetScenSpecAttr ("cumShipReward");
d274 2
a275 2
cumShipReward_.curDblFlexVec () = theValue;
}
d280 2
a281 2
{
witAssert (theValue != NULL);
d283 1
a283 1
witAssert (theValue.isNonNeg (nPeriods ()));
d285 3
a287 3
if (myProblem ()->myHeurAllMgr ()->modifiable ())
{
prepSetNonUnpostAttr ();
d289 5
a293 5
myProblem ()->myHeurModifier ()->modifyForShipVol (this, theValue);
}
else
{
myDetOptImpMgr ()->shutDown ();
d295 1
a295 1
myOptComp ()->schedOptStarter ()->beChosen ();
d297 2
a298 2
prepSetUnpostAttr ();
}
d300 2
a301 2
shipVol_ = theValue;
}
d306 3
a308 3
{
witAssert (theValue >= -1);
witAssert (theValue <= lastPeriod ());
d310 1
a310 1
prepSetNonUnpostAttr ();
d312 1
a312 1
myProblem ()->myFSS ()->uncompute ();
d314 2
a315 2
focusHorizon_ = theValue;
}
d320 2
a321 2
{
witAssert (theValue != NULL);
d323 1
a323 1
witAssert (theValue.isNonNeg (nPeriods ()));
d325 1
a325 1
prepSetNonUnpostAttr ();
d327 1
a327 1
myProblem ()->myFSS ()->uncompute ();
d329 2
a330 2
fssShipVol_ = theValue;
}
d337 2
a338 2
{
witAssert (myPostprocessor ()->postprocessing ());
d340 2
a341 2
cumShipVol_ = theTVec;
}
d346 2
a347 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d349 2
a350 2
shipVol_.elemRef (thePer) = theValue;
}
d355 2
a356 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d358 2
a359 2
cumShipVol_.elemRef (thePer) = theValue;
}
d364 2
a365 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d367 1
a367 1
demandVol_ = theFlexVec;
d369 2
a370 2
compCumDemandVol ();
}
d375 2
a376 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d378 2
a379 2
shipReward_.curDblFlexVec () = theFlexVec;
}
d384 2
a385 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d387 2
a388 2
cumShipReward_.curDblFlexVec () = theFlexVec;
}
d393 2
a394 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d396 2
a397 2
shipVol_ = theFlexVec;
}
d402 2
a403 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d405 2
a406 2
cumShipVol_ = theFlexVec;
}
d411 3
a413 3
{
return (demandedPart ()->myDemands ().contains (this));
}
d418 4
a421 4
{
shipReward_   .writeDataMulti ("shipReward",    this, theObj);
cumShipReward_.writeDataMulti ("cumShipReward", this, theObj);
}
d426 4
a429 4
{
if (myMsgFac ().mayIssue ("demandInstIDMsg"))
myMsgFac () ("demandInstIDMsg", demandedPartName (), demandName ());
}
d434 6
a439 6
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("demand");
myDataWriter ()->writeStringValue  (demandedPartName ());
myDataWriter ()->writeStringValue  (demandName ());
}
d444 3
a446 3
{
WitPart *   thePart;
WitDemand * theDemand;
d448 1
a448 1
thePart   = theCompMgr->myMatchFor (demandedPart ());
d450 1
a450 1
theDemand = new WitDemand (demandName ().myCstring (), thePart);
d452 2
a453 2
theDemand->copyAttrsFrom (this);
}
d458 2
a459 2
{
mappingIndex_ = myCompMgr ()->nDemands ();
d461 2
a462 2
myCompMgr ()->recountDemand (this);
}
d467 2
a468 2
{
witAssert (myDetOptImpMgr ()->clearingSoln ());
d470 3
a472 3
shipVol_    = 0.0;
cumShipVol_ = 0.0;
}
d477 2
a478 2
{
WitComponent::clearStochSoln ();
d480 2
a481 2
shipVol_ = 0.0;
}
d486 3
a488 3
{
return this;
}
d493 3
a495 3
{
return myMsgFac ().myFrag ("demandFrag");
}
d500 3
a502 3
{
return WitAT_DEMAND;
}
d507 2
a508 2
{
WitDelComp::copyAttrsFrom (theDemand);
d510 16
a525 16
demandVol_       = theDemand->demandVol_;
priority_        = theDemand->priority_;
searchInc_       = theDemand->searchInc_;
buildAheadUB_    = theDemand->buildAheadUB_;
leadTimeUB_      = theDemand->leadTimeUB_;
shipLateUB_      = theDemand->shipLateUB_;
shipLateAllowed_ = theDemand->shipLateAllowed_;
prefBuildAhead_  = theDemand->prefBuildAhead_;
intShipVols_     = theDemand->intShipVols_;
shipReward_      = theDemand->shipReward_;
cumShipReward_   = theDemand->cumShipReward_;
focusHorizon_    = theDemand->focusHorizon_;
cumDemandVol_    = theDemand->cumDemandVol_;
cumShipBounds_->
copyAttrsFrom  (theDemand->cumShipBounds_);
}
d530 3
a532 3
{
return theDemand->demandName ();
}
d537 2
a538 2
{
witAssert (myGlobalComp ()->perfPegging ());
d540 1
a540 1
witAssert (not myPegElsFor_.isAllocated ());
d542 2
a543 2
buildPegEls ();
}
d548 2
a549 2
{
witAssert (not myGlobalComp ()->perfPegging ());
d551 1
a551 1
witAssert (myPegElsFor_.isAllocated ());
d553 2
a554 2
deleteContents (myPegElsFor_);
}
d559 4
a562 4
WitPeriod                shipPer,
WitObjStack <WitPegEl> & thePegElStack)
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d564 1
a564 1
witAssert (thePegElStack.isEmpty ());
d566 2
a567 2
thePegElStack.takeContentsFrom (myPegElsFor_ (shipPer));
}
d572 4
a575 4
WitPeriod                shipPer,
WitObjStack <WitPegEl> & thePegElStack)
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d577 1
a577 1
witAssert (myPegElsFor_ (shipPer).isEmpty ());
d579 2
a580 2
myPegElsFor_ (shipPer).takeContentsFrom (thePegElStack);
}
d585 13
a597 13
WitPeriod                     shipPer,
WitObjStack <WitFixedPegEl> & theFixedPegEls)
{
WitObjStItr <WitPegEl> theItr;
WitPegEl *             thePegEl;

theFixedPegEls.clear ();

myPegElsFor_ (shipPer).attachItr (theItr);

while (theItr.advance (thePegEl))
theFixedPegEls.push (thePegEl->myFixedPegEl ());
}
d602 3
a604 3
{
deleteContents (myPegElsFor_ (shipPer));
}
d609 3
a611 3
{
return 0.0;
}
d616 8
a623 8
{
if (shipVol () == defShipVol ())
return;

myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("demand");
myDataWriter ()->writeStringValue  (demandedPartName ());
myDataWriter ()->writeStringValue  (demandName ());
d625 1
a625 1
myDataWriter ()->writeVector       ("shipVol", shipVol (), defShipVol ());
d627 2
a628 2
myDataWriter ()->writeEndCommand ();
}
d633 21
a653 21
{
myMsgFac () ("demandIdDdMsg",
demandedPartName (),
demandName_);

myMsgFac () ("demandScalarsDdMsg",
mappingIndex_,
searchInc_,
shipLateAllowed_,
prefBuildAhead_,
intShipVols_);

myMsgFac ()           ("focusHorizonDdMsg",     focusHorizon_);

myProblem ()->display ("demVolDdMsg",           demandVol_);
myProblem ()->display ("demPriDdMsg",           priority_);
myProblem ()->display ("buildAheadUBDdMsg",     buildAheadUB_);
myProblem ()->display ("leadTimeUBDdMsg",       leadTimeUB_);
myProblem ()->display ("shipLateUBDdMsg",       shipLateUB_);
myProblem ()->display ("demShipRewardDdMsg",    shipReward_);
myProblem ()->display ("demCumShipRewardDdMsg", cumShipReward_);
d655 1
a655 1
cumShipBounds_->display ();
d657 2
a658 2
WitDelComp::display ();
}
d663 2
a664 2
{
WitDemand * theDemand;
d666 1
a666 1
WitTimer::enterSection ("preproc");
d668 1
a668 1
WitSchedule <WitDemand, int> newPriority (theProblem, 0);
d670 1
a670 1
theProblem->prepSetUnpostAttr ();
d672 1
a672 1
theProblem->myHeurImploder ()->genPriorities (newPriority);
d674 2
a675 2
forEachDemand (theDemand, theProblem)
theDemand->priority_ = newPriority (theDemand);
d677 2
a678 2
WitTimer::leaveSection ("preproc");
}
d683 2
a684 2
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d686 2
a687 2
shipVol_ = 0.0;
}
d692 2
a693 2
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d695 2
a696 2
shipVol_.elemRef (thePer) += incVol;
}
d701 2
a702 2
{
witAssert (myPostprocessor ()->postprocessing ());
d704 2
a705 2
fssShipVol_ = shipVol_;
}
d710 3
a712 3
{
myFSS ()->compFssShipVol (this, fssShipVol_);
}
d717 2
a718 2
{
WitPeriod thePer;
d720 27
a746 27
fprintf (solnFile (),
"\nPart %s,  Demand %s:\n",
demandedPartName ().myCstring (),
demandName ().myCstring ());

fprintf (solnFile (), "Period");

fprintf (solnFile (),
"    DemandVol"
" CumDemandVol"
"      ShipVol"
"   CumShipVol");

fprintf (solnFile (), "\n");

forEachPeriod (thePer, myProblem ())
{
fprintf (solnFile (), "%6d", thePer);

writeSolnValue (demandVol ()[thePer]);
writeSolnValue (cumDemandVol ()[thePer]);
writeSolnValue (shipVol ()[thePer]);
writeSolnValue (cumShipVol ()[thePer]);

fprintf (solnFile (), "\n");
}
}
d751 3
a753 3
{
return demandedPart ()->partName ();
}
d758 3
a760 3
{
return theProblem->myCompMgr ()->nDemands ();
}
d765 18
a782 18
{
double    cumSum;
WitPeriod thePer;

if (demandVol_ == 0.0)
cumDemandVol_ = 0.0;
else
{
cumSum = 0.0;

forEachPeriod (thePer, myProblem ())
{
cumSum += demandVol_[thePer];

cumDemandVol_.elemRef (thePer) = cumSum;
}
}
}
d787 3
a789 3
{
return cumShipBounds_;
}
d794 6
a799 6
{
myDataWriter ()->writeFirstKeyWord ("add");
myDataWriter ()->writeKeyWord      ("demand");
myDataWriter ()->writeStringValue  (demandedPartName ());
myDataWriter ()->writeStringValue  (demandName ());
}
d804 2
a805 2
{
WitDelComp::writeDataAttrs ();
d807 62
a868 62
myDataWriter ()->writeVector (
"demandVol",
demandVol (),
defDemandVol ());

myDataWriter ()->writeVector (
"priority",
priority (),
defPriority ());

myDataWriter ()->writeDouble (
"searchInc",
searchInc (),
defSearchInc ());

myDataWriter ()->writeVector (
"buildAheadUB",
buildAheadUB (),
defBuildAheadUB ());

myDataWriter ()->writeVector (
"leadTimeUB",
leadTimeUB (),
defLeadTimeUB (myProblem ()));

myDataWriter ()->writeVector (
"shipLateUB",
shipLateUB (),
defShipLateUB (myProblem ()));

myDataWriter ()->writeBool (
"shipLateAllowed",
shipLateAllowed (),
defShipLateAllowed ());

myDataWriter ()->writeBool (
"prefBuildAhead",
prefBuildAhead (),
defPrefBuildAhead ());

myDataWriter ()->writeBool (
"intShipVols",
intShipVols (),
defIntShipVols ());

cumShipBounds_->writeData ();

myDataWriter ()->writeObjVec (
"shipReward",
shipReward_,
defShipReward ());

myDataWriter ()->writeObjVec (
"cumShipReward",
cumShipReward_,
defCumShipReward ());

myDataWriter ()->writeInt (
"focusHorizon",
focusHorizon (),
defFocusHorizon ());
}
d873 4
a876 4
{
prereq1 = demandedPart ();
prereq2 = NULL;
}
d881 2
a882 2
{
WitPeriod shipPer;
d884 1
a884 1
witAssert (myGlobalComp ()->perfPegging ());
d886 1
a886 1
myPegElsFor_.allocate (myProblem ());
d888 3
a890 3
forEachPeriod (shipPer, myProblem ())
myPegElsFor_[shipPer] = new WitObjStack <WitPegEl> (myProblem ());
}
@


1.168
log
@Fixed a bug in optInitMethod
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d44 33
a76 33
      WitDelComp       (thePart->myCompMgr ()),
      mappingIndex_    (myCompMgr ()->nDemands ()),
      demandName_      (),
      demandedPart_    (thePart),
      demandVol_       (myProblem (), defDemandVol ()),
      priority_        (myProblem (), defPriority ()),
      searchInc_       (defSearchInc ()),
      buildAheadUB_    (myProblem (), defBuildAheadUB ()),
      leadTimeUB_      (myProblem (), defLeadTimeUB (myProblem ())),
      shipLateUB_      (myProblem (), defShipLateUB (myProblem ())),
      shipLateAllowed_ (defShipLateAllowed ()),
      prefBuildAhead_  (defPrefBuildAhead ()),
      intShipVols_     (defIntShipVols ()),
      cumShipBounds_   (NULL),
      shipReward_      (myProblem (), defShipReward ()),
      cumShipReward_   (myProblem (), defCumShipReward ()),
      shipVol_         (myProblem (), 0.0),
      focusHorizon_    (defFocusHorizon ()),
      fssShipVol_      (myProblem (), 0.0),
      cumDemandVol_    (myProblem (), 0.0),
      cumShipVol_      (myProblem (), 0.0),
      myPegElsFor_     ()
   {
   setDemandName (theName);

   cumShipBounds_ = new WitCumShipBoundSet (this);

   if (myGlobalComp ()->perfPegging ())
      buildPegEls ();

   myCompMgr    ()->insert (this);
   demandedPart ()->insert (this);
   }
d81 2
a82 2
   {
   deleteContents (myPegElsFor_);
d84 2
a85 2
   delete cumShipBounds_;
   }
d90 3
a92 3
   {
   return theProblem->lastPeriod ();
   }
d97 3
a99 3
   {
   return theProblem->lastPeriod ();
   }
d106 2
a107 2
   {
   WitDemand * priorDemand;
d109 1
a109 1
   witAssert (theName != NULL);
d111 1
a111 1
   witAssert (not isNullCstring (theName));
d113 1
a113 1
   prepSetNonUnpostAttr ();
d115 1
a115 1
   priorDemand = myCompMgr ()->findDemand (demandedPart_, theName);
d117 1
a117 1
   witAssert (priorDemand == NULL);
d119 2
a120 2
   demandName_ = theName;
   }
d125 2
a126 2
   {
   witAssert (theValue != NULL);
d128 1
a128 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d130 1
a130 1
   prepSetScenSpecAttr ("demandVol");
d132 1
a132 1
   demandVol_ = theValue;
d134 2
a135 2
   compCumDemandVol ();
   }
d140 2
a141 2
   {
   witAssert (theValue != NULL);
d143 1
a143 1
   prepSetUnpostAttr ();
d145 2
a146 2
   priority_ = theValue;
   }
d151 2
a152 2
   {
   witAssert (theValue >= 0.000999);
d154 1
a154 1
   prepSetUnpostAttr ();
d156 2
a157 2
   searchInc_ = theValue;
   }
d162 2
a163 2
   {
   WitPeriod thePer;
d165 1
a165 1
   witAssert (theValue != NULL);
d167 5
a171 5
   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert    (theValue[thePer] >= 0);
         stronglyAssert    (theValue[thePer] <  nPeriods ());
d173 3
a175 3
         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }
d177 1
a177 1
   prepSetUnpostAttr ();
d179 2
a180 2
   buildAheadUB_ = theValue;
   }
d185 2
a186 2
   {
   WitPeriod thePer;
d188 1
a188 1
   witAssert (theValue != NULL);
d190 5
a194 5
   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert (theValue[thePer] >= 0);
         stronglyAssert (theValue[thePer] <  nPeriods ());
d196 3
a198 3
         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }
d200 1
a200 1
   prepSetUnpostAttr ();
d202 2
a203 2
   leadTimeUB_ = theValue;
   }
d208 2
a209 2
   {
   WitPeriod thePer;
d211 1
a211 1
   witAssert (theValue != NULL);
d213 5
a217 5
   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         stronglyAssert (theValue[thePer] >= 0);
         stronglyAssert (theValue[thePer] <  nPeriods ());
d219 3
a221 3
         if (thePer <= nPeriods () - 2)
            stronglyAssert (theValue[thePer + 1] >= theValue[thePer] - 1);
         }
d223 1
a223 1
   prepSetUnpostAttr ();
d225 2
a226 2
   shipLateUB_ = theValue;
   }
d231 2
a232 2
   {
   prepSetUnpreAttr ();
d234 2
a235 2
   shipLateAllowed_ = theValue;
   }
d240 2
a241 2
   {
   prepSetUnpostAttr ();
d243 2
a244 2
   prefBuildAhead_ = theValue;
   }
d249 2
a250 2
   {
   prepSetUnpreAttr ();
d252 2
a253 2
   intShipVols_ = theValue;
   }
d258 2
a259 2
   {
   witAssert (theValue != NULL);
d261 1
a261 1
   prepSetScenSpecAttr ("shipReward");
d263 2
a264 2
   shipReward_.curDblFlexVec () = theValue;
   }
d269 2
a270 2
   {
   witAssert (theValue != NULL);
d272 1
a272 1
   prepSetScenSpecAttr ("cumShipReward");
d274 2
a275 2
   cumShipReward_.curDblFlexVec () = theValue;
   }
d280 2
a281 2
   {
   witAssert (theValue != NULL);
d283 1
a283 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d285 3
a287 3
   if (myProblem ()->myHeurAllMgr ()->modifiable ())
      {
      prepSetNonUnpostAttr ();
d289 5
a293 5
      myProblem ()->myHeurModifier ()->modifyForShipVol (this, theValue);
      }
   else
      {
      myDetOptImpMgr ()->shutDown ();
d295 1
a295 1
      myOptComp ()->schedOptStarter ()->beChosen ();
d297 2
a298 2
      prepSetUnpostAttr ();
      }
d300 2
a301 2
   shipVol_ = theValue;
   }
d306 3
a308 3
   {
   witAssert (theValue >= -1);
   witAssert (theValue <= lastPeriod ());
d310 1
a310 1
   prepSetNonUnpostAttr ();
d312 1
a312 1
   myProblem ()->myFSS ()->uncompute ();
d314 2
a315 2
   focusHorizon_ = theValue;
   }
d320 2
a321 2
   {
   witAssert (theValue != NULL);
d323 1
a323 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d325 1
a325 1
   prepSetNonUnpostAttr ();
d327 1
a327 1
   myProblem ()->myFSS ()->uncompute ();
d329 2
a330 2
   fssShipVol_ = theValue;
   }
d337 2
a338 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d340 2
a341 2
   cumShipVol_ = theTVec;
   }
d346 2
a347 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d349 2
a350 2
   shipVol_.elemRef (thePer) = theValue;
   }
d355 2
a356 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d358 2
a359 2
   cumShipVol_.elemRef (thePer) = theValue;
   }
d364 2
a365 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d367 1
a367 1
   demandVol_ = theFlexVec;
d369 2
a370 2
   compCumDemandVol ();
   }
d375 2
a376 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d378 2
a379 2
   shipReward_.curDblFlexVec () = theFlexVec;
   }
d384 2
a385 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d387 2
a388 2
   cumShipReward_.curDblFlexVec () = theFlexVec;
   }
d393 2
a394 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d396 2
a397 2
   shipVol_ = theFlexVec;
   }
d402 2
a403 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d405 2
a406 2
   cumShipVol_ = theFlexVec;
   }
d411 3
a413 3
   {
   return (demandedPart ()->myDemands ().contains (this));
   }
d418 4
a421 4
   {
   shipReward_   .writeDataMulti ("shipReward",    this, theObj);
   cumShipReward_.writeDataMulti ("cumShipReward", this, theObj);
   }
d426 4
a429 4
   {
   if (myMsgFac ().mayIssue ("demandInstIDMsg"))
      myMsgFac () ("demandInstIDMsg", demandedPartName (), demandName ());
   }
d434 6
a439 6
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());
   }
d444 3
a446 3
   {
   WitPart *   thePart;
   WitDemand * theDemand;
d448 1
a448 1
   thePart   = theCompMgr->myMatchFor (demandedPart ());
d450 1
a450 1
   theDemand = new WitDemand (demandName ().myCstring (), thePart);
d452 2
a453 2
   theDemand->copyAttrsFrom (this);
   }
d458 2
a459 2
   {
   mappingIndex_ = myCompMgr ()->nDemands ();
d461 2
a462 2
   myCompMgr ()->recountDemand (this);
   }
d467 2
a468 2
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());
d470 3
a472 3
   shipVol_    = 0.0;
   cumShipVol_ = 0.0;
   }
d477 2
a478 2
   {
   WitComponent::clearStochSoln ();
d480 2
a481 2
   shipVol_ = 0.0;
   }
d486 3
a488 3
   {
   return this;
   }
d493 3
a495 3
   {
   return myMsgFac ().myFrag ("demandFrag");
   }
d500 3
a502 3
   {
   return WitAT_DEMAND;
   }
d507 2
a508 2
   {
   WitDelComp::copyAttrsFrom (theDemand);
d510 16
a525 16
   demandVol_       = theDemand->demandVol_;
   priority_        = theDemand->priority_;
   searchInc_       = theDemand->searchInc_;
   buildAheadUB_    = theDemand->buildAheadUB_;
   leadTimeUB_      = theDemand->leadTimeUB_;
   shipLateUB_      = theDemand->shipLateUB_;
   shipLateAllowed_ = theDemand->shipLateAllowed_;
   prefBuildAhead_  = theDemand->prefBuildAhead_;
   intShipVols_     = theDemand->intShipVols_;
   shipReward_      = theDemand->shipReward_;
   cumShipReward_   = theDemand->cumShipReward_;
   focusHorizon_    = theDemand->focusHorizon_;
   cumDemandVol_    = theDemand->cumDemandVol_;
   cumShipBounds_->
      copyAttrsFrom  (theDemand->cumShipBounds_);
   }
d530 3
a532 3
   {
   return theDemand->demandName ();
   }
d537 2
a538 2
   {
   witAssert (myGlobalComp ()->perfPegging ());
d540 1
a540 1
   witAssert (not myPegElsFor_.isAllocated ());
d542 2
a543 2
   buildPegEls ();
   }
d548 2
a549 2
   {
   witAssert (not myGlobalComp ()->perfPegging ());
d551 1
a551 1
   witAssert (myPegElsFor_.isAllocated ());
d553 2
a554 2
   deleteContents (myPegElsFor_);
   }
d559 4
a562 4
      WitPeriod                shipPer,
      WitObjStack <WitPegEl> & thePegElStack)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d564 1
a564 1
   witAssert (thePegElStack.isEmpty ());
d566 2
a567 2
   thePegElStack.takeContentsFrom (myPegElsFor_ (shipPer));
   }
d572 4
a575 4
      WitPeriod                shipPer,
      WitObjStack <WitPegEl> & thePegElStack)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d577 1
a577 1
   witAssert (myPegElsFor_ (shipPer).isEmpty ());
d579 2
a580 2
   myPegElsFor_ (shipPer).takeContentsFrom (thePegElStack);
   }
d585 13
a597 13
      WitPeriod                     shipPer,
      WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   theFixedPegEls.clear ();

   myPegElsFor_ (shipPer).attachItr (theItr);

   while (theItr.advance (thePegEl))
      theFixedPegEls.push (thePegEl->myFixedPegEl ()); 
  }
d602 3
a604 3
   {
   deleteContents (myPegElsFor_ (shipPer));
   }
d609 3
a611 3
   {
   return 0.0;
   }
d616 8
a623 8
   {
   if (shipVol () == defShipVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());
d625 1
a625 1
   myDataWriter ()->writeVector       ("shipVol", shipVol (), defShipVol ());
d627 2
a628 2
   myDataWriter ()->writeEndCommand ();
   }
d633 21
a653 21
   {
   myMsgFac () ("demandIdDdMsg",
      demandedPartName (),
      demandName_);

   myMsgFac () ("demandScalarsDdMsg",
      mappingIndex_,
      searchInc_,
      shipLateAllowed_,
      prefBuildAhead_,
      intShipVols_);

   myMsgFac ()           ("focusHorizonDdMsg",     focusHorizon_);

   myProblem ()->display ("demVolDdMsg",           demandVol_);
   myProblem ()->display ("demPriDdMsg",           priority_);
   myProblem ()->display ("buildAheadUBDdMsg",     buildAheadUB_);
   myProblem ()->display ("leadTimeUBDdMsg",       leadTimeUB_);
   myProblem ()->display ("shipLateUBDdMsg",       shipLateUB_);
   myProblem ()->display ("demShipRewardDdMsg",    shipReward_);
   myProblem ()->display ("demCumShipRewardDdMsg", cumShipReward_);
d655 1
a655 1
   cumShipBounds_->display ();
d657 2
a658 2
   WitDelComp::display ();
   }
d663 2
a664 2
   {
   WitDemand * theDemand;
d666 1
a666 1
   WitTimer::enterSection ("preproc");
d668 1
a668 1
   WitSchedule <WitDemand, int> newPriority (theProblem, 0);
d670 1
a670 1
   theProblem->prepSetUnpostAttr ();
d672 1
a672 1
   theProblem->myHeurImploder ()->genPriorities (newPriority);
d674 2
a675 2
   forEachDemand (theDemand, theProblem)
      theDemand->priority_ = newPriority (theDemand);
d677 2
a678 2
   WitTimer::leaveSection ("preproc");
   }
d683 2
a684 2
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d686 2
a687 2
   shipVol_ = 0.0;
   }
d692 2
a693 2
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d695 2
a696 2
   shipVol_.elemRef (thePer) += incVol;
   }
d701 2
a702 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d704 2
a705 2
   fssShipVol_ = shipVol_;
   }
d710 3
a712 3
   {
   myFSS ()->compFssShipVol (this, fssShipVol_);
   }
d717 2
a718 2
   {
   WitPeriod thePer;
d720 27
a746 27
   fprintf (solnFile (),
      "\nPart %s,  Demand %s:\n",
      demandedPartName ().myCstring (),
      demandName ().myCstring ());

   fprintf (solnFile (), "Period");

   fprintf (solnFile (),
       "    DemandVol"
       " CumDemandVol"
       "      ShipVol"
       "   CumShipVol");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (demandVol ()[thePer]);
      writeSolnValue (cumDemandVol ()[thePer]);
      writeSolnValue (shipVol ()[thePer]);
      writeSolnValue (cumShipVol ()[thePer]);

      fprintf (solnFile (), "\n");
      }
   }
d751 3
a753 3
   {
   return demandedPart ()->partName ();
   }
d758 3
a760 3
   {
   return theProblem->myCompMgr ()->nDemands ();
   }
d765 18
a782 18
   {
   double    cumSum;
   WitPeriod thePer;

   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
   }
d787 3
a789 3
   {
   return cumShipBounds_;
   }
d794 6
a799 6
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName ());
   }
d804 2
a805 2
   {
   WitDelComp::writeDataAttrs ();
d807 62
a868 62
   myDataWriter ()->writeVector (
      "demandVol",
      demandVol (),
      defDemandVol ());

   myDataWriter ()->writeVector (
      "priority",
      priority (),
      defPriority ());

   myDataWriter ()->writeDouble (
      "searchInc",
      searchInc (),
      defSearchInc ());

   myDataWriter ()->writeVector (
        "buildAheadUB",
         buildAheadUB (),
      defBuildAheadUB ());

   myDataWriter ()->writeVector (
        "leadTimeUB",
         leadTimeUB (),
      defLeadTimeUB (myProblem ()));

   myDataWriter ()->writeVector (
        "shipLateUB",
         shipLateUB (),
      defShipLateUB (myProblem ()));

   myDataWriter ()->writeBool (
        "shipLateAllowed",
         shipLateAllowed (),
      defShipLateAllowed ());

   myDataWriter ()->writeBool (
        "prefBuildAhead",
         prefBuildAhead (),
      defPrefBuildAhead ());

   myDataWriter ()->writeBool (
        "intShipVols",
         intShipVols (),
      defIntShipVols ());

   cumShipBounds_->writeData ();

   myDataWriter ()->writeObjVec (
        "shipReward",
         shipReward_,
      defShipReward ());

   myDataWriter ()->writeObjVec (
        "cumShipReward",
         cumShipReward_,
      defCumShipReward ());

   myDataWriter ()->writeInt (
      "focusHorizon",
      focusHorizon (),
      defFocusHorizon ());
   }
d873 4
a876 4
   {
   prereq1 = demandedPart ();
   prereq2 = NULL;
   }
d881 2
a882 2
   {
   WitPeriod shipPer;
d884 1
a884 1
   witAssert (myGlobalComp ()->perfPegging ());
d886 1
a886 1
   myPegElsFor_.allocate (myProblem ());
d888 3
a890 3
   forEachPeriod (shipPer, myProblem ())
      myPegElsFor_[shipPer] = new WitObjStack <WitPegEl> (myProblem ());
   }
@


1.167
log
@Modifiable heuristic allocation
@
text
@d293 2
@


1.166
log
@Heuristic Adjustment
@
text
@d27 1
a27 1
#include <HeurAdjuster.h>
d285 1
a285 1
   if (myProblem ()->myHeurAllMgr ()->adjustMode ())
d289 1
a289 1
      myProblem ()->myHeurAdjuster ()->adjustForShipVol (this, theValue);
@


1.165
log
@Heuristic Adjustment
@
text
@d285 1
a285 1
   if (myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
@


1.164
log
@Heuristic Adjustment
@
text
@d285 1
a285 1
   if (myProblem ()->myHeurAdjuster ()->active ())
@


1.163
log
@Heuristic Adjustment
@
text
@d27 1
a27 1
#include <HeurAdjMgr.h>
d285 1
a285 1
   if (myProblem ()->myHeurAdjMgr ()->active ())
d289 1
a289 1
      myProblem ()->myHeurAdjMgr ()->adjustForShipVol (this, theValue);
@


1.162
log
@Heuristic Adjustment
@
text
@d288 2
@


1.161
log
@Lead Time Bounds
@
text
@d27 1
d285 7
a291 1
   myOptComp ()->schedOptStarter ()->beChosen ();
d293 2
a294 1
   prepSetUnpostAttr ();
@


1.160
log
@Lead Time Bounds.
@
text
@d169 2
a170 2
         witAssert    (theValue[thePer] >= 0);
         witAssert    (theValue[thePer] <  nPeriods ());
d172 2
a173 2
         if (thePer > 0)
            witAssert (theValue[thePer] <= theValue[thePer - 1] + 1);
d218 2
a219 2
         if (thePer > 0)
            stronglyAssert (theValue[thePer] >= theValue[thePer - 1] - 1);
@


1.159
log
@Bounded Lead Times
@
text
@d195 2
a196 2
         if (thePer > 0)
            stronglyAssert (theValue[thePer] <= theValue[thePer - 1] + 1);
@


1.158
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d51 1
d88 7
d183 23
d215 2
a216 2
         witAssert    (theValue[thePer] >= 0);
         witAssert    (theValue[thePer] <  nPeriods ());
d219 1
a219 1
            witAssert (theValue[thePer] >= theValue[thePer - 1] - 1);
d502 1
d638 1
d816 5
@


1.157
log
@Multi-objective mode
@
text
@d29 1
a29 1
#include <Global.h>
@


1.156
log
@Multi-Objective Mode
@
text
@d43 21
a63 21
      WitDelComp           (thePart->myCompMgr ()),
      mappingIndex_        (myCompMgr ()->nDemands ()),
      demandName_          (),
      demandedPart_        (thePart),
      demandVol_           (myProblem (), defDemandVol ()),
      priority_            (myProblem (), defPriority ()),
      searchInc_           (defSearchInc ()),
      buildAheadUB_        (myProblem (), defBuildAheadUB ()),
      shipLateUB_          (myProblem (), defShipLateUB (myProblem ())),
      shipLateAllowed_     (defShipLateAllowed ()),
      prefBuildAhead_      (defPrefBuildAhead ()),
      intShipVols_         (defIntShipVols ()),
      cumShipBounds_       (NULL),
      shipRewardObjVec_    (myProblem (), defShipReward ()),
      cumShipRewardObjVec_ (myProblem (), defCumShipReward ()),
      shipVol_             (myProblem (), 0.0),
      focusHorizon_        (defFocusHorizon ()),
      fssShipVol_          (myProblem (), 0.0),
      cumDemandVol_        (myProblem (), 0.0),
      cumShipVol_          (myProblem (), 0.0),
      myPegElsFor_         ()
d231 1
a231 1
   shipRewardObjVec_ = theValue;
d242 1
a242 1
   cumShipRewardObjVec_ = theValue;
d335 1
a335 1
   shipRewardObjVec_ = theFlexVec;
d344 1
a344 1
   cumShipRewardObjVec_ = theFlexVec;
d376 2
a377 2
   shipRewardObjVec_   .writeDataMulti ("shipReward",    this, theObj);
   cumShipRewardObjVec_.writeDataMulti ("cumShipReward", this, theObj);
d467 12
a478 12
   demandVol_           = theDemand->demandVol_;
   priority_            = theDemand->priority_;
   searchInc_           = theDemand->searchInc_;
   buildAheadUB_        = theDemand->buildAheadUB_;
   shipLateUB_          = theDemand->shipLateUB_;
   shipLateAllowed_     = theDemand->shipLateAllowed_;
   prefBuildAhead_      = theDemand->prefBuildAhead_;
   intShipVols_         = theDemand->intShipVols_;
   shipRewardObjVec_    = theDemand->shipRewardObjVec_;
   cumShipRewardObjVec_ = theDemand->cumShipRewardObjVec_;
   focusHorizon_        = theDemand->focusHorizon_;
   cumDemandVol_        = theDemand->cumDemandVol_;
d480 1
a480 1
      copyAttrsFrom      (theDemand->cumShipBounds_);
d607 2
a608 2
   myProblem ()->display ("demShipRewardDdMsg",    shipRewardObjVec_);
   myProblem ()->display ("demCumShipRewardDdMsg", cumShipRewardObjVec_);
d806 1
a806 1
         shipRewardObjVec_,
d811 1
a811 1
         cumShipRewardObjVec_,
@


1.155
log
@Multi-Objective Mode
@
text
@d43 21
a63 21
      WitDelComp        (thePart->myCompMgr ()),
      mappingIndex_     (myCompMgr ()->nDemands ()),
      demandName_       (),
      demandedPart_     (thePart),
      demandVol_        (myProblem (), defDemandVol ()),
      priority_         (myProblem (), defPriority ()),
      searchInc_        (defSearchInc ()),
      buildAheadUB_     (myProblem (), defBuildAheadUB ()),
      shipLateUB_       (myProblem (), defShipLateUB (myProblem ())),
      shipLateAllowed_  (defShipLateAllowed ()),
      prefBuildAhead_   (defPrefBuildAhead ()),
      intShipVols_      (defIntShipVols ()),
      cumShipBounds_    (NULL),
      shipRewardObjVec_ (myProblem (), defShipReward ()),
      cumShipReward_    (myProblem (), defCumShipReward ()),
      shipVol_          (myProblem (), 0.0),
      focusHorizon_     (defFocusHorizon ()),
      fssShipVol_       (myProblem (), 0.0),
      cumDemandVol_     (myProblem (), 0.0),
      cumShipVol_       (myProblem (), 0.0),
      myPegElsFor_      ()
d242 1
a242 1
   cumShipReward_ = theValue;
d344 1
a344 1
   cumShipReward_ = theFlexVec;
d376 2
a377 1
   shipRewardObjVec_.writeDataMulti ("shipReward", this, theObj);
d467 12
a478 12
   demandVol_        = theDemand->demandVol_;
   priority_         = theDemand->priority_;
   searchInc_        = theDemand->searchInc_;
   buildAheadUB_     = theDemand->buildAheadUB_;
   shipLateUB_       = theDemand->shipLateUB_;
   shipLateAllowed_  = theDemand->shipLateAllowed_;
   prefBuildAhead_   = theDemand->prefBuildAhead_;
   intShipVols_      = theDemand->intShipVols_;
   shipRewardObjVec_ = theDemand->shipRewardObjVec_;
   cumShipReward_    = theDemand->cumShipReward_;
   focusHorizon_     = theDemand->focusHorizon_;
   cumDemandVol_     = theDemand->cumDemandVol_;
d480 1
a480 1
      copyAttrsFrom   (theDemand->cumShipBounds_);
d608 1
a608 1
   myProblem ()->display ("demCumShipRewardDdMsg", cumShipReward_);
d804 1
a804 1
   myDataWriter ()->writeVector (
d806 1
a806 1
         shipReward (),
d809 1
a809 1
   myDataWriter ()->writeVector (
d811 1
a811 1
         cumShipReward (),
@


1.154
log
@Multi-Objective Mode
@
text
@d43 21
a63 21
      WitDelComp       (thePart->myCompMgr ()),
      mappingIndex_    (myCompMgr ()->nDemands ()),
      demandName_      (),
      demandedPart_    (thePart),
      demandVol_       (myProblem (), defDemandVol ()),
      priority_        (myProblem (), defPriority ()),
      searchInc_       (defSearchInc ()),
      buildAheadUB_    (myProblem (), defBuildAheadUB ()),
      shipLateUB_      (myProblem (), defShipLateUB (myProblem ())),
      shipLateAllowed_ (defShipLateAllowed ()),
      prefBuildAhead_  (defPrefBuildAhead ()),
      intShipVols_     (defIntShipVols ()),
      cumShipBounds_   (NULL),
      shipReward_      (myProblem (), defShipReward ()),
      cumShipReward_   (myProblem (), defCumShipReward ()),
      shipVol_         (myProblem (), 0.0),
      focusHorizon_    (defFocusHorizon ()),
      fssShipVol_      (myProblem (), 0.0),
      cumDemandVol_    (myProblem (), 0.0),
      cumShipVol_      (myProblem (), 0.0),
      myPegElsFor_     ()
d231 1
a231 1
   shipReward_ = theValue;
d335 1
a335 1
   shipReward_ = theFlexVec;
d374 7
d466 12
a477 12
   demandVol_       = theDemand->demandVol_;
   priority_        = theDemand->priority_;
   searchInc_       = theDemand->searchInc_;
   buildAheadUB_    = theDemand->buildAheadUB_;
   shipLateUB_      = theDemand->shipLateUB_;
   shipLateAllowed_ = theDemand->shipLateAllowed_;
   prefBuildAhead_  = theDemand->prefBuildAhead_;
   intShipVols_     = theDemand->intShipVols_;
   shipReward_      = theDemand->shipReward_;
   cumShipReward_   = theDemand->cumShipReward_;
   focusHorizon_    = theDemand->focusHorizon_;
   cumDemandVol_    = theDemand->cumDemandVol_;
d479 1
a479 1
      copyAttrsFrom  (theDemand->cumShipBounds_);
d606 1
a606 1
   myProblem ()->display ("demShipRewardDdMsg",    shipReward_);
@


1.153
log
@Removing objective #2.
@
text
@d382 10
@


1.152
log
@Removing objective #2.
@
text
@d25 1
d583 1
a583 1
   myMsgFac ()                  ("focusHorizonDdMsg",     focusHorizon_);
d585 6
a590 7
   myProblem ()->display        ("demVolDdMsg",           demandVol_);
   myProblem ()->display        ("demPriDdMsg",           priority_);
   myProblem ()->display        ("buildAheadUBDdMsg",     buildAheadUB_);
   myProblem ()->display        ("shipLateUBDdMsg",       shipLateUB_);

   objChoice ()->displayForObj1 ("demShipRewardDdMsg",    shipReward_);
   objChoice ()->displayForObj1 ("demCumShipRewardDdMsg", cumShipReward_);
d609 1
a609 5
   theProblem->
      myCompMgr ()->
         myOptComp ()->
            objChoice ()->
               genPriorities (newPriority);
@


1.151
log
@Object name change.
@
text
@a54 1
      grossRev_        (defGrossRev ()),
a223 11
void WitDemand::setGrossRev (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   grossRev_ = theValue;
   }

//------------------------------------------------------------------------------

a455 1
   grossRev_        = theDemand->grossRev_;
d547 1
a547 1
   return positivePart (grossRev () - demandedPart ()->unitCost ());
a581 3
   objChoice ()->displayForObj2 ("demandGrossRevDdMsg",   grossRev_);
   objChoice ()->displayForObj2 ("demandNetRevDdMsg",     netRev ());

a789 5
   myDataWriter ()->writeDouble (
      "grossRev",
      grossRev (),
      defGrossRev ());

@


1.150
log
@Object name change.
@
text
@d44 1
a44 1
      demandName_      (theName),
d65 1
a65 7
   WitDemand * priorDemand;

   witAssert (not isNullCstring (theName));

   priorDemand = myCompMgr ()->findDemand (demandedPart_, theName);

   witAssert (priorDemand == NULL);
d96 19
@


1.149
log
@Object name change.
@
text
@d42 1
a42 2
      WitDelComp       (preconstruct (theName, thePart)),

d65 8
a707 21
WitCompMgr * WitDemand::preconstruct (
      const char * theName,
      WitPart *    thePart)
   {
   WitDemand * theDemand;

   witAssert (theName != NULL);

   witAssert (not isNullString (theName));

   witAssert (thePart != NULL);

   theDemand = thePart->myCompMgr ()->findDemand (thePart, theName);

   witAssert (theDemand == NULL);

   return thePart->myCompMgr ();
   }

//------------------------------------------------------------------------------

@


1.148
log
@Stochastic Implosion
@
text
@d705 2
d713 4
@


1.147
log
@Stochastic Implosion
@
text
@a435 7
int WitDemand::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (this);
   }

//------------------------------------------------------------------------------

@


1.146
log
@Stochastic Implosion
@
text
@d220 1
a220 1
   prepSetUnpostAttr ();
d231 1
a231 1
   prepSetUnpostAttr ();
d322 18
@


1.145
log
@Stochastic Implosion
@
text
@d357 1
d360 3
a362 4
   theDemand =
      new WitDemand (
         demandName ().myCstring (), 
         theCompMgr->match (demandedPart ()));
@


1.144
log
@Stochastic Implosion
@
text
@d101 1
a101 1
   prepSetStochModeAttr ("demandVol");
@


1.143
log
@Stochastic Implosion
@
text
@a102 4
   if (DEBUG_MODE)
      if (myStochImpMgr ()->stochMode ())
         witAssert (myStochImpMgr ()->stageIndex (demandedPart_) != 0);

@


1.142
log
@Stochastic Implosion
@
text
@d422 7
@


1.141
log
@Stochastic Implosion
@
text
@a391 7
int WitDemand::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (demandedPart ());
   }

//------------------------------------------------------------------------------

@


1.140
log
@Stochastic Implosion
@
text
@d288 1
a288 1
void WitDemand::storePostCumShipVol (const WitTVec <double> & theValue)
d292 1
a292 1
   cumShipVol_ = theValue;
d315 1
a315 1
void WitDemand::storeStochDemandVol (const WitDblFlexVec & theValue)
d319 1
a319 1
   demandVol_ = theValue;
d326 1
a326 1
void WitDemand::storeStochShipVol (const WitDblFlexVec & theValue)
d330 1
a330 1
   shipVol_ = theValue;
d335 1
a335 1
void WitDemand::storeStochCumShipVol (const WitDblFlexVec & theValue)
d339 1
a339 1
   cumShipVol_ = theValue;
@


1.139
log
@Stochastic Implosion
@
text
@d16 1
a17 1
#include <Global.h>
d28 2
@


1.138
log
@Stochastic Implosion
@
text
@d295 18
d380 6
a385 4
void WitDemand::importOptSoln ()
   {
   myDetOptImpMgr ()->exportSoln (this, shipVol_,
                                        cumShipVol_);
@


1.137
log
@Stochastic Implosion
@
text
@d459 26
@


1.136
log
@Stochastic Implosion
@
text
@d25 1
a294 9
void WitDemand::storePostFssShipVol (const WitDblFlexVec & theValue)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   fssShipVol_ = theValue;
   }

//------------------------------------------------------------------------------

d564 27
@


1.135
log
@Stochastic Implosion
@
text
@d21 1
d285 18
@


1.134
log
@Stochastic Implosion
@
text
@d101 1
a101 1
         witAssert (myStochImpMgr ()->stageNo (demandedPart_) != 0);
d359 1
a359 1
int WitDemand::stageNo ()
d361 1
a361 1
   return myStochImpMgr ()->stageNo (demandedPart ());
@


1.133
log
@Stochastic Implosion
@
text
@d359 7
@


1.132
log
@Stochastic Implosion
@
text
@d359 9
@


1.131
log
@Stochastic Implosion
@
text
@d99 4
@


1.130
log
@Stochastic Implosion
@
text
@d280 1
a280 1
void WitDemand::storeStochDemandVol (const WitTVec <double> & theValue)
d291 1
a291 1
void WitDemand::storeStochShipVol (const WitTVec <double> & theValue)
d300 1
a300 1
void WitDemand::storeStochCumShipVol (const WitTVec <double> & theValue)
@


1.129
log
@Stochastic Implosion
@
text
@d280 1
a280 1
void WitDemand::storeStochDemandVol (const WitTVec <double> & demandVolArg)
d282 3
a284 1
   storeStochAttr (demandVol_, demandVolArg);
d293 3
a295 1
   storeStochAttr (shipVol_, theValue);
d302 3
a304 1
   storeStochAttr (cumShipVol_, theValue);
d380 15
a394 15
   demandVol_       =   theDemand->demandVol_;
   priority_        =   theDemand->priority_;
   searchInc_       =   theDemand->searchInc_;
   buildAheadUB_    =   theDemand->buildAheadUB_;
   shipLateUB_      =   theDemand->shipLateUB_;
   shipLateAllowed_ =   theDemand->shipLateAllowed_;
   prefBuildAhead_  =   theDemand->prefBuildAhead_;
   intShipVols_     =   theDemand->intShipVols_;
   grossRev_        =   theDemand->grossRev_;
   shipReward_      =   theDemand->shipReward_;
   cumShipReward_   =   theDemand->cumShipReward_;
   focusHorizon_    =   theDemand->focusHorizon_;
   cumDemandVol_    =   theDemand->cumDemandVol_;

   cumShipBounds_->set (theDemand->cumShipBounds_);
d502 1
a502 1
   cumShipBounds ()->display ();
d625 1
a625 1
WitBoundSet * WitDemand::myBoundSetForUpdate ()
d686 1
a686 1
   cumShipBounds ()->writeData ();
@


1.128
log
@Stochastic Implosion
@
text
@a317 10
void WitDemand::writeDataSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (demandedPartName ());
   myDataWriter ()->writeStringValue  (demandName_);
   }

//------------------------------------------------------------------------------

@


1.127
log
@Stochastic Implosion
@
text
@d280 1
a280 1
void WitDemand::loadInStochDemandVol (const WitTVec <double> & demandVolArg)
d282 1
a282 1
   loadInStochAttr (demandVol_, demandVolArg);
d289 1
a289 1
void WitDemand::loadInStochShipVol (const WitTVec <double> & theValue)
d291 1
a291 1
   loadInStochAttr (shipVol_, theValue);
d296 1
a296 1
void WitDemand::loadInStochCumShipVol (const WitTVec <double> & theValue)
d298 1
a298 1
   loadInStochAttr (cumShipVol_, theValue);
@


1.126
log
@Stochastic Implosion
@
text
@d289 14
a358 8
void WitDemand::importStochSoln ()
   {
   myStochImpMgr ()->exportSoln (this, shipVol_,
                                       cumShipVol_);
   }

//------------------------------------------------------------------------------

@


1.125
log
@Stochastic Implosion
@
text
@d280 9
a344 8
void WitDemand::importStochInput ()
   {
   myStochImpMgr ()->exportInput (this, demandVol_,
                                        cumDemandVol_);
   }

//------------------------------------------------------------------------------

@


1.124
log
@Stochastic Implosion
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
//    Demand
//    CumShipBoundSet
a726 55

//------------------------------------------------------------------------------
// Implementation of class CumShipBoundSet.
//------------------------------------------------------------------------------

WitCumShipBoundSet::WitCumShipBoundSet (WitDemand * theDemand):

      WitBoundSet (theDemand->myProblem ()),
      myDemand_   (theDemand)
   {
   }

//------------------------------------------------------------------------------

WitCumShipBoundSet::~WitCumShipBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitCumShipBoundSet::boundedVal (WitPeriod thePer) const
   {
   return myDemand_->cumShipVol ()[thePer];
   }

//------------------------------------------------------------------------------

WitAttr WitCumShipBoundSet::apiAttr () const
   {
   return "cumShipBounds";
   }

//------------------------------------------------------------------------------

WitMsgID WitCumShipBoundSet::headingMsgID () const
   {
   return "cumShipBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

WitAttr WitCumShipBoundSet::boundedVectorName () const
   {
   return "CumShipVol";
   }

//------------------------------------------------------------------------------

void WitCumShipBoundSet::idObjectForSoln () const
   {
   fprintf (myProblem ()->solnFile (),
      "demand \"%s\" for part \"%s\":\n",
      myDemand_->demandName ().myCstring (),
      myDemand_->demandedPartName ().myCstring ());
   }
@


1.123
log
@Stochastic Implosion
@
text
@d333 2
a334 1
   myDetOptImpMgr ()->exportSoln (this, shipVol_, cumShipVol_);
d341 2
a342 3
   myStochImpMgr ()->exportInput (this, demandVol_);

   compCumDemandVol ();
d349 2
a350 1
   myStochImpMgr ()->exportSoln (this, shipVol_, cumShipVol_);
@


1.122
log
@Stochastic Implosion
@
text
@d27 1
a27 1
#include <OptImp.h>
d333 1
a333 1
   myOptImploder ()->exportSoln (this, shipVol_, cumShipVol_);
@


1.121
log
@Stochastic Implosion
@
text
@d735 1
@


1.120
log
@Stochastic Implosion
@
text
@d100 1
a100 1
   prepSetStochModeAttr ();
@


1.119
log
@Stochastic Implosion
@
text
@a644 2
   myStochImpMgr ()->prepWriteStochAttr ();

@


1.118
log
@Stochastic Implosion
@
text
@d100 1
a100 3
   myStochImpMgr ()->prepStochModeAttr ();

   prepSetUnpostAttr ();
@


1.117
log
@Stochastic Implosion
@
text
@a406 22
void WitDemand::compCumDemandVol ()
   {
   double    cumSum;
   WitPeriod thePer;

   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
   }

//------------------------------------------------------------------------------

d604 22
@


1.116
log
@Stochastic Implosion
@
text
@d333 1
a333 1
void WitDemand::acquireOptSoln ()
d335 1
a335 1
   myOptImploder ()->provideSoln (this, shipVol_, cumShipVol_);
d340 1
a340 1
void WitDemand::passStochRefs ()
d342 10
a351 3
   myStochImpMgr ()->receiveDemandRefs (demandVol_,
                                        shipVol_,
                                        cumShipVol_);
@


1.115
log
@Stochastic Implosion
@
text
@d335 1
a335 1
   myOptImploder ()->provideDemandSoln (shipVol_, cumShipVol_);
@


1.114
log
@Stochastic Implosion
@
text
@d333 1
a333 1
void WitDemand::importOptImpSoln (WitPeriod thePer)
d335 1
a335 2
   shipVol_   .elemRef (thePer) = myOptImploder ()->shipVol    (this, thePer);
   cumShipVol_.elemRef (thePer) = myOptImploder ()->cumShipVol (this, thePer);
@


1.113
log
@Stochastic Implosion
@
text
@d341 1
a341 1
void WitDemand::passStochData ()
d343 3
a345 5
   myStochImpMgr ()->
      receiveDemandData (
         demandVol_,
         shipVol_,
         cumShipVol_);
@


1.112
log
@Stochastic Implosion
@
text
@d341 1
a341 1
void WitDemand::restoreStochInputAttrs ()
d343 5
a347 19
   demandVol_ = myStochImpMgr ()->demandVol (this);

   compCumDemandVol ();
   }

//------------------------------------------------------------------------------

void WitDemand::clearStochSoln ()
   {
   shipVol_    = 0.0;
   cumShipVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitDemand::restoreStochSoln ()
   {
   shipVol_    = myStochImpMgr ()->shipVol    (this);
   cumShipVol_ = myStochImpMgr ()->cumShipVol (this);
d403 22
a730 22

void WitDemand::compCumDemandVol ()
   {
   double    cumSum;
   WitPeriod thePer;

   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
   }

//------------------------------------------------------------------------------
@


1.111
log
@Stochastic Implosion
@
text
@d100 1
a100 1
   myStochImpMgr ()->prepStochDataModeAttr ();
@


1.110
log
@Stochastic Implosion
@
text
@d544 7
@


1.109
log
@Stochastic Implosion
@
text
@d27 1
d333 8
@


1.108
log
@Stochastic Implosion
@
text
@d332 25
a407 22
void WitDemand::compCumDemandVol ()
   {
   double    cumSum;
   WitPeriod thePer;

   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
   }

//------------------------------------------------------------------------------

d707 22
@


1.107
log
@Stochastic Implosion
@
text
@d99 1
a99 1
   myStochImpMgr ()->prepSetStochAttr ();
a245 2
   myStochImpMgr ()->prepSetStochAttr ();

@


1.106
log
@Stochastic Implosion
@
text
@d27 1
a27 1
#include <StochMgr.h>
d99 1
a99 1
   myStochMgr ()->prepSetStochAttr ();
d246 1
a246 1
   myStochMgr ()->prepSetStochAttr ();
d618 1
a618 1
   myStochMgr ()->prepWriteStochAttr ();
@


1.105
log
@Stochastic Implosion
@
text
@a94 3
   double    cumSum;
   WitPeriod thePer;

d105 1
a105 13
   if (demandVol_ == 0.0)
      cumDemandVol_ = 0.0;
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += demandVol_[thePer];

         cumDemandVol_.elemRef (thePer) = cumSum;
         }
      }
d385 22
@


1.104
log
@Stochastic Implosion
@
text
@d261 2
@


1.103
log
@Stochastic Implosion
@
text
@d102 1
a102 1
   myStochMgr ()->willSetStochAttr ();
d104 1
a104 1
   settingUnpostAttr ();
d129 1
a129 1
   settingUnpostAttr ();
d140 1
a140 1
   settingUnpostAttr ();
d163 1
a163 1
   settingUnpostAttr ();
d186 1
a186 1
   settingUnpostAttr ();
d195 1
a195 1
   settingUnpreAttr ();
d204 1
a204 1
   settingUnpostAttr ();
d213 1
a213 1
   settingUnpreAttr ();
d224 1
a224 1
   settingUnpostAttr ();
d235 1
a235 1
   settingUnpostAttr ();
d246 1
a246 1
   settingUnpostAttr ();
d261 1
a261 1
   settingUnpostAttr ();
d273 1
a273 1
   settingNonUnpostAttr ();
d288 1
a288 1
   settingNonUnpostAttr ();
d509 1
a509 1
   theProblem->settingUnpostAttr ();
d609 6
a614 5
   if (not myStochMgr ()->stochDataMode ())
      myDataWriter ()->writeVector (
         "demandVol",
         demandVol (),
         defDemandVol ());
@


1.102
log
@Stochastic Implosion
@
text
@d102 3
a104 1
   settingStochAttr ();
@


1.101
log
@Stochastic Implosion
@
text
@d607 1
a607 1
   if (not myStochMgr ()->stochasticMode ())
@


1.100
log
@Stochastic Implosion
@
text
@d607 1
a607 1
   if (not myStochMgr ()->stochImpMode ())
@


1.99
log
@Stochastic Implosion
@
text
@a27 1
#include <Scenario.h>
a344 7
void WitDemand::retrieveStochAttrs ()
   {
   demandVol_ = curScenario ()->demandVol () (this);
   }

//------------------------------------------------------------------------------

@


1.98
log
@Stochastic Implosion
@
text
@d313 10
@


1.97
log
@Stochastic Implosion
@
text
@d27 1
d605 5
a609 4
   myDataWriter ()->writeVector (
      "demandVol",
      demandVol (),
      defDemandVol ());
@


1.96
log
@Stochastic implosion
@
text
@d465 1
a465 1
   myMsgFac () ("demandDdMsg",
d467 3
a469 1
      demandName_,
@


1.95
log
@Stochastic implosion.
@
text
@d27 1
a27 1
#include <StochMgr.h>
d114 1
a114 1
         cumSum += demandVol ()[thePer];
d335 7
@


1.94
log
@Stochastic implosion.
@
text
@d271 2
d286 2
@


1.93
log
@Stochastic Implosion.
@
text
@a24 1
#include <Pre.h>
d102 1
a102 3
   myStochMgr ()->settingStochAttr ();

   myProblem ()->resetSoln ();
d127 1
a127 1
   myProblem ()->resetSoln ();
d138 1
a138 1
   myProblem ()->resetSoln ();
d161 1
a161 1
   myProblem ()->resetSoln ();
d184 1
a184 1
   myProblem ()->resetSoln ();
d193 1
a193 1
   myPreprocessor ()->unpreprocess ();
d202 1
a202 1
   myProblem ()->resetSoln ();
d211 1
a211 1
   myPreprocessor ()->unpreprocess ();
d222 1
a222 1
   myProblem ()->resetSoln ();
d233 1
a233 1
   myProblem ()->resetSoln ();
d244 1
a244 1
   myProblem ()->resetSoln ();
d259 1
a259 1
   myProblem ()->resetSoln ();
d491 1
a491 1
   theProblem->resetSoln ();
d493 5
a497 2
   theProblem->myCompMgr ()->myOptComp ()->objChoice ()->
      genPriorities (newPriority);
@


1.92
log
@Stochastic implosion.
@
text
@a64 2
   forbidAddStochAct ();

@


1.91
log
@Stochastic Implosion.
@
text
@d28 1
d105 2
@


1.90
log
@Stochastic implosion.
@
text
@d31 1
d64 1
a64 1
   forbidAddStochAct ("demandFrag");
a301 7
WitMsgFragID WitDemand::classFragID ()
   {
   return "demandFrag";
   }

//------------------------------------------------------------------------------

d340 7
@


1.89
log
@[disallowed backlog]
@
text
@d63 2
@


1.88
log
@[disallowed backlog]
@
text
@d39 1
a39 1
      WitDelComp      (preconstruct (theName, thePart)),
d41 21
a61 21
      mappingIndex_   (myCompMgr ()->nDemands ()),
      demandName_     (theName),
      demandedPart_   (thePart),
      demandVol_      (myProblem (), defDemandVol ()),
      priority_       (myProblem (), defPriority ()),
      searchInc_      (defSearchInc ()),
      buildAheadUB_   (myProblem (), defBuildAheadUB ()),
      shipLateUB_     (myProblem (), defShipLateUB (myProblem ())),
      backlogAllowed_ (defBacklogAllowed ()),
      prefBuildAhead_ (defPrefBuildAhead ()),
      intShipVols_    (defIntShipVols ()),
      cumShipBounds_  (NULL),
      grossRev_       (defGrossRev ()),
      shipReward_     (myProblem (), defShipReward ()),
      cumShipReward_  (myProblem (), defCumShipReward ()),
      shipVol_        (myProblem (), 0.0),
      focusHorizon_   (defFocusHorizon ()),
      fssShipVol_     (myProblem (), 0.0),
      cumDemandVol_   (myProblem (), 0.0),
      cumShipVol_     (myProblem (), 0.0),
      myPegElsFor_    ()
d190 1
a190 1
void WitDemand::setBacklogAllowed (bool theValue)
d194 1
a194 1
   backlogAllowed_ = theValue;
d355 13
a367 13
   demandVol_      =    theDemand->demandVol_;
   priority_       =    theDemand->priority_;
   searchInc_      =    theDemand->searchInc_;
   buildAheadUB_   =    theDemand->buildAheadUB_;
   shipLateUB_     =    theDemand->shipLateUB_;
   backlogAllowed_ =    theDemand->backlogAllowed_;
   prefBuildAhead_ =    theDemand->prefBuildAhead_;
   intShipVols_    =    theDemand->intShipVols_;
   grossRev_       =    theDemand->grossRev_;
   shipReward_     =    theDemand->shipReward_;
   cumShipReward_  =    theDemand->cumShipReward_;
   focusHorizon_   =    theDemand->focusHorizon_;
   cumDemandVol_   =    theDemand->cumDemandVol_;
d458 1
a458 1
      backlogAllowed_,
d613 3
a615 3
        "backlogAllowed",
         backlogAllowed (),
      defBacklogAllowed ());
@


1.87
log
@[disallowed backlog]
@
text
@a191 2
   stronglyAssert (myGlobalComp ()->allowDBL ());

@


1.86
log
@[disallowed backlog]
@
text
@d39 1
a39 1
      WitDelComp       (preconstruct (theName, thePart)),
d41 21
a61 21
      mappingIndex_    (myCompMgr ()->nDemands ()),
      demandName_      (theName),
      demandedPart_    (thePart),
      demandVol_       (myProblem (), defDemandVol ()),
      priority_        (myProblem (), defPriority ()),
      searchInc_       (defSearchInc ()),
      buildAheadUB_    (myProblem (), defBuildAheadUB ()),
      shipLateUB_      (myProblem (), defShipLateUB (myProblem ())),
      disallowBacklog_ (defDisallowBacklog ()),
      prefBuildAhead_  (defPrefBuildAhead ()),
      intShipVols_     (defIntShipVols ()),
      cumShipBounds_   (NULL),
      grossRev_        (defGrossRev ()),
      shipReward_      (myProblem (), defShipReward ()),
      cumShipReward_   (myProblem (), defCumShipReward ()),
      shipVol_         (myProblem (), 0.0),
      focusHorizon_    (defFocusHorizon ()),
      fssShipVol_      (myProblem (), 0.0),
      cumDemandVol_    (myProblem (), 0.0),
      cumShipVol_      (myProblem (), 0.0),
      myPegElsFor_     ()
d190 1
a190 1
void WitDemand::setDisallowBacklog (bool theValue)
d196 1
a196 1
   disallowBacklog_ = theValue;
d357 13
a369 13
   demandVol_       =   theDemand->demandVol_;
   priority_        =   theDemand->priority_;
   searchInc_       =   theDemand->searchInc_;
   buildAheadUB_    =   theDemand->buildAheadUB_;
   shipLateUB_      =   theDemand->shipLateUB_;
   disallowBacklog_ =   theDemand->disallowBacklog_;
   prefBuildAhead_  =   theDemand->prefBuildAhead_;
   intShipVols_     =   theDemand->intShipVols_;
   grossRev_        =   theDemand->grossRev_;
   shipReward_      =   theDemand->shipReward_;
   cumShipReward_   =   theDemand->cumShipReward_;
   focusHorizon_    =   theDemand->focusHorizon_;
   cumDemandVol_    =   theDemand->cumDemandVol_;
d460 1
a460 1
      disallowBacklog_,
d615 3
a617 3
        "disallowBacklog",
         disallowBacklog (),
      defDisallowBacklog ());
@


1.85
log
@[disallowed backlog]
@
text
@d192 1
a192 1
   stronglyAssert (myGlobalComp ()->allowBLA ());
@


1.84
log
@[disallowed backlog]
@
text
@d39 1
a39 1
      WitDelComp      (preconstruct (theName, thePart)),
d41 21
a61 21
      mappingIndex_   (myCompMgr ()->nDemands ()),
      demandName_     (theName),
      demandedPart_   (thePart),
      demandVol_      (myProblem (), defDemandVol ()),
      priority_       (myProblem (), defPriority ()),
      searchInc_      (defSearchInc ()),
      buildAheadUB_   (myProblem (), defBuildAheadUB ()),
      shipLateUB_     (myProblem (), defShipLateUB (myProblem ())),
      backlogAllowed_ (defBacklogAllowed ()),
      prefBuildAhead_ (defPrefBuildAhead ()),
      intShipVols_    (defIntShipVols ()),
      cumShipBounds_  (NULL),
      grossRev_       (defGrossRev ()),
      shipReward_     (myProblem (), defShipReward ()),
      cumShipReward_  (myProblem (), defCumShipReward ()),
      shipVol_        (myProblem (), 0.0),
      focusHorizon_   (defFocusHorizon ()),
      fssShipVol_     (myProblem (), 0.0),
      cumDemandVol_   (myProblem (), 0.0),
      cumShipVol_     (myProblem (), 0.0),
      myPegElsFor_    ()
d190 1
a190 1
void WitDemand::setBacklogAllowed (bool theValue)
d196 1
a196 1
   backlogAllowed_ = theValue;
d357 13
a369 13
   demandVol_      =    theDemand->demandVol_;
   priority_       =    theDemand->priority_;
   searchInc_      =    theDemand->searchInc_;
   buildAheadUB_   =    theDemand->buildAheadUB_;
   shipLateUB_     =    theDemand->shipLateUB_;
   backlogAllowed_ =    theDemand->backlogAllowed_;
   prefBuildAhead_ =    theDemand->prefBuildAhead_;
   intShipVols_    =    theDemand->intShipVols_;
   grossRev_       =    theDemand->grossRev_;
   shipReward_     =    theDemand->shipReward_;
   cumShipReward_  =    theDemand->cumShipReward_;
   focusHorizon_   =    theDemand->focusHorizon_;
   cumDemandVol_   =    theDemand->cumDemandVol_;
d460 1
a460 1
      backlogAllowed_,
d615 3
a617 3
        "backlogAllowed",
         backlogAllowed (),
      defBacklogAllowed ());
@


1.83
log
@Rescinded all changed made since 1/31/07.
@
text
@a25 3
#include <Post.h>
#include <HeurAllMgr.h>
#include <OptImp.h>
a538 13
void WitDemand::transmitDMPs ()
   {
   WitHeurAllMgr   ::receiveDMPs (& WitDemand::shipVol_,
                                  & WitDemand::myPegElsFor_);
   WitOptImploder  ::receiveDMPs (& WitDemand::shipVol_,
                                  & WitDemand::cumShipVol_);
   WitPostprocessor::receiveDMPs (& WitDemand::cumShipVol_,
                                  & WitDemand::fssShipVol_);
   WitFSS          ::receiveDMPs (& WitDemand::fssShipVol_);
   }

//------------------------------------------------------------------------------

@


1.82
log
@[disallowed backlog]
@
text
@a43 4
      shipVol_        (myProblem ()),
      cumShipVol_     (myProblem ()),
      fssShipVol_     (myProblem ()),

d59 1
d61 1
d63 1
d257 9
a265 1
   myOptImploder ()->setShipVol (this, theValue);
d281 13
d544 1
a544 1
   WitHeurAllMgr   ::receiveDMPs (  NULL,
d546 5
@


1.81
log
@[backlog avoidance]
@
text
@d44 4
a62 1
      shipVol_        (myProblem (), 0.0),
a63 1
      fssShipVol_     (myProblem (), 0.0),
a64 1
      cumShipVol_     (myProblem (), 0.0),
d258 1
a258 9
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   shipVol_ = theValue;
a273 13

void WitDemand::setFssShipVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myProblem ()->myFSS ()->uncompute ();

   fssShipVol_ = theValue;
   }

//------------------------------------------------------------------------------
d524 1
a524 1
   WitHeurAllMgr   ::receiveDMPs (& WitDemand::shipVol_,
a525 5
   WitOptImploder  ::receiveDMPs (& WitDemand::shipVol_,
                                  & WitDemand::cumShipVol_);
   WitPostprocessor::receiveDMPs (& WitDemand::cumShipVol_,
                                  & WitDemand::fssShipVol_);
   WitFSS          ::receiveDMPs (& WitDemand::fssShipVol_);
@


1.80
log
@witCopy<Object>Data
@
text
@d52 1
d193 11
d365 1
d463 1
d631 5
@


1.79
log
@External opt implosion.
@
text
@d344 22
a650 21
void WitDemand::copyAttrsFrom (WitDemand * theDemand)
   {
   WitDelComp::copyAttrsFrom (theDemand);

   demandVol_      =    theDemand->demandVol_;
   priority_       =    theDemand->priority_;
   searchInc_      =    theDemand->searchInc_;
   buildAheadUB_   =    theDemand->buildAheadUB_;
   shipLateUB_     =    theDemand->shipLateUB_;
   prefBuildAhead_ =    theDemand->prefBuildAhead_;
   intShipVols_    =    theDemand->intShipVols_;
   cumShipBounds_->set (theDemand->cumShipBounds_);
   grossRev_       =    theDemand->grossRev_;
   shipReward_     =    theDemand->shipReward_;
   cumShipReward_  =    theDemand->cumShipReward_;
   focusHorizon_   =    theDemand->focusHorizon_;
   cumDemandVol_   =    theDemand->cumDemandVol_;
   }

//------------------------------------------------------------------------------

@


1.78
log
@Heuristic search increment.
@
text
@d53 1
a53 1
      intConShipVols_ (defIntConShipVols ()),
d201 1
a201 1
void WitDemand::setIntConShipVols (bool theValue)
d205 1
a205 1
   intConShipVols_ = theValue;
d429 1
a429 1
      intConShipVols_);
d600 3
a602 3
        "intConShipVols",
         intConShipVols (),
      defIntConShipVols ());
d639 1
a639 1
   intConShipVols_ =    theDemand->intConShipVols_;
@


1.77
log
@Heuristic search increment.
@
text
@a136 2
   stronglyAssert (DEVELOPMENT);

@


1.76
log
@App controlled opt implosion.
@
text
@d49 1
d135 13
d427 1
a427 1
      demandName (),
d429 3
a431 2
      prefBuildAhead (),
      intConShipVols ());
d581 5
d637 1
@


1.75
log
@App controlled opt implosion.
@
text
@a23 1
#include <DataAlt.h>
d29 1
d33 1
d98 7
a104 1
   demandVol_ = prepNonNegDblVec (theValue, postprocAlt ());
d127 1
a127 1
   postprocAlt ()->incur ();
d136 17
a152 1
   buildAheadUB_ = prepBuildAheadUB (theValue);
d161 1
a161 1
   prepPeriodIntVec (theValue, postprocAlt ());
d164 10
a173 2
      for (thePer = 1; thePer < nPeriods (); thePer ++)
         witAssert (theValue[thePer] >= theValue[thePer - 1] - 1);
d182 3
a184 1
   prefBuildAhead_ = prepBool (theValue, postprocAlt ());
d191 3
a193 1
   intConShipVols_ = prepBool (theValue, preprocAlt ());
d200 5
a204 1
   grossRev_ = prepNonNegDouble (theValue, postprocAlt ());
d211 5
a215 1
   shipReward_ = prepDblVec (theValue, postprocAlt ());
d222 5
a226 1
   cumShipReward_ = prepDblVec (theValue, postprocAlt ());
d233 9
a241 1
   shipVol_ = prepSchedVec (theValue, postprocAlt ());
d248 3
d253 1
a253 1
   focusHorizon_ = prepRangedInt (theValue, noOpAlt (), -1, lastPeriod ());
d260 4
d266 1
a266 1
   fssShipVol_ = prepNonNegDblVec (theValue, noOpAlt ());
d446 1
a446 1
   theProblem->postprocAlt ()->incur ();
@


1.74
log
@Integrality constraints.
@
text
@d158 1
a158 1
   intConShipVols_ = prepBool (theValue, postprocAlt ());
@


1.73
log
@Opt implosion with integrality constraints.
@
text
@d51 1
a51 1
      intShipVols_    (defIntShipVols ()),
d156 1
a156 1
void WitDemand::setIntShipVols (bool theValue)
d158 1
a158 1
   intShipVols_ = prepBool (theValue, postprocAlt ());
d354 1
a354 1
      intShipVols ());
d520 3
a522 3
        "intShipVols",
         intShipVols (),
      defIntShipVols ());
d558 1
a558 1
   intShipVols_    =    theDemand->intShipVols_;
@


1.72
log
@Updated the copyright date on all source files.
@
text
@d51 1
d156 7
d353 2
a354 1
      prefBuildAhead ());
d519 5
d558 1
@


1.71
log
@Minor changes.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.70
log
@[shared-resource pegging]
@
text
@a489 2
   cumShipBounds ()->writeData ();

d510 2
d539 5
a543 11
   prefBuildAhead_ = theDemand->prefBuildAhead_;
   grossRev_       = theDemand->grossRev_;
   focusHorizon_   = theDemand->focusHorizon_;
   demandVol_      = theDemand->demandVol_;
   cumDemandVol_   = theDemand->cumDemandVol_;
   priority_       = theDemand->priority_;
   buildAheadUB_   = theDemand->buildAheadUB_;
   shipLateUB_     = theDemand->shipLateUB_;
   shipReward_     = theDemand->shipReward_;
   cumShipReward_  = theDemand->cumShipReward_;

d545 5
@


1.69
log
@[shared-resource pegging]
@
text
@d300 1
a300 1
   myPegElsFor_ (shipPer).attach (theItr);
@


1.68
log
@[multi-thread]
@
text
@d300 1
a300 1
   theItr.attachTo (myPegElsFor_ (shipPer));
@


1.67
log
@[multi-thread]
@
text
@a31 1
#include <PtrTVec.h>
d60 1
a60 1
      myPegElsFor_    (* new WitPtrTVec <WitObjStack <WitPegEl> >)
d77 1
a77 2
   delete & myPegElsFor_;
   delete   cumShipBounds_;
a254 9
void WitDemand::loadPegging ()
   {
   witAssert (myGlobalComp ()->perfPegging ());

   myHeurAllMgr ()->loadPegDataFrom (this, myPegElsFor_);
   }

//------------------------------------------------------------------------------

d424 2
a425 1
   WitHeurAllMgr   ::receiveDMPs (& WitDemand::shipVol_);
@


1.66
log
@[multi-thread]
@
text
@a256 28
void WitDemand::loadPost ()
   {
   myPostprocessor ()->loadDataFrom (this, cumShipVol_, fssShipVol_);
   }

//------------------------------------------------------------------------------

void WitDemand::loadFss ()
   {
   myFSS ()->loadDataFrom (this, fssShipVol_);
   }

//------------------------------------------------------------------------------

void WitDemand::loadHeur ()
   {
   myHeurAllMgr ()->loadDataFrom (this, shipVol_);
   }

//------------------------------------------------------------------------------

void WitDemand::loadOpt ()
   {
   myOptImploder ()->loadDataFrom (this, shipVol_, cumShipVol_);
   }

//------------------------------------------------------------------------------

d433 12
@


1.65
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d427 1
a427 1
void WitDemand::writeSoln (bool fssInput)
a443 5
   if (fssInput)
      fprintf (solnFile (),
         "  Focus"
         "     FssShipVol");

a454 9
      if (fssInput)
         {
         fprintf (solnFile (),
            "      %1s",
            (thePer <= focusHorizon ())? "*": " ");

         writeSolnValue (fssShipVol ()[thePer]);
         }

@


1.64
log
@Revised mappingIndex code.
@
text
@d42 1
a42 1
      WitDelComp         (preconstruct (theName, thePart)),
d44 18
a61 18
      mappingIndex_      (myCompMgr ()->nDemands ()),
      demandName_        (theName),
      demandedPart_      (thePart),
      demandVol_         (myProblem (), defDemandVol ()),
      priority_          (myProblem (), defPriority ()),
      buildAheadUB_      (myProblem (), defBuildAheadUB ()),
      shipLateUB_        (myProblem (), defShipLateUB (myProblem ())),
      prefBuildAhead_    (defPrefBuildAhead ()),
      cumShipBounds_     (NULL),
      grossRev_          (defGrossRev ()),
      obj1ShipReward_    (myProblem (), defObj1ShipReward ()),
      obj1CumShipReward_ (myProblem (), defObj1CumShipReward ()),
      shipVol_           (myProblem (), 0.0),
      focusHorizon_      (defFocusHorizon ()),
      fssShipVol_        (myProblem (), 0.0),
      cumDemandVol_      (myProblem (), 0.0),
      cumShipVol_        (myProblem (), 0.0),
      myPegElsFor_       (* new WitPtrTVec <WitObjStack <WitPegEl> >)
d164 1
a164 1
void WitDemand::setObj1ShipReward (const WitIVRealArg & theValue)
d166 1
a166 1
   obj1ShipReward_ = prepDblVec (theValue, postprocAlt ());
d171 1
a171 1
void WitDemand::setObj1CumShipReward (const WitIVRealArg & theValue)
d173 1
a173 1
   obj1CumShipReward_ = prepDblVec (theValue, postprocAlt ());
d386 1
a386 1
   objChoice ()->displayForObj2 ("demandGrossRevDdMsg",   grossRev ());
d389 1
a389 1
   myMsgFac ()                  ("focusHorizonDdMsg",     focusHorizon ());
d391 4
a394 4
   myProblem ()->display        ("demVolDdMsg",           demandVol ());
   myProblem ()->display        ("demPriDdMsg",           priority ());
   myProblem ()->display        ("buildAheadUBDdMsg",     buildAheadUB ());
   myProblem ()->display        ("shipLateUBDdMsg",       shipLateUB ());
d396 2
a397 2
   objChoice ()->displayForObj1 ("demShipRewardDdMsg",    obj1ShipReward ());
   objChoice ()->displayForObj1 ("demCumShipRewardDdMsg", obj1CumShipReward ());
d558 3
a560 3
        "obj1ShipReward",
         obj1ShipReward (),
      defObj1ShipReward ());
d563 3
a565 3
        "obj1CumShipReward",
         obj1CumShipReward (),
      defObj1CumShipReward ());
d582 7
a588 8

   demandVol_         = theDemand->demandVol_;
   cumDemandVol_      = theDemand->cumDemandVol_;
   priority_          = theDemand->priority_;
   buildAheadUB_      = theDemand->buildAheadUB_;
   shipLateUB_        = theDemand->shipLateUB_;
   obj1ShipReward_    = theDemand->obj1ShipReward_;
   obj1CumShipReward_ = theDemand->obj1CumShipReward_;
@


1.63
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@a34 1
#include <MapIdxI.h>
@


1.62
log
@Vector PropRt.
@
text
@d167 1
a167 1
   obj1ShipReward_ = prepObj1DblVec (theValue, postprocAlt ());
d174 1
a174 1
   obj1CumShipReward_ = prepObj1DblVec (theValue, postprocAlt ());
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d94 1
a94 1
void WitDemand::setDemandVol (const WitInVecRA & theValue)
d165 1
a165 1
void WitDemand::setObj1ShipReward (const WitInVecRA & theValue)
d172 1
a172 1
void WitDemand::setObj1CumShipReward (const WitInVecRA & theValue)
d179 1
a179 1
void WitDemand::setShipVol (const WitInVecRA & theValue)
d195 1
a195 1
void WitDemand::setFssShipVol (const WitInVecRA & theValue)
@


1.60
log
@Double Precision.
@
text
@d335 2
a336 1
   WitObjStItr <WitPegEl> thePegElItr;
d340 1
a340 1
   thePegElItr.attachTo (myPegElsFor_ (shipPer));
d342 2
a343 2
   while (thePegElItr.advance ())
      theFixedPegEls.push (thePegElItr->myFixedPegEl ()); 
@


1.59
log
@Double Precision.
@
text
@d99 1
a99 1
   demandVol_.convCopy (prepNonNegDblVec (theValue, postprocAlt ()));
d102 1
a102 1
      cumDemandVol_.setToScalar (0.0);
d124 1
a124 1
   priority_.convCopy (theValue);
d131 1
a131 1
   buildAheadUB_.convCopy (prepBuildAheadUB (theValue));
d146 1
a146 1
   shipLateUB_.convCopy (theValue);
d167 1
a167 1
   obj1ShipReward_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d174 1
a174 1
   obj1CumShipReward_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d181 1
a181 1
   shipVol_.convCopy (prepSchedVec (theValue, postprocAlt ()));
d199 1
a199 1
   fssShipVol_.convCopy (prepNonNegDblVec (theValue, noOpAlt ()));
d420 1
a420 1
      theDemand->priority_.convCopy (newPriority (theDemand));
@


1.58
log
@Double Precision.
@
text
@d583 7
a589 7
   demandVol_        .copy (theDemand->demandVol_);
   cumDemandVol_     .copy (theDemand->cumDemandVol_);
   priority_         .copy (theDemand->priority_);
   buildAheadUB_     .copy (theDemand->buildAheadUB_);
   shipLateUB_       .copy (theDemand->shipLateUB_);
   obj1ShipReward_   .copy (theDemand->obj1ShipReward_);
   obj1CumShipReward_.copy (theDemand->obj1CumShipReward_);
@


1.57
log
@Double Precision.
@
text
@d101 5
a105 1
   cumSum = 0.0;
d107 3
a109 3
   forEachPeriod (thePer, myProblem ())
      {
      cumSum += demandVol ()[thePer];
d111 2
a112 1
      cumDemandVol_.elemRef (thePer) = cumSum;
@


1.56
log
@Double Precision.
@
text
@a93 19
void WitDemand::setDemandVol (const float * theValue)
   {
   double    cumSum;
   WitPeriod thePer;

   demandVol_.convCopy (prepNonNegDblVec (theValue, postprocAlt ()));

   cumSum = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      cumSum += demandVol ()[thePer];

      cumDemandVol_.elemRef (thePer) = cumSum;
      }
   }

//------------------------------------------------------------------------------

a159 7
void WitDemand::setObj1ShipReward (const float * theValue)
   {
   obj1ShipReward_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a166 7
void WitDemand::setObj1CumShipReward (const float * theValue)
   {
   obj1CumShipReward_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a173 7
void WitDemand::setShipVol (const float * theValue)
   {
   shipVol_.convCopy (prepSchedVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a185 9
   }

//------------------------------------------------------------------------------

void WitDemand::setFssShipVol (const float * theValue)
   {
   myProblem ()->myFSS ()->uncompute ();

   fssShipVol_.convCopy (prepNonNegDblVec (theValue, noOpAlt ()));
@


1.55
log
@Double Precision.
@
text
@d113 19
d186 7
d200 7
d214 7
d231 9
@


1.54
log
@Double Precision.
@
text
@d99 1
a99 1
   demandVol_.convCopy (prepNonNegFloatVec (theValue, postprocAlt ()));
d162 1
a162 1
   obj1ShipReward_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d169 1
a169 1
   obj1CumShipReward_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d194 1
a194 1
   fssShipVol_.convCopy (prepNonNegFloatVec (theValue, noOpAlt ()));
@


1.53
log
@Double Precision.
@
text
@d99 1
a99 3
   convCopy (
      demandVol_,
      prepNonNegFloatVec (theValue, postprocAlt ()));
d162 1
a162 1
   convCopy (obj1ShipReward_, prepObj1FloatVec (theValue, postprocAlt ()));
d169 1
a169 1
   convCopy (obj1CumShipReward_, prepObj1FloatVec (theValue, postprocAlt ()));
d176 1
a176 1
   convCopy (shipVol_, prepSchedVec (theValue, postprocAlt ()));
d194 1
a194 1
   convCopy (fssShipVol_, prepNonNegFloatVec (theValue, noOpAlt ()));
@


1.52
log
@Double Precision.
@
text
@d99 3
a101 1
   demandVol_.convCopy (prepNonNegFloatVec (theValue, postprocAlt ()));
d109 1
a109 1
      cumDemandVol_.setElem (thePer, cumSum);
d164 1
a164 1
   obj1ShipReward_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d171 1
a171 1
   obj1CumShipReward_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d196 1
a196 1
   fssShipVol_.convCopy (prepNonNegFloatVec (theValue, noOpAlt ()));
@


1.51
log
@Double Precision.
@
text
@d629 1
a629 1
float WitCumShipBoundSet::boundedVal (WitPeriod thePer) const
@


1.50
log
@Double Precision.
@
text
@d107 1
a107 1
      cumDemandVol_[thePer] = cumSum;
d424 1
a424 1
   WitPeriod t;
d446 1
a446 1
   forEachPeriod (t, myProblem ())
d448 1
a448 1
      fprintf (solnFile (), "%6d", t);
d450 4
a453 4
      writeSolnValue (demandVol ()[t]);
      writeSolnValue (cumDemandVol ()[t]);
      writeSolnValue (shipVol ()[t]);
      writeSolnValue (cumShipVol ()[t]);
d457 3
a459 1
         fprintf (solnFile (), "      %1s", (t <= focusHorizon ())? "*": " ");
d461 1
a461 1
         writeSolnValue (fssShipVol ()[t]);
d629 1
a629 1
float WitCumShipBoundSet::boundedVal (WitPeriod t) const
d631 1
a631 1
   return myDemand_->cumShipVol ()[t];
@


1.49
log
@Double Precision.
@
text
@d99 1
a99 1
   demandVol_.copyFltCVec (prepNonNegFloatVec (theValue, postprocAlt ()));
d119 1
a119 1
   priority_.copyCVec (theValue);
d126 1
a126 1
   buildAheadUB_.copyCVec (prepBuildAheadUB (theValue));
d141 1
a141 1
   shipLateUB_.copyCVec (theValue);
d162 1
a162 1
   obj1ShipReward_.copyFltCVec (prepObj1FloatVec (theValue, postprocAlt ()));
d169 1
a169 1
   obj1CumShipReward_.copyFltCVec (prepObj1FloatVec (theValue, postprocAlt ()));
d194 1
a194 1
   fssShipVol_.copyFltCVec (prepNonNegFloatVec (theValue, noOpAlt ()));
d415 1
a415 1
      theDemand->priority_.copyTVec (newPriority (theDemand));
@


1.48
log
@Double Precision.
@
text
@d176 1
a176 1
   copyInto (shipVol_, prepSchedVec (theValue, postprocAlt ()));
@


1.47
log
@Double Precision.
@
text
@d119 1
a119 1
   priority_.copyCvector (theValue);
d126 1
a126 1
   buildAheadUB_.copyCvector (prepBuildAheadUB (theValue));
d141 1
a141 1
   shipLateUB_.copyCvector (theValue);
@


1.46
log
@Continued double precision.
@
text
@d99 1
a99 1
   demandVol_.copyCvector (prepNonNegFloatVec (theValue, postprocAlt ()));
d162 1
a162 1
   obj1ShipReward_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
d169 1
a169 1
   obj1CumShipReward_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
d194 1
a194 1
   fssShipVol_.copyCvector (prepNonNegFloatVec (theValue, noOpAlt ()));
d381 2
a382 1
   objChoice ()->displayForObj2 ("demandGrossRevDdMsg", grossRev ());
d384 1
a384 1
   objChoice ()->displayForObj2 ("demandNetRevDdMsg", netRev ());
d386 4
a389 11
   myMsgFac () ("focusHorizonDdMsg", focusHorizon ());

   myMsgFac () ("demVolDdMsg", demandVol ());

   myProblem ()->display ("demPriDdMsg", priority ());

   myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB ());

   myProblem ()->display ("shipLateUBDdMsg", shipLateUB ());

   objChoice ()->displayForObj1 ("demShipRewardDdMsg", obj1ShipReward ());
d391 1
d572 11
a582 11
   prefBuildAhead_ = theDemand->prefBuildAhead ();
   grossRev_       = theDemand->grossRev ();
   focusHorizon_   = theDemand->focusHorizon ();

   demandVol_        .copy (theDemand->demandVol ());
   cumDemandVol_     .copy (theDemand->cumDemandVol ());
   priority_         .copy (theDemand->priority ());
   buildAheadUB_     .copy (theDemand->buildAheadUB ());
   shipLateUB_       .copy (theDemand->shipLateUB ());
   obj1ShipReward_   .copy (theDemand->obj1ShipReward ());
   obj1CumShipReward_.copy (theDemand->obj1CumShipReward ());
d584 1
a584 1
   cumShipBounds_->set (theDemand->cumShipBounds ());
@


1.45
log
@Continued double precision.
@
text
@d153 1
a153 1
void WitDemand::setGrossRev (StrDbl theValue)
d155 1
a155 1
   grossRev_ = prepNonNegStrDbl (theValue, postprocAlt ());
d550 1
a550 1
   myDataWriter ()->writeStrDbl (
@


1.44
log
@Continued double precision.
@
text
@d349 1
a349 1
float WitDemand::netRev () const
@


1.43
log
@Continued implementation of PIP.
@
text
@d153 1
a153 1
void WitDemand::setGrossRev (float theValue)
d155 1
a155 1
   grossRev_ = prepNonNegFloat (theValue, postprocAlt ());
d550 1
a550 1
   myDataWriter ()->writeFloat (
@


1.42
log
@Removed a bad function overload.
@
text
@d20 2
a22 1
#include <OptComp.h>
@


1.41
log
@Continued implementation of post-implosion pegging.
@
text
@d245 1
a245 1
WitDemand * WitDemand::myDemand ()
@


1.40
log
@Continued implementation of post-implosion pegging.
@
text
@a29 1
#include <ScheduleI.h>
d34 1
@


1.39
log
@Continued implementation of opt with COIN.
@
text
@a34 1
#include <FlexVecI.h>
@


1.38
log
@Made modifications to improve the speed of witPurgeData.
@
text
@d408 3
a410 2
   WitTimingEvent theEvent    ("preproc");
   WitDemand *    theDemand;
d421 2
@


1.37
log
@Continued implementation of proportionate routing.
@
text
@d217 2
a218 1
   myMsgFac () ("demandInstIDMsg", demandedPartName (), demandName ());
@


1.36
log
@Continued implementation of proportionate routing.
@
text
@d245 1
a245 1
void WitDemand::getDemand (WitDemand * & theDemand)
d247 1
a247 1
   theDemand = this;
@


1.35
log
@Removed all const_casts from WIT.
@
text
@d329 1
a329 2
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d333 1
a333 1
   theItr.attachTo (myPegElsFor_ (shipPer));
d335 2
a336 2
   while (theItr.advance (thePegEl))
      theFixedPegEls.push (thePegEl->myFixedPegEl ()); 
d472 7
@


1.34
log
@Internal changes.
@
text
@d325 3
a327 3
void WitDemand::getMyPegEls (
      WitPeriod                      shipPer,
      WitObjStack <const WitPegEl> & thePegEls)
d332 1
a332 1
   thePegEls.clear ();
d337 1
a337 1
      thePegEls.push (thePegEl); 
@


1.33
log
@Internal changes.
@
text
@d307 1
a307 1
   witAssert (! myPegElsFor_.isAllocated ());
d316 1
a316 1
   witAssert (! myGlobalComp ()->perfPegging ());
d483 1
a483 1
   witAssert (! isNullString (theName));
@


1.32
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d146 1
a146 1
void WitDemand::setPrefBuildAhead (WitBoolean theValue)
d148 1
a148 1
   prefBuildAhead_ = prepBoolean (theValue, postprocAlt ());
d201 1
a201 1
WitBoolean WitDemand::inserted ()
d424 1
a424 1
void WitDemand::writeSoln (WitBoolean fssInput)
d535 1
a535 1
   myDataWriter ()->writeBoolean (
@


1.31
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d35 1
@


1.30
log
@Continued implementation of Single-Source.
@
text
@d21 1
@


1.29
log
@Continued implementation of Single-Source.
@
text
@d28 1
a28 1
#include <PegSite.h>
d30 2
d60 1
a60 1
      myPegSite_         (NULL)
d65 1
a65 1
      myPegSite_ = new WitPegSite (myProblem ());
d75 1
a75 5
   delete myPegSite_;
   delete cumShipBounds_;
   }

//------------------------------------------------------------------------------
d77 2
a78 3
const WitString & WitDemand::demandedPartName ()
   {
   return demandedPart ()->partName ();
d282 1
a282 1
   myHeurAllMgr ()->loadPegDataFrom (this, myPegSite_);
d305 1
a305 1
   witAssert (myPegSite_ == NULL);
d307 1
a307 1
   myPegSite_ = new WitPegSite (myProblem ());
d316 1
a316 1
   witAssert (myPegSite_ != NULL);
d318 1
a318 3
   delete myPegSite_;

   myPegSite_ = NULL;
d323 1
a323 1
void WitDemand::getMyOpnPegEls (
d327 4
a330 1
   witAssert (myPegSite_ != NULL);
d332 5
a336 2
   myPegSite_->getMyOpnPegEls (shipPer, thePegEls);
   }
d340 1
a340 3
void WitDemand::getMySubPegEls (
      WitPeriod                      shipPer,
      WitObjStack <const WitPegEl> & thePegEls)
d342 1
a342 3
   witAssert (myPegSite_ != NULL);

   myPegSite_->getMySubPegEls (shipPer, thePegEls);
d468 7
d586 14
@


1.28
log
@Continued implementation of Single-Source.
@
text
@d281 9
d324 22
@


1.27
log
@Continued implementation of single-source.
@
text
@d29 1
a29 1
#include <Schedule.h>
@


1.26
log
@Continued implementation of single-source.
@
text
@d26 1
d263 14
@


1.25
log
@Continued implementation of single-source.
@
text
@d25 1
d248 14
@


1.24
log
@Continued implementation of single-source.
@
text
@a24 1
#include <Post.h>
a25 1
#include <wit/src/Variant.h>
a404 74
      }
   }

//------------------------------------------------------------------------------

void WitDemand::compDefFssShipVol ()
   {
   copyInto (fssShipVol_, shipVol_);
   }

//------------------------------------------------------------------------------
// compFssShipVol ()
//
// Local Variables:
//
// cumShipVolThePer:      Cumulative shipment volume in thePer.
// cDFHorizon:            Cumulative demand volume at the focus horizon
// cumFssShipVolT:        Cumulative of fssShipVol_[thePer].
// cumFssShipVolThePer_1: Cumulative of fssShipVol_[thePer - 1].
//------------------------------------------------------------------------------

void WitDemand::compFssShipVol ()
   {
   WitPeriod thePer;
   double    cumShipVolThePer;
   double    cDFHorizon;
   double    cumFssShipVolThePer;
   double    cumFssShipVolThePer_1;

   witAssert (myGlobalComp ()->useFocusHorizons ());

   cumShipVolThePer = 0.0;

   cDFHorizon =
      (focusHorizon_ >= 0)?
         cumDemandVol_[focusHorizon_]:
         0.0;

   cumFssShipVolThePer = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      cumShipVolThePer += shipVol_[thePer];

      cumFssShipVolThePer_1 = cumFssShipVolThePer;

      cumFssShipVolThePer =
         (thePer <= focusHorizon_)?
            cumDemandVol_[thePer]:
            max (cDFHorizon, cumShipVolThePer);

      fssShipVol_[thePer] = cumFssShipVolThePer - cumFssShipVolThePer_1;
      }
   }

//------------------------------------------------------------------------------

void WitDemand::compCumShipVol ()
   {
   double    cumSum;
   WitPeriod thePer;

   if (shipVol_ == 0.0)
      cumShipVol_.setToScalar (0.0);
   else
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum += shipVol_[thePer];

         cumShipVol_.elemRef (thePer) = cumSum;
         }
@


1.23
log
@Continued implementation of single-source.
@
text
@a252 8
void WitDemand::importPostprocResults ()
   {
   if (! myProblem ()->currentVariant ()->compsSecScheds ())
      cumShipVol_.copyTVec (myPostprocessor ()->cumShipVol (this));
   }

//------------------------------------------------------------------------------

d459 22
@


1.22
log
@Continued implementation of single-source.
@
text
@d25 1
d27 1
d253 1
a253 1
void WitDemand::importFssResults ()
d255 2
d416 7
@


1.21
log
@Preliminary work on single source.
@
text
@d251 6
d411 45
@


1.20
log
@Continued preliminary work on single source.
@
text
@d98 1
a98 1
   demandVol_.copyFromCvector (prepNonNegFloatVec (theValue, postprocAlt ()));
d118 1
a118 1
   priority_ = theValue;
d125 1
a125 1
   buildAheadUB_ = prepBuildAheadUB (theValue);
d140 1
a140 1
   shipLateUB_ = theValue;
d161 1
a161 1
   obj1ShipReward_ = prepObj1FloatVec (theValue, postprocAlt ());
d168 1
a168 1
   obj1CumShipReward_ = prepObj1FloatVec (theValue, postprocAlt ());
d193 1
a193 1
   fssShipVol_.copyFromCvector (prepNonNegFloatVec (theValue, noOpAlt ()));
d359 1
a359 1
      theDemand->priority_ = newPriority (theDemand);
d500 13
a512 11
   demandVol_     .copy (theDemand->demandVol ());
   cumDemandVol_  .copy (theDemand->cumDemandVol ());
   cumShipBounds_->set  (theDemand->cumShipBounds ());
   priority_           = theDemand->priority ();
   buildAheadUB_       = theDemand->buildAheadUB ();
   shipLateUB_         = theDemand->shipLateUB ();
   prefBuildAhead_     = theDemand->prefBuildAhead ();
   grossRev_           = theDemand->grossRev ();
   obj1ShipReward_     = theDemand->obj1ShipReward ();
   obj1CumShipReward_  = theDemand->obj1CumShipReward ();
   focusHorizon_       = theDemand->focusHorizon ();
@


1.19
log
@Continued preliminary work on single source.
@
text
@d27 1
d348 2
a349 3
   WitTimingEvent               theEvent    ("preproc");
   WitDemand *                  theDemand;
   WitSchedule (WitDemand, int) newPriority (theProblem, 0);
d351 1
@


1.18
log
@Continued implementation of object iteration.
@
text
@d97 1
a97 1
   demandVol_ = prepNonNegFloatVec (theValue, postprocAlt ());
d192 1
a192 1
   fssShipVol_ = prepNonNegFloatVec (theValue, noOpAlt ());
d499 11
a509 11
   demandVol_         = theDemand->demandVol ();
   cumDemandVol_      = theDemand->cumDemandVol ();
   cumShipBounds_->set (theDemand->cumShipBounds ());
   priority_          = theDemand->priority ();
   buildAheadUB_      = theDemand->buildAheadUB ();
   shipLateUB_        = theDemand->shipLateUB ();
   prefBuildAhead_    = theDemand->prefBuildAhead ();
   grossRev_          = theDemand->grossRev ();
   obj1ShipReward_    = theDemand->obj1ShipReward ();
   obj1CumShipReward_ = theDemand->obj1CumShipReward ();
   focusHorizon_      = theDemand->focusHorizon ();
@


1.17
log
@Continued implementation of object iteration.
@
text
@d250 1
a250 1
WitAttr WitDemand::apiItrState ()
@


1.16
log
@Continued implementation of object iteration.
@
text
@d252 1
a252 1
   return WitITR_AT_DEMAND;
@


1.15
log
@Began implementation of object iteration.
@
text
@d27 1
d183 1
a183 1
   focusHorizon_ = prepRangedInt (theValue, noopAlt (), -1, lastPeriod ());
d192 1
a192 1
   fssShipVol_ = prepNonNegFloatVec (theValue, noopAlt ());
d239 14
@


1.14
log
@Minor change.
@
text
@d27 1
d71 7
@


1.13
log
@Continued implementation of pegging.
@
text
@d57 1
a57 1
   if (myGlobalComp ()->peggingNeeded ())
d243 1
a243 1
   witAssert (myGlobalComp ()->peggingNeeded ());
d254 1
a254 1
   witAssert (! myGlobalComp ()->peggingNeeded ());
@


1.12
log
@Continued implementation of pegging.
@
text
@d57 1
a57 1
   if (myGlobalComp ()->pegging ())
d243 1
a243 1
   witAssert (myGlobalComp ()->pegging ());
d254 1
a254 1
   witAssert (! myGlobalComp ()->pegging ());
@


1.11
log
@Continued implementation of pegging.
@
text
@d53 1
a53 2
      myOpnPegSite_      (NULL),
      mySubPegSite_      (NULL)
d58 1
a58 4
      {
      myOpnPegSite_ = new WitPegSite <WitOperation> (myProblem ());
      mySubPegSite_ = new WitPegSite <WitSubEntry>  (myProblem ());
      }
d68 1
a68 2
   delete mySubPegSite_;
   delete myOpnPegSite_;
d241 1
a241 1
void WitDemand::startUpPegging ()
d245 1
a245 1
   witAssert (myOpnPegSite_ == NULL);
d247 1
a247 2
   myOpnPegSite_ = new WitPegSite <WitOperation> (myProblem ());
   mySubPegSite_ = new WitPegSite <WitSubEntry>  (myProblem ());
d256 1
a256 1
   witAssert (myOpnPegSite_ != NULL);
d258 1
a258 2
   delete mySubPegSite_;
   delete myOpnPegSite_;
d260 1
a260 2
   mySubPegSite_ = NULL;
   myOpnPegSite_ = NULL;
@


1.10
log
@Continued implementation of pegging.
@
text
@d58 1
a58 1
   if (myGlobalComp ()->perfPegging ())
d248 1
a248 1
   witAssert (myGlobalComp ()->perfPegging ());
d260 1
a260 1
   witAssert (! myGlobalComp ()->perfPegging ());
@


1.9
log
@Continued implementation of pegging.
@
text
@d58 1
a58 1
   if (myGlobalComp ()->doPegging ())
d248 1
a248 1
   witAssert (myGlobalComp ()->doPegging ());
d260 1
a260 1
   witAssert (! myGlobalComp ()->doPegging ());
@


1.8
log
@Initial implementation of pegging.
@
text
@d53 2
a54 1
      myPegSite_         (NULL)
d59 4
a62 1
      myPegSite_ = new WitPegSite (myProblem ());
d72 2
a73 1
   delete myPegSite_;
d250 1
a250 1
   witAssert (myPegSite_ == NULL);
d252 2
a253 1
   myPegSite_ = new WitPegSite (myProblem ());
d262 1
a262 1
   witAssert (myPegSite_ != NULL);
d264 2
a265 1
   delete myPegSite_;
d267 2
a268 1
   myPegSite_ = NULL;
@


1.7
log
@Implemented and used class SelMgr.
@
text
@d26 1
d52 2
a53 1
      cumShipVol_        (myProblem (), 0.0)
d57 3
d68 1
d237 24
@


1.6
log
@Coarse selection splitting.
@
text
@a467 6

implementClearContents (WitDemand)
   //
   // See RWClient.h.

//------------------------------------------------------------------------------
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d223 1
a223 1
   myCompMgr ()->recount (this);
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d159 1
a159 1
   copyTo (shipVol_, prepSchedVec (theValue, postprocAlt ()));
d205 1
a205 1
void WitDemand::copyInto (WitCompMgr * theCompMgr)
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d159 1
a159 1
   shipVol_ = prepSchedVec (theValue, postprocAlt ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d70 1
a70 1
   return theProblem->nPeriods () - 1;
d168 1
a168 1
   focusHorizon_ = prepRangedInt (theValue, noopAlt (), -1, nPeriods () - 1);
d237 1
a237 1
   return WitUtil::positivePart (grossRev () - demandedPart ()->unitCost ());
d362 1
a362 1
   witAssert (! WitUtil::isNullString (theName));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.65;
access;
symbols
	sce_5_01_20080919:1.58
	latest_sce_4_20_20060523:1.39.0.2
	sce_4_20_20060523:1.39
	latest_sce4_20_OSL:1.38.0.2
	sce_4_20_OSL:1.38
	sce_410_withVa:1.26
	sce_4_05_20040511:1.18
	sce_4_00_20040201:1.12
	nextGenBranch:1.7.0.2
	nextGenRoot:1.7
	sce_3_30_20030627:1.7
	EndRw-branch:1.2.0.4
	Root-of-EndRw:1.2
	rwToStl:1.2.0.2;
locks; strict;
comment	@ * @;


1.65
date	2011.09.28.23.49.59;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.09.24.00.28.22;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.30.20.17.59;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.07.22.58.48;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.07.19.27.33;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.07.18.32.30;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.15.19.57.34;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.15.17.15.35;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.01.20.11.36;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.30.21.44.18;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.08.18.26.10;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.05.21.06.02;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.05.18.48.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.04.21.06.39;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.04.20.07.11;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.30.16.07.02;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.30.16.01.20;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.27.21.03.05;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.10.00.08.15;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.08.22.47.36;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.07.22.14.54;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.07.19.55.37;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.02.17.34.09;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.02.20.00.43;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.02.17.34.56;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.01.23.33.33;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.01.23.31.13;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.01.19.23.25;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.30.22.58.57;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.30.21.57.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.27.21.50.19;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.27.20.31.00;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.28.20.14.37;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.03.21.20.30;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.01.22.39.21;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.04.00.02.47;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.14.20.02.34;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.27.21.26.48;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.14.15.32.20;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.11.19.28.23;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.05.22.19.59;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.30.23.07.51;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.13.00.17.51;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.18.29.14;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.02.20.46.43;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.19.16.48.25;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.25.19.16.57;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.23.20.47.19;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.02.23.40.48;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.02.22.18.44;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.11.18.53.15;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.23.18.09.16;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "PreHelp.C"
//
// Contains the implementation of the following classes and templates:
//
//    BelowLister
//    AvSorter <SortEntry>
//------------------------------------------------------------------------------

#include <Below.h>
#include <AvSorter.h>
#include <BopEntry.h>
#include <SubEntry.h>
#include <Part.h>
#include <Operation.h>
#include <ObjStack.h>
#include <PtrVecSort.h>

//------------------------------------------------------------------------------
// Implementation of class BelowLister.
//------------------------------------------------------------------------------

WitBelowLister::WitBelowLister (WitProblem * theProblem):

      WitProbAssoc    (theProblem),
      isBelowCurrent_ ()
   {
   }

//------------------------------------------------------------------------------

WitBelowLister::~WitBelowLister ()
   {
   }

//------------------------------------------------------------------------------

void WitBelowLister::buildBelow ()
   {
   WitPart * thePart;

   isBelowCurrent_.allocate (myProblem (), false);

   forEachPart (thePart, myProblem ())
      buildBelow (thePart);

   isBelowCurrent_.clear  ();
   }

//------------------------------------------------------------------------------

void WitBelowLister::buildBelow (WitPart * thePart)
   {
   WitObjStack <WitPart> theParts (myProblem ());
   WitBopEntry *         theBopEnt;
   WitOperation *        theOpn;
   WitBomEntry *         theBomEnt;
   WitSubEntry *         theSub;
   WitPtrVec <WitPart>   belowListForPart;
   int                   theIdx;
   WitPart *             thePartBelow;


   theParts.push (thePart);

   isBelowCurrent_ (thePart) = true;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         {
         theOpn = theBopEnt->myOperation ();

         forEachEl (theBomEnt, theOpn->bom ())
            {
            mergeBelow (theBomEnt, theParts);

            forEachEl (theSub, theBomEnt->mySubEntries ())
               mergeBelow (theSub, theParts);
            }
         }

   belowListForPart.resize (theParts.nElements ());

   theIdx = -1;

   while (theParts.pop (thePartBelow))
      {
      theIdx ++;

      belowListForPart[theIdx] = thePartBelow;

      isBelowCurrent_ (thePartBelow) = false;
      }

   if (belowListForPart.length () > 1)
      sort (
           belowListForPart,
         & WitBelowLister::compareParts,
           this);

   thePart->storePreBelowList (belowListForPart);
   }

//------------------------------------------------------------------------------

void WitBelowLister::mergeBelow (
      WitConsEntry *          theConsEnt,
      WitObjStack <WitPart> & theParts)
   {
   WitPtrVecItr <WitPart> theItr;
   WitPart *              thePart;

   theConsEnt->myPart ()->belowList ().attachItr (theItr);

   while (theItr.advance (thePart))
      if (not isBelowCurrent_ (thePart))
         {
         theParts.push (thePart);

         isBelowCurrent_ (thePart) = true;
         }
   }

//------------------------------------------------------------------------------

bool WitBelowLister::compareParts (WitPart * thePart1, WitPart * thePart2)
   {
   int theIdx1;
   int theIdx2;

   theIdx1 = thePart1->sortedPartIndex ();
   theIdx2 = thePart2->sortedPartIndex ();

   return (theIdx1 > theIdx2);
   }

//------------------------------------------------------------------------------
// Implementation of class template AvSorter <SortEntry>
//------------------------------------------------------------------------------

template <typename SortEntry> 
      WitAvSorter <SortEntry>::WitAvSorter (int nEntries):

         workingVec_ (nEntries)
   {
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      WitAvSorter <SortEntry>::~WitAvSorter ()
   {
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      void WitAvSorter <SortEntry>::sort (WitList <SortEntry> & theList)
   {
   int         theIdx;
   SortEntry * theSortEnt;
   int         nEntries;

   if (inOrder (theList))
      return;

   theIdx = -1;

   forEachEl (theSortEnt, theList)
      {
      theIdx ++;

      workingVec_[theIdx] = theSortEnt;
      }

   nEntries = theList.nElements ();

   WitNonClass::sort (
        workingVec_,
        nEntries,
      & WitAvSorter <SortEntry>::compareAversions,
        this);

   theList.clear ();

   for (theIdx = 0; theIdx < nEntries; theIdx ++)
      theList.append (workingVec_[theIdx]);
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      bool WitAvSorter <SortEntry>::inOrder (
         const WitList <SortEntry> & theList)
   {
   SortEntry * curSortEnt;
   SortEntry * prevSortEnt;

   prevSortEnt = NULL;

   forEachEl (curSortEnt, theList)
      {
      if (prevSortEnt != NULL)
         if (aversion (curSortEnt) < aversion (prevSortEnt))
            return false;

      prevSortEnt = curSortEnt;
      }

   return true;
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      bool WitAvSorter <SortEntry>::compareAversions (
         SortEntry * theSortEnt1,
         SortEntry * theSortEnt2)
   {
   double aversion1;
   double aversion2;
   int    theIdx1;
   int    theIdx2;

   aversion1 = aversion (theSortEnt1);
   aversion2 = aversion (theSortEnt2);

   if (aversion1 < aversion2)
      return true;

   if (aversion1 > aversion2)
      return false;

   theIdx1 = theSortEnt1->mappingIndex ();
   theIdx2 = theSortEnt2->mappingIndex ();

   return (theIdx1 < theIdx2);
   }

//------------------------------------------------------------------------------

template <>
      double WitAvSorter <WitBopEntry>::aversion (WitBopEntry * theBopEnt)
   {
   return theBopEnt->expAversion ();
   }

//------------------------------------------------------------------------------

template <>
      double WitAvSorter <WitSubEntry>::aversion (WitSubEntry * theSub)
   {
   return theSub->expNetAversion ();
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template AvSorter <SortEntry>
//------------------------------------------------------------------------------

template class WitAvSorter <WitBopEntry>;
template class WitAvSorter <WitSubEntry>;
@


1.64
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.63
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d34 4
a37 4
WitProbAssoc    (theProblem),
isBelowCurrent_ ()
{
}
d42 2
a43 2
{
}
d48 2
a49 2
{
WitPart * thePart;
d51 1
a51 1
isBelowCurrent_.allocate (myProblem (), false);
d53 2
a54 2
forEachPart (thePart, myProblem ())
buildBelow (thePart);
d56 2
a57 2
isBelowCurrent_.clear  ();
}
d62 9
a70 9
{
WitObjStack <WitPart> theParts (myProblem ());
WitBopEntry *         theBopEnt;
WitOperation *        theOpn;
WitBomEntry *         theBomEnt;
WitSubEntry *         theSub;
WitPtrVec <WitPart>   belowListForPart;
int                   theIdx;
WitPart *             thePartBelow;
d73 1
a73 1
theParts.push (thePart);
d75 1
a75 1
isBelowCurrent_ (thePart) = true;
d77 4
a80 4
forEachEl (theBopEnt, thePart->producingBopEntries ())
if (theBopEnt->expAllowed ())
{
theOpn = theBopEnt->myOperation ();
d82 3
a84 3
forEachEl (theBomEnt, theOpn->bom ())
{
mergeBelow (theBomEnt, theParts);
d86 4
a89 4
forEachEl (theSub, theBomEnt->mySubEntries ())
mergeBelow (theSub, theParts);
}
}
d91 1
a91 1
belowListForPart.resize (theParts.nElements ());
d93 1
a93 1
theIdx = -1;
d95 3
a97 3
while (theParts.pop (thePartBelow))
{
theIdx ++;
d99 1
a99 1
belowListForPart[theIdx] = thePartBelow;
d101 2
a102 2
isBelowCurrent_ (thePartBelow) = false;
}
d104 5
a108 5
if (belowListForPart.length () > 1)
sort (
belowListForPart,
& WitBelowLister::compareParts,
this);
d110 2
a111 2
thePart->storePreBelowList (belowListForPart);
}
d116 16
a131 16
WitConsEntry *          theConsEnt,
WitObjStack <WitPart> & theParts)
{
WitPtrVecItr <WitPart> theItr;
WitPart *              thePart;

theConsEnt->myPart ()->belowList ().attachItr (theItr);

while (theItr.advance (thePart))
if (not isBelowCurrent_ (thePart))
{
theParts.push (thePart);

isBelowCurrent_ (thePart) = true;
}
}
d136 3
a138 3
{
int theIdx1;
int theIdx2;
d140 2
a141 2
theIdx1 = thePart1->sortedPartIndex ();
theIdx2 = thePart2->sortedPartIndex ();
d143 2
a144 2
return (theIdx1 > theIdx2);
}
d150 2
a151 2
template <typename SortEntry>
WitAvSorter <SortEntry>::WitAvSorter (int nEntries):
d153 3
a155 3
workingVec_ (nEntries)
{
}
d159 4
a162 4
template <typename SortEntry>
WitAvSorter <SortEntry>::~WitAvSorter ()
{
}
d166 6
a171 6
template <typename SortEntry>
void WitAvSorter <SortEntry>::sort (WitList <SortEntry> & theList)
{
int         theIdx;
SortEntry * theSortEnt;
int         nEntries;
d173 2
a174 2
if (inOrder (theList))
return;
d176 1
a176 1
theIdx = -1;
d178 3
a180 3
forEachEl (theSortEnt, theList)
{
theIdx ++;
d182 2
a183 2
workingVec_[theIdx] = theSortEnt;
}
d185 1
a185 1
nEntries = theList.nElements ();
d187 5
a191 5
WitNonClass::sort (
workingVec_,
nEntries,
& WitAvSorter <SortEntry>::compareAversions,
this);
d193 1
a193 1
theList.clear ();
d195 3
a197 3
for (theIdx = 0; theIdx < nEntries; theIdx ++)
theList.append (workingVec_[theIdx]);
}
d201 6
a206 6
template <typename SortEntry>
bool WitAvSorter <SortEntry>::inOrder (
const WitList <SortEntry> & theList)
{
SortEntry * curSortEnt;
SortEntry * prevSortEnt;
d208 1
a208 1
prevSortEnt = NULL;
d210 5
a214 5
forEachEl (curSortEnt, theList)
{
if (prevSortEnt != NULL)
if (aversion (curSortEnt) < aversion (prevSortEnt))
return false;
d216 2
a217 2
prevSortEnt = curSortEnt;
}
d219 2
a220 2
return true;
}
d224 9
a232 9
template <typename SortEntry>
bool WitAvSorter <SortEntry>::compareAversions (
SortEntry * theSortEnt1,
SortEntry * theSortEnt2)
{
double aversion1;
double aversion2;
int    theIdx1;
int    theIdx2;
d234 2
a235 2
aversion1 = aversion (theSortEnt1);
aversion2 = aversion (theSortEnt2);
d237 2
a238 2
if (aversion1 < aversion2)
return true;
d240 2
a241 2
if (aversion1 > aversion2)
return false;
d243 2
a244 2
theIdx1 = theSortEnt1->mappingIndex ();
theIdx2 = theSortEnt2->mappingIndex ();
d246 2
a247 2
return (theIdx1 < theIdx2);
}
d252 4
a255 4
double WitAvSorter <WitBopEntry>::aversion (WitBopEntry * theBopEnt)
{
return theBopEnt->expAversion ();
}
d260 4
a263 4
double WitAvSorter <WitSubEntry>::aversion (WitSubEntry * theSub)
{
return theSub->expNetAversion ();
}
@


1.62
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d34 4
a37 4
      WitProbAssoc    (theProblem),
      isBelowCurrent_ ()
   {
   }
d42 2
a43 2
   {
   }
d48 2
a49 2
   {
   WitPart * thePart;
d51 1
a51 1
   isBelowCurrent_.allocate (myProblem (), false);
d53 2
a54 2
   forEachPart (thePart, myProblem ())
      buildBelow (thePart);
d56 2
a57 2
   isBelowCurrent_.clear  ();
   }
d62 9
a70 9
   {
   WitObjStack <WitPart> theParts (myProblem ());
   WitBopEntry *         theBopEnt;
   WitOperation *        theOpn;
   WitBomEntry *         theBomEnt;
   WitSubEntry *         theSub;
   WitPtrVec <WitPart>   belowListForPart;
   int                   theIdx;
   WitPart *             thePartBelow;
d73 1
a73 1
   theParts.push (thePart);
d75 1
a75 1
   isBelowCurrent_ (thePart) = true;
d77 4
a80 4
   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         {
         theOpn = theBopEnt->myOperation ();
d82 3
a84 3
         forEachEl (theBomEnt, theOpn->bom ())
            {
            mergeBelow (theBomEnt, theParts);
d86 4
a89 4
            forEachEl (theSub, theBomEnt->mySubEntries ())
               mergeBelow (theSub, theParts);
            }
         }
d91 1
a91 1
   belowListForPart.resize (theParts.nElements ());
d93 1
a93 1
   theIdx = -1;
d95 3
a97 3
   while (theParts.pop (thePartBelow))
      {
      theIdx ++;
d99 1
a99 1
      belowListForPart[theIdx] = thePartBelow;
d101 2
a102 2
      isBelowCurrent_ (thePartBelow) = false;
      }
d104 5
a108 5
   if (belowListForPart.length () > 1)
      sort (
           belowListForPart,
         & WitBelowLister::compareParts,
           this);
d110 2
a111 2
   thePart->storePreBelowList (belowListForPart);
   }
d116 16
a131 16
      WitConsEntry *          theConsEnt,
      WitObjStack <WitPart> & theParts)
   {
   WitPtrVecItr <WitPart> theItr;
   WitPart *              thePart;

   theConsEnt->myPart ()->belowList ().attachItr (theItr);

   while (theItr.advance (thePart))
      if (not isBelowCurrent_ (thePart))
         {
         theParts.push (thePart);

         isBelowCurrent_ (thePart) = true;
         }
   }
d136 3
a138 3
   {
   int theIdx1;
   int theIdx2;
d140 2
a141 2
   theIdx1 = thePart1->sortedPartIndex ();
   theIdx2 = thePart2->sortedPartIndex ();
d143 2
a144 2
   return (theIdx1 > theIdx2);
   }
d150 2
a151 2
template <typename SortEntry> 
      WitAvSorter <SortEntry>::WitAvSorter (int nEntries):
d153 3
a155 3
         workingVec_ (nEntries)
   {
   }
d159 4
a162 4
template <typename SortEntry> 
      WitAvSorter <SortEntry>::~WitAvSorter ()
   {
   }
d166 6
a171 6
template <typename SortEntry> 
      void WitAvSorter <SortEntry>::sort (WitList <SortEntry> & theList)
   {
   int         theIdx;
   SortEntry * theSortEnt;
   int         nEntries;
d173 2
a174 2
   if (inOrder (theList))
      return;
d176 1
a176 1
   theIdx = -1;
d178 3
a180 3
   forEachEl (theSortEnt, theList)
      {
      theIdx ++;
d182 2
a183 2
      workingVec_[theIdx] = theSortEnt;
      }
d185 1
a185 1
   nEntries = theList.nElements ();
d187 5
a191 5
   WitNonClass::sort (
        workingVec_,
        nEntries,
      & WitAvSorter <SortEntry>::compareAversions,
        this);
d193 1
a193 1
   theList.clear ();
d195 3
a197 3
   for (theIdx = 0; theIdx < nEntries; theIdx ++)
      theList.append (workingVec_[theIdx]);
   }
d201 6
a206 6
template <typename SortEntry> 
      bool WitAvSorter <SortEntry>::inOrder (
         const WitList <SortEntry> & theList)
   {
   SortEntry * curSortEnt;
   SortEntry * prevSortEnt;
d208 1
a208 1
   prevSortEnt = NULL;
d210 5
a214 5
   forEachEl (curSortEnt, theList)
      {
      if (prevSortEnt != NULL)
         if (aversion (curSortEnt) < aversion (prevSortEnt))
            return false;
d216 2
a217 2
      prevSortEnt = curSortEnt;
      }
d219 2
a220 2
   return true;
   }
d224 9
a232 9
template <typename SortEntry> 
      bool WitAvSorter <SortEntry>::compareAversions (
         SortEntry * theSortEnt1,
         SortEntry * theSortEnt2)
   {
   double aversion1;
   double aversion2;
   int    theIdx1;
   int    theIdx2;
d234 2
a235 2
   aversion1 = aversion (theSortEnt1);
   aversion2 = aversion (theSortEnt2);
d237 2
a238 2
   if (aversion1 < aversion2)
      return true;
d240 2
a241 2
   if (aversion1 > aversion2)
      return false;
d243 2
a244 2
   theIdx1 = theSortEnt1->mappingIndex ();
   theIdx2 = theSortEnt2->mappingIndex ();
d246 2
a247 2
   return (theIdx1 < theIdx2);
   }
d252 4
a255 4
      double WitAvSorter <WitBopEntry>::aversion (WitBopEntry * theBopEnt)
   {
   return theBopEnt->expAversion ();
   }
d260 4
a263 4
      double WitAvSorter <WitSubEntry>::aversion (WitSubEntry * theSub)
   {
   return theSub->expNetAversion ();
   }
@


1.61
log
@Re-organized code.
@
text
@d24 1
a24 1
#include <Opn.h>
@


1.60
log
@Put the implementation of class NodeSorter into its own .C file.
@
text
@a14 1
//    OffsetProc
a18 1
#include <Offset.h>
d22 1
a22 1
#include <Global.h>
a24 1
#include <SubEntry.h>
a28 357
// Implementation of class OffsetProc.
//------------------------------------------------------------------------------

WitOffsetProc::WitOffsetProc (WitProblem * theProblem):

      WitProbAssoc (theProblem),
      truncOffset_ (),
      dblCumLead_  ()
   {
   }

//------------------------------------------------------------------------------

WitOffsetProc::~WitOffsetProc ()
   {
   }

//------------------------------------------------------------------------------

void WitOffsetProc::roundOffsets ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   bool           executableVal;

   WitTVec <double> leadToImpact (myProblem (), 0.0);
   WitTVec <bool>   hasImpact    (myProblem (), false);
      //
      // See updateProdCumLeads.

   if (myGlobalComp ()->truncOffsets ())
      truncateOffsets ();

   dblCumLead_.allocate (myProblem (), 0.0);

   forEachOperation (theOpn, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         executableVal = roundOffsets (theOpn, thePer);

         theOpn->storePreExecutable (thePer, executableVal);

         if (not executableVal)
            resetExec (theOpn, thePer);
         }

      updateProdCumLeads (theOpn, leadToImpact, hasImpact);
      }

   truncOffset_.clear ();
   dblCumLead_ .clear ();
   }

//------------------------------------------------------------------------------

void WitOffsetProc::truncateOffsets ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   truncOffset_.allocate (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      {
      truncateOffset (theBomEnt);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         truncateOffset (theSub);
      }

   forEachBopEntry (theBopEnt, myProblem ())
      truncateOffset (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::truncateOffset (WitBillEntry * theBillEnt)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      truncOffset_ (theBillEnt)[thePer] =
         min (static_cast <double> (thePer), theBillEnt->offset ()[thePer]);
   }

//------------------------------------------------------------------------------
// roundOffsets
//
// Computes impactPeriods for the BomEntries and BopEntries of theOpn in thePer.
// Also checks for the various conditions under which execution of
// theOpn is to be forbidden in thePer.
// If any such condition occurs, computation is terminated and false
// is returned, indicating forbidden execution.
// Otherwise true is returned.
//
// The conditions for forbidding execution are:
//
//   yieldRate         == 0.0
//   cycle time        < 0 (3.4 mode only)
//   release date      < 0 (3.4 mode only)
//   an impactPeriod   < 0, or >= nPeriods
//   execEmptyBom () is false and no BomEntries are in effect in period t.
//------------------------------------------------------------------------------

bool WitOffsetProc::roundOffsets (WitOperation * theOpn, WitPeriod thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   bool          emptyBom;

   if (theOpn->yieldRate ()[thePer] == 0.0)
      return false;

   if (wit34Compatible ())
      if (theOpn->cycleTime34PreventsExec (thePer))
         return false;

   forEachEl (theBomEnt, theOpn->bom ())
      {
      if (not compImpactPeriod (theBomEnt, thePer))
         return false;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (myGlobalComp ()->independentOffsets ())
            compImpactPeriod (theSub, thePer);
         else
            copyImpactPeriod (theSub, thePer);
      }

   forEachEl (theBopEnt, theOpn->bop ())
      if (not compImpactPeriod (theBopEnt, thePer))
         return false;

   if (not myGlobalComp ()->execEmptyBom ())
      {
      emptyBom = true;

      forEachEl (theBomEnt, theOpn->bom ())
         if (theBomEnt->inEffect (thePer))
            emptyBom = false;

      if (emptyBom)
         return false;
      }

   return true;
   }

//------------------------------------------------------------------------------
// compImpactPeriod.
// Computes theConsEnt->impactPeriod_[thePer].
// If the resulting impactPeriod falls outside the time horizon, the
// computation is aborted and the function returns false, indicating that
// execution of theConsEnt->myOperation () should be forbidden in thePer.
// Otherwise returns true.
//
// An initial value for the impactPeriod is computed using a simple integer
// round down of the double workOffset ()[thePer]. The final value is computed
// by rounding the double lead time either up or down so as to have the right
// effect on cumulative lead time.
//
// Variables:
//
//    initImpactPeriod:   Initial value for impactPeriod
//    consDCLead:         The double cum lead time for the consumed Part.
//    propDCLead:         The proposed double cum lead time for the consuming
//                        Operation. The proposed value is taken iff it is
//                        larger than the current value.
//    leadTime:           The int lead time
//    finalImpactPeriod:  Final value for ImpactPeriod
//------------------------------------------------------------------------------

bool WitOffsetProc::compImpactPeriod (
      WitConsEntry * theConsEnt,
      WitPeriod      thePer)
   {
   WitPeriod initImpactPeriod;
   double    consDCLead;
   double    propDCLead;
   int       leadTime;
   WitPeriod finalImpactPeriod;

   theConsEnt->storePreImpactPeriod (thePer, -1);

   if (not theConsEnt->withinInterval (thePer))
      return true;

   initImpactPeriod = thePer - ltRoundDown (workOffset (theConsEnt, thePer));

   if (initImpactPeriod < 0)
      return false;

   if (initImpactPeriod >= nPeriods ())
      return false;

   consDCLead = dblCumLead_ (theConsEnt->myPart ())[initImpactPeriod];

   propDCLead = consDCLead + workOffset (theConsEnt, thePer);

   leadTime =
        ltRoundDown (propDCLead)
      - ltRoundDown (consDCLead);

   finalImpactPeriod = thePer - leadTime;

   if (finalImpactPeriod < 0)
      return false;

   theConsEnt->storePreImpactPeriod (thePer, finalImpactPeriod);

   setToMax (dblCumLead_ (theConsEnt->myOperation ())[thePer], propDCLead);

   return true;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::copyImpactPeriod (WitSubEntry * theSub, WitPeriod thePer)
   {
   WitPeriod impactPer;

   theSub->storePreImpactPeriod (thePer, -1);

   if (theSub->myBomEnt ()->inEffect (thePer))
      if (theSub->withinInterval (thePer))
         {
         impactPer = theSub->myBomEnt ()->impactPeriod () [thePer];

         theSub->storePreImpactPeriod (thePer, impactPer);
         }
   }

//------------------------------------------------------------------------------
// compImpactPeriod for a BopEntry.
//
// Variables:
//
//    opnDCLead:        The double cum lead time for the producing Operation:
//    propDCLead:       The proposed double cum lead time for the produced
//                      Part. The proposed value is taken iff it is larger
//                      than the current value.
//    leadTime:         The int lead time
//    theImpactPeriod:  The impactPeriod
//------------------------------------------------------------------------------

bool WitOffsetProc::compImpactPeriod (
      WitBopEntry * theBopEnt,
      WitPeriod     thePer)
   {
   double    opnDCLead;
   double    propDCLead;
   int       leadTime;
   WitPeriod impactPer;

   theBopEnt->storePreImpactPeriod (thePer, -1);

   if (not theBopEnt->withinInterval (thePer))
      return true;

   opnDCLead  = dblCumLead_ (theBopEnt->myOperation ())[thePer];

   propDCLead = opnDCLead - workOffset (theBopEnt, thePer);

   leadTime =
        ltRoundDown (opnDCLead)
      - ltRoundDown (propDCLead);

   impactPer = thePer - leadTime;

   if (impactPer < 0)
      return false;

   if (impactPer >= nPeriods ())
      return false;

   theBopEnt->storePreImpactPeriod (thePer, impactPer);

   return true;
   }

//------------------------------------------------------------------------------

int WitOffsetProc::ltRoundDown (double leadTime)
   {
   return static_cast <int> (floor (leadTime + 1.0E-3));
   }

//------------------------------------------------------------------------------

void WitOffsetProc::resetExec (WitOperation * theOpn, WitPeriod thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   forEachEl (theBomEnt, theOpn->bom ())
      {
      theBomEnt->storePreImpactPeriod (thePer, -1);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         theSub->storePreImpactPeriod (thePer, -1);
      }

   forEachEl (theBopEnt, theOpn->bop ())
      theBopEnt->storePreImpactPeriod (thePer, -1);

   dblCumLead_ (theOpn)[thePer] = 0.0;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::updateProdCumLeads (
      WitOperation *     theOpn,
      WitTVec <double> & leadToImpact,
      WitTVec <bool> &   hasImpact)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitPeriod     theImpactPer;

   forEachEl (theBopEnt, theOpn->bop ())
      {
      hasImpact = false;

      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->inEffect (thePer))
            {
            theImpactPer = theBopEnt->impactPeriod ()[thePer];

            hasImpact[theImpactPer]    = true;

            leadToImpact[theImpactPer] = 
               dblCumLead_ (theOpn)[thePer] - workOffset (theBopEnt, thePer);
            }

      forEachPeriod (theImpactPer, myProblem ())
         if (hasImpact[theImpactPer])
            setToMax (
               dblCumLead_ (theBopEnt->myPart ())[theImpactPer],
               leadToImpact[theImpactPer]);
      }
   }

//------------------------------------------------------------------------------

double WitOffsetProc::workOffset (WitBillEntry * theBillEnt, WitPeriod thePer)
   {
   return
      myGlobalComp ()->truncOffsets ()?
         truncOffset_ (theBillEnt)[thePer]:
         theBillEnt->offset ()[thePer];
   }

//------------------------------------------------------------------------------
@


1.59
log
@Made a function non-inline to avoid a compiler warning.
@
text
@a14 1
//    NodeSorter
a19 2
#include <Pre.h>
#include <NodeSorter.h>
a29 373
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class NodeSorter.
//------------------------------------------------------------------------------

WitNodeSorter::WitNodeSorter (WitProblem * theProblem):

      WitProbAssoc     (theProblem),
      allNodes_        (),
      successors_      (),
      sorted_          (),
      unsortedPredFor_ (),
      cycleFound_      (false),
      cycleParts_      (myProblem ()),
      cycleOpns_       (myProblem ())
   {
   }

//------------------------------------------------------------------------------

WitNodeSorter::~WitNodeSorter ()
   {
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodesIfNeeded ()
   {
   sortNodesIfNeededInt ();

   if (cycleFound_)
      reportCycle ();
   }

//------------------------------------------------------------------------------

void WitNodeSorter::getExpCycle (
      WitObjStack <WitPart> &      theParts,
      WitObjStack <WitOperation> & theOpns)
   {
   sortNodesIfNeededInt ();

   theParts.takeContentsFrom (cycleParts_);
   theOpns .takeContentsFrom (cycleOpns_);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodesIfNeededInt ()
   {
   int            nBefore;
   WitPart *      thePart;
   WitOperation * theOpn;

   successors_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      successors_ (thePart) = new WitList <WitNode>;

   forEachOperation (theOpn, myProblem ())
      successors_ (theOpn)  = new WitList <WitNode>;

   defineAllNodesSuccessors ();

   if (not nodesInOrder ())
      sortNodes ();

   forEachOperation (theOpn, myProblem ())
      delete successors_ (theOpn);

   forEachPart (thePart, myProblem ())
      delete successors_ (thePart);

   allNodes_  .clear ();
   successors_.clear ();

   if (cycleFound_)
      return;

   nBefore = 0;

   forEachPart (thePart, myProblem ())
      {
      thePart->storePreSortedPartIndex (nBefore);

      nBefore ++;
      }
   }

//------------------------------------------------------------------------------

void WitNodeSorter::defineAllNodesSuccessors ()
   {
   WitPart      * thePart;
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;
   WitSubEntry  * theSub;
   WitBopEntry  * theBopEnt;

   forEachPart (thePart, myProblem ())
      allNodes_.append (thePart);

   forEachOperation (theOpn, myProblem ())
      allNodes_.append (theOpn);

   forEachOperation (theOpn, myProblem ())
      {
      forEachEl (theBomEnt, theOpn->bom ())
         {
         successors_.myElemAt (theBomEnt->myPart ()).append (theOpn);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            successors_.myElemAt (theSub->myPart ()).append (theOpn);
         }
      }

   forEachPart (thePart, myProblem ())
      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            successors_.myElemAt (theBopEnt->myOperation ()).append (thePart);
   }

//------------------------------------------------------------------------------
// nodesInOrder.
// Returns true, iff the Parts and Operations are already in order.
// Variables:
//
//    nBefore
//       nBefore (theNode) is the # of Nodes listed before theNode in allNodes_
//       This indicates the order of the Nodes in allNodes_.
//
//    nBeforeSuccs
//       nBeforeSuccs (theNode) is the minimum # of Nodes listed before
//       any successor to theNode.
//
// The Nodes are considered to be in order iff the Parts are in order and the
// Operations are in order. Since allNodes_ is just a temporary List, a Part
// is allowed to be out of order with respect to an Operation. Abstractly, this
// means that a Node should not be compared to its successors, which are of the
// opposite derived class (Part vs. Operation). Instead, a Node should be
// compared to the successors of its successors, which are of the same derived
// class. Specifically, the Nodes are out of order, iff there exists a Node,
// theNode and a successor to it, succNode, such that:
//
//    nBefore (theNode) >= nBeforeSuccs (succNode)
//------------------------------------------------------------------------------

bool WitNodeSorter::nodesInOrder ()
   {
   WitMapping <WitNode, int> nBefore      (myProblem (), 0);
   WitMapping <WitNode, int> nBeforeSuccs (myProblem (), 0);

   WitNode * theNode;
   WitNode * succNode;
   int nScanned;

   nScanned = 0;

   forEachEl (theNode, allNodes_)
      nBefore (theNode) = nScanned ++;

   forEachEl (theNode, allNodes_)
       {
       nBeforeSuccs (theNode) = myCompMgr ()->nNodes ();

       forEachEl (succNode, successors_.myElemAt (theNode))
          nBeforeSuccs (theNode) =
             min (nBeforeSuccs (theNode), nBefore (succNode));
       }

   forEachEl (theNode, allNodes_)
       forEachEl (succNode, successors_.myElemAt (theNode))
          if (nBefore (theNode) >= nBeforeSuccs (succNode))
             return false;

   return true;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodes ()
   {
   WitList <WitNode> sortedNodes;
      //
      // The sorted List of all Nodes.

   myMsgFac () ("sortNodesMsg");

   sorted_.allocate (myProblem (), false);

   sortNodes (sortedNodes);

   if (sortedNodes.nElements () != myCompMgr ()->nNodes ())
      constructCycle ();

   sorted_.clear ();

   if (not cycleFound_)
      myCompMgr ()->storePreSortedNodes (sortedNodes);
   }

//------------------------------------------------------------------------------
// sortNodes.
// Variables:
//
//    nUnsortedPreds
//       nUnsortedPreds (theNode) is the # of BillEntries to predecessors to
//       theNode that have not yet been sorted. When this value is 0,
//       theNode is eligible to be sorted.
//
//    eligibleNodes
//       The list of all Nodes currently eligible to be sorted: those with
//       no unsorted predecessors.
//------------------------------------------------------------------------------

void WitNodeSorter::sortNodes (WitList <WitNode> & sortedNodes)
   {
   WitMapping <WitNode, int> nUnsortedPreds (myProblem (), 0);

   WitList <WitNode> eligibleNodes;

   WitNode * theNode;
   WitNode * succNode;

   forEachEl (theNode, allNodes_)
      forEachEl (succNode, successors_.myElemAt (theNode))
         ++ nUnsortedPreds (succNode);

   forEachEl (theNode, allNodes_)
      if (nUnsortedPreds (theNode) == 0)
         eligibleNodes.append (theNode);

   while (not eligibleNodes.isEmpty ())
      {
      theNode = eligibleNodes.get ();

      sortedNodes.append (theNode);

      sorted_ (theNode) = true;

      forEachEl (succNode, successors_.myElemAt (theNode))
         {
         -- nUnsortedPreds (succNode);

         if (nUnsortedPreds (succNode) == 0)
             eligibleNodes.append (succNode);
         }
      }
   }

//------------------------------------------------------------------------------

void WitNodeSorter::constructCycle ()
   {
   WitNode * theNode;
   WitNode * succNode;
   WitPart * startingPart;

   unsortedPredFor_.allocate (myProblem ());

   forEachEl (theNode, allNodes_)
      if (not sorted_ (theNode))
         forEachEl (succNode, successors_.myElemAt (theNode))
            unsortedPredFor_ (succNode) = theNode;

   startingPart = findPartInCycle ();

   storeCycle (startingPart);

   unsortedPredFor_.clear ();

   cycleFound_ = true;
   }

//------------------------------------------------------------------------------
// findPartInCycle
// Local Variable:
//
//    scanned
//       scanned (theNode) is true, iff theNode has already been scanned in
//       the search for a cycle. A cycle has been found when a Node gets
//       scanned twice.
//------------------------------------------------------------------------------

WitPart * WitNodeSorter::findPartInCycle ()
   {
   WitMapping <WitNode, bool> scanned (myProblem (), false);
   WitNode *                  theNode;
   WitPart *                  thePart;

   forEachEl (theNode, allNodes_)
      if (not sorted_ (theNode))
         break;

   while (not scanned (theNode))
      {
      scanned (theNode) = true;

      theNode           = unsortedPredFor_ (theNode);
      }

   thePart = theNode->thisPart ();

   if (thePart != NULL)
      return thePart;

   thePart = unsortedPredFor_ (theNode)->thisPart ();

   stronglyAssert (thePart != NULL);

   return thePart;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::storeCycle (WitPart * startingPart)
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   thePart = startingPart;

   do
      {
      cycleParts_.push (thePart);

      theOpn  = unsortedPredFor_ (thePart)->thisOpn ();

      stronglyAssert (theOpn  != NULL);

      cycleOpns_.push (theOpn);

      thePart = unsortedPredFor_ (theOpn) ->thisPart ();

      stronglyAssert (thePart != NULL);
      }
      while (thePart != startingPart);

   cycleParts_.reverse ();
   cycleOpns_ .reverse ();
   }

//------------------------------------------------------------------------------

void WitNodeSorter::reportCycle ()
   {
   WitPart *      firstPart;
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPart *      nextPart;

   myMsgFac () ("bomCycleHeadingSmsg");

   firstPart = cycleParts_.firstObject ();

   while (cycleParts_.pop (thePart))
      {
      cycleOpns_.pop (theOpn);

      nextPart =
         cycleParts_.isNonEmpty ()?
            cycleParts_.firstObject ():
            firstPart;

      myMsgFac () ("bomCycleNodesSmsg",
         thePart ->partName      (),
         theOpn  ->operationName (),
         nextPart->partName      ());
      }

   myMsgFac () ("bomCycleSmsg");
   }
@


1.58
log
@Stochastic Implosion
@
text
@a463 12
inline double WitOffsetProc::workOffset (
      WitBillEntry * theBillEnt, 
      WitPeriod      thePer)
   {
   return
      myGlobalComp ()->truncOffsets ()?
         truncOffset_ (theBillEnt)[thePer]:
         theBillEnt->offset ()[thePer];
   }

//------------------------------------------------------------------------------

d755 10
@


1.57
log
@Stochastic Implosion
@
text
@d91 1
a91 1
      successors_.setMapFor (thePart, * new WitList <WitNode>);
d94 1
a94 1
      successors_.setMapFor (theOpn,  * new WitList <WitNode>);
d102 1
a102 1
      delete & successors_ (theOpn);
d105 1
a105 1
      delete & successors_ (thePart);
d143 1
a143 1
         successors_ (theBomEnt->myPart ()).append (theOpn);
d146 1
a146 1
            successors_ (theSub->myPart ()).append (theOpn);
d153 1
a153 1
            successors_ (theBopEnt->myOperation ()).append (thePart);
d199 1
a199 1
       forEachEl (succNode, successors_ (theNode))
d205 1
a205 1
       forEachEl (succNode, successors_ (theNode))
d259 1
a259 1
      forEachEl (succNode, successors_ (theNode))
d274 1
a274 1
      forEachEl (succNode, successors_ (theNode))
d296 1
a296 1
         forEachEl (succNode, successors_ (theNode))
@


1.56
log
@witGetExpCycle
@
text
@d48 1
a48 4
      cycleOpns_       (myProblem ()),
      allParts_        (),
      allOperations_   (),
      sortedPartIndex_ (myProblem ())
a49 2
   allParts_     .allowAttach ();
   allOperations_.allowAttach ();
a59 20
void WitNodeSorter::receiveRefs (
      WitCompMgr *,
      WitList <WitPart>      & allPartsRef,
      WitList <WitOperation> & allOperationsRef)
   {
   allParts_.     attachTo (allPartsRef);
   allOperations_.attachTo (allOperationsRef);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::receiveRefs (
      WitPart * thePart,
      int &     sortedPartIndexRef)
   {
   sortedPartIndex_.setMapFor (thePart, sortedPartIndexRef);
   }

//------------------------------------------------------------------------------

d117 1
a117 1
      sortedPartIndex_ (thePart) = nBefore;
a219 4
   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;

d231 2
a232 18
   if (cycleFound_)
      return;

   allParts_      ().clear ();
   allOperations_ ().clear ();

   forEachEl (theNode, sortedNodes)
      {     
      thePart = theNode->thisPart ();

      if (thePart != NULL)
         allParts_ ().append (thePart);

      theOpn = theNode->thisOpn ();

      if (theOpn != NULL)
         allOperations_ ().append (theOpn);
      }
d413 3
a415 5
      WitProbAssoc  (theProblem),
      truncOffset_  (),
      dblCumLead_   (),
      executable_   (myProblem ()),
      impactPeriod_ (myProblem ())
a426 18
void WitOffsetProc::receiveRefs (
      WitOperation *   theOpn,
      WitTVec <bool> & executableRef)
   {
   executable_.setMapFor (theOpn, executableRef);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::receiveRefs (
      WitBillEntry *        theBillEnt,
      WitTVec <WitPeriod> & impactPeriodRef)
   {
   impactPeriod_.setMapFor (theBillEnt, impactPeriodRef);
   }

//------------------------------------------------------------------------------

d449 1
a449 1
         executable_ (theOpn)[thePer] = executableVal;
d605 1
a605 1
   impactPeriod_ (theConsEnt)[thePer] = -1;
d631 1
a631 1
   impactPeriod_ (theConsEnt)[thePer] = finalImpactPeriod;
d642 3
a644 1
   impactPeriod_ (theSub)[thePer] = -1;
d648 5
a652 2
         impactPeriod_ (theSub)[thePer] = 
            theSub->myBomEnt ()->impactPeriod () [thePer];
d675 1
a675 1
   WitPeriod theImpactPeriod;
d677 1
a677 1
   impactPeriod_ (theBopEnt)[thePer] = -1;
d690 1
a690 1
   theImpactPeriod = thePer - leadTime;
d692 1
a692 1
   if (theImpactPeriod < 0)
d695 1
a695 1
   if (theImpactPeriod >= nPeriods ())
d698 1
a698 1
   impactPeriod_ (theBopEnt)[thePer] = theImpactPeriod;
d720 1
a720 1
      impactPeriod_ (theBomEnt)[thePer] = -1;
d723 1
a723 1
         impactPeriod_ (theSub)[thePer] = -1;
d727 1
a727 1
      impactPeriod_ (theBopEnt)[thePer] = -1;
d773 1
a773 2
      isBelowCurrent_ (),
      belowList_      (myProblem ())
a784 9
void WitBelowLister::receiveRefs (
      WitPart *             thePart,
      WitPtrVec <WitPart> & belowListRef)
   {
   belowList_.setMapFor (thePart, belowListRef);
   }

//------------------------------------------------------------------------------

d799 1
a799 1
void WitBelowLister::buildBelow (WitPart * currentPart)
d801 8
a808 6
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   int            theIdx;
   WitPart *      theBelowPart;
a809 1
   WitObjStack <WitPart> theParts (myProblem ());
d811 1
a811 1
   theParts.push (currentPart);
d813 1
a813 1
   isBelowCurrent_ (currentPart) = true;
d815 1
a815 1
   forEachEl (theBopEnt, currentPart->producingBopEntries ())
d829 1
a829 1
   belowList_ (currentPart).resize (theParts.nElements ());
d833 1
a833 1
   while (theParts.pop (theBelowPart))
d837 1
a837 1
      belowList_ (currentPart)[theIdx] = theBelowPart;
d839 1
a839 1
      isBelowCurrent_ (theBelowPart) = false;
d842 1
a842 1
   if (currentPart->belowList ().length () > 1)
d844 1
a844 1
           belowList_ (currentPart),
d847 2
@


1.55
log
@witGetExpCycle
@
text
@a398 2
   cycleParts_.push (startingPart);

d403 2
a410 1

a413 2

      cycleParts_.push (thePart);
d425 1
a425 1
   WitPart *      prevPart;
d428 1
d432 1
a432 1
   cycleParts_.pop (prevPart);
d434 1
a434 1
   while (cycleOpns_.pop (theOpn))
d436 6
a441 1
      cycleParts_.pop (thePart);
d444 1
a444 1
         prevPart->partName      (),
d446 1
a446 3
         thePart ->partName      ());

      prevPart = thePart;
@


1.54
log
@Stochastic Implosion
@
text
@d46 3
d87 22
d135 3
d258 5
a262 1
   sorted_          .clear ();
a329 8
// constructCycle
// Variables:
//
//    scanned
//       scanned (theNode) is true, iff theNode has already been scanned in
//       the search for a cycle. A cycle has been found when a Node gets
//       scanned twice.
//------------------------------------------------------------------------------
a332 2
   WitMapping <WitNode, bool> scanned (myProblem (), false);

a333 1
   WitPart * thePart;
d335 1
a335 1
   WitNode * cycleStart;
d344 25
d377 1
a377 1
      theNode = unsortedPredFor_ (theNode);
d382 22
a403 1
   if (thePart == NULL)
d405 5
a409 1
      theNode = unsortedPredFor_ (theNode);
d411 2
a412 1
      thePart = theNode->thisPart ();
d415 2
a416 3
         //
         // The cycle needs to begin with a Part, so that the error message
         // makes sense.
d418 5
d424 7
a430 1
   cycleStart = theNode;
d434 3
a436 1
   do
d438 2
d441 3
a443 3
         theNode->nodeName (),
         unsortedPredFor_ (theNode)->nodeName (),
         unsortedPredFor_ (unsortedPredFor_ (theNode))->nodeName ());
d445 1
a445 1
      theNode = unsortedPredFor_ (unsortedPredFor_ (theNode));
a446 1
      while (theNode != cycleStart);
@


1.53
log
@Stochastic Implosion
@
text
@d64 2
a65 2
      WitList <WitPart>      & allPartsArg,
      WitList <WitOperation> & allOperationsArg)
d67 2
a68 2
   allParts_.     attachTo (allPartsArg);
   allOperations_.attachTo (allOperationsArg);
d75 1
a75 1
      int &     sortedPartIndexArg)
d77 1
a77 1
   sortedPartIndex_.setMapFor (thePart, sortedPartIndexArg);
d390 1
a390 1
      WitTVec <bool> & executableArg)
d392 1
a392 1
   executable_.setMapFor (theOpn, executableArg);
d399 1
a399 1
      WitTVec <WitPeriod> & impactPeriodArg)
d401 1
a401 1
   impactPeriod_.setMapFor (theBillEnt, impactPeriodArg);
d762 1
a762 1
      WitPtrVec <WitPart> & belowListArg)
d764 1
a764 1
   belowList_.setMapFor (thePart, belowListArg);
@


1.52
log
@Stochastic Implosion
@
text
@a21 1
#include <PreData.h>
a30 1
#include <PreAccess.h>
d39 1
a39 1
WitNodeSorter::WitNodeSorter (WitPreData * thePreData):
d41 1
a41 2
      WitProbAssoc     (thePreData->myProblem ()),
      myPreData_       (thePreData),
d98 1
a98 6
   if (nodesInOrder ())
      {
      myPreData_->allParts      () = myCompMgr ()->allParts      ();
      myPreData_->allOperations () = myCompMgr ()->allOperations ();
      }
   else
d112 6
a117 2
   forEachEl (thePart, myPreData_->allParts ())
      myPreData_->sortedPartIndex () (thePart) = nBefore ++;
d230 3
a232 3
   sorted_                     .clear ();
   myPreData_->allParts      ().clear ();
   myPreData_->allOperations ().clear ();
d239 1
a239 1
         myPreData_->allParts ().append (thePart);
d244 1
a244 1
         myPreData_->allOperations ().append (theOpn);
d370 1
a370 1
WitOffsetProc::WitOffsetProc (WitPreData * thePreData):
d372 1
a372 2
      WitProbAssoc  (thePreData->myProblem ()),
      myPreData_    (thePreData),
d422 1
a422 1
   forEachEl (theOpn, myPreData_->allOperations ())
d428 1
a428 1
         myPreData_->executable () (theOpn)[thePer] = executableVal;
d540 1
a540 1
         if (myPreData_->inEffect (theBomEnt, thePer))
d584 1
a584 1
   myPreData_->impactPeriod () (theConsEnt)[thePer] = -1;
d610 1
a610 1
   myPreData_->impactPeriod () (theConsEnt)[thePer] = finalImpactPeriod;
d621 1
a621 1
   myPreData_->  impactPeriod () (theSub)[thePer] = -1;
d623 1
a623 1
   if (myPreData_->inEffect (theSub->myBomEnt (), thePer))
d625 2
a626 2
         myPreData_->   impactPeriod () (theSub)             [thePer] = 
            myPreData_->impactPeriod () (theSub->myBomEnt ())[thePer];
d651 1
a651 1
   myPreData_->impactPeriod () (theBopEnt)[thePer] = -1;
d672 1
a672 1
   myPreData_->impactPeriod () (theBopEnt)[thePer] = theImpactPeriod;
d694 1
a694 1
      myPreData_->impactPeriod () (theBomEnt)[thePer] = -1;
d697 1
a697 1
         myPreData_->impactPeriod () (theSub)[thePer] = -1;
d701 1
a701 1
      myPreData_->impactPeriod () (theBopEnt)[thePer] = -1;
d722 1
a722 1
         if (myPreData_->inEffect (theBopEnt, thePer))
d724 1
a724 1
            theImpactPer = myPreData_->impactPeriod () (theBopEnt)[thePer];
d744 1
a744 1
WitBelowLister::WitBelowLister (WitPreData * thePreData):
d746 1
a746 2
      WitProbAssoc    (thePreData->myProblem ()),
      myPreData_      (thePreData),
d775 1
a775 1
   forEachEl (thePart, myPreData_->allParts ())
d812 1
a812 1
   WitPreAccess::belowList (currentPart).resize (theParts.nElements ());
d820 1
a820 1
      WitPreAccess::belowList (currentPart)[theIdx] = theBelowPart;
d825 1
a825 1
   if (WitPreAccess::belowList (currentPart).length () > 1)
d827 1
a827 1
           WitPreAccess::belowList (currentPart),
d859 2
a860 2
   theIdx1 = myPreData_->sortedPartIndex () (thePart1);
   theIdx2 = myPreData_->sortedPartIndex () (thePart2);
d870 1
a870 3
      WitAvSorter <SortEntry>::WitAvSorter (
            WitPreData * thePreData,
            int          nEntries):
a871 1
         myPreData_  (thePreData),
@


1.51
log
@Stochastic Implosion
@
text
@d51 1
a51 1
      sortedPartIndex_ ()
d53 2
d380 2
a381 2
      executable_   (),
      impactPeriod_ ()
d754 1
a754 1
      belowList_      ()
@


1.50
log
@Stochastic Implosion
@
text
@d392 2
a393 2
      WitOperation *      theOpn,
      WitFlexVec <bool> & executableArg)
d401 2
a402 2
      WitBillEntry *           theBillEnt,
      WitFlexVec <WitPeriod> & impactPeriodArg)
@


1.49
log
@Stochastic Implosion
@
text
@d63 20
d391 18
d764 9
@


1.48
log
@Stochastic Implosion
@
text
@d48 4
a51 1
      unsortedPredFor_ ()
d354 6
a359 4
      WitProbAssoc (thePreData->myProblem ()),
      myPreData_   (thePreData),
      truncOffset_ (),
      dblCumLead_  ()
d713 2
a714 1
      isBelowCurrent_ ()
@


1.47
log
@Stochastic Implosion
@
text
@d544 1
a544 2
// WitPreAccess::impactPeriod    (theConsEnt)[thePer] = -1;
   myPreData_->  impactPeriod () (theConsEnt)[thePer] = -1;
d570 1
a570 2
// WitPreAccess::impactPeriod    (theConsEnt)[thePer] = finalImpactPeriod;
   myPreData_->  impactPeriod () (theConsEnt)[thePer] = finalImpactPeriod;
a580 1
// WitPreAccess::impactPeriod    (theSub)[thePer] = -1;
d585 1
a585 5
         {
//       WitPreAccess::impactPeriod    (theSub)[thePer] = 
//          myPreData_->impactPeriod () (theSub->myBomEnt ())[thePer];

         myPreData_->  impactPeriod () (theSub)[thePer] = 
a586 1
         }
d611 1
a611 2
// WitPreAccess::impactPeriod    (theBopEnt)[thePer] = -1;
   myPreData_->  impactPeriod () (theBopEnt)[thePer] = -1;
d632 1
a632 2
// WitPreAccess::impactPeriod    (theBopEnt)[thePer] = theImpactPeriod;
   myPreData_->  impactPeriod () (theBopEnt)[thePer] = theImpactPeriod;
d654 1
a654 2
//    WitPreAccess::impactPeriod    (theBomEnt)[thePer] = -1;
      myPreData_->  impactPeriod () (theBomEnt)[thePer] = -1;
d657 1
a657 4
         {
//       WitPreAccess::impactPeriod    (theSub)[thePer] = -1;
         myPreData_->  impactPeriod () (theSub)[thePer] = -1;
         }
d661 1
a661 4
      {
//    WitPreAccess::impactPeriod    (theBopEnt)[thePer] = -1;
      myPreData_->  impactPeriod () (theBopEnt)[thePer] = -1;
      }
@


1.46
log
@[disallowed backlog]
@
text
@d22 1
d41 8
a48 2
WitNodeSorter::WitNodeSorter (WitProblem * theProblem):
      WitProbAssoc (theProblem)
d76 6
a81 1
   if (not nodesInOrder ())
d95 2
a96 2
   forEachPart (thePart, myProblem ())
      WitPreAccess::sortedPartIndex (thePart) = nBefore ++;
d209 3
a211 4
   sorted_                                   .clear ();

   WitPreAccess::allParts      (myCompMgr ()).clear ();
   WitPreAccess::allOperations (myCompMgr ()).clear ();
d218 1
a218 1
         WitPreAccess::allParts      (myCompMgr ()).append (thePart);
d223 1
a223 1
         WitPreAccess::allOperations (myCompMgr ()).append (theOpn);
d349 6
a354 2
WitOffsetProc::WitOffsetProc (WitProblem * theProblem):
      WitProbAssoc (theProblem)
d370 1
d382 1
a382 1
   forEachOperation (theOpn, myProblem ())
d386 1
a386 2
         WitPreAccess::executable (theOpn)[thePer] =
            roundOffsets (theOpn, thePer);
d388 3
a390 1
         if (not theOpn->executable ()[thePer])
d470 1
d496 8
a503 1
      if (not theOpn->hasBomEntryInEffect (thePer))
d505 1
d544 2
a545 1
   WitPreAccess::impactPeriod (theConsEnt)[thePer] = -1;
d571 2
a572 1
   WitPreAccess::impactPeriod (theConsEnt)[thePer] = finalImpactPeriod;
d583 2
a584 1
   WitPreAccess::impactPeriod (theSub)[thePer] = -1;
d586 1
a586 1
   if (theSub->myBomEnt ()->inEffect (thePer))
d588 7
a594 2
         WitPreAccess::impactPeriod (theSub)[thePer] = 
            theSub->myBomEnt ()->impactPeriod ()[thePer];
d619 2
a620 1
   WitPreAccess::impactPeriod (theBopEnt)[thePer] = -1;
d641 2
a642 1
   WitPreAccess::impactPeriod (theBopEnt)[thePer] = theImpactPeriod;
d664 2
a665 1
      WitPreAccess::impactPeriod (theBomEnt)[thePer] = -1;
d668 4
a671 1
         WitPreAccess::impactPeriod (theSub)[thePer] = -1;
d675 4
a678 1
      WitPreAccess::impactPeriod (theBopEnt)[thePer] = -1;
d699 1
a699 1
         if (theBopEnt->inEffect (thePer))
d701 1
a701 1
            theImpactPer               = theBopEnt->impactPeriod ()[thePer];
d721 1
a721 3
WitBelowLister::WitBelowLister (WitProblem * theProblem):

      WitProbAssoc    (theProblem),
d723 2
a724 1
      nPartsBefore_   (),
a739 8
   int       nBefore;

   nPartsBefore_.allocate (myProblem (), 0);

   nBefore = 0;

   forEachPart (thePart, myProblem ())
      nPartsBefore_ (thePart) = nBefore ++;
d743 1
a743 1
   forEachPart (thePart, myProblem ())
a745 1
   nPartsBefore_  .clear  ();
d827 2
a828 2
   theIdx1 = thePart1->sortedPartIndex ();
   theIdx2 = thePart2->sortedPartIndex ();
d838 5
a842 1
      WitAvSorter <SortEntry>::WitAvSorter (int nEntries):
@


1.45
log
@[disallowed backlog]
@
text
@a39 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

int WitPart::* WitNodeSorter::sortedPartIndex_ = NULL;

//------------------------------------------------------------------------------

d84 1
a84 8
      thePart->*sortedPartIndex_ = nBefore ++;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::receiveDMPs (int WitPart::* sortedPartIndexArg)
   {
   sortedPartIndex_ = sortedPartIndexArg;
a337 9
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitTVec <bool>      WitOperation::* WitOffsetProc::executable_   = NULL;
WitTVec <WitPeriod> WitBillEntry::* WitOffsetProc::impactPeriod_ = NULL;

//------------------------------------------------------------------------------

d370 2
a371 1
         (theOpn->*executable_)[thePer] = roundOffsets (theOpn, thePer);
a385 15
void WitOffsetProc::receiveDMPs (WitTVec <bool> WitOperation::* executableArg)
   {
   executable_ = executableArg;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::receiveDMPs (
      WitTVec <WitPeriod> WitBillEntry::* impactPeriodArg)
   {
   impactPeriod_ = impactPeriodArg;
   }

//------------------------------------------------------------------------------

d518 1
a518 1
   (theConsEnt->*impactPeriod_)[thePer] = -1;
d544 1
a544 1
   (theConsEnt->*impactPeriod_)[thePer] = finalImpactPeriod;
d555 1
a555 1
   (theSub->*impactPeriod_)[thePer] = -1;
d559 1
a559 1
         (theSub->*impactPeriod_)[thePer] = 
d585 1
a585 1
   (theBopEnt->*impactPeriod_)[thePer] = -1;
d606 1
a606 1
   (theBopEnt->*impactPeriod_)[thePer] = theImpactPeriod;
d628 1
a628 1
      (theBomEnt->*impactPeriod_)[thePer] = -1;
d631 1
a631 1
         (theSub->*impactPeriod_)[thePer] = -1;
d635 1
a635 1
      (theBopEnt->*impactPeriod_)[thePer] = -1;
a677 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitPtrVec <WitPart> WitPart::* WitBelowLister::belowList_ = NULL;

//------------------------------------------------------------------------------

a717 7
void WitBelowLister::receiveDMPs (WitPtrVec <WitPart> WitPart::* belowListArg)
   {
   belowList_ = belowListArg;
   }

//------------------------------------------------------------------------------

d747 1
a747 1
   (currentPart->*belowList_).resize (theParts.nElements ());
d755 1
a755 1
      (currentPart->*belowList_)[theIdx] = theBelowPart;
d760 1
a760 1
   if ((currentPart->*belowList_).length () > 1)
d762 1
a762 1
           currentPart->*belowList_,
@


1.44
log
@Rescinded all changed made since 1/31/07.
@
text
@d31 1
d44 1
a44 3
int                       WitPart::* WitNodeSorter::sortedPartIndex_ = NULL;
WitList <WitPart>      WitCompMgr::* WitNodeSorter::allParts_        = NULL;
WitList <WitOperation> WitCompMgr::* WitNodeSorter::allOperations_   = NULL;
a103 10
void WitNodeSorter::receiveDMPs (
      WitList <WitPart>      WitCompMgr::* allPartsArg,
      WitList <WitOperation> WitCompMgr::* allOperationsArg)
   {
   allParts_      = allPartsArg;
   allOperations_ = allOperationsArg;
   }

//------------------------------------------------------------------------------

d212 4
a215 3
   sorted_                        .clear ();
   (myCompMgr ()->*allParts_)     .clear ();
   (myCompMgr ()->*allOperations_).clear ();
d222 1
a222 1
         (myCompMgr ()->*allParts_).append (thePart);
d227 1
a227 1
         (myCompMgr ()->*allOperations_).append (theOpn);
@


1.43
log
@[disallowed backlog]
@
text
@d43 1
d93 8
a100 1
      thePart->sortedPartIndex_ () = nBefore ++;
d363 9
a386 3
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
a399 9
   forEachBomEntry (theBomEnt, myProblem ())
      theBomEnt->impactPeriod_ ().allocate (myProblem (), -1);

   forEachSubEntry (theSub, myProblem ())
      theSub->   impactPeriod_ ().allocate (myProblem (), -1);

   forEachBopEntry (theBopEnt, myProblem ())
      theBopEnt->impactPeriod_ ().allocate (myProblem (), -1);

d404 1
a404 1
         theOpn->executable_ ()[thePer] = roundOffsets (theOpn, thePer);
d419 15
d566 1
a566 1
   theConsEnt->impactPeriod_ ()[thePer] = -1;
d592 1
a592 1
   theConsEnt->impactPeriod_ ()[thePer] = finalImpactPeriod;
d603 1
a603 1
   theSub->impactPeriod_ ()[thePer] = -1;
d607 1
a607 1
         theSub->impactPeriod_ ()[thePer] = 
d633 1
a633 1
   theBopEnt->impactPeriod_ ()[thePer] = -1;
d654 1
a654 1
   theBopEnt->impactPeriod_ ()[thePer] = theImpactPeriod;
d676 1
a676 1
      theBomEnt->impactPeriod_ ()[thePer] = -1;
d679 1
a679 1
         theSub->impactPeriod_ ()[thePer] = -1;
d683 1
a683 1
      theBopEnt->impactPeriod_ ()[thePer] = -1;
d726 8
d774 7
d810 1
a810 1
   currentPart->belowList_ ().resize (theParts.nElements ());
d818 1
a818 1
      currentPart->belowList_ ()[theIdx] = theBelowPart;
d823 1
a823 1
   if (currentPart->belowList ().length () > 1)
d825 1
a825 1
           currentPart->belowList_ (),
@


1.42
log
@[disallowed backlog]
@
text
@d92 1
a92 1
      thePart->sortedPartIndex_.forUpdate () = nBefore ++;
d387 1
a387 1
      theBomEnt->impactPeriod_->allocate (myProblem (), -1);
d390 1
a390 1
      theSub->impactPeriod_->allocate (myProblem (), -1);
d393 1
a393 1
      theBopEnt->impactPeriod_->allocate (myProblem (), -1);
d399 1
a399 2
         theOpn->executable_.forUpdate ()[thePer] =
            roundOffsets (theOpn, thePer);
d546 1
a546 1
   theConsEnt->impactPeriod_.forUpdate ()[thePer] = -1;
d572 1
a572 1
   theConsEnt->impactPeriod_.forUpdate ()[thePer] = finalImpactPeriod;
d583 1
a583 1
   theSub->impactPeriod_.forUpdate ()[thePer] = -1;
d587 1
a587 1
         theSub->impactPeriod_.forUpdate ()[thePer] = 
d613 1
a613 1
   theBopEnt->impactPeriod_.forUpdate ()[thePer] = -1;
d634 1
a634 1
   theBopEnt->impactPeriod_.forUpdate ()[thePer] = theImpactPeriod;
d656 1
a656 1
      theBomEnt->impactPeriod_.forUpdate ()[thePer] = -1;
d659 1
a659 1
         theSub->impactPeriod_.forUpdate ()[thePer] = -1;
d663 1
a663 1
      theBopEnt->impactPeriod_.forUpdate ()[thePer] = -1;
d775 1
a775 1
   currentPart->belowList_->resize (theParts.nElements ());
d783 1
a783 1
      currentPart->belowList_.forUpdate ()[theIdx] = theBelowPart;
d790 1
a790 1
           currentPart->belowList_.forUpdate (),
@


1.41
log
@[disallowed backlog]
@
text
@a354 9
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitTVec <bool>      WitOperation::* WitOffsetProc::executable_   = NULL;
WitTVec <WitPeriod> WitBillEntry::* WitOffsetProc::impactPeriod_ = NULL;

//------------------------------------------------------------------------------

d370 3
d386 9
d399 2
a400 1
         (theOpn->*executable_)[thePer] = roundOffsets (theOpn, thePer);
a414 15
void WitOffsetProc::receiveDMPs (WitTVec <bool> WitOperation::* executableArg)
   {
   executable_ = executableArg;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::receiveDMPs (
      WitTVec <WitPeriod> WitBillEntry::* impactPeriodArg)
   {
   impactPeriod_ = impactPeriodArg;
   }

//------------------------------------------------------------------------------

d547 1
a547 1
   (theConsEnt->*impactPeriod_)[thePer] = -1;
d573 1
a573 1
   (theConsEnt->*impactPeriod_)[thePer] = finalImpactPeriod;
d584 1
a584 1
   (theSub->*impactPeriod_)[thePer] = -1;
d588 1
a588 1
         (theSub->*impactPeriod_)[thePer] = 
d614 1
a614 1
   (theBopEnt->*impactPeriod_)[thePer] = -1;
d635 1
a635 1
   (theBopEnt->*impactPeriod_)[thePer] = theImpactPeriod;
d657 1
a657 1
      (theBomEnt->*impactPeriod_)[thePer] = -1;
d660 1
a660 1
         (theSub->*impactPeriod_)[thePer] = -1;
d664 1
a664 1
      (theBopEnt->*impactPeriod_)[thePer] = -1;
d776 1
a776 1
   currentPart->belowList_.forUpdate ().resize (theParts.nElements ());
@


1.40
log
@[disallowed backlog]
@
text
@a717 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitPtrVec <WitPart> WitPart::* WitBelowLister::belowList_ = NULL;

//------------------------------------------------------------------------------

a757 7
void WitBelowLister::receiveDMPs (WitPtrVec <WitPart> WitPart::* belowListArg)
   {
   belowList_ = belowListArg;
   }

//------------------------------------------------------------------------------

d787 1
a787 1
   (currentPart->*belowList_).resize (theParts.nElements ());
d795 1
a795 1
      (currentPart->*belowList_)[theIdx] = theBelowPart;
d800 1
a800 1
   if ((currentPart->*belowList_).length () > 1)
d802 1
a802 1
           currentPart->*belowList_,
@


1.39
log
@Updated the copyright date on all source files.
@
text
@a42 1
int                       WitPart::* WitNodeSorter::sortedPartIndex_ = NULL;
d92 1
a92 8
      thePart->*sortedPartIndex_ = nBefore ++;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::receiveDMPs (int WitPart::* sortedPartIndexArg)
   {
   sortedPartIndex_ = sortedPartIndexArg;
@


1.38
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.37
log
@[shared-resource pegging]
@
text
@d854 7
a860 1
   return (thePart1->sortedPartIndex () > thePart2->sortedPartIndex ());
d945 7
a951 2
   double avDiff;
   int    idxDiff;
d953 2
a954 3
   avDiff =
        aversion (theSortEnt1)
      - aversion (theSortEnt2);
d956 2
a957 2
   if (avDiff != 0.0)
      return (avDiff < 0.0);
d959 2
a960 3
   idxDiff =
        theSortEnt1->mappingIndex ()
      - theSortEnt2->mappingIndex ();
d962 1
a962 1
   return (idxDiff < 0);
@


1.36
log
@[shared-resource pegging]
@
text
@d863 1
a863 1
         workDenseList_ (nEntries)
d879 3
a881 1
   SortEntry * theEntry;
d886 1
a886 1
   copyIntoDense (workDenseList_, theList);
d888 14
a901 1
   workDenseList_.sort (compare, NULL);
d905 2
a906 2
   forEachElDense (theEntry, workDenseList_)
      theList.append (theEntry);
d915 2
a916 2
   SortEntry * theEntry;
   SortEntry * prevEntry;
d918 1
a918 1
   prevEntry = NULL;
d920 1
a920 1
   forEachEl (theEntry, theList)
d922 2
a923 2
      if (prevEntry != NULL)
         if (aversion (theEntry) < aversion (prevEntry))
d926 1
a926 1
      prevEntry = theEntry;
d935 3
a937 4
      int WitAvSorter <SortEntry>::compare (
         SortEntry * theSortEntry1,
         SortEntry * theSortEntry2,
         void *)
d942 10
a951 20
   avDiff = aversion (theSortEntry1) - aversion (theSortEntry2);

   if (avDiff < 0.0)
      return -1;

   if (avDiff > 0.0)
      return +1;

   idxDiff = theSortEntry1->mappingIndex () - theSortEntry2->mappingIndex ();

   if (idxDiff < 0)
      return -1;

   if (idxDiff > 0)
      return +1;

   stronglyAssert (false);
      //
      // The two SortEntries should always have distict values of
      // mappingIndex ().
d953 1
a953 1
   return 0;
@


1.35
log
@[shared-resource pegging]
@
text
@a851 13
int WitBelowLister::compareNPartsBefore (
      WitPart * thePart1,
      WitPart * thePart2,
      void *)
   {  
   return
      sign (
           thePart2->sortedPartIndex ()
         - thePart1->sortedPartIndex ());
   }

//------------------------------------------------------------------------------

@


1.34
log
@[shared-resource pegging]
@
text
@d31 2
d739 1
a739 2
      isBelowCurrent_ (),
      belowCurrent_   ()
a764 2
   belowCurrent_.resize (myCompMgr ()->nParts ());

a769 1
   belowCurrent_  .resize (0);
d790 3
a792 1
   belowCurrent_.append (currentPart);
d803 1
a803 1
            mergeBelow (theBomEnt);
d806 1
a806 1
               mergeBelow (theSub);
d810 1
a810 4
   if (belowCurrent_.nElements () > 1)
      belowCurrent_.sort (compareNPartsBefore, NULL);

   (currentPart->*belowList_).resize (belowCurrent_.nElements ());
d814 1
a814 1
   forEachElDense (theBelowPart, belowCurrent_)
a815 2
      isBelowCurrent_ (theBelowPart) = false;

d819 2
d823 5
a827 1
   belowCurrent_.clear ();
d832 3
a834 1
void WitBelowLister::mergeBelow (WitConsEntry * theConsEnt)
d844 1
a844 1
         belowCurrent_.append (thePart);
d864 7
@


1.33
log
@[multi-thread]
@
text
@d728 1
a728 1
WitDenseList <WitPart> WitPart::* WitBelowLister::belowList_ = NULL;
d769 2
a770 2
   nPartsBefore_  .clear ();
   isBelowCurrent_.clear ();
d776 1
a776 2
void WitBelowLister::receiveDMPs (
      WitDenseList <WitPart> WitPart::* belowListArg)
d789 1
d815 2
d821 3
a823 1
      (currentPart->*belowList_).append (theBelowPart);
d833 2
a834 2
   WitPart * theConsPart;
   WitPart * theBelowPart;
d836 1
a836 1
   theConsPart = theConsEnt->myPart ();
d838 2
a839 2
   forEachElDense (theBelowPart, theConsPart->belowList ())
      if (not isBelowCurrent_ (theBelowPart))
d841 1
a841 1
         belowCurrent_.append (theBelowPart);
d843 1
a843 1
         isBelowCurrent_ (theBelowPart) = true;
@


1.32
log
@[multi-thread]
@
text
@d728 1
a728 3
WitDenseList <WitPart> WitPart::* WitBelowLister::belowList_      = NULL;

WitBelowLister *                  WitBelowLister::activeInstance_ = NULL;
a754 4
   witAssert (activeInstance_ == NULL);

   activeInstance_ = this;

a771 2

   activeInstance_ = NULL;
@


1.31
log
@[multi-thread]
@
text
@a36 5
WitNodeSorter::WitNodeSorter (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

d38 1
a38 5

WitNodeSorter::~WitNodeSorter ()
   {
   }

d41 3
a43 4
void WitNodeSorter::loadDataFrom (WitPart * thePart, int & sortedPartIndexArg)
   {
   sortedPartIndex_.setMapFor (thePart, sortedPartIndexArg);
   }
d47 2
a48 3
void WitNodeSorter::loadDataFromCompMgr (
      WitList    <WitPart>      & allPartsArg,
      WitList    <WitOperation> & allOperationsArg)
a49 2
   allParts_     .attachTo (allPartsArg);
   allOperations_.attachTo (allOperationsArg);
d54 1
a54 8
void WitNodeSorter::allocLoadedData ()
   {
   sortedPartIndex_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitNodeSorter::clearLoadedData ()
a55 3
   allParts_       .clear ();
   allOperations_  .clear ();
   sortedPartIndex_.clear ();
d91 18
a108 1
      sortedPartIndex_ (thePart) = nBefore ++;
d221 3
a223 3
   sorted_          .clear ();
   allParts_ ()     .clear ();
   allOperations_ ().clear ();
d230 1
a230 1
         allParts_ ().append (thePart);
d235 1
a235 1
         allOperations_ ().append (theOpn);
a360 11
WitOffsetProc::WitOffsetProc (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitOffsetProc::~WitOffsetProc ()
   {
   }

d362 1
a362 8

void WitOffsetProc::loadDataFrom (
      WitOperation *      theOpn,
      WitTVec    <bool> & executableArg)
   {
   executable_.setMapFor (theOpn, executableArg);
   }

d365 2
a366 6
void WitOffsetProc::loadDataFrom (
      WitBillEntry *             theBillEnt,
      WitTVec    <WitPeriod>   & impactPeriodArg)
   {
   impactPeriod_.setMapFor (theBillEnt, impactPeriodArg);
   }
d370 2
a371 1
void WitOffsetProc::allocLoadedData ()
a372 2
   executable_  .allocate (myProblem ());
   impactPeriod_.allocate (myProblem ());
d377 1
a377 1
void WitOffsetProc::clearLoadedData ()
a378 2
   executable_  .clear ();
   impactPeriod_.clear ();
d402 1
a402 1
         executable_ (theOpn)[thePer] = roundOffsets (theOpn, thePer);
d417 15
d564 1
a564 1
   impactPeriod_ (theConsEnt)[thePer] = -1;
d590 1
a590 1
   impactPeriod_ (theConsEnt)[thePer] = finalImpactPeriod;
d601 1
a601 1
   impactPeriod_ (theSub)[thePer] = -1;
d605 1
a605 1
         impactPeriod_ (theSub)[thePer] = 
d631 1
a631 1
   impactPeriod_ (theBopEnt)[thePer] = -1;
d652 1
a652 1
   impactPeriod_ (theBopEnt)[thePer] = theImpactPeriod;
d674 1
a674 1
      impactPeriod_ (theBomEnt)[thePer] = -1;
d677 1
a677 1
         impactPeriod_ (theSub)[thePer] = -1;
d681 1
a681 1
      impactPeriod_ (theBopEnt)[thePer] = -1;
d724 7
a730 1
WitBelowLister * WitBelowLister::activeInstance_ = NULL;
a751 23
void WitBelowLister::loadDataFrom (
      WitPart *                  thePart,
      WitDenseList <WitPart>   & belowListArg)
   {
   belowList_.setMapFor (thePart, belowListArg);
   }

//------------------------------------------------------------------------------

void WitBelowLister::allocLoadedData ()
   {
   belowList_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitBelowLister::clearLoadedData ()
   {
   belowList_.clear ();
   }

//------------------------------------------------------------------------------

d784 8
d821 1
a821 1
   belowList_ (currentPart).resize (belowCurrent_.nElements ());
d827 1
a827 1
      belowList_ (currentPart).append (theBelowPart);
@


1.30
log
@[multi-thread]
@
text
@a30 1
#include <DLSort.h>
d844 1
a844 4
      WitDLSorter <WitPart, void>::sort (
         belowCurrent_,
         compareNPartsBefore,
         NULL);
d918 1
a918 1
   WitDLSorter <SortEntry, void>::sort (workDenseList_, compare, NULL);
@


1.29
log
@[multi-thread]
@
text
@d845 1
a845 1
      WitDLSorter <WitPart, WitBelowLister>::sort (
d883 3
a885 3
      WitPart *        thePart1,
      WitPart *        thePart2,
      WitBelowLister *)
d922 1
a922 4
   WitDLSorter <SortEntry, WitAvSorter <SortEntry> >::sort (
      workDenseList_,
      compare,
      NULL);
d957 3
a959 3
         SortEntry *               theSortEntry1,
         SortEntry *               theSortEntry2,
         WitAvSorter <SortEntry> *)
@


1.28
log
@[multi-thread]
@
text
@d846 3
a848 3
           belowCurrent_,
         & WitBelowLister::compareNPartsBefore,
           this);
d882 5
a886 2
int WitBelowLister::compareNPartsBefore (WitPart * thePart1, WitPart * thePart2)
   {
d923 3
a925 3
        workDenseList_,
      & WitAvSorter <SortEntry>::compare,
        this);
d960 3
a962 2
         SortEntry * theSortEntry1,
         SortEntry * theSortEntry2)
@


1.27
log
@[multi-thread]
@
text
@d31 1
d845 1
a845 1
      WitNonClass::sort (
d919 1
a919 1
   WitNonClass::sort (
@


1.26
log
@Revised mappingIndex code.
@
text
@d844 4
a847 1
      belowCurrent_.sort (compareNPartsBefore);
d918 4
a921 1
   workDenseList_.sort (compare);
@


1.25
log
@pegged Critical List.
@
text
@a31 1
#include <MapIdxI.h>
@


1.24
log
@Pegged critical list.
@
text
@d62 2
a63 2
   allParts_     .refTo (allPartsArg);
   allOperations_.refTo (allOperationsArg);
@


1.23
log
@Low-Pri Prop-Rt.
@
text
@d169 1
a169 1
// compared to the successors to its successors, which are of the same derived
@


1.22
log
@Fixed a bug in the sorting of BOP entries that produce each part.
@
text
@d965 1
a965 1
   idxDiff = nEntriesBefore (theSortEntry1) - nEntriesBefore (theSortEntry2);
d976 1
a976 1
      // nEntriesBefore ().
a997 16

template <>
      int WitAvSorter <WitBopEntry>::nEntriesBefore (WitBopEntry * theBopEnt)
   {
   return WitPreprocessor::nProdEntsBefore (theBopEnt);
   }

//------------------------------------------------------------------------------

template <>
      int WitAvSorter <WitSubEntry>::nEntriesBefore (WitSubEntry * theSub)
   {
   return theSub->localIndex ();
   }

//------------------------------------------------------------------------------
@


1.21
log
@Made sorting of substitutes and BOP entries break ties, using the order of
creation.
@
text
@d21 1
d965 1
a965 1
   idxDiff = theSortEntry1->localIndex ()- theSortEntry2->localIndex ();
d975 2
a976 1
      // The two SortEntries should always have distict localIndexes.
d995 16
@


1.20
log
@Altered the below list to improve robustness.
@
text
@d953 24
a976 4
   return
      sign (
           aversion (theSortEntry1) 
         - aversion (theSortEntry2));
@


1.19
log
@Fixed a bug in building the below lists.
@
text
@a818 2
   WitPart *      theBomPart;
   WitPart *      theBelowPart;
d823 1
d825 1
a825 1
   belowCurrent_.clear ();
d827 1
a827 1
   recordBelowCurrent (currentPart);
d836 1
a836 4
            theBomPart = theBomEnt->myPart ();

            forEachElDense (theBelowPart, theBomPart->belowList ())
               recordBelowCurrent (theBelowPart);
d839 1
a839 9
               {
               if (theSub->expAllowed ())
                  {
                  forEachElDense (theBelowPart, theSub->myPart ()->belowList ())
                     recordBelowCurrent (theBelowPart);
                  }
               else if (theSub->netAllowed ())
                  recordBelowCurrent (theSub->myPart ());
               }
d854 2
d860 1
a860 1
void WitBelowLister::recordBelowCurrent (WitPart * thePart)
d862 4
a865 2
   if (isBelowCurrent_ (thePart))
      return;
d867 4
a870 1
   belowCurrent_.append (thePart);
d872 2
a873 1
   isBelowCurrent_ (thePart) = true;
@


1.18
log
@Double Precision.
@
text
@d843 3
a845 1
               if (myGlobalComp ()->multiRoute () and theSub->expAllowed ())
d848 1
d851 1
@


1.17
log
@Double Precision.
@
text
@d953 4
a956 1
   return sign (aversion (theSortEntry1) - aversion (theSortEntry2));
@


1.16
log
@Double Precision.
@
text
@d715 1
a715 1
      hasImpact.setToScalar (false);
@


1.15
log
@Double Precision.
@
text
@d419 2
a420 2
   WitTVec <float> leadToImpact (myProblem (), 0.0);
   WitTVec <bool>  hasImpact    (myProblem (), false);
d427 1
a427 1
   floatCumLead_.allocate (myProblem (), 0.0);
d442 2
a443 2
   truncOffset_ .clear ();
   floatCumLead_.clear ();
d448 1
a448 1
inline float WitOffsetProc::workOffset (
d555 2
a556 2
// round down of the float workOffset ()[thePer]. The final value is computed by
// rounding the float lead time either up or down so as to have the right
d562 2
a563 2
//    consFCLead:         The float cum lead time for the consumed Part.
//    propFCLead:         The proposed float cum lead time for the consuming
d575 2
a576 2
   float     consFCLead;
   float     propFCLead;
d593 1
a593 1
   consFCLead = floatCumLead_ (theConsEnt->myPart ())[initImpactPeriod];
d595 1
a595 1
   propFCLead = consFCLead + workOffset (theConsEnt, thePer);
d598 2
a599 2
        ltRoundDown (propFCLead)
      - ltRoundDown (consFCLead);
d608 1
a608 1
   setToMax (floatCumLead_ (theConsEnt->myOperation ())[thePer], propFCLead);
d630 2
a631 2
//    opnFCLead:        The float cum lead time for the producing Operation:
//    propFCLead:       The proposed float cum lead time for the produced
d642 2
a643 2
   float     opnFCLead;
   float     propFCLead;
d652 1
a652 1
   opnFCLead  = floatCumLead_ (theBopEnt->myOperation ())[thePer];
d654 1
a654 1
   propFCLead = opnFCLead - workOffset (theBopEnt, thePer);
d657 2
a658 2
        ltRoundDown (opnFCLead)
      - ltRoundDown (propFCLead);
d675 1
a675 1
int WitOffsetProc::ltRoundDown (float leadTime)
d699 1
a699 1
   floatCumLead_ (theOpn)[thePer] = 0.0;
d705 3
a707 3
      WitOperation *    theOpn,
      WitTVec <float> & leadToImpact,
      WitTVec <bool> &  hasImpact)
d725 1
a725 1
               floatCumLead_ (theOpn)[thePer] - workOffset (theBopEnt, thePer);
d731 1
a731 1
               floatCumLead_ (theBopEnt->myPart ())[theImpactPer],
@


1.14
log
@Continued double precision.
@
text
@d488 1
a488 1
         min (static_cast <float> (thePer), theBillEnt->offset ()[thePer]);
@


1.13
log
@Continued double precision.
@
text
@d969 1
a969 1
   return static_cast <double> (theSub->expNetAversion ());
@


1.12
log
@An attempt to fix more syntax errors from on Windows.
@
text
@d959 1
a959 1
      float WitAvSorter <WitBopEntry>::aversion (WitBopEntry * theBopEnt)
d967 1
a967 1
      float WitAvSorter <WitSubEntry>::aversion (WitSubEntry * theSub)
d969 1
a969 1
   return theSub->expNetAversion ();
@


1.11
log
@Removed a bad function overload.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d18 1
d24 1
d885 93
@


1.10
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d231 1
a231 1
      thePart = theNode->myPart ();
d236 1
a236 1
      theOpn = theNode->myOpn ();
d329 1
a329 1
   thePart = theNode->myPart ();
d335 1
a335 1
      thePart = theNode->myPart ();
@


1.9
log
@Continued implementation of post-implosion pegging.
@
text
@a28 1
#include <PtrMapI.h>
@


1.8
log
@Continued implementation of post-implosion pegging.
@
text
@a28 1
#include <RefMapI.h>
@


1.7
log
@Continued implementation of proportionate routing.
@
text
@a28 1
#include <ScheduleI.h>
d31 1
@


1.6
log
@Continued implementation of proportionate routing.
@
text
@d233 1
a233 1
      theNode->getPart (thePart);
d238 1
a238 1
      theNode->getOperation (theOpn);
d331 1
a331 1
   theNode->getPart (thePart);
d334 1
d337 1
a337 1
   theNode->getPart (thePart);
d339 5
a343 4
   stronglyAssert (thePart != NULL);
      //
      // The cycle needs to begin with a Part, so that the error message
      // makes sense.
@


1.5
log
@Changed some C style casts to C++ style.
@
text
@a30 1
#include <RefI.h>
@


1.4
log
@Internal changes.
@
text
@d487 1
a487 1
         min ((float) thePer, theBillEnt->offset ()[thePer]);
d676 1
a676 1
   return (int) floor (leadTime + 1.0E-3);
@


1.3
log
@Internal changes.
@
text
@d100 1
a100 1
   if (! nodesInOrder ())
d277 1
a277 1
   while (! eligibleNodes.isEmpty ())
d317 1
a317 1
      if (! sorted_ (theNode))
d322 1
a322 1
      if (! sorted_ (theNode))
d325 1
a325 1
   while (! scanned (theNode))
d434 1
a434 1
         if (! theOpn->executable ()[thePer])
d524 1
a524 1
      if (! compImpactPeriod (theBomEnt, thePer))
d535 1
a535 1
      if (! compImpactPeriod (theBopEnt, thePer))
d538 2
a539 2
   if (! myGlobalComp ()->execEmptyBom ())
      if (! theOpn->hasBomEntryInEffect (thePer))
d581 1
a581 1
   if (! theConsEnt->withinInterval (thePer))
d648 1
a648 1
   if (! theBopEnt->withinInterval (thePer))
d842 1
a842 1
               if (myGlobalComp ()->multiRoute () && theSub->expAllowed ())
@


1.2
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d153 1
a153 1
// Returns TRUE, iff the Parts and Operations are already in order.
d176 1
a176 1
WitBoolean WitNodeSorter::nodesInOrder ()
d202 1
a202 1
             return witFALSE;
d204 1
a204 1
   return witTRUE;
d221 1
a221 1
   sorted_.allocate (myProblem (), witFALSE);
d283 1
a283 1
      sorted_ (theNode) = witTRUE;
d300 1
a300 1
//       scanned (theNode) is TRUE, iff theNode has already been scanned in
d307 1
a307 1
   WitMapping <WitNode, WitBoolean> scanned (myProblem (), witFALSE);
d327 1
a327 1
      scanned (theNode) = witTRUE;
d380 2
a381 2
      WitOperation *             theOpn,
      WitTVec    <WitBoolean>  & executableArg)
d418 2
a419 2
   WitTVec <float>      leadToImpact (myProblem (), 0.0);
   WitTVec <WitBoolean> hasImpact    (myProblem (), witFALSE);
d496 1
a496 1
// If any such condition occurs, computation is terminated and FALSE
d498 1
a498 1
// Otherwise TRUE is returned.
d506 1
a506 1
//   execEmptyBom () is FALSE and no BomEntries are in effect in period t.
d509 1
a509 3
WitBoolean WitOffsetProc::roundOffsets (
      WitOperation * theOpn,
      WitPeriod      thePer)
d516 1
a516 1
      return witFALSE;
d520 1
a520 1
         return witFALSE;
d525 1
a525 1
         return witFALSE;
d536 1
a536 1
         return witFALSE;
d540 1
a540 1
         return witFALSE;
d542 1
a542 1
   return witTRUE;
d549 1
a549 1
// computation is aborted and the function returns FALSE, indicating that
d551 1
a551 1
// Otherwise returns TRUE.
d569 1
a569 1
WitBoolean WitOffsetProc::compImpactPeriod (
d582 1
a582 1
      return witTRUE;
d587 1
a587 1
      return witFALSE;
d590 1
a590 1
      return witFALSE;
d603 1
a603 1
      return witFALSE;
d609 1
a609 1
   return witTRUE;
d637 1
a637 1
WitBoolean WitOffsetProc::compImpactPeriod (
d649 1
a649 1
      return witTRUE;
d662 1
a662 1
      return witFALSE;
d665 1
a665 1
      return witFALSE;
d669 1
a669 1
   return witTRUE;
d704 3
a706 3
      WitOperation *         theOpn,
      WitTVec <float> &      leadToImpact,
      WitTVec <WitBoolean> & hasImpact)
d714 1
a714 1
      hasImpact.setToScalar (witFALSE);
d721 1
a721 1
            hasImpact[theImpactPer]    = witTRUE;
d800 1
a800 1
   isBelowCurrent_.allocate (myProblem (), witFALSE);
d857 1
a857 1
      isBelowCurrent_ (theBelowPart) = witFALSE;
d872 1
a872 1
   isBelowCurrent_ (thePart) = witTRUE;
@


1.1
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d32 1
@


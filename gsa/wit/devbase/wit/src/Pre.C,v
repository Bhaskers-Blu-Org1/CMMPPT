head	1.139;
access;
symbols
	sce_5_01_20080919:1.128
	latest_sce_4_20_20060523:1.82.0.2
	sce_4_20_20060523:1.82
	latest_sce4_20_OSL:1.81.0.2
	sce_4_20_OSL:1.81
	sce_410_withVa:1.79
	sce_4_05_20040511:1.74
	sce_4_00_20040201:1.64
	nextGenBranch:1.50.0.2
	nextGenRoot:1.50
	sce_3_30_20030627:1.50
	EndRw-branch:1.39.0.4
	Root-of-EndRw:1.39
	rwToStl:1.39.0.2
	latest_sce_3_10_20010924:1.14.0.2
	sce_3_10_20010924:1.14
	latest_sce_3_00_20010601:1.9.0.4
	sce_3_00_20010601:1.9
	latest_sce_2_31_20010308:1.9.0.2
	sce_2_31_20010308:1.9
	latest_sce_2_31_20001003:1.6.0.2
	sce_2_31_20001003:1.6
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.139
date	2011.09.28.23.49.58;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2011.09.24.00.28.22;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2011.08.30.20.17.59;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2011.08.25.23.27.05;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2011.02.18.00.32.30;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2011.01.06.00.08.24;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2010.01.25.19.45.18;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2009.11.13.19.01.26;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2009.07.07.22.58.48;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.11.15.17.15.34;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.10.30.21.44.17;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.08.03.22.04.10;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.08.01.22.41.58;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.06.08.18.26.09;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.06.05.18.48.32;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.04.21.40.00;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.04.19.34.00;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.06.04.19.05.56;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.01.23.29.47;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.01.22.25.07;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.01.20.31.29;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2007.06.01.18.50.54;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.01.16.22.11;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.31.20.09.15;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.31.20.05.49;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.31.19.52.54;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.30.22.57.06;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.30.22.05.51;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.05.30.21.02.11;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.21.15.20.10;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.04.23.21.03.20;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.04.20.20.51.13;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.04.09.16.05.07;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.04.04.20.04.39;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.04.02.23.01.15;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.04.02.21.21.19;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.03.08.17.02.55;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.03.05.21.32.10;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.27.21.03.05;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.13.23.40.13;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.08.22.47.36;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.02.08.00.14.26;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.07.22.14.54;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.07.19.55.37;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.09.19.14.15;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.02.17.34.09;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.01.19.23.24;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.30.21.57.57;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.28.20.14.37;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.02.03.21.20.30;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.04.00.02.47;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.09.14.20.02.34;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.07.15.18.26;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.23.19.14.25;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.05.21.24.56;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.17.21.23.00;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2003.12.13.00.17.51;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.12.11.18.37.26;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.10.17.27.37;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.09.23.20.58;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.01.22.38.12;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.01.21.05.04;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.11.18.29.14;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.31.15.37.55;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.30.15.40.55;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.29.23.29.41;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.23.18.12.38;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.19.16.48.24;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.25.21.07.42;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.25.19.16.56;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.16.20.19.09;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.16.16.34.31;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.15.23.13.15;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.15.21.01.23;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.13.22.22.11;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.02.23.40.48;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.02.22.18.44;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.10.19.21.17;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.30.21.36.38;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.11.18.53.14;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.23.18.09.15;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.22.22.42.21;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.22.21.16.21;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.09.20.49.49;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.06.18.53.40;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.05.21.20.01;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.05.19.31.36;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.04.23.07.23;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.03.16.01.51;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.30.20.09.00;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.10.18.02.12;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.08.21.58.57;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.08.19.21.55;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.07.20.15.02;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.06.20.04.15;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.03.23.16.41;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.03.19.58.29;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.02.20.53.14;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.01.14.26.00;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.22.14.32.12;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.18.14.02.41;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.00.12.59;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.18.50.59;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.22.00.11;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.06.23.36.01;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.21.18.24.32;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.01.19.23.35;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.06.19.58.40;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.22.23.11.46;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.25.20.12.35;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.26;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.34;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.46;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches;
next	;


desc
@@


1.139
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Pre.C"
//
// Contains the implementation of class Preprocessor.
//------------------------------------------------------------------------------

#include <Pre.h>
#include <Post.h>
#include <NodeSorter.h>
#include <OffsetProc.h>
#include <Below.h>
#include <AvSorter.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <BoundSet.h>
#include <StochImpMgr.h>
#include <Timing.h>
#include <DetOptImpMgr.h>
#include <OptStarter.h>
#include <MsgFac.h>
#include <PtrTVec.h>

//------------------------------------------------------------------------------
// Implementation of class Preprocessor.
//------------------------------------------------------------------------------

WitPreprocessor::WitPreprocessor (WitProblem * theProblem):

      WitProbAssoc   (theProblem),
      preprocessing_ (false),
      preprocessed_  (false),
      myNodeSorter_  (NULL),
      myOffsetProc_  (NULL),
      myBelowLister_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitPreprocessor::~WitPreprocessor ()
   {
   }

//------------------------------------------------------------------------------

void WitPreprocessor::preprocess ()
   {
   WitBomEntry * theBomEnt;

   if (preprocessed_)
      return;

   myMsgFac () ("preProcMsg");

   setUp ();

   checkMaxNameLength ();

   myNodeSorter ()->sortNodesIfNeeded ();

   myOffsetProc ()->roundOffsets ();

   findMandECs ();

   validateBLA ();

   procLotSizes ();

   compHasSubsInEffect ();

   compEffConsRates ();

   forEachBomEntry (theBomEnt, myProblem ())
      checkMinLotSize (theBomEnt);

   compEffProdRates ();

   chooseExpExecPeriods ();

   checkSmallEffProdRates ();

   sortBopEntries ();
   sortSubEntries ();

   chooseExpBopEntries ();

   findExpPerGaps ();

   myBelowLister ()->buildBelow ();

   shutDown ();
   }

//------------------------------------------------------------------------------

void WitPreprocessor::getExpCycle (
      WitObjStack <WitPart> &      theParts,
      WitObjStack <WitOperation> & theOpns)
   {
   theParts.clear ();
   theOpns .clear ();

   if (preprocessed_)
      return;

   setUp ();

   myNodeSorter ()->getExpCycle (theParts, theOpns);

   shutDown ();
   }

//------------------------------------------------------------------------------

void WitPreprocessor::unpreprocess ()
   {
   WitComponent * theComp;

   stronglyAssert (not myStochImpMgr ()->stochMode ());

   if (not preprocessed_)
      return;

   myProblem ()->resetSoln ();

   myDetOptImpMgr ()->shutDown ();

   myOptComp ()->crashOptStarter ()->beChosen ();

   preprocessed_ = false;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->unpreprocess ();
   }

//------------------------------------------------------------------------------

void WitPreprocessor::setUp ()
   {
   myMsgFac ().abortIfErrors ();

   WitTimer::enterSection ("preproc");

   preprocessing_ = true;

   myNodeSorter_  = new WitNodeSorter  (myProblem ());
   myOffsetProc_  = new WitOffsetProc  (myProblem ());
   myBelowLister_ = new WitBelowLister (myProblem ());
   }

//------------------------------------------------------------------------------

void WitPreprocessor::shutDown ()
   {
   delete myBelowLister_;
   delete myOffsetProc_;
   delete myNodeSorter_;

   myBelowLister_ = NULL;
   myOffsetProc_  = NULL;
   myNodeSorter_  = NULL;

   preprocessing_ = false;
   preprocessed_  = true;

   WitTimer::leaveSection ("preproc");
   }

//------------------------------------------------------------------------------

void WitPreprocessor::checkMaxNameLength ()
   {
   int       maxNameLength;
      //
      // Maximum length of theNode->nodeName () and
      // theDemand->demandName () over all Nodes and Demands.

   WitString theLongestName;
      //
      // A name whose length is maxNameLength.

   int       nominalNameLength;
      //
      // The max name length allowed without a warning.

   WitPart *      thePart;
   WitOperation * theOpn;
   WitDemand *    theDemand;

   maxNameLength  = 0;
   theLongestName = "";

   forEachPart (thePart, myProblem ())
      updateLongestName (
         thePart->partName (),
         maxNameLength,
         theLongestName);

   forEachOperation (theOpn, myProblem ())
      updateLongestName (
         theOpn->operationName (),
         maxNameLength,
         theLongestName);

   forEachDemand (theDemand, myProblem ())
      updateLongestName (
         theDemand->demandName (),
         maxNameLength,
         theLongestName);

   nominalNameLength = 12;

   if (maxNameLength > nominalNameLength)
      myMsgFac () ("longNameWmsg", nominalNameLength, theLongestName);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::updateLongestName (
      const WitString & theName,
      int &             maxNameLength,
      WitString &       theLongestName)
   {
   if (theName.length () > maxNameLength)
      {
      maxNameLength  = theName.length ();
      theLongestName = theName;
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::validateBLA ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      if (not theDemand->shipLateAllowed ())
         {
         if (theDemand->cumShipReward () != 0.0)
            myMsgFac () ("cumShipRewardWoShipLateSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         if (theDemand->cumShipBounds ()->softLB () != 0.0)
            myMsgFac () ("cumShipSLBWoShipLateSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         forEachPeriod (thePer, myProblem ())
            if (theDemand->cumShipBounds ()->hardUBIsFinite (thePer))
               myMsgFac () ("cumShipHUBWoShipLateSmsg",
                  theDemand->demandedPartName (),
                  theDemand->demandName ());
         }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::procLotSizes ()
   {
   bool           lotSizesExistVal;
   WitOperation * theOpn;
   WitPeriod      thePer;

   lotSizesExistVal = false;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->incLotSize ()[thePer] > 0.0)
            lotSizesExistVal = true;

   myGlobalComp ()->storePreLotSizesExist (lotSizesExistVal);

   forEachOperation (theOpn, myProblem ())
      if (theOpn->twoLevelLotSizes ())
         forEachPeriod (thePer, myProblem ())
            {
            if (theOpn->incLotSize ()[thePer] < 0.9)
               myMsgFac () ("incLotSizeLT1Smsg",
                  theOpn->operationName ().myCstring (),
                  thePer,
                  theOpn->incLotSize ()[thePer]);

            if (theOpn->incLotSize2 ()[thePer] < 0.9)
               myMsgFac () ("incLotSize2LT1Smsg",
                  theOpn->operationName ().myCstring (),
                  thePer,
                  theOpn->incLotSize2 ()[thePer]);
            }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compHasSubsInEffect ()
   {
   WitBomEntry *  theBomEnt;
   WitPeriod      thePer;
   WitSubEntry *  theSub;
   WitTVec <bool> hasSubsInEffectVec (myProblem (), false);

   forEachBomEntry (theBomEnt, myProblem ())
      {
      hasSubsInEffectVec = false;

      if (theBomEnt->mySubEntries ().isEmpty ())
         continue;

      forEachPeriod (thePer, myProblem ())
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->inEffect (thePer))
               {
               hasSubsInEffectVec[thePer] = true;

               break;
               }

      theBomEnt->storePreHasSubsInEffect (hasSubsInEffectVec);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compEffConsRates ()
   {
   WitTVec <double> effConsRateVec;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;

   effConsRateVec.allocate (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      compEffConsRate (theBomEnt, effConsRateVec);

   forEachSubEntry (theSub, myProblem ())
      compEffConsRate (theSub, effConsRateVec);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compEffConsRate (
      WitConsEntry *     theConsEnt,
      WitTVec <double> & effConsRateVec)
   {
   WitPeriod execPer;
   double    effConsRateVal;

   if (theConsEnt->consRate () == theConsEnt->consRate ()[0])
      {
      effConsRateVal =
           theConsEnt->consRate ()[0]
         / (1.0 - theConsEnt->falloutRate ());

      theConsEnt->storePreEffConsRate (effConsRateVal);
      }
   else
      {
      forEachPeriod (execPer, myProblem ())
         effConsRateVec[execPer] =
              theConsEnt->consRate ()[execPer] 
            / (1.0 - theConsEnt->falloutRate ());

      theConsEnt->storePreEffConsRate (effConsRateVec);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::checkMinLotSize (WitBomEntry * theBomEnt)
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      execPer; // Execution period.
   WitPeriod      tCons;   // Consumption period.
   double         avail;   // Availability.
   double         minCons; // Consumption for minLotSize.

   if (not myGlobalComp ()->lotSizesExist ())
      return;

   thePart = theBomEnt->myPart ();
   theOpn  = theBomEnt->myOperation ();

   if (thePart->thisCap () == NULL)
      return;

   forEachPeriod (execPer, myProblem ())
      {
      if (not theBomEnt->inEffect (execPer))
         continue;

      if (theOpn->minLotSize ()[execPer] == 0.0)
         continue;

      tCons = theBomEnt->impactPeriod ()[execPer];

      avail = thePart->supplyVol ()[tCons];

      if (avail == 0.0)
         continue;

      minCons = 
           theOpn   ->minLotSize  ()[execPer]
         * theBomEnt->effConsRate ()[execPer];

      if (minCons > avail + FLOAT_EPSILON)
         {
         myMsgFac () ("minLotSizeTooLargeWmsg",
            theOpn->operationName (),
            execPer,
            minCons,
            thePart->partName (),
            tCons,
            avail);

         return;
         }
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compEffProdRates ()
   {
   WitBopEntry *    theBopEnt;
   WitPeriod        execPer;
   WitTVec <double> effProdRateVec;

   effProdRateVec.allocate (myProblem (), 0.0);

   forEachBopEntry (theBopEnt, myProblem ())
      {
      forEachPeriod (execPer, myProblem ())
         effProdRateVec[execPer] =
            theBopEnt->inEffect (execPer)?
                 theBopEnt->productRate ()[execPer]
               * theBopEnt->myOperation ()->yieldRate ()[execPer]:
               0.0;

      theBopEnt->storePreEffProdRate (effProdRateVec);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::chooseExpExecPeriods ()
   {
   WitTVec <WitPeriod> expExecPeriodVec;
   WitBopEntry *       theBopEnt;
   WitPeriod           execPer;
   double              effProd;
   WitPeriod           prodPer;

   expExecPeriodVec.allocate (myProblem (), -1);

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         continue;

      expExecPeriodVec = -1;

      forEachPeriod (execPer, myProblem ())
         {
         effProd = theBopEnt->effProdRate ()[execPer];

         if (effProd >= myGlobalComp ()->expCutoff ())
            {
            prodPer                   = theBopEnt->impactPeriod ()[execPer];

            expExecPeriodVec[prodPer] = execPer;
            }

         theBopEnt->storePreExpExecPeriod (expExecPeriodVec);
         }
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::checkSmallEffProdRates ()
   {
   double        minAccEffProd;
   WitBopEntry * minAccBopEnt;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   double        effProd;
   WitPeriod     minAccPer;
   double        maxRejEffProd;
   WitBopEntry * maxRejBopEnt;
   WitPeriod     maxRejPer;

   minAccEffProd = WitGlobalComp::defExpCutoff ();
   maxRejEffProd = 0.0;

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            {
            effProd = theBopEnt->effProdRate ()[execPer];

            if (effProd >= myGlobalComp ()->expCutoff ())
               {
               if (effProd < minAccEffProd)
                  {
                  minAccEffProd = effProd;
                  minAccBopEnt  = theBopEnt;
                  minAccPer     = execPer;
                  }
               }
            else 
               if (effProd > maxRejEffProd)
                  {
                  maxRejEffProd = effProd;
                  maxRejBopEnt  = theBopEnt;
                  maxRejPer     = execPer;
                  }
            }

   if (maxRejEffProd > 0.0)
      myMsgFac () ("rejBopEntWmsg",
         myGlobalComp ()->expCutoff (),
         maxRejEffProd,
         maxRejBopEnt->myOperationName (),
         maxRejBopEnt->localIndex (),
         maxRejPer);

   if (minAccEffProd < WitGlobalComp::defExpCutoff () - FLOAT_EPSILON)
      myMsgFac () ("smallEffProdWmsg",
         myGlobalComp ()->expCutoff (),
         WitGlobalComp::defExpCutoff (),
         minAccEffProd,
         minAccBopEnt->myOperationName (),
         minAccBopEnt->localIndex (),
         minAccPer);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::sortBopEntries ()
   {
   WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
   WitPart *                 thePart;
   WitList <WitBopEntry>     theBopEntries;

   forEachPart (thePart, myProblem ())
      {
      theBopEntries = thePart->producingBopEntries ();

      theSorter.sort (theBopEntries);

      thePart->storePreProducingBopEntries (theBopEntries);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::sortSubEntries ()
   {
   WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
   WitBomEntry *             theBomEnt;
   WitList <WitSubEntry>     theSubs;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      theSubs = theBomEnt->mySubEntries ();

      theSorter.sort (theSubs);

      theBomEnt->storePreMySubEntries (theSubs);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::chooseExpBopEntries ()
   {
   WitPtrTVec <WitBopEntry> expBopEntryVec;
   WitPart *                thePart;
   WitBopEntry *            theBopEnt;
   WitPeriod                thePer;

   expBopEntryVec.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      {
      if (thePart->producingBopEntries ().isEmpty ())
         continue;

      expBopEntryVec.setToNull ();

      forEachPeriod (thePer, myProblem ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expExecPeriod ()[thePer] >= 0)
               {
               expBopEntryVec[thePer] = theBopEnt;

               break;
               }

      thePart->storePreExpBopEntry (expBopEntryVec);
      }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::findExpPerGaps ()
   {
   bool          expPerGapsVal;
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;

   forEachPart (thePart, myProblem ())
      {
      expPerGapsVal = false;

      theMat        = thePart->thisMat ();

      if (theMat != NULL)
         if (not theMat->producingBopEntries ().isEmpty ())
            for (thePer = 1; thePer < nPeriods (); thePer ++)
               if (not theMat->explodeable (thePer))
                  if (theMat->explodeable (thePer - 1))
                     if (not theMat->mandEC ()[thePer - 1])
                        {
                        expPerGapsVal = true;

                        break;
                        }

      thePart->storePreExpPerGaps (expPerGapsVal);
      }  
   }

//------------------------------------------------------------------------------
// findMandECs.
// Determines mandEC for each Material in theProblem.
//
// A Material theMat will have a mandEC in thePer, iff
// * There is a BopEntry producing theMat in thePer, and
// * The producing Operation incurs a mandEC in the corresponding exec period.
//
// An Operation, theOpn, can incur a mandEC for either of two reasons:
//
// Direct case:
//    A BomEntry, theBomEnt, in its BOM has a mandEC. In this case,
//    theOpn incurs a mandEC in periods
//    theBomEnt->earliestPeriod () - 1  and theBomEnt->latestPeriod (),
//    but not in lastPeriod ().
//
// Propagated case:
//    theOpn has a ConsEntry, theConsEnt, whose consumed Part is a
//    Material, theMat, that incurs a mandEC. In this case, let tImp be a
//    period in which theMat incurs a mandEC. theOpn incurs its
//    mandEC in the last period execPer, such that
//    theConsEnt->impactPeriod ()[execPer] <= tImp.
//    In other words, the mandEC occurs in the last period in which one can
//    execute theOpn by consuming theMat before or during its
//    mandEC. The mandEC periods, execPer, are found by iterating backwards on
//    tImp and then scanning backwards for execPer, starting with the last 
//    execPer found. This works, because the execPer value for a given tImp is
//    an upper bound on the execPer value of any lower tImp.
//
//    The purpose of the propagated case is to prevent obsolete material from
//    being implicitly stocked by building a product early. The propagation
//    logic implictly assumes that the impact periods of the BopEntries are a
//    non-decreasing function of the exec periods, i.e.,
//    t1 <= t2 ==> impactPeriod ()[t1] <= impactPeriod ()[t2]
//    If this assumption fails to hold, the mandECs generate might not
//    prevent obsolete material from being implicitly stocked, but this is a
//    pathological case.
//
// Note that the mandECs for Operations are not stored: As soon as one is
// found, the corresponding Material mandECs are generated.
//------------------------------------------------------------------------------

void WitPreprocessor::findMandECs ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   forEachBomEntry (theBomEnt, myProblem ())
      setDirectMandECs (theBomEnt);

   forEachBomEntry (theBomEnt, myProblem ())
      propMandECs (theBomEnt);

   forEachSubEntry (theSub, myProblem ())
      propMandECs (theSub);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::setDirectMandECs (WitBomEntry * theBomEnt)
   {
   if (not theBomEnt->mandEC ())
      return;

   if (theBomEnt->earliestPeriod () > 0)
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->earliestPeriod () - 1);

   if (theBomEnt->latestPeriod () < lastPeriod ())
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->latestPeriod ());
   }

//------------------------------------------------------------------------------

void WitPreprocessor::propMandECs (WitConsEntry * theConsEnt)
   {
   WitMaterial * theMat;
   WitPeriod     execPer;
   WitPeriod     thePer;

   theMat = theConsEnt->myPart ()->thisMat ();

   if (theMat == NULL)
      return;

   execPer = lastPeriod ();

   for (thePer = lastPeriod (); thePer >= 0; -- thePer)
      if (theMat->mandEC ()[thePer])
         for (; execPer >= 0; -- execPer)
            if (theConsEnt->inEffect (execPer))
               if (theConsEnt->impactPeriod ()[execPer] <= thePer)
                  {
                  setMandECs (theConsEnt->myOperation (), execPer);

                  break;
                  }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::setMandECs (WitOperation * theOpn, WitPeriod thePer)
   {
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitPeriod     prodPer;

   forEachEl (theBopEnt, theOpn->bop ())
      {
      theMat = theBopEnt->myPart ()->thisMat ();

      if (theMat != NULL)
         if (theBopEnt->inEffect (thePer))
            {
            prodPer = theBopEnt->impactPeriod ()[thePer];

            theMat->storePreMandEC (prodPer, true);
            }
      }
   }
@


1.138
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.137
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d44 8
a51 8
WitProbAssoc   (theProblem),
preprocessing_ (false),
preprocessed_  (false),
myNodeSorter_  (NULL),
myOffsetProc_  (NULL),
myBelowLister_ (NULL)
{
}
d56 2
a57 2
{
}
d62 2
a63 2
{
WitBomEntry * theBomEnt;
d65 2
a66 2
if (preprocessed_)
return;
d68 1
a68 1
myMsgFac () ("preProcMsg");
d70 1
a70 1
setUp ();
d72 1
a72 1
checkMaxNameLength ();
d74 1
a74 1
myNodeSorter ()->sortNodesIfNeeded ();
d76 1
a76 1
myOffsetProc ()->roundOffsets ();
d78 1
a78 1
findMandECs ();
d80 1
a80 1
validateBLA ();
d82 1
a82 1
procLotSizes ();
d84 1
a84 1
compHasSubsInEffect ();
d86 1
a86 1
compEffConsRates ();
d88 2
a89 2
forEachBomEntry (theBomEnt, myProblem ())
checkMinLotSize (theBomEnt);
d91 1
a91 1
compEffProdRates ();
d93 1
a93 1
chooseExpExecPeriods ();
d95 1
a95 1
checkSmallEffProdRates ();
d97 2
a98 2
sortBopEntries ();
sortSubEntries ();
d100 1
a100 1
chooseExpBopEntries ();
d102 1
a102 1
findExpPerGaps ();
d104 1
a104 1
myBelowLister ()->buildBelow ();
d106 2
a107 2
shutDown ();
}
d112 5
a116 5
WitObjStack <WitPart> &      theParts,
WitObjStack <WitOperation> & theOpns)
{
theParts.clear ();
theOpns .clear ();
d118 2
a119 2
if (preprocessed_)
return;
d121 1
a121 1
setUp ();
d123 1
a123 1
myNodeSorter ()->getExpCycle (theParts, theOpns);
d125 2
a126 2
shutDown ();
}
d131 2
a132 2
{
WitComponent * theComp;
d134 1
a134 1
stronglyAssert (not myStochImpMgr ()->stochMode ());
d136 2
a137 2
if (not preprocessed_)
return;
d139 1
a139 1
myProblem ()->resetSoln ();
d141 1
a141 1
myDetOptImpMgr ()->shutDown ();
d143 1
a143 1
myOptComp ()->crashOptStarter ()->beChosen ();
d145 1
a145 1
preprocessed_ = false;
d147 3
a149 3
forEachEl (theComp, myCompMgr ()->allComponents ())
theComp->unpreprocess ();
}
d154 2
a155 2
{
myMsgFac ().abortIfErrors ();
d157 1
a157 1
WitTimer::enterSection ("preproc");
d159 1
a159 1
preprocessing_ = true;
d161 4
a164 4
myNodeSorter_  = new WitNodeSorter  (myProblem ());
myOffsetProc_  = new WitOffsetProc  (myProblem ());
myBelowLister_ = new WitBelowLister (myProblem ());
}
d169 8
a176 8
{
delete myBelowLister_;
delete myOffsetProc_;
delete myNodeSorter_;

myBelowLister_ = NULL;
myOffsetProc_  = NULL;
myNodeSorter_  = NULL;
d178 2
a179 2
preprocessing_ = false;
preprocessed_  = true;
d181 2
a182 2
WitTimer::leaveSection ("preproc");
}
d187 44
a230 44
{
int       maxNameLength;
//
// Maximum length of theNode->nodeName () and
// theDemand->demandName () over all Nodes and Demands.

WitString theLongestName;
//
// A name whose length is maxNameLength.

int       nominalNameLength;
//
// The max name length allowed without a warning.

WitPart *      thePart;
WitOperation * theOpn;
WitDemand *    theDemand;

maxNameLength  = 0;
theLongestName = "";

forEachPart (thePart, myProblem ())
updateLongestName (
thePart->partName (),
maxNameLength,
theLongestName);

forEachOperation (theOpn, myProblem ())
updateLongestName (
theOpn->operationName (),
maxNameLength,
theLongestName);

forEachDemand (theDemand, myProblem ())
updateLongestName (
theDemand->demandName (),
maxNameLength,
theLongestName);

nominalNameLength = 12;

if (maxNameLength > nominalNameLength)
myMsgFac () ("longNameWmsg", nominalNameLength, theLongestName);
}
d235 10
a244 10
const WitString & theName,
int &             maxNameLength,
WitString &       theLongestName)
{
if (theName.length () > maxNameLength)
{
maxNameLength  = theName.length ();
theLongestName = theName;
}
}
d249 24
a272 24
{
WitDemand * theDemand;
WitPeriod   thePer;

forEachDemand (theDemand, myProblem ())
if (not theDemand->shipLateAllowed ())
{
if (theDemand->cumShipReward () != 0.0)
myMsgFac () ("cumShipRewardWoShipLateSmsg",
theDemand->demandedPartName (),
theDemand->demandName ());

if (theDemand->cumShipBounds ()->softLB () != 0.0)
myMsgFac () ("cumShipSLBWoShipLateSmsg",
theDemand->demandedPartName (),
theDemand->demandName ());

forEachPeriod (thePer, myProblem ())
if (theDemand->cumShipBounds ()->hardUBIsFinite (thePer))
myMsgFac () ("cumShipHUBWoShipLateSmsg",
theDemand->demandedPartName (),
theDemand->demandName ());
}
}
d277 31
a307 31
{
bool           lotSizesExistVal;
WitOperation * theOpn;
WitPeriod      thePer;

lotSizesExistVal = false;

forEachOperation (theOpn, myProblem ())
forEachPeriod (thePer, myProblem ())
if (theOpn->incLotSize ()[thePer] > 0.0)
lotSizesExistVal = true;

myGlobalComp ()->storePreLotSizesExist (lotSizesExistVal);

forEachOperation (theOpn, myProblem ())
if (theOpn->twoLevelLotSizes ())
forEachPeriod (thePer, myProblem ())
{
if (theOpn->incLotSize ()[thePer] < 0.9)
myMsgFac () ("incLotSizeLT1Smsg",
theOpn->operationName ().myCstring (),
thePer,
theOpn->incLotSize ()[thePer]);

if (theOpn->incLotSize2 ()[thePer] < 0.9)
myMsgFac () ("incLotSize2LT1Smsg",
theOpn->operationName ().myCstring (),
thePer,
theOpn->incLotSize2 ()[thePer]);
}
}
d312 25
a336 25
{
WitBomEntry *  theBomEnt;
WitPeriod      thePer;
WitSubEntry *  theSub;
WitTVec <bool> hasSubsInEffectVec (myProblem (), false);

forEachBomEntry (theBomEnt, myProblem ())
{
hasSubsInEffectVec = false;

if (theBomEnt->mySubEntries ().isEmpty ())
continue;

forEachPeriod (thePer, myProblem ())
forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->inEffect (thePer))
{
hasSubsInEffectVec[thePer] = true;

break;
}

theBomEnt->storePreHasSubsInEffect (hasSubsInEffectVec);
}
}
d341 13
a353 13
{
WitTVec <double> effConsRateVec;
WitBomEntry *    theBomEnt;
WitSubEntry *    theSub;

effConsRateVec.allocate (myProblem (), 0.0);

forEachBomEntry (theBomEnt, myProblem ())
compEffConsRate (theBomEnt, effConsRateVec);

forEachSubEntry (theSub, myProblem ())
compEffConsRate (theSub, effConsRateVec);
}
d358 24
a381 24
WitConsEntry *     theConsEnt,
WitTVec <double> & effConsRateVec)
{
WitPeriod execPer;
double    effConsRateVal;

if (theConsEnt->consRate () == theConsEnt->consRate ()[0])
{
effConsRateVal =
theConsEnt->consRate ()[0]
/ (1.0 - theConsEnt->falloutRate ());

theConsEnt->storePreEffConsRate (effConsRateVal);
}
else
{
forEachPeriod (execPer, myProblem ())
effConsRateVec[execPer] =
theConsEnt->consRate ()[execPer]
/ (1.0 - theConsEnt->falloutRate ());

theConsEnt->storePreEffConsRate (effConsRateVec);
}
}
d386 50
a435 50
{
WitPart *      thePart;
WitOperation * theOpn;
WitPeriod      execPer; // Execution period.
WitPeriod      tCons;   // Consumption period.
double         avail;   // Availability.
double         minCons; // Consumption for minLotSize.

if (not myGlobalComp ()->lotSizesExist ())
return;

thePart = theBomEnt->myPart ();
theOpn  = theBomEnt->myOperation ();

if (thePart->thisCap () == NULL)
return;

forEachPeriod (execPer, myProblem ())
{
if (not theBomEnt->inEffect (execPer))
continue;

if (theOpn->minLotSize ()[execPer] == 0.0)
continue;

tCons = theBomEnt->impactPeriod ()[execPer];

avail = thePart->supplyVol ()[tCons];

if (avail == 0.0)
continue;

minCons =
theOpn   ->minLotSize  ()[execPer]
* theBomEnt->effConsRate ()[execPer];

if (minCons > avail + FLOAT_EPSILON)
{
myMsgFac () ("minLotSizeTooLargeWmsg",
theOpn->operationName (),
execPer,
minCons,
thePart->partName (),
tCons,
avail);

return;
}
}
}
d440 19
a458 19
{
WitBopEntry *    theBopEnt;
WitPeriod        execPer;
WitTVec <double> effProdRateVec;

effProdRateVec.allocate (myProblem (), 0.0);

forEachBopEntry (theBopEnt, myProblem ())
{
forEachPeriod (execPer, myProblem ())
effProdRateVec[execPer] =
theBopEnt->inEffect (execPer)?
theBopEnt->productRate ()[execPer]
* theBopEnt->myOperation ()->yieldRate ()[execPer]:
0.0;

theBopEnt->storePreEffProdRate (effProdRateVec);
}
}
d463 31
a493 31
{
WitTVec <WitPeriod> expExecPeriodVec;
WitBopEntry *       theBopEnt;
WitPeriod           execPer;
double              effProd;
WitPeriod           prodPer;

expExecPeriodVec.allocate (myProblem (), -1);

forEachBopEntry (theBopEnt, myProblem ())
{
if (not theBopEnt->expAllowed ())
continue;

expExecPeriodVec = -1;

forEachPeriod (execPer, myProblem ())
{
effProd = theBopEnt->effProdRate ()[execPer];

if (effProd >= myGlobalComp ()->expCutoff ())
{
prodPer                   = theBopEnt->impactPeriod ()[execPer];

expExecPeriodVec[prodPer] = execPer;
}

theBopEnt->storePreExpExecPeriod (expExecPeriodVec);
}
}
}
d498 55
a552 55
{
double        minAccEffProd;
WitBopEntry * minAccBopEnt;
WitBopEntry * theBopEnt;
WitPeriod     execPer;
double        effProd;
WitPeriod     minAccPer;
double        maxRejEffProd;
WitBopEntry * maxRejBopEnt;
WitPeriod     maxRejPer;

minAccEffProd = WitGlobalComp::defExpCutoff ();
maxRejEffProd = 0.0;

forEachBopEntry (theBopEnt, myProblem ())
if (theBopEnt->expAllowed ())
forEachPeriod (execPer, myProblem ())
{
effProd = theBopEnt->effProdRate ()[execPer];

if (effProd >= myGlobalComp ()->expCutoff ())
{
if (effProd < minAccEffProd)
{
minAccEffProd = effProd;
minAccBopEnt  = theBopEnt;
minAccPer     = execPer;
}
}
else
if (effProd > maxRejEffProd)
{
maxRejEffProd = effProd;
maxRejBopEnt  = theBopEnt;
maxRejPer     = execPer;
}
}

if (maxRejEffProd > 0.0)
myMsgFac () ("rejBopEntWmsg",
myGlobalComp ()->expCutoff (),
maxRejEffProd,
maxRejBopEnt->myOperationName (),
maxRejBopEnt->localIndex (),
maxRejPer);

if (minAccEffProd < WitGlobalComp::defExpCutoff () - FLOAT_EPSILON)
myMsgFac () ("smallEffProdWmsg",
myGlobalComp ()->expCutoff (),
WitGlobalComp::defExpCutoff (),
minAccEffProd,
minAccBopEnt->myOperationName (),
minAccBopEnt->localIndex (),
minAccPer);
}
d557 14
a570 14
{
WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
WitPart *                 thePart;
WitList <WitBopEntry>     theBopEntries;

forEachPart (thePart, myProblem ())
{
theBopEntries = thePart->producingBopEntries ();

theSorter.sort (theBopEntries);

thePart->storePreProducingBopEntries (theBopEntries);
}
}
d575 14
a588 14
{
WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
WitBomEntry *             theBomEnt;
WitList <WitSubEntry>     theSubs;

forEachBomEntry (theBomEnt, myProblem ())
{
theSubs = theBomEnt->mySubEntries ();

theSorter.sort (theSubs);

theBomEnt->storePreMySubEntries (theSubs);
}
}
d593 27
a619 27
{
WitPtrTVec <WitBopEntry> expBopEntryVec;
WitPart *                thePart;
WitBopEntry *            theBopEnt;
WitPeriod                thePer;

expBopEntryVec.allocate (myProblem ());

forEachPart (thePart, myProblem ())
{
if (thePart->producingBopEntries ().isEmpty ())
continue;

expBopEntryVec.setToNull ();

forEachPeriod (thePer, myProblem ())
forEachEl (theBopEnt, thePart->producingBopEntries ())
if (theBopEnt->expExecPeriod ()[thePer] >= 0)
{
expBopEntryVec[thePer] = theBopEnt;

break;
}

thePart->storePreExpBopEntry (expBopEntryVec);
}
}
d624 27
a650 27
{
bool          expPerGapsVal;
WitPart *     thePart;
WitMaterial * theMat;
WitPeriod     thePer;

forEachPart (thePart, myProblem ())
{
expPerGapsVal = false;

theMat        = thePart->thisMat ();

if (theMat != NULL)
if (not theMat->producingBopEntries ().isEmpty ())
for (thePer = 1; thePer < nPeriods (); thePer ++)
if (not theMat->explodeable (thePer))
if (theMat->explodeable (thePer - 1))
if (not theMat->mandEC ()[thePer - 1])
{
expPerGapsVal = true;

break;
}

thePart->storePreExpPerGaps (expPerGapsVal);
}
}
d677 1
a677 1
//    tImp and then scanning backwards for execPer, starting with the last
d695 13
a707 13
{
WitBomEntry * theBomEnt;
WitSubEntry * theSub;

forEachBomEntry (theBomEnt, myProblem ())
setDirectMandECs (theBomEnt);

forEachBomEntry (theBomEnt, myProblem ())
propMandECs (theBomEnt);

forEachSubEntry (theSub, myProblem ())
propMandECs (theSub);
}
d712 14
a725 14
{
if (not theBomEnt->mandEC ())
return;

if (theBomEnt->earliestPeriod () > 0)
setMandECs (
theBomEnt->myOperation (),
theBomEnt->earliestPeriod () - 1);

if (theBomEnt->latestPeriod () < lastPeriod ())
setMandECs (
theBomEnt->myOperation (),
theBomEnt->latestPeriod ());
}
d730 23
a752 23
{
WitMaterial * theMat;
WitPeriod     execPer;
WitPeriod     thePer;

theMat = theConsEnt->myPart ()->thisMat ();

if (theMat == NULL)
return;

execPer = lastPeriod ();

for (thePer = lastPeriod (); thePer >= 0; -- thePer)
if (theMat->mandEC ()[thePer])
for (; execPer >= 0; -- execPer)
if (theConsEnt->inEffect (execPer))
if (theConsEnt->impactPeriod ()[execPer] <= thePer)
{
setMandECs (theConsEnt->myOperation (), execPer);

break;
}
}
d757 18
a774 18
{
WitMaterial * theMat;
WitBopEntry * theBopEnt;
WitPeriod     prodPer;

forEachEl (theBopEnt, theOpn->bop ())
{
theMat = theBopEnt->myPart ()->thisMat ();

if (theMat != NULL)
if (theBopEnt->inEffect (thePer))
{
prodPer = theBopEnt->impactPeriod ()[thePer];

theMat->storePreMandEC (prodPer, true);
}
}
}
@


1.136
log
@Removed COIN from WIT.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d44 8
a51 8
      WitProbAssoc   (theProblem),
      preprocessing_ (false),
      preprocessed_  (false),
      myNodeSorter_  (NULL),
      myOffsetProc_  (NULL),
      myBelowLister_ (NULL)
   {
   }
d56 2
a57 2
   {
   }
d62 2
a63 2
   {
   WitBomEntry * theBomEnt;
d65 2
a66 2
   if (preprocessed_)
      return;
d68 1
a68 1
   myMsgFac () ("preProcMsg");
d70 1
a70 1
   setUp ();
d72 1
a72 1
   checkMaxNameLength ();
d74 1
a74 1
   myNodeSorter ()->sortNodesIfNeeded ();
d76 1
a76 1
   myOffsetProc ()->roundOffsets ();
d78 1
a78 1
   findMandECs ();
d80 1
a80 1
   validateBLA ();
d82 1
a82 1
   procLotSizes ();
d84 1
a84 1
   compHasSubsInEffect ();
d86 1
a86 1
   compEffConsRates ();
d88 2
a89 2
   forEachBomEntry (theBomEnt, myProblem ())
      checkMinLotSize (theBomEnt);
d91 1
a91 1
   compEffProdRates ();
d93 1
a93 1
   chooseExpExecPeriods ();
d95 1
a95 1
   checkSmallEffProdRates ();
d97 2
a98 2
   sortBopEntries ();
   sortSubEntries ();
d100 1
a100 1
   chooseExpBopEntries ();
d102 1
a102 1
   findExpPerGaps ();
d104 1
a104 1
   myBelowLister ()->buildBelow ();
d106 2
a107 2
   shutDown ();
   }
d112 5
a116 5
      WitObjStack <WitPart> &      theParts,
      WitObjStack <WitOperation> & theOpns)
   {
   theParts.clear ();
   theOpns .clear ();
d118 2
a119 2
   if (preprocessed_)
      return;
d121 1
a121 1
   setUp ();
d123 1
a123 1
   myNodeSorter ()->getExpCycle (theParts, theOpns);
d125 2
a126 2
   shutDown ();
   }
d131 2
a132 2
   {
   WitComponent * theComp;
d134 1
a134 1
   stronglyAssert (not myStochImpMgr ()->stochMode ());
d136 2
a137 2
   if (not preprocessed_)
      return;
d139 1
a139 1
   myProblem ()->resetSoln ();
d141 1
a141 1
   myDetOptImpMgr ()->shutDown ();
d143 1
a143 1
   myOptComp ()->crashOptStarter ()->beChosen ();
d145 1
a145 1
   preprocessed_ = false;
d147 3
a149 3
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->unpreprocess ();
   }
d154 2
a155 2
   {
   myMsgFac ().abortIfErrors ();
d157 1
a157 1
   WitTimer::enterSection ("preproc");
d159 1
a159 1
   preprocessing_ = true;
d161 4
a164 4
   myNodeSorter_  = new WitNodeSorter  (myProblem ());
   myOffsetProc_  = new WitOffsetProc  (myProblem ());
   myBelowLister_ = new WitBelowLister (myProblem ());
   }
d169 8
a176 8
   {
   delete myBelowLister_;
   delete myOffsetProc_;
   delete myNodeSorter_;

   myBelowLister_ = NULL;
   myOffsetProc_  = NULL;
   myNodeSorter_  = NULL;
d178 2
a179 2
   preprocessing_ = false;
   preprocessed_  = true;
d181 2
a182 2
   WitTimer::leaveSection ("preproc");
   }
d187 44
a230 44
   {
   int       maxNameLength;
      //
      // Maximum length of theNode->nodeName () and
      // theDemand->demandName () over all Nodes and Demands.

   WitString theLongestName;
      //
      // A name whose length is maxNameLength.

   int       nominalNameLength;
      //
      // The max name length allowed without a warning.

   WitPart *      thePart;
   WitOperation * theOpn;
   WitDemand *    theDemand;

   maxNameLength  = 0;
   theLongestName = "";

   forEachPart (thePart, myProblem ())
      updateLongestName (
         thePart->partName (),
         maxNameLength,
         theLongestName);

   forEachOperation (theOpn, myProblem ())
      updateLongestName (
         theOpn->operationName (),
         maxNameLength,
         theLongestName);

   forEachDemand (theDemand, myProblem ())
      updateLongestName (
         theDemand->demandName (),
         maxNameLength,
         theLongestName);

   nominalNameLength = 12;

   if (maxNameLength > nominalNameLength)
      myMsgFac () ("longNameWmsg", nominalNameLength, theLongestName);
   }
d235 10
a244 10
      const WitString & theName,
      int &             maxNameLength,
      WitString &       theLongestName)
   {
   if (theName.length () > maxNameLength)
      {
      maxNameLength  = theName.length ();
      theLongestName = theName;
      }
   }
d249 24
a272 24
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      if (not theDemand->shipLateAllowed ())
         {
         if (theDemand->cumShipReward () != 0.0)
            myMsgFac () ("cumShipRewardWoShipLateSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         if (theDemand->cumShipBounds ()->softLB () != 0.0)
            myMsgFac () ("cumShipSLBWoShipLateSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         forEachPeriod (thePer, myProblem ())
            if (theDemand->cumShipBounds ()->hardUBIsFinite (thePer))
               myMsgFac () ("cumShipHUBWoShipLateSmsg",
                  theDemand->demandedPartName (),
                  theDemand->demandName ());
         }
   }
d277 31
a307 31
   {
   bool           lotSizesExistVal;
   WitOperation * theOpn;
   WitPeriod      thePer;

   lotSizesExistVal = false;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->incLotSize ()[thePer] > 0.0)
            lotSizesExistVal = true;

   myGlobalComp ()->storePreLotSizesExist (lotSizesExistVal);

   forEachOperation (theOpn, myProblem ())
      if (theOpn->twoLevelLotSizes ())
         forEachPeriod (thePer, myProblem ())
            {
            if (theOpn->incLotSize ()[thePer] < 0.9)
               myMsgFac () ("incLotSizeLT1Smsg",
                  theOpn->operationName ().myCstring (),
                  thePer,
                  theOpn->incLotSize ()[thePer]);

            if (theOpn->incLotSize2 ()[thePer] < 0.9)
               myMsgFac () ("incLotSize2LT1Smsg",
                  theOpn->operationName ().myCstring (),
                  thePer,
                  theOpn->incLotSize2 ()[thePer]);
            }
   }
d312 25
a336 25
   {
   WitBomEntry *  theBomEnt;
   WitPeriod      thePer;
   WitSubEntry *  theSub;
   WitTVec <bool> hasSubsInEffectVec (myProblem (), false);

   forEachBomEntry (theBomEnt, myProblem ())
      {
      hasSubsInEffectVec = false;

      if (theBomEnt->mySubEntries ().isEmpty ())
         continue;

      forEachPeriod (thePer, myProblem ())
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->inEffect (thePer))
               {
               hasSubsInEffectVec[thePer] = true;

               break;
               }

      theBomEnt->storePreHasSubsInEffect (hasSubsInEffectVec);
      }
   }
d341 13
a353 13
   {
   WitTVec <double> effConsRateVec;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;

   effConsRateVec.allocate (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      compEffConsRate (theBomEnt, effConsRateVec);

   forEachSubEntry (theSub, myProblem ())
      compEffConsRate (theSub, effConsRateVec);
   }
d358 24
a381 24
      WitConsEntry *     theConsEnt,
      WitTVec <double> & effConsRateVec)
   {
   WitPeriod execPer;
   double    effConsRateVal;

   if (theConsEnt->consRate () == theConsEnt->consRate ()[0])
      {
      effConsRateVal =
           theConsEnt->consRate ()[0]
         / (1.0 - theConsEnt->falloutRate ());

      theConsEnt->storePreEffConsRate (effConsRateVal);
      }
   else
      {
      forEachPeriod (execPer, myProblem ())
         effConsRateVec[execPer] =
              theConsEnt->consRate ()[execPer] 
            / (1.0 - theConsEnt->falloutRate ());

      theConsEnt->storePreEffConsRate (effConsRateVec);
      }
   }
d386 50
a435 50
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      execPer; // Execution period.
   WitPeriod      tCons;   // Consumption period.
   double         avail;   // Availability.
   double         minCons; // Consumption for minLotSize.

   if (not myGlobalComp ()->lotSizesExist ())
      return;

   thePart = theBomEnt->myPart ();
   theOpn  = theBomEnt->myOperation ();

   if (thePart->thisCap () == NULL)
      return;

   forEachPeriod (execPer, myProblem ())
      {
      if (not theBomEnt->inEffect (execPer))
         continue;

      if (theOpn->minLotSize ()[execPer] == 0.0)
         continue;

      tCons = theBomEnt->impactPeriod ()[execPer];

      avail = thePart->supplyVol ()[tCons];

      if (avail == 0.0)
         continue;

      minCons = 
           theOpn   ->minLotSize  ()[execPer]
         * theBomEnt->effConsRate ()[execPer];

      if (minCons > avail + FLOAT_EPSILON)
         {
         myMsgFac () ("minLotSizeTooLargeWmsg",
            theOpn->operationName (),
            execPer,
            minCons,
            thePart->partName (),
            tCons,
            avail);

         return;
         }
      }
   }
d440 19
a458 19
   {
   WitBopEntry *    theBopEnt;
   WitPeriod        execPer;
   WitTVec <double> effProdRateVec;

   effProdRateVec.allocate (myProblem (), 0.0);

   forEachBopEntry (theBopEnt, myProblem ())
      {
      forEachPeriod (execPer, myProblem ())
         effProdRateVec[execPer] =
            theBopEnt->inEffect (execPer)?
                 theBopEnt->productRate ()[execPer]
               * theBopEnt->myOperation ()->yieldRate ()[execPer]:
               0.0;

      theBopEnt->storePreEffProdRate (effProdRateVec);
      }
   }
d463 31
a493 31
   {
   WitTVec <WitPeriod> expExecPeriodVec;
   WitBopEntry *       theBopEnt;
   WitPeriod           execPer;
   double              effProd;
   WitPeriod           prodPer;

   expExecPeriodVec.allocate (myProblem (), -1);

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         continue;

      expExecPeriodVec = -1;

      forEachPeriod (execPer, myProblem ())
         {
         effProd = theBopEnt->effProdRate ()[execPer];

         if (effProd >= myGlobalComp ()->expCutoff ())
            {
            prodPer                   = theBopEnt->impactPeriod ()[execPer];

            expExecPeriodVec[prodPer] = execPer;
            }

         theBopEnt->storePreExpExecPeriod (expExecPeriodVec);
         }
      }
   }
d498 55
a552 55
   {
   double        minAccEffProd;
   WitBopEntry * minAccBopEnt;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   double        effProd;
   WitPeriod     minAccPer;
   double        maxRejEffProd;
   WitBopEntry * maxRejBopEnt;
   WitPeriod     maxRejPer;

   minAccEffProd = WitGlobalComp::defExpCutoff ();
   maxRejEffProd = 0.0;

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            {
            effProd = theBopEnt->effProdRate ()[execPer];

            if (effProd >= myGlobalComp ()->expCutoff ())
               {
               if (effProd < minAccEffProd)
                  {
                  minAccEffProd = effProd;
                  minAccBopEnt  = theBopEnt;
                  minAccPer     = execPer;
                  }
               }
            else 
               if (effProd > maxRejEffProd)
                  {
                  maxRejEffProd = effProd;
                  maxRejBopEnt  = theBopEnt;
                  maxRejPer     = execPer;
                  }
            }

   if (maxRejEffProd > 0.0)
      myMsgFac () ("rejBopEntWmsg",
         myGlobalComp ()->expCutoff (),
         maxRejEffProd,
         maxRejBopEnt->myOperationName (),
         maxRejBopEnt->localIndex (),
         maxRejPer);

   if (minAccEffProd < WitGlobalComp::defExpCutoff () - FLOAT_EPSILON)
      myMsgFac () ("smallEffProdWmsg",
         myGlobalComp ()->expCutoff (),
         WitGlobalComp::defExpCutoff (),
         minAccEffProd,
         minAccBopEnt->myOperationName (),
         minAccBopEnt->localIndex (),
         minAccPer);
   }
d557 14
a570 14
   {
   WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
   WitPart *                 thePart;
   WitList <WitBopEntry>     theBopEntries;

   forEachPart (thePart, myProblem ())
      {
      theBopEntries = thePart->producingBopEntries ();

      theSorter.sort (theBopEntries);

      thePart->storePreProducingBopEntries (theBopEntries);
      }
   }
d575 14
a588 14
   {
   WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
   WitBomEntry *             theBomEnt;
   WitList <WitSubEntry>     theSubs;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      theSubs = theBomEnt->mySubEntries ();

      theSorter.sort (theSubs);

      theBomEnt->storePreMySubEntries (theSubs);
      }
   }
d593 27
a619 27
   {
   WitPtrTVec <WitBopEntry> expBopEntryVec;
   WitPart *                thePart;
   WitBopEntry *            theBopEnt;
   WitPeriod                thePer;

   expBopEntryVec.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      {
      if (thePart->producingBopEntries ().isEmpty ())
         continue;

      expBopEntryVec.setToNull ();

      forEachPeriod (thePer, myProblem ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expExecPeriod ()[thePer] >= 0)
               {
               expBopEntryVec[thePer] = theBopEnt;

               break;
               }

      thePart->storePreExpBopEntry (expBopEntryVec);
      }
   }
d624 27
a650 27
   {
   bool          expPerGapsVal;
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;

   forEachPart (thePart, myProblem ())
      {
      expPerGapsVal = false;

      theMat        = thePart->thisMat ();

      if (theMat != NULL)
         if (not theMat->producingBopEntries ().isEmpty ())
            for (thePer = 1; thePer < nPeriods (); thePer ++)
               if (not theMat->explodeable (thePer))
                  if (theMat->explodeable (thePer - 1))
                     if (not theMat->mandEC ()[thePer - 1])
                        {
                        expPerGapsVal = true;

                        break;
                        }

      thePart->storePreExpPerGaps (expPerGapsVal);
      }  
   }
d677 1
a677 1
//    tImp and then scanning backwards for execPer, starting with the last 
d695 13
a707 13
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   forEachBomEntry (theBomEnt, myProblem ())
      setDirectMandECs (theBomEnt);

   forEachBomEntry (theBomEnt, myProblem ())
      propMandECs (theBomEnt);

   forEachSubEntry (theSub, myProblem ())
      propMandECs (theSub);
   }
d712 14
a725 14
   {
   if (not theBomEnt->mandEC ())
      return;

   if (theBomEnt->earliestPeriod () > 0)
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->earliestPeriod () - 1);

   if (theBomEnt->latestPeriod () < lastPeriod ())
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->latestPeriod ());
   }
d730 23
a752 23
   {
   WitMaterial * theMat;
   WitPeriod     execPer;
   WitPeriod     thePer;

   theMat = theConsEnt->myPart ()->thisMat ();

   if (theMat == NULL)
      return;

   execPer = lastPeriod ();

   for (thePer = lastPeriod (); thePer >= 0; -- thePer)
      if (theMat->mandEC ()[thePer])
         for (; execPer >= 0; -- execPer)
            if (theConsEnt->inEffect (execPer))
               if (theConsEnt->impactPeriod ()[execPer] <= thePer)
                  {
                  setMandECs (theConsEnt->myOperation (), execPer);

                  break;
                  }
   }
d757 18
a774 18
   {
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitPeriod     prodPer;

   forEachEl (theBopEnt, theOpn->bop ())
      {
      theMat = theBopEnt->myPart ()->thisMat ();

      if (theMat != NULL)
         if (theBopEnt->inEffect (thePer))
            {
            prodPer = theBopEnt->impactPeriod ()[thePer];

            theMat->storePreMandEC (prodPer, true);
            }
      }
   }
@


1.135
log
@CPLEX
@
text
@d143 1
a143 4
   if (myOptComp ()->cplexSelected ())
      myOptComp ()->crashOptStarter ()->beChosen ();
   else
      myOptComp ()->heurOptStarter  ()->beChosen ();
@


1.134
log
@Allowed intExecVols, etc. with mipMode == false.
@
text
@d143 4
a146 1
   myOptComp ()->heurOptStarter ()->beChosen ();
@


1.133
log
@Heuristic Adjustment
@
text
@a152 29
void WitPreprocessor::verifyNoIntCons ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
   WitDemand *    theDemand;

   stronglyAssert (not myOptComp ()->mipMode ());

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         myMsgFac () ("intExecVolsWoMipModeSmsg",
            theOpn->operationName ());

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         myMsgFac () ("intSubVolsWoMipModeSmsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->localIndex (),
            theSub->             localIndex ());

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         myMsgFac () ("intShipVolsWoMipModeSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName ());
   }

//------------------------------------------------------------------------------

@


1.132
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d25 1
a25 1
#include <Opn.h>
@


1.131
log
@Multi-objective mode
@
text
@d22 1
a22 1
#include <Global.h>
@


1.130
log
@Removing objective #2.
@
text
@d235 1
a235 2

   theLongestName.copyCstring ("");
@


1.129
log
@Re-organized code.
@
text
@a300 5

         if (myCompMgr ()->myOptComp ()->myObjFunc2 ()->isChosen ())
            myMsgFac () ("obj2WoShipLateSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());
@


1.128
log
@Stochastic Implosion
@
text
@d19 1
a19 1
#include <Offset.h>
@


1.127
log
@witGetExpCycle
@
text
@d44 6
a49 15
      WitProbAssoc         (theProblem),
      preprocessed_        (false),
      myNodeSorter_        (NULL),
      myOffsetProc_        (NULL),
      myBelowLister_       (NULL),
      lotSizesExist_       (),
      expPerGaps_          (),
      producingBopEntries_ (),
      expBopEntry_         (),
      mandEC_              (),
      effConsRate_         (),
      hasSubsInEffect_     (),
      mySubEntries_        (),
      effProdRate_         (),
      expExecPeriod_       ()
a63 2
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
d86 2
a88 2
      {
      compEffConsRate (theBomEnt);
a89 1
      }
d91 1
a91 2
   forEachSubEntry (theSub, myProblem ())
      compEffConsRate (theSub);
d93 1
a93 5
   forEachBopEntry (theBopEnt, myProblem ())
      {
      compEffProdRate      (theBopEnt);
      chooseExpExecPeriods (theBopEnt);
      }
a181 95
void WitPreprocessor::receiveRefs (
      WitCompMgr *             theCompMgr,
      WitList <WitPart>      & allPartsRef,
      WitList <WitOperation> & allOperationsRef)
   {
   myNodeSorter  ()->receiveRefs (theCompMgr, allPartsRef, allOperationsRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitGlobalComp *,
      bool & lotSizesExistRef)
   {
   lotSizesExist_.attachTo (lotSizesExistRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitPart *                  thePart,
      bool                     & expPerGapsRef,
      WitList <WitBopEntry>    & producingBopEntriesRef,
      WitPtrTVec <WitBopEntry> & expBopEntryRef,
      int                      & sortedPartIndexRef,
      WitPtrVec <WitPart>      & belowListRef)
   {
   expPerGaps_         .setMapFor (thePart, expPerGapsRef);
   producingBopEntries_.setMapFor (thePart, producingBopEntriesRef);
   expBopEntry_        .setMapFor (thePart, expBopEntryRef);

   myNodeSorter  ()->receiveRefs  (thePart, sortedPartIndexRef);
   myBelowLister ()->receiveRefs  (thePart, belowListRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitMaterial *       theMat,
      WitFlexVec <bool> & mandECRef)
   {
   mandEC_.setMapFor (theMat, mandECRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitOperation *   theOpn,
      WitTVec <bool> & executableRef)
   {
   myOffsetProc ()->receiveRefs (theOpn, executableRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitBillEntry *        theBillEnt,
      WitTVec <WitPeriod> & impactPeriodRef)
   {
   myOffsetProc ()->receiveRefs (theBillEnt, impactPeriodRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitConsEntry *  theConsEnt,
      WitDblFlexVec & effConsRateRef)
   {
   effConsRate_.setMapFor (theConsEnt, effConsRateRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitBomEntry *           theBomEnt,
      WitFlexVec <bool>     & hasSubsInEffectRef,
      WitList <WitSubEntry> & mySubEntriesRef)
   {
   hasSubsInEffect_.setMapFor (theBomEnt, hasSubsInEffectRef);
   mySubEntries_   .setMapFor (theBomEnt, mySubEntriesRef);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveRefs (
      WitBopEntry *         theBopEnt,
      WitDblFlexVec       & effProdRateRef,
      WitTVec <WitPeriod> & expExecPeriodRef)
   {
   effProdRate_  .setMapFor (theBopEnt, effProdRateRef);
   expExecPeriod_.setMapFor (theBopEnt, expExecPeriodRef);
   }

//------------------------------------------------------------------------------

d188 2
a192 26

   acquireRefs ();
   }

//------------------------------------------------------------------------------

void WitPreprocessor::acquireRefs ()
   {
   WitComponent * theComp;

   lotSizesExist_      .allowAttach ();

   expPerGaps_         .allocate (myProblem ());
   producingBopEntries_.allocate (myProblem ());
   expBopEntry_        .allocate (myProblem ());
   mandEC_             .allocate (myProblem ());
   effConsRate_        .allocate (myProblem ());
   hasSubsInEffect_    .allocate (myProblem ());
   mySubEntries_       .allocate (myProblem ());
   effProdRate_        .allocate (myProblem ());
   expExecPeriod_      .allocate (myProblem ());

   myCompMgr ()->passPreRefs ();

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->passPreRefs ();
a198 11
   lotSizesExist_      .clear ();
   expPerGaps_         .clear ();
   producingBopEntries_.clear ();
   expBopEntry_        .clear ();
   mandEC_             .clear ();
   effConsRate_        .clear ();
   hasSubsInEffect_    .clear ();
   mySubEntries_       .clear ();
   effProdRate_        .clear ();
   expExecPeriod_      .clear ();

d207 1
d313 1
d317 1
a317 1
   lotSizesExist_ () = false;
d322 3
a324 1
            lotSizesExist_ () = true;
d369 1
a369 1
      hasSubsInEffect_ (theBomEnt) = hasSubsInEffectVec;
d375 20
a394 1
void WitPreprocessor::compEffConsRate (WitConsEntry * theConsEnt)
d397 1
a397 1
   double    effRate;
d400 7
a406 2
      effConsRate_ (theConsEnt) =
         (theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d408 1
d410 1
a410 2
         {
         effRate = 
d414 2
a415 2
         effConsRate_ (theConsEnt).elemRef (execPer) = effRate;
         }
d474 1
a474 1
void WitPreprocessor::compEffProdRate (WitBopEntry * theBopEnt)
d476 5
a480 2
   WitPeriod execPer;
   double    effRate;
d482 1
a482 1
   forEachPeriod (execPer, myProblem ())
d484 6
a489 5
      effRate =
         theBopEnt->inEffect (execPer)?
              theBopEnt->productRate ()[execPer]
            * theBopEnt->myOperation ()->yieldRate ()[execPer]:
            0.0;
d491 1
a491 1
      effProdRate_ (theBopEnt).elemRef (execPer) = effRate;
d497 1
a497 1
void WitPreprocessor::chooseExpExecPeriods (WitBopEntry * theBopEnt)
d499 5
a503 3
   WitPeriod execPer;
   double    effProd;
   WitPeriod prodPer;
d505 1
a505 1
   expExecPeriod_ (theBopEnt) = -1;
d507 4
a510 2
   if (not theBopEnt->expAllowed ())
      return;
d512 1
a512 3
   forEachPeriod (execPer, myProblem ())
      {
      effProd = theBopEnt->effProdRate ()[execPer];
d514 1
a514 1
      if (effProd >= myGlobalComp ()->expCutoff ())
d516 8
a523 1
         prodPer = theBopEnt->impactPeriod ()[execPer];
d525 1
a525 1
         expExecPeriod_ (theBopEnt)[prodPer] = execPer;
d595 1
d598 7
a604 1
      theSorter.sort (producingBopEntries_ (thePart));
d613 1
d616 7
a622 1
      theSorter.sort (mySubEntries_ (theBomEnt));
d629 6
a634 3
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
d641 1
a641 1
      expBopEntry_ (thePart).allocate (myProblem ());
d647 1
a647 1
               expBopEntry_ (thePart)[thePer] = theBopEnt;
d651 2
d660 1
d667 1
a667 1
      expPerGaps_ (thePart) = false;
d669 1
a669 1
      theMat = thePart->thisMat ();
d678 1
a678 1
                        expPerGaps_ (theMat) = true;
d682 2
d806 1
a806 1
            mandEC_ (theMat).elemRef (prodPer) = true;
@


1.126
log
@Stochastic Implosion
@
text
@d79 2
d128 19
a299 2
   myMsgFac () ("preProcMsg");

@


1.125
log
@Stochastic Implosion
@
text
@d149 29
@


1.124
log
@Stochastic Implosion
@
text
@d33 1
a33 1
#include <OptImp.h>
d137 1
a137 1
   myOptImploder ()->shutDown ();
@


1.123
log
@Stochastic Implosion
@
text
@d151 2
a152 2
      WitList <WitPart>      & allPartsArg,
      WitList <WitOperation> & allOperationsArg)
d154 1
a154 1
   myNodeSorter  ()->receiveRefs (theCompMgr, allPartsArg, allOperationsArg);
d161 1
a161 1
      bool & lotSizesExistArg)
d163 1
a163 1
   lotSizesExist_.attachTo (lotSizesExistArg);
d170 9
a178 9
      bool                     & expPerGapsArg,
      WitList <WitBopEntry>    & producingBopEntriesArg,
      WitPtrTVec <WitBopEntry> & expBopEntryArg,
      int                      & sortedPartIndexArg,
      WitPtrVec <WitPart>      & belowListArg)
   {
   expPerGaps_         .setMapFor (thePart, expPerGapsArg);
   producingBopEntries_.setMapFor (thePart, producingBopEntriesArg);
   expBopEntry_        .setMapFor (thePart, expBopEntryArg);
d180 2
a181 2
   myNodeSorter  ()->receiveRefs  (thePart, sortedPartIndexArg);
   myBelowLister ()->receiveRefs  (thePart, belowListArg);
d188 1
a188 1
      WitFlexVec <bool> & mandECArg)
d190 1
a190 1
   mandEC_.setMapFor (theMat, mandECArg);
d197 1
a197 1
      WitTVec <bool> & executableArg)
d199 1
a199 1
   myOffsetProc ()->receiveRefs (theOpn, executableArg);
d206 1
a206 1
      WitTVec <WitPeriod> & impactPeriodArg)
d208 1
a208 1
   myOffsetProc ()->receiveRefs (theBillEnt, impactPeriodArg);
d215 1
a215 1
      WitDblFlexVec & effConsRateArg)
d217 1
a217 1
   effConsRate_.setMapFor (theConsEnt, effConsRateArg);
d224 2
a225 2
      WitFlexVec <bool>     & hasSubsInEffectArg,
      WitList <WitSubEntry> & mySubEntriesArg)
d227 2
a228 2
   hasSubsInEffect_.setMapFor (theBomEnt, hasSubsInEffectArg);
   mySubEntries_   .setMapFor (theBomEnt, mySubEntriesArg);
d235 2
a236 2
      WitDblFlexVec       & effProdRateArg,
      WitTVec <WitPeriod> & expExecPeriodArg)
d238 2
a239 2
   effProdRate_  .setMapFor (theBopEnt, effProdRateArg);
   expExecPeriod_.setMapFor (theBopEnt, expExecPeriodArg);
@


1.122
log
@Stochastic Implosion
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
//    Preprocessor
//    PreData
a16 1
#include <PreData.h>
a30 1
#include <PreAccess.h>
a44 2
      myPreData_           (NULL),
      expPreData_          (NULL),
d252 3
a254 4
   myPreData_     = new WitPreData     (myProblem ());
   myNodeSorter_  = new WitNodeSorter  (myPreData_);
   myOffsetProc_  = new WitOffsetProc  (myPreData_);
   myBelowLister_ = new WitBelowLister (myPreData_);
a305 2
   exportData ();

d414 1
a414 1
   myPreData_->lotSizesExist () = false;
d419 1
a419 1
            myPreData_->lotSizesExist () = true;
d446 1
d450 1
a450 1
      myPreData_->hasSubsInEffect () (theBomEnt) = false;
d457 1
a457 1
            if (myPreData_->inEffect (theSub, thePer))
d459 1
a459 1
               myPreData_->hasSubsInEffect () (theBomEnt)[thePer] = true;
d463 2
d473 1
d475 7
a481 3
   forEachPeriod (execPer, myProblem ())
      myPreData_->
         effConsRate () (theConsEnt)[execPer] =
d484 3
d500 1
a500 1
   if (not myPreData_->lotSizesExist ())
d511 1
a511 1
      if (not myPreData_->inEffect (theBomEnt, execPer))
d517 1
a517 1
      tCons = myPreData_->impactPeriod () (theBomEnt)[execPer];
d525 2
a526 2
           theOpn->minLotSize ()[execPer]
         * myPreData_->effConsRate () (theBomEnt)[execPer];
d548 1
d551 9
a559 6
      myPreData_->
         effProdRate () (theBopEnt)[execPer] =
            myPreData_->inEffect (theBopEnt, execPer)?
                 theBopEnt->productRate ()[execPer]
               * theBopEnt->myOperation ()->yieldRate ()[execPer]:
               0.0;
d570 1
a570 1
   myPreData_->expExecPeriod () (theBopEnt) = -1;
d577 1
a577 1
      effProd = myPreData_->effProdRate () (theBopEnt)[execPer];
d581 1
a581 1
         prodPer = myPreData_->impactPeriod () (theBopEnt)[execPer];
d583 1
a583 1
         myPreData_->expExecPeriod () (theBopEnt)[prodPer] = execPer;
d609 1
a609 1
            effProd = myPreData_->effProdRate () (theBopEnt)[execPer];
d651 2
a652 6
   WitPart * thePart;

   WitAvSorter <WitBopEntry>
      theSorter (
         myPreData_,
         myCompMgr ()->nBopEntries ());
d655 1
a655 1
      theSorter.sort (myPreData_->producingBopEntries (thePart));
d662 2
a663 6
   WitBomEntry * theBomEnt;

   WitAvSorter <WitSubEntry>
      theSorter (
         myPreData_,
         myCompMgr ()->nSubEntries ());
d666 1
a666 1
      theSorter.sort (myPreData_->mySubEntries (theBomEnt));
d679 1
a679 1
      if (myPreData_->producingBopEntries (thePart).isEmpty ())
d682 1
a682 1
      WitPreAccess::expBopEntry (thePart).allocate (myProblem ());
d685 2
a686 2
         forEachEl (theBopEnt, myPreData_->producingBopEntries (thePart))
            if (myPreData_->expExecPeriod () (theBopEnt)[thePer] >= 0)
d688 1
a688 1
               WitPreAccess::expBopEntry (thePart)[thePer] = theBopEnt;
d705 1
a705 1
      WitPreAccess::expPerGaps (thePart) = false;
d714 1
a714 1
                     if (not myPreData_->mandEC () (theMat)[thePer - 1])
d716 1
a716 1
                        WitPreAccess::expPerGaps (theMat) = true;
d814 1
a814 1
      if (myPreData_->mandEC () (theMat)[thePer])
d816 2
a817 2
            if (myPreData_->inEffect (theConsEnt, execPer))
               if (myPreData_->impactPeriod () (theConsEnt)[execPer] <= thePer)
d838 1
a838 1
         if (myPreData_->inEffect (theBopEnt, thePer))
d840 1
a840 1
            prodPer = myPreData_->impactPeriod () (theBopEnt)[thePer];
d842 1
a842 1
            myPreData_->mandEC () (theMat)[prodPer] = true;
a845 121

//------------------------------------------------------------------------------

void WitPreprocessor::exportData ()
   {
   expPreData_ = myPreData_;

   myPreData_->exportData ();

   expPreData_ = NULL;

   delete myPreData_;

   myPreData_  = NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class PreData.
//------------------------------------------------------------------------------

WitPreData::WitPreData (WitProblem * theProblem):

      WitProbAssoc         (theProblem),
      allParts_            (),
      allOperations_       (),
      sortedPartIndex_     (myProblem (), -1),
      executable_          (myProblem (), false),
      impactPeriod_        (myProblem (), -1),
      mandEC_              (myProblem (), false),
      lotSizesExist_       (false),
      hasSubsInEffect_     (myProblem (), false),
      effConsRate_         (myProblem (), 0.0),
      effProdRate_         (myProblem (), 0.0),
      expExecPeriod_       (myProblem (), -1),
      producingBopEntries_ (myProblem ()),
      mySubEntries_        (myProblem ())
   {                 
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, myProblem ())
      {
      producingBopEntries_ (thePart) = new WitList <WitBopEntry>;

      producingBopEntries  (thePart) = thePart->producingBopEntries ();
      }

   forEachBomEntry (theBomEnt, myProblem ())
      {
      mySubEntries_ (theBomEnt) = new WitList <WitSubEntry>;

      mySubEntries  (theBomEnt) = theBomEnt->mySubEntries ();
      }
   }

//------------------------------------------------------------------------------

WitPreData::~WitPreData ()
   {
   WitBomEntry * theBomEnt;
   WitPart *     thePart;

   forEachBomEntry (theBomEnt, myProblem ())
      delete mySubEntries_ (theBomEnt);

   forEachPart (thePart, myProblem ())
      delete producingBopEntries_ (thePart);
   }

//------------------------------------------------------------------------------

void WitPreData::exportData ()
   {
   WitComponent * theComp;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importPreData ();

   myCompMgr ()->importPreData ();
   }

//------------------------------------------------------------------------------

bool WitPreData::inEffect (WitBillEntry * theBillEnt, WitPeriod thePer) const
   {
   return impactPeriod_ (theBillEnt)[thePer] >= 0;
   }

//------------------------------------------------------------------------------

const WitList <WitBopEntry> & WitPreData::producingBopEntries (
      WitPart * thePart)
      const
   {
   return * producingBopEntries_ (thePart);
   }


//------------------------------------------------------------------------------

const WitList <WitSubEntry> & WitPreData::mySubEntries (
      WitBomEntry * theBomEnt)
      const
   {
   return * mySubEntries_ (theBomEnt);
   }

//------------------------------------------------------------------------------

WitList <WitBopEntry> & WitPreData::producingBopEntries (WitPart * thePart)
   {
   return * producingBopEntries_ (thePart);
   }

//------------------------------------------------------------------------------

WitList <WitSubEntry> & WitPreData::mySubEntries (WitBomEntry * theBomEnt)
   {
   return * mySubEntries_ (theBomEnt);
   }

@


1.121
log
@Stochastic Implosion
@
text
@d263 26
d295 11
@


1.120
log
@Stochastic Implosion
@
text
@d53 3
a55 3
      myNodeSorter_        (),
      myOffsetProc_        (),
      myBelowLister_       (),
d58 3
a61 2
      effProdRate_         (),
      mandEC_              (),
a62 2
      expExecPeriod_       (),
      producingBopEntries_ (),
d64 2
a65 1
      expBopEntry_         ()
d156 95
@


1.119
log
@Stochastic Implosion
@
text
@d53 3
d86 1
a86 7
   WitTimer::enterSection ("preproc");

   myMsgFac ().abortIfErrors ();

   myMsgFac () ("preProcMsg");

   myPreData_ = new WitPreData (myProblem ());
d90 1
a90 1
   sortNodesIfNeeded ();
d92 1
a92 1
   roundOffsets ();
d126 1
a126 1
   buildBelow ();
d128 1
a128 5
   exportData ();

   preprocessed_ = true;

   WitTimer::leaveSection ("preproc");
d156 35
a253 18
void WitPreprocessor::sortNodesIfNeeded ()
   {
   WitNodeSorter theNodeSorter (myPreData_);

   theNodeSorter.sortNodesIfNeeded ();
   }

//------------------------------------------------------------------------------

void WitPreprocessor::roundOffsets ()
   {
   WitOffsetProc theOffsetProc (myPreData_);

   theOffsetProc.roundOffsets ();
   }

//------------------------------------------------------------------------------

a719 9
void WitPreprocessor::buildBelow ()
   {
   WitBelowLister theBelowLister (myPreData_);

   theBelowLister.buildBelow ();
   }

//------------------------------------------------------------------------------

@


1.118
log
@Stochastic Implosion
@
text
@d61 2
a62 1
      mySubEntries_        ()
@


1.117
log
@Stochastic Implosion
@
text
@d49 13
a61 5
      WitProbAssoc  (theProblem),

      myPreData_    (NULL),
      expPreData_   (NULL),
      preprocessed_ (false)
@


1.116
log
@Stochastic Implosion
@
text
@d113 1
a114 1
   sortBopEntries ();
d503 1
a503 1
      theSorter.sort (WitPreAccess::producingBopEntries (thePart));
d531 1
a531 1
      if (thePart->producingBopEntries ().isEmpty ())
d537 1
a537 1
         forEachEl (theBopEnt, thePart->producingBopEntries ())
d729 14
a742 13
      WitProbAssoc     (theProblem),
      allParts_        (),
      allOperations_   (),
      sortedPartIndex_ (myProblem (), -1),
      executable_      (myProblem (), false),
      impactPeriod_    (myProblem (), -1),
      mandEC_          (myProblem (), false),
      lotSizesExist_   (false),
      hasSubsInEffect_ (myProblem (), false),
      effConsRate_     (myProblem (), 0.0),
      effProdRate_     (myProblem (), 0.0),
      expExecPeriod_   (myProblem (), -1),
      mySubEntries_    (myProblem ())
d744 1
d747 7
d767 1
d771 3
d797 10
d816 7
@


1.115
log
@Stochastic Implosion
@
text
@d68 1
d97 7
a103 1
      preprocess (theBomEnt);
d106 4
a109 1
      preprocess (theBopEnt);
a325 14
void WitPreprocessor::preprocess (WitBomEntry * theBomEnt)
   {
   WitSubEntry * theSub;

   compEffConsRate (theBomEnt);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      compEffConsRate (theSub);

   checkMinLotSize (theBomEnt);
   }

//------------------------------------------------------------------------------

a392 8
void WitPreprocessor::preprocess (WitBopEntry * theBopEnt)
   {
   compEffProdRate      (theBopEnt);
   chooseExpExecPeriods (theBopEnt);
   }

//------------------------------------------------------------------------------

d518 1
a518 1
      theSorter.sort (WitPreAccess::mySubEntries (theBomEnt));
d740 2
a741 1
      expExecPeriod_   (myProblem (), -1)
d743 8
d757 4
d781 17
@


1.114
log
@Stochastic Implosion
@
text
@d426 1
a426 1
   WitPreAccess::expExecPeriod (theBopEnt) = -1;
d439 1
a439 1
         WitPreAccess::expExecPeriod (theBopEnt)[prodPer] = execPer;
d550 1
a550 1
            if (theBopEnt->expEligible (thePer))
d751 2
a752 1
      effProdRate_     (myProblem (), 0.0)
@


1.113
log
@Stochastic Implosion
@
text
@d335 4
a338 3
      myPreData_->effConsRate () (theConsEnt)[execPer] =
           theConsEnt->consRate ()[execPer] 
         / (1.0 - theConsEnt->falloutRate ());
d407 1
a407 2
   WitPeriod thePer;
   double    effRate;
d409 7
a415 10
   forEachPeriod (thePer, myProblem ())
      {
      effRate =
         myPreData_->inEffect (theBopEnt, thePer)?
              theBopEnt->productRate ()[thePer]
            * theBopEnt->myOperation ()->yieldRate ()[thePer]:
            0.0;

      WitPreAccess::effProdRate (theBopEnt).elemRef (thePer) = effRate;
      }
d423 1
d432 4
a435 1
      if (theBopEnt->execPerOKForExp (execPer))
d441 1
d448 2
d452 1
a452 2
   double        minAccEffProd;
   WitBopEntry * minAccBopEnt;
d464 4
a467 1
            if (theBopEnt->execPerOKForExp (execPer))
d469 1
a469 1
               if (theBopEnt->effProdRate ()[execPer] < minAccEffProd)
d471 1
a471 1
                  minAccEffProd = theBopEnt->effProdRate ()[execPer];
d477 1
a477 1
               if (theBopEnt->effProdRate ()[execPer] > maxRejEffProd)
d479 1
a479 1
                  maxRejEffProd = theBopEnt->effProdRate ()[execPer];
d483 1
d750 2
a751 1
      effConsRate_     (myProblem (), 0.0)
a778 1

@


1.112
log
@Stochastic Implosion
@
text
@d332 1
a332 2
   WitPeriod thePer;
   double    effRate;
d334 4
a337 12
   if (theConsEnt->consRate () == theConsEnt->consRate ()[0])
      WitPreAccess::effConsRate (theConsEnt) =
         (theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
   else
      forEachPeriod (thePer, myProblem ())
         {
         effRate = 
              theConsEnt->consRate ()[thePer] 
            / (1.0 - theConsEnt->falloutRate ());

         WitPreAccess::effConsRate (theConsEnt).elemRef (thePer) = effRate;
         }
d376 2
a377 1
         theOpn->minLotSize ()[execPer] * theBomEnt->effConsRate ()[execPer];
d742 2
a743 1
      hasSubsInEffect_ (myProblem (), false)
@


1.111
log
@Stochastic Implosion
@
text
@a294 1
   WitTVec <bool> hasSubsInEffectVal (myProblem (), false);
a302 2
      hasSubsInEffectVal = false;

d307 1
a307 1
               hasSubsInEffectVal[thePer] = true;
a310 2

      myPreData_->hasSubsInEffect () (theBomEnt) = hasSubsInEffectVal;
@


1.110
log
@Stochastic Implosion
@
text
@d299 1
a299 1
      WitPreAccess::hasSubsInEffect (theBomEnt) = false;
d315 1
a315 1
      WitPreAccess::hasSubsInEffect (theBomEnt) = hasSubsInEffectVal;
d754 2
a755 1
      lotSizesExist_   (false)
@


1.109
log
@Stochastic Implosion
@
text
@d263 1
a263 1
   WitPreAccess::lotSizesExist (myGlobalComp ()) = false;
d268 1
a268 1
            WitPreAccess::lotSizesExist (myGlobalComp ()) = true;
d365 1
a365 1
   if (not myGlobalComp ()->lotSizesExist ())
d753 3
a755 2
      mandEC_          (myProblem (), false)
   {
@


1.108
log
@Stochastic Implosion
@
text
@d584 1
a584 1
                     if (not theMat->mandEC ()[thePer - 1])
d684 1
a684 1
      if (theMat->mandEC ()[thePer])
d712 1
a712 1
            WitPreAccess::mandEC (theMat).elemRef (prodPer) = true;
d752 2
a753 1
      impactPeriod_    (myProblem (), -1)
d774 8
@


1.107
log
@Stochastic Implosion
@
text
@d49 1
a49 1
      WitProbAssoc     (theProblem),
d51 3
a53 4
      myPreData_       (NULL),
      expPreData_      (NULL),
      preprocessed_    (false),
      optPreprocessed_ (false)
a120 19
void WitPreprocessor::optPreprocess ()
   {
   if (optPreprocessed_)
      return;

   WitTimer::enterSection ("preproc");

   preprocess ();

   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsSmsg");

   optPreprocessed_ = true;

   WitTimer::leaveSection ("preproc");
   }

//------------------------------------------------------------------------------

d132 3
a134 1
   unoptPreprocess ();
a741 14

void WitPreprocessor::unoptPreprocess ()
   {
   if (not optPreprocessed_)
      return;

   optPreprocessed_ = false;

   myOptImploder ()->shutDown ();

   myOptComp ()->heurOptStarter ()->beChosen ();
   }

//------------------------------------------------------------------------------
@


1.106
log
@Stochastic Implosion
@
text
@d49 1
a49 1
      WitProbAssoc         (theProblem),
d51 4
a54 6
      myPreData_           (NULL),
      expPreData_          (NULL),
      preprocessed_        (false),
      optPreprocessed_     (false),
      execPeriodsComputed_ (false),
      tempExecPeriod_      (* new WitPtrTVec <WitVector <WitPeriod> >)
a61 1
   delete & tempExecPeriod_;
a133 2
   compExecPeriods ();

d154 1
a154 2
   preprocessed_        = false;
   execPeriodsComputed_ = false; 
a760 85
void WitPreprocessor::compExecPeriods ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;

   if (execPeriodsComputed_)
      return;

   tempNExecPeriods_.allocate (myProblem (), 0);
   tempExecPeriod_  .allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      tempExecPeriod_[thePer] = new WitVector <WitPeriod> (nPeriods (), 0);

   forEachBomEntry (theBomEnt, myProblem ())
      compExecPeriod (theBomEnt);

   forEachSubEntry (theSub, myProblem ())
      compExecPeriod (theSub);

   forEachBopEntry (theBopEnt, myProblem ())
      compExecPeriod (theBopEnt);

   forEachPeriod (thePer, myProblem ())
      delete tempExecPeriod_[thePer];

   tempNExecPeriods_.clear ();
   tempExecPeriod_  .clear ();

   execPeriodsComputed_ = true; 
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compExecPeriod (WitBillEntry * theBillEnt)
   {
   WitPeriod execPer;
   WitPeriod impactPer;
   int       localIdx;
   int       theEPIndex;
   int       totNExecPeriods;
      //
      // The length of theBillEnt->execPeriod_.

   totNExecPeriods = 0;

   tempNExecPeriods_ = 0;

   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      if (theBillEnt->inEffect (execPer))
         {
         impactPer = theBillEnt->impactPeriod ()[execPer];

         ++ totNExecPeriods;

         localIdx = tempNExecPeriods_[impactPer] ++;

         tempExecPeriod_ (impactPer)[localIdx] = execPer;
         }

   WitPreAccess::firstEPIndex (theBillEnt).resize (nPeriods () + 1, 0);
   WitPreAccess::execPeriod   (theBillEnt).resize (totNExecPeriods, 0);

   theEPIndex = 0;

   forEachPeriod (impactPer, myProblem ())
      {
      WitPreAccess::firstEPIndex (theBillEnt)[impactPer] = theEPIndex;

      for ( localIdx = 0; 
            localIdx < tempNExecPeriods_[impactPer]; 
            localIdx ++)
         {
         WitPreAccess::execPeriod (theBillEnt)[theEPIndex ++] = 
            tempExecPeriod_ (impactPer)[localIdx];
         }
      }

   WitPreAccess::firstEPIndex (theBillEnt)[nPeriods ()] = theEPIndex;
   }

//------------------------------------------------------------------------------

@


1.105
log
@Stochastic Implosion
@
text
@d13 4
a16 1
// Contains the implementation of class Preprocessor.
d20 1
d51 2
a57 3
   myNodeSorter_  = new WitNodeSorter  (myProblem ());
   myOffsetProc_  = new WitOffsetProc  (myProblem ());
   myBelowLister_ = new WitBelowLister (myProblem ());
a64 3
   delete   myBelowLister_;
   delete   myOffsetProc_;
   delete   myNodeSorter_;
d71 3
a76 3
   WitBomEntry * theBomEnt;
   WitBopEntry * theBopEnt;

d83 2
d87 1
a87 1
   myNodeSorter_->sortNodesIfNeeded ();
d89 1
a89 1
   myOffsetProc_->roundOffsets ();
d114 3
a116 1
   myBelowLister_->buildBelow ();
d231 18
d332 1
a332 1
            if (theSub->inEffect (thePer))
d400 1
a400 1
      if (not theBomEnt->inEffect (execPer))
d406 1
a406 1
      tCons = theBomEnt->impactPeriod ()[execPer];
d449 1
a449 1
         theBopEnt->inEffect (thePer)?
d473 1
a473 1
         prodPer = theBopEnt->impactPeriod ()[execPer];
d537 6
a542 2
   WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
   WitPart *                 thePart;
d552 6
a557 2
   WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
   WitBomEntry *             theBomEnt;
d698 1
a698 1
   WitPeriod     impactPer;
d707 2
a708 2
   for (impactPer = lastPeriod (); impactPer >= 0; -- impactPer)
      if (theMat->mandEC ()[impactPer])
d710 2
a711 2
            if (theConsEnt->inEffect (execPer))
               if (theConsEnt->impactPeriod ()[execPer] <= impactPer)
d732 1
a732 1
         if (theBopEnt->inEffect (thePer))
d734 1
a734 1
            prodPer = theBopEnt->impactPeriod ()[thePer];
d743 24
d863 33
@


1.104
log
@Stochastic Implosion
@
text
@d146 1
a146 1
   stronglyAssert (not myStochImpMgr ()->stochDataMode ());
@


1.103
log
@Stochastic Implosion
@
text
@d32 1
a32 1
#include <StochMgr.h>
d146 1
a146 1
   stronglyAssert (not myStochMgr ()->stochDataMode ());
@


1.102
log
@Stochastic Implosion
@
text
@d146 1
a146 1
   stronglyAssert (not myStochMgr ()->stochasticMode ());
@


1.101
log
@Stochastic implosion.
@
text
@d146 1
a146 1
   stronglyAssert (not myStochMgr ()->stochImpMode ());
@


1.100
log
@Stochastic Implosion.
@
text
@d146 1
a146 1
   stronglyAssert (not myStochMgr ()->active ());
@


1.99
log
@Stochastic implosion.
@
text
@d146 1
a146 1
   witAssert (not myStochMgr ()->active ());
@


1.98
log
@Stochastic implosion.
@
text
@d32 1
d146 2
@


1.97
log
@Stochastic implosion.
@
text
@a31 1
#include <StochMgr.h>
a144 2
   stronglyAssert (not myStochMgr ()->stochImpActive ());

@


1.96
log
@[disallowed backlog]
@
text
@d32 1
d146 2
@


1.95
log
@[disallowed backlog]
@
text
@d230 1
a230 1
      if (not theDemand->backlogAllowed ())
d233 1
a233 1
            myMsgFac () ("cumShipRewardDisBacklogSmsg",
d238 1
a238 1
            myMsgFac () ("cumShipSLBDisBacklogSmsg",
d244 1
a244 1
               myMsgFac () ("cumShipHUBDisBacklogSmsg",
d249 1
a249 1
            myMsgFac () ("obj2DisBacklogSmsg",
@


1.94
log
@[disallowed backlog]
@
text
@d30 1
d90 2
d224 33
@


1.93
log
@[disallowed backlog]
@
text
@d30 1
a40 20
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

bool                 WitGlobalComp::* WitPreprocessor::lotSizesExist_   = NULL;
WitList <WitBopEntry>      WitPart::* WitPreprocessor::producingBopEntries_ 
                                                                        = NULL;
bool                       WitPart::* WitPreprocessor::expPerGaps_      = NULL;
WitPtrTVec <WitBopEntry>   WitPart::* WitPreprocessor::expBopEntry_     = NULL;
WitFlexVec <bool>      WitMaterial::* WitPreprocessor::mandEC_          = NULL;
WitVector <int>       WitBillEntry::* WitPreprocessor::firstEPIndex_    = NULL;
WitVector <WitPeriod> WitBillEntry::* WitPreprocessor::execPeriod_      = NULL;
WitDblFlexVec         WitConsEntry::* WitPreprocessor::effConsRate_     = NULL;
WitFlexVec <bool>      WitBomEntry::* WitPreprocessor::hasSubsInEffect_ = NULL;
WitList <WitSubEntry>  WitBomEntry::* WitPreprocessor::mySubEntries_    = NULL;
WitTVec <WitPeriod>    WitBopEntry::* WitPreprocessor::expExecPeriod_   = NULL;
WitDblFlexVec          WitBopEntry::* WitPreprocessor::effProdRate_     = NULL;

//------------------------------------------------------------------------------

a157 78
void WitPreprocessor::receiveDMPs (bool WitGlobalComp::* lotSizesExistArg)
   {
   lotSizesExist_ = lotSizesExistArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      bool                     WitPart::* expPerGapsArg,
      WitList    <WitBopEntry> WitPart::* producingBopEntriesArg,
      WitPtrTVec <WitBopEntry> WitPart::* expBopEntryArg,
      int                      WitPart::* sortedPartIndexArg,
      WitPtrVec <WitPart>      WitPart::* belowListArg)
   {
   expPerGaps_          = expPerGapsArg;
   producingBopEntries_ = producingBopEntriesArg;
   expBopEntry_         = expBopEntryArg;

   WitNodeSorter ::receiveDMPs (sortedPartIndexArg);
   WitBelowLister::receiveDMPs (belowListArg);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (WitFlexVec <bool> WitMaterial::* mandECArg)
   {
   mandEC_ = mandECArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (WitTVec <bool> WitOperation::* executableArg)
   {
   WitOffsetProc::receiveDMPs (executableArg);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      WitVector  <int>       WitBillEntry::* firstEPIndexArg,
      WitVector  <WitPeriod> WitBillEntry::* execPeriodArg,
      WitTVec <WitPeriod>    WitBillEntry::* impactPeriodArg)
   {
   firstEPIndex_ = firstEPIndexArg;
   execPeriod_   = execPeriodArg;

   WitOffsetProc::receiveDMPs (impactPeriodArg);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (WitDblFlexVec WitConsEntry::* effConsRateArg)
   {
   effConsRate_ = effConsRateArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      WitFlexVec <bool>        WitBomEntry::* hasSubsInEffectArg,
      WitList    <WitSubEntry> WitBomEntry::* mySubEntriesArg)
   {
   hasSubsInEffect_ = hasSubsInEffectArg;
   mySubEntries_    = mySubEntriesArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      WitTVec <WitPeriod> WitBopEntry::* expExecPeriodArg,
      WitDblFlexVec       WitBopEntry::* effProdRateArg)
   {
   expExecPeriod_ = expExecPeriodArg;
   effProdRate_   = effProdRateArg;
   }

//------------------------------------------------------------------------------

d226 1
a226 1
   myGlobalComp ()->*lotSizesExist_ = false;
d231 1
a231 1
            myGlobalComp ()->*lotSizesExist_ = true;
d262 1
a262 1
      theBomEnt->*hasSubsInEffect_ = false;
d278 1
a278 1
      theBomEnt->*hasSubsInEffect_ = hasSubsInEffectVal;
d304 1
a304 1
      theConsEnt->*effConsRate_ =
d313 1
a313 1
         (theConsEnt->*effConsRate_).elemRef (thePer) = effRate;
d393 1
a393 1
      (theBopEnt->*effProdRate_).elemRef (thePer) = effRate;
d404 1
a404 1
   theBopEnt->*expExecPeriod_ = -1;
d414 1
a414 1
         (theBopEnt->*expExecPeriod_)[prodPer] = execPer;
d480 1
a480 1
      theSorter.sort (thePart->*producingBopEntries_);
d491 1
a491 1
      theSorter.sort (theBomEnt->*mySubEntries_);
d507 1
a507 1
      (thePart->*expBopEntry_).allocate (myProblem ());
d513 1
a513 1
               (thePart->*expBopEntry_)[thePer] = theBopEnt;
d530 1
a530 1
      thePart->*expPerGaps_ = false;
d541 1
a541 1
                        theMat->*expPerGaps_ = true;
d667 1
a667 1
            (theMat->*mandEC_).elemRef (prodPer) = true;
d736 2
a737 2
   (theBillEnt->*firstEPIndex_).resize (nPeriods () + 1, 0);
   (theBillEnt->*execPeriod_).resize (totNExecPeriods, 0);
d743 1
a743 1
      (theBillEnt->*firstEPIndex_)[impactPer] = theEPIndex;
d748 2
a749 2

         (theBillEnt->*execPeriod_)[theEPIndex ++] = 
d751 1
d754 1
a754 1
   (theBillEnt->*firstEPIndex_)[nPeriods ()] = theEPIndex;
@


1.92
log
@Rescinded all changed made since 1/31/07.
@
text
@a254 10
void WitPreprocessor::receiveDMPs (
      WitList <WitPart>      WitCompMgr::* allPartsArg,
      WitList <WitOperation> WitCompMgr::* allOperationsArg)
   {
   WitNodeSorter::receiveDMPs (allPartsArg,
                               allOperationsArg);
   }

//------------------------------------------------------------------------------

@


1.91
log
@[disallowed backlog]
@
text
@d44 16
d120 3
a122 3
   WitBomEntry::sortSubEntries (myProblem ());
   WitPart    ::sortBopEntries (myProblem ());
            
a159 6
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
d173 27
d201 4
a204 1
   myGlobalComp ()->lotSizesExist_ () = false;
d206 1
a206 3
   forEachPart (thePart, myProblem ())
      {
      thePart->expBopEntry_ ().clear ();
d208 4
a211 2
      thePart->belowList_ ().resize (0);
      }
d213 1
a213 2
   forEachMaterial (theMat, myProblem ())
      theMat->mandEC_ () = false;
d215 7
a221 2
   forEachOperation (theOpn, myProblem ())
      theOpn->executable_ () = false;
d223 2
a224 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      unpreprocess (theBomEnt);
d226 1
a226 3
      theBomEnt->effConsRate_     () = 0.0;
      theBomEnt->hasSubsInEffect_ () = false;
      }
d228 4
a231 3
   forEachSubEntry (theSub, myProblem ())
      {
      unpreprocess (theSub);
d233 1
a233 2
      theSub->effConsRate_ () = 0.0;
      }
d235 7
a241 3
   forEachBopEntry (theBopEnt, myProblem ())
      {
      unpreprocess (theBopEnt);
d243 1
a243 1
      theBopEnt->expExecPeriod_ ().clear ();
d245 6
a250 2
      theBopEnt->effProdRate_ () =  0.0;
      }
d333 1
a333 1
   myGlobalComp ()->lotSizesExist_ () = false;
d338 1
a338 1
            myGlobalComp ()->lotSizesExist_ () = true;
d369 1
a369 1
      theBomEnt->hasSubsInEffect_ () = false;
d385 1
a385 1
      theBomEnt->hasSubsInEffect_ () = hasSubsInEffectVal;
d411 2
a412 5
      {
      theConsEnt->effConsRate_ () =
            theConsEnt->consRate ()[0]
         / (1.0 - theConsEnt->falloutRate ());
      }
d420 1
a420 1
         theConsEnt->effConsRate_ ().elemRef (thePer) = effRate;
d500 1
a500 1
      theBopEnt->effProdRate_ ().elemRef (thePer) = effRate;
d511 1
a511 1
   theBopEnt->expExecPeriod_ ().allocate (myProblem (), -1);
d521 1
a521 1
         theBopEnt->expExecPeriod_ ()[prodPer] = execPer;
d581 22
d614 1
a614 1
      thePart->expBopEntry_ ().allocate (myProblem ());
d620 1
a620 1
               thePart->expBopEntry_ ()[thePer] = theBopEnt;
d637 1
a637 1
      thePart->expPerGaps_ () = false;
d648 1
a648 1
                        theMat->expPerGaps_ () = true;
d774 1
a774 1
            theMat->mandEC_ ().elemRef (prodPer) = true;
d827 2
a828 1
   totNExecPeriods   = 0;
d843 2
a844 2
   theBillEnt->firstEPIndex_ ().resize (nPeriods () + 1, 0);
   theBillEnt->execPeriod_   ().resize (totNExecPeriods, 0);
d850 1
a850 1
      theBillEnt->firstEPIndex_ ()[impactPer] = theEPIndex;
d855 2
a856 2
         {
         theBillEnt->execPeriod_ ()[theEPIndex ++] = 
a857 1
         }
d860 1
a860 1
   theBillEnt->firstEPIndex_ ()[nPeriods ()] = theEPIndex;
a875 9

//------------------------------------------------------------------------------

void WitPreprocessor::unpreprocess (WitBillEntry * theBillEnt)
   {
   theBillEnt->impactPeriod_ ().clear ();
   theBillEnt->firstEPIndex_ ().clear ();
   theBillEnt->execPeriod_   ().clear ();
   }
@


1.90
log
@[disallowed backlog]
@
text
@a43 4
bool WitGlobalComp::* WitPreprocessor::lotSizesExist_ = NULL;

//------------------------------------------------------------------------------

d164 2
a205 7
void WitPreprocessor::receiveDMPs (bool WitGlobalComp::* lotSizesExistArg)
   {
   lotSizesExist_ = lotSizesExistArg;
   }

//------------------------------------------------------------------------------

d284 1
a284 1
   myGlobalComp ()->*lotSizesExist_ = false;
d289 1
a289 1
            myGlobalComp ()->*lotSizesExist_ = true;
@


1.89
log
@[disallowed backlog]
@
text
@d44 1
a44 5
bool                 WitGlobalComp::* WitPreprocessor::lotSizesExist_   = NULL;
WitFlexVec <bool>      WitBomEntry::* WitPreprocessor::hasSubsInEffect_ = NULL;
WitList <WitSubEntry>  WitBomEntry::* WitPreprocessor::mySubEntries_    = NULL;
WitTVec <WitPeriod>    WitBopEntry::* WitPreprocessor::expExecPeriod_   = NULL;
WitDblFlexVec          WitBopEntry::* WitPreprocessor::effProdRate_     = NULL;
d108 2
a109 3
   sortSubEntries ();

   WitPart::sortBopEntries (myProblem ());
d170 1
a170 1
      thePart->expBopEntry_->clear ();
d172 1
a172 1
      thePart->belowList_->resize (0);
d176 1
a176 1
      theMat->mandEC_.forUpdate () = false;
d179 1
a179 1
      theOpn->executable_.forUpdate () = false;
d185 2
a186 1
      theBomEnt->effConsRate_.forUpdate () = 0.0;
d193 1
a193 1
      theSub->effConsRate_.forUpdate () = 0.0;
d197 1
d199 5
a215 20
      WitFlexVec <bool>        WitBomEntry::* hasSubsInEffectArg,
      WitList    <WitSubEntry> WitBomEntry::* mySubEntriesArg)
   {
   hasSubsInEffect_ = hasSubsInEffectArg;
   mySubEntries_    = mySubEntriesArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      WitTVec <WitPeriod> WitBopEntry::* expExecPeriodArg,
      WitDblFlexVec       WitBopEntry::* effProdRateArg)
   {
   expExecPeriod_ = expExecPeriodArg;
   effProdRate_   = effProdRateArg;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
d329 1
a329 1
      theBomEnt->*hasSubsInEffect_ = false;
d345 1
a345 1
      theBomEnt->*hasSubsInEffect_ = hasSubsInEffectVal;
d372 3
a374 2
      theConsEnt->effConsRate_.forUpdate () =
         (theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d383 1
a383 1
         theConsEnt->effConsRate_->elemRef (thePer) = effRate;
d463 1
a463 1
      (theBopEnt->*effProdRate_).elemRef (thePer) = effRate;
d474 1
a474 1
   theBopEnt->*expExecPeriod_ = -1;
d484 1
a484 1
         (theBopEnt->*expExecPeriod_)[prodPer] = execPer;
a543 11
void WitPreprocessor::sortSubEntries ()
   {
   WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
   WitBomEntry *             theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      theSorter.sort (theBomEnt->*mySubEntries_);
   }

//------------------------------------------------------------------------------

d555 1
a555 1
      thePart->expBopEntry_->allocate (myProblem ());
d561 1
a561 1
               thePart->expBopEntry_.forUpdate ()[thePer] = theBopEnt;
d578 1
a578 1
      thePart->expPerGaps_.forUpdate () = false;
d589 1
a589 1
                        theMat->expPerGaps_.forUpdate () = true;
d715 1
a715 1
            theMat->mandEC_->elemRef (prodPer) = true;
d783 2
a784 2
   theBillEnt->firstEPIndex_->resize (nPeriods () + 1, 0);
   theBillEnt->execPeriod_  ->resize (totNExecPeriods, 0);
d790 1
a790 1
      theBillEnt->firstEPIndex_.forUpdate ()[impactPer] = theEPIndex;
d796 1
a796 1
         theBillEnt->execPeriod_.forUpdate ()[theEPIndex ++] = 
d801 1
a801 1
   theBillEnt->firstEPIndex_.forUpdate ()[nPeriods ()] = theEPIndex;
d822 3
a824 3
   theBillEnt->impactPeriod_->clear ();
   theBillEnt->firstEPIndex_->clear ();
   theBillEnt->execPeriod_  ->clear ();
@


1.88
log
@[disallowed backlog]
@
text
@a44 4
WitFlexVec <bool>      WitMaterial::* WitPreprocessor::mandEC_          = NULL;
WitVector <int>       WitBillEntry::* WitPreprocessor::firstEPIndex_    = NULL;
WitVector <WitPeriod> WitBillEntry::* WitPreprocessor::execPeriod_      = NULL;
WitDblFlexVec         WitConsEntry::* WitPreprocessor::effConsRate_     = NULL;
d154 5
d175 1
a175 1
      thePart->expBopEntry_.forUpdate ().clear ();
d177 1
a177 1
      thePart->belowList_.forUpdate ().resize (0);
a178 1
   }
d180 2
a181 1
//------------------------------------------------------------------------------
d183 2
a184 4
void WitPreprocessor::receiveDMPs (bool WitGlobalComp::* lotSizesExistArg)
   {
   lotSizesExist_ = lotSizesExistArg;
   }
d186 3
a188 1
//------------------------------------------------------------------------------
d190 2
a191 4
void WitPreprocessor::receiveDMPs (WitFlexVec <bool> WitMaterial::* mandECArg)
   {
   mandEC_ = mandECArg;
   }
d193 3
a195 1
//------------------------------------------------------------------------------
d197 2
a198 4
void WitPreprocessor::receiveDMPs (WitTVec <bool> WitOperation::* executableArg)
   {
   WitOffsetProc::receiveDMPs (executableArg);
   }
d200 2
a201 11
//------------------------------------------------------------------------------

void WitPreprocessor::receiveDMPs (
      WitVector  <int>       WitBillEntry::* firstEPIndexArg,
      WitVector  <WitPeriod> WitBillEntry::* execPeriodArg,
      WitTVec <WitPeriod>    WitBillEntry::* impactPeriodArg)
   {
   firstEPIndex_ = firstEPIndexArg;
   execPeriod_   = execPeriodArg;

   WitOffsetProc::receiveDMPs (impactPeriodArg);
d206 1
a206 1
void WitPreprocessor::receiveDMPs (WitDblFlexVec WitConsEntry::* effConsRateArg)
d208 1
a208 1
   effConsRate_ = effConsRateArg;
d389 2
a390 1
      theConsEnt->*effConsRate_ =
d392 1
d400 1
a400 1
         (theConsEnt->*effConsRate_).elemRef (thePer) = effRate;
d583 1
a583 1
      thePart->expBopEntry_.forUpdate ().allocate (myProblem ());
d743 1
a743 1
            (theMat->*mandEC_).elemRef (prodPer) = true;
d796 1
a796 2
   totNExecPeriods = 0;

d811 2
a812 2
   (theBillEnt->*firstEPIndex_).resize (nPeriods () + 1, 0);
   (theBillEnt->*execPeriod_).resize (totNExecPeriods, 0);
d818 1
a818 1
      (theBillEnt->*firstEPIndex_)[impactPer] = theEPIndex;
d823 2
a824 2

         (theBillEnt->*execPeriod_)[theEPIndex ++] = 
d826 1
d829 1
a829 1
   (theBillEnt->*firstEPIndex_)[nPeriods ()] = theEPIndex;
d845 9
@


1.87
log
@[disallowed backlog]
@
text
@a44 2
WitList <WitBopEntry>      WitPart::* WitPreprocessor::producingBopEntries_ 
                                                                        = NULL;
a116 1
   sortBopEntries ();
d118 2
a188 12
void WitPreprocessor::receiveDMPs (
      bool                     WitPart::*,
      WitList    <WitBopEntry> WitPart::* producingBopEntriesArg,
      WitPtrTVec <WitBopEntry> WitPart::*,
      int                      WitPart::*,
      WitPtrVec <WitPart>      WitPart::*)
   {
   producingBopEntries_ = producingBopEntriesArg;
   }

//------------------------------------------------------------------------------

a568 11
void WitPreprocessor::sortBopEntries ()
   {
   WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
   WitPart *                 thePart;

   forEachPart (thePart, myProblem ())
      theSorter.sort (thePart->*producingBopEntries_);
   }

//------------------------------------------------------------------------------

@


1.86
log
@[disallowed backlog]
@
text
@a46 2
bool                       WitPart::* WitPreprocessor::expPerGaps_      = NULL;
WitPtrTVec <WitBopEntry>   WitPart::* WitPreprocessor::expBopEntry_     = NULL;
d158 1
d172 7
d191 1
a191 1
      bool                     WitPart::* expPerGapsArg,
d193 1
a193 1
      WitPtrTVec <WitBopEntry> WitPart::* expBopEntryArg,
d195 1
a195 1
      WitPtrVec <WitPart>      WitPart::* belowListArg)
a196 1
   expPerGaps_          = expPerGapsArg;
a197 3
   expBopEntry_         = expBopEntryArg;

   WitBelowLister::receiveDMPs (belowListArg);
d615 1
a615 1
      (thePart->*expBopEntry_).allocate (myProblem ());
d621 1
a621 1
               (thePart->*expBopEntry_)[thePer] = theBopEnt;
d638 1
a638 1
      thePart->*expPerGaps_ = false;
d649 1
a649 1
                        theMat->*expPerGaps_ = true;
@


1.85
log
@witCopy<Object>Data
@
text
@d188 1
a188 1
      int                      WitPart::* sortedPartIndexArg,
a194 1
   WitNodeSorter ::receiveDMPs (sortedPartIndexArg);
@


1.84
log
@App controlled opt implosion.
@
text
@d441 1
a441 1
   if (not thePart->isaCapacity ())
@


1.83
log
@App controlled opt implosion.
@
text
@d159 2
d164 1
a164 3
   WitComponent * theComp;

   myPostprocessor ()->unpostprocess ();
@


1.82
log
@Updated the copyright date on all source files.
@
text
@d17 1
d88 1
a88 1
   if (preprocessed ())
d138 1
a138 1
   if (optPreprocessed ())
d159 1
a159 1
   if (not preprocessed ())
d164 1
a164 1
   myProblem ()->unpostprocess ();
d867 1
a867 1
   if (not optPreprocessed ())
@


1.81
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.80
log
@[multi-thread]
@
text
@d188 1
a188 1
      WitDenseList <WitPart>   WitPart::* belowListArg)
@


1.79
log
@Revised mappingIndex code.
@
text
@d39 20
a98 2
   loadData ();

a127 2
   clearLoadedData ();

a139 2
   WitComponent * theComp;

a143 6
   firstEPIndex_.allocate (myProblem ());
   execPeriod_  .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadOptPre ();

a148 3
   firstEPIndex_.clear ();
   execPeriod_  .clear ();

d176 1
a176 21
void WitPreprocessor::loadDataFrom (
      WitPart *                  thePart,
      int                      & sortedPartIndexArg,
      bool                     & expPerGapsArg,
      WitList    <WitBopEntry> & producingBopEntriesArg,
      WitPtrTVec <WitBopEntry> & expBopEntryArg,
      WitDenseList <WitPart>   & belowListArg)
   {
   expPerGaps_         .setMapFor (thePart, expPerGapsArg);
   producingBopEntries_.setMapFor (thePart, producingBopEntriesArg);
   expBopEntry_        .setMapFor (thePart, expBopEntryArg);

   myNodeSorter_ ->loadDataFrom (thePart, sortedPartIndexArg);
   myBelowLister_->loadDataFrom (thePart, belowListArg);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::loadDataFrom (
      WitMaterial *        theMat,
      WitFlexVec <bool>  & mandECArg)
d178 1
a178 1
   mandEC_.setMapFor (theMat, mandECArg);
d183 6
a188 3
void WitPreprocessor::loadDataFrom (
      WitOperation *             theOpn,
      WitTVec <bool>           & executableArg)
d190 3
a192 2
   myOffsetProc_->loadDataFrom (theOpn, executableArg);
   }
d194 2
a195 7
//------------------------------------------------------------------------------

void WitPreprocessor::loadDataFrom (
      WitBillEntry *             theBillEnt,
      WitTVec    <WitPeriod>   & impactPeriodArg)
   {
   myOffsetProc_->loadDataFrom (theBillEnt, impactPeriodArg);
d200 1
a200 3
void WitPreprocessor::loadDataFrom (
      WitConsEntry *  theConsEnt,
      WitDblFlexVec & effConsRateArg)
d202 1
a202 1
   effConsRate_.setMapFor (theConsEnt, effConsRateArg);
d207 1
a207 4
void WitPreprocessor::loadDataFrom (
      WitBomEntry *              theBomEnt,
      WitFlexVec <bool>        & hasSubsInEffectArg,
      WitList    <WitSubEntry> & mySubEntriesArg)
d209 1
a209 2
   hasSubsInEffect_.setMapFor (theBomEnt, hasSubsInEffectArg);
   mySubEntries_   .setMapFor (theBomEnt, mySubEntriesArg);
d214 4
a217 4
void WitPreprocessor::loadDataFrom (
      WitBopEntry *         theBopEnt,
      WitTVec <WitPeriod> & expExecPeriodArg,
      WitDblFlexVec &       effProdRateArg)
d219 2
a220 3
   expExecPeriod_.setMapFor (theBopEnt, expExecPeriodArg);
   effProdRate_  .setMapFor (theBopEnt, effProdRateArg);
   }
d222 1
a222 7
//------------------------------------------------------------------------------

void WitPreprocessor::loadDataFromCompMgr (
      WitList    <WitPart>      & allPartsArg,
      WitList    <WitOperation> & allOperationsArg)
   {
   myNodeSorter_ ->loadDataFromCompMgr (allPartsArg, allOperationsArg);
d227 1
a227 2
void WitPreprocessor::loadDataFromGlobalComp (
      bool                      & lotSizesExistArg)
d229 1
a229 1
   lotSizesExist_.attachTo (lotSizesExistArg);
d234 3
a236 4
void WitPreprocessor::loadOptPreDataFrom (
      WitBillEntry *              theBillEnt, 
      WitVector  <int>          & firstEPIndexArg,
      WitVector  <WitPeriod>    & execPeriodArg)
d238 2
a239 2
   firstEPIndex_.setMapFor (theBillEnt, firstEPIndexArg);
   execPeriod_  .setMapFor (theBillEnt, execPeriodArg);
d244 3
a246 1
void WitPreprocessor::loadData ()
d248 2
a249 20
   WitComponent * theComp;

   expPerGaps_         .allocate (myProblem ());
   producingBopEntries_.allocate (myProblem ());
   expBopEntry_        .allocate (myProblem ());
   mandEC_             .allocate (myProblem ());
   effConsRate_        .allocate (myProblem ());
   hasSubsInEffect_    .allocate (myProblem ());
   mySubEntries_       .allocate (myProblem ());
   expExecPeriod_      .allocate (myProblem ());
   effProdRate_        .allocate (myProblem ());

   myNodeSorter_ ->allocLoadedData ();
   myOffsetProc_ ->allocLoadedData ();
   myBelowLister_->allocLoadedData ();

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadPre ();

   myCompMgr ()->loadPre ();
d254 3
a256 1
void WitPreprocessor::clearLoadedData ()
d258 2
a259 14
   expPerGaps_         .clear ();
   producingBopEntries_.clear ();
   expBopEntry_        .clear ();
   mandEC_             .clear ();
   effConsRate_        .clear ();
   hasSubsInEffect_    .clear ();
   mySubEntries_       .clear ();
   expExecPeriod_      .clear ();
   effProdRate_        .clear ();
   lotSizesExist_      .clear ();

   myNodeSorter_ ->clearLoadedData ();
   myOffsetProc_ ->clearLoadedData ();
   myBelowLister_->clearLoadedData ();
d332 1
a332 1
   lotSizesExist_ () = false;
d337 1
a337 1
            lotSizesExist_ () = true;
d368 1
a368 1
      hasSubsInEffect_ (theBomEnt) = false;
d384 1
a384 1
      hasSubsInEffect_ (theBomEnt) = hasSubsInEffectVal;
d410 1
a410 1
      effConsRate_ (theConsEnt) =
d419 1
a419 1
         effConsRate_ (theConsEnt).elemRef (thePer) = effRate;
d499 1
a499 1
      effProdRate_ (theBopEnt).elemRef (thePer) = effRate;
d510 1
a510 1
   expExecPeriod_ (theBopEnt) = -1;
d520 1
a520 1
         expExecPeriod_ (theBopEnt)[prodPer] = execPer;
d586 1
a586 1
      theSorter.sort (producingBopEntries_ (thePart));
d597 1
a597 1
      theSorter.sort (mySubEntries_ (theBomEnt));
d613 1
a613 1
      expBopEntry_ (thePart).allocate (myProblem ());
d619 1
a619 1
               expBopEntry_ (thePart)[thePer] = theBopEnt;
d636 1
a636 1
      expPerGaps_ (thePart) = false;
d647 1
a647 1
                        expPerGaps_ (theMat) = true;
d773 1
a773 1
            mandEC_ (theMat).elemRef (prodPer) = true;
d824 1
a824 1
      // The length of execPeriod_ (theBillEnt).
d842 2
a843 2
   firstEPIndex_ (theBillEnt).resize (nPeriods () + 1, 0);
   execPeriod_   (theBillEnt).resize (totNExecPeriods, 0);
d849 1
a849 1
      firstEPIndex_ (theBillEnt)[impactPer] = theEPIndex;
d855 1
a855 1
         execPeriod_ (theBillEnt)[theEPIndex ++] = 
d859 1
a859 1
   firstEPIndex_ (theBillEnt)[nPeriods ()] = theEPIndex;
@


1.78
log
@pegged Critical List.
@
text
@a33 1
#include <MapIdxI.h>
@


1.77
log
@Low-Pri Prop-Rt.
@
text
@d260 1
a260 1
   lotSizesExist_.refTo (lotSizesExistArg);
@


1.76
log
@Fixed a bug in the sorting of BOP entries that produce each part.
@
text
@a39 4
WitMapping <WitBopEntry, int> * WitPreprocessor::nProdEntsBeforePtr_ = NULL;

//------------------------------------------------------------------------------

a171 9
int WitPreprocessor::nProdEntsBefore (WitBopEntry * theBopEnt)
   {
   witAssert (nProdEntsBeforePtr_ != NULL);

   return (* nProdEntsBeforePtr_) (theBopEnt);
   }

//------------------------------------------------------------------------------

a641 4
   WitBopEntry *             theBopEnt;
   int                       nBefore;

   nProdEntsBeforePtr_ = new WitMapping <WitBopEntry, int> (myProblem (), -1);
a643 10
      {
      nBefore = 0;

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         {
         (* nProdEntsBeforePtr_) (theBopEnt) = nBefore;

         nBefore ++;
         }

a644 5
      }

   delete nProdEntsBeforePtr_;

   nProdEntsBeforePtr_ = NULL;
@


1.75
log
@Fixed a bug in the screening of the optimization model.
@
text
@d40 4
d176 9
d653 1
d655 4
a658 1
   WitAvSorter <WitBopEntry> theSorter (myCompMgr ()->nBopEntries ());
d661 10
d672 5
d683 1
a684 1
   WitAvSorter <WitSubEntry> theSorter (myCompMgr ()->nSubEntries ());
@


1.74
log
@Double Precision.
@
text
@a110 2
   setIsCoproduced ();

a174 1
      WitFlexVec <bool>        & isCoproducedArg,
a179 1
   isCoproduced_       .setMapFor (thePart, isCoproducedArg);
a279 1
   isCoproduced_       .allocate (myProblem ());
a303 1
   isCoproduced_       .clear ();
a833 48
   }

//------------------------------------------------------------------------------

void WitPreprocessor::setIsCoproduced ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      execPer;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;

   forEachPart (thePart, myProblem ())
      isCoproduced_ (thePart) = false;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theOpn->isCoproducing (execPer))
            {
            forEachEl (theBopEnt, theOpn->bop ())
               if (theBopEnt->productRate ()[execPer] > 0.0)
                  setCoprod (theBopEnt, execPer);

            forEachEl (theBomEnt, theOpn->bom ())
               {
               if (theBomEnt->consRate ()[execPer] < 0.0)
                  setCoprod (theBomEnt, execPer);

               forEachEl (theSub, theBomEnt->mySubEntries ())
                  if (theSub->consRate ()[execPer] < 0.0)
                     setCoprod (theSub, execPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitPreprocessor::setCoprod (WitBillEntry * theEnt, WitPeriod execPer)
   {
   WitPeriod impactPer;

   if (not theEnt->inEffect (execPer))
      return;

   impactPer = theEnt->impactPeriod ()[execPer];

   isCoproduced_ (theEnt->myPart ()).elemRef (impactPer) = true;
@


1.73
log
@Double Precision.
@
text
@d432 1
a432 1
      hasSubsInEffect_ (theBomEnt).setToScalar (false);
d437 1
a437 1
      hasSubsInEffectVal.setToScalar (false);
d448 1
a448 1
      hasSubsInEffect_ (theBomEnt).convCopy (hasSubsInEffectVal);
d474 2
a475 2
      effConsRate_ (theConsEnt).setToScalar (
         theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d574 1
a574 1
   expExecPeriod_ (theBopEnt).setToScalar (-1);
d854 1
a854 1
      isCoproduced_ (thePart).setToScalar (false);
d940 1
a940 1
   tempNExecPeriods_.setToScalar (0);
@


1.72
log
@Double Precision.
@
text
@d384 2
a385 3
      maxNameLength = theName.length ();

      theLongestName.copy (theName);
@


1.71
log
@Double Precision.
@
text
@d222 2
a223 2
      WitConsEntry *        theConsEnt,
      WitFlexVec <double> & effConsRateArg)
d244 1
a244 1
      WitFlexVec <double> & effProdRateArg)
@


1.70
log
@Double Precision.
@
text
@d222 2
a223 2
      WitConsEntry * theConsEnt,
      WitRealVec &   effConsRateArg)
d244 1
a244 1
      WitRealVec &          effProdRateArg)
d484 1
a484 1
         effConsRate_ (theConsEnt).setElem (thePer, effRate);
d564 1
a564 1
      effProdRate_ (theBopEnt).setElem (thePer, effRate);
@


1.69
log
@Double Precision.
@
text
@d244 1
a244 1
      WitRealTVc &          effProdRateArg)
@


1.68
log
@Double Precision.
@
text
@d244 1
a244 1
      WitRealVec &          effProdRateArg)
@


1.67
log
@Double Precision.
@
text
@d496 2
a497 2
   float          avail;   // Availability.
   float          minCons; // Consumption for minLotSize.
@


1.66
log
@Double Precision.
@
text
@d222 2
a223 2
      WitConsEntry *             theConsEnt,
      WitFlexVec <float>       & effConsRateArg)
d242 3
a244 3
      WitBopEntry *              theBopEnt,
      WitTVec    <WitPeriod>   & expExecPeriodArg,
      WitTVec    <float>       & effProdRateArg)
d472 1
d479 2
a480 1
         effConsRate_ (theConsEnt).elemRef (thePer) =
d483 3
d554 1
d557 2
a558 1
      effProdRate_ (theBopEnt)[thePer] =
d563 3
@


1.65
log
@Continued double precision.
@
text
@d449 1
a449 1
      hasSubsInEffect_ (theBomEnt).copyTVec (hasSubsInEffectVal);
@


1.64
log
@Continued implementation of PIP.
@
text
@d585 1
a585 1
   float         minAccEffProd;
d588 1
a588 1
   float         maxRejEffProd;
d623 1
a623 1
   if (minAccEffProd < WitGlobalComp::defExpCutoff ())
@


1.63
log
@An attempt to fix more syntax errors from on Windows.
@
text
@a30 1
#include <PipInt.h>
a114 3
   if (myGlobalComp ()->pip ())
      myProblem ()->myPipInt ()->preprocess ();

a161 3

   if (myGlobalComp ()->pip ())
      myProblem ()->myPipInt ()->unpreprocess ();
@


1.62
log
@Continued implementation of PIP.
@
text
@d20 1
a37 39
// Namespace SortEntryUtil
//
// Functions and templates used by class Preprocessor for sorting BillEntries.
//
// In the following template functions, the SortEntry template argument is to be
// either SubEntry or BopEntry.
//------------------------------------------------------------------------------

namespace WitSortEntryUtil
{

template <typename SortEntry> 
      bool orderedByAversion (const WitList <SortEntry> & theList);
   //
   // Returns true, iff the elements of theList are ordered consistently with
   // the aversion function.

template <typename SortEntry> 
      void sortByAversion (
         WitList      <SortEntry> & theList,
         WitDenseList <SortEntry> & theDenseList);
   //
   // Sorts the elements of theList according to the aversion function.
   // Uses theDenseList as a temporary work area for the sort.

template <typename SortEntry> 
      int compareAversion (SortEntry *, SortEntry *);
   //
   // Sort compare function based on aversion.

float aversion (WitSubEntry *);
float aversion (WitBopEntry *);
   //
   // Returns expNetAversion or expAversion, respectively.

// Leaving namespace SortEntryUtil
};

//------------------------------------------------------------------------------
d644 2
a645 6
   using namespace WitSortEntryUtil;

   WitPart *                  thePart;
   WitDenseList <WitBopEntry> sortedBopEntries;

   sortedBopEntries.resize (myCompMgr ()->nBopEntries ());
d648 1
a648 2
      if (not orderedByAversion (thePart->producingBopEntries ()))
         sortByAversion (producingBopEntries_ (thePart), sortedBopEntries);
d655 2
a656 7
   using namespace WitSortEntryUtil;

   WitBomEntry * theBomEnt;

   WitDenseList <WitSubEntry> sortedSubEntries;

   sortedSubEntries.resize (myCompMgr ()->nSubEntries ());
d659 1
a659 2
      if (not orderedByAversion (theBomEnt->mySubEntries ()))
         sortByAversion (mySubEntries_ (theBomEnt), sortedSubEntries);
a983 68
   }

//------------------------------------------------------------------------------
// Implementation of SortEntryUtil functions and templates.
//------------------------------------------------------------------------------

template <typename SortEntry> 
      bool WitSortEntryUtil::orderedByAversion (
         const WitList <SortEntry> & theList)
   {
   SortEntry * theEntry;
   SortEntry * prevEntry;

   prevEntry = NULL;

   forEachEl (theEntry, theList)
      {
      if (prevEntry != NULL)
         if (aversion (theEntry) < aversion (prevEntry))
            return false;

      prevEntry = theEntry;
      }

   return true;
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      void WitSortEntryUtil::sortByAversion (
         WitList      <SortEntry> & theList,
         WitDenseList <SortEntry> & theDenseList)
   {
   SortEntry * theEntry;

   copyIntoDense (theDenseList, theList);

   theDenseList.sort (compareAversion);

   theList.clear ();

   forEachElDense (theEntry, theDenseList)
      theList.append (theEntry);
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      int WitSortEntryUtil::compareAversion (
         SortEntry * theSortEntry1,
         SortEntry * theSortEntry2)
   {
   return sign (aversion (theSortEntry1) - aversion (theSortEntry2));
   }

//------------------------------------------------------------------------------

float WitSortEntryUtil::aversion (WitSubEntry * theSub)
   {
   return theSub->expNetAversion ();
   }

//------------------------------------------------------------------------------

float WitSortEntryUtil::aversion (WitBopEntry * theBopEnt)
   {
   return theBopEnt->expAversion ();
@


1.61
log
@Continued implementation of PIP.
@
text
@d46 1
a46 6
   {
   template <typename SortEntry> 
         bool orderedByAversion (const WitList <SortEntry> & theList);
      //
      // Returns true, iff the elements of theList are ordered consistently with
      // the aversion function.
d48 5
a52 7
   template <typename SortEntry> 
         void sortByAversion (
            WitList      <SortEntry> & theList,
            WitDenseList <SortEntry> & theDenseList);
      //
      // Sorts the elements of theList according to the aversion function.
      // Uses theDenseList as a temporary work area for the sort.
d54 7
a60 4
   template <typename SortEntry> 
         int compareAversion (SortEntry *, SortEntry *);
      //
      // Sort compare function based on aversion.
d62 12
a73 5
   float aversion (WitSubEntry *);
   float aversion (WitBopEntry *);
      //
      // Returns expNetAversion or expAversion, respectively.
   };
@


1.60
log
@Continued implementation of PIP.
@
text
@d1066 1
a1066 1
   copyIntoD (theDenseList, theList);
@


1.59
log
@Continued implementation of PIP.
@
text
@d1066 1
a1066 1
   copyInto (theDenseList, theList);
@


1.58
log
@Continued implementation of PIP.
@
text
@d37 3
a39 1
// Declaration of global functions and templates used by class Preprocessor.
d45 15
a59 5
template <typename SortEntry> 
      bool orderedByAversion (const WitList <SortEntry> & theList);
   //
   // Returns true, iff the elements of theList are ordered consistently with
   // the aversion function.
d61 4
a64 7
template <typename SortEntry> 
      void sortByAversion (
         WitList      <SortEntry> & theList,
         WitDenseList <SortEntry> & theDenseList);
   //
   // Sorts the elements of theList according to the aversion function.
   // Uses theDenseList as a temporary work area for the sort.
d66 5
a70 9
template <typename SortEntry> 
      int compareAversion (SortEntry *, SortEntry *);
   //
   // Sort compare function based on aversion.

float aversion (WitSubEntry *);
float aversion (WitBopEntry *);
   //
   // Returns expNetAversion or expAversion, respectively.
d679 1
a679 1
   WitPart * thePart;
d681 1
d695 2
d1033 1
a1033 1
// Implementation of global functions and templates used by class Preprocessor.
d1037 2
a1038 1
      bool orderedByAversion (const WitList <SortEntry> & theList)
d1060 1
a1060 1
      void sortByAversion (
d1079 1
a1079 1
      int compareAversion (
d1088 1
a1088 1
float aversion (WitSubEntry * theSub)
d1095 1
a1095 1
float aversion (WitBopEntry * theBopEnt)
@


1.57
log
@Continued implementation of PIP.
@
text
@d49 1
a49 1
template <class SortEntry> 
d57 1
a57 1
template <class SortEntry> 
d1028 1
a1028 1
template <class SortEntry> 
d1050 1
a1050 1
template <class SortEntry> 
d1069 1
a1069 1
template <class SortEntry> 
@


1.56
log
@Removed a bad function overload.
@
text
@d1074 1
a1074 1
   return WitUtil::sign (aversion (theSortEntry1) - aversion (theSortEntry2));
@


1.55
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d738 1
a738 1
      theMat = thePart->myMat ();
d837 1
a837 1
   theMat = theConsEnt->myPart ()->myMat ();
d866 1
a866 1
      theMat = theBopEnt->myPart ()->myMat ();
@


1.54
log
@Continued implementation of post-implosion pegging.
@
text
@d146 1
a146 1
   if (myGlobalComp ()->perfPIPegging ())
d197 1
a197 1
   if (myGlobalComp ()->perfPIPegging ())
@


1.53
log
@Continued implementation of post-implosion pegging.
@
text
@d34 1
a34 1
#include <RefMapI.h>
@


1.52
log
@Contined implementation of post-implosion pegging.
@
text
@d30 1
a30 1
#include <PIPegInt.h>
d147 1
a147 1
      myProblem ()->myPIPegInt ()->preprocess ();
d198 1
a198 1
      myProblem ()->myPIPegInt ()->unpreprocess ();
@


1.51
log
@Continued implementation of post-implosion pegging.
@
text
@d30 1
d146 3
d196 3
@


1.50
log
@Continued implementation of opt with COIN.
@
text
@a33 1
#include <FlexVecI.h>
@


1.49
log
@Continued implementation of proportionate routing.
@
text
@d105 1
a105 1
   WitTimingEvent theEvent ("preproc");
d147 2
d160 1
a160 1
   WitTimingEvent theEvent ("preproc");
d179 2
@


1.48
log
@Continued implementation of proportionate routing.
@
text
@d728 1
a728 1
      thePart->getMaterial (theMat);
d827 1
a827 1
   theConsEnt->myPart ()->getMaterial (theMat);
d856 1
a856 1
      theBopEnt->myPart ()->getMaterial (theMat);
@


1.47
log
@Continued implementation of proportionate routing.
@
text
@a33 1
#include <RefI.h>
a34 7

//------------------------------------------------------------------------------
// Explicit template instantiation.
//------------------------------------------------------------------------------

template class WitRef <WitList <WitPart> >;
template class WitRef <WitList <WitOperation> >;
@


1.46
log
@Attempt to fix a syntax error from the MS compiler.
@
text
@d38 7
@


1.45
log
@Attempt to fix a syntax error from the MS compiler in Pre.C.
@
text
@d38 33
a692 66
template <typename SortEntry> 
      bool WitPreprocessor::orderedByAversion (
         const WitList <SortEntry> & theList)
   {
   SortEntry * theEntry;
   SortEntry * prevEntry;

   prevEntry = NULL;

   forEachEl (theEntry, theList)
      {
      if (prevEntry != NULL)
         if (compareAversion (theEntry, prevEntry) == -1)
            return false;

      prevEntry = theEntry;
      }

   return true;
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      void WitPreprocessor::sortByAversion (
         WitList      <SortEntry> & theList,
         WitDenseList <SortEntry> & theDenseList)
   {
   SortEntry * theEntry;

   copyInto (theDenseList, theList);

   theDenseList.sort (& compareAversion);

   theList.clear ();

   forEachElDense (theEntry, theDenseList)
      theList.append (theEntry);
   }

//------------------------------------------------------------------------------

int WitPreprocessor::compareAversion (
      WitSubEntry * theSub1,
      WitSubEntry * theSub2)
   {
   return
      WitUtil::sign (
           theSub1->expNetAversion () 
         - theSub2->expNetAversion ());
   }

//------------------------------------------------------------------------------

int WitPreprocessor::compareAversion (
      WitBopEntry * theBopEnt1,
      WitBopEntry * theBopEnt2)
   {
   return
      WitUtil::sign (
           theBopEnt1->expAversion () 
         - theBopEnt2->expAversion ());
   }

//------------------------------------------------------------------------------

d1013 67
@


1.44
log
@Tried to fix some syntax errors from the MS compiler.
@
text
@a659 14
inline float WitPreprocessor::aversion (WitSubEntry * theSub)
   {
   return theSub->expNetAversion ();
   }

//------------------------------------------------------------------------------

inline float WitPreprocessor::aversion (WitBopEntry * theBopEnt)
   {
   return theBopEnt->expAversion ();
   }

//------------------------------------------------------------------------------

d672 1
a672 1
         if (aversion (theEntry) < aversion (prevEntry))
d702 15
a716 4
template <typename SortEntry> 
      int WitPreprocessor::compareAversion (
         SortEntry * theSortEntry1,
         SortEntry * theSortEntry2)
d718 4
a721 1
   return WitUtil::sign (aversion (theSortEntry1) - aversion (theSortEntry2));
@


1.43
log
@Various internal changes.
@
text
@d706 1
a706 1
   theDenseList.sort (compareAversion);
@


1.42
log
@Various internal changes.
@
text
@a37 70
// Declaration and implementation of global functions and templates used by
// class Preprocessor.
//------------------------------------------------------------------------------

inline float aversion (WitSubEntry * theSub)
   {
   return theSub->expNetAversion ();
   }

//------------------------------------------------------------------------------

inline float aversion (WitBopEntry * theBopEnt)
   {
   return theBopEnt->expAversion ();
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      bool orderedByAversion (const WitList <SortEntry> & theList)
   {
   SortEntry * theEntry;
   SortEntry * prevEntry;

   prevEntry = NULL;

   forEachEl (theEntry, theList)
      {
      if (prevEntry != NULL)
         if (aversion (theEntry) < aversion (prevEntry))
            return false;

      prevEntry = theEntry;
      }

   return true;
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      void sortByAversion (
         WitList      <SortEntry> & theList,
         WitDenseList <SortEntry> & theDenseList)
   {
   SortEntry * theEntry;

   copyInto (theDenseList, theList);

   theDenseList.sort (compareAversion);

   theList.clear ();

   forEachElDense (theEntry, theDenseList)
      theList.append (theEntry);
   }

//------------------------------------------------------------------------------

template <typename SortEntry> 
      int compareAversion (
         SortEntry * theSortEntry1,
         SortEntry * theSortEntry2)
   {
   return WitUtil::sign (aversion (theSortEntry1) - aversion (theSortEntry2));
   }

//------------------------------------------------------------------------------
// Implementation of class Preprocessor.
//------------------------------------------------------------------------------
d656 66
@


1.41
log
@Internal changes.
@
text
@d56 1
a56 1
template <class SortEntry> 
d78 1
a78 1
template <class SortEntry> 
d97 1
a97 1
template <class SortEntry> 
@


1.40
log
@Internal changes.
@
text
@d221 1
a221 1
   if (! preprocessed ())
d559 1
a559 1
   if (! myGlobalComp ()->lotSizesExist ())
d565 1
a565 1
   if (! thePart->isaCapacity ())
d570 1
a570 1
      if (! theBomEnt->inEffect (execPer))
d632 1
a632 1
   if (! theBopEnt->expAllowed ())
d709 1
a709 1
      if (! orderedByAversion (thePart->producingBopEntries ()))
d724 1
a724 1
      if (! orderedByAversion (theBomEnt->mySubEntries ()))
d769 1
a769 1
         if (! theMat->producingBopEntries ().isEmpty ())
d771 1
a771 1
               if (! theMat->explodeable (thePer))
d773 1
a773 1
                     if (! theMat->mandEC ()[thePer - 1])
d843 1
a843 1
   if (! theBomEnt->mandEC ())
d946 1
a946 1
   if (! theEnt->inEffect (execPer))
d1042 1
a1042 1
   if (! optPreprocessed ())
@


1.39
log
@Continued implementation of two-level lot sizes.
@
text
@d57 1
a57 1
      WitBoolean orderedByAversion (const WitList <SortEntry> & theList)
d68 1
a68 1
            return witFALSE;
d73 1
a73 1
   return witTRUE;
d113 3
a115 3
      preprocessed_        (witFALSE),
      optPreprocessed_     (witFALSE),
      execPeriodsComputed_ (witFALSE),
d184 1
a184 1
   preprocessed_ = witTRUE;
d214 1
a214 1
   optPreprocessed_ = witTRUE;
d230 2
a231 2
   preprocessed_        = witFALSE;
   execPeriodsComputed_ = witFALSE; 
d242 2
a243 2
      WitFlexVec <WitBoolean>  & isCoproducedArg,
      WitBoolean               & expPerGapsArg,
d260 2
a261 2
      WitMaterial *             theMat,
      WitFlexVec <WitBoolean>  & mandECArg)
d270 1
a270 1
      WitTVec    <WitBoolean>  & executableArg)
d297 1
a297 1
      WitFlexVec <WitBoolean>  & hasSubsInEffectArg,
d327 1
a327 1
      WitBoolean                & lotSizesExistArg)
d462 1
a462 1
   lotSizesExist_ () = witFALSE;
d467 1
a467 1
            lotSizesExist_ () = witTRUE;
d491 4
a494 4
   WitBomEntry *        theBomEnt;
   WitPeriod            thePer;
   WitSubEntry *        theSub;
   WitTVec <WitBoolean> hasSubsInEffectVal (myProblem (), witFALSE);
d498 1
a498 1
      hasSubsInEffect_ (theBomEnt).setToScalar (witFALSE);
d503 1
a503 1
      hasSubsInEffectVal.setToScalar (witFALSE);
d509 1
a509 1
               hasSubsInEffectVal[thePer] = witTRUE;
d764 1
a764 1
      expPerGaps_ (thePart) = witFALSE;
d775 1
a775 1
                        expPerGaps_ (theMat) = witTRUE;
d901 1
a901 1
            mandEC_ (theMat).elemRef (prodPer) = witTRUE;
d918 1
a918 1
      isCoproduced_ (thePart).setToScalar (witFALSE);
d951 1
a951 1
   isCoproduced_ (theEnt->myPart ()).elemRef (impactPer) = witTRUE;
d987 1
a987 1
   execPeriodsComputed_ = witTRUE; 
d1045 1
a1045 1
   optPreprocessed_ = witFALSE;
@


1.38
log
@Continued implementation of two-level lot sizes.
@
text
@a465 1
         {
d469 3
a471 1
         if (theOpn->lotSize2Thresh ()[thePer] >= 0.0)
d475 1
a475 1
                  theOpn->operationName  ().myCstring (),
d477 1
a477 2
                  theOpn->lotSize2Thresh ()[thePer],
                  theOpn->incLotSize     ()[thePer]);
d481 1
a481 1
                  theOpn->operationName  ().myCstring (),
d483 1
a483 2
                  theOpn->lotSize2Thresh ()[thePer],
                  theOpn->incLotSize2    ()[thePer]);
a484 1
         }
@


1.37
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d159 1
a159 1
   compLotSizesExist ();
d457 1
a457 1
void WitPreprocessor::compLotSizesExist ()
d466 2
a467 3
         if ((theOpn->minLotSize ()[thePer] > 0.0) ||
             (theOpn->incLotSize ()[thePer] > 0.0)   )
            {
d470 15
a484 1
            return;
d486 1
@


1.36
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d35 1
d526 4
a529 1
   if (theConsEnt->consRate ().repIsByVec ())
a533 3
   else
      effConsRate_ (theConsEnt).setToScalar (
         theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d1035 1
a1035 1
   myOptImploder ()->unaccelerate ();
@


1.35
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d13 1
a13 6
// Contains the implementation of the following classes:
//
//    Preprocessor
//    NodeSorter
//    OffsetProc
//    BelowLister
d20 6
d27 1
d30 1
a32 1
#include <ScheduleI.h>
a1036 853
   }

//------------------------------------------------------------------------------
// Implementation of class NodeSorter.
//------------------------------------------------------------------------------

WitNodeSorter::WitNodeSorter (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitNodeSorter::~WitNodeSorter ()
   {
   }

//------------------------------------------------------------------------------

void WitNodeSorter::loadDataFrom (WitPart * thePart, int & sortedPartIndexArg)
   {
   sortedPartIndex_.setMapFor (thePart, sortedPartIndexArg);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::loadDataFromCompMgr (
      WitList    <WitPart>      & allPartsArg,
      WitList    <WitOperation> & allOperationsArg)
   {
   allParts_     .refTo (allPartsArg);
   allOperations_.refTo (allOperationsArg);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::allocLoadedData ()
   {
   sortedPartIndex_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitNodeSorter::clearLoadedData ()
   {
   allParts_       .clear ();
   allOperations_  .clear ();
   sortedPartIndex_.clear ();
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodesIfNeeded ()
   {
   int            nBefore;
   WitPart *      thePart;
   WitOperation * theOpn;

   successors_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      successors_.setMapFor (thePart, * new WitList <WitNode>);

   forEachOperation (theOpn, myProblem ())
      successors_.setMapFor (theOpn,  * new WitList <WitNode>);

   defineAllNodesSuccessors ();

   if (! nodesInOrder ())
      sortNodes ();

   forEachOperation (theOpn, myProblem ())
      delete & successors_ (theOpn);

   forEachPart (thePart, myProblem ())
      delete & successors_ (thePart);

   allNodes_  .clear ();
   successors_.clear ();

   nBefore = 0;

   forEachPart (thePart, myProblem ())
      sortedPartIndex_ (thePart) = nBefore ++;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::defineAllNodesSuccessors ()
   {
   WitPart      * thePart;
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;
   WitSubEntry  * theSub;
   WitBopEntry  * theBopEnt;

   forEachPart (thePart, myProblem ())
      allNodes_.append (thePart);

   forEachOperation (theOpn, myProblem ())
      allNodes_.append (theOpn);

   forEachOperation (theOpn, myProblem ())
      {
      forEachEl (theBomEnt, theOpn->bom ())
         {
         successors_ (theBomEnt->myPart ()).append (theOpn);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            successors_ (theSub->myPart ()).append (theOpn);
         }
      }

   forEachPart (thePart, myProblem ())
      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            successors_ (theBopEnt->myOperation ()).append (thePart);
   }

//------------------------------------------------------------------------------
// nodesInOrder.
// Returns TRUE, iff the Parts and Operations are already in order.
// Variables:
//
//    nBefore
//       nBefore (theNode) is the # of Nodes listed before theNode in allNodes_
//       This indicates the order of the Nodes in allNodes_.
//
//    nBeforeSuccs
//       nBeforeSuccs (theNode) is the minimum # of Nodes listed before
//       any successor to theNode.
//
// The Nodes are considered to be in order iff the Parts are in order and the
// Operations are in order. Since allNodes_ is just a temporary List, a Part
// is allowed to be out of order with respect to an Operation. Abstractly, this
// means that a Node should not be compared to its successors, which are of the
// opposite derived class (Part vs. Operation). Instead, a Node should be
// compared to the successors to its successors, which are of the same derived
// class. Specifically, the Nodes are out of order, iff there exists a Node,
// theNode and a successor to it, succNode, such that:
//
//    nBefore (theNode) >= nBeforeSuccs (succNode)
//------------------------------------------------------------------------------

WitBoolean WitNodeSorter::nodesInOrder ()
   {
   WitMapping <WitNode, int> nBefore      (myProblem (), 0);
   WitMapping <WitNode, int> nBeforeSuccs (myProblem (), 0);

   WitNode * theNode;
   WitNode * succNode;
   int nScanned;

   nScanned = 0;

   forEachEl (theNode, allNodes_)
      nBefore (theNode) = nScanned ++;

   forEachEl (theNode, allNodes_)
       {
       nBeforeSuccs (theNode) = myCompMgr ()->nNodes ();

       forEachEl (succNode, successors_ (theNode))
          nBeforeSuccs (theNode) =
             min (nBeforeSuccs (theNode), nBefore (succNode));
       }

   forEachEl (theNode, allNodes_)
       forEachEl (succNode, successors_ (theNode))
          if (nBefore (theNode) >= nBeforeSuccs (succNode))
             return witFALSE;

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodes ()
   {
   WitList <WitNode> sortedNodes;
      //
      // The sorted List of all Nodes.

   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;

   myMsgFac () ("sortNodesMsg");

   sorted_.allocate (myProblem (), witFALSE);

   sortNodes (sortedNodes);

   if (sortedNodes.nElements () != myCompMgr ()->nNodes ())
      constructCycle ();

   sorted_          .clear ();
   allParts_ ()     .clear ();
   allOperations_ ().clear ();

   forEachEl (theNode, sortedNodes)
      {     
      theNode->getPart (thePart);

      if (thePart != NULL)
         allParts_ ().append (thePart);

      theNode->getOperation (theOpn);

      if (theOpn != NULL)
         allOperations_ ().append (theOpn);
      }
   }

//------------------------------------------------------------------------------
// sortNodes.
// Variables:
//
//    nUnsortedPreds
//       nUnsortedPreds (theNode) is the # of BillEntries to predecessors to
//       theNode that have not yet been sorted. When this value is 0,
//       theNode is eligible to be sorted.
//
//    eligibleNodes
//       The list of all Nodes currently eligible to be sorted: those with
//       no unsorted predecessors.
//------------------------------------------------------------------------------

void WitNodeSorter::sortNodes (WitList <WitNode> & sortedNodes)
   {
   WitMapping <WitNode, int> nUnsortedPreds (myProblem (), 0);

   WitList <WitNode> eligibleNodes;

   WitNode * theNode;
   WitNode * succNode;

   forEachEl (theNode, allNodes_)
      forEachEl (succNode, successors_ (theNode))
         ++ nUnsortedPreds (succNode);

   forEachEl (theNode, allNodes_)
      if (nUnsortedPreds (theNode) == 0)
         eligibleNodes.append (theNode);

   while (! eligibleNodes.isEmpty ())
      {
      theNode = eligibleNodes.get ();

      sortedNodes.append (theNode);

      sorted_ (theNode) = witTRUE;

      forEachEl (succNode, successors_ (theNode))
         {
         -- nUnsortedPreds (succNode);

         if (nUnsortedPreds (succNode) == 0)
             eligibleNodes.append (succNode);
         }
      }
   }

//------------------------------------------------------------------------------
// constructCycle
// Variables:
//
//    scanned
//       scanned (theNode) is TRUE, iff theNode has already been scanned in
//       the search for a cycle. A cycle has been found when a Node gets
//       scanned twice.
//------------------------------------------------------------------------------

void WitNodeSorter::constructCycle ()
   {
   WitMapping <WitNode, WitBoolean> scanned (myProblem (), witFALSE);

   WitNode * theNode;
   WitPart * thePart;
   WitNode * succNode;
   WitNode * cycleStart;

   unsortedPredFor_.allocate (myProblem ());

   forEachEl (theNode, allNodes_)
      if (! sorted_ (theNode))
         forEachEl (succNode, successors_ (theNode))
            unsortedPredFor_ (succNode) = theNode;

   forEachEl (theNode, allNodes_)
      if (! sorted_ (theNode))
         break;

   while (! scanned (theNode))
      {
      scanned (theNode) = witTRUE;

      theNode = unsortedPredFor_ (theNode);
      }

   theNode->getPart (thePart);

   if (thePart == NULL)
      theNode = unsortedPredFor_ (theNode);

   theNode->getPart (thePart);

   stronglyAssert (thePart != NULL);
      //
      // The cycle needs to begin with a Part, so that the error message
      // makes sense.

   cycleStart = theNode;

   myMsgFac () ("bomCycleHeadingSmsg");

   do
      {
      myMsgFac () ("bomCycleNodesSmsg",
         theNode->nodeName (),
         unsortedPredFor_ (theNode)->nodeName (),
         unsortedPredFor_ (unsortedPredFor_ (theNode))->nodeName ());

      theNode = unsortedPredFor_ (unsortedPredFor_ (theNode));
      }
      while (theNode != cycleStart);

   myMsgFac () ("bomCycleSmsg");
   }

//------------------------------------------------------------------------------
// Implementation of class OffsetProc.
//------------------------------------------------------------------------------

WitOffsetProc::WitOffsetProc (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitOffsetProc::~WitOffsetProc ()
   {
   }

//------------------------------------------------------------------------------

void WitOffsetProc::loadDataFrom (
      WitOperation *             theOpn,
      WitTVec    <WitBoolean>  & executableArg)
   {
   executable_.setMapFor (theOpn, executableArg);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::loadDataFrom (
      WitBillEntry *             theBillEnt,
      WitTVec    <WitPeriod>   & impactPeriodArg)
   {
   impactPeriod_.setMapFor (theBillEnt, impactPeriodArg);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::allocLoadedData ()
   {
   executable_  .allocate (myProblem ());
   impactPeriod_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitOffsetProc::clearLoadedData ()
   {
   executable_  .clear ();
   impactPeriod_.clear ();
   }

//------------------------------------------------------------------------------

void WitOffsetProc::roundOffsets ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   WitTVec <float>      leadToImpact (myProblem (), 0.0);
   WitTVec <WitBoolean> hasImpact    (myProblem (), witFALSE);
      //
      // See updateProdCumLeads.

   if (myGlobalComp ()->truncOffsets ())
      truncateOffsets ();

   floatCumLead_.allocate (myProblem (), 0.0);

   forEachOperation (theOpn, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         executable_ (theOpn)[thePer] = roundOffsets (theOpn, thePer);

         if (! theOpn->executable ()[thePer])
            resetExec (theOpn, thePer);
         }

      updateProdCumLeads (theOpn, leadToImpact, hasImpact);
      }

   truncOffset_ .clear ();
   floatCumLead_.clear ();
   }

//------------------------------------------------------------------------------

inline float WitOffsetProc::workOffset (
      WitBillEntry * theBillEnt, 
      WitPeriod      thePer)
   {
   return
      myGlobalComp ()->truncOffsets ()?
         truncOffset_ (theBillEnt)[thePer]:
         theBillEnt->offset ()[thePer];
   }

//------------------------------------------------------------------------------

void WitOffsetProc::truncateOffsets ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   truncOffset_.allocate (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      {
      truncateOffset (theBomEnt);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         truncateOffset (theSub);
      }

   forEachBopEntry (theBopEnt, myProblem ())
      truncateOffset (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::truncateOffset (WitBillEntry * theBillEnt)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      truncOffset_ (theBillEnt)[thePer] =
         min ((float) thePer, theBillEnt->offset ()[thePer]);
   }

//------------------------------------------------------------------------------
// roundOffsets
//
// Computes impactPeriods for the BomEntries and BopEntries of theOpn in thePer.
// Also checks for the various conditions under which execution of
// theOpn is to be forbidden in thePer.
// If any such condition occurs, computation is terminated and FALSE
// is returned, indicating forbidden execution.
// Otherwise TRUE is returned.
//
// The conditions for forbidding execution are:
//
//   yieldRate         == 0.0
//   cycle time        < 0 (3.4 mode only)
//   release date      < 0 (3.4 mode only)
//   an impactPeriod   < 0, or >= nPeriods
//   execEmptyBom () is FALSE and no BomEntries are in effect in period t.
//------------------------------------------------------------------------------

WitBoolean WitOffsetProc::roundOffsets (
      WitOperation * theOpn,
      WitPeriod      thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   if (theOpn->yieldRate ()[thePer] == 0.0)
      return witFALSE;

   if (wit34Compatible ())
      if (theOpn->cycleTime34PreventsExec (thePer))
         return witFALSE;

   forEachEl (theBomEnt, theOpn->bom ())
      {
      if (! compImpactPeriod (theBomEnt, thePer))
         return witFALSE;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (myGlobalComp ()->independentOffsets ())
            compImpactPeriod (theSub, thePer);
         else
            copyImpactPeriod (theSub, thePer);
      }

   forEachEl (theBopEnt, theOpn->bop ())
      if (! compImpactPeriod (theBopEnt, thePer))
         return witFALSE;

   if (! myGlobalComp ()->execEmptyBom ())
      if (! theOpn->hasBomEntryInEffect (thePer))
         return witFALSE;

   return witTRUE;
   }

//------------------------------------------------------------------------------
// compImpactPeriod.
// Computes theConsEnt->impactPeriod_[thePer].
// If the resulting impactPeriod falls outside the time horizon, the
// computation is aborted and the function returns FALSE, indicating that
// execution of theConsEnt->myOperation () should be forbidden in thePer.
// Otherwise returns TRUE.
//
// An initial value for the impactPeriod is computed using a simple integer
// round down of the float workOffset ()[thePer]. The final value is computed by
// rounding the float lead time either up or down so as to have the right
// effect on cumulative lead time.
//
// Variables:
//
//    initImpactPeriod:   Initial value for impactPeriod
//    consFCLead:         The float cum lead time for the consumed Part.
//    propFCLead:         The proposed float cum lead time for the consuming
//                        Operation. The proposed value is taken iff it is
//                        larger than the current value.
//    leadTime:           The int lead time
//    finalImpactPeriod:  Final value for ImpactPeriod
//------------------------------------------------------------------------------

WitBoolean WitOffsetProc::compImpactPeriod (
      WitConsEntry * theConsEnt,
      WitPeriod      thePer)
   {
   WitPeriod initImpactPeriod;
   float     consFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod finalImpactPeriod;

   impactPeriod_ (theConsEnt)[thePer] = -1;

   if (! theConsEnt->withinInterval (thePer))
      return witTRUE;

   initImpactPeriod = thePer - ltRoundDown (workOffset (theConsEnt, thePer));

   if (initImpactPeriod < 0)
      return witFALSE;

   if (initImpactPeriod >= nPeriods ())
      return witFALSE;

   consFCLead = floatCumLead_ (theConsEnt->myPart ())[initImpactPeriod];

   propFCLead = consFCLead + workOffset (theConsEnt, thePer);

   leadTime =
        ltRoundDown (propFCLead)
      - ltRoundDown (consFCLead);

   finalImpactPeriod = thePer - leadTime;

   if (finalImpactPeriod < 0)
      return witFALSE;

   impactPeriod_ (theConsEnt)[thePer] = finalImpactPeriod;

   setToMax (floatCumLead_ (theConsEnt->myOperation ())[thePer], propFCLead);

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::copyImpactPeriod (WitSubEntry * theSub, WitPeriod thePer)
   {
   impactPeriod_ (theSub)[thePer] = -1;

   if (theSub->myBomEnt ()->inEffect (thePer))
      if (theSub->withinInterval (thePer))
         impactPeriod_ (theSub)[thePer] = 
            theSub->myBomEnt ()->impactPeriod ()[thePer];
   }

//------------------------------------------------------------------------------
// compImpactPeriod for a BopEntry.
//
// Variables:
//
//    opnFCLead:        The float cum lead time for the producing Operation:
//    propFCLead:       The proposed float cum lead time for the produced
//                      Part. The proposed value is taken iff it is larger
//                      than the current value.
//    leadTime:         The int lead time
//    theImpactPeriod:  The impactPeriod
//------------------------------------------------------------------------------

WitBoolean WitOffsetProc::compImpactPeriod (
      WitBopEntry * theBopEnt,
      WitPeriod     thePer)
   {
   float     opnFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod theImpactPeriod;

   impactPeriod_ (theBopEnt)[thePer] = -1;

   if (! theBopEnt->withinInterval (thePer))
      return witTRUE;

   opnFCLead  = floatCumLead_ (theBopEnt->myOperation ())[thePer];

   propFCLead = opnFCLead - workOffset (theBopEnt, thePer);

   leadTime =
        ltRoundDown (opnFCLead)
      - ltRoundDown (propFCLead);

   theImpactPeriod = thePer - leadTime;

   if (theImpactPeriod < 0)
      return witFALSE;

   if (theImpactPeriod >= nPeriods ())
      return witFALSE;

   impactPeriod_ (theBopEnt)[thePer] = theImpactPeriod;

   return witTRUE;
   }

//------------------------------------------------------------------------------

int WitOffsetProc::ltRoundDown (float leadTime)
   {
   return (int) floor (leadTime + 1.0E-3);
   }

//------------------------------------------------------------------------------

void WitOffsetProc::resetExec (WitOperation * theOpn, WitPeriod thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   forEachEl (theBomEnt, theOpn->bom ())
      {
      impactPeriod_ (theBomEnt)[thePer] = -1;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         impactPeriod_ (theSub)[thePer] = -1;
      }

   forEachEl (theBopEnt, theOpn->bop ())
      impactPeriod_ (theBopEnt)[thePer] = -1;

   floatCumLead_ (theOpn)[thePer] = 0.0;
   }

//------------------------------------------------------------------------------

void WitOffsetProc::updateProdCumLeads (
      WitOperation *         theOpn,
      WitTVec <float> &      leadToImpact,
      WitTVec <WitBoolean> & hasImpact)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitPeriod     theImpactPer;

   forEachEl (theBopEnt, theOpn->bop ())
      {
      hasImpact.setToScalar (witFALSE);

      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->inEffect (thePer))
            {
            theImpactPer               = theBopEnt->impactPeriod ()[thePer];

            hasImpact[theImpactPer]    = witTRUE;

            leadToImpact[theImpactPer] = 
               floatCumLead_ (theOpn)[thePer] - workOffset (theBopEnt, thePer);
            }

      forEachPeriod (theImpactPer, myProblem ())
         if (hasImpact[theImpactPer])
            setToMax (
               floatCumLead_ (theBopEnt->myPart ())[theImpactPer],
               leadToImpact[theImpactPer]);
      }
   }

//------------------------------------------------------------------------------
// Implementation of class BelowLister.
//------------------------------------------------------------------------------

WitBelowLister * WitBelowLister::activeInstance_ = NULL;

//------------------------------------------------------------------------------

WitBelowLister::WitBelowLister (WitProblem * theProblem):

      WitProbAssoc    (theProblem),

      nPartsBefore_   (),
      isBelowCurrent_ (),
      belowCurrent_   ()
   {
   }

//------------------------------------------------------------------------------

WitBelowLister::~WitBelowLister ()
   {
   }

//------------------------------------------------------------------------------

void WitBelowLister::loadDataFrom (
      WitPart *                  thePart,
      WitDenseList <WitPart>   & belowListArg)
   {
   belowList_.setMapFor (thePart, belowListArg);
   }

//------------------------------------------------------------------------------

void WitBelowLister::allocLoadedData ()
   {
   belowList_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitBelowLister::clearLoadedData ()
   {
   belowList_.clear ();
   }

//------------------------------------------------------------------------------

void WitBelowLister::buildBelow ()
   {
   WitPart * thePart;
   int       nBefore;

   witAssert (activeInstance_ == NULL);

   activeInstance_ = this;

   nPartsBefore_.allocate (myProblem (), 0);

   nBefore = 0;

   forEachPart (thePart, myProblem ())
      nPartsBefore_ (thePart) = nBefore ++;

   isBelowCurrent_.allocate (myProblem (), witFALSE);

   belowCurrent_.resize (myCompMgr ()->nParts ());

   forEachPart (thePart, myProblem ())
      buildBelow (thePart);

   nPartsBefore_  .clear ();
   isBelowCurrent_.clear ();
   belowCurrent_  .resize (0);

   activeInstance_ = NULL;
   }

//------------------------------------------------------------------------------

void WitBelowLister::buildBelow (WitPart * currentPart)
   {
   WitPart *      theBomPart;
   WitPart *      theBelowPart;
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;

   belowCurrent_.clear ();

   recordBelowCurrent (currentPart);

   forEachEl (theBopEnt, currentPart->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         {
         theOpn = theBopEnt->myOperation ();

         forEachEl (theBomEnt, theOpn->bom ())
            {
            theBomPart = theBomEnt->myPart ();

            forEachElDense (theBelowPart, theBomPart->belowList ())
               recordBelowCurrent (theBelowPart);

            forEachEl (theSub, theBomEnt->mySubEntries ())
               if (myGlobalComp ()->multiRoute () && theSub->expAllowed ())
                  forEachElDense (theBelowPart, theSub->myPart ()->belowList ())
                     recordBelowCurrent (theBelowPart);
               else if (theSub->netAllowed ())
                  recordBelowCurrent (theSub->myPart ());
            }
         }

   if (belowCurrent_.nElements () > 1)
      belowCurrent_.sort (compareNPartsBefore);

   belowList_ (currentPart).resize (belowCurrent_.nElements ());

   forEachElDense (theBelowPart, belowCurrent_)
      {
      isBelowCurrent_ (theBelowPart) = witFALSE;

      belowList_ (currentPart).append (theBelowPart);
      }
   }

//------------------------------------------------------------------------------

void WitBelowLister::recordBelowCurrent (WitPart * thePart)
   {
   if (isBelowCurrent_ (thePart))
      return;

   belowCurrent_.append (thePart);

   isBelowCurrent_ (thePart) = witTRUE;
   }

//------------------------------------------------------------------------------

int WitBelowLister::compareNPartsBefore (WitPart * thePart1, WitPart * thePart2)
   {
   return
      sign (
           thePart2->sortedPartIndex ()
         - thePart1->sortedPartIndex ());
@


1.34
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d17 1
d22 2
a24 1
#include <NodeSorter.h>
a105 12
inline float WitPreprocessor::workOffset (
      WitBillEntry * theBillEnt, 
      WitPeriod      thePer)
   {
   return
      myGlobalComp ()->truncOffsets ()?
         truncOffset_ (theBillEnt)[thePer]:
         theBillEnt->offset ()[thePer];
   }

//------------------------------------------------------------------------------

d116 1
d126 1
d152 1
a152 1
   roundOffsets ();
d269 1
a269 1
   executable_.setMapFor (theOpn, executableArg);
d278 1
a278 1
   impactPeriod_.setMapFor (theBillEnt, impactPeriodArg);
a350 2
   executable_         .allocate (myProblem ());
   impactPeriod_       .allocate (myProblem ());
d358 1
a375 2
   executable_         .clear ();
   impactPeriod_       .clear ();
d384 1
d454 1
a454 1
void WitPreprocessor::truncateOffsets ()
d456 2
a457 3
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
d459 1
a459 1
   truncOffset_.allocate (myProblem (), 0.0);
d461 6
a466 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      truncateOffset (theBomEnt);
d468 2
a469 6
      forEachEl (theSub, theBomEnt->mySubEntries ())
         truncateOffset (theSub);
      }

   forEachBopEntry (theBopEnt, myProblem ())
      truncateOffset (theBopEnt);
d474 1
a474 1
void WitPreprocessor::truncateOffset (WitBillEntry * theBillEnt)
d476 4
a479 1
   WitPeriod thePer;
d481 3
a483 4
   forEachPeriod (thePer, myProblem ())
      truncOffset_ (theBillEnt)[thePer] =
         min ((float) thePer, theBillEnt->offset ()[thePer]);
   }
d485 2
a486 1
//------------------------------------------------------------------------------
d488 1
a488 12
void WitPreprocessor::roundOffsets ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   WitTVec <float>      leadToImpact (myProblem (), 0.0);
   WitTVec <WitBoolean> hasImpact    (myProblem (), witFALSE);
      //
      // See updateProdCumLeads.

   if (myGlobalComp ()->truncOffsets ())
      truncateOffsets ();
a489 4
   floatCumLead_.allocate (myProblem (), 0.0);

   forEachOperation (theOpn, myProblem ())
      {
d491 4
a494 2
         {
         executable_ (theOpn)[thePer] = roundOffsets (theOpn, thePer);
d496 2
a497 3
         if (! theOpn->executable ()[thePer])
            resetExec (theOpn, thePer);
         }
d499 1
a499 1
      updateProdCumLeads (theOpn, leadToImpact, hasImpact);
a500 3

   truncOffset_ .clear ();
   floatCumLead_.clear ();
a503 17
// roundOffsets
//
// Computes impactPeriods for the BomEntries and BopEntries of theOpn in thePer.
// Also checks for the various conditions under which execution of
// theOpn is to be forbidden in thePer.
// If any such condition occurs, computation is terminated and FALSE
// is returned, indicating forbidden execution.
// Otherwise TRUE is returned.
//
// The conditions for forbidding execution are:
//
//   yieldRate         == 0.0
//   cycle time        < 0 (3.4 mode only)
//   release date      < 0 (3.4 mode only)
//   an impactPeriod   < 0, or >= nPeriods
//   execEmptyBom () is FALSE and no BomEntries are in effect in period t.
//------------------------------------------------------------------------------
d505 1
a505 3
WitBoolean WitPreprocessor::roundOffsets (
      WitOperation * theOpn,
      WitPeriod      thePer)
a506 1
   WitBomEntry * theBomEnt;
a507 1
   WitBopEntry * theBopEnt;
d509 1
a509 2
   if (theOpn->yieldRate ()[thePer] == 0.0)
      return witFALSE;
d511 2
a512 3
   if (wit34Compatible ())
      if (theOpn->cycleTime34PreventsExec (thePer))
         return witFALSE;
d514 2
a515 4
   forEachEl (theBomEnt, theOpn->bom ())
      {
      if (! compImpactPeriod (theBomEnt, thePer))
         return witFALSE;
d517 1
a517 6
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (myGlobalComp ()->independentOffsets ())
            compImpactPeriod (theSub, thePer);
         else
            copyImpactPeriod (theSub, thePer);
      }
d519 3
a521 3
   forEachEl (theBopEnt, theOpn->bop ())
      if (! compImpactPeriod (theBopEnt, thePer))
         return witFALSE;
d523 8
a530 5
   if (! myGlobalComp ()->execEmptyBom ())
      if (! theOpn->hasBomEntryInEffect (thePer))
         return witFALSE;

   return witTRUE;
a533 22
// compImpactPeriod.
// Computes theConsEnt->impactPeriod_[thePer].
// If the resulting impactPeriod falls outside the time horizon, the
// computation is aborted and the function returns FALSE, indicating that
// execution of theConsEnt->myOperation () should be forbidden in thePer.
// Otherwise returns TRUE.
//
// An initial value for the impactPeriod is computed using a simple integer
// round down of the float workOffset ()[thePer]. The final value is computed by
// rounding the float lead time either up or down so as to have the right
// effect on cumulative lead time.
//
// Variables:
//
//    initImpactPeriod:   Initial value for impactPeriod
//    consFCLead:         The float cum lead time for the consumed Part.
//    propFCLead:         The proposed float cum lead time for the consuming
//                        Operation. The proposed value is taken iff it is
//                        larger than the current value.
//    leadTime:           The int lead time
//    finalImpactPeriod:  Final value for ImpactPeriod
//------------------------------------------------------------------------------
d535 1
a535 3
WitBoolean WitPreprocessor::compImpactPeriod (
      WitConsEntry * theConsEnt,
      WitPeriod      thePer)
d537 6
a542 5
   WitPeriod initImpactPeriod;
   float     consFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod finalImpactPeriod;
d544 2
a545 1
   impactPeriod_ (theConsEnt)[thePer] = -1;
d547 2
a548 2
   if (! theConsEnt->withinInterval (thePer))
      return witTRUE;
d550 2
a551 1
   initImpactPeriod = thePer - ltRoundDown (workOffset (theConsEnt, thePer));
d553 4
a556 2
   if (initImpactPeriod < 0)
      return witFALSE;
d558 2
a559 2
   if (initImpactPeriod >= nPeriods ())
      return witFALSE;
d561 1
a561 1
   consFCLead = floatCumLead_ (theConsEnt->myPart ())[initImpactPeriod];
d563 1
a563 1
   propFCLead = consFCLead + workOffset (theConsEnt, thePer);
d565 2
a566 3
   leadTime =
        ltRoundDown (propFCLead)
      - ltRoundDown (consFCLead);
d568 2
a569 1
   finalImpactPeriod = thePer - leadTime;
d571 9
a579 2
   if (finalImpactPeriod < 0)
      return witFALSE;
d581 4
a584 1
   impactPeriod_ (theConsEnt)[thePer] = finalImpactPeriod;
d586 1
a586 1
   setToMax (floatCumLead_ (theConsEnt->myOperation ())[thePer], propFCLead);
d588 4
a591 1
   return witTRUE;
d596 1
a596 1
void WitPreprocessor::copyImpactPeriod (WitSubEntry * theSub, WitPeriod thePer)
d598 1
a598 1
   impactPeriod_ (theSub)[thePer] = -1;
d600 6
a605 4
   if (theSub->myBomEnt ()->inEffect (thePer))
      if (theSub->withinInterval (thePer))
         impactPeriod_ (theSub)[thePer] = 
            theSub->myBomEnt ()->impactPeriod ()[thePer];
d609 2
a610 15
// compImpactPeriod for a BopEntry.
//
// Variables:
//
//    opnFCLead:        The float cum lead time for the producing Operation:
//    propFCLead:       The proposed float cum lead time for the produced
//                      Part. The proposed value is taken iff it is larger
//                      than the current value.
//    leadTime:         The int lead time
//    theImpactPeriod:  The impactPeriod
//------------------------------------------------------------------------------

WitBoolean WitPreprocessor::compImpactPeriod (
      WitBopEntry * theBopEnt,
      WitPeriod     thePer)
d612 2
a613 4
   float     opnFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod theImpactPeriod;
d615 1
a615 1
   impactPeriod_ (theBopEnt)[thePer] = -1;
d617 2
a618 2
   if (! theBopEnt->withinInterval (thePer))
      return witTRUE;
d620 4
a623 1
   opnFCLead  = floatCumLead_ (theBopEnt->myOperation ())[thePer];
d625 2
a626 17
   propFCLead = opnFCLead - workOffset (theBopEnt, thePer);

   leadTime =
        ltRoundDown (opnFCLead)
      - ltRoundDown (propFCLead);

   theImpactPeriod = thePer - leadTime;

   if (theImpactPeriod < 0)
      return witFALSE;

   if (theImpactPeriod >= nPeriods ())
      return witFALSE;

   impactPeriod_ (theBopEnt)[thePer] = theImpactPeriod;

   return witTRUE;
d631 1
a631 8
int WitPreprocessor::ltRoundDown (float leadTime)
   {
   return (int) floor (leadTime + 1.0E-3);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::resetExec (WitOperation * theOpn, WitPeriod thePer)
a632 2
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
d634 7
d642 2
a643 3
   forEachEl (theBomEnt, theOpn->bom ())
      {
      impactPeriod_ (theBomEnt)[thePer] = -1;
d645 19
a663 3
      forEachEl (theSub, theBomEnt->mySubEntries ())
         impactPeriod_ (theSub)[thePer] = -1;
      }
d665 7
a671 2
   forEachEl (theBopEnt, theOpn->bop ())
      impactPeriod_ (theBopEnt)[thePer] = -1;
d673 8
a680 1
   floatCumLead_ (theOpn)[thePer] = 0.0;
d685 1
a685 4
void WitPreprocessor::updateProdCumLeads (
      WitOperation *         theOpn,
      WitTVec <float> &      leadToImpact,
      WitTVec <WitBoolean> & hasImpact)
d687 1
a687 3
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitPeriod     theImpactPer;
d689 1
a689 3
   forEachEl (theBopEnt, theOpn->bop ())
      {
      hasImpact.setToScalar (witFALSE);
d691 1
a691 4
      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->inEffect (thePer))
            {
            theImpactPer               = theBopEnt->impactPeriod ()[thePer];
d693 3
a695 12
            hasImpact[theImpactPer]    = witTRUE;

            leadToImpact[theImpactPer] = 
               floatCumLead_ (theOpn)[thePer] - workOffset (theBopEnt, thePer);
            }

      forEachPeriod (theImpactPer, myProblem ())
         if (hasImpact[theImpactPer])
            setToMax (
               floatCumLead_ (theBopEnt->myPart ())[theImpactPer],
               leadToImpact[theImpactPer]);
      }
d700 1
a700 1
void WitPreprocessor::compLotSizesExist ()
d702 1
a702 2
   WitOperation * theOpn;
   WitPeriod      thePer;
d704 1
a704 1
   lotSizesExist_ () = witFALSE;
d706 1
a706 6
   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if ((theOpn->minLotSize ()[thePer] > 0.0) ||
             (theOpn->incLotSize ()[thePer] > 0.0)   )
            {
            lotSizesExist_ () = witTRUE;
d708 3
a710 2
            return;
            }
d715 1
a715 1
void WitPreprocessor::compHasSubsInEffect ()
d717 3
a719 4
   WitBomEntry *        theBomEnt;
   WitPeriod            thePer;
   WitSubEntry *        theSub;
   WitTVec <WitBoolean> hasSubsInEffectVal (myProblem (), witFALSE);
d721 1
a721 1
   forEachBomEntry (theBomEnt, myProblem ())
d723 1
a723 3
      hasSubsInEffect_ (theBomEnt).setToScalar (witFALSE);

      if (theBomEnt->mySubEntries ().isEmpty ())
d726 1
a726 1
      hasSubsInEffectVal.setToScalar (witFALSE);
d729 2
a730 2
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->inEffect (thePer))
d732 1
a732 1
               hasSubsInEffectVal[thePer] = witTRUE;
a735 2

      hasSubsInEffect_ (theBomEnt).copyTVec (hasSubsInEffectVal);
d741 1
a741 1
void WitPreprocessor::preprocess (WitBomEntry * theBomEnt)
d743 7
a749 1
   WitSubEntry * theSub;
d751 1
a751 1
   compEffConsRate (theBomEnt);
d753 8
a760 2
   forEachEl (theSub, theBomEnt->mySubEntries ())
      compEffConsRate (theSub);
d762 3
a764 1
   checkMinLotSize (theBomEnt);
d768 40
d809 1
a809 1
void WitPreprocessor::compEffConsRate (WitConsEntry * theConsEnt)
d811 8
a818 1
   WitPeriod thePer;
d820 2
a821 8
   if (theConsEnt->consRate ().repIsByVec ())
      forEachPeriod (thePer, myProblem ())
         effConsRate_ (theConsEnt).elemRef (thePer) =
              theConsEnt->consRate ()[thePer] 
            / (1.0 - theConsEnt->falloutRate ());
   else
      effConsRate_ (theConsEnt).setToScalar (
         theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d826 1
a826 1
void WitPreprocessor::checkMinLotSize (WitBomEntry * theBomEnt)
d828 15
a842 6
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      execPer; // Execution period.
   WitPeriod      tCons;   // Consumption period.
   float          avail;   // Availability.
   float          minCons; // Consumption for minLotSize.
d844 5
a848 2
   if (! myGlobalComp ()->lotSizesExist ())
      return;
d850 1
a850 2
   thePart = theBomEnt->myPart ();
   theOpn  = theBomEnt->myOperation ();
d852 1
a852 1
   if (! thePart->isaCapacity ())
d855 1
a855 4
   forEachPeriod (execPer, myProblem ())
      {
      if (! theBomEnt->inEffect (execPer))
         continue;
d857 7
a863 2
      if (theOpn->minLotSize ()[execPer] == 0.0)
         continue;
d865 3
a867 1
      tCons = theBomEnt->impactPeriod ()[execPer];
d869 1
a869 1
      avail = thePart->supplyVol ()[tCons];
d871 5
a875 2
      if (avail == 0.0)
         continue;
d877 3
a879 2
      minCons = 
         theOpn->minLotSize ()[execPer] * theBomEnt->effConsRate ()[execPer];
d881 4
a884 9
      if (minCons > avail + FLOAT_EPSILON)
         {
         myMsgFac () ("minLotSizeTooLargeWmsg",
            theOpn->operationName (),
            execPer,
            minCons,
            thePart->partName (),
            tCons,
            avail);
d886 2
a887 2
         return;
         }
d893 1
a893 1
void WitPreprocessor::preprocess (WitBopEntry * theBopEnt)
d895 9
a903 3
   compEffProdRate      (theBopEnt);
   chooseExpExecPeriods (theBopEnt);
   }
d905 7
a911 1
//------------------------------------------------------------------------------
d913 4
a916 3
void WitPreprocessor::compEffProdRate (WitBopEntry * theBopEnt)
   {
   WitPeriod thePer;
d918 5
a922 6
   forEachPeriod (thePer, myProblem ())
      effProdRate_ (theBopEnt)[thePer] =
         theBopEnt->inEffect (thePer)?
              theBopEnt->productRate ()[thePer]
            * theBopEnt->myOperation ()->yieldRate ()[thePer]:
            0.0;
d927 1
a927 1
void WitPreprocessor::chooseExpExecPeriods (WitBopEntry * theBopEnt)
d929 1
a929 2
   WitPeriod execPer;
   WitPeriod prodPer;
d931 1
a931 3
   expExecPeriod_ (theBopEnt).setToScalar (-1);

   if (! theBopEnt->expAllowed ())
d934 1
a934 4
   forEachPeriod (execPer, myProblem ())
      if (theBopEnt->execPerOKForExp (execPer))
         {
         prodPer = theBopEnt->impactPeriod ()[execPer];
d936 1
a936 2
         expExecPeriod_ (theBopEnt)[prodPer] = execPer;
         }
d941 1
a941 1
void WitPreprocessor::checkSmallEffProdRates ()
d943 2
d946 1
a946 7
   WitPeriod     execPer;
   float         minAccEffProd;
   WitBopEntry * minAccBopEnt;
   WitPeriod     minAccPer;
   float         maxRejEffProd;
   WitBopEntry * maxRejBopEnt;
   WitPeriod     maxRejPer;
d948 2
a949 2
   minAccEffProd = WitGlobalComp::defExpCutoff ();
   maxRejEffProd = 0.0;
d951 2
a952 19
   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               {
               if (theBopEnt->effProdRate ()[execPer] < minAccEffProd)
                  {
                  minAccEffProd = theBopEnt->effProdRate ()[execPer];
                  minAccBopEnt  = theBopEnt;
                  minAccPer     = execPer;
                  }
               }
            else 
               if (theBopEnt->effProdRate ()[execPer] > maxRejEffProd)
                  {
                  maxRejEffProd = theBopEnt->effProdRate ()[execPer];
                  maxRejBopEnt  = theBopEnt;
                  maxRejPer     = execPer;
                  }
d954 2
a955 7
   if (maxRejEffProd > 0.0)
      myMsgFac () ("rejBopEntWmsg",
         myGlobalComp ()->expCutoff (),
         maxRejEffProd,
         maxRejBopEnt->myOperationName (),
         maxRejBopEnt->localIndex (),
         maxRejPer);
d957 2
a958 9
   if (minAccEffProd < WitGlobalComp::defExpCutoff ())
      myMsgFac () ("smallEffProdWmsg",
         myGlobalComp ()->expCutoff (),
         WitGlobalComp::defExpCutoff (),
         minAccEffProd,
         minAccBopEnt->myOperationName (),
         minAccBopEnt->localIndex (),
         minAccPer);
   }
d960 2
a961 1
//------------------------------------------------------------------------------
d963 2
a964 3
void WitPreprocessor::sortBopEntries ()
   {
   WitPart * thePart;
d966 2
a967 1
   WitDenseList <WitBopEntry> sortedBopEntries;
d969 2
a970 1
   sortedBopEntries.resize (myCompMgr ()->nBopEntries ());
d972 1
a972 3
   forEachPart (thePart, myProblem ())
      if (! orderedByAversion (thePart->producingBopEntries ()))
         sortByAversion (producingBopEntries_ (thePart), sortedBopEntries);
d977 1
a977 1
void WitPreprocessor::sortSubEntries ()
d979 7
a985 1
   WitBomEntry * theBomEnt;
d987 1
a987 1
   WitDenseList <WitSubEntry> sortedSubEntries;
d989 1
a989 1
   sortedSubEntries.resize (myCompMgr ()->nSubEntries ());
d991 4
a994 4
   forEachBomEntry (theBomEnt, myProblem ())
      if (! orderedByAversion (theBomEnt->mySubEntries ()))
         sortByAversion (mySubEntries_ (theBomEnt), sortedSubEntries);
   }
d996 9
a1004 1
//------------------------------------------------------------------------------
d1006 1
a1006 5
void WitPreprocessor::chooseExpBopEntries ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
d1008 1
a1008 1
   forEachPart (thePart, myProblem ())
d1010 1
a1010 2
      if (thePart->producingBopEntries ().isEmpty ())
         continue;
d1012 3
a1014 1
      expBopEntry_ (thePart).allocate (myProblem ());
d1016 3
a1018 5
      forEachPeriod (thePer, myProblem ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expEligible (thePer))
               {
               expBopEntry_ (thePart)[thePer] = theBopEnt;
d1020 1
a1020 3
               break;
               }
      }
d1025 1
a1025 1
void WitPreprocessor::findExpPerGaps ()
d1027 2
a1028 3
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;
d1030 1
a1030 3
   forEachPart (thePart, myProblem ())
      {
      expPerGaps_ (thePart) = witFALSE;
d1032 1
a1032 1
      thePart->getMaterial (theMat);
d1034 1
a1034 12
      if (theMat != NULL)
         if (! theMat->producingBopEntries ().isEmpty ())
            for (thePer = 1; thePer < nPeriods (); thePer ++)
               if (! theMat->explodeable (thePer))
                  if (theMat->explodeable (thePer - 1))
                     if (! theMat->mandEC ()[thePer - 1])
                        {
                        expPerGaps_ (theMat) = witTRUE;

                        break;
                        }
      }  
d1038 1
a1038 39
// findMandECs.
// Determines mandEC for each Material in theProblem.
//
// A Material theMat will have a mandEC in thePer, iff
// * There is a BopEntry producing theMat in thePer, and
// * The producing Operation incurs a mandEC in the corresponding exec period.
//
// An Operation, theOpn, can incur a mandEC for either of two reasons:
//
// Direct case:
//    A BomEntry, theBomEnt, in its BOM has a mandEC. In this case,
//    theOpn incurs a mandEC in periods
//    theBomEnt->earliestPeriod () - 1  and theBomEnt->latestPeriod (),
//    but not in lastPeriod ().
//
// Propagated case:
//    theOpn has a ConsEntry, theConsEnt, whose consumed Part is a
//    Material, theMat, that incurs a mandEC. In this case, let tImp be a
//    period in which theMat incurs a mandEC. theOpn incurs its
//    mandEC in the last period execPer, such that
//    theConsEnt->impactPeriod ()[execPer] <= tImp.
//    In other words, the mandEC occurs in the last period in which one can
//    execute theOpn by consuming theMat before or during its
//    mandEC. The mandEC periods, execPer, are found by iterating backwards on
//    tImp and then scanning backwards for execPer, starting with the last 
//    execPer found. This works, because the execPer value for a given tImp is
//    an upper bound on the execPer value of any lower tImp.
//
//    The purpose of the propagated case is to prevent obsolete material from
//    being implicitly stocked by building a product early. The propagation
//    logic implictly assumes that the impact periods of the BopEntries are a
//    non-decreasing function of the exec periods, i.e.,
//    t1 <= t2 ==> impactPeriod ()[t1] <= impactPeriod ()[t2]
//    If this assumption fails to hold, the mandECs generate might not
//    prevent obsolete material from being implicitly stocked, but this is a
//    pathological case.
//
// Note that the mandECs for Operations are not stored: As soon as one is
// found, the corresponding Material mandECs are generated.
d1041 2
a1042 1
void WitPreprocessor::findMandECs ()
d1044 1
a1044 2
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
d1046 1
a1046 2
   forEachBomEntry (theBomEnt, myProblem ())
      setDirectMandECs (theBomEnt);
d1048 2
a1049 5
   forEachBomEntry (theBomEnt, myProblem ())
      propMandECs (theBomEnt);

   forEachSubEntry (theSub, myProblem ())
      propMandECs (theSub);
d1054 1
a1054 1
void WitPreprocessor::setDirectMandECs (WitBomEntry * theBomEnt)
d1056 2
a1057 2
   if (! theBomEnt->mandEC ())
      return;
d1059 1
a1059 4
   if (theBomEnt->earliestPeriod () > 0)
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->earliestPeriod () - 1);
d1061 6
a1066 4
   if (theBomEnt->latestPeriod () < lastPeriod ())
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->latestPeriod ());
d1071 1
a1071 1
void WitPreprocessor::propMandECs (WitConsEntry * theConsEnt)
d1073 1
a1073 21
   WitMaterial * theMat;
   WitPeriod     execPer;
   WitPeriod     impactPer;

   theConsEnt->myPart ()->getMaterial (theMat);

   if (theMat == NULL)
      return;

   execPer = lastPeriod ();

   for (impactPer = lastPeriod (); impactPer >= 0; -- impactPer)
      if (theMat->mandEC ()[impactPer])
         for (; execPer >= 0; -- execPer)
            if (theConsEnt->inEffect (execPer))
               if (theConsEnt->impactPeriod ()[execPer] <= impactPer)
                  {
                  setMandECs (theConsEnt->myOperation (), execPer);

                  break;
                  }
d1078 1
a1078 1
void WitPreprocessor::setMandECs (WitOperation * theOpn, WitPeriod thePer)
d1080 3
a1082 16
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitPeriod     prodPer;

   forEachEl (theBopEnt, theOpn->bop ())
      {
      theBopEnt->myPart ()->getMaterial (theMat);

      if (theMat != NULL)
         if (theBopEnt->inEffect (thePer))
            {
            prodPer = theBopEnt->impactPeriod ()[thePer];

            mandEC_ (theMat).elemRef (prodPer) = witTRUE;
            }
      }
d1087 1
a1087 1
void WitPreprocessor::setIsCoproduced ()
d1089 1
d1092 2
a1093 4
   WitPeriod      execPer;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
d1096 1
a1096 1
      isCoproduced_ (thePart).setToScalar (witFALSE);
d1099 1
a1099 6
      forEachPeriod (execPer, myProblem ())
         if (theOpn->isCoproducing (execPer))
            {
            forEachEl (theBopEnt, theOpn->bop ())
               if (theBopEnt->productRate ()[execPer] > 0.0)
                  setCoprod (theBopEnt, execPer);
d1101 1
a1101 4
            forEachEl (theBomEnt, theOpn->bom ())
               {
               if (theBomEnt->consRate ()[execPer] < 0.0)
                  setCoprod (theBomEnt, execPer);
d1103 2
a1104 6
               forEachEl (theSub, theBomEnt->mySubEntries ())
                  if (theSub->consRate ()[execPer] < 0.0)
                     setCoprod (theSub, execPer);
               }
            }
   }
d1106 2
a1107 1
//------------------------------------------------------------------------------
d1109 2
a1110 3
void WitPreprocessor::setCoprod (WitBillEntry * theEnt, WitPeriod execPer)
   {
   WitPeriod impactPer;
d1112 2
a1113 2
   if (! theEnt->inEffect (execPer))
      return;
d1115 1
a1115 1
   impactPer = theEnt->impactPeriod ()[execPer];
d1117 2
a1118 1
   isCoproduced_ (theEnt->myPart ()).elemRef (impactPer) = witTRUE;
d1123 1
a1123 1
void WitPreprocessor::compExecPeriods ()
d1125 5
a1129 4
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
d1131 2
a1132 2
   if (execPeriodsComputed_)
      return;
d1134 2
a1135 2
   tempNExecPeriods_.allocate (myProblem (), 0);
   tempExecPeriod_  .allocate (myProblem ());
d1137 4
a1140 187
   forEachPeriod (thePer, myProblem ())
      tempExecPeriod_[thePer] = new WitVector <WitPeriod> (nPeriods (), 0);

   forEachBomEntry (theBomEnt, myProblem ())
      compExecPeriod (theBomEnt);

   forEachSubEntry (theSub, myProblem ())
      compExecPeriod (theSub);

   forEachBopEntry (theBopEnt, myProblem ())
      compExecPeriod (theBopEnt);

   forEachPeriod (thePer, myProblem ())
      delete tempExecPeriod_[thePer];

   tempNExecPeriods_.clear ();
   tempExecPeriod_  .clear ();

   execPeriodsComputed_ = witTRUE; 
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compExecPeriod (WitBillEntry * theBillEnt)
   {
   WitPeriod execPer;
   WitPeriod impactPer;
   int       localIdx;
   int       theEPIndex;
   int       totNExecPeriods;
      //
      // The length of execPeriod_ (theBillEnt).

   totNExecPeriods = 0;

   tempNExecPeriods_.setToScalar (0);

   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      if (theBillEnt->inEffect (execPer))
         {
         impactPer = theBillEnt->impactPeriod ()[execPer];

         ++ totNExecPeriods;

         localIdx = tempNExecPeriods_[impactPer] ++;

         tempExecPeriod_ (impactPer)[localIdx] = execPer;
         }

   firstEPIndex_ (theBillEnt).resize (nPeriods () + 1, 0);
   execPeriod_   (theBillEnt).resize (totNExecPeriods, 0);

   theEPIndex = 0;

   forEachPeriod (impactPer, myProblem ())
      {
      firstEPIndex_ (theBillEnt)[impactPer] = theEPIndex;

      for ( localIdx = 0; 
            localIdx < tempNExecPeriods_[impactPer]; 
            localIdx ++)

         execPeriod_ (theBillEnt)[theEPIndex ++] = 
            tempExecPeriod_ (impactPer)[localIdx];
      }

   firstEPIndex_ (theBillEnt)[nPeriods ()] = theEPIndex;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::unoptPreprocess ()
   {
   if (! optPreprocessed ())
      return;

   optPreprocessed_ = witFALSE;

   myOptImploder ()->unaccelerate ();

   myOptComp ()->heurOptStarter ()->beChosen ();
   }

//------------------------------------------------------------------------------
// Implementation of class NodeSorter.
//------------------------------------------------------------------------------

WitNodeSorter::WitNodeSorter (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitNodeSorter::~WitNodeSorter ()
   {
   }

//------------------------------------------------------------------------------

void WitNodeSorter::loadDataFrom (WitPart * thePart, int & sortedPartIndexArg)
   {
   sortedPartIndex_.setMapFor (thePart, sortedPartIndexArg);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::loadDataFromCompMgr (
      WitList    <WitPart>      & allPartsArg,
      WitList    <WitOperation> & allOperationsArg)
   {
   allParts_     .refTo (allPartsArg);
   allOperations_.refTo (allOperationsArg);
   }

//------------------------------------------------------------------------------

void WitNodeSorter::allocLoadedData ()
   {
   sortedPartIndex_.allocate (myProblem ());
   }

//------------------------------------------------------------------------------

void WitNodeSorter::clearLoadedData ()
   {
   allParts_       .clear ();
   allOperations_  .clear ();
   sortedPartIndex_.clear ();
   }

//------------------------------------------------------------------------------

void WitNodeSorter::sortNodesIfNeeded ()
   {
   int            nBefore;
   WitPart *      thePart;
   WitOperation * theOpn;

   successors_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      successors_.setMapFor (thePart, * new WitList <WitNode>);

   forEachOperation (theOpn, myProblem ())
      successors_.setMapFor (theOpn,  * new WitList <WitNode>);

   defineAllNodesSuccessors ();

   if (! nodesInOrder ())
      sortNodes ();

   forEachOperation (theOpn, myProblem ())
      delete & successors_ (theOpn);

   forEachPart (thePart, myProblem ())
      delete & successors_ (thePart);

   allNodes_  .clear ();
   successors_.clear ();

   nBefore = 0;

   forEachPart (thePart, myProblem ())
      sortedPartIndex_ (thePart) = nBefore ++;
   }

//------------------------------------------------------------------------------

void WitNodeSorter::defineAllNodesSuccessors ()
   {
   WitPart      * thePart;
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;
   WitSubEntry  * theSub;
   WitBopEntry  * theBopEnt;

   forEachPart (thePart, myProblem ())
      allNodes_.append (thePart);

   forEachOperation (theOpn, myProblem ())
      allNodes_.append (theOpn);

   forEachOperation (theOpn, myProblem ())
      {
      forEachEl (theBomEnt, theOpn->bom ())
         {
d1363 375
@


1.33
log
@Continued implementation of Single-Source.
@
text
@d16 1
d22 2
a26 1
#include <PtrVec.h>
a27 1
#include <Mapping.h>
a103 7
inline const WitList <WitNode> & WitPreprocessor::successors (WitNode * theNode)
   {
   return successorsVector_ (theNode->nodeIndex ());
   }

//------------------------------------------------------------------------------

a121 2
      successorsVector_    (* new WitPtrVec <WitList <WitNode> >),
      sorted_              (* new WitMapping <WitNode, WitBoolean>),
d125 2
a126 1
   myBelowLister_ = new WitBelowLister (myProblem (), belowList_);
a133 2
   delete & sorted_;
   delete & successorsVector_;
d135 1
d158 1
a158 1
   sortNodesIfNeeded ();
d245 7
a251 7
            WitPart *                  thePart,
            int                      & sortedPartIndexArg,
            WitFlexVec <WitBoolean>  & isCoproducedArg,
            WitBoolean               & expPerGapsArg,
            WitList    <WitBopEntry> & producingBopEntriesArg,
            WitPtrTVec <WitBopEntry> & expBopEntryArg,
            WitDenseList <WitPart>   & belowListArg)
a252 1
   sortedPartIndex_    .setMapFor (thePart, sortedPartIndexArg);
d257 3
a259 1
   belowList_          .setMapFor (thePart, belowListArg);
d326 1
a326 2
   allParts_     .refTo (allPartsArg);
   allOperations_.refTo (allOperationsArg);
a353 1
   sortedPartIndex_    .allocate (myProblem ());
a357 1
   belowList_          .allocate (myProblem ());
d367 3
a379 1
   sortedPartIndex_    .clear ();
a383 1
   belowList_          .clear ();
a391 2
   allParts_           .clear ();
   allOperations_      .clear ();
d393 3
d464 1
a464 1
void WitPreprocessor::sortNodesIfNeeded ()
d466 3
a468 3
   int       idx;
   int       nBefore;
   WitPart * thePart;
d470 1
a470 1
   successorsVector_.resize (myCompMgr ()->nNodes ());
d472 3
a474 2
   for (idx = 0; idx < myCompMgr ()->nNodes (); idx ++)
      successorsVector_[idx] = new WitList <WitNode>;
d476 3
a478 1
   defineAllNodesSuccessors ();
d480 3
a482 2
   if (! nodesInOrder ())
      sortNodes ();
d484 1
a484 2
   for (idx = 0; idx < myCompMgr ()->nNodes (); idx ++)
      delete successorsVector_[idx];
d486 3
a488 2
   allNodes_        .clear ();
   successorsVector_.clear ();
d490 3
a492 4
   nBefore = 0;

   forEachPart (thePart, myProblem ())
      sortedPartIndex_ (thePart) = nBefore ++;
d497 1
a497 1
void WitPreprocessor::defineAllNodesSuccessors ()
a498 1
   WitPart      * thePart;
d500 6
a505 3
   WitBomEntry  * theBomEnt;
   WitSubEntry  * theSub;
   WitBopEntry  * theBopEnt;
d507 2
a508 2
   forEachPart (thePart, myProblem ())
      allNodes_.append (thePart);
d510 1
a510 2
   forEachOperation (theOpn, myProblem ())
      allNodes_.append (theOpn);
d514 1
a514 1
      forEachEl (theBomEnt, theOpn->bom ())
d516 1
a516 2
         successorsVector_ (theBomEnt->myPart ()->nodeIndex ()).
            append (theOpn);
d518 2
a519 3
         forEachEl (theSub, theBomEnt->mySubEntries ())
            successorsVector_ (theSub->myPart ()->nodeIndex ()).
               append (theOpn);
d521 2
d525 2
a526 5
   forEachPart (thePart, myProblem ())
      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            successorsVector_ (theBopEnt->myOperation ()->nodeIndex ()).
               append (thePart);
d530 1
a530 3
// nodesInOrder.
// Returns TRUE, iff the Parts and Operations are already in order.
// Variables:
d532 6
a537 3
//    nBefore
//       nBefore (theNode) is the # of Nodes listed before theNode in allNodes_
//       This indicates the order of the Nodes in allNodes_.
d539 1
a539 3
//    nBeforeSuccs
//       nBeforeSuccs (theNode) is the minimum # of Nodes listed before
//       any successor to theNode.
d541 5
a545 10
// The Nodes are considered to be in order iff the Parts are in order and the
// Operations are in order. Since allNodes_ is just a temporary List, a Part
// is allowed to be out of order with respect to an Operation. Abstractly, this
// means that a Node should not be compared to its successors, which are of the
// opposite derived class (Part vs. Operation). Instead, a Node should be
// compared to the successors to its successors, which are of the same derived
// class. Specifically, the Nodes are out of order, iff there exists a Node,
// theNode and a successor to it, succNode, such that:
//
//    nBefore (theNode) >= nBeforeSuccs (succNode)
d548 3
a550 1
WitBoolean WitPreprocessor::nodesInOrder ()
d552 3
a554 2
   WitMapping <WitNode, int> nBefore      (myProblem (), 0);
   WitMapping <WitNode, int> nBeforeSuccs (myProblem (), 0);
d556 2
a557 3
   WitNode * theNode;
   WitNode * succNode;
   int nScanned;
d559 3
a561 1
   nScanned = 0;
d563 4
a566 2
   forEachEl (theNode, allNodes_)
      nBefore (theNode) = nScanned ++;
d568 6
a573 3
   forEachEl (theNode, allNodes_)
       {
       nBeforeSuccs (theNode) = myCompMgr ()->nNodes ();
d575 3
a577 4
       forEachEl (succNode, successors (theNode))
          nBeforeSuccs (theNode) =
             min (nBeforeSuccs (theNode), nBefore (succNode));
       }
d579 3
a581 4
   forEachEl (theNode, allNodes_)
       forEachEl (succNode, successors (theNode))
          if (nBefore (theNode) >= nBeforeSuccs (succNode))
             return witFALSE;
d587 22
d610 3
a612 1
void WitPreprocessor::sortNodes ()
d614 20
a633 3
   WitList <WitNode> sortedNodes;
      //
      // The sorted List of all Nodes.
d635 1
a635 3
   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;
d637 3
a639 1
   myMsgFac () ("sortNodesMsg");
d641 1
a641 1
   sorted_.allocate (myProblem (), witFALSE);
d643 2
a644 1
   sortNodes (sortedNodes);
d646 1
a646 2
   if (sortedNodes.nElements () != myCompMgr ()->nNodes ())
      constructCycle ();
d648 1
a648 3
   sorted_          .clear ();
   allParts_ ()     .clear ();
   allOperations_ ().clear ();
d650 2
a651 3
   forEachEl (theNode, sortedNodes)
      {     
      theNode->getPart (thePart);
d653 1
a653 2
      if (thePart != NULL)
         allParts_ ().append (thePart);
d655 3
a657 1
      theNode->getOperation (theOpn);
d659 4
a662 3
      if (theOpn != NULL)
         allOperations_ ().append (theOpn);
      }
d666 2
a667 1
// sortNodes.
d670 6
a675 8
//    nUnsortedPreds
//       nUnsortedPreds (theNode) is the # of BillEntries to predecessors to
//       theNode that have not yet been sorted. When this value is 0,
//       theNode is eligible to be sorted.
//
//    eligibleNodes
//       The list of all Nodes currently eligible to be sorted: those with
//       no unsorted predecessors.
d678 3
a680 1
void WitPreprocessor::sortNodes (WitList <WitNode> & sortedNodes)
d682 6
a687 1
   WitMapping <WitNode, int> nUnsortedPreds (myProblem (), 0);
d689 2
a690 1
   WitList <WitNode> eligibleNodes;
d692 1
a692 2
   WitNode * theNode;
   WitNode * succNode;
d694 1
a694 3
   forEachEl (theNode, allNodes_)
      forEachEl (succNode, successors (theNode))
         ++ nUnsortedPreds (succNode);
d696 3
a698 3
   forEachEl (theNode, allNodes_)
      if (nUnsortedPreds (theNode) == 0)
         eligibleNodes.append (theNode);
d700 1
a700 3
   while (! eligibleNodes.isEmpty ())
      {
      theNode = eligibleNodes.get ();
d702 2
a703 1
      sortedNodes.append (theNode);
d705 2
a706 1
      sorted_ (theNode) = witTRUE;
d708 1
a708 3
      forEachEl (succNode, successors (theNode))
         {
         -- nUnsortedPreds (succNode);
d710 1
a710 4
         if (nUnsortedPreds (succNode) == 0)
             eligibleNodes.append (succNode);
         }
      }
d714 6
a719 7
// constructCycle
// Variables:
//
//    scanned
//       scanned (theNode) is TRUE, iff theNode has already been scanned in
//       the search for a cycle. A cycle has been found when a Node gets
//       scanned twice.
d722 1
a722 1
void WitPreprocessor::constructCycle ()
d724 11
a734 1
   WitMapping <WitNode, WitBoolean> scanned (myProblem (), witFALSE);
d736 2
a737 4
   WitNode * theNode;
   WitPart * thePart;
   WitNode * succNode;
   WitNode * cycleStart;
d739 2
a740 1
   unsortedPredFor_.allocate (myProblem ());
d742 1
a742 4
   forEachEl (theNode, allNodes_)
      if (! sorted_ (theNode))
         forEachEl (succNode, successors (theNode))
            unsortedPredFor_ (succNode) = theNode;
d744 8
a751 3
   forEachEl (theNode, allNodes_)
      if (! sorted_ (theNode))
         break;
d753 1
a753 1
   while (! scanned (theNode))
d755 12
a766 1
      scanned (theNode) = witTRUE;
d768 5
a772 1
      theNode = unsortedPredFor_ (theNode);
d774 3
d778 4
a781 1
   theNode->getPart (thePart);
d783 1
a783 2
   if (thePart == NULL)
      theNode = unsortedPredFor_ (theNode);
d785 6
a790 1
   theNode->getPart (thePart);
d792 3
a794 4
   stronglyAssert (thePart != NULL);
      //
      // The cycle needs to begin with a Part, so that the error message
      // makes sense.
d796 1
a796 1
   cycleStart = theNode;
d798 6
a803 1
   myMsgFac () ("bomCycleHeadingSmsg");
d805 1
a805 1
   do
d807 15
a821 4
      myMsgFac () ("bomCycleNodesSmsg",
         theNode->nodeName (),
         unsortedPredFor_ (theNode)->nodeName (),
         unsortedPredFor_ (unsortedPredFor_ (theNode))->nodeName ());
d823 1
a823 1
      theNode = unsortedPredFor_ (unsortedPredFor_ (theNode));
a824 3
      while (theNode != cycleStart);

   myMsgFac () ("bomCycleSmsg");
d829 1
a829 1
void WitPreprocessor::truncateOffsets ()
a830 1
   WitBomEntry * theBomEnt;
a831 1
   WitBopEntry * theBopEnt;
d833 1
a833 1
   truncOffset_.allocate (myProblem (), 0.0);
d835 2
a836 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      truncateOffset (theBomEnt);
d838 1
a838 6
      forEachEl (theSub, theBomEnt->mySubEntries ())
         truncateOffset (theSub);
      }

   forEachBopEntry (theBopEnt, myProblem ())
      truncateOffset (theBopEnt);
d843 1
a843 1
void WitPreprocessor::truncateOffset (WitBillEntry * theBillEnt)
d847 8
a854 3
   forEachPeriod (thePer, myProblem ())
      truncOffset_ (theBillEnt)[thePer] =
         min ((float) thePer, theBillEnt->offset ()[thePer]);
d859 1
a859 1
void WitPreprocessor::roundOffsets ()
d861 1
d863 4
a866 1
   WitPeriod      thePer;
d868 2
a869 4
   WitTVec <float>      leadToImpact (myProblem (), 0.0);
   WitTVec <WitBoolean> hasImpact    (myProblem (), witFALSE);
      //
      // See updateProdCumLeads.
d871 2
a872 2
   if (myGlobalComp ()->truncOffsets ())
      truncateOffsets ();
d874 2
a875 1
   floatCumLead_.allocate (myProblem (), 0.0);
d877 1
a877 1
   forEachOperation (theOpn, myProblem ())
d879 17
a895 1
      forEachPeriod (thePer, myProblem ())
d897 7
a903 1
         executable_ (theOpn)[thePer] = roundOffsets (theOpn, thePer);
d905 1
a905 2
         if (! theOpn->executable ()[thePer])
            resetExec (theOpn, thePer);
a906 2

      updateProdCumLeads (theOpn, leadToImpact, hasImpact);
a907 3

   truncOffset_ .clear ();
   floatCumLead_.clear ();
d911 7
a917 16
// roundOffsets
//
// Computes impactPeriods for the BomEntries and BopEntries of theOpn in thePer.
// Also checks for the various conditions under which execution of
// theOpn is to be forbidden in thePer.
// If any such condition occurs, computation is terminated and FALSE
// is returned, indicating forbidden execution.
// Otherwise TRUE is returned.
//
// The conditions for forbidding execution are:
//
//   yieldRate         == 0.0
//   cycle time        < 0 (3.4 mode only)
//   release date      < 0 (3.4 mode only)
//   an impactPeriod   < 0, or >= nPeriods
//   execEmptyBom () is FALSE and no BomEntries are in effect in period t.
d920 1
a920 3
WitBoolean WitPreprocessor::roundOffsets (
      WitOperation * theOpn,
      WitPeriod      thePer)
d922 1
a922 3
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
d924 7
a930 2
   if (theOpn->yieldRate ()[thePer] == 0.0)
      return witFALSE;
d932 1
a932 3
   if (wit34Compatible ())
      if (theOpn->cycleTime34PreventsExec (thePer))
         return witFALSE;
d934 4
a937 4
   forEachEl (theBomEnt, theOpn->bom ())
      {
      if (! compImpactPeriod (theBomEnt, thePer))
         return witFALSE;
d939 1
a939 6
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (myGlobalComp ()->independentOffsets ())
            compImpactPeriod (theSub, thePer);
         else
            copyImpactPeriod (theSub, thePer);
      }
d941 2
a942 3
   forEachEl (theBopEnt, theOpn->bop ())
      if (! compImpactPeriod (theBopEnt, thePer))
         return witFALSE;
d944 4
a947 3
   if (! myGlobalComp ()->execEmptyBom ())
      if (! theOpn->hasBomEntryInEffect (thePer))
         return witFALSE;
d949 2
a950 1
   return witTRUE;
d954 53
a1006 21
// compImpactPeriod.
// Computes theConsEnt->impactPeriod_[thePer].
// If the resulting impactPeriod falls outside the time horizon, the
// computation is aborted and the function returns FALSE, indicating that
// execution of theConsEnt->myOperation () should be forbidden in thePer.
// Otherwise returns TRUE.
//
// An initial value for the impactPeriod is computed using a simple integer
// round down of the float workOffset ()[thePer]. The final value is computed by
// rounding the float lead time either up or down so as to have the right
// effect on cumulative lead time.
//
// Variables:
//
//    initImpactPeriod:   Initial value for impactPeriod
//    consFCLead:         The float cum lead time for the consumed Part.
//    propFCLead:         The proposed float cum lead time for the consuming
//                        Operation. The proposed value is taken iff it is
//                        larger than the current value.
//    leadTime:           The int lead time
//    finalImpactPeriod:  Final value for ImpactPeriod
d1009 1
a1009 3
WitBoolean WitPreprocessor::compImpactPeriod (
      WitConsEntry * theConsEnt,
      WitPeriod      thePer)
d1011 3
a1013 5
   WitPeriod initImpactPeriod;
   float     consFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod finalImpactPeriod;
d1015 1
a1015 1
   impactPeriod_ (theConsEnt)[thePer] = -1;
d1017 4
a1020 2
   if (! theConsEnt->withinInterval (thePer))
      return witTRUE;
d1022 1
a1022 1
   initImpactPeriod = thePer - ltRoundDown (workOffset (theConsEnt, thePer));
d1024 3
a1026 2
   if (initImpactPeriod < 0)
      return witFALSE;
d1028 1
a1028 2
   if (initImpactPeriod >= nPeriods ())
      return witFALSE;
d1030 1
a1030 1
   consFCLead = floatCumLead_ (theConsEnt->myPart ())[initImpactPeriod];
d1032 4
a1035 1
   propFCLead = consFCLead + workOffset (theConsEnt, thePer);
d1037 1
a1037 3
   leadTime =
        ltRoundDown (propFCLead)
      - ltRoundDown (consFCLead);
d1039 5
a1043 1
   finalImpactPeriod = thePer - leadTime;
d1045 4
a1048 2
   if (finalImpactPeriod < 0)
      return witFALSE;
d1050 1
a1050 1
   impactPeriod_ (theConsEnt)[thePer] = finalImpactPeriod;
d1052 5
a1056 1
   setToMax (floatCumLead_ (theConsEnt->myOperation ())[thePer], propFCLead);
d1058 3
a1060 1
   return witTRUE;
d1065 1
a1065 1
void WitPreprocessor::copyImpactPeriod (WitSubEntry * theSub, WitPeriod thePer)
d1067 18
a1084 1
   impactPeriod_ (theSub)[thePer] = -1;
d1086 3
a1088 4
   if (theSub->myBomEnt ()->inEffect (thePer))
      if (theSub->withinInterval (thePer))
         impactPeriod_ (theSub)[thePer] = 
            theSub->myBomEnt ()->impactPeriod ()[thePer];
d1092 27
a1118 1
// compImpactPeriod for a BopEntry.
d1120 8
a1127 1
// Variables:
d1129 2
a1130 6
//    opnFCLead:        The float cum lead time for the producing Operation:
//    propFCLead:       The proposed float cum lead time for the produced
//                      Part. The proposed value is taken iff it is larger
//                      than the current value.
//    leadTime:         The int lead time
//    theImpactPeriod:  The impactPeriod
d1133 1
a1133 3
WitBoolean WitPreprocessor::compImpactPeriod (
      WitBopEntry * theBopEnt,
      WitPeriod     thePer)
d1135 2
a1136 4
   float     opnFCLead;
   float     propFCLead;
   int       leadTime;
   WitPeriod theImpactPeriod;
d1138 2
a1139 1
   impactPeriod_ (theBopEnt)[thePer] = -1;
d1141 2
a1142 2
   if (! theBopEnt->withinInterval (thePer))
      return witTRUE;
d1144 3
a1146 1
   opnFCLead  = floatCumLead_ (theBopEnt->myOperation ())[thePer];
d1148 1
a1148 1
   propFCLead = opnFCLead - workOffset (theBopEnt, thePer);
d1150 4
a1153 3
   leadTime =
        ltRoundDown (opnFCLead)
      - ltRoundDown (propFCLead);
d1155 4
a1158 1
   theImpactPeriod = thePer - leadTime;
d1160 4
a1163 9
   if (theImpactPeriod < 0)
      return witFALSE;

   if (theImpactPeriod >= nPeriods ())
      return witFALSE;

   impactPeriod_ (theBopEnt)[thePer] = theImpactPeriod;

   return witTRUE;
d1168 1
a1168 1
int WitPreprocessor::ltRoundDown (float leadTime)
d1170 3
a1172 2
   return (int) floor (leadTime + 1.0E-3);
   }
d1174 1
a1174 1
//------------------------------------------------------------------------------
d1176 2
a1177 5
void WitPreprocessor::resetExec (WitOperation * theOpn, WitPeriod thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
d1179 1
a1179 3
   forEachEl (theBomEnt, theOpn->bom ())
      {
      impactPeriod_ (theBomEnt)[thePer] = -1;
d1181 7
a1187 3
      forEachEl (theSub, theBomEnt->mySubEntries ())
         impactPeriod_ (theSub)[thePer] = -1;
      }
d1189 2
a1190 4
   forEachEl (theBopEnt, theOpn->bop ())
      impactPeriod_ (theBopEnt)[thePer] = -1;

   floatCumLead_ (theOpn)[thePer] = 0.0;
d1195 1
a1195 4
void WitPreprocessor::updateProdCumLeads (
      WitOperation *         theOpn,
      WitTVec <float> &      leadToImpact,
      WitTVec <WitBoolean> & hasImpact)
d1197 1
d1199 1
a1199 2
   WitPeriod     thePer;
   WitPeriod     theImpactPer;
d1203 1
a1203 1
      hasImpact.setToScalar (witFALSE);
d1205 1
a1205 1
      forEachPeriod (thePer, myProblem ())
d1208 1
a1208 1
            theImpactPer               = theBopEnt->impactPeriod ()[thePer];
d1210 1
a1210 4
            hasImpact[theImpactPer]    = witTRUE;

            leadToImpact[theImpactPer] = 
               floatCumLead_ (theOpn)[thePer] - workOffset (theBopEnt, thePer);
a1211 6

      forEachPeriod (theImpactPer, myProblem ())
         if (hasImpact[theImpactPer])
            setToMax (
               floatCumLead_ (theBopEnt->myPart ())[theImpactPer],
               leadToImpact[theImpactPer]);
d1217 1
a1217 1
void WitPreprocessor::compLotSizesExist ()
d1219 1
d1221 4
a1224 1
   WitPeriod      thePer;
d1226 2
a1227 1
   lotSizesExist_ () = witFALSE;
d1230 2
a1231 3
      forEachPeriod (thePer, myProblem ())
         if ((theOpn->minLotSize ()[thePer] > 0.0) ||
             (theOpn->incLotSize ()[thePer] > 0.0)   )
d1233 8
a1240 1
            lotSizesExist_ () = witTRUE;
d1242 4
a1245 1
            return;
d1251 1
a1251 1
void WitPreprocessor::compHasSubsInEffect ()
d1253 1
a1253 4
   WitBomEntry *        theBomEnt;
   WitPeriod            thePer;
   WitSubEntry *        theSub;
   WitTVec <WitBoolean> hasSubsInEffectVal (myProblem (), witFALSE);
d1255 2
a1256 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      hasSubsInEffect_ (theBomEnt).setToScalar (witFALSE);
d1258 1
a1258 2
      if (theBomEnt->mySubEntries ().isEmpty ())
         continue;
d1260 1
a1260 13
      hasSubsInEffectVal.setToScalar (witFALSE);

      forEachPeriod (thePer, myProblem ())
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->inEffect (thePer))
               {
               hasSubsInEffectVal[thePer] = witTRUE;

               break;
               }

      hasSubsInEffect_ (theBomEnt).copyTVec (hasSubsInEffectVal);
      }
d1265 1
a1265 1
void WitPreprocessor::preprocess (WitBomEntry * theBomEnt)
d1267 1
d1269 11
d1281 2
a1282 1
   compEffConsRate (theBomEnt);
d1284 2
a1285 2
   forEachEl (theSub, theBomEnt->mySubEntries ())
      compEffConsRate (theSub);
d1287 2
a1288 2
   checkMinLotSize (theBomEnt);
   }
d1290 2
a1291 1
//------------------------------------------------------------------------------
d1293 2
a1294 3
void WitPreprocessor::compEffConsRate (WitConsEntry * theConsEnt)
   {
   WitPeriod thePer;
d1296 1
a1296 8
   if (theConsEnt->consRate ().repIsByVec ())
      forEachPeriod (thePer, myProblem ())
         effConsRate_ (theConsEnt).elemRef (thePer) =
              theConsEnt->consRate ()[thePer] 
            / (1.0 - theConsEnt->falloutRate ());
   else
      effConsRate_ (theConsEnt).setToScalar (
         theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ()));
d1301 1
a1301 1
void WitPreprocessor::checkMinLotSize (WitBomEntry * theBomEnt)
d1303 7
a1309 6
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      execPer; // Execution period.
   WitPeriod      tCons;   // Consumption period.
   float          avail;   // Availability.
   float          minCons; // Consumption for minLotSize.
d1311 1
a1311 2
   if (! myGlobalComp ()->lotSizesExist ())
      return;
d1313 1
a1313 2
   thePart = theBomEnt->myPart ();
   theOpn  = theBomEnt->myOperation ();
d1315 4
a1318 2
   if (! thePart->isaCapacity ())
      return;
d1320 1
a1320 4
   forEachPeriod (execPer, myProblem ())
      {
      if (! theBomEnt->inEffect (execPer))
         continue;
d1322 1
a1322 2
      if (theOpn->minLotSize ()[execPer] == 0.0)
         continue;
d1324 2
a1325 1
      tCons = theBomEnt->impactPeriod ()[execPer];
d1327 2
a1328 1
      avail = thePart->supplyVol ()[tCons];
d1330 1
a1330 2
      if (avail == 0.0)
         continue;
d1332 3
a1334 2
      minCons = 
         theOpn->minLotSize ()[execPer] * theBomEnt->effConsRate ()[execPer];
d1336 3
a1338 9
      if (minCons > avail + FLOAT_EPSILON)
         {
         myMsgFac () ("minLotSizeTooLargeWmsg",
            theOpn->operationName (),
            execPer,
            minCons,
            thePart->partName (),
            tCons,
            avail);
d1340 2
a1341 2
         return;
         }
a1342 35
   }

//------------------------------------------------------------------------------

void WitPreprocessor::preprocess (WitBopEntry * theBopEnt)
   {
   compEffProdRate      (theBopEnt);
   chooseExpExecPeriods (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compEffProdRate (WitBopEntry * theBopEnt)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      effProdRate_ (theBopEnt)[thePer] =
         theBopEnt->inEffect (thePer)?
              theBopEnt->productRate ()[thePer]
            * theBopEnt->myOperation ()->yieldRate ()[thePer]:
            0.0;
   }

//------------------------------------------------------------------------------

void WitPreprocessor::chooseExpExecPeriods (WitBopEntry * theBopEnt)
   {
   WitPeriod execPer;
   WitPeriod prodPer;

   expExecPeriod_ (theBopEnt).setToScalar (-1);

   if (! theBopEnt->expAllowed ())
      return;
d1344 1
a1344 7
   forEachPeriod (execPer, myProblem ())
      if (theBopEnt->execPerOKForExp (execPer))
         {
         prodPer = theBopEnt->impactPeriod ()[execPer];

         expExecPeriod_ (theBopEnt)[prodPer] = execPer;
         }
d1349 1
a1349 1
void WitPreprocessor::checkSmallEffProdRates ()
d1351 2
a1352 8
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   float         minAccEffProd;
   WitBopEntry * minAccBopEnt;
   WitPeriod     minAccPer;
   float         maxRejEffProd;
   WitBopEntry * maxRejBopEnt;
   WitPeriod     maxRejPer;
d1354 1
a1354 2
   minAccEffProd = WitGlobalComp::defExpCutoff ();
   maxRejEffProd = 0.0;
d1356 1
a1356 19
   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               {
               if (theBopEnt->effProdRate ()[execPer] < minAccEffProd)
                  {
                  minAccEffProd = theBopEnt->effProdRate ()[execPer];
                  minAccBopEnt  = theBopEnt;
                  minAccPer     = execPer;
                  }
               }
            else 
               if (theBopEnt->effProdRate ()[execPer] > maxRejEffProd)
                  {
                  maxRejEffProd = theBopEnt->effProdRate ()[execPer];
                  maxRejBopEnt  = theBopEnt;
                  maxRejPer     = execPer;
                  }
d1358 1
a1358 16
   if (maxRejEffProd > 0.0)
      myMsgFac () ("rejBopEntWmsg",
         myGlobalComp ()->expCutoff (),
         maxRejEffProd,
         maxRejBopEnt->myOperationName (),
         maxRejBopEnt->localIndex (),
         maxRejPer);

   if (minAccEffProd < WitGlobalComp::defExpCutoff ())
      myMsgFac () ("smallEffProdWmsg",
         myGlobalComp ()->expCutoff (),
         WitGlobalComp::defExpCutoff (),
         minAccEffProd,
         minAccBopEnt->myOperationName (),
         minAccBopEnt->localIndex (),
         minAccPer);
d1362 2
d1365 2
a1366 1
void WitPreprocessor::sortBopEntries ()
d1368 1
a1368 1
   WitPart * thePart;
d1370 1
a1370 1
   WitDenseList <WitBopEntry> sortedBopEntries;
d1372 2
a1373 5
   sortedBopEntries.resize (myCompMgr ()->nBopEntries ());

   forEachPart (thePart, myProblem ())
      if (! orderedByAversion (thePart->producingBopEntries ()))
         sortByAversion (producingBopEntries_ (thePart), sortedBopEntries);
d1378 1
a1378 1
void WitPreprocessor::sortSubEntries ()
d1380 2
a1381 1
   WitBomEntry * theBomEnt;
d1383 1
a1383 1
   WitDenseList <WitSubEntry> sortedSubEntries;
d1385 6
a1390 5
   sortedSubEntries.resize (myCompMgr ()->nSubEntries ());

   forEachBomEntry (theBomEnt, myProblem ())
      if (! orderedByAversion (theBomEnt->mySubEntries ()))
         sortByAversion (mySubEntries_ (theBomEnt), sortedSubEntries);
d1395 1
a1395 1
void WitPreprocessor::chooseExpBopEntries ()
d1397 2
a1398 3
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
d1400 1
a1400 4
   forEachPart (thePart, myProblem ())
      {
      if (thePart->producingBopEntries ().isEmpty ())
         continue;
d1402 5
a1406 11
      expBopEntry_ (thePart).allocate (myProblem ());

      forEachPeriod (thePer, myProblem ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expEligible (thePer))
               {
               expBopEntry_ (thePart)[thePer] = theBopEnt;

               break;
               }
      }
d1411 1
a1411 1
void WitPreprocessor::findExpPerGaps ()
d1413 5
a1417 3
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;
d1420 1
a1420 2
      {
      expPerGaps_ (thePart) = witFALSE;
d1422 2
a1423 1
      thePart->getMaterial (theMat);
d1425 1
a1425 8
      if (theMat != NULL)
         if (! theMat->producingBopEntries ().isEmpty ())
            for (thePer = 1; thePer < nPeriods (); thePer ++)
               if (! theMat->explodeable (thePer))
                  if (theMat->explodeable (thePer - 1))
                     if (! theMat->mandEC ()[thePer - 1])
                        {
                        expPerGaps_ (theMat) = witTRUE;
d1427 2
a1428 4
                        break;
                        }
      }  
   }
d1430 2
a1431 41
//------------------------------------------------------------------------------
// findMandECs.
// Determines mandEC for each Material in theProblem.
//
// A Material theMat will have a mandEC in thePer, iff
// * There is a BopEntry producing theMat in thePer, and
// * The producing Operation incurs a mandEC in the corresponding exec period.
//
// An Operation, theOpn, can incur a mandEC for either of two reasons:
//
// Direct case:
//    A BomEntry, theBomEnt, in its BOM has a mandEC. In this case,
//    theOpn incurs a mandEC in periods
//    theBomEnt->earliestPeriod () - 1  and theBomEnt->latestPeriod (),
//    but not in lastPeriod ().
//
// Propagated case:
//    theOpn has a ConsEntry, theConsEnt, whose consumed Part is a
//    Material, theMat, that incurs a mandEC. In this case, let tImp be a
//    period in which theMat incurs a mandEC. theOpn incurs its
//    mandEC in the last period execPer, such that
//    theConsEnt->impactPeriod ()[execPer] <= tImp.
//    In other words, the mandEC occurs in the last period in which one can
//    execute theOpn by consuming theMat before or during its
//    mandEC. The mandEC periods, execPer, are found by iterating backwards on
//    tImp and then scanning backwards for execPer, starting with the last 
//    execPer found. This works, because the execPer value for a given tImp is
//    an upper bound on the execPer value of any lower tImp.
//
//    The purpose of the propagated case is to prevent obsolete material from
//    being implicitly stocked by building a product early. The propagation
//    logic implictly assumes that the impact periods of the BopEntries are a
//    non-decreasing function of the exec periods, i.e.,
//    t1 <= t2 ==> impactPeriod ()[t1] <= impactPeriod ()[t2]
//    If this assumption fails to hold, the mandECs generate might not
//    prevent obsolete material from being implicitly stocked, but this is a
//    pathological case.
//
// Note that the mandECs for Operations are not stored: As soon as one is
// found, the corresponding Material mandECs are generated.
//------------------------------------------------------------------------------
d1433 2
a1434 4
void WitPreprocessor::findMandECs ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
d1436 2
a1437 2
   forEachBomEntry (theBomEnt, myProblem ())
      setDirectMandECs (theBomEnt);
d1439 1
a1439 2
   forEachBomEntry (theBomEnt, myProblem ())
      propMandECs (theBomEnt);
d1441 2
a1442 2
   forEachSubEntry (theSub, myProblem ())
      propMandECs (theSub);
d1447 1
a1447 1
void WitPreprocessor::setDirectMandECs (WitBomEntry * theBomEnt)
d1449 5
a1453 2
   if (! theBomEnt->mandEC ())
      return;
d1455 2
a1456 4
   if (theBomEnt->earliestPeriod () > 0)
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->earliestPeriod () - 1);
d1458 2
a1459 5
   if (theBomEnt->latestPeriod () < lastPeriod ())
      setMandECs (
         theBomEnt->myOperation (),
         theBomEnt->latestPeriod ());
   }
d1461 5
a1465 1
//------------------------------------------------------------------------------
d1467 4
a1470 5
void WitPreprocessor::propMandECs (WitConsEntry * theConsEnt)
   {
   WitMaterial * theMat;
   WitPeriod     execPer;
   WitPeriod     impactPer;
d1472 5
a1476 1
   theConsEnt->myPart ()->getMaterial (theMat);
d1478 24
a1501 2
   if (theMat == NULL)
      return;
d1503 4
a1506 1
   execPer = lastPeriod ();
d1508 3
a1510 7
   for (impactPer = lastPeriod (); impactPer >= 0; -- impactPer)
      if (theMat->mandEC ()[impactPer])
         for (; execPer >= 0; -- execPer)
            if (theConsEnt->inEffect (execPer))
               if (theConsEnt->impactPeriod ()[execPer] <= impactPer)
                  {
                  setMandECs (theConsEnt->myOperation (), execPer);
d1512 1
a1512 3
                  break;
                  }
   }
d1514 2
a1515 1
//------------------------------------------------------------------------------
d1517 3
a1519 5
void WitPreprocessor::setMandECs (WitOperation * theOpn, WitPeriod thePer)
   {
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitPeriod     prodPer;
d1521 4
a1524 3
   forEachEl (theBopEnt, theOpn->bop ())
      {
      theBopEnt->myPart ()->getMaterial (theMat);
d1526 4
a1529 4
      if (theMat != NULL)
         if (theBopEnt->inEffect (thePer))
            {
            prodPer = theBopEnt->impactPeriod ()[thePer];
d1531 1
a1531 3
            mandEC_ (theMat).elemRef (prodPer) = witTRUE;
            }
      }
d1536 1
a1536 1
void WitPreprocessor::setIsCoproduced ()
d1538 5
a1544 4
   WitPeriod      execPer;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
d1546 1
a1546 2
   forEachPart (thePart, myProblem ())
      isCoproduced_ (thePart).setToScalar (witFALSE);
d1548 1
a1548 7
   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theOpn->isCoproducing (execPer))
            {
            forEachEl (theBopEnt, theOpn->bop ())
               if (theBopEnt->productRate ()[execPer] > 0.0)
                  setCoprod (theBopEnt, execPer);
d1550 1
a1550 4
            forEachEl (theBomEnt, theOpn->bom ())
               {
               if (theBomEnt->consRate ()[execPer] < 0.0)
                  setCoprod (theBomEnt, execPer);
d1552 2
a1553 6
               forEachEl (theSub, theBomEnt->mySubEntries ())
                  if (theSub->consRate ()[execPer] < 0.0)
                     setCoprod (theSub, execPer);
               }
            }
   }
d1555 3
a1557 1
//------------------------------------------------------------------------------
d1559 3
a1561 3
void WitPreprocessor::setCoprod (WitBillEntry * theEnt, WitPeriod execPer)
   {
   WitPeriod impactPer;
d1563 2
a1564 2
   if (! theEnt->inEffect (execPer))
      return;
d1566 1
a1566 1
   impactPer = theEnt->impactPeriod ()[execPer];
d1568 3
a1570 1
   isCoproduced_ (theEnt->myPart ()).elemRef (impactPer) = witTRUE;
d1574 12
d1587 1
a1587 1
void WitPreprocessor::compExecPeriods ()
d1589 1
a1589 4
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
d1591 1
a1591 2
   if (execPeriodsComputed_)
      return;
d1593 2
a1594 2
   tempNExecPeriods_.allocate (myProblem (), 0);
   tempExecPeriod_  .allocate (myProblem ());
d1596 3
a1598 2
   forEachPeriod (thePer, myProblem ())
      tempExecPeriod_[thePer] = new WitVector <WitPeriod> (nPeriods (), 0);
d1600 3
a1602 2
   forEachBomEntry (theBomEnt, myProblem ())
      compExecPeriod (theBomEnt);
d1604 3
a1606 2
   forEachSubEntry (theSub, myProblem ())
      compExecPeriod (theSub);
d1608 1
a1608 2
   forEachBopEntry (theBopEnt, myProblem ())
      compExecPeriod (theBopEnt);
d1610 1
a1610 2
   forEachPeriod (thePer, myProblem ())
      delete tempExecPeriod_[thePer];
d1612 3
a1614 2
   tempNExecPeriods_.clear ();
   tempExecPeriod_  .clear ();
d1616 4
a1619 1
   execPeriodsComputed_ = witTRUE; 
d1623 8
d1632 1
a1632 1
void WitPreprocessor::compExecPeriod (WitBillEntry * theBillEnt)
d1634 1
a1634 7
   WitPeriod execPer;
   WitPeriod impactPer;
   int       localIdx;
   int       theEPIndex;
   int       totNExecPeriods;
      //
      // The length of execPeriod_ (theBillEnt).
d1636 4
a1639 1
   totNExecPeriods = 0;
d1641 1
a1641 1
   tempNExecPeriods_.setToScalar (0);
d1643 4
a1646 4
   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      if (theBillEnt->inEffect (execPer))
         {
         impactPer = theBillEnt->impactPeriod ()[execPer];
d1648 3
a1650 1
         ++ totNExecPeriods;
d1652 3
a1654 1
         localIdx = tempNExecPeriods_[impactPer] ++;
d1656 2
a1657 2
         tempExecPeriod_ (impactPer)[localIdx] = execPer;
         }
d1659 1
a1659 2
   firstEPIndex_ (theBillEnt).resize (nPeriods () + 1, 0);
   execPeriod_   (theBillEnt).resize (totNExecPeriods, 0);
d1661 2
a1662 1
   theEPIndex = 0;
d1664 1
a1664 3
   forEachPeriod (impactPer, myProblem ())
      {
      firstEPIndex_ (theBillEnt)[impactPer] = theEPIndex;
d1666 4
a1669 3
      for ( localIdx = 0; 
            localIdx < tempNExecPeriods_[impactPer]; 
            localIdx ++)
d1671 1
a1671 3
         execPeriod_ (theBillEnt)[theEPIndex ++] = 
            tempExecPeriod_ (impactPer)[localIdx];
      }
d1673 1
a1673 2
   firstEPIndex_ (theBillEnt)[nPeriods ()] = theEPIndex;
   }
d1675 6
a1680 1
//------------------------------------------------------------------------------
d1682 3
a1684 4
void WitPreprocessor::unoptPreprocess ()
   {
   if (! optPreprocessed ())
      return;
d1686 1
a1686 5
   optPreprocessed_ = witFALSE;

   myOptImploder ()->unaccelerate ();

   myOptComp ()->heurOptStarter ()->beChosen ();
d1697 1
a1697 3
WitBelowLister::WitBelowLister (
         WitProblem *                                   theProblem,
         WitRefMap <WitPart, WitDenseList <WitPart> > & belowListArg):
a1700 1
      belowList_      (belowListArg),
d1711 23
@


1.32
log
@Continued implementation of Single-Source.
@
text
@a25 1
#include <Dense.h>
d1663 1
a1663 1
      belowCurrent_   (* new WitDenseList <WitPart>)
a1670 1
   delete & belowCurrent_;
@


1.31
log
@Continued implementation of single-source.
@
text
@d28 1
a28 1
#include <Schedule.h>
a126 1
      myBelowLister_       (NULL),
a130 2
      truncOffset_         (* new WitSchedule <WitBillEntry, float>),
      floatCumLead_        (* new WitSchedule <WitNode, float>),
a141 2
   delete & floatCumLead_;
   delete & truncOffset_;
@


1.30
log
@Continued implementation of single-source.
@
text
@d117 1
a117 1
         truncOffset_ (theBillEnt, thePer):
d782 1
a782 1
      truncOffset_ (theBillEnt, thePer) =
a810 1

d924 1
a924 1
   consFCLead = floatCumLead_ (theConsEnt->myPart (), initImpactPeriod);
d939 1
a939 1
   setToMax (floatCumLead_ (theConsEnt->myOperation (), thePer), propFCLead);
d1030 1
a1030 1
   floatCumLead_ (theOpn, thePer) = 0.0;
d1056 1
a1056 1
               floatCumLead_ (theOpn, thePer) - workOffset (theBopEnt, thePer);
@


1.29
log
@Continued implementation of single-source.
@
text
@a126 19
      sortedPartIndex_     (),
      isCoproduced_        (),
      expPerGaps_          (),
      producingBopEntries_ (),
      expBopEntry_         (),
      belowList_           (),
      mandEC_              (),
      executable_          (),
      impactPeriod_        (),
      firstEPIndex_        (),
      execPeriod_          (),
      effConsRate_         (),
      hasSubsInEffect_     (),
      mySubEntries_        (),
      expExecPeriod_       (),
      effProdRate_         (),
      allParts_            (),
      allOperations_       (),
      lotSizesExist_       (),
a129 1
      allNodes_            (),
a131 1
      unsortedPredFor_     (),
a134 1
      tempNExecPeriods_    (),
@


1.28
log
@Continued implementation of single-source.
@
text
@d29 2
d127 19
a145 1
      myAccFlag_           (new WitAccFlag),
d159 1
a159 1
   myBelowLister_ = new WitBelowLister (myProblem (), myAccFlag_);
a170 1
   delete   myAccFlag_;
d190 2
d223 2
d235 2
d241 6
d252 3
d265 1
a265 6
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
d274 80
a353 1
   lotSizesExist (myGlobalComp ()) = witFALSE;
d355 17
a371 3
   forEachPart (thePart, myProblem ())
      {
      expBopEntry (thePart).clear ();
d373 1
a373 2
      isCoproduced (thePart).setToScalar (witFALSE);
      }
d375 8
a382 2
   forEachMaterial (theMat, myProblem ())
      mandEC (theMat).setToScalar (witFALSE);
d384 1
a384 2
   forEachOperation (theOpn, myProblem ())
      executable (theOpn).setToScalar (witFALSE);
d386 3
a388 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      unpreprocessConsEntry (theBomEnt);
d390 14
a403 1
      hasSubsInEffect (theBomEnt).setToScalar (witFALSE);
d405 2
a406 2
      nonSubVol       (theBomEnt).setToScalar (0.0);
      }
d408 2
a409 2
   forEachSubEntry (theSub, myProblem ())
      unpreprocessConsEntry (theSub);
d411 1
a411 3
   forEachBopEntry (theBopEnt, myProblem ())
      {
      unpreprocessBillEntry (theBopEnt);
d413 19
a431 3
      expExecPeriod (theBopEnt).setToScalar (-1);
      effProdRate   (theBopEnt).setToScalar  (0.0);
      }
d525 1
a525 1
      sortedPartIndex (thePart) = nBefore ++;
d641 3
a643 3
   sorted_                     .clear ();
   allParts      (myCompMgr ()).clear ();
   allOperations (myCompMgr ()).clear ();
d650 1
a650 1
         allParts      (myCompMgr ()).append (thePart);
d655 1
a655 1
         allOperations (myCompMgr ()).append (theOpn);
d829 1
a829 1
         executable (theOpn)[thePer] = roundOffsets (theOpn, thePer);
d934 1
a934 1
   impactPeriod (theConsEnt)[thePer] = -1;
d960 1
a960 1
   impactPeriod (theConsEnt)[thePer] = finalImpactPeriod;
d971 1
a971 1
   impactPeriod (theSub)[thePer] = -1;
d975 1
a975 1
         impactPeriod (theSub)[thePer] = 
d1001 1
a1001 1
   impactPeriod (theBopEnt)[thePer] = -1;
d1022 1
a1022 1
   impactPeriod (theBopEnt)[thePer] = theImpactPeriod;
d1044 1
a1044 1
      impactPeriod (theBomEnt)[thePer] = -1;
d1047 1
a1047 1
         impactPeriod (theSub)[thePer] = -1;
d1051 1
a1051 1
      impactPeriod (theBopEnt)[thePer] = -1;
d1097 1
a1097 1
   lotSizesExist (myGlobalComp ()) = witFALSE;
d1104 1
a1104 1
            lotSizesExist (myGlobalComp ()) = witTRUE;
d1121 1
a1121 1
      hasSubsInEffect (theBomEnt).setToScalar (witFALSE);
d1137 1
a1137 1
      hasSubsInEffect (theBomEnt).copyTVec (hasSubsInEffectVal);
d1163 1
a1163 1
         effConsRate (theConsEnt).elemRef (thePer) =
d1167 1
a1167 1
      effConsRate (theConsEnt).setToScalar (
d1239 1
a1239 1
      effProdRate (theBopEnt)[thePer] =
d1253 1
a1253 1
   expExecPeriod (theBopEnt).setToScalar (-1);
d1263 1
a1263 1
         expExecPeriod (theBopEnt)[prodPer] = execPer;
d1333 1
a1333 1
         sortByAversion (producingBopEntries (thePart), sortedBopEntries);
d1348 1
a1348 1
         sortByAversion (mySubEntries (theBomEnt), sortedSubEntries);
d1364 1
a1364 1
      expBopEntry (thePart).allocate (myProblem ());
d1370 1
a1370 1
               expBopEntry (thePart)[thePer] = theBopEnt;
d1387 1
a1387 1
      expPerGaps (thePart) = witFALSE;
d1398 1
a1398 1
                        expPerGaps (theMat) = witTRUE;
d1524 1
a1524 1
            mandEC (theMat).elemRef (prodPer) = witTRUE;
d1541 1
a1541 1
      isCoproduced (thePart).setToScalar (witFALSE);
d1574 1
a1574 1
   isCoproduced (theEnt->myPart ()).elemRef (impactPer) = witTRUE;
d1623 1
a1623 1
      // The length of execPeriod (theBillEnt).
d1641 2
a1642 2
   firstEPIndex (theBillEnt).resize (nPeriods () + 1, 0);
   execPeriod   (theBillEnt).resize (totNExecPeriods, 0);
d1648 1
a1648 1
      firstEPIndex (theBillEnt)[impactPer] = theEPIndex;
d1654 1
a1654 1
         execPeriod (theBillEnt)[theEPIndex ++] = 
d1658 1
a1658 1
   firstEPIndex (theBillEnt)[nPeriods ()] = theEPIndex;
a1675 19

void WitPreprocessor::unpreprocessConsEntry (WitConsEntry * theConsEnt)
   {
   unpreprocessBillEntry (theConsEnt);

   effConsRate (theConsEnt).setToScalar (0.0);
   }

//------------------------------------------------------------------------------

void WitPreprocessor::unpreprocessBillEntry (WitBillEntry * theBillEnt)
   {
   impactPeriod (theBillEnt).setToScalar (-1);

   firstEPIndex (theBillEnt).clear ();
   execPeriod   (theBillEnt).clear ();
   }

//------------------------------------------------------------------------------
d1684 2
a1685 2
         WitProblem * theProblem,
         WitAccFlag * theAccFlag):
d1689 1
a1689 1
      myAccFlag_      (theAccFlag),
d1774 1
a1774 1
   belowList (currentPart).resize (belowCurrent_.nElements ());
d1780 1
a1780 1
      belowList (currentPart).append (theBelowPart);
a1803 10
   }

//------------------------------------------------------------------------------

void WitBelowLister::unpreprocess ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      belowList (thePart).resize (0);
@


1.27
log
@Continued implementation of single-source.
@
text
@a124 1
      sortedNodes_         (),
d179 1
a179 1
   myGlobalComp ()->compLotSizesExist ();
d245 1
a245 1
   myGlobalComp ()->resetLotSizesExist ();
d471 8
d483 1
a483 1
   innerSortNodes ();
d485 1
a485 1
   if (sortedNodes_.nElements () != myCompMgr ()->nNodes ())
d488 7
a494 1
   sorted_.clear ();
d496 2
a497 1
   myCompMgr ()->importSortedNodes ();
d499 5
a503 1
   sortedNodes_.clear ();
d520 1
a520 1
void WitPreprocessor::innerSortNodes ()
d541 1
a541 1
      sortedNodes_.append (theNode);
d935 20
@


1.26
log
@Continued implementation of single source.
@
text
@d125 1
d180 1
a180 1
   compLotSizesExist ();
d246 1
a246 1
   lotSizesExist (myGlobalComp ()) = witFALSE;
a471 8
   WitList <WitNode> sortedNodes;
      //
      // The sorted List of all Nodes.

   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;

d476 1
a476 1
   sortNodes (sortedNodes);
d478 1
a478 1
   if (sortedNodes.nElements () != myCompMgr ()->nNodes ())
d481 1
a481 7
   sorted_                     .clear ();
   allParts      (myCompMgr ()).clear ();
   allOperations (myCompMgr ()).clear ();

   forEachEl (theNode, sortedNodes)
      {     
      theNode->getPart (thePart);
d483 1
a483 2
      if (thePart != NULL)
         allParts      (myCompMgr ()).append (thePart);
d485 1
a485 5
      theNode->getOperation (theOpn);

      if (theOpn != NULL)
         allOperations (myCompMgr ()).append (theOpn);
      }
d502 1
a502 1
void WitPreprocessor::sortNodes (WitList <WitNode> & sortedNodes)
d523 1
a523 1
      sortedNodes.append (theNode);
a916 20
   }

//------------------------------------------------------------------------------

void WitPreprocessor::compLotSizesExist ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   lotSizesExist (myGlobalComp ()) = witFALSE;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if ((theOpn->minLotSize ()[thePer] > 0.0) ||
             (theOpn->incLotSize ()[thePer] > 0.0)   )
            {
            lotSizesExist (myGlobalComp ()) = witTRUE;

            return;
            }
@


1.25
log
@Preliminary work on single source.
@
text
@d50 1
a50 1
      WitBoolean orderedByAversioT (const WitList <SortEntry> & theList)
d72 1
a72 1
      void sortByAversioT (
d80 1
a80 1
   theDenseList.sort (compareAversioT);
d91 1
a91 1
      int compareAversioT (
d1179 2
a1180 2
      if (! orderedByAversioT (thePart->producingBopEntries ()))
         sortByAversioT (producingBopEntries (thePart), sortedBopEntries);
d1194 2
a1195 2
      if (! orderedByAversioT (theBomEnt->mySubEntries ()))
         sortByAversioT (mySubEntries (theBomEnt), sortedSubEntries);
@


1.24
log
@Preliminary work on single source.
@
text
@d303 2
a304 1
   theLongestName = "";
d339 3
a341 2
      maxNameLength  = theName.length ();
      theLongestName = theName;
@


1.23
log
@Continued preliminary work on single source.
@
text
@d251 1
a251 1
      isCoproduced  (thePart) = witFALSE;
d255 1
a255 1
      mandEC (theMat) = witFALSE;
d258 1
a258 1
      executable (theOpn).setTo (witFALSE);
d264 1
a264 1
      hasSubsInEffect (theBomEnt) = witFALSE;
d266 1
a266 1
      nonSubVol       (theBomEnt) = 0.0;
d276 2
a277 2
      expExecPeriod (theBopEnt).setTo (-1);
      effProdRate   (theBopEnt).setTo  (0.0);
d914 1
a914 1
      hasImpact.setTo (witFALSE);
d966 1
a966 1
      hasSubsInEffect (theBomEnt) = witFALSE;
d971 1
a971 1
      hasSubsInEffectVal.setTo (witFALSE);
d982 1
a982 1
      hasSubsInEffect (theBomEnt) = hasSubsInEffectVal;
d1012 2
a1013 2
      effConsRate (theConsEnt) =
         theConsEnt->consRate ()[0] / (1.0 - theConsEnt->falloutRate ());
d1098 1
a1098 1
   expExecPeriod (theBopEnt).setTo (-1);
d1386 1
a1386 1
      isCoproduced (thePart) = witFALSE;
d1472 1
a1472 1
   tempNExecPeriods_.setTo (0);
d1526 1
a1526 1
   effConsRate (theConsEnt) = 0.0;
d1533 1
a1533 1
   impactPeriod (theBillEnt).setTo (-1);
@


1.22
log
@Continued preliminary work on single source.
@
text
@d27 2
d109 12
d131 1
a131 1
      sorted_              (),
d133 2
a134 2
      truncOffset_         (),
      floatCumLead_        (),
d147 3
d436 2
a437 2
   WitMapping (WitNode, int) nBefore      (myProblem (), 0);
   WitMapping (WitNode, int) nBeforeSuccs (myProblem (), 0);
d520 1
a520 1
   WitMapping (WitNode, int) nUnsortedPreds (myProblem (), 0);
d565 1
a565 1
   WitMapping (WitNode, WitBoolean) scanned (myProblem (), witFALSE);
@


1.21
log
@Continued preliminary work on single source.
@
text
@d1539 1
a1539 1
      belowCurrent_   ()
d1547 1
@


1.20
log
@More preliminary work on single source.
@
text
@d241 1
a241 1
      executable (theOpn) = witFALSE;
d259 2
a260 2
      expExecPeriod (theBopEnt) = -1;
      effProdRate   (theBopEnt) = 0.0;
d643 2
a644 2
   WitTVec (float)      leadToImpact (myProblem (), 0.0);
   WitTVec (WitBoolean) hasImpact    (myProblem (), witFALSE);
d888 2
a889 2
      WitTVec (float) &      leadToImpact,
      WitTVec (WitBoolean) & hasImpact)
d897 1
a897 1
      hasImpact = witFALSE;
d945 1
a945 1
   WitTVec (WitBoolean) hasSubsInEffectVal (myProblem (), witFALSE);
d954 1
a954 1
      hasSubsInEffectVal = witFALSE;
d1081 1
a1081 1
   expExecPeriod (theBopEnt) = -1;
d1453 3
a1455 2
   totNExecPeriods   = 0;
   tempNExecPeriods_ = 0;
d1516 1
a1516 1
   impactPeriod (theBillEnt) = -1;
@


1.19
log
@Preliminary work on single source.
@
text
@d29 68
d1155 3
a1157 1
   WitDenseList (WitBopEntry) sortedBopEntries;
d1160 2
a1161 2
      if (! orderedByAversion (thePart->producingBopEntries ()))
         sortByAversion (producingBopEntries (thePart), sortedBopEntries);
d1170 3
a1172 1
   WitDenseList (WitSubEntry) sortedSubEntries;
d1175 2
a1176 2
      if (! orderedByAversion (theBomEnt->mySubEntries ()))
         sortByAversion (mySubEntries (theBomEnt), sortedSubEntries);
a1177 70

//------------------------------------------------------------------------------
// Macro implementAversionSort (SortEntry)
//
// SortEntry = WitSubEntry or WitBopEntry.
//
// Implements functions to sort SortEntries by aversion.
//------------------------------------------------------------------------------

#define implementAversionSort(SortEntry)                                       \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean WitPreprocessor::orderedByAversion (                                \
      const WitList <SortEntry> & theList)                                     \
   {                                                                           \
   SortEntry * theEntry;                                                       \
   SortEntry * prevEntry;                                                      \
                                                                               \
   prevEntry = NULL;                                                           \
                                                                               \
   forEachEl (theEntry, theList)                                               \
      {                                                                        \
      if (prevEntry != NULL)                                                   \
         if (aversion (theEntry) < aversion (prevEntry))                       \
            return witFALSE;                                                   \
                                                                               \
      prevEntry = theEntry;                                                    \
      }                                                                        \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPreprocessor::sortByAversion (                                         \
      WitList      <SortEntry> & theList,                                      \
      WitDenseList (SortEntry) & theDenseList)                                 \
   {                                                                           \
   int         nInst;                                                          \
   SortEntry * theEntry;                                                       \
                                                                               \
   nInst = myCompMgr ()->nInstances ((SortEntry *) NULL);                      \
                                                                               \
   if (theDenseList.storageCapacity () == 0)                                   \
      theDenseList.resize (nInst);                                             \
                                                                               \
   copyInto (theDenseList, theList);                                           \
                                                                               \
   theDenseList.sort (compareAversion);                                        \
                                                                               \
   theList.clear ();                                                           \
                                                                               \
   forEachElDense (theEntry, theDenseList)                                     \
      theList.append (theEntry);                                               \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
int WitPreprocessor::compareAversion (                                         \
      SortEntry * theSortEntry1,                                               \
      SortEntry * theSortEntry2)                                               \
   {                                                                           \
   return sign (aversion (theSortEntry1) - aversion (theSortEntry2));          \
   }                                                                           \

//------------------------------------------------------------------------------

implementAversionSort (WitSubEntry)
implementAversionSort (WitBopEntry)
@


1.18
log
@Preliminary work on single source.
@
text
@d55 1
a55 1
      tempExecPeriod_      (* new WitPtrTVec <WitVector (WitPeriod)>)
d1419 1
a1419 1
      tempExecPeriod_[thePer] = new WitVector (WitPeriod) (nPeriods (), 0);
@


1.17
log
@Continued implementation of object iteration.
@
text
@d32 1
a32 1
inline const WitList (WitNode) & WitPreprocessor::successors (WitNode * theNode)
d48 1
a48 1
      successorsVector_    (* new WitPtrVec <WitList (WitNode)>),
d269 1
a269 1
      successorsVector_[idx] = new WitList (WitNode);
d384 1
a384 1
   WitList (WitNode) sortedNodes;
d433 1
a433 1
void WitPreprocessor::sortNodes (WitList (WitNode) & sortedNodes)
d437 1
a437 1
   WitList (WitNode) eligibleNodes;
d1120 1
a1120 1
      const WitList (SortEntry) & theList)                                     \
d1142 1
a1142 1
      WitList      (SortEntry) & theList,                                      \
@


1.16
log
@Began implementation of object iteration.
@
text
@d388 3
a390 1
   WitNode * theNode;
d406 11
a416 4
      if (theNode->isaPart ())
         allParts     (myCompMgr ()).append (theNode->asaPart ());
      else
         allOperations (myCompMgr ()).append (theNode->asanOperation ());
d483 1
d505 3
a507 1
   if (! theNode->isaPart ())
d509 7
a515 3
         //
         // Make sure the cycle begins with a Part, so that the error message
         // makes sense.
d1215 1
a1215 1
      theMat = thePart->myMat ();
d1314 1
a1314 1
   theMat = theConsEnt->myPart ()->myMat ();
d1343 1
a1343 1
      theMat = theBopEnt->myPart ()->myMat ();
@


1.15
log
@Continued development of Selective Stock Reallocation.
@
text
@d23 1
@


1.14
log
@Continued implementation of selective stock reallocation.
@
text
@a918 1
   WitCapacity *  theCap;
d931 1
a931 1
   if (! thePart->getMyCapacity (theCap))
d1198 3
a1200 1
      if (thePart->getMyMaterial (theMat))
a1292 1
   WitPart *     thePart;
d1297 1
a1297 1
   thePart = theConsEnt->myPart ();
d1299 1
a1299 1
   if (! thePart->getMyMaterial (theMat))
a1319 1
   WitPart *     thePart;
d1326 1
a1326 1
      thePart = theBopEnt->myPart ();
d1328 1
a1328 1
      if (thePart->getMyMaterial (theMat))
@


1.13
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d932 1
a932 1
   if (! thePart->isaCapacity (theCap))
d1199 1
a1199 1
      if (thePart->isaMaterial (theMat))
d1299 1
a1299 1
   if (! thePart->isaMaterial (theMat))
d1329 1
a1329 1
      if (thePart->isaMaterial (theMat))
@


1.12
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@d261 3
a263 1
   int idx;
d280 5
d1629 2
a1630 2
         activeInstance_->nPartsBefore_ (thePart2) -
         activeInstance_->nPartsBefore_ (thePart1));
@


1.11
log
@More templates.
@
text
@d49 1
a49 1
      unsortedPredTl_      (),
d469 1
a469 1
   unsortedPredTl_.allocate (myProblem (), NULL);
d474 1
a474 1
            unsortedPred (succNode) = theNode;
d484 1
a484 1
      theNode = unsortedPred (theNode);
d488 1
a488 1
      theNode = unsortedPred (theNode);
d501 2
a502 2
         unsortedPred (theNode)->nodeName (),
         unsortedPred (unsortedPred (theNode))->nodeName ());
d504 1
a504 1
      theNode = unsortedPred (unsortedPred (theNode));
@


1.10
log
@Continued development of selection splitting for multi=exec.
@
text
@d47 1
a47 1
      successorsVector_    (* new WitPtrVec (WitList (WitNode))),
d54 1
a54 1
      tempExecPeriod_      (* new WitPtrTVec (WitVector (WitPeriod)))
@


1.9
log
@Some minor changes.
@
text
@d709 1
a709 1
   if (theSub->myBomEntry ()->inEffect (thePer))
d712 1
a712 1
            theSub->myBomEntry ()->impactPeriod ()[thePer];
@


1.8
log
@Refactoring for selection splitting.
@
text
@d23 3
d31 7
d47 1
a47 1
      successorsVector_    (),
d54 1
a54 1
      tempExecPeriod_      ()
d63 4
a66 2
   delete myAccFlag_;
   delete myBelowLister_;
d261 2
d265 3
d273 3
d300 1
a300 1
         successorsVector_[theBomEnt->myPart ()->nodeIndex ()].
d304 1
a304 1
            successorsVector_[theSub->myPart ()->nodeIndex ()].
d312 1
a312 1
            successorsVector_[theBopEnt->myOperation ()->nodeIndex ()].
d1393 1
a1393 1
   tempExecPeriod_  .resize   (nPeriods ());
d1396 1
a1396 1
      tempExecPeriod_[thePer].resize (nPeriods (), 0);
d1407 3
d1440 1
a1440 1
         tempExecPeriod_[impactPer][localIdx] = execPer;
d1457 1
a1457 1
            tempExecPeriod_[impactPer][localIdx];
@


1.7
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d151 1
a151 1
      expBopEntryTl (thePart).clear ();
d1147 1
a1147 1
      expBopEntryTl (thePart).allocate (myProblem (), NULL);
d1153 1
a1153 1
               expBopEntry (thePart, thePer) = theBopEnt;
@


1.6
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d1110 1
a1110 1
   copyTo (theDenseList, theList);                                             \
@


1.5
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d863 1
a863 1
   compEffUsageRate (theBomEnt);
d866 1
a866 1
      compEffUsageRate (theSub);
d873 1
a873 1
void WitPreprocessor::compEffUsageRate (WitConsEntry * theConsEnt)
d875 10
a884 2
   effUsageRate (theConsEnt) =
      theConsEnt->usageRate () / (1.0 - theConsEnt->falloutRate ());
d923 2
a924 1
      minCons = theOpn->minLotSize ()[execPer] * theBomEnt->effUsageRate ();
d958 1
a958 1
              theBopEnt->prodRate ()
d1318 1
d1327 6
a1332 5
      if (theOpn->isCoproducing ())
         {
         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->prodRate () > 0.0)
               isCoproduced (theBopEnt->myPart ()) = witTRUE;
d1334 4
a1337 4
         forEachEl (theBomEnt, theOpn->bom ())
            {
            if (theBomEnt->usageRate () < 0.0)
               isCoproduced (theBomEnt->myPart ()) = witTRUE;
d1339 4
a1342 3
            forEachEl (theSub, theBomEnt->mySubEntries ())
               if (theSub->usageRate () < 0.0)
                  isCoproduced (theSub->myPart ()) = witTRUE;
d1344 14
a1357 1
         }
d1460 1
a1460 1
   effUsageRate (theConsEnt) = 0.0;
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d168 1
a168 1
      nonSubVol       (theBomEnt).clear ();
a862 3
   if (! theBomEnt->mySubEntries ().isEmpty ())
      nonSubVol (theBomEnt).allocate (myProblem (), 0.0);

d1101 1
a1101 1
   copy (theDenseList, theList);                                               \
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d341 1
a341 1
             WitUtil::min (nBeforeSuccs (theNode), nBefore (succNode));
d521 1
a521 1
         WitUtil::min ((float) thePer, theBillEnt->offset ()[thePer]);
d678 1
a678 3
   WitUtil::setToMax (
      floatCumLead_ (theConsEnt->myOperation (), thePer),
      propFCLead);
d800 1
a800 1
            WitUtil::setToMax (
d1120 1
a1120 4
   return                                                                      \
      WitUtil::sign (                                                          \
           aversion (theSortEntry1)                                            \
         - aversion (theSortEntry2));                                          \
d1194 1
a1194 1
//    but not in myProblem ()->lPeriod ().
d1249 1
a1249 1
   if (theBomEnt->latestPeriod () < myProblem ()->lPeriod ())
d1262 1
a1262 1
   WitPeriod     tImp;
d1269 1
a1269 1
   execPer = myProblem ()->lPeriod ();
d1271 2
a1272 2
   for (tImp = myProblem ()->lPeriod (); tImp >= 0; -- tImp)
      if (theMat->mandEC ()[tImp])
d1275 1
a1275 1
               if (theConsEnt->impactPeriod ()[execPer] <= tImp)
d1386 1
a1386 1
   for (execPer = nPeriods () - 1; execPer >= 0; execPer --)
d1576 1
a1576 1
      WitUtil::sign (
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d678 1
a678 1
   WitUtil::updateToMax (
d802 1
a802 1
            WitUtil::updateToMax (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

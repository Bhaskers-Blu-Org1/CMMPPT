head	1.101;
access;
symbols
	sce_5_01_20080919:1.92
	latest_sce_4_20_20060523:1.86.0.2
	sce_4_20_20060523:1.86
	latest_sce4_20_OSL:1.85.0.2
	sce_4_20_OSL:1.85
	sce_410_withVa:1.63
	sce_4_05_20040511:1.58
	sce_4_00_20040201:1.58
	nextGenBranch:1.43.0.2
	nextGenRoot:1.43
	sce_3_30_20030627:1.40
	EndRw-branch:1.32.0.4
	Root-of-EndRw:1.32
	rwToStl:1.32.0.2
	latest_sce_3_10_20010924:1.21.0.2
	sce_3_10_20010924:1.21
	latest_sce_3_00_20010601:1.12.0.2
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11;
locks; strict;
comment	@ * @;


1.101
date	2011.09.28.23.50.29;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.09.24.00.28.44;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.08.30.20.18.15;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.29.20.57.00;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.09.28.21.54.07;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.09.28.19.25.17;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.27.21.12.21;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.21.19.58.43;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.27.23.07.07;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.07.10.15.57.24;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2006.08.07.22.24.29;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2006.08.03.17.38.33;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2006.06.06.21.31.18;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.26.21.14.30;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.26.20.40.11;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2006.05.02.17.34.13;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.11.00.03.46;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.08.23.57.12;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.03.20.46.56;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.26.22.10.56;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.12.23.10.47;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.01.09.20.02.31;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.01.03.19.00.04;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.30.20.40.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.28.18.57.50;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.12.16.20.33.56;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.12.05.20.47.34;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.22.22.20.28;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.16.23.24.49;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.11.16.20.42.15;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.11.16.19.24.33;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.11.16.16.52.56;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.11.15.21.45.26;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.15.21.27.24;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.15.19.55.21;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.14.22.29.02;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.28.19.34.28;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.14.00.01.17;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.01.11.20.28.37;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.04.00.02.48;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.12.17.02.44;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.24.23.25.56;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.24.20.12.34;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.24.17.11.17;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.24.16.23.23;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.23.17.56.20;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.22.19.56.12;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.19.19.01.02;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.17.16.53.53;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.12.19.49.44;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.11.21.56.33;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.23.19.33.13;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.16.22.29.40;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.16.16.18.03;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.06.21.12.27;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.24.15.31.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.23.21.23.21;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.23.20.00.17;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.11.20.45.36;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.13.23.06.34;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.23.19.13.24;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.13.22.22.14;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.09.23.29.46;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.02.23.40.52;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.02.22.18.52;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.14.00.55.49;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.09.19.52.37;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.28.19.40.17;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.26.18.42.53;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.26.18.28.39;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.21.21.52.22;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.21.18.13.44;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.16.23.32.10;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.13.21.31.43;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.10.18.02.14;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.01.14.26.02;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.08.21.18.01;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.24.22.03.23;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.01.14.55.31;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.09.22.09.45;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.05.18.50.18;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.03.20.07.31;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.27.21.45.12;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.21.15.40.05;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.20.20.07.07;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.18.21.38.39;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.25.14.53.28;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.06.21.50.18;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.01.16.24.45;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.15.19.01.52;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.11.16.35.11;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.28.22.13.39;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.22.16.18.27;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.20.20.22.27;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.20.20.08.38;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.23.45.59;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.13.19.57.26;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.05.19.05.32;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.101
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Stack.C"
//
// Contains the implementation of the following classes and templates:
//
//    AbsStack
//    AbsStItr
//    AbsObjStack
//    AbsObjStItr
//    PairStack <ObjByPtr, ObjByVal>, with explicit instantiation
//    PerSglStack <ObjByPtr>, with explicit instantiation
//    AbsTripStack
//    AbsLinkMgr
//    ObjLinkMgr
//    PairLinkMgr <ObjByVal>, with explicit instantiation
//    TripLinkMgr
//    AbsLink
//    ObjLink
//    PairLink <ObjByVal>, with explicit instantiation
//    TripLink
//------------------------------------------------------------------------------

#include <ObjStack.h>
#include <PerSglStack.h>
#include <TripStack.h>
#include <LinkMgr.h>

#include <Material.h>
#include <Operation.h>
#include <BomEntry.h>
#include <BopEntry.h>
#include <RtSite.h>
#include <RtCand.h>

//------------------------------------------------------------------------------
// Implementation of class AbsStack.
//------------------------------------------------------------------------------

void WitAbsStack::clear ()
   {
   while (isNonEmpty ())
      popAbs ();
   }

//------------------------------------------------------------------------------

int WitAbsStack::nElements () const
   {
   int          nEl;
   WitAbsLink * theAbsLink;

   nEl = 0;

   theAbsLink = firstAbsLink_;

   while (theAbsLink != NULL)
      {
      nEl ++;

      theAbsLink = theAbsLink->nextAbsLink ();
      }

   return nEl;
   }

//------------------------------------------------------------------------------

void WitAbsStack::reverse ()
   {
   WitAbsLink * oldFirstAbsLink;
   WitAbsLink * theAbsLink;

   oldFirstAbsLink = firstAbsLink_;
   firstAbsLink_   = NULL;

   while (oldFirstAbsLink != NULL)
      {
      theAbsLink      = oldFirstAbsLink;
      oldFirstAbsLink = oldFirstAbsLink->nextAbsLink ();

      theAbsLink->linkTo (firstAbsLink_);

      firstAbsLink_   = theAbsLink;
      }
   }

//------------------------------------------------------------------------------

WitProblem * WitAbsStack::myProblem () const
   {
   return myAbsLinkMgr_->myProblem ();
   }

//------------------------------------------------------------------------------

WitAbsStack::WitAbsStack (WitAbsLinkMgr * theAbsLinkMgr):

      myAbsLinkMgr_ (theAbsLinkMgr),
      firstAbsLink_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAbsStack::~WitAbsStack ()
   {
   clear ();
   }

//------------------------------------------------------------------------------

void WitAbsStack::pushAbs ()
   {
   firstAbsLink_ = myAbsLinkMgr_->freshAbsLink (firstAbsLink_);
   }

//------------------------------------------------------------------------------

void WitAbsStack::popAbs ()
   {
   WitAbsLink * theAbsLink;

   witAssert (isNonEmpty ());

   theAbsLink    = firstAbsLink_;
   firstAbsLink_ = theAbsLink->nextAbsLink ();

   myAbsLinkMgr_->recycleAbsLink (theAbsLink);
   }

//------------------------------------------------------------------------------

void WitAbsStack::takeContentsFromAbs (WitAbsStack & thatAbsStack)
   {
   witAssert (isEmpty ());

                firstAbsLink_ = thatAbsStack.firstAbsLink_;
   thatAbsStack.firstAbsLink_ = NULL;
   }

//------------------------------------------------------------------------------

void WitAbsStack::attachItrAbs (WitAbsStItr & theAbsStItr) const
   {
   theAbsStItr.myAbsStack_ = this;
   theAbsStItr.curAbsLink_ = NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class AbsStItr.
//------------------------------------------------------------------------------

WitAbsStItr::WitAbsStItr ():
      myAbsStack_ (NULL),
      curAbsLink_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAbsStItr::~WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsStItr::advanceAbs ()
   {
   witAssert (myAbsStack_ != NULL);

   curAbsLink_ =
      (curAbsLink_ == NULL)?
         myAbsStack_->firstConstLink ():
         curAbsLink_->nextAbsLink ();
   }

//------------------------------------------------------------------------------
// Implementation of class AbsObjStack.
//------------------------------------------------------------------------------

WitAbsObjStack::WitAbsObjStack (WitProblem * theProblem):

      WitAbsStack (theProblem->myObjLinkMgr ())
   {
   }

//------------------------------------------------------------------------------

WitAbsObjStack::~WitAbsObjStack ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsObjStack::revCopyFromAbs (const WitAbsObjStack & theAbsObjStack)
   {
   WitAbsLink * theAbsLink;
   WitObjLink * theObjLink;

   clear ();

   theAbsLink = theAbsObjStack.firstAbsLink ();

   while (theAbsLink != NULL)
      {
      theObjLink = static_cast <WitObjLink *> (theAbsLink);

      pushAbsObj (theObjLink->myObjByVP ());

      theAbsLink = theObjLink->nextAbsLink ();
      }
   }

//------------------------------------------------------------------------------

bool WitAbsObjStack::containsAbs (void * theObjByVP) const
   {
   WitAbsObjStItr theItr;
   void *         theItrObjByVP;

   attachItrAbsObj (theItr);

   while (theItr.advanceAbsObj (theItrObjByVP))
      if (theItrObjByVP == theObjByVP)
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitAbsObjStack::pushAbsObj (void * theObjByVP)
   {
   pushAbs ();

   firstObjLink ()->setDataTo (theObjByVP);
   }

//------------------------------------------------------------------------------

bool WitAbsObjStack::popAbsObj (void * & theObjByVP)
   {
   if (isEmpty ())
      return false;

   theObjByVP = firstObjLink ()->myObjByVP ();

   popAbs ();

   return true;
   }

//------------------------------------------------------------------------------

void WitAbsObjStack::attachItrAbsObj (WitAbsObjStItr & theAbsObjStItr) const
   {
   attachItrAbs (theAbsObjStItr);
   }

//------------------------------------------------------------------------------

void WitAbsObjStack::removeAbs (void * theObjByVP)
   {
   WitAbsObjStack revStack (myProblem ());
   void *         poppedObjByVP;

   while (popAbsObj (poppedObjByVP))
      if (poppedObjByVP != theObjByVP)
         revStack.pushAbsObj (poppedObjByVP);

   takeContentsFromAbs (revStack);
   
   reverse ();
   }

//------------------------------------------------------------------------------

void * WitAbsObjStack::firstObjByVP () const
   {
   witAssert (not isEmpty ());

   return firstObjLink ()->myObjByVP ();
   }

//------------------------------------------------------------------------------
// Implementation of class AbsObjStItr.
//------------------------------------------------------------------------------

WitAbsObjStItr::WitAbsObjStItr ():

      WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

WitAbsObjStItr::~WitAbsObjStItr ()
   {
   }

//------------------------------------------------------------------------------

bool WitAbsObjStItr::advanceAbsObj (void * & theObjByVP)
   {
   const WitObjLink * theObjLink;

   advanceAbs ();

   theObjLink = static_cast <const WitObjLink *> (curAbsLink ());

   if (theObjLink != NULL)
      {
      theObjByVP = theObjLink->myObjByVP ();

      return true;
      }
   else
      {
      theObjByVP = NULL;

      return false;
      }
   }

//------------------------------------------------------------------------------
// Implementation of NonClass function template revCopyInto.
//------------------------------------------------------------------------------

template <typename ObjByPtr>
      void WitNonClass::revCopyInto (
         WitObjStack <ObjByPtr> &   theObjStack,
         const WitList <ObjByPtr> & theList)
   {
   WitListItr theItr (theList);
   ObjByPtr * theObjByPtr;

   theObjStack.clear ();

   while (theList.advance (theItr, theObjByPtr))
      theObjStack.push (theObjByPtr);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of NonClass function template revCopyInto.
//------------------------------------------------------------------------------

template void WitNonClass::revCopyInto <WitPart> (
   WitObjStack            <WitPart> &,
   const WitList          <WitPart> &);

template void WitNonClass::revCopyInto <WitOperation> (
   WitObjStack            <WitOperation> &,
   const WitList          <WitOperation> &);

template void WitNonClass::revCopyInto <WitSubEntry> (
   WitObjStack            <WitSubEntry> &,
   const WitList          <WitSubEntry> &);

//------------------------------------------------------------------------------
// Implementation of class template PairStack <ObjByPtr, ObjByVal>.
//------------------------------------------------------------------------------

template <PairStArgDecs> 
      WitPairStack <PairStArgs>::WitPairStack (WitProblem * theProblem):

         WitAbsStack (WitPairLinkMgr <ObjByVal>::theInstanceFor (theProblem))
   {
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      WitPairStack <PairStArgs>::~WitPairStack ()
   {
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      void WitPairStack <PairStArgs>::push (
         ObjByPtr * theObjByPtr,
         ObjByVal   theObjByVal)
   {
   pushAbs ();

   firstPairLink ()->setDataTo (theObjByPtr, theObjByVal);
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      bool WitPairStack <PairStArgs>::pop (
         ObjByPtr * & theObjByPtr, 
         ObjByVal &   theObjByVal)
   {
   if (isEmpty ())
      return false;

   theObjByPtr = reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());

   theObjByVal = firstPairLink ()->myObjByVal ();

   popAbs ();

   return true;
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      void WitPairStack <PairStArgs>::revCopyFrom (
         const WitPairStack & thePairStack)
   {
   WitPairStItr <PairStArgs> theItr;
   ObjByPtr *                theObjByPtr;
   ObjByVal                  theObjByVal;

   clear ();

   thePairStack.attachItr (theItr);

   while (theItr.advance (theObjByPtr, theObjByVal))
      push (theObjByPtr, theObjByVal);
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      ObjByPtr * WitPairStack <PairStArgs>::firstObject () const
   {
   witAssert (isNonEmpty ());

   return reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      ObjByVal WitPairStack <PairStArgs>::firstValue () const
   {
   witAssert (isNonEmpty ());

   return firstPairLink ()->myObjByVal ();
   }

//------------------------------------------------------------------------------

template <PairStArgDecs> 
      bool WitPairStack <PairStArgs>::advance (
         WitPairStItr <PairStArgs> & theItr,
         ObjByPtr * &                theObjByPtr,
         ObjByVal &                  theObjByVal)
   {
   const WitPairLink <ObjByVal> * thePairLink;

   theItr.advanceAbs ();

   thePairLink =
      static_cast <const WitPairLink <ObjByVal> *> (theItr.curAbsLink ());

   if (thePairLink == NULL)
      return false;

   theObjByPtr = reinterpret_cast <ObjByPtr *> (thePairLink->myObjByVP ());

   theObjByVal = thePairLink->myObjByVal ();

   return true;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PairStack <ObjByPtr, ObjByVal>.
//------------------------------------------------------------------------------

template class WitPairStack <bool,         bool>;
template class WitPairStack <WitPart,      bool>;

template class WitPairStack <int,          int>;
template class WitPairStack <WitPart,      int>;
template class WitPairStack <WitMaterial,  int>;
template class WitPairStack <WitOperation, int>;
template class WitPairStack <WitBomEntry,  int>;
template class WitPairStack <WitSubEntry,  int>;
template class WitPairStack <WitBopEntry,  int>;
template class WitPairStack <WitDemand,    int>;
template class WitPairStack <WitRtCand,    int>;
template class WitPairStack <WitBaMat,     int>;
template class WitPairStack <WitRtSite,    int>;

template class WitPairStack <double,       double>;
template class WitPairStack <WitFixedPer,  double>;
template class WitPairStack <WitRtCand,    double>;
template class WitPairStack <WitSelPt,     double>;
template class WitPairStack <WitSelCand,   double>;
template class WitPairStack <WitPipSeqEl,  double>;
template class WitPairStack <WitPipReqSrc, double>;

template class WitPairStack <void *,       void *>;

//------------------------------------------------------------------------------
// Implementation of class template PerSglStack <ObjByPtr>.
//------------------------------------------------------------------------------

template <typename ObjByPtr> 
      WitPerSglStack <ObjByPtr>::WitPerSglStack (WitProblem * theProblem):

      myPairs_ (theProblem),
      inStack_ ()
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByPtr> 
      WitPerSglStack <ObjByPtr>::~WitPerSglStack ()
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByPtr> 
      void WitPerSglStack <ObjByPtr>::push (
         ObjByPtr * theObjByPtr,
         WitPeriod  thePer)
   {
   if (inStack_.domainSize () == 0)
      {
      inStack_.allocate1D (myPairs_.myProblem ());
      }

   if (not inStack_ (theObjByPtr).isAllocated ())
      {
      inStack_ (theObjByPtr).allocate (myPairs_.myProblem (), false);
      }

   if (inStack_ (theObjByPtr)[thePer])
      return;

   myPairs_.push (theObjByPtr, thePer);

   inStack_ (theObjByPtr)[thePer] = true;
   }

//------------------------------------------------------------------------------

template <typename ObjByPtr> 
      bool WitPerSglStack <ObjByPtr>::pop (
         ObjByPtr * & theObjByPtr,
         WitPeriod &  thePer)
   {
   if (myPairs_.isEmpty ())
      return false;

   myPairs_.pop (theObjByPtr, thePer);

   inStack_ (theObjByPtr)[thePer] = false;

   return true;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PerSglStack <ObjByPtr>.
//------------------------------------------------------------------------------

template class WitPerSglStack <WitPart>;
template class WitPerSglStack <WitMaterial>;
template class WitPerSglStack <WitOperation>;
template class WitPerSglStack <WitBomEntry>;
template class WitPerSglStack <WitBopEntry>;
template class WitPerSglStack <WitRtSite>;
template class WitPerSglStack <WitRtCand>;

//------------------------------------------------------------------------------
// Implementation of class AbsTripStack.
//------------------------------------------------------------------------------

WitAbsTripStack::WitAbsTripStack (WitProblem * theProblem):

      WitAbsStack (theProblem->myTripLinkMgr ())
   {
   }

//------------------------------------------------------------------------------

WitAbsTripStack::~WitAbsTripStack ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsTripStack::pushAbsTrip (
      void *    theObjByVP,
      WitPeriod thePer,
      double    theDbl)
   {
   pushAbs ();

   firstTripLink ()->setDataTo (theObjByVP, thePer, theDbl);
   }

//------------------------------------------------------------------------------

bool WitAbsTripStack::popAbsTrip (
      void * &    theObjByVP,
      WitPeriod & thePer,
      double &    theDbl)
   {
   if (isEmpty ())
      return false;

   firstTripLink ()->getData (theObjByVP, thePer, theDbl);

   popAbs ();

   return true;
   }

//------------------------------------------------------------------------------

WitTripLink * WitAbsTripStack::firstTripLink () const
   {
   return static_cast <WitTripLink *> (firstAbsLink ());
   }

//------------------------------------------------------------------------------

void WitAbsTripStack::revCopyFromAbs (const WitAbsTripStack & theAbsTripStack)
   {
   WitAbsLink *  theAbsLink;
   WitTripLink * theTripLink;
   void *        theObjByVP;
   WitPeriod     thePer;
   double        theDbl;

   clear ();

   theAbsLink = theAbsTripStack.firstAbsLink ();

   while (theAbsLink != NULL)
      {
      theTripLink = static_cast <WitTripLink *> (theAbsLink);

      theTripLink->getData (theObjByVP, thePer, theDbl);

      pushAbsTrip (theObjByVP, thePer, theDbl);

      theAbsLink = theAbsLink->nextAbsLink ();
      }
   }

//------------------------------------------------------------------------------
// Implementation of class AbsLinkMgr.
//------------------------------------------------------------------------------

void WitAbsLinkMgr::deleteInstance (WitAbsLinkMgr * theAbsLinkMgr)
   {
   WitAbsLink * theAbsLink;
   WitAbsLink * deadAbsLink;

   if (theAbsLinkMgr == NULL)
      return;

   theAbsLink = theAbsLinkMgr->firstUnusedAbsLink_;

   while (theAbsLink != NULL)
      {
      deadAbsLink = theAbsLink;
      theAbsLink  = theAbsLink->nextAbsLink ();

      theAbsLinkMgr->deleteAbsLink (deadAbsLink);
      }

   delete theAbsLinkMgr;
   }

//------------------------------------------------------------------------------

WitAbsLink * WitAbsLinkMgr::freshAbsLink (WitAbsLink * theAbsLink)
   {
   WitAbsLink * theFreshAbsLink;

   if (firstUnusedAbsLink_ == NULL)
      theFreshAbsLink     = newAbsLink ();
   else
      {
      theFreshAbsLink     = firstUnusedAbsLink_;
      firstUnusedAbsLink_ = theFreshAbsLink->nextAbsLink ();
      }

   theFreshAbsLink->linkTo (theAbsLink);

   return theFreshAbsLink;
   }

//------------------------------------------------------------------------------

void WitAbsLinkMgr::recycleAbsLink (WitAbsLink * theAbsLink)
   {
   theAbsLink->linkTo (firstUnusedAbsLink_);

   firstUnusedAbsLink_ = theAbsLink;
   }

//------------------------------------------------------------------------------

WitAbsLinkMgr::WitAbsLinkMgr (WitProblem * theProblem):
      WitProbAssoc        (theProblem),

      firstUnusedAbsLink_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAbsLinkMgr::~WitAbsLinkMgr ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class ObjLinkMgr.
//------------------------------------------------------------------------------

WitObjLinkMgr::WitObjLinkMgr (WitProblem * theProblem):
      WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitObjLinkMgr::~WitObjLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAbsLink * WitObjLinkMgr::newAbsLink ()
   {
   return new WitObjLink;
   }

//------------------------------------------------------------------------------

void WitObjLinkMgr::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete static_cast <WitObjLink *> (theAbsLink);
   }

//------------------------------------------------------------------------------
// Implementation of class template PairLinkMgr <ObjByVal>.
//------------------------------------------------------------------------------

template <typename ObjByVal> 
      WitPairLinkMgr <ObjByVal>::WitPairLinkMgr (WitProblem * theProblem):

         WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByVal> 
      WitPairLinkMgr <ObjByVal>::~WitPairLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByVal> 
      WitAbsLink * WitPairLinkMgr <ObjByVal>::newAbsLink ()
   {
   return new WitPairLink <ObjByVal>;
   }

//------------------------------------------------------------------------------

template <typename ObjByVal> 
      void WitPairLinkMgr <ObjByVal>::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete static_cast <WitPairLink <ObjByVal> *> (theAbsLink);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of class template PairLinkMgr <ObjByVal> member
// functions.
//------------------------------------------------------------------------------

template <>
      WitPairLinkMgr <int> * WitPairLinkMgr <int>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myIntPairLinkMgr ();
   }

//------------------------------------------------------------------------------

template <>
      WitPairLinkMgr <bool> * WitPairLinkMgr <bool>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myBoolPairLinkMgr ();
   }

//------------------------------------------------------------------------------

template <>
      WitPairLinkMgr <double> * WitPairLinkMgr <double>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myDblPairLinkMgr ();
   }

//------------------------------------------------------------------------------

template <>
      WitPairLinkMgr <void *> * 
         WitPairLinkMgr <void *>::theInstanceFor (WitProblem * theProblem)
   {
   return theProblem->myVoidPtrPairLinkMgr ();
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PairLink <ObjByVal>.
//------------------------------------------------------------------------------

template class WitPairLinkMgr <bool>;
template class WitPairLinkMgr <int>;
template class WitPairLinkMgr <double>;
template class WitPairLinkMgr <void *>;

//------------------------------------------------------------------------------
// Implementation of class TripLinkMgr.
//------------------------------------------------------------------------------

WitTripLinkMgr::WitTripLinkMgr (WitProblem * theProblem):
      WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitTripLinkMgr::~WitTripLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAbsLink * WitTripLinkMgr::newAbsLink ()
   {
   return new WitTripLink;
   }

//------------------------------------------------------------------------------

void WitTripLinkMgr::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete static_cast <WitTripLink *> (theAbsLink);
   }

//------------------------------------------------------------------------------
// Implementation of class AbsLink.
//------------------------------------------------------------------------------

void WitAbsLink::linkTo (WitAbsLink * theAbsLink)
   {
   nextAbsLink_ = theAbsLink;
   }

//------------------------------------------------------------------------------

WitAbsLink::WitAbsLink ():
      nextAbsLink_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAbsLink::~WitAbsLink ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class ObjLink.
//------------------------------------------------------------------------------

WitObjLink::WitObjLink ():
      WitAbsLink (),

      myObjByVP_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitObjLink::~WitObjLink ()
   {
   }

//------------------------------------------------------------------------------

void WitObjLink::setDataTo (void * theObjByVP)
   {
   myObjByVP_ = theObjByVP;
   }

//------------------------------------------------------------------------------
// Implementation of class template PairLink <ObjByVal>.
//------------------------------------------------------------------------------

template <typename ObjByVal> 
      WitPairLink <ObjByVal>::WitPairLink ():
         WitAbsLink  (),

         myObjByVP_  (NULL),
         myObjByVal_ ()
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByVal> 
      WitPairLink <ObjByVal>::~WitPairLink ()
   {
   }

//------------------------------------------------------------------------------

template <typename ObjByVal> 
      void WitPairLink <ObjByVal>::setDataTo (
         void *   theObjByVP,
         ObjByVal theObjByVal)
   {
   myObjByVP_  = theObjByVP;
   myObjByVal_ = theObjByVal;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PairLink <ObjByVal>.
//------------------------------------------------------------------------------

template class WitPairLink <bool>;
template class WitPairLink <int>;
template class WitPairLink <double>;
template class WitPairLink <void *>;

//------------------------------------------------------------------------------
// Implementation of class TripLink.
//------------------------------------------------------------------------------

WitTripLink::WitTripLink ():
      WitAbsLink (),

      myObjByVP_ (NULL),
      myPer_     (-1),
      myDbl_     (0.0)
   {
   }

//------------------------------------------------------------------------------

WitTripLink::~WitTripLink ()
   {
   }

//------------------------------------------------------------------------------

void WitTripLink::setDataTo (
      void *    theObjByVP,
      WitPeriod thePer,
      double    theDbl)
   {
   myObjByVP_ = theObjByVP;
   myPer_     = thePer;
   myDbl_     = theDbl;
   }

//------------------------------------------------------------------------------

void WitTripLink::getData (
      void * &    theObjByVP,
      WitPeriod & thePer,
      double &    theDbl)
      const
   {
   theObjByVP = myObjByVP_;
   thePer     = myPer_;
   theDbl     = myDbl_;
   }
@


1.100
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.99
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d49 4
a52 4
{
while (isNonEmpty ())
popAbs ();
}
d57 3
a59 3
{
int          nEl;
WitAbsLink * theAbsLink;
d61 1
a61 1
nEl = 0;
d63 1
a63 1
theAbsLink = firstAbsLink_;
d65 3
a67 3
while (theAbsLink != NULL)
{
nEl ++;
d69 2
a70 2
theAbsLink = theAbsLink->nextAbsLink ();
}
d72 2
a73 2
return nEl;
}
d78 17
a94 17
{
WitAbsLink * oldFirstAbsLink;
WitAbsLink * theAbsLink;

oldFirstAbsLink = firstAbsLink_;
firstAbsLink_   = NULL;

while (oldFirstAbsLink != NULL)
{
theAbsLink      = oldFirstAbsLink;
oldFirstAbsLink = oldFirstAbsLink->nextAbsLink ();

theAbsLink->linkTo (firstAbsLink_);

firstAbsLink_   = theAbsLink;
}
}
d99 3
a101 3
{
return myAbsLinkMgr_->myProblem ();
}
d107 4
a110 4
myAbsLinkMgr_ (theAbsLinkMgr),
firstAbsLink_ (NULL)
{
}
d115 3
a117 3
{
clear ();
}
d122 3
a124 3
{
firstAbsLink_ = myAbsLinkMgr_->freshAbsLink (firstAbsLink_);
}
d129 2
a130 2
{
WitAbsLink * theAbsLink;
d132 1
a132 1
witAssert (isNonEmpty ());
d134 2
a135 2
theAbsLink    = firstAbsLink_;
firstAbsLink_ = theAbsLink->nextAbsLink ();
d137 2
a138 2
myAbsLinkMgr_->recycleAbsLink (theAbsLink);
}
d143 2
a144 2
{
witAssert (isEmpty ());
d146 3
a148 3
firstAbsLink_ = thatAbsStack.firstAbsLink_;
thatAbsStack.firstAbsLink_ = NULL;
}
d153 4
a156 4
{
theAbsStItr.myAbsStack_ = this;
theAbsStItr.curAbsLink_ = NULL;
}
d163 4
a166 4
myAbsStack_ (NULL),
curAbsLink_ (NULL)
{
}
d171 2
a172 2
{
}
d177 2
a178 2
{
witAssert (myAbsStack_ != NULL);
d180 5
a184 5
curAbsLink_ =
(curAbsLink_ == NULL)?
myAbsStack_->firstConstLink ():
curAbsLink_->nextAbsLink ();
}
d192 3
a194 3
WitAbsStack (theProblem->myObjLinkMgr ())
{
}
d199 2
a200 2
{
}
d205 3
a207 3
{
WitAbsLink * theAbsLink;
WitObjLink * theObjLink;
d209 1
a209 1
clear ();
d211 1
a211 1
theAbsLink = theAbsObjStack.firstAbsLink ();
d213 3
a215 3
while (theAbsLink != NULL)
{
theObjLink = static_cast <WitObjLink *> (theAbsLink);
d217 1
a217 1
pushAbsObj (theObjLink->myObjByVP ());
d219 3
a221 3
theAbsLink = theObjLink->nextAbsLink ();
}
}
d226 9
a234 9
{
WitAbsObjStItr theItr;
void *         theItrObjByVP;

attachItrAbsObj (theItr);

while (theItr.advanceAbsObj (theItrObjByVP))
if (theItrObjByVP == theObjByVP)
return true;
d236 2
a237 2
return false;
}
d242 2
a243 2
{
pushAbs ();
d245 2
a246 2
firstObjLink ()->setDataTo (theObjByVP);
}
d251 3
a253 3
{
if (isEmpty ())
return false;
d255 1
a255 1
theObjByVP = firstObjLink ()->myObjByVP ();
d257 1
a257 1
popAbs ();
d259 2
a260 2
return true;
}
d265 3
a267 3
{
attachItrAbs (theAbsObjStItr);
}
d272 12
a283 12
{
WitAbsObjStack revStack (myProblem ());
void *         poppedObjByVP;

while (popAbsObj (poppedObjByVP))
if (poppedObjByVP != theObjByVP)
revStack.pushAbsObj (poppedObjByVP);

takeContentsFromAbs (revStack);

reverse ();
}
d288 2
a289 2
{
witAssert (not isEmpty ());
d291 2
a292 2
return firstObjLink ()->myObjByVP ();
}
d300 3
a302 3
WitAbsStItr ()
{
}
d307 2
a308 2
{
}
d313 2
a314 2
{
const WitObjLink * theObjLink;
d316 1
a316 1
advanceAbs ();
d318 1
a318 1
theObjLink = static_cast <const WitObjLink *> (curAbsLink ());
d320 13
a332 13
if (theObjLink != NULL)
{
theObjByVP = theObjLink->myObjByVP ();

return true;
}
else
{
theObjByVP = NULL;

return false;
}
}
d339 12
a350 12
void WitNonClass::revCopyInto (
WitObjStack <ObjByPtr> &   theObjStack,
const WitList <ObjByPtr> & theList)
{
WitListItr theItr (theList);
ObjByPtr * theObjByPtr;

theObjStack.clear ();

while (theList.advance (theItr, theObjByPtr))
theObjStack.push (theObjByPtr);
}
d357 2
a358 2
WitObjStack            <WitPart> &,
const WitList          <WitPart> &);
d361 2
a362 2
WitObjStack            <WitOperation> &,
const WitList          <WitOperation> &);
d365 2
a366 2
WitObjStack            <WitSubEntry> &,
const WitList          <WitSubEntry> &);
d372 2
a373 2
template <PairStArgDecs>
WitPairStack <PairStArgs>::WitPairStack (WitProblem * theProblem):
d375 3
a377 3
WitAbsStack (WitPairLinkMgr <ObjByVal>::theInstanceFor (theProblem))
{
}
d381 4
a384 4
template <PairStArgDecs>
WitPairStack <PairStArgs>::~WitPairStack ()
{
}
d388 6
a393 6
template <PairStArgDecs>
void WitPairStack <PairStArgs>::push (
ObjByPtr * theObjByPtr,
ObjByVal   theObjByVal)
{
pushAbs ();
d395 2
a396 2
firstPairLink ()->setDataTo (theObjByPtr, theObjByVal);
}
d400 7
a406 7
template <PairStArgDecs>
bool WitPairStack <PairStArgs>::pop (
ObjByPtr * & theObjByPtr,
ObjByVal &   theObjByVal)
{
if (isEmpty ())
return false;
d408 1
a408 1
theObjByPtr = reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());
d410 1
a410 1
theObjByVal = firstPairLink ()->myObjByVal ();
d412 1
a412 1
popAbs ();
d414 2
a415 2
return true;
}
d419 7
a425 7
template <PairStArgDecs>
void WitPairStack <PairStArgs>::revCopyFrom (
const WitPairStack & thePairStack)
{
WitPairStItr <PairStArgs> theItr;
ObjByPtr *                theObjByPtr;
ObjByVal                  theObjByVal;
d427 1
a427 1
clear ();
d429 1
a429 1
thePairStack.attachItr (theItr);
d431 3
a433 3
while (theItr.advance (theObjByPtr, theObjByVal))
push (theObjByPtr, theObjByVal);
}
d437 4
a440 4
template <PairStArgDecs>
ObjByPtr * WitPairStack <PairStArgs>::firstObject () const
{
witAssert (isNonEmpty ());
d442 2
a443 2
return reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());
}
d447 4
a450 4
template <PairStArgDecs>
ObjByVal WitPairStack <PairStArgs>::firstValue () const
{
witAssert (isNonEmpty ());
d452 2
a453 2
return firstPairLink ()->myObjByVal ();
}
d457 7
a463 7
template <PairStArgDecs>
bool WitPairStack <PairStArgs>::advance (
WitPairStItr <PairStArgs> & theItr,
ObjByPtr * &                theObjByPtr,
ObjByVal &                  theObjByVal)
{
const WitPairLink <ObjByVal> * thePairLink;
d465 1
a465 1
theItr.advanceAbs ();
d467 2
a468 2
thePairLink =
static_cast <const WitPairLink <ObjByVal> *> (theItr.curAbsLink ());
d470 2
a471 2
if (thePairLink == NULL)
return false;
d473 1
a473 1
theObjByPtr = reinterpret_cast <ObjByPtr *> (thePairLink->myObjByVP ());
d475 1
a475 1
theObjByVal = thePairLink->myObjByVal ();
d477 2
a478 2
return true;
}
d513 2
a514 2
template <typename ObjByPtr>
WitPerSglStack <ObjByPtr>::WitPerSglStack (WitProblem * theProblem):
d516 4
a519 4
myPairs_ (theProblem),
inStack_ ()
{
}
d523 4
a526 4
template <typename ObjByPtr>
WitPerSglStack <ObjByPtr>::~WitPerSglStack ()
{
}
d530 14
a543 14
template <typename ObjByPtr>
void WitPerSglStack <ObjByPtr>::push (
ObjByPtr * theObjByPtr,
WitPeriod  thePer)
{
if (inStack_.domainSize () == 0)
{
inStack_.allocate1D (myPairs_.myProblem ());
}

if (not inStack_ (theObjByPtr).isAllocated ())
{
inStack_ (theObjByPtr).allocate (myPairs_.myProblem (), false);
}
d545 2
a546 2
if (inStack_ (theObjByPtr)[thePer])
return;
d548 1
a548 1
myPairs_.push (theObjByPtr, thePer);
d550 2
a551 2
inStack_ (theObjByPtr)[thePer] = true;
}
d555 7
a561 7
template <typename ObjByPtr>
bool WitPerSglStack <ObjByPtr>::pop (
ObjByPtr * & theObjByPtr,
WitPeriod &  thePer)
{
if (myPairs_.isEmpty ())
return false;
d563 1
a563 1
myPairs_.pop (theObjByPtr, thePer);
d565 1
a565 1
inStack_ (theObjByPtr)[thePer] = false;
d567 2
a568 2
return true;
}
d588 3
a590 3
WitAbsStack (theProblem->myTripLinkMgr ())
{
}
d595 2
a596 2
{
}
d601 5
a605 5
void *    theObjByVP,
WitPeriod thePer,
double    theDbl)
{
pushAbs ();
d607 2
a608 2
firstTripLink ()->setDataTo (theObjByVP, thePer, theDbl);
}
d613 6
a618 6
void * &    theObjByVP,
WitPeriod & thePer,
double &    theDbl)
{
if (isEmpty ())
return false;
d620 1
a620 1
firstTripLink ()->getData (theObjByVP, thePer, theDbl);
d622 1
a622 1
popAbs ();
d624 2
a625 2
return true;
}
d630 3
a632 3
{
return static_cast <WitTripLink *> (firstAbsLink ());
}
d637 6
a642 6
{
WitAbsLink *  theAbsLink;
WitTripLink * theTripLink;
void *        theObjByVP;
WitPeriod     thePer;
double        theDbl;
d644 1
a644 1
clear ();
d646 1
a646 1
theAbsLink = theAbsTripStack.firstAbsLink ();
d648 3
a650 3
while (theAbsLink != NULL)
{
theTripLink = static_cast <WitTripLink *> (theAbsLink);
d652 1
a652 1
theTripLink->getData (theObjByVP, thePer, theDbl);
d654 1
a654 1
pushAbsTrip (theObjByVP, thePer, theDbl);
d656 3
a658 3
theAbsLink = theAbsLink->nextAbsLink ();
}
}
d665 3
a667 3
{
WitAbsLink * theAbsLink;
WitAbsLink * deadAbsLink;
d669 2
a670 2
if (theAbsLinkMgr == NULL)
return;
d672 1
a672 1
theAbsLink = theAbsLinkMgr->firstUnusedAbsLink_;
d674 4
a677 4
while (theAbsLink != NULL)
{
deadAbsLink = theAbsLink;
theAbsLink  = theAbsLink->nextAbsLink ();
d679 2
a680 2
theAbsLinkMgr->deleteAbsLink (deadAbsLink);
}
d682 2
a683 2
delete theAbsLinkMgr;
}
d688 2
a689 2
{
WitAbsLink * theFreshAbsLink;
d691 7
a697 7
if (firstUnusedAbsLink_ == NULL)
theFreshAbsLink     = newAbsLink ();
else
{
theFreshAbsLink     = firstUnusedAbsLink_;
firstUnusedAbsLink_ = theFreshAbsLink->nextAbsLink ();
}
d699 1
a699 1
theFreshAbsLink->linkTo (theAbsLink);
d701 2
a702 2
return theFreshAbsLink;
}
d707 2
a708 2
{
theAbsLink->linkTo (firstUnusedAbsLink_);
d710 2
a711 2
firstUnusedAbsLink_ = theAbsLink;
}
d716 1
a716 1
WitProbAssoc        (theProblem),
d718 3
a720 3
firstUnusedAbsLink_ (NULL)
{
}
d725 2
a726 2
{
}
d733 3
a735 3
WitAbsLinkMgr (theProblem)
{
}
d740 2
a741 2
{
}
d746 3
a748 3
{
return new WitObjLink;
}
d753 3
a755 3
{
delete static_cast <WitObjLink *> (theAbsLink);
}
d761 2
a762 2
template <typename ObjByVal>
WitPairLinkMgr <ObjByVal>::WitPairLinkMgr (WitProblem * theProblem):
d764 3
a766 3
WitAbsLinkMgr (theProblem)
{
}
d770 4
a773 4
template <typename ObjByVal>
WitPairLinkMgr <ObjByVal>::~WitPairLinkMgr ()
{
}
d777 5
a781 5
template <typename ObjByVal>
WitAbsLink * WitPairLinkMgr <ObjByVal>::newAbsLink ()
{
return new WitPairLink <ObjByVal>;
}
d785 5
a789 5
template <typename ObjByVal>
void WitPairLinkMgr <ObjByVal>::deleteAbsLink (WitAbsLink * theAbsLink)
{
delete static_cast <WitPairLink <ObjByVal> *> (theAbsLink);
}
d797 5
a801 5
WitPairLinkMgr <int> * WitPairLinkMgr <int>::theInstanceFor (
WitProblem * theProblem)
{
return theProblem->myIntPairLinkMgr ();
}
d806 5
a810 5
WitPairLinkMgr <bool> * WitPairLinkMgr <bool>::theInstanceFor (
WitProblem * theProblem)
{
return theProblem->myBoolPairLinkMgr ();
}
d815 5
a819 5
WitPairLinkMgr <double> * WitPairLinkMgr <double>::theInstanceFor (
WitProblem * theProblem)
{
return theProblem->myDblPairLinkMgr ();
}
d824 5
a828 5
WitPairLinkMgr <void *> *
WitPairLinkMgr <void *>::theInstanceFor (WitProblem * theProblem)
{
return theProblem->myVoidPtrPairLinkMgr ();
}
d844 3
a846 3
WitAbsLinkMgr (theProblem)
{
}
d851 2
a852 2
{
}
d857 3
a859 3
{
return new WitTripLink;
}
d864 3
a866 3
{
delete static_cast <WitTripLink *> (theAbsLink);
}
d873 3
a875 3
{
nextAbsLink_ = theAbsLink;
}
d880 3
a882 3
nextAbsLink_ (NULL)
{
}
d887 2
a888 2
{
}
d895 1
a895 1
WitAbsLink (),
d897 3
a899 3
myObjByVP_ (NULL)
{
}
d904 2
a905 2
{
}
d910 3
a912 3
{
myObjByVP_ = theObjByVP;
}
d918 3
a920 3
template <typename ObjByVal>
WitPairLink <ObjByVal>::WitPairLink ():
WitAbsLink  (),
d922 4
a925 4
myObjByVP_  (NULL),
myObjByVal_ ()
{
}
d929 4
a932 4
template <typename ObjByVal>
WitPairLink <ObjByVal>::~WitPairLink ()
{
}
d936 8
a943 8
template <typename ObjByVal>
void WitPairLink <ObjByVal>::setDataTo (
void *   theObjByVP,
ObjByVal theObjByVal)
{
myObjByVP_  = theObjByVP;
myObjByVal_ = theObjByVal;
}
d959 1
a959 1
WitAbsLink (),
d961 5
a965 5
myObjByVP_ (NULL),
myPer_     (-1),
myDbl_     (0.0)
{
}
d970 2
a971 2
{
}
d976 8
a983 8
void *    theObjByVP,
WitPeriod thePer,
double    theDbl)
{
myObjByVP_ = theObjByVP;
myPer_     = thePer;
myDbl_     = theDbl;
}
d988 9
a996 9
void * &    theObjByVP,
WitPeriod & thePer,
double &    theDbl)
const
{
theObjByVP = myObjByVP_;
thePer     = myPer_;
theDbl     = myDbl_;
}
@


1.98
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d49 4
a52 4
   {
   while (isNonEmpty ())
      popAbs ();
   }
d57 3
a59 3
   {
   int          nEl;
   WitAbsLink * theAbsLink;
d61 1
a61 1
   nEl = 0;
d63 1
a63 1
   theAbsLink = firstAbsLink_;
d65 3
a67 3
   while (theAbsLink != NULL)
      {
      nEl ++;
d69 2
a70 2
      theAbsLink = theAbsLink->nextAbsLink ();
      }
d72 2
a73 2
   return nEl;
   }
d78 17
a94 17
   {
   WitAbsLink * oldFirstAbsLink;
   WitAbsLink * theAbsLink;

   oldFirstAbsLink = firstAbsLink_;
   firstAbsLink_   = NULL;

   while (oldFirstAbsLink != NULL)
      {
      theAbsLink      = oldFirstAbsLink;
      oldFirstAbsLink = oldFirstAbsLink->nextAbsLink ();

      theAbsLink->linkTo (firstAbsLink_);

      firstAbsLink_   = theAbsLink;
      }
   }
d99 3
a101 3
   {
   return myAbsLinkMgr_->myProblem ();
   }
d107 4
a110 4
      myAbsLinkMgr_ (theAbsLinkMgr),
      firstAbsLink_ (NULL)
   {
   }
d115 3
a117 3
   {
   clear ();
   }
d122 3
a124 3
   {
   firstAbsLink_ = myAbsLinkMgr_->freshAbsLink (firstAbsLink_);
   }
d129 2
a130 2
   {
   WitAbsLink * theAbsLink;
d132 1
a132 1
   witAssert (isNonEmpty ());
d134 2
a135 2
   theAbsLink    = firstAbsLink_;
   firstAbsLink_ = theAbsLink->nextAbsLink ();
d137 2
a138 2
   myAbsLinkMgr_->recycleAbsLink (theAbsLink);
   }
d143 2
a144 2
   {
   witAssert (isEmpty ());
d146 3
a148 3
                firstAbsLink_ = thatAbsStack.firstAbsLink_;
   thatAbsStack.firstAbsLink_ = NULL;
   }
d153 4
a156 4
   {
   theAbsStItr.myAbsStack_ = this;
   theAbsStItr.curAbsLink_ = NULL;
   }
d163 4
a166 4
      myAbsStack_ (NULL),
      curAbsLink_ (NULL)
   {
   }
d171 2
a172 2
   {
   }
d177 2
a178 2
   {
   witAssert (myAbsStack_ != NULL);
d180 5
a184 5
   curAbsLink_ =
      (curAbsLink_ == NULL)?
         myAbsStack_->firstConstLink ():
         curAbsLink_->nextAbsLink ();
   }
d192 3
a194 3
      WitAbsStack (theProblem->myObjLinkMgr ())
   {
   }
d199 2
a200 2
   {
   }
d205 3
a207 3
   {
   WitAbsLink * theAbsLink;
   WitObjLink * theObjLink;
d209 1
a209 1
   clear ();
d211 1
a211 1
   theAbsLink = theAbsObjStack.firstAbsLink ();
d213 3
a215 3
   while (theAbsLink != NULL)
      {
      theObjLink = static_cast <WitObjLink *> (theAbsLink);
d217 1
a217 1
      pushAbsObj (theObjLink->myObjByVP ());
d219 3
a221 3
      theAbsLink = theObjLink->nextAbsLink ();
      }
   }
d226 9
a234 9
   {
   WitAbsObjStItr theItr;
   void *         theItrObjByVP;

   attachItrAbsObj (theItr);

   while (theItr.advanceAbsObj (theItrObjByVP))
      if (theItrObjByVP == theObjByVP)
         return true;
d236 2
a237 2
   return false;
   }
d242 2
a243 2
   {
   pushAbs ();
d245 2
a246 2
   firstObjLink ()->setDataTo (theObjByVP);
   }
d251 3
a253 3
   {
   if (isEmpty ())
      return false;
d255 1
a255 1
   theObjByVP = firstObjLink ()->myObjByVP ();
d257 1
a257 1
   popAbs ();
d259 2
a260 2
   return true;
   }
d265 3
a267 3
   {
   attachItrAbs (theAbsObjStItr);
   }
d272 12
a283 12
   {
   WitAbsObjStack revStack (myProblem ());
   void *         poppedObjByVP;

   while (popAbsObj (poppedObjByVP))
      if (poppedObjByVP != theObjByVP)
         revStack.pushAbsObj (poppedObjByVP);

   takeContentsFromAbs (revStack);
   
   reverse ();
   }
d288 2
a289 2
   {
   witAssert (not isEmpty ());
d291 2
a292 2
   return firstObjLink ()->myObjByVP ();
   }
d300 3
a302 3
      WitAbsStItr ()
   {
   }
d307 2
a308 2
   {
   }
d313 2
a314 2
   {
   const WitObjLink * theObjLink;
d316 1
a316 1
   advanceAbs ();
d318 1
a318 1
   theObjLink = static_cast <const WitObjLink *> (curAbsLink ());
d320 13
a332 13
   if (theObjLink != NULL)
      {
      theObjByVP = theObjLink->myObjByVP ();

      return true;
      }
   else
      {
      theObjByVP = NULL;

      return false;
      }
   }
d339 12
a350 12
      void WitNonClass::revCopyInto (
         WitObjStack <ObjByPtr> &   theObjStack,
         const WitList <ObjByPtr> & theList)
   {
   WitListItr theItr (theList);
   ObjByPtr * theObjByPtr;

   theObjStack.clear ();

   while (theList.advance (theItr, theObjByPtr))
      theObjStack.push (theObjByPtr);
   }
d357 2
a358 2
   WitObjStack            <WitPart> &,
   const WitList          <WitPart> &);
d361 2
a362 2
   WitObjStack            <WitOperation> &,
   const WitList          <WitOperation> &);
d365 2
a366 2
   WitObjStack            <WitSubEntry> &,
   const WitList          <WitSubEntry> &);
d372 2
a373 2
template <PairStArgDecs> 
      WitPairStack <PairStArgs>::WitPairStack (WitProblem * theProblem):
d375 3
a377 3
         WitAbsStack (WitPairLinkMgr <ObjByVal>::theInstanceFor (theProblem))
   {
   }
d381 4
a384 4
template <PairStArgDecs> 
      WitPairStack <PairStArgs>::~WitPairStack ()
   {
   }
d388 6
a393 6
template <PairStArgDecs> 
      void WitPairStack <PairStArgs>::push (
         ObjByPtr * theObjByPtr,
         ObjByVal   theObjByVal)
   {
   pushAbs ();
d395 2
a396 2
   firstPairLink ()->setDataTo (theObjByPtr, theObjByVal);
   }
d400 7
a406 7
template <PairStArgDecs> 
      bool WitPairStack <PairStArgs>::pop (
         ObjByPtr * & theObjByPtr, 
         ObjByVal &   theObjByVal)
   {
   if (isEmpty ())
      return false;
d408 1
a408 1
   theObjByPtr = reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());
d410 1
a410 1
   theObjByVal = firstPairLink ()->myObjByVal ();
d412 1
a412 1
   popAbs ();
d414 2
a415 2
   return true;
   }
d419 7
a425 7
template <PairStArgDecs> 
      void WitPairStack <PairStArgs>::revCopyFrom (
         const WitPairStack & thePairStack)
   {
   WitPairStItr <PairStArgs> theItr;
   ObjByPtr *                theObjByPtr;
   ObjByVal                  theObjByVal;
d427 1
a427 1
   clear ();
d429 1
a429 1
   thePairStack.attachItr (theItr);
d431 3
a433 3
   while (theItr.advance (theObjByPtr, theObjByVal))
      push (theObjByPtr, theObjByVal);
   }
d437 4
a440 4
template <PairStArgDecs> 
      ObjByPtr * WitPairStack <PairStArgs>::firstObject () const
   {
   witAssert (isNonEmpty ());
d442 2
a443 2
   return reinterpret_cast <ObjByPtr *> (firstPairLink ()->myObjByVP ());
   }
d447 4
a450 4
template <PairStArgDecs> 
      ObjByVal WitPairStack <PairStArgs>::firstValue () const
   {
   witAssert (isNonEmpty ());
d452 2
a453 2
   return firstPairLink ()->myObjByVal ();
   }
d457 7
a463 7
template <PairStArgDecs> 
      bool WitPairStack <PairStArgs>::advance (
         WitPairStItr <PairStArgs> & theItr,
         ObjByPtr * &                theObjByPtr,
         ObjByVal &                  theObjByVal)
   {
   const WitPairLink <ObjByVal> * thePairLink;
d465 1
a465 1
   theItr.advanceAbs ();
d467 2
a468 2
   thePairLink =
      static_cast <const WitPairLink <ObjByVal> *> (theItr.curAbsLink ());
d470 2
a471 2
   if (thePairLink == NULL)
      return false;
d473 1
a473 1
   theObjByPtr = reinterpret_cast <ObjByPtr *> (thePairLink->myObjByVP ());
d475 1
a475 1
   theObjByVal = thePairLink->myObjByVal ();
d477 2
a478 2
   return true;
   }
d513 2
a514 2
template <typename ObjByPtr> 
      WitPerSglStack <ObjByPtr>::WitPerSglStack (WitProblem * theProblem):
d516 4
a519 4
      myPairs_ (theProblem),
      inStack_ ()
   {
   }
d523 4
a526 4
template <typename ObjByPtr> 
      WitPerSglStack <ObjByPtr>::~WitPerSglStack ()
   {
   }
d530 14
a543 14
template <typename ObjByPtr> 
      void WitPerSglStack <ObjByPtr>::push (
         ObjByPtr * theObjByPtr,
         WitPeriod  thePer)
   {
   if (inStack_.domainSize () == 0)
      {
      inStack_.allocate1D (myPairs_.myProblem ());
      }

   if (not inStack_ (theObjByPtr).isAllocated ())
      {
      inStack_ (theObjByPtr).allocate (myPairs_.myProblem (), false);
      }
d545 2
a546 2
   if (inStack_ (theObjByPtr)[thePer])
      return;
d548 1
a548 1
   myPairs_.push (theObjByPtr, thePer);
d550 2
a551 2
   inStack_ (theObjByPtr)[thePer] = true;
   }
d555 7
a561 7
template <typename ObjByPtr> 
      bool WitPerSglStack <ObjByPtr>::pop (
         ObjByPtr * & theObjByPtr,
         WitPeriod &  thePer)
   {
   if (myPairs_.isEmpty ())
      return false;
d563 1
a563 1
   myPairs_.pop (theObjByPtr, thePer);
d565 1
a565 1
   inStack_ (theObjByPtr)[thePer] = false;
d567 2
a568 2
   return true;
   }
d588 3
a590 3
      WitAbsStack (theProblem->myTripLinkMgr ())
   {
   }
d595 2
a596 2
   {
   }
d601 5
a605 5
      void *    theObjByVP,
      WitPeriod thePer,
      double    theDbl)
   {
   pushAbs ();
d607 2
a608 2
   firstTripLink ()->setDataTo (theObjByVP, thePer, theDbl);
   }
d613 6
a618 6
      void * &    theObjByVP,
      WitPeriod & thePer,
      double &    theDbl)
   {
   if (isEmpty ())
      return false;
d620 1
a620 1
   firstTripLink ()->getData (theObjByVP, thePer, theDbl);
d622 1
a622 1
   popAbs ();
d624 2
a625 2
   return true;
   }
d630 3
a632 3
   {
   return static_cast <WitTripLink *> (firstAbsLink ());
   }
d637 6
a642 6
   {
   WitAbsLink *  theAbsLink;
   WitTripLink * theTripLink;
   void *        theObjByVP;
   WitPeriod     thePer;
   double        theDbl;
d644 1
a644 1
   clear ();
d646 1
a646 1
   theAbsLink = theAbsTripStack.firstAbsLink ();
d648 3
a650 3
   while (theAbsLink != NULL)
      {
      theTripLink = static_cast <WitTripLink *> (theAbsLink);
d652 1
a652 1
      theTripLink->getData (theObjByVP, thePer, theDbl);
d654 1
a654 1
      pushAbsTrip (theObjByVP, thePer, theDbl);
d656 3
a658 3
      theAbsLink = theAbsLink->nextAbsLink ();
      }
   }
d665 3
a667 3
   {
   WitAbsLink * theAbsLink;
   WitAbsLink * deadAbsLink;
d669 2
a670 2
   if (theAbsLinkMgr == NULL)
      return;
d672 1
a672 1
   theAbsLink = theAbsLinkMgr->firstUnusedAbsLink_;
d674 4
a677 4
   while (theAbsLink != NULL)
      {
      deadAbsLink = theAbsLink;
      theAbsLink  = theAbsLink->nextAbsLink ();
d679 2
a680 2
      theAbsLinkMgr->deleteAbsLink (deadAbsLink);
      }
d682 2
a683 2
   delete theAbsLinkMgr;
   }
d688 2
a689 2
   {
   WitAbsLink * theFreshAbsLink;
d691 7
a697 7
   if (firstUnusedAbsLink_ == NULL)
      theFreshAbsLink     = newAbsLink ();
   else
      {
      theFreshAbsLink     = firstUnusedAbsLink_;
      firstUnusedAbsLink_ = theFreshAbsLink->nextAbsLink ();
      }
d699 1
a699 1
   theFreshAbsLink->linkTo (theAbsLink);
d701 2
a702 2
   return theFreshAbsLink;
   }
d707 2
a708 2
   {
   theAbsLink->linkTo (firstUnusedAbsLink_);
d710 2
a711 2
   firstUnusedAbsLink_ = theAbsLink;
   }
d716 1
a716 1
      WitProbAssoc        (theProblem),
d718 3
a720 3
      firstUnusedAbsLink_ (NULL)
   {
   }
d725 2
a726 2
   {
   }
d733 3
a735 3
      WitAbsLinkMgr (theProblem)
   {
   }
d740 2
a741 2
   {
   }
d746 3
a748 3
   {
   return new WitObjLink;
   }
d753 3
a755 3
   {
   delete static_cast <WitObjLink *> (theAbsLink);
   }
d761 2
a762 2
template <typename ObjByVal> 
      WitPairLinkMgr <ObjByVal>::WitPairLinkMgr (WitProblem * theProblem):
d764 3
a766 3
         WitAbsLinkMgr (theProblem)
   {
   }
d770 4
a773 4
template <typename ObjByVal> 
      WitPairLinkMgr <ObjByVal>::~WitPairLinkMgr ()
   {
   }
d777 5
a781 5
template <typename ObjByVal> 
      WitAbsLink * WitPairLinkMgr <ObjByVal>::newAbsLink ()
   {
   return new WitPairLink <ObjByVal>;
   }
d785 5
a789 5
template <typename ObjByVal> 
      void WitPairLinkMgr <ObjByVal>::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete static_cast <WitPairLink <ObjByVal> *> (theAbsLink);
   }
d797 5
a801 5
      WitPairLinkMgr <int> * WitPairLinkMgr <int>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myIntPairLinkMgr ();
   }
d806 5
a810 5
      WitPairLinkMgr <bool> * WitPairLinkMgr <bool>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myBoolPairLinkMgr ();
   }
d815 5
a819 5
      WitPairLinkMgr <double> * WitPairLinkMgr <double>::theInstanceFor (
         WitProblem * theProblem)
   {
   return theProblem->myDblPairLinkMgr ();
   }
d824 5
a828 5
      WitPairLinkMgr <void *> * 
         WitPairLinkMgr <void *>::theInstanceFor (WitProblem * theProblem)
   {
   return theProblem->myVoidPtrPairLinkMgr ();
   }
d844 3
a846 3
      WitAbsLinkMgr (theProblem)
   {
   }
d851 2
a852 2
   {
   }
d857 3
a859 3
   {
   return new WitTripLink;
   }
d864 3
a866 3
   {
   delete static_cast <WitTripLink *> (theAbsLink);
   }
d873 3
a875 3
   {
   nextAbsLink_ = theAbsLink;
   }
d880 3
a882 3
      nextAbsLink_ (NULL)
   {
   }
d887 2
a888 2
   {
   }
d895 1
a895 1
      WitAbsLink (),
d897 3
a899 3
      myObjByVP_ (NULL)
   {
   }
d904 2
a905 2
   {
   }
d910 3
a912 3
   {
   myObjByVP_ = theObjByVP;
   }
d918 3
a920 3
template <typename ObjByVal> 
      WitPairLink <ObjByVal>::WitPairLink ():
         WitAbsLink  (),
d922 4
a925 4
         myObjByVP_  (NULL),
         myObjByVal_ ()
   {
   }
d929 4
a932 4
template <typename ObjByVal> 
      WitPairLink <ObjByVal>::~WitPairLink ()
   {
   }
d936 8
a943 8
template <typename ObjByVal> 
      void WitPairLink <ObjByVal>::setDataTo (
         void *   theObjByVP,
         ObjByVal theObjByVal)
   {
   myObjByVP_  = theObjByVP;
   myObjByVal_ = theObjByVal;
   }
d959 1
a959 1
      WitAbsLink (),
d961 5
a965 5
      myObjByVP_ (NULL),
      myPer_     (-1),
      myDbl_     (0.0)
   {
   }
d970 2
a971 2
   {
   }
d976 8
a983 8
      void *    theObjByVP,
      WitPeriod thePer,
      double    theDbl)
   {
   myObjByVP_ = theObjByVP;
   myPer_     = thePer;
   myDbl_     = theDbl;
   }
d988 9
a996 9
      void * &    theObjByVP,
      WitPeriod & thePer,
      double &    theDbl)
      const
   {
   theObjByVP = myObjByVP_;
   thePer     = myPer_;
   theDbl     = myDbl_;
   }
@


1.97
log
@Modifiable Heuristic Allocation
@
text
@d574 1
@


1.96
log
@Modifiable Heuristic Allocation
@
text
@d37 4
a42 2
#include <Material.h>
#include <BopEntry.h>
d575 2
@


1.95
log
@Modifiable Heuristic Allocation
@
text
@d37 1
d39 2
d572 3
@


1.94
log
@Heuristic Adjustment
@
text
@d20 1
d33 1
a33 1
#include <PairStack.h>
d37 2
d505 67
@


1.93
log
@Selection Recovery
@
text
@d483 2
a485 1
template class WitPairStack <WitSubEntry,  int>;
@


1.92
log
@ASAP Pegging Order
@
text
@d481 1
@


1.91
log
@execVol pegging for BOP entries.
@
text
@d134 1
a134 1
void WitAbsStack::passContentsToAbs (WitAbsStack & theAbsStack)
d136 1
a136 1
   witAssert (theAbsStack.isEmpty ());
d138 2
a139 2
   theAbsStack.firstAbsLink_ = firstAbsLink_;
   firstAbsLink_             = NULL;
d272 1
a272 1
   revStack.passContentsToAbs (* this);
@


1.90
log
@GPIP migration.
@
text
@d482 1
@


1.89
log
@New PIP pegging order.
@
text
@d476 2
a477 2
template class WitPairStack <bool,          bool>;
template class WitPairStack <WitPart,       bool>;
d479 16
a494 16
template class WitPairStack <int,           int>;
template class WitPairStack <WitPart,       int>;
template class WitPairStack <WitOperation,  int>;
template class WitPairStack <WitSubEntry,   int>;
template class WitPairStack <WitDemand,     int>;
template class WitPairStack <WitRtCand,     int>;
template class WitPairStack <WitBaMat,      int>;
template class WitPairStack <WitRtSite,     int>;

template class WitPairStack <double,        double>;
template class WitPairStack <WitFixedPer,   double>;
template class WitPairStack <WitRtCand,     double>;
template class WitPairStack <WitSelPt,      double>;
template class WitPairStack <WitSelCand,    double>;
template class WitPairStack <WitGpipSeqEl,  double>;
template class WitPairStack <WitGpipReqSrc, double>;
@


1.88
log
@New PIP pegging order.
@
text
@d42 2
a43 1
   while (popAbs ());
d120 1
a120 1
bool WitAbsStack::popAbs ()
d124 1
a124 2
   if (isEmpty ())
      return false;
a129 2

   return true;
d244 2
a245 3
   if (isNonEmpty ())
      {
      theObjByVP = firstObjLink ()->myObjByVP ();
d247 1
a247 1
      popAbs ();
d249 1
a249 5
      return true;
      }
   else
      {
      theObjByVP = NULL;
d251 1
a251 2
      return false;
      }
@


1.87
log
@New PIP pegging order.
@
text
@d138 1
a138 1
   theAbsStack.clear ();
@


1.86
log
@Updated the copyright date on all source files.
@
text
@d136 1
a136 1
void WitAbsStack::takeContentsAbs (WitAbsStack & theAbsStack)
d138 1
a138 1
   clear ();
d140 2
a141 2
   firstAbsLink_             = theAbsStack.firstAbsLink_;
   theAbsStack.firstAbsLink_ = NULL;
d246 3
a248 2
   if (isEmpty ())
      return false;
d250 1
a250 1
   theObjByVP = firstObjLink ()->myObjByVP ();
d252 5
a256 1
   popAbs ();
d258 2
a259 1
   return true;
d280 1
a280 1
   takeContentsAbs (revStack);
d320 3
a322 2
   if (theObjLink == NULL)
      return false;
d324 5
a328 1
   theObjByVP = theObjLink->myObjByVP ();
d330 2
a331 1
   return true;
@


1.85
log
@GPIP
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.84
log
@[shared-resource pegging]
@
text
@d472 2
a473 2
template class WitPairStack <bool,         bool>;
template class WitPairStack <WitPart,      bool>;
d475 16
a490 16
template class WitPairStack <int,          int>;
template class WitPairStack <WitPart,      int>;
template class WitPairStack <WitOperation, int>;
template class WitPairStack <WitSubEntry,  int>;
template class WitPairStack <WitDemand,    int>;
template class WitPairStack <WitRtCand,    int>;
template class WitPairStack <WitBaMat,     int>;
template class WitPairStack <WitRtSite,    int>;

template class WitPairStack <double,       double>;
template class WitPairStack <WitFixedPer,  double>;
template class WitPairStack <WitRtCand,    double>;
template class WitPairStack <WitSelPt,     double>;
template class WitPairStack <WitSelCand,   double>;
template class WitPairStack <WitSrpSeqEl,  double>;
template class WitPairStack <WitSrpReqSrc, double>;
@


1.83
log
@[shared-resource pegging]
@
text
@a488 1
template class WitPairStack <WitPipTarg,   double>;
@


1.82
log
@[shared-resource pegging]
@
text
@d489 1
a489 1
template class WitPairStack <WitUrpTarg,   double>;
@


1.81
log
@[shared-resource pegging]
@
text
@d146 1
a146 1
void WitAbsStack::attachAbs (WitAbsStItr & theAbsStItr) const
d224 1
a224 1
   attachAbsObj (theItr);
d258 1
a258 1
void WitAbsObjStack::attachAbsObj (WitAbsObjStItr & theAbsObjStItr) const
d260 1
a260 1
   attachAbs (theAbsObjStItr);
d417 1
a417 1
   thePairStack.attach (theItr);
@


1.80
log
@[shared-resource pegging]
@
text
@d491 1
@


1.79
log
@[shared-resource pegging]
@
text
@d490 1
@


1.78
log
@[shared-resource pegging]
@
text
@a18 2
//    DblDblStack
//    DblDblStItr
a22 1
//    DblDblLinkMgr
a26 1
//    DblDblLink
a31 1
#include <DblDblStack.h>
a322 95
// Implementation of class DblDblStack.
//------------------------------------------------------------------------------

WitDblDblStack::WitDblDblStack (WitProblem * theProblem):

      WitAbsStack (theProblem->myDblDblLinkMgr ())
   {
   }

//------------------------------------------------------------------------------

WitDblDblStack::~WitDblDblStack ()
   {
   }

//------------------------------------------------------------------------------

void WitDblDblStack::push (double theDbl1, double theDbl2)
   {
   pushAbs ();

   firstDblDblLink ()->setDataTo (theDbl1, theDbl2);
   }

//------------------------------------------------------------------------------

bool WitDblDblStack::pop (double & theDbl1, double & theDbl2)
   {
   if (isEmpty ())
      return false;

   firstDblDblLink ()->getData (theDbl1, theDbl2);

   popAbs ();

   return true;
   }

//------------------------------------------------------------------------------

void WitDblDblStack::revCopyFrom (const WitDblDblStack & theDblDblStack)
   {
   WitDblDblStItr theItr;
   double         theDbl1;
   double         theDbl2;

   clear ();

   theDblDblStack.attach (theItr);

   while (theItr.advance (theDbl1, theDbl2))
      push (theDbl1, theDbl2);
   }

//------------------------------------------------------------------------------

void WitDblDblStack::attach (WitDblDblStItr & theDblDblStItr) const
   {
   attachAbs (theDblDblStItr);
   }

//------------------------------------------------------------------------------
// Implementation of class DblDblStItr.
//------------------------------------------------------------------------------

WitDblDblStItr::WitDblDblStItr ():
      WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

WitDblDblStItr::~WitDblDblStItr ()
   {
   }

//------------------------------------------------------------------------------

bool WitDblDblStItr::advance (double & theDbl1, double & theDbl2)
   {
   const WitDblDblLink * theDblDblLink;

   advanceAbs ();

   theDblDblLink = static_cast <const WitDblDblLink *> (curAbsLink ());

   if (theDblDblLink == NULL)
      return false;

   theDblDblLink->getData (theDbl1, theDbl2);

   return true;
   }

//------------------------------------------------------------------------------
a668 29
// Implementation of class DblDblLinkMgr.
//------------------------------------------------------------------------------

WitDblDblLinkMgr::WitDblDblLinkMgr (WitProblem * theProblem):
      WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitDblDblLinkMgr::~WitDblDblLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAbsLink * WitDblDblLinkMgr::newAbsLink ()
   {
   return new WitDblDblLink;
   }

//------------------------------------------------------------------------------

void WitDblDblLinkMgr::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete static_cast <WitDblDblLink *> (theAbsLink);
   }

//------------------------------------------------------------------------------
a825 35
// Implementation of class DblDblLink.
//------------------------------------------------------------------------------

WitDblDblLink::WitDblDblLink ():

      WitAbsLink (),

      myDbl1_    (0.0),
      myDbl2_    (0.0)
   {
   }

//------------------------------------------------------------------------------

WitDblDblLink::~WitDblDblLink ()
   {
   }

//------------------------------------------------------------------------------

void WitDblDblLink::setDataTo (double theDbl1, double theDbl2)
   {
   myDbl1_ = theDbl1;
   myDbl2_ = theDbl2;
   }

//------------------------------------------------------------------------------

void WitDblDblLink::getData (double & theDbl1, double & theDbl2) const
   {
   theDbl1 = myDbl1_;
   theDbl2 = myDbl2_;
   }

//------------------------------------------------------------------------------
@


1.77
log
@[shared-resource pegging]
@
text
@d572 2
a573 2
template class WitPairStack <bool,           bool>;
template class WitPairStack <WitPart,        bool>;
d575 15
a589 16
template class WitPairStack <int,            int>;
template class WitPairStack <WitPart,        int>;
template class WitPairStack <WitOperation,   int>;
template class WitPairStack <WitSubEntry,    int>;
template class WitPairStack <WitDemand,      int>;
template class WitPairStack <WitRtCand,      int>;
template class WitPairStack <WitBaMat,       int>;
template class WitPairStack <WitRtSite,      int>;

template class WitPairStack <double,         double>;
template class WitPairStack <WitFixedPer,    double>;
template class WitPairStack <WitRtCand,      double>;
template class WitPairStack <WitSelPt,       double>;
template class WitPairStack <WitSelCand,     double>;
template class WitPairStack <WitUrpTarg,     double>;
template class WitPairStack <WitSrpFillMeth, double>;
d591 1
a591 1
template class WitPairStack <void *,         void *>;
@


1.76
log
@[shared-resource peging]
@
text
@d592 1
a592 1
template class WitPairStack <void *,       void *>;
@


1.75
log
@[shared-resource pegging]
@
text
@d368 16
@


1.74
log
@[shared-resource pegging]
@
text
@d556 2
a557 2
template class WitPairStack <bool,         bool>;
template class WitPairStack <WitPart,      bool>;
d559 16
a574 15
template class WitPairStack <int,          int>;
template class WitPairStack <WitPart,      int>;
template class WitPairStack <WitOperation, int>;
template class WitPairStack <WitSubEntry,  int>;
template class WitPairStack <WitDemand,    int>;
template class WitPairStack <WitRtCand,    int>;
template class WitPairStack <WitBaMat,     int>;
template class WitPairStack <WitRtSite,    int>;

template class WitPairStack <double,       double>;
template class WitPairStack <WitFixedPer,  double>;
template class WitPairStack <WitRtCand,    double>;
template class WitPairStack <WitSelPt,     double>;
template class WitPairStack <WitSelCand,   double>;
template class WitPairStack <WitUrpTarg,   double>;
@


1.73
log
@[shared-resource pegging]
@
text
@d150 8
a174 8
void WitAbsStItr::attachToAbs (const WitAbsStack & theAbsStack)
   {
   myAbsStack_ = & theAbsStack;
   curAbsLink_ =   NULL;
   }

//------------------------------------------------------------------------------

d229 1
a229 1
   theItr.attachToAbsObj (* this);
d263 7
d367 7
a389 7
void WitDblDblStItr::attachTo (const WitDblDblStack & theDblDblStack)
   {
   attachToAbs (theDblDblStack);
   }

//------------------------------------------------------------------------------

d501 1
a501 1
   theItr.attachTo (thePairStack);
@


1.72
log
@[shared-resource pegging]
@
text
@d18 1
d167 8
a185 8

void WitAbsStItr::attachToAbs (const WitAbsStack & theAbsStack)
   {
   myAbsStack_  = & theAbsStack;
   curAbsLink_  =   NULL;
   }

//------------------------------------------------------------------------------
d226 2
a227 2
   WitAbsStItr theItr;
   void *      theItrObjByVP;
d229 1
a229 1
   theItr.attachToAbs (* this);
d231 1
a231 1
   while (advanceAbsObj (theItr, theItrObjByVP))
d287 4
d292 13
a304 3
bool WitAbsObjStack::advanceAbsObj (
      WitAbsStItr & theItr,
      void * &      theObjByVP)
d308 1
a308 1
   theItr.advanceAbs ();
d310 1
a310 1
   theObjLink = static_cast <const WitObjLink *> (theItr.curAbsLink ());
a359 21

bool WitDblDblStack::advance (
      WitDblDblStItr & theItr,
      double &         theDbl1,
      double &         theDbl2)
   {
   const WitDblDblLink * theDblDblLink;

   theItr.advanceAbs ();

   theDblDblLink = static_cast <const WitDblDblLink *> (theItr.curAbsLink ());

   if (theDblDblLink == NULL)
      return false;

   theDblDblLink->getData (theDbl1, theDbl2);

   return true;
   }

//------------------------------------------------------------------------------
d382 18
@


1.71
log
@[shared-resource pegging]
@
text
@d19 1
d337 1
a337 1
   firstDblDblLink ()->getDataAs (theDbl1, theDbl2);
d345 43
d948 1
a948 1
void WitDblDblLink::getDataAs (double & theDbl1, double & theDbl2)
d1031 1
@


1.70
log
@[shared-resource pegging]
@
text
@d330 14
d903 8
@


1.69
log
@[shared-resource pegging]
@
text
@d18 1
d34 1
d305 25
@


1.68
log
@[shared-resource pegging]
Update to error exceptions.
@
text
@d22 1
d649 29
@


1.67
log
@[shared-resource pegging]
@
text
@d26 1
d805 27
@


1.66
log
@[shared-resource pegging]
@
text
@d716 1
a716 1
   return theProblem->myTlPtrPairLinkMgr ();
@


1.65
log
@[shared-resource pegging]
@
text
@d210 1
a210 1
      pushAbsObj (theObjLink->myTlObj ());
d218 1
a218 1
bool WitAbsObjStack::containsAbs (WitTlObj * theTlObj) const
d221 1
a221 1
   WitTlObj *  theItrTlObj;
d225 2
a226 2
   while (advanceAbsObj (theItr, theItrTlObj))
      if (theItrTlObj == theTlObj)
d234 1
a234 1
void WitAbsObjStack::pushAbsObj (WitTlObj * theTlObj)
d238 1
a238 1
   firstObjLink ()->setDataTo (theTlObj);
d243 1
a243 1
bool WitAbsObjStack::popAbsObj (WitTlObj * & theTlObj)
d248 1
a248 1
   theTlObj = firstObjLink ()->myTlObj ();
d257 1
a257 1
void WitAbsObjStack::removeAbs (WitTlObj * theTlObj)
d260 1
a260 1
   WitTlObj *     poppedTlObj;
d262 3
a264 3
   while (popAbsObj (poppedTlObj))
      if (poppedTlObj != theTlObj)
         revStack.pushAbsObj (poppedTlObj);
d273 1
a273 1
WitTlObj * WitAbsObjStack::firstTlObj () const
d277 1
a277 1
   return firstObjLink ()->myTlObj ();
d284 1
a284 1
      WitTlObj * &  theTlObj)
d295 1
a295 1
   theTlObj = theObjLink->myTlObj ();
d361 1
a361 1
   firstPairLink ()->setDataTo (toTlObj_cast (theObjByPtr), theObjByVal);
d374 1
a374 1
   theObjByPtr   = fromTlObj_cast <ObjByPtr> (firstPairLink ()->myTlObj ());
d408 1
a408 1
   return fromTlObj_cast <ObjByPtr> (firstPairLink ()->myTlObj ());
d439 1
a439 1
   theObjByPtr = fromTlObj_cast <ObjByPtr> (thePairLink->myTlObj ());
d469 1
a469 1
template class WitPairStack <WitTlObj *,   WitTlObj *>;
d490 3
a492 3
      WitTlObj * theTlObj,
      WitPeriod  thePer,
      double     theDbl)
d496 1
a496 1
   firstTripLink ()->setDataTo (theTlObj, thePer, theDbl);
d502 3
a504 3
      WitTlObj * & theTlObj,
      WitPeriod &  thePer,
      double &     theDbl)
d509 1
a509 1
   firstTripLink ()->getData (theTlObj, thePer, theDbl);
d529 1
a529 1
   WitTlObj *    theTlObj;
d541 1
a541 1
      theTripLink->getData        (theTlObj, thePer, theDbl);
d543 1
a543 1
      pushAbsTrip (theTlObj, thePer, theDbl);
d713 2
a714 2
      WitPairLinkMgr <WitTlObj *> * 
         WitPairLinkMgr <WitTlObj *>::theInstanceFor (WitProblem * theProblem)
d726 1
a726 1
template class WitPairLinkMgr <WitTlObj *>;
d786 1
a786 1
      myTlObj_   (NULL)
d798 1
a798 1
void WitObjLink::setDataTo (WitTlObj * theTlObj)
d800 1
a800 1
   myTlObj_ = theTlObj;
d811 1
a811 1
         myTlObj_    (NULL),
d827 2
a828 2
         WitTlObj * theTlObj,
         ObjByVal   theObjByVal)
d830 1
a830 1
   myTlObj_    = theTlObj;
d841 1
a841 1
template class WitPairLink <WitTlObj *>;
d850 1
a850 1
      myTlObj_   (NULL),
d865 7
a871 7
      WitTlObj * theTlObj,
      WitPeriod  thePer,
      double     theDbl)
   {
   myTlObj_ = theTlObj;
   myPer_   = thePer;
   myDbl_   = theDbl;
d877 7
a883 7
      WitTlObj * & theTlObj,
      WitPeriod &  thePer,
      double &     theDbl)
   {
   theTlObj = myTlObj_;
   thePer   = myPer_;
   theDbl   = myDbl_;
@


1.64
log
@[shared-resource pegging]
@
text
@d18 1
a18 1
//    PairStack <ObjType, ValType>, with explicit instantiation
d22 1
a22 1
//    PairLinkMgr <ValType>, with explicit instantiation
d26 1
a26 1
//    PairLink <ValType>, with explicit instantiation
d304 1
a304 1
template <typename ObjType>
d306 2
a307 2
         WitObjStack <ObjType> &   theObjStack,
         const WitList <ObjType> & theList)
d310 1
a310 1
   ObjType *  theObject;
d314 2
a315 2
   while (theList.advance (theItr, theObject))
      theObjStack.push (theObject);
d335 1
a335 1
// Implementation of class template PairStack <ObjType, ValType>.
d341 1
a341 1
         WitAbsStack (WitPairLinkMgr <ValType>::theInstanceFor (theProblem))
d355 3
a357 1
      void WitPairStack <PairStArgs>::push (ObjType * theObject, ValType theVal)
d361 1
a361 1
   firstPairLink ()->setDataTo (toTlObj_cast (theObject), theVal);
d368 2
a369 2
         ObjType * & theObject, 
         ValType &   theVal)
d374 1
a374 1
   theObject = fromTlObj_cast <ObjType> (firstPairLink ()->myTlObj ());
d376 1
a376 1
   theVal    = firstPairLink ()->myValue ();
d390 2
a391 2
   ObjType *                 theObject;
   ValType                   theVal;
d397 2
a398 2
   while (theItr.advance (theObject, theVal))
      push (theObject, theVal);
d404 1
a404 1
      ObjType * WitPairStack <PairStArgs>::firstObject () const
d408 1
a408 1
   return fromTlObj_cast <ObjType> (firstPairLink ()->myTlObj ());
d414 1
a414 1
      ValType WitPairStack <PairStArgs>::firstValue () const
d418 1
a418 1
   return firstPairLink ()->myValue ();
d426 2
a427 2
         ObjType * &                 theObject,
         ValType &                   theVal)
d429 1
a429 1
   const WitPairLink <ValType> * thePairLink;
d434 1
a434 1
      static_cast <const WitPairLink <ValType> *> (theItr.curAbsLink ());
d439 1
a439 1
   theObject = fromTlObj_cast <ObjType> (thePairLink->myTlObj ());
d441 1
a441 1
   theVal    = thePairLink->myValue ();
d447 1
a447 1
// Explicit instantiation of class template PairStack <ObjType, ValType>.
d647 1
a647 1
// Implementation of class template PairLinkMgr <ValType>.
d650 2
a651 2
template <typename ValType> 
      WitPairLinkMgr <ValType>::WitPairLinkMgr (WitProblem * theProblem):
d659 2
a660 2
template <typename ValType> 
      WitPairLinkMgr <ValType>::~WitPairLinkMgr ()
d666 2
a667 2
template <typename ValType> 
      WitAbsLink * WitPairLinkMgr <ValType>::newAbsLink ()
d669 1
a669 1
   return new WitPairLink <ValType>;
d674 2
a675 2
template <typename ValType> 
      void WitPairLinkMgr <ValType>::deleteAbsLink (WitAbsLink * theAbsLink)
d677 1
a677 1
   delete static_cast <WitPairLink <ValType> *> (theAbsLink);
d681 1
a681 1
// Non-parametric implementation of class template PairLinkMgr <ValType> member
d720 1
a720 1
// Explicit instantiation of class template PairLink <ValType>.
d804 1
a804 1
// Implementation of class template PairLink <ValType>.
d807 3
a809 3
template <typename ValType> 
      WitPairLink <ValType>::WitPairLink ():
         WitAbsLink (),
d811 2
a812 2
         myTlObj_   (NULL),
         myValue_   ()
d818 2
a819 2
template <typename ValType> 
      WitPairLink <ValType>::~WitPairLink ()
d825 2
a826 2
template <typename ValType> 
      void WitPairLink <ValType>::setDataTo (
d828 1
a828 1
         ValType    theVal)
d830 2
a831 2
   myTlObj_ = theTlObj;
   myValue_ = theVal;
d835 1
a835 1
// Explicit instantiation of class template PairLink <ValType>.
@


1.63
log
@Tie Breaking Prop-Rt.
@
text
@d465 1
a465 1
template class WitPairStack <WitPipTarg,   double>;
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@d465 1
a465 1
template class WitPairStack <WitPip::Targ, double>;
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d458 1
@


1.60
log
@Low-Pri Prop-Rt.
@
text
@a300 9

bool WitAbsObjStack::advanceAbsObj (WitAbsStItr & theItr)
   {
   theItr.advanceAbs ();

   return (theItr.curAbsLink () != NULL);
   }

//------------------------------------------------------------------------------
@


1.59
log
@Low-Pri Prop-Rt.
@
text
@d457 2
a458 2
template class WitPairStack <bool,                      bool>;
template class WitPairStack <WitPart,                   bool>;
d460 14
a473 14
template class WitPairStack <int,                       int>;
template class WitPairStack <WitPart,                   int>;
template class WitPairStack <WitOperation,              int>;
template class WitPairStack <WitSubEntry,               int>;
template class WitPairStack <WitDemand,                 int>;
template class WitPairStack <WitRtCand,                 int>;
template class WitPairStack <WitBaMat,                  int>;

template class WitPairStack <double,                    double>;
template class WitPairStack <WitFixedPer,               double>;
template class WitPairStack <WitRtCand,                 double>;
template class WitPairStack <WitSelPt,                  double>;
template class WitPairStack <WitSelCand,                double>;
template class WitPairStack <WitPip::Targ,              double>;
d475 1
a475 1
template class WitPairStack <WitTlObj *,                WitTlObj *>;
@


1.58
log
@Continued implementation of PIP.
@
text
@d413 1
a413 1
   witAssert (not isEmpty ());
d421 10
@


1.57
log
@Continued implementation of PIP.
@
text
@a458 1
template class WitPairStack <WitDemPer,                 double>;
a462 3
template class WitPairStack <WitPerPair <WitPart>,      double>;
template class WitPairStack <WitPerPair <WitOperation>, double>;
template class WitPairStack <WitPerPair <WitSubEntry>,  double>;
@


1.56
log
@Continued implementation of PIP.
@
text
@d19 1
d23 1
d27 1
d32 1
d197 1
a197 1
void WitAbsObjStack::revCopyIntoAbs (WitAbsObjStack & theAbsObjStack) const
d199 1
d202 1
a202 1
   theAbsObjStack.clear ();
d204 1
a204 1
   theObjLink = firstObjLink ();
d206 1
a206 1
   while (theObjLink != NULL)
d208 3
a210 1
      theAbsObjStack.pushAbsObj (theObjLink->myTlObj ());
d212 1
a212 1
      theObjLink = static_cast <WitObjLink *> (theObjLink->nextAbsLink ());
d472 78
d729 29
d841 44
a884 1
//mplate class WitPairLink <WitTlObj *>;
@


1.55
log
@Continued implementation of PIP.
@
text
@a14 2
//    DataRepos
//    TypedRepos <VarType>
a26 2
#include <Repos.h>
#include <TypedRepos.h>
d28 2
a29 163

//------------------------------------------------------------------------------
// Implementation of class DataRepos.
//------------------------------------------------------------------------------

WitDataRepos::WitDataRepos (WitProblem * theProblem):
      WitProbAssoc (theProblem),

      myIntRepos_  (NULL),
      myBoolRepos_ (NULL),
      myDblRepos_  (NULL),
      myPtrRepos_  (NULL)
   {
   myIntRepos_  = new WitTypedRepos <int>        (theProblem);
   myBoolRepos_ = new WitTypedRepos <bool>       (theProblem);
   myDblRepos_  = new WitTypedRepos <double>     (theProblem);
   myPtrRepos_  = new WitTypedRepos <WitTlObj *> (theProblem);
   }

//------------------------------------------------------------------------------

WitDataRepos::~WitDataRepos ()
   {
   delete myPtrRepos_;
   delete myDblRepos_;
   delete myBoolRepos_;
   delete myIntRepos_;
   }

//------------------------------------------------------------------------------

void WitDataRepos::saveVal (int & theVar)
   {
   myIntRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitDataRepos::saveVal (bool & theVar)
   {
   myBoolRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitDataRepos::saveVal (double & theVar)
   {
   myDblRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitDataRepos::restore ()
   {
   myIntRepos_ ->restore ();
   myBoolRepos_->restore ();
   myDblRepos_ ->restore ();
   myPtrRepos_ ->restore ();
   }

//------------------------------------------------------------------------------

void WitDataRepos::restoreAndSave (WitDataRepos * theDataRepos)
   {
   myIntRepos_ ->restoreAndSave (theDataRepos->myIntRepos_);
   myBoolRepos_->restoreAndSave (theDataRepos->myBoolRepos_);
   myDblRepos_ ->restoreAndSave (theDataRepos->myDblRepos_);
   myPtrRepos_ ->restoreAndSave (theDataRepos->myPtrRepos_);
   }

//------------------------------------------------------------------------------

void WitDataRepos::clear ()
   {
   myIntRepos_ ->clear ();
   myBoolRepos_->clear ();
   myDblRepos_ ->clear ();
   myPtrRepos_ ->clear ();
   }

//------------------------------------------------------------------------------

bool WitDataRepos::isEmpty ()
   {
   return
          myIntRepos_ ->isEmpty ()
      and myBoolRepos_->isEmpty ()
      and myDblRepos_ ->isEmpty ()
      and myPtrRepos_ ->isEmpty ();
   }

//------------------------------------------------------------------------------

void WitDataRepos::savePtrVal (WitTlObj * & theTlPtr)
   {
   myPtrRepos_->saveVal (theTlPtr);
   }

//------------------------------------------------------------------------------
// Implementation of class template TypedRepos <VarType>.
//------------------------------------------------------------------------------

template <typename VarType>
      WitTypedRepos <VarType>::WitTypedRepos (WitProblem * theProblem):

         WitProbAssoc (theProblem),
         savedPairs_  (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <typename VarType>
      WitTypedRepos <VarType>::~WitTypedRepos ()
   {
   }

//------------------------------------------------------------------------------

template <typename VarType>
      void WitTypedRepos <VarType>::saveVal (VarType & theVar)
   {
   savedPairs_.push (& theVar, theVar);
   }

//------------------------------------------------------------------------------
    
template <typename VarType>
      void WitTypedRepos <VarType>::restore ()
   {
   VarType * theVarPtr;
   VarType   theVal;

   while (savedPairs_.pop (theVarPtr, theVal))
      * theVarPtr = theVal;
   }

//------------------------------------------------------------------------------
    
template <typename VarType>
      void WitTypedRepos <VarType>::restoreAndSave (
         WitTypedRepos * theTypedRepos)
   {
   VarType * theVarPtr;
   VarType   theVal;

   theTypedRepos->clear ();

   while (savedPairs_.pop (theVarPtr, theVal))
      {
      theTypedRepos->saveVal (* theVarPtr);

      * theVarPtr = theVal;
      }
   }

//------------------------------------------------------------------------------

template <typename VarType>
      void WitTypedRepos <VarType>::clear ()
   {
   savedPairs_.clear ();
   }
d404 10
d440 1
d443 1
d451 1
d461 2
@


1.54
log
@Continued implementation of PIP.
@
text
@d20 1
a20 1
//    PairStack, with explicit instantiation
d23 1
a23 1
//    PairLinkMgr <ValType> (non-parametric)
d26 1
d712 34
d785 9
d838 40
@


1.53
log
@Fixed a syntax error that occurred on AIX and not Linux.
@
text
@a14 2
//    PerPair    <FirstEl>, with explicit instantiation
//    PerPairMgr <FirstEl>, with explicit instantiation
a27 2
#include <PerPair.h>
#include <PerPairMgr.h>
a30 100
#include <PairStack.h>
#include <Part.h>
#include <Opn.h>
#include <SubEntry.h>
#include <MapIdxI.h>

//------------------------------------------------------------------------------
// Implementation of class template PerPair <FirstEl>.
//------------------------------------------------------------------------------

template <typename FirstEl>
      WitPerPair <FirstEl>::WitPerPair (FirstEl * theFirstEl, WitPeriod thePer):
         myFirstEl_ (theFirstEl),
         myPeriod_  (thePer)
   {                                                                     
   }                                                                     
                                                                               
//------------------------------------------------------------------------------

template <typename FirstEl>
      WitPerPair <FirstEl>::~WitPerPair ()                                      
   {                                                                     
   }                                                                     
                                                                               
//------------------------------------------------------------------------------

template <typename FirstEl>
      void WitPerPair <FirstEl>::getElems (
         FirstEl * & theFirstEl,
         WitPeriod & thePer)
   {
   theFirstEl = myFirstEl_;
   thePer     = myPeriod_;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PerPair <FirstEl>.
//------------------------------------------------------------------------------

template class WitPerPair <WitPart>;
template class WitPerPair <WitOperation>;
template class WitPerPair <WitSubEntry>;
template class WitPerPair <WitDemand>;

//------------------------------------------------------------------------------
// Implementation of class template PerPairMgr <FirstEl>.
//------------------------------------------------------------------------------

template <typename FirstEl> 
      WitPerPairMgr <FirstEl>::WitPerPairMgr (WitProblem * theProblem):

         WitProbAssoc (theProblem),
         myPerPairs_  (theProblem)
   {
   myPairSched_.allocate1D (theProblem);
   }

//------------------------------------------------------------------------------

template <typename FirstEl> 
      WitPerPairMgr <FirstEl>::~WitPerPairMgr ()
   {
   myPairSched_.clear ();

   deleteContents (myPerPairs_);
   }

//------------------------------------------------------------------------------

template <typename FirstEl> 
      WitPerPair <FirstEl> * WitPerPairMgr <FirstEl>::myPerPairFor (
         FirstEl * theFirstEl,
         WitPeriod thePer)
   {
   WitPerPair <FirstEl> * thePerPair;

   if (not myPairSched_.myPtrTVecAt (theFirstEl).isAllocated ())
      myPairSched_.myPtrTVecAt (theFirstEl).allocate (myProblem ());

   thePerPair = myPairSched_.myPtrAt (theFirstEl, thePer);

   if (thePerPair != NULL)
      return thePerPair;

   thePerPair = new WitPerPair <FirstEl> (theFirstEl, thePer);

   myPerPairs_.push (thePerPair);

   myPairSched_.myPtrAt (theFirstEl, thePer) = thePerPair;

   return thePerPair;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PerPairMgr <FirstEl>.
//------------------------------------------------------------------------------

template class WitPerPairMgr <WitPart>;
template class WitPerPairMgr <WitOperation>;
template class WitPerPairMgr <WitSubEntry>;
a611 56

//------------------------------------------------------------------------------
// Implementation of NonClass function template pop (FirstEl, Period, double).
//------------------------------------------------------------------------------

template <typename FirstEl> 
      bool WitNonClass::pop (
         WitPairStack <WitPerPair <FirstEl>, double> & theTriples,
         FirstEl * &                                   theFirstEl,
         WitPeriod &                                   thePer,
         double &                                      theVol)
   {
   WitPerPair <FirstEl> * thePair;

   if (theTriples.isEmpty ())
      return false;

   theTriples.pop (thePair, theVol);

   thePair->getElems (theFirstEl, thePer);

   return true;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of NonClass function template
//    pop (FirstEl, Period, double).
//------------------------------------------------------------------------------

template
   bool WitNonClass::pop <WitPart> (
      WitPairStack <WitPerPair <WitPart>, double> &,
      WitPart * &,
      WitPeriod &,
      double &);

template
   bool WitNonClass::pop <WitOperation> (
      WitPairStack <WitPerPair <WitOperation>, double> &,
      WitOperation * &,
      WitPeriod &,
      double &);

template
   bool WitNonClass::pop <WitSubEntry> (
      WitPairStack <WitPerPair <WitSubEntry>, double> &,
      WitSubEntry * &,
      WitPeriod &,
      double &);

template
   bool WitNonClass::pop <WitDemand> (
      WitPairStack <WitPerPair <WitDemand>, double> &,
      WitDemand * &,
      WitPeriod &,
      double &);
@


1.52
log
@Continued implementation of PIP.
@
text
@d36 4
@


1.51
log
@Continued implementation of PIP.
@
text
@d15 2
d30 2
d38 95
d694 46
a739 1
template class WitPairStack <WitPart,                    bool>;
d741 27
a767 16
template class WitPairStack <WitDemand,                  int>;
template class WitPairStack <WitPart,                    int>;
template class WitPairStack <WitRtCand,                  int>;
template class WitPairStack <WitBaMat,                   int>;

template class WitPairStack <WitDemPer,                  double>;
template class WitPairStack <WitFixedPer,                double>;
template class WitPairStack <WitRtCand,                  double>;
template class WitPairStack <WitSelPt,                   double>;
template class WitPairStack <WitSelCand,                 double>;

template class WitPairStack <WitPip::Targ,               double>;

template class WitPairStack <WitPip::Src <WitPart>,      double>;
template class WitPairStack <WitPip::Src <WitOperation>, double>;
template class WitPairStack <WitPip::Src <WitSubEntry>,  double>;
@


1.50
log
@Continued implementation of PIP.
@
text
@d602 1
@


1.49
log
@Continued implementation of PIP.
@
text
@d595 1
a595 1
template class WitPairStack <WitPart,                          bool>;
d597 4
a600 4
template class WitPairStack <WitDemand,                        int>;
template class WitPairStack <WitPart,                          int>;
template class WitPairStack <WitRtCand,                        int>;
template class WitPairStack <WitBaMat,                         int>;
d602 4
a605 4
template class WitPairStack <WitFixedPer,                      double>;
template class WitPairStack <WitRtCand,                        double>;
template class WitPairStack <WitSelPt,                         double>;
template class WitPairStack <WitSelCand,                       double>;
d607 1
a607 1
template class WitPairStack <WitPIP::WitPipTarg,               double>;
d609 3
a611 3
template class WitPairStack <WitPIP::WitPipSrc <WitPart>,      double>;
template class WitPairStack <WitPIP::WitPipSrc <WitOperation>, double>;
template class WitPairStack <WitPIP::WitPipSrc <WitSubEntry>,  double>;
@


1.48
log
@Continued implementation of PIP.
@
text
@d595 1
a595 1
template class WitPairStack <WitPart,                  bool>;
d597 4
a600 4
template class WitPairStack <WitDemand,                int>;
template class WitPairStack <WitPart,                  int>;
template class WitPairStack <WitRtCand,                int>;
template class WitPairStack <WitBaMat,                 int>;
d602 4
a605 5
template class WitPairStack <WitFixedPer,              double>;
template class WitPairStack <WitRtCand,                double>;
template class WitPairStack <WitSelPt,                 double>;
template class WitPairStack <WitSelCand,               double>;
template class WitPairStack <WitPipTarg,               double>;
d607 5
a611 3
template class WitPairStack <WitPipSrc <WitPart>,      double>;
template class WitPairStack <WitPipSrc <WitOperation>, double>;
template class WitPairStack <WitPipSrc <WitSubEntry>,  double>;
@


1.47
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d468 1
a468 1
// Implementation of global function template revCopyInto.
d472 1
a472 1
      void revCopyInto (
d486 1
a486 1
// Explicit instantiation of global function template revCopyInto.
d489 1
a489 1
template void revCopyInto <WitPart> (
d493 1
a493 1
template void revCopyInto <WitOperation> (
d497 1
a497 1
template void revCopyInto <WitSubEntry> (
@


1.46
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d595 1
a595 1
template class WitPairStack <WitPart,       bool>;
d597 4
a600 4
template class WitPairStack <WitDemand,     int>;
template class WitPairStack <WitPart,       int>;
template class WitPairStack <WitRtCand,     int>;
template class WitPairStack <WitBaMat,      int>;
d602 9
a610 7
template class WitPairStack <WitFixedPer,   double>;
template class WitPairStack <WitRtCand,     double>;
template class WitPairStack <WitSelPt,      double>;
template class WitPairStack <WitSelCand,    double>;
template class WitPairStack <WitPartPipSrc, double>;
template class WitPairStack <WitOpnPipSrc,  double>;
template class WitPairStack <WitPipTarg,    double>;
@


1.45
log
@Continued implementation of post-implosion pegging.
@
text
@a603 2
template class WitPairStack <WitPipTarg,    double>;
template class WitPairStack <WitPartPipSrc, double>;
d606 3
@


1.44
log
@Continued implementation of post-implosion pegging.
@
text
@d595 1
a595 1
template class WitPairStack <WitPart,     bool>;
d597 4
a600 4
template class WitPairStack <WitDemand,   int>;
template class WitPairStack <WitPart,     int>;
template class WitPairStack <WitRtCand,   int>;
template class WitPairStack <WitBaMat,    int>;
d602 6
a607 6
template class WitPairStack <WitFixedPer, double>;
template class WitPairStack <WitRtCand,   double>;
template class WitPairStack <WitPipTarg,  double>;
template class WitPairStack <WitPipSrc,   double>;
template class WitPairStack <WitSelPt,    double>;
template class WitPairStack <WitSelCand,  double>;
@


1.43
log
@Minor changes.
@
text
@d20 1
d500 108
@


1.42
log
@An attempt to fix another link error from the Windows compiler.
@
text
@a19 1
//    ObjStack <VarType>
a464 27

//------------------------------------------------------------------------------
// Implementation of class template ObjStack <VarType>
//------------------------------------------------------------------------------

template <typename ObjType>
      void WitObjStack <ObjType>::oldRevCopyOf (
         const WitList <ObjType> & theList)
   {
   WitListItr theItr (theList);
   ObjType *  theObject;

   clear ();

   while (theList.advance (theItr, theObject))
      push (theObject);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template ObjStack <VarType>.
//
// Explicit instantiation is only needed for cases that use oldRevCopyOf.
//------------------------------------------------------------------------------

template class WitObjStack <WitPart>;
template class WitObjStack <WitOperation>;
template class WitObjStack <WitSubEntry>;
@


1.41
log
@An attempt to fix link errors from the Windows compiler.
@
text
@d472 2
a473 1
      void WitObjStack <ObjType>::revCopyOf (const WitList <ObjType> & theList)
d485 3
a487 2
// Explicit instantiation of member functions of class template
// ObjStack <VarType>.
d490 3
a492 2
template 
   void WitObjStack <WitPart>     ::revCopyOf (const WitList <WitPart>      &);
d494 21
a514 2
template 
   void WitObjStack <WitOperation>::revCopyOf (const WitList <WitOperation> &);
d516 11
a526 2
template 
   void WitObjStack <WitSubEntry> ::revCopyOf (const WitList <WitSubEntry>  &);
@


1.40
log
@Modifications for the Linux port.
@
text
@d308 3
a310 1
void WitAbsStItr::advanceAbs ()
a311 6
   witAssert (myAbsStack_ != NULL);

   curAbsLink_ =
      (curAbsLink_ == NULL)?
         myAbsStack_->firstConstLink ():
         curAbsLink_->nextAbsLink ();
d316 1
a316 3
WitAbsStItr::WitAbsStItr ():
      myAbsStack_ (NULL),
      curAbsLink_ (NULL)
d322 1
a322 1
WitAbsStItr::~WitAbsStItr ()
d324 6
d376 16
d484 1
a484 18

template <typename ObjType> 
      bool WitObjStack <ObjType>::contains (ObjType * theObject) const
   {
   WitObjStItr <ObjType> theItr;
   ObjType *             theItrObj;

   theItr.attachTo (* this);

   while (theItr.advance (theItrObj))
      if (theItrObj == theObject)
         return true;

   return false;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of various member functions of class template
a495 5

//------------------------------------------------------------------------------

template bool WitObjStack <WitSelPt>  ::contains (WitSelPt   *) const;
template bool WitObjStack <WitSplitPt>::contains (WitSplitPt *) const;
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d450 52
@


1.38
log
@Replaced some C style casts with C++ style casts.
@
text
@d442 9
@


1.37
log
@Various internal changes.
@
text
@a19 2
//    PerStack
//    PerStItr
a29 1
#include <PerStack.h>
d369 1
a369 1
      theObjLink = (WitObjLink *) theObjLink->nextAbsLink ();
d431 1
a431 1
   theObjLink = (const WitObjLink *) theItr.curAbsLink ();
a441 68
// Implementation of class PerStack.
//------------------------------------------------------------------------------

WitPerStack::WitPerStack (WitProblem * theProblem):

      WitObjStack <const WitPeriod> (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitPerStack::~WitPerStack ()
   {
   }

//------------------------------------------------------------------------------

void WitPerStack::push (WitPeriod thePer)
   {
   WitObjStack <const WitPeriod>::push (myProblem ()->ptrToPer (thePer));
   }

//------------------------------------------------------------------------------

bool WitPerStack::pop (WitPeriod & thePer)
   {
   bool              popOK;
   const WitPeriod * thePerPtr;

   popOK = WitObjStack <const WitPeriod>::pop (thePerPtr);

   if (popOK)
      thePer = * thePerPtr;

   return popOK;
   }

//------------------------------------------------------------------------------

bool WitPerStack::advance (WitPerStItr & theItr, WitPeriod & thePer)
   {
   bool              advOK;
   const WitPeriod * thePerPtr;

   advOK = WitObjStack <const WitPeriod>::advance (theItr, thePerPtr);

   if (advOK)
      thePer = * thePerPtr;

   return advOK;
   }

//------------------------------------------------------------------------------
// Implementation of class PerStItr.
//------------------------------------------------------------------------------

WitPerStItr::WitPerStItr ():
      WitObjStItr <const WitPeriod> ()
   {
   }

//------------------------------------------------------------------------------

WitPerStItr::~WitPerStItr ()
   {
   }

//------------------------------------------------------------------------------
d535 1
a535 1
   delete (WitObjLink *) theAbsLink;
@


1.36
log
@Updated the code to accomodate the following two VAC compiler warning messages:
   1540-0152
   1540-0080
@
text
@d136 1
a136 1
template <class VarType>
d146 1
a146 1
template <class VarType>
d153 1
a153 1
template <class VarType>
d161 1
a161 1
template <class VarType>
d173 1
a173 1
template <class VarType>
d175 1
a175 1
         WitTypedRepos <VarType> * theTypedRepos)
d192 1
a192 1
template <class VarType>
@


1.35
log
@Internal changes.
@
text
@d614 3
a616 2
WitPairLinkMgr <int> * WitPairLinkMgr <int>::theInstanceFor (
      WitProblem * theProblem)
d623 3
a625 2
WitPairLinkMgr <bool> * WitPairLinkMgr <bool>::theInstanceFor (
      WitProblem * theProblem)
d632 3
a634 2
WitPairLinkMgr <double> * WitPairLinkMgr <double>::theInstanceFor (
      WitProblem * theProblem)
d641 3
a643 2
WitPairLinkMgr <WitTlObj *> * WitPairLinkMgr <WitTlObj *>::theInstanceFor (
      WitProblem * theProblem)
@


1.34
log
@Internal changes.
@
text
@d119 4
a122 4
      myIntRepos_ ->isEmpty () &&
      myBoolRepos_->isEmpty () &&
      myDblRepos_ ->isEmpty () &&
      myPtrRepos_ ->isEmpty ();
d419 1
a419 1
   witAssert (! isEmpty ());
@


1.33
log
@Continued implementation of single-source by the new algorithm.
@
text
@d43 1
d47 4
a50 3
   myIntRepos_ = new WitTypedRepos <int>        (theProblem);
   myDblRepos_ = new WitTypedRepos <double>     (theProblem);
   myPtrRepos_ = new WitTypedRepos <WitTlObj *> (theProblem);
d59 1
d72 7
d88 4
a91 3
   myIntRepos_->restore ();
   myDblRepos_->restore ();
   myPtrRepos_->restore ();
d98 4
a101 3
   myIntRepos_->restoreAndSave (theDataRepos->myIntRepos_);
   myDblRepos_->restoreAndSave (theDataRepos->myDblRepos_);
   myPtrRepos_->restoreAndSave (theDataRepos->myPtrRepos_);
d108 4
a111 3
   myIntRepos_->clear ();
   myDblRepos_->clear ();
   myPtrRepos_->clear ();
d116 1
a116 1
WitBoolean WitDataRepos::isEmpty ()
d119 4
a122 3
      myIntRepos_->isEmpty () &&
      myDblRepos_->isEmpty () &&
      myPtrRepos_->isEmpty ();
d281 1
a281 1
WitBoolean WitAbsStack::popAbs ()
d286 1
a286 1
      return witFALSE;
d293 1
a293 1
   return witTRUE;
d387 1
a387 1
WitBoolean WitAbsObjStack::popAbsObj (WitTlObj * & theTlObj)
d390 1
a390 1
      return witFALSE;
d396 1
a396 1
   return witTRUE;
d426 1
a426 1
WitBoolean WitAbsObjStack::advanceAbsObj (
d437 1
a437 1
      return witFALSE;
d441 1
a441 1
   return witTRUE;
d469 1
a469 1
WitBoolean WitPerStack::pop (WitPeriod & thePer)
d471 1
a471 1
   WitBoolean        popOK;
d484 1
a484 1
WitBoolean WitPerStack::advance (WitPerStItr & theItr, WitPeriod & thePer)
d486 1
a486 1
   WitBoolean        advOK;
d618 8
@


1.32
log
@Continued implementation of single-source.
@
text
@d85 9
d155 19
@


1.31
log
@Continued implementation of Single-Source.
@
text
@d41 8
a48 4
      myIntRepos_  (* new WitTypedRepos <int>        (theProblem)),
      myDblRepos_  (* new WitTypedRepos <double>     (theProblem)),
      myPtrRepos_  (* new WitTypedRepos <WitTlObj *> (theProblem))
   {
d55 3
a57 3
   delete & myPtrRepos_;
   delete & myDblRepos_;
   delete & myIntRepos_;
d64 1
a64 1
   myIntRepos_.saveVal (theVar);
d71 1
a71 1
   myDblRepos_.saveVal (theVar);
d78 3
a80 3
   myIntRepos_.restore ();
   myDblRepos_.restore ();
   myPtrRepos_.restore ();
d87 3
a89 3
   myIntRepos_.clear ();
   myDblRepos_.clear ();
   myPtrRepos_.clear ();
d97 3
a99 3
      myIntRepos_.isEmpty () &&
      myDblRepos_.isEmpty () &&
      myPtrRepos_.isEmpty ();
d106 1
a106 1
   myPtrRepos_.saveVal (theTlPtr);
@


1.30
log
@Continued implementation of Single-Source.
@
text
@d418 1
a418 1
   WitObjStack <const WitPeriod>::push (myProblem ()->ptrFor (thePer));
d425 1
a425 1
   WitBoolean        retVal;
d428 1
a428 1
   retVal = WitObjStack <const WitPeriod>::pop (thePerPtr);
d430 2
a431 1
   thePer = * thePerPtr;
d433 1
a433 1
   return retVal;
d440 1
a440 1
   WitBoolean        retVal;
d443 1
a443 1
   retVal = WitObjStack <const WitPeriod>::advance (theItr, thePerPtr);
d445 2
a446 1
   thePer = * thePerPtr;
d448 1
a448 1
   return retVal;
@


1.29
log
@Continued implementation of Single-Source.
@
text
@a23 1
//    PerLinkMgr
a26 1
//    PerLink
a561 29
// Implementation of class PerLinkMgr.
//------------------------------------------------------------------------------

WitPerLinkMgr::WitPerLinkMgr (WitProblem * theProblem):
      WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitPerLinkMgr::~WitPerLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAbsLink * WitPerLinkMgr::newAbsLink ()
   {
   return new WitPerLink;
   }

//------------------------------------------------------------------------------

void WitPerLinkMgr::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete (WitPerLink *) theAbsLink;
   }

//------------------------------------------------------------------------------
a631 24
   }

//------------------------------------------------------------------------------
// Implementation of class PerLink.
//------------------------------------------------------------------------------

WitPerLink::WitPerLink ():
      WitAbsLink (),

      myPer_     (NULL)
   {
   }

//------------------------------------------------------------------------------

WitPerLink::~WitPerLink ()
   {
   }

//------------------------------------------------------------------------------

void WitPerLink::setDataTo (WitPeriod thePer)
   {
   myPer_ = thePer;
@


1.28
log
@Continued implementation of Single-Source.
@
text
@d406 1
a406 1
      WitAbsStack (theProblem->myPerLinkMgr ())
d420 1
a420 3
   pushAbs ();

   firstPerLink ()->setDataTo (thePer);
d427 2
a428 2
   if (isEmpty ())
      return witFALSE;
d430 1
a430 1
   thePer = firstPerLink ()->myPer ();
d432 1
a432 1
   popAbs ();
d434 1
a434 1
   return witTRUE;
d439 1
a439 1
WitBoolean WitPerStack::advance (WitAbsStItr & theItr, WitPeriod & thePer)
d441 2
a442 5
   const WitPerLink * thePerLink;

   theItr.advanceAbs ();

   thePerLink = (const WitPerLink *) theItr.curAbsLink ();
d444 1
a444 2
   if (thePerLink == NULL)
      return witFALSE;
d446 1
a446 1
   thePer = thePerLink->myPer ();
d448 1
a448 1
   return witTRUE;
d456 1
a456 1
      WitAbsStItr ()
@


1.27
log
@Continued implementation of Single-Source.
@
text
@d20 2
d24 1
d28 1
d34 1
d401 1
a401 1
// Implementation a global function for WitTlPerItr.
d404 59
a462 1
WitBoolean advancePerItr (WitTlPerItr & theItr, WitPeriod & thePer)
d464 3
a466 1
   WitTlObj * theTlObj;
d468 2
a469 1
   return theItr.advance (theTlObj, thePer);
d570 29
d669 24
@


1.26
log
@Continued implementation of single source.
@
text
@d396 11
@


1.25
log
@Continued implementation of single source.
@
text
@d38 3
a40 2
      myIntRepos_  (* new WitTypedRepos <int>    (theProblem)),
      myDblRepos_  (* new WitTypedRepos <double> (theProblem))
d48 1
d73 1
d82 18
d497 1
a497 1
WitPairLinkMgr <WitPeriod> * WitPairLinkMgr <WitPeriod>::theInstanceFor (
d500 1
a500 1
   return theProblem->myPerPairLinkMgr ();
d509 8
@


1.24
log
@Continued implementation of single source.
@
text
@d74 8
d118 8
@


1.23
log
@Preliminary work on single source.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d15 2
d27 2
d31 80
@


1.22
log
@Continued implementation of sel-split for pen-exec.
@
text
@d142 2
d146 1
a146 1
         firstAbsLink_:
d153 2
a154 2
      firstAbsLink_ (NULL),
      curAbsLink_   (NULL)
d168 2
a169 2
   firstAbsLink_ = theAbsStack.firstConstLink ();
   curAbsLink_   = NULL;
@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@d229 16
@


1.20
log
@Continued implementation of pegging.
@
text
@a127 24
WitAbsLink * WitAbsStack::slowAppendAbs ()
   {
   WitAbsLink * theNewAbsLink;
   WitAbsLink * theAbsLink;

   theNewAbsLink = myAbsLinkMgr_->freshAbsLink (NULL);

   if (firstAbsLink_ == NULL)
      firstAbsLink_ = theNewAbsLink;
   else
      {
      theAbsLink = firstAbsLink_;

      while (theAbsLink->nextAbsLink () != NULL)
         theAbsLink = theAbsLink->nextAbsLink ();

      theAbsLink->linkTo (theNewAbsLink);
      }

   return theNewAbsLink;
   }

//------------------------------------------------------------------------------

a133 24
   }

//------------------------------------------------------------------------------

void WitAbsStack::implementTempCases ()
   {
   myProblem ()->myMsgFac () ("internalErrorFmsg", 
      "WitAbsStack::implementTempCases");

   void (* revPartFunc) (
            WitObjStack <WitPart> &, 
      const WitList (WitPart) &);

   void (* revOpnFunc)  (
            WitObjStack <WitOperation> &, 
      const WitList (WitOperation) &);

   void (* revSubFunc)  (
            WitObjStack <WitSubEntry> &, 
      const WitList (WitSubEntry) &);

   revPartFunc = reverseCopyInto;
   revOpnFunc  = reverseCopyInto;
   revSubFunc  = reverseCopyInto;
@


1.19
log
@Removed class template AbsPairStack <*,*>.
@
text
@d236 18
@


1.18
log
@An attempt to resolve link troubles on Windows.
@
text
@a17 1
//    AbsPairStack <ValType> (non-parametric)
d20 1
a286 18
// Non-parametric implementation of AbsPairStack <ValType> template classes.
//------------------------------------------------------------------------------

WitPairLinkMgr <WitPeriod> * WitAbsPairStack <WitPeriod>::thePairLinkMgrFor (
      WitProblem * theProblem)
   {
   return theProblem->myPerPairLinkMgr ();
   }

//------------------------------------------------------------------------------

WitPairLinkMgr <double> * WitAbsPairStack <double>::thePairLinkMgrFor (
      WitProblem * theProblem)
   {
   return theProblem->myDblPairLinkMgr ();
   }

//------------------------------------------------------------------------------
d381 19
@


1.17
log
@Moved Stack template implementations to header files.
@
text
@d18 1
d287 1
a287 1
// Implementation if global function template reverseCopyInto.
d290 2
a291 4
template <class ObjType, class ListObjType> 
      void reverseCopyInto (
               WitObjStack <ObjType> & theObjStack,
         const ListObjType &           theList)
d293 2
a294 2
   WitListItr theItr (theList);
   ObjType *  theObject;
d296 1
a296 1
   theObjStack.clear ();
d298 4
a301 2
   while (theList.advance (theItr, theObject))
      theObjStack.push (theObject);
@


1.16
log
@Initial implementation of multi-route class templates.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
a17 1
//    AbsPairStack <ValType>
a19 1
//    PairLinkMgr  <ValType>
a21 1
//    PairLink     <ValType>
a23 2
#include <Link.h>
#include <LinkMgr.h>
d25 1
a25 1
#include <PairSt.h>
a180 3

   WitAbsPairStack    <double>::implementThisCase ();
   WitAbsPairStack <WitPeriod>::implementThisCase ();
d204 14
a303 130
// Implementation of class template AbsPairStack <ValType>.
//------------------------------------------------------------------------------

template <class ValType> 
      void WitAbsPairStack <ValType>::implementThisCase ()
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitAbsPairStack <ValType>::WitAbsPairStack (
            WitProblem * theProblem):

         WitAbsStack (itsPairLinkMgr (theProblem))
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitAbsPairStack <ValType>::~WitAbsPairStack ()
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      void WitAbsPairStack <ValType>::pushAbsPair (
         WitTlObj * theTlObj,
         ValType    theVal)
   {
   pushAbs ();

   firstPairLink ()->setDataTo (theTlObj, theVal);
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitBoolean WitAbsPairStack <ValType>::popAbsPair (
         WitTlObj * & theTlObj,
         ValType &    theVal)
   {
   if (isEmpty ())
      return witFALSE;

   theTlObj = firstPairLink ()->myTlObj ();
   theVal   = firstPairLink ()->myValue ();

   popAbs ();

   return witTRUE;
   }

//------------------------------------------------------------------------------

template <class ValType> 
      void WitAbsPairStack <ValType>::slowAppendAbsPair (
         WitTlObj * theTlObj,
         ValType    theVal)
   {
   WitPairLink <ValType> * thePairLink;

   thePairLink = (WitPairLink <ValType> *) slowAppendAbs ();

   thePairLink->setDataTo (theTlObj, theVal);
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitTlObj * WitAbsPairStack <ValType>::firstTlObj () const
   {
   witAssert (! isEmpty ());

   return firstPairLink ()->myTlObj ();
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitBoolean WitAbsPairStack <ValType>::advanceAbsPair (
         WitAbsStItr & theItr,
         WitTlObj * &  theTlObj,
         ValType &     theVal)
   {
   const WitPairLink <ValType> * thePairLink;

   theItr.advanceAbs ();

   thePairLink = (const WitPairLink <ValType> *) theItr.curAbsLink ();

   if (thePairLink == NULL)
      return witFALSE;

   theTlObj = thePairLink->myTlObj ();
   theVal   = thePairLink->myValue ();

   return witTRUE;
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitPairLinkMgr <ValType> * WitAbsPairStack <ValType>::itsPairLinkMgr (
         WitProblem * theProblem)
   {
   WitPairLinkMgr <ValType> * theInstance;

   theProblem->getMyInstance (theInstance);

   return theInstance;
   }

//------------------------------------------------------------------------------

WitAbsStItr::~WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsStItr::attachToAbs (const WitAbsStack & theAbsStack)
   {
   firstAbsLink_ = theAbsStack.firstConstLink ();
   curAbsLink_   = NULL;
   }

//------------------------------------------------------------------------------
a400 34
// Implementation of class template PairLinkMgr <ValType>.
//------------------------------------------------------------------------------

template <class ValType> 
      WitPairLinkMgr <ValType>::WitPairLinkMgr (WitProblem * theProblem):

         WitAbsLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitPairLinkMgr <ValType>::~WitPairLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitAbsLink * WitPairLinkMgr <ValType>::newAbsLink ()
   {
   return new WitPairLink <ValType>;
   }

//------------------------------------------------------------------------------

template <class ValType> 
      void WitPairLinkMgr <ValType>::deleteAbsLink (WitAbsLink * theAbsLink)
   {
   delete (WitPairLink <ValType> *) theAbsLink;
   }

//------------------------------------------------------------------------------
a443 31
   }

//------------------------------------------------------------------------------
// Implementation of class template PairLink <ValType>.
//------------------------------------------------------------------------------

template <class ValType> 
      WitPairLink <ValType>::WitPairLink ():
         WitAbsLink (),

         myTlObj_   (NULL),
         myValue_   ()
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      WitPairLink <ValType>::~WitPairLink ()
   {
   }

//------------------------------------------------------------------------------

template <class ValType> 
      void WitPairLink <ValType>::setDataTo (
         WitTlObj * theTlObj,
         ValType    theVal)
   {
   myTlObj_ = theTlObj;
   myValue_ = theVal;
@


1.15
log
@Some template stuff.
@
text
@d166 1
a166 1
void WitAbsStack::implementTempCases (WitTlObj * theTlObj)
@


1.14
log
@Converted several generic classes into class templates.
@
text
@d18 1
a18 5
//    ObjStack <ObjType>
//    ObjStItr <ObjType>
//    AbsPairStack          <ValType>
//    PairStack    <ObjType, ValType>
//    PairStItr    <ObjType, ValType>
d21 1
a21 1
//    PairLinkMgr           <ValType>
d24 1
a24 1
//    PairLink              <ValType>
d166 1
a166 1
void WitAbsStack::callTempFuncs (WitTlObj * theTlObj)
d169 1
a169 1
      "WitAbsStack::callTempFuncs");
d171 18
a188 37
   delete (WitObjStack  <double>                  *) theTlObj;
   delete (WitObjStack  <WitBopEntry>             *) theTlObj;
   delete (WitObjStack  <WitCmrCand>              *) theTlObj;
   delete (WitObjStack  <WitConsEntry>            *) theTlObj;
   delete (WitObjStack  <WitMaterial>             *) theTlObj;
   delete (WitObjStack  <WitOperation>            *) theTlObj;
   delete (WitObjStack  <WitPart>                 *) theTlObj;
   delete (WitObjStack  <WitPmrCand>              *) theTlObj;
   delete (WitObjStack  <WitReqPt>                *) theTlObj;
   delete (WitObjStack  <WitReqPt *>              *) theTlObj;
   delete (WitObjStack  <WitSelPt>                *) theTlObj;
   delete (WitObjStack  <WitSubEntry>             *) theTlObj;
   delete (WitObjStack  <WitSplitPt>              *) theTlObj;
   delete (WitObjStack  <WitTlObj>                *) theTlObj;

   delete (WitPairStack <double,       double>    *) theTlObj;
   delete (WitPairStack <WitTlObj,     double>    *) theTlObj;
   delete (WitPairStack <WitSelPt,     double>    *) theTlObj;

   delete (WitPairStack <WitPart,      WitPeriod> *) theTlObj;
   delete (WitPairStack <WitDemand,    WitPeriod> *) theTlObj;
   delete (WitPairStack <WitOperation, WitPeriod> *) theTlObj;
   delete (WitPairStack <WitBopEntry,  WitPeriod> *) theTlObj;
   delete (WitPairStack <WitConsEntry, WitPeriod> *) theTlObj;
   delete (WitPairStack <WitBaMat,     WitPeriod> *) theTlObj;

   reverseCopyInto (
      * (WitObjStack <WitPart> *)     theTlObj,
      * (WitList     (WitPart) *)     theTlObj);

   reverseCopyInto (
      * (WitObjStack <WitOperation> *) theTlObj,
      * (WitList     (WitOperation) *) theTlObj);

   reverseCopyInto (
      * (WitObjStack <WitSubEntry> *)  theTlObj,
      * (WitList     (WitSubEntry) *)  theTlObj);
a279 26
// Implementation of class template ObjStack <ObjType>.
//------------------------------------------------------------------------------

template <class ObjType> 
      WitObjStack <ObjType>::WitObjStack (WitProblem * theProblem):
         WitAbsObjStack (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <class ObjType> 
      WitObjStack <ObjType>::~WitObjStack ()
   {
   }

//------------------------------------------------------------------------------

template <class ObjType> 
      void WitObjStack <ObjType>::takeContents (
         WitObjStack <ObjType> & theObjStack)
   {
   takeContentsAbs (theObjStack);
   }

//------------------------------------------------------------------------------
d298 1
a298 1
// Implementation of class template ObjStItr <ObjType>.
d301 2
a302 10
template <class ObjType> 
      WitObjStItr <ObjType>::WitObjStItr ():
         WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

template <class ObjType> 
      WitObjStItr <ObjType>::~WitObjStItr ()
a306 2
// Implementation of class template AbsPairStack <ValType>.
//------------------------------------------------------------------------------
a424 52
   }

//------------------------------------------------------------------------------
// Implementation of class template PairStack <ObjType, ValType>.
//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      WitPairStack <ObjType, ValType>::WitPairStack (WitProblem * theProblem):
         WitAbsPairStack <ValType> (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      WitPairStack <ObjType, ValType>::~WitPairStack ()
   {
   }

//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      void WitPairStack <ObjType, ValType>::
         slowAppend (ObjType * theObject, ValType theVal)
   {
   slowAppendAbsPair ((WitTlObj *) theObject, theVal);
   }

//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      void WitPairStack <ObjType, ValType>::
         takeContents (WitPairStack <ObjType, ValType> & thePairStack)
   {
   takeContentsAbs (thePairStack);
   }

//------------------------------------------------------------------------------
// Implementation of class template PairStItr <ObjType, ValType>.
//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      WitPairStItr <ObjType, ValType>::WitPairStItr ():
         WitAbsStItr ()
   {
   }

//------------------------------------------------------------------------------

template <class ObjType, class ValType> 
      WitPairStItr <ObjType, ValType>::~WitPairStItr ()
   {
@


1.13
log
@Replaced generic class PairLink (ValType)
   with class template PairLink <ValType>.
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d13 1
a13 1
// Contains the implementation of the following classes:
d16 1
d18 5
a22 2
//    AbsPairStack (ValType)
//    AbsStItr
d25 1
a25 1
//    PairLinkMgr  (ValType)
d28 1
a28 2
//    OldPLink     (ValType)
//    PairLink     <ValType>
d169 66
d285 1
a285 1
      WitAbsStItr & theItr, 
d289 135
a423 136
                                                                       
   theItr.advanceAbs ();                                               
                                                                       
   theObjLink = (const WitObjLink *) theItr.curAbsLink (); 
                                                                       
   if (theObjLink == NULL)                                            
      return witFALSE;                                                 
                                                                       
   theTlObj = theObjLink->myTlObj ();                                 
                                                                       
   return witTRUE;                                                     
   }

//------------------------------------------------------------------------------
// Implementation macro for generic global function
// reverseCopyInto (ObjStack (ObjType) &, const List (ObjType) &)
//------------------------------------------------------------------------------

#define reverseCopyInto_ObjStackimplement(ObjType)                             \
                                                                               \
void reverseCopyInto (                                                         \
      WitObjStack (ObjType) & theObjStack,                                     \
      const WitList (ObjType) &  theList)                                      \
   {                                                                           \
   WitListItr theItr (theList);                                                \
   ObjType *  theObject;                                                       \
                                                                               \
   theObjStack.clear ();                                                       \
                                                                               \
   while (theList.advance (theItr, theObject))                                 \
      theObjStack.push (theObject);                                            \
   }                                                                           \

//------------------------------------------------------------------------------
// Implementation macro for generic class AbsPairStack (ValType).
//------------------------------------------------------------------------------

#define WitAbsPairStackimplement(ValType)                                      \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitAbsPairStack (ValType)::WitAbsPairStack (ValType) (                         \
         WitProblem * theProblem):                                             \
                                                                               \
      WitAbsStack (itsPairLinkMgr (theProblem))                                \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitAbsPairStack (ValType)::~WitAbsPairStack (ValType) ()                       \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitAbsPairStack (ValType)::pushAbsPair (                                  \
      WitTlObj * theTlObj,                                                     \
      ValType    theVal)                                                       \
   {                                                                           \
   pushAbs ();                                                                 \
                                                                               \
   firstPairLink ()->setDataTo (theTlObj, theVal);                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean WitAbsPairStack (ValType)::popAbsPair (                             \
      WitTlObj * & theTlObj,                                                   \
      ValType &    theVal)                                                     \
   {                                                                           \
   if (isEmpty ())                                                             \
      return witFALSE;                                                         \
                                                                               \
   theTlObj = firstPairLink ()->myTlObj ();                                    \
   theVal   = firstPairLink ()->myValue ();                                    \
                                                                               \
   popAbs ();                                                                  \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitAbsPairStack (ValType)::slowAppendAbsPair (                            \
      WitTlObj * theTlObj,                                                     \
      ValType    theVal)                                                       \
   {                                                                           \
   WitPairLink <ValType> * thePairLink;                                        \
                                                                               \
   thePairLink = (WitPairLink <ValType> *) slowAppendAbs ();                   \
                                                                               \
   thePairLink->setDataTo (theTlObj, theVal);                                  \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitTlObj * WitAbsPairStack (ValType)::firstTlObj () const                      \
   {                                                                           \
   witAssert (! isEmpty ());                                                   \
                                                                               \
   return firstPairLink ()->myTlObj ();                                        \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean WitAbsPairStack (ValType)::advanceAbsPair (                         \
      WitAbsStItr & theItr,                                                    \
      WitTlObj * &  theTlObj,                                                  \
      ValType &     theVal)                                                    \
   {                                                                           \
   const WitPairLink <ValType> * thePairLink;                                  \
                                                                               \
   theItr.advanceAbs ();                                                       \
                                                                               \
   thePairLink = (const WitPairLink <ValType> *) theItr.curAbsLink ();         \
                                                                               \
   if (thePairLink == NULL)                                                    \
      return witFALSE;                                                         \
                                                                               \
   theTlObj = thePairLink->myTlObj ();                                         \
   theVal   = thePairLink->myValue ();                                         \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPairLinkMgr (ValType) * WitAbsPairStack (ValType)::itsPairLinkMgr (         \
      WitProblem * theProblem)                                                 \
   {                                                                           \
   WitPairLinkMgr (ValType) * theInstance;                                     \
                                                                               \
   theProblem->getMyInstance (theInstance);                                    \
                                                                               \
   return theInstance;                                                         \
d427 32
a458 1
// Implementation of class AbsStItr.
d460 11
a470 8
                                                                             
void WitAbsStItr::advanceAbs ()
   {                                                                         
   curAbsLink_ =                                                            
      (curAbsLink_ == NULL)?                                                
         firstAbsLink_:                                                     
         curAbsLink_->nextAbsLink ();                                      
   }                                                                         
d474 4
a477 12
WitAbsStItr::WitAbsStItr ():                     
      firstAbsLink_ (NULL),                                                 
      curAbsLink_   (NULL)                                                  
   {                                                                         
   }                                                                         
                                                                             
//------------------------------------------------------------------------------
                                                                             
WitAbsStItr::~WitAbsStItr ()                     
   {                                                                         
   }                                                                         
                                                                             
d479 1
a479 1
                                                                             
d481 57
a537 5
   {                                                                         
   firstAbsLink_ = theAbsStack.firstConstLink ();                        
   curAbsLink_   = NULL;                                                    
   }                                                                         
                                                                             
d636 1
a636 1
// Implementation macro for generic class PairLinkMgr (ValType).
d639 29
a667 30
#define WitPairLinkMgrimplement(ValType)                                       \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPairLinkMgr (ValType)::WitPairLinkMgr (ValType) (                           \
         WitProblem * theProblem):                                             \
                                                                               \
      WitAbsLinkMgr (theProblem)                                               \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPairLinkMgr (ValType)::~WitPairLinkMgr (ValType) ()                         \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitAbsLink * WitPairLinkMgr (ValType)::newAbsLink ()                           \
   {                                                                           \
   return new WitPairLink <ValType>;                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPairLinkMgr (ValType)::deleteAbsLink (WitAbsLink * theAbsLink)         \
   {                                                                           \
   delete (WitPairLink <ValType> *) theAbsLink;                                \
   }                                                                           \
d709 1
a709 1
 
a715 30
// Implementation macro for generic class OldPLink (ValType).
//------------------------------------------------------------------------------

#define WitOldPLinkimplement(ValType)                                          \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitOldPLink (ValType)::WitOldPLink (ValType) ():                               \
      WitAbsLink (),                                                           \
                                                                               \
      myTlObj_   (NULL),                                                       \
      myValue_   ()                                                            \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitOldPLink (ValType)::~WitOldPLink (ValType) ()                               \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitOldPLink (ValType)::setDataTo (WitTlObj * theTlObj, ValType theVal)    \
   {                                                                           \
   myTlObj_ = theTlObj;                                                        \
   myValue_ = theVal;                                                          \
   }                                                                           \

//------------------------------------------------------------------------------
d719 3
a721 2
template <class ValType> WitPairLink <ValType>::WitPairLink ():
      WitAbsLink (),
d723 2
a724 2
      myTlObj_   (NULL),
      myValue_   ()
d730 2
a731 1
template <class ValType> WitPairLink <ValType>::~WitPairLink ()
d737 4
a740 3
template <class ValType> void WitPairLink <ValType>::setDataTo (
      WitTlObj * theTlObj, 
      ValType    theVal)
a744 17

//------------------------------------------------------------------------------
// Implementations of all specific cases of the generic classes and functions 
// implemented in this file.
//------------------------------------------------------------------------------

implement (reverseCopyInto_ObjStack, WitPart)
implement (reverseCopyInto_ObjStack, WitOperation)
implement (reverseCopyInto_ObjStack, WitSubEntry)

implement (WitAbsPairStack, double)
implement (WitPairLinkMgr,  double)
//plement (WitOldPLink,     double)

implement (WitAbsPairStack, WitPeriod)
implement (WitPairLinkMgr,  WitPeriod)
//plement (WitOldPLink,     WitPeriod)
@


1.12
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d24 2
a25 1
//    PairLink     (ValType)
d308 1
a308 1
   WitPairLink (ValType) * thePairLink;                                        \
d310 1
a310 1
   thePairLink = (WitPairLink (ValType) *) slowAppendAbs ();                   \
d331 1
a331 1
   const WitPairLink (ValType) * thePairLink;                                  \
d335 1
a335 1
   thePairLink = (const WitPairLink (ValType) *) theItr.curAbsLink ();         \
d514 1
a514 1
   return new WitPairLink (ValType);                                           \
d521 1
a521 1
   delete (WitPairLink (ValType) *) theAbsLink;                                \
d571 1
a571 1
// Implementation macro for generic class PairLink (ValType).
d574 1
a574 1
#define WitPairLinkimplement(ValType)                                          \
d578 1
a578 1
WitPairLink (ValType)::WitPairLink (ValType) ():                               \
d588 1
a588 1
WitPairLink (ValType)::~WitPairLink (ValType) ()                               \
d594 1
a594 1
void WitPairLink (ValType)::setDataTo (WitTlObj * theTlObj, ValType theVal)    \
d601 28
d639 1
a639 1
implement (WitPairLink,     double)
d643 1
a643 1
implement (WitPairLink,     WitPeriod)
@


1.11
log
@Changed
  if ( theAbsLinkMgr = NULL )
to
  if ( theAbsLinkMgr == NULL )
@
text
@d182 1
a182 1
void WitAbsObjStack::pushAbsObj (WitTl * theTlObj)
d191 1
a191 1
WitBoolean WitAbsObjStack::popAbsObj (WitTl * & theTlObj)
d205 1
a205 1
WitTl * WitAbsObjStack::firstTlObj () const
d216 1
a216 1
      WitTl * &     theTlObj)
d275 3
a277 1
void WitAbsPairStack (ValType)::pushAbsPair (WitTl * theTlObj, ValType theVal) \
d287 2
a288 2
      WitTl * & theTlObj,                                                      \
      ValType & theVal)                                                        \
d304 2
a305 2
      WitTl * theTlObj,                                                        \
      ValType theVal)                                                          \
d316 1
a316 1
WitTl * WitAbsPairStack (ValType)::firstTlObj () const                         \
d327 1
a327 1
      WitTl * &     theTlObj,                                                  \
d564 1
a564 1
void WitObjLink::setDataTo (WitTl * theTlObj)
d593 1
a593 1
void WitPairLink (ValType)::setDataTo (WitTl * theTlObj, ValType theVal)       \
@


1.10
log
@Further implementation of coarse selection splitting.
@
text
@d398 1
a398 1
   if (theAbsLinkMgr = NULL)
@


1.9
log
@Fixed some bugs in coarse selection splitting.
@
text
@d132 24
d297 13
@


1.8
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d38 1
a38 1
   while (getAbs ());
d108 1
a108 1
void WitAbsStack::putAbs ()
d115 1
a115 1
WitBoolean WitAbsStack::getAbs ()
d158 1
a158 1
void WitAbsObjStack::putAbsObj (WitTl * theTlObj)
d160 1
a160 1
   putAbs ();
d167 1
a167 1
WitBoolean WitAbsObjStack::getAbsObj (WitTl * & theTlObj)
d174 1
a174 1
   getAbs ();
d225 1
a225 1
      theObjStack.put (theObject);                                             \
d251 1
a251 1
void WitAbsPairStack (ValType)::putAbsPair (WitTl * theTlObj, ValType theVal)  \
d253 1
a253 1
   putAbs ();                                                                  \
d260 1
a260 1
WitBoolean WitAbsPairStack (ValType)::getAbsPair (                             \
d270 1
a270 1
   getAbs ();                                                                  \
@


1.7
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d15 1
d17 2
a18 2
//    AbsPairStack    (ValType)
//    AbsPairStackItr (ValType)
d21 1
a21 1
//    PairLinkMgr     (ValType)
d24 1
a24 1
//    PairLink        (ValType)
a28 1
#include <StackItr.h>
d30 1
d33 1
a33 1
// Implementation of class AbsObjStack.
d36 1
a36 1
void WitAbsObjStack::clear ()
d38 1
a38 3
   WitTl * theTlObj;

   while (getAbs (theTlObj));
d43 1
a43 1
int WitAbsObjStack::nElements () const
d46 1
a46 1
   WitObjLink * theObjLink;
d50 1
a50 1
   theObjLink = firstObjLink_;
d52 1
a52 1
   while (theObjLink != NULL)
d56 1
a56 1
      theObjLink = theObjLink->nextObjLink ();
d64 1
a64 1
void WitAbsObjStack::reverse ()
d66 2
a67 2
   WitObjLink * oldFirstObjLink;
   WitObjLink * theObjLink;
d69 2
a70 2
   oldFirstObjLink = firstObjLink_;
   firstObjLink_   = NULL;
d72 1
a72 1
   while (oldFirstObjLink != NULL)
d74 2
a75 2
      theObjLink      = oldFirstObjLink;
      oldFirstObjLink = oldFirstObjLink->nextObjLink ();
d77 1
a77 1
      theObjLink->linkToObjLink (firstObjLink_);
d79 1
a79 1
      firstObjLink_   = theObjLink;
d85 1
a85 1
WitProblem * WitAbsObjStack::myProblem () const
d87 1
a87 1
   return myObjLinkMgr_->myProblem ();
d92 1
a92 1
WitAbsObjStack::WitAbsObjStack (WitProblem * theProblem):
d94 2
a95 2
      myObjLinkMgr_  (theProblem->myObjLinkMgr ()),
      firstObjLink_  (NULL)
d101 1
a101 1
WitAbsObjStack::~WitAbsObjStack ()
d108 1
a108 1
void WitAbsObjStack::putAbs (WitTl * theTlObj)
d110 1
a110 3
   firstObjLink_ = myObjLinkMgr_->freshObjLink (firstObjLink_);

   firstObjLink_->setDataTo (theTlObj);
d115 1
a115 1
WitBoolean WitAbsObjStack::getAbs (WitTl * & theTlObj)
d117 1
a117 1
   WitObjLink * theObjLink;
d122 2
a123 3
   theObjLink    = firstObjLink_;
   firstObjLink_ = theObjLink->nextObjLink ();
   theTlObj      = theObjLink->myTlObj ();
d125 1
a125 1
   myObjLinkMgr_->recycleObjLink (theObjLink);
d132 1
a132 1
void WitAbsObjStack::takeContentsAbs (WitAbsObjStack & theAbsObjStack)
d136 41
a176 2
   firstObjLink_                = theAbsObjStack.firstObjLink_;
   theAbsObjStack.firstObjLink_ = NULL;
d185 21
a205 1
   return firstObjLink_->myTlObj ();
a235 38
void WitAbsPairStack (ValType)::clear ()                                       \
   {                                                                           \
   WitTl * theTlObj;                                                           \
   ValType theVal;                                                             \
                                                                               \
   while (getAbs (theTlObj, theVal));                                          \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitAbsPairStack (ValType)::reverse ()                                     \
   {                                                                           \
   WitPairLink (ValType) * oldFirstPairLink;                                   \
   WitPairLink (ValType) * thePairLink;                                        \
                                                                               \
   oldFirstPairLink = firstPairLink_;                                          \
   firstPairLink_   = NULL;                                                    \
                                                                               \
   while (oldFirstPairLink != NULL)                                            \
      {                                                                        \
      thePairLink      = oldFirstPairLink;                                     \
      oldFirstPairLink = oldFirstPairLink->nextPairLink ();                    \
                                                                               \
      thePairLink->linkToPairLink (firstPairLink_);                            \
                                                                               \
      firstPairLink_   = thePairLink;                                          \
      }                                                                        \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitProblem * WitAbsPairStack (ValType)::myProblem () const                     \
   {                                                                           \
   return myPairLinkMgr_->myProblem ();                                        \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
d239 1
a239 2
      myPairLinkMgr_ (WitPairLinkMgr (ValType)::itsInstance (theProblem)),     \
      firstPairLink_ (NULL)                                                    \
a246 1
   clear ();                                                                   \
d251 1
a251 1
void WitAbsPairStack (ValType)::putAbs (WitTl * theTlObj, ValType theVal)      \
d253 1
a253 1
   firstPairLink_ = myPairLinkMgr_->freshPairLink (firstPairLink_);            \
d255 1
a255 1
   firstPairLink_->setDataTo (theTlObj, theVal);                               \
d260 1
a260 1
WitBoolean WitAbsPairStack (ValType)::getAbs (                                 \
a263 2
   WitPairLink (ValType) * thePairLink;                                        \
                                                                               \
d267 2
a268 4
   thePairLink    = firstPairLink_;                                            \
   firstPairLink_ = thePairLink->nextPairLink ();                              \
   theTlObj       = thePairLink->myTlObj ();                                   \
   theVal         = thePairLink->myValue ();                                   \
d270 1
a270 1
   myPairLinkMgr_->recyclePairLink (thePairLink);                              \
d277 1
a277 2
void WitAbsPairStack (ValType)::takeContentsAbs (                              \
      WitAbsPairStack (ValType) & theAbsPairStack)                             \
d279 1
a279 1
   clear ();                                                                   \
d281 1
a281 2
   firstPairLink_                 = theAbsPairStack.firstPairLink_;            \
   theAbsPairStack.firstPairLink_ = NULL;                                      \
d286 4
a289 2
void WitAbsPairStack (ValType)::reverseCopyOfAbs (                             \
      const WitAbsPairStack (ValType) & theAbsPairStack)                       \
d291 1
a291 1
   WitPairLink (ValType) * thePairLink;                                        \
d293 1
a293 1
   clear ();                                                                   \
d295 4
a298 1
   thePairLink = theAbsPairStack.firstPairLink_;                               \
d300 2
a301 3
   while (thePairLink != NULL)                                                 \
      {                                                                        \
      putAbs (thePairLink->myTlObj (), thePairLink->myValue ());               \
d303 1
a303 2
      thePairLink = thePairLink->nextPairLink ();                              \
      }                                                                        \
d308 2
a309 1
WitTl * WitAbsPairStack (ValType)::firstTlObj () const                         \
d311 3
a313 1
   witAssert (! isEmpty ());                                                   \
d315 2
a316 2
   return firstPairLink_->myTlObj ();                                          \
   }                                                                           \
d319 1
a319 1
// Implementation macro for generic class AbsPairStackItr (ValType).
d321 8
d330 1
a330 44
#define WitAbsPairStackItrimplement(ValType)                                   \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitAbsPairStackItr (ValType)::WitAbsPairStackItr (ValType) ():                 \
      firstPairLink_ (NULL),                                                   \
      curPairLink_   (NULL)                                                    \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitAbsPairStackItr (ValType)::~WitAbsPairStackItr (ValType) ()                 \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitAbsPairStackItr (ValType)::attachToAbs (                               \
      const WitAbsPairStack (ValType) & theAbsPairStack)                       \
   {                                                                           \
   firstPairLink_ = theAbsPairStack.firstPairLink_;                            \
   curPairLink_   = NULL;                                                      \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean WitAbsPairStackItr (ValType)::advanceAbs (                          \
      WitTl * & theTlObj,                                                      \
      ValType & theVal)                                                        \
   {                                                                           \
   curPairLink_ =                                                              \
      (curPairLink_ == NULL)?                                                  \
         firstPairLink_:                                                       \
         curPairLink_->nextPairLink ();                                        \
                                                                               \
   if (curPairLink_ == NULL)                                                   \
      return witFALSE;                                                         \
                                                                               \
   theTlObj = curPairLink_->myTlObj ();                                        \
   theVal   = curPairLink_->myValue ();                                        \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \
d332 20
a378 15
WitAbsLinkMgr::WitAbsLinkMgr (WitProblem * theProblem):
      WitProbAssoc        (theProblem),

      firstUnusedAbsLink_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAbsLinkMgr::~WitAbsLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

d391 1
a391 1
   theFreshAbsLink->linkToAbsLink (theAbsLink);
d400 1
a400 1
   theAbsLink->linkToAbsLink (firstUnusedAbsLink_);
d406 15
d446 1
a446 1
   delete asanObjLink (theAbsLink);
a465 12
WitPairLinkMgr (ValType) * WitPairLinkMgr (ValType)::itsInstance (             \
      WitProblem * theProblem)                                                 \
   {                                                                           \
   WitPairLinkMgr (ValType) * theInstance;                                     \
                                                                               \
   theProblem->getMyInstance (theInstance);                                    \
                                                                               \
   return theInstance;                                                         \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
d481 1
a481 1
   delete asaPairLink (theAbsLink);                                            \
d488 1
a488 2
WitAbsLink::WitAbsLink ():
      nextAbsLink_ (NULL)
d490 1
d495 2
a496 1
WitAbsLink::~WitAbsLink ()
d502 1
a502 1
void WitAbsLink::linkToAbsLink (WitAbsLink * theAbsLink)
a503 1
   nextAbsLink_ = theAbsLink;
d569 7
a575 9
implement (WitAbsPairStack,    double)
implement (WitAbsPairStackItr, double)
implement (WitPairLinkMgr,     double)
implement (WitPairLink,        double)

implement (WitAbsPairStack,    WitPeriod)
implement (WitAbsPairStackItr, WitPeriod)
implement (WitPairLinkMgr,     WitPeriod)
implement (WitPairLink,        WitPeriod)
@


1.6
log
@Further development of coarse selection splitting.
@
text
@d39 1
a39 1
   while (popAbs (theTlObj));
d109 1
a109 1
void WitAbsObjStack::pushAbs (WitTl * theTlObj)
d118 1
a118 1
WitBoolean WitAbsObjStack::popAbs (WitTl * & theTlObj)
d170 1
a170 1
      theObjStack.push (theObject);                                            \
d186 1
a186 1
   while (popAbs (theTlObj, theVal));                                          \
d236 1
a236 1
void WitAbsPairStack (ValType)::pushAbs (WitTl * theTlObj, ValType theVal)     \
d245 1
a245 1
WitBoolean WitAbsPairStack (ValType)::popAbs (                                 \
d288 1
a288 1
      pushAbs (thePairLink->myTlObj (), thePairLink->myValue ());              \
d573 1
a573 1
// Implementations of all specific cases of the generic classes functions 
d582 1
@


1.5
log
@Minor correction.
@
text
@d15 4
a18 6
//    Stack
//    ObjStack     (ObjType)
//    PairStack    (ObjType, ValType)
//    StackItr
//    PairStackItr (ObjType, ValType)
//    LinkMgr
d20 2
a21 2
//    PairLinkMgr           (ValType)
//    Link
d23 1
a23 1
//    PairLink              (ValType)
d29 1
d32 1
a32 1
// Implementation of class Stack.
d35 1
a35 1
void WitStack::clear ()
d37 1
a37 1
   WitTl * theObject;
d39 1
a39 1
   while (popAbs ());
d44 1
a44 1
int WitStack::nElements () const
d46 2
a47 2
   int       nEl;
   WitLink * theLink;
d51 1
a51 4
   for (
         theLink  = firstLink_;
         theLink != NULL;
         theLink  = theLink->next ())
d53 2
d57 3
d65 1
a65 1
void WitStack::reverse ()
d67 2
a68 2
   WitLink * oldFirstLink;
   WitLink * theLink;
d70 2
a71 2
   oldFirstLink = firstLink_;
   firstLink_   = NULL;
d73 1
a73 1
   while (oldFirstLink != NULL)
d75 2
a76 2
      theLink      = oldFirstLink;
      oldFirstLink = oldFirstLink->next ();
d78 1
a78 1
      theLink->linkTo (firstLink_);
d80 1
a80 1
      firstLink_   = theLink;
d86 1
a86 1
WitProblem * WitStack::myProblem () const
d88 1
a88 1
   return myLinkMgr_->myProblem ();
d93 4
a96 3
WitStack::WitStack (WitLinkMgr * theLinkMgr):
      myLinkMgr_ (theLinkMgr),
      firstLink_ (NULL)
a97 1
   witAssert (theLinkMgr != NULL);
d102 1
a102 1
WitStack::~WitStack ()
d109 1
a109 1
void WitStack::pushAbs ()
d111 3
a113 1
   firstLink_ = myLinkMgr_->freshLink (firstLink_);
d118 1
a118 1
WitBoolean WitStack::popAbs ()
d120 2
d125 3
a127 4
   WitLink * theLink;

   theLink    = firstLink_;
   firstLink_ = theLink->next ();
d129 1
a129 1
   myLinkMgr_->recycle (theLink);
d136 1
a136 1
void WitStack::takeContentsAbs (WitStack & theStack)
d140 2
a141 3
   firstLink_          = theStack.firstLink_;

   theStack.firstLink_ = NULL;
d146 1
a146 1
void WitStack::reverseCopyOfAbs (const WitStack & theStack)
d148 1
a148 1
   WitLink * theLink;
d150 2
a151 1
   clear ();
d153 4
a156 1
   theLink = theStack.firstLink_;
d158 14
a171 9
   while (theLink != NULL)
      {
      pushAbs ();
      
      myLinkMgr_->copyDataInto (firstLink_, theLink);

      theLink = theLink->next ();
      }
   }
d174 1
a174 1
// Implementation macro for generic class ObjStack (ObjType).
d177 1
a177 1
#define WitObjStackimplement(ObjType)                                          \
d181 1
a181 2
WitObjStack (ObjType)::WitObjStack (ObjType) (WitProblem * theProblem):        \
      WitStack (theProblem->myObjLinkMgr ())                                   \
d183 4
d191 1
a191 1
WitObjStack (ObjType)::~WitObjStack (ObjType) ()                               \
d193 15
d212 1
a212 1
void WitObjStack (ObjType)::push (ObjType * theObject)                         \
d214 4
a217 1
   pushAbs ();                                                                 \
d219 6
a224 1
   firstObjLink ()->setDataTo ((WitTl *) theObject);                           \
d229 1
a229 1
WitBoolean WitObjStack (ObjType)::pop (ObjType * & theObject)                  \
d231 1
a231 4
   if (! isEmpty ())                                                           \
      theObject = (ObjType *) firstObjLink ()->myObject ();                    \
                                                                               \
   return popAbs ();                                                           \
d236 1
a236 1
ObjType * WitObjStack (ObjType)::firstObject () const                          \
d238 1
a238 1
   witAssert (! isEmpty ());                                                   \
d240 1
a240 1
   return (ObjType *) firstObjLink ()->myObject ();                            \
a241 7

//------------------------------------------------------------------------------
// Implementation macro for generic global function
// reverseCopyInto (ObjStack (ObjType) &, const List (ObjType) &)
//------------------------------------------------------------------------------

#define reverseCopyInto_ObjStackimplement(ObjType)                             \
d243 5
a247 3
void reverseCopyInto (                                                         \
      WitObjStack (ObjType) & theObjStack,                                     \
      const WitList (ObjType) &  theList)                                      \
d249 1
a249 4
   WitListItr theItr (theList);                                                \
   ObjType *  theObject;                                                       \
                                                                               \
   theObjStack.clear ();                                                       \
d251 2
a252 9
   while (theList.advance (theItr, theObject))                                 \
      theObjStack.push (theObject);                                            \
   }                                                                           \

//------------------------------------------------------------------------------
// Implementation macro for generic class PairStack (ObjType, ValType).
//------------------------------------------------------------------------------

#define WitPairStackimplement2(ObjType, ValType)                               \
d254 4
a257 1
/*---------------------------------------------------------------------------*/\
d259 1
a259 2
WitPairStack (ObjType, ValType)::WitPairStack (ObjType, ValType) (             \
         WitProblem * theProblem):                                             \
d261 1
a261 2
      WitStack (WitPairLinkMgr (ValType)::itsInstance (theProblem))            \
   {                                                                           \
d266 2
a267 1
WitPairStack (ObjType, ValType)::~WitPairStack (ObjType, ValType) ()           \
d269 4
d277 2
a278 3
void WitPairStack (ObjType, ValType)::push (                                   \
      ObjType * theObject,                                                     \
      ValType   theVal)                                                        \
d280 1
a280 1
   pushAbs ();                                                                 \
d282 1
a282 2
   firstPairLink ()->setDataTo ((WitTl *) theObject, theVal);                  \
   }                                                                           \
d284 1
a284 1
/*---------------------------------------------------------------------------*/\
d286 1
a286 5
WitBoolean WitPairStack (ObjType, ValType)::pop (                              \
      ObjType * & theObject,                                                   \
      ValType &   theVal)                                                      \
   {                                                                           \
   if (! isEmpty ())                                                           \
d288 3
a290 2
      theObject = (ObjType *) firstPairLink ()->myObject ();                   \
      theVal    =             firstPairLink ()->myValue ();                    \
a291 2
                                                                               \
   return popAbs ();                                                           \
d296 1
a296 1
ObjType * WitPairStack (ObjType, ValType)::firstObject () const                \
d300 1
a300 1
   return (ObjType *) firstPairLink ()->myObject ();                           \
d304 1
a304 37
// Implementation of class StackItr.
//------------------------------------------------------------------------------

WitStackItr::WitStackItr ():
      firstLink_ (NULL),
      curLink_   (NULL)
   {
   }

//------------------------------------------------------------------------------

WitStackItr::~WitStackItr ()
   {
   }

//------------------------------------------------------------------------------

void WitStackItr::attachToAbs (const WitStack & theStack)
   {
   firstLink_ = theStack.firstLink_;
   curLink_   = NULL;
   }

//------------------------------------------------------------------------------

WitBoolean WitStackItr::advanceAbs ()
   {
   curLink_ = 
      (curLink_ == NULL)?
         firstLink_:
         curLink_->next ();

   return (curLink_ != NULL);
   }

//------------------------------------------------------------------------------
// Implementation macro for generic class PairStackItr (ObjType, ValType).
d307 1
a307 1
#define WitPairStackItrimplement2(ObjType, ValType)                            \
d311 3
a313 2
WitPairStackItr (ObjType, ValType)::WitPairStackItr (ObjType, ValType) ():     \
      WitStackItr ()                                                           \
d319 1
a319 1
WitPairStackItr (ObjType, ValType)::~WitPairStackItr (ObjType, ValType) ()     \
d325 2
a326 2
void WitPairStackItr (ObjType, ValType)::attachTo (                            \
      const WitPairStack (ObjType, ValType) & thePairStack)                    \
d328 2
a329 1
   WitStackItr::attachToAbs (thePairStack);                                    \
d334 3
a336 3
WitBoolean WitPairStackItr (ObjType, ValType)::advance (                       \
      ObjType * & theObject,                                                   \
      ValType &   theVal)                                                      \
d338 4
a341 1
   WitBoolean stillValid;                                                      \
d343 2
a344 1
   stillValid = advanceAbs ();                                                 \
d346 2
a347 5
   if (stillValid)                                                             \
      {                                                                        \
      theObject = (ObjType *) curPairLink ()->myObject ();                     \
      theVal    =             curPairLink ()->myValue ();                      \
      }                                                                        \
d349 1
a349 1
   return stillValid;                                                          \
d353 1
a353 1
// Implementation of class LinkMgr.
d356 1
a356 4
WitLinkMgr::WitLinkMgr (WitProblem * theProblem):
      WitProbAssoc     (theProblem),

      firstUnusedLink_ (NULL)
d358 2
a359 1
   }
d361 1
a361 8
//------------------------------------------------------------------------------

void WitLinkMgr::deleteInstance (WitLinkMgr * theLinkMgr)
   {
   WitLink * theLink;
   WitLink * deadLink;

   if (theLinkMgr = NULL)
d364 1
a364 1
   theLink = theLinkMgr->firstUnusedLink_;
d366 1
a366 1
   while (theLink != NULL)
d368 2
a369 2
      deadLink = theLink;
      theLink  = theLink->next ();
d371 1
a371 1
      theLinkMgr->deleteLink (deadLink);
d374 1
a374 1
   delete theLinkMgr;
d379 4
a382 1
WitLink * WitLinkMgr::freshLink (WitLink * theLink)
d384 1
a384 1
   WitLink * theFreshLink;
d386 1
a386 7
   if (firstUnusedLink_ == NULL)
      theFreshLink     = newLink ();
   else
      {
      theFreshLink     = firstUnusedLink_;
      firstUnusedLink_ = theFreshLink->next ();
      }
d388 2
a389 3
   theFreshLink->linkTo (theLink);

   return theFreshLink;
d394 1
a394 1
void WitLinkMgr::recycle (WitLink * theLink)
d396 1
a396 1
   theLink->linkTo (firstUnusedLink_);
d398 11
a408 1
   firstUnusedLink_ = theLink;
d413 1
a413 1
WitLinkMgr::~WitLinkMgr ()
d415 3
d425 1
a425 9
      WitLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

void WitObjLinkMgr::copyDataInto (
      WitLink * dstLink, 
      WitLink * srcLink)
a426 2
   asanObjLink (dstLink)->setDataTo (
      asanObjLink (srcLink)->myObject ());
d437 1
a437 1
WitLink * WitObjLinkMgr::newLink ()
d444 1
a444 1
void WitObjLinkMgr::deleteLink (WitLink * theLink)
d446 1
a446 1
   delete asanObjLink (theLink);
d460 1
a460 1
      WitLinkMgr (theProblem)                                                  \
a477 11
void WitPairLinkMgr (ValType)::copyDataInto (                                  \
      WitLink * dstLink,                                                       \
      WitLink * srcLink)                                                       \
   {                                                                           \
   asaPairLink (dstLink)->setDataTo (                                          \
      asaPairLink (srcLink)->myObject (),                                      \
      asaPairLink (srcLink)->myValue ());                                      \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
d484 1
a484 1
WitLink * WitPairLinkMgr (ValType)::newLink ()                                 \
d491 1
a491 1
void WitPairLinkMgr (ValType)::deleteLink (WitLink * theLink)                  \
d493 1
a493 1
   delete asaPairLink (theLink);                                               \
d497 1
a497 1
// Implementation of class Link.
d500 2
a501 1
void WitLink::linkTo (WitLink * theLink)
a502 1
   next_ = theLink;
d507 1
a507 2
WitLink::WitLink ():
      next_ (NULL)
d513 1
a513 1
WitLink::~WitLink ()
d515 1
d523 1
a523 1
      WitLink (),
d525 1
a525 1
      myObject_  (NULL)
d537 1
a537 1
void WitObjLink::setDataTo (WitTl * theObject)
d539 1
a539 1
   myObject_ = theObject;
d551 1
a551 1
      WitLink (),                                                              \
d553 1
a553 1
      myObject_  (NULL),                                                       \
d566 1
a566 1
void WitPairLink (ValType)::setDataTo (WitTl * theObject, ValType theVal)      \
d568 2
a569 2
   myObject_ = theObject;                                                      \
   myValue_  = theVal;                                                         \
d577 12
a588 34
implement  (WitObjStack,              double)
implement  (WitObjStack,              WitPart)
implement  (WitObjStack,              WitOperation)
implement  (WitObjStack,              WitSubEntry)
implement  (WitObjStack,              WitBopEntry)
implement  (WitObjStack,              WitConsEntry)
implement  (WitObjStack,              WitAltPt)
implement  (WitObjStack,              WitTl)
implement  (WitObjStack,              WitReqPt)
implement  (WitObjStack,              WitReqPtPtr)
implement  (WitObjStack,              WitMeSelPt)

implement  (reverseCopyInto_ObjStack, WitPart)
implement  (reverseCopyInto_ObjStack, WitOperation)
implement  (reverseCopyInto_ObjStack, WitSubEntry)

implement2 (WitPairStack,             WitPart,      WitPeriod)
implement2 (WitPairStack,             WitDemand,    WitPeriod)
implement2 (WitPairStack,             WitOperation, WitPeriod)
implement2 (WitPairStack,             WitBopEntry,  WitPeriod)
implement2 (WitPairStack,             WitConsEntry, WitPeriod)

implement2 (WitPairStack,             double,       double)
implement2 (WitPairStack,             WitConsEntry, double)

implement2 (WitPairStackItr,          WitDemand,    WitPeriod)
implement2 (WitPairStackItr,          WitBopEntry,  WitPeriod)
implement2 (WitPairStackItr,          WitConsEntry, WitPeriod)

implement  (WitPairLinkMgr,                         WitPeriod)
implement  (WitPairLinkMgr,                         double)

implement  (WitPairLink,                            double)
implement  (WitPairLink,                            WitPeriod)
@


1.4
log
@Further development of coarse selection splitting.
@
text
@a22 1
//    ObjPerDblLinkMgr
a25 1
//    ObjPerDblLink
a531 36
// Implementation of class ObjPerDblLinkMgr.
//------------------------------------------------------------------------------

WitObjPerDblLinkMgr::WitObjPerDblLinkMgr (WitProblem * theProblem):
      WitLinkMgr (theProblem)
   {
   }

//------------------------------------------------------------------------------

void WitObjPerDblLinkMgr::copyDataInto (WitLink * dstLink, WitLink * srcLink)
   {
   asanObjPerDblLink (dstLink)->copyDataFrom (asanObjPerDblLink (srcLink));
   }

//------------------------------------------------------------------------------

WitObjPerDblLinkMgr::~WitObjPerDblLinkMgr ()
   {
   }

//------------------------------------------------------------------------------

WitLink * WitObjPerDblLinkMgr::newLink ()
   {
   return new WitObjPerDblLink;
   }

//------------------------------------------------------------------------------

void WitObjPerDblLinkMgr::deleteLink (WitLink * theLink)
   {
   delete asanObjPerDblLink (theLink);
   }

//------------------------------------------------------------------------------
a605 50

//------------------------------------------------------------------------------
// Implementation of class ObjPerDblLink.
//------------------------------------------------------------------------------

WitObjPerDblLink::WitObjPerDblLink ():
      WitLink   (),

      myObject_ (NULL),
      myPeriod_ (-1),
      myDouble_ (0.0)
   {
   }

//------------------------------------------------------------------------------

WitObjPerDblLink::~WitObjPerDblLink ()
   {
   }

//------------------------------------------------------------------------------

void WitObjPerDblLink::copyDataFrom (WitObjPerDblLink * theObjPerDblLink)
   {
   theObjPerDblLink->getData (myObject_, myPeriod_, myDouble_);
   }

//------------------------------------------------------------------------------

void WitObjPerDblLink::setDataTo (
      WitTl *   theObject,
      WitPeriod thePer,
      double    theDbl)
   {
   myObject_ = theObject;
   myPeriod_ = thePer;
   myDouble_ = theDbl;
   }

//------------------------------------------------------------------------------

void WitObjPerDblLink::getData (
      WitTl * &   theObject,
      WitPeriod & thePer,
      double &    theDbl)
   {
   theObject = myObject_;
   thePer    = myPeriod_;
   theDbl    = myDouble_;
   }
@


1.3
log
@Futher development of selection splitting.
@
text
@d40 1
a40 1
   WitTypelessPtr theObject;
d188 1
a188 1
   firstObjLink ()->setDataTo ((WitTypelessPtr) theObject);                    \
d259 1
a259 1
   firstPairLink ()->setDataTo ((WitTypelessPtr) theObject, theVal);           \
d610 1
a610 1
void WitObjLink::setDataTo (WitTypelessPtr theObject)
d639 1
a639 3
void WitPairLink (ValType)::setDataTo (                                        \
      WitTypelessPtr theObject,                                                \
      ValType        theVal)                                                   \
d674 3
a676 3
      WitTypelessPtr theObject,
      WitPeriod      thePer,
      double         theDbl)
d686 3
a688 3
      WitTypelessPtr & theObject,
      WitPeriod &      thePer,
      double &         theDbl)
d707 1
a720 1
implement2 (WitPairStack,             WitMrBomEnt,  WitPeriod)
@


1.2
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@a17 1
//    MrBomEntPerDblStack
a286 46
// Implementation of class MrBomEntPerDblStack.
//------------------------------------------------------------------------------

WitMrBomEntPerDblStack::WitMrBomEntPerDblStack (WitProblem * theProblem):
      WitStack (theProblem->myObjPerDblLinkMgr ())
   {
   }

//------------------------------------------------------------------------------

WitMrBomEntPerDblStack::~WitMrBomEntPerDblStack ()
   {
   }

//------------------------------------------------------------------------------

void WitMrBomEntPerDblStack::push (
      WitMrBomEnt * theMrBomEnt,
      WitPeriod     thePer,
      double        theDbl)
   {
   pushAbs ();

   firstObjPerDblLink ()->setDataTo (
      (WitTypelessPtr) theMrBomEnt,
      thePer,
      theDbl);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrBomEntPerDblStack::pop (
      WitMrBomEnt * & theMrBomEnt,
      WitPeriod &     thePer,
      double &        theDbl)
   {
   if (! isEmpty ())
      firstObjPerDblLink ()->getData (
         (WitTypelessPtr &) theMrBomEnt,
         thePer,
         theDbl);

   return popAbs ();
   }

//------------------------------------------------------------------------------
d702 1
d724 1
@


1.1
log
@Some minor modifications.
@
text
@d18 1
d21 8
a28 6
//    StackLinkMgr
//    ObjStackLinkMgr
//    PairStackLinkMgr       (ValType)
//    StackLink
//    ObjStackLink
//    PairStackLink          (ValType)
d50 2
a51 2
   int            nEl;
   WitStackLink * theLink;
d56 1
a56 1
         theLink  = firstStackLink_;
d69 2
a70 2
   WitStackLink * oldFirstLink;
   WitStackLink * theLink;
d72 2
a73 2
   oldFirstLink    = firstStackLink_;
   firstStackLink_ = NULL;
d77 2
a78 2
      theLink         = oldFirstLink;
      oldFirstLink    = oldFirstLink->next ();
d80 1
a80 1
      theLink->linkTo (firstStackLink_);
d82 1
a82 1
      firstStackLink_ = theLink;
d90 1
a90 1
   return myStackLinkMgr_->myProblem ();
d95 3
a97 3
WitStack::WitStack (WitStackLinkMgr * theStackLinkMgr):
      myStackLinkMgr_ (theStackLinkMgr),
      firstStackLink_ (NULL)
d99 1
a99 1
   witAssert (theStackLinkMgr != NULL);
d113 1
a113 1
   firstStackLink_ = myStackLinkMgr_->freshLink (firstStackLink_);
d123 1
a123 1
   WitStackLink * theLink;
d125 2
a126 2
   theLink         = firstStackLink_;
   firstStackLink_ = theLink->next ();
d128 1
a128 1
   myStackLinkMgr_->recycle (theLink);
d139 1
a139 1
   firstStackLink_          = theStack.firstStackLink_;
d141 1
a141 1
   theStack.firstStackLink_ = NULL;
d148 1
a148 1
   WitStackLink * theLink;
d152 1
a152 1
   theLink = theStack.firstStackLink_;
d158 1
a158 1
      myStackLinkMgr_->copyDataInto (firstStackLink_, theLink);
d173 1
a173 1
      WitStack (theProblem->myObjStackLinkMgr ())                              \
d189 1
a189 1
   firstObjStackLink ()->setDataTo ((WitTypelessPtr) theObject);               \
d197 1
a197 1
      theObject = (ObjType *) firstObjStackLink ()->myObject ();               \
d208 1
a208 1
   return (ObjType *) firstObjStackLink ()->myObject ();                       \
d242 1
a242 1
      WitStack (WitPairStackLinkMgr (ValType)::itsInstance (theProblem))       \
d260 1
a260 1
   firstPairStackLink ()->setDataTo ((WitTypelessPtr) theObject, theVal);      \
d271 2
a272 2
      theObject = (ObjType *) firstPairStackLink ()->myObject ();              \
      theVal    =             firstPairStackLink ()->myValue ();               \
d284 1
a284 1
   return (ObjType *) firstPairStackLink ()->myObject ();                      \
d288 46
d338 2
a339 2
      firstStackLink_ (NULL),
      curStackLink_   (NULL)
d353 2
a354 2
   firstStackLink_ = theStack.firstStackLink_;
   curStackLink_   = NULL;
d361 4
a364 4
   curStackLink_ = 
      (curStackLink_ == NULL)?
         firstStackLink_:
         curStackLink_->next ();
d366 1
a366 1
   return (curStackLink_ != NULL);
d408 2
a409 2
      theObject = (ObjType *) curPairStackLink ()->myObject ();                \
      theVal    =             curPairStackLink ()->myValue ();                 \
d416 1
a416 1
// Implementation of class StackLinkMgr.
d419 1
a419 1
WitStackLinkMgr::WitStackLinkMgr (WitProblem * theProblem):
d428 1
a428 1
void WitStackLinkMgr::deleteInstance (WitStackLinkMgr * theStackLinkMgr)
d430 2
a431 2
   WitStackLink * theLink;
   WitStackLink * deadLink;
d433 1
a433 1
   if (theStackLinkMgr = NULL)
d436 1
a436 1
   theLink = theStackLinkMgr->firstUnusedLink_;
d443 1
a443 1
      theStackLinkMgr->deleteLink (deadLink);
d446 1
a446 1
   delete theStackLinkMgr;
d451 1
a451 1
WitStackLink * WitStackLinkMgr::freshLink (WitStackLink * theLink)
d453 1
a453 1
   WitStackLink * theFreshLink;
d470 1
a470 1
void WitStackLinkMgr::recycle (WitStackLink * theLink)
d479 1
a479 1
WitStackLinkMgr::~WitStackLinkMgr ()
d484 1
a484 1
// Implementation of class ObjStackLinkMgr.
d487 2
a488 2
WitObjStackLinkMgr::WitObjStackLinkMgr (WitProblem * theProblem):
      WitStackLinkMgr (theProblem)
d494 3
a496 3
void WitObjStackLinkMgr::copyDataInto (
      WitStackLink * dstLink, 
      WitStackLink * srcLink)
d498 2
a499 2
   asanObjStackLink (dstLink)->setDataTo (
      asanObjStackLink (srcLink)->myObject ());
d504 1
a504 1
WitObjStackLinkMgr::~WitObjStackLinkMgr ()
d510 1
a510 1
WitStackLink * WitObjStackLinkMgr::newLink ()
d512 1
a512 1
   return new WitObjStackLink;
d517 1
a517 1
void WitObjStackLinkMgr::deleteLink (WitStackLink * theLink)
d519 1
a519 1
   delete asanObjStackLink (theLink);
d523 1
a523 1
// Implementation macro for generic class PairStackLinkMgr (ValType).
d526 1
a526 1
#define WitPairStackLinkMgrimplement(ValType)                                  \
d530 1
a530 1
WitPairStackLinkMgr (ValType)::WitPairStackLinkMgr (ValType) (                 \
d533 1
a533 1
      WitStackLinkMgr (theProblem)                                             \
d539 1
a539 1
WitPairStackLinkMgr (ValType) * WitPairStackLinkMgr (ValType)::itsInstance (   \
d542 1
a542 1
   WitPairStackLinkMgr (ValType) * theInstance;                                \
d551 3
a553 3
void WitPairStackLinkMgr (ValType)::copyDataInto (                             \
      WitStackLink * dstLink,                                                  \
      WitStackLink * srcLink)                                                  \
d555 3
a557 3
   asaPairStackLink (dstLink)->setDataTo (                                     \
      asaPairStackLink (srcLink)->myObject (),                                 \
      asaPairStackLink (srcLink)->myValue ());                                 \
d562 1
a562 1
WitPairStackLinkMgr (ValType)::~WitPairStackLinkMgr (ValType) ()               \
d568 1
a568 1
WitStackLink * WitPairStackLinkMgr (ValType)::newLink ()                       \
d570 1
a570 1
   return new WitPairStackLink (ValType);                                      \
d575 1
a575 1
void WitPairStackLinkMgr (ValType)::deleteLink (WitStackLink * theLink)        \
d577 1
a577 1
   delete asaPairStackLink (theLink);                                          \
d581 37
a617 1
// Implementation of class StackLink.
d620 1
a620 1
void WitStackLink::linkTo (WitStackLink * theLink)
d627 1
a627 1
WitStackLink::WitStackLink ():
d634 1
a634 1
WitStackLink::~WitStackLink ()
d639 1
a639 1
// Implementation of class ObjStackLink.
d642 2
a643 2
WitObjStackLink::WitObjStackLink ():
      WitStackLink (),
d651 1
a651 1
WitObjStackLink::~WitObjStackLink ()
d657 1
a657 1
void WitObjStackLink::setDataTo (WitTypelessPtr theObject)
d663 1
a663 1
// Implementation macro for generic class PairStackLink (ValType).
d666 1
a666 1
#define WitPairStackLinkimplement(ValType)                                     \
d670 2
a671 2
WitPairStackLink (ValType)::WitPairStackLink (ValType) ():                     \
      WitStackLink (),                                                         \
d680 1
a680 1
WitPairStackLink (ValType)::~WitPairStackLink (ValType) ()                     \
d686 1
a686 1
void WitPairStackLink (ValType)::setDataTo (                                   \
d695 50
d768 2
d772 3
a774 3
implement2 (WitPairStackItr,               WitDemand,    WitPeriod)
implement2 (WitPairStackItr,               WitBopEntry,  WitPeriod)
implement2 (WitPairStackItr,               WitConsEntry, WitPeriod)
d776 2
a777 2
implement  (WitPairStackLinkMgr,                         WitPeriod)
implement  (WitPairStackLinkMgr,                         double)
d779 2
a780 2
implement  (WitPairStackLink,                            WitPeriod)
implement  (WitPairStackLink,                            double)
@


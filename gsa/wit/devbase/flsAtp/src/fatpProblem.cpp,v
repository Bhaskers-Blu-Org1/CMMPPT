head	1.63;
access;
symbols
	Start:1.1.1.1 IBM:1.1.1;
locks; strict;
comment	@// @;


1.63
date	2004.05.13.20.05.17;	author grzes;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.11.22.29.47;	author grzes;	state Exp;
branches;
next	1.61;

1.61
date	2004.05.11.21.13.47;	author grzes;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.07.19.29.49;	author grzes;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.29.21.47.36;	author grzes;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.29.18.55.27;	author grzes;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.29.16.40.27;	author grzes;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.21.14.46.51;	author grzes;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.20.18.51.22;	author grzes;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.19.20.58.03;	author grzes;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.09.14.29.31;	author grzes;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.07.22.56.24;	author grzes;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.05.22.24.02;	author grzes;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.31.16.19.43;	author grzes;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.31.00.06.08;	author grzes;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.30.20.58.48;	author grzes;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.22.19.48.02;	author grzes;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.22.19.43.11;	author grzes;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.18.19.11.15;	author grzes;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.18.15.12.40;	author grzes;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.16.20.37.00;	author grzes;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.16.18.36.20;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.15.16.32.43;	author grzes;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.15.16.06.06;	author grzes;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.13.15.11.00;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.13.04.35.21;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.13.04.24.41;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.12.22.00.26;	author grzes;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.12.19.06.08;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.12.18.34.43;	author grzes;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.11.19.15.38;	author grzes;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.11.18.33.07;	author grzes;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.11.17.06.28;	author grzes;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.11.15.55.12;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.11.15.53.18;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.11.15.25.04;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.10.18.55.26;	author grzes;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.10.18.02.34;	author grzes;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.10.14.45.57;	author grzes;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.09.16.36.34;	author grzes;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.08.23.04.12;	author grzes;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.07.17.21.47;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.06.03.27.17;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.05.22.33.15;	author grzes;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.05.21.58.45;	author grzes;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.05.19.00.18;	author grzes;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.04.21.48.40;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.04.21.42.23;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.04.18.31.14;	author grzes;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.04.15.05.52;	author grzes;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.03.20.02.42;	author grzes;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.03.18.57.08;	author grzes;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.02.23.54.53;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.02.21.00.35;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.01.22.43.02;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.01.22.16.14;	author grzes;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.01.20.31.04;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.01.16.40.09;	author grzes;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.01.16.35.50;	author grzes;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.27.20.46.27;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.19.54.57;	author grzes;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.24.17.17.01;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.24.15.21.35;	author fasano;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.02.24.15.21.35;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.63
log
@FLSATP ver 1.0
Done, comments have been added
Messages can be switched off by using static class field MessagesOn
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#endif

#include <numeric>
#include <set>
#include <algorithm>

#include <cassert>
#include <iostream>
#include <cfloat>
#include <cstdio>
#include <climits>

#include "CoinFinite.h"
#include "CoinFloatEqual.h"
#include "campaignAppData.h"
#include "orderEntryAppData.h"
#include "fatpException.h"
#include "fatpProblem.h"


bool FATPproblem::MessagesOn = true;

bool& FATPproblem::getMessagesOn()
   {
    	return MessagesOn;
   }

//----------------------
// Methods for Campaigns.
//----------------------
void FATPproblem::addCampaign(const std::string & campaignName)
{
  WitRun * wr = witRun();

  // One should not be able to add the same campaign twice
  if (campaignExists(campaignName)) return;

  witAddPart(wr,campaignName.c_str(),WitCAPACITY);
  //witAddOperation(wr,campaignName.c_str());
  //witAddBomEntry(wr, campaignName.c_str(), campaignName.c_str() );
  
  FATPcampaignAppData * appData = new FATPcampaignAppData();
  witSetPartAppData (witRun(), campaignName.c_str(), appData);
  appData->setCampaignName(campaignName);
  campaignNames_.insert(campaignName);
}

void FATPproblem::setCampaignDuration( const std::string & campaignName, int d )
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(witRun(),campaignName.c_str(),(void**)&appData);
		try
		{
			if (appData->getStartPeriod() + d > getNPeriods())
			{
				char errorMessage[1000];
				sprintf(errorMessage,"Campaign %s ends too late",campaignName.c_str());
				FATPException error(errorMessage);
				throw(error);
			}
			appData->setDuration(d);
			campsByTypes_.clear();
		}
		catch(FATPException error)
		{
			throw(error);
		}
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

int FATPproblem::getCampaignDuration( const std::string & campaignName ) const
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		return appData->getDuration();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

void FATPproblem::setCampaignStartPeriod(const std::string & campaignName, int startPeriod )
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		try
		{
			if (startPeriod > getNPeriods() || startPeriod < 0)
			{
				char errorMessage[1000];
				sprintf(errorMessage,"Invalid Campaign %s Start Period",campaignName.c_str());
				FATPException error(errorMessage);
				throw(error);
			}
			appData->setStartPeriod(startPeriod);
			
			//now we deal with the list of sorted campaigns - if the campaign is on the list, we remove it first.
			std::string tempName;
			std::set<FATPcampaignAppData *, sortCampaignsByStartPeriod>::iterator it;
			it=sortedCampaignNames_.begin();
			while(it!=sortedCampaignNames_.end())
			{
				tempName = (*it)->getCampaignName();
				if (tempName == campaignName)
				{
					sortedCampaignNames_.erase(it);
					break;
				}
				it++;
			}
			sortedCampaignNames_.insert(appData);
			campsByTypes_.clear();
		}
		catch(FATPException error)
		{
			throw(error);
		}
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

int FATPproblem::getCampaignStartPeriod( const std::string & campaignName ) const 
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		return appData->getStartPeriod();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

void FATPproblem::setCampaignExcessCapacity(const std::string & campaignName, float excessCapacity )
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		appData->setExcessCapacity(excessCapacity);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

float FATPproblem::getCampaignExcessCapacity( const std::string & campaignName ) const
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		return appData->getExcessCapacity();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

void FATPproblem::setCampaignType(const std::string & campaignName, const std::string & type )
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		appData->setCampaignType(type);
		campaignTypes_.insert(type);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

std::string FATPproblem::getCampaignType( const std::string & campaignName ) const
throw(FATPException)
{
	try
	{
		CheckIfCampExists(campaignName);
		FATPcampaignAppData * appData;
		witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
		return appData->getCampaignType();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return "No such Camapaign";
	}
}

void FATPproblem::getCampaignNames( std::vector<std::string> & campaignNames ) const
{
  campaignNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=campaignNames_.begin(); it!=campaignNames_.end(); ++it ) {
    campaignNames.push_back( *it );
  }
}

void FATPproblem::getSortedCampaignNames( std::vector<std::string> & campaignNames ) const
{
  campaignNames.clear();

  std::set<FATPcampaignAppData *, sortCampaignsByStartPeriod>::const_iterator it;
  for ( it=sortedCampaignNames_.begin(); it!=sortedCampaignNames_.end(); ++it ) {
    campaignNames.push_back( (*it)->getCampaignName() );
  }
}

void FATPproblem::getCampaignTypes( std::vector<std::string> & campaignTypes ) const
{
  campaignTypes.clear();

  std::set<std::string>::const_iterator it;
  for ( it=campaignTypes_.begin(); it!=campaignTypes_.end(); ++it ) {
    campaignTypes.push_back( *it );
  }
}

FATPvectorString FATPproblem::getCampaignsOfType(const std::string & campaignType)
  {
	return campsByTypes_[campaignType];
  }


float FATPproblem::getCampaignExcessCapacityConsumed(const std::string & campaignName)const
{
   float * consVol;
   witGetPartConsVol(mutableWitRun(),campaignName.c_str(),&consVol);
   float retVal = consVol[getCampaignStartPeriod(campaignName)];
   witFree(consVol);
   return retVal;
}

//FIXED!!!!!
bool FATPproblem::campaignExists(const std::string & campaignName)const
{
  bool exists = false;
  std::set<std::string>::const_iterator it;
  for ( it=campaignNames_.begin(); it!=campaignNames_.end(); ++it ) 
  {
	  exists = (*it == campaignName);
	  if (exists) break;
  }
  
	//witBoolean exists;
  //witGetPartExists(mutableWitRun(), campaignName.c_str(), &exists);
  if ( exists ) return true;
  else return false;
}

inline void FATPproblem::CheckIfCampExists(const std::string & campaignName) const 
throw(FATPException)
{
	if (!campaignExists(campaignName))
	{
		char errorMessage[1000];
		sprintf(errorMessage,"Campaign %s does not exist",campaignName.c_str());
		FATPException error(errorMessage);
		throw(error);
	}
}

bool FATPproblem::campaignsFeasible(const std::string & firstCampaignName,
	  const std::string & secondCampaignName)
{
	int first = getCampaignStartPeriod(firstCampaignName)+ getCampaignDuration(firstCampaignName);
	int second = getCampaignStartPeriod(secondCampaignName);
	return(first <= second) ;
}

int FATPproblem::compareCampaigns(const std::string & firstCampaignName,
	  const std::string & secondCampaignName)
{
	int first = getCampaignStartPeriod(firstCampaignName);
	int second = getCampaignStartPeriod(secondCampaignName);
	return(second-first) ;
}


//----------------------
// Methods for OrderEntry.
//----------------------

void FATPproblem::addOrderEntry( const std::string & orderId )
{
	witAddPart(witRun(),orderId.c_str(),WitMATERIAL);
	witAddDemand(witRun(),orderId.c_str(),orderId.c_str() );
	
	FATPorderEntryAppData * appData = new FATPorderEntryAppData();
	witSetDemandAppData (witRun(), orderId.c_str(), orderId.c_str(), appData);
	appData->setOrderEntryId(orderId);
	orderEntryIds_.insert(orderId);
}

void FATPproblem::setOrderEntryImportance( const std::string & orderId, int impt )
throw(FATPException)
{
	//order of importances: {1,2,3,4,5,...,0 and <0}
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPorderEntryAppData * appData;
		witGetDemandAppData (mutableWitRun(), orderId.c_str(), orderId.c_str(),(void**) &appData);
		int * prioVec = intToIntStar(impt);
		witSetDemandPriority(witRun(),orderId.c_str(),orderId.c_str(),prioVec );
		delete [] prioVec;
		appData->setImportance(impt);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

int FATPproblem::getOrderEntryImportance( const std::string & orderId) const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		int * temp;
		int retVal;
		witGetDemandPriority(mutableWitRun(),orderId.c_str(),orderId.c_str(),&temp);
		retVal = temp[0];
		witFree(temp);
		return retVal;
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

int FATPproblem::getOrderEntryNRecipes( const std::string & orderId )const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		int retVal;
		witGetPartNProducingBopEntries(mutableWitRun(),orderId.c_str(),&retVal);
		return retVal;
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

bool  FATPproblem::orderEntryExists(const std::string & orderName)const
{
	witBoolean exists;
	witGetPartExists(mutableWitRun(), orderName.c_str(), &exists);
	if ( exists ) return true;
	else return false;
}

inline void FATPproblem::CheckIfOrderEntryExists(const std::string & orderId) const
throw(FATPException)
{
	if (!orderEntryExists(orderId))
	{
		char errorMessage[1000];
		sprintf(errorMessage,"Order Entry %s does not exist",orderId.c_str());
		FATPException error(errorMessage);
		throw(error);
	}
}

void FATPproblem::addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe,
									  const FATPvectorFloat & consRates )
									  throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		// if recipe does not contain any campaign's then there is nothing to do
		int recipeSize = recipe.size();
		if ( recipeSize == 0 ) return;
		
		// Make sure orderId and campaign's exist
		assert( orderEntryExists(orderId) );
		int r;
		for ( r=0; r<recipe.size(); ++r ) {
			assert( campaignExists(recipe[r]) );
		}
		
		// add recipe to appData
		FATPorderEntryAppData * appData;
		witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
		appData->addRecipe(recipe, consRates);
		int numRecipes = appData->getRecipes().size();
		
		// Create operation
		char witOpName[5000];
		sprintf(witOpName,"orderId: %s, recipe:%d",orderId.c_str(),numRecipes);
		witAddOperation(witRun(),witOpName);
		witAddBopEntry(witRun(),witOpName,orderId.c_str());
		
		
		float Aversion = 0;
		float np = float(getNPeriods());
		float weight = (1.0/np/np);
		// loop once for each campaign in recipe
		for ( r=0; r<recipeSize; ++r ) 
		{
			char witName[5000];
			sprintf(witName,"orderId: %s, recipe:%d, campaign:%d",orderId.c_str(),numRecipes,r);
			
			witAddPart(witRun(),witName,WitMATERIAL);
			witSetPartBuildNstn(witRun(),witName,WitTRUE);
			witAddBomEntry(witRun(),witOpName,witName);
			
			witAddOperation(witRun(),witName);
			witAddBopEntry(witRun(),witName,witName);
			
			// connect campaign to operation
			witAddBomEntry(witRun(),witName,recipe[r].c_str());
			
			// get campaign duration
			float duration = getCampaignDuration(recipe[r]);
			float endPeriod = duration + getCampaignStartPeriod(recipe[r]);
			Aversion += endPeriod*weight;
			
			// set BomEntry offset to duration
			witSetArcAttribute(witSetBomEntryOffset,witName,0,duration);
			witSetArcAttribute(witSetBomEntryConsRate,witName,0,consRates[r]);
			weight*=np;
		}
		witSetBopEntryExpAversion(witRun(),witOpName,0,Aversion);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

void FATPproblem::addOrderEntryRecipe( const std::string & orderId,
									  const FATPvectorString & recipe )
									  throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPvectorFloat cr;
		int c;
		for ( c=0; c<recipe.size(); ++c ) {
			cr.push_back(1.0f);
		}
		addOrderEntryRecipe(orderId,recipe,cr);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}


//---------------------------------------------------------------------------
// GMS - converting recipe of types to recipes of campaigns
//---------------------------------------------------------------------------

// Recursive function which adds campaing names of a certain type
void FATPproblem::recursiveAddCampaignNamesToRecipe(const std::string & orderId,
													int & recipeLength,
													int & cloneMarker,
													std::vector<int> &vecOfPositions,
													std::vector<int> &vecOfLoBounds,
													const std::vector<FATPvectorString> &typeToCamps,
													const FATPvectorFloat & consRates)
{
	//if there are no types in the recipe, no recipe of campaign names can be made
	//this is also used to quit effectively when we are out of campaigns of a certain type
	if (!recipeLength) return;
	
	int functionCloneId = cloneMarker++;
	int i;
	FATPvectorString tempRecipe;
	const FATPvectorString & avCampaigns = typeToCamps[functionCloneId];
	std::string prevCamp;
	int numberOfCamps=avCampaigns.size();
	
	//if we are not at the first position in the list of types
	//reset current positon to the first feasible campaign
	if (functionCloneId > 0)
	{
		prevCamp = typeToCamps[functionCloneId-1][vecOfPositions[functionCloneId-1]];
		// first we set LoBound with respect to the Start Period
		vecOfPositions[functionCloneId]= vecOfLoBounds[functionCloneId];
		while (compareCampaigns(prevCamp,
			avCampaigns[vecOfPositions[functionCloneId]]) < 0)
		{
			++vecOfPositions[functionCloneId];
			if (!(vecOfPositions[functionCloneId] < numberOfCamps))
			{
				recipeLength = 0;
				return;
			}
		}
		vecOfLoBounds[functionCloneId] = vecOfPositions[functionCloneId];

		while (!campaignsFeasible(prevCamp,
			avCampaigns[vecOfPositions[functionCloneId]]))
		{
			++vecOfPositions[functionCloneId];
			if (!(vecOfPositions[functionCloneId] < numberOfCamps))
			{
				recipeLength = 0;
				return;
			}
		}
	}

	while (vecOfPositions[functionCloneId] < numberOfCamps)
	{
		//if we are not at the last position in the list of types
		//call next clone of this function for the next position in the list of types
		//else just add recipes for all posible entries of th last type with the previous
		//campaigns set by previous calls of the function
		
		if (functionCloneId < recipeLength-1) 
		{
			recursiveAddCampaignNamesToRecipe(orderId,recipeLength,cloneMarker,
				vecOfPositions,vecOfLoBounds,typeToCamps,consRates);
		}
		else
		{
			tempRecipe.clear();
			for(i=0; i<recipeLength; i++)
			{
				if(MessagesOn) {std::cout << typeToCamps[i][vecOfPositions[i]] << " ";}
				tempRecipe.push_back(typeToCamps[i][vecOfPositions[i]]);
			}
			addOrderEntryRecipe(orderId,tempRecipe,consRates);
			if(MessagesOn) {std::cout << std::endl;}
		};
		vecOfPositions[functionCloneId]++;
	};
	cloneMarker--;
}
//----------------------------------------------------------------------------------------

//consumption rates set to one, when none are given
void FATPproblem::addOrderEntryRecipesByCampaignType(const std::string & orderId, 
													 const FATPvectorString & campaignTypes)
													 throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPvectorFloat cr;
		int c;
		for ( c=0; c<campaignTypes.size(); ++c ) {
			cr.push_back(1.0f);
		}
		addOrderEntryRecipesByCampaignType(orderId,campaignTypes,cr);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

//This is the method building list of all possible recipes for a given sequence of
//campaign types, by calling recursively the method recursiveAddCampaignNamesToRecipe.
void FATPproblem::addOrderEntryRecipesByCampaignType(const std::string & orderId, 
													 const FATPvectorString & campaignTypes,
													 const FATPvectorFloat & consRates)
													 throw(FATPException)
{
	// creating a list of campaigns sorted by type
	// Initializing the field "campsByTypes_" - only if it has not been done before.
	try
	{
		CheckIfOrderEntryExists(orderId);
		if(MessagesOn) 
		{std::cout<<std::endl<<"Building recipes for Order Entry "<<orderId<<std::endl;}
		if (campsByTypes_.size()==0)
		{
			// Get list of all campaigns
			std::vector<std::string> campaignNames,campTypes;
			getSortedCampaignNames(campaignNames);
			getCampaignTypes(campTypes);
			int numberOfTypes = campTypes.size();
			
			int c,s;
			for (s=0;s<numberOfTypes;s++)
			{ 
				// Loop once for each campaign to create vector of campaigns of type campType
				for (c=0; c<campaignNames.size(); ++c ) 
				{
					// get c'th campaigns type
					if (campTypes[s] == getCampaignType(campaignNames[c]))
						// add c'th campaign to map of types to campaigns.
						campsByTypes_[campTypes[s]].push_back(campaignNames[c]);
				}
			}
		};
		int recipeLength = campaignTypes.size();
		//	FATPvectorString::constant_iterator typIt=campaignTypes.begin();
		//the variable enumerating recursively called functions
		int cloneMarker =0;
		//initialize vector of positons with zeroes
		std::vector<int> vecOfPositions,vecOfLoBounds;
		int t;
		for(t=0;t<recipeLength;t++)
		{
			vecOfPositions.push_back(0);
			vecOfLoBounds.push_back(0);
		}
		// if no campaignTypes were specified, then just return
		if ( campaignTypes.begin() == campaignTypes.end() ) return;
		
		// Create map from campaignType to vector of campaigns
		// This typeToCamps could be kept in this classes private member data so
		// it does not have to be created each time this method is called.
		std::vector<FATPvectorString> typeToCamps;
		
		int s;
		for (s=0;s<recipeLength;s++)
		{			
			// Loop once for each campaign to create vector of campaigns of type campType
			std::vector<std::string> vectorOfCampaigns;
			std::string temp = campaignTypes[s];
			int u = getCampaignsOfType(campaignTypes[s]).size();
			
			//if there are no campaigns of a certain type available, we cannot compose a recipe
			if(getCampaignsOfType(campaignTypes[s]).size()==0) return;
			typeToCamps.push_back(getCampaignsOfType(campaignTypes[s]));
		}
		
		// Build recipe from campaign types
		recursiveAddCampaignNamesToRecipe(orderId,recipeLength,cloneMarker,
			vecOfPositions,vecOfLoBounds,typeToCamps,consRates);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

int FATPproblem::getOrderEntryAtpPeriod(const std::string & orderId )const
throw(FATPException)
{
	try
	{
	CheckIfOrderEntryExists(orderId);
	float * shipVol;
	witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
	int retPeriod = getNPeriods();
	while(!shipVol[--retPeriod]);
	witFree(shipVol);
	return retPeriod;
		}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

float FATPproblem::getOrderEntryCoilAtpQty(const std::string & orderId )const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		float * shipVol;
		witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
		int np = getNPeriods();
		float retVal=0;
		int t;
		for ( t=0; t<np; t++ ) {
			retVal = retVal + shipVol[t];
		}
		witFree(shipVol);
		return retVal;
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

std::vector<float>  FATPproblem::getOrderEntryCoilAtpVector(const std::string & orderId)const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		float * shipVol;
		witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
		int np = getNPeriods();
		std::vector<float> retVal;
		int i;
		for (i=0; i<np; i++) {
			retVal.push_back(shipVol[i]);
		}
		witFree(shipVol);
		return retVal;
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		std::vector<float> retVal;
		retVal.push_back(-1);
		return retVal;
	}
}

void FATPproblem::setOrderEntryDesiredPeriod(const std::string & orderId, int desiredPeriod )
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		if (desiredPeriod > getNPeriods())
		{
			std::cerr << "OrderEntry " << orderId << " scheduled too late" <<std::endl;
			exit(1);
		}
		FATPorderEntryAppData * appData;
		witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
		appData->setDesiredPeriod(desiredPeriod);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}


int FATPproblem::getOrderEntryDesiredPeriod( const std::string & orderId ) const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPorderEntryAppData * appData;
		witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
		return appData->getDesiredPeriod();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

void FATPproblem::setOrderEntryCoilQty(const std::string & orderId, float coilQty )
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPorderEntryAppData * appData;
		witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
		appData->setCoilQty(coilQty);
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

float FATPproblem::getOrderEntryCoilQty( const std::string & orderId ) const
throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		FATPorderEntryAppData * appData;
		witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
		return appData->getCoilQty();
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

void FATPproblem::getOrderEntryIds( std::vector<std::string> & orderEntryIds ) const
{
	orderEntryIds.clear();
	
	std::set<std::string>::const_iterator it;
	for ( it=orderEntryIds_.begin(); it!=orderEntryIds_.end(); ++it ) {
		orderEntryIds.push_back( *it );
	}
}

void FATPproblem::getOrderEntryUsedCampaigns (const std::string & orderId,
											  std::vector<std::string> & campaignNamesList,
											  std::vector<float>  & capacitiesConsumed)const
											  throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		if(MessagesOn)
		{
			std::cout << std::endl;
		    std::cout << "Pegging for Order Entry " << orderId <<std::endl;
		    std::cout << std::endl;
		}
		campaignNamesList.clear();
		capacitiesConsumed.clear();
		int per,i;
		int	NPeriods = getNPeriods();
		int Period = getOrderEntryDesiredPeriod(orderId );
		int locLenLists;
		char **           locPartNameList;
		int *             locPeriodList;
		float *           locPeggedVolList;
		
		for (per = Period; per<NPeriods; per++)
		{
			witGetDemandConsVolPip (mutableWitRun(),orderId.c_str(),orderId.c_str(),
				per, &locLenLists, &locPartNameList,&locPeriodList,&locPeggedVolList);
			for (i = locLenLists-1; 0<i ; i--)
			{
				if (campaignExists(locPartNameList[i]))
				{
					campaignNamesList.push_back(locPartNameList[i]);
					capacitiesConsumed.push_back(locPeggedVolList[i]);
					if(MessagesOn)
					{
						std::cout << "Campaign: " << locPartNameList[i] << "; ";
						std::cout << "at period: " << locPeriodList[i] << "; ";
						std::cout << "time consumed: " << locPeggedVolList[i] << "." << std::endl;
					}
				}
			}
			witFree(locPartNameList);
			witFree(locPeggedVolList);
		}
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
	}
}

char FATPproblem::getOrderEntryCampaignShortages(
												 const std::string & orderId,
												 std::vector<std::string> & shortCampaigns,
												 std::vector<float> & capacityShortages )const
												 throw(FATPException)
{
	try
	{
		CheckIfOrderEntryExists(orderId);
		int np = getNPeriods();

		// set FSS Ship Vol
		float * shipVol;
		float * originalShipVol;
		witGetDemandFssShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&originalShipVol);
		witGetDemandDemandVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
		witSetDemandFssShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),shipVol);  
		witFree(shipVol);
		shortCampaigns.clear();
		capacityShortages.clear();
		
		// Get shortages
		int nShortCampaigns;
		char **shortCamps;
		float **shortVols;
		witGetFocusShortageVol(mutableWitRun(),&nShortCampaigns,&shortCamps,&shortVols);
		
		// loop once for each campaign with a shortage
		int c,m;
		
		for ( c=0; c<nShortCampaigns; ++c ) {
			shortCampaigns.push_back(shortCamps[c]);
			
			int startPeriod = getCampaignStartPeriod(shortCamps[c]);
			for (m=0;m<startPeriod;m++)
			{
				if (shortVols[c][m] != 0)
				{
					shortCampaigns.clear();
					capacityShortages.clear();
					witFree(shortCamps[c]);
					witFree(shortVols[c]);
					witSetDemandFssShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),originalShipVol);
					witFree(originalShipVol);
					return 1;
				}
			}
			float shortage = 0;
			for (m=startPeriod; m < np; m++)
			{
				shortage +=shortVols[c][m];
			}
			capacityShortages.push_back(shortage);
			//std::vector<float> shortVol = witFloatStarToStlVec(shortVols[c]);
			//shortageQuantity.push_back(shortVol);
			witFree(shortCamps[c]);
			witFree(shortVols[c]);
		}
		witSetDemandFssShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),originalShipVol);
		witFree(originalShipVol);
		return 0;
		//GMS - I am messing with the answers:
		//If WIT tells us to get more of Campaign at period later then Start period, 
		//we move it back.
		//If WIT says we need it earlier, we answer "no way" (return 1).
	}
	catch(FATPException error)
	{
		error.displayMessage();
		throw(error);
		return -1;
	}
}

// ---------------------------
// Private method presolve.
// Set wit attributes required before solving
// ---------------------------
void FATPproblem::presolve()
{
  int np=getNPeriods();

  // Each campaign has a duration, startPeriod, and excessCapacity.
  // These three campaign attributes are used to set the supplyVol
  // of the wit capacity that represents the campaign.
  {
    
  // Initializing Campaigns
	float * supplyVol = new float[np];
    std::vector<std::string> campaignNames;
    getCampaignNames(campaignNames);
    int c,t;
    for( c=0; c<campaignNames.size(); ++c ) 
	{
		for (t=0; t<np; t++ ) 
			supplyVol[t]=0.f;

		int startPeriod = getCampaignStartPeriod(campaignNames[c]);
		float duration = getCampaignDuration(campaignNames[c]);
		float excessCapacity = getCampaignExcessCapacity(campaignNames[c]);

    supplyVol[startPeriod] = excessCapacity;

		witSetPartSupplyVol(witRun(),campaignNames[c].c_str(),supplyVol);
    
    }
    delete [] supplyVol;   
  }

  {
  //Initializing OrderEntries (by GMS)
	float * demandVol = new float[np];
    std::vector<std::string> orderEntryIds;
    getOrderEntryIds(orderEntryIds);
    int c,t;
    for( c=0; c<orderEntryIds.size(); ++c ) 
	{
		for (t=0; t<np; t++ )
		{
			demandVol[t]=0.f;
		}
		int  desiredPeriod = getOrderEntryDesiredPeriod(orderEntryIds[c]);
		float coilQty = getOrderEntryCoilQty(orderEntryIds[c]);
		demandVol[desiredPeriod]=coilQty;
		witSetDemandDemandVol(witRun(),orderEntryIds[c].c_str(),orderEntryIds[c].c_str(),demandVol);
    }
    delete [] demandVol; 
  }
}

// ************************************************************************

void FATPproblem::computeAtp()
{
	presolve();
	witWriteData(witRun(),"fatp.wit");
	//generate sorted w.r.t importance list of order entries.
	
	FATPorderEntryAppData * appData;
	std::set<FATPorderEntryAppData *, sortOrderEntriesByImportance> sortedOrderEntryIds;
	std::vector<std::string> orderEntryIds;
	
	//and now we order them using a set. :-)
	getOrderEntryIds(orderEntryIds);
	int i, size = orderEntryIds.size() ;
	for (i=0; i<size;i++)
	{
		witGetDemandAppData (mutableWitRun(), orderEntryIds[i].c_str(), 
			orderEntryIds[i].c_str(),(void**) &appData);
		sortedOrderEntryIds.insert(appData);
	}
	std::set<FATPorderEntryAppData *, sortOrderEntriesByImportance>::const_iterator it;
	it = sortedOrderEntryIds.begin();
	i = sortedOrderEntryIds.size();
	orderEntryIds.clear();
	
	for (it=sortedOrderEntryIds.begin();it!=sortedOrderEntryIds.end();++it)
	{
		orderEntryIds.push_back((*it)->getOrderEntryId());
	}
	
	// now orderEntryIds is a sorted vector of orderId-s
	float demand, incVol;
	int period, nPeriods = getNPeriods();
	std::string name;
	witReturnCode rc;
	
	rc = witSetPipSeqFromHeur(witRun(), true);
	rc = witStartHeurAlloc(witRun());
	
	for (i=0;i<size;i++)
	{
		witGetDemandAppData (mutableWitRun(), orderEntryIds[i].c_str(), 
			orderEntryIds[i].c_str(),(void**) &appData);
		name = orderEntryIds[i].c_str();
		period = (appData)->getDesiredPeriod();
		demand = (appData)->getCoilQty();
		incVol=0;
		do
		{
			demand -= incVol;
			rc = witIncHeurAlloc (
				mutableWitRun(),
				orderEntryIds[i].c_str(),
				orderEntryIds[i].c_str(),
				period++,
				demand,
				& incVol);
		}
		while(incVol < demand && period < nPeriods);
	}
	
	rc = witFinishHeurAlloc(witRun());
	rc = witBuildPip(witRun());

	//OLD WIT CALL :
	//witHeurImplode(witRun());
}

//*************************************************************************


//--------------------------------------------------------

// default constructor
FATPproblem::FATPproblem()
:
SCOproblemBase(),
campaignNames_(),
sortedCampaignNames_(),
campaignTypes_(),
orderEntryIds_(),
campsByTypes_()
{
  // witSetOptWithLotSizes(witRun(),WitTRUE); 
  witSetExecEmptyBom(witRun(),WitTRUE);
}

// destructor
FATPproblem::~FATPproblem()
{
  gutsOfDestructor();
}

// copy constructor
FATPproblem::FATPproblem( const FATPproblem& source ):
SCOproblemBase(source),
campaignNames_(),
sortedCampaignNames_(),
campaignTypes_(),
orderEntryIds_()
{
  gutsOfCopy(source);
}

// assignment operator
FATPproblem&
FATPproblem::operator=(const FATPproblem& rhs)
{  
  if (this != &rhs) { 
    SCOproblemBase::operator=(rhs);
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object
void FATPproblem::gutsOfCopy( const FATPproblem& source )
{
  
  campaignNames_ = source.campaignNames_;
  sortedCampaignNames_ = source.sortedCampaignNames_;
  campaignTypes_ = source.campaignTypes_;
  orderEntryIds_ = source.orderEntryIds_;
  campsByTypes_.clear();

  // copy campaign appData
  {
    int c;
    std::vector<std::string> campaignNames;
    getCampaignNames(campaignNames);
    for ( c=0; c<campaignNames.size(); ++c ) { 
      FATPcampaignAppData * srcAppData;    
      FATPcampaignAppData * sinkAppData;
      witGetPartAppData(source.mutableWitRun(),campaignNames[c].c_str(),(void**)&srcAppData);
      sinkAppData = new FATPcampaignAppData(*srcAppData);    
      witSetPartAppData(witRun(),campaignNames[c].c_str(),sinkAppData);
    }
  }

  // copy orderEntryId appData
  {
    int o;
    std::vector<std::string> orderEntryIds;
    getOrderEntryIds(orderEntryIds);
    for ( o=0; o<orderEntryIds.size(); ++o ) { 
      FATPorderEntryAppData * srcAppData;    
      FATPorderEntryAppData * sinkAppData;
      witGetDemandAppData(source.mutableWitRun(),orderEntryIds[o].c_str(),orderEntryIds[o].c_str(),(void**)&srcAppData);
      sinkAppData = new FATPorderEntryAppData(*srcAppData);    
      witSetDemandAppData(witRun(),orderEntryIds[o].c_str(),orderEntryIds[o].c_str(),sinkAppData);
    }
  }
}

// destructor
void FATPproblem::gutsOfDestructor()
{
  
  // delete campaign appData
  {
    int c;
    std::vector<std::string> campaignNames;
    getCampaignNames(campaignNames);
    for ( c=0; c<campaignNames.size(); ++c ) { 
      FATPcampaignAppData * srcAppData;  
      witGetPartAppData(mutableWitRun(),campaignNames[c].c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
   
  // delete orderEntry appData
  {
    int c;
    std::vector<std::string> orderEntryIds;
    getOrderEntryIds(orderEntryIds);
    for ( c=0; c<orderEntryIds.size(); ++c ) { 
      FATPorderEntryAppData * srcAppData;  
      witGetDemandAppData(mutableWitRun(),orderEntryIds[c].c_str(),orderEntryIds[c].c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
}

#ifdef NDEBUG
#undef NDEBUG
#endif

//******************************************************************************
//------------------------------------------------------------------------------
// Test function
//------------------------------------------------------------------------------
//******************************************************************************


void
FATPproblem::test()
{
  //FATPproblem::getMessagesOn() = false;
  CoinRelFltEq eq;
  FATPproblem tempProb;
  
  {
	  FATPproblem prob,prob1;
	  
	  prob.setNPeriods(30);
	  assert( prob.getNPeriods() == 30 );
	  
	  prob.setTitle("wittitle");
	  assert( prob.getTitle() == "wittitle");
	  
	  assert( prob.implosionCount()==0 );  
  }
  
  // test campaign methods
  {
	  FATPproblem prob;
	  assert( !prob.campaignExists("C1") );

	  std::vector<std::string> cNames;
	  prob.getCampaignNames(cNames);
	  assert( cNames.size()==0 );
	  
	  std::vector<std::string> cTypes;
	  prob.getCampaignTypes(cTypes);
	  assert( cTypes.size()==0 );


	  prob.addCampaign("C1");
	  assert( prob.campaignExists("C1") );
	  prob.getCampaignNames(cNames);
	  assert( cNames.size()==1 );
	  assert( cNames[0]=="C1");
	  
	  assert(prob.getCampaignDuration("C1")==1);
	  prob.setCampaignDuration("C1",5);
	  assert(prob.getCampaignDuration("C1")==5);
	  
	  assert(prob.getCampaignStartPeriod("C1")==0);
	  prob.setCampaignStartPeriod("C1",4);
	  assert(prob.getCampaignStartPeriod("C1")==4);

	  //testing error handling
	  try
	  {
		  prob.setCampaignStartPeriod("Nonexistent 1",4);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Campaign Nonexistent 1 does not exist");
	  }
	  try
	  {
		  prob.getCampaignStartPeriod("Nonexistent 2");
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Campaign Nonexistent 2 does not exist");
	  }
	  try
	  {
		  prob.getCampaignDuration("Nonexistent 3");
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Campaign Nonexistent 3 does not exist");
	  }
	  try
	  {
		  prob.setCampaignDuration("Nonexistent 4",4);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Campaign Nonexistent 4 does not exist");
	  }
	  try
	  {
		  prob.setCampaignStartPeriod("C1",310);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Invalid Campaign C1 Start Period");
	  }
	  try
	  {
		  prob.setCampaignDuration("C1",4000);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Campaign C1 ends too late");
	  }


	  prob.setCampaignStartPeriod("C1",26);

	  
	  assert(prob.getCampaignExcessCapacity("C1")==0);
	  prob.setCampaignExcessCapacity("C1",7.1f);
	  assert(eq(prob.getCampaignExcessCapacity("C1"),7.1f));

	  
	  assert(prob.getCampaignType("C1")=="");
	  assert(prob.getCampaignType("C1")!="c");
	  prob.setCampaignType("C1","CT1");
	  assert(prob.getCampaignType("C1")=="CT1");

	  prob.addCampaign("C2");
	  assert( prob.campaignExists("C2") );
	  prob.setCampaignStartPeriod("C2",3);
	  prob.getCampaignNames(cNames);
	  assert( cNames.size()==2 );
	  assert( cNames[0]=="C1");
	  assert( cNames[1]=="C2");

	  assert(prob.getCampaignType("C2")=="");
	  assert(prob.getCampaignType("C2")!="c");
	  prob.setCampaignType("C2","CT1");
	  assert(prob.getCampaignType("C2")=="CT1");

	  prob.getCampaignNames(cNames);
	  assert( cNames.size()==2 );
	  assert( cNames[0]=="C1");
	  assert( cNames[1]=="C2");

	  cNames.clear();
	  prob.getSortedCampaignNames(cNames);
	  assert( cNames.size()==2 );
	  assert( cNames[0]=="C2");
	  assert( cNames[1]=="C1");

	  tempProb = prob;

	  prob.getCampaignTypes(cTypes);
	  assert( cTypes.size()==1 );
	  assert( cTypes[0]=="CT1");
  }

   	  std::vector<std::string> cTypes;
	  tempProb.getCampaignTypes(cTypes);
	  assert( cTypes.size()==1 );
	  assert( cTypes[0]=="CT1");

//Multiple calls of the SetStartPeriod for the same campaign
  {
	  FATPproblem prob;
	  
   	  std::vector<std::string> cNames;

	  prob.addCampaign("C1");
	  prob.setCampaignStartPeriod("C1",5);
	  prob.setCampaignStartPeriod("C1",4);

	  
	  cNames.clear();
	  prob.getSortedCampaignNames(cNames);
	  assert( cNames.size()==1 );
	  assert( cNames[0]=="C1");

	  prob.addCampaign("C2");
	  prob.setCampaignStartPeriod("C2",5);
	  prob.setCampaignStartPeriod("C1",3);
	  prob.setCampaignStartPeriod("C2",2);

	  assert(prob.getCampaignStartPeriod("C1")==3);

	  cNames.clear();
	  prob.getSortedCampaignNames(cNames);
	  assert( cNames.size()==2 );
	  assert( cNames[0]=="C2");
	  assert( cNames[1]=="C1");  
  }

  //test order entry methods
  {
	  FATPproblem prob;

	  //testing calls for nonexistent Order Entries
	  try
	  {
	  prob.setOrderEntryDesiredPeriod("NonexistentOrder",4);
	   }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  }
	  try
	  {
	  prob.getOrderEntryDesiredPeriod("NonexistentOrder");
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  }
	  try
	  {
	  prob.setOrderEntryCoilQty("NonexistentOrder",4);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  }
	   try
	  {
	  prob.getOrderEntryCoilQty("NonexistentOrder");
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  }
	   try
	  {
	  prob.setOrderEntryImportance("NonexistentOrder",4);
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  } try
	  {
	  prob.getOrderEntryImportance("NonexistentOrder");
	  }
	  catch (FATPException error)
	  {
		  assert(error.getErrorMessage() == "Order Entry NonexistentOrder does not exist");
	  }
	 	  
	  //testing Order Entry methods
	  assert(!prob.orderEntryExists("Order1"));

	  std::vector<std::string> oeNames;
	  prob.getOrderEntryIds(oeNames);
	  assert( oeNames.size()==0 );

	  prob.addOrderEntry("Order1");
	  assert( prob.orderEntryExists("Order1") );
	  prob.getOrderEntryIds(oeNames);
	  assert( oeNames.size()==1 );
	  assert( oeNames[0]=="Order1");
	  

	  
	  assert(prob.getOrderEntryImportance("Order1")==0);
	  prob.setOrderEntryImportance("Order1",3);
	  assert(prob.getOrderEntryImportance("Order1")==3);
	  assert(prob.orderEntryExists("Order1"));
	  	  
	  assert(prob.getOrderEntryDesiredPeriod("Order1")==0);
	  prob.setOrderEntryDesiredPeriod("Order1",5);
	  assert(prob.getOrderEntryDesiredPeriod("Order1")==5);

      // should cause an error
	  //prob.setOrderEntryDesiredPeriod("Order1",29);


	  assert(prob.getOrderEntryCoilQty("Order1")==0);
	  prob.setOrderEntryCoilQty("Order1",7);
	  assert(prob.getOrderEntryCoilQty("Order1")==7);

	  prob.addOrderEntry("Order2");
	  assert( prob.orderEntryExists("Order2") );
	  prob.getOrderEntryIds(oeNames);
	  assert( oeNames.size()==2 );
	  assert( oeNames[0]=="Order1");
	  assert( oeNames[1]=="Order2");
  }

  // test presolve
  {
	  FATPproblem prob;

	  prob.addCampaign("C1");
	  prob.setCampaignStartPeriod("C1",3);
	  prob.setCampaignDuration("C1",2);
	  prob.setCampaignType("C1","T1");
	  prob.setCampaignExcessCapacity("C1",5.f);
	  prob.addCampaign("C2"); 

	  float * supplyVol;
	  witGetPartSupplyVol(prob.witRun(),"C1",&supplyVol);
	  assert(supplyVol[2]==0.0f);
	  assert(supplyVol[3]==0.0f);
	  assert(supplyVol[4]==0.0f);
	  assert(supplyVol[5]==0.0f);
	  assert(supplyVol[6]==0.0f);
	  witFree(supplyVol);

	  prob.setCampaignStartPeriod("C2",3);
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignExcessCapacity("C2",5.f);

	  prob.computeAtp();

	 // assert(prob.getCampaignsOfType("T1")[0] == "C1");

	  witGetPartSupplyVol(prob.witRun(),"C1",&supplyVol);
	  assert(supplyVol[2]==0.0f);
	  assert(supplyVol[3]==5.0f);
	  assert(supplyVol[4]==0.0f);
	  assert(supplyVol[5]==0.0f);
	  assert(supplyVol[6]==0.0f);
	  witFree(supplyVol);

  }

  // test assignment operator
  {
    FATPproblem p1;
    {
      FATPproblem prob;
      
      prob.addCampaign("C1");
      prob.addCampaign("C2");
      prob.setCampaignStartPeriod("C1",2); 
      prob.setCampaignStartPeriod("C2",3);

	  prob.addOrderEntry("o1");
	  prob.setOrderEntryCoilQty("o1",4.f);

      p1 = prob;

      prob.setCampaignStartPeriod("C1",4); 
      prob.setCampaignStartPeriod("C2",5);
	  prob.setOrderEntryCoilQty("o1",5.f);
    }

    assert(p1.getCampaignStartPeriod("C1") == 2 );
    assert(p1.getCampaignStartPeriod("C2") == 3 );
	assert( eq(p1.getOrderEntryCoilQty("o1"),4.f) );


  }

  // test adding recipe
  // 1 order entry, 3 campaigns. No time delay.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	 float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	 std::vector<float> atpQtyV = prob.getOrderEntryCoilAtpVector("O1");

	 // sum atpQtyV
	 float sumAtpQtyV = 0.f;
	 int t;
	 for ( t=0; t<atpQtyV.size(); ++t ) {
		 sumAtpQtyV += atpQtyV[t];
	 }
	 assert( eq(sumAtpQtyV,atpQty) );
	  

	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  
	  assert( o1delivered==9 );
	  
	  assert( eq(atpQty,5.f) );
  }

  // test consumption rate other than 1.
  // 1 order entry, 3 campaigns. No time delay.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  //this is NOT a feasible set of campaigns!
	  assert( !prob.campaignsFeasible("C1","C2") || !prob.campaignsFeasible("C2","C3") );
  	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);

	  assert( !prob.campaignsFeasible("C1","C2") || !prob.campaignsFeasible("C2","C3") );

	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.5f);
	  cr.push_back(0.5f);
	  prob.addOrderEntryRecipe("O1",recipe,cr);
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  std::vector<float> atpQtyV = prob.getOrderEntryCoilAtpVector("O1");
	  
	  // sum atpQtyV
	  float sumAtpQtyV = 0.f;
	  int t;
	  for ( t=0; t<atpQtyV.size(); ++t ) {
		  sumAtpQtyV += atpQtyV[t];
	  }
	  assert( eq(sumAtpQtyV,atpQty) );
	  
	  
	  assert( eq(c1Consumed,5.0f/2.f) );
	  assert( eq(c2Consumed,5.0f/2.f) );
	  assert( eq(c2Consumed,5.0f/2.f) );
	  
	  assert( o1delivered==9 );
	  
	  assert( eq(atpQty,5.f) );
  }
  
  // test consumption rate other than 1 AND using types instead of campaign names
  // 1 order entry, 3 campaigns. No time delay.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",3); 
	  prob.setCampaignStartPeriod("C2",5);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);

	  prob.setCampaignType("C1","CT1"); 
	  prob.setCampaignType("C2","CT2");
	  prob.setCampaignType("C3","CT3");

	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("CT1");
	  recipe.push_back("CT2");
	  recipe.push_back("CT3");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.5f);
	  cr.push_back(0.5f);
  	  prob.addOrderEntryRecipesByCampaignType("O1",recipe,cr);

	  prob.computeAtp();	

	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	 float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	 std::vector<float> atpQtyV = prob.getOrderEntryCoilAtpVector("O1");

	 // sum atpQtyV
	 float sumAtpQtyV = 0.f;
	 int t;
	 for ( t=0; t<atpQtyV.size(); ++t ) {
		 sumAtpQtyV += atpQtyV[t];
	 }
	 assert( eq(sumAtpQtyV,atpQty) );
	  

	  assert( eq(c1Consumed,5.0f/2.f) );
	  assert( eq(c2Consumed,5.0f/2.f) );
	  assert( eq(c2Consumed,5.0f/2.f) );
	  
	  assert( o1delivered==9 );
	  
	  assert( eq(atpQty,5.f) );
  }




  // 1 order entry, 3 campaigns. No time delay. 
  // No part of order can be met, because insuffient capacity.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",0); 
	  prob.setCampaignDuration("C2",0);
	  prob.setCampaignDuration("C3",0);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2", 0.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  
	  assert( eq(c1Consumed,0.0f) );
	  assert( eq(c2Consumed,0.0f) );
	  assert( eq(c2Consumed,0.0f) );
	  
	  assert( o1delivered==-1 );
	  
	  assert( eq(atpQty,0.f) );
  }

    
  // 1 order entry, 3 campaigns. No time delay. 
  // Half of order can be met, because not enough
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",0); 
	  prob.setCampaignDuration("C2",0);
	  prob.setCampaignDuration("C3",0);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",3.0f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
    
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  
	  assert( eq(c1Consumed,3.0f) );
	  assert( eq(c2Consumed,3.0f) );
	  assert( eq(c2Consumed,3.0f) );
	  
    assert( o1delivered==7 );

    assert( eq(atpQty,3.0f) );
  }

  // 1 order entry, 3 campaigns with duration of 2, 1 recipe.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",9);
	  prob.setCampaignStartPeriod("C3",11);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",0);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  
	  prob.computeAtp();
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  assert( o1delivered==13 );
	  assert( eq(atpQty,5.f) );
	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  assert( eq(c3Consumed,5.0f) );
  }

  // single orderEntry, 2 recipes, no time delay
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",0); 
	  prob.setCampaignDuration("C2",0);
	  prob.setCampaignDuration("C3",0);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  prob.addOrderEntryRecipe("O1",recipe);
	  recipe.clear();
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  
	  assert( eq(c1Consumed,5.0f) || eq(c3Consumed,5.0f));
	  assert( eq(c2Consumed,5.0f) );
	  
	  assert( o1delivered==7 );
	  assert( eq(atpQty,5.f) );
  }

  // single orderEntry, 2 recipes, no time delay, no capacity in first recipe
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",7);
	  
	  prob.setCampaignDuration("C1",0); 
	  prob.setCampaignDuration("C2",0);
	  prob.setCampaignDuration("C3",0);
	  
	  prob.setCampaignExcessCapacity("C1",0.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  prob.addOrderEntryRecipe("O1",recipe);
	  assert( prob.getOrderEntryNRecipes("O1")==1 );
	  recipe.clear();
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
	  assert( prob.getOrderEntryNRecipes("O1")==2 );
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");

	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  
	  assert( eq(c1Consumed,0.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  assert( eq(c3Consumed,5.0f) );
	  
    assert( o1delivered==7 );
    assert( eq(atpQty,5.f) );
  }

  
  // single orderEntry, 2 recipes defined campaignTypes
  // with time delay,
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",2); 
	  prob.setCampaignStartPeriod("C2",4);
	  prob.setCampaignStartPeriod("C3",6);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",5.f);
	  prob.setCampaignExcessCapacity("C3",5.f);
	  
	  prob.setCampaignType("C1","T1"); 
	  prob.setCampaignType("C2","T2"); 
	  prob.setCampaignType("C3","T2"); 
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
#if 0
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  prob.addOrderEntryRecipe("O1",recipe);
	  recipe.clear();
	  recipe.push_back("C1");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O1",recipe);
#else
    FATPvectorString types;
	  types.push_back("T1");
	  types.push_back("T2");
	  prob.addOrderEntryRecipesByCampaignType("O1",types);
    assert( prob.getOrderEntryNRecipes("O1")==2 );
#endif
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");

	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
    std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
	  
	  assert( eq(c1Consumed,10.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  assert( eq(c3Consumed,5.0f) );
	  
    assert( o1delivered==8 );
    assert( eq(atpQty,10.f) );
    assert( eq(atpQtyVec[7],5.f) );
    assert( eq(atpQtyVec[8],5.f) );
  }
  
  // single orderEntry, 27 recipes defined from campaignTypes
  // with time delay.
  // 2 of the 27 recipes have capacity to meet orderEntry
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  prob.addCampaign("C4");
	  prob.addCampaign("C5");
	  prob.addCampaign("C6");
	  prob.addCampaign("C7");
	  prob.addCampaign("C8");
	  prob.addCampaign("C9");
	  
	  prob.setCampaignStartPeriod("C1",2); 
	  prob.setCampaignStartPeriod("C2",2);
	  prob.setCampaignStartPeriod("C3",2);
	  prob.setCampaignStartPeriod("C4",4); 
	  prob.setCampaignStartPeriod("C5",4);
	  prob.setCampaignStartPeriod("C6",4);
	  prob.setCampaignStartPeriod("C7",6); 
	  prob.setCampaignStartPeriod("C8",6);
	  prob.setCampaignStartPeriod("C9",6);

	  std::vector<std::string> campaignNames;
	  prob.getSortedCampaignNames(campaignNames);

	  assert(campaignNames.size()==9);
	  assert(campaignNames[3] =="C4");

	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  prob.setCampaignDuration("C4",2); 
	  prob.setCampaignDuration("C5",2);
	  prob.setCampaignDuration("C6",2);
	  prob.setCampaignDuration("C7",2); 
	  prob.setCampaignDuration("C8",2);
	  prob.setCampaignDuration("C9",2);
	  
	  prob.setCampaignExcessCapacity("C1",5.f); 
	  prob.setCampaignExcessCapacity("C2",0.f);
	  prob.setCampaignExcessCapacity("C3",5.f);
	  prob.setCampaignExcessCapacity("C4",0.f); 
	  prob.setCampaignExcessCapacity("C5",10.f);
	  prob.setCampaignExcessCapacity("C6",0.f);
	  prob.setCampaignExcessCapacity("C7",0.f); 
	  prob.setCampaignExcessCapacity("C8",5.f);
	  prob.setCampaignExcessCapacity("C9",5.f);
	  
	  prob.setCampaignType("C1","T1"); 
	  prob.setCampaignType("C2","T1"); 
	  prob.setCampaignType("C3","T1"); 
	  prob.setCampaignType("C4","T2"); 
	  prob.setCampaignType("C5","T2"); 
	  prob.setCampaignType("C6","T2"); 
	  prob.setCampaignType("C7","T3"); 
	  prob.setCampaignType("C8","T3"); 
	  prob.setCampaignType("C9","T3"); 
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
    FATPvectorString types;
	  types.push_back("T1");
	  types.push_back("T2");
	  types.push_back("T3");
	  prob.addOrderEntryRecipesByCampaignType("O1",types);
      assert( prob.getOrderEntryNRecipes("O1")==27 );
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  float c4Consumed = prob.getCampaignExcessCapacityConsumed("C4");
	  float c5Consumed = prob.getCampaignExcessCapacityConsumed("C5");
	  float c6Consumed = prob.getCampaignExcessCapacityConsumed("C6");
	  float c7Consumed = prob.getCampaignExcessCapacityConsumed("C7");
	  float c8Consumed = prob.getCampaignExcessCapacityConsumed("C8");
	  float c9Consumed = prob.getCampaignExcessCapacityConsumed("C9");
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
	  
	  assert( eq(c1Consumed, 5.0f) );
	  assert( eq(c3Consumed, 5.0f) );
	  assert( eq(c5Consumed,10.0f) );
	  assert( eq(c8Consumed, 5.0f) );
	  assert( eq(c9Consumed, 5.0f) );
	  
	  assert( o1delivered==8 );
	  assert( eq(atpQty,10.f) );
	  assert( eq(atpQtyVec[7],0.f) );
	  assert( eq(atpQtyVec[8],10.f) );

	  //added to test pegging

	  std::vector<std::string> camps;
	  std::vector<float>  usages;

	  prob.getOrderEntryUsedCampaigns ("O1",camps,usages);

	  assert(camps.size() == 5);
	  assert(camps[0] == "C1");
	  assert(camps[1] == "C3");
	  assert(camps[2] == "C5");
	  assert(camps[3] == "C8");
	  assert(camps[4] == "C9");
	  assert(eq(usages[0], 5.0f));	  
	  assert(eq(usages[1], 5.0f));
	  assert(eq(usages[2], 10.0f));
	  assert(eq(usages[3], 5.0f));
	  assert(eq(usages[4], 5.0f));
}

  
  // single orderEntry, 27 possible recipes defined from campaignTypes,
  // but only one of them is time feasible.
  // The purpose of this test is to ensure that only the one
  // feasible recipe gets added.
  // There is time delay.
  // There is enough capacity to meet have of the orderEntry.
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  prob.addCampaign("C4");
	  prob.addCampaign("C5");
	  prob.addCampaign("C6");
	  prob.addCampaign("C7");
	  prob.addCampaign("C8");
	  prob.addCampaign("C9");
	  
	  prob.setCampaignStartPeriod("C1",2); 
	  prob.setCampaignStartPeriod("C2",3);
	  prob.setCampaignStartPeriod("C3",2);
	  prob.setCampaignStartPeriod("C4",3); 
	  prob.setCampaignStartPeriod("C5",4);
	  prob.setCampaignStartPeriod("C6",4);
	  prob.setCampaignStartPeriod("C7",5); 
	  prob.setCampaignStartPeriod("C8",5);
	  prob.setCampaignStartPeriod("C9",6);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",4);
	  prob.setCampaignDuration("C4",2); 
	  prob.setCampaignDuration("C5",2);
	  prob.setCampaignDuration("C6",3);
	  prob.setCampaignDuration("C7",2); 
	  prob.setCampaignDuration("C8",3);
	  prob.setCampaignDuration("C9",2);
	  
	  prob.setCampaignExcessCapacity("C1",5.f); 
	  prob.setCampaignExcessCapacity("C2",5.f);
	  prob.setCampaignExcessCapacity("C3",5.f);
	  prob.setCampaignExcessCapacity("C4",5.f); 
	  prob.setCampaignExcessCapacity("C5",5.f);
	  prob.setCampaignExcessCapacity("C6",5.f);
	  prob.setCampaignExcessCapacity("C7",5.f); 
	  prob.setCampaignExcessCapacity("C8",5.f);
	  prob.setCampaignExcessCapacity("C9",5.f);
	  
	  prob.setCampaignType("C1","T1"); 
	  prob.setCampaignType("C2","T1"); 
	  prob.setCampaignType("C3","T1"); 
	  prob.setCampaignType("C4","T2"); 
	  prob.setCampaignType("C5","T2"); 
	  prob.setCampaignType("C6","T2"); 
	  prob.setCampaignType("C7","T3"); 
	  prob.setCampaignType("C8","T3"); 
	  prob.setCampaignType("C9","T3"); 
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
    FATPvectorString types;
	  types.push_back("T1");
	  types.push_back("T2");
	  types.push_back("T3");
	  prob.addOrderEntryRecipesByCampaignType("O1",types);
    assert( prob.getOrderEntryNRecipes("O1")==1 );
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  float c4Consumed = prob.getCampaignExcessCapacityConsumed("C4");
	  float c5Consumed = prob.getCampaignExcessCapacityConsumed("C5");
	  float c6Consumed = prob.getCampaignExcessCapacityConsumed("C6");
	  float c7Consumed = prob.getCampaignExcessCapacityConsumed("C7");
	  float c8Consumed = prob.getCampaignExcessCapacityConsumed("C8");
	  float c9Consumed = prob.getCampaignExcessCapacityConsumed("C9");

	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
    std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
	  
	  assert( eq(c1Consumed, 5.0f) );
	  assert( eq(c2Consumed, 0.0f) );
	  assert( eq(c3Consumed, 0.0f) );
	  assert( eq(c4Consumed, 0.0f) );
	  assert( eq(c5Consumed, 5.0f) );
	  assert( eq(c6Consumed, 0.0f) );
	  assert( eq(c7Consumed, 0.0f) );
	  assert( eq(c8Consumed, 0.0f) );
	  assert( eq(c9Consumed, 5.0f) );
	  
    assert( o1delivered==8 );
    assert( eq(atpQty,5.f) );
    assert( eq(atpQtyVec[7],0.f) );
    assert( eq(atpQtyVec[8],5.f) );
  }

  
  // single orderEntry, 0 recipes defined campaignTypes where an undefined campaignType is specified
  // with time delay,
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",2); 
	  prob.setCampaignStartPeriod("C2",4);
	  prob.setCampaignStartPeriod("C3",6);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",5.f);
	  prob.setCampaignExcessCapacity("C3",5.f);
	  
	  prob.setCampaignType("C1","T1"); 
	  prob.setCampaignType("C2","T2"); 
	  prob.setCampaignType("C3","T2"); 
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
    // Specify a type for which there are no campaigns.
    FATPvectorString types;
	  types.push_back("T1");
	  types.push_back("TXX");
	  types.push_back("T2");
	  prob.addOrderEntryRecipesByCampaignType("O1",types);
    assert( prob.getOrderEntryNRecipes("O1")==0 );
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");

	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
    std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
	  
	  assert( eq(c1Consumed,0.0f) );
	  assert( eq(c2Consumed,0.0f) );
	  assert( eq(c3Consumed,0.0f) );
	  
    assert( o1delivered==-1 );
    assert( eq(atpQty,0.f) );
    assert( eq(atpQtyVec[7],0.f) );
    assert( eq(atpQtyVec[8],0.f) );
  }

  
  // single orderEntry, 0 recipes defined by 0 length campaignTypes vector
  {
	  FATPproblem prob;
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  
	  prob.setCampaignStartPeriod("C1",2); 
	  prob.setCampaignStartPeriod("C2",4);
	  prob.setCampaignStartPeriod("C3",6);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",5.f);
	  prob.setCampaignExcessCapacity("C3",5.f);
	  
	  prob.setCampaignType("C1","T1"); 
	  prob.setCampaignType("C2","T2"); 
	  prob.setCampaignType("C3","T2"); 
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",7);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",2);
	  
	  // define campaigns required for producing order entry
    // Specify a type for which there are no campaigns.
    FATPvectorString types;
	  prob.addOrderEntryRecipesByCampaignType("O1",types);
    assert( prob.getOrderEntryNRecipes("O1")==0 );
	  
	  prob.computeAtp();
	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");

	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
    std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
	  
	  assert( eq(c1Consumed,0.0f) );
	  assert( eq(c2Consumed,0.0f) );
	  assert( eq(c3Consumed,0.0f) );
	  
    assert( o1delivered==-1 );
    assert( eq(atpQty,0.f) );
    assert( eq(atpQtyVec[7],0.f) );
    assert( eq(atpQtyVec[8],0.f) );
  }

  // Some more testing by GMS
  // 5 campaigns (just in case)
  // Many competing orders
  {
	  FATPproblem prob;
	  
	  prob.setNPeriods(30);
	  assert( prob.getNPeriods() == 30 );
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  prob.addCampaign("C4");
	  prob.addCampaign("C5");
	  
	  prob.setCampaignStartPeriod("C1",3); 
	  prob.setCampaignStartPeriod("C2",5);
	  prob.setCampaignStartPeriod("C3",7);
	  prob.setCampaignStartPeriod("C4",9); 
	  prob.setCampaignStartPeriod("C5",11);
	  
	  prob.setCampaignDuration("C1",2); 
	  prob.setCampaignDuration("C2",2);
	  prob.setCampaignDuration("C3",2);
	  prob.setCampaignDuration("C4",2); 
	  prob.setCampaignDuration("C5",2);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  prob.setCampaignExcessCapacity("C4",10.f); 
	  prob.setCampaignExcessCapacity("C5",10.f);
	  
	  
	  
	  // define order entries
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",0);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",3);
	  
	  prob.addOrderEntry("O2");
	  prob.setOrderEntryDesiredPeriod("O2",0);
	  prob.setOrderEntryCoilQty("O2",10.f);
	  prob.setOrderEntryImportance("O2",4);
	  
	  prob.addOrderEntry("O3");
	  prob.setOrderEntryDesiredPeriod("O3",0);
	  prob.setOrderEntryCoilQty("O3",5.f);
	  prob.setOrderEntryImportance("O3",5);
	  
	  prob.addOrderEntry("O4");
	  prob.setOrderEntryDesiredPeriod("O4",0);
	  prob.setOrderEntryCoilQty("O4",5.f);
	  prob.setOrderEntryImportance("O4",2);
	  
	  prob.addOrderEntry("O5");
	  prob.setOrderEntryDesiredPeriod("O5",10);
	  prob.setOrderEntryCoilQty("O5",5.f);
	  prob.setOrderEntryImportance("O5",1);
	  
	  	  
	  // define campaigns required for producing order entry
	  FATPvectorString recipe;
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.25f);
	  cr.push_back(0.5f);
	  prob.addOrderEntryRecipe("O1",recipe,cr);
	  
	  
	  recipe.clear();
	  cr.clear();
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  cr.push_back(0.25f);
	  cr.push_back(0.25f);
	  cr.push_back(0.25f);
	  prob.addOrderEntryRecipe("O2",recipe,cr);
	  	  
	  recipe.clear();
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O3",recipe);
	  
	  recipe.clear();
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O4",recipe);
	  
	  
	  recipe.clear();
	  recipe.push_back("C2");
	  recipe.push_back("C3");
	  prob.addOrderEntryRecipe("O5",recipe);
	  
	  recipe.clear();
	  recipe.push_back("C4");
	  recipe.push_back("C5");
	  prob.addOrderEntryRecipe("O5",recipe);
	  
	  
	  prob.computeAtp();
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  int o2delivered = prob.getOrderEntryAtpPeriod("O2");
	  int o3delivered = prob.getOrderEntryAtpPeriod("O3");
	  int o4delivered = prob.getOrderEntryAtpPeriod("O4");
	  int o5delivered = prob.getOrderEntryAtpPeriod("O5");
	  
	  //now it seems that for the price of order O5 being delivered earlier
	  //none of O1, O2, O3 is being done...

	  assert(o1delivered == -1);
	  assert(o2delivered == -1);
	  assert(o3delivered == -1);
	  assert(o4delivered == 9);
	  assert(o5delivered == 10);
	  	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");
	  float c4Consumed = prob.getCampaignExcessCapacityConsumed("C4");
	  float c5Consumed = prob.getCampaignExcessCapacityConsumed("C5");
	  
	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,10.0f) );
	  assert( eq(c3Consumed,10.0f) );
	  assert( eq(c4Consumed,0.0f) );
	  assert( eq(c5Consumed,0.0f) );
  }


  //testing Campaign Types to Campaigns, when the campaigns are sorted w.r.t. start date
  {
	  FATPproblem prob;
	
	  	  prob.setNPeriods(30);
	  assert( prob.getNPeriods() == 30 );
	  
	  // define campaigns
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	  prob.addCampaign("C3");
	  prob.addCampaign("C4");
	  prob.addCampaign("C5");
	  prob.addCampaign("C6");

	  prob.setCampaignType("C1","CT1");
	  prob.setCampaignType("C2","CT1");
	  prob.setCampaignType("C3","CT2");
	  prob.setCampaignType("C4","CT2");
	  prob.setCampaignType("C5","CT3");
	  prob.setCampaignType("C6","CT4");

	  
	  prob.setCampaignStartPeriod("C1",3); 
	  prob.setCampaignStartPeriod("C2",7);
	  prob.setCampaignStartPeriod("C3",5);
	  prob.setCampaignStartPeriod("C4",9); 
	  prob.setCampaignStartPeriod("C5",11);
	  prob.setCampaignStartPeriod("C6",12);
	  
	  prob.setCampaignDuration("C1",1); 
	  prob.setCampaignDuration("C2",1);
	  prob.setCampaignDuration("C3",1);
	  prob.setCampaignDuration("C4",1); 
	  prob.setCampaignDuration("C5",1);
	  prob.setCampaignDuration("C6",1);
	  
	  prob.setCampaignExcessCapacity("C1",10.f); 
	  prob.setCampaignExcessCapacity("C2",10.f);
	  prob.setCampaignExcessCapacity("C3",10.f);
	  prob.setCampaignExcessCapacity("C4",10.f); 
	  prob.setCampaignExcessCapacity("C5",10.f);
	  prob.setCampaignExcessCapacity("C6",10.f);

	  assert(prob.campaignsFeasible("C1","C4"));

	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",0);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",3);

	  FATPvectorString recipe;
	  recipe.push_back("CT1");
	  recipe.push_back("CT2");
	  recipe.push_back("CT3");
	  recipe.push_back("CT4");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.25f);
  	  cr.push_back(0.5f);
  	  cr.push_back(0.5f);

	  prob.addOrderEntryRecipesByCampaignType("O1",recipe);
  }

// testing Campaign Types to Campaigns, the same as previous , only 
// when the campaigns are not sorted w.r.t. start date
  {
	  FATPproblem prob;
	
	  	  prob.setNPeriods(30);
	  assert( prob.getNPeriods() == 30 );
	  
	  // define campaigns

	  prob.addCampaign("EC2");
	  prob.addCampaign("DC3");
	  prob.addCampaign("CC4");
	  prob.addCampaign("AC6");
	  prob.addCampaign("FC1");
	  prob.addCampaign("BC5");

	  prob.setCampaignType("FC1","CT1");
	  prob.setCampaignType("EC2","CT1");
	  prob.setCampaignType("DC3","CT2");
	  prob.setCampaignType("CC4","CT2");
	  prob.setCampaignType("BC5","CT3");
	  prob.setCampaignType("AC6","CT4");

	  
	  prob.setCampaignStartPeriod("FC1",3); 
	  prob.setCampaignStartPeriod("EC2",7);
	  prob.setCampaignStartPeriod("DC3",5);
	  prob.setCampaignStartPeriod("CC4",9); 
	  prob.setCampaignStartPeriod("BC5",11);
	  prob.setCampaignStartPeriod("AC6",13);
	  
	  prob.setCampaignDuration("FC1",1); 
	  prob.setCampaignDuration("EC2",1);
	  prob.setCampaignDuration("DC3",1);
	  prob.setCampaignDuration("CC4",1); 
	  prob.setCampaignDuration("BC5",1);
	  prob.setCampaignDuration("AC6",1);
	  
	  prob.setCampaignExcessCapacity("FC1",10.f); 
	  prob.setCampaignExcessCapacity("EC2",10.f);
	  prob.setCampaignExcessCapacity("DC3",10.f);
	  prob.setCampaignExcessCapacity("CC4",10.f); 
	  prob.setCampaignExcessCapacity("BC5",10.f);
	  prob.setCampaignExcessCapacity("AC6",10.f);

	  assert(prob.campaignsFeasible("FC1","CC4"));

	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",0);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",3);

	  FATPvectorString recipe;
	  recipe.push_back("CT1");
	  recipe.push_back("CT2");
	  recipe.push_back("CT3");
	  recipe.push_back("CT4");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.25f);
  	  cr.push_back(0.5f);
  	  cr.push_back(0.5f);
	  
	  prob.addOrderEntryRecipesByCampaignType("O1",recipe);
  }
  // testing Campaign Types to Campaigns, now some fun with start periods and durations.
  {
	  FATPproblem prob;
	
	  	  prob.setNPeriods(30);
	  assert( prob.getNPeriods() == 30 );
	  
	  // define campaigns

	  prob.addCampaign("EC2");
	  prob.addCampaign("DC3");
	  prob.addCampaign("CC4");
	  prob.addCampaign("AC6");
	  prob.addCampaign("FC1");
	  prob.addCampaign("BC5");

	  prob.setCampaignType("FC1","CT1");
	  prob.setCampaignType("EC2","CT1");
	  prob.setCampaignType("DC3","CT1");
	  prob.setCampaignType("CC4","CT2");
	  prob.setCampaignType("BC5","CT2");
	  prob.setCampaignType("AC6","CT2");

	  
	  prob.setCampaignStartPeriod("FC1",3); 
	  prob.setCampaignStartPeriod("EC2",7);
	  prob.setCampaignStartPeriod("DC3",5);
	  prob.setCampaignStartPeriod("CC4",9); 
	  prob.setCampaignStartPeriod("BC5",11);
	  prob.setCampaignStartPeriod("AC6",13);
	  
	  prob.setCampaignDuration("FC1",7); 
	  prob.setCampaignDuration("EC2",5);
	  prob.setCampaignDuration("DC3",1);
	  prob.setCampaignDuration("CC4",1); 
	  prob.setCampaignDuration("BC5",1);
	  prob.setCampaignDuration("AC6",1);
	  
	  prob.setCampaignExcessCapacity("FC1",10.f); 
	  prob.setCampaignExcessCapacity("EC2",10.f);
	  prob.setCampaignExcessCapacity("DC3",10.f);
	  prob.setCampaignExcessCapacity("CC4",10.f); 
	  prob.setCampaignExcessCapacity("BC5",10.f);
	  prob.setCampaignExcessCapacity("AC6",10.f);

	  assert(!prob.campaignsFeasible("FC1","CC4"));
	  assert(prob.campaignsFeasible("FC1","BC5"));

	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",0);
	  prob.setOrderEntryCoilQty("O1",5.f);
	  prob.setOrderEntryImportance("O1",3);

	  FATPvectorString recipe;
	  recipe.push_back("CT1");
	  recipe.push_back("CT2");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.25f);
  	  cr.push_back(0.5f);
  	  cr.push_back(0.5f);
	  
	  prob.addOrderEntryRecipesByCampaignType("O1",recipe);

  }

// 2 competing orders, 2 computeATP calls.
  {
	  FATPproblem prob;
	
	  prob.addCampaign("C1");
	  prob.addCampaign("C2");
	
	  prob.setCampaignType("C1","CT1");
	  prob.setCampaignType("C2","CT2");
		  
	  prob.setCampaignStartPeriod("C1",3); 
	  prob.setCampaignStartPeriod("C2",7);
		  
	  prob.setCampaignDuration("C1",3); 
	  prob.setCampaignDuration("C2",3);
	 	  
	  prob.setCampaignExcessCapacity("C1",5.f); 
	  prob.setCampaignExcessCapacity("C2",5.f);
	  
	  prob.addOrderEntry("O1");
	  prob.setOrderEntryDesiredPeriod("O1",11);
	  prob.setOrderEntryCoilQty("O1",10.f);
	  prob.setOrderEntryImportance("O1",1);

	  prob.addOrderEntry("O2");
	  prob.setOrderEntryDesiredPeriod("O2",6);
	  prob.setOrderEntryCoilQty("O2",5.f);
	  prob.setOrderEntryImportance("O2",2);

	  //Used to test FSS (shortage shedule)
	  prob.addOrderEntry("O3");
	  prob.setOrderEntryDesiredPeriod("O3",22);
	  prob.setOrderEntryCoilQty("O3",17.f);
	  prob.setOrderEntryImportance("O3",12);

	  FATPvectorString recipe;
	  recipe.push_back("CT1");
	  recipe.push_back("CT2");
	  FATPvectorFloat cr;
	  cr.push_back(0.5f);
	  cr.push_back(0.25f);
  	 
	  prob.addOrderEntryRecipesByCampaignType("O1",recipe,cr);

	  prob.computeAtp();
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  
	  assert(o1delivered == 11);
	  	  	  
	  float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	 	  
	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,2.5f) );

	  recipe.clear();
	  recipe.push_back("C1");
	  recipe.push_back("C2");
	
	  prob.addOrderEntryRecipe("O2",recipe);
	  prob.addOrderEntryRecipe("O3",recipe,cr);


	  prob.computeAtp();
	  
	  o1delivered = prob.getOrderEntryAtpPeriod("O1");
	  int o2delivered = prob.getOrderEntryAtpPeriod("O2");

	  assert(o1delivered == 11);
	  assert(o2delivered == -1);
	  	  	  
	  c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
	  c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
	  
	  std::vector<std::string> camps;
	  std::vector<float>  usages;

	  prob.getOrderEntryUsedCampaigns ("O1",camps,usages);

	  assert(camps.size() == 2);
	  assert(camps[0] == "C1");
	  assert(camps[1] == "C2");
	  assert(eq(usages[0], 5.0f));	  
	  assert(eq(usages[1], 2.5f));

  	  prob.getOrderEntryUsedCampaigns ("O2",camps,usages);
	  assert(camps.size() == 0);
  	  
	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,2.5f) );

	  //testing Focus Shortage
	  std::vector<float> shortages;
	  assert(prob.getOrderEntryCampaignShortages ("O1",camps, shortages) == 0);
	  assert(camps.size() == 0);
	  assert(prob.getOrderEntryCampaignShortages ("O2",camps,shortages) == 1);
	  assert(prob.getOrderEntryCampaignShortages ("O3",camps,shortages) == 0);
	  assert(camps.size() == 2);
	  assert(camps[0] == "C1");
	  assert(camps[1] == "C2");
	  assert( eq(shortages[0],8.5f));
	  assert( eq(shortages[1],4.25f));
  }
}@


1.62
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d24 7
d587 1
a587 1
				std::cout << typeToCamps[i][vecOfPositions[i]] << " ";
d591 1
a591 1
			std::cout << std::endl;
d633 2
d865 6
a870 3
		std::cout << std::endl;
		std::cout << "Pegging for Order Entry " << orderId <<std::endl;
		std::cout << std::endl;
a889 2
					std::cout << "Campaign: " << locPartNameList[i] << "; ";
					std::cout << "at period: " << locPeriodList[i] << "; ";
d891 6
a896 1
					std::cout << "time consumed: " << locPeggedVolList[i] << "." << std::endl;
d1238 1
a2684 1
	  std::cout << "Campaigns sorted" << std::endl;
a2751 1
	  std::cout << "Campaigns unsorted" << std::endl;
a2815 1
	  std::cout << "Now durations are changing things a bit" << std::endl;
@


1.61
log
@D O N E!
Errors handled and tested.
Shortage Shedule debugged, fixed and tested.
I think this version of FLSATP can be considered ready.
@
text
@d758 3
a760 1
		return -1;
@


1.60
log
@Some more error handling, finished for Camapigns
Still some more work needed for Order Entries
@
text
@d411 1
a411 1
		sprintf(errorMessage,"Order Entry  %s does not exist",orderId.c_str());
d902 2
a903 1
		
d906 2
a910 1
		
d922 1
a922 1
		int np = getNPeriods();
d935 2
d943 1
a943 1
				shortage +=shortVols[c][startPeriod];
d951 2
d955 1
a955 1
		//If WIT tells us to get more of Campaignn at period later then Start period, 
d957 1
a957 1
		//If WIT says we need it earlier, we answer "no way".
d1398 50
a1447 5
	  //should cause error termination
	  //prob.setOrderEntryDesiredPeriod("NonexistentOrder",4);
	  //prob.getOrderEntryDesiredPeriod("NonexistentOrder");
	  //prob.setOrderEntryCoilQty("NonexistentOrder",4);
	  
d2834 6
d2866 2
d2899 9
a2907 2
	  prob.getOrderEntryCampaignShortages ("O1",camps, shortages);
	  prob.getOrderEntryCampaignShortages ("O2",camps,shortages);
@


1.59
log
@I have done some changes to
getOrderEntryCampaignShortages
method and I think now it might be doing what it is supposed to be doing.
But it is not tested at all (code runs, bnut that's it), I'll test it ASAP.
Exceptions still under construction - no changes in that since the last version.
@
text
@d45 1
d47 23
a69 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(witRun(),campaignName.c_str(),(void**)&appData);
	if (appData->getStartPeriod() + d > getNPeriods())
d71 2
a72 2
		std::cerr << "Campaign " << campaignName << " ends too late" <<std::endl;
		exit(1);
a73 2
	appData->setDuration(d);
	campsByTypes_.clear();
d77 1
d79 13
a91 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	return appData->getDuration();
d95 1
d102 1
a102 1
		if (startPeriod > getNPeriods())
d104 25
a128 2
			std::cerr << "Campaign " << campaignName << " starts too late" <<std::endl;
			exit(1);
d130 1
a130 7
		appData->setStartPeriod(startPeriod);
		
		//now we deal with the list of sorted campaigns - if the campaign is on the list, we remove it first.
		std::string tempName;
		std::set<FATPcampaignAppData *, sortCampaignsByStartPeriod>::iterator it;
		it=sortedCampaignNames_.begin();
		while(it!=sortedCampaignNames_.end())
d132 1
a132 7
			tempName = (*it)->getCampaignName();
			if (tempName == campaignName)
			{
				sortedCampaignNames_.erase(it);
				break;
			}
			it++;
a133 2
		sortedCampaignNames_.insert(appData);
		campsByTypes_.clear();
d135 1
a135 1
	catch(char *)
d137 2
d142 2
a143 1
int FATPproblem::getCampaignStartPeriod( const std::string & campaignName ) const throw(FATPException)
d161 1
d163 12
a174 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	appData->setExcessCapacity(excessCapacity);
d178 1
d180 13
a192 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	return appData->getExcessCapacity();
d196 1
d198 13
a210 5
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	appData->setCampaignType(type);
	campaignTypes_.insert(type);
d214 1
d216 13
a228 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	return appData->getCampaignType();
d293 2
a294 1
inline void FATPproblem::CheckIfCampExists(const std::string & campaignName) const throw(FATPException)
d338 1
d341 15
a355 7
	CheckIfOrderEntryExists(orderId);
	FATPorderEntryAppData * appData;
	witGetDemandAppData (mutableWitRun(), orderId.c_str(), orderId.c_str(),(void**) &appData);
	int * prioVec = intToIntStar(impt);
	witSetDemandPriority(witRun(),orderId.c_str(),orderId.c_str(),prioVec );
	delete [] prioVec;
	appData->setImportance(impt);
d359 1
d361 16
a376 7
	CheckIfOrderEntryExists(orderId);
	int * temp;
	int retVal;
	witGetDemandPriority(mutableWitRun(),orderId.c_str(),orderId.c_str(),&temp);
	retVal = temp[0];
	witFree(temp);
	return retVal;
d380 1
d382 13
a394 4
	CheckIfOrderEntryExists(orderId);
	int retVal;
	witGetPartNProducingBopEntries(mutableWitRun(),orderId.c_str(),&retVal);
	return retVal;
d406 1
d410 4
a413 2
		std::cerr << "Order Entry " << orderId << " does not exist" <<std::endl;
		exit(1);
d419 1
d421 57
a477 10
	CheckIfOrderEntryExists(orderId);
	// if recipe does not contain any campaign's then there is nothing to do
	int recipeSize = recipe.size();
	if ( recipeSize == 0 ) return;
	
	// Make sure orderId and campaign's exist
	assert( orderEntryExists(orderId) );
	int r;
	for ( r=0; r<recipe.size(); ++r ) {
		assert( campaignExists(recipe[r]) );
d479 4
a482 42
	
	// add recipe to appData
	FATPorderEntryAppData * appData;
	witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
	appData->addRecipe(recipe, consRates);
	int numRecipes = appData->getRecipes().size();
	
	// Create operation
	char witOpName[5000];
	sprintf(witOpName,"orderId: %s, recipe:%d",orderId.c_str(),numRecipes);
	witAddOperation(witRun(),witOpName);
	witAddBopEntry(witRun(),witOpName,orderId.c_str());
	

	float Aversion = 0;
	float np = float(getNPeriods());
	float weight = (1.0/np/np);
	// loop once for each campaign in recipe
	for ( r=0; r<recipeSize; ++r ) 
	{
		char witName[5000];
		sprintf(witName,"orderId: %s, recipe:%d, campaign:%d",orderId.c_str(),numRecipes,r);
		
		witAddPart(witRun(),witName,WitMATERIAL);
		witSetPartBuildNstn(witRun(),witName,WitTRUE);
		witAddBomEntry(witRun(),witOpName,witName);
		
		witAddOperation(witRun(),witName);
		witAddBopEntry(witRun(),witName,witName);
		
		// connect campaign to operation
		witAddBomEntry(witRun(),witName,recipe[r].c_str());
		
		// get campaign duration
		float duration = getCampaignDuration(recipe[r]);
		float endPeriod = duration + getCampaignStartPeriod(recipe[r]);
		Aversion += endPeriod*weight;
		
		// set BomEntry offset to duration
		witSetArcAttribute(witSetBomEntryOffset,witName,0,duration);
		witSetArcAttribute(witSetBomEntryConsRate,witName,0,consRates[r]);
		weight*=np;
a483 1
	witSetBopEntryExpAversion(witRun(),witOpName,0,Aversion);
d485 1
d488 1
d490 14
a503 5
	CheckIfOrderEntryExists(orderId);
	FATPvectorFloat cr;
	int c;
	for ( c=0; c<recipe.size(); ++c ) {
		cr.push_back(1.0f);
a504 1
	addOrderEntryRecipe(orderId,recipe,cr);
d595 1
d597 14
a610 5
	CheckIfOrderEntryExists(orderId);
	FATPvectorFloat cr;
	int c;
	for ( c=0; c<campaignTypes.size(); ++c ) {
		cr.push_back(1.0f);
a611 1
	addOrderEntryRecipesByCampaignType(orderId,campaignTypes,cr);
d619 1
d623 1
a623 3
	
	CheckIfOrderEntryExists(orderId);
	if (campsByTypes_.size()==0)
d625 45
a669 9
		// Get list of all campaigns
		std::vector<std::string> campaignNames,campTypes;
		getSortedCampaignNames(campaignNames);
		getCampaignTypes(campTypes);
		int numberOfTypes = campTypes.size();
		
		int c,s;
		for (s=0;s<numberOfTypes;s++)
		{ 
d671 7
a677 7
			for (c=0; c<campaignNames.size(); ++c ) 
			{
				// get c'th campaigns type
				if (campTypes[s] == getCampaignType(campaignNames[c]))
					// add c'th campaign to map of types to campaigns.
					campsByTypes_[campTypes[s]].push_back(campaignNames[c]);
			}
d679 10
a688 37
	};
	int recipeLength = campaignTypes.size();
	//	FATPvectorString::constant_iterator typIt=campaignTypes.begin();
	//the variable enumerating recursively called functions
	int cloneMarker =0;
	//initialize vector of positons with zeroes
	std::vector<int> vecOfPositions,vecOfLoBounds;
	int t;
	for(t=0;t<recipeLength;t++)
	{
		vecOfPositions.push_back(0);
        vecOfLoBounds.push_back(0);
	}
	// if no campaignTypes were specified, then just return
	if ( campaignTypes.begin() == campaignTypes.end() ) return;
	
	// Create map from campaignType to vector of campaigns
	// This typeToCamps could be kept in this classes private member data so
	// it does not have to be created each time this method is called.
	std::vector<FATPvectorString> typeToCamps;
	
	int s;
	for (s=0;s<recipeLength;s++)
	{			
		// Loop once for each campaign to create vector of campaigns of type campType
		std::vector<std::string> vectorOfCampaigns;
		std::string temp = campaignTypes[s];
		int u = getCampaignsOfType(campaignTypes[s]).size();
		
		//if there are no campaigns of a certain type available, we cannot compose a recipe
		if(getCampaignsOfType(campaignTypes[s]).size()==0) return;
		typeToCamps.push_back(getCampaignsOfType(campaignTypes[s]));
	}
	
	// Build recipe from campaign types
	recursiveAddCampaignNamesToRecipe(orderId,recipeLength,cloneMarker,
		vecOfPositions,vecOfLoBounds,typeToCamps,consRates);
d692 1
d694 2
d703 7
d713 1
d715 19
a733 8
	CheckIfOrderEntryExists(orderId);
	float * shipVol;
	witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
	int np = getNPeriods();
	float retVal=0;
	int t;
	for ( t=0; t<np; t++ ) {
		retVal = retVal + shipVol[t];
a734 2
	witFree(shipVol);
	return retVal;
d738 1
d740 19
a758 8
	CheckIfOrderEntryExists(orderId);
	float * shipVol;
	witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
	int np = getNPeriods();
	std::vector<float> retVal;
	int i;
	for (i=0; i<np; i++) {
		retVal.push_back(shipVol[i]);
a759 2
	witFree(shipVol);
    return retVal;
d763 1
d765 13
a777 2
	CheckIfOrderEntryExists(orderId);
	if (desiredPeriod > getNPeriods())
d779 2
a780 2
		std::cerr << "OrderEntry " << orderId << " scheduled too late" <<std::endl;
		exit(1);
a781 3
	FATPorderEntryAppData * appData;
	witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
	appData->setDesiredPeriod(desiredPeriod);
d783 2
d786 1
d788 12
a799 4
	CheckIfOrderEntryExists(orderId);
	FATPorderEntryAppData * appData;
	witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
	return appData->getDesiredPeriod();
d803 1
d805 12
a816 4
	CheckIfOrderEntryExists(orderId);
	FATPorderEntryAppData * appData;
	witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
	appData->setCoilQty(coilQty);
d818 1
d820 1
d822 12
a833 4
	CheckIfOrderEntryExists(orderId);
	FATPorderEntryAppData * appData;
	witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
	return appData->getCoilQty();
d849 1
d851 17
a867 19
	CheckIfOrderEntryExists(orderId);
	std::cout << std::endl;
	std::cout << "Pegging for Order Entry " << orderId <<std::endl;
	std::cout << std::endl;
	campaignNamesList.clear();
	capacitiesConsumed.clear();
	int per,i;
	int	NPeriods = getNPeriods();
	int Period = getOrderEntryDesiredPeriod(orderId );
	int locLenLists;
	char **           locPartNameList;
	int *             locPeriodList;
	float *           locPeggedVolList;
	
	for (per = Period; per<NPeriods; per++)
	{
		witGetDemandConsVolPip (mutableWitRun(),orderId.c_str(),orderId.c_str(),
			per, &locLenLists, &locPartNameList,&locPeriodList,&locPeggedVolList);
		for (i = locLenLists-1; 0<i ; i--)
d869 3
a871 1
			if (campaignExists(locPartNameList[i]))
d873 8
a880 5
				campaignNamesList.push_back(locPartNameList[i]);
				std::cout << "Campaign: " << locPartNameList[i] << "; ";
				std::cout << "at period: " << locPeriodList[i] << "; ";
				capacitiesConsumed.push_back(locPeggedVolList[i]);
				std::cout << "time consumed: " << locPeggedVolList[i] << "." << std::endl;
d882 2
d885 5
a889 2
		witFree(locPartNameList);
		witFree(locPeggedVolList);
d893 67
a959 58

// modern version by J P

 char FATPproblem::getOrderEntryCampaignShortages(
     const std::string & orderId,
     std::vector<std::string> & shortCampaigns,
     std::vector<float> & capacityShortages )const
 {
   // set FSS Ship Vol
   float * shipVol;
   witGetDemandDemandVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
   witSetDemandFssShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),shipVol);  
   witFree(shipVol);
 
   shortCampaigns.clear();
   capacityShortages.clear();
   
   // Get shortages
   int nShortCampaigns;
   char **shortCamps;
   float **shortVols;
   witGetFocusShortageVol(mutableWitRun(),&nShortCampaigns,&shortCamps,&shortVols);
 
   // loop once for each campaign with a shortage
   int c,m;
   int np = getNPeriods();
   for ( c=0; c<nShortCampaigns; ++c ) {
     shortCampaigns.push_back(shortCamps[c]);
     
     int startPeriod = getCampaignStartPeriod(shortCamps[c]);
	 for (m=0;m<startPeriod;m++)
	 {
		 if (shortVols[c][m] != 0)
		 {
			 shortCampaigns.clear();
             capacityShortages.clear();
			 witFree(shortCamps[c]);
             witFree(shortVols[c]);
			 return 1;
		 }
	 }
     float shortage = 0;
	 for (m=startPeriod; m < np; m++)
	 {
		 shortage +=shortVols[c][startPeriod];
	 }
     capacityShortages.push_back(shortage);
	      //std::vector<float> shortVol = witFloatStarToStlVec(shortVols[c]);
     //shortageQuantity.push_back(shortVol);
     witFree(shortCamps[c]);
     witFree(shortVols[c]);
   }
   return 0;
   //GMS - I am messing with the answers:
   //If WIT tells us to get more of Campaignn at period later then Start period, we move it back
   //If WIT says we need it earlier, we answer "no way".
 }
// end of modern version
a1211 2


d1258 17
a1274 2
	  //should cause error termination
	  //prob.setCampaignStartPeriod("Nonexistent",4);
d1277 1
a1277 1
		prob.getCampaignStartPeriod("Nonexistent");
d1281 1
a1281 1
		  assert(error.getErrorMessage() == "Campaign Nonexistent does not exist");
d1283 25
a1307 4
	  //prob.getCampaignDuration("Nonexistent");
	  //prob.setCampaignDuration("Nonexistent",4);
	  //prob.setCampaignStartPeriod("C1",31);
	  //prob.setCampaignDuration("C1",4000);
@


1.58
log
@Some advances in Exception Handling, but still unfinished, only one method
(getCampaignStartPeriod) uses FATPException class.
More modifications to come soon. :-)
@
text
@d332 4
a335 1
	
d337 2
a338 2
	for ( r=0; r<recipeSize; ++r ) {
		
d354 2
d360 1
a360 1
		
d362 1
a362 1
	
a380 1

a381 1
						 
a475 1

a504 2
	
	
a568 1

d670 1
a670 1
 void FATPproblem::getOrderEntryCampaignShortages(
d691 2
a692 1
   int c;
d697 16
a712 1
     float shortage = shortVols[c][startPeriod];
d714 1
a714 1
     //std::vector<float> shortVol = witFloatStarToStlVec(shortVols[c]);
d719 4
a723 1

a725 61
//old stuff by GMS, to be deleted soon

void FATPproblem::getOrderEntryShortage (const std::string & orderId,
											  std::vector<std::string> & campaignsNamesList,
											  std::vector<FATPvectorFloat>  & shortageVolList)
{
	CheckIfOrderEntryExists(orderId);
	std::cout << std::endl;
	std::cout << "Getting Shortage for Order Entry " << orderId <<std::endl;
	std::cout << std::endl;

	campaignsNamesList.clear();
	shortageVolList.clear();
	int per,i,NOrders;
	int	NPeriods = getNPeriods();
	int Period = getOrderEntryDesiredPeriod(orderId );
	int locLenLists;
	char **           locPartNameList;
	float **          locShortageVolList;
	FATPvectorFloat   tempShortages;

	witSetUseFocusHorizons(witRun(), true);

	//reset Focus Horizons
	std::vector<std::string> orderEntryIds;
	getOrderEntryIds(orderEntryIds);
	NOrders = orderEntryIds.size();

	for (i=0; i< NOrders; i++)
	{
		witSetDemandFocusHorizon (witRun(), orderEntryIds[i].c_str(),
			orderEntryIds[i].c_str(), -1);
	}
	//set the Focus Horizon for our OrderEntry
	witSetDemandFocusHorizon (witRun(), orderId.c_str(),orderId.c_str(), Period);
		
	witGetFocusShortageVol (mutableWitRun(),
		&locLenLists, &locPartNameList,&locShortageVolList);
	for (i = 0; i<locLenLists ; i++)
	{
		if (campaignExists(locPartNameList[i]))
		{
			campaignsNamesList.push_back(locPartNameList[i]);
			std::cout << "Campaign: " << locPartNameList[i] << "; ";
			std::cout << "at periods: ";
			tempShortages.clear();
			for (per = 0; per<NPeriods; per++)
			{	
				std::cout<< locShortageVolList[i][per] << ", ";
				tempShortages.push_back(locShortageVolList[i][per]);
			}
			shortageVolList.push_back(tempShortages);
			std::cout << "missing." << std::endl;
		}
	}
	witFree(locPartNameList);
	witFree(locShortageVolList);
}
 // end of stuff to be deleted


d2570 4
a2573 12

	  std::vector<FATPvectorFloat> shortages;
	  prob.getOrderEntryShortage ("O1",camps,shortages);
//	  prob.getOrderEntryCampaignShortages ("O1",camps,shortages);
	  prob.getOrderEntryShortage ("O2",camps,shortages);
//	  prob.getOrderEntryCampaignShortages ("O2",camps,shortages);
  }
//  catch (FATPException error)
  //{
//	  error.displayMessage();
  //}

@


1.57
log
@FATPException class added and tested. Still needs a second look at.
Not yet being used by other parts of code.
Application still fully functional.
More modifications and comments will be added soon.
@
text
@d102 1
a102 1
int FATPproblem::getCampaignStartPeriod( const std::string & campaignName ) const
d111 1
a111 1
	catch(char *)
d113 2
d214 1
a214 1
inline void FATPproblem::CheckIfCampExists(const std::string & campaignName) const throw(char *)
d220 2
a221 2
		std::cerr << errorMessage <<std::endl;
		throw(campaignName.c_str());
d1070 8
d2619 5
a2624 3

 
  }
@


1.56
log
@J P's method added to the code.
Variable names changed.
Minor changes.
No comments yet
@
text
@d20 1
d68 1
a68 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	if (startPeriod > getNPeriods())
d70 26
a95 2
		std::cerr << "Campaign " << campaignName << " starts too late" <<std::endl;
		exit(1);
d97 1
a97 7
	appData->setStartPeriod(startPeriod);
	
	//now we deal with the list of sorted campaigns - if the campaign is on the list, we remove it first.
	std::string tempName;
	std::set<FATPcampaignAppData *, sortCampaignsByStartPeriod>::iterator it;
	it=sortedCampaignNames_.begin();
	while(it!=sortedCampaignNames_.end())
a98 7
		tempName = (*it)->getCampaignName();
		if (tempName == campaignName)
		{
			sortedCampaignNames_.erase(it);
			break;
		}
		it++;
a99 2
	sortedCampaignNames_.insert(appData);
    campsByTypes_.clear();
d104 11
a114 4
	CheckIfCampExists(campaignName);
	FATPcampaignAppData * appData;
	witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
	return appData->getStartPeriod();
d212 1
a212 1
inline void FATPproblem::CheckIfCampExists(const std::string & campaignName) const
d216 4
a219 2
		std::cerr << "Campaign " << campaignName << " does not exist" <<std::endl;
		exit(1);
d629 2
a630 2
											  std::vector<std::string> & campaignsNamesList,
											  std::vector<float>  & peggedVolList)const
d636 2
a637 2
	campaignsNamesList.clear();
	peggedVolList.clear();
d654 1
a654 1
				campaignsNamesList.push_back(locPartNameList[i]);
d657 1
a657 1
				peggedVolList.push_back(locPeggedVolList[i]);
@


1.55
log
@Now the negative priorities are being handled in the right way.
Some cleaning-up of the code.
Comments fixed, minor changes.
@
text
@d612 1
a612 1
int FATPproblem::getOrderEntryUsedCampaigns (const std::string & orderId,
d614 1
a614 1
											  std::vector<float>  & peggedVolList)
d625 1
a625 1
	int locLenLists, numberOfItems = 0;
a642 1
				numberOfItems++;
a647 1
	return(numberOfItems);
d651 42
a692 1
int FATPproblem::getOrderEntryShortage (const std::string & orderId,
d706 1
a706 1
	int locLenLists, numberOfItems = 0;
a742 1
			numberOfItems++;
a746 2
	
	return(numberOfItems);
d748 2
a1913 1
	  int a;
d1917 1
a1917 1
	  a = prob.getOrderEntryUsedCampaigns ("O1",camps,usages);
d1919 1
a1919 1
	  assert(a == 5);
a2568 1
	  int a;
d2572 1
a2572 1
	  a = prob.getOrderEntryUsedCampaigns ("O1",camps,usages);
d2574 1
a2574 1
	  assert(a == 2);
d2580 2
a2581 2
  	  a = prob.getOrderEntryUsedCampaigns ("O2",camps,usages);
	  assert(a == 0);
d2589 4
a2592 2
	  a = prob.getOrderEntryShortage ("O1",camps,shortages);
	  a = prob.getOrderEntryShortage ("O2",camps,shortages);
@


1.54
log
@getOrderEntryShortage method has been added.
It is NOTgiving the correct answer, some adjustments in the WIT
model must be done.
It is not properly tested yet.
@
text
@a21 3
//Some more error handling should be added, I think.
//E.g. when we try to set period out of range etc.

d241 1
a712 6



//--------------------------


d730 3
a732 4
    int c;
    for( c=0; c<campaignNames.size(); ++c ) {

		int t;
d753 5
a757 5
    int c;
    for( c=0; c<orderEntryIds.size(); ++c ) {

		int t;
		for (t=0; t<np; t++ ) 
d759 1
a759 1

a761 1

a762 1

a783 1
	std::string temp;
a785 1
		temp = orderEntryIds[i];
a788 1
		temp = (appData)->getOrderEntryId();
a796 1
		temp = (*it)->getOrderEntryId();
a800 2
	
	
a806 1
	
a831 1
	
d834 1
a834 15

#if 0
	
WIT_DECLSPEC witReturnCode STDCALL witGetDemandConsVolPip (
   WitRun * const     theWitRun,
   const char * const partName,
   const char * const demandName,
   const int          shipPeriod,
   int *              lenLists,
   char ***           partNameList,
   int **             periodList,
   float **           peggedVolList);
	
#endif

a952 2


d956 2
d961 5
d2517 1
@


1.53
log
@Pegging improved and tested (asserts added).
@
text
@d655 63
d2576 8
@


1.52
log
@Pegging up and running!
Some more tests probably should be done in a nearby future
to check if it really works fine, but it seems to.
The "campaignExists" method has been fixed - when it was given a name of
a part of an order it was saying YES! :-)
@
text
@d615 1
a615 2
											  std::vector<std::string> & partNameList,
											  std::vector<int> & periodList,
a616 1
											  
d619 4
a622 2
	partNameList.clear();
	periodList.clear();
d624 2
d632 1
a632 4
	witGetDemandConsVolPip (mutableWitRun(),orderId.c_str(),orderId.c_str(),
		Period, &locLenLists, &locPartNameList,&locPeriodList,&locPeggedVolList);
	int i = locLenLists;
	for (i = 0; i < locLenLists; i++)
d634 3
a636 1
		if (campaignExists(locPartNameList[i]))
d638 9
a646 7
			partNameList.push_back(locPartNameList[i]);
			std::cout << locPartNameList[i] << " ";
			periodList.push_back(locPeriodList[i]);
			std::cout << locPeriodList[i] << " ";
			peggedVolList.push_back(locPeggedVolList[i]);
			std::cout << locPeggedVolList[i] << std::endl;
			numberOfItems++;
d648 2
a649 2
		
		
a650 3
	witFree(locPartNameList);
	witFree(locPeriodList);
	witFree(locPeggedVolList);
d1838 21
a1858 1
  }
d2427 1
d2497 2
a2498 3
	  std::vector<std::string> b;
	  std::vector<int>    c;
	  std::vector<float>  d;
d2500 1
a2500 1
	  a = prob.getOrderEntryUsedCampaigns ("O1",b,c,d);
d2503 4
a2506 6
	  assert(b[1] == "C1");
	  assert(b[0] == "C2");
	  assert(c[1] == 3);
	  assert(c[0] == 7);
	  assert(eq(d[1], 5.0f));	  
	  assert(eq(d[0], 2.5f));
d2508 3
a2510 1
	 	  
@


1.51
log
@Finishing touches.
Some error handling.
Some comments fixed.
Ready for April 6 presentation!
@
text
@d184 1
d187 10
a196 2
  witBoolean exists;
  witGetPartExists(mutableWitRun(), campaignName.c_str(), &exists);
d613 42
d724 1
a724 1

d745 1
a745 1

d752 3
a754 4
// now orderEntryIds is a sorted vector of orderId-s

	//witHeurImplode(witRun());

d759 3
a761 1

d763 1
a763 1

d785 4
a789 1
		rc = witFinishHeurAlloc(witRun());
d792 10
a801 7
	WIT_DECLSPEC witReturnCode STDCALL witIncHeurAlloc (
		WitRun * const theWitRun,
		const char * const demandedPartName,
		const char * const demandName,
		const int shipPeriod,
		const float desIncVol,
		float * incVol);
d804 1
a804 1
	
d2474 16
@


1.50
log
@Now the higher priority orders are being done first.
Test cases have been adjusted to the change in the algorithm.
Now some orders are not being stisfied at all, because the higher priority
orders are forced to be done as close to the desired period as possible.
@
text
@d22 3
d48 10
a57 5
  if (!campaignExists(campaignName)) return;
  FATPcampaignAppData * appData;
  witGetPartAppData(witRun(),campaignName.c_str(),(void**)&appData);
  appData->setDuration(d);
  campsByTypes_.clear();
d62 4
a65 3
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  return appData->getDuration();
d70 1
a70 1
	if (!campaignExists(campaignName)) return;
d73 5
d100 4
a103 3
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  return appData->getStartPeriod();
d105 1
d108 4
a111 3
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  appData->setExcessCapacity(excessCapacity);
d113 1
d116 4
a119 3
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  return appData->getExcessCapacity();
d124 5
a128 4
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  appData->setCampaignType(type);
  campaignTypes_.insert(type);
d130 1
d133 4
a136 3
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  return appData->getCampaignType();
d192 9
a221 5

// Some private fields (e.g. recipes) are not being assigned, the things are only
// being passed to WIT, caused nasty bugs already
// must be handled I think - GMS

d224 7
a230 7
  witAddPart(witRun(),orderId.c_str(),WitMATERIAL);
  witAddDemand(witRun(),orderId.c_str(),orderId.c_str() );
  
  FATPorderEntryAppData * appData = new FATPorderEntryAppData();
  witSetDemandAppData (witRun(), orderId.c_str(), orderId.c_str(), appData);
  appData->setOrderEntryId(orderId);
  orderEntryIds_.insert(orderId);
d235 1
d246 1
d257 4
a260 3
  int retVal;
  witGetPartNProducingBopEntries(mutableWitRun(),orderId.c_str(),&retVal);
  return retVal;
d265 4
a268 4
  witBoolean exists;
  witGetPartExists(mutableWitRun(), orderName.c_str(), &exists);
  if ( exists ) return true;
  else return false;
d271 8
d281 1
a281 1
	  const FATPvectorFloat & consRates )
d283 50
a332 49
  // if recipe does not contain any campaign's then there is nothing to do
  int recipeSize = recipe.size();
  if ( recipeSize == 0 ) return;

  // Make sure orderId and campaign's exist
  assert( orderEntryExists(orderId) );
  int r;
  for ( r=0; r<recipe.size(); ++r ) {
    assert( campaignExists(recipe[r]) );
  }
  
  // add recipe to appData
  FATPorderEntryAppData * appData;
  witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
  appData->addRecipe(recipe, consRates);
  int numRecipes = appData->getRecipes().size();

  // Create operation
  char witOpName[5000];
  sprintf(witOpName,"orderId: %s, recipe:%d",orderId.c_str(),numRecipes);
  witAddOperation(witRun(),witOpName);
  witAddBopEntry(witRun(),witOpName,orderId.c_str());


  // loop once for each campaign in recipe
  for ( r=0; r<recipeSize; ++r ) {

	  char witName[5000];
      sprintf(witName,"orderId: %s, recipe:%d, campaign:%d",orderId.c_str(),numRecipes,r);

	  witAddPart(witRun(),witName,WitMATERIAL);
    witSetPartBuildNstn(witRun(),witName,WitTRUE);
	  witAddBomEntry(witRun(),witOpName,witName);

	  witAddOperation(witRun(),witName);
	  witAddBopEntry(witRun(),witName,witName);

	  // connect campaign to operation
      witAddBomEntry(witRun(),witName,recipe[r].c_str());

      // get campaign duration
      float duration = getCampaignDuration(recipe[r]);

      // set BomEntry offset to duration
      witSetArcAttribute(witSetBomEntryOffset,witName,0,duration);
      witSetArcAttribute(witSetBomEntryConsRate,witName,0,consRates[r]);

  }

d337 1
d437 1
d456 1
d520 1
d531 1
d547 1
a559 4

//------------------------
//Some code by Grzegorz
//------------------------
d562 9
a570 3
  FATPorderEntryAppData * appData;
  witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
  appData->setDesiredPeriod(desiredPeriod);
d574 4
a577 3
  FATPorderEntryAppData * appData;
  witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
  return appData->getDesiredPeriod();
d582 4
a585 3
  FATPorderEntryAppData * appData;
  witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
  appData->setCoilQty(coilQty);
d589 4
a592 3
  FATPorderEntryAppData * appData;
  witGetDemandAppData(mutableWitRun(),orderId.c_str(),orderId.c_str(),(void**)&appData);
  return appData->getCoilQty();
d597 6
a602 6
  orderEntryIds.clear();

  std::set<std::string>::const_iterator it;
  for ( it=orderEntryIds_.begin(); it!=orderEntryIds_.end(); ++it ) {
    orderEntryIds.push_back( *it );
  }
d919 9
a927 1
	  prob.setCampaignStartPeriod("Nonexistent",4);
d1008 5
d1036 4
@


1.49
log
@A failed attempt to use witIncHeurAlloc.
I have produced something that I expected to work, but it does not.
The code still runs, but fails on the assertions.
@
text
@d191 5
d209 2
d214 1
d656 3
a658 2
	float incVol;
	int smiec;
d667 16
a682 11
		temp = orderEntryIds[i].c_str();
		smiec = (appData)->getDesiredPeriod();
		smiec = (appData)->getCoilQty();

		rc = witIncHeurAlloc (
			mutableWitRun(),
			orderEntryIds[i].c_str(),
			orderEntryIds[i].c_str(),
			(appData)->getDesiredPeriod(),
			(appData)->getCoilQty(),
			& incVol);
d2063 5
a2067 2
	  assert(o1delivered == 9);
	  assert(o2delivered == 9);
d2070 1
a2070 1
	  assert(o5delivered == 13);
d2078 2
a2079 2
	  assert( eq(c1Consumed,10.0f) );
	  assert( eq(c2Consumed,8.75f) );
d2081 2
a2082 2
	  assert( eq(c4Consumed,5.0f) );
	  assert( eq(c5Consumed,5.0f) );
d2307 1
a2307 1
	  prob.setOrderEntryImportance("O1",2);
d2312 1
a2312 1
	  prob.setOrderEntryImportance("O2",1);
d2345 2
a2346 4
	  //the WRONG result is being asserted, because now 2 is done, because
	  //it is ordered earlier, though O1 has higher priority.
	  assert(o1delivered == -1);
	  assert(o2delivered == 6);
d2352 1
a2352 1
	  assert( eq(c2Consumed,0.f) );
@


1.48
log
@Mulitiple StartPeriod changes handled.
Removed unnecessary bool campsByTypesBuilt variable.
Many changes in comments.
Some couts changed into asserts, but some still have to be changed.
Some test cases added
@
text
@d198 1
a198 1

d609 2
d614 71
a684 2
  witWriteData(witRun(),"fatp.wit");
	witHeurImplode(witRun());
d687 2
d2266 73
@


1.47
log
@I forgot to include campsByTypes_ in the assignment operator
Now I think all is fine.
@
text
@d29 4
d45 1
d49 1
d51 1
a58 1

d61 21
a81 4
  FATPcampaignAppData * appData;
  witGetPartAppData(mutableWitRun(),campaignName.c_str(),(void**)&appData);
  appData->setStartPeriod(startPeriod);
  sortedCampaignNames_.insert(appData);
d131 1
a131 1
  std::set<FATPcampaignAppData *, ltstr>::const_iterator it;
a293 1
    //std::cout <<c <<" " <<recipe[c] <<std::endl;
a295 1
  //std::cout <<std::endl;
a305 6
// I think the data should be organized into a struct type variable

// The algorithm STRONGLY depends on the fact that the vectors
// assigned by the map typeToCamps are ORDERED with respect to campaign
// start period .
// I think that IF the set campaignNames_ is built in an ordered way, all works fine.
d344 1
a344 2
		//----------------------------------------------------
		vecOfPositions[functionCloneId]= vecOfLoBounds[functionCloneId];
d398 2
a399 6
//This part needs a lot of attention!
//The lists of campaigns are NOT being built in an ordered way
//Till now by pure accident it works, but in a future it can cause a REALLY NASTY BUG

//The campaign consumption rates are not yet taken into account.

d406 1
a406 1
	// Initializing the field "campsByTypes_"
d408 1
a408 1
	if (campsByTypesNotbuilt_)
a409 1
		campsByTypesNotbuilt_ = false;
d627 1
a627 2
campsByTypes_(),
campsByTypesNotbuilt_(true)
d645 1
a645 3
orderEntryIds_(),
campsByTypes_(),
campsByTypesNotbuilt_(true)
d669 1
a669 2
  campsByTypes_ = source.campsByTypes_;
  campsByTypesNotbuilt_ = source.campsByTypesNotbuilt_;
d782 2
a814 1
	  int i = cNames.size();
d831 30
a897 1
	  
d1044 3
a1046 3
	  //this is NOT feasible set of campaigns!
	  //It should produce nothing!

d1050 3
d1083 11
a1093 10
	 float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	 std::vector<float> atpQtyV = prob.getOrderEntryCoilAtpVector("O1");

	 // sum atpQtyV
	 float sumAtpQtyV = 0.f;
	 int t;
	 for ( t=0; t<atpQtyV.size(); ++t ) {
		 sumAtpQtyV += atpQtyV[t];
	 }
	 assert( eq(sumAtpQtyV,atpQty) );
a1094 1

d1220 1
a1220 1
    
d1222 2
a1223 2

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
d1229 3
a1231 3
    assert( o1delivered==-1 );

    assert( eq(atpQty,0.f) );
d1326 2
a1327 2

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
d1333 2
a1334 2
    assert( o1delivered==13 );
    assert( eq(atpQty,5.f) );
d1382 1
a1382 1

d1384 2
a1385 2

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
d1390 2
a1391 2
    assert( o1delivered==7 );
    assert( eq(atpQty,5.f) );
d1426 1
a1426 1
    assert( prob.getOrderEntryNRecipes("O1")==1 );
d1431 1
a1431 1
    assert( prob.getOrderEntryNRecipes("O1")==2 );
a1551 1
		int i=campaignNames.size();
d1553 3
a1555 6
		for (i=0;i<campaignNames.size();i++)
		{
			std::cout << campaignNames[i];
		}
		std::cout <<std::endl;
	  
d1611 1
a1611 1

d1613 3
a1615 3

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
    std::vector<float> atpQtyVec = prob.getOrderEntryCoilAtpVector("O1");
d1623 4
a1626 4
    assert( o1delivered==8 );
    assert( eq(atpQty,10.f) );
    assert( eq(atpQtyVec[7],0.f) );
    assert( eq(atpQtyVec[8],10.f) );
d1976 6
a1981 7
	  std::cout << "Order1 delivered: " << o1delivered <<std::endl;
	  std::cout << "Order2 delivered: " << o2delivered <<std::endl;
	  std::cout << "Order3 delivered: " << o3delivered <<std::endl;
	  std::cout << "Order4 delivered: " << o4delivered <<std::endl;
	  std::cout << "Order5 delivered: " << o5delivered <<std::endl;
	  
	  
d1991 2
@


1.46
log
@Algorithms are now efficient, so this is more or less a final version for the time
being - I can't think of anything else before we meet with Jayant.
Test cases has been added, all seems to be fine.
(unless I overlooked something)
A very ugly bool indicator has been added to the private part of the
FATPproblem class - is there a way of avoiding it?
@
text
@d663 1
@


1.45
log
@Now the list is sorted! :-))))))))
All seems to work fine, although still a lot has to be done, constructors etc.
Also the algorithm for translating types to camps is now far from
being optimal, most of the changes were supposed
to make the sorted map ONCE, but now it ias being made every time, just to make things run.
I think I know how to fix it.
@
text
@d316 15
a330 1
		vecOfPositions[functionCloneId]= 0;// vecOfLoBounds[functionCloneId];
d342 1
a342 1
	vecOfLoBounds[functionCloneId] = vecOfPositions[functionCloneId];
d395 27
a421 26
  // creating a list of campaigns sorted by type
  // Initializing the field "campsByTypes_"

//	if (!(campsByTypes_))
  {
	  // Get list of all campaigns
	  std::vector<std::string> campaignNames,campaignTypes;
	  getSortedCampaignNames(campaignNames);
	  getCampaignTypes(campaignTypes);
	  int numberOfTypes = campaignTypes.size();
  
	  int c,s;
	  for (s=0;s<numberOfTypes;s++)
	  { 
		  // Loop once for each campaign to create vector of campaigns of type campType
		  for (c=0; c<campaignNames.size(); ++c ) 
		  {
			  // get c'th campaigns type
			  if (campaignTypes[s] == getCampaignType(campaignNames[c]))
				  // add c'th campaign to map of types to campaigns.
				  campsByTypes_[campaignTypes[s]].push_back(campaignNames[c]);
		  }
	  }
  };


a453 29

	
#if 0
	{
		// Get list of all campaigns
			std::vector<std::string> campaignNames;
		getSortedCampaignNames(campaignNames);
	
		std::string campType;

		int c,s;
		for (s=0;s<recipeLength;s++)
		{
			campType = campaignTypes[s];
      
		  // Loop once for each campaign to create vector of campaigns of type campType
      std::vector<std::string> vectorOfCampaigns;
			for (c=0; c<campaignNames.size(); ++c ) {
				// get c'th campaigns type
				if (campType == getCampaignType(campaignNames[c]))
				// add c'th campaign to map of types to campaigns.
        vectorOfCampaigns.push_back(campaignNames[c]);
			}
	  	//if there are no campaigns of a certain type available, we cannot compose a recipe
	  	if(vectorOfCampaigns.size()==0) return;
			typeToCamps.push_back(vectorOfCampaigns);
		}
	}
#endif
a459 3



d618 2
a619 1
campsByTypes_()
d638 2
a639 1
campsByTypes_()
d663 1
d2091 65
@


1.44
log
@The method addOrderEntryRecipesByCampaignType
now has three parameters, the last one is a list of consumption rates
(which depend only on camapign type, so it is okay I think).
There is also a 2 parameter version, that sets cr=1 by default.
I have added a test case and it works fine.
LIne 944 - added a comment, I think we get a wrong answer, campaigns
are NOT feasible, so nothing should be produced. On the other hand, this
cannot happen when we specify campaign TYPES, so maybe
it is okay when we can "override" the campaign start period violation rule
by giving names explicitly?
@
text
@d35 1
a35 1

d58 1
d60 1
d104 10
d124 6
d316 1
a316 1
		vecOfPositions[functionCloneId]=vecOfLoBounds[functionCloneId];
d381 25
d408 1
a408 1
//	FATPvectorString::constant_iterator typIt=campaignTypes.begin();
d426 16
d444 3
a446 2
		std::vector<std::string> campaignNames;
		getCampaignNames(campaignNames);
d467 1
d593 1
d632 1
d634 2
a635 1
orderEntryIds_()
d651 1
d653 2
a654 1
orderEntryIds_()
d675 1
d803 1
d819 7
d885 1
d904 2
d1121 4
a1124 4
	  prob.addOrderEntryRecipesByCampaignType("O1",recipe,cr);
	  
	  prob.computeAtp();
	  
d1524 10
d1577 1
a1577 1
    assert( prob.getOrderEntryNRecipes("O1")==27 );
d2107 1
a2107 56
}


// A pattern for using std::set class, to be deleted ASAP


#if 0
>>>>>>> 1.39
struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

int main()
{
  const int N = 6;
  const char* a[N] = {"isomer", "ephemeral", "prosaic", 
                      "nugatory", "artichoke", "serif"};
  const char* b[N] = {"flat", "this", "artichoke",
                      "frigate", "prosaic", "isomer"};

  set<const char*, ltstr> A(a, a + N);
  set<const char*, ltstr> B(b, b + N);
  set<const char*, ltstr> C;

  cout << "Set A: ";
  copy(A.begin(), A.end(), ostream_iterator<const char*>(cout, " "));
  cout << endl;
  cout << "Set B: ";
  copy(B.begin(), B.end(), ostream_iterator<const char*>(cout, " "));   
  cout << endl;

  cout << "Union: ";
  set_union(A.begin(), A.end(), B.begin(), B.end(),
            ostream_iterator<const char*>(cout, " "),
            ltstr());   
  cout << endl;

  cout << "Intersection: ";
  set_intersection(A.begin(), A.end(), B.begin(), B.end(),
                   ostream_iterator<const char*>(cout, " "),
                   ltstr());    
  cout << endl;

  set_difference(A.begin(), A.end(), B.begin(), B.end(),
                 inserter(C, C.begin()),
                 ltstr());
  cout << "Set C (difference of A and B): ";
  copy(C.begin(), C.end(), ostream_iterator<const char*>(cout, " "));
  cout << endl;
}

#endif
@


1.43
log
@Some minor changes:
added campaignTypes_ to the constructor, assignment operator etc.
Added a test case to check assignment operator
@
text
@a21 10
// to be deleted, probably, my humble attempt to be fancy :-)
struct dataForTypeToCamp
{
	std::string & orderId;
	int recipeLength;
	int cloneMarker;
	std::vector<int> vecOfPositions;
	std::vector<int> vecOfLoBounds;
	std::map<int,FATPvectorString> typeToCamps;
};
d279 2
a280 1
													const std::vector<FATPvectorString> &typeToCamps)
d321 1
a321 1
				vecOfPositions,vecOfLoBounds,typeToCamps);
d331 1
a331 1
			addOrderEntryRecipe(orderId,tempRecipe);
d340 11
d360 2
a361 1
													 const FATPvectorString & campaignTypes)
d410 1
a410 1
		vecOfPositions,vecOfLoBounds,typeToCamps);
d944 3
d1001 76
@


1.42
log
@no message
@
text
@d567 1
d584 1
d606 1
d679 1
d748 2
d754 5
@


1.41
log
@I finally managed to add the test case which makes things go wrong.
For the unsorted case the algorithm adds a recipe consisting of unfeasible
sequence of campaigns, while for the sorted case
(only the names of campaigns changed)
this sequence is not being built (see printout)
@
text
@d289 1
a289 1
													std::map<int,FATPvectorString> &typeToCamps)
d298 1
a298 1
	FATPvectorString * avCampaigns = & typeToCamps[functionCloneId];
d300 1
a300 1
	int numberOfCamps=(*avCampaigns).size();
d309 1
a309 1
			(*avCampaigns)[vecOfPositions[functionCloneId]]))
a358 2


d379 1
a379 1
	std::map<int,FATPvectorString> typeToCamps;
a385 2
		// Loop once for each campaign

d390 3
d397 1
a397 1
				typeToCamps[s].push_back(campaignNames[c]);
d399 3
a401 2
		//if there are no campaigns of a certain type available, we cannot compose a recipe
		if(typeToCamps[s].size()==0) return;
a409 143
// original by J.P.

#if 0
void buildRecipe(
=======


//----------------------------------
// private method which is recursive to create vector of recipes from vector of campaign types
//----------------------------------
void FATPproblem::buildRecipe(
>>>>>>> 1.39
            const FATPvectorString & campaignTypes, 
            const std::map<std::string,FATPvectorString> & typeToCamps,
            FATPvectorStringConstIterator ctIt, 
            FATPvectorStringConstIterator cIt, 
            const std::string & orderId,
            FATPvectorString recipe)
{
<<<<<<< fatpProblem.cpp
=======
  // if no more capaign types then done adding campaigns to recipes
  if ( ctIt == campaignTypes.end() ) {
    // completed list of campaigns of type, so now add recipe
    addOrderEntryRecipe(orderId,recipe);
    return;
  }
>>>>>>> 1.39

<<<<<<< fatpProblem.cpp
	
	
	// if no more capaign types then done
	if ( ctIt == campaignTypes.end() ) {
		return;
	}
	else {
		FATPvectorStringConstIterator campaigns = typeToCamps.find(*ctIt);
		// if no more campaigns then recipe has been constructed
		if ( cIt == campaigns.end() ) {
			
		}
	}
}
#endif

#if 0
=======
  // if no more campaigns of type *ctIt then just return
  if ( cIt == ((typeToCamps.find(*ctIt))->second).end() ) 
    return;

  // Increment pointer to next campaign of type *ctIt and recursively call
  {
    FATPvectorStringConstIterator cItX = cIt;
    cItX++;
    buildRecipe(campaignTypes, typeToCamps, ctIt, cItX, orderId, recipe);
  }

  // get name of campaign to add to recipe
  std::string campaign = *cIt;

  // check to see if adding this campaign is time feasible
  if ( recipe.size()!=0 ) {
    const std::string & recipeTailCampaign = recipe[recipe.size()-1];
    if ( !pairOfCampaignsIsFeasible(recipeTailCampaign,campaign) )
      // not feasible, so don't add it to recipes
      return;
  }

  // add campaign to recipe
  recipe.push_back(campaign);

  // Increment pointer to next campaignType and set pointer to campaigns of that type to the begining.
  {
    FATPvectorStringConstIterator ctItX = ctIt;
    ctItX++;
    FATPvectorStringConstIterator cItX = cIt;
    if ( ctItX != campaignTypes.end() ) cItX = ((typeToCamps.find(*ctItX))->second).begin();
    buildRecipe(campaignTypes, typeToCamps, ctItX, cItX, orderId, recipe);
  }

}
  
>>>>>>> 1.39
void FATPproblem::addOrderEntryRecipesByCampaignType(
													 const std::string & orderId, 
													 const FATPvectorString & campaignTypes)
													 
{

		struct ltstr
	{
		bool operator()(const std::string & campaignName1, const std::string & campaignName2) const
		{
			return compareCampaigns(campaignName1, campaignName2) < 0;
		}
	};

  // if no campaignTypes were specified, then just return
  if ( campaignTypes.begin() == campaignTypes.end() ) return;

  // Create map from campaignType to vector of campaigns
  // This typeToCamps could be kept in this classes private member data so
  // it does not have to be created each time this method is called.
  std::map<std::string,FATPvectorString> typeToCamps;
  {
    // Get list of all campaigns
    std::vector<std::string> campaignNames;
    getCampaignNames(campaignNames);

    // Loop once for each campaign
    int c;
    for (c=0; c<campaignNames.size(); ++c ) {
      // get c'th campaigns type
      std::string campType = getCampaignType(campaignNames[c]);
      // add c'th campaign to map of types to campaigns.
      typeToCamps[campType].push_back(campaignNames[c]);
    }
  }

  // Build recipe from campaign types
  FATPvectorString recipe;
  FATPvectorStringConstIterator ctIt=campaignTypes.begin();
<<<<<<< fatpProblem.cpp
  const FATPvectorString & campaigns = typeToCamps[*ctIt];
  FATPvectorStringConstIterator cIt = campaigns.begin();
  buildRecipe(campaignTypes, typeToCamps, ctIt, cIt, recipe);

=======
  const FATPvectorString & campaignsOfType = typeToCamps[*ctIt];
  FATPvectorStringConstIterator cIt = campaignsOfType.begin();

  buildRecipe(campaignTypes, typeToCamps, ctIt, cIt, orderId, recipe);
>>>>>>> 1.39

}

<<<<<<< fatpProblem.cpp
=======


>>>>>>> 1.39
a410 1
#endif
@


1.40
log
@Implemented the methods for converting campaign types
into campaigns, some testing, changes in comments etc.
Fixed the bug detected by J.P.'s test case.
@
text
@d1936 2
a1937 1
//testing Campaign Types to Campaigns :-D
d1953 1
a1953 1
	  prob.setCampaignType("C2","CT2");
d1955 1
a1955 1
	  prob.setCampaignType("C4","CT3");
d1961 2
a1962 2
	  prob.setCampaignStartPeriod("C2",5);
	  prob.setCampaignStartPeriod("C3",7);
d1998 70
@


1.39
log
@Added testcase to ensure that time infeasible recipes are not being generated from sequence of campaign types.
@
text
@d22 10
d93 1
a101 2


d112 10
d139 9
a147 1
bool FATPproblem::pairOfCampaignsIsFeasible(const std::string & firstCampaignName,
d150 3
a152 3
	int firstCampaignEndPeriod    = getCampaignStartPeriod(firstCampaignName)+ getCampaignDuration(firstCampaignName);
	int secondCampaignStartPeriod = getCampaignStartPeriod(secondCampaignName);
	return(firstCampaignEndPeriod <= secondCampaignStartPeriod) ;
d257 2
a258 1
void FATPproblem::addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe )
d271 144
d421 1
d429 2
d437 18
d456 2
d494 1
d496 3
a498 2
    const std::string & orderId, 
    const FATPvectorString & campaignTypes)
d501 8
d521 1
a521 1
    // Loop once fore each campaign
d534 6
d544 6
d552 1
a552 1
}
d554 1
a583 1
#if 0
a593 3
#endif   
  std::vector<float> retVal = witGetDemandAttribute(witGetDemandShipVol,orderId,orderId);
  return retVal;
a596 2


d841 5
d870 1
a870 1
	  
d877 14
d1935 64
d2001 4
d2006 1
@


1.38
log
@added method getOrderEntryNRecipes.
Used method to better test addOrderEntryRecipesByCampaignType.
@
text
@d1341 108
@


1.37
log
@implemented addOrderEntryRecipesByCampaignType
@
text
@d161 7
d235 1
a235 1
    std::cout <<c <<" " <<recipe[c] <<std::endl;
d238 1
a238 1
  std::cout <<std::endl;
d1143 1
d1148 1
d1216 1
d1309 1
d1380 1
d1439 1
@


1.36
log
@Added the method
checkIfPairOfCampaignsIsFeasible
to the class FATPproblem
untested yet.
Some comments etc.
@
text
@d120 1
a120 1
bool FATPproblem::checkIfPairOfCampaignsIsFeasible(const std::string & firstCampaignName,
d123 3
a125 3
	int first = getCampaignStartPeriod(firstCampaignName)+ getCampaignDuration(firstCampaignName);
	int second = getCampaignStartPeriod(secondCampaignName);
	return(first < second) ;
a128 2


d228 1
d231 1
d236 6
a241 2
#if 0
void buildRecipe(
d246 1
d249 1
a249 1
  // if no more capaign types then done
d251 2
a254 4
  else {
     FATPvectorStringConstIterator campaigns = typeToCamps.find(*ctIt);
     // if no more campaigns then recipe has been constructed
     if ( cIt == campaigns.end() ) {
d256 20
a275 1
     }
d277 13
d313 1
a313 1
      std::string campType = "X"; //getCampaignType(campaignNames[c]);
d322 4
a325 3
  const FATPvectorString & campaigns = typeToCamps[*ctIt];
  FATPvectorStringConstIterator cIt = campaigns.begin();
  buildRecipe(campaignTypes, typeToCamps, ctIt, cIt, recipe);
a329 1
#endif
d359 1
d370 3
a372 11
}
#if 0
void FATPproblem::getOrderEntryCoilAtpVector(const std::string & orderId,tabFloat& atpQtyVector)const
{
	float * shipVol;
	witGetDemandShipVol(mutableWitRun(),orderId.c_str(),orderId.c_str(),&shipVol);
	int np = getNPeriods();
	atpQtyVector = new float[np];
	int i;
	for (i=0; i<np; i++) *(atpQtyVector+i) = shipVol[i];
	witFree(shipVol);
a374 1
# endif
d1159 289
d1585 1
a1585 1
#if0
@


1.35
log
@added some commented out code
@
text
@d120 9
d1268 50
@


1.34
log
@Added methods for campaignType to FATP class.
@
text
@d226 62
@


1.33
log
@Fixed assert
@
text
@d78 13
d542 6
@


1.32
log
@Some more testing, seems to work fine with fractional consumptions for campains.
@
text
@d1113 1
a1113 1
	  cr.push_back(0.3f);
d1123 3
a1125 3
	  cr.push_back(0.3f);
	  cr.push_back(0.3f);
	  cr.push_back(0.3f);
d1174 1
a1174 1
	  assert( eq(c2Consumed,10.0f) );
@


1.31
log
@Added consumpution rate to orderEntry appData.
Not yet setting consumption rate on bom arc
@
text
@d198 1
d705 67
d1048 1
a1048 1

d1064 1
a1064 1
  
d1076 1
a1076 1
  
d1087 1
a1087 1
	  prob.setOrderEntryCoilQty("O2",5.f);
d1096 1
a1096 1
	  prob.setOrderEntryDesiredPeriod("O4",1);
d1102 1
a1102 1
	  prob.setOrderEntryCoilQty("O5",9.f);
d1111 7
a1117 2
	  prob.addOrderEntryRecipe("O1",recipe);

d1119 1
d1123 5
a1127 2
	  prob.addOrderEntryRecipe("O2",recipe);
	  
d1139 2
a1140 2


d1145 1
a1145 1

d1150 1
a1150 1

d1159 7
a1165 7

    std::cout << "Order1 delivered: " << o1delivered <<std::endl;
    std::cout << "Order2 delivered: " << o2delivered <<std::endl;
    std::cout << "Order3 delivered: " << o3delivered <<std::endl;
    std::cout << "Order4 delivered: " << o4delivered <<std::endl;
    std::cout << "Order5 delivered: " << o5delivered <<std::endl;

@


1.30
log
@fixed type of variable. was int and should have been float
@
text
@d150 2
a151 1
void FATPproblem::addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe )
d167 1
a167 1
  appData->addRecipe(recipe);
d202 9
a210 1

@


1.29
log
@fixed capitalization of file name
@
text
@d94 1
a94 1
   int retVal = consVol[getCampaignStartPeriod(campaignName)];
@


1.28
log
@changed cout to use std::
@
text
@d20 1
a20 1
#include "FATPproblem.h"
@


1.27
log
@The method returning the vector of Atp values for OrderEntry has been added.
@
text
@a15 2
#include <iostream.h>

d1074 5
a1078 5
	  cout << "Order1 delivered: " << o1delivered <<endl;
	  cout << "Order2 delivered: " << o2delivered <<endl;
      cout << "Order3 delivered: " << o3delivered <<endl;
      cout << "Order4 delivered: " << o4delivered <<endl;
	  cout << "Order5 delivered: " << o5delivered <<endl;
@


1.26
log
@Here is a version that works, but I want to do it in another way, so I commit
it just in case I mess things up.
@
text
@d229 15
d255 2
d676 10
a685 3
	  float atpQty = prob.getOrderEntryCoilAtpQty("O1");
	  float * atpQtyVector;
	  prob.getOrderEntryCoilAtpVector("O1",atpQtyVector);
d687 1
@


1.25
log
@Some more testing, updated comments, nothing much, actually. :-)
@
text
@d24 1
d220 5
a224 5
  float retVal=0;
  int t;
  for ( t=0; t<np; t++ ) {
    retVal = retVal + shipVol[t];
  }
d229 11
a340 1

a348 2


d660 2
@


1.24
log
@Now order 4 competes with orders 1,2,3. It has higher priority, but later desired period. (1 instead of 0).
It is NOT being done, instead 1 and 2 are being done.
Besides this all seems to work fine, I have tried a lot of cionfigurations, and they all worked as I expecetd them to.
@
text
@d307 1
a307 1
  //Initializing OrderEntries (by GMS) - UNTESTED
d621 3
a623 3
	  prob.setCampaignDuration("C1",0); 
	  prob.setCampaignDuration("C2",0);
	  prob.setCampaignDuration("C3",0);
d647 1
a647 1
    
d649 2
a650 2

    float atpQty = prob.getOrderEntryCoilAtpQty("O1");
d656 3
a658 3
    assert( o1delivered==7 );

    assert( eq(atpQty,5.f) );
@


1.23
log
@The test procedure by Grzegorz now works fine
@
text
@d948 5
a952 5
	  prob.setCampaignStartPeriod("C1",7); 
	  prob.setCampaignStartPeriod("C2",9);
	  prob.setCampaignStartPeriod("C3",11);
	  prob.setCampaignStartPeriod("C4",13); 
	  prob.setCampaignStartPeriod("C5",15);
d972 1
a972 1
	  prob.setOrderEntryImportance("O1",1);
d977 1
a977 1
	  prob.setOrderEntryImportance("O2",2);
d982 1
a982 1
	  prob.setOrderEntryImportance("O3",3);
d985 1
a985 1
	  prob.setOrderEntryDesiredPeriod("O4",0);
d987 1
a987 1
	  prob.setOrderEntryImportance("O4",4);
d990 1
a990 1
	  prob.setOrderEntryDesiredPeriod("O5",0);
d992 1
a992 3
	  prob.setOrderEntryImportance("O5",10);
	  
	  
d994 1
a1020 2

	  // Without this it runs as expected....
a1024 2
	  // -------------------------------------

a1034 2
	  cout << "Order1 delivered: " << o1delivered <<endl ;

d1038 3
d1042 2
a1043 2

	  int o5delivered = prob.getOrderEntryAtpPeriod("O5");
@


1.22
log
@added method
  float getOrderEntryCoilAtpQty(const std::string & orderId )const;
test method updated to use this new method
@
text
@d931 1
a931 1
#if 0
d1040 1
a1040 1
	  cout << "Order1 delivered: " << o1delivered <<endl << "koniec linii";
d1045 1
a1045 1
	  cout << "Order2 delivered: " << o2delivered;
d1048 1
a1048 2
	  cout << "Order5 delivered: " << o5delivered;

d1057 3
a1059 3
	  assert( eq(c1Consumed,5.0f) );
	  assert( eq(c2Consumed,5.0f) );
	  assert( eq(c2Consumed,5.0f) );
a1060 2
#endif

@


1.21
log
@fixed model to set PartBuildNstn to true
@
text
@d214 14
d608 1
d647 4
d656 102
d759 7
d767 2
d808 2
d815 2
a816 1
      assert( o1delivered==13 );
d866 2
d872 2
a873 1
      assert( o1delivered==7 );
d920 2
d927 2
a928 1
      assert( o1delivered==7 );
@


1.20
log
@new model that is not yet working, so both JP and Grzes
@
text
@d184 1
d739 1
a739 1
#if 0
d791 1
a791 1
#endif
@


1.19
log
@added a few more tests.
some are ifdef'ed out because they don't yet run.
turned off wit informational messages
@
text
@d31 2
a32 2
  witAddOperation(wr,campaignName.c_str());
  witAddBomEntry(wr, campaignName.c_str(), campaignName.c_str() );
d170 5
a174 2
  // add wit constructs for recipe
  for ( r=0; r<recipeSize-1; ++r ) {
a175 3
    // create name of intermediate wit part
    char witPartName[5000];
    sprintf(witPartName,"%s:%d:%d",orderId.c_str(),numRecipes,r+1);
d177 2
a178 2
    // create intermediate part
    witAddPart(witRun(),witPartName,WitMATERIAL);
d180 2
a181 2
    // connect witPart to producing operation
    witAddBopEntry(witRun(),recipe[r].c_str(),witPartName);
d183 2
a184 3
    // get index of bom to be added
    int bomIndex;
    witGetOperationNBomEntries(mutableWitRun(),recipe[r+1].c_str(),&bomIndex);
d186 2
a187 2
    // connect witPart to consuming operation
    witAddBomEntry(witRun(),recipe[r+1].c_str(),witPartName);
d189 2
a190 2
    // get campaign duration
    float duration = getCampaignDuration(recipe[r+1]);
d192 5
a196 2
    // set BomEntry offset to duration
    witSetArcAttribute(witSetBomEntryOffset,recipe[r+1],bomIndex,duration);
a199 2
  // connect last campaign to orderEntry
  witAddBopEntry(witRun(),recipe[recipeSize-1].c_str(),orderId.c_str());
a286 4

    
    // set BomEntry offset to duration
    witSetArcAttribute(witSetBomEntryOffset,campaignNames[c],0,duration);
d640 1
a640 1
  // test adding recipe where campaigns have a 2 period duration
a676 1
    assert( o1delivered==13 );
d682 1
@


1.18
log
@Some testing procedure added, but unfinished, 9 campaigns, 5 orders, but just copy and paste, I must work on it a bit more
@
text
@d449 2
a450 2
	  prob.setNPeriods(12);
	  assert( prob.getNPeriods() == 12 );
d689 49
d739 2
d742 43
d786 10
a795 1
  
d797 2
d801 3
a810 4
	  prob.addCampaign("C6");
	  prob.addCampaign("C7");
	  prob.addCampaign("C8");
	  prob.addCampaign("C9");
d815 3
a817 8
	  prob.setCampaignStartPeriod("C4",7); 
	  prob.setCampaignStartPeriod("C5",9);
	  prob.setCampaignStartPeriod("C6",11);
	  prob.setCampaignStartPeriod("C7",7); 
	  prob.setCampaignStartPeriod("C8",9);
	  prob.setCampaignStartPeriod("C9",11);
	  
	  
a822 4
	  prob.setCampaignDuration("C6",2);
	  prob.setCampaignDuration("C7",2); 
	  prob.setCampaignDuration("C8",2);
	  prob.setCampaignDuration("C9",2);
d829 1
a829 8
	  prob.setCampaignExcessCapacity("C6",10.f);
	  prob.setCampaignExcessCapacity("C7",10.f); 
	  prob.setCampaignExcessCapacity("C8",10.f);
	  prob.setCampaignExcessCapacity("C9",10.f);
	  
	  
	  
	  
d836 1
a836 1
	  prob.setOrderEntryImportance("O1",2);
d846 1
a846 1
	  prob.setOrderEntryImportance("O3",2);
d851 1
a851 1
	  prob.setOrderEntryImportance("O4",2);
d855 2
a856 2
	  prob.setOrderEntryCoilQty("O5",5.f);
	  prob.setOrderEntryImportance("O5",2);
d874 3
a876 3
	  recipe.push_back("C4");
	  recipe.push_back("C5");
	  recipe.push_back("C6");
d880 3
a882 3
	  recipe.push_back("C4");
	  recipe.push_back("C5");
	  recipe.push_back("C6");
d885 3
d889 9
a897 3
	  recipe.push_back("C7");
	  recipe.push_back("C8");
	  recipe.push_back("C9");
d904 1
a904 1
	  cout << "Order1 delivered: " << o1delivered;
d907 2
d910 5
d919 2
d926 1
a926 1

@


1.17
log
@setting offsets on bomEntry's to consider campaign duration
@
text
@d692 129
@


1.16
log
@modifed setting of capacity supplyVol to be a single period (the startPeriod).
@
text
@d194 1
a194 1
    //witSetArcAttribute(witSetBomEntryOffset,recipe[r+1],bomIndex,-duration);
d281 1
a281 1
		int duration = getCampaignDuration(campaignNames[c]);
d287 5
a643 1
#if 0
d680 3
a689 3
	  
	  int o1delivered = prob.getOrderEntryAtpPeriod("O1");
    assert( o1delivered==13 );
a690 1
#endif
@


1.15
log
@Changed "float" to "int", and fixed a bug caused by my previous "bugfix" :-)
@
text
@d183 4
d190 6
d284 1
a284 4
		for (t=startPeriod; t<startPeriod+duration; t++ ) {
			assert(t<np);
			supplyVol[t]=excessCapacity;
		}
d556 1
a556 1
	  assert(supplyVol[4]==5.0f);
d604 3
a606 3
	  prob.setCampaignDuration("C1",1); 
	  prob.setCampaignDuration("C2",1);
	  prob.setCampaignDuration("C3",1);
d614 1
a614 1
	  prob.setOrderEntryDesiredPeriod("O1",2);
d636 2
a637 2
      //float o2delivered = prob.getOrderEntryAtpPeriod("O2");
      //float o3delivered = prob.getOrderEntryAtpPeriod("O3");
d639 47
a685 1
	  cout << "o1delivered = " << o1delivered;
d687 1
a687 1

@


1.14
log
@Fixed a silly "fencepost" bug.
@
text
@d198 1
a198 1
	while(!shipVol[retPeriod])retPeriod--;
d628 1
a628 1
	  float o1delivered = prob.getOrderEntryAtpPeriod("O1");
@


1.13
log
@Added the getOrderEntryAtpPeriod method and tested it and I think it works fine.
@
text
@d198 1
a198 2
	do retPeriod--;
	while(!shipVol[retPeriod]);
@


1.12
log
@fixed up constructors
@
text
@d16 2
d190 1
d193 9
d205 1
d587 45
a631 41
    FATPproblem prob;

    // define campaigns
    prob.addCampaign("C1");
    prob.addCampaign("C2");
    prob.addCampaign("C3");

    prob.setCampaignStartPeriod("C1",5); 
    prob.setCampaignStartPeriod("C2",5);
    prob.setCampaignStartPeriod("C3",5);

    prob.setCampaignDuration("C1",1); 
    prob.setCampaignDuration("C2",1);
    prob.setCampaignDuration("C3",1);

    prob.setCampaignExcessCapacity("C1",10.f); 
    prob.setCampaignExcessCapacity("C2",10.f);
    prob.setCampaignExcessCapacity("C3",10.f);

    // define order entries
    prob.addOrderEntry("O1");
    prob.setOrderEntryDesiredPeriod("O1",5);
    prob.setOrderEntryCoilQty("O1",5.f);
    prob.setOrderEntryImportance("O1",2);

    // define campaigns required for producing order entry
    FATPvectorString recipe;
    recipe.push_back("C1");
    recipe.push_back("C2");
    recipe.push_back("C3");
    prob.addOrderEntryRecipe("O1",recipe);

    prob.computeAtp();

    float c1Consumed = prob.getCampaignExcessCapacityConsumed("C1");
    float c2Consumed = prob.getCampaignExcessCapacityConsumed("C2");
    float c3Consumed = prob.getCampaignExcessCapacityConsumed("C3");

    assert( eq(c1Consumed,5.0f) );
    assert( eq(c2Consumed,5.0f) );
    assert( eq(c2Consumed,5.0f) );
d633 1
@


1.11
log
@Removed dead code that was ifdef'ed out
@
text
@d173 1
a173 1
    sprintf(witPartName,"%s:%d:%d",orderId.c_str(),numRecipes,r);
d311 2
a312 1
campaignNames_()
d327 2
a328 1
campaignNames_()
d349 1
d364 14
d395 12
d555 3
d562 1
d567 1
@


1.10
log
@added method addOrderEntryRecipe
@
text
@a301 869
#if 0
//----------------------
// Methods for engagements.
//----------------------
void FATPproblem::addEngagement(const std::string & engName)
{
  std::string theEngagement = engagementName(engName);
  witAddPart(witRun(),theEngagement.c_str(),WitCAPACITY);
  witAddDemand(witRun(),theEngagement.c_str(),theEngagement.c_str());
  witAddOperation(witRun(),theEngagement.c_str());
  witAddBopEntry(witRun(),theEngagement.c_str(),theEngagement.c_str());

  float * vecOne = floatToFloatStar(1.0);
  witSetOperationIncLotSize(witRun(),theEngagement.c_str(),vecOne);
  delete [] vecOne;
  
  RCPengagementAppData * appData = new RCPengagementAppData;
  witSetPartAppData(witRun(),theEngagement.c_str(),appData);

  engagementNames_.insert(theEngagement);
  //  engagementLocationNames_.insert(engagementLocationName);
}

bool FATPproblem::engagementExists    (const std::string & engName)const
{
  return witPartExists(engagementName(engName).c_str());
}

void FATPproblem::setEngagementRevenue(const std::string & engName, 
                                      float revenue)
{
  RCPengagementAppData * appData;
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
  appData->setRevenue(revenue);
}
void FATPproblem::setEngagementLocation(const std::string & engName, 
                                      const std::string & location)
{
  RCPengagementAppData * appData;
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
  appData->setLocation(location);
}
void FATPproblem::setEngagementStartPeriod(const std::string & engName, 
                                      int startPeriod)
{
  assert(startPeriod<getNPeriods());
  std::string theEngagement = engagementName(engName);
  // Save start period in appData
  RCPengagementAppData * appData;
  witGetPartAppData(witRun(),theEngagement.c_str(),(void**)&appData);
  appData->setRequestedStartPeriod(startPeriod);
   
  // Set wit's demandVol from startPeriod
  float * demandVol = floatToFloatStar(0.0f);
  demandVol[startPeriod]=1.0f;
  witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol);
  delete [] demandVol;
}
void FATPproblem::setEngagementDuration(const std::string & engName, 
                                      int duration)
{
  RCPengagementAppData * appData;
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
  appData->setDuration(duration);
}
void FATPproblem::setEngagementLateAllowance(const std::string & engName, 
                                      int lateAllowance)
{
  RCPengagementAppData * appData;
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
  appData->setLateAllowance(lateAllowance);
}


float FATPproblem::getEngagementRevenue(const std::string & engName)const
{
  RCPengagementAppData * appData;
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
  return appData->getRevenue();
}
std::string FATPproblem::getEngagementLocation(const std::string & engName)const
{
  RCPengagementAppData * appData;
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
  return appData->getLocation();
}
int FATPproblem::getEngagementRequestedStartPeriod(const std::string & engName)const
{
  RCPengagementAppData * appData;
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
  return appData->getRequestedStartPeriod();
}
int FATPproblem::getEngagementStartPeriod(const std::string & engName)const
{
  bool executed = getEngagementExecuted(engName);
  int duration = getEngagementDuration(engName);
  int retVal = -1;
  if (!executed) return retVal;
  else {
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,engagementName(engName));
    for ( int t=0; t<execVol.size(); ++t ) {
      if( execVol[t]>0.0 ) {
	retVal=t;
	break;
      }
	}
    return retVal;
 }
}

int FATPproblem::getEngagementDuration(const std::string & engName)const
{
  RCPengagementAppData * appData;
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
  return appData->getDuration();
}

int FATPproblem::getEngagementLateAllowance(const std::string & engName)const
{
  RCPengagementAppData * appData;
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
  return appData->getLateAllowance();
}


void FATPproblem::getEngagementNames( std::vector<std::string> & engagementNames ) const
{
  engagementNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=engagementNames_.begin(); it!=engagementNames_.end(); ++it ) {
    engagementNames.push_back( engagementFromEngagementName(*it) );
  }
}

bool FATPproblem::getEngagementExecuted(const std::string & engName)const
{
  bool retVal=false;
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,
						   engagementName(engName));
  for ( int t=0; t<execVol.size(); ++t ) {
    if( execVol[t]>0.0 ) {
      retVal=true;
      break;
    }
  }
  return retVal;
}


//----------------------
// Methods for resources.
//----------------------
void FATPproblem::addResource(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source,  const std::string & locName)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);

  // Add parts and operations
  witAddOperation(witRun(),acquireOp.c_str());
  witAddPart(witRun(),benchRes.c_str(),WitMATERIAL);
  witAddOperation(witRun(),enableOp.c_str());
  witAddPart(witRun(),workingRes.c_str(),WitCAPACITY);

  // connect parts and operations.
  witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str());
  // dpc --- test for MRP
  witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE);

  witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str());
  witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str());

  int np = getNPeriods();
  if (np>1){
    witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str());

    float * offsetVec = floatToFloatStar(-1.f);
    witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec);
    delete [] offsetVec;
    witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE);
    witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2);
  }

  // Add appData for benchRes
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);

  
  RCPresourceAppData * appData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),workingRes.c_str(),appData);

  std::string baseName = baseResourceName(jobRole,skillSet,LOB,source,locName);
  resourceNames_.insert(baseName);
  jobToResourceNames_[jobRole].insert(baseName);
  skillToResourceNames_[skillSet].insert(baseName);
  lobToResourceNames_[LOB].insert(baseName);
  sourceToResourceNames_[source].insert(baseName);
  locToResourceNames_[locName].insert(baseName);
}

bool FATPproblem::resourceExists(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName)const
{
  std::string witName = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witPartExists(witName);
}


void FATPproblem::getResourceNames( 
           std::vector<std::string> & jobRoles, std::vector<std::string> & skillSets, 
	   std::vector<std::string> & LOBs, std::vector<std::string> & sources,
           std::vector<std::string> & locNames ) const
{
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  locNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=resourceNames_.begin(); it!=resourceNames_.end(); ++it ) {
    jobRoles.push_back( jobRoleFromResourceName(*it) );
    skillSets.push_back( skillSetFromResourceName(*it) );
    LOBs.push_back( LOBFromResourceName(*it) );
    sources.push_back( sourceFromResourceName(*it) );
    locNames.push_back( locationFromResourceName(*it) );
  }
}

void FATPproblem::setExogenousResourceSupplyQuantity(
                                           const std::string & jobRole,
					   const std::string & skillSet,
					   const std::string & LOB,
					   const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float supplyQuantity)
{
  //  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  //  witSetNameAttribute(
  //    witGetPartSupplyVol,witSetPartSupplyVol,
  //    exogRes,
  //    period, supplyQuantity );

    std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData);
    appData->setExogenousSupply(period, supplyQuantity);
}

void FATPproblem::setBenchResourceSupplyQuantity(
                                           const std::string & jobRole,
					   const std::string & skillSet,
					   const std::string & LOB,
					   const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float supplyQuantity)
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    benchRes,
    period, supplyQuantity );
}

std::vector<float> FATPproblem::setBenchResourceSupplyQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartSupplyVol,benchRes);
}

std::vector<float> FATPproblem::getExogenousResourceSupplyQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  //  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  //  return witGetNameAttribute(witGetPartSupplyVol,exogRes);
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getExogenousSupply());

}

std::vector<float> FATPproblem::getResourceWorkingQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName )const
{
  std::string opName = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}
std::vector<float> FATPproblem::getResourceBenchQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  std::vector<float> stockVol = witGetNameAttribute(witGetPartStockVol,benchRes);
  return stockVol;
}

std::vector<float> FATPproblem::getResourceReleaseQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string partName = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartScrapVol,partName);
}

std::vector<float> FATPproblem::getResourceAcquireQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string acquireRes = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationExecVol,acquireRes);
}
void FATPproblem::setResourceAcquireCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet, 
                                        const std::string & LOB, 
                                        const std::string & source, 
                                        const std::string & locName,
                                        float acquireCost)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * acv = floatToFloatStar(acquireCost);
  witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv);
  delete [] acv;
}

void FATPproblem::setResourceAcquireTime(
                                        const std::string & jobRole,
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName,
                                        float acquireTime)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float invacquireTime = -acquireTime; //offset should be negative so that
                                       //the resource is available after it's acquired
  float * atv = floatToFloatStar(invacquireTime);
  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv);
  delete [] atv;
}

void FATPproblem::setResourceReleaseTime(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName,
                                        float releaseTime)
{
   //remember to negate this
	
	//std::string acquireOp = acquireResourceOperationName(jobRole);  Still need to model this
  //  float * rtv = floatToFloatStar(releaseTime);
  //  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,rtv);   Still need to model this
  //delete [] rtv;
}

void FATPproblem::setResourceReleaseCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName,
                                        float releaseCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,locName); 
  float * rcv = floatToFloatStar(releaseCost);
  witSetPartObj1ScrapCost(witRun(),benchOp.c_str(),rcv);
  delete [] rcv;
}




std::vector<float> FATPproblem::getResourceFixedCost(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationObj1ExecCost,benchRes);
  

}



void FATPproblem::setResourceFixedCost(
                                      const std::string & jobRole,
                                      const std::string & skillSet,
                                      const std::string & LOB,
                                      const std::string & source,
                                      const std::string & locName,
                                      int   period,
                                      float fixedCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * stockcost;
  witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost);
  stockcost[period] = fixedCost;
  witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost);
  witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost);
  //  witSetOperationObj1ExecCost(witRun(),enableExogOp.c_str(),stockcost);
  //  witSetPartObj1ScrapCost(witRun(),exogRes.c_str(),stockcost);

  
}

float FATPproblem::getResourceAcquireCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & locName) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * acv;
  witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv);
  float returnVal = acv[0];
  witFree(acv);
  return returnVal;
}

float FATPproblem::getResourceAcquireTime(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & locName) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * atv;
  witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv);
  float returnVal = atv[0];
  witFree(atv);
  return returnVal;
}

float FATPproblem::getResourceReleaseCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & locName) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * rcv;
  witGetPartObj1ScrapCost(mutableWitRun(),acquireOp.c_str(),&rcv);
  float returnVal = rcv[0];
  witFree(rcv);
  return returnVal;
}

float FATPproblem::getResourceReleaseTime(
					 const std::string & jobRole,
					 const std::string & skillSet,
					 const std::string & LOB,
					 const std::string & source,
                                         const std::string & locName) const 
{
  //  std::string acquireOp = acquireResourceOperationName(jobRole);
  //float * rtv;
  //witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&rtv);
  //float returnVal = rtv[0];
  float returnVal = 0.0;  //Still need to model this
  assert(0==1);
  //witFree(rtv);
  
  return returnVal;
}



std::vector<float> FATPproblem::getDemandShipReward(const std::string & engName)const
{
  std::string witDemandName = engagementName(engName);
  return witGetDemandAttribute(witGetDemandObj1ShipReward,witDemandName,witDemandName);
}

std::vector<float> FATPproblem::getResourceGrossQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationMrpExecVol,enableOp);
}

std::vector<float> FATPproblem::getResourceGapQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::vector<float> gapQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,locName);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,locName);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>=0) gapQty.push_back(0.0f);
    else
      gapQty.push_back(-delta);
  }
  return(gapQty);
}

std::vector<float> FATPproblem::getResourceGlutQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::vector<float> glutQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,locName);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,locName);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>0) glutQty.push_back(delta);
    else
      glutQty.push_back(0.0f);
  }
  return(glutQty);
}

std::vector<float> FATPproblem::getResourceStockQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}

//----------------------
// Methods for boms.
//----------------------
void FATPproblem::addBom(const std::string & engagementName, 
                        const std::string & jobRole,
                        const std::string & skillSet,
                        const std::string & LOB,
                        const std::string & source,
                        const std::string & resourceLocName)
{ 
  std::string bn = bomName(engagementName,jobRole,skillSet,LOB,source,resourceLocName);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);

  // nothing to do here. 
  // wit bomEntries are added when the usage period is known

  bomNames_.insert(bn);
}

void FATPproblem::setBomUsageQuantity(
                                     const std::string & engName, 
                                     const std::string & jobRole,
                                     const std::string & skillSet, 
                                     const std::string & LOB, 
                                     const std::string & source, 
                                     const std::string & resourceLocName,
                                     int period, 
                                     float usageQuantity)
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string engagement = engagementName(engName);

  // Get the index for the bom connecting the operation to the part for this period
  int bomIndex = getBomEntryIndex(engagement,workingRes,period);

  // if the bomEntry was not found then add it.
  if ( bomIndex==-1 ) {
    // The RCP BOM must have already been added.
    assert( bomExists(engName,jobRole,skillSet,LOB,source,resourceLocName) );

    witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex);
    witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str());
  
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(period);
    witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData);
  }

  // set the RCP's usageQuantity to consRate
  witSetArcAttribute(witSetBomEntryConsRate,engagement,bomIndex,usageQuantity);
  

  // The BOM entries offset is set just before wit*Implode.
  // The offset will be set to engagementDuration-period

}
  
bool FATPproblem::bomExists(
                           const std::string & engagementName, 
                           const std::string & jobRole,
                           const std::string & skillSet,
                           const std::string & LOB,
                           const std::string & source,
                           const std::string & resourceLocName)const
{
  std::string bn = bomName(engagementName,jobRole,skillSet,LOB,source,resourceLocName);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}


void FATPproblem::getBomNames( 
                             std::vector<std::string> & engagementNames, 
                             std::vector<std::string> & jobRoles, 
                             std::vector<std::string> & skillSets,
                             std::vector<std::string> & LOBs,
                             std::vector<std::string> & sources,
                             std::vector<std::string> & resourceLocNames )const
{
  engagementNames.clear();
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  resourceLocNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=bomNames_.begin(); it!=bomNames_.end(); ++it ) {
    engagementNames.push_back( engagementFromBomName(*it) );
    jobRoles.push_back( resourceFromBomName(*it) );
    skillSets.push_back( skillSetFromBomName(*it) );
    LOBs.push_back( LOBFromBomName(*it) );
    sources.push_back( sourceFromBomName(*it) );
    resourceLocNames.push_back( resourceLocFromBomName(*it) );
  }
}
std::vector<float> FATPproblem::getBomUsageQuantity(
                                                   const std::string & engName,
                                                   const std::string & jobRole, 
                                                   const std::string & skillSet,
                                                   const std::string & LOB,
                                                   const std::string & source,
                                                   const std::string & resourceLocName)const
{
  std::vector<float> retVal;

  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string theEngagement = engagementName(engName);

  int np = getNPeriods();

  int t;
  for (t=0; t<np; ++t) {
    int bomIndex = getBomEntryIndex(theEngagement,workingRes,t);
    retVal.push_back( getBomUsageQuantity(engName,jobRole,skillSet,LOB,source,resourceLocName,t) );
  }

  return retVal;
}
float FATPproblem::getBomUsageQuantity(
                                      const std::string & engName, 
                                      const std::string & jobRole, 
                                      const std::string & skillSet,
                                      const std::string & LOB,
                                      const std::string & source,
                                      const std::string & resourceLocName,
                                      int period)const
{
  float retVal;
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string theEngagement = engagementName(engName);

  int bomIndex = getBomEntryIndex(theEngagement,workingRes,period);
  if ( bomIndex==-1 ) {
    // A bomEntry does not exist for this period
    retVal = 0.0f;
  }
  else {
    std::vector<float> consVol = 
      witGetArcAttribute(witGetBomEntryConsRate,theEngagement,bomIndex);
    retVal = consVol[0];    
  }

  return retVal;
}

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
void  FATPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int sub,
    void (RCPbomAppData::*setSubFunc)(int) )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  (appData->*setSubFunc)(sub);
}

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  FATPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int (RCPbomAppData::*getSubFunc)() const ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return (appData->*getSubFunc)();
}

void  FATPproblem::setBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int match)
{  
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setJobRoleMatch);
}
void  FATPproblem::setBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setSkillSetMatch);
}
void  FATPproblem::setBomLocationMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setLocationMatch);
}
void  FATPproblem::setBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setLobMatch);
}
void  FATPproblem::setBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setSourceMatch);
}

int FATPproblem::getBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getJobRoleMatch);
}
int FATPproblem::getBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSkillSetMatch);
}
int FATPproblem::getBomLocationMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLocationMatch);
}
int FATPproblem::getBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLobMatch);
}
int FATPproblem::getBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSourceMatch);
}

void  FATPproblem::setBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int sub)
{  
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setJobRoleSub);
}
void  FATPproblem::setBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setSkillSetSub);
}
void  FATPproblem::setBomLocationSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setLocationSub);
}
void  FATPproblem::setBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setLobSub);
}
void  FATPproblem::setBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setSourceSub);
}

int FATPproblem::getBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getJobRoleSub);
}
int FATPproblem::getBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSkillSetSub);
}
int FATPproblem::getBomLocationSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLocationSub);
}
int FATPproblem::getBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLobSub);
}
int FATPproblem::getBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSourceSub);
}
  
//----------------------
// Methods for jobRole substitution.
//----------------------
void FATPproblem::addJobRoleSubs(const std::string & fromJobRole, const std::string & toJobRole )
{
  addSubs(jobRoleSubs_,fromJobRole,toJobRole);
}
void FATPproblem::setJobRoleSubsCost(const std::string & fromJobRole, const std::string & toJobRole, float cost )
{
  setSubsCost(jobRoleSubs_,fromJobRole,toJobRole,cost);
}
void FATPproblem::setJobRoleSubsLeadTime(const std::string & fromJobRole, const std::string & toJobRole, float leadTime )
{
  setSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole,leadTime);
}

bool FATPproblem::jobRoleSubsExists(const std::string & fromJobRole, const std::string & toJobRole )const
{
  return subsExists(jobRoleSubs_,fromJobRole,toJobRole);
}
void FATPproblem::getJobRoleSubsNames( std::vector<std::string> & fromJobRoles, std::vector<std::string> & toJobRoles)const
{
  getSubsNames(jobRoleSubs_,fromJobRoles,toJobRoles);
}

float FATPproblem::getJobRoleSubsCost(const std::string & fromJobRole, const std::string & toJobRole )const
{
  return getSubsCost(jobRoleSubs_,fromJobRole,toJobRole);
}
a302 525
float FATPproblem::getJobRoleSubsLeadTime(const std::string & fromJobRole, const std::string & toJobRole )const
{
  return getSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole);
}

  
//----------------------
// Methods for skill substitution.
//----------------------
void FATPproblem::addSkillSubs(const std::string & fromSkill, const std::string & toSkill )
{
  addSubs(skillSubs_,fromSkill,toSkill);
}
void FATPproblem::setSkillSubsCost(const std::string & fromSkill, const std::string & toSkill, float cost )
{
  setSubsCost(skillSubs_,fromSkill,toSkill,cost);
}
void FATPproblem::setSkillSubsLeadTime(const std::string & fromSkill, const std::string & toSkill, float leadTime )
{
  setSubsLeadTime(skillSubs_,fromSkill,toSkill,leadTime);
}

bool FATPproblem::skillSubsExists(const std::string & fromSkill, const std::string & toSkill )const
{
  return subsExists(skillSubs_,fromSkill,toSkill);
}
void FATPproblem::getSkillSubsNames( std::vector<std::string> & fromSkills, std::vector<std::string> & toSkills)const
{
  getSubsNames(skillSubs_,fromSkills,toSkills);
}

float FATPproblem::getSkillSubsCost(const std::string & fromSkill, const std::string & toSkill )const
{
  return getSubsCost(skillSubs_,fromSkill,toSkill);
}

float FATPproblem::getSkillSubsLeadTime(const std::string & fromSkill, const std::string & toSkill )const
{
  return getSubsLeadTime(skillSubs_,fromSkill,toSkill);
}

  
//----------------------
// Methods for location substitution.
//----------------------
void FATPproblem::addLocationSubs(const std::string & fromLocation, const std::string & toLocation )
{
  addSubs(locationSubs_,fromLocation,toLocation);
}
void FATPproblem::setLocationSubsCost(const std::string & fromLocation, const std::string & toLocation, float cost )
{
  setSubsCost(locationSubs_,fromLocation,toLocation,cost);
}
void FATPproblem::setLocationSubsLeadTime(const std::string & fromLocation, const std::string & toLocation, float leadTime )
{
  setSubsLeadTime(locationSubs_,fromLocation,toLocation,leadTime);
}

bool FATPproblem::locationSubsExists(const std::string & fromLocation, const std::string & toLocation )const
{
  return subsExists(locationSubs_,fromLocation,toLocation);
}
void FATPproblem::getLocationSubsNames( std::vector<std::string> & fromLocations, std::vector<std::string> & toLocations)const
{
  getSubsNames(locationSubs_,fromLocations,toLocations);
}

float FATPproblem::getLocationSubsCost(const std::string & fromLocation, const std::string & toLocation )const
{
  return getSubsCost(locationSubs_,fromLocation,toLocation);
}

float FATPproblem::getLocationSubsLeadTime(const std::string & fromLocation, const std::string & toLocation )const
{
  return getSubsLeadTime(locationSubs_,fromLocation,toLocation);
}

  
//----------------------
// Methods for lob substitution.
//----------------------
void FATPproblem::addLobSubs(const std::string & fromLob, const std::string & toLob )
{
  addSubs(lobSubs_,fromLob,toLob);
}
void FATPproblem::setLobSubsCost(const std::string & fromLob, const std::string & toLob, float cost )
{
  setSubsCost(lobSubs_,fromLob,toLob,cost);
}
void FATPproblem::setLobSubsLeadTime(const std::string & fromLob, const std::string & toLob, float leadTime )
{
  setSubsLeadTime(lobSubs_,fromLob,toLob,leadTime);
}

bool FATPproblem::lobSubsExists(const std::string & fromLob, const std::string & toLob )const
{
  return subsExists(lobSubs_,fromLob,toLob);
}
void FATPproblem::getLobSubsNames( std::vector<std::string> & fromLobs, std::vector<std::string> & toLobs)const
{
  getSubsNames(lobSubs_,fromLobs,toLobs);
}

float FATPproblem::getLobSubsCost(const std::string & fromLob, const std::string & toLob )const
{
  return getSubsCost(lobSubs_,fromLob,toLob);
}

float FATPproblem::getLobSubsLeadTime(const std::string & fromLob, const std::string & toLob )const
{
  return getSubsLeadTime(lobSubs_,fromLob,toLob);
}

  
//----------------------
// Methods for source substitution.
//----------------------
void FATPproblem::addSourceSubs(const std::string & fromSource, const std::string & toSource )
{
  addSubs(sourceSubs_,fromSource,toSource);
}
void FATPproblem::setSourceSubsCost(const std::string & fromSource, const std::string & toSource, float cost )
{
  setSubsCost(sourceSubs_,fromSource,toSource,cost);
}
void FATPproblem::setSourceSubsLeadTime(const std::string & fromSource, const std::string & toSource, float leadTime )
{
  setSubsLeadTime(sourceSubs_,fromSource,toSource,leadTime);
}

bool FATPproblem::sourceSubsExists(const std::string & fromSource, const std::string & toSource )const
{
  return subsExists(sourceSubs_,fromSource,toSource);
}
void FATPproblem::getSourceSubsNames( std::vector<std::string> & fromSources, std::vector<std::string> & toSources)const
{
  getSubsNames(sourceSubs_,fromSources,toSources);
}

float FATPproblem::getSourceSubsCost(const std::string & fromSource, const std::string & toSource )const
{
  return getSubsCost(sourceSubs_,fromSource,toSource);
}

float FATPproblem::getSourceSubsLeadTime(const std::string & fromSource, const std::string & toSource )const
{
  return getSubsLeadTime(sourceSubs_,fromSource,toSource);
}



//----------------------
// Methods for handling jobRole, skill, location, lob, and source substitution in a common way
//----------------------
void FATPproblem::addSubs(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )
{
  assert( !subsExists(subCollection,from,to) );
  RCPbaseSubs subs(from,to);
  subCollection[from][to]=subs;
}
void FATPproblem::setSubsCost(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to, float cost )
{
  RCPbaseSubs & subs = getSubs(subCollection,from,to);
  subs.setCost(cost);
}
void FATPproblem::setSubsLeadTime(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to, float leadTime )
{
  RCPbaseSubs & subs = getSubs(subCollection,from,to);
  subs.setLeadTime(leadTime);
} 

bool FATPproblem::subsExists(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
{
  bool retVal=false;
  
  // does the fromSkill exist
  std::map<std::string,RCPmapStringToSubs>::const_iterator itFrom = subCollection.find(from);
  if ( itFrom!=subCollection.end() ) {
    
    // the fromSkill exists, now see if this fromSkill has the toSkill
    RCPmapStringToSubs::const_iterator itTo = itFrom->second.find(to);
    if ( itTo!=itFrom->second.end() ) 
      retVal=true;
  }
  return retVal;
}

void FATPproblem::getSubsNames(const std::map<std::string,RCPmapStringToSubs> & subCollection, std::vector<std::string> & froms, std::vector<std::string> & tos)const
{
  froms.clear();
  tos.clear();
  
  // loop once for each fromSkill
  std::map<std::string,RCPmapStringToSubs>::const_iterator itFrom;
  for (itFrom=subCollection.begin(); itFrom!=subCollection.end(); ++itFrom) {
    
    // loop once for each toSkill
    RCPmapStringToSubs::const_iterator itTo;
    for (itTo=itFrom->second.begin(); itTo!=itFrom->second.end(); ++itTo ) {
      
      // get skillSubs and append from and to skills to returned vectors
      const RCPbaseSubs & subs  = (*itTo).second;
      froms.push_back(subs.getFromName() );
      tos.push_back(subs.getToName() );
      
    }
  }
}
float FATPproblem::getSubsCost(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(subCollection,from,to);
  return subs.getCost();
}
float FATPproblem::getSubsLeadTime(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(subCollection,from,to);
  return subs.getLeadTime();
}

// Get baseSubs from collection class
RCPbaseSubs & FATPproblem::getSubs(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to ) 
{
  assert( subsExists(subCollection,from,to) );
  RCPmapStringToSubs & tos = subCollection.find(from)->second;
  RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}
const RCPbaseSubs & FATPproblem::getSubs(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to ) const
{
  assert( subsExists(subCollection,from,to) );
  const RCPmapStringToSubs & tos = subCollection.find(from)->second;
  const RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}

// given 2 sets return their union
void FATPproblem::unionCollectionOfStrings(
                                            const RCPcollectionOfStrings & set1,
                                            const RCPcollectionOfStrings & set2,
                                            RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_union(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}
// given 2 sets return their intersection
void FATPproblem::intersectionCollectionOfStrings(
                                            const RCPcollectionOfStrings & set1,
                                            const RCPcollectionOfStrings & set2,
                                            RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_intersection(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}

void FATPproblem::removeIneligibleResources(
                                           RCPcollectionOfStrings & currentToResources,
                                           int subAllowed,
                                           const std::map<std::string,RCPmapStringToSubs> & attributeSubs,
                                           const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames,
                                           const std::string & fromResourceAttribute )
{  
  
  if ( subAllowed ) {
    
    // This will be the set we build up
    RCPcollectionOfStrings unionSet;

    // get toResources that can substitute for fromResources
    const RCPmapStringToSubs & toResources = attributeSubs.find(fromResourceAttribute)->second;
    
    // loop over each toResource creating a collection of all resources that have the toResource.
    RCPmapStringToSubs::const_iterator toResourcesIt;
    for ( toResourcesIt=toResources.begin(); toResourcesIt!=toResources.end(); ++toResourcesIt ) {
      // Get all resources whose attribute value matches
      const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
      
      //What is the "to" resource attribute?
      std::string toResourceAttribute = toResourcesIt->first;
      
      // If there aren't any resources with toSkill then there is nothing to do
      if ( attributeToResourceNames.find(toResourceAttribute)==attributeToResourceNames.end() ) continue;
      
      
      // Get set of all resources that have toAttribute
      const RCPcollectionOfStrings & resWithToAttributes = attributeToResourceNames.find(toResourceAttribute)->second;
      
      //take the union of these
      unionCollectionOfStrings(resWithToAttributes,resWithMatch,unionSet);
      
    } // end of for toSkillIt loop
    
    // Take the intersection of unionOrig and currentToResources storing result in intersectionSet
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,unionSet,intersection);
    currentToResources=intersection;
  }
  else { 
    // Are there any resources with the attribute value? If no, then just return
    if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 
    
    // Get all resources whose attribute value matches
    const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
    // Intersect resourcse whose attribute matches with set passed into this method
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,resWithMatch,intersection);
    
    // update set passed into this method with insection just computed
    currentToResources = intersection;
  }
}
//--------------------------------------------------------------------------
// Add wit substitute arcs 
//--------------------------------------------------------------------------
void FATPproblem::addSubsArcsToWitModel()
{
  int np = getNPeriods();
  
  // Get rcp boms
  std::vector<std::string> engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames;
  getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames );
  
  // loop once for each rcp bom
  int b;
  for ( b=0; b<engagementNames.size(); ++b ) {
    const std::string & fromJobRole = jobRoles[b];
    const std::string & fromSkillSet = skillSets[b];
    const std::string & fromLob = LOBs[b];
    const std::string & fromSource = sources[b];
    const std::string & fromLocation = resourceLocNames[b];
    
    // Does fromSkill appear in list of substitutes? If no, then just iterate
    //if ( skillSubs_.find(fromSkill)==skillSubs_.end() ) continue; 
    
    // Name of wit part connected to bomEntry
    std::string workingRes = workingResourceName(fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation);
    
    // Name of wit operation connected to bomEntry
    std::string witEngagement = engagementName(engagementNames[b]);
    
    // Get the indices for the boms connecting the operation to the part
    std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
    
    
    // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
    // be added.  Need loop over bomEntries, because data files allow substitution rules to be different
    // by period.
    int be;
    for( be=0; be<bomIndices.size(); ++be ) {
      int bomIndex = bomIndices[be];  
      
      // get the period associated with this bomEntry
      RCPbomAppData * appData;
      witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),be,(void**)&appData);
      int period = appData->getPeriod();
      
      // Collection that will be manipulated to contain all allowed substitute resources
      RCPcollectionOfStrings subsResources = resourceNames_;;
      
      // Does this bom allow jobRole substitution? 
      int subAllowed =      getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int jobRoleMatching = getBomJobRoleMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (jobRoleMatching) {
        removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,jobToResourceNames_,fromJobRole);
      }
      
      // Does this bom allow skill substitution? 
      subAllowed = getBomSkillSetSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int skillSetMatching = getBomSkillSetMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (skillSetMatching) {
        removeIneligibleResources(subsResources,subAllowed,skillSubs_,skillToResourceNames_,fromSkillSet);
      }
      
      // Does this bom allow location substitution? 
      subAllowed = getBomLocationSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int locationMatching = getBomLocationMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (locationMatching) {
        removeIneligibleResources(subsResources,subAllowed,locationSubs_,locToResourceNames_,fromLocation);
      }
      
      // Does this bom allow lob substitution? 
      subAllowed = getBomLobSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int lobMatching = getBomLobMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (lobMatching) {
        removeIneligibleResources(subsResources,subAllowed,lobSubs_,lobToResourceNames_,fromLob);
      }
      
      // Does this bom allow source substitution? 
      subAllowed = getBomSourceSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int sourceMatching = getBomSourceMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (sourceMatching) {
        removeIneligibleResources(subsResources,subAllowed,sourceSubs_,sourceToResourceNames_,fromSource);
      }

      // Remove resource connected to BOM from the set of substitute resources
      subsResources.erase(baseNameFromWorkingResourceName(workingRes));
           
      // loop once for each substitute resource
      RCPcollectionOfStrings::const_iterator subsResIt;
      for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::string subsResource = *subsResIt;
        std::string toJobRole = jobRoleFromResourceName(subsResource);
        std::string toSkill   = skillSetFromResourceName(subsResource);
        std::string toLocation = locationFromResourceName(subsResource);
        std::string toLOB = LOBFromResourceName(subsResource);
        std::string toSource = sourceFromResourceName(subsResource);

        // make sure substitute resource exists
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
        
        // compute the substitute arcs cost and leadTime
        // subsCost is the sum of the substitute cost for each substituted attribute
        // subsLeadTime is the maximum of the lead time for each substituted attribute
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        if ( fromJobRole != toJobRole && jobRoleMatching==1 ) {
          //jobRole was substituted
          subsLeadTime = max( subsLeadTime , jobRoleSubs_[fromJobRole][toJobRole].getLeadTime() );
          subsCost     = subsCost          + jobRoleSubs_[fromJobRole][toJobRole].getCost();
        }
        if ( fromSkillSet != toSkill && skillSetMatching==1 ) {
          //skill was substituted
          subsLeadTime = max( subsLeadTime , skillSubs_[fromSkillSet][toSkill].getLeadTime() );
          subsCost     = subsCost          + skillSubs_[fromSkillSet][toSkill].getCost();
        }
        if ( fromLocation != toLocation && locationMatching==1 ) {
          //location was substituted
          subsLeadTime = max( subsLeadTime , locationSubs_[fromLocation][toLocation].getLeadTime() );
          subsCost     = subsCost          + locationSubs_[fromLocation][toLocation].getCost();
        }
        if ( fromLob != toLOB && lobMatching==1 ) {
          //lob was substituted
          subsLeadTime = max( subsLeadTime , lobSubs_[fromLob][toLOB].getLeadTime() );
          subsCost     = subsCost          + lobSubs_[fromLob][toLOB].getCost();
        }
        if ( fromSource != toSource && sourceMatching==1 ) {
          //source was substituted
          subsLeadTime = max( subsLeadTime , sourceSubs_[fromSource][toSource].getLeadTime() );
          subsCost     = subsCost          + sourceSubs_[fromSource][toSource].getCost();
        }
        
        // Assert that the subs resource exists
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
        
        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(toJobRole,toSkill,toLOB,toSource,toLocation);
        
        std::cout <<"  resource: " <<workingRes <<std::endl;
        std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
        
        
        // get some attributes of bomEntry that will have substitute added
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,witEngagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,witEngagement,bomIndex);
        
        // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
        // no shifting by lead time is needed
#ifndef NDEBUG
        {
          int t;
          for( t=1; t<np; ++t )
            assert(bomConsRate[0]==bomConsRate[t]);
        }
#endif
        
        // get index of substitute to be added
        int subIndex;
        witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex);
        
        // add substitute
        witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() );
        
        // set substitute consRate
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,witEngagement,bomIndex,subIndex,bomConsRate);
        
        // compute substitute offset
        // JP, Donna, Dan: need to verify that offset is being set correctly.
        std::vector<float> subsOffset(np);
        int t;
        for (t=0; t<np; ++t) {
          subsOffset[t]=offset[t]-subsLeadTime;
        }
        
        // set substitutes offset
        witSetSubArcAttribute(witSetSubsBomEntryOffset,witEngagement,bomIndex,subIndex,subsOffset);
        
        // set cost of using substitute
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,witEngagement,bomIndex,subIndex,subsCost);
        
      }  // end for subsResIt loop
      
    }  // end of for be loop 
    
  } // end for b loop
}

// For a specified BOM return all of the resources that can substitute for it
void FATPproblem::getSubsResources( 
                    const std::string & engName, 
                    const std::string & jobRole,
                    const std::string & skillSet,
                    const std::string & location,
                    const std::string & lob,
                    const std::string & source,
                    RCPcollectionOfStrings & retVal)const
{
  retVal.clear();
  
  // Name of wit part connected to bomEntry
  std::string workingRes = workingResourceName(jobRole,skillSet,lob,source,location);
    
  // Name of wit operation connected to bomEntry
  std::string witEngagement = engagementName(engName);
    
  // Get the indices of the boms connecting the operation to the part
  std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
  int b;
  for( b=0; b<bomIndices.size(); ++b ) {
    int bomIndex = bomIndices[b]; 

    // Get the number of substitutes
    int nSubs;
    witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&nSubs);
a303 297
    // loop once for each subs
    int s;
    for ( s=0; s<nSubs; ++s ) {
      char * subResName;
      witGetSubsBomEntryConsumedPart(mutableWitRun(),witEngagement.c_str(),bomIndex,s,&subResName);
      std::string baseName = baseNameFromWorkingResourceName(subResName);
      retVal.insert(baseName);
      witFree(subResName);
    }
  }

}


void FATPproblem::presolveForGapGlut()
{
  int np=getNPeriods();

  // set witOperationExecBounds for RCP engagement
  // Set softLB to be 1 in the requested startPeriod
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float * softLB = new float[np];
      int t;
      for (t=0; t<np; t++)
	softLB[t] = 0.0f;
      softLB[startPeriod] = 1.0f;
      witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL);
      delete [] softLB;
    }
  }
}
#endif

#if 0
void FATPproblem::presolve()
{
  int np=getNPeriods();

  // set wit obj1ShipReward from RCP engagement revenue, startTime, duration.
  // Loop over all engagements
  {
    float * obj1ShipReward = new float[np];
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
      
      //   int lastPeriod = startPeriod+duration-1;
      //if (lastPeriod>np) lastPeriod=np;
      int t;
      for ( t=0; t<startPeriod; t++ ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 ){
        for ( t=startPeriod; t<np; t++ ) obj1ShipReward[t]=revenue;
      }
      else {
	int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
        for ( t=startPeriod; t<endPoint; t++) obj1ShipReward[t]=revenue;
	for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
      }
      witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward);
    }
    delete [] obj1ShipReward;   
  }

  // set wit bomEntryOffset for each RCP bom.
  // The offset = (engagement duration) - (wit's bomEntry period)
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int e;
    for ( e=0; e<engagementNames.size(); ++e ) {

      // Get engagements duration
      int duration = getEngagementDuration(engagementNames[e]);
      std::string theEngagement = engagementName(engagementNames[e]);
      
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        // get the period associated with this bomEntry
        RCPbomAppData * appData;
        witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData);
        int period = appData->getPeriod();

        // compute offset for bomEntry
        float offset = -period;

        // Set bomEntry offest
        witSetArcAttribute(witSetBomEntryOffset,theEngagement,b,offset);
        
      } // end of b loop
    } // end of e loop
  } // finished setting wit bomEntryOffset for each RCP BOM
  
  // Add substitute arcs.  
  addSubsArcsToWitModel();
}
void FATPproblem::gapGlut()
{
  presolve();
  presolveForGapGlut();
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
  witWriteData(witRun(),"wit.dat");
  witMrp(witRun());
  witOptImplode(witRun());
}
//--------------------------------------------
void FATPproblem::optimalPlan()
{

  presolve();
  witSetOptWithLotSizes(witRun(),WitTRUE); 
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
  witWriteData(witRun(),"wit.dat");
  witMrp(witRun());
  witOptImplode(witRun());
}
#endif


#if 0
//-------------------------------------------------------------------------
// Engagement Name Methods
//-------------------------------------------------------------------------
std::string FATPproblem::engagementName(const std::string & engagementName )
{
  return "engagement: "+engagementName;
}


std::string FATPproblem::engagementFromEngagementName(const std::string & engName)
{
  return textAfter(engName,"engagement: ");
}





//-------------------------------------------------------------------------
// Resource Name Methods
//-------------------------------------------------------------------------
std::string FATPproblem::acquireResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "acquire: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::benchResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "bench: " + baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::enableResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "enable: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::workingResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "working: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::enableExogenousResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "enableSup: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::exogenousResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "exogRes: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string FATPproblem::baseResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +locName;
}


std::string FATPproblem::jobRoleFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName,"resource: "," skillSet: ");
}
std::string FATPproblem::skillSetFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," skillSet: "," LOB: ");
}
std::string FATPproblem::LOBFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," LOB: "," source: ");
}
std::string FATPproblem::sourceFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," source: "," at: ");
}
std::string FATPproblem::locationFromResourceName(const std::string & baseResourceName)
{
  return textAfter(baseResourceName," at: ");
}
std::string FATPproblem::baseNameFromWorkingResourceName(const std::string & workingName)
{
  return textAfter(workingName,"working: ");
}


//-------------------------------------------------------------------------
// Bom Name Methods
//------------------------------------------------------------------------- 
std::string FATPproblem::bomName(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName)
{
  return "bom op: " + engagementName + " resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source +" at: "+ resourceLocName;
}
std::string FATPproblem::engagementFromBomName(const std::string & bomName)
{
  return textBetween(bomName,"bom op: "," resource: ");
}
std::string FATPproblem::resourceFromBomName(const std::string & bomName)
{
  return textBetween(bomName," resource: "," skillSet: ");
}
std::string FATPproblem::skillSetFromBomName(const std::string & bomName)
{
  return textBetween(bomName," skillSet: "," LOB: ");
}
std::string FATPproblem::LOBFromBomName(const std::string & bomName)
{
  return textBetween(bomName," LOB: "," source: ");
}
std::string FATPproblem::sourceFromBomName(const std::string & bomName)
{
  return textBetween(bomName," source: "," at: ");
}
std::string FATPproblem::resourceLocFromBomName(const std::string & bomName)
{
  return textAfter(bomName," at: ");
}

  

#if 0
//-------------------------------------------------------------------------
// skillSubs Name Methods
//------------------------------------------------------------------------- 
std::string FATPproblem::skillSubsName(const std::string & fromSkill,const std::string & toSkill)
{
  return "fromSkill: " + fromSkill + " toSkill: " + toSkill;
}
#endif



//--------------------------------------------------------
// Get Bom Entry Index
// Return the bom entry index that matches input parms
// -1 returned if bomEntryIndex does not exist
int FATPproblem::getBomEntryIndex( 
                                const std::string & opName, 
                                const std::string & partName,
                                int period
                                ) const
{
  int retVal = -1;
  
  int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  int nBoms;
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms);
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit);
    if(partName==consPartFromWit) {
      // Operation and Part match, now see if bomEntry has correct period    
      RCPbomAppData * appData;
      witGetBomEntryAppData(mutableWitRun(),opName.c_str(),bei,(void**)&appData);
      int bomEntryPeriod = appData->getPeriod();
      if ( bomEntryPeriod == period ) {      
        retVal=bei;
      }
      witFree(consPartFromWit);
      if(retVal!=-1) break;
    }
    
  }
  return retVal;
}
a305 29
// Get Bom Entry Indices
// Return the bom entry indices that matches input parms
std::vector<int> FATPproblem::getBomEntryIndex( 
                                const std::string & opName, 
                                const std::string & partName
                                ) const
{
  std::vector<int> retVal;
  
  int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  int nBoms;
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms);
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit);
    if(partName==consPartFromWit) {
      // Operation and Part match     
      retVal.push_back(bei);
    }
    witFree(consPartFromWit);
  }
  return retVal;
}
#endif
//--------------------------------------------------------
a360 43
  
#if 0

  // copy rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPbomAppData * srcAppData;    
        RCPbomAppData * sinkAppData;
        witGetBomEntryAppData(source.mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData);
        sinkAppData = new RCPbomAppData(*srcAppData);    
        witSetBomEntryAppData(witRun(),theEngagement.c_str(),b,sinkAppData);
        
      } // end of b loop
    } // end of e loop
  } // finished copying rcp bom appData
  
  // copy resource appData
  {
    int r;
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    for ( r=0; r<jobRoles.size(); ++r ) { 
      std::string resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      RCPresourceAppData * srcAppData;  
      RCPresourceAppData * sinkAppData;  
      witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
      sinkAppData = new RCPresourceAppData(*srcAppData);   
      witSetPartAppData(witRun(),resourceName.c_str(),sinkAppData); 
    }
  }
#endif

a377 48
#if 0
  // delete engagement appData
  int e;
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;  
    witGetPartAppData(mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData);
    delete srcAppData;
  }

  // delte rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPengagementAppData * srcAppData;
        witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData);
        delete srcAppData;
        
      } // end of b loop
    } // end of e loop
  } // finished deleting rcp bom appData

  // delete resource appData
  {
    int r;
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    for ( r=0; r<jobRoles.size(); ++r ) { 
      std::string resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      RCPresourceAppData * srcAppData;  
      witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
#endif

@


1.9
log
@modified copy constructor to copy campaign appData.
modified destructor to delete campaign appData.
@
text
@d89 9
d149 44
d298 1
d2034 1
a2034 1
 // witSetExecEmptyBom(witRun(),WitTRUE);
d2346 46
@


1.8
log
@I have fixed some terminology inconsequences (changed orderEntryNames to
orderEntryIds.
I have added a code in the presolve method for initializing order list.
The last thing is not tested. The rest seems to work fine, unless I have overlooked something.
@
text
@a180 1

d2014 14
a2028 13
  // copy engagement appData
  int e;
  std::vector<std::string> engagementNames;
  std::vector<std::string> engagementLocs;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;    
    RCPengagementAppData * sinkAppData;
    witGetPartAppData(source.mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData);
    sinkAppData = new RCPengagementAppData(*srcAppData);    
    witSetPartAppData(witRun(),theEngagement.c_str(),sinkAppData);
  }
d2075 12
d2196 1
d2237 1
a2237 1
   //test FATPproblem class
d2272 1
a2272 255
#if 0
         
  // Test engagements
  {
    
    FATPproblem prob;

    std::cout <<"Test B:engagements " <<std::endl;
    prob.setNPeriods(2);

    prob.addEngagement("e1");  
    prob.addEngagement("e2");

    assert(  prob.engagementExists("e1") );
    assert(  prob.engagementExists("e2") );
    assert( !prob.engagementExists("e3") );

    assert( prob.getEngagementRevenue("e1") == 0.0f );
    prob.setEngagementRevenue("e1",1.234f);
    assert( prob.getEngagementRevenue("e1") == 1.234f );

    prob.setEngagementStartPeriod("e1",1);
    assert( prob.getEngagementRequestedStartPeriod("e1") == 1 );

    prob.setEngagementDuration("e1",3);
    assert( prob.getEngagementDuration("e1") == 3 );

    assert(prob.getEngagementLocation("e1")=="");
    prob.setEngagementLocation("e1","Loc1");
    assert(prob.getEngagementLocation("e1")=="Loc1");

    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    assert( engagementNames.size()==2 );
    assert( engagementNames[0]=="e1" || engagementNames[1]=="e1" );
    assert( engagementNames[0]=="e2" || engagementNames[1]=="e2" );

    assert( !prob.getEngagementExecuted("e1") );

  }
           
  // Test resources
  {
    FATPproblem prob;
    std::cout <<"Test C:resources " <<std::endl;
    prob.setNPeriods(4);

    prob.addResource("r1","s1", "LOB1","src1","l1");  
    prob.addResource("r2","s2","LOB2","src2","l2");
    float time = prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1");
    assert( time == 0.f);
    prob.setResourceAcquireTime("r1","s1","LOB1","src1","l1", 2.f);
    assert ( prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1") == -2.f ); //note that we negate the
	                                                      //acquire time inside setResourceAcquireTime
	                                                      //so that logically it can be positive

    assert( prob.getResourceAcquireCost("r1","s1","LOB1","src1","l1") == 0 );
    prob.setResourceAcquireCost("r1","s1","LOB1","src1","l1", 100.f);
    assert ( prob.getResourceAcquireCost("r1","s1","LOB1","src1","l1") == 100.f );
    
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    prob.getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    assert( jobRoles.size()==2 );
    assert( jobRoles[0]=="r1" || jobRoles[1]=="r1" );
    assert( jobRoles[1]=="r2" || jobRoles[1]=="r2" );

    assert( skillSets.size()==2 );
    assert( skillSets[0]=="s1" || skillSets[1]=="s1" );
    assert( skillSets[0]=="s2" || skillSets[1]=="s2" );

    assert( LOBs.size()==2 );
    assert( LOBs[0]=="LOB1" || LOBs[1]=="LOB1" );
    assert( LOBs[0]=="LOB2" || LOBs[1]=="LOB2" );

    assert( sources.size()==2 );
    assert( sources[0]=="src1" || sources[1]=="src1" );
    assert( sources[0]=="src2" || sources[1]=="src2" );

    assert( locNames.size()==2 );
    assert( locNames[0]=="l1" || locNames[1]=="l1" );
    assert( locNames[0]=="l2" || locNames[1]=="l2" );

    // Test to ensure SupplyQuantity defaults to 0
    std::vector<float> sq = prob.setBenchResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
    assert( sq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==0.0f );

    std::vector<float> sqOrig = sq;

    // Test SupplyQuantity Set/Get
    sqOrig[2]=5.0f;
    prob.setExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2",2,sqOrig[2]);
    sq = prob.getExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    sqOrig[0]=2.0f;
    prob.setExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2",0,sqOrig[0]);
    sq = prob.getExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    

  }

             
  // Test bom
  {
    FATPproblem prob;
    std::cout <<"Test D:bom " <<std::endl;
    prob.setNPeriods(4);

    prob.addResource("r1","s1","LOB1","src1","l1");  
    prob.addResource("r2","s2","LOB2","src2","l1");
    prob.addEngagement("e1");

    std::vector<std::string> jobRoles,skillSets,LOBs,sources,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,jobRoles,skillSets,LOBs,sources,resourceLocNames);
    assert( jobRoles.size()==0);
    assert( engagementNames.size()==0);

    // test add bom
    assert( !prob.bomExists("e1","r1","s1","LOB1","src1","l1") );
    prob.addBom("e1","r1","s1","LOB1","src1","l1");
    assert( prob.bomExists("e1","r1","s1","LOB1","src1","l1") );

    // test add another bom
    assert( !prob.bomExists("e1","r2","s2","LOB2","src2","l1") );
    prob.addBom("e1","r2","s2","LOB2","src2","l1");
    assert( prob.bomExists("e1","r2","s2","LOB2","src2","l1") );

    prob.getBomNames(engagementNames,jobRoles,skillSets,LOBs,sources,resourceLocNames);
    assert( engagementNames.size()==2);
    assert( engagementNames[0]=="e1");
    assert( engagementNames[1]=="e1");
    assert( jobRoles.size()==2 );
    assert( jobRoles[0]=="r1" || jobRoles[1]=="r1" );
    assert( jobRoles[0]=="r2" || jobRoles[1]=="r2" );
    assert( skillSets.size()==2 );
    assert( skillSets[0]=="s1" || skillSets[1]=="s1" );
    assert( skillSets[0]=="s2" || skillSets[1]=="s2" );
    assert( LOBs.size()==2 );
    assert( LOBs[0]=="LOB1" || LOBs[1]=="LOB1" );
    assert( LOBs[0]=="LOB2" || LOBs[1]=="LOB2" );
    assert( sources.size()==2 );
    assert( sources[0]=="src1" || sources[1]=="src1" );
    assert( sources[0]=="src2" || sources[1]=="src2" );
    assert( resourceLocNames.size()==2 );
    assert( resourceLocNames[0]=="l1");
    assert( resourceLocNames[1]=="l1");

    // Test to ensure usageQuantity defaults to 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
    assert( uq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==0.0f );

    std::vector<float> uqOrig = uq;

    // Test SupplyQuantity Set/Get
    uqOrig[2]=5.0f;
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    uqOrig[0]=2.0f;
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
      
    // test set/getting match usage
    assert( prob.getBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLobMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    
    prob.setBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLobMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0,1);

    assert( prob.getBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLobMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );

    // test set/getting subs usage
    assert( prob.getBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLocationSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLobSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSourceSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    
    prob.setBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLocationSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLobSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSourceSub("e1","r2","s2","LOB2","src2","l1",0,1);

    assert( prob.getBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLocationSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLobSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSourceSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
  }
   // Test skillSubs
  {
    FATPproblem prob;
    std::vector<std::string> fromSkills, toSkills;
    prob.getSkillSubsNames(fromSkills,toSkills);
    assert(fromSkills.size()==0);
    assert(toSkills.size()==0);

    
    assert( !prob.skillSubsExists("s1","s2") );
    prob.addSkillSubs("s1","s2");
    assert( prob.skillSubsExists("s1","s2") );
    prob.getSkillSubsNames(fromSkills,toSkills);
    assert(fromSkills.size()==1);
    assert(toSkills.size()==1);
    assert(fromSkills[0]=="s1");
    assert(toSkills[0]=="s2");

    prob.setSkillSubsCost("s1","s2",2.0f);
    assert( eq(prob.getSkillSubsCost("s1","s2"),2.0f) );

    prob.setSkillSubsLeadTime("s1","s2",3.0f);
    assert( eq(prob.getSkillSubsLeadTime("s1","s2"),3.0f) );
    
    prob.addSkillSubs("sA","sB");
    prob.getSkillSubsNames(fromSkills,toSkills);
    assert(fromSkills.size()==2);
    assert(toSkills.size()==2);
    assert(fromSkills[1]=="sA");
    assert(toSkills[1]=="sB");

    assert(  prob.skillSubsExists("sA","sB") );
    assert( !prob.skillSubsExists("sB","sA") );

  } // end test skillSubs

  // Test assignment operator
d2274 1
a2274 1
    FATPproblem prob0;
d2276 1
a2276 3
      FATPproblem prob1;
      std::cout <<"Test E:assignment " <<std::endl;
      prob1.setNPeriods(2);
d2278 4
a2281 5
      prob1.addEngagement("e1");

      prob1.setEngagementRevenue("e1",1.0f);
      prob1.setEngagementStartPeriod("e1",1);
      prob1.setEngagementDuration("e1",3);
d2283 1
a2283 3
      assert(prob1.getEngagementRevenue("e1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("e1")==1);
      assert(prob1.getEngagementDuration("e1")==3);
d2285 2
a2286 1
      prob0=prob1;
d2289 2
a2290 148
    assert(prob0.getEngagementRevenue("e1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("e1")==1);
    assert(prob0.getEngagementDuration("e1")==3);    
  }

  
  {
    FATPproblem prob_subs;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example4";
    //this problem must use substitute skills to satisfy engagements
    populate(prob_subs, inputDirectory, outputDirectory);
    prob_subs.optimalPlan();
    
    //check that appropriate substitute arcs are there
    {
      
      // Create base name for each resource
      std::string r1s1   = FATPproblem::baseResourceName("r1", "s1", "LOB1","src1","l1");
      std::string r1s2   = FATPproblem::baseResourceName("r1", "s2", "LOB1","src1","l1");
      std::string r2s1   = FATPproblem::baseResourceName("r2", "s1", "LOB1","src1","l1");
      std::string r2s2   = FATPproblem::baseResourceName("r2", "s2", "LOB1","src1","l1");
      std::string r1as1  = FATPproblem::baseResourceName("r1a","s1", "LOB1","src1","l1");
      std::string r1as2  = FATPproblem::baseResourceName("r1a","s2", "LOB1","src1","l1");
      std::string r1s1a  = FATPproblem::baseResourceName("r1", "s1a","LOB1","src1","l1");
      std::string r2s1a  = FATPproblem::baseResourceName("r2", "s1a","LOB1","src1","l1");
      std::string r1as1a = FATPproblem::baseResourceName("r1a","s1a","LOB1","src1","l1");
      
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r1","s1","l1","LOB1","src1"
      RCPcollectionOfStrings subsRes;
      prob_subs.getSubsResources(
        "e1",
        "r1","s1","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  != subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  != subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) != subsRes.end() ); 
      assert( subsRes.size() == 3 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r2","s1","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",
        "r2","s1","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  != subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );        
      assert( subsRes.size() == 1 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r1","s2","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",
        "r1","s2","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  != subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() ); 
      assert( subsRes.size() == 1 );  
      
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r2","s2","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",
        "r2","s2","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );   
      assert( subsRes.size() == 0 );
    }
    
    //Check optimal value
    double obj = prob_subs.getObjValue();
    assert( eq(obj,4886.0) );
    
    
  }
  
  //now do some meaningful tests with various test directories.
  {
    FATPproblem prob_baseline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_baseline";
    populate(prob_baseline, inputDirectory, outputDirectory);
    prob_baseline.gapGlut(); 
    
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l1");
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l1");
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 );
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l1");
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 );
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l1");
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==10.0 ); //or -10?
    
    gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l2");
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==30.0 ); //or -30?
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l2");
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==10.0 ); //or -10?
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l2");
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 ); 
a2294 129
  {
    FATPproblem prob_acquire;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_acquire";
    //this problem has a short time horizon, and revenue is set so that
    //acquiring new resources is worthwhile
    populate(prob_acquire, inputDirectory, outputDirectory);
    prob_acquire.optimalPlan();
    double obj = prob_acquire.getObjValue();
    assert( eq(obj,4925.0) );
    //test that resources got acquired; 2 of r1 and 3 of r2, both in period 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    assert(acquireQty[1]==2);
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    assert(acquireQty[1]==3);
    //test that one engagement gets executed starting in period 1 (it has to wait one period to acquire the resources)
    assert(prob_acquire.getEngagementExecuted("e1"));
    assert(prob_acquire.getEngagementExecuted("e2"));
    assert(prob_acquire.getEngagementStartPeriod("e1")==0);
    assert(prob_acquire.getEngagementStartPeriod("e2")==2);
  }
  
  {
    FATPproblem prob_delay;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_delay";
    //this problem has a longer time horizon, and revenue is set so that
    //delaying the execution of jobs is worthwhile
    populate(prob_delay, inputDirectory, outputDirectory);
    prob_delay.optimalPlan();
    double obj = prob_delay.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,4935.0) );
    //test that no resources were acquired, and that a job was done late
    assert(
      prob_delay.getEngagementStartPeriod("e2")==0 && prob_delay.getEngagementStartPeriod("e1")==3
      ||
      prob_delay.getEngagementStartPeriod("e2")==3 && prob_delay.getEngagementStartPeriod("e1")==0
      );
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
    acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
  }
  
  {
    FATPproblem prob_decline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_decline";
    //this problem has a short time horizon, but revenue and acquire costs are such that
    //it is better to decline an engagement
    populate(prob_decline, inputDirectory, outputDirectory);
    prob_decline.optimalPlan();
    double obj = prob_decline.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,265.0) );
    //test that resources were not acquired and that a job was declined
    assert(prob_decline.getEngagementExecuted("e1")==false);
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
    acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
  }
  {
    FATPproblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory);

    prob_IGS.optimalPlan();
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39835.0f) );
    //test that the shipReward is set in periods 6 and 7
    std::vector<float> shipRewardQty = prob_IGS.getDemandShipReward("e1");
    int i;
    for(i=0; i<6; i++)
      assert(eq(shipRewardQty[i],0.0f));
    assert(eq(shipRewardQty[6],40000.0f));
    assert(eq(shipRewardQty[7],40000.0f));
    for(i=8; i<16; i++)
      assert(eq(shipRewardQty[i],0.0f));

    int ed = prob_IGS.getEngagementDuration("e1");
    assert(ed==2);
    int ela = prob_IGS.getEngagementLateAllowance("e1");
    assert( ela == 1 );
    int ersp = prob_IGS.getEngagementRequestedStartPeriod("e1");
    assert( ersp == 6 );
    int esp = prob_IGS.getEngagementStartPeriod("e1");
    assert( esp == 6 || esp == 7 );
  }
  
  {
    FATPproblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory);

    // don't let the engagement be done a period late
    prob_IGS.setEngagementLateAllowance("e1",0);

    prob_IGS.optimalPlan();
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39835.0f) );
    int esp = prob_IGS.getEngagementStartPeriod("e1");
    assert( esp == 6 );
  }
  
  //"new" style simple input
  {
    FATPproblem prob_simple;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_simple";
    
    populate(prob_simple, inputDirectory, outputDirectory);
    prob_simple.optimalPlan();
    
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    prob_simple.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
a2295 23
    std::vector<float> gapQty = prob_simple.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    std::vector<float> glutQty = prob_simple.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==20);
    assert(glutQty[1]==0);

    gapQty = prob_simple.getResourceGapQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    assert(gapQty[0]==10);
    assert(glutQty[0]==0);
    assert(gapQty[1]==30);
    assert(glutQty[1]==0);

    gapQty = prob_simple.getResourceGapQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==30);
    assert(gapQty[1]==0);
    assert(glutQty[1]==10);

  }
#endif
@


1.7
log
@modified addOrderEntry to create appData
@
text
@d89 9
d110 2
d131 1
a131 1
bool  FATPproblem::orderExists(const std::string & orderName)const
d140 30
a169 1
bool FATPproblem::campaignExists(const std::string & campaignName)const
d171 6
a176 4
  witBoolean exists;
  witGetPartExists(mutableWitRun(), campaignName.c_str(), &exists);
  if ( exists ) return true;
  else return false;
d178 2
d194 3
a196 1
    float * supplyVol = new float[np];
d219 21
a2147 1
	  
d2150 1
a2150 1
  // test campaigm methods
d2184 1
a2184 1

d2188 11
a2198 1
	  assert(!prob.orderExists("Order1"));
d2200 1
a2200 1
	  prob.addOrderEntry("Order1");
d2205 1
a2205 1
	  assert(prob.orderExists("Order1"));
d2207 15
a2221 1
	 
d2224 1
@


1.6
log
@fixed method to be of type const
@
text
@d19 1
d96 5
a100 2
witAddPart(witRun(),orderId.c_str(),WitMATERIAL);
witAddDemand(witRun(),orderId.c_str(),orderId.c_str() );
@


1.5
log
@finished implementing campaign methods.
implemented presolve for setting campaign's supplyVol
fixed type problem in campaignAppData
@
text
@d106 1
a106 1
int FATPproblem::getOrderEntryImportance( const std::string & orderId)
d110 1
a110 1
	witGetDemandPriority(witRun(),orderId.c_str(),orderId.c_str(),&temp);
@


1.4
log
@Added campaignAppData.
Implemented [sg]etCampaignDuration using app data.
@
text
@d33 2
d51 38
d133 45
d2084 5
d2091 23
a2114 4
    assert(prob.getCampaignDuration("C1")==1);
    prob.setCampaignDuration("C1",5);
    assert(prob.getCampaignDuration("C1")==5);
  }
d2126 2
d2130 33
@


1.3
log
@no message
@
text
@d18 1
d28 18
a45 2
   witAddOperation(wr,campaignName.c_str());
    witAddBomEntry(wr, campaignName.c_str(), campaignName.c_str() );
d48 5
d2001 4
@


1.2
log
@implemented addCampaign and campaignExists methods.
Added stanza to unitTest to test them
@
text
@d27 2
d31 33
a63 1
bool FATPproblem::compaignExists(const std::string & campaignName)const
d1961 10
a1970 10
    FATPproblem prob,prob1;
          
    prob.setNPeriods(12);
    assert( prob.getNPeriods() == 12 );
    
    prob.setTitle("wittitle");
    assert( prob.getTitle() == "wittitle");

    assert( prob.implosionCount()==0 );  

d1972 1
a1972 1

d1975 4
a1978 4
    FATPproblem prob;
    assert( !prob.compaignExists("C1") );
    prob.addCampaign("C1");
    assert( prob.compaignExists("C1") );
d1980 13
@


1.1
log
@Initial revision
@
text
@d20 8
d29 7
d1927 2
a1928 4
    FATPproblem prob;
    
    std::cout <<"Test A: " <<std::endl;
      
d1937 1
d1939 6
@


1.1.1.1
log
@no message
@
text
@@

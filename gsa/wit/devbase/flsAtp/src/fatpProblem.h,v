head	1.47;
access;
symbols
	Start:1.1.1.1 IBM:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2004.05.13.20.05.17;	author grzes;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.11.22.23.00;	author grzes;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.11.22.20.42;	author grzes;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.11.22.10.25;	author grzes;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.11.22.01.50;	author grzes;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.11.22.00.01;	author grzes;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.11.21.55.01;	author grzes;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.11.21.47.37;	author grzes;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.11.21.34.20;	author grzes;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.11.21.31.44;	author grzes;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.11.21.13.47;	author grzes;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.29.21.47.36;	author grzes;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.29.16.40.28;	author grzes;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.21.14.46.51;	author grzes;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.20.18.51.22;	author grzes;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.19.20.58.03;	author grzes;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.09.14.29.31;	author grzes;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.07.22.56.25;	author grzes;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.05.22.24.02;	author grzes;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.31.00.06.08;	author grzes;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.30.20.58.48;	author grzes;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.22.19.48.02;	author grzes;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.22.19.43.11;	author grzes;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.18.19.11.15;	author grzes;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.18.15.12.40;	author grzes;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.16.18.36.20;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.15.16.06.06;	author grzes;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.13.04.35.21;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.13.04.24.41;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.12.22.00.27;	author grzes;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.12.19.06.08;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.12.18.34.43;	author grzes;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.11.17.06.28;	author grzes;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.10.18.55.26;	author grzes;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.10.18.02.34;	author grzes;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.07.17.21.47;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.03.20.02.55;	author grzes;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.03.18.57.08;	author grzes;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.02.21.00.35;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.01.22.16.14;	author grzes;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.01.16.35.50;	author grzes;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.27.19.54.57;	author grzes;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.24.16.36.45;	author grzes;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.24.16.32.55;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.24.16.27.05;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.24.16.22.27;	author grzes;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.24.15.21.35;	author fasano;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.02.24.15.21.35;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.47
log
@FLSATP ver 1.0
Done, comments have been added
Messages can be switched off by using static class field MessagesOn
@
text
@#ifndef FATPproblem_h
#define FATPproblem_h

#include "problemBase.h"
#include "fatpException.h"

class FATPproblem : public SCOproblemBase {

static bool MessagesOn;

public:

   // if switched to false, no messages are displayed, default = true.
   static bool& getMessagesOn();

  //----------------------
  // Methods for campaigns.
  //----------------------

  //--------------------------------------------------------
  //Time in the model is expressed in terms of periods.
  //Periods are "time b uckets", and it is up to user to treat 
  //them as days, hours etc.
  //Camapaign Start Period denotes the period at which Capaign starts.
  //The Duration expresses "how long does the campaign last", so if a coil
  //goes through a Campaign with Start Period SP and Duration D, it will be available
  //for the next Campaign or for delivery at period SP+D.
  


  void addCampaign       (const std::string & campaignName);
  void setCampaignStartPeriod   (const std::string & campaignName, int startPeriod )
	  throw(FATPException);
  void setCampaignDuration   (const std::string & campaignName, int duration )
	  throw(FATPException);
  void setCampaignExcessCapacity   (const std::string & campaignName, float time )
	  throw(FATPException);
  void setCampaignType (const std::string & campaignName, const std::string & type )
	  throw(FATPException);
 
  bool campaignExists    (const std::string & campaignName)const;
  void getCampaignNames( std::vector<std::string> & campaignNames )const;
  void getSortedCampaignNames( std::vector<std::string> & campaignNames )const;
  void getCampaignTypes( std::vector<std::string> & campaignTypes ) const;
  int getCampaignStartPeriod   (const std::string & campaignName) const
	  throw(FATPException);
  int getCampaignDuration   (const std::string & campaignName) const
	  throw(FATPException);
  float getCampaignExcessCapacity (const std::string & campaignName) const
	  throw(FATPException);
  float getCampaignExcessCapacityConsumed(const std::string & campaignName) const;

  std::string getCampaignType(const std::string & campaignName) const
	  throw(FATPException);
  FATPvectorString getCampaignsOfType(const std::string & campaignType);

  //checking if pair of two campaigns is feasible

  bool campaignsFeasible(const std::string & firstCampaignName,
	  const std::string & secondCampaignName);
    
  int compareCampaigns(const std::string & firstCampaignName,
	  const std::string & secondCampaignName);


  //----------------------
  // Methods for orders
  //----------------------
  void addOrderEntry( const std::string & orderId );
  void setOrderEntryCoilQty( const std::string & orderId, float qty )
	  throw(FATPException);  
  void setOrderEntryDesiredPeriod( const std::string & orderId, int date )
	  throw(FATPException); 
  void setOrderEntryImportance( const std::string & orderId, int impt )
	  throw(FATPException);
  bool orderEntryExists(const std::string & orderName)const;

  void getOrderEntryIds( std::vector<std::string> & orderEntryIds )const; 
  float getOrderEntryCoilQty( const std::string & orderId )const
	  throw(FATPException);  
  int getOrderEntryDesiredPeriod( const std::string & orderId )const
	  throw(FATPException);  
  int getOrderEntryImportance( const std::string & orderId )const
	  throw(FATPException);
  int getOrderEntryNRecipes( const std::string & orderId )const
	  throw(FATPException);


  //we ask for campaigns used by Order Entry: orderId
  //as a return we get campaignNamesList - vector of Campaigns used
  //and capacities consumed, capacitiesConsumed[i] is the amount of
  //Excess Capacity consumed by orderId of Campaign campaignNamesList[i]
  void getOrderEntryUsedCampaigns (const std::string & orderId,
	  std::vector<std::string> & campaignNamesList,
	  std::vector<float> & capacitiesConsumed)const
	  throw(FATPException);
  
  //we want to now what campaigng Excess Capacities should be increased
  //for the Order Entry orderID to be satisfied in the Desired Period
  //as a return we get the vector of Campaigns: shortCampaigns
  //and the vector of the amounts by which we must increase each Excess Capacity
  //it returns 0 if there is such possibility, and returns 1 if it cannot be done
  //by increasing Excess Capacities of existing Campaigns
  char getOrderEntryCampaignShortages(
	  const std::string & orderId,
	  std::vector<std::string> & shortCampaigns,
	  std::vector<float> & capacityShortages )const
	  throw(FATPException);
	  

  //------------------------------------------------------------------
  // AtpPeriod (output) - the period when the order can be promised.
  // The AtpPeriod will be >= the DesiredPeriod or -1.
  // If -1 is returned then no part of the order entry can be fufilled.
  //------------------------------------------------------------------
  int getOrderEntryAtpPeriod(const std::string & orderId )const
	  throw(FATPException);

  // CoilAtpQty (output) - the amount of the order that can be promised.
  // If there is not enough capacity, then it is possible to promise a portion of the order
  // CoilAtpQty will be in range [0,CoilQty].
  float getOrderEntryCoilAtpQty(const std::string & orderId )const
	  throw(FATPException);
  
  //The vector of coils Atp at ther certain period.
  std::vector<float> getOrderEntryCoilAtpVector(const std::string & orderId)const
	  throw(FATPException);


  //-----------------------
  // Methods for adding recipes.
  // A recipe is the sequence of campaigns that can be used to 
  // produce an order entry.
  //-----------------------
  void addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe,
	  const FATPvectorFloat & consRates )
	  throw(FATPException);
  void addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe )
	  throw(FATPException);
  
    void addOrderEntryRecipesByCampaignType(
     const std::string & orderId, 
    const FATPvectorString & campaignTypes)
	  throw(FATPException);
	
  void addOrderEntryRecipesByCampaignType(
    const std::string & orderId, 
    const FATPvectorString & campaignTypes,
	const FATPvectorFloat & consRates)
	throw(FATPException);
  //----------------------
  // Methods for order bill of material.
  //----------------------

  //--------------------
  // Solve Methods. 
  //--------------------
  void computeAtp();

  // default constructor
  FATPproblem();
  
  // copy constructor
  FATPproblem( const FATPproblem& source );
  
  // assignment operator
  FATPproblem&
  operator=(const FATPproblem& rhs);
  
  // destructor
  ~FATPproblem();
  

  // Self-test
  static void test();


private:
	
	// presolve
	void presolve();

	inline void CheckIfCampExists(const std::string & campaignName) const
		throw(FATPException);
		
	inline void CheckIfOrderEntryExists(const std::string & orderId) const
		throw(FATPException);

	
	void recursiveAddCampaignNamesToRecipe(const std::string & orderId, 
		int & recipeLength,
		int & cloneMarker,
		std::vector<int> &vecOfPositions,
		std::vector<int> &vecOfLoBounds,
		const std::vector<FATPvectorString> &typeToCamps,
		const FATPvectorFloat & consRates);
	
	void gutsOfCopy( const FATPproblem& source );
	void gutsOfDestructor();

	std::set<std::string> campaignNames_;
	std::set<std::string> campaignTypes_;
	std::set<std::string> orderEntryIds_;

struct sortCampaignsByStartPeriod
{
	bool operator()(FATPcampaignAppData * campaign1,
		FATPcampaignAppData * campaign2) const
	{
		if (campaign1->getStartPeriod() == campaign2->getStartPeriod())
		{
			return (campaign1->getCampaignName() < campaign2->getCampaignName());
		}
		else
		{
			return (campaign1->getStartPeriod() < campaign2->getStartPeriod());
		};
	}
};


struct sortOrderEntriesByImportance
{
	bool operator()(FATPorderEntryAppData * order1,
		FATPorderEntryAppData * order2) const
	{
		if (order1->getImportance() == order2->getImportance())
		{
			return (order1->getOrderEntryId() < order2->getOrderEntryId());
		}
		else
		{
			if ((order1->getImportance() <= 0)  && (order2 ->getImportance() > 0))
			{
				return(false);
			}
			else
			{
				if ((order1->getImportance() > 0)  && (order2 ->getImportance() <= 0))
				{
					return (true);
				}
				else
				{
					return (order1->getImportance() < order2->getImportance());
				};
			};
		};
	};
};


	std::set<FATPcampaignAppData *, sortCampaignsByStartPeriod> sortedCampaignNames_;

	std::map<std::string,FATPvectorString> campsByTypes_;

};
#endif
@


1.46
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d8 3
d13 2
d19 12
@


1.45
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d62 4
a65 2
  float getOrderEntryCoilQty( const std::string & orderId )const;  
  int getOrderEntryDesiredPeriod( const std::string & orderId )const;  
@


1.44
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d103 2
a104 1
  float getOrderEntryCoilAtpQty(const std::string & orderId )const;
d107 2
a108 1
  std::vector<float> getOrderEntryCoilAtpVector(const std::string & orderId)const;
d130 2
a131 1
	const FATPvectorFloat & consRates);
@


1.43
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d97 2
a98 1
  int getOrderEntryAtpPeriod(const std::string & orderId )const;
d115 2
a116 1
	  const FATPvectorFloat & consRates );
@


1.42
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d5 1
a5 2
#include "fatpException.h "

@


1.41
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d5 1
@


1.40
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d34 2
a35 2
  float getCampaignExcessCapacityConsumed(const std::string & campaignName) const
	  throw(FATPException);
d64 4
a67 2
  int getOrderEntryImportance( const std::string & orderId )const;
  int getOrderEntryNRecipes( const std::string & orderId )const;
d115 2
a116 1
  void addOrderEntryRecipe( const std::string & orderId, const FATPvectorString & recipe );
d120 2
a121 1
    const FATPvectorString & campaignTypes);
@


1.39
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d36 2
a37 1
  std::string getCampaignType(const std::string & campaignName) const;
d155 2
a156 1
	inline void CheckIfCampExists(const std::string & campaignName) const;
d158 2
a159 1
	inline void CheckIfOrderEntryExists(const std::string & orderId) const;
@


1.38
log
@The code does not compile on Harmonym, trying to fix that...
@
text
@d28 8
a35 4
  int getCampaignStartPeriod   (const std::string & campaignName) const;
  int getCampaignDuration   (const std::string & campaignName) const;
  float getCampaignExcessCapacity (const std::string & campaignName) const;
  float getCampaignExcessCapacityConsumed(const std::string & campaignName) const;
@


1.37
log
@D O N E!
Errors handled and tested.
Shortage Shedule debugged, fixed and tested.
I think this version of FLSATP can be considered ready.
@
text
@d15 8
a22 4
  void setCampaignStartPeriod   (const std::string & campaignName, int startPeriod );
  void setCampaignDuration   (const std::string & campaignName, int duration );
  void setCampaignExcessCapacity   (const std::string & campaignName, float time );
  void setCampaignType (const std::string & campaignName, const std::string & type );
d48 6
a53 3
  void setOrderEntryCoilQty( const std::string & orderId, float qty );  
  void setOrderEntryDesiredPeriod( const std::string & orderId, int date ); 
  void setOrderEntryImportance( const std::string & orderId, int impt );
d69 2
a70 1
	  std::vector<float> & capacitiesConsumed)const;
d81 2
a82 1
	  std::vector<float> & capacityShortages )const;
@


1.36
log
@I have done some changes to
getOrderEntryCampaignShortages
method and I think now it might be doing what it is supposed to be doing.
But it is not tested at all (code runs, bnut that's it), I'll test it ASAP.
Exceptions still under construction - no changes in that since the last version.
@
text
@d68 1
a68 1
  //it returns 0 if there is such possibility, and returns 1 if it canot be done
@


1.35
log
@FATPException class added and tested. Still needs a second look at.
Not yet being used by other parts of code.
Application still fully functional.
More modifications and comments will be added soon.
@
text
@d56 4
a59 1
  
d64 7
a70 6
  
  void getOrderEntryShortage (const std::string & orderId,
	  std::vector<std::string> & campaignsNamesList,
	  std::vector<FATPvectorFloat> & shortageVolList);
  
  void getOrderEntryCampaignShortages(
@


1.34
log
@J P's method added to the code.
Variable names changed.
Minor changes.
No comments yet
@
text
@d55 2
d58 2
a59 2
	  std::vector<std::string> & campaignsNamesList,
	  std::vector<float> & peggedVolList)const;
@


1.33
log
@Now the negative priorities are being handled in the right way.
Some cleaning-up of the code.
Comments fixed, minor changes.
@
text
@d55 1
a55 1
  int getOrderEntryUsedCampaigns (const std::string & orderId,
d57 1
a57 2
	  std::vector<float> & peggedVolList);

d59 2
a60 1
  int getOrderEntryShortage (const std::string & orderId,
d63 6
@


1.32
log
@getOrderEntryShortage method has been added.
It is NOTgiving the correct answer, some adjustments in the WIT
model must be done.
It is not properly tested yet.
@
text
@a165 1
//negative importances must be handled -TBD ASAP
d177 15
a191 1
			return (order1->getImportance() < order2->getImportance());
d193 1
a193 1
	}
@


1.31
log
@Pegging improved and tested (asserts added).
@
text
@d59 5
@


1.30
log
@Pegging up and running!
Some more tests probably should be done in a nearby future
to check if it really works fine, but it seems to.
The "campaignExists" method has been fixed - when it was given a name of
a part of an order it was saying YES! :-)
@
text
@d56 1
a56 2
	  std::vector<std::string> & partNameList,
	  std::vector<int>   & periodList,
@


1.29
log
@Finishing touches.
Some error handling.
Some comments fixed.
Ready for April 6 presentation!
@
text
@d55 5
@


1.28
log
@A failed attempt to use witIncHeurAlloc.
I have produced something that I expected to work, but it does not.
The code still runs, but fails on the assertions.
@
text
@d17 1
a17 1
  void setCampaignExcessCapacity   (const std::string & campaignName, float coils );
d119 5
@


1.27
log
@Mulitiple StartPeriod changes handled.
Removed unnecessary bool campsByTypesBuilt variable.
Many changes in comments.
Some couts changed into asserts, but some still have to be changed.
Some test cases added
@
text
@a5 13
// How do implement these things?? 
// Pure virtual functions are the only solution I can think of
// but it cannot be that complicated... GMS 

#if 0
struct ltstr
{
	bool operator()(const std::string & campaignName1, const std::string & campaignName2) const
	{
		return FATPproblem::compareCampaigns(campaignName1, campaignName2) < 0;
	}
};
#endif
d9 1
a9 1
  
d140 8
a147 3
	if (campaign1->getStartPeriod() == campaign2->getStartPeriod())
	{
		return (campaign1->getCampaignName() < campaign2->getCampaignName());
d149 8
a156 1
	else
d158 8
a165 2
		return (campaign1->getStartPeriod() < campaign2->getStartPeriod());
	};
d168 1
@


1.26
log
@I forgot to include campsByTypes_ in the assignment operator
Now I think all is fine.
@
text
@d148 1
a148 1
struct ltstr
d164 1
a164 1
	std::set<FATPcampaignAppData *, ltstr> sortedCampaignNames_;
a167 2
	// tells us if campsByTypes has already been built - very inelegant! :-(
	bool campsByTypesNotbuilt_;
@


1.25
log
@Algorithms are now efficient, so this is more or less a final version for the time
being - I can't think of anything else before we meet with Jayant.
Test cases has been added, all seems to be fine.
(unless I overlooked something)
A very ugly bool indicator has been added to the private part of the
FATPproblem class - is there a way of avoiding it?
@
text
@a163 1
//NOT yet properly implemented in the assignment operator and copy constructor	
a165 1
	// Not finally handled by the constructor, destructor etc. yet - TBD ASAP
@


1.24
log
@Now the list is sorted! :-))))))))
All seems to work fine, although still a lot has to be done, constructors etc.
Also the algorithm for translating types to camps is now far from
being optimal, most of the changes were supposed
to make the sorted map ONCE, but now it ias being made every time, just to make things run.
I think I know how to fix it.
@
text
@a143 19

#if 0
	<<<<<<< fatpProblem.h

=======
  void buildRecipe(
            const FATPvectorString & campaignTypes, 
            const std::map<std::string,FATPvectorString> & typeToCamps,
            FATPvectorStringConstIterator ctIt, 
            FATPvectorStringConstIterator cIt, 
            const std::string & orderId,
            FATPvectorString recipe);

  // presolve
  void presolve();
>>>>>>> 1.20

#endif

d169 3
@


1.23
log
@The method addOrderEntryRecipesByCampaignType
now has three parameters, the last one is a list of consumption rates
(which depend only on camapign type, so it is okay I think).
There is also a 2 parameter version, that sets cr=1 by default.
I have added a test case and it works fine.
LIne 944 - added a comment, I think we get a wrong answer, campaigns
are NOT feasible, so nothing should be produced. On the other hand, this
cannot happen when we specify campaign TYPES, so maybe
it is okay when we can "override" the campaign start period violation rule
by giving names explicitly?
@
text
@d35 1
d42 1
d166 22
a187 1
	
@


1.22
log
@no message
@
text
@d91 4
d97 2
a98 1
    const FATPvectorString & campaignTypes);
d136 2
a137 1
		const std::vector<FATPvectorString> &typeToCamps);
@


1.21
log
@Implemented the methods for converting campaign types
into campaigns, some testing, changes in comments etc.
Fixed the bug detected by J.P.'s test case.
@
text
@d131 1
a131 1
		std::map<int,FATPvectorString> &typeToCamps);
@


1.20
log
@added method getOrderEntryNRecipes.
Used method to better test addOrderEntryRecipesByCampaignType.
@
text
@d6 13
d35 1
d43 5
a47 1
  bool pairOfCampaignsIsFeasible(const std::string & firstCampaignName,
d50 1
d122 17
d140 1
d151 1
d153 1
d155 4
a158 8

  void gutsOfCopy( const FATPproblem& source );
  void gutsOfDestructor();

  std::set<std::string> campaignNames_;
  std::set<std::string> orderEntryIds_;
  

a159 2


@


1.19
log
@implemented addOrderEntryRecipesByCampaignType
@
text
@d45 1
@


1.18
log
@Added the method
checkIfPairOfCampaignsIsFeasible
to the class FATPproblem
untested yet.
Some comments etc.
@
text
@d29 1
a29 1
  bool checkIfPairOfCampaignsIsFeasible(const std::string & firstCampaignName,
d102 8
@


1.17
log
@added some commented out code
@
text
@d28 4
a31 1
  
@


1.16
log
@Added methods for campaignType to FATP class.
@
text
@d67 4
a70 1

@


1.15
log
@Added consumpution rate to orderEntry appData.
Not yet setting consumption rate on bom arc
@
text
@d18 1
d26 1
@


1.14
log
@The method returning the vector of Atp values for OrderEntry has been added.
@
text
@d62 2
@


1.13
log
@Here is a version that works, but I want to do it in another way, so I commit
it just in case I mess things up.
@
text
@a3 1

a5 1
typedef float * tabFloat;
d54 1
a54 1
  void getOrderEntryCoilAtpVector(const std::string & orderId,tabFloat& atpQtyVector )const;
@


1.12
log
@added method
  float getOrderEntryCoilAtpQty(const std::string & orderId )const;
test method updated to use this new method
@
text
@d7 2
a25 2

  // Not yet implemented
d43 1
d47 1
d53 5
a57 1
  float getOrderEntryCoilAtpQty(const std::string & orderId )const; 
@


1.11
log
@Added the getOrderEntryAtpPeriod method and tested it and I think it works fine.
@
text
@d42 10
a51 1
  int getOrderEntryAtpPeriod(const std::string & orderId )const; 
@


1.10
log
@fixed up constructors
@
text
@d33 2
a34 2
  void setOrderEntryCoilQty( const std::string & orderId, float qty );  //tbd
  void setOrderEntryDesiredPeriod( const std::string & orderId, int date ); //tbd
d38 3
a40 3
  void getOrderEntryIds( std::vector<std::string> & orderEntryIds )const; //tbd
  float getOrderEntryCoilQty( const std::string & orderId )const;  //tbd
  int getOrderEntryDesiredPeriod( const std::string & orderId )const;  //tbd
d42 1
@


1.9
log
@added method addOrderEntryRecipe
@
text
@d45 1
a45 1
  // A recipe is the sequence on campaigns that can be used to 
@


1.8
log
@I have fixed some terminology inconsequences (changed orderEntryNames to
orderEntryIds.
I have added a code in the presolve method for initializing order list.
The last thing is not tested. The rest seems to work fine, unless I have overlooked something.
@
text
@d43 6
@


1.7
log
@finished implementing campaign methods.
implemented presolve for setting campaign's supplyVol
fixed type problem in campaignAppData
@
text
@d36 1
a36 1
  bool orderExists(const std::string & orderName)const;
d38 1
a38 1
  void getOrderEntryNames( std::vector<std::string> & orderEntryNames )const; //tbd
d82 1
@


1.6
log
@no message
@
text
@d17 1
a17 1
  void setCampaignExtraCapacity   (const std::string & campaignName, float coils );
d23 4
a26 2
  float getCampaignExtraCapacity (const std::string & campaignName) const;
  float getCampaignExtraCapacityConsumed(const std::string & campaignName) const;
d33 2
a34 2
  void setOrderEntryCoilQty( const std::string & orderId, float qty );
  void setOrderEntryDesiredPeriod( const std::string & orderId, int date );
d38 4
a41 1
  int getOrderEntryImportance( const std::string & orderId );
@


1.5
log
@added method prototype to header - conflict resolved
@
text
@d19 1
a19 1
  bool compaignExists    (const std::string & campaignName)const;
d30 8
a37 1
  void addOrder( const std::string & orderId );
@


1.4
log
@added some more comments to demonstrate how cvs works
@
text
@d28 1
a28 1
  // Methods for order.
d30 1
@


1.3
log
@added some more comments
@
text
@d28 1
a28 1
  // Methods for orders.
@


1.2
log
@added comment to header file
@
text
@d31 4
@


1.1
log
@Initial revision
@
text
@d26 5
@


1.1.1.1
log
@no message
@
text
@@

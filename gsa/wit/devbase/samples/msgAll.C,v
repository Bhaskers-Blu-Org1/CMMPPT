head	1.127;
access;
symbols
	EndRw-branch:1.22.0.4
	Root-of-EndRw:1.22
	rwToStl:1.22.0.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.127
date	2011.08.25.23.30.12;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2011.02.28.18.51.08;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2011.02.07.15.46.29;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2011.02.03.19.02.44;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.26.18.46.58;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2010.08.17.22.25.17;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2010.08.03.23.42.29;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2010.06.24.18.20.20;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.22.20.48.00;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2010.03.16.21.22.24;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2010.03.03.21.43.48;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2010.03.03.20.12.19;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2010.02.05.20.44.41;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2010.02.05.19.36.00;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.17.19.30.30;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2009.11.13.19.00.59;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2009.11.12.23.28.30;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2009.11.12.20.04.20;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2009.10.08.20.41.16;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2009.06.09.18.48.32;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2008.12.08.15.54.14;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2008.03.03.23.01.43;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2008.01.21.21.47.57;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.22.19.59.16;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.02.22.30.24;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.09.07.20.10.59;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.08.29.16.28.13;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.08.24.21.12.54;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.16.18.08.52;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.21.15.20.29;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.18.23.16.47;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.17.20.05.39;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.17.17.59.53;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.04.14.42.01;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.04.30.20.10.43;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.24.21.18.26;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.23.21.03.31;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.23.20.28.41;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.20.22.21.44;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.20.20.51.33;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.16.17.41.49;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.11.22.45.45;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.04.11.21.01.44;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.11.20.29.06;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.11.20.15.39;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.22.23.08.40;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.22.22.03.55;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.28.22.05.56;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.12.28.16.39.47;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.12.06.19.53.07;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.12.01.21.36.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.12.01.19.55.41;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.17.18.33.05;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.17.16.58.03;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.10.12.20.48.50;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.12.19.44.20;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.12.16.02.06;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.10.19.11.20;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2006.10.10.14.27.30;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.10.02.22.12.10;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.09.15.23.10.02;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.09.15.22.01.45;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.18.18.42.51;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.17.17.39.14;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.02.16.12.37;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.27.23.04.34;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.26.20.37.25;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.17.22.42.13;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.27.23.03.51;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.27.18.51.04;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.16.19.33.47;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.16.16.53.19;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.19.14.50.35;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.25.21.58.53;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.14.18.17.17;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.06.21.28.43;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.13.22.12.04;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.13.17.52.03;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.08.18.41.14;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.17.17.33.00;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.31.15.38.46;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.30.22.12.15;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.30.20.24.24;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.29.22.31.29;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.29.20.40.08;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.16.17.01.47;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.04.00.02.11;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.21.23.04.03;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.18.19.29.56;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.16.17.43.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.23.21.01.29;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.11.16.36.42;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.27.22.46.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.18.21.54.53;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.19.23.27.31;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.06.21.14.12;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.31.23.19.55;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.31.20.57.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.31.16.39.52;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.06.21.05.31;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.10.01.09.05;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.10.01.04.30;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.26.18.36.03;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.24.22.53.33;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.23.20.46.37;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.10.19.22.35;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.30.21.38.22;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.29.19.11.32;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.22.14.57.22;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.25.17.45.44;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.25.21.49.22;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.25.19.16.10;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.24.20.07.23;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.08.19.44.47;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.05.20.55.00;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.03.18.56.33;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.28.21.44.35;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.06.17.32.03;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.03.18.41.42;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.30.18.40.34;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.28.00.49.53;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.17.20.03.39;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.13.21.05.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.18.15;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.00.19.01;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.08.21.58.29;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.33.17;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.33.17;	author wit;	state Exp;
branches;
next	;


desc
@@


1.127
log
@Revisions for the removal of COIN from WIT.
@
text
@//------------------------------------------------------------------------------
// Source File: "msgAll.C".
//
// A WIT application program whose purpose is to test WIT's issuing of messages.
// This program makes whatever WIT API function calls are necessary
// to cause WIT to issue each of its messages for which the WIT internal
// attribute "WitMsg::testable" is TRUE, and then verifies that it has done so,
// by calling witListUnissuedMsgs, which lists the testable messages that
// weren't issued.
//
// Note: For convenience, this program intentionally leaks memory.
//------------------------------------------------------------------------------

#include <wit.h>

#include <stdlib.h>
#include <string.h>

//------------------------------------------------------------------------------

void           setUpMsgs         (WitRun *);
void           testMainMsgs      (WitRun *);
void           testPipMsgs       (WitRun *);
void           testExtOptMsgs    (WitRun *);
void           testCopyObjMsgs   (WitRun *);
void           testStochMsgs     (WitRun *);
void           testUhsMsgs       (WitRun *);
void           testMultiObjMsgs  (WitRun *);
void           checkUnissuedMsgs (WitRun *);

float *        vector            (float);
float *        vector            (float, float, float, float);
int *          vector            (int, int, int, int);
const char * * vector            (const char *);
void           prtRemove         (const char *);

//------------------------------------------------------------------------------

int main (int argc, char * argv[])
   {
   WitRun * theWitRun;

   witNewRun           (& theWitRun);

   setUpMsgs             (theWitRun);
   testMainMsgs          (theWitRun);
   testUhsMsgs           (theWitRun);
   testMultiObjMsgs      (theWitRun);
   checkUnissuedMsgs     (theWitRun);
   witDeleteRun          (theWitRun);
   }

//------------------------------------------------------------------------------
// testMainMsgs
//
// Sets up the messages.
// Verifies that the file name can be changed without crashing.
//------------------------------------------------------------------------------

void setUpMsgs (WitRun * theWitRun)
   {
   witSetMesgFileName    (theWitRun, WitFALSE, "msgAll-temp.log");
   witSetMesgFileName    (theWitRun, WitFALSE, WitSTDOUT);

   witSetMesgPrintNumber (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 704, WitFALSE);
   }

//------------------------------------------------------------------------------
// testMainMsgs
//
// Tests most of the messages.
//------------------------------------------------------------------------------

void testMainMsgs (WitRun * theWitRun)
   {
   witBoolean theBool;
   int        theInt;
   float      theFloat;
   double     theDouble;
   float *    theFloatSt;
   char * *   theCharStSt;
   float * *  theFloatStSt;
   int        lenLists;
   char * *   operationNameList;
   int *      execPeriodList;
   float *    peggedExecVolList;
   witAttr    objItrState;

   witSetMesgTimesPrint  (theWitRun, WitFALSE, 106,                UCHAR_MAX);
   witSetMesgTimesPrint  (theWitRun, WitFALSE,  82,                UCHAR_MAX);
   witSetMesgTimesPrint  (theWitRun, WitFALSE, WitSEVERE_MESSAGES, 1);

   witSetMesgPrintNumber (theWitRun, WitFALSE, WitSEVERE_MESSAGES, WitTRUE);

   witSetMesgStopRunning (theWitRun, WitFALSE, WitSEVERE_MESSAGES, WitTRUE);

   witInitialize                 (theWitRun);
   witSetTitle                   (theWitRun, "msgAll Data");
   witSetNPeriods                (theWitRun, 4);
   witSetWit34Compatible         (theWitRun, WitTRUE);
   witSetComputeCriticalList     (theWitRun, WitTRUE);
   witSetAccAfterSoftLB          (theWitRun, WitTRUE);
   witSetBuildWhenEmpty          (theWitRun, WitTRUE);
   witSetLocalBuildAhead         (theWitRun, WitTRUE);
   witSetLocalMultiExec          (theWitRun, WitTRUE);
   witSetTwoWayMultiExec         (theWitRun, WitTRUE);
   witSetMultiRoute              (theWitRun, WitTRUE);
   witSetPenExec                 (theWitRun, WitTRUE);
   witSetStockRealloc            (theWitRun, WitTRUE);
   witSetSkipFailures            (theWitRun, WitFALSE);
   witSetSelectionRecovery       (theWitRun, WitTRUE);
   witSetRespectStockSLBs        (theWitRun, WitTRUE);
   witSetExpCutoff               (theWitRun, 0.001);
   witSetPerfPegging             (theWitRun, WitTRUE);

   witGetAccelerated             (theWitRun, & theBool);
   witGetBuildWhenEmpty          (theWitRun, & theBool);
   witGetOutputPrecision         (theWitRun, & theInt);
   witGetExpCutoff               (theWitRun, & theFloat);
   witGetExpCutoffDbl            (theWitRun, & theDouble);

   witAddPart                    (theWitRun, "Mat", WitMATERIAL);
   witAddPart                    (theWitRun, "Cap", WitCAPACITY);
   witAddOperation               (theWitRun, "Opn");
   witAddBomEntry                (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry            (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry                (theWitRun, "Opn", "Mat");
   witAddBopEntry                (theWitRun, "Opn", "Mat");
   witAddDemand                  (theWitRun, "Mat", "Dem");
   witAddDemand                  (theWitRun, "Mat", "Dm2");
   witAddDemand                  (theWitRun, "Mat", "Dm3");
   witAddOperation               (theWitRun, "1234567890123");
   witAddPart                    (theWitRun, "Prd", WitPRODUCT);
   witAddPart                    (theWitRun, "Raw", WitRAW);

   witSetPartSupplyVol           (theWitRun, "Cap",        vector (2.0));
   witSetPartSupplyVol           (theWitRun, "Mat",        vector (1.0f, 0.0f,
                                                                   0.0f, 0.0f));
   witSetPartSupplyVol           (theWitRun, "Raw",        vector (1.0f, 0.0f,
                                                                   1.0f, 0.0f));
   witSetDemandDemandVol         (theWitRun, "Mat", "Dem", vector (30.0));
   witSetExpCutoff               (theWitRun,                        0.001);
   witSetPartBuildAsap           (theWitRun, "Mat",        WitTRUE);
   witSetPartBuildAheadLimit     (theWitRun, "Mat",        1);
   witSetPartBoundedLeadTimes    (theWitRun, "Mat",        WitTRUE);
   witSetPartStockBounds         (theWitRun, "Mat",        vector (0.0),
                                                           vector (10.0),
                                                           vector (10.0));
   witSetOperationExecBounds     (theWitRun, "Opn",        vector (0.0),
                                                           vector (0.0),
                                                           vector (100.0));
   witSetDemandCumShipBounds     (theWitRun, "Mat", "Dem", vector (0.0),
                                                           vector (0.0),
                                                           vector (100.0));
   witSetDemandPriority          (theWitRun, "Mat", "Dem", vector (5, 5, 5, 5));
   witSetDemandPriority          (theWitRun, "Mat", "Dm2", vector (1, 0, 0, 0));
   witSetDemandPriority          (theWitRun, "Mat", "Dm3", vector (1, 1, 0, 0));
   witSetSubsBomEntryExpAllowed  (theWitRun, "Opn", 0, 0,  WitTRUE);
   witSetBopEntryExpAllowed      (theWitRun, "Opn", 0,     WitTRUE);
   witSetBopEntryProdRate        (theWitRun, "Opn", 0,     0.007);
   witSetPartObj1ScrapCost       (theWitRun, "Mat",        vector (-1.0));
   witSetOperationExecCost       (theWitRun, "Opn",        vector (-1.0));
   witSetSubsBomEntrySubCost     (theWitRun, "Opn", 0, 0,  vector (-1.0));
   witSetWit34Compatible         (theWitRun,               WitTRUE);

   witSetOperationTwoLevelLotSizes
                                 (theWitRun, "Opn",        WitTRUE);
   witSetOperationMinLotSize     (theWitRun, "Opn",        vector (20.0));
   witSetOperationIncLotSize     (theWitRun, "Opn",        vector (1.0));
   witSetOperationLotSize2Thresh (theWitRun, "Opn",        vector (50.0));
   witSetOperationMinLotSize2    (theWitRun, "Opn",        vector (100.0));
   witSetOperationIncLotSize2    (theWitRun, "Opn",        vector (20.0));

   witSetOperationYieldRate      (theWitRun, "Opn",        
                                  vector (1.0f, 1.0f, .05f, 1.0f));
   witSetPartCycleTime           (theWitRun, "Prd",        vector (10.0));
   witSetBomEntryUsageTime       (theWitRun, "Opn", 0,     0.0);
   witSetBomEntryUsageRate       (theWitRun, "Opn", 0,    -1.0);
   witSetBomEntryUsageRate       (theWitRun, "Opn", 0,     1.0);
   witSetBomEntryFallout         (theWitRun, "Opn", 0,     2);
   witSetPartSelForDel           (theWitRun, "Mat",        WitTRUE);
   witSetOperationSelForDel      (theWitRun, "Opn",        WitTRUE);

   witSetPartPropRtg (
      theWitRun,
      "Mat",
      vector (WitFALSE, WitFALSE, WitTRUE, WitFALSE));

   witSetPartPropRtg (
      theWitRun,
      "Cap",
      vector (WitTRUE, WitFALSE, WitFALSE, WitTRUE));

   witSetBomEntryPropRtg (
      theWitRun,
      "Opn",
      0,
      vector (WitTRUE, WitTRUE, WitTRUE, WitTRUE));

   witSetCplexParSpecName    (theWitRun, "LPMETHOD");
   witSetCplexParSpecIntVal  (theWitRun, 4);

   witSetCplexParSpecName    (theWitRun, "TILIM");
   witSetCplexParSpecDblVal  (theWitRun, 1.5);

   witGetPartExists          (theWitRun, "Mat",    & theBool);
   witGetPartExists          (theWitRun, "XXX",    & theBool);
   witGetOperationExists     (theWitRun, "Opn",    & theBool);
   witGetOperationExists     (theWitRun, "YYY",    & theBool);
   witGetPartNBomEntries     (theWitRun, "Cap",    & theInt);
   witGetPartBuildAheadLimit (theWitRun, "Mat",    & theInt);
   witGetPartCycleTime       (theWitRun, "Prd",    & theFloatSt);
   witGetBomEntryUsageTime   (theWitRun, "Opn", 0, & theFloat);
   witGetBomEntryFallout     (theWitRun, "Opn", 0, & theInt);
   witGetPartObj1ScrapCost   (theWitRun, "Mat",    & theFloatSt);

   while (WitTRUE)
      {
      witAdvanceObjItr  (theWitRun);

      witGetObjItrState (theWitRun, & objItrState);

      if (objItrState == WitINACTIVE)
         break;
      }

   witGetDemandExecVolPegging (
      theWitRun,
      "Mat",
      "Dem",
      2,
      & lenLists,
      & operationNameList,
      & execPeriodList,
      & peggedExecVolList);

   witStartHeurAlloc         (theWitRun);
   witIncHeurAllocTwme       (theWitRun, "Mat", "Dem", 0, 1.0, & theFloat, 
                                         WitTRUE);

   witEqHeurAllocTwme        (theWitRun,
      4,
      vector ("Mat"),
      vector ("Dem"),
      vector (2, 3, 1, 0),
      vector (2.0f, 3.0f, 2.0f, 3.0f),
      & theFloatSt,
      vector (WitTRUE, WitFALSE, WitFALSE, WitTRUE));

   witFinishHeurAlloc        (theWitRun);

   witGetFocusShortageVol    (theWitRun,
      & theInt,
      & theCharStSt,
      & theFloatStSt);

   witOptImplode             (theWitRun);

   prtRemove                 ("solver.log");

   witMrp                    (theWitRun);

   witSetOperationExecVol    (theWitRun, "Opn",        vector (10.0));
   witSetSubsBomEntrySubVol  (theWitRun, "Opn", 0, 0,  vector (22.7));
   witSetDemandShipVol       (theWitRun, "Mat", "Dem", vector (10.0));
   witSetHighPrecisionWD     (theWitRun, WitTRUE);
   witWriteData              (theWitRun, WitSTDOUT);
   witSetHighPrecisionWD     (theWitRun, WitFALSE);
   witWriteData              (theWitRun, WitSTDOUT);
   witDisplayData            (theWitRun, WitSTDOUT);
   witWriteExecSched         (theWitRun, WitSTDOUT, WitBSV);
   witWriteExecSched         (theWitRun, WitSTDOUT, WitCSV);
   witWriteProdSched         (theWitRun, WitSTDOUT, WitBSV);
   witWriteShipSched         (theWitRun, WitSTDOUT, WitBSV);
   witWriteShipSched         (theWitRun, WitSTDOUT, WitCSV);
   witWriteReqSched          (theWitRun, WitSTDOUT, WitBSV);
   witWriteReqSched          (theWitRun, WitSTDOUT, WitCSV);
   witWriteCriticalList      (theWitRun, WitSTDOUT, WitBSV, 10);
   witWriteCriticalList      (theWitRun, WitSTDOUT, WitCSV, 10);
   witDisplayData            (theWitRun, WitSTDOUT);
   witSetAccAfterOptImp      (theWitRun, WitTRUE);

   witOptImplode             (theWitRun);
   witOptImplode             (theWitRun);

   witSetAccAfterOptImp      (theWitRun, WitFALSE);

   prtRemove                 ("solver.log");

   witSetAccAfterOptImp      (theWitRun, WitTRUE);

   witSetOptInitMethod       (theWitRun, WitHEUR_OPT_INIT_METHOD);

   witOptImplode             (theWitRun);

   witSetDemandShipVol       (theWitRun, "Mat", "Dem", vector (20.0));

   witEvalObjectives         (theWitRun);

   witSetAccAfterOptImp      (theWitRun, WitFALSE);
   prtRemove                 ("solver.log");

   witSetComputeCriticalList (theWitRun,        WitFALSE);
   witSetMipMode             (theWitRun,        WitTRUE);
   witSetOperationIntExecVols(theWitRun, "Opn", WitTRUE); 

   witOptImplode             (theWitRun);

   witSetMipMode             (theWitRun,        WitFALSE);

   witSetMultiRoute          (theWitRun,        WitFALSE);
   witSetSelSplit            (theWitRun,        WitTRUE);
   witSetStockRealloc        (theWitRun,        WitFALSE);
   witSetStockReallocation   (theWitRun,        WitTRUE);
   witSetPartSingleSource    (theWitRun, "Mat", WitTRUE);
   witSetPartPropRouting     (theWitRun, "Cap", WitTRUE);
   witSetPipSeqFromHeur      (theWitRun,        WitTRUE);

   witHeurImplode            (theWitRun);

   testPipMsgs               (theWitRun);

   witSetMultiRoute          (theWitRun,        WitTRUE);
   witSetPenExec             (theWitRun,        WitFALSE);

   witHeurImplode            (theWitRun);

   witSetPartSingleSource    (theWitRun, "Mat", WitFALSE);
   witSetSelSplit            (theWitRun,        WitFALSE);
   witSetPenExec             (theWitRun,        WitTRUE);
   witSetPgdCritListMode     (theWitRun,        WitTRUE);

   witSetUserHeurStart       (theWitRun,        WitTRUE);

   witSetOperationMinLotSize (theWitRun, "Opn", vector (0.0));
   witSetOperationExecVol    (theWitRun, "Opn", vector (1.0));

   witHeurImplode            (theWitRun);

   witSetUserHeurStart       (theWitRun,        WitFALSE);

   witSetTieBreakPropRt      (theWitRun,        WitTRUE);

   witHeurImplode            (theWitRun);

   witPurgeData              (theWitRun);

   witSetMesgPrintNumber     (theWitRun,
                              WitFALSE,
                              WitINFORMATIONAL_MESSAGES,
                              WitFALSE);

   witPurgeData              (theWitRun);

   witSetMesgPrintNumber     (theWitRun,
                              WitFALSE,
                              WitINFORMATIONAL_MESSAGES,
                              WitTRUE);

   testExtOptMsgs            (theWitRun);

   testCopyObjMsgs           (theWitRun);

   testStochMsgs             (theWitRun);
   }

//------------------------------------------------------------------------------
// testPipMsgs
//
// Tests messages for PIP.
//------------------------------------------------------------------------------

void testPipMsgs (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * demandNameList;
   int *    shipPerList;   
   float *  incShipVolList;
   int      theIdx;

   witGetPipSeq (
        theWitRun,
      & lenLists,
      & partNameList,
      & demandNameList,
      & shipPerList,
      & incShipVolList);

   witClearPipSeq (theWitRun);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witAppendToPipSeq (
         theWitRun,
         partNameList  [theIdx],
         demandNameList[theIdx],
         shipPerList   [theIdx],
         incShipVolList[theIdx] * 2);

   witSetNewPipPggOrder (theWitRun, WitTRUE);
   witWriteData         (theWitRun, WitSTDOUT);
   witDisplayData       (theWitRun, WitSTDOUT);
   witBuildPip          (theWitRun);
   witSetNewPipPggOrder (theWitRun, WitFALSE);
   witBuildPip          (theWitRun);
   }

//------------------------------------------------------------------------------
// testExtOptMsgs
//
// Tests messages for ext opt implosion.
//------------------------------------------------------------------------------

void testExtOptMsgs (WitRun * theWitRun)
   {
   int      numcols;
   int      numrows;
   int *    start;
   int *    index;
   double * value;
   double * collb;
   double * colub;
   double * obj;
   double * rowlb;
   double * rowub;
   int      scrapVarIndex;

   witStartExtOpt          (theWitRun);

   witGetExtOptLpProbDbl   (theWitRun,
      & numcols,
      & numrows,
      & start,
      & index,
      & value,
      & collb,
      & colub,
      & obj,
      & rowlb,
      & rowub);

   collb[2] -= 4.7;

   witGetPartScrapVarIndex (theWitRun, "Cap", 2, & scrapVarIndex);
   witSetExtOptSolnDbl     (theWitRun, collb);
   witFinishExtOpt         (theWitRun);
   witStartExtOpt          (theWitRun);
   witShutDownExtOpt       (theWitRun);
   }

//------------------------------------------------------------------------------
// testCopyObjMsgs
//
// Tests messages for witCopy<Object>Data.
//------------------------------------------------------------------------------

void testCopyObjMsgs (WitRun * theWitRun)
   {
   WitRun * theWitRun2;

   witCopyPartData       (theWitRun, "Raw",theWitRun, "Prd");

   witNewRun           (& theWitRun2);
   witInitialize         (theWitRun2);
   witSetNPeriods        (theWitRun2, 4);
   witSetWit34Compatible (theWitRun2, WitTRUE);
   witAddPart            (theWitRun2, "A", WitMATERIAL);

   witCopyPartData       (theWitRun, "Prd", theWitRun2, "A");

   witDeleteRun          (theWitRun2);
   }

//------------------------------------------------------------------------------
// testStochMsgs
//
// Tests messages for stochastic implosion.
//------------------------------------------------------------------------------

void testStochMsgs (WitRun * theWitRun)
   {
   witBoolean devMode;

   witGetDevMode              (theWitRun, & devMode);

   if (! devMode)
      return;

   witSetWit34Compatible      (theWitRun, WitFALSE);
   witSetAccAfterSoftLB       (theWitRun, WitFALSE);

   witSetStageByObject        (theWitRun, WitTRUE);
   witSetStochMode            (theWitRun, WitTRUE);

   witSetPartObjectStage      (theWitRun, "Cap",           1);
   witSetPartObjectStage      (theWitRun, "Raw",           1);
   witSetPartObjectStage      (theWitRun, "Prd",           1);
   witSetOperationObjectStage (theWitRun, "1234567890123", 1);
   witSetOperationObjectStage (theWitRun, "Prd",           1);

   witSetProbability          (theWitRun, 1.0);
   witWriteData               (theWitRun, WitSTDOUT);
   witDisplayData             (theWitRun, WitSTDOUT);
   witStochImplode            (theWitRun);
   witSetStochMode            (theWitRun, WitFALSE);

   witSetStageByObject        (theWitRun, WitFALSE);
   witSetStochMode            (theWitRun, WitTRUE);
   witSetPeriodStage          (theWitRun, vector (0, 0, 1, 1));
   witDisplayData             (theWitRun, WitSTDOUT);
   witSetStochMode            (theWitRun, WitFALSE);
   }

//------------------------------------------------------------------------------
// testUhsMsgs
//
// Tests messages for UHS.
//------------------------------------------------------------------------------

void testUhsMsgs (WitRun * theWitRun)
   {
   witInitialize             (theWitRun);
   witSetNPeriods            (theWitRun, 1);
   witSetUserHeurStart       (theWitRun, true);

   witAddPart                (theWitRun, "A", WitMATERIAL);
   witAddPart                (theWitRun, "B", WitMATERIAL);
   witAddOperation           (theWitRun, "C");
   witAddBomEntry            (theWitRun, "C","A");
   witAddSubsBomEntry        (theWitRun, "C", 0, "B");
   witAddPart                (theWitRun, "D", WitMATERIAL);
   witAddBopEntry            (theWitRun, "C", "D");
   witAddDemand              (theWitRun, "D", "E");

   witSetOperationIncLotSize (theWitRun, "C", vector (100));

   witSetOperationExecBounds (theWitRun, "C", NULL, NULL, vector (17));

   witSetPartSupplyVol       (theWitRun, "B", vector (20));

   witSetDemandDemandVol     (theWitRun, "D", "E", vector (30));

   witSetOperationExecVol    (theWitRun, "C", vector (20));

   witSetSubsBomEntrySubVol  (theWitRun, "C", 0,  0, vector (27));

   witSetDemandShipVol       (theWitRun, "D", "E", vector (45));

   witHeurImplode            (theWitRun);
   }

//------------------------------------------------------------------------------
// testMultiObjMsgs
//
// Tests messages for multiple objectives mode.
//------------------------------------------------------------------------------

void testMultiObjMsgs (WitRun * theWitRun)
   {
   float softLB[] = {10.0};

   witInitialize         (theWitRun);
   witSetNPeriods        (theWitRun,      1);
   witSetMultiObjMode    (theWitRun,      WitTRUE);
   witAddPart            (theWitRun, "A", WitMATERIAL);
   witSetPartStockBounds (theWitRun, "A", NULL, softLB, NULL);
   witDisplayData        (theWitRun,      WitSTDOUT);
   witOptImplode         (theWitRun);
   }

//------------------------------------------------------------------------------
// checkUnissuedMsgs
// In development mode, lists unissued messages.
//------------------------------------------------------------------------------

void checkUnissuedMsgs (WitRun * theWitRun)
   {
   witBoolean devMode;

   witInitialize (theWitRun);

   witGetDevMode (theWitRun, & devMode);

   if (! devMode)
      return;

   witSetMesgTimesPrint (theWitRun, WitFALSE, 98,  0);

   printf (
      "\n"
      "----------------------------------------"
      "----------------------------------------"
      "\n");

   witListUnissuedMsgs (theWitRun);
   }

//------------------------------------------------------------------------------
// Utility Functions
//------------------------------------------------------------------------------

float * vector (float theValue)
   {
   float * v = new float [4];

   v[0] = theValue;
   v[1] = theValue;
   v[2] = theValue;
   v[3] = theValue;

   return v;
   }

//------------------------------------------------------------------------------

float * vector (float v0, float v1, float v2, float v3)
   {
   float * v = new float [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

//------------------------------------------------------------------------------

int * vector (int v0, int v1, int v2, int v3)
   {
   int * v = new int [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

//------------------------------------------------------------------------------

const char * * vector (const char * theString)
   {
   const char * * theStrVec = new const char * [4];

   theStrVec[0] = theString;
   theStrVec[1] = theString;
   theStrVec[2] = theString;
   theStrVec[3] = theString;

   return theStrVec;
   }

//------------------------------------------------------------------------------
// prtRemove
//------------------------------------------------------------------------------

void prtRemove (const char * filename)
   {
   char cmd[100];

   printf (
      "\n"
      "File \"%s\":\n"
      "\n",
      filename);

   fflush (stdout);

   strcpy (cmd, "cat ");

   strcat (cmd, filename);

   system (cmd);

   remove (filename);
   }
@


1.126
log
@Revised the default values of coinSelected and cplexSelected.
@
text
@a282 1

d292 1
a292 1
   witSetOptInitMethod       (theWitRun, WitCRASH_OPT_INIT_METHOD);
d294 1
a294 1
   witSetAccAfterOptImp      (theWitRun, WitTRUE);
@


1.125
log
@CPLEX Parameters
@
text
@d308 1
@


1.124
log
@CPLEX Parameters
@
text
@d202 2
a203 2
   witSetCpxParSpecName      (theWitRun, "LPMETHOD");
   witSetCpxParSpecIntVal    (theWitRun, 4);
d205 2
a206 2
   witSetCpxParSpecName      (theWitRun, "TILIM");
   witSetCpxParSpecDblVal    (theWitRun, 1.5);
@


1.123
log
@CPLEX Parameters
@
text
@d202 2
a203 2
   witSetSpecCpxParName      (theWitRun, "CPX_PARAM_LPMETHOD");
   witSetSpecCpxParIntVal    (theWitRun, 4);
d205 2
a206 2
   witSetSpecCpxParName      (theWitRun, "CPX_PARAM_TILIM");
   witSetSpecCpxParDblVal    (theWitRun, 1.5);
@


1.122
log
@Lead Time Bounds
@
text
@d202 6
@


1.121
log
@Selection Recovery
@
text
@d112 1
d147 1
@


1.120
log
@Selection reuse
@
text
@d112 1
@


1.119
log
@Selection Reuse.
@
text
@a111 1
   witSetSelectionReuse          (theWitRun, WitTRUE);
@


1.118
log
@Multi-Obj Mode
@
text
@d112 1
@


1.117
log
@Made constraint violation messages testable.
@
text
@d553 9
a561 6
   witInitialize      (theWitRun);
   witSetNPeriods     (theWitRun, 1);
   witSetMultiObjMode (theWitRun, WitTRUE);
   witAddPart         (theWitRun, "A",      WitCAPACITY);
   witDisplayData     (theWitRun, WitSTDOUT);
   witOptImplode      (theWitRun);
@


1.116
log
@Reduced message 903 from severe to warning.
@
text
@d257 1
a257 1
   witSetSubsBomEntrySubVol  (theWitRun, "Opn", 0, 0,  vector (10.0));
@


1.115
log
@Multi-obj mode
@
text
@d435 2
@


1.114
log
@Multi-objectives mode
@
text
@d546 1
a546 1
// Tests messages for multi-objectives mode.
@


1.113
log
@Removing objective #2.
@
text
@d28 1
d48 1
d475 1
a475 1
   witGetDevMode          (theWitRun, & devMode);
d507 1
d544 16
@


1.112
log
@Removing objective #2.
@
text
@d71 1
a71 1
// Tests most of the messages; objChoice == 1.
@


1.111
log
@Removed some calls to obj2 API funcs.
@
text
@d140 1
a140 1
   witSetPartUnitCost            (theWitRun, "Mat",        2.0);
d243 5
a253 5
   witGetFocusShortageVol    (theWitRun,
      & theInt,
      & theCharStSt,
      & theFloatStSt);

d294 8
a302 1
   witSetComputeCriticalList (theWitRun,        WitFALSE);
@


1.110
log
@Removed calls to objective #2 API functions.
@
text
@d117 2
a118 2
   witGetCapCost                 (theWitRun, & theFloat);
   witGetCapCostDbl              (theWitRun, & theDouble);
@


1.109
log
@Revised for the removal of the multiThread attribute.
@
text
@a26 1
void           testObj2Msgs      (WitRun *);
a45 1
   testObj2Msgs          (theWitRun);
a496 34
// testObj2Msgs
//
// Test messages for objChoice == 2.
//------------------------------------------------------------------------------

void testObj2Msgs (WitRun * theWitRun)
   {
   witInitialize              (theWitRun);
   witSetNPeriods             (theWitRun, 4);
   witSetObjChoice            (theWitRun, 2);
   witSetMipMode              (theWitRun, WitTRUE);
   
   witAddPart                 (theWitRun, "Mat", WitMATERIAL);
   witAddPart                 (theWitRun, "Cap", WitCAPACITY);
   witAddOperation            (theWitRun, "Opn");
   witAddBomEntry             (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry         (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry             (theWitRun, "Opn", "Mat");
   witAddDemand               (theWitRun, "Mat", "Dem");

   witSetPartSupplyVol        (theWitRun, "Cap",        vector (10.0));
   witSetDemandDemandVol      (theWitRun, "Mat", "Dem", vector (10.0));
   witSetOperationIntExecVols (theWitRun, "Opn",        WitTRUE);
   witSetPartStockBounds      (theWitRun, "Mat",        NULL,
                                                        vector (10.0),
                                                        NULL);

   witOptImplode              (theWitRun);
   witDisplayData             (theWitRun, WitSTDOUT);

   prtRemove                  ("solver.log");
   }

//------------------------------------------------------------------------------
@


1.108
log
@Added a test for file name change.
@
text
@a120 1
   witGetMultiThread             (theWitRun, & theBool);
@


1.107
log
@Removed some calls that set mesgFileAccessMode to "w".
@
text
@d21 1
d45 1
a45 4
   witSetMesgPrintNumber (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 704, WitFALSE);

d56 17
d91 7
a97 24
   witSetMesgTimesPrint          (theWitRun,
      WitFALSE,
      106,
      UCHAR_MAX);

   witSetMesgTimesPrint          (theWitRun,
      WitFALSE,
      82,
      UCHAR_MAX);

   witSetMesgTimesPrint          (theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      1);

   witSetMesgPrintNumber         (theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitTRUE);

   witSetMesgStopRunning         (theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitTRUE);
@


1.106
log
@Stochastic Implosion
@
text
@d42 1
a42 1
   witNewRun              (& theWitRun);
d44 9
a52 11
   witSetMesgFileAccessMode (theWitRun, WitFALSE, "w");

   witSetMesgPrintNumber    (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber    (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber    (theWitRun, WitFALSE, 704, WitFALSE);

   testMainMsgs             (theWitRun);
   testObj2Msgs             (theWitRun);
   testUhsMsgs              (theWitRun);
   checkUnissuedMsgs        (theWitRun);
   witDeleteRun             (theWitRun);
d448 1
a448 1
   witCopyPartData          (theWitRun, "Raw",theWitRun, "Prd");
d450 5
a454 6
   witNewRun              (& theWitRun2);
   witSetMesgFileAccessMode (theWitRun2, WitFALSE, "w");
   witInitialize            (theWitRun2);
   witSetNPeriods           (theWitRun2, 4);
   witSetWit34Compatible    (theWitRun2, WitTRUE);
   witAddPart               (theWitRun2, "A", WitMATERIAL);
d456 1
a456 1
   witCopyPartData          (theWitRun, "Prd", theWitRun2, "A");
d458 1
a458 1
   witDeleteRun             (theWitRun2);
@


1.105
log
@Stochastic Implosion
@
text
@d496 6
@


1.104
log
@Stochastic Implosion
@
text
@d479 2
a480 2
   witSetWit34Compatible     (theWitRun, WitFALSE);
   witSetAccAfterSoftLB      (theWitRun, WitFALSE);
d482 2
a483 2
   witSetStageByObject       (theWitRun, WitTRUE);
   witSetStochMode           (theWitRun, WitTRUE);
d485 11
a495 11
   witSetPartStageIndex      (theWitRun, "Cap",           1);
   witSetPartStageIndex      (theWitRun, "Raw",           1);
   witSetPartStageIndex      (theWitRun, "Prd",           1);
   witSetOperationStageIndex (theWitRun, "1234567890123", 1);
   witSetOperationStageIndex (theWitRun, "Prd",           1);

   witSetProbability         (theWitRun, 1.0);
   witWriteData              (theWitRun, WitSTDOUT);
   witDisplayData            (theWitRun, WitSTDOUT);
   witStochImplode           (theWitRun);
   witSetStochMode           (theWitRun, WitFALSE);
@


1.103
log
@Stochastic Implosion
@
text
@d479 2
a480 2
   witSetWit34Compatible  (theWitRun, WitFALSE);
   witSetAccAfterSoftLB   (theWitRun, WitFALSE);
d482 2
a483 2
   witSetStageByObject    (theWitRun, WitTRUE);
   witSetStochMode        (theWitRun, WitTRUE);
d485 11
a495 11
   witSetPartStageNo      (theWitRun, "Cap",           1);
   witSetPartStageNo      (theWitRun, "Raw",           1);
   witSetPartStageNo      (theWitRun, "Prd",           1);
   witSetOperationStageNo (theWitRun, "1234567890123", 1);
   witSetOperationStageNo (theWitRun, "Prd",           1);

   witSetProbability      (theWitRun, 1.0);
   witWriteData           (theWitRun, WitSTDOUT);
   witDisplayData         (theWitRun, WitSTDOUT);
   witStochImplode        (theWitRun);
   witSetStochMode        (theWitRun, WitFALSE);
@


1.102
log
@Stochastic Implosion
@
text
@a481 1
   witInterpretDevCmd     (theWitRun, "Allow stochastic implosion.");
@


1.101
log
@Stochastic Implosion
@
text
@d523 3
@


1.100
log
@Stochastic Implosion
@
text
@d474 1
a474 1
   witGetDevMode                (theWitRun, & devMode);
d479 2
a480 2
   witSetWit34Compatible        (theWitRun, WitFALSE);
   witSetAccAfterSoftLB         (theWitRun, WitFALSE);
d482 15
a496 15
   witInterpretDevCmd           (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject          (theWitRun, WitTRUE);
   witSetStochMode              (theWitRun, WitTRUE);

   witSetPartRecourseStage      (theWitRun, "Cap",           WitTRUE);
   witSetPartRecourseStage      (theWitRun, "Raw",           WitTRUE);
   witSetPartRecourseStage      (theWitRun, "Prd",           WitTRUE);
   witSetOperationRecourseStage (theWitRun, "1234567890123", WitTRUE);
   witSetOperationRecourseStage (theWitRun, "Prd",           WitTRUE);

   witSetProbability            (theWitRun, 1.0);
   witWriteData                 (theWitRun, WitSTDOUT);
   witDisplayData               (theWitRun, WitSTDOUT);
   witStochImplode              (theWitRun);
   witSetStochMode              (theWitRun, WitFALSE);
@


1.99
log
@Changed the message file open mode to "w".
@
text
@d492 1
a492 1
   witSetScenarioProb           (theWitRun, 1.0);
@


1.98
log
@Stochastic Implosion
@
text
@d42 1
a42 1
   witNewRun           (& theWitRun);
d44 11
a54 9
   witSetMesgPrintNumber (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 704, WitFALSE);

   testMainMsgs          (theWitRun);
   testObj2Msgs          (theWitRun);
   testUhsMsgs           (theWitRun);
   checkUnissuedMsgs     (theWitRun);
   witDeleteRun          (theWitRun);
d450 1
a450 1
   witCopyPartData (theWitRun, "Raw",theWitRun, "Prd");
d452 6
a457 5
   witNewRun           (& theWitRun2);
   witInitialize         (theWitRun2);
   witSetNPeriods        (theWitRun2, 4);
   witSetWit34Compatible (theWitRun2, WitTRUE);
   witAddPart            (theWitRun2, "A", WitMATERIAL);
d459 1
a459 1
   witCopyPartData       (theWitRun, "Prd", theWitRun2, "A");
d461 1
a461 1
   witDeleteRun          (theWitRun2);
@


1.97
log
@Stochastic Implosion
@
text
@d481 1
a481 1
   witSetStochDataMode          (theWitRun, WitTRUE);
d493 1
a493 1
   witSetStochDataMode          (theWitRun, WitFALSE);
@


1.96
log
@Stochastic Implosion
@
text
@d489 1
a489 1
   witSetScenarioProb           (theWitRun, 0.2);
@


1.95
log
@Stochastic Implosion
@
text
@d471 1
a471 1
   witGetDevMode          (theWitRun, & devMode);
d476 2
a477 2
   witSetWit34Compatible (theWitRun, WitFALSE);
   witSetAccAfterSoftLB  (theWitRun, WitFALSE);
d479 15
a493 8
   witInterpretDevCmd    (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject   (theWitRun, WitTRUE);
   witSetStochDataMode   (theWitRun, WitTRUE);
   witSetScenarioProb    (theWitRun, 0.2);
   witWriteData          (theWitRun, WitSTDOUT);
   witDisplayData        (theWitRun, WitSTDOUT);
   witStochImplode       (theWitRun);
   witSetStochDataMode   (theWitRun, WitFALSE);
@


1.94
log
@Stochastic Implosion
@
text
@d482 1
a482 1
   witSetProbability     (theWitRun, 0.2);
@


1.93
log
@Stochastic Implosion
@
text
@d471 1
a471 1
   witGetDevMode        (theWitRun, & devMode);
d476 11
a486 8
   witInterpretDevCmd  (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject (theWitRun, WitTRUE);
   witSetStochDataMode (theWitRun, WitTRUE);
   witSetProbability   (theWitRun, 0.2);
   witWriteData        (theWitRun, WitSTDOUT);
   witDisplayData      (theWitRun, WitSTDOUT);
   witStochImplode     (theWitRun);
   witSetStochDataMode (theWitRun, WitFALSE);
@


1.92
log
@Stochastic Implosion
@
text
@a482 1
   witDiscardStochSoln (theWitRun);
@


1.91
log
@Stochastic Implosion
@
text
@d479 1
a479 1
   witSetScenarioProb  (theWitRun, 0.2);
@


1.90
log
@Stochastic Implosion
@
text
@d476 9
a484 9
   witInterpretDevCmd   (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject  (theWitRun, WitTRUE);
   witSetStochasticMode (theWitRun, WitTRUE);
   witSetScenarioProb   (theWitRun, 0.2);
   witWriteData         (theWitRun, WitSTDOUT);
   witDisplayData       (theWitRun, WitSTDOUT);
   witStochImplode      (theWitRun);
   witDiscardStochSoln  (theWitRun);
   witSetStochasticMode (theWitRun, WitFALSE);
@


1.89
log
@Stochastic Implosion
@
text
@d483 1
@


1.88
log
@Stochastic Implosion
@
text
@d482 1
@


1.87
log
@Stochastic Implosion
@
text
@d471 1
a471 1
   witGetDevMode       (theWitRun, & devMode);
d476 7
a482 7
   witInterpretDevCmd  (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject (theWitRun, WitTRUE);
   witSetStochImpMode  (theWitRun, WitTRUE);
   witSetScenarioProb  (theWitRun, 0.2);
   witWriteData        (theWitRun, WitSTDOUT);
   witDisplayData      (theWitRun, WitSTDOUT);
   witSetStochImpMode  (theWitRun, WitFALSE);
@


1.86
log
@Stochastic Implosion
@
text
@d479 1
@


1.85
log
@Stochastic Implosion
@
text
@a476 1

@


1.84
log
@Stochastic Implosion
@
text
@d25 1
d352 2
d358 2
d399 2
a400 1
// Tests ext opt implosion messages.
d440 2
a441 1
// Test witCopy<Object>Data messages.
d462 24
d518 1
a518 1
// Tests UHS Messages.
@


1.83
log
@Stochastic Implosion
@
text
@a20 1
void           testPreInitMsgs   (WitRun *);
d22 1
a25 1
void           testPipMsgs       (WitRun *);
a46 3
   testPreInitMsgs       (theWitRun);

   witInitialize         (theWitRun);
a47 4
   testExtOptMsgs        (theWitRun);
   testCopyObjMsgs       (theWitRun);

   witInitialize         (theWitRun);
a48 2

   witInitialize         (theWitRun);
a49 2

   witInitialize         (theWitRun);
d55 1
a55 1
// testPreInitMsgs
d57 1
a57 1
// Tests messages before witInitialize.
d60 1
a60 1
void testPreInitMsgs (WitRun * theWitRun)
d62 13
a98 22
   }

//------------------------------------------------------------------------------
// testMainMsgs
//
// Tests most of the messages; objChoice == 1.
//------------------------------------------------------------------------------

void testMainMsgs (WitRun * theWitRun)
   {
   witBoolean theBool;
   int        theInt;
   float      theFloat;
   double     theDouble;
   float *    theFloatSt;
   char * *   theCharStSt;
   float * *  theFloatStSt;
   int        lenLists;
   char * *   operationNameList;
   int *      execPeriodList;
   float *    peggedExecVolList;
   witAttr    objItrState;
d100 1
d347 43
d462 1
a485 39
// testPipMsgs
//------------------------------------------------------------------------------

void testPipMsgs (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * demandNameList;
   int *    shipPerList;   
   float *  incShipVolList;
   int      theIdx;

   witGetPipSeq (
        theWitRun,
      & lenLists,
      & partNameList,
      & demandNameList,
      & shipPerList,
      & incShipVolList);

   witClearPipSeq (theWitRun);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witAppendToPipSeq (
         theWitRun,
         partNameList  [theIdx],
         demandNameList[theIdx],
         shipPerList   [theIdx],
         incShipVolList[theIdx] * 2);

   witSetNewPipPggOrder (theWitRun, WitTRUE);
   witWriteData         (theWitRun, WitSTDOUT);
   witDisplayData       (theWitRun, WitSTDOUT);
   witBuildPip          (theWitRun);
   witSetNewPipPggOrder (theWitRun, WitFALSE);
   witBuildPip          (theWitRun);
   }

//------------------------------------------------------------------------------
d492 1
d531 2
@


1.82
log
@witCopy<Object>Data
@
text
@d21 14
a34 11
void           callFuncs1      (WitRun *);
void           callFuncs2      (WitRun *);
float *        vector          (float);
float *        vector          (float, float, float, float);
int *          vector          (int, int, int, int);
const char * * vector          (const char *);
void           prtRemove       (const char *);
void           testPip         (WitRun *);
void           testUHS         (WitRun *);
void           testExtOpt      (WitRun *);
void           testCopyObjData (WitRun *);
d40 3
a42 2
   WitRun *   theWitRun;
   witBoolean devMode;
d44 3
a46 1
   witNewRun               (& theWitRun);
d48 1
a48 9
   witSetMesgPrintNumber     (theWitRun,   WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber     (theWitRun,   WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber     (theWitRun,   WitFALSE, 704, WitFALSE);

   callFuncs1                (theWitRun);
   callFuncs2                (theWitRun);
   testUHS                   (theWitRun);
   witInitialize             (theWitRun);
   witGetDevMode             (theWitRun, & devMode);
d50 4
a53 3
   if (devMode)
      {
      witSetMesgTimesPrint   (theWitRun,   WitFALSE, 98,  0);
d55 2
a56 5
      printf (
         "\n"
         "----------------------------------------"
         "----------------------------------------"
         "\n");
d58 2
a59 2
         witListUnissuedMsgs (theWitRun);
      }
d61 3
a63 1
   witDeleteRun              (theWitRun);
d67 1
a67 1
// callFuncs1
d69 1
a69 1
// Call various API functions with objChoice == 1.
d72 1
a72 1
void callFuncs1 (WitRun * theWitRun)
a73 13
   witBoolean theBool;
   int        theInt;
   float      theFloat;
   double     theDouble;
   float *    theFloatSt;
   char * *   theCharStSt;
   float * *  theFloatStSt;
   int        lenLists;
   char * *   operationNameList;
   int *      execPeriodList;
   float *    peggedExecVolList;
   witAttr    objItrState;

d98 22
a120 1
   witInitialize                 (theWitRun);
d329 1
a329 1
   testPip                   (theWitRun);
d367 52
d420 7
a426 1
   testExtOpt                (theWitRun);
d428 1
a428 1
   testCopyObjData           (theWitRun);
d432 1
a432 1
// callFuncs2
d434 1
a434 1
// Call various API functions with objChoice == 2.
d437 1
a437 1
void callFuncs2 (WitRun * theWitRun)
a438 2
   witInitialize              (theWitRun);

d462 1
a462 41

float * vector (float theValue)
   {
   float * v = new float [4];

   v[0] = theValue;
   v[1] = theValue;
   v[2] = theValue;
   v[3] = theValue;

   return v;
   }

//------------------------------------------------------------------------------

float * vector (float v0, float v1, float v2, float v3)
   {
   float * v = new float [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

//------------------------------------------------------------------------------

int * vector (int v0, int v1, int v2, int v3)
   {
   int * v = new int [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

d465 1
a465 42
const char * * vector (const char * theString)
   {
   const char * * theStrVec = new const char * [4];

   theStrVec[0] = theString;
   theStrVec[1] = theString;
   theStrVec[2] = theString;
   theStrVec[3] = theString;

   return theStrVec;
   }

//------------------------------------------------------------------------------
// prtRemove
//------------------------------------------------------------------------------

void prtRemove (const char * filename)
   {
   char cmd[100];

   printf (
      "\n"
      "File \"%s\":\n"
      "\n",
      filename);

   fflush (stdout);

   strcpy (cmd, "cat ");

   strcat (cmd, filename);

   system (cmd);

   remove (filename);
   }

//------------------------------------------------------------------------------
// testPip
//------------------------------------------------------------------------------

void testPip (WitRun * theWitRun)
d501 2
a502 1
// test UHS
d505 1
a505 1
void testUHS (WitRun * theWitRun)
a506 2
   witInitialize             (theWitRun);

d537 54
a590 1
// Test Msgs for Ext Opt Implosion.
d593 1
a593 1
void testExtOpt (WitRun * theWitRun)
d595 11
a605 11
   int      numcols;
   int      numrows;
   int *    start;
   int *    index;
   double * value;
   double * collb;
   double * colub;
   double * obj;
   double * rowlb;
   double * rowub;
   int      scrapVarIndex;
d607 3
a609 1
   witStartExtOpt          (theWitRun);
d611 4
a614 11
   witGetExtOptLpProbDbl   (theWitRun,
      & numcols,
      & numrows,
      & start,
      & index,
      & value,
      & collb,
      & colub,
      & obj,
      & rowlb,
      & rowub);
d616 1
a616 5
   witGetPartScrapVarIndex (theWitRun, "Cap", 2, & scrapVarIndex);
   witSetExtOptSolnDbl     (theWitRun, collb);
   witFinishExtOpt         (theWitRun);
   witStartExtOpt          (theWitRun);
   witShutDownExtOpt       (theWitRun);
d620 1
a620 1
// Test Msgs for witCopy<Object>Data.
d623 1
a623 1
void testCopyObjData (WitRun * theWitRun)
d625 9
a633 1
   WitRun * theWitRun2;
d635 1
a635 1
   witCopyPartData (theWitRun, "Raw",theWitRun, "Prd");
d637 1
a637 5
   witNewRun           (& theWitRun2);
   witInitialize         (theWitRun2);
   witSetNPeriods        (theWitRun2, 4);
   witSetWit34Compatible (theWitRun2, WitTRUE);
   witAddPart            (theWitRun2, "A", WitMATERIAL);
d639 1
a639 1
   witCopyPartData       (theWitRun, "Prd", theWitRun2, "A");
d641 1
a641 1
   witDeleteRun          (theWitRun2);
@


1.81
log
@witCopy<Object>Data
@
text
@d605 5
a609 4
   witNewRun     (& theWitRun2);
   witInitialize   (theWitRun2);
   witSetNPeriods  (theWitRun2, 4);
   witAddPart      (theWitRun2, "A", WitMATERIAL);
d611 1
a611 1
   witCopyPartData (theWitRun, "Prd", theWitRun2, "A");
d613 1
a613 1
   witDeleteRun    (theWitRun2);
@


1.80
log
@External opt implosion.
@
text
@d21 11
a31 10
void           callFuncs1 (WitRun *);
void           callFuncs2 (WitRun *);
float *        vector     (float);
float *        vector     (float, float, float, float);
int *          vector     (int, int, int, int);
const char * * vector     (const char *);
void           prtRemove  (const char *);
void           testPip    (WitRun *);
void           testUHS    (WitRun *);
void           testExtOpt (WitRun *);
d362 3
a364 1
   testExtOpt (theWitRun);
d594 20
@


1.79
log
@External opt implosion.
@
text
@d30 1
a86 1
   int        scrapVarIndex;
d361 1
a361 5
   witStartExtOpt            (theWitRun);
   witGetPartScrapVarIndex   (theWitRun, "Cap", 2, & scrapVarIndex);
   witFinishExtOpt           (theWitRun);
   witStartExtOpt            (theWitRun);
   witShutDownExtOpt         (theWitRun);
d552 39
@


1.78
log
@external opt implosion.
@
text
@d364 2
@


1.77
log
@External opt implosion.
@
text
@d378 1
a378 1
   witSetAllowIntCons         (theWitRun, WitTRUE);
@


1.76
log
@External opt implosion.
@
text
@d378 1
a378 1
   witSetEnforceIntCons       (theWitRun, WitTRUE);
@


1.75
log
@External opt implosion.
@
text
@d378 2
a379 1

@


1.74
log
@External opt implosion.
@
text
@d86 1
a86 1
   int        colIndex;
d362 1
a362 1
   witGetPartScrapVarIndex   (theWitRun, "Cap", 2, & colIndex);
@


1.73
log
@External opt implosion.
@
text
@d86 1
d362 1
@


1.72
log
@External opt implosion.
@
text
@d372 1
a372 1
   witInitialize                 (theWitRun);
d374 2
a375 2
   witSetNPeriods                (theWitRun, 4);
   witSetObjChoice               (theWitRun, 2);
d377 11
a387 11
   witAddPart                    (theWitRun, "Mat", WitMATERIAL);
   witAddPart                    (theWitRun, "Cap", WitCAPACITY);
   witAddOperation               (theWitRun, "Opn");
   witAddBomEntry                (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry            (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry                (theWitRun, "Opn", "Mat");
   witAddDemand                  (theWitRun, "Mat", "Dem");

   witSetPartSupplyVol           (theWitRun, "Cap",        vector (10.0));
   witSetDemandDemandVol         (theWitRun, "Mat", "Dem", vector (10.0));
   witSetOperationIntConExecVols (theWitRun, "Opn",        WitTRUE);
d389 2
a390 2
   witOptImplode                 (theWitRun);
   witDisplayData                (theWitRun, WitSTDOUT);
d392 1
a392 1
   prtRemove                     ("solver.log");
@


1.71
log
@External opt implosion.
@
text
@d360 2
a361 2
   witStartAsstOpt           (theWitRun);
   witFinishAsstOpt          (theWitRun);
@


1.70
log
@Assisted opt implosion.
@
text
@a360 1
   witSolveOptProblem        (theWitRun);
@


1.69
log
@Custom opt implosion.
@
text
@d244 3
a246 3
   witStartHeurAlloc             (theWitRun);
   witIncHeurAllocTwme           (theWitRun, "Mat", "Dem", 0, 1.0, & theFloat, 
                                             WitTRUE);
d248 1
a248 1
   witEqHeurAllocTwme            (theWitRun,
d257 1
a257 1
   witFinishHeurAlloc            (theWitRun);
d259 1
a259 1
   witOptImplode                 (theWitRun);
d261 1
a261 1
   prtRemove                     ("solver.log");
d263 1
a263 1
   witMrp                        (theWitRun);
d265 1
a265 1
   witGetFocusShortageVol        (theWitRun,
d270 48
a317 19
   witSetOperationExecVol        (theWitRun, "Opn",        vector (10.0));
   witSetSubsBomEntrySubVol      (theWitRun, "Opn", 0, 0,  vector (10.0));
   witSetDemandShipVol           (theWitRun, "Mat", "Dem", vector (10.0));

   witSetHighPrecisionWD         (theWitRun, WitTRUE);
   witWriteData                  (theWitRun, WitSTDOUT);
   witSetHighPrecisionWD         (theWitRun, WitFALSE);
   witWriteData                  (theWitRun, WitSTDOUT);
   witDisplayData                (theWitRun, WitSTDOUT);
   witWriteExecSched             (theWitRun, WitSTDOUT, WitBSV);
   witWriteExecSched             (theWitRun, WitSTDOUT, WitCSV);
   witWriteProdSched             (theWitRun, WitSTDOUT, WitBSV);
   witWriteShipSched             (theWitRun, WitSTDOUT, WitBSV);
   witWriteShipSched             (theWitRun, WitSTDOUT, WitCSV);
   witWriteReqSched              (theWitRun, WitSTDOUT, WitBSV);
   witWriteReqSched              (theWitRun, WitSTDOUT, WitCSV);
   witWriteCriticalList          (theWitRun, WitSTDOUT, WitBSV, 10);
   witWriteCriticalList          (theWitRun, WitSTDOUT, WitCSV, 10);
   witDisplayData                (theWitRun, WitSTDOUT);
d319 1
a319 4
   witSetAccAfterOptImp          (theWitRun, WitTRUE);

   witOptImplode                 (theWitRun);
   witOptImplode                 (theWitRun);
d321 1
a321 1
   witSetAccAfterOptImp          (theWitRun, WitFALSE);
d323 2
a324 1
   prtRemove                     ("solver.log");
d326 1
a326 1
   witSetOptInitMethod           (theWitRun, WitCRASH_OPT_INIT_METHOD);
d328 4
a331 1
   witSetAccAfterOptImp          (theWitRun, WitTRUE);
d333 1
a333 1
   witOptImplode                 (theWitRun);
d335 2
a336 1
   witSetDemandShipVol           (theWitRun, "Mat", "Dem", vector (20.0));
d338 1
a338 1
   witEvalObjectives             (theWitRun);
d340 1
a340 1
   witSetAccAfterOptImp          (theWitRun, WitFALSE);
d342 1
a342 1
   prtRemove                     ("solver.log");
d344 1
a344 44
   witSetMultiRoute              (theWitRun,        WitFALSE);
   witSetComputeCriticalList     (theWitRun,        WitFALSE);
   witSetSelSplit                (theWitRun,        WitTRUE);
   witSetStockRealloc            (theWitRun,        WitFALSE);
   witSetStockReallocation       (theWitRun,        WitTRUE);
   witSetPartSingleSource        (theWitRun, "Mat", WitTRUE);
   witSetPartPropRouting         (theWitRun, "Cap", WitTRUE);
   witSetPipSeqFromHeur          (theWitRun,        WitTRUE);

   witHeurImplode                (theWitRun);

   testPip                       (theWitRun);

   witSetMultiRoute              (theWitRun,        WitTRUE);
   witSetPenExec                 (theWitRun,        WitFALSE);

   witHeurImplode                (theWitRun);

   witSetPartSingleSource        (theWitRun, "Mat", WitFALSE);
   witSetSelSplit                (theWitRun,        WitFALSE);
   witSetPenExec                 (theWitRun,        WitTRUE);
   witSetPgdCritListMode         (theWitRun,        WitTRUE);

   witSetUserHeurStart           (theWitRun,        WitTRUE);

   witSetOperationMinLotSize     (theWitRun, "Opn", vector (0.0));
   witSetOperationExecVol        (theWitRun, "Opn", vector (1.0));

   witHeurImplode                (theWitRun);

   witSetUserHeurStart           (theWitRun,        WitFALSE);

   witSetTieBreakPropRt          (theWitRun,        WitTRUE);

   witHeurImplode                (theWitRun);

   witPurgeData                  (theWitRun);

   witSetMesgPrintNumber         (theWitRun,
                                  WitFALSE,
                                  WitINFORMATIONAL_MESSAGES,
                                  WitFALSE);

   witPurgeData                  (theWitRun);
d346 1
a346 4
   witSetMesgPrintNumber         (theWitRun,
                                  WitFALSE,
                                  WitINFORMATIONAL_MESSAGES,
                                  WitTRUE);
d348 15
a362 3
   witStartCustOptImp            (theWitRun);
   witSolveOptProblem            (theWitRun);
   witFinishCustOptImp           (theWitRun);
@


1.68
log
@App controlled opt implosion.
@
text
@d363 1
a363 1
   witStartOptImp                (theWitRun);
d365 1
a365 1
   witFinishOptImp               (theWitRun);
@


1.67
log
@App controlled opt implosion.
@
text
@d362 4
a553 1

@


1.66
log
@App controlled opt implosion.
@
text
@d38 1
a38 1
   witNewRun            (& theWitRun);
d40 9
a48 8
   witSetMesgPrintNumber  (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber  (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber  (theWitRun, WitFALSE, 704, WitFALSE);

   callFuncs1             (theWitRun);
   callFuncs2             (theWitRun);
   testUHS                (theWitRun);
   witInitialize          (theWitRun);
d50 3
a52 7
   witSetMesgTimesPrint   (theWitRun, WitFALSE, 98,  0);

   printf (
      "\n"
      "----------------------------------------"
      "----------------------------------------"
      "\n");
d54 5
a58 1
   witGetDevMode          (theWitRun, & devMode);
d60 2
a61 2
   if (devMode)
      witListUnissuedMsgs (theWitRun);
d63 1
a63 1
   witDeleteRun           (theWitRun);
@


1.65
log
@Integrality constraints.
@
text
@d35 2
a36 1
   WitRun * theWitRun;
d38 1
a38 1
   witNewRun          (& theWitRun);
d40 3
a42 3
   witSetMesgPrintNumber (theWitRun, WitFALSE, 702, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 703, WitFALSE);
   witSetMesgPrintNumber (theWitRun, WitFALSE, 704, WitFALSE);
d44 4
a47 4
   callFuncs1            (theWitRun);
   callFuncs2            (theWitRun);
   testUHS               (theWitRun);
   witInitialize         (theWitRun);
d49 1
a49 1
   witSetMesgTimesPrint  (theWitRun, WitFALSE, 98,  0);
d57 6
a62 2
   witListUnissuedMsgs   (theWitRun);
   witDeleteRun          (theWitRun);
@


1.64
log
@Removed calls to witSet/GetOptWithLotSizes.
@
text
@d366 1
a366 1
   witInitialize              (theWitRun);
d368 2
a369 2
   witSetNPeriods             (theWitRun, 4);
   witSetObjChoice            (theWitRun, 2);
d371 11
a381 11
   witAddPart                 (theWitRun, "Mat", WitMATERIAL);
   witAddPart                 (theWitRun, "Cap", WitCAPACITY);
   witAddOperation            (theWitRun, "Opn");
   witAddBomEntry             (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry         (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry             (theWitRun, "Opn", "Mat");
   witAddDemand               (theWitRun, "Mat", "Dem");

   witSetPartSupplyVol        (theWitRun, "Cap",        vector (10.0));
   witSetDemandDemandVol      (theWitRun, "Mat", "Dem", vector (10.0));
   witSetOperationIntExecVols (theWitRun, "Opn",        WitTRUE);
d383 2
a384 2
   witOptImplode              (theWitRun);
   witDisplayData             (theWitRun, WitSTDOUT);
d386 1
a386 1
   prtRemove                  ("solver.log");
@


1.63
log
@GPIP migration.
@
text
@d366 4
a369 1
   witInitialize             (theWitRun);
d371 11
a381 15
   witSetNPeriods            (theWitRun, 4);
   witSetObjChoice           (theWitRun, 2);
   witSetOptWithLotSizes     (theWitRun, WitTRUE);

   witAddPart                (theWitRun, "Mat", WitMATERIAL);
   witAddPart                (theWitRun, "Cap", WitCAPACITY);
   witAddOperation           (theWitRun, "Opn");
   witAddBomEntry            (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry        (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry            (theWitRun, "Opn", "Mat");
   witAddDemand              (theWitRun, "Mat", "Dem");

   witSetPartSupplyVol       (theWitRun, "Cap",        vector (10.0));
   witSetDemandDemandVol     (theWitRun, "Mat", "Dem", vector (10.0));
   witSetOperationIncLotSize (theWitRun, "Opn",        vector  (1.0));
d383 2
a384 2
   witOptImplode             (theWitRun);
   witDisplayData            (theWitRun, WitSTDOUT);
d386 1
a386 1
   prtRemove                 ("solver.log");
@


1.62
log
@Updates for groupPipMode defaulting to TRUE.
@
text
@a501 1
   witSetGroupPipMode   (theWitRun, WitFALSE);
a506 1
   witSetGroupPipMode   (theWitRun, WitTRUE);
@


1.61
log
@Added code to test the new PIP pegging order message.
@
text
@d502 1
@


1.60
log
@Removed calls to witSetOslMesgFileName and witGetOslMesgFileName.
@
text
@d502 7
a508 5
   witWriteData       (theWitRun, WitSTDOUT);
   witDisplayData     (theWitRun, WitSTDOUT);
   witBuildPip        (theWitRun);
   witSetGroupPipMode (theWitRun, WitTRUE);
   witBuildPip        (theWitRun);
@


1.59
log
@Minor modification for GPIP.
@
text
@a252 2
   witSetOslMesgFileName         (theWitRun, "solver.log");

a383 2
   witSetOslMesgFileName     (theWitRun, "solver.log");

@


1.58
log
@Added tests for group PIP.
@
text
@a509 1
   witPostprocess     (theWitRun);
@


1.57
log
@Updated to avoid an error on the MS V6 compiler.
@
text
@d506 6
a511 3
   witWriteData   (theWitRun, WitSTDOUT);
   witDisplayData (theWitRun, WitSTDOUT);
   witBuildPip    (theWitRun);
@


1.56
log
@Update to error exception capability.
@
text
@a100 5
   witSetMesgThrowErrorExc       (theWitRun,
      WitFALSE,
      283,
      WitTRUE);

@


1.55
log
@Test code for WIT's new exception throwing capability.
@
text
@a102 5
      WitSEVERE_MESSAGES,
      WitTRUE);

   witSetMesgThrowErrorExc       (theWitRun,
      WitFALSE,
d108 1
a108 1
      77,
@


1.54
log
@[multi-thread]
@
text
@d101 1
a101 1
   witSetMesgThrowException      (theWitRun,
d106 1
a106 1
   witSetMesgThrowException      (theWitRun,
@


1.53
log
@[exceptions]
@
text
@d138 1
@


1.52
log
@Adding errTest, a WIT application program whose purpose is to test WIT's
handling of errors.
@
text
@d101 15
@


1.51
log
@Reduced use of objective #2.
@
text
@d460 1
a460 1
   strcpy(cmd, "cat ");
@


1.50
log
@Added code to test set/get functions for the new names of obj1 attributes
like scrapCost.
@
text
@d310 1
d314 2
a385 6

   witSetPipSeqFromHeur      (theWitRun, WitTRUE);

   witHeurImplode            (theWitRun);

   testPip                   (theWitRun);
@


1.49
log
@Changed test code and data to accommodate the change in the default value
of the objChoice attribute from 2 to 1.
@
text
@d163 2
a164 2
   witSetOperationObj1ExecCost   (theWitRun, "Opn",        vector (-1.0));
   witSetSubsBomEntryObj1SubCost (theWitRun, "Opn", 0, 0,  vector (-1.0));
d201 10
a210 9
   witGetPartExists              (theWitRun, "Mat",        & theBool);
   witGetPartExists              (theWitRun, "XXX",        & theBool);
   witGetOperationExists         (theWitRun, "Opn",        & theBool);
   witGetOperationExists         (theWitRun, "YYY",        & theBool);
   witGetPartNBomEntries         (theWitRun, "Cap",        & theInt);
   witGetPartBuildAheadLimit     (theWitRun, "Mat",        & theInt);
   witGetPartCycleTime           (theWitRun, "Prd",        & theFloatSt);
   witGetBomEntryUsageTime       (theWitRun, "Opn", 0,     & theFloat);
   witGetBomEntryFallout         (theWitRun, "Opn", 0,     & theInt);
@


1.48
log
@Updated apiAll and msgAll to reflect the unconditional use of COIN
when WIT is built with -DCOIN_BUILD.
@
text
@a103 1
   witSetObjChoice               (theWitRun, 1);
d361 1
@


1.47
log
@Added more code to test WIT in COIN mode.
@
text
@a30 2
bool           coinMode;

a36 7
   coinMode = (argc > 1);

   if (coinMode)
      printf ("WIT will use COIN as its solver.\n");
   else
      printf ("WIT will use OSL as its solver.\n");

d247 1
a247 4
   if (coinMode)
      witSetSolverIsCoin         (theWitRun, WitTRUE);
   else
      witSetOslMesgFileName      (theWitRun, "solver.log");
d376 1
a376 4
   if (coinMode)
      witSetSolverIsCoin     (theWitRun, WitTRUE);
   else
      witSetOslMesgFileName  (theWitRun, "solver.log");
@


1.46
log
@Added more code to test WIT in COIN mode.
@
text
@a19 16
// USE_COIN
// 1, if WIT is     to use COIN.
// 0, if WIT is not to use COIN.
//------------------------------------------------------------------------------

#ifdef COIN_BUILD

   #define USE_COIN 1

#else

   #define USE_COIN 0

#endif

//------------------------------------------------------------------------------
d31 2
d35 1
a35 1
int main ()
d39 4
a42 2
   if (USE_COIN)
      printf ("This is a COIN build of msgAll.\n");
d44 1
a44 1
      printf ("This is a non-COIN build of msgAll.\n");
d256 1
a256 1
   if (USE_COIN)
d388 1
a388 1
   if (USE_COIN)
@


1.45
log
@Modification for new optInitMethod behavior.
@
text
@d309 4
d315 2
d323 4
a399 4
   witSetOslMesgFileName     (theWitRun, "solver.log");

#if 0

a404 2
#endif

@


1.44
log
@Added more code to test WIT in COIN mode.
@
text
@a128 1
   witSetOptInitMethod           (theWitRun, WitACC_OPT_INIT_METHOD);
@


1.43
log
@Added initial code to test WIT in COIN mode.
@
text
@d269 4
a272 1
   witSetOslMesgFileName         (theWitRun, "solver.log");
d275 3
a306 2
   witSetOslMesgFileName         (theWitRun, "solver.log");

d393 9
@


1.42
log
@Added code to test API functions and messages for the vector propRtg
attribute.
@
text
@d20 16
d53 5
d269 2
d301 2
d372 2
a373 2
   witSetNPeriods           (theWitRun, 4);
   witSetOptWithLotSizes    (theWitRun, WitTRUE);
d387 2
d392 1
a392 1
   prtRemove                 ("osl.log");
@


1.41
log
@Pegged Critical List.
@
text
@d187 16
@


1.40
log
@Changed test code to accommodate a change in the names of some unreleased API
functions.
@
text
@d275 1
a275 1
   witSetPartBaSelSplit          (theWitRun, "Mat", WitTRUE);
d289 1
d291 1
@


1.39
log
@Added code to test messages for Low-Pri Prop-Rt.
@
text
@d300 1
a300 1
   witSetLowPriPropRt            (theWitRun,        WitTRUE);
@


1.38
log
@Double Precision.
@
text
@d288 3
d300 4
@


1.37
log
@Double Precision.
@
text
@d244 3
@


1.36
log
@Double Precision.
@
text
@d71 1
d124 1
@


1.35
log
@Double Precision.
@
text
@a183 1
   witSetDoubleMode              (theWitRun,               WitFALSE);
@


1.34
log
@Added code to test messages for constraint violations in the
   user-specified heuristic starting solution.
@
text
@d184 1
@


1.33
log
@Modified code to test PIP.
@
text
@d29 1
d45 1
d459 38
@


1.32
log
@Added code to test messages for writeWriteData for PIP.
@
text
@d335 1
a335 1
   witSetHeurPipSeq          (theWitRun, WitTRUE);
@


1.31
log
@Added code to test messages for data display of the PIP shipment sequence.
@
text
@d454 1
d456 1
a456 2

   witBuildPip (theWitRun);
@


1.30
log
@Added code to test more of the messages for PIP.
@
text
@d454 2
@


1.29
log
@Added code to test messages for Post-Implosion Pegging.
@
text
@d28 1
d313 12
a324 1
   witInitialize                 (theWitRun);
d326 3
a328 2
   witSetNPeriods                (theWitRun, 4);
   witSetOptWithLotSizes         (theWitRun, WitTRUE);
d330 2
a331 7
   witAddPart                    (theWitRun, "Mat", WitMATERIAL);
   witAddPart                    (theWitRun, "Cap", WitCAPACITY);
   witAddOperation               (theWitRun, "Opn");
   witAddBomEntry                (theWitRun, "Opn", "Cap");
   witAddSubsBomEntry            (theWitRun, "Opn", 0, "Cap");
   witAddBopEntry                (theWitRun, "Opn", "Mat");
   witAddDemand                  (theWitRun, "Mat", "Dem");
d333 1
a333 3
   witSetPartSupplyVol           (theWitRun, "Cap",        vector (10.0));
   witSetDemandDemandVol         (theWitRun, "Mat", "Dem", vector (10.0));
   witSetOperationIncLotSize     (theWitRun, "Opn",        vector  (1.0));
d335 1
a335 2
   witOptImplode                 (theWitRun);
   witDisplayData                (theWitRun, WitSTDOUT);
d337 1
a337 1
   prtRemove                     ("osl.log");
d339 1
a339 2
   witSetPip                     (theWitRun, WitTRUE);
   witHeurImplode                (theWitRun);
d421 34
@


1.28
log
@Added test code for proportionate routing.
@
text
@d333 3
@


1.27
log
@Removed temporary test code.
@
text
@d271 1
@


1.26
log
@Added temporary C++ test code.
@
text
@a30 22
template <typename Element>
      class MsgSet
   {
   public:

      inline MsgSet ()
         {
         myEl = 17;
         }

      inline void print ()
         {
         printf ("\nmyEl = %d\n\n", myEl);
         }

   private:

      Element myEl;
   };

//------------------------------------------------------------------------------

d33 1
a33 6
   WitRun *     theWitRun;
   MsgSet <int> theMsgSet;

   theMsgSet.print ();

   exit (0);
@


1.25
log
@Modified test code for user-specified heuristic starting solution.
@
text
@d31 2
a32 1
void main ()
d34 27
a60 1
   WitRun * theWitRun;
a440 1

@


1.24
log
@Modified msgAll code to accommodate changes in WIT's "user-specified heuristic
starting solution" capability.
@
text
@d281 2
a282 1
   witSetOperationExecVol        (theWitRun, "Opn", vector (22.0));
@


1.23
log
@Made changes to accommodate WIT changes in the user-specified heuristic
starting solution feature.
@
text
@d281 1
a281 1
   witSetOperationExecVol        (theWitRun, "Opn", vector (10.0));
@


1.22
log
@Updated test code for two-level lot sizes.
@
text
@d279 8
@


1.21
log
@Caused minLotSizeTooLargeWmsg to be issued with the current code.
@
text
@d163 4
d168 4
a171 1
   witSetOperationMinLotSize     (theWitRun, "Opn",        vector (20.0));
@


1.20
log
@Added test code for opt implosion with lot sizes.
@
text
@d163 1
@


1.19
log
@Added code to print the OSL log files to stdout and remove them.
@
text
@d297 1
d307 1
a307 1
   witSetPartSupplyVol           (theWitRun, "Cap", vector (10.0));
d309 1
@


1.18
log
@Added code to test API functions and messages for single-source.
@
text
@d16 2
a17 2
void callFuncs1 (WitRun * theWitRun);
void callFuncs2 (WitRun * theWitRun);
d21 7
a27 53
float * vector (float theValue)
   {
   float * v = new float [4];

   v[0] = theValue;
   v[1] = theValue;
   v[2] = theValue;
   v[3] = theValue;

   return v;
   }

//------------------------------------------------------------------------------

float * vector (float v0, float v1, float v2, float v3)
   {
   float * v = new float [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

//------------------------------------------------------------------------------

int * vector (int v0, int v1, int v2, int v3)
   {
   int * v = new int [4];

   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;

   return v;
   }

//------------------------------------------------------------------------------

const char * * vector (const char * theString)
   {
   const char * * theStrVec = new const char * [4];

   theStrVec[0] = theString;
   theStrVec[1] = theString;
   theStrVec[2] = theString;
   theStrVec[3] = theString;

   return theStrVec;
   }
d311 2
d314 82
@


1.17
log
@Updated test code for object iteration.
@
text
@d6 4
a9 3
// to cause WIT to issue each of its messages for which the Msg::testable
// attribute is TRUE, and then verifies that it has done so, by calling
// witListUnissuedMsgs, which lists the testable messages that weren't issued.
d308 6
@


1.16
log
@Updated testing code for object iteration.
@
text
@d231 3
a233 1
      witAdvanceObjItr (theWitRun, & objItrState);
@


1.15
log
@Added code to test object iteration.
@
text
@d120 1
a120 1
   witAttr    curItrState;
d231 1
a231 1
      witAdvanceItr (theWitRun, & curItrState);
d233 1
a233 1
      if (curItrState == WitINACTIVE)
@


1.14
log
@Changed test code to acommodate the fact that stockRealloc and stockReallocation
cannot both be TRUE.
@
text
@d120 1
a120 1

d228 8
@


1.13
log
@Change test code for recent attribute name changes.
@
text
@d295 1
@


1.12
log
@Changed testing code for name change of mandatory stock reallocation to
   unconditional stock reallocation.
@
text
@d156 1
a156 1
   witSetUncondStockRe           (theWitRun, WitTRUE);
d295 1
a295 1
   witSetSelStockRe              (theWitRun,        WitTRUE);
@


1.11
log
@Added code to test API functions and messages for:
   mandStockRe attribute
   selective stock reallocation
@
text
@d4 3
a6 3
// A PRM application program whose purpose is to test the PRM Engine's issuing
// of messages. This program makes whatever PRM API function calls are necessary
// to cause PRM to issue each of its messages for which the Msg::testable
d156 1
a156 1
   witSetMandStockRe             (theWitRun, WitTRUE);
@


1.10
log
@Minor change.
@
text
@d156 1
a156 1
   witSetStockRealloc            (theWitRun, WitTRUE);
d295 1
@


1.9
log
@Updated testing code for pegging.
@
text
@d159 1
a159 1
   witSetPeggingNeeded           (theWitRun, WitTRUE);
@


1.8
log
@Minor change.
@
text
@d159 1
a159 1
   witSetPegging                 (theWitRun, WitTRUE);
d229 1
a229 1
   witGetDemandPeggedExecVols (
@


1.7
log
@Added code to test API functions and messages for pegging.
@
text
@d159 1
a159 1
   witSetPerfPegging             (theWitRun, WitTRUE);
@


1.6
log
@Added code to test api functions and messages for selection splitting for
build-ahead.
@
text
@d116 4
d159 1
d228 10
@


1.5
log
@Added test code for respectStockSLBs and prefHighStockSLBs attributes.
@
text
@d150 1
d277 4
a280 1
   witSetMultiRoute              (theWitRun, WitTRUE);
@


1.4
log
@Added code to test the new vector attributes:

   BOM entry  consRate
   substitute consRate
   BOP entry  productRate
@
text
@d152 1
@


1.3
log
@Made testing code assume that the default value of stockRealloc is FALSE.
@
text
@d130 2
a131 2
      WitINFORMATIONAL_MESSAGES,
      UCHAR_MAX);
@


1.2
log
@Added code to test API functions and messages for stock reallocation.
@
text
@d151 1
a151 1
   witSetStockRealloc            (theWitRun, WitFALSE);
@


1.1
log
@Initial revision
@
text
@d151 1
@


1.1.1.1
log
@Import samples
@
text
@@

head	1.316;
access;
symbols
	EndRw-branch:1.40.0.2
	Root-of-EndRw:1.40
	rwToStl:1.39.0.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.316
date	2011.08.25.23.30.11;	author rjw;	state Exp;
branches;
next	1.315;

1.315
date	2011.03.03.23.24.25;	author rjw;	state Exp;
branches;
next	1.314;

1.314
date	2011.03.02.00.21.38;	author rjw;	state Exp;
branches;
next	1.313;

1.313
date	2011.02.28.18.51.07;	author rjw;	state Exp;
branches;
next	1.312;

1.312
date	2011.02.18.22.29.11;	author rjw;	state Exp;
branches;
next	1.311;

1.311
date	2011.02.18.00.32.54;	author rjw;	state Exp;
branches;
next	1.310;

1.310
date	2011.02.15.23.27.08;	author rjw;	state Exp;
branches;
next	1.309;

1.309
date	2011.02.10.19.15.50;	author rjw;	state Exp;
branches;
next	1.308;

1.308
date	2011.02.10.00.46.56;	author rjw;	state Exp;
branches;
next	1.307;

1.307
date	2011.02.09.19.44.01;	author rjw;	state Exp;
branches;
next	1.306;

1.306
date	2011.02.07.15.46.28;	author rjw;	state Exp;
branches;
next	1.305;

1.305
date	2011.02.03.19.02.44;	author rjw;	state Exp;
branches;
next	1.304;

1.304
date	2011.01.31.21.22.18;	author rjw;	state Exp;
branches;
next	1.303;

1.303
date	2011.01.27.19.56.23;	author rjw;	state Exp;
branches;
next	1.302;

1.302
date	2011.01.27.16.35.14;	author rjw;	state Exp;
branches;
next	1.301;

1.301
date	2011.01.27.15.13.54;	author rjw;	state Exp;
branches;
next	1.300;

1.300
date	2011.01.27.00.31.50;	author rjw;	state Exp;
branches;
next	1.299;

1.299
date	2011.01.26.22.37.40;	author rjw;	state Exp;
branches;
next	1.298;

1.298
date	2011.01.26.21.27.43;	author rjw;	state Exp;
branches;
next	1.297;

1.297
date	2011.01.26.18.46.58;	author rjw;	state Exp;
branches;
next	1.296;

1.296
date	2011.01.26.00.23.27;	author rjw;	state Exp;
branches;
next	1.295;

1.295
date	2010.12.27.20.48.57;	author rjw;	state Exp;
branches;
next	1.294;

1.294
date	2010.11.12.22.23.33;	author rjw;	state Exp;
branches;
next	1.293;

1.293
date	2010.11.05.16.05.41;	author rjw;	state Exp;
branches;
next	1.292;

1.292
date	2010.10.29.22.28.02;	author rjw;	state Exp;
branches;
next	1.291;

1.291
date	2010.10.19.20.13.58;	author rjw;	state Exp;
branches;
next	1.290;

1.290
date	2010.10.14.16.27.59;	author rjw;	state Exp;
branches;
next	1.289;

1.289
date	2010.10.12.22.42.33;	author rjw;	state Exp;
branches;
next	1.288;

1.288
date	2010.10.12.22.02.37;	author rjw;	state Exp;
branches;
next	1.287;

1.287
date	2010.10.12.19.48.40;	author rjw;	state Exp;
branches;
next	1.286;

1.286
date	2010.10.08.15.40.07;	author rjw;	state Exp;
branches;
next	1.285;

1.285
date	2010.10.07.16.33.35;	author rjw;	state Exp;
branches;
next	1.284;

1.284
date	2010.07.01.22.42.36;	author rjw;	state Exp;
branches;
next	1.283;

1.283
date	2010.06.22.22.12.05;	author rjw;	state Exp;
branches;
next	1.282;

1.282
date	2010.06.22.22.06.20;	author rjw;	state Exp;
branches;
next	1.281;

1.281
date	2010.05.21.18.22.51;	author rjw;	state Exp;
branches;
next	1.280;

1.280
date	2010.05.20.23.21.05;	author rjw;	state Exp;
branches;
next	1.279;

1.279
date	2010.05.14.23.50.07;	author rjw;	state Exp;
branches;
next	1.278;

1.278
date	2010.05.14.21.42.45;	author rjw;	state Exp;
branches;
next	1.277;

1.277
date	2010.05.14.17.49.44;	author rjw;	state Exp;
branches;
next	1.276;

1.276
date	2010.05.12.18.38.16;	author rjw;	state Exp;
branches;
next	1.275;

1.275
date	2010.05.11.22.33.30;	author rjw;	state Exp;
branches;
next	1.274;

1.274
date	2010.05.11.22.30.14;	author rjw;	state Exp;
branches;
next	1.273;

1.273
date	2010.04.09.14.48.37;	author rjw;	state Exp;
branches;
next	1.272;

1.272
date	2010.04.09.14.25.20;	author rjw;	state Exp;
branches;
next	1.271;

1.271
date	2010.04.08.21.08.35;	author rjw;	state Exp;
branches;
next	1.270;

1.270
date	2010.03.29.21.34.33;	author rjw;	state Exp;
branches;
next	1.269;

1.269
date	2010.03.26.22.33.52;	author rjw;	state Exp;
branches;
next	1.268;

1.268
date	2010.03.25.15.32.26;	author rjw;	state Exp;
branches;
next	1.267;

1.267
date	2010.03.23.22.00.13;	author rjw;	state Exp;
branches;
next	1.266;

1.266
date	2010.03.18.22.04.30;	author rjw;	state Exp;
branches;
next	1.265;

1.265
date	2010.02.10.18.26.41;	author rjw;	state Exp;
branches;
next	1.264;

1.264
date	2010.02.10.18.24.00;	author rjw;	state Exp;
branches;
next	1.263;

1.263
date	2010.02.05.20.44.41;	author rjw;	state Exp;
branches;
next	1.262;

1.262
date	2010.02.05.00.18.11;	author rjw;	state Exp;
branches;
next	1.261;

1.261
date	2010.02.04.23.40.53;	author rjw;	state Exp;
branches;
next	1.260;

1.260
date	2010.02.01.23.07.39;	author rjw;	state Exp;
branches;
next	1.259;

1.259
date	2009.11.17.19.30.30;	author rjw;	state Exp;
branches;
next	1.258;

1.258
date	2009.11.12.20.24.35;	author rjw;	state Exp;
branches;
next	1.257;

1.257
date	2009.11.12.20.01.13;	author rjw;	state Exp;
branches;
next	1.256;

1.256
date	2009.11.11.20.03.30;	author dpc;	state Exp;
branches;
next	1.255;

1.255
date	2009.10.08.20.41.16;	author rjw;	state Exp;
branches;
next	1.254;

1.254
date	2009.06.08.20.57.15;	author rjw;	state Exp;
branches;
next	1.253;

1.253
date	2009.02.04.21.33.25;	author rjw;	state Exp;
branches;
next	1.252;

1.252
date	2008.12.08.15.54.13;	author rjw;	state Exp;
branches;
next	1.251;

1.251
date	2008.12.08.15.10.31;	author rjw;	state Exp;
branches;
next	1.250;

1.250
date	2008.08.25.21.20.56;	author rjw;	state Exp;
branches;
next	1.249;

1.249
date	2008.03.03.21.58.46;	author rjw;	state Exp;
branches;
next	1.248;

1.248
date	2008.02.25.22.35.23;	author rjw;	state Exp;
branches;
next	1.247;

1.247
date	2008.02.22.23.45.32;	author rjw;	state Exp;
branches;
next	1.246;

1.246
date	2008.02.22.21.37.00;	author rjw;	state Exp;
branches;
next	1.245;

1.245
date	2008.01.21.21.47.57;	author rjw;	state Exp;
branches;
next	1.244;

1.244
date	2007.11.02.20.21.48;	author rjw;	state Exp;
branches;
next	1.243;

1.243
date	2007.11.01.20.11.46;	author rjw;	state Exp;
branches;
next	1.242;

1.242
date	2007.10.30.22.53.10;	author rjw;	state Exp;
branches;
next	1.241;

1.241
date	2007.10.30.22.01.16;	author rjw;	state Exp;
branches;
next	1.240;

1.240
date	2007.10.22.19.59.15;	author rjw;	state Exp;
branches;
next	1.239;

1.239
date	2007.10.22.19.20.53;	author rjw;	state Exp;
branches;
next	1.238;

1.238
date	2007.10.22.18.54.11;	author rjw;	state Exp;
branches;
next	1.237;

1.237
date	2007.10.15.21.50.54;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2007.10.02.22.30.23;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2007.08.29.16.28.12;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2007.08.24.21.12.54;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2007.07.17.22.10.37;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2007.07.16.20.15.14;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2007.07.16.18.08.51;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2007.07.16.15.52.20;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2007.05.21.15.20.29;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2007.05.17.20.05.38;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2007.05.17.17.59.53;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2007.05.17.17.37.28;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2007.05.11.22.52.43;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2007.05.03.22.11.06;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2007.05.02.23.11.18;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2007.04.30.20.43.15;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2007.04.30.19.32.45;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2007.04.27.19.32.59;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2007.04.26.21.32.42;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2007.04.26.20.45.50;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2007.04.25.23.30.58;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2007.04.24.21.18.26;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2007.04.23.21.03.31;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2007.04.23.20.28.40;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2007.04.20.23.32.01;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2007.04.20.22.21.44;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2007.04.20.20.51.33;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2007.04.16.20.29.04;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2007.04.13.23.08.48;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2007.04.13.22.39.21;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2007.04.13.21.26.37;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2007.04.11.23.03.57;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2007.04.11.22.45.45;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2007.03.09.20.28.50;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2007.03.08.17.03.06;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2007.03.07.16.58.13;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2007.03.06.23.00.11;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2007.03.06.22.51.40;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2007.03.06.19.47.31;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2007.03.02.22.51.38;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2007.01.23.17.05.28;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2007.01.23.16.45.56;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2006.12.28.21.03.32;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2006.12.28.16.39.47;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2006.12.26.22.24.25;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2006.12.19.19.27.32;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2006.12.06.19.53.07;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2006.12.01.21.36.53;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2006.12.01.19.55.40;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2006.11.20.17.19.30;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2006.11.20.17.05.14;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2006.11.18.00.10.26;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2006.11.17.19.01.14;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2006.11.17.18.33.04;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2006.11.17.16.58.03;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2006.11.16.22.32.21;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2006.11.01.17.32.15;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2006.10.19.21.54.43;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2006.10.13.20.47.48;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2006.10.12.20.48.50;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2006.10.12.19.44.19;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2006.10.12.16.02.06;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2006.10.11.22.37.49;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2006.10.10.19.11.20;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2006.10.10.14.27.30;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2006.10.05.21.26.43;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2006.10.05.20.55.41;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2006.10.05.18.19.44;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2006.10.04.20.45.08;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2006.10.02.19.28.06;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2006.09.27.22.33.52;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2006.09.27.22.13.39;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2006.09.26.19.12.14;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2006.09.22.18.02.16;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2006.09.21.21.30.54;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2006.09.15.23.10.02;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2006.09.15.22.01.45;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2006.09.08.20.24.35;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2006.08.29.15.02.09;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2006.08.28.23.05.04;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2006.08.21.16.00.39;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2006.08.18.23.32.28;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2006.08.18.23.28.06;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2006.08.18.18.42.51;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2006.08.17.17.39.14;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2006.08.17.15.34.19;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2006.08.09.18.37.36;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2006.08.08.19.08.35;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2006.08.08.19.01.55;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2006.08.02.17.54.24;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2006.08.02.16.05.28;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.07.27.23.04.34;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.06.27.13.49.09;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.06.06.21.36.11;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.05.19.23.22.01;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.05.16.21.59.46;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.04.17.22.42.12;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.27.22.30.21;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.27.18.51.04;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2005.11.16.16.53.19;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2005.11.16.14.21.53;	author fasano;	state Exp;
branches;
next	1.136;

1.136
date	2005.11.04.19.30.42;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2005.10.17.22.17.06;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2005.10.13.20.41.38;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2005.10.13.19.02.14;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2005.10.10.16.00.34;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2005.09.28.15.08.01;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2005.09.20.20.18.24;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2005.09.19.14.50.35;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2005.09.12.21.30.49;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2005.08.25.21.58.53;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2005.07.11.22.54.18;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2005.07.08.21.07.10;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2005.06.13.22.12.04;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2005.06.13.17.52.03;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2005.06.08.18.41.14;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2005.05.17.17.32.59;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2005.04.15.17.38.13;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2005.03.31.15.38.46;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2005.03.29.20.04.15;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2005.03.29.19.22.00;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2005.03.29.00.04.58;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2005.03.28.22.30.56;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2005.03.21.23.01.26;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2005.03.16.17.01.46;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2005.02.07.19.32.48;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2005.02.04.21.17.47;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2005.02.04.20.12.20;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2005.01.21.23.04.03;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2005.01.18.19.46.56;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2004.10.12.21.40.08;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.18.15.49.41;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.12.18.47.51;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.16.17.43.05;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.07.19.41.10;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.06.19.59.07;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2004.04.06.19.32.23;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.05.23.08.34;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.04.05.22.18.24;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.04.05.17.58.20;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2004.04.03.01.09.01;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2004.04.01.21.04.37;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2004.03.31.22.56.28;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2004.03.31.20.57.46;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2004.03.31.20.53.05;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.31.20.44.28;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.30.21.10.25;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2004.03.30.20.30.33;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2004.03.30.20.20.36;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2004.03.30.18.57.20;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2004.03.30.00.05.52;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2004.03.29.22.25.35;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2004.03.26.17.03.57;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.24.16.50.54;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.11.16.36.42;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.02.16.47.08;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.27.21.00.47;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.24.22.09.01;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2004.02.24.21.50.33;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.02.24.20.35.44;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.20.23.55.35;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.20.16.38.40;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.20.15.42.48;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.19.22.56.30;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.19.21.21.50;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.19.16.42.06;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.17.20.24.16;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.02.14.00.46.23;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.02.10.23.58.33;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.02.05.16.40.42;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.19.23.27.31;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2003.12.31.21.21.43;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.31.21.03.58;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.31.20.13.24;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2003.12.31.20.09.54;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.12.30.22.11.13;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.30.20.42.15;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.30.18.08.59;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.30.16.25.22;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.30.15.49.52;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.29.22.00.58;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.05.16.19.55;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.31.16.18.05;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.03.18.10.42;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.08.05.20.19.50;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.01.21.04.18;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.28.20.47.34;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.08.22.29.11;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.07.02.19.25.23;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.07.18.16.23;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.06.21.05.31;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.24.20.59.22;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.23.23.23.20;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.30.21.58.25;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.30.20.39.03;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.23.20.46.36;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.25.15.18.13;	author rwToStl;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.15.20.28.18;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.04.20.50.32;	author fasano;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.10.17.19.13.22;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.10.19.32.45;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.10.19.22.35;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.09.19.23.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.26.20.03.31;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.11.20.16.08;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.06.20.12.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.29.19.11.32;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.22.14.57.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.21.21.00.27;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.02.15.10.09;	author austel;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.02.13.51.51;	author austel;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.25.17.45.44;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.29.20.55.05;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.25.21.49.22;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.25.19.16.09;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.24.20.07.23;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.15.22.17.59;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.09.17.44.35;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.20.18.52.16;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.08.19.44.47;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.05.20.55.00;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.03.18.56.33;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.21.44.35;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.14.13.25.54;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.29.21.38.29;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.06.17.32.03;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.03.18.41.41;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.30.18.40.34;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.28.00.49.53;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.05.19.54.58;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.17.20.03.39;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.01.21.48.11;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.13.21.05.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.18.15;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.00.19.01;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.08.21.58.28;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.33.16;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.39.2.1
date	2002.11.10.17.35.36;	author fasano;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.15.33.16;	author wit;	state Exp;
branches;
next	;


desc
@@


1.316
log
@Revisions for the removal of COIN from WIT.
@
text
@/*----------------------------------------------------------------------------*/
/* Program apiAll                                                             */
/*                                                                            */
/* This is a WIT application program that invokes each of WIT's API functions */
/* at least once. Its purpose is for testing WIT, especially WIT's API.       */
/*----------------------------------------------------------------------------*/
 
#include <wit.h>

#include <stdlib.h>
#include <stdio.h>
#if !defined(_MSC_VER)
#  include <unistd.h>  
#endif
#include <string.h>
#include <assert.h>
#include <math.h>

/*----------------------------------------------------------------------------*/
/* Macro ERROR_EXC_AVAIL                                                      */
/*                                                                            */
/* WitTRUE, iff WIT's error exception capability is available on the platform */
/* being used.                                                                */
/*----------------------------------------------------------------------------*/

#define ERROR_EXC_AVAIL WitTRUE

#if defined(_MSC_VER)

#if _MSC_VER <= 1200
   /*                           */
   /* MS Visual C++ V6 or less. */

#undef  ERROR_EXC_AVAIL
#define ERROR_EXC_AVAIL WitFALSE

#endif

#endif

/*----------------------------------------------------------------------------*/

void testStandAlone ();

void testCplexParSpecs      (WitRun *);
void testClearCplexParSpecs (WitRun *);
void testCplexParSpecAtts   (WitRun *);
void testGetIntCplexParSpec (WitRun *);
void testGetDblCplexParSpec (WitRun *);

void testWriteReadData (WitRun *, const char *);
void testOperationApis();
void testBopApis();
void testAddPart();
void testPartToArcApis ();
void testHeurAlloc ();
void testHeurAllocDbl ();
void testHeurAllocTwme ();
void testHeurAllocTwmeDbl ();
void testDeletion ();
void defProfDelTest (WitRun *);
void selItemsDelTest (WitRun *);
void copyWriteDelTest (WitRun *);
void checkSelDelTest (WitRun *);
void testExecVolPegging    (WitRun *, const char *, const char *, int);
void testExecVolPeggingDbl (WitRun *, const char *, const char *, int);
void testSubVolPegging     (WitRun *, const char *, const char *, int);
void testSubVolPeggingDbl  (WitRun *, const char *, const char *, int);

void testPip          (WitRun *);
void truncatePipSeq   (WitRun *);
void testExecVolPip   (WitRun *, const char *, const char *, int);
void testCoExecVolPip (WitRun *, const char *, const char *, int);
void testSubVolPip    (WitRun *, const char *, const char *, int);
void testSupplyVolPip (WitRun *, const char *, const char *, int);
void testSideVolPip   (WitRun *, const char *, const char *, int);
void testProdVolPip   (WitRun *, const char *, const char *, int);
void testConsVolPip   (WitRun *, const char *, const char *, int);

void testPartVolPip (
      const char *, 
      const char *, 
      const char *, 
      int, 
      int, 
      char * *, 
      int *, 
      float *);

void testPipDbl          (WitRun *);
void truncatePipSeqDbl   (WitRun *);
void testExecVolPipDbl   (WitRun *, const char *, const char *, int);
void testCoExecVolPipDbl (WitRun *, const char *, const char *, int);
void testSubVolPipDbl    (WitRun *, const char *, const char *, int);
void testSupplyVolPipDbl (WitRun *, const char *, const char *, int);
void testSideVolPipDbl   (WitRun *, const char *, const char *, int);
void testProdVolPipDbl   (WitRun *, const char *, const char *, int);
void testConsVolPipDbl   (WitRun *, const char *, const char *, int);

void testPartVolPipDbl (
      const char *, 
      const char *, 
      const char *, 
      int, 
      int, 
      char * *, 
      int *, 
      double *);

void testPgdCritList  (WitRun *);
void printPgdCritList (WitRun *);

void testObjItr (WitRun *);
void testAccOptImp ();
void optImpA1 (WitRun *);
void optImpB1 (WitRun *);
void optImpA2 (WitRun *);
void optImpB2 (WitRun *);
void prtFiles ();
void prtRemove (const char *);
void testCumShipVol ();

void testExtOpt             ();
void buildExtOptProblem     (WitRun *);
void testGetExtOptLpProb    (WitRun *);
void testGetExtOptLpProbDbl (WitRun *);
void testGetConIndices      (WitRun *);
void testGetVarIndices      (WitRun *);
void testGetSlbvVarIndices  (WitRun *);
void testGetSlbConIndices   (WitRun *);

void testCopyObjData1WR  ();
void testCopyObjData2WRs ();

void testShipLateAllowed ();

void testGetExpCycle     ();
void buildCycleProblem   (WitRun *);
void displayCycle        (WitRun *);

void testStageByObject   ();
void buildCoreProblemSBO (WitRun *);
void specifyStochDataSBO (WitRun *);
void checkStochData      (WitRun *);
void testStochWriteData  (WitRun *);
void testStochCopyData   (WitRun *);
void testStochImplode    (WitRun *);
void checkStochSoln      (WitRun *);
void testClearStochSoln  (WitRun *);

void testStageByPeriod   ();
void buildCoreProblemSBP (WitRun *);
void specifyStochDataSBP (WitRun *);

void testMultiObjMode  ();
void testObjListSpec   (WitRun *);
void testObjList       (WitRun *);
void testObjSeq        (WitRun *);
void testMultiObjTol   (WitRun *);
void populateMultiObj  (WitRun *);
void testSetObjVecs    (WitRun *);
void testGetObjVecs    (WitRun *);
void testMultiObjValue (WitRun *);

void testLeadTimeBounds ();

void testAccOptWithCplex ();

void          compareFltVecsOf2 (float *,        float,          float);
const float * fltVecOf1         (float);
const float * fltVecOf2         (float,          float);
witBoolean    equalStrings      (const char *,   const char *);
void          compareIntVecs    (const int *,    const int *,    int);
void          compareFltVecs    (const float *,  const float *,  int);
void          compareDblVecs    (const double *, const double *, int);
void          printFltVec       (const char *,   const float *,  int);
void          printDblVec       (const char *,   const double *, int);

const int    nPeriods        = 5;
const double dblEps          = .00001;

witBoolean   developmentMode = WitFALSE;

witBoolean   cplexEmbedded   = WitFALSE;

/*----------------------------------------------------------------------------*/
/* Main Program                                                               */
/*----------------------------------------------------------------------------*/

int main ()
   {
   int   t;
   WitRun * theWitRun;
   WitRun * theMrpRun;
   WitRun * theObj1Run;

   char theAppData[] = "Contents of theAppData.";

   testStandAlone ();

   witNewRun (& theWitRun);
   witNewRun (& theObj1Run);

   /* Message Functions */
   {
   char *string;
   witBoolean bool;
   int intnum;

   if (ERROR_EXC_AVAIL)
      witSetMesgThrowErrorExc (
         theWitRun,
         WitFALSE,
         77,
         WitTRUE);

   witSetMesgFileAccessMode( theWitRun, WitFALSE, "w" );

   witSetMesgFileName( theWitRun, WitFALSE, "apiAll.msg" );

   witSetMesgPrintNumber( theWitRun, WitFALSE, 
        WitINFORMATIONAL_MESSAGES, WitFALSE);   

   witSetMesgFileName( theWitRun, WitTRUE, WitSTDOUT );

   unlink( "apiAll.msg" );

   witSetMesgPrintNumber( theWitRun, WitFALSE, 
       WitINFORMATIONAL_MESSAGES, WitTRUE);

   witSetMesgStopRunning( theWitRun, WitFALSE, WitFATAL_MESSAGES, WitFALSE);
   witSetMesgStopRunning( theWitRun, WitFALSE, WitFATAL_MESSAGES, WitTRUE); 

   witSetMesgTimesPrint( theWitRun, WitFALSE, WitWARNING_MESSAGES, 2 ); 
   witSetMesgTimesPrint( theWitRun, WitFALSE, WitWARNING_MESSAGES, UCHAR_MAX );
   }

   witInitialize ( theWitRun );

   witSetWit34Compatible( theWitRun, WitTRUE );

   witGetCplexEmbedded (theWitRun, & cplexEmbedded);

   if (cplexEmbedded)
      printf (
         "\n"
         "This is a CPLEX-embedded build of WIT.\n");
   else
      printf (
         "\n"
         "This is not a CPLEX-embedded build of WIT.\n");

   testCplexParSpecs (theWitRun);

   {
   FILE * tempFile;
   witGetMesgFile(     theWitRun, &tempFile );
   fprintf( tempFile, "Hello world\n");
   }

   /* get message functions */
   {
   char *string;
   witBoolean bool;
   int intnum;

   witGetMesgThrowErrorExc (theWitRun, 77, & bool);

   if (ERROR_EXC_AVAIL)
      assert (bool);
   else
      assert (! bool);

   witGetMesgFileAccessMode( theWitRun, &string );
   assert( strcmp( string, "w" ) == 0 );

   witFree (string);

   witGetMesgFileName( theWitRun, &string );
   assert( strcmp( string, WitSTDOUT ) == 0 );

   witFree (string);

   witGetMesgPrintNumber( theWitRun, 97, &bool );
   assert( bool == WitTRUE );

   witGetMesgStopRunning( theWitRun, 543, &bool );
   assert( bool == WitTRUE );

   witGetMesgTimesPrint( theWitRun, 75, &intnum );
   assert( intnum == UCHAR_MAX );
   }


   /* witSetGlobalAttribute */
   {
   witSetAccAfterSoftLB( theWitRun, WitFALSE );
   witSetAccAfterSoftLB( theWitRun, WitTRUE );

   witSetAccAfterOptImp( theWitRun, WitTRUE );
   witSetAccAfterOptImp( theWitRun, WitFALSE );

   witSetAutoPriority( theWitRun, WitFALSE );
   witSetAutoPriority( theWitRun, WitTRUE );

   witSetBuildWhenEmpty( theWitRun, WitFALSE );
   witSetExecEmptyBom( theWitRun, WitTRUE );

   witSetRoundReqVols( theWitRun, WitFALSE );

   witSetComputeCriticalList( theWitRun, WitTRUE );

   witSetEquitability( theWitRun, 12 );
   witSetForcedMultiEq( theWitRun, WitTRUE );
   witSetHashTableSize( theWitRun, 5 );
   witSetIndependentOffsets (theWitRun, WitTRUE);
   witSetLocalBuildAhead( theWitRun, WitTRUE );
   witSetLocalMultiExec( theWitRun, WitTRUE );
   witSetLotSizeTolDbl( theWitRun, 5.0e-6 );
   witSetLotSizeTol( theWitRun, 1.0e-4 );
   witSetExpCutoffDbl( theWitRun, 1.0e-4 );
   witSetExpCutoff( theWitRun, 1.0e-3 );
   witSetNPeriods( theWitRun, nPeriods );
   witSetObjChoice( theWitRun, 1 );
   witSetSkipFailures (theWitRun, WitFALSE);
   witSetTitle( theWitRun, "Invoke Each API Function" );
   witSetWboundsDbl( theWitRun, 66000. );
   witSetWbounds( theWitRun, 44000. );

   witSetUseFocusHorizons( theWitRun, WitFALSE );

   witSetTruncOffsets( theWitRun, WitTRUE );

   witSetMultiRoute (theWitRun, WitTRUE);

   witSetPenExec (theWitRun, WitTRUE);

   witSetStockRealloc (theWitRun, WitFALSE);

   witSetStockReallocation (theWitRun, WitTRUE);

   witSetSrSelSplit (theWitRun, WitTRUE);

   witSetNonMrSelSplit (theWitRun, WitTRUE);

   witSetRespectStockSLBs (theWitRun, WitTRUE);

   witSetPrefHighStockSLBs (theWitRun, WitTRUE);

   witSetPerfPegging (theWitRun, WitTRUE);

   witSetCompPrices (theWitRun, WitTRUE);

   witSetUserHeurStart (theWitRun, WitTRUE);

   witSetTieBreakPropRt (theWitRun, WitTRUE);

   witSetNstnResidual (theWitRun, WitTRUE);

   witSetMinimalExcess (theWitRun, WitTRUE);
   }

   /* witGetGlobalAttribute */
   {
   witBoolean bool;
   int i;
   float theFlt;
   double theDbl;
   char * title;

   witGetAccAfterSoftLB( theWitRun, &bool );

   assert( bool );

   witGetAccAfterOptImp( theWitRun, &bool );

   assert( !bool );

   witGetAccelerated( theWitRun, &bool );

   assert( !bool );

   witGetDevMode (theWitRun, & developmentMode);

   if (developmentMode)
      printf (
         "\n"
         "WIT was built in development mode.\n");
   else
      printf (
         "\n"
         "WIT was built in non-development mode.\n");

   witGetAutoPriority( theWitRun, &bool );
   assert( bool );
   witGetBuildWhenEmpty( theWitRun, &bool );
   assert( bool );
   witGetExecEmptyBom( theWitRun, &bool );
   assert( bool );
   witGetRoundReqVols( theWitRun, &bool );
   assert( ! bool );
   witGetComputeCriticalList( theWitRun, &bool );
   assert( bool );

   witSetComputeCriticalList( theWitRun, WitFALSE );

   witGetHashTableSize( theWitRun, &i );
   assert( i == 5 );

   witGetIndependentOffsets ( theWitRun, &bool );
   assert( bool );

   witSetIndependentOffsets (theWitRun, WitFALSE);

   witGetEquitability( theWitRun, &i );
   assert( i == 12 );

   witGetForcedMultiEq( theWitRun, &bool );
   assert( bool );

   witGetLocalBuildAhead( theWitRun, &bool );
   assert( bool );

   witGetLocalMultiExec( theWitRun, &bool );
   assert( bool );

   witGetLotSizeTol   ( theWitRun, &theFlt );
   witGetLotSizeTolDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 1.0e-4 ) < dblEps );
   assert( fabs(theDbl - 1.0e-4 ) < dblEps );

   witGetExpCutoff   ( theWitRun, &theFlt );
   witGetExpCutoffDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 1.0e-3 ) < dblEps );
   assert( fabs(theDbl - 1.0e-3 ) < dblEps );

   witSetMultiExec( theWitRun, WitTRUE );

   witGetLocalMultiExec( theWitRun, &bool );
   assert( ! bool );

   witGetMultiExec( theWitRun, &bool );
   assert( bool );

   witGetNPeriods( theWitRun, &i );
   assert( i == nPeriods );

   witGetObjChoice( theWitRun, &i );
   assert( i == 1 );

   witGetSkipFailures( theWitRun, &bool );
   assert( !bool );

   witGetTitle( theWitRun, &title );
   assert( strcmp( title, "Invoke Each API Function" ) == 0 );
   witFree ( title );
   
   witGetWbounds   ( theWitRun, &theFlt );
   witGetWboundsDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 44000. ) < dblEps );
   assert( fabs(theDbl - 44000. ) < dblEps );

   witGetPreprocessed( theWitRun, &bool );
   assert( !bool );

   witGetFeasible( theWitRun, &bool );
   assert( !bool );

   witGetUseFocusHorizons( theWitRun, &bool );
   assert( !bool );

   witGetTruncOffsets( theWitRun, &bool );
   assert( bool );

   witGetMultiRoute (theWitRun, &bool);
   assert (bool);

   witGetPenExec (theWitRun, &bool);
   assert (bool);

   witGetStockRealloc (theWitRun, &bool);
   assert (! bool);

   witGetStockReallocation (theWitRun, &bool);
   assert (bool);

   witGetSrSelSplit (theWitRun, &bool);
   assert (bool);

   witGetNonMrSelSplit (theWitRun, &bool);
   assert (bool);

   witSetSelSplit (theWitRun, WitTRUE);

   witGetSelSplit (theWitRun, &bool);
   assert (bool);

   witGetNonMrSelSplit (theWitRun, &bool);
   assert (! bool);

   witGetRespectStockSLBs (theWitRun, &bool);
   assert (bool);

   witGetPrefHighStockSLBs (theWitRun, &bool);
   assert (bool);

   witGetPerfPegging (theWitRun, &bool);
   assert (bool);

   witGetCompPrices (theWitRun, &bool);
   assert (bool);

   witGetUserHeurStart (theWitRun, & bool);
   assert (bool);

   witSetUserHeurStart (theWitRun, WitFALSE);

   witGetTieBreakPropRt (theWitRun, & bool);
   assert (bool);

   witGetNstnResidual (theWitRun, & bool);
   assert (bool);

   witGetMinimalExcess (theWitRun, & bool);
   assert (bool);
   }

   /* Global appData */
   {
   void * ptr;
   int i;

   witSetAppData( theWitRun, theAppData);
   witGetAppData( theWitRun, &ptr);
   assert( ptr==theAppData );
   }

   {
   int p;
   witGetOutputPrecision( theWitRun, &p );
   assert( p==3 );
   witSetOutputPrecision( theWitRun, 4 );
   witGetOutputPrecision( theWitRun, &p );
   assert( p==4 );
   }

   /* wit34Compatible */
   {
   witBoolean b;
   witSetWit34Compatible( theWitRun, WitFALSE );
   witGetWit34Compatible( theWitRun, &b );
   assert( !b );
   witSetWit34Compatible( theWitRun, WitTRUE );
   witGetWit34Compatible( theWitRun, &b );
   assert( b );
   }

   /* Part PS1 */
   {
   float      cycle             [] = {0.0, 0.1, 0.2, 0.3, 0.4};
   float      prodBoundsHL      [] = {1., 2.,  3., 4., 5.};
   float      prodBoundsSL      [] = {2., 2.2, 4., 5., 6.};
   float      stockBoundsSL     [] = {20., 20.2, 40., 50., 60.};
   double     stockBoundsSLDbl  [] = {10., 10.2, 30., 40., 50.};
   float      stockBoundsHU     [] = {20., 20.2, 40., 50., 60.};
   double     stockBoundsHUDbl  [] = {10., 10.2, 30., 40., 50.};
   float      defaultBoundsHU   [] = {-1.0, -1.0, -1.0, -1.0, -1.0};
   float      defaultBoundsHL   [] = {0.0, 0.0, 0.0, 0.0, 0.0};
   double     defaultBoundsHLDbl[] = {0.0, 0.0, 0.0, 0.0, 0.0};
   float      defaultBoundsSL   [] = {0.0, 0.0, 0.0, 0.0, 0.0};
   float      minLotSize        [] = {2., 2., 4., 5., 6.};
   float      incLotSize        [] = {1., 1., 3., 4., 3.};
   int        yield             [] = {90, 91, 92, 93, 94};
   float      theFlt;
   double     theDbl;
   float *    fv;
   int *      iv;
   witAttr    partCat;
   witBoolean buildNstn;
   witBoolean buildAsap;
   witBoolean scrapAllowed;
   witBoolean asapPipOrder;
   witBoolean baSelSplit;
   int        buildAheadLimit;
   int        buildAheadUB[] = {1, 2, 2, 1, 0};

   witAddPart( theWitRun, "PS1", WitPRODUCT );

   {  /* verify part stock bounds in double  */
   double *hlb;
   double *slb;
   double *hub;
   witSetPartStockBoundsDbl( theWitRun, "PS1", NULL, stockBoundsSLDbl,
                                                     stockBoundsHUDbl);
   witGetPartStockBoundsDbl( theWitRun, "PS1", &hlb, &slb, &hub);
   compareDblVecs( hlb, defaultBoundsHLDbl, nPeriods );
   compareDblVecs( slb, stockBoundsSLDbl,   nPeriods );
   compareDblVecs( hub, stockBoundsHUDbl,   nPeriods );
   witFree (hlb);
   witFree (slb);
   witFree (hub);
   }

   witSetPartCycleTime( theWitRun, "PS1", cycle );
   witSetPartProdBounds( theWitRun, "PS1", prodBoundsHL,prodBoundsSL,NULL );
   witSetPartStockBounds( theWitRun, "PS1", NULL, stockBoundsSL,stockBoundsHU);
   witSetPartYield( theWitRun, "PS1", yield );
   witSetPartMinLotSize( theWitRun, "PS1", minLotSize );
   witSetPartIncLotSize( theWitRun, "PS1", incLotSize );
   witSetPartBuildAsap( theWitRun, "PS1", WitTRUE);

   witSetPartScrapAllowed (theWitRun, "PS1", WitFALSE);
   witSetPartAsapPipOrder (theWitRun, "PS1", WitTRUE);

   {  /* verify get part product bounds */
   float *hlb;
   float *slb;
   float *hub;
   witGetPartProdBounds( theWitRun, "PS1", &hlb, &slb, &hub);
   compareFltVecs( hlb, prodBoundsHL,    nPeriods );
   compareFltVecs( slb, prodBoundsSL,    nPeriods );
   compareFltVecs( hub, defaultBoundsHU, nPeriods );
   witFree (hlb);
   witFree (slb);
   witFree (hub);
   }

   {  /* verify get part stock bounds */
   float *hlb;
   float *slb;
   float *hub;
   witGetPartStockBounds( theWitRun, "PS1", &hlb, &slb, &hub);
   compareFltVecs( hlb, defaultBoundsHL, nPeriods );
   compareFltVecs( slb, stockBoundsSL,   nPeriods );
   compareFltVecs( hub, stockBoundsHU,   nPeriods );
   witFree (hlb);
   witFree (slb);
   witFree (hub);
   }

   {  /* verify get part yield */
   int *my_yield;
   witGetPartYield( theWitRun, "PS1", &my_yield );
   compareIntVecs( my_yield, yield, nPeriods );
   witFree (my_yield);
   }

   witGetPartCategory( theWitRun, "PS1", &partCat );
   assert( partCat == WitPRODUCT );

   witGetPartMinLotSize( theWitRun, "PS1", &fv );
   compareFltVecs( fv, minLotSize, nPeriods );
   witFree (fv);

   witGetPartIncLotSize( theWitRun, "PS1", &fv );
   compareFltVecs( fv, incLotSize, nPeriods );
   witFree (fv);

   witGetPartCycleTime( theWitRun, "PS1", &fv );
   compareFltVecs( fv, cycle, nPeriods );
   witFree (fv);

   witGetPartBuildNstn( theWitRun, "PS1", & buildNstn);
   assert (! buildNstn);

   witGetPartBuildAsap( theWitRun, "PS1", & buildAsap);
   assert (buildAsap);

   witSetPartBuildNstn( theWitRun, "PS1", WitTRUE);

   witGetPartBuildNstn( theWitRun, "PS1", & buildNstn);
   assert (buildNstn);

   witGetPartBuildAsap( theWitRun, "PS1", & buildAsap);
   assert (! buildAsap);

   witGetPartScrapAllowed (theWitRun, "PS1", & scrapAllowed);

   assert (! scrapAllowed);

   witGetPartAsapPipOrder (theWitRun, "PS1", & asapPipOrder);

   assert (asapPipOrder);

   witSetPartAsapPipOrder (theWitRun, "PS1", WitFALSE);

   witSetPartBaSelSplit( theWitRun, "PS1", WitTRUE);

   witGetPartBaSelSplit( theWitRun, "PS1", & baSelSplit);
   assert (baSelSplit);

   witSetPartBaSelSplit( theWitRun, "PS1", WitFALSE);

   /* part buildAheadUB and buildAheadLimit */

   witSetPartBuildAheadLimit (theWitRun, "PS1", 2);

   witGetPartBuildAheadLimit (theWitRun, "PS1", & buildAheadLimit);

   assert (buildAheadLimit == 2);

   witGetPartBuildAheadUB (theWitRun, "PS1", & iv);

   assert (iv[3] == 2);

   witFree (iv);

   witSetPartBuildAheadUB (theWitRun, "PS1", buildAheadUB);

   witGetPartBuildAheadUB (theWitRun, "PS1", & iv);

   compareIntVecs (iv, buildAheadUB, nPeriods);

   witFree (iv);

   witGetPartBuildAheadLimit (theWitRun, "PS1", & buildAheadLimit);

   assert (buildAheadLimit == 1);

   /* part appData */
   {
   void * ptr;
   witSetPartAppData( theWitRun, "PS1", theAppData);
   witGetPartAppData( theWitRun, "PS1", &ptr);
   assert( ptr==theAppData );
   }


   }

   /* Part PS2 */
   {
   float cycle[] = {0.02, 0.12, 0.22, 0.32, 0.42};
   float prodBoundsHL[] = {1.2, 2.2,  3.2, 4.2, 5.2};
   float prodBoundsSL[] = {2.2, 2.22, 4.2, 5.2, 6.2};
   float stockBoundsHU[] = {20.2, 20.22, 40.2, 50.2, 60.2};
   float minLotSize[] = {12., 12., 14., 15., 16.};
   float incLotSize[] = {1., 2., 13., 14., 13.};
   int   yield[] = {94, 95, 96, 97, 98};
  
   witAttr partCat;

   witAddPart (theWitRun, "PS2", WitPRODUCT);

   witGetPartCategory( theWitRun, "PS2", &partCat );
   assert( partCat == WitPRODUCT );
   }

   /* Part MOBILE */
   {
   witAttr partCat;

   witAddPart (theWitRun, "MOBILE", WitPRODUCT);

   witGetPartCategory( theWitRun, "MOBILE", &partCat );
   assert( partCat == WitPRODUCT );
   }

   /* witGetParts */
   {
   int lenList;
   char ** partList;
   witGetParts( theWitRun, &lenList, &partList );
   assert( lenList == 3 );
   assert( strcmp(partList[0],"PS1") == 0 );
   assert( strcmp(partList[1],"PS2") == 0 );
   assert( strcmp(partList[2],"MOBILE") == 0 );
   witFree ( partList[0] );
   witFree ( partList[1] );
   witFree ( partList[2] );
   witFree ( partList );
   }



   /* Part CompA*/
   {
   float supplyVol[] = {2000., 2000., 2000., 2000., 2000.};
   float *fv;
   witAttr partCat;

   witAddPart( theWitRun, "CompA", WitRAW );
   witSetPartSupplyVol( theWitRun, "CompA", supplyVol );

   witGetPartSupplyVol( theWitRun, "CompA", &fv );
   compareFltVecs( fv, supplyVol, nPeriods );
   witFree (fv);

   witGetPartCategory( theWitRun, "CompA", &partCat );
   assert( partCat == WitRAW );
   }

   /* Part CompB*/
   {
   float  supplyVol[]    = {3500., 2500., 2500., 2500., 2500.};
   double supplyVolDbl[] = {3500., 2500., 2500., 2500., 2500.};
   float *fv;
   double * dv;
   witAttr partCat;

   witAddPart( theWitRun, "CompB", WitRAW );
   witSetPartSupplyVolDbl( theWitRun, "CompB", supplyVolDbl );

   witGetPartSupplyVol( theWitRun, "CompB", &fv );
   compareFltVecs( fv, supplyVol, nPeriods );
   witFree (fv);

   witGetPartSupplyVolDbl (theWitRun, "CompB", & dv);

   compareDblVecs (dv, supplyVolDbl, nPeriods);

   witFree (dv);

   witGetPartCategory( theWitRun, "CompB", &partCat );
   assert( partCat == WitRAW );
   }


   /* Part CompC*/
   {
   float supplyVol[] = {2000., 2000., 2000., 2000., 2000.};
   float *fv;
   witAttr partCat;

   witAddPart( theWitRun, "CompC", WitRAW );
   witSetPartSupplyVol( theWitRun, "CompC", supplyVol );

   witGetPartSupplyVol( theWitRun, "CompC", &fv );
   compareFltVecs( fv, supplyVol, nPeriods );
   witFree (fv);

   witGetPartCategory( theWitRun, "CompC", &partCat );
   assert( partCat == WitRAW );
   }

   /* Part TestCap*/
   {
   float supplyVol[] = {3500., 3500., 3500., 3500., 3500.};
   float *fv;
   witAttr partCat;

   witAddPart( theWitRun, "TestCap", WitCAPACITY );
   witSetPartSupplyVol( theWitRun, "TestCap", supplyVol );

   witGetPartSupplyVol( theWitRun, "TestCap", &fv );
   compareFltVecs( fv, supplyVol, nPeriods );
   witFree (fv);

   witGetPartCategory( theWitRun, "TestCap", &partCat );
   assert( partCat == WitCAPACITY );
   }

   {
   witBoolean exists;

   witGetPartExists( theWitRun, "TestCap", &exists );
   assert( exists );

   witGetPartExists( theWitRun, "xyzTestCap", &exists );
   assert( !exists );
   }
 
   /* Part PS1, Demand US */
   {
   int    priority          [] = { 3, 3, 3, 3, 3 };
   float  demandVol         [] = { 500., 500., 500., 500., 500. };
   double demandVolDbl      [] = { 500., 500., 500., 500., 500. };
   float  cumShipBoundsHL   [] = {1.2, 2.2,  3.2, 4.2, 5.2};
   double cumShipBoundsHLDbl[] = {1.6, 2.2,  3.2, 4.2, 5.2};
   float  cumShipBoundsSL   [] = {2.2, 2.22, 4.2, 5.2, 6.2};
   double cumShipBoundsSLDbl[] = {2.6, 2.22, 4.2, 5.2, 6.2};
   float  cumShipBoundsHU   [] = {-1., 200., -1., -1., -1.};
   double cumShipBoundsHUDbl[] = {-1., 300., -1., -1., -1.};
   float  fssShipVol        [] = { 500., 500., 450., 500., 500. };
   double fssShipVolDbl     [] = { 500., 500., 450., 500., 500. };

   int i;
   float theFlt;
   double theDbl;
   float *fv;
   double * dv;
   witBoolean bool;
   int *      iv;
   int        buildAheadLimit;
   int        buildAheadUB[] = {4, 2, 2, 1, 0};
   int        shipLateLimit;
   int        shipLateUB[]   = {3, 2, 3, 2, 1};
   
   witAddDemand( theWitRun, "PS1", "US" );
   witSetDemandPriority( theWitRun, "PS1", "US", priority );
   witSetDemandDemandVol( theWitRun, "PS1", "US", demandVol );
   witSetDemandDemandVolDbl( theWitRun, "PS1", "US", demandVolDbl );
   witSetDemandFssShipVol( theWitRun, "PS1", "US", fssShipVol );
   witSetDemandFssShipVolDbl( theWitRun, "PS1", "US", fssShipVolDbl );
   witSetDemandFocusHorizon( theWitRun, "PS1", "US", nPeriods-1 );
   witSetDemandShipLateLimit( theWitRun, "PS1", "US", 2 );
   witSetDemandPrefBuildAhead( theWitRun, "PS1", "US", WitTRUE );

   witSetDemandSearchInc    (theWitRun, "PS1", "US", 0.1);
   witSetDemandSearchIncDbl (theWitRun, "PS1", "US", 0.01);

   witGetDemandSearchInc    (theWitRun, "PS1", "US", & theFlt);
   witGetDemandSearchIncDbl (theWitRun, "PS1", "US", & theDbl);

   assert (fabs (theFlt - 0.01) < dblEps);
   assert (fabs (theDbl - 0.01) < dblEps);

   witSetDemandSearchInc    (theWitRun, "PS1", "US", 1);

   witGetDemandDemandVol( theWitRun, "PS1", "US", &fv );
   compareFltVecs( fv, demandVol, nPeriods );
   witFree (fv);

   witGetDemandDemandVolDbl( theWitRun, "PS1", "US", &dv );
   compareDblVecs( dv, demandVolDbl, nPeriods );
   witFree (dv);

   witGetDemandFssShipVol( theWitRun, "PS1", "US", &fv );
   compareFltVecs( fv, fssShipVol, nPeriods );
   witFree (fv);

   witGetDemandFssShipVolDbl( theWitRun, "PS1", "US", &dv );
   compareDblVecs( dv, fssShipVolDbl, nPeriods );
   witFree (dv);

   {
   double *hlb;
   double *slb;
   double *hub;

   witSetDemandCumShipBoundsDbl( theWitRun, "PS1", "US", 
      cumShipBoundsHLDbl, cumShipBoundsSLDbl, cumShipBoundsHUDbl);
   witGetDemandCumShipBoundsDbl( theWitRun, "PS1", "US", 
      &hlb, &slb, &hub);
   compareDblVecs( hlb, cumShipBoundsHLDbl, nPeriods );
   compareDblVecs( slb, cumShipBoundsSLDbl, nPeriods );
   compareDblVecs( hub, cumShipBoundsHUDbl, nPeriods );
   witFree (hlb);
   witFree (slb);
   witFree (hub);
   }

   {
   float *hlb;
   float *slb;
   float *hub;

   witSetDemandCumShipBounds( theWitRun, "PS1", "US", 
      cumShipBoundsHL, cumShipBoundsSL, cumShipBoundsHU);
   witGetDemandCumShipBounds( theWitRun, "PS1", "US", 
      &hlb, &slb, &hub);
   compareFltVecs( hlb, cumShipBoundsHL, nPeriods );
   compareFltVecs( slb, cumShipBoundsSL, nPeriods );
   compareFltVecs( hub, cumShipBoundsHU, nPeriods );
   witFree (hlb);
   witFree (slb);
   witFree (hub);
   }

   witGetDemandFocusHorizon( theWitRun, "PS1", "US", &i );
   assert( i == nPeriods-1 );

   /*---------------- demand buildAheadUB and buildAheadLimit ----------------*/

   witSetDemandBuildAheadLimit (theWitRun, "PS1", "US", 3);

   witGetDemandBuildAheadLimit (theWitRun, "PS1", "US", & buildAheadLimit);

   assert (buildAheadLimit == 3);

   witGetDemandBuildAheadUB (theWitRun, "PS1", "US", & iv);

   assert (iv[3] == 3);

   witFree (iv);

   witSetDemandBuildAheadUB (theWitRun, "PS1", "US", buildAheadUB);

   witGetDemandBuildAheadUB (theWitRun, "PS1", "US", & iv);

   compareIntVecs (iv, buildAheadUB, nPeriods);

   witFree (iv);

   witGetDemandBuildAheadLimit (theWitRun, "PS1", "US", & buildAheadLimit);

   assert (buildAheadLimit == 4);

   /*------------------ demand shipLateUB and shipLateLimit ------------------*/

   witSetDemandShipLateLimit (theWitRun, "PS1", "US", 1);

   witGetDemandShipLateLimit (theWitRun, "PS1", "US", & shipLateLimit);

   assert (shipLateLimit == 1);

   witGetDemandShipLateUB (theWitRun, "PS1", "US", & iv);

   assert (iv[2] == 1);

   witFree (iv);

   witSetDemandShipLateUB (theWitRun, "PS1", "US", shipLateUB);

   witGetDemandShipLateUB (theWitRun, "PS1", "US", & iv);

   compareIntVecs (iv, shipLateUB, nPeriods);

   witFree (iv);

   witGetDemandShipLateLimit (theWitRun, "PS1", "US", & shipLateLimit);

   assert (shipLateLimit == 3);

   /*-------------------------------------------------------------------------*/

   witGetDemandPrefBuildAhead( theWitRun, "PS1", "US", &bool );
   assert( bool );

   /* demand appData */
   {
   void * ptr;
   witSetDemandAppData( theWitRun, "PS1", "US",  theAppData);
   witGetDemandAppData( theWitRun, "PS1", "US",  &ptr);
   assert( ptr==theAppData );
   }

   }

   /* Part PS1, Demand AGP */
   {
   int priority[] = { 3, 2, 3, 2, 3 };
   float demandVol[] = { 500., 500., 500., 500., 500. };
   float cumShipBoundsHL[] = {1.2, 2.2,  3.2, 4.2, 5.2};
   float cumShipBoundsSL[] = {2.2, 2.22, 4.2, 5.2, 6.2};
   float cumShipBoundsHU[] = {-1., 200., -1., -1., -1.};

   int i;

   witAddDemand( theWitRun, "PS1", "AGP");
   witSetDemandFocusHorizon( theWitRun, "PS1", "AGP", nPeriods-2 );

   witGetDemandFocusHorizon( theWitRun, "PS1", "AGP", &i );
   assert( i == nPeriods-2 );
   }

   /*----------------------------------------------*/
   /* Changing the name of a part and of a demand. */
   /*----------------------------------------------*/
   {
   witBoolean selForDel;

   witGetDemandSelForDel   (theWitRun, "PS1",  "AGP", & selForDel);
   assert                                            (! selForDel);
   witSetPartPartName      (theWitRun, "PS1",           "TmpP");
   witSetDemandDemandName  (theWitRun, "TmpP", "AGP",   "TmpD");
   witSetDemandSelForDel   (theWitRun, "TmpP", "TmpD",  WitTRUE);
   witSetPartPartName      (theWitRun, "TmpP",          "PS1");
   witSetDemandDemandName  (theWitRun, "PS1",  "TmpD",  "AGP");
   witGetDemandSelForDel   (theWitRun, "PS1",  "AGP", & selForDel);
   assert                                              (selForDel);
   witSetDemandSelForDel   (theWitRun, "PS1",  "AGP",   WitFALSE);
   }

   /* witGetPartDemands */
   {
   int lenList;
   char **demandList;
   witGetPartDemands( theWitRun, "PS1", &lenList, &demandList );
   assert( lenList == 2 );
   assert( strcmp(demandList[0],"US") == 0 );
   assert( strcmp(demandList[1],"AGP") == 0 );
   witFree ( demandList[0] );
   witFree ( demandList[1] );
   witFree ( demandList );
   }


   /* Part PS2, Demand US */
   {
   int i;

   witAddDemand( theWitRun, "PS2", "US");
   witSetDemandFocusHorizon( theWitRun, "PS2", "US",  nPeriods-3 );

   witGetDemandFocusHorizon( theWitRun, "PS2", "US",  &i );
   assert( i == nPeriods-3 );
   }


   /* Part MOBILE, Demand US */
   {
   int priority[] = { 1, 2, 1, 1, 1 };
   float demandVol[] = { 1000., 1000.,1000.,1000.,1000. };

   int i;

   witAddDemand( theWitRun, "MOBILE", "US");
   witSetDemandFocusHorizon( theWitRun, "MOBILE", "US", nPeriods-4 );

   witGetDemandFocusHorizon( theWitRun, "MOBILE", "US", &i );
   assert( i == nPeriods-4 );
   }

   /* Part PS1 BOM */
   {
   float  offset         [] = {0.0, 0.5, 1.0, 0.0, 0.0};
   double offsetDbl      [] = {0.0, 0.5, 1.0, 0.0, 0.0};
   float  consRate       [] = {1.2, 2.3, 3.4, 4.5, 5.6};
   double consRateDbl    [] = {1.2, 2.3, 3.4, 4.5, 5.6};
   float  routingShare   [] = {5.0, 4.0, 3.0, 2.0, 1.0};
   double routingShareDbl[] = {5.0, 4.0, 3.0, 2.0, 1.0};

   witAddBomEntry( theWitRun, "PS1", "CompA");
   witSetBomEntryUsageTime( theWitRun, "PS1", 0, -0.1 );
   witSetBomEntryUsageRate( theWitRun, "PS1", 0, 1.1 );
   witSetBomEntryConsRate( theWitRun, "PS1", 0, consRate);
   witSetBomEntryConsRateDbl( theWitRun, "PS1", 0, consRateDbl);
   witSetBomEntryEarliestPeriod( theWitRun, "PS1", 0, 1 );
   witSetBomEntryLatestPeriod( theWitRun, "PS1", 0, 3 );
   witSetBomEntryMandEC( theWitRun, "PS1", 0, WitTRUE );

   witSetBomEntryExecPenaltyDbl  (theWitRun, "PS1", 0, 234.76);
   witSetBomEntryExecPenalty     (theWitRun, "PS1", 0,  34.76);
   witSetBomEntryRoutingShare (theWitRun, "PS1", 0, routingShare);
   witSetBomEntryRoutingShareDbl (theWitRun, "PS1", 0, routingShareDbl);

   witAddBomEntry(  theWitRun, "PS1", "CompB");
   witAddBomEntry( theWitRun, "PS1", "TestCap");

     {
     float * off;

     offset[1]=0.;
     offset[2]=0.;

     witSetBomEntryOffset( theWitRun, "PS1", 1, offset );

     witGetBomEntryOffset( theWitRun, "PS1", 1, &off );
     compareFltVecs( off, offset, nPeriods );

     witFree (off);
     }

     {
     double * off;

     offsetDbl[1]=0.;
     offsetDbl[2]=0.;

     witSetBomEntryOffsetDbl( theWitRun, "PS1", 1, offsetDbl );

     witGetBomEntryOffsetDbl( theWitRun, "PS1", 1, &off );
     compareDblVecs( off, offsetDbl, nPeriods );

     witFree (off);
     }

     {
     char *s;
     witGetBomEntryConsumedPart( theWitRun, "PS1", 2, &s );
     assert( equalStrings(s,"TestCap") );
     witFree (s);
     }
   
   }

   {
   int bomEntryEarliestPeriod;
   witGetBomEntryEarliestPeriod( theWitRun, "PS1", 0, &bomEntryEarliestPeriod );
   assert( bomEntryEarliestPeriod == 1 );
   }

   /* falloutRate */
   {
   float  theFalloutRate;
   double theFalloutRateDbl;
   int    theFallout;

   witSetBomEntryFalloutRateDbl (theWitRun, "PS1", 0, 0.043);
   witSetBomEntryFalloutRate    (theWitRun, "PS1", 0, 0.026);
   witGetBomEntryFalloutRate    (theWitRun, "PS1", 0, & theFalloutRate);
   witGetBomEntryFallout        (theWitRun, "PS1", 0, & theFallout);

   assert (fabs (theFalloutRate - 0.026) < dblEps);
   assert (theFallout == 3);

   witSetBomEntryFallout        (theWitRun, "PS1", 0, 4);
   witGetBomEntryFallout        (theWitRun, "PS1", 0, & theFallout);
   witGetBomEntryFalloutRate    (theWitRun, "PS1", 0, & theFalloutRate);
   witGetBomEntryFalloutRateDbl (theWitRun, "PS1", 0, & theFalloutRateDbl);

   assert (theFallout == 4);
   assert (fabs (theFalloutRate    - 0.04) < dblEps);
   assert (fabs (theFalloutRateDbl - 0.04) < dblEps);

   }

   {
   int bomEntryLatestPeriod;
   witGetBomEntryLatestPeriod( theWitRun, "PS1", 0, &bomEntryLatestPeriod );
   assert( bomEntryLatestPeriod == 3 );
   }

   {
   witBoolean bomEntryMandEC;
   witGetBomEntryMandEC( theWitRun, "PS1", 0, &bomEntryMandEC );
   assert( bomEntryMandEC == WitTRUE );
   }

   {
   float  theFlt;
   double theDbl;

   witGetBomEntryExecPenalty    (theWitRun, "PS1", 0, & theFlt);
   witGetBomEntryExecPenaltyDbl (theWitRun, "PS1", 0, & theDbl);

   assert (fabs (theFlt - 34.76) < dblEps);
   assert (fabs (theDbl - 34.76) < dblEps);
   }

   {
   float bomEntryUsageTime;
   witGetBomEntryUsageTime( theWitRun, "PS1", 0, &bomEntryUsageTime );
   assert( fabs( bomEntryUsageTime + 0.1 ) < dblEps );
   }

   {
   float   usageRate;
   float * consRate;
   float   goodConsRate[] = {1.2, 2.3, 3.4, 4.5, 5.6};

   witGetBomEntryUsageRate (theWitRun, "PS1", 0, & usageRate);

   assert (fabs (usageRate - 1.2) < dblEps);

   witGetBomEntryConsRate (theWitRun, "PS1", 0, & consRate);

   compareFltVecs (consRate, goodConsRate, nPeriods);

   witFree (consRate);
   }

   {
   double * consRateDbl;
   double   goodConsRateDbl[] = {1.2, 2.3, 3.4, 4.5, 5.6};

   witGetBomEntryConsRateDbl (theWitRun, "PS1", 0, & consRateDbl);

   compareDblVecs (consRateDbl, goodConsRateDbl, nPeriods);

   witFree (consRateDbl);
   }

   {
   float * routingShare;
   float   goodRoutingShare[] = {5.0, 4.0, 3.0, 2.0, 1.0};

   witGetBomEntryRoutingShare (theWitRun, "PS1", 0, & routingShare);

   compareFltVecs (routingShare, goodRoutingShare, nPeriods);

   witFree (routingShare);
   }

   {
   double * routingShareDbl;
   double   goodRoutingShareDbl[] = {5.0, 4.0, 3.0, 2.0, 1.0};

   witGetBomEntryRoutingShareDbl (theWitRun, "PS1", 0, & routingShareDbl);

   compareDblVecs (routingShareDbl, goodRoutingShareDbl, nPeriods);

   witFree (routingShareDbl);
   }

   {
   int nBomEntries;

   witGetPartNBomEntries( theWitRun, "PS1", &nBomEntries );
   assert( nBomEntries == 3 );

   witGetOperationNBomEntries( theWitRun, "PS1", &nBomEntries );
   assert( nBomEntries == 3 );

   witGetPartNBomEntries( theWitRun, "CompA", &nBomEntries );
   assert( nBomEntries == 0 );

   witGetPartNBomEntries( theWitRun, "TestCap", &nBomEntries );
   assert( nBomEntries == 0 );
   }

   /* bomEntry appData */
   {
   void * ptr;
   witSetBomEntryAppData( theWitRun, "PS1", 2, theAppData);
   witGetBomEntryAppData( theWitRun, "PS1", 2, &ptr);
   assert( ptr==theAppData );
   }

   /* impactPeriod */
   {
   int * impactPeriod;
   int   correctImpactPeriod[] = { -1, 1, 2, 3, -1};

   witGetBomEntryImpactPeriod (theWitRun, "PS1", 0, &impactPeriod);

   compareIntVecs (impactPeriod, correctImpactPeriod, nPeriods);

   witFree (impactPeriod);
   }

   /* Part PS2 BOM */
   {
   witAddBomEntry( theWitRun, "PS2", "CompA");
   witAddBomEntry( theWitRun, "PS2", "CompB");
   witAddBomEntry( theWitRun, "PS2", "CompC");
   witAddBomEntry( theWitRun, "PS2", "TestCap");
   }

   /* Part MOBILE BOM */
   {
   witAddBomEntry( theWitRun, "MOBILE", "CompB");
   witAddBomEntry( theWitRun, "MOBILE", "CompC");
   witAddBomEntry( theWitRun, "MOBILE", "TestCap");
   }

   /* Part PS1 BOM substitute */
   {
   float  consRate       [] = {6.5, 5.4, 4.3, 3.2, 2.1};
   double consRateDbl    [] = {6.5, 5.4, 4.3, 3.2, 2.1};
   float  routingShare   [] = {1.0, 3.0, 1.0, 3.0, 1.0};
   double routingShareDbl[] = {1.0, 3.0, 1.0, 3.0, 1.0};

   witAddSubsBomEntry( theWitRun, "PS1", 0, "CompB");
   witSetSubsBomEntryUsageRate( theWitRun, "PS1", 0, 0, 2.1 );
   witSetSubsBomEntryConsRate (theWitRun, "PS1", 0, 0, consRate);
   witSetSubsBomEntryConsRateDbl (theWitRun, "PS1", 0, 0, consRateDbl);
   witSetSubsBomEntryEarliestPeriod( theWitRun, "PS1", 0, 0, 0 );
   witSetSubsBomEntryLatestPeriod( theWitRun, "PS1", 0, 0, nPeriods-1 );

   witSetSubsBomEntryExpAllowed (theWitRun, "PS1", 0, 0, WitFALSE);
   witSetSubsBomEntryExpNetAversionDbl (theWitRun, "PS1", 0, 0, 3.9);
   witSetSubsBomEntryExpNetAversion    (theWitRun, "PS1", 0, 0, 1.2);
   witSetSubsBomEntryExecPenaltyDbl (theWitRun, "PS1", 0, 0, 329.87);
   witSetSubsBomEntryExecPenalty    (theWitRun, "PS1", 0, 0,  29.87);
   witSetSubsBomEntryNetAllowed (theWitRun, "PS1", 0, 0, WitFALSE);
   witSetSubsBomEntryRoutingShare (theWitRun, "PS1", 0, 0, routingShare);
   witSetSubsBomEntryRoutingShareDbl (theWitRun, "PS1", 0, 0, routingShareDbl);

   witAddSubsBomEntry(  theWitRun, "PS1", 1, "CompA");

   witSetSubsBomEntryNetAllowed    (theWitRun, "PS1", 1, 0, WitFALSE);
   witSetSubsBomEntryMrpNetAllowed (theWitRun, "PS1", 1, 0, WitTRUE);
   }

   /* consumedPartName */
   {
   char *s;
   witGetSubsBomEntryConsumedPart( theWitRun, "PS1", 0, 0, &s );
   assert( equalStrings(s,"CompB") );
   witFree (s);
   }

   {
   int subsBomEntryEarliestPeriod;
   witGetSubsBomEntryEarliestPeriod( theWitRun, "PS1", 0, 0, &subsBomEntryEarliestPeriod );
   assert( subsBomEntryEarliestPeriod == 0 );
   }

   /* falloutRate */
   {
   float  theFalloutRate;
   double theFalloutRateDbl;
   int    theFallout;

   witSetSubsBomEntryFalloutRateDbl (theWitRun, "PS1", 0, 0, 0.037);
   witSetSubsBomEntryFalloutRate    (theWitRun, "PS1", 0, 0, 0.054);
   witGetSubsBomEntryFalloutRate    (theWitRun, "PS1", 0, 0, & theFalloutRate);
   witGetSubsBomEntryFalloutRateDbl (theWitRun, "PS1", 0, 0, 
                                                & theFalloutRateDbl);
   witGetSubsBomEntryFallout        (theWitRun, "PS1", 0, 0, & theFallout);

   assert (fabs (theFalloutRate    - 0.054) < dblEps);
   assert (fabs (theFalloutRateDbl - 0.054) < dblEps);
   assert (theFallout == 5);

   witSetSubsBomEntryFallout     (theWitRun, "PS1", 0, 0, 17);
   witGetSubsBomEntryFallout     (theWitRun, "PS1", 0, 0, & theFallout);
   witGetSubsBomEntryFalloutRate (theWitRun, "PS1", 0, 0, & theFalloutRate);

   assert (theFallout == 17);
   assert (fabs (theFalloutRate - 0.17) < dblEps);
   }

   {
   int subsBomEntryLatestPeriod;
   witGetSubsBomEntryLatestPeriod( theWitRun, "PS1", 0, 0,
      &subsBomEntryLatestPeriod );
   assert( subsBomEntryLatestPeriod == nPeriods-1 );
   }

   {
   witBoolean subsBomEntryExpAllowed;

   witGetSubsBomEntryExpAllowed (
       theWitRun, "PS1", 0, 0, & subsBomEntryExpAllowed);

   assert (! subsBomEntryExpAllowed);
   }

   {
   witBoolean subsBomEntryNetAllowed;

   witGetSubsBomEntryNetAllowed (
       theWitRun, "PS1", 1, 0, & subsBomEntryNetAllowed);

   assert (! subsBomEntryNetAllowed);
   }

   {
   witBoolean subsBomEntryMrpNetAllowed;

   witGetSubsBomEntryMrpNetAllowed (
       theWitRun, "PS1", 1, 0, & subsBomEntryMrpNetAllowed);

   assert (subsBomEntryMrpNetAllowed);
   }

   {
   float  subsBomEntryExpNetAversion;
   double subsBomEntryExpNetAversionDbl;

   witGetSubsBomEntryExpNetAversion (
      theWitRun, "PS1", 0, 0, & subsBomEntryExpNetAversion);
   witGetSubsBomEntryExpNetAversionDbl (
      theWitRun, "PS1", 0, 0, & subsBomEntryExpNetAversionDbl);

   assert (fabs (subsBomEntryExpNetAversion    - 1.2) < dblEps);
   assert (fabs (subsBomEntryExpNetAversionDbl - 1.2) < dblEps);
   }

   {
   float   usageRate;
   float * consRate;
   float   goodConsRate[] = {6.5, 5.4, 4.3, 3.2, 2.1};

   witGetSubsBomEntryUsageRate (theWitRun, "PS1", 0, 0, & usageRate);

   assert (fabs (usageRate - 6.5) < dblEps);

   witGetSubsBomEntryConsRate (theWitRun, "PS1", 0, 0, & consRate);

   compareFltVecs (consRate, goodConsRate, nPeriods);

   witFree (consRate);
   }

   {
   double * consRateDbl;
   double   goodConsRateDbl[] = {6.5, 5.4, 4.3, 3.2, 2.1};

   witGetSubsBomEntryConsRateDbl (theWitRun, "PS1", 0, 0, & consRateDbl);

   compareDblVecs (consRateDbl, goodConsRateDbl, nPeriods);

   witFree (consRateDbl);
   }

   {
   float * routingShare;
   float   goodRoutingShare[] = {1.0, 3.0, 1.0, 3.0, 1.0};

   witGetSubsBomEntryRoutingShare (theWitRun, "PS1", 0, 0, & routingShare);

   compareFltVecs (routingShare, goodRoutingShare, nPeriods);

   witFree (routingShare);
   }

   {
   double * routingShareDbl;
   double   goodRoutingShareDbl[] = {1.0, 3.0, 1.0, 3.0, 1.0};

   witGetSubsBomEntryRoutingShareDbl (
      theWitRun, "PS1", 0, 0, & routingShareDbl);

   compareDblVecs (routingShareDbl, goodRoutingShareDbl, nPeriods);

   witFree (routingShareDbl);
   }

   {
   float  theFlt;
   double theDbl;

   witGetSubsBomEntryExecPenalty    (theWitRun, "PS1", 0, 0, & theFlt);
   witGetSubsBomEntryExecPenaltyDbl (theWitRun, "PS1", 0, 0, & theDbl);

   assert (fabs (theFlt - 29.87) < dblEps);
   assert (fabs (theDbl - 29.87) < dblEps);
   }

   /* subsBomEntry appData */
   {
   void * ptr;
   witSetSubsBomEntryAppData( theWitRun, "PS1", 0, 0, theAppData );
   witGetSubsBomEntryAppData( theWitRun, "PS1", 0, 0, &ptr);
   assert( ptr==theAppData );
   }

   /* impactPeriod */
   {
   int * impactPeriod;
   int   correctImpactPeriod[] = { -1, 1, 2, 3, -1};

   witGetSubsBomEntryImpactPeriod (theWitRun, "PS1", 0, 0, &impactPeriod);

   compareIntVecs (impactPeriod, correctImpactPeriod, nPeriods);

   witFree (impactPeriod);
   }

   {
   int nSubsBomEntries;
   witGetBomEntryNSubsBomEntries( theWitRun, "PS1", 1, &nSubsBomEntries );
   assert( nSubsBomEntries == 1 );
   }

   /*-------------------------------------------------------------------------*/
   /* belowList                                                               */
   /*                                                                         */
   /* This is being done at this point, instead of with the other Part        */
   /* attributes, so that the below list will not be empty.                   */
   /*-------------------------------------------------------------------------*/

   {
   int      lenList;
   char * * partNameList;
   int      i;

   witGetPartBelowList (theWitRun, "PS1", & lenList, & partNameList);

   printf ("\nBelow List:\n");

   for (i = 0; i < lenList; ++ i)
      printf ("   %s\n", partNameList[i]);

   for (i = 0; i < lenList; ++ i)
      witFree (partNameList[i]);

   witFree (partNameList);
   }

   /*-------------------------------------------------------------------------*/
   /* Object Iteration.                                                       */
   /*-------------------------------------------------------------------------*/

   testObjItr (theWitRun);

   /*-------------------------------------------------------------------------*/

   {
   witBoolean bool;
   witPreprocess( theWitRun );
   witOptPreprocess( theWitRun );
   witDisplayData( theWitRun, WitSTDOUT );
   witGetPreprocessed( theWitRun, &bool );
   assert( bool );
   }
   {
   witBoolean accAfterOptImp,accelerated;
   witGetAccAfterOptImp( theWitRun, &accAfterOptImp );
   witGetAccelerated( theWitRun, &accelerated );

   assert( !accAfterOptImp );
   assert( !accelerated );

   witSetAccAfterOptImp( theWitRun, WitTRUE );
   witGetAccAfterOptImp( theWitRun, &accAfterOptImp );

   assert( accAfterOptImp );

   }

   /* Opt implode */
   {
   float    prodVol    [] = {5000., 5000., 2000., 0000., 2000.};
   float    subVol1    [] = {4001., 4001., 1001., 501., 21.};
   float    subVol     [] = {4000., 4000., 1000., 500., 20.};
   double   subVolDbl  [] = {4000., 4000., 1000., 500., 20.};
   float    shipVol    [] = {6000., 6000., 3000., 0000., 3000.};
   double   shipVolDbl [] = {6000., 6000., 3000., 0000., 3000.};
   float    cumShipSLB [] = {10000., 10000., 10000., 10000., 10000.};
   float    cumShipHUB [] = {   -1.,    -1.,    -1.,    -1.,    -1.};
   float *  fv;
   double * dv;
   char *   string;

   witSetDemandCumShipBounds (theWitRun, "PS1", "US",
                              NULL,
                              cumShipSLB,
                              cumShipHUB);

   witSetSolverLogFileName (theWitRun, "solver-alt.log" );
   witGetSolverLogFileName (theWitRun, & string);

   assert (strcmp (string, "solver-alt.log") == 0);

   witFree (string);

   witSetPartProdVol( theWitRun, "PS1", prodVol );
   witGetPartProdVol( theWitRun, "PS1", &fv );
   compareFltVecs( fv, prodVol, nPeriods );
   witFree (fv);

   witSetDemandShipVol( theWitRun, "PS1", "US", shipVol );
   witGetDemandShipVol( theWitRun, "PS1", "US", &fv );
   compareFltVecs( fv, shipVol, nPeriods );
   witFree (fv);

   witSetDemandShipVolDbl( theWitRun, "PS1", "US", shipVolDbl );
   witGetDemandShipVolDbl( theWitRun, "PS1", "US", &dv );
   compareDblVecs( dv, shipVolDbl, nPeriods );
   witFree (dv);

   witSetSubsBomEntryProdVol( theWitRun, "PS1", 0, 0, subVol1);
   witGetSubsBomEntryProdVol( theWitRun, "PS1", 0, 0, &fv );
   compareFltVecs( fv, subVol1, nPeriods );
   witFree (fv);

   witSetSubsBomEntrySubVol( theWitRun, "PS1", 0, 0, subVol );
   witGetSubsBomEntrySubVol( theWitRun, "PS1", 0, 0, &fv );
   compareFltVecs( fv, subVol, nPeriods );
   witFree (fv);

   witSetSubsBomEntrySubVolDbl( theWitRun, "PS1", 0, 0, subVolDbl );
   witGetSubsBomEntrySubVolDbl( theWitRun, "PS1", 0, 0, &dv );
   compareDblVecs( dv, subVolDbl, nPeriods );
   witFree (dv);


   {
   witBoolean postprocessed;
   witGetPostprocessed( theWitRun, &postprocessed );
   assert( !postprocessed );
   witPostprocess(theWitRun);
   witGetPostprocessed( theWitRun, &postprocessed );
   assert( postprocessed );
   }


   {
   witAttr optInitMethod;
   witGetOptInitMethod( theWitRun, & optInitMethod );
   assert( optInitMethod == WitSCHED_OPT_INIT_METHOD );

   witSetOptInitMethod( theWitRun, WitCRASH_OPT_INIT_METHOD );
   witGetOptInitMethod( theWitRun, & optInitMethod );
   assert( optInitMethod == WitCRASH_OPT_INIT_METHOD );

   witSetOptInitMethod( theWitRun, WitHEUR_OPT_INIT_METHOD );
   witGetOptInitMethod( theWitRun, & optInitMethod );
   assert( optInitMethod == WitHEUR_OPT_INIT_METHOD );
   }

   if (cplexEmbedded)
      witOptImplode (theWitRun);
   else
      witHeurImplode (theWitRun);

   witWriteProdSched( theWitRun, WitSTDOUT, WitBSV );
   witWriteShipSched( theWitRun, WitSTDOUT, WitCSV );
   witWriteCriticalList( theWitRun, WitSTDOUT, WitBSV, 0 );

   witSetMesgFileAccessMode( theWitRun, WitFALSE, "w" );
   witWriteExecSched( theWitRun, "apiAll.sch", WitBSV );
   witSetMesgFileAccessMode( theWitRun, WitFALSE, "a" );
   witWriteShipSched( theWitRun, "apiAll.sch", WitBSV );
   witSetMesgFileAccessMode( theWitRun, WitFALSE, "w" );

   fflush(stdout);
   system("cat apiAll.sch");
   unlink( "apiAll.sch" );
   }

   /* Get global solution attributes */

   if (cplexEmbedded )
      {
      float  objValue,  boundsValue,  rev,  inv,  serv,  sub;
      double objValueD, boundsValueD, revD, invD, servD, subD;
      witBoolean optSolved;

      witGetObjValue( theWitRun, &objValue );
      printf( "objValue = %f\n",objValue);

      witGetBoundsValue( theWitRun, &boundsValue );
      printf( "boundsValue = %f\n",boundsValue);

      objValue    = 0.0;
      boundsValue = 0.0;

      witGetObjValues( theWitRun, &objValue, &boundsValue );
      printf( "objValue = %f, boundsValue = %f\n",objValue,boundsValue);

      witGetBoundsValueDbl( theWitRun, &boundsValueD );
      printf( "boundsValue = %f\n",boundsValueD);

      objValueD    = 0.0;
      boundsValueD = 0.0;

      witGetObjValuesDbl( theWitRun, &objValueD, &boundsValueD );
      printf( "objValue = %f, boundsValue = %f\n",objValueD,boundsValueD);

      witGetPostprocessed( theWitRun, &optSolved );
      assert( optSolved );
      }

   witEvalObjectives(theWitRun);

   {
   witBoolean accAfterOptImp,accelerated;
   witGetAccAfterOptImp( theWitRun, &accAfterOptImp );
   witGetAccelerated( theWitRun, &accelerated );

   if (cplexEmbedded)
      {
      assert (accAfterOptImp);
      assert (accelerated);
      }

   witSetAccAfterOptImp( theWitRun, WitFALSE );
   witGetAccelerated( theWitRun, &accelerated );
   witGetAccAfterOptImp( theWitRun, &accAfterOptImp );

   if (cplexEmbedded)
      {
      assert (! accelerated);
      assert (! accAfterOptImp);

      prtRemove ("solver-alt.log");
      }
   }

   /* Heuristic Implosion */
   {
   witBoolean postproc;

   witHeurImplode( theWitRun );

   witWriteExecSched( theWitRun, WitSTDOUT, WitCSV );
   witWriteShipSched( theWitRun, WitSTDOUT, WitBSV );
   witWriteCriticalList( theWitRun, WitSTDOUT, WitCSV, 0 );
   witGetPostprocessed( theWitRun, &postproc );
   assert( postproc );
   }
   {
   witBoolean bool;
   witGetFeasible( theWitRun, &bool );
/* assert( bool ); */
   }

   /* Get critical list */
   {
   int i;
   int lenCritList, *critPerList;
   char **critPartList;
   witGetCriticalList( theWitRun, &lenCritList, &critPartList, &critPerList);
   for ( i=0; i<lenCritList; i++ ) {
      printf(" Critical list item: %d  part: %s  period: %d\n",
             i, critPartList[i], critPerList[i] );
      witFree (critPartList[i]);
   }
   witFree (critPartList);
   witFree (critPerList);
   } 

   /* Get Focus Shortage Vol using fssShipVol */
   {
   int i;
   int lenList;
   char **partList;
   float **focShortVol;

   witSetUseFocusHorizons( theWitRun, WitFALSE );

   witGetFocusShortageVol( theWitRun, &lenList, &partList, &focShortVol);
   for ( i=0; i<lenList; i++ ) {
      printf(" Focus Shortage item: %d  part: %s\n", i, partList[i] );
      witFree (partList[i]);
      printFltVec ("focusedShortage", focShortVol[i], nPeriods);
      witFree (focShortVol[i]);
   }
   witFree (partList);
   witFree (focShortVol);
   } 

   /* Get Focus Shortage Vol using FocusHorizons */
   {
   int i;
   int lenList;
   char **partList;
   float **focShortVol;

   witSetUseFocusHorizons( theWitRun, WitTRUE );
   witGetDemandFocusHorizon( theWitRun, "PS1", "AGP", &i );
   assert( i == nPeriods-2 );

   witGetFocusShortageVol( theWitRun, &lenList, &partList, &focShortVol);
   for ( i=0; i<lenList; i++ ) {
      printf(" Focus Shortage item: %d  part: %s\n", i, partList[i] );
      witFree (partList[i]);
      printFltVec ("focusedShortage", focShortVol[i], nPeriods);
      witFree (focShortVol[i]);
   }
   witFree (partList);
   witFree (focShortVol);
   }


   /* Get Focus Shortage Vol using FocusHorizons: Double Precision */
   {
   int i;
   int lenList;
   char **partList;
   double **focShortVol;

   witGetFocusShortageVolDbl( theWitRun, &lenList, &partList, &focShortVol);
   for ( i=0; i<lenList; i++ ) {
      printf(" Focus Shortage item: %d  part: %s\n", i, partList[i] );
      witFree (partList[i]);
      printDblVec ("focusedShortage", focShortVol[i], nPeriods);
      witFree (focShortVol[i]);
   }
   witFree (partList);
   witFree (focShortVol);
   }


   /* Get part solution values */
   {
   float  * fv;
   double * dv;

   witGetPartConsVol( theWitRun, "CompA", &fv);
   printFltVec ("ConsVol", fv, nPeriods);
   witFree (fv);

   witGetPartConsVolDbl( theWitRun, "CompA", &dv);
   printDblVec ("ConsVol", dv, nPeriods);
   witFree (dv);

   witGetPartResidualVol( theWitRun, "CompA", &fv);
   printFltVec ("ResidualVol", fv, nPeriods);
   witFree (fv);

   witGetPartResidualVolDbl( theWitRun, "CompA", &dv);
   printDblVec ("ResidualVol", dv, nPeriods);
   witFree (dv);

   witGetPartExcessVol( theWitRun, "CompA", &fv);
   printFltVec ("ExcessVol", fv, nPeriods);
   witFree (fv);

   witGetPartExcessVolDbl( theWitRun, "CompA", &dv);
   printDblVec ("ExcessVol", dv, nPeriods);
   witFree (dv);

   witGetPartProdVol( theWitRun, "PS2", &fv);
   printFltVec ("ProdVol", fv, nPeriods);
   witFree (fv);

   witGetPartProdVolDbl (theWitRun, "PS2", & dv);
   printDblVec ("ProdVol", dv, nPeriods);
   witFree (dv);

   witGetPartScrapVol( theWitRun, "CompA", &fv);
   printFltVec ("ScrapVol", fv, nPeriods);
   witFree (fv);

   witGetPartScrapVolDbl( theWitRun, "CompA", &dv);
   printDblVec ("ScrapVol", dv, nPeriods);
   witFree (dv);

   witGetPartShadowPrice( theWitRun, "CompA", &fv);
   printFltVec ("ShadowPrice", fv, nPeriods);
   witFree (fv);

   witGetPartShadowPriceDbl (theWitRun, "CompA", & dv);
   printDblVec ("ShadowPrice", dv, nPeriods);
   witFree (dv);

   witGetPartFocusShortageVol( theWitRun, "CompB", &fv);
   printFltVec ("FocusShortageVol", fv, nPeriods);
   witFree (fv);

   witGetPartFocusShortageVolDbl( theWitRun, "CompB", &dv);
   printDblVec ("FocusShortageVol", dv, nPeriods);
   witFree (dv);

   witGetOperationFssExecVol( theWitRun, "PS1", &fv);
   printFltVec ("FssExecVol", fv, nPeriods);
   witFree (fv);

   witGetOperationFssExecVolDbl( theWitRun, "PS1", &dv);
   printDblVec ("FssExecVol", dv, nPeriods);
   witFree (dv);

   witGetSubsBomEntryFssSubVol( theWitRun, "PS1", 0, 0, &fv );
   printFltVec ("FssSubVol", fv, nPeriods);
   witFree (fv);

   witGetSubsBomEntryFssSubVolDbl( theWitRun, "PS1", 1, 0, &dv );
   printDblVec ("FssSubVol", dv, nPeriods);
   witFree (dv);

   witGetPartStockVol( theWitRun, "CompA", &fv);
   printFltVec ("StockVol", fv, nPeriods);
   witFree (fv);

   witGetPartStockVolDbl( theWitRun, "CompA", &dv);
   printDblVec ("StockVol", dv, nPeriods);
   witFree (dv);

   witGetPartSupplyVol( theWitRun, "CompA", &fv);
   printFltVec ("SupplyVol", fv, nPeriods);
   witFree (fv);
   }

   /* Get demand solution values */
   {
   float *fv;

   witGetDemandShipVol( theWitRun, "MOBILE", "US", &fv);
   printFltVec ("ShipVol", fv, nPeriods);
   witFree (fv);
   }

   /* Get substitute solution values */
   {
   float *fv;
   witGetSubsBomEntryProdVol( theWitRun, "PS1", 0, 0, &fv);
   printFltVec ("ProdVol", fv, nPeriods);
   witFree (fv);
   }

   /* Test Concurrent Pegging */

   {
   testExecVolPegging    (theWitRun, "PS1", "US", 1);
   testSubVolPegging     (theWitRun, "PS1", "US", 1);
   testExecVolPegging    (theWitRun, "PS1", "US", 2);
   testExecVolPeggingDbl (theWitRun, "PS1", "US", 2);
   testSubVolPegging     (theWitRun, "PS1", "US", 2);
   testSubVolPeggingDbl  (theWitRun, "PS1", "US", 2);

   witClearPegging       (theWitRun);

   testExecVolPegging    (theWitRun, "PS1", "US", 2);
   testSubVolPegging     (theWitRun, "PS1", "US", 2);
   }
   
   /* Write and Read data and switch to new witRun */
   {
   witWriteData( theWitRun, "apiAll.data" );

   witNewRun (& theMrpRun);

   witInitialize( theMrpRun );
   witSetWit34Compatible( theMrpRun, WitTRUE );
   witReadData( theMrpRun, "apiAll.data" );

   fflush(stdout);
   system ("cat apiAll.data");
   unlink( "apiAll.data" );
   }

   /* MRP */
   {
   float supp[] = {500, 500, 500, 500, 500};

   witSetPartSupplyVol (theMrpRun, "CompB", supp);

   witMrp( theMrpRun );
   witWriteReqSched( theMrpRun, WitSTDOUT, WitBSV );
   }

   /* Get part mrp solution values */
   {
   float  * fv;
   double * dv;

   witGetPartReqVol( theMrpRun, "CompB", &fv);
   printFltVec ("ReqVol", fv, nPeriods);
   witFree (fv);

   witGetPartReqVolDbl( theMrpRun, "CompB", &dv);
   printDblVec ("ReqVol", dv, nPeriods);
   witFree (dv);

   witGetPartMrpProdVol( theMrpRun, "PS2", &fv);
   printFltVec ("MrpProdVol", fv, nPeriods);
   witFree (fv);

   witGetPartMrpResidualVol( theMrpRun, "CompA", &fv);
   printFltVec ("MrpResidualVol", fv, nPeriods);
   witFree (fv);

   witGetPartMrpResidualVolDbl( theMrpRun, "CompA", &dv);
   printDblVec ("MrpResidualVol", dv, nPeriods);
   witFree (dv);

   witGetPartMrpExcessVol( theMrpRun, "CompA", &fv);
   printFltVec ("MrpExcessVol", fv, nPeriods);
   witFree (fv);

   witGetPartMrpExcessVolDbl( theMrpRun, "CompA", &dv);
   printDblVec ("MrpExcessVol", dv, nPeriods);
   witFree (dv);

   witGetPartMrpConsVol( theMrpRun, "CompB", &fv);
   printFltVec ("MrpConsVol", fv, nPeriods);
   witFree (fv);

   witGetPartMrpConsVolDbl( theMrpRun, "CompB", &dv);
   printDblVec ("MrpConsVol", dv, nPeriods);
   witFree (dv);

   witGetOperationMrpExecVol( theMrpRun, "PS2", &fv);
   printFltVec ("MrpExecVol", fv, nPeriods);
   witFree (fv);

   witGetOperationMrpExecVolDbl( theMrpRun, "PS2", &dv);
   printDblVec ("MrpExecVol", dv, nPeriods);
   witFree (dv);

   witGetSubsBomEntryMrpSubVol (theMrpRun, "PS1", 1, 0, & fv);
   printFltVec ("MrpSubVol", fv, nPeriods);
   witFree (fv);

   witGetSubsBomEntryMrpSubVolDbl (theMrpRun, "PS1", 1, 0, & dv);
   printDblVec ("MrpSubVol", dv, nPeriods);
   witFree (dv);
   }

   testPip    (theWitRun);
   testPipDbl (theWitRun);

   testPgdCritList (theWitRun);

   witDeleteRun (theWitRun);
   witDeleteRun (theMrpRun);

   {
   witInitialize( theObj1Run );
   witSetWit34Compatible( theObj1Run, WitTRUE );
   witSetHashTableSize( theObj1Run, 5 );
   witSetNPeriods( theObj1Run, nPeriods );
   witSetIndependentOffsets (theObj1Run, WitTRUE);
   witSetMultiRoute (theObj1Run, WitTRUE);
   }


   /* Parts */
   {
   float  supplyVolCompA [] = {2000., 2000., 2000., 2000., 2000.};
   float  supplyVolCompB [] = {3500., 2500., 2500., 2500., 2500.};
   float  supplyVolCompC [] = {2000., 2000., 2000., 2000., 2000.};
   float  supplyVolCap   [] = {3500., 3500., 3500., 3500., 3500.};

   float  obj1ProdCost   [] = {1.1,  1.2,  1.3,  1.4,  1.5};
   float  scrapCost      [] = {0.1,  0.2,  0.3,  0.4,  0.5};
   double scrapCostDbl   [] = {0.1,  0.2,  0.3,  0.4,  0.5};
   float  stockCost      [] = {0.01, 0.02, 0.03, 0.04, 0.05};
   double stockCostDbl   [] = {0.01, 0.02, 0.03, 0.04, 0.05};
   float  incLotSize     [] = { 500.0,  500.0,  500.0,  500.0,  500.0};
   float  minLotSize     [] = {2500.0, 2500.0, 2500.0, 2500.0, 2500.0};

   witBoolean   singleSource;
   witBoolean   propRtgSet [] = {WitTRUE, WitFALSE, WitTRUE, WitFALSE, WitTRUE};
   witBoolean * propRtgGet;
   witBoolean   propRoutingGet;

   witAddPart( theObj1Run, "PS1", WitPRODUCT );
   witAddPart (theObj1Run, "PS2", WitPRODUCT);
   witAddPart (theObj1Run, "MOBILE", WitPRODUCT);
   witAddPart( theObj1Run, "CompA", WitRAW );
   witSetPartSupplyVol( theObj1Run, "CompA", supplyVolCompB );

   witAddPart( theObj1Run, "CompB", WitRAW );
   witSetPartSupplyVol( theObj1Run, "CompB", supplyVolCompB );

   witAddPart( theObj1Run, "CompC", WitRAW );
   witSetPartSupplyVol( theObj1Run, "CompC", supplyVolCompC );

   witAddPart( theObj1Run, "TestCap", WitCAPACITY );
   witSetPartSupplyVol( theObj1Run, "TestCap", supplyVolCap );

   witSetPartObj1ProdCost     (theObj1Run, "PS1", obj1ProdCost);
   witSetPartObj1ScrapCost    (theObj1Run, "PS1", scrapCost);
   witSetPartObj1ScrapCostDbl (theObj1Run, "PS1", scrapCostDbl);
   witSetPartScrapCost        (theObj1Run, "PS1", scrapCost);
   witSetPartScrapCostDbl     (theObj1Run, "PS1", scrapCostDbl);
   witSetPartStockCost        (theObj1Run, "PS1", stockCost);
   witSetPartStockCostDbl     (theObj1Run, "PS1", stockCostDbl);
   witSetPartObj1StockCost    (theObj1Run, "PS1", stockCost);
   witSetPartObj1StockCostDbl (theObj1Run, "PS1", stockCostDbl);

   witSetPartSingleSource (theObj1Run, "PS1", WitTRUE);
   witSetPartPropRtg      (theObj1Run, "PS1", propRtgSet);
   witSetPartPropRouting  (theObj1Run, "PS2", WitTRUE);

   witSetOperationIncLotSize     (theObj1Run, "PS1", incLotSize);
   witSetOperationMinLotSize     (theObj1Run, "PS1", minLotSize);
   witSetOperationIncLotSize     (theObj1Run, "PS2", incLotSize);

   {  /* verify get obj1 product cost */
   float *cost;
   witGetPartObj1ProdCost( theObj1Run, "PS1", &cost );
   compareFltVecs( cost, obj1ProdCost, nPeriods );
   witFree (cost);
   }

   {  /* verify get scrap cost */
   float *cost;
   witGetPartScrapCost( theObj1Run, "PS1", &cost );
   compareFltVecs( cost, scrapCost, nPeriods );
   witFree (cost);
   }

   {  /* verify get scrap cost, double */
   double *cost;
   witGetPartScrapCostDbl( theObj1Run, "PS1", &cost );
   compareDblVecs( cost, scrapCostDbl, nPeriods );
   witFree (cost);
   }

   {  /* verify get obj1 scrap cost */
   float *cost;
   witGetPartObj1ScrapCost( theObj1Run, "PS1", &cost );
   compareFltVecs( cost, scrapCost, nPeriods );
   witFree (cost);
   }

   {  /* verify get obj1 scrap cost, double */
   double *cost;
   witGetPartObj1ScrapCostDbl( theObj1Run, "PS1", &cost );
   compareDblVecs( cost, scrapCostDbl, nPeriods );
   witFree (cost);
   }

   {  /* verify get stock cost */
   float *cost;
   witGetPartStockCost( theObj1Run, "PS1", &cost );
   compareFltVecs( cost, stockCost, nPeriods );
   witFree (cost);
   }

   {  /* verify get stock cost, double */
   double *cost;
   witGetPartStockCostDbl( theObj1Run, "PS1", &cost );
   compareDblVecs( cost, stockCostDbl, nPeriods );
   witFree (cost);
   }

   {  /* verify get obj1 stock cost */
   float *cost;
   witGetPartObj1StockCost( theObj1Run, "PS1", &cost );
   compareFltVecs( cost, stockCost, nPeriods );
   witFree (cost);
   }

   {  /* verify get obj1 stock cost, double */
   double *cost;
   witGetPartObj1StockCostDbl( theObj1Run, "PS1", &cost );
   compareDblVecs( cost, stockCostDbl, nPeriods );
   witFree (cost);
   }

   witGetPartSingleSource (theObj1Run, "PS1", & singleSource);

   assert (singleSource);

   witGetPartPropRtg (theObj1Run, "PS1", & propRtgGet);

   compareIntVecs (propRtgGet, propRtgSet, nPeriods);

   witFree (propRtgGet);

   witGetPartPropRouting (theObj1Run, "PS2", & propRoutingGet);

   assert (propRoutingGet);
   }

   /* Demands */
   {
   float  demandVolPS1US       [] = { 500., 500., 500., 500., 500. };
   float  demandVolPS1AGP      [] = { 500., 500., 500., 500., 500. };
   float  demandVolPS2US       [] = { 500., 500.,1000.,1500.,1500. };
   float  demandVolMOBILEUS    [] = { 1000., 1000.,1000.,1000.,1000. };

   float  cumShipRewardPS1US   [] = { 50., 50., 40., 50., 50. };
   double cumShipRewardDblPS1US[] = { 50., 50., 40., 50., 50. };
   float  cumShipRewardPS1AGP  [] = { 150., 150., 140., 150., 150. };

   float  shipRewardPS1US      [] = { 5., 5., 4., 5., 5. };
   double shipRewardDblPS1US   [] = { 5., 5., 4., 5., 5. };
   float  shipRewardPS1AGP     [] = { 15., 15., 14., 15., 15. };

   witAddDemand( theObj1Run, "PS1", "US" );

   witSetDemandObj1CumShipReward( theObj1Run, "PS1", "US", 
        cumShipRewardPS1US );
   witSetDemandObj1CumShipRewardDbl( theObj1Run, "PS1", "US", 
        cumShipRewardDblPS1US );
   witSetDemandCumShipReward( theObj1Run, "PS1", "US", 
        cumShipRewardPS1US );
   witSetDemandCumShipRewardDbl( theObj1Run, "PS1", "US", 
        cumShipRewardDblPS1US );
   witSetDemandObj1ShipReward( theObj1Run, "PS1", "US", 
        shipRewardPS1US );
   witSetDemandObj1ShipRewardDbl( theObj1Run, "PS1", "US", 
        shipRewardDblPS1US );
   witSetDemandShipReward( theObj1Run, "PS1", "US", 
        shipRewardPS1US );
   witSetDemandShipRewardDbl( theObj1Run, "PS1", "US", 
        shipRewardDblPS1US );

   witAddDemand( theObj1Run, "PS1", "AGP");
   witAddDemand( theObj1Run, "PS2", "US");
   witAddDemand( theObj1Run, "MOBILE", "US");
   
   witSetDemandDemandVol (theObj1Run, "PS1",    "US",  demandVolPS1US);
   witSetDemandDemandVol (theObj1Run, "PS1",    "AGP", demandVolPS1AGP);
   witSetDemandDemandVol (theObj1Run, "PS2",    "US",  demandVolPS2US);
   witSetDemandDemandVol (theObj1Run, "MOBILE", "US",  demandVolMOBILEUS);

   /* Verify demand settings */
   {  
   float  * fv;
   double * dv;

   witGetDemandShipReward( theObj1Run, "PS1", "US", &fv ); 
   compareFltVecs( fv, shipRewardPS1US, nPeriods );
   witFree (fv);

   witGetDemandShipRewardDbl( theObj1Run, "PS1", "US", &dv ); 
   compareDblVecs( dv, shipRewardDblPS1US, nPeriods );
   witFree (dv);

   witGetDemandObj1ShipReward( theObj1Run, "PS1", "US", &fv ); 
   compareFltVecs( fv, shipRewardPS1US, nPeriods );
   witFree (fv);

   witGetDemandObj1ShipRewardDbl( theObj1Run, "PS1", "US", &dv ); 
   compareDblVecs( dv, shipRewardDblPS1US, nPeriods );
   witFree (dv);

   witGetDemandCumShipReward( theObj1Run, "PS1", "US", &fv ); 
   compareFltVecs( fv, cumShipRewardPS1US, nPeriods );
   witFree (fv);

   witGetDemandCumShipRewardDbl( theObj1Run, "PS1", "US", &dv ); 
   compareDblVecs( dv, cumShipRewardDblPS1US, nPeriods );
   witFree (dv);

   witGetDemandObj1CumShipReward( theObj1Run, "PS1", "US", &fv ); 
   compareFltVecs( fv, cumShipRewardPS1US, nPeriods );
   witFree (fv);

   witGetDemandObj1CumShipRewardDbl( theObj1Run, "PS1", "US", &dv ); 
   compareDblVecs( dv, cumShipRewardDblPS1US, nPeriods );
   witFree (dv);
   }
   }

   /* BOM's */
   {
   witBoolean   singleSource;
   witBoolean   propRtgSet[] = {WitFALSE, WitTRUE, WitTRUE, WitTRUE, WitFALSE};
   witBoolean * propRtgGet;
   witBoolean   propRoutingGet;

   witAddBomEntry( theObj1Run, "PS1", "CompA");
   witAddBomEntry(  theObj1Run, "PS1", "CompB");
   witAddBomEntry( theObj1Run, "PS1", "TestCap");

   witAddBomEntry( theObj1Run, "PS2", "CompA");
   witAddBomEntry( theObj1Run, "PS2", "CompB");
   witAddBomEntry( theObj1Run, "PS2", "CompC");
   witAddBomEntry( theObj1Run, "PS2", "TestCap");

   witAddBomEntry( theObj1Run, "MOBILE", "CompB");
   witAddBomEntry( theObj1Run, "MOBILE", "CompC");
   witAddBomEntry( theObj1Run, "MOBILE", "TestCap");

   witSetBomEntrySingleSource (theObj1Run, "PS1", 0, WitTRUE);

   witGetBomEntrySingleSource (theObj1Run, "PS1", 0, & singleSource);

   assert (singleSource);

   witSetBomEntryPropRtg     (theObj1Run, "PS2", 1,   propRtgSet);
   witGetBomEntryPropRtg     (theObj1Run, "PS2", 1, & propRtgGet);

   compareIntVecs (propRtgGet, propRtgSet, nPeriods);

   witFree (propRtgGet);

   witSetBomEntryPropRouting (theObj1Run, "PS1", 1,   WitTRUE);
   witGetBomEntryPropRouting (theObj1Run, "PS1", 1, & propRoutingGet);

   assert (propRoutingGet);
   }

   /* Part PS1 BOM substitute */
   {
   float  subCostCompA   []={ 1., 2., 3., 4., 5.};
   double subCostDblCompA[]={ 1., 2., 3., 4., 5.};
   float  subCostCompB   []={ 10., 20., 30., 40., 50.};
   float  offsetCompA    []={ 2., 2., 3., 3., 3.};
   double offsetDblCompA []={ 2., 2., 3., 3., 3.};

   witAddSubsBomEntry( theObj1Run, "PS1", 0, "CompA");
   witSetSubsBomEntryObj1SubCost( theObj1Run, "PS1", 0, 0, subCostCompA);
   witSetSubsBomEntryObj1SubCostDbl (
      theObj1Run, "PS1", 0, 0, subCostDblCompA);
   witSetSubsBomEntrySubCost( theObj1Run, "PS1", 0, 0, subCostCompA);
   witSetSubsBomEntrySubCostDbl (
      theObj1Run, "PS1", 0, 0, subCostDblCompA);

   witSetSubsBomEntryOffset     ( theObj1Run, "PS1", 0, 0, offsetCompA);
   witSetSubsBomEntryOffsetDbl  ( theObj1Run, "PS1", 0, 0, offsetDblCompA);

   witAddSubsBomEntry(  theObj1Run, "PS1", 1, "CompB");

   {  
   float *fv;
   witGetSubsBomEntrySubCost( theObj1Run, "PS1", 0, 0, &fv ); 
   compareFltVecs( fv, subCostCompA, nPeriods );
   witFree (fv);
   }

   {  
   double *dv;
   witGetSubsBomEntrySubCostDbl( theObj1Run, "PS1", 0, 0, &dv ); 
   compareDblVecs( dv, subCostDblCompA, nPeriods );
   witFree (dv);
   }

   {  
   float *fv;
   witGetSubsBomEntryObj1SubCost( theObj1Run, "PS1", 0, 0, &fv ); 
   compareFltVecs( fv, subCostCompA, nPeriods );
   witFree (fv);
   }

   {  
   double *dv;
   witGetSubsBomEntryObj1SubCostDbl( theObj1Run, "PS1", 0, 0, &dv ); 
   compareDblVecs( dv, subCostDblCompA, nPeriods );
   witFree (dv);
   }

   {
   float *fv;
   witGetSubsBomEntryOffset( theObj1Run, "PS1", 0, 0, &fv );
   compareFltVecs( fv, offsetCompA, nPeriods );
   witFree (fv);
   }

   {
   double *dv;
   witGetSubsBomEntryOffsetDbl( theObj1Run, "PS1", 0, 0, &dv );
   compareDblVecs( dv, offsetDblCompA, nPeriods );
   witFree (dv);
   }
   }

   {
   witBoolean theBool;

   witSetMipMode                (theObj1Run,                WitTRUE);
   witGetMipMode                (theObj1Run,              & theBool);

   assert (theBool);

   witSetOperationIntExecVols   (theObj1Run, "PS1",         WitTRUE);
   witGetOperationIntExecVols   (theObj1Run, "PS1",       & theBool);

   assert (theBool);

   witSetSubsBomEntryIntSubVols (theObj1Run, "PS1", 0, 0,   WitTRUE);
   witGetSubsBomEntryIntSubVols (theObj1Run, "PS1", 0, 0, & theBool);

   assert (theBool);

   witSetDemandIntShipVols      (theObj1Run, "PS1", "US",    WitTRUE);
   witGetDemandIntShipVols      (theObj1Run, "PS1", "US",  & theBool);

   assert (theBool);
   }

   testWriteReadData (theObj1Run, "obj1.data");

   /* Do objective 1 implosion */
   {
   if (cplexEmbedded)
      {
      witOptImplode (theObj1Run);

      prtRemove ("solver.log");
      }
   else
      witHeurImplode (theObj1Run);

   witWriteExecSched( theObj1Run, WitSTDOUT, WitBSV );
   witWriteShipSched( theObj1Run, WitSTDOUT, WitBSV );
   }

   /* Test opt implosion with CPLEX, if possible. */

   if (cplexEmbedded)
      {
      int    cplexStatusCode;
      char * cplexStatusText;
      float  cplexMipBound;
      double cplexMipBoundDbl;
      float  cplexMipRelGap;
      double cplexMipRelGapDbl;

      witOptImplode         (theObj1Run);

      witGetCplexStatusCode (theObj1Run, & cplexStatusCode);

      assert (cplexStatusCode == 101);

      witGetCplexStatusText (theObj1Run, & cplexStatusText);

      assert (equalStrings (cplexStatusText, "integer optimal solution"));

      witFree (cplexStatusText);

      witGetCplexMipBound    (theObj1Run, & cplexMipBound);
      witGetCplexMipBoundDbl (theObj1Run, & cplexMipBoundDbl);

      assert (fabs (cplexMipBound    - 369150) < .001);
      assert (fabs (cplexMipBoundDbl - 369150) < .001);

      witGetCplexMipRelGap    (theObj1Run, & cplexMipRelGap);
      witGetCplexMipRelGapDbl (theObj1Run, & cplexMipRelGapDbl);

      assert (fabs (cplexMipRelGap)    < 1.0e-6);
      assert (fabs (cplexMipRelGapDbl) < 1.0e-6);

      prtRemove                       ("solver.log");

      witWriteExecSched   (theObj1Run, WitSTDOUT,   WitBSV);
      witWriteShipSched   (theObj1Run, WitSTDOUT,   WitBSV);
      }

   /* Generate priorites */
   { 
   witGeneratePriorities( theObj1Run );
   witHeurImplode( theObj1Run );
   }


   /* Test WitRun copying */
   {
   int lhsInt, rhsInt;
   WitRun * lhs;

   witNewRun (& lhs);
   witCopyData( lhs, theObj1Run );

   witGetNPeriods( lhs,        &lhsInt );
   witGetNPeriods( theObj1Run, &rhsInt );
   assert( lhsInt == rhsInt );

   witGetHashTableSize( lhs,        &lhsInt );
   witGetHashTableSize( theObj1Run, &rhsInt );
   assert( lhsInt == rhsInt );

   witDeleteRun( lhs );

   witCopyData (theObj1Run, theObj1Run);               
      /*                                             */
      /* Test of copying a WitRun to itself (no-op). */
   }

   witDeleteRun( theObj1Run );

   testOperationApis();
   testBopApis();
   testAddPart();
   testPartToArcApis ();
   testHeurAlloc ();
   testHeurAllocDbl ();
   testHeurAllocTwme ();
   testHeurAllocTwmeDbl ();
   testDeletion ();

   if (cplexEmbedded)
      testAccOptImp ();

   testCumShipVol ();

   /* witFree, witMalloc */
   {
   void * mem = NULL;
   witReturnCode rc = witMalloc(123,&mem);
   assert(mem!=NULL);
   assert(rc==WitINFORMATIONAL_RC);
   witFree(mem);
   }

   witDeleteRun (NULL);

   testExtOpt          ();
   testCopyObjData1WR  ();
   testCopyObjData2WRs ();
   testShipLateAllowed ();
   testGetExpCycle     ();
   testStageByObject   ();
   testStageByPeriod   ();
   testMultiObjMode    ();
   testLeadTimeBounds  ();
   testAccOptWithCplex ();

   printf (
      "\n"
      "Normal termination of apiAll.\n"
      "\n");

   exit (0);
   }
   /* End of Main Program */

/*----------------------------------------------------------------------------*/
/* testStandAlone                                                             */
/*----------------------------------------------------------------------------*/

void testStandAlone ()
   {
   char *   argv[2];
   WitRun * theWitRun;

   argv[0] = "";
   argv[1] = "data/diner.params";

   witNewRun       (& theWitRun);
   witExecStandAlone (theWitRun, 2, argv);
   witDeleteRun      (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testCplexParSpecs (theWitRun)                                              */
/*                                                                            */
/* Tests CPLEX parameter specifications.                                      */
/*----------------------------------------------------------------------------*/

void testCplexParSpecs (WitRun * theWitRun)
   {
   testClearCplexParSpecs   (theWitRun);

   testCplexParSpecAtts     (theWitRun);

   witAddIntCplexParSpec    (theWitRun, "ITLIM", 100000);
   witAddDblCplexParSpec    (theWitRun, "EPRHS", 1.e-5);
   witAddDblCplexParSpecDbl (theWitRun, "EPOPT", 1.e-7);

   testGetIntCplexParSpec   (theWitRun);
   testGetDblCplexParSpec   (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testClearCplexParSpecs (theWitRun)                                         */
/*                                                                            */
/* Tests witClearCplexParSpecs.                                               */
/*----------------------------------------------------------------------------*/

void testClearCplexParSpecs (WitRun * theWitRun)
   {
   int        theInt;
   witBoolean intSpecExists;

   witAddIntCplexParSpec    (theWitRun, "SIMDISPLAY",   2);

   witGetIntCplexParSpec    (theWitRun, "SIMDISPLAY", & intSpecExists,
                                                      & theInt);

   assert   (intSpecExists);
   assert   (theInt == 2);

   witClearCplexParSpecs    (theWitRun);
   
   witGetIntCplexParSpec    (theWitRun, "SIMDISPLAY", & intSpecExists,
                                                      & theInt);

   assert (! intSpecExists);
   }

/*----------------------------------------------------------------------------*/
/* testCplexParSpecAtts (theWitRun)                                           */
/*                                                                            */
/* Tests the attribute functions for CPLEX parameter specifications.          */
/*----------------------------------------------------------------------------*/

void testCplexParSpecAtts (WitRun * theWitRun)
   {
   char * theString;
   int    theInt;
   float  theFlt;
   double theDbl;

   witSetCplexParSpecName      (theWitRun, "LPMETHOD");
   witSetCplexParSpecIntVal    (theWitRun, 4);

   witSetCplexParSpecName      (theWitRun, "TILIM");
   witSetCplexParSpecDblVal    (theWitRun, 0.7);
   witSetCplexParSpecDblValDbl (theWitRun, 2.5);

   witGetCplexParSpecName      (theWitRun, & theString);
   witGetCplexParSpecIntVal    (theWitRun, & theInt);
   witGetCplexParSpecDblVal    (theWitRun, & theFlt);
   witGetCplexParSpecDblValDbl (theWitRun, & theDbl);

   assert (equalStrings (theString, "TILIM"));

   assert (theInt == 4);

   assert (fabs (theFlt - 2.5) < dblEps);
   assert (fabs (theDbl - 2.5) < dblEps);

   witFree (theString);
   }

/*----------------------------------------------------------------------------*/
/* testGetIntCplexParSpec (theWitRun)                                         */
/*                                                                            */
/* Tests witGetIntCplexParSpec.                                               */
/*----------------------------------------------------------------------------*/

void testGetIntCplexParSpec (WitRun * theWitRun)
   {
   int        theInt;
   witBoolean intSpecExists;

   witGetIntCplexParSpec (theWitRun, "NONE",  & intSpecExists,
                                              & theInt);

   assert (! intSpecExists);

   witGetIntCplexParSpec (theWitRun, "EPOPT", & intSpecExists,
                                              & theInt);

   assert (! intSpecExists);

   witGetIntCplexParSpec (theWitRun, "ITLIM", & intSpecExists,
                                              & theInt);

   assert   (intSpecExists);

   assert   (theInt == 100000);
   }

/*----------------------------------------------------------------------------*/
/* testGetDblCplexParSpec (theWitRun)                                         */
/*                                                                            */
/* Tests witGetDblCplexParSpec and witGetDblCplexParSpecDbl.                  */
/*----------------------------------------------------------------------------*/

void testGetDblCplexParSpec (WitRun * theWitRun)
   {
   float      theFlt;
   double     theDbl;
   witBoolean dblSpecExists;

   witGetDblCplexParSpec    (theWitRun, "NONE",  & dblSpecExists,
                                                 & theFlt);

   assert (! dblSpecExists);

   witGetDblCplexParSpec    (theWitRun, "ITLIM", & dblSpecExists,
                                                 & theFlt);

   assert (! dblSpecExists);

   witGetDblCplexParSpecDbl (theWitRun, "EPRHS", & dblSpecExists,
                                                 & theDbl);

   assert   (dblSpecExists);

   assert   (fabs (theDbl - 1.e-5) < 1.e-9);
   }

/*----------------------------------------------------------------------------*/
/* testWriteReadData (theWitRun, fileName)                                    */
/*                                                                            */
/* Tests witWriteData and witReadData using a temporary WitRun.               */
/*----------------------------------------------------------------------------*/

void testWriteReadData (WitRun * theWitRun, const char * fileName)
   {
   WitRun * tempWitRun;

   witWriteData  (theWitRun, fileName);

   witNewRun   (& tempWitRun);

   witInitialize (tempWitRun);

   witReadData   (tempWitRun, fileName);

   witDeleteRun  (tempWitRun);

   unlink                    (fileName);
   }

/*----------------------------------------------------------------------------*/

void testOperationApis ()
{
   int   t;
   WitRun * wr1;
   WitRun * wr2;

   char theAppData[] = "Contents of theAppData.";

   witNewRun (& wr1);
   witNewRun (& wr2);

   witInitialize( wr1 );
   witSetNPeriods( wr1, nPeriods );

   witInitialize( wr2 );
   witSetNPeriods( wr2, nPeriods );

   witAddOperation( wr1, "opn1" );
   witAddOperation( wr2, "opn1" );

   witAddPart (wr2, "part1", WitCAPACITY);
      /*                                             */
      /* Added to fulfill the >= 1 part requirement. */

   /* execBounds, double  */
   {
   double hlb[]={3., 4., 5., 4., 2.};
   double slb[]={4., 4., 5., 4., 3.};
   double hub[]={4., 4., 7., 4., 3.};
   double *hlb1, *slb1, *hub1;
   
   witSetOperationExecBoundsDbl( wr2, "opn1", hlb, slb, hub );
   witGetOperationExecBoundsDbl( wr2, "opn1", &hlb1, &slb1, &hub1 );

   compareDblVecs(hlb,hlb1, nPeriods);
   compareDblVecs(slb,slb1, nPeriods);
   compareDblVecs(hub,hub1, nPeriods);

   witFree (hlb1);
   witFree (slb1);
   witFree (hub1);
   }

   /* execBounds, float  */
   {
   float hlb[]={1., 2., 3., 2., 0.};
   float slb[]={2., 2., 3., 2., 1.};
   float hub[]={2., 2., 5., 2., 1.};
   float *hlb1, *slb1, *hub1;
   
   witSetOperationExecBounds( wr2, "opn1", hlb, slb, hub );
   witGetOperationExecBounds( wr2, "opn1", &hlb1, &slb1, &hub1 );

   compareFltVecs(hlb,hlb1, nPeriods);
   compareFltVecs(slb,slb1, nPeriods);
   compareFltVecs(hub,hub1, nPeriods);

   witFree (hlb1);
   witFree (slb1);
   witFree (hub1);
   }

   /* Changing the name of an operation. */

   {
   witSetOperationOperationName  (wr1, "opn1",      "Temp-Name");
   witSetOperationOperationName  (wr1, "Temp-Name", "opn1");
   }

   /* execPenalty */
   {
   float  theFlt;
   double theDbl;

   witSetOperationExecPenaltyDbl( wr2, "opn1", 272.89 );
   witGetOperationExecPenaltyDbl( wr2, "opn1", &theDbl );

   assert( fabs(theDbl - 272.89) < dblEps );

   witSetOperationExecPenalty( wr2, "opn1", 72.89 );
   witGetOperationExecPenalty( wr2, "opn1", &theFlt );

   assert( fabs(theFlt - 72.89) < dblEps );
   }

   /* execVol: double */
   {
   double dblVec[]={2., 2., 3., 2., 0.};
   double *dblVec1;

   witSetOperationExecVolDbl( wr2, "opn1", dblVec );
   witGetOperationExecVolDbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* execVol: float */
   {
   float fltVec[]={2., 2., 3., 2., 0.};
   float *fltVec1;

   witSetOperationExecVol( wr2, "opn1", fltVec );
   witGetOperationExecVol( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* twoLevelLotSizes */
   {
   witBoolean twoLevelLotSizes;

   witSetOperationTwoLevelLotSizes (wr2, "opn1",   WitTRUE);
   witGetOperationTwoLevelLotSizes (wr2, "opn1", & twoLevelLotSizes);

   assert (twoLevelLotSizes);
   }

   /* incLotSize */
   {
   float fltVec[]={2., 9., 3., 2., 1.};
   float *fltVec1;

   witSetOperationIncLotSize( wr2, "opn1", fltVec );
   witGetOperationIncLotSize( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }


   /* incLotSize: double */
   {
   double   dblVec[]={2., 9., 3., 2., 1.};
   double * dblVec1;

   witSetOperationIncLotSizeDbl( wr2, "opn1", dblVec );
   witGetOperationIncLotSizeDbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }


   /* minLotSize */
   {
   float fltVec[]={3., 9., 3., 2., 0.};
   float *fltVec1;

   witSetOperationMinLotSize( wr2, "opn1", fltVec );
   witGetOperationMinLotSize( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* minLotSize: double */
   {
   double   dblVec[]={3., 9., 3., 2., 0.};
   double * dblVec1;

   witSetOperationMinLotSizeDbl( wr2, "opn1", dblVec );
   witGetOperationMinLotSizeDbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* lotSize2Thresh */
   {
   float fltVec[]={13., 19., 13., 12., 10.};
   float *fltVec1;

   witSetOperationLotSize2Thresh( wr2, "opn1", fltVec );
   witGetOperationLotSize2Thresh( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* lotSize2Thresh */
   {
   double   dblVec[]={13., 19., 13., 12., 10.};
   double * dblVec1;

   witSetOperationLotSize2ThreshDbl( wr2, "opn1", dblVec );
   witGetOperationLotSize2ThreshDbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* minLotSize2 */
   {
   float fltVec[]={23., 29., 23., 22., 20.};
   float *fltVec1;

   witSetOperationMinLotSize2( wr2, "opn1", fltVec );
   witGetOperationMinLotSize2( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* minLotSize2: double */
   {
   double   dblVec[]={23., 29., 23., 22., 20.};
   double * dblVec1;

   witSetOperationMinLotSize2Dbl( wr2, "opn1", dblVec );
   witGetOperationMinLotSize2Dbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* incLotSize2 */
   {
   float fltVec[]={12., 19., 13., 12., 11.};
   float *fltVec1;

   witSetOperationIncLotSize2( wr2, "opn1", fltVec );
   witGetOperationIncLotSize2( wr2, "opn1", &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* incLotSize2: double */
   {
   double   dblVec[]={12., 19., 13., 12., 11.};
   double * dblVec1;

   witSetOperationIncLotSize2Dbl( wr2, "opn1", dblVec );
   witGetOperationIncLotSize2Dbl( wr2, "opn1", &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* execCost */
   {
   float fltVec[]={4., 9., 3., 2., 0.};
   float *fltVec1;

   witSetOperationObj1ExecCost (wr1, "opn1",   fltVec);
   witSetOperationExecCost     (wr1, "opn1",   fltVec);

   witGetOperationExecCost     (wr1, "opn1", & fltVec1);

   compareFltVecs (fltVec, fltVec1, nPeriods);

   witFree (fltVec1);

   witGetOperationObj1ExecCost (wr1, "opn1", & fltVec1);

   compareFltVecs (fltVec, fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* execCost */
   {
   double   dblVec[]={4., 9., 3., 2., 0.};
   double * dblVec1;

   witSetOperationObj1ExecCostDbl (wr1, "opn1",   dblVec);
   witSetOperationExecCostDbl     (wr1, "opn1",   dblVec);

   witGetOperationExecCostDbl     (wr1, "opn1", & dblVec1);

   compareDblVecs (dblVec, dblVec1, nPeriods);

   witFree (dblVec1);

   witGetOperationObj1ExecCostDbl (wr1, "opn1", & dblVec1);

   compareDblVecs (dblVec, dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* yieldRate */
   {
   float    trueYieldRate1   [] = {1.0, 0.876, 0.874, 0.01, 0.0};
   double   trueYieldRateDbl1[] = {1.0, 0.876, 0.874, 0.01, 0.0};
   int      trueYield1       [] = {100,   88,    87,     1,   0};

   int      trueYield2       [] = {   2,   0,    3,   0,   99};
   float    trueYieldRate2   [] = {0.02, 0.0, 0.03, 0.0, 0.99};

   float *  witYieldRate;
   double * witYieldRateDbl;
   int *    witYield;

   witSetOperationYieldRate    (wr2, "opn1",  trueYieldRate1);
   witSetOperationYieldRateDbl (wr2, "opn1",  trueYieldRateDbl1);
   witGetOperationYieldRate    (wr2, "opn1", & witYieldRate);
   witGetOperationYieldRateDbl (wr2, "opn1", & witYieldRateDbl);
   witGetOperationYield        (wr2, "opn1", & witYield);

   compareFltVecs (witYieldRate,    trueYieldRate1,    nPeriods);
   compareDblVecs (witYieldRateDbl, trueYieldRateDbl1, nPeriods);
   compareIntVecs (witYield,        trueYield1,        nPeriods);

   witFree (witYieldRate);
   witFree (witYieldRateDbl);
   witFree (witYield);

   witSetOperationYield        (wr2, "opn1",  trueYield2);
   witGetOperationYield        (wr2, "opn1", & witYield);
   witGetOperationYieldRate    (wr2, "opn1", & witYieldRate);

   compareIntVecs (witYield,        trueYield2,     nPeriods);
   compareFltVecs (witYieldRate,    trueYieldRate2, nPeriods);

   witFree (witYield);
   witFree (witYieldRate);
   }

   /* appData */
   {
   void * ptr;
   witSetOperationAppData( wr2, "opn1", theAppData);
   witGetOperationAppData( wr2, "opn1", &ptr);
   assert( ptr==theAppData );
   }

   /* executable */
   {
   witBoolean * executable;

   witBoolean   correctExecutable[] =
      {
      WitTRUE,
      WitFALSE,
      WitTRUE,
      WitFALSE,
      WitTRUE};

   witGetOperationExecutable (wr2, "opn1", &executable);

   compareIntVecs (executable, correctExecutable, nPeriods);

   witFree ( executable);
   }

   /* witGetOperations */
   {
   int lenList;
   char ** operationList;
   witGetOperations( wr2, &lenList, &operationList );
   assert( lenList == 1 );
   assert( equalStrings (operationList[0],"opn1"));
   witFree ( operationList[0] );
   witFree ( operationList );
   }

   {
   witBoolean exists;

   witGetOperationExists( wr2, "opn1", &exists );
   assert( exists );

   witGetOperationExists( wr2, "xyzzy", &exists );
   assert( !exists );
   }

   {
   WitRun *   copyWitRun;
   witBoolean theBool;

   witNewRun           (& copyWitRun);
   witCopyData           (copyWitRun, wr2);

   witSetHighPrecisionWD (copyWitRun, WitTRUE);
   witGetHighPrecisionWD (copyWitRun, & theBool);

   assert (theBool);

   witWriteData  (  copyWitRun, "opnTest.data");
   witInitialize (  copyWitRun);
   witReadData   (  copyWitRun, "opnTest.data");
   unlink        (              "opnTest.data");
   witWriteData  (  copyWitRun, WitSTDOUT);
   witDeleteRun  (  copyWitRun);
   }

   witDeleteRun( wr1 );
   witDeleteRun( wr2 );
}

void testBopApis() 
{
   int   t;
   WitRun *wr1;

   char theAppData[] = "Contents of theAppData.";

   witNewRun (& wr1);

   witInitialize( wr1 );
   witSetWit34Compatible( wr1, WitTRUE );
   witSetNPeriods( wr1, nPeriods );

   witAddOperation( wr1, "opn1" );
   witAddPart( wr1, "part1", WitPRODUCT );
   witAddBopEntry( wr1, "opn1", "part1" );

   /* expAllowed and byProduct */
   {
   witBoolean bool;

   witSetBopEntryExpAllowed (wr1, "opn1", 0, WitFALSE);

   witGetBopEntryExpAllowed (wr1, "opn1", 0, & bool);
   assert (! bool);

   witGetBopEntryByProduct  (wr1, "opn1", 0, & bool);
   assert (bool);

   witSetBopEntryByProduct  (wr1, "opn1", 0, WitFALSE);

   witGetBopEntryByProduct  (wr1, "opn1", 0, & bool);
   assert (! bool);

   witGetBopEntryExpAllowed (wr1, "opn1", 0, & bool);
   assert (bool);
   }

   /* meSelSplit */
   {
   witBoolean bool;

   witSetBopEntryMeSelSplit (wr1, "opn1", 0, WitTRUE);

   witGetBopEntryMeSelSplit (wr1, "opn1", 0, & bool);
   assert (bool);
   }

   /* earliestPeriod */
   {
   int per;

   witSetBopEntryEarliestPeriod( wr1, "opn1", 0, 4 );
   witGetBopEntryEarliestPeriod( wr1, "opn1", 0, &per );
   assert( per==4 );

   witSetBopEntryEarliestPeriod( wr1, "opn1", 0, 1 );
   witGetBopEntryEarliestPeriod( wr1, "opn1", 0, &per );
   assert( per==1 );
   }

   /* latestPeriod */
   {
   int per;

   witSetBopEntryLatestPeriod( wr1, "opn1", 0, 1 );
   witGetBopEntryLatestPeriod( wr1, "opn1", 0, &per );
   assert( per==1 );

   witSetBopEntryLatestPeriod( wr1, "opn1", 0, 3 );
   witGetBopEntryLatestPeriod( wr1, "opn1", 0, &per );
   assert( per==3 );
   }

   /* offset */
   {
   float fltVec[]={4., 9., 0., 2., 0.};
   float *fltVec1;

   witSetBopEntryOffset( wr1, "opn1", 0, fltVec );
   witGetBopEntryOffset( wr1, "opn1", 0, &fltVec1 );

   compareFltVecs(fltVec,fltVec1, nPeriods);

   witFree (fltVec1);
   }

   /* offset: double */
   {
   double   dblVec[]={4., 9., 0., 2., 0.};
   double * dblVec1;

   witSetBopEntryOffsetDbl( wr1, "opn1", 0, dblVec );
   witGetBopEntryOffsetDbl( wr1, "opn1", 0, &dblVec1 );

   compareDblVecs(dblVec,dblVec1, nPeriods);

   witFree (dblVec1);
   }

   /* productRate & prodRate */
   {
   float   prodRateRet;
   float   productRateEnt[] = {2.0, 2.1, 2.2, 2.3, 2.4};
   float * productRateRet;

   witSetBopEntryProductRate (wr1, "opn1", 0,   productRateEnt);
   witGetBopEntryProdRate    (wr1, "opn1", 0, & prodRateRet);

   assert (fabs (prodRateRet - 2.0) < dblEps);

   witGetBopEntryProductRate (wr1, "opn1", 0, & productRateRet);

   compareFltVecs (productRateRet, productRateEnt, nPeriods);

   witFree (productRateRet);

   witSetBopEntryProdRate (wr1, "opn1", 0, 1.);
   witGetBopEntryProdRate (wr1, "opn1", 0, & prodRateRet);

   assert (fabs (prodRateRet - 1.0) < dblEps);

   witGetBopEntryProductRate (wr1, "opn1", 0, & productRateRet);

   assert (fabs (productRateRet[2] - 1.0) < dblEps);

   witFree (productRateRet);
   }

   /* productRate: double */
   {
   double   productRateDblEnt[] = {2.0, 2.1, 2.2, 2.3, 2.4};
   double * productRateDblRet;

   witSetBopEntryProductRateDbl (wr1, "opn1", 0,   productRateDblEnt);

   witGetBopEntryProductRateDbl (wr1, "opn1", 0, & productRateDblRet);

   compareDblVecs (productRateDblRet, productRateDblEnt, nPeriods);

   witFree (productRateDblRet);
   }

   /* expAversion */
   {
   float  aversion;
   double aversionDbl;

   witSetBopEntryExpAversion (wr1, "opn1", 0, -4.0);
   witGetBopEntryExpAversion (wr1, "opn1", 0, & aversion);

   assert (fabs (aversion + 4.0) < dblEps);

   witSetBopEntryExpAversionDbl (wr1, "opn1", 0, 53.0);
   witGetBopEntryExpAversionDbl (wr1, "opn1", 0, & aversionDbl);

   assert (fabs (aversionDbl - 53.0) < dblEps);

   witSetBopEntryExpAversion (wr1, "opn1", 0, 0.0);
   witGetBopEntryExpAversion (wr1, "opn1", 0, & aversion);

   assert (fabs (aversion - 0.0) < dblEps);
   }

   /* routingShare */
   {
   float   goodRoutingShare[] = {5.0, 5.0, 1.0, 5.0, 5.0};
   float * routingShare;

   witSetBopEntryRoutingShare (wr1, "opn1", 0, goodRoutingShare);

   witGetBopEntryRoutingShare (wr1, "opn1", 0, & routingShare);

   compareFltVecs (routingShare, goodRoutingShare, nPeriods);

   witFree (routingShare);
   }

   /* routingShare: double */
   {
   double   goodRoutingShareDbl[] = {5.0, 5.0, 1.0, 5.0, 5.0};
   double * routingShareDbl;

   witSetBopEntryRoutingShareDbl (wr1, "opn1", 0, goodRoutingShareDbl);

   witGetBopEntryRoutingShareDbl (wr1, "opn1", 0, & routingShareDbl);

   compareDblVecs (routingShareDbl, goodRoutingShareDbl, nPeriods);

   witFree (routingShareDbl);
   }

   /* producedPartName */
   {
   char *s;
   witGetBopEntryProducedPart( wr1, "opn1", 0, &s );
   assert( equalStrings(s,"part1") );
   witFree (s);
   }

   /* nBopEntries */
   {
   int nBopEntries;
   witGetOperationNBopEntries( wr1, "opn1", &nBopEntries );
   assert( nBopEntries == 1 );
   }

   /* bopEntry appData */
   {
   void * ptr;
   witSetBopEntryAppData( wr1, "opn1", 0, theAppData);
   witGetBopEntryAppData( wr1, "opn1", 0, &ptr);
   assert( ptr==theAppData );
   }

   /* impactPeriod */
   {
   int * impactPeriod;
   int   correctImpactPeriod[] = { -1, -1, 2, 1, -1};

   witGetBopEntryImpactPeriod (wr1, "opn1", 0, & impactPeriod);

   compareIntVecs (impactPeriod, correctImpactPeriod, nPeriods);

   witFree (impactPeriod);
   }

   witDeleteRun( wr1 );

}


void testAddPart()
{
   int   t;
   WitRun *wr1;

   witNewRun (& wr1);

   witInitialize( wr1 );
   witSetNPeriods( wr1, nPeriods );
   witSetWit34Compatible( wr1, WitTRUE );

   witAddPart( wr1, "partRaw",     WitRAW );
   witAddPart ( wr1, "partRawVa", WitRAW);

   witAddPart( wr1, "partCap",     WitCAPACITY );
   witAddPart( wr1, "partCapVa", WitCAPACITY);

   witAddPart( wr1, "partPrd",     WitPRODUCT );
   witAddPart( wr1, "partPrdVa", WitPRODUCT);
   {
   float obj1ProdCost[]  ={ 1., 2., 3., 4., 5.5 };
   float cycleTime[]={ 2., 3., 3., 4., 5.5 };
   int   yield[] = { 90, 91, 92, 93, 94 };
   witAddPart( wr1, "partPrdVa1", WitPRODUCT);
   }

   witAddPart( wr1, "partMat",     WitMATERIAL );
   witAddPart( wr1, "partMatVa", WitMATERIAL);

   witAddPartWithOperation( wr1, "partWithOperation" );

   witInitialize( wr1 );
   witSetNPeriods( wr1, nPeriods );
   witSetWit34Compatible( wr1, WitFALSE );

   witAddPart( wr1, "partCap",     WitCAPACITY );
   witAddPart( wr1, "partCapVa", WitCAPACITY);

   witAddPart( wr1, "partMat",     WitMATERIAL );
   witAddPart( wr1, "partMatVa", WitMATERIAL);

   witAddPartWithOperation( wr1, "partWithOperation" );

   witDeleteRun( wr1 );
}

/*----------------------------------------------------------------------------*/
/* testPartToArcApis                                                          */
/* Tests the API functions that find the arcs associated with a part.         */
/*----------------------------------------------------------------------------*/

void testPartToArcApis ()
   {
   WitRun * theWitRun;
   char *   theOperationName;
   int      nArcs;
   int      theBomEntryIndex;
   int      theSubEntryIndex;
   int      theBopEntryIndex;

   printf (
      "\n"
      "--- Testing the API functions that find the "
          "arcs associated with a part. ---\n"
      "\n");

   /*---------------------*/
   /* Set up the problem. */
   /*---------------------*/

   witNewRun   (& theWitRun);
   witInitialize (theWitRun);

   witAddPart (theWitRun, "PA", WitMATERIAL);
   witAddPart (theWitRun, "PB", WitMATERIAL);
   witAddPart (theWitRun, "PC", WitMATERIAL);

   witAddOperation (theWitRun, "OA");
   witAddOperation (theWitRun, "OB");

   witAddBomEntry (theWitRun, "OA", "PA");
   witAddBomEntry (theWitRun, "OB", "PA");

   witAddSubsBomEntry (theWitRun, "OA", 0, "PB");
   witAddSubsBomEntry (theWitRun, "OB", 0, "PB");
   witAddSubsBomEntry (theWitRun, "OA", 0, "PB");

   witAddBopEntry (theWitRun, "OA", "PC");
   witAddBopEntry (theWitRun, "OB", "PC");

   /*------------*/
   /* Run tests. */
   /*------------*/

   witGetPartNConsumingBomEntries (theWitRun, "PA", &nArcs);

   assert (nArcs == 2);

   witGetPartNConsumingSubsBomEntries (theWitRun, "PB", &nArcs);

   assert (nArcs == 3);

   witGetPartNProducingBopEntries (theWitRun, "PC", &nArcs);

   assert (nArcs == 2);

   witGetPartConsumingBomEntry (
      theWitRun,
      "PA",
      1,
      & theOperationName,
      & theBomEntryIndex);

   assert (equalStrings (theOperationName, "OB"));

   witFree (theOperationName);

   assert (theBomEntryIndex == 0);

   witGetPartConsumingSubsBomEntry (
      theWitRun,
      "PB",
      2,
      & theOperationName,
      & theBomEntryIndex,
      & theSubEntryIndex);

   assert (equalStrings (theOperationName, "OA"));

   witFree (theOperationName);

   assert (theBomEntryIndex == 0);

   assert (theSubEntryIndex == 1);

   witGetPartProducingBopEntry (
      theWitRun,
      "PC",
      1,
      & theOperationName,
      & theBopEntryIndex);

   assert (equalStrings (theOperationName, "OB"));

   witFree (theOperationName);

   assert (theBopEntryIndex == 0);

   witDeleteRun (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testHeurAlloc                                                              */
/* Tests heuristic allocation and equitable allocation in float mode.         */
/*----------------------------------------------------------------------------*/

void testHeurAlloc ()
   {
   WitRun *   theWitRun;
   float      incVol;
   witBoolean active;
   witBoolean postproc;

   printf (
      "\n"
      "--- Testing Heuristic Allocation in Float Mode ---\n"
      "\n");

   witNewRun   (& theWitRun);
   witInitialize (theWitRun);

   witReadData (theWitRun, "data/diner.data");

   witSetEquitability (theWitRun, 100);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (active);

   witSetAccAfterOptImp (theWitRun, WitFALSE);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

      {
      const char * const demandedPartNameList[] = {
         "Ham_and_Egg_Sandwich",
         "Ham_and_Cheese_Sandwich",
         "Ham_Sandwich"};

      const char * const demandNameList[] = {
         "demand",
         "demand",
         "demand"};

      const int shipPeriodList[] = {1, 0, 1};

      const float desIncVolList[] = {7.0, 6.0, 15.0};

      float * incVolList;

      witEqHeurAlloc (
         theWitRun,
         3,
         demandedPartNameList,
         demandNameList,
         shipPeriodList,
         desIncVolList,
         & incVolList);

      assert (incVolList[0] == 4.0);
      assert (incVolList[1] == 4.0);
      assert (incVolList[2] == 9.0);

      witFree (incVolList);
      }

   witIncHeurAlloc (
      theWitRun,
      "Grilled_Cheese_Sandwich",
      "demand",
      1,
      9.0,
      & incVol);

   assert (incVol == 1.0);

   witIncHeurAlloc (
      theWitRun,
      "Plain_Sandwich",
      "demand",
      0,
      10.0,
      & incVol);

   assert (incVol == 4.0);

   witFinishHeurAlloc (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witGetPostprocessed (theWitRun, & postproc);

   assert (postproc);

   witDeleteRun (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testHeurAllocDbl                                                           */
/* Tests heuristic allocation and equitable allocation in double mode.        */
/*----------------------------------------------------------------------------*/

void testHeurAllocDbl ()
   {
   WitRun *   theWitRun;
   double     incVol;
   witBoolean active;
   witBoolean postproc;

   printf (
      "\n"
      "--- Testing Heuristic Allocation in Double Mode ---\n"
      "\n");

   witNewRun   (& theWitRun);
   witInitialize (theWitRun);

   witReadData (theWitRun, "data/diner.data");

   witSetEquitability (theWitRun, 100);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (active);

   witSetAccAfterOptImp (theWitRun, WitFALSE);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

      {
      const char * const demandedPartNameList[] = {
         "Ham_and_Egg_Sandwich",
         "Ham_and_Cheese_Sandwich",
         "Ham_Sandwich"};

      const char * const demandNameList[] = {
         "demand",
         "demand",
         "demand"};

      const int shipPeriodList[] = {1, 0, 1};

      const double desIncVolList[] = {7.0, 6.0, 15.0};

      double * incVolList;

      witEqHeurAllocDbl (
         theWitRun,
         3,
         demandedPartNameList,
         demandNameList,
         shipPeriodList,
         desIncVolList,
         & incVolList);

      assert (incVolList[0] == 4.0);
      assert (incVolList[1] == 4.0);
      assert (incVolList[2] == 9.0);

      witFree (incVolList);
      }

   witIncHeurAllocDbl (
      theWitRun,
      "Grilled_Cheese_Sandwich",
      "demand",
      1,
      9.0,
      & incVol);

   assert (incVol == 1.0);

   witIncHeurAllocDbl (
      theWitRun,
      "Plain_Sandwich",
      "demand",
      0,
      10.0,
      & incVol);

   assert (incVol == 4.0);

   witFinishHeurAlloc (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witGetPostprocessed (theWitRun, & postproc);

   assert (postproc);

   witDeleteRun (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testHeurAllocTwme                                                          */
/* Tests heuristic allocation and equitable allocation in float two-way       */
/* multi-exec mode.                                                           */
/*----------------------------------------------------------------------------*/

void testHeurAllocTwme ()
   {
   WitRun *   theWitRun;
   float      incVol;
   witBoolean active;
   witBoolean twoWayMultiExec;
   witBoolean multiExec;

   printf (
      "\n"
      "--- Testing Heuristic Allocation in Float Two-Way Multi-Exec Mode ---\n"
      "\n");

   witNewRun   (& theWitRun);
   witInitialize (theWitRun);

   witReadData (theWitRun, "data/diner.data");

   witSetEquitability (theWitRun, 100);

   witSetTwoWayMultiExec (theWitRun, WitTRUE);

   witGetTwoWayMultiExec (theWitRun, & twoWayMultiExec);

   assert (twoWayMultiExec);

   witGetMultiExec (theWitRun, & multiExec);

   assert (multiExec);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

      {
      const char * const demandedPartNameList[] = {
         "Ham_and_Egg_Sandwich",
         "Ham_and_Cheese_Sandwich",
         "Ham_Sandwich"};

      const char * const demandNameList[] = {
         "demand",
         "demand",
         "demand"};

      const int shipPeriodList[] = {1, 0, 1};

      const float desIncVolList[] = {7.0, 6.0, 15.0};

      float * incVolList;

      witBoolean asapMultiExecList[] = {WitTRUE, WitFALSE, WitTRUE};

      witEqHeurAllocTwme (
         theWitRun,
         3,
         demandedPartNameList,
         demandNameList,
         shipPeriodList,
         desIncVolList,
         & incVolList,
         asapMultiExecList);

      assert (incVolList[0] == 4.0);
      assert (incVolList[1] == 4.0);
      assert (incVolList[2] == 9.0);

      witFree (incVolList);
      }

   witIncHeurAllocTwme (
      theWitRun,
      "Grilled_Cheese_Sandwich",
      "demand",
      1,
      9.0,
      & incVol,
      WitTRUE);

   assert (incVol == 1.0);

   witIncHeurAllocTwme (
      theWitRun,
      "Plain_Sandwich",
      "demand",
      0,
      10.0,
      & incVol,
      WitFALSE);

   assert (incVol == 4.0);

   witFinishHeurAlloc (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witDeleteRun (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testHeurAllocTwmeDbl                                                       */
/* Tests heuristic allocation and equitable allocation in double two-way      */
/* multi-exec mode.                                                           */
/*----------------------------------------------------------------------------*/

void testHeurAllocTwmeDbl ()
   {
   WitRun *   theWitRun;
   double     incVol;
   witBoolean active;
   witBoolean twoWayMultiExec;
   witBoolean multiExec;

   printf (
      "\n"
      "--- Testing Heuristic Allocation in Double Two-Way Multi-Exec Mode ---\n"
      "\n");

   witNewRun   (& theWitRun);
   witInitialize (theWitRun);

   witReadData (theWitRun, "data/diner.data");

   witSetEquitability (theWitRun, 100);

   witSetTwoWayMultiExec (theWitRun, WitTRUE);

   witGetTwoWayMultiExec (theWitRun, & twoWayMultiExec);

   assert (twoWayMultiExec);

   witGetMultiExec (theWitRun, & multiExec);

   assert (multiExec);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witStartHeurAlloc  (theWitRun);

      {
      const char * const demandedPartNameList[] = {
         "Ham_and_Egg_Sandwich",
         "Ham_and_Cheese_Sandwich",
         "Ham_Sandwich"};

      const char * const demandNameList[] = {
         "demand",
         "demand",
         "demand"};

      const int shipPeriodList[] = {1, 0, 1};

      const double desIncVolList[] = {7.0, 6.0, 15.0};

      double * incVolList;

      witBoolean asapMultiExecList[] = {WitTRUE, WitFALSE, WitTRUE};

      witEqHeurAllocTwmeDbl (
         theWitRun,
         3,
         demandedPartNameList,
         demandNameList,
         shipPeriodList,
         desIncVolList,
         & incVolList,
         asapMultiExecList);

      assert (incVolList[0] == 4.0);
      assert (incVolList[1] == 4.0);
      assert (incVolList[2] == 9.0);

      witFree (incVolList);
      }

   witIncHeurAllocTwmeDbl (
      theWitRun,
      "Grilled_Cheese_Sandwich",
      "demand",
      1,
      9.0,
      & incVol,
      WitTRUE);

   assert (incVol == 1.0);

   witIncHeurAllocTwmeDbl (
      theWitRun,
      "Plain_Sandwich",
      "demand",
      0,
      10.0,
      & incVol,
      WitFALSE);

   assert (incVol == 4.0);

   witFinishHeurAlloc (theWitRun);

   witGetHeurAllocActive (theWitRun, & active);

   assert (! active);

   witDeleteRun (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testDeletion                                                               */
/* Tests item deletion.                                                       */
/*----------------------------------------------------------------------------*/

void testDeletion ()
   {
   WitRun * theWitRun;

   printf (
      "\n"
      "--- Testing Item Deletion ---\n"
      "\n");

   witNewRun (& theWitRun);

   witSetMesgPrintNumber (theWitRun,
                          WitTRUE,
                          WitINFORMATIONAL_MESSAGES,
                          WitFALSE);

   witInitialize         (theWitRun);
   witSetWit34Allowed    (theWitRun, WitFALSE);
   defProfDelTest        (theWitRun);
   selItemsDelTest       (theWitRun);
   copyWriteDelTest      (theWitRun);
   witDisplayData        (theWitRun, WitSTDOUT);
   checkSelDelTest       (theWitRun);
   witPurgeData          (theWitRun);
   witDisplayData        (theWitRun, WitSTDOUT);

   if (cplexEmbedded)
      {
      witOptImplode (theWitRun);

      prtRemove ("solver.log");
      }

   witWriteExecSched (theWitRun, WitSTDOUT, WitBSV);
   witWriteShipSched (theWitRun, WitSTDOUT, WitBSV);
   witDeleteRun      (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* defProfDelTest.                                                            */
/* Define the problem for a item deletion test.                               */
/*----------------------------------------------------------------------------*/

void defProfDelTest (WitRun * theWitRun)
   {
   float supplyVolA[] = {0,  5};
   float supplyVolB[] = {10, 0};
   float demandVolK[] = {20, 0};

   witSetTitle        (theWitRun, "Item Deletion Test");
   witSetNPeriods     (theWitRun, 2);

   witAddPart         (theWitRun, "A", WitCAPACITY);
   witAddPart         (theWitRun, "B", WitCAPACITY);
   witAddPart         (theWitRun, "E", WitMATERIAL);
   witAddPart         (theWitRun, "F", WitMATERIAL);
   witAddPart         (theWitRun, "I", WitMATERIAL);

   witAddOperation    (theWitRun, "C");
   witAddOperation    (theWitRun, "D");
   witAddOperation    (theWitRun, "H");

   witAddBomEntry     (theWitRun, "C", "A");
   witAddBomEntry     (theWitRun, "D", "B");
   witAddBomEntry     (theWitRun, "H", "B");
   witAddBomEntry     (theWitRun, "H", "E");
   witAddBomEntry     (theWitRun, "H", "F");

   witAddSubsBomEntry (theWitRun, "C", 0, "A");
   witAddSubsBomEntry (theWitRun, "C", 0, "B");
   witAddSubsBomEntry (theWitRun, "D", 0, "A");
   witAddSubsBomEntry (theWitRun, "H", 1, "F");
   witAddSubsBomEntry (theWitRun, "H", 2, "E");

   witAddBopEntry     (theWitRun, "C", "I");
   witAddBopEntry     (theWitRun, "C", "E");
   witAddBopEntry     (theWitRun, "C", "F");
   witAddBopEntry     (theWitRun, "D", "F");
   witAddBopEntry     (theWitRun, "H", "I");

   witAddDemand       (theWitRun, "E", "G");
   witAddDemand       (theWitRun, "I", "J");
   witAddDemand       (theWitRun, "I", "K");

   witSetPartSupplyVol   (theWitRun, "A",      supplyVolA);
   witSetPartSupplyVol   (theWitRun, "B",      supplyVolB);
   witSetDemandDemandVol (theWitRun, "I", "K", demandVolK);
   }

/*----------------------------------------------------------------------------*/
/* selItemsDelTest.                                                           */
/* Selects items for deletion.                                                */
/*----------------------------------------------------------------------------*/

void selItemsDelTest (WitRun * theWitRun)
   {
   witSetPartSelForDel         (theWitRun, "E",       WitTRUE);
   witSetOperationSelForDel    (theWitRun, "D",       WitTRUE);
   witSetOperationSelForDel    (theWitRun, "C",       WitTRUE);
   witSetBomEntrySelForDel     (theWitRun, "H", 0,    WitTRUE);
   witSetSubsBomEntrySelForDel (theWitRun, "C", 0, 0, WitTRUE);
   witSetBopEntrySelForDel     (theWitRun, "C", 0,    WitTRUE);
   witSetDemandSelForDel       (theWitRun, "I", "J",  WitTRUE);
   witSetOperationSelForDel    (theWitRun, "C",       WitFALSE);
   }

/*----------------------------------------------------------------------------*/
/* copyWriteDelTest                                                           */
/* Tests copying and writing the selForDel attributes.                        */
/*----------------------------------------------------------------------------*/

void copyWriteDelTest (WitRun * theWitRun)
   {
   WitRun * copyWitRun;

   witNewRun   (& copyWitRun);
   witCopyData   (copyWitRun, theWitRun);
   witInitialize ( theWitRun);
   witWriteData  (copyWitRun, "delTest.data");
   witDeleteRun  (copyWitRun);

   copyWitRun = NULL;

   witReadData   ( theWitRun, "delTest.data");
   unlink        (            "delTest.data");
   }

/*----------------------------------------------------------------------------*/
/* checkSelDelTest                                                            */
/* Checks the selForDel attribute.                                            */
/*----------------------------------------------------------------------------*/

void checkSelDelTest (WitRun * theWitRun)
   {
   witBoolean selForDel;

   witGetPartSelForDel         (theWitRun, "E",       & selForDel);

   assert (selForDel);

   witGetOperationSelForDel    (theWitRun, "D",       & selForDel);

   assert (selForDel);

   witGetBomEntrySelForDel     (theWitRun, "H", 0,    & selForDel);

   assert (selForDel);

   witGetSubsBomEntrySelForDel (theWitRun, "C", 0, 0, & selForDel);

   assert (selForDel);

   witGetBopEntrySelForDel     (theWitRun, "C", 0,    & selForDel);

   assert (selForDel);

   witGetDemandSelForDel       (theWitRun, "I", "J",  & selForDel);

   assert (selForDel);


   witGetOperationSelForDel    (theWitRun, "C",       & selForDel);

   assert (!selForDel);

   witGetPartSelForDel         (theWitRun, "A",       & selForDel);

   assert (! selForDel);
   }

/*----------------------------------------------------------------------------*/
/* testExecVolPegging                                                         */
/*----------------------------------------------------------------------------*/

void testExecVolPegging (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    execPeriodList;
   float *  peggedExecVolList;
   int      theIdx;

   witGetDemandExecVolPegging (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & execPeriodList,
      & peggedExecVolList);

   printf (
      "\n"
      "ExecVol Pegging for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, Period %d, ExecVol: %.0f\n",
         operationNameList[theIdx],
         execPeriodList   [theIdx],
         peggedExecVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (execPeriodList);
   witFree (peggedExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testExecVolPeggingDbl                                                      */
/*----------------------------------------------------------------------------*/

void testExecVolPeggingDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    execPeriodList;
   double * peggedExecVolList;
   int      theIdx;

   witGetDemandExecVolPeggingDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & execPeriodList,
      & peggedExecVolList);

   printf (
      "\n"
      "ExecVol Pegging (Double) for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, Period %d, ExecVol: %.0f\n",
         operationNameList[theIdx],
         execPeriodList   [theIdx],
         peggedExecVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (execPeriodList);
   witFree (peggedExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSubVolPegging                                                          */
/*----------------------------------------------------------------------------*/

void testSubVolPegging (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bomEntryIndexList;
   int *    subsBomEntryIndexList;
   int *    execPeriodList;
   float *  peggedSubVolList;
   int      theIdx;

   witGetDemandSubVolPegging (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bomEntryIndexList,
      & subsBomEntryIndexList,
      & execPeriodList,
      & peggedSubVolList);

   printf (
      "\n"
      "SubVol Pegging for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, BOM Ent %d, Sub %d, Period %d, SubVol: %.0f\n",
         operationNameList    [theIdx],
         bomEntryIndexList    [theIdx],
         subsBomEntryIndexList[theIdx],
         execPeriodList       [theIdx],
         peggedSubVolList     [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bomEntryIndexList);
   witFree (subsBomEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedSubVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSubVolPeggingDbl                                                       */
/*----------------------------------------------------------------------------*/

void testSubVolPeggingDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bomEntryIndexList;
   int *    subsBomEntryIndexList;
   int *    execPeriodList;
   double * peggedSubVolList;
   int      theIdx;

   witGetDemandSubVolPeggingDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bomEntryIndexList,
      & subsBomEntryIndexList,
      & execPeriodList,
      & peggedSubVolList);

   printf (
      "\n"
      "SubVol Pegging (Double) for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, BOM Ent %d, Sub %d, Period %d, SubVol: %.0f\n",
         operationNameList    [theIdx],
         bomEntryIndexList    [theIdx],
         subsBomEntryIndexList[theIdx],
         execPeriodList       [theIdx],
         peggedSubVolList     [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bomEntryIndexList);
   witFree (subsBomEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedSubVolList);
   }

/*----------------------------------------------------------------------------*/
/* testPip                                                                    */
/*----------------------------------------------------------------------------*/

void testPip (WitRun * theWitRun)
   {
   witBoolean theBool;

   witSetPipSeqFromHeur (theWitRun,   WitTRUE);
   witGetPipSeqFromHeur (theWitRun, & theBool);

   assert               (theBool);

   witSetNewPipPggOrder (theWitRun,   WitTRUE);
   witGetNewPipPggOrder (theWitRun, & theBool);

   assert               (theBool);

   witGetPipExists      (theWitRun, & theBool);

   assert               (! theBool);

   witHeurImplode       (theWitRun);

   witBuildPip          (theWitRun);

   witGetPipExists      (theWitRun, & theBool);

   assert               (theBool);

   testExecVolPip       (theWitRun, "PS1", "US", 2);
   testCoExecVolPip     (theWitRun, "PS1", "US", 2);
   testSubVolPip        (theWitRun, "PS1", "US", 2);
   testSupplyVolPip     (theWitRun, "PS1", "US", 2);
   testSideVolPip       (theWitRun, "PS1", "US", 2);
   testProdVolPip       (theWitRun, "PS1", "US", 2);
   testConsVolPip       (theWitRun, "PS1", "US", 2);

   truncatePipSeq       (theWitRun);

   witBuildPip          (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* truncatePipSeq                                                             */
/*                                                                            */
/* Reduces the PIP shipment sequence to its first and last elements.          */
/*----------------------------------------------------------------------------*/

void truncatePipSeq (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * demandNameList;
   int *    shipPerList;   
   float *  incShipVolList;
   int      theIdx;

   witGetPipSeq (
        theWitRun,
      & lenLists,
      & partNameList,
      & demandNameList,
      & shipPerList,
      & incShipVolList);

   witClearPipSeq (theWitRun);

   if (lenLists >= 2)
      {
      witAppendToPipSeq (
         theWitRun,
         partNameList  [0],
         demandNameList[0],
         shipPerList   [0],
         incShipVolList[0]);

      witAppendToPipSeq (
         theWitRun,
         partNameList  [lenLists - 1],
         demandNameList[lenLists - 1],
         shipPerList   [lenLists - 1],
         incShipVolList[lenLists - 1]);
      }

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      {
      witFree (partNameList  [theIdx]);
      witFree (demandNameList[theIdx]);
      }

   witFree (partNameList);
   witFree (demandNameList);
   witFree (shipPerList);
   witFree (incShipVolList);
   }

/*----------------------------------------------------------------------------*/
/* testExecVolPip                                                             */
/*----------------------------------------------------------------------------*/

void testExecVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    execPeriodList;
   float *  peggedExecVolList;
   int      theIdx;

   witGetDemandExecVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & execPeriodList,
      & peggedExecVolList);

   printf (
      "\n"
      "ExecVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, Period %d, ExecVol: %.0f\n",
         operationNameList[theIdx],
         execPeriodList   [theIdx],
         peggedExecVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (execPeriodList);
   witFree (peggedExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testCoExecVolPip                                                           */
/*----------------------------------------------------------------------------*/

void testCoExecVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bopEntryIndexList;
   int *    execPeriodList;
   float *  peggedCoExecVolList;
   int      theIdx;

   witGetDemandCoExecVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bopEntryIndexList,
      & execPeriodList,
      & peggedCoExecVolList);

   printf (
      "\n"
      "CoExecVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, BOP Entry %d, Period %d, CoExecVol: %.0f\n",
         operationNameList    [theIdx],
         bopEntryIndexList    [theIdx],
         execPeriodList       [theIdx],
         peggedCoExecVolList  [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bopEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedCoExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSubVolPip                                                              */
/*----------------------------------------------------------------------------*/

void testSubVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bomEntryIndexList;
   int *    subsBomEntryIndexList;
   int *    execPeriodList;
   float *  peggedSubVolList;
   int      theIdx;

   witGetDemandSubVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bomEntryIndexList,
      & subsBomEntryIndexList,
      & execPeriodList,
      & peggedSubVolList);

   printf (
      "\n"
      "SubVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf (
         "   Operation %s, BOM Entry %d, Sub %d, Period %d, SubVol: %.0f\n",
         operationNameList    [theIdx],
         bomEntryIndexList    [theIdx],
         subsBomEntryIndexList[theIdx],
         execPeriodList       [theIdx],
         peggedSubVolList     [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bomEntryIndexList);
   witFree (subsBomEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedSubVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSupplyVolPip                                                           */
/*----------------------------------------------------------------------------*/

void testSupplyVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   float *  peggedSupplyVolList;

   witGetDemandSupplyVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedSupplyVolList);

   testPartVolPip (
      "SupplyVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedSupplyVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSideVolPip                                                             */
/*----------------------------------------------------------------------------*/

void testSideVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   float *  peggedSideVolList;

   witGetDemandSideVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedSideVolList);

   testPartVolPip (
      "SideVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedSideVolList);
   }

/*----------------------------------------------------------------------------*/
/* testProdVolPip                                                             */
/*----------------------------------------------------------------------------*/

void testProdVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   float *  peggedProdVolList;

   witGetDemandProdVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedProdVolList);

   testPartVolPip (
      "ProdVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedProdVolList);
   }

/*----------------------------------------------------------------------------*/
/* testConsVolPip                                                             */
/*----------------------------------------------------------------------------*/

void testConsVolPip (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   float *  peggedConsVolList;

   witGetDemandConsVolPip (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedConsVolList);

   testPartVolPip (
      "ConsVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedConsVolList);
   }

/*----------------------------------------------------------------------------*/

void testPartVolPip (
      const char * attrName,
      const char * partName, 
      const char * demandName, 
      int          shipPer,
      int          lenLists,
      char * *     partNameList,
      int *        periodList,
      float *      peggedVolList)
   {
   int theIdx;

   printf (
      "\n"
      "%s PIP for Part %s, Demand %s, Period %d:\n\n",
      attrName,
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Part %s, Period %d, %s: %.0f\n",
         partNameList [theIdx],
         periodList   [theIdx],
         attrName,
         peggedVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (partNameList[theIdx]);

   witFree (partNameList);
   witFree (periodList);
   witFree (peggedVolList);
   }

/*----------------------------------------------------------------------------*/
/* testPipDbl                                                                 */
/*----------------------------------------------------------------------------*/

void testPipDbl (WitRun * theWitRun)
   {
   witBoolean theBool;

   witSetNewPipPggOrder (theWitRun,   WitFALSE);
   witGetNewPipPggOrder (theWitRun, & theBool);

   assert               (! theBool);

   witSetPipSeqFromHeur (theWitRun,   WitTRUE);
   witGetPipSeqFromHeur (theWitRun, & theBool);

   assert               (theBool);

   witGetPipExists      (theWitRun, & theBool);

   assert               (! theBool);

   witHeurImplode       (theWitRun);

   witBuildPip          (theWitRun);

   witGetPipExists      (theWitRun, & theBool);

   assert               (theBool);

   testExecVolPipDbl    (theWitRun, "PS1", "US", 2);
   testCoExecVolPipDbl  (theWitRun, "PS1", "US", 2);
   testSubVolPipDbl     (theWitRun, "PS1", "US", 2);
   testSupplyVolPipDbl  (theWitRun, "PS1", "US", 2);
   testSideVolPipDbl    (theWitRun, "PS1", "US", 2);
   testProdVolPipDbl    (theWitRun, "PS1", "US", 2);
   testConsVolPipDbl    (theWitRun, "PS1", "US", 2);

   truncatePipSeqDbl    (theWitRun);

   witBuildPip          (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* truncatePipSeqDbl                                                          */
/*                                                                            */
/* Reduces the PIP shipment sequence to its first and last elements.          */
/*----------------------------------------------------------------------------*/

void truncatePipSeqDbl (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * demandNameList;
   int *    shipPerList;   
   double * incShipVolList;
   int      theIdx;

   witGetPipSeqDbl (
        theWitRun,
      & lenLists,
      & partNameList,
      & demandNameList,
      & shipPerList,
      & incShipVolList);

   witClearPipSeq (theWitRun);

   witAppendToPipSeqDbl (
      theWitRun,
      partNameList  [0],
      demandNameList[0],
      shipPerList   [0],
      incShipVolList[0]);

   witAppendToPipSeqDbl (
      theWitRun,
      partNameList  [lenLists - 1],
      demandNameList[lenLists - 1],
      shipPerList   [lenLists - 1],
      incShipVolList[lenLists - 1]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      {
      witFree (partNameList  [theIdx]);
      witFree (demandNameList[theIdx]);
      }

   witFree (partNameList);
   witFree (demandNameList);
   witFree (shipPerList);
   witFree (incShipVolList);
   }

/*----------------------------------------------------------------------------*/
/* testExecVolPipDbl                                                          */
/*----------------------------------------------------------------------------*/

void testExecVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    execPeriodList;
   double * peggedExecVolList;
   int      theIdx;

   witGetDemandExecVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & execPeriodList,
      & peggedExecVolList);

   printf (
      "\n"
      "ExecVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, Period %d, ExecVol: %.0f\n",
         operationNameList[theIdx],
         execPeriodList   [theIdx],
         peggedExecVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (execPeriodList);
   witFree (peggedExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testCoExecVolPipDbl                                                        */
/*----------------------------------------------------------------------------*/

void testCoExecVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bopEntryIndexList;
   int *    execPeriodList;
   double * peggedCoExecVolList;
   int      theIdx;

   witGetDemandCoExecVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bopEntryIndexList,
      & execPeriodList,
      & peggedCoExecVolList);

   printf (
      "\n"
      "CoExecVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Operation %s, BOP Entry %d, Period %d, CoExecVol: %.0f\n",
         operationNameList    [theIdx],
         bopEntryIndexList    [theIdx],
         execPeriodList       [theIdx],
         peggedCoExecVolList  [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bopEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedCoExecVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSubVolPipDbl                                                           */
/*----------------------------------------------------------------------------*/

void testSubVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * operationNameList;
   int *    bomEntryIndexList;
   int *    subsBomEntryIndexList;
   int *    execPeriodList;
   double * peggedSubVolList;
   int      theIdx;

   witGetDemandSubVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & operationNameList,
      & bomEntryIndexList,
      & subsBomEntryIndexList,
      & execPeriodList,
      & peggedSubVolList);

   printf (
      "\n"
      "SubVol PIP for Part %s, Demand %s, Period %d:\n\n",
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf (
         "   Operation %s, BOM Entry %d, Sub %d, Period %d, SubVol: %.0f\n",
         operationNameList    [theIdx],
         bomEntryIndexList    [theIdx],
         subsBomEntryIndexList[theIdx],
         execPeriodList       [theIdx],
         peggedSubVolList     [theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (operationNameList[theIdx]);

   witFree (operationNameList);
   witFree (bomEntryIndexList);
   witFree (subsBomEntryIndexList);
   witFree (execPeriodList);
   witFree (peggedSubVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSupplyVolPipDbl                                                        */
/*----------------------------------------------------------------------------*/

void testSupplyVolPipDbl (
      WitRun *     theWitRun,
      const char * partName,
      const char * demandName,
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   double * peggedSupplyVolList;

   witGetDemandSupplyVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedSupplyVolList);


   testPartVolPipDbl (
      "SupplyVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedSupplyVolList);
   }

/*----------------------------------------------------------------------------*/
/* testSideVolPipDbl                                                          */
/*----------------------------------------------------------------------------*/

void testSideVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   double * peggedSideVolList;

   witGetDemandSideVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedSideVolList);


   testPartVolPipDbl (
      "SideVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedSideVolList);
   }

/*----------------------------------------------------------------------------*/
/* testProdVolPipDbl                                                          */
/*----------------------------------------------------------------------------*/

void testProdVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   double * peggedProdVolList;

   witGetDemandProdVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedProdVolList);


   testPartVolPipDbl (
      "ProdVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedProdVolList);
   }

/*----------------------------------------------------------------------------*/
/* testConsVolPipDbl                                                          */
/*----------------------------------------------------------------------------*/

void testConsVolPipDbl (
      WitRun *     theWitRun, 
      const char * partName, 
      const char * demandName, 
      int          shipPer)
   {
   int      lenLists;
   char * * partNameList;
   int *    periodList;
   double * peggedConsVolList;

   witGetDemandConsVolPipDbl (
        theWitRun,
        partName,
        demandName,
        shipPer,
      & lenLists,
      & partNameList,
      & periodList,
      & peggedConsVolList);


   testPartVolPipDbl (
      "ConsVol",
      partName, 
      demandName, 
      shipPer,
      lenLists,
      partNameList,
      periodList,
      peggedConsVolList);
   }

/*----------------------------------------------------------------------------*/

void testPartVolPipDbl (
      const char * attrName,
      const char * partName, 
      const char * demandName, 
      int          shipPer,
      int          lenLists,
      char * *     partNameList,
      int *        periodList,
      double *     peggedVolList)
   {
   int theIdx;

   printf (
      "\n"
      "%s PIP for Part %s, Demand %s, Period %d:\n\n",
      attrName,
      partName,
      demandName,
      shipPer);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Part %s, Period %d, %s: %.0f\n",
         partNameList [theIdx],
         periodList   [theIdx],
         attrName,
         peggedVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      witFree (partNameList[theIdx]);

   witFree (partNameList);
   witFree (periodList);
   witFree (peggedVolList);
   }

/*----------------------------------------------------------------------------*/
/* Function testPgdCritList.                                                  */
/*                                                                            */
/* Tests pegged critical list.                                                */
/*----------------------------------------------------------------------------*/

void testPgdCritList (WitRun * theWitRun)
   {
   witBoolean theBool;

   witSetSelSplit        (theWitRun,   WitFALSE);
   witSetSrSelSplit      (theWitRun,   WitFALSE);
   witSetSkipFailures    (theWitRun,   WitTRUE);

   witSetPgdCritListMode (theWitRun,   WitTRUE);

   witGetPgdCritListMode (theWitRun, & theBool);

   assert (theBool);

   witHeurImplode        (theWitRun);

   printPgdCritList      (theWitRun);

   witSetPgdCritListMode (theWitRun,   WitFALSE);

   printPgdCritList      (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* Function printPgdCritList.                                                 */
/*                                                                            */
/* Prints pegged critical list.                                               */
/*----------------------------------------------------------------------------*/

void printPgdCritList (WitRun * theWitRun)
   {
   int      lenLists;
   char * * critPartNameList;
   int *    critPerList;
   char * * demPartNameList;
   char * * demandNameList;
   int *    shipPerList;
   int      theIdx;

   witGetPgdCritList (
        theWitRun,
      & lenLists,
      & critPartNameList,
      & critPerList,
      & demPartNameList,
      & demandNameList,
      & shipPerList);

   printf (
      "\n"
      "-------------------------------------\n"
      "Pegged Critical List\n"
      "-------------------------------------\n"
      "\n"
      "Idx  Crit     Crit  Dem     Dem  Ship\n"
      "     Part      Per  Part          Per\n"
      );

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf (
         "%3d  %-7s  %4d  %-6s  %-3s  %4d\n",
         theIdx,
         critPartNameList[theIdx],
         critPerList     [theIdx],
         demPartNameList [theIdx],
         demandNameList  [theIdx],
         shipPerList     [theIdx]);

   printf (
      "\n"
      "-------------------------------------\n"
      "\n");

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      {
      witFree (critPartNameList[theIdx]);
      witFree (demPartNameList [theIdx]);
      witFree (demandNameList  [theIdx]);
      }

   witFree (critPartNameList);
   witFree (critPerList);
   witFree (demPartNameList);
   witFree (demandNameList);
   witFree (shipPerList);
   }

/*----------------------------------------------------------------------------*/
/* testObjItr                                                                 */
/*----------------------------------------------------------------------------*/

void testObjItr (WitRun * theWitRun)
   {
   witAttr objItrState;
   char *  partName;
   char *  opnName;
   char *  demandName;
   int     bomEntIdx;
   int     subIdx;
   int     bopEntIdx;

   witGetObjItrState (theWitRun, & objItrState);

   assert (objItrState == WitINACTIVE);

   witResetObjItr (theWitRun);

   while (WitTRUE)
      {
      witAdvanceObjItr  (theWitRun);

      witGetObjItrState (theWitRun, & objItrState);

      if      (objItrState == WitAT_PART)
         {
         witGetObjItrPart (theWitRun, & partName);

         printf (
            "\n"
            "Object iteration is currently located at the following part:\n"
            "\n"
            "   Part \"%s\"\n",
            partName);

         witFree (partName);
         }
      else if (objItrState == WitAT_DEMAND)
         {
         witGetObjItrDemand (theWitRun, & partName, & demandName);

         printf (
            "\n"
            "Object iteration is currently located at the following demand:\n"
            "\n"
            "   Part   \"%s\"\n"
            "   Demand \"%s\"\n",
            partName,
            demandName);

         witFree (partName);
         witFree (demandName);
         }
      else if (objItrState == WitAT_OPERATION)
         {
         witGetObjItrOperation (theWitRun, & opnName);

         printf (
            "\n"
            "Object iteration is currently located at the following operation:"
            "\n"
            "\n"
            "   Operation \"%s\"\n",
            opnName);

         witFree (opnName);
         }
      else if (objItrState == WitAT_BOM_ENTRY)
         {
         witGetObjItrBomEntry (theWitRun, & opnName, & bomEntIdx);

         printf (
            "\n"
            "Object iteration is currently located at the following BOM entry:"
            "\n"
            "\n"
            "   Operation       \"%s\"\n"
            "   BOM Entry Index %d\n",
            opnName,
            bomEntIdx);

         witFree (opnName);
         }
      else if (objItrState == WitAT_SUB_ENTRY)
         {
         witGetObjItrSubsBomEntry (theWitRun, & opnName, & bomEntIdx, & subIdx);

         printf (
            "\n"
            "Object iteration is currently located at the following substitute:"
            "\n"
            "\n"
            "   Operation       \"%s\"\n"
            "   BOM Entry Index %d\n"
            "   Sub Index       %d\n",
            opnName,
            bomEntIdx,
            subIdx);

         witFree (opnName);
         }
      else if (objItrState == WitAT_BOP_ENTRY)
         {
         witGetObjItrBopEntry (theWitRun, & opnName, & bopEntIdx);

         printf (
            "\n"
            "Object iteration is currently located at the following BOP entry:"
            "\n"
            "\n"
            "   Operation       \"%s\"\n"
            "   BOP Entry Index %d\n",
            opnName,
            bopEntIdx);

         witFree (opnName);
         }
      else if (objItrState == WitINACTIVE)
         return;
      else
         assert (WitFALSE);
      }
   }

/*----------------------------------------------------------------------------*/
/* testAccOptImp                                                              */
/*                                                                            */
/* Tests accelerated optimizing implosion.                                    */
/*----------------------------------------------------------------------------*/

void testAccOptImp ()
   {
   WitRun * theWitRunA;
   WitRun * theWitRunB;

   printf (
      "\n"
      "--- Testing Accelerated Optimizing Implosion ---\n"
      "\n");

   witNewRun  (& theWitRunA);
   witNewRun  (& theWitRunB);

   optImpA1     (theWitRunA);
   optImpB1     (theWitRunB);
   optImpA2     (theWitRunA);
   optImpB2     (theWitRunB);

   witDeleteRun (theWitRunA);
   witDeleteRun (theWitRunB);

   prtFiles ();
   }

/*----------------------------------------------------------------------------*/
/* optImpA1                                                                   */
/*----------------------------------------------------------------------------*/

void optImpA1 (WitRun * theWitRunA)
   {
   witSetMesgFileName         (theWitRunA, WitTRUE, "wit-a.log");

   witInitialize              (theWitRunA);

   witReadData                (theWitRunA, "data/obj1.data");

   witSetAccAfterOptImp       (theWitRunA, WitTRUE);

   witSetSolverLogFileName    (theWitRunA, "solver-a.log");

   witOptImplode              (theWitRunA);
 
   witWriteExecSched          (theWitRunA, "exec-a1.out", WitBSV);
   }

/*----------------------------------------------------------------------------*/
/* optImpB1                                                                   */
/*----------------------------------------------------------------------------*/

void optImpB1 (WitRun * theWitRunB)
   {
   float hardLB[] = {0, 0, 0, 0, 0, 0, 0, 0};

   witSetMesgFileName         (theWitRunB, WitTRUE, "wit-b.log");

   witInitialize              (theWitRunB);

   witReadData                (theWitRunB, "data/diner.data");

   witSetAccAfterOptImp       (theWitRunB, WitTRUE);

   witSetSolverLogFileName    (theWitRunB, "solver-b.log");

   witSetOperationExecBounds  (theWitRunB,
                               "Ham_Sandwich",
                               hardLB,
                               NULL,
                               NULL);

   witOptImplode              (theWitRunB);

   witWriteExecSched          (theWitRunB, "exec-b1.out", WitBSV);
   }

/*----------------------------------------------------------------------------*/
/* optImpA2                                                                   */
/*----------------------------------------------------------------------------*/

void optImpA2 (WitRun * theWitRunA)
   {
   float supplyVol[] = {0, 10, 10, 10, 10, 10, 10, 10};

   witSetPartSupplyVol (theWitRunA, "COMP2", supplyVol);

   witOptImplode       (theWitRunA);

   witWriteExecSched   (theWitRunA, "exec-a2.out", WitBSV);
   }

/*----------------------------------------------------------------------------*/
/* optImpB2                                                                   */
/*----------------------------------------------------------------------------*/

void optImpB2 (WitRun * theWitRunB)
   {
   float supplyVol[] = {200, 200, 200, 200, 200, 200, 200, 200};

   witSetPartSupplyVol (theWitRunB, "Bread", supplyVol);

   witOptImplode       (theWitRunB);

   witWriteExecSched   (theWitRunB, "exec-b2.out", WitBSV);
   }

/*----------------------------------------------------------------------------*/
/* prtFiles                                                                   */
/*----------------------------------------------------------------------------*/

void prtFiles ()
   {
   prtRemove ("wit-a.log");
   prtRemove ("solver-a.log");
   prtRemove ("exec-a1.out");
   prtRemove ("exec-a2.out");

   prtRemove ("wit-b.log");
   prtRemove ("solver-b.log");
   prtRemove ("exec-b1.out");
   prtRemove ("exec-b2.out");
   }

/*----------------------------------------------------------------------------*/
/* prtRemove                                                                  */
/*----------------------------------------------------------------------------*/

void prtRemove (const char * filename)
   {
   char cmd[100];

   printf (
      "\n"
      "File \"%s\":\n"
      "\n",
      filename);

   fflush (stdout);

   strcpy(cmd, "cat ");

   strcat (cmd, filename);

   system (cmd);

   remove (filename);
   }

/*----------------------------------------------------------------------------*/
/* testCumShipVol                                                             */
/*                                                                            */
/* Verifies that heuristic allocation satisfies cumShipVol <= cumDemandVol.   */
/*----------------------------------------------------------------------------*/

void testCumShipVol ()
   {
   WitRun *   theWitRun;
   float      supplyVol[] = {100.0,  0.0,  0.0};
   float      demandVol[] = { 30.0, 10.0, 10.0};
   float      incVol;
   witBoolean postproc;

   witNewRun           (& theWitRun);

   witInitialize         (theWitRun);

   witSetNPeriods        (theWitRun, 3);

   witAddPart            (theWitRun, "A",      WitMATERIAL);

   witAddDemand          (theWitRun, "A", "B");

   witSetPartSupplyVol   (theWitRun, "A",      supplyVol);

   witSetDemandDemandVol (theWitRun, "A", "B", demandVol);

   witStartHeurAlloc     (theWitRun);

   witIncHeurAlloc       (theWitRun, "A", "B", 1, 29, & incVol);
   witIncHeurAlloc       (theWitRun, "A", "B", 2, 13, & incVol);
   witIncHeurAlloc       (theWitRun, "A", "B", 0, 14, & incVol);

   assert (fabs (incVol - 8.0) < 0.00001);

   witShutDownHeurAlloc  (theWitRun);

   witGetPostprocessed   (theWitRun, & postproc);

   assert (! postproc);

   witDeleteRun          (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* Function testExtOpt.                                                       */
/*                                                                            */
/* Tests external optimizing implosion.                                       */
/*----------------------------------------------------------------------------*/

void testExtOpt ()
   {
   WitRun *   theWitRun;
   witBoolean extOptActive;

   witNewRun            (& theWitRun);

   buildExtOptProblem     (theWitRun);

   witGetExtOptActive     (theWitRun, & extOptActive);
   assert                            (! extOptActive);

   witStartExtOpt         (theWitRun);

   witGetExtOptActive     (theWitRun, & extOptActive);
   assert                              (extOptActive);

   testGetExtOptLpProb    (theWitRun);
   testGetExtOptLpProbDbl (theWitRun);
   testGetConIndices      (theWitRun);
   testGetVarIndices      (theWitRun);
   testGetSlbvVarIndices  (theWitRun);
   testGetSlbConIndices   (theWitRun);

   witFinishExtOpt        (theWitRun);

   witGetExtOptActive     (theWitRun, & extOptActive);
   assert                            (! extOptActive);

   witStartExtOpt         (theWitRun);
   witShutDownExtOpt      (theWitRun);

   witGetExtOptActive     (theWitRun, & extOptActive);
   assert                            (! extOptActive);

   witDeleteRun           (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* buildExtOptProblem                                                         */
/*----------------------------------------------------------------------------*/

void buildExtOptProblem (WitRun * theWitRun)
   {
   float offset[]     = {2.0, 2.0, 2.0};
   float execSlb[]    = {3.0, 4.0, 5.0};
   float stockSlb[]   = {2.0, 0.0, 3.0};
   float cumShipSlb[] = {1.0, 3.0, 0.0};

   witInitialize             (theWitRun);

   witSetNPeriods            (theWitRun,             3);

   witAddPart                (theWitRun,   "A",      WitMATERIAL);
   witAddPart                (theWitRun,   "B",      WitMATERIAL);
   witAddOperation           (theWitRun,   "C");
   witAddBomEntry            (theWitRun,   "C", "A");
   witAddBopEntry            (theWitRun,   "C", "B");
   witAddSubsBomEntry        (theWitRun,   "C",  0,  "A");
   witAddDemand              (theWitRun,   "B", "D");

   witSetBomEntryOffset      (theWitRun,   "C",  0,  offset);
   witSetOperationExecBounds (theWitRun,   "C",      NULL, execSlb,    NULL);
   witSetPartStockBounds     (theWitRun,   "B",      NULL, stockSlb,   NULL);
   witSetDemandCumShipBounds (theWitRun,   "B", "D", NULL, cumShipSlb, NULL);
   }

/*----------------------------------------------------------------------------*/
/* testGetExtOptLpProb                                                        */
/*----------------------------------------------------------------------------*/

void testGetExtOptLpProb (WitRun * theWitRun)
   {
   int     numcols;
   int     numrows;
   int *   start;
   int *   index;
   float * value;
   float * collb;
   float * colub;
   float * obj;
   float * rowlb;
   float * rowub;

   witGetExtOptLpProb (
        theWitRun,
      & numcols,
      & numrows,
      & start,
      & index,
      & value,
      & collb,
      & colub,
      & obj,
      & rowlb,
      & rowub);

   witSetExtOptSoln (theWitRun, collb);

   witFree (start);
   witFree (index);
   witFree (value);
   witFree (collb);
   witFree (colub);
   witFree (obj);
   witFree (rowlb);
   witFree (rowub);
   }

/*----------------------------------------------------------------------------*/
/* testGetExtOptLpProbDbl                                                     */
/*----------------------------------------------------------------------------*/

void testGetExtOptLpProbDbl (WitRun * theWitRun)
   {
   int      numcols;
   int      numrows;
   int *    start;
   int *    index;
   double * value;
   double * collb;
   double * colub;
   double * obj;
   double * rowlb;
   double * rowub;
   int *    indices;
   int      nIntVars;

   witGetExtOptLpProbDbl (
        theWitRun,
      & numcols,
      & numrows,
      & start,
      & index,
      & value,
      & collb,
      & colub,
      & obj,
      & rowlb,
      & rowub);

   witGetExtOptIntVarIndices (
        theWitRun,
      & indices,
      & nIntVars);

   witSetExtOptSolnDbl (theWitRun, collb);

   witFree (start);
   witFree (index);
   witFree (value);
   witFree (collb);
   witFree (colub);
   witFree (obj);
   witFree (rowlb);
   witFree (rowub);
   witFree (indices);
   }

/*----------------------------------------------------------------------------*/
/* testGetConIndices                                                          */
/*----------------------------------------------------------------------------*/

void testGetConIndices (WitRun * theWitRun)
   {
   int conIndex;

   witGetPartResourceConIndex (theWitRun, "A", 2, & conIndex);

   printf (
      "\n"
      "Resource Allocation Constraint Index:\n"
      "   Part:   A\n"
      "   Period: 2\n"
      "   Index: %2d\n",
      conIndex);

   witGetDemandShipConIndex (theWitRun, "B", "D", 1, & conIndex);

   printf (
      "\n"
      "Shipment Cumulation Constraint Index:\n"
      "   Part:   B\n"
      "   Demand: D\n"
      "   Period: 1\n"
      "   Index: %2d\n",
      conIndex);

   witGetBomEntrySubConIndex (theWitRun, "C", 0, 1, & conIndex);

   printf (
      "\n"
      "Substitution Constraint Index:\n"
      "   Operation: C\n"
      "   BOM Entry: 0\n"
      "   Period:    1\n"
      "   Index:    %2d\n",
      conIndex);
   }

/*----------------------------------------------------------------------------*/
/* testGetVarIndices                                                          */
/*----------------------------------------------------------------------------*/

void testGetVarIndices (WitRun * theWitRun)
   {
   int varIndex;

   witGetOperationExecVarIndex (theWitRun, "C", 1, & varIndex);

   printf (
      "\n"
      "Execution Variable Index:\n"
      "   Operation: C\n"
      "   Period:    1\n"
      "   Index:    %2d\n",
      varIndex);

   witGetPartScrapVarIndex (theWitRun, "A", 2, & varIndex);

   printf (
      "\n"
      "Scrap Variable Index:\n"
      "   Part:   A\n"
      "   Period: 2\n"
      "   Index: %2d\n",
      varIndex);

   witGetPartStockVarIndex (theWitRun, "B", 0, & varIndex);

   printf (
      "\n"
      "Stock Variable Index:\n"
      "   Part:   B\n"
      "   Period: 0\n"
      "   Index: %2d\n",
      varIndex);

   witGetDemandShipVarIndex (theWitRun, "B", "D", 0, & varIndex);

   printf (
      "\n"
      "Shipment Variable Index:\n"
      "   Part:   B\n"
      "   Demand: D\n"
      "   Period: 0\n"
      "   Index: %2d\n",
      varIndex);

   witGetDemandCumShipVarIndex (theWitRun, "B", "D", 2, & varIndex);

   printf (
      "\n"
      "Cumulative Shipment Variable Index:\n"
      "   Part:   B\n"
      "   Demand: D\n"
      "   Period: 2\n"
      "   Index: %2d\n",
      varIndex);

   witGetBomEntryNonSubVarIndex (theWitRun, "C", 0, 0, & varIndex);

   printf (
      "\n"
      "Non-Substitution Variable Index:\n"
      "   Operation: C\n"
      "   BOM Entry: 0\n"
      "   Period:    0\n"
      "   Index:    %2d\n",
      varIndex);

   witGetSubsBomEntrySubVarIndex (theWitRun, "C", 0, 0, 2, & varIndex);

   printf (
      "\n"
      "Substitution Variable Index:\n"
      "   Operation:  C\n"
      "   BOM Entry:  0\n"
      "   Substitute: 0\n"
      "   Period:     2\n"
      "   Index:     %2d\n",
      varIndex);
   }

/*----------------------------------------------------------------------------*/
/* testGetSlbvVarIndices                                                      */
/*----------------------------------------------------------------------------*/

void testGetSlbvVarIndices (WitRun * theWitRun)
   {
   int varIndex;

   witGetOperationExecSlbvVarIndex (theWitRun, "C", 2, & varIndex);

   printf (
      "\n"
      "Execution SLBV Variable Index:\n"
      "   Operation: C\n"
      "   Period:    2\n"
      "   Index:    %2d\n",
      varIndex);

   witGetPartStockSlbvVarIndex (theWitRun, "B", 0, & varIndex);

   printf (
      "\n"
      "Stock SLBV Variable Index:\n"
      "   Part:   B\n"
      "   Period: 0\n"
      "   Index: %2d\n",
      varIndex);

   witGetDemandCumShipSlbvVarIndex (theWitRun, "B", "D", 1, & varIndex);

   printf (
      "\n"
      "Cumulative Shipment SLBV Variable Index:\n"
      "   Part:   B\n"
      "   Demand: D\n"
      "   Period: 2\n"
      "   Index: %2d\n",
      varIndex);
   }

/*----------------------------------------------------------------------------*/
/* testGetSlbConIndices                                                       */
/*----------------------------------------------------------------------------*/

void testGetSlbConIndices (WitRun * theWitRun)
   {
   int conIndex;

   witGetOperationExecSlbConIndex (theWitRun, "C", 2, & conIndex);

   printf (
      "\n"
      "Execution SLB Constraint Index:\n"
      "   Operation: C\n"
      "   Period:    2\n"
      "   Index:    %2d\n",
      conIndex);

   witGetPartStockSlbConIndex (theWitRun, "B", 2, & conIndex);

   printf (
      "\n"
      "Stock SLB Constraint Index:\n"
      "   Part:   B\n"
      "   Period: 2\n"
      "   Index: %2d\n",
      conIndex);

   witGetDemandCumShipSlbConIndex (theWitRun, "B", "D", 0, & conIndex);

   printf (
      "\n"
      "Cumulative Shipment SLB Constraint Index:\n"
      "   Part:   B\n"
      "   Demand: D\n"
      "   Period: 0\n"
      "   Index: %2d\n",
      conIndex);
   }

/*----------------------------------------------------------------------------*/
/* testCopyObjData1WR                                                         */
/*                                                                            */
/* Tests witCopy<Object>Data using one WitRun.                                */
/*----------------------------------------------------------------------------*/

void testCopyObjData1WR ()
   {
   WitRun *   theWitRun;
   witBoolean theBool;

   witNewRun                 (& theWitRun);
   witInitialize               (theWitRun);

   witAddPart                  (theWitRun, "A", WitMATERIAL);
   witAddPart                  (theWitRun, "B", WitMATERIAL);
   witAddPart                  (theWitRun, "C", WitMATERIAL);
   witAddOperation             (theWitRun, "D");
   witAddOperation             (theWitRun, "E");
   witAddBomEntry              (theWitRun, "D", "A");
   witAddBomEntry              (theWitRun, "E", "B");
   witAddBopEntry              (theWitRun, "D", "B");
   witAddBopEntry              (theWitRun, "E", "C");
   witAddSubsBomEntry          (theWitRun, "D",  0, "A");
   witAddSubsBomEntry          (theWitRun, "E",  0, "A");
   witAddDemand                (theWitRun, "C", "F");
   witAddDemand                (theWitRun, "C", "G");

   witSetPartSelForDel         (theWitRun, "A",         WitTRUE);
   witSetOperationSelForDel    (theWitRun, "D",         WitTRUE);
   witSetBomEntrySelForDel     (theWitRun, "D", 0,      WitTRUE);
   witSetBopEntrySelForDel     (theWitRun, "D", 0,      WitTRUE);
   witSetSubsBomEntrySelForDel (theWitRun, "D", 0, 0,   WitTRUE);
   witSetDemandSelForDel       (theWitRun, "C", "F",    WitTRUE);

   witCopyPartData             (theWitRun, "B",         theWitRun, "A");
   witCopyOperationData        (theWitRun, "E",         theWitRun, "D");
   witCopyBomEntryData         (theWitRun, "E", 0,      theWitRun, "D", 0);
   witCopyBopEntryData         (theWitRun, "E", 0,      theWitRun, "D", 0);
   witCopySubsBomEntryData     (theWitRun, "E", 0, 0,   theWitRun, "D", 0, 0);
   witCopyDemandData           (theWitRun, "C", "G",    theWitRun, "C", "F");

   witGetPartSelForDel         (theWitRun, "B",       & theBool);
   assert                                              (theBool);
   witGetOperationSelForDel    (theWitRun, "E",       & theBool);
   assert                                              (theBool);
   witGetBomEntrySelForDel     (theWitRun, "E", 0,    & theBool);
   assert                                              (theBool);
   witGetBopEntrySelForDel     (theWitRun, "E", 0,    & theBool);
   assert                                              (theBool);
   witGetSubsBomEntrySelForDel (theWitRun, "E", 0, 0, & theBool);
   assert                                              (theBool);
   witGetDemandSelForDel       (theWitRun, "C", "G",  & theBool);
   assert                                              (theBool);

   witDeleteRun                (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testCopyObjData2WRs                                                        */
/*                                                                            */
/* Tests witCopy<Object>Data using two WitRuns.                               */
/*----------------------------------------------------------------------------*/

void testCopyObjData2WRs ()
   {
   WitRun *   origWitRun;
   WitRun *    dupWitRun;
   witBoolean theBool;

   witNewRun                 (& origWitRun);
   witInitialize               (origWitRun);

   witAddPart                  (origWitRun, "A", WitMATERIAL);
   witAddPart                  (origWitRun, "B", WitMATERIAL);
   witAddOperation             (origWitRun, "C");
   witAddBomEntry              (origWitRun, "C", "A");
   witAddBopEntry              (origWitRun, "C", "B");
   witAddSubsBomEntry          (origWitRun, "C",  0, "A");
   witAddDemand                (origWitRun, "B", "D");

   witSetPartSelForDel         (origWitRun, "A",         WitTRUE);
   witSetOperationSelForDel    (origWitRun, "C",         WitTRUE);
   witSetBomEntrySelForDel     (origWitRun, "C", 0,      WitTRUE);
   witSetBopEntrySelForDel     (origWitRun, "C", 0,      WitTRUE);
   witSetSubsBomEntrySelForDel (origWitRun, "C", 0, 0,   WitTRUE);
   witSetDemandSelForDel       (origWitRun, "B", "D",    WitTRUE);

   witNewRun                  (& dupWitRun);
   witInitialize                (dupWitRun);

   witAddPart                   (dupWitRun, "A", WitMATERIAL);
   witAddPart                   (dupWitRun, "B", WitMATERIAL);
   witAddOperation              (dupWitRun, "C");
   witAddBomEntry               (dupWitRun, "C", "A");
   witAddBopEntry               (dupWitRun, "C", "B");
   witAddSubsBomEntry           (dupWitRun, "C",  0, "A");
   witAddDemand                 (dupWitRun, "B", "D");

   witCopyPartData              (dupWitRun, "A",         origWitRun, "A");
   witCopyOperationData         (dupWitRun, "C",         origWitRun, "C");
   witCopyBomEntryData          (dupWitRun, "C", 0,      origWitRun, "C", 0);
   witCopyBopEntryData          (dupWitRun, "C", 0,      origWitRun, "C", 0);
   witCopySubsBomEntryData      (dupWitRun, "C", 0, 0,   origWitRun, "C", 0, 0);
   witCopyDemandData            (dupWitRun, "B", "D",    origWitRun, "B", "D");

   witGetPartSelForDel          (dupWitRun, "A",       & theBool);
   assert                                               (theBool);
   witGetOperationSelForDel     (dupWitRun, "C",       & theBool);
   assert                                               (theBool);
   witGetBomEntrySelForDel      (dupWitRun, "C", 0,    & theBool);
   assert                                               (theBool);
   witGetBopEntrySelForDel      (dupWitRun, "C", 0,    & theBool);
   assert                                               (theBool);
   witGetSubsBomEntrySelForDel  (dupWitRun, "C", 0, 0, & theBool);
   assert                                               (theBool);
   witGetDemandSelForDel        (dupWitRun, "B", "D",  & theBool);
   assert                                               (theBool);

   witDeleteRun                 (dupWitRun);
   witDeleteRun                (origWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testShipLateAllowed                                                        */
/*                                                                            */
/* Test of WIT with shipLateAllowed = FALSE                                   */
/*----------------------------------------------------------------------------*/

void testShipLateAllowed ()
   {
   WitRun *   theWitRun;
   float      supplyVolA [] = {100.0, 400.0};
   float      demandVolB [] = {200.0, 200.0};
   witBoolean shipLateAllowedB;
   float *    shipVolB;
   float      fssShipVolB[] = {700.0, 700.0};
   float *    shortVolA;

   witNewRun                 (& theWitRun);
   witInitialize               (theWitRun);

   witSetNPeriods              (theWitRun, 2);

   witAddPart                  (theWitRun, "A",        WitCAPACITY );
   witAddDemand                (theWitRun, "A", "B");

   witSetPartSupplyVol         (theWitRun, "A",        supplyVolA);
   witSetDemandDemandVol       (theWitRun, "A", "B",   demandVolB);
   witSetDemandShipLateAllowed (theWitRun, "A", "B",   WitFALSE);
   witGetDemandShipLateAllowed (theWitRun, "A", "B", & shipLateAllowedB);
   assert                                           (! shipLateAllowedB);

   witHeurImplode              (theWitRun);

   witGetDemandShipVol         (theWitRun, "A", "B", & shipVolB);

   printFltVec                 ("B.shipVol",           shipVolB,  2);
   witFree                                            (shipVolB);

   witSetUseFocusHorizons      (theWitRun,             WitFALSE);
   witSetDemandFssShipVol      (theWitRun, "A", "B",   fssShipVolB);
   witGetPartFocusShortageVol  (theWitRun, "A",      & shortVolA);

   printFltVec                 ("A.shortVol",          shortVolA, 2);
   witFree                                            (shortVolA);

   witDeleteRun                (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testGetExpCycle                                                            */
/*                                                                            */
/* Test of witGetExpCycle                                                     */
/*----------------------------------------------------------------------------*/

void testGetExpCycle ()
   {
   WitRun * theWitRun;

   witNewRun       (& theWitRun);
   buildCycleProblem (theWitRun);
   displayCycle      (theWitRun);
   witDeleteRun      (theWitRun);
   }

/*----------------------------------------------------------------------------*/

void buildCycleProblem (WitRun * theWitRun)
   {
   witInitialize   (theWitRun);

   witAddPart      (theWitRun, "A", WitMATERIAL);
   witAddOperation (theWitRun, "B");
   witAddPart      (theWitRun, "C", WitMATERIAL);
   witAddOperation (theWitRun, "D");
   witAddBomEntry  (theWitRun, "B", "A");
   witAddBopEntry  (theWitRun, "B", "C");
   witAddBomEntry  (theWitRun, "D", "C");
   witAddBopEntry  (theWitRun, "D", "A");
   }

/*----------------------------------------------------------------------------*/

void displayCycle (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * opnNameList;
   int      theIdx;

   witGetExpCycle (
        theWitRun,
      & lenLists,
      & partNameList,
      & opnNameList);

   assert (lenLists > 0);

   printf (
      "\n"
      "The following explodeable cycle was found:\n");

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf (
         "   Part      %s\n"
         "   Operation %s\n",
         partNameList[theIdx],
         opnNameList [theIdx]);
      
   printf (
      "   Part      %s\n",
      partNameList[0]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      {
      witFree (partNameList[theIdx]);
      witFree (opnNameList [theIdx]);
      }

   witFree (partNameList);
   witFree (opnNameList);
   }

/*----------------------------------------------------------------------------*/
/* testStageByObject                                                          */
/*                                                                            */
/* Test of API functions for stochastic implosion in stage-by-object mode.    */
/*----------------------------------------------------------------------------*/

void testStageByObject ()
   {
   WitRun * theWitRun;

   if (! cplexEmbedded)
      return;

   witNewRun         (& theWitRun);
   buildCoreProblemSBO (theWitRun);
   specifyStochDataSBO (theWitRun);
   checkStochData      (theWitRun);
   witDisplayData      (theWitRun, WitSTDOUT);
   printf                         ("\n");
   testStochWriteData  (theWitRun);
   testStochCopyData   (theWitRun);
   testStochImplode    (theWitRun);
   checkStochSoln      (theWitRun);
   testClearStochSoln  (theWitRun);

   witDeleteRun        (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* buildCoreProblemSBO                                                        */
/*                                                                            */
/* Builds the core problem for the stochastic implosion stage-by-object test. */
/*----------------------------------------------------------------------------*/

void buildCoreProblemSBO (WitRun * theWitRun)
   {
   float supplyVolA [] = {500.0};
   float demandVolD [] = {300.0};
   float execCostC  [] =   {1.0};
   float shipRewardD[] =   {5.0};

   witSetMesgPrintNumber     (theWitRun, WitTRUE,
                                         WitINFORMATIONAL_MESSAGES,
                                         WitFALSE);   

   witInitialize             (theWitRun);

   witSetNPeriods            (theWitRun, 1);
   witSetWbounds             (theWitRun, 0.0);
   witSetOptInitMethod       (theWitRun, WitCRASH_OPT_INIT_METHOD);

   witAddPart                (theWitRun, "A",      WitMATERIAL);
   witAddPart                (theWitRun, "B",      WitMATERIAL);
   witAddOperation           (theWitRun, "C");
   witAddBomEntry            (theWitRun, "C", "A");
   witAddBopEntry            (theWitRun, "C", "B");
   witAddDemand              (theWitRun, "B", "D");

   witSetPartSupplyVol       (theWitRun, "A",      supplyVolA);
   witSetDemandDemandVol     (theWitRun, "B", "D", demandVolD);
   witSetDemandCumShipBounds (theWitRun, "B", "D", NULL,
                                                   demandVolD,
                                                   NULL);
   witSetOperationExecCost   (theWitRun, "C",      execCostC);
   witSetDemandShipReward    (theWitRun, "B", "D", shipRewardD);
   }

/*----------------------------------------------------------------------------*/
/* specifyStochDataSBO                                                        */
/*                                                                            */
/* Specifies the stochastic data for the stochastic implosion test.           */
/*----------------------------------------------------------------------------*/

void specifyStochDataSBO (WitRun * theWitRun)
   {
   float demandVolD0[] = {100.0};
   float demandVolD1[] = {200.0};

   witSetStageByObject        (theWitRun,           WitTRUE);
   witSetNScenarios           (theWitRun,           3);
   witSetStochMode            (theWitRun,           WitTRUE);
   witSetPartObjectStage      (theWitRun, "A",      0);
   witSetPartObjectStage      (theWitRun, "B",      1);
   witSetOperationObjectStage (theWitRun, "C",      0);
   witSetPartAppData          (theWitRun, "A",      theWitRun);

   witSetCurrentScenario      (theWitRun,           0);
   witSetProbability          (theWitRun,           0.6);
   witSetDemandDemandVol      (theWitRun, "B", "D", demandVolD0);
   witSetDemandCumShipBounds  (theWitRun, "B", "D", NULL,
                                                    demandVolD0,
                                                    NULL);

   witSetCurrentScenario      (theWitRun,           1);
   witSetProbabilityDbl       (theWitRun,           0.3);
   witSetDemandDemandVol      (theWitRun, "B", "D", demandVolD1);
   witSetDemandCumShipBounds  (theWitRun, "B", "D", NULL,
                                                    demandVolD1,
                                                    NULL);

   witSetCurrentScenario      (theWitRun,           2);
   witSetProbability          (theWitRun,           0.1);

   witSetCurrentScenario      (theWitRun,           1);
   }

/*----------------------------------------------------------------------------*/
/* checkStochData                                                             */
/*                                                                            */
/* Verifies the stochastic data for the stochastic implosion test.            */
/*----------------------------------------------------------------------------*/

void checkStochData (WitRun * theWitRun)
   {
   witBoolean theBool;
   int        theInt;
   float      theFlt;
   double     theDbl;

   witGetStageByObject        (theWitRun,      & theBool);
   assert                                       (theBool);

   witGetNScenarios           (theWitRun,      & theInt);
   assert                                       (theInt == 3);

   witGetStochMode            (theWitRun,      & theBool);
   assert                                       (theBool);

   witGetCurrentScenario      (theWitRun,      & theInt);
   assert                                       (theInt == 1);

   witGetOperationObjectStage (theWitRun, "C", & theInt);
   assert                                       (theInt == 0);

   witGetPartObjectStage      (theWitRun, "B", & theInt);
   assert                                       (theInt == 1);

   /* Check data for scenario #0. */

   witSetCurrentScenario (theWitRun,   0);
   witGetProbabilityDbl  (theWitRun, & theDbl);

   assert (fabs (theDbl - 0.6) < dblEps);

   /* Check data for scenario #1. */

   witSetCurrentScenario (theWitRun,   1);
   witGetProbability     (theWitRun, & theFlt);

   assert (fabs (theFlt - 0.3) < dblEps);

   /* Check data for scenario #2. */

   witSetCurrentScenario (theWitRun,   2);
   witGetProbabilityDbl  (theWitRun, & theDbl);

   assert (fabs (theDbl - 0.1) < dblEps);

   witSetCurrentScenario (theWitRun,   1);
   }

/*----------------------------------------------------------------------------*/
/* testStochWriteData                                                         */
/*                                                                            */
/* Tests witWriteData in stochastic implosion mode.                           */
/*----------------------------------------------------------------------------*/

void testStochWriteData (WitRun * theWitRun)
   {
   WitRun * theWitRun2;

   witDisplayData           (theWitRun, "disp1.out");
   witWriteData             (theWitRun, "stoch.data");

   witNewRun              (& theWitRun2);
   witSetMesgPrintNumber    (theWitRun2, WitTRUE,
                                         WitINFORMATIONAL_MESSAGES,
                                         WitFALSE);   
   witInitialize            (theWitRun2);
   witReadData              (theWitRun2, "stoch.data");
   witDisplayData           (theWitRun2, "disp2.out");
   witDeleteRun             (theWitRun2);

   remove ("stoch.data");

   printf ("\n"
           "-----------\n"
           "Diff Output\n"
           "-----------\n"
           "\n");

   fflush  (stdout);

   system ("diff disp1.out disp2.out");

   printf ("\n"
           "------------------\n"
           "End of Diff Output\n"
           "------------------\n"
           "\n");

   fflush  (stdout);

   remove ("disp1.out");
   remove ("disp2.out");
   }

/*----------------------------------------------------------------------------*/
/* testStochCopyData                                                          */
/*                                                                            */
/* Tests witCopyData in stochastic implosion mode.                            */
/*----------------------------------------------------------------------------*/

void testStochCopyData (WitRun * theWitRun)
   {
   WitRun * theWitRun2;

   witDisplayData           (theWitRun, "disp1.out");

   witNewRun              (& theWitRun2);
   witSetMesgPrintNumber    (theWitRun2, WitTRUE,
                                         WitINFORMATIONAL_MESSAGES,
                                         WitFALSE);   
   witInitialize            (theWitRun2);
   witCopyData              (theWitRun2, theWitRun);
   witPreprocess            (theWitRun2);
   witDisplayData           (theWitRun2, "disp2.out");
   witDeleteRun             (theWitRun2);

   remove ("stoch.data");

   printf ("\n"
           "-----------\n"
           "Diff Output\n"
           "-----------\n"
           "\n");

   fflush  (stdout);

   system ("diff disp1.out disp2.out");

   printf ("\n"
           "------------------\n"
           "End of Diff Output\n"
           "------------------\n"
           "\n");

   fflush  (stdout);

   remove ("disp1.out");
   remove ("disp2.out");
   }

/*----------------------------------------------------------------------------*/
/* testStochImplode                                                           */
/*                                                                            */
/* Tests witStochImplode.                                                     */
/*----------------------------------------------------------------------------*/

void testStochImplode (WitRun * theWitRun)
   {
   witBoolean theBool;

   witGetStochSolnMode          (theWitRun,    & theBool);
   assert                                     (! theBool);

   witStochImplode              (theWitRun);

   witGetStochSolnMode          (theWitRun,    & theBool);
   assert                                       (theBool);
   }

/*----------------------------------------------------------------------------*/
/* checkStochSoln                                                             */
/*                                                                            */
/* Verifies the stochastic implosion solution for the stochastic implosion    */
/* test.                                                                      */
/*----------------------------------------------------------------------------*/

void checkStochSoln (WitRun * theWitRun)
   {
   float   objValue;
   float   boundsValue;
   float * theFltVec;
   float   execVolC[]      = {200.};
   float   residualVolB0[] = {100.};
   float   zeroVec[]       = {  0.};

   /*-------------------------------------------------------------------------*/

   witGetObjValues        (theWitRun, & objValue, & boundsValue );

   printf (
      "\n"
      "Stochastic objective function values:\n"
      "   objValue    = %3.0f\n"
      "   boundsValue = %3.0f\n",
      objValue,
      boundsValue);

   assert (fabs (objValue    - 500.0) < dblEps);
   assert (fabs (boundsValue -  10.0) < dblEps);

   /*-------------------------------------------------------------------------*/

   witSetCurrentScenario  (theWitRun, 0);

   witGetOperationExecVol (theWitRun, "C", & theFltVec);
   compareFltVecs                           (theFltVec, execVolC,      1);
   witFree                                  (theFltVec);

   witGetPartResidualVol  (theWitRun, "B", & theFltVec);
   compareFltVecs                           (theFltVec, residualVolB0, 1);
   witFree                                  (theFltVec);

   /*-------------------------------------------------------------------------*/

   witSetCurrentScenario  (theWitRun, 2);

   witGetOperationExecVol (theWitRun, "C", & theFltVec);
   compareFltVecs                           (theFltVec, execVolC,      1);
   witFree                                  (theFltVec);

   witGetPartResidualVol  (theWitRun, "B", & theFltVec);
   compareFltVecs                           (theFltVec, zeroVec,       1);
   witFree                                  (theFltVec);
   }

/*----------------------------------------------------------------------------*/
/* testClearStochSoln                                                         */
/*                                                                            */
/* Tests witClearStochSoln.                                                   */
/*----------------------------------------------------------------------------*/

void testClearStochSoln (WitRun * theWitRun)
   {
   float * theFltVec;
   float   zeroVec[]    = {  0.};
   float   supplyVolB[] = {107.};

   /*-------------------------------------------------------------------------*/

   witClearStochSoln   (theWitRun);

   witGetPartExcessVol (theWitRun, "A", & theFltVec);
   compareFltVecs                        (theFltVec, zeroVec, 1);
   witFree                               (theFltVec);

   witSetPartSupplyVol (theWitRun, "B",   supplyVolB);
   }

/*----------------------------------------------------------------------------*/
/* testStageByPeriod                                                          */
/*                                                                            */
/* Test of stochastic implosion in stage-by-period mode.                      */
/*----------------------------------------------------------------------------*/

void testStageByPeriod ()
   {
   WitRun * theWitRun;

   if (! cplexEmbedded)
      return;

   witNewRun         (& theWitRun);
   buildCoreProblemSBP (theWitRun);
   specifyStochDataSBP (theWitRun);
   witDisplayData      (theWitRun, WitSTDOUT);
   witStochImplode     (theWitRun);
   witDeleteRun        (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* buildCoreProblemSBP                                                        */
/*                                                                            */
/* Builds the core problem for the stochastic implosion stage-by-period test. */
/*----------------------------------------------------------------------------*/

void buildCoreProblemSBP (WitRun * theWitRun)
   {
   float execCostB  [] = { 4.0,  4.0};
   float execCostC  [] = { 7.0,  7.0};
   float shipRewardD[] = {10.0, 10.0};
   float offsetB    [] = {-1,   -1};
   float offsetC    [] = { 0,    0};

   witInitialize           (theWitRun);

   witSetNPeriods          (theWitRun, 2);
   witSetOptInitMethod     (theWitRun, WitCRASH_OPT_INIT_METHOD);

   witAddPart              (theWitRun, "A", WitCAPACITY);
   witAddOperation         (theWitRun, "B");
   witAddOperation         (theWitRun, "C");
   witAddBopEntry          (theWitRun, "B", "A");
   witAddBopEntry          (theWitRun, "C", "A");
   witAddDemand            (theWitRun, "A", "D");

   witSetOperationExecCost (theWitRun, "B",      execCostB);
   witSetOperationExecCost (theWitRun, "C",      execCostC);
   witSetDemandShipReward  (theWitRun, "A", "D", shipRewardD);

   witSetBopEntryOffset    (theWitRun, "B",  0,  offsetB);
   witSetBopEntryOffset    (theWitRun, "C",  0,  offsetC);
   }

/*----------------------------------------------------------------------------*/
/* specifyStochDataSBP                                                        */
/*                                                                            */
/* Specifies the stochastic data for the stochastic implosion stage-by-period */
/* test.                                                                      */
/*----------------------------------------------------------------------------*/

void specifyStochDataSBP (WitRun * theWitRun)
   {
   int   periodStage[] = {0,    1};
   float demandVolD0[] = {0.0, 20.0};
   float demandVolD1[] = {0.0, 30.0};

   witSetStageByObject   (theWitRun, WitFALSE);
   witSetNScenarios      (theWitRun, 2);
   witSetStochMode       (theWitRun, WitTRUE);
   witSetPeriodStage     (theWitRun, periodStage);

   witSetCurrentScenario (theWitRun,           0);
   witSetDemandDemandVol (theWitRun, "A", "D", demandVolD0);

   witSetCurrentScenario (theWitRun,           1);
   witSetDemandDemandVol (theWitRun, "A", "D", demandVolD1);
   }

/*----------------------------------------------------------------------------*/
/* Function testMultiObjMode                                                  */
/*                                                                            */
/* Tests multiple objectives mode.                                            */
/*----------------------------------------------------------------------------*/

void testMultiObjMode ()
   {
   WitRun *   theWitRun;
   WitRun *   cpyWitRun;
   witBoolean theBool;

   if (! cplexEmbedded)
      return;

   witNewRun        (& theWitRun);

   witInitialize      (theWitRun);

   witSetNPeriods     (theWitRun,   2);

   witSetMultiObjMode (theWitRun,   WitTRUE);
   witGetMultiObjMode (theWitRun, & theBool);
   assert                          (theBool);

   testObjListSpec    (theWitRun);
   testObjList        (theWitRun);
   testObjSeq         (theWitRun);
   testMultiObjTol    (theWitRun);
   populateMultiObj   (theWitRun);
   testSetObjVecs     (theWitRun);

   witNewRun        (& cpyWitRun);

   witCopyData        (cpyWitRun, theWitRun);

   witDeleteRun       (theWitRun);

   testGetObjVecs     (cpyWitRun);

   witOptImplode      (cpyWitRun);

   testMultiObjValue  (cpyWitRun);

   witDeleteRun       (cpyWitRun);
   }

/*----------------------------------------------------------------------------*/
/* Function testObjListSpec                                                   */
/*                                                                            */
/* Tests witSetObjectiveListSpec and related functions.                       */
/*----------------------------------------------------------------------------*/

void testObjListSpec (WitRun * theWitRun)
   {
   char *   theSpec;
   int      lenList;
   char * * theList;

   witSetObjectiveListSpec (theWitRun, "temp1|temp2|temp3");

   witGetObjectiveListSpec (theWitRun, & theSpec);

   assert (equalStrings (theSpec, "temp1|temp2|temp3"));

   witFree (theSpec);

   witGetObjectiveList     (theWitRun, & lenList, & theList);

   assert (lenList == 3);

   assert (equalStrings (theList[0], "temp1"));
   assert (equalStrings (theList[1], "temp2"));
   assert (equalStrings (theList[2], "temp3"));

   witFree (theList[0]);
   witFree (theList[1]);
   witFree (theList[2]);
   witFree (theList);
   }

/*----------------------------------------------------------------------------*/
/* Function testObjList                                                       */
/*                                                                            */
/* Tests witSetObjectiveList and related functions.                           */
/*----------------------------------------------------------------------------*/

void testObjList (WitRun * theWitRun)
   {
   const char * theObjList[] = {"LOW", "HIGH"};
   char * *     outObjList;
   int          lenList;
   char *       theSpec;

   witSetObjectiveList (theWitRun,   2,         theObjList);
   witGetObjectiveList (theWitRun, & lenList, & outObjList);

   assert (lenList == 2);

   assert (equalStrings (outObjList[0], "LOW"));
   assert (equalStrings (outObjList[1], "HIGH"));

   witFree (outObjList[0]);
   witFree (outObjList[1]);
   witFree (outObjList);

   witGetObjectiveListSpec (theWitRun, & theSpec);

   assert (equalStrings (theSpec, "LOW|HIGH"));

   witFree (theSpec);
   }

/*----------------------------------------------------------------------------*/
/* testObjSeq                                                                 */
/*                                                                            */
/* Tests functions for objectiveSeq and currentObjective.                     */
/*----------------------------------------------------------------------------*/

void testObjSeq (WitRun * theWitRun)
   {
   char * theObjName;
   int    theSeqNo;

   witSetCurrentObjective (theWitRun, "LOW");
   witSetObjectiveRank    (theWitRun, 2);

   witSetCurrentObjective (theWitRun, "HIGH");
   witSetObjectiveRank    (theWitRun, 1);

   witGetCurrentObjective (theWitRun, & theObjName);
   witGetObjectiveRank    (theWitRun, & theSeqNo);

   assert (equalStrings (theObjName, "HIGH"));

   assert (theSeqNo == 1);

   witFree (theObjName);
   }

/*----------------------------------------------------------------------------*/
/* testMultiObjTol                                                            */
/*                                                                            */
/* Tests the multiObjTol attribute.                                           */
/*----------------------------------------------------------------------------*/

void testMultiObjTol (WitRun * theWitRun)
   {
   float  theFlt;
   double theDbl;

   witSetMultiObjTol    (theWitRun,   1.e-6);
   witSetMultiObjTolDbl (theWitRun,   1.e-5);
   witGetMultiObjTol    (theWitRun, & theFlt);
   witGetMultiObjTolDbl (theWitRun, & theDbl);

   assert (fabs (theFlt - 1.e-5) < 1.e-10);
   assert (fabs (theDbl - 1.e-5) < 1.e-10);
   }

/*----------------------------------------------------------------------------*/
/* populateMultiObj                                                           */
/*                                                                            */
/* Creates all data objects for the WitRun for the multiple objectives mode   */
/* test.                                                                      */
/*----------------------------------------------------------------------------*/

void populateMultiObj (WitRun * theWitRun)
   {
   witAddPart            (theWitRun, "A", WitCAPACITY);
   witAddPart            (theWitRun, "B", WitMATERIAL);
   witAddOperation       (theWitRun, "C");
   witAddBomEntry        (theWitRun, "C", "A");
   witAddSubsBomEntry    (theWitRun, "C",  0,  "A");
   witAddBopEntry        (theWitRun, "C", "B");
   witAddDemand          (theWitRun, "B", "D");

   witSetPartSupplyVol   (theWitRun, "A",      fltVecOf2 (2, 0));
   witSetDemandDemandVol (theWitRun, "B", "D", fltVecOf2 (0, 1));
   }

/*----------------------------------------------------------------------------*/
/* Function testSetObjVecs                                                    */
/*                                                                            */
/* Tests functions for setting objective function vectors in multiple         */
/* objectives mode.                                                           */
/*----------------------------------------------------------------------------*/

void testSetObjVecs (WitRun * theWitRun)
   {
   witSetCurrentObjective    (theWitRun, "LOW");

   witSetPartScrapCost       (theWitRun, "A",       fltVecOf2 ( 1,  2));
   witSetPartStockCost       (theWitRun, "B",       fltVecOf2 ( 5,  6));
   witSetOperationExecCost   (theWitRun, "C",       fltVecOf2 ( 9, 10));
   witSetSubsBomEntrySubCost (theWitRun, "C", 0, 0, fltVecOf2 (13, 14));
   witSetDemandShipReward    (theWitRun, "B", "D",  fltVecOf2 (17, 18));
   witSetDemandCumShipReward (theWitRun, "B", "D",  fltVecOf2 (21, 22));

   witSetCurrentObjective    (theWitRun, "HIGH");

   witSetPartScrapCost       (theWitRun, "A",       fltVecOf2 ( 3,  4));
   witSetPartStockCost       (theWitRun, "B",       fltVecOf2 ( 7,  8));
   witSetOperationExecCost   (theWitRun, "C",       fltVecOf2 (11, 12));
   witSetSubsBomEntrySubCost (theWitRun, "C", 0, 0, fltVecOf2 (15, 16));
   witSetDemandShipReward    (theWitRun, "B", "D",  fltVecOf2 (19, 20));
   witSetDemandCumShipReward (theWitRun, "B", "D",  fltVecOf2 (23, 24));
   }

/*----------------------------------------------------------------------------*/
/* Function testGetObjVecs                                                    */
/*                                                                            */
/* Tests functions for retrieving objective function vectors in               */
/* multiple objectives mode.                                                  */
/*----------------------------------------------------------------------------*/

void testGetObjVecs (WitRun * theWitRun)
   {
   float   goodVec[2];
   float * outVec;

   witSetCurrentObjective    (theWitRun, "LOW");

   witGetPartScrapCost       (theWitRun, "A",       & outVec);
   compareFltVecsOf2                                 (outVec,  1,  2);
   witFree                                           (outVec);

   witGetPartStockCost       (theWitRun, "B",       & outVec);
   compareFltVecsOf2                                 (outVec,  5,  6);
   witFree                                           (outVec);

   witGetOperationExecCost   (theWitRun, "C",       & outVec);
   compareFltVecsOf2                                 (outVec,  9, 10);
   witFree                                           (outVec);

   witGetSubsBomEntrySubCost (theWitRun, "C", 0, 0, & outVec);
   compareFltVecsOf2                                 (outVec, 13, 14);
   witFree                                           (outVec);

   witGetDemandShipReward    (theWitRun, "B", "D",  & outVec);
   compareFltVecsOf2                                 (outVec, 17, 18);
   witFree                                           (outVec);

   witGetDemandCumShipReward (theWitRun, "B", "D",  & outVec);
   compareFltVecsOf2                                 (outVec, 21, 22);
   witFree                                           (outVec);


   witSetCurrentObjective    (theWitRun, "HIGH");

   witGetPartScrapCost       (theWitRun, "A",       & outVec);
   compareFltVecsOf2                                 (outVec,  3,  4);
   witFree                                           (outVec);

   witGetPartStockCost       (theWitRun, "B",       & outVec);
   compareFltVecsOf2                                 (outVec,  7,  8);
   witFree                                           (outVec);

   witGetOperationExecCost   (theWitRun, "C",       & outVec);
   compareFltVecsOf2                                 (outVec, 11, 12);
   witFree                                           (outVec);

   witGetSubsBomEntrySubCost (theWitRun, "C", 0, 0, & outVec);
   compareFltVecsOf2                                 (outVec, 15, 16);
   witFree                                           (outVec);

   witGetDemandShipReward    (theWitRun, "B", "D",  & outVec);
   compareFltVecsOf2                                 (outVec, 19, 20);
   witFree                                           (outVec);

   witGetDemandCumShipReward (theWitRun, "B", "D",  & outVec);
   compareFltVecsOf2                                 (outVec, 23, 24);
   witFree                                           (outVec);
   }

/*----------------------------------------------------------------------------*/
/* testMultiObjValue                                                          */
/*                                                                            */
/* Tests witGetObjValue in multiple objectives mode.                          */
/*----------------------------------------------------------------------------*/

void testMultiObjValue (WitRun * theWitRun)
   {
   float theFloat;

   witSetCurrentObjective (theWitRun, "LOW");

   witGetObjValue         (theWitRun, & theFloat);
   
   assert (fabs (theFloat - 25.0) < dblEps);


   witSetCurrentObjective (theWitRun, "HIGH");

   witGetObjValue         (theWitRun, & theFloat);
   
   assert (fabs (theFloat - 23.0) < dblEps);
   }

/*----------------------------------------------------------------------------*/
/* testLeadTimeBounds ()                                                      */
/*                                                                            */
/* Tests lead time bounds and selection recovery.                             */
/*----------------------------------------------------------------------------*/

void testLeadTimeBounds ()
   {
   WitRun *   theWitRun;
   witBoolean theBool;
   float      supplyVol[] = {100,  0,  0};
   float      demandVol[] = {  0,  0, 10};
   int        the1Vec  [] = {  1,  1,  1};
   int        the2Vec  [] = {  2,  2,  2};
   int *      theIntVec;

   witNewRun                (& theWitRun);

   witInitialize              (theWitRun);

   witSetNPeriods             (theWitRun,               3);
   witSetSelectionRecovery    (theWitRun,               WitTRUE);
   witGetSelectionRecovery    (theWitRun,             & theBool);
   assert                                              (theBool);
   witSetSkipFailures         (theWitRun,               WitFALSE);

   witAddPart                 (theWitRun,   "A",        WitCAPACITY);
   witAddPart                 (theWitRun,   "B",        WitMATERIAL);
   witAddOperation            (theWitRun,   "C");
   witAddBomEntry             (theWitRun,   "C", "A");
   witAddBopEntry             (theWitRun,   "C", "B");
   witAddDemand               (theWitRun,   "B", "D");
   witAddDemand               (theWitRun,   "B", "E");

   witSetPartSupplyVol        (theWitRun,   "A",        supplyVol);
   witSetPartBuildNstn        (theWitRun,   "B",        WitTRUE);
   witSetPartBoundedLeadTimes (theWitRun,   "B",        WitTRUE);
   witGetPartBoundedLeadTimes (theWitRun,   "B",      & theBool);
   assert                                              (theBool);

   witSetDemandDemandVol      (theWitRun,   "B", "D",   demandVol);
   witSetDemandDemandVol      (theWitRun,   "B", "E",   demandVol);

   witSetDemandLeadTimeUB     (theWitRun,   "B", "D",   the2Vec);
   witSetDemandLeadTimeUB     (theWitRun,   "B", "E",   the1Vec);
   witGetDemandLeadTimeUB     (theWitRun,   "B", "E", & theIntVec);
   assert                                              (theIntVec[2] == 1);

   witSetDemandPriority       (theWitRun,   "B", "D",   the1Vec);
   witSetDemandPriority       (theWitRun,   "B", "E",   the2Vec);

   witHeurImplode             (theWitRun);

   witWriteShipSched          (theWitRun,               WitSTDOUT, WitBSV);

   witDeleteRun               (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* testAccOptWithCplex ()                                                     */
/*                                                                            */
/* Tests accelerated optimizing implosion with CPLEX, if appropriate.         */
/*----------------------------------------------------------------------------*/

void testAccOptWithCplex ()
   {
   WitRun * theWitRun;
   witAttr  optInitMethod;

   if (! developmentMode)
      return;

   if (! cplexEmbedded)
      return;

   witNewRun               (& theWitRun);
   witInitialize             (theWitRun);
   witSetAccAfterOptImp      (theWitRun, WitTRUE);
   witSetNPeriods            (theWitRun, 1);

   witAddPart                (theWitRun, "A",      WitMATERIAL);
   witAddPart                (theWitRun, "B",      WitMATERIAL);
   witAddPart                (theWitRun, "C",      WitMATERIAL);

   witAddOperation           (theWitRun, "D");
   witAddOperation           (theWitRun, "E");
   witAddOperation           (theWitRun, "F");

   witAddBomEntry            (theWitRun, "D", "A");
   witAddBomEntry            (theWitRun, "E", "A");

   witAddBopEntry            (theWitRun, "D", "B");
   witAddBopEntry            (theWitRun, "E", "C");
   witAddBopEntry            (theWitRun, "F", "C");

   witAddDemand              (theWitRun, "B", "G");
   witAddDemand              (theWitRun, "C", "H");

   witSetPartSupplyVol       (theWitRun, "A",      fltVecOf1 (170));

   witSetDemandDemandVol     (theWitRun, "B", "G", fltVecOf1 (100));
   witSetDemandDemandVol     (theWitRun, "C", "H", fltVecOf1 (100));

   witSetOperationExecBounds (theWitRun, "F",      NULL,
                                                   NULL,
                                                   fltVecOf1  (10));

   witSetDemandShipReward    (theWitRun, "B", "G", fltVecOf1   (3));
   witSetDemandShipReward    (theWitRun, "C", "H", fltVecOf1   (2));

   witOptImplode             (theWitRun);

   witWriteShipSched         (theWitRun, WitSTDOUT, WitCSV);

   witSetDemandShipReward    (theWitRun, "B", "G", fltVecOf1   (1));

   witSetPartSupplyVol       (theWitRun, "A",      fltVecOf1 (140));

   witSetOperationExecBounds (theWitRun, "F",      NULL,
                                                   NULL,
                                                   fltVecOf1  (20));

   witOptImplode             (theWitRun);

   witWriteShipSched         (theWitRun, WitSTDOUT, WitCSV);

   witAddOperation           (theWitRun, "Z");

   witGetOptInitMethod       (theWitRun, & optInitMethod);

   assert (optInitMethod == WitCRASH_OPT_INIT_METHOD);

   witDeleteRun              (theWitRun);
   }

/*----------------------------------------------------------------------------*/
/* compareFltVecsOf2                                                          */
/*                                                                            */
/* Asserts that theFltVec2 == (theFlt0, theFlt1)                              */
/*----------------------------------------------------------------------------*/

void compareFltVecsOf2 (float * theFltVec, float theFlt0, float theFlt1)
   {
   compareFltVecs (
      theFltVec,
      fltVecOf2 (theFlt0, theFlt1),
      2);
   }

/*----------------------------------------------------------------------------*/
/* Function fltVecOf1 (theFlt)                                                */
/*                                                                            */
/* Populates a statically declared vector of length 1 with the argument and   */
/* returns it.                                                                */
/*----------------------------------------------------------------------------*/

const float * fltVecOf1 (float theFlt)
   {
   static float theFltVec[1];

   theFltVec[0] = theFlt;

   return theFltVec;
   }

/*----------------------------------------------------------------------------*/
/* Function fltVecOf2 (theFlt0, theFlt1)                                      */
/*                                                                            */
/* Populates a statically declared vector of length 2 with the arguments and  */
/* returns it.                                                                */
/*----------------------------------------------------------------------------*/

const float * fltVecOf2 (float theFlt0, float theFlt1)
   {
   static float theFltVec[2];

   theFltVec[0] = theFlt0;
   theFltVec[1] = theFlt1;

   return theFltVec;
   }

/*----------------------------------------------------------------------------*/
/* Function equalStrings.                                                     */
/*                                                                            */
/* Returns true iff str1 == str2 as strings.                                  */
/*----------------------------------------------------------------------------*/

witBoolean equalStrings (const char * str1, const char * str2)
   {
   return (strcmp (str1, str2) == 0);
   }

/*----------------------------------------------------------------------------*/
/* Function compareIntVecs.                                                   */
/*                                                                            */
/* Asserts that theIntVec1 == theIntVec2.                                     */
/*----------------------------------------------------------------------------*/

void compareIntVecs (const int * theIntVec1, const int * theIntVec2, int length)
   {
   int theIdx;

   for (theIdx = 0; theIdx < length; theIdx ++) 
      assert (theIntVec1[theIdx] == theIntVec2[theIdx]);
   }

/*----------------------------------------------------------------------------*/
/* Function compareFltVecs.                                                   */
/*                                                                            */
/* Asserts that theFltVec1 == theFltVec2.                                     */
/*----------------------------------------------------------------------------*/

void compareFltVecs (
      const float * theFltVec1,
      const float * theFltVec2,
      int           length)
   {
   int theIdx;

   for (theIdx = 0; theIdx < length; theIdx ++) 
      assert (fabs (theFltVec1[theIdx] - theFltVec2[theIdx]) < dblEps);
   }

/*----------------------------------------------------------------------------*/
/* Function compareDblVecs.                                                   */
/*                                                                            */
/* Asserts that theDblVec1 == theDblVec2.                                     */
/*----------------------------------------------------------------------------*/

void compareDblVecs (
      const double * theDblVec1,
      const double * theDblVec2,
      int            length)
   {
   int theIdx;

   for (theIdx = 0; theIdx < nPeriods; theIdx ++) 
      assert (fabs (theDblVec1[theIdx] - theDblVec2[theIdx]) < dblEps);
   }

/*----------------------------------------------------------------------------*/
/* Function printFltVec.                                                      */
/*----------------------------------------------------------------------------*/

void printFltVec (const char * attrName, const float * theFltVec, int length)
   {
   int theIdx;

   printf ("%s = ", attrName);

   for (theIdx = 0; theIdx < length; theIdx ++)
      printf (" %f", theFltVec[theIdx]);

   printf ("\n");
   }

/*----------------------------------------------------------------------------*/
/* Function printDblVec.                                                      */
/*----------------------------------------------------------------------------*/

void printDblVec (const char * attrName, const double * theDblVec, int length)
   {
   int theIdx;

   printf ("%s (double) = ", attrName);

   for (theIdx = 0; theIdx < length; theIdx ++)
      printf (" %f", theDblVec[theIdx]);

   printf ("\n");
   }
@


1.315
log
@Removed setting of optInitMethod in stochastic implosion.
@
text
@a183 1
witBoolean   coinEmbedded    = WitFALSE;
a184 1
witBoolean   solverEmbedded  = WitFALSE;
a241 11
   witGetCoinEmbedded (theWitRun, & coinEmbedded);

   if (coinEmbedded)
      printf (
         "\n"
         "This is a COIN-embedded build of WIT.\n");
   else
      printf (
         "\n"
         "This is not a COIN-embedded build of WIT.\n");

a252 35
   solverEmbedded = coinEmbedded || cplexEmbedded;

   if     (coinEmbedded)
      if (cplexEmbedded)
         {
         witBoolean  coinSelected;
         witBoolean cplexSelected;

         witSetCplexSelected (theWitRun,   WitTRUE);

         witGetCoinSelected  (theWitRun, & coinSelected);
         assert                         (! coinSelected);
         witGetCplexSelected (theWitRun, & cplexSelected);
         assert                           (cplexSelected);

         witSetCoinSelected  (theWitRun,   WitTRUE);

         witGetCoinSelected  (theWitRun, & coinSelected);
         assert                           (coinSelected);
         witGetCplexSelected (theWitRun, & cplexSelected);
         assert                         (! cplexSelected);
         }

   if      (coinEmbedded)
      witSetCoinSelected  (theWitRun, WitTRUE);

   else if (cplexEmbedded)
      witSetCplexSelected (theWitRun, WitTRUE);

   else
      {
      witSetCoinSelected  (theWitRun, WitFALSE);
      witSetCplexSelected (theWitRun, WitFALSE);
      }

d1670 1
a1670 1
   if (solverEmbedded)
d1692 1
a1692 1
   if (solverEmbedded )
d1730 1
a1730 1
   if (solverEmbedded)
d1740 1
a1740 1
   if (solverEmbedded)
d2412 1
a2412 1
   if (solverEmbedded)
a2435 2
      witSetCplexSelected   (theObj1Run, WitTRUE);

d2508 1
a2508 1
   if (solverEmbedded)
d3980 1
a3980 1
   if (solverEmbedded)
a3981 3
      if (cplexEmbedded)
         witSetCplexSelected (theWitRun, WitTRUE);

d6233 1
a6233 1
   if (! solverEmbedded)
d6584 1
a6584 1
   if (! solverEmbedded)
d6666 1
a6666 1
   if (! solverEmbedded)
a7029 1
   witSetCplexSelected       (theWitRun, WitTRUE);
@


1.314
log
@Added severe error for selecting a solver that's not embedded.
@
text
@d6325 1
d6665 1
@


1.313
log
@Revised the default values of coinSelected and cplexSelected.
@
text
@d268 5
a272 3
   {
   witBoolean  coinSelected;
   witBoolean cplexSelected;
d274 1
a274 1
   witSetCplexSelected (theWitRun,   WitTRUE);
d276 12
a287 12
   witGetCoinSelected  (theWitRun, & coinSelected);
   assert                         (! coinSelected);
   witGetCplexSelected (theWitRun, & cplexSelected);
   assert                           (cplexSelected);

   witSetCoinSelected  (theWitRun,   WitTRUE);

   witGetCoinSelected  (theWitRun, & coinSelected);
   assert                           (coinSelected);
   witGetCplexSelected (theWitRun, & cplexSelected);
   assert                         (! cplexSelected);
   }
a4037 2

      witSetCoinSelected     (theWitRun, WitTRUE);
@


1.312
log
@Fixed a bug in optInitMethod.
@
text
@a271 5
   witGetCoinSelected  (theWitRun, & coinSelected);
   assert                           (coinSelected);
   witGetCplexSelected (theWitRun, & cplexSelected);
   assert                         (! cplexSelected);

d287 12
a1634 7
   {
   witAttr optInitMethod;
   witGetOptInitMethod( theWitRun, & optInitMethod );
   assert( optInitMethod == WitHEUR_OPT_INIT_METHOD );
   }


a2481 13
      witGetCplexStatusCode (theObj1Run, & cplexStatusCode);

      assert (cplexStatusCode == -1);

      witGetCplexStatusText (theObj1Run, & cplexStatusText);

      assert (
         equalStrings (
            cplexStatusText,
            "The CPLEX solution status is not yet defined."));

      witFree (cplexStatusText);

@


1.311
log
@CPLEX
@
text
@d326 1
a326 1
   witGetMesgStopRunning( theWitRun, 283, &bool );
@


1.310
log
@CPLEX
@
text
@d2477 4
a2480 4
      float  cplexObjBound;
      double cplexObjBoundDbl;
      float  cplexObjRelGap;
      double cplexObjRelGapDbl;
d2509 2
a2510 2
      witGetCplexObjBound    (theObj1Run, & cplexObjBound);
      witGetCplexObjBoundDbl (theObj1Run, & cplexObjBoundDbl);
d2512 2
a2513 2
      assert (fabs (cplexObjBound    - 369150) < .001);
      assert (fabs (cplexObjBoundDbl - 369150) < .001);
d2515 2
a2516 2
      witGetCplexObjRelGap    (theObj1Run, & cplexObjRelGap);
      witGetCplexObjRelGapDbl (theObj1Run, & cplexObjRelGapDbl);
d2518 2
a2519 2
      assert (fabs (cplexObjRelGap)    < 1.0e-6);
      assert (fabs (cplexObjRelGapDbl) < 1.0e-6);
d7084 1
d7144 6
@


1.309
log
@CPLEX
@
text
@d2479 2
d2515 6
@


1.308
log
@CPLEX
@
text
@d2261 1
d2283 5
d2510 2
a2511 2
      assert (cplexObjBound    == 0.0);
      assert (cplexObjBoundDbl == 0.0);
@


1.307
log
@CPLEX
@
text
@d2471 2
d2501 6
@


1.306
log
@CPLEX Parameters
@
text
@d2469 2
a2470 1
      int cplexSolnStatus;
d2472 1
a2472 1
      witGetCplexSolnStatus (theObj1Run, & cplexSolnStatus);
d2474 10
a2483 1
      assert (cplexSolnStatus == -1);
d2489 7
a2495 1
      witGetCplexSolnStatus (theObj1Run, & cplexSolnStatus);
d2497 1
a2497 1
      assert (cplexSolnStatus == 101);
@


1.305
log
@CPLEX Parameters
@
text
@d45 5
a49 5
void testCpxParSpecs      (WitRun *);
void testClearCpxParSpecs (WitRun *);
void testCpxParSpecAtts   (WitRun *);
void testGetIntCpxParSpec (WitRun *);
void testGetDblCpxParSpec (WitRun *);
d292 1
a292 1
   testCpxParSpecs (theWitRun);
d2469 1
a2469 1
      int cpxSolnStatus;
d2471 1
a2471 1
      witGetCpxSolnStatus (theObj1Run, & cpxSolnStatus);
d2473 1
a2473 1
      assert (cpxSolnStatus == -1);
d2475 1
a2475 1
      witSetCplexSelected (theObj1Run, WitTRUE);
d2477 1
a2477 1
      witOptImplode       (theObj1Run);
d2479 1
a2479 1
      witGetCpxSolnStatus (theObj1Run, & cpxSolnStatus);
d2481 1
a2481 1
      assert (cpxSolnStatus == 101);
d2585 1
a2585 1
/* testCpxParSpecs (theWitRun)                                                */
d2590 1
a2590 1
void testCpxParSpecs (WitRun * theWitRun)
d2592 1
a2592 1
   testClearCpxParSpecs   (theWitRun);
d2594 1
a2594 1
   testCpxParSpecAtts     (theWitRun);
d2596 3
a2598 3
   witAddIntCpxParSpec    (theWitRun, "ITLIM", 100000);
   witAddDblCpxParSpec    (theWitRun, "EPRHS", 1.e-5);
   witAddDblCpxParSpecDbl (theWitRun, "EPOPT", 1.e-7);
d2600 2
a2601 2
   testGetIntCpxParSpec   (theWitRun);
   testGetDblCpxParSpec   (theWitRun);
d2605 1
a2605 1
/* testClearCpxParSpecs (theWitRun)                                           */
d2607 1
a2607 1
/* Tests witClearCpxParSpecs.                                                 */
d2610 1
a2610 1
void testClearCpxParSpecs (WitRun * theWitRun)
d2615 1
a2615 1
   witAddIntCpxParSpec    (theWitRun, "SIMDISPLAY",   2);
d2617 2
a2618 2
   witGetIntCpxParSpec    (theWitRun, "SIMDISPLAY", & intSpecExists,
                                                    & theInt);
d2623 1
a2623 1
   witClearCpxParSpecs    (theWitRun);
d2625 2
a2626 2
   witGetIntCpxParSpec    (theWitRun, "SIMDISPLAY", & intSpecExists,
                                                    & theInt);
d2632 1
a2632 1
/* testCpxParSpecAtts (theWitRun)                                             */
d2637 1
a2637 1
void testCpxParSpecAtts (WitRun * theWitRun)
d2644 2
a2645 2
   witSetCpxParSpecName      (theWitRun, "LPMETHOD");
   witSetCpxParSpecIntVal    (theWitRun, 4);
d2647 8
a2654 8
   witSetCpxParSpecName      (theWitRun, "TILIM");
   witSetCpxParSpecDblVal    (theWitRun, 0.7);
   witSetCpxParSpecDblValDbl (theWitRun, 2.5);

   witGetCpxParSpecName      (theWitRun, & theString);
   witGetCpxParSpecIntVal    (theWitRun, & theInt);
   witGetCpxParSpecDblVal    (theWitRun, & theFlt);
   witGetCpxParSpecDblValDbl (theWitRun, & theDbl);
d2667 1
a2667 1
/* testGetIntCpxParSpec (theWitRun)                                           */
d2669 1
a2669 1
/* Tests witGetIntCpxParSpec.                                                 */
d2672 1
a2672 1
void testGetIntCpxParSpec (WitRun * theWitRun)
d2677 2
a2678 2
   witGetIntCpxParSpec    (theWitRun, "NONE",  & intSpecExists,
                                               & theInt);
d2682 2
a2683 2
   witGetIntCpxParSpec    (theWitRun, "EPOPT", & intSpecExists,
                                               & theInt);
d2687 2
a2688 2
   witGetIntCpxParSpec    (theWitRun, "ITLIM", & intSpecExists,
                                               & theInt);
d2696 1
a2696 1
/* testGetDblCpxParSpec (theWitRun)                                           */
d2698 1
a2698 1
/* Tests witGetDblCpxParSpec and witGetDblCpxParSpecDbl.                      */
d2701 1
a2701 1
void testGetDblCpxParSpec (WitRun * theWitRun)
d2707 2
a2708 2
   witGetDblCpxParSpec    (theWitRun, "NONE",  & dblSpecExists,
                                               & theFlt);
d2712 2
a2713 2
   witGetDblCpxParSpec    (theWitRun, "ITLIM", & dblSpecExists,
                                               & theFlt);
d2717 2
a2718 2
   witGetDblCpxParSpecDbl (theWitRun, "EPRHS", & dblSpecExists,
                                               & theDbl);
@


1.304
log
@CPLEX solution status
@
text
@d2596 3
a2598 3
   witAddIntCpxParSpec    (theWitRun, "CPX_PARAM_ITLIM", 100000);
   witAddDblCpxParSpec    (theWitRun, "CPX_PARAM_EPRHS", 1.e-5);
   witAddDblCpxParSpecDbl (theWitRun, "CPX_PARAM_EPOPT", 1.e-7);
d2615 1
a2615 1
   witAddIntCpxParSpec    (theWitRun, "CPX_PARAM_SIMDISPLAY",   2);
d2617 2
a2618 2
   witGetIntCpxParSpec    (theWitRun, "CPX_PARAM_SIMDISPLAY", & intSpecExists,
                                                              & theInt);
d2625 2
a2626 2
   witGetIntCpxParSpec    (theWitRun, "CPX_PARAM_SIMDISPLAY", & intSpecExists,
                                                              & theInt);
d2644 2
a2645 2
   witSetSpecCpxParName      (theWitRun, "CPX_PARAM_LPMETHOD");
   witSetSpecCpxParIntVal    (theWitRun, 4);
d2647 8
a2654 8
   witSetSpecCpxParName      (theWitRun, "CPX_PARAM_TILIM");
   witSetSpecCpxParDblVal    (theWitRun, 0.7);
   witSetSpecCpxParDblValDbl (theWitRun, 2.5);

   witGetSpecCpxParName      (theWitRun, & theString);
   witGetSpecCpxParIntVal    (theWitRun, & theInt);
   witGetSpecCpxParDblVal    (theWitRun, & theFlt);
   witGetSpecCpxParDblValDbl (theWitRun, & theDbl);
d2656 1
a2656 1
   assert (equalStrings (theString, "CPX_PARAM_TILIM"));
d2677 2
a2678 2
   witGetIntCpxParSpec    (theWitRun, "CPX_PARAM_NONE",  & intSpecExists,
                                                         & theInt);
d2682 2
a2683 2
   witGetIntCpxParSpec    (theWitRun, "CPX_PARAM_EPOPT", & intSpecExists,
                                                         & theInt);
d2687 2
a2688 2
   witGetIntCpxParSpec    (theWitRun, "CPX_PARAM_ITLIM", & intSpecExists,
                                                         & theInt);
d2707 2
a2708 2
   witGetDblCpxParSpec    (theWitRun, "CPX_PARAM_NONE",  & dblSpecExists,
                                                         & theFlt);
d2712 2
a2713 2
   witGetDblCpxParSpec    (theWitRun, "CPX_PARAM_ITLIM", & dblSpecExists,
                                                         & theFlt);
d2717 2
a2718 2
   witGetDblCpxParSpecDbl (theWitRun, "CPX_PARAM_EPRHS", & dblSpecExists,
                                                         & theDbl);
@


1.303
log
@CPLEX Solution Status
@
text
@d2469 1
a2469 1
      int cpxStat;
d2471 1
a2471 1
      witGetCpxStat       (theObj1Run, & cpxStat);
d2473 1
a2473 1
      assert (cpxStat == -1);
d2479 1
a2479 1
      witGetCpxStat       (theObj1Run, & cpxStat);
d2481 1
a2481 1
      assert (cpxStat == 101);
@


1.302
log
@CPLEX Parameters
@
text
@d2469 6
d2479 4
@


1.301
log
@CPLEX Parameters
@
text
@d44 7
a50 1
void testCpxParSpecs (WitRun *);
d2582 20
a2601 1
   char *     theString;
a2602 2
   float      theFlt;
   double     theDbl;
a2603 1
   witBoolean dblSpecExists;
d2605 28
a2632 1
   /*-------------------------------------------------------------------------*/
d2654 1
d2656 5
a2660 1
   /*-------------------------------------------------------------------------*/
d2662 4
a2665 5
   witAddIntCpxParSpec    (theWitRun, "CPX_PARAM_ITLIM",   100000);
   witAddDblCpxParSpec    (theWitRun, "CPX_PARAM_EPRHS",   1.e-5);
   witAddDblCpxParSpecDbl (theWitRun, "CPX_PARAM_EPOPT",   1.e-7);

   /*-------------------------------------------------------------------------*/
d2683 1
d2685 11
a2695 1
   /*-------------------------------------------------------------------------*/
@


1.300
log
@CPLEX Parameters
@
text
@d2581 3
d2606 2
d2612 2
d2630 19
@


1.299
log
@CPLEX Parameters
@
text
@d2576 5
a2580 4
   char * theString;
   int    theInt;
   float  theFlt;
   double theDbl;
d2603 20
a2622 3
   witAddIntCpxParSpec    (theWitRun, "CPX_PARAM_ITLIM", 100000);
   witAddDblCpxParSpec    (theWitRun, "CPX_PARAM_EPRHS", 1.e-5);
   witAddDblCpxParSpecDbl (theWitRun, "CPX_PARAM_EPOPT", 1.e-7);
@


1.298
log
@CPLEX Parameters
@
text
@d2602 3
a2604 1
   witAddIntCpxParSpec (theWitRun, "CPX_PARAM_ITLIM", 100000);
a2606 1

@


1.297
log
@CPLEX Parameters
@
text
@d44 1
a45 1
void testCpxParSpecs (WitRun *);
d286 2
a2458 2
   testCpxParSpecs (theObj1Run);

d2601 2
@


1.296
log
@CPLEX Parameters
@
text
@d2585 2
a2586 2
   witSetSpecCpxParDblVal    (theWitRun, 0.5);
   witSetSpecCpxParDblValDbl (theWitRun, 0.1);
d2597 2
a2598 2
   assert (fabs (theFlt - 0.1) < dblEps);
   assert (fabs (theDbl - 0.1) < dblEps);
@


1.295
log
@Added a test of MIP mode with CPLEX.
@
text
@d44 2
a162 1
void          testWriteReadData (WitRun *, const char *);
d2457 2
d2569 59
a6987 23
/* testWriteReadData (theWitRun, fileName)                                    */
/*                                                                            */
/* Tests witWriteData and witReadData using a temporary WitRun.               */
/*----------------------------------------------------------------------------*/

void testWriteReadData (WitRun * theWitRun, const char * fileName)
   {
   WitRun * tempWitRun;

   witWriteData  (theWitRun, fileName);

   witNewRun   (& tempWitRun);

   witInitialize (tempWitRun);

   witReadData   (tempWitRun, fileName);

   witDeleteRun  (tempWitRun);

   unlink                    (fileName);
   }

/*----------------------------------------------------------------------------*/
@


1.294
log
@CPLEX
@
text
@d2460 1
a2460 5
      witSetOperationIntExecVols   (theObj1Run, "PS1",       WitFALSE);
      witSetSubsBomEntryIntSubVols (theObj1Run, "PS1", 0, 0, WitFALSE);
      witSetDemandIntShipVols      (theObj1Run, "PS1", "US", WitFALSE);
      witSetMipMode                (theObj1Run,              WitFALSE);
      witSetCplexSelected          (theObj1Run,              WitTRUE);
d2462 1
a2462 1
      witOptImplode                (theObj1Run);
d2464 1
a2464 1
      prtRemove                                ("solver.log");
d2466 2
a2467 2
      witWriteExecSched            (theObj1Run, WitSTDOUT,   WitBSV);
      witWriteShipSched            (theObj1Run, WitSTDOUT,   WitBSV);
@


1.293
log
@CPLEX
@
text
@a6875 1
   witInterpretDevCmd        (theWitRun, "Allow accelerated CPLEX.");
@


1.292
log
@CPLEX
@
text
@a170 1
witBoolean    developmentMode   ();
d172 2
a173 2
const int    nPeriods = 5;
const double dblEps   = .00001;
d175 5
a179 3
witBoolean   coinEmbedded;
witBoolean   cplexEmbedded;
witBoolean   solverEmbedded;
d413 3
a415 1
   if (developmentMode ())
d6868 1
a6868 1
   if (! developmentMode ())
d6874 17
a6890 6
   witNewRun            (& theWitRun);
   witInitialize          (theWitRun);
   witInterpretDevCmd     (theWitRun, "Allow accelerated CPLEX.");
   witSetCplexSelected    (theWitRun, WitTRUE);
   witSetAccAfterOptImp   (theWitRun, WitTRUE);
   witSetNPeriods         (theWitRun, 1);
d6892 3
a6894 3
   witAddPart             (theWitRun, "A",      WitMATERIAL);
   witAddPart             (theWitRun, "B",      WitMATERIAL);
   witAddPart             (theWitRun, "C",      WitMATERIAL);
d6896 2
a6897 2
   witAddOperation        (theWitRun, "D");
   witAddOperation        (theWitRun, "E");
d6899 1
a6899 2
   witAddBomEntry         (theWitRun, "D", "A");
   witAddBomEntry         (theWitRun, "E", "A");
d6901 2
a6902 2
   witAddBopEntry         (theWitRun, "D", "B");
   witAddBopEntry         (theWitRun, "E", "C");
d6904 3
a6906 2
   witAddDemand           (theWitRun, "B", "F");
   witAddDemand           (theWitRun, "C", "G");
d6908 2
a6909 1
   witSetPartSupplyVol    (theWitRun, "A",      fltVecOf1 (170));
d6911 1
a6911 2
   witSetDemandDemandVol  (theWitRun, "B", "F", fltVecOf1 (100));
   witSetDemandDemandVol  (theWitRun, "C", "G", fltVecOf1 (100));
d6913 1
a6913 2
   witSetDemandShipReward (theWitRun, "B", "F", fltVecOf1   (3));
   witSetDemandShipReward (theWitRun, "C", "G", fltVecOf1   (2));
d6915 1
a6915 1
   witOptImplode          (theWitRun);
d6917 1
a6917 1
   witWriteShipSched      (theWitRun, WitSTDOUT, WitCSV);
d6919 3
a6921 1
   witSetDemandShipReward (theWitRun, "B", "F", fltVecOf1   (1));
d6923 1
a6923 1
   witOptImplode          (theWitRun);
d6925 1
a6925 1
   witWriteShipSched      (theWitRun, WitSTDOUT, WitCSV);
d6927 1
a6927 1
   witDeleteRun           (theWitRun);
a7089 18

/*----------------------------------------------------------------------------*/
/* Function developmentMode.                                                  */
/*                                                                            */
/* Returns WitTRUE, iff WIT was built in development mode.                    */
/*----------------------------------------------------------------------------*/

witBoolean developmentMode ()
   {
   WitRun *   theWitRun;
   witBoolean devMode;

   witNewRun   (& theWitRun);
   witGetDevMode (theWitRun, & devMode);
   witDeleteRun  (theWitRun);

   return devMode;
   }
@


1.291
log
@CPLEX
@
text
@d159 13
a171 10
void       testWriteReadData (WitRun *, const char *);
void       compareFltVecsOf2 (float *,        float,          float);
float *    fltVecOf2         (float *,        float,          float);
witBoolean equalStrings      (const char *,   const char *);
void       compareIntVecs    (const int *,    const int *,    int);
void       compareFltVecs    (const float *,  const float *,  int);
void       compareDblVecs    (const double *, const double *, int);
void       printFltVec       (const char *,   const float *,  int);
void       printDblVec       (const char *,   const double *, int);
witBoolean developmentMode   ();
d2538 1
a6666 2
   float theVec[2];

d6675 2
a6676 2
   witSetPartSupplyVol   (theWitRun, "A",      fltVecOf2 (theVec, 2, 0));
   witSetDemandDemandVol (theWitRun, "B", "D", fltVecOf2 (theVec, 0, 1));
a6687 2
   float theVec[2];

d6690 6
a6695 6
   witSetPartScrapCost       (theWitRun, "A",       fltVecOf2 (theVec,  1,  2));
   witSetPartStockCost       (theWitRun, "B",       fltVecOf2 (theVec,  5,  6));
   witSetOperationExecCost   (theWitRun, "C",       fltVecOf2 (theVec,  9, 10));
   witSetSubsBomEntrySubCost (theWitRun, "C", 0, 0, fltVecOf2 (theVec, 13, 14));
   witSetDemandShipReward    (theWitRun, "B", "D",  fltVecOf2 (theVec, 17, 18));
   witSetDemandCumShipReward (theWitRun, "B", "D",  fltVecOf2 (theVec, 21, 22));
d6699 6
a6704 6
   witSetPartScrapCost       (theWitRun, "A",       fltVecOf2 (theVec,  3,  4));
   witSetPartStockCost       (theWitRun, "B",       fltVecOf2 (theVec,  7,  8));
   witSetOperationExecCost   (theWitRun, "C",       fltVecOf2 (theVec, 11, 12));
   witSetSubsBomEntrySubCost (theWitRun, "C", 0, 0, fltVecOf2 (theVec, 15, 16));
   witSetDemandShipReward    (theWitRun, "B", "D",  fltVecOf2 (theVec, 19, 20));
   witSetDemandCumShipReward (theWitRun, "B", "D",  fltVecOf2 (theVec, 23, 24));
d6856 60
a6945 2
   float goodVec[2];

d6948 1
a6948 1
      fltVecOf2 (goodVec, theFlt0, theFlt1),
d6953 1
a6953 1
/* Function fltVecOf2 (theFltVec, theFlt0, theFlt1)                           */
d6955 2
a6956 3
/* Assumes that theFltVec is a vector of length 2.                            */
/* Populates theFltVec with theFlt0 and theFlt1.                              */
/* Return    theFltVec.                                                       */
d6959 1
a6959 1
float * fltVecOf2 (float * theFltVec, float theFlt0, float theFlt1)
d6961 18
@


1.290
log
@CPLEX
@
text
@a2458 1
      witSetOptInitMethod          (theObj1Run, WitCRASH_OPT_INIT_METHOD);
@


1.289
log
@CPLEX
@
text
@d258 1
a259 1
   witBoolean coinSelected;
d261 18
a278 29
   if (cplexEmbedded)
      {
      witSetCplexSelected (theWitRun,   WitTRUE);
      witGetCplexSelected (theWitRun, & cplexSelected);
      assert                           (cplexSelected);

      witGetCoinSelected  (theWitRun, & coinSelected);
      assert                         (! coinSelected);
      }
   else
      {
      witGetCplexSelected (theWitRun, & cplexSelected);
      assert                         (! cplexSelected);
      }

   if (coinEmbedded)
      {
      witSetCoinSelected  (theWitRun,   WitTRUE);
      witGetCoinSelected  (theWitRun, & coinSelected);
      assert                           (coinSelected);

      witGetCplexSelected (theWitRun, & cplexSelected);
      assert                         (! cplexSelected);
      }
   else
      {
      witGetCoinSelected  (theWitRun, & coinSelected);
      assert                         (! coinSelected);
      }
d3827 1
a3827 2
      if (cplexEmbedded)
         witSetCoinSelected  (theWitRun, WitTRUE);
@


1.288
log
@CPLEX
@
text
@d259 1
d262 1
d264 2
d267 8
a274 7
   witGetCplexSelected    (theWitRun, & cplexSelected);

   assert (cplexSelected == cplexEmbedded);
   }

   {
   witBoolean coinSelected;
d277 4
a280 1
      witSetCoinSelected (theWitRun,   WitTRUE);
d282 8
a289 3
   witGetCoinSelected    (theWitRun, & coinSelected);

   assert (coinSelected == coinEmbedded);
@


1.287
log
@CPLEX
@
text
@a172 1
witBoolean   solverEmbedded;
d175 1
a232 11
   witGetSolverEmbedded (theWitRun, & solverEmbedded);

   if (solverEmbedded)
      printf (
         "\n"
         "This is a solver-embedded build of WIT.\n");
   else
      printf (
         "\n"
         "This is not a solver-embedded build of WIT.\n");

d255 2
d1721 1
a1721 1
   if (solverEmbedded)
@


1.286
log
@CPLEX
@
text
@d267 1
a267 1
   witBoolean solverIsCplex;
d270 1
a270 1
      witSetSolverIsCplex (theWitRun,   WitTRUE);
d272 1
a272 1
   witGetSolverIsCplex    (theWitRun, & solverIsCplex);
d274 1
a274 1
   assert (solverIsCplex == cplexEmbedded);
d278 1
a278 1
   witBoolean solverIsCoin;
d281 1
a281 1
      witSetSolverIsCoin (theWitRun,   WitTRUE);
d283 1
a283 1
   witGetSolverIsCoin    (theWitRun, & solverIsCoin);
d285 1
a285 1
   assert (solverIsCoin == coinEmbedded);
d2465 1
a2465 1
      witSetSolverIsCplex          (theObj1Run,              WitTRUE);
d3828 1
a3828 1
         witSetSolverIsCplex (theWitRun, WitTRUE);
d3835 1
a3835 1
         witSetSolverIsCoin  (theWitRun, WitTRUE);
@


1.285
log
@CPLEX
@
text
@d2457 19
@


1.284
log
@Name change: "selection reuse" has become "selection recovery".
@
text
@d1709 1
a1709 1
      witOptImplode  (theWitRun);
d2446 1
a2446 1
      witOptImplode( theObj1Run );
d2451 1
a2451 1
      witHeurImplode( theObj1Run );
d3808 3
d3814 3
@


1.283
log
@Lead Time Bounds.
@
text
@d6784 1
a6784 1
/* Tests selection reuse and lead time bounds.                                */
d6802 2
a6803 2
   witSetSelectionReuse       (theWitRun,               WitTRUE);
   witGetSelectionReuse       (theWitRun,             & theBool);
@


1.282
log
@Selection reuse and lead time bounds.
@
text
@d6795 1
d6801 5
a6805 5
   witSetNPeriods             (theWitRun,             3);
   witSetSelectionReuse       (theWitRun,             WitTRUE);
   witGetSelectionReuse       (theWitRun,           & theBool);
   assert                                            (theBool);
   witSetSkipFailures         (theWitRun,             WitFALSE);
d6807 2
a6808 2
   witAddPart                 (theWitRun,   "A",      WitCAPACITY);
   witAddPart                 (theWitRun,   "B",      WitMATERIAL);
d6815 13
a6827 3
   witSetPartSupplyVol        (theWitRun,   "A",      supplyVol);
   witSetPartBuildNstn        (theWitRun,   "B",      WitTRUE);
   witSetPartBoundedLeadTimes (theWitRun,   "B",      WitTRUE);
d6829 2
a6830 8
   witSetDemandDemandVol      (theWitRun,   "B", "D", demandVol);
   witSetDemandDemandVol      (theWitRun,   "B", "E", demandVol);

   witSetDemandLeadTimeUB     (theWitRun,   "B", "D", the2Vec);
   witSetDemandLeadTimeUB     (theWitRun,   "B", "E", the1Vec);

   witSetDemandPriority       (theWitRun,   "B", "D", the1Vec);
   witSetDemandPriority       (theWitRun,   "B", "E", the2Vec);
d6834 1
a6834 1
   witWriteShipSched          (theWitRun,             WitSTDOUT, WitBSV);
@


1.281
log
@CPLEX
@
text
@d157 2
d2523 1
d6782 53
@


1.280
log
@CPLEX
@
text
@d265 11
@


1.279
log
@Preparing for CPLEX.
@
text
@d173 1
d253 11
@


1.278
log
@Revising the build procedure for WIT.
@
text
@d253 11
@


1.277
log
@Revising the build procedure.
@
text
@d171 1
d230 11
d1672 1
a1672 1
   if (coinEmbedded)
d1694 1
a1694 1
   if (coinEmbedded)
d1732 1
a1732 1
   if (coinEmbedded)
d1742 1
a1742 1
   if (coinEmbedded)
d2408 1
a2408 1
   if (coinEmbedded)
d2463 1
a2463 1
   if (coinEmbedded)
d3769 1
a3769 1
   if (coinEmbedded)
d6022 1
a6022 1
   if (! coinEmbedded)
d6372 1
a6372 1
   if (! coinEmbedded)
d6453 1
a6453 1
   if (! coinEmbedded)
@


1.276
log
@Revising the build procedure.
@
text
@d171 1
a171 1
witBoolean   coinEmdedded;
d229 1
a229 1
   witGetCoinEmdedded (theWitRun, & coinEmdedded);
d231 1
a231 1
   if (coinEmdedded)
d1660 1
a1660 1
   if (coinEmdedded)
d1682 1
a1682 1
   if (coinEmdedded)
d1720 1
a1720 1
   if (coinEmdedded)
d1730 1
a1730 1
   if (coinEmdedded)
d2396 1
a2396 1
   if (coinEmdedded)
d2451 1
a2451 1
   if (coinEmdedded)
d3757 1
a3757 1
   if (coinEmdedded)
d6010 1
a6010 1
   if (! coinEmdedded)
d6360 1
a6360 1
   if (! coinEmdedded)
d6441 1
a6441 1
   if (! coinEmdedded)
@


1.275
log
@Minor revision.
@
text
@d171 1
a171 1
witBoolean   witEmbedsCoin;
d229 1
a229 1
   witGetWitEmbedsCoin (theWitRun, & witEmbedsCoin);
d231 1
a231 1
   if (witEmbedsCoin)
d234 1
a234 1
         "This build of WIT embeds COIN.\n");
d238 1
a238 1
         "This build of WIT does not embed COIN.\n");
d1660 1
a1660 1
   if (witEmbedsCoin)
d1682 1
a1682 1
   if (witEmbedsCoin)
d1720 1
a1720 1
   if (witEmbedsCoin)
d1730 1
a1730 1
   if (witEmbedsCoin)
d2396 1
a2396 1
   if (witEmbedsCoin)
d2451 1
a2451 1
   if (witEmbedsCoin)
d3757 1
a3757 1
   if (witEmbedsCoin)
d6010 1
a6010 1
   if (! witEmbedsCoin)
d6360 1
a6360 1
   if (! witEmbedsCoin)
d6441 1
a6441 1
   if (! witEmbedsCoin)
@


1.274
log
@Revising the build process.
@
text
@d234 1
a234 1
         "This build of WIT embeds COIN.");
d238 1
a238 1
         "This build of WIT does not embed COIN.");
@


1.273
log
@Made mesgFileAccessMode 'w'.
@
text
@d171 1
a171 1
witBoolean   optImpAllowed;
d229 1
a229 1
   witGetOptImpAllowed (theWitRun, & optImpAllowed);
d231 1
a231 1
   if (optImpAllowed)
d234 1
a234 1
         "Optimizing implosion is allowed in this build of WIT.\n");
d238 1
a238 1
         "Optimizing implosion is not allowed in this build of WIT.\n");
d1660 1
a1660 1
   if (optImpAllowed)
d1682 1
a1682 1
   if (optImpAllowed)
d1720 1
a1720 1
   if (optImpAllowed)
d1730 1
a1730 1
   if (optImpAllowed)
d2396 1
a2396 1
   if (optImpAllowed)
d2451 1
a2451 1
   if (optImpAllowed)
d3757 1
a3757 1
   if (optImpAllowed)
d6010 1
a6010 1
   if (! optImpAllowed)
d6360 1
a6360 1
   if (! optImpAllowed)
d6441 1
a6441 1
   if (! optImpAllowed)
@


1.272
log
@Minor revision.
@
text
@d204 1
a204 1
   witSetMesgFileAccessMode( theWitRun, WitFALSE, "a" );
d260 1
a260 1
   assert( strcmp( string, "a" ) == 0 );
d1673 1
@


1.271
log
@Added a test of witWriteData followed by witReadData on the resulting file.
@
text
@a6740 1
   witWriteData  (theWitRun, WitSTDOUT);
@


1.270
log
@Multi-Obj Mode
@
text
@d157 1
d2391 2
d6732 24
@


1.269
log
@Added test for multiObjTol.
@
text
@d6550 1
a6550 1
   witSetObjectiveSeqNo   (theWitRun, 2);
d6553 1
a6553 1
   witSetObjectiveSeqNo   (theWitRun, 1);
d6556 1
a6556 1
   witGetObjectiveSeqNo   (theWitRun, & theSeqNo);
@


1.268
log
@Made apiAll work correctly with optImpAllowed == WitFALSE.
@
text
@d151 1
d6453 1
d6566 20
@


1.267
log
@Improved the test for boundsValue in stochastic mode.
@
text
@d6005 3
d6355 3
d6436 3
@


1.266
log
@Made the test for witGetBoundsValue valid.
@
text
@d6033 23
a6055 19
   witSetMesgPrintNumber    (theWitRun, WitTRUE,
                                        WitINFORMATIONAL_MESSAGES,
                                        WitFALSE);   

   witInitialize            (theWitRun);

   witSetNPeriods           (theWitRun, 1);

   witAddPart               (theWitRun, "A",      WitMATERIAL);
   witAddPart               (theWitRun, "B",      WitMATERIAL);
   witAddOperation          (theWitRun, "C");
   witAddBomEntry           (theWitRun, "C", "A");
   witAddBopEntry           (theWitRun, "C", "B");
   witAddDemand             (theWitRun, "B", "D");

   witSetPartSupplyVol      (theWitRun, "A",      supplyVolA);
   witSetDemandDemandVol    (theWitRun, "B", "D", demandVolD);
   witSetOperationExecCost  (theWitRun, "C",      execCostC);
   witSetDemandShipReward   (theWitRun, "B", "D", shipRewardD);
d6080 3
d6087 3
d6292 1
a6292 1
   assert (fabs (boundsValue -   0.0) < dblEps);
d6343 1
a6343 1
/* testStageByObject                                                          */
d6345 1
a6345 1
/* Test of stochastic implosion in stage-by-object mode.                      */
@


1.265
log
@Removed a redundant test.
@
text
@d1585 2
d1591 5
@


1.264
log
@Fixed a bug:
   witCopyData on a WitRun pointer that was not initialized.
@
text
@a6427 1
   testGetObjVecs     (theWitRun);
@


1.263
log
@Multi-obj mode
@
text
@d6430 2
d6434 2
d6438 1
a6438 1
   witOptImplode      (theWitRun);
d6440 1
a6440 1
   testMultiObjValue  (theWitRun);
d6442 1
a6442 1
   witDeleteRun       (theWitRun);
@


1.262
log
@Multi-objectives mode
@
text
@d6404 1
a6404 1
/* Tests multi-objectives mode.                                               */
d6537 2
a6538 1
/* Creates all data objects for the WitRun for the multi-objectives mode test.*/
d6560 2
a6561 2
/* Tests functions for setting objective function vectors in multi-objectives */
/* mode.                                                                      */
d6591 1
a6591 1
/* multi-objectives mode.                                                     */
d6656 1
a6656 1
/* Tests witGetObjValue in multi-objectives mode.                             */
@


1.261
log
@Multi-objectives mode
@
text
@d147 8
a154 7
void testMultiObjMode    ();
void testObjListSpec     (WitRun *);
void testObjList         (WitRun *);
void testObjSeq          (WitRun *);
void populateMultiObj    (WitRun *);
void testSetObjVecs      (WitRun *);
void testGetObjVecs      (WitRun *);
d6410 1
d6430 8
d6653 24
@


1.260
log
@Multi-objectives mode
@
text
@d148 16
a163 8

witBoolean equalStrings    (const char *,   const char *);
void       compareIntVecs  (const int *,    const int *,    int);
void       compareFltVecs  (const float *,  const float *,  int);
void       compareDblVecs  (const double *, const double *, int);
void       printFltVec     (const char *,   const float *,  int);
void       printDblVec     (const char *,   const double *, int);
witBoolean developmentMode ();
d6415 2
d6421 7
d6432 243
d6688 1
a6688 1
/* Returns true iff theIntVec1 == theIntVec2.                                 */
d6702 1
a6702 1
/* Returns true iff theFltVec1 == theFltVec2.                                 */
d6719 1
a6719 1
/* Returns true iff theDblVec1 == theDblVec2.                                 */
@


1.259
log
@Removing objective #2.
@
text
@d147 2
d2453 1
d6393 22
@


1.258
log
@Removed the reading of ex1.data from apiAll.
@
text
@a296 2
   witSetPeriodsPerYearDbl( theWitRun, 365. );
   witSetPeriodsPerYear   ( theWitRun,  12. );
a419 6
   witGetPeriodsPerYear   ( theWitRun, &theFlt );
   witGetPeriodsPerYearDbl( theWitRun, &theDbl );

   assert( theFlt == 12.0 );
   assert( theDbl == 12.0 );

@


1.257
log
@Removed calls to objective #2 API functions.
@
text
@a2440 12
   /* witReadData40 */
   {
   WitRun *wr1;

   witNewRun (& wr1);

   witInitialize( wr1 );

   witReadData(wr1, "data/ex1.data");
   witDeleteRun ( wr1 );
   }

@


1.256
log
@Removed two memory leaks
@
text
@a282 3
   witSetCapCostDbl( theWitRun, 15.7 );
   witSetCapCost   ( theWitRun, 12.3 );

a288 2
   witSetInvCostDbl( theWitRun, 10.2 );
   witSetInvCost   ( theWitRun, 6.78 );
d296 1
a296 9
   witSetObjChoice( theWitRun, 2 );
   witSetObj2WinvDbl( theWitRun, 511. );
   witSetObj2Winv   ( theWitRun,  11. );
   witSetObj2WrevDbl( theWitRun, 522. );
   witSetObj2Wrev   ( theWitRun,  22. );
   witSetObj2WservDbl(theWitRun, 533. );
   witSetObj2Wserv   (theWitRun,  33. );
   witSetObj2WsubDbl( theWitRun, 544. );
   witSetObj2Wsub   ( theWitRun,  44. );
a378 12
   witGetCapCost   ( theWitRun, &theFlt );
   witGetCapCostDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 12.3) < dblEps );
   assert( fabs(theDbl - 12.3) < dblEps );

   witGetInvCost   ( theWitRun, &theFlt );
   witGetInvCostDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 6.78) < dblEps );
   assert( fabs(theDbl - 6.78) < dblEps );

d429 1
a429 25
   assert( i == 2 );

   witGetObj2Winv   ( theWitRun, &theFlt );
   witGetObj2WinvDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 11. ) < dblEps );
   assert( fabs(theDbl - 11. ) < dblEps );

   witGetObj2Wrev   ( theWitRun, &theFlt );
   witGetObj2WrevDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 22. ) < dblEps );
   assert( fabs(theDbl - 22. ) < dblEps );

   witGetObj2Wserv   ( theWitRun, &theFlt );
   witGetObj2WservDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 33. ) < dblEps );
   assert( fabs(theDbl - 33. ) < dblEps );

   witGetObj2Wsub   ( theWitRun, &theFlt );
   witGetObj2WsubDbl( theWitRun, &theDbl );

   assert( fabs(theFlt - 44. ) < dblEps );
   assert( fabs(theDbl - 44. ) < dblEps );
a584 1
   witSetPartUnitCost   ( theWitRun, "PS1", 50.0 );
a643 4
   witGetPartUnitCost   ( theWitRun, "PS1", & theFlt);

   assert( fabs(theFlt - 50.0) < dblEps );

a700 15
   /* Double Precision */

   witSetPartUnitCost    (theWitRun, "PS1",   1.0e12);
   witGetPartUnitCost    (theWitRun, "PS1", & theFlt);
   witSetPartUnitCostDbl (theWitRun, "PS1",   1.0e12);
   witGetPartUnitCostDbl (theWitRun, "PS1", & theDbl);
   witSetPartUnitCost    (theWitRun, "PS1",   50.0);

   printf (
      "\n"
      "unitCost (float)  = %13.0f\n"
      "unitCost (double) = %13.0f\n",
      theFlt,
      theDbl);

a763 1
   witSetPartUnitCost( theWitRun, "CompA", 40.0 );
a782 1
   witSetPartUnitCost( theWitRun, "CompB", 10.0 );
a806 1
   witSetPartUnitCost( theWitRun, "CompC", 40.0 );
a823 1
   witSetPartUnitCost( theWitRun, "TestCap", .01 );
a870 2
   witSetDemandGrossRevDbl( theWitRun, "PS1", "US", 1200. );
   witSetDemandGrossRev( theWitRun, "PS1", "US", 200. );
a1000 6
   witGetDemandGrossRev   ( theWitRun, "PS1", "US", &theFlt );
   witGetDemandGrossRevDbl( theWitRun, "PS1", "US", &theDbl );

   assert( fabs(theFlt - 200.0) < dblEps );
   assert( fabs(theDbl - 200.0) < dblEps );

a1321 2
   witSetSubsBomEntryObj2SubPenaltyDbl( theWitRun, "PS1", 0, 0, 14. );
   witSetSubsBomEntryObj2SubPenalty   ( theWitRun, "PS1", 0, 0, 8. );
a1384 13
   float  subsBomEntryObj2SubPenalty;
   double subsBomEntryObj2SubPenaltyDbl;

   witGetSubsBomEntryObj2SubPenalty( theWitRun, "PS1", 0, 0,
      &subsBomEntryObj2SubPenalty );
   witGetSubsBomEntryObj2SubPenaltyDbl( theWitRun, "PS1", 0, 0,
      &subsBomEntryObj2SubPenaltyDbl );

   assert( fabs( subsBomEntryObj2SubPenalty    - 8.0 ) < dblEps );
   assert( fabs( subsBomEntryObj2SubPenaltyDbl - 8.0 ) < dblEps );
   }

   {
a1686 11
      witGetObj2Values( theWitRun, &rev, &inv, &serv, &sub );
      printf( "obj2Rev=%f, obj2Inv=%f, obj2Serv=%f, obj2Sub=%f\n",
              rev, inv, serv, sub );

      printf (
         "\n"
         "Objective function values in double precision:\n");

      witGetObjValueDbl( theWitRun, &objValueD );
      printf( "objValue = %f\n",objValueD);

a1695 4
      witGetObj2ValuesDbl( theWitRun, &revD, &invD, &servD, &subD );
      printf( "obj2Rev=%f, obj2Inv=%f, obj2Serv=%f, obj2Sub=%f\n",
              revD, invD, servD, subD );

a2065 1
   witSetPartUnitCost( theObj1Run, "PS1", 50.0 );
a2068 1
   witSetPartUnitCost( theObj1Run, "CompA", 40.0 );
a2071 1
   witSetPartUnitCost( theObj1Run, "CompB", 10.0 );
a2074 1
   witSetPartUnitCost( theObj1Run, "CompC", 40.0 );
a2077 1
   witSetPartUnitCost( theObj1Run, "TestCap", .01 );
a2173 6

   witSetObjChoice (theObj1Run, 1);
      /*                                                                      */
      /* This late call to witSetObjChoice tests the ability to set objChoice */
      /* when parts and operations exist and the ability to set and get the   */
      /* obj1 attributes when objChoice != 1.                                 */
a2191 2
   witSetDemandGrossRev( theObj1Run, "PS1", "US", 200. );
   witSetDemandDemandVol( theObj1Run, "PS1", "US", demandVolPS1US );
a2794 18

   /* obj2AuxCost */
   {
   double theDbl;
   float  theFlt;

   witSetOperationObj2AuxCostDbl( wr2, "opn1", 4.51 );
   witGetOperationObj2AuxCostDbl( wr2, "opn1", &theDbl );

   assert( fabs(theDbl - 4.51) < dblEps );

   witSetOperationObj2AuxCost( wr2, "opn1", 3.14 );
   witGetOperationObj2AuxCost( wr2, "opn1", &theFlt );

   assert( fabs(theFlt - 3.14) < dblEps );
   }


d3322 1
a3322 1
   witSetPartUnitCost (theWitRun, "Vegtable_Omlet", 42.0);
d3430 1
a3430 1
   witSetPartUnitCostDbl (theWitRun, "Vegtable_Omlet", 42.0);
a3543 2
   witSetPartUnitCost (theWitRun, "Vegtable_Omlet", 42.0);

a3652 2
   witSetPartUnitCostDbl (theWitRun, "Vegtable_Omlet", 42.0);

d5248 1
a5248 1
   witReadData                (theWitRunB, "data/obj2.data");
d5255 1
a5255 1
                               "SUBASMBL1",
d5288 1
a5288 1
   witSetPartSupplyVol (theWitRunB, "COMP3", supplyVol);
@


1.255
log
@Revised for the removal of the multiThread attribute.
@
text
@d254 2
d1687 2
@


1.254
log
@Revised wit34Allowed.
@
text
@a146 2
void testMultiThread ();

a2590 1
   testMultiThread     ();
a6551 26
/* testMultiThread                                                            */
/*----------------------------------------------------------------------------*/

void testMultiThread ()
   {
   WitRun *   theWitRun1;
   WitRun *   theWitRun2;
   witBoolean theBool;

   witNewRun       (& theWitRun1);
   witInitialize     (theWitRun1);
   witSetMultiThread (theWitRun1, WitTRUE);
   witDeleteRun      (theWitRun1);

   theWitRun1 = NULL;

   witNewRun       (& theWitRun2);
   witInitialize     (theWitRun2);
   witGetMultiThread (theWitRun2, & theBool);

   assert                          (theBool);

   witDeleteRun      (theWitRun2);
   }

/*----------------------------------------------------------------------------*/
@


1.253
log
@wit34Allowed
@
text
@a585 1
   witSetWit34Allowed (theWitRun, WitFALSE);
d2570 1
d2572 1
a2572 1
   witDeleteRun( wr1 );
d3883 14
a3896 14
   witSetMesgPrintNumber
                     (theWitRun,
                      WitTRUE,
                      WitINFORMATIONAL_MESSAGES,
                      WitFALSE);

   witInitialize     (theWitRun);
   defProfDelTest    (theWitRun);
   selItemsDelTest   (theWitRun);
   copyWriteDelTest  (theWitRun);
   witDisplayData    (theWitRun, WitSTDOUT);
   checkSelDelTest   (theWitRun);
   witPurgeData      (theWitRun);
   witDisplayData    (theWitRun, WitSTDOUT);
@


1.252
log
@Removed some calls that set mesgFileAccessMode to "w".
@
text
@d577 1
a577 1
   /* 34Compatible */
d586 1
@


1.251
log
@Added test of setting appData in stochastic mode.
@
text
@a155 1
WitRun *   newWitRun       ();
d177 2
a178 3
   theWitRun  = newWitRun ();

   theObj1Run = newWitRun ();
d2057 1
a2057 1
   theMrpRun = newWitRun ();
d2528 1
a2528 2
   lhs = newWitRun ();

d2567 1
a2567 1
   wr1 = newWitRun ();
d2615 1
a2615 2
   theWitRun = newWitRun ();

a2616 1

d2630 2
a2631 2
   wr1 = newWitRun ();
   wr2 = newWitRun ();
d3022 2
a3023 2
   WitRun *         copyWitRun;
   witBoolean       theBool;
d3025 2
a3026 3
   copyWitRun = newWitRun ();

   witCopyData   (  copyWitRun, wr2);
d3052 1
a3052 1
   wr1 = newWitRun ();
d3282 1
a3282 1
   wr1 = newWitRun ();
d3347 1
a3347 2
   theWitRun = newWitRun ();

d3445 1
a3445 2
   theWitRun = newWitRun ();

d3553 1
a3553 2
   theWitRun = newWitRun ();

d3663 1
a3663 2
   theWitRun = newWitRun ();

d3774 1
a3774 2
   theWitRun = newWitRun ();

d3880 1
a3880 1
   theWitRun = newWitRun ();
d3986 1
a3986 2
   copyWitRun = newWitRun ();

d5345 2
a5346 2
   theWitRunA = newWitRun ();
   theWitRunB = newWitRun ();
d5495 1
a5495 1
   theWitRun = newWitRun ();
d5537 1
a5537 1
   theWitRun = newWitRun ();
d5907 1
a5907 2
   theWitRun = newWitRun ();

d5966 1
a5966 2
   origWitRun = newWitRun ();

d5984 1
a5984 2
   dupWitRun = newWitRun ();

d6035 1
a6035 2
   theWitRun = newWitRun ();

d6076 1
a6076 2
   theWitRun = newWitRun ();

a6077 1

a6078 1

d6150 1
a6150 2
   theWitRun = newWitRun ();

a6181 1
   witSetMesgFileAccessMode (theWitRun, WitFALSE, "w");
d6300 1
a6300 2
   theWitRun2 = newWitRun ();

a6303 1
   witSetMesgFileAccessMode (theWitRun2, WitFALSE, "w");
d6345 1
a6345 2
   theWitRun2 = newWitRun ();

a6348 1
   witSetMesgFileAccessMode (theWitRun2, WitFALSE, "w");
d6487 1
a6487 2
   theWitRun = newWitRun ();

d6563 1
a6563 2
   theWitRun1 = newWitRun ();

d6570 1
a6570 2
   theWitRun2 = newWitRun ();

d6681 1
a6681 2
   theWitRun = newWitRun ();

a6682 1

a6686 18

/*----------------------------------------------------------------------------*/
/* Function newWitRun.                                                        */
/*                                                                            */
/* Creates and returns a new WitRun.                                          */
/* Sets the message file mode to "w" to specify writing a new file.           */
/*----------------------------------------------------------------------------*/

WitRun * newWitRun ()
   {
   WitRun * theWitRun;

   witNewRun              (& theWitRun);

   witSetMesgFileAccessMode (theWitRun, WitFALSE, "w");

   return theWitRun;
   }
@


1.250
log
@Added tests for witGetObjValue and witGetBoundsValue.
@
text
@d6237 1
@


1.249
log
@Stochastic Implosion
@
text
@d1771 9
d1791 9
@


1.248
log
@Object name change.
@
text
@d133 13
a145 9
void testStochImp       ();
void buildCoreProblem   (WitRun *);
void specifyStochData   (WitRun *);
void checkStochData     (WitRun *);
void testStochWriteData (WitRun *);
void testStochCopyData  (WitRun *);
void testStochImplode   (WitRun *);
void checkStochSoln     (WitRun *);
void testClearStochSoln (WitRun *);
d2575 2
a2576 1
   testStochImp        ();
d6142 1
a6142 1
/* testStochImp                                                               */
d6144 1
a6144 1
/* Test of API functions for stochastic implosion.                            */
d6147 1
a6147 1
void testStochImp ()
d6153 10
a6162 10
   buildCoreProblem   (theWitRun);
   specifyStochData   (theWitRun);
   checkStochData     (theWitRun);
   witDisplayData     (theWitRun, WitSTDOUT);
   printf                        ("\n");
   testStochWriteData (theWitRun);
   testStochCopyData  (theWitRun);
   testStochImplode   (theWitRun);
   checkStochSoln     (theWitRun);
   testClearStochSoln (theWitRun);
d6164 1
a6164 1
   witDeleteRun       (theWitRun);
d6168 1
a6168 1
/* buildCoreProblem                                                           */
d6170 1
a6170 1
/* Builds the core problem for the stochastic implosion test.                 */
d6173 1
a6173 1
void buildCoreProblem (WitRun * theWitRun)
d6203 1
a6203 1
/* specifyStochData                                                           */
d6208 1
a6208 1
void specifyStochData (WitRun * theWitRun)
d6484 77
@


1.247
log
@Object name changing.
@
text
@a796 24
   /* Changing the name of a part. */

   {
   witBoolean selForDel;

   witGetPartSelForDel (theWitRun, "PS1",     & selForDel);

   assert (! selForDel);

   witSetPartPartName  (theWitRun, "PS1",       "Temp-Name");

   witGetPartSelForDel (theWitRun, "PS2",     & selForDel);

   witSetPartSelForDel (theWitRun, "Temp-Name", WitTRUE);

   witSetPartPartName  (theWitRun, "Temp-Name", "PS1");

   witGetPartSelForDel (theWitRun, "PS1",     & selForDel);

   assert (selForDel);

   witSetPartSelForDel (theWitRun, "PS1",       WitFALSE);
   }

d1107 18
@


1.246
log
@Object name changing.
@
text
@a640 3
   witSetPartPartName     (theWitRun, "PS1", "Temp-Name");
   witSetPartPartName     (theWitRun, "Temp-Name", "PS1");

d797 24
d2610 1
a2610 1
void testOperationApis()
d2672 7
@


1.245
log
@Stochastic Implosion
@
text
@d641 3
@


1.244
log
@Stochastic Implosion
@
text
@d6183 14
a6196 14
   witSetStageByObject       (theWitRun,           WitTRUE);
   witSetNScenarios          (theWitRun,           3);
   witSetStochMode           (theWitRun,           WitTRUE);
   witSetPartStageIndex      (theWitRun, "A",      0);
   witSetPartStageIndex      (theWitRun, "B",      1);
   witSetOperationStageIndex (theWitRun, "C",      0);

   witSetCurScenarioIndex    (theWitRun,           0);
   witSetProbability         (theWitRun,           0.6);
   witSetDemandDemandVol     (theWitRun, "B", "D", demandVolD0);
 
   witSetCurScenarioIndex    (theWitRun,           1);
   witSetProbabilityDbl      (theWitRun,           0.3);
   witSetDemandDemandVol     (theWitRun, "B", "D", demandVolD1);
d6198 2
a6199 2
   witSetCurScenarioIndex    (theWitRun,           2);
   witSetProbability         (theWitRun,           0.1);
d6201 1
a6201 1
   witSetCurScenarioIndex    (theWitRun,           1);
d6217 2
a6218 2
   witGetStageByObject       (theWitRun,      & theBool);
   assert                                      (theBool);
d6220 2
a6221 2
   witGetNScenarios          (theWitRun,      & theInt);
   assert                                      (theInt == 3);
d6223 2
a6224 2
   witGetStochMode           (theWitRun,      & theBool);
   assert                                      (theBool);
d6226 2
a6227 2
   witGetCurScenarioIndex    (theWitRun,      & theInt);
   assert                                      (theInt == 1);
d6229 2
a6230 2
   witGetOperationStageIndex (theWitRun, "C", & theInt);
   assert                                      (theInt == 0);
d6232 2
a6233 2
   witGetPartStageIndex      (theWitRun, "B", & theInt);
   assert                                      (theInt == 1);
d6237 2
a6238 2
   witSetCurScenarioIndex (theWitRun,   0);
   witGetProbabilityDbl   (theWitRun, & theDbl);
d6244 2
a6245 2
   witSetCurScenarioIndex (theWitRun,   1);
   witGetProbability      (theWitRun, & theFlt);
d6251 2
a6252 2
   witSetCurScenarioIndex (theWitRun,   2);
   witGetProbabilityDbl   (theWitRun, & theDbl);
d6256 1
a6256 1
   witSetCurScenarioIndex (theWitRun,   1);
d6407 1
a6407 1
   witSetCurScenarioIndex (theWitRun, 0);
d6419 1
a6419 1
   witSetCurScenarioIndex (theWitRun, 2);
@


1.243
log
@witGetExpCycle
@
text
@d141 1
a4484 1

a4520 1

a4556 1

a4592 1

d6132 1
d6186 1
a6186 1
   witSetPartStageIndex      (theWitRun, "A",      1);
d6188 1
a6188 1
   witSetOperationStageIndex (theWitRun, "C",      1);
d6229 2
a6230 2
   witGetPartStageIndex      (theWitRun, "A", & theInt);
   assert                                      (theInt == 1);
d6232 1
a6232 1
   witGetOperationStageIndex (theWitRun, "C", & theInt);
d6386 3
a6388 5
   float   execVolC0[]   = {100.};
   float   excessVolA0[] = {400.};
   float   execVolC2[]   = {300.};
   float   excessVolA2[] = {200.};
   float   zeroVec[]     = {  0.};
d6402 1
a6402 1
   assert (fabs (objValue    - 600.0) < dblEps);
d6404 1
a6404 1
  
d6410 1
a6410 1
   compareFltVecs                           (theFltVec, execVolC0,   1);
d6413 2
a6414 2
   witGetPartExcessVol    (theWitRun, "A", & theFltVec);
   compareFltVecs                           (theFltVec, excessVolA0, 1);
d6422 1
a6422 1
   compareFltVecs                           (theFltVec, execVolC2,   1);
d6425 2
a6426 2
   witGetPartExcessVol    (theWitRun, "A", & theFltVec);
   compareFltVecs                           (theFltVec, excessVolA2, 1);
d6428 1
d6430 5
a6434 1
   /*-------------------------------------------------------------------------*/
d6436 5
a6440 1
   witClearStochSoln      (theWitRun);
d6444 5
a6448 3
   witGetPartExcessVol    (theWitRun, "A", & theFltVec);
   compareFltVecs                           (theFltVec, zeroVec,     1);
   witFree                                  (theFltVec);
d6450 1
a6450 1
   witSetPartSupplyVol    (theWitRun, "A",   excessVolA2);
@


1.242
log
@witGetExpCycle
@
text
@d6102 1
a6102 1
      partNameList[lenLists]);
a6109 2
   witFree (partNameList[lenLists]);

@


1.241
log
@Stochastic Implosion
@
text
@d129 4
d2551 1
d6038 79
@


1.240
log
@Stochastic Implosion
@
text
@a6041 3
   if (! developmentMode ())
      return;

@


1.239
log
@Stochastic Implosion
@
text
@d6106 10
a6115 10
   witSetStageByObject    (theWitRun,           WitTRUE);
   witSetNScenarios       (theWitRun,           3);
   witSetStochMode        (theWitRun,           WitTRUE);
   witSetPartStageNo      (theWitRun, "A",      1);
   witSetPartStageNo      (theWitRun, "B",      1);
   witSetOperationStageNo (theWitRun, "C",      1);

   witSetCurScenarioIndex (theWitRun,           0);
   witSetProbability      (theWitRun,           0.6);
   witSetDemandDemandVol  (theWitRun, "B", "D", demandVolD0);
d6117 3
a6119 3
   witSetCurScenarioIndex (theWitRun,           1);
   witSetProbabilityDbl   (theWitRun,           0.3);
   witSetDemandDemandVol  (theWitRun, "B", "D", demandVolD1);
d6121 2
a6122 2
   witSetCurScenarioIndex (theWitRun,           2);
   witSetProbability      (theWitRun,           0.1);
d6124 1
a6124 1
   witSetCurScenarioIndex (theWitRun,           1);
d6140 2
a6141 2
   witGetStageByObject    (theWitRun,      & theBool);
   assert                                   (theBool);
d6143 2
a6144 2
   witGetNScenarios       (theWitRun,      & theInt);
   assert                                   (theInt == 3);
d6146 2
a6147 2
   witGetStochMode        (theWitRun,      & theBool);
   assert                                   (theBool);
d6149 2
a6150 2
   witGetCurScenarioIndex (theWitRun,      & theInt);
   assert                                   (theInt == 1);
d6152 2
a6153 2
   witGetPartStageNo      (theWitRun, "A", & theInt);
   assert                                   (theInt == 1);
d6155 2
a6156 2
   witGetOperationStageNo (theWitRun, "C", & theInt);
   assert                                   (theInt == 1);
@


1.238
log
@Stochastic Implosion
@
text
@d6113 1
a6113 1
   witSetCurScenarioNo    (theWitRun,           0);
d6117 1
a6117 1
   witSetCurScenarioNo    (theWitRun,           1);
d6121 1
a6121 1
   witSetCurScenarioNo    (theWitRun,           2);
d6124 1
a6124 1
   witSetCurScenarioNo    (theWitRun,           1);
d6149 1
a6149 1
   witGetCurScenarioNo    (theWitRun,      & theInt);
d6160 2
a6161 2
   witSetCurScenarioNo  (theWitRun,   0);
   witGetProbabilityDbl (theWitRun, & theDbl);
d6167 2
a6168 2
   witSetCurScenarioNo  (theWitRun,   1);
   witGetProbability    (theWitRun, & theFlt);
d6174 2
a6175 2
   witSetCurScenarioNo  (theWitRun,   2);
   witGetProbabilityDbl (theWitRun, & theDbl);
d6179 1
a6179 1
   witSetCurScenarioNo  (theWitRun,   1);
d6332 1
a6332 1
   witSetCurScenarioNo    (theWitRun, 0);
d6344 1
a6344 1
   witSetCurScenarioNo    (theWitRun, 2);
@


1.237
log
@Stochastic Implosion
@
text
@d6356 1
a6356 1
   witDiscardStochSoln    (theWitRun);
@


1.236
log
@Stochastic Implosion
@
text
@d6313 1
d6357 8
@


1.235
log
@Stochastic Implosion
@
text
@d6047 9
a6055 9
   buildCoreProblem    (theWitRun);
   specifyStochData    (theWitRun);
   checkStochData      (theWitRun);
   witDisplayData      (theWitRun, WitSTDOUT);
   printf                         ("\n");
   testStochWriteData  (theWitRun);
   testStochCopyData   (theWitRun);
   testStochImplode    (theWitRun);
   checkStochSoln      (theWitRun);
d6057 1
a6057 1
   witDeleteRun        (theWitRun);
a6105 2
   witInterpretDevCmd     (theWitRun, "Allow stochastic implosion.");

a6201 1
   witInterpretDevCmd       (theWitRun2, "Allow stochastic implosion.");
@


1.234
log
@Stochastic Implosion
@
text
@d6106 1
a6106 1
   witInterpretDevCmd           (theWitRun, "Allow stochastic implosion.");
d6108 10
a6117 10
   witSetStageByObject          (theWitRun,            WitTRUE);
   witSetNScenarios             (theWitRun,            3);
   witSetStochMode              (theWitRun,            WitTRUE);
   witSetPartRecourseStage      (theWitRun, "A",       WitTRUE);
   witSetPartRecourseStage      (theWitRun, "B",       WitTRUE);
   witSetOperationRecourseStage (theWitRun, "C",       WitTRUE);

   witSetScenarioIndex          (theWitRun,            0);
   witSetProbability            (theWitRun,            0.6);
   witSetDemandDemandVol        (theWitRun, "B", "D",  demandVolD0);
d6119 3
a6121 3
   witSetScenarioIndex          (theWitRun,            1);
   witSetProbabilityDbl         (theWitRun,            0.3);
   witSetDemandDemandVol        (theWitRun, "B", "D",  demandVolD1);
d6123 2
a6124 2
   witSetScenarioIndex          (theWitRun,            2);
   witSetProbability            (theWitRun,            0.1);
d6126 1
a6126 1
   witSetScenarioIndex          (theWitRun,            1);
d6142 2
a6143 2
   witGetStageByObject          (theWitRun,      & theBool);
   assert                                         (theBool);
d6145 2
a6146 2
   witGetNScenarios             (theWitRun,      & theInt);
   assert                                         (theInt == 3);
d6148 2
a6149 2
   witGetStochMode              (theWitRun,      & theBool);
   assert                                         (theBool);
d6151 2
a6152 2
   witGetScenarioIndex          (theWitRun,      & theInt);
   assert                                         (theInt == 1);
d6154 2
a6155 2
   witGetPartRecourseStage      (theWitRun, "A", & theBool);
   assert                                         (theBool);
d6157 2
a6158 2
   witGetOperationRecourseStage (theWitRun, "C", & theBool);
   assert                                         (theBool);
d6162 1
a6162 1
   witSetScenarioIndex  (theWitRun,   0);
d6169 1
a6169 1
   witSetScenarioIndex  (theWitRun,   1);
d6176 1
a6176 1
   witSetScenarioIndex  (theWitRun,   2);
d6181 1
a6181 1
   witSetScenarioIndex  (theWitRun,   1);
d6334 1
a6334 1
   witSetScenarioIndex    (theWitRun, 0);
d6346 1
a6346 1
   witSetScenarioIndex    (theWitRun, 2);
@


1.233
log
@ASAP Pegging Order.
@
text
@d6116 1
a6116 1
   witSetScenarioProb           (theWitRun,            0.6);
d6120 1
a6120 1
   witSetScenarioProbDbl        (theWitRun,            0.3);
d6124 1
a6124 1
   witSetScenarioProb           (theWitRun,            0.1);
d6162 2
a6163 2
   witSetScenarioIndex   (theWitRun,   0);
   witGetScenarioProbDbl (theWitRun, & theDbl);
d6169 2
a6170 2
   witSetScenarioIndex   (theWitRun,   1);
   witGetScenarioProb    (theWitRun, & theFlt);
d6176 2
a6177 2
   witSetScenarioIndex   (theWitRun,   2);
   witGetScenarioProbDbl (theWitRun, & theDbl);
d6181 1
a6181 1
   witSetScenarioIndex   (theWitRun,   1);
@


1.232
log
@ASAP Pegging Order
@
text
@d637 1
a637 7

   if (developmentMode ())
      {
      witInterpretDevCmd     (theWitRun, "Allow PIP with ASAP pegging order.");
      
      witSetPartAsapPipOrder (theWitRun, "PS1", WitTRUE);
      }
@


1.231
log
@Changed the message file open mode to "w".
@
text
@d605 1
a605 1
   witBoolean asapPip;
d640 1
a640 1
      witInterpretDevCmd (theWitRun, "Allow PIP with ASAP pegging order.");
d642 1
a642 1
      witSetPartAsapPip (theWitRun, "PS1", WitTRUE);
d715 1
a715 1
   witGetPartAsapPip (theWitRun, "PS1", & asapPip);
d717 1
a717 1
   assert (asapPip);
d719 1
a719 1
   witSetPartAsapPip (theWitRun, "PS1", WitFALSE);
@


1.230
log
@ASAP Pegging Order
@
text
@d147 1
d169 3
a171 2
   witNewRun( &theWitRun );
   witNewRun( &theObj1Run );
d2019 3
a2021 1
   witNewRun( &theMrpRun );
d2490 2
a2491 1
   witNewRun( &lhs );
d2530 3
a2532 1
   witNewRun( &wr1 );
d2577 1
a2577 1
   witNewRun       (& theWitRun);
d2594 2
a2595 2
   witNewRun( &wr1 );
   witNewRun( &wr2 );
d2982 2
a2983 1
   witNewRun     (& copyWitRun);
d3010 1
a3010 1
   witNewRun( &wr1 );
d3240 1
a3240 1
   witNewRun( &wr1 );
d3305 1
a3305 1
   witNewRun (& theWitRun);
d3404 1
a3404 1
   witNewRun (& theWitRun);
d3513 1
a3513 1
   witNewRun (& theWitRun);
d3624 1
a3624 1
   witNewRun (& theWitRun);
d3736 1
a3736 1
   witNewRun (& theWitRun);
d3843 1
a3843 1
   witNewRun      (& theWitRun);
d3949 2
a3950 1
   witNewRun   (& copyWitRun);
d5313 2
a5314 2
   witNewRun  (& theWitRunA);
   witNewRun  (& theWitRunB);
d5463 1
a5463 1
   witNewRun           (& theWitRun);
d5505 1
a5505 1
   witNewRun            (& theWitRun);
d5875 2
a5876 1
   witNewRun                 (& theWitRun);
d5935 2
a5936 1
   witNewRun                 (& origWitRun);
d5954 2
a5955 1
   witNewRun                  (& dupWitRun);
d6006 2
a6007 1
   witNewRun                 (& theWitRun);
d6051 1
a6051 1
   witNewRun         (& theWitRun);
d6203 2
a6204 1
   witNewRun              (& theWitRun2);
d6251 2
a6252 1
   witNewRun              (& theWitRun2);
d6377 2
a6378 1
   witNewRun       (& theWitRun1);
d6385 2
a6386 1
   witNewRun       (& theWitRun2);
d6497 2
a6498 1
   witNewRun   (& theWitRun);
d6505 18
@


1.229
log
@Stochastic Implosion
@
text
@d603 1
d636 7
d713 6
@


1.228
log
@Stochastic Implosion
@
text
@d6089 1
a6089 1
   witSetStochDataMode          (theWitRun,            WitTRUE);
d6127 1
a6127 1
   witGetStochDataMode          (theWitRun,      & theBool);
@


1.227
log
@Stochastic Implosion
@
text
@d6090 3
a6092 2
   witSetPartRecourseStage      (theWitRun, "A",       WitFALSE);
   witSetOperationRecourseStage (theWitRun, "C",       WitFALSE);
d6134 1
a6134 1
   assert                                       (! theBool);
d6137 1
a6137 1
   assert                                       (! theBool);
a6267 3
   witSetPartRecourseStage      (theWitRun, "A", WitTRUE);
   witSetOperationRecourseStage (theWitRun, "C", WitTRUE);

@


1.226
log
@Stochastic Implosion
@
text
@d6094 1
a6094 1
   witSetProbability            (theWitRun,            0.6);
d6098 1
a6098 1
   witSetProbabilityDbl         (theWitRun,            0.3);
d6102 1
a6102 1
   witSetProbability            (theWitRun,            0.1);
d6141 1
a6141 1
   witGetProbabilityDbl  (theWitRun, & theDbl);
d6148 1
a6148 1
   witGetProbability     (theWitRun, & theFlt);
d6155 1
a6155 1
   witGetProbabilityDbl  (theWitRun, & theDbl);
@


1.225
log
@Stochastic Implosion
@
text
@d6085 1
a6085 1
   witInterpretDevCmd       (theWitRun, "Allow stochastic implosion.");
d6087 13
a6099 3
   witSetStageByObject      (theWitRun,            WitTRUE);
   witSetNScenarios         (theWitRun,            3);
   witSetStochDataMode      (theWitRun,            WitTRUE);
d6101 2
a6102 3
   witSetScenarioIndex      (theWitRun,            0);
   witSetProbability        (theWitRun,            0.6);
   witSetDemandDemandVol    (theWitRun, "B", "D",  demandVolD0);
d6104 1
a6104 8
   witSetScenarioIndex      (theWitRun,            1);
   witSetProbabilityDbl     (theWitRun,            0.3);
   witSetDemandDemandVol    (theWitRun, "B", "D",  demandVolD1);

   witSetScenarioIndex      (theWitRun,            2);
   witSetProbability        (theWitRun,            0.1);

   witSetScenarioIndex      (theWitRun,            1);
d6120 5
a6124 2
   witGetStageByObject   (theWitRun, & theBool);
   assert                             (theBool);
d6126 2
a6127 2
   witGetNScenarios      (theWitRun, & theInt);
   assert                             (theInt == 3);
d6129 2
a6130 2
   witGetStochDataMode   (theWitRun, & theBool);
   assert                             (theBool);
d6132 5
a6136 2
   witGetScenarioIndex   (theWitRun, & theInt);
   assert                             (theInt == 1);
d6267 5
a6271 2
   witGetStochSolnMode (theWitRun, & theBool);
   assert                        ( ! theBool);
d6273 1
a6273 1
   witStochImplode     (theWitRun);
d6275 2
a6276 2
   witGetStochSolnMode (theWitRun, & theBool);
   assert                           (theBool);
@


1.224
log
@Stochastic Implosion.
@
text
@d6277 2
d6287 16
a6302 1
   witSetScenarioIndex (theWitRun, 0);
d6314 1
a6314 1
   witSetScenarioIndex (theWitRun, 2);
@


1.223
log
@Stochastic Implosion
@
text
@a6281 1
   float   zeroVec[]     =   {0.};
a6309 4

   witGetOperationExecVol (theWitRun, "C", & theFltVec);
   compareFltVecs                           (theFltVec, zeroVec,     1);
   witFree                                  (theFltVec);
@


1.222
log
@Stochastic Implosion
@
text
@a6034 1
   witDiscardStochSoln (theWitRun);
d6282 1
d6307 8
@


1.221
log
@Stochastic Implosion
@
text
@d136 1
d6034 1
d6270 40
@


1.220
log
@Stochastic Implosion
@
text
@d6023 1
a6023 1
   witNewRun        (& theWitRun);
d6025 9
a6033 8
   buildCoreProblem   (theWitRun);
   specifyStochData   (theWitRun);
   checkStochData     (theWitRun);
   witDisplayData     (theWitRun, WitSTDOUT);
   printf                        ("\n");
   testStochWriteData (theWitRun);
   testStochCopyData  (theWitRun);
   testStochImplode   (theWitRun);
d6035 1
a6035 1
   witDeleteRun       (theWitRun);
d6258 2
a6259 2
   witGetStochSolnExists (theWitRun, & theBool);
   assert                          ( ! theBool);
d6261 1
a6261 1
   witStochImplode       (theWitRun);
d6263 2
a6264 4
   witGetStochSolnExists (theWitRun, & theBool);
   assert                             (theBool);

   witDiscardStochSoln   (theWitRun);
@


1.219
log
@Stochastic Implosion
@
text
@a6062 1
   witAddSubsBomEntry       (theWitRun, "C", 0,   "A");
a6081 3
   float shipVolD2  [] = {150.0};
   float execVolC1  [] = {270.0};
   float subVolC0   [] = {120.0};
a6091 1
   witSetSubsBomEntrySubVol (theWitRun, "C", 0, 0, subVolC0);
a6095 1
   witSetOperationExecVol   (theWitRun, "C",       execVolC1);
a6098 1
   witSetDemandShipVol      (theWitRun, "B", "D",  shipVolD2);
a6114 5
   float *    theFltVec;
   float      zeroVec  [] =   {0.0};
   float      shipVolD2[] = {150.0};
   float      execVolC1[] = {270.0};
   float      subVolC0 [] = {120.0};
a6134 10
   witGetOperationExecVol (theWitRun,  "C",        & theFltVec);

   compareFltVecs                                   (theFltVec, zeroVec,   1);
   witFree                                          (theFltVec);

   witGetSubsBomEntrySubVol (theWitRun, "C", 0, 0, & theFltVec);

   compareFltVecs                                   (theFltVec, subVolC0,  1);
   witFree                                          (theFltVec);

a6141 10
   witGetDemandShipVol   (theWitRun,   "B", "D",   & theFltVec);

   compareFltVecs                                   (theFltVec, zeroVec,   1);
   witFree                                          (theFltVec);

   witGetOperationExecVol (theWitRun,  "C",        & theFltVec);

   compareFltVecs                                   (theFltVec, execVolC1, 1);
   witFree                                          (theFltVec);

a6148 10
   witGetDemandShipVol   (theWitRun,   "B", "D",   & theFltVec);

   compareFltVecs                                   (theFltVec, shipVolD2, 1);
   witFree                                          (theFltVec);

   witGetSubsBomEntrySubVol (theWitRun, "C", 0, 0, & theFltVec);

   compareFltVecs                                   (theFltVec, zeroVec,    1);
   witFree                                          (theFltVec);

@


1.218
log
@Stochastic Implosion
@
text
@d6063 1
d6085 1
d6087 1
a6087 1
   witInterpretDevCmd     (theWitRun,           "Allow stochastic implosion.");
d6089 3
a6091 16
   witSetStageByObject    (theWitRun,           WitTRUE);
   witSetNScenarios       (theWitRun,           3);
   witSetStochDataMode    (theWitRun,           WitTRUE);

   witSetScenarioIndex    (theWitRun,           0);
   witSetProbability      (theWitRun,           0.6);
   witSetDemandDemandVol  (theWitRun, "B", "D", demandVolD0);

   witSetScenarioIndex    (theWitRun,           1);
   witSetProbabilityDbl   (theWitRun,           0.3);
   witSetDemandDemandVol  (theWitRun, "B", "D", demandVolD1);
   witSetOperationExecVol (theWitRun, "C",      execVolC1);

   witSetScenarioIndex    (theWitRun,           2);
   witSetProbability      (theWitRun,           0.1);
   witSetDemandShipVol    (theWitRun, "B", "D", shipVolD2);
d6093 15
a6107 1
   witSetScenarioIndex    (theWitRun,           1);
d6126 1
d6140 2
d6147 4
a6150 1
   witGetOperationExecVol (theWitRun,  "C",      & theFltVec);
d6152 6
a6157 2
   compareFltVecs                                 (theFltVec, zeroVec,   1);
   witFree                                        (theFltVec);
d6164 4
a6167 1
   witGetDemandShipVol   (theWitRun,   "B", "D", & theFltVec);
d6169 1
a6169 2
   compareFltVecs                                 (theFltVec, zeroVec,   1);
   witFree                                        (theFltVec);
d6171 2
a6172 1
   witGetOperationExecVol (theWitRun,  "C",      & theFltVec);
d6174 1
a6174 2
   compareFltVecs                                 (theFltVec, execVolC1, 1);
   witFree                                        (theFltVec);
d6181 6
a6186 1
   witGetDemandShipVol   (theWitRun,   "B", "D", & theFltVec);
d6188 2
a6189 2
   compareFltVecs                                 (theFltVec, shipVolD2, 1);
   witFree                                        (theFltVec);
@


1.217
log
@Stochastic Implosion
@
text
@d6083 1
d6085 1
a6085 1
   witInterpretDevCmd    (theWitRun,           "Allow stochastic implosion.");
d6087 3
a6089 3
   witSetStageByObject   (theWitRun,           WitTRUE);
   witSetNScenarios      (theWitRun,           3);
   witSetStochDataMode   (theWitRun,           WitTRUE);
d6091 3
a6093 3
   witSetScenarioIndex   (theWitRun,           0);
   witSetProbability     (theWitRun,           0.6);
   witSetDemandDemandVol (theWitRun, "B", "D", demandVolD0);
d6095 4
a6098 3
   witSetScenarioIndex   (theWitRun,           1);
   witSetProbabilityDbl  (theWitRun,           0.3);
   witSetDemandDemandVol (theWitRun, "B", "D", demandVolD1);
d6100 3
a6102 3
   witSetScenarioIndex   (theWitRun,           2);
   witSetProbability     (theWitRun,           0.1);
   witSetDemandShipVol   (theWitRun, "B", "D", shipVolD2);
d6104 1
a6104 1
   witSetScenarioIndex   (theWitRun,           1);
d6120 1
a6120 1
   float      shipVolD1[] =   {0.0};
d6122 1
d6141 5
d6153 6
a6158 1
   compareFltVecs                                 (theFltVec, shipVolD1, 1);
@


1.216
log
@Stochastic Implosion
@
text
@d6082 1
d6100 1
d6117 3
d6143 5
d6153 5
@


1.215
log
@Stochastic Implosion
@
text
@d6090 1
a6090 1
   witSetScenarioProb    (theWitRun,           0.6);
d6094 1
a6094 1
   witSetScenarioProbDbl (theWitRun,           0.3);
d6098 1
a6098 1
   witSetScenarioProb    (theWitRun,           0.1);
d6129 1
a6129 1
   witGetScenarioProbDbl (theWitRun, & theDbl);
d6134 1
a6134 1
   witGetScenarioProb    (theWitRun, & theFlt);
d6139 1
a6139 1
   witGetScenarioProbDbl (theWitRun, & theDbl);
@


1.214
log
@Stochastic Implosion
@
text
@d6087 1
a6087 1
   witSetStochasticMode  (theWitRun,           WitTRUE);
d6122 1
a6122 1
   witGetStochasticMode  (theWitRun, & theBool);
@


1.213
log
@Stochastic Implosion
@
text
@d6251 2
a6252 2
   witGetStochSolnAvail (theWitRun, & theBool);
   assert                         ( ! theBool);
d6254 1
a6254 1
   witStochImplode      (theWitRun);
d6256 4
a6259 2
   witGetStochSolnAvail (theWitRun, & theBool);
   assert                         ( ! theBool);
@


1.212
log
@Stochastic Implosion
@
text
@d6249 9
a6257 1
   witStochImplode (theWitRun);
@


1.211
log
@Stochastic Implosion
@
text
@d135 1
d6032 1
d6242 11
@


1.210
log
@Stochastic Implosion
@
text
@d6085 1
a6085 1
   witSetStochImpMode    (theWitRun,           WitTRUE);
d6120 1
a6120 1
   witGetStochImpMode    (theWitRun, & theBool);
@


1.209
log
@Stochastic Implosion
@
text
@d6078 2
a6079 1
   witInterpretDevCmd    (theWitRun, "Allow stochastic implosion.");
d6081 1
a6081 3
   witSetStageByObject   (theWitRun, WitTRUE);
   witSetNScenarios      (theWitRun, 3);
   witSetStochImpMode    (theWitRun, WitTRUE);
d6083 3
a6085 2
   witSetScenarioIndex   (theWitRun, 0);
   witSetScenarioProb    (theWitRun, 0.6);
d6087 3
a6089 2
   witSetScenarioIndex   (theWitRun, 1);
   witSetScenarioProbDbl (theWitRun, 0.3);
d6091 3
a6093 2
   witSetScenarioIndex   (theWitRun, 2);
   witSetScenarioProb    (theWitRun, 0.1);
d6095 4
a6098 1
   witSetScenarioIndex   (theWitRun, 1);
d6140 2
@


1.208
log
@Stochastic Implosion
@
text
@d6030 1
a6030 1
/* testStochCopyData  (theWitRun); */
d6169 2
d6179 2
a6202 1
   witInterpretDevCmd       (theWitRun2, "Allow stochastic implosion.");
d6204 1
d6216 2
d6226 2
@


1.207
log
@Stochastic Implosion
@
text
@d129 6
a134 4
void testStochImp     ();
void buildCoreProblem (WitRun *);
void specifyStochData (WitRun *);
void checkStochData   (WitRun *);
d6022 1
a6022 1
   witNewRun      (& theWitRun);
d6024 7
a6030 3
   buildCoreProblem (theWitRun);
   specifyStochData (theWitRun);
   checkStochData   (theWitRun);
d6032 1
a6032 1
   witDeleteRun     (theWitRun);
d6048 20
a6067 15
   witInitialize           (theWitRun);

   witSetNPeriods          (theWitRun, 1);

   witAddPart              (theWitRun, "A",      WitMATERIAL);
   witAddPart              (theWitRun, "B",      WitMATERIAL);
   witAddOperation         (theWitRun, "C");
   witAddBomEntry          (theWitRun, "C", "A");
   witAddBopEntry          (theWitRun, "C", "B");
   witAddDemand            (theWitRun, "B", "D");

   witSetPartSupplyVol     (theWitRun, "A",      supplyVolA);
   witSetDemandDemandVol   (theWitRun, "B", "D", demandVolD);
   witSetOperationExecCost (theWitRun, "C",      execCostC);
   witSetDemandShipReward  (theWitRun, "B", "D", shipRewardD);
d6083 7
d6091 3
a6093 2
   witSetScenarioProb    (theWitRun, 0.4);
   witSetScenarioProbDbl (theWitRun, 0.5);
d6119 6
a6124 1
   assert                             (theInt == 2);
d6126 1
d6128 4
d6134 88
a6221 2
   assert (fabs (theFlt - 0.5) < dblEps);
   assert (fabs (theDbl - 0.5) < dblEps);
@


1.206
log
@Stochastic Implosion
@
text
@d129 4
a132 1
void testStochImp ();
d136 7
a142 6
witBoolean equalStrings   (const char *,   const char *);
void       compareIntVecs (const int *,    const int *,    int);
void       compareFltVecs (const float *,  const float *,  int);
void       compareDblVecs (const double *, const double *, int);
void       printFltVec    (const char *,   const float *,  int);
void       printDblVec    (const char *,   const double *, int);
a343 2
   witBoolean devMode;

d357 1
a357 4

   witGetDevMode (theWitRun, & devMode);

   if (devMode)
d6015 10
a6024 10
   WitRun *   theWitRun;
   witBoolean devMode;
   float      supplyVolA [] = {500.0};
   float      demandVolD [] = {300.0};
   float      execCostC  [] =   {1.0};
   float      shipRewardD[] =   {5.0};
   witBoolean theBool;
   int        theInt;
   float      theFlt;
   double     theDbl;
d6026 2
a6027 2
   witNewRun             (& theWitRun);
   witGetDevMode           (theWitRun, & devMode);
d6029 5
a6033 3
   if (! devMode)
      {
      witDeleteRun         (theWitRun);
d6035 6
a6040 2
      return;
      }
a6042 1
   witInterpretDevCmd      (theWitRun, "Allow stochastic implosion.");
d6057 41
d6099 5
a6103 20
   witSetStageByObject     (theWitRun,           WitTRUE);
   witGetStageByObject     (theWitRun,         & theBool);
   assert                                       (theBool);

   witSetNScenarios        (theWitRun,           3);
   witGetNScenarios        (theWitRun,         & theInt);
   assert                                       (theInt == 3);

   witSetStochImpMode      (theWitRun,           WitTRUE);
   witGetStochImpMode      (theWitRun,         & theBool);
   assert                                       (theBool);

   witSetScenarioIndex     (theWitRun,           2);
   witGetScenarioIndex     (theWitRun,         & theInt);
   assert                                       (theInt == 2);

   witSetScenarioProb      (theWitRun,           0.4);
   witSetScenarioProbDbl   (theWitRun,           0.5);
   witGetScenarioProb      (theWitRun,         & theFlt);
   witGetScenarioProbDbl   (theWitRun,         & theDbl);
a6106 2

   witDeleteRun            (theWitRun);
d6225 19
@


1.205
log
@Stochastic Implosion
@
text
@d6070 4
a6073 4
   witSetProbability       (theWitRun,           0.4);
   witSetProbabilityDbl    (theWitRun,           0.5);
   witGetProbability       (theWitRun,         & theFlt);
   witGetProbabilityDbl    (theWitRun,         & theDbl);
@


1.204
log
@[disallowed scrap]
@
text
@d129 2
d2529 1
d6009 73
@


1.203
log
@[disallowed backlog]
@
text
@d597 1
d628 2
d696 4
@


1.202
log
@Added a length argument to some vector utility functions.
@
text
@d127 1
a127 1
void testBacklogAllowed ();
d2519 1
a2519 1
   testBacklogAllowed  ();
d5952 1
a5952 1
/* testBacklogAllowed                                                         */
d5954 1
a5954 1
/* Test of WIT with backlogAllowed = FALSE                                    */
d5957 1
a5957 1
void testBacklogAllowed ()
d5962 1
a5962 1
   witBoolean backlogAllowedB;
d5967 2
a5968 2
   witNewRun                (& theWitRun);
   witInitialize              (theWitRun);
d5970 1
a5970 1
   witSetNPeriods             (theWitRun, 2);
d5972 2
a5973 2
   witAddPart                 (theWitRun, "A",        WitCAPACITY );
   witAddDemand               (theWitRun, "A", "B");
d5975 5
a5979 5
   witSetPartSupplyVol        (theWitRun, "A",        supplyVolA);
   witSetDemandDemandVol      (theWitRun, "A", "B",   demandVolB);
   witSetDemandBacklogAllowed (theWitRun, "A", "B",   WitFALSE);
   witGetDemandBacklogAllowed (theWitRun, "A", "B", & backlogAllowedB);
   assert                                          (! backlogAllowedB);
d5981 1
a5981 1
   witHeurImplode             (theWitRun);
d5983 1
a5983 1
   witGetDemandShipVol        (theWitRun, "A", "B", & shipVolB);
d5985 2
a5986 2
   printFltVec                ("B.shipVol",           shipVolB,  2);
   witFree                                           (shipVolB);
d5988 3
a5990 3
   witSetUseFocusHorizons     (theWitRun,             WitFALSE);
   witSetDemandFssShipVol     (theWitRun, "A", "B",   fssShipVolB);
   witGetPartFocusShortageVol (theWitRun, "A",      & shortVolA);
d5992 2
a5993 2
   printFltVec                ("A.shortVol",          shortVolA, 2);
   witFree                                           (shortVolA);
d5995 1
a5995 1
   witDeleteRun               (theWitRun);
@


1.201
log
@[disallowed backlog]
@
text
@d132 5
a136 9
void       compareIntVecs (const int *,    const int *);
void       compareFltVecs (const float *,  const float *);
void       compareDblVecs (const double *, const double *);
void       printIntVec    (const char *,   const int *);
void       printFltVec    (const char *,   const float *);
void       printDblVec    (const char *,   const double *);

void       printFltVecVar (const char *,   const float *, int);

d607 2
a608 1
   witSetPartStockBoundsDbl( theWitRun, "PS1", NULL, stockBoundsSLDbl,stockBoundsHUDbl);
d610 3
a612 3
   compareDblVecs( hlb, defaultBoundsHLDbl );
   compareDblVecs( slb, stockBoundsSLDbl );
   compareDblVecs( hub, stockBoundsHUDbl );
d632 3
a634 3
   compareFltVecs( hlb, prodBoundsHL );
   compareFltVecs( slb, prodBoundsSL );
   compareFltVecs( hub, defaultBoundsHU );
d645 3
a647 3
   compareFltVecs( hlb, defaultBoundsHL );
   compareFltVecs( slb, stockBoundsSL );
   compareFltVecs( hub, stockBoundsHU );
d656 1
a656 1
   compareIntVecs( my_yield, yield );
d664 1
a664 1
   compareFltVecs( fv, minLotSize );
d668 1
a668 1
   compareFltVecs( fv, incLotSize );
d672 1
a672 1
   compareFltVecs( fv, cycle );
d718 1
a718 1
   compareIntVecs (iv, buildAheadUB);
d808 1
a808 1
   compareFltVecs( fv, supplyVol );
d828 1
a828 1
   compareFltVecs( fv, supplyVol );
d833 1
a833 1
   compareDblVecs (dv, supplyVolDbl);
d853 1
a853 1
   compareFltVecs( fv, supplyVol );
d871 1
a871 1
   compareFltVecs( fv, supplyVol );
d938 1
a938 1
   compareFltVecs( fv, demandVol );
d942 1
a942 1
   compareDblVecs( dv, demandVolDbl );
d946 1
a946 1
   compareFltVecs( fv, fssShipVol );
d950 1
a950 1
   compareDblVecs( dv, fssShipVolDbl );
d962 3
a964 3
   compareDblVecs( hlb, cumShipBoundsHLDbl );
   compareDblVecs( slb, cumShipBoundsSLDbl );
   compareDblVecs( hub, cumShipBoundsHUDbl );
d979 3
a981 3
   compareFltVecs( hlb, cumShipBoundsHL );
   compareFltVecs( slb, cumShipBoundsSL );
   compareFltVecs( hub, cumShipBoundsHU );
d1008 1
a1008 1
   compareIntVecs (iv, buildAheadUB);
d1034 1
a1034 1
   compareIntVecs (iv, shipLateUB);
d1155 1
a1155 1
     compareFltVecs( off, offset );
d1169 1
a1169 1
     compareDblVecs( off, offsetDbl );
d1254 1
a1254 1
   compareFltVecs (consRate, goodConsRate);
d1265 1
a1265 1
   compareDblVecs (consRateDbl, goodConsRateDbl);
d1276 1
a1276 1
   compareFltVecs (routingShare, goodRoutingShare);
d1287 1
a1287 1
   compareDblVecs (routingShareDbl, goodRoutingShareDbl);
d1323 1
a1323 1
   compareIntVecs (impactPeriod, correctImpactPeriod);
d1484 1
a1484 1
   compareFltVecs (consRate, goodConsRate);
d1495 1
a1495 1
   compareDblVecs (consRateDbl, goodConsRateDbl);
d1506 1
a1506 1
   compareFltVecs (routingShare, goodRoutingShare);
d1518 1
a1518 1
   compareDblVecs (routingShareDbl, goodRoutingShareDbl);
d1549 1
a1549 1
   compareIntVecs (impactPeriod, correctImpactPeriod);
d1642 1
a1642 1
   compareFltVecs( fv, prodVol );
d1647 1
a1647 1
   compareFltVecs( fv, shipVol );
d1652 1
a1652 1
   compareDblVecs( dv, shipVolDbl );
d1657 1
a1657 1
   compareFltVecs( fv, subVol1 );
d1662 1
a1662 1
   compareFltVecs( fv, subVol );
d1667 1
a1667 1
   compareDblVecs( dv, subVolDbl );
d1816 1
a1816 1
      printFltVec ("focusedShortage", focShortVol[i] );
d1838 1
a1838 1
      printFltVec ("focusedShortage", focShortVol[i] );
d1857 1
a1857 1
      printDblVec ("focusedShortage", focShortVol[i] );
d1871 1
a1871 1
   printFltVec ("ConsVol", fv);
d1875 1
a1875 1
   printDblVec ("ConsVol", dv);
d1879 1
a1879 1
   printFltVec ("ResidualVol", fv);
d1883 1
a1883 1
   printDblVec ("ResidualVol", dv);
d1887 1
a1887 1
   printFltVec ("ExcessVol", fv);
d1891 1
a1891 1
   printDblVec ("ExcessVol", dv);
d1895 1
a1895 1
   printFltVec ("ProdVol", fv);
d1899 1
a1899 1
   printDblVec ("ProdVol", dv);
d1903 1
a1903 1
   printFltVec ("ScrapVol", fv);
d1907 1
a1907 1
   printDblVec ("ScrapVol", dv);
d1911 1
a1911 1
   printFltVec ("ShadowPrice", fv);
d1915 1
a1915 1
   printDblVec ("ShadowPrice", dv);
d1919 1
a1919 1
   printFltVec ("FocusShortageVol", fv);
d1923 1
a1923 1
   printDblVec ("FocusShortageVol", dv);
d1927 1
a1927 1
   printFltVec ("FssExecVol", fv);
d1931 1
a1931 1
   printDblVec ("FssExecVol", dv);
d1935 1
a1935 1
   printFltVec ("FssSubVol", fv);
d1939 1
a1939 1
   printDblVec ("FssSubVol", dv);
d1943 1
a1943 1
   printFltVec ("StockVol", fv);
d1947 1
a1947 1
   printDblVec ("StockVol", dv);
d1951 1
a1951 1
   printFltVec ("SupplyVol", fv);
d1960 1
a1960 1
   printFltVec ("ShipVol", fv);
d1968 1
a1968 1
   printFltVec ("ProdVol", fv);
d2017 1
a2017 1
   printFltVec ("ReqVol", fv);
d2021 1
a2021 1
   printDblVec ("ReqVol", dv);
d2025 1
a2025 1
   printFltVec ("MrpProdVol", fv);
d2029 1
a2029 1
   printFltVec ("MrpResidualVol", fv);
d2033 1
a2033 1
   printDblVec ("MrpResidualVol", dv);
d2037 1
a2037 1
   printFltVec ("MrpExcessVol", fv);
d2041 1
a2041 1
   printDblVec ("MrpExcessVol", dv);
d2045 1
a2045 1
   printFltVec ("MrpConsVol", fv);
d2049 1
a2049 1
   printDblVec ("MrpConsVol", dv);
d2053 1
a2053 1
   printFltVec ("MrpExecVol", fv);
d2057 1
a2057 1
   printDblVec ("MrpExecVol", dv);
d2061 1
a2061 1
   printFltVec ("MrpSubVol", fv);
d2065 1
a2065 1
   printDblVec ("MrpSubVol", dv);
d2148 1
a2148 1
   compareFltVecs( cost, obj1ProdCost );
d2155 1
a2155 1
   compareFltVecs( cost, scrapCost );
d2162 1
a2162 1
   compareDblVecs( cost, scrapCostDbl );
d2169 1
a2169 1
   compareFltVecs( cost, scrapCost );
d2176 1
a2176 1
   compareDblVecs( cost, scrapCostDbl );
d2183 1
a2183 1
   compareFltVecs( cost, stockCost );
d2190 1
a2190 1
   compareDblVecs( cost, stockCostDbl );
d2197 1
a2197 1
   compareFltVecs( cost, stockCost );
d2204 1
a2204 1
   compareDblVecs( cost, stockCostDbl );
d2214 1
a2214 1
   compareIntVecs (propRtgGet, propRtgSet);
d2274 1
a2274 1
   compareFltVecs( fv, shipRewardPS1US );
d2278 1
a2278 1
   compareDblVecs( dv, shipRewardDblPS1US );
d2282 1
a2282 1
   compareFltVecs( fv, shipRewardPS1US );
d2286 1
a2286 1
   compareDblVecs( dv, shipRewardDblPS1US );
d2290 1
a2290 1
   compareFltVecs( fv, cumShipRewardPS1US );
d2294 1
a2294 1
   compareDblVecs( dv, cumShipRewardDblPS1US );
d2298 1
a2298 1
   compareFltVecs( fv, cumShipRewardPS1US );
d2302 1
a2302 1
   compareDblVecs( dv, cumShipRewardDblPS1US );
d2336 1
a2336 1
   compareIntVecs (propRtgGet, propRtgSet);
d2370 1
a2370 1
   compareFltVecs( fv, subCostCompA );
d2377 1
a2377 1
   compareDblVecs( dv, subCostDblCompA );
d2384 1
a2384 1
   compareFltVecs( fv, subCostCompA );
d2391 1
a2391 1
   compareDblVecs( dv, subCostDblCompA );
d2398 1
a2398 1
   compareFltVecs( fv, offsetCompA );
d2405 1
a2405 1
   compareDblVecs( dv, offsetDblCompA );
d2586 3
a2588 3
   compareDblVecs(hlb,hlb1);
   compareDblVecs(slb,slb1);
   compareDblVecs(hub,hub1);
d2605 3
a2607 3
   compareFltVecs(hlb,hlb1);
   compareFltVecs(slb,slb1);
   compareFltVecs(hub,hub1);
d2638 1
a2638 1
   compareDblVecs(dblVec,dblVec1);
d2651 1
a2651 1
   compareFltVecs(fltVec,fltVec1);
d2674 1
a2674 1
   compareFltVecs(fltVec,fltVec1);
d2688 1
a2688 1
   compareDblVecs(dblVec,dblVec1);
d2702 1
a2702 1
   compareFltVecs(fltVec,fltVec1);
d2715 1
a2715 1
   compareDblVecs(dblVec,dblVec1);
d2728 1
a2728 1
   compareFltVecs(fltVec,fltVec1);
d2741 1
a2741 1
   compareDblVecs(dblVec,dblVec1);
d2754 1
a2754 1
   compareFltVecs(fltVec,fltVec1);
d2767 1
a2767 1
   compareDblVecs(dblVec,dblVec1);
d2780 1
a2780 1
   compareFltVecs(fltVec,fltVec1);
d2793 1
a2793 1
   compareDblVecs(dblVec,dblVec1);
d2808 1
a2808 1
   compareFltVecs (fltVec, fltVec1);
d2814 1
a2814 1
   compareFltVecs (fltVec, fltVec1);
d2829 1
a2829 1
   compareDblVecs (dblVec, dblVec1);
d2835 1
a2835 1
   compareDblVecs (dblVec, dblVec1);
d2877 3
a2879 3
   compareFltVecs (witYieldRate,    trueYieldRate1);
   compareDblVecs (witYieldRateDbl, trueYieldRateDbl1);
   compareIntVecs (witYield,        trueYield1);
d2889 2
a2890 2
   compareIntVecs (witYield,        trueYield2);
   compareFltVecs (witYieldRate,    trueYieldRate2);
d2918 1
a2918 1
   compareIntVecs (executable, correctExecutable);
d3050 1
a3050 1
   compareFltVecs(fltVec,fltVec1);
d3063 1
a3063 1
   compareDblVecs(dblVec,dblVec1);
d3081 1
a3081 1
   compareFltVecs (productRateRet, productRateEnt);
d3106 1
a3106 1
   compareDblVecs (productRateDblRet, productRateDblEnt);
d3141 1
a3141 1
   compareFltVecs (routingShare, goodRoutingShare);
d3155 1
a3155 1
   compareDblVecs (routingShareDbl, goodRoutingShareDbl);
d3190 1
a3190 1
   compareIntVecs (impactPeriod, correctImpactPeriod);
d5985 1
a5985 1
   printFltVecVar             ("B.shipVol",           shipVolB,  2);
d5992 1
a5992 1
   printFltVecVar             ("A.shortVol",          shortVolA, 2);
d6041 1
a6041 1
void compareIntVecs (const int * theIntVec1, const int *theIntVec2)
d6043 1
a6043 1
   int thePer;
d6045 2
a6046 2
   for (thePer = 0; thePer < nPeriods; thePer ++) 
      assert (theIntVec1[thePer] == theIntVec2[thePer]);
d6055 4
a6058 1
void compareFltVecs (const float * theFltVec1, const float *theFltVec2)
d6060 1
a6060 1
   int thePer;
d6062 2
a6063 2
   for (thePer = 0; thePer < nPeriods; thePer ++) 
      assert (fabs (theFltVec1[thePer] - theFltVec2[thePer]) < dblEps);
d6072 4
a6075 1
void compareDblVecs (const double * theDblVec1, const double *theDblVec2)
d6077 1
a6077 1
   int thePer;
d6079 2
a6080 18
   for (thePer = 0; thePer < nPeriods; thePer ++) 
      assert (fabs (theDblVec1[thePer] - theDblVec2[thePer]) < dblEps);
   }

/*----------------------------------------------------------------------------*/
/* Function printIntVec.                                                      */
/*----------------------------------------------------------------------------*/

void printIntVec (const char * attrName, const int * theIntVec)
   {
   int thePer;

   printf ("%s = ", attrName);

   for (thePer = 0; thePer < nPeriods; thePer ++)
      printf (" %d", theIntVec[thePer]);

   printf ("\n");
d6087 1
a6087 1
void printFltVec (const char * attrName, const float * theFltVec)
d6089 1
a6089 1
   int thePer;
d6093 2
a6094 2
   for (thePer = 0; thePer < nPeriods; thePer ++)
      printf (" %f", theFltVec[thePer]);
d6103 1
a6103 1
void printDblVec (const char * attrName, const double * theDblVec)
d6105 1
a6105 1
   int thePer;
d6109 2
a6110 18
   for (thePer = 0; thePer < nPeriods; thePer ++)
      printf (" %f", theDblVec[thePer]);

   printf ("\n");
   }

/*----------------------------------------------------------------------------*/
/* Function printFltVecVar.                                                   */
/*----------------------------------------------------------------------------*/

void printFltVecVar (const char * attrName, const float * theFltVec, int nPers)
   {
   int thePer;

   printf ("%s = ", attrName);

   for (thePer = 0; thePer < nPers; thePer ++)
      printf (" %f", theFltVec[thePer]);
@


1.200
log
@[disallowed backlog]
@
text
@a928 7
   witSetDemandBacklogAllowed (theWitRun, "PS1", "US",   WitFALSE);
   witGetDemandBacklogAllowed (theWitRun, "PS1", "US", & bool);

   assert (! bool);

   witSetDemandBacklogAllowed (theWitRun, "PS1", "US",   WitTRUE);

d5962 7
a5968 6
   WitRun * theWitRun;
   float    supplyVolA [] = {100.0, 400.0};
   float    demandVolB [] = {200.0, 200.0};
   float *  shipVolB;
   float    fssShipVolB[] = {700.0, 700.0};
   float *  shortVolA;
d5981 2
@


1.199
log
@Fixed a bug in external opt implosion for non-development builds.
@
text
@d127 2
d139 2
d2529 1
d5962 44
d6131 16
@


1.198
log
@[disallowed backlog]
@
text
@a5471 1
   witBoolean devMode;
a5475 9
   witGetDevMode          (theWitRun, & devMode);

   if (! devMode)
      {
      witDeleteRun        (theWitRun);

      return;
      }

@


1.197
log
@witCopy<Object>Data
@
text
@d925 7
@


1.196
log
@witCopy<Object>Data
@
text
@d124 2
a125 1
void testCopyObjData1WR ();
d2515 4
a2518 5
   testExtOpt ();

   testCopyObjData1WR ();

   testMultiThread ();
d5895 65
@


1.195
log
@External opt implosion.
@
text
@d124 2
d2516 2
d5837 58
@


1.194
log
@External opt implosion.
@
text
@d5609 1
a5609 1
   witGetExtOptIntVars (
@


1.193
log
@External opt implosion.
@
text
@d5497 6
@


1.192
log
@External Optimizing Implosion
@
text
@d5559 1
a5559 1
   witSetExtOptColSol (theWitRun, collb);
d5587 2
a5588 2
   int *    intIndices;
   int      numIntCols;
d5603 1
a5603 1
   witGetExtOptIntIndices (
d5605 2
a5606 2
      & intIndices,
      & numIntCols);
d5608 1
a5608 1
   witSetExtOptColSolDbl (theWitRun, collb);
d5618 1
a5618 1
   witFree (intIndices);
@


1.191
log
@external opt implosion.
@
text
@d115 8
a122 8
void testExtOpt            ();
void buildExtOptProblem    (WitRun *);
void testGetExtOptProb     (WitRun *);
void testGetExtOptProbDbl  (WitRun *);
void testGetConIndices     (WitRun *);
void testGetVarIndices     (WitRun *);
void testGetSlbvVarIndices (WitRun *);
void testGetSlbConIndices  (WitRun *);
d5464 1
a5464 1
   witNewRun           (& theWitRun);
d5466 1
a5466 1
   witGetDevMode         (theWitRun, & devMode);
d5470 1
a5470 1
      witDeleteRun       (theWitRun);
d5475 1
a5475 1
   buildExtOptProblem    (theWitRun);
d5477 2
a5478 2
   witGetExtOptActive    (theWitRun, & extOptActive);
   assert                           (! extOptActive);
d5480 1
a5480 1
   witStartExtOpt        (theWitRun);
d5482 2
a5483 2
   witGetExtOptActive    (theWitRun, & extOptActive);
   assert                             (extOptActive);
d5485 6
a5490 6
   testGetExtOptProb     (theWitRun);
   testGetExtOptProbDbl  (theWitRun);
   testGetConIndices     (theWitRun);
   testGetVarIndices     (theWitRun);
   testGetSlbvVarIndices (theWitRun);
   testGetSlbConIndices  (theWitRun);
d5492 1
a5492 1
   witFinishExtOpt       (theWitRun);
d5494 2
a5495 2
   witGetExtOptActive    (theWitRun, & extOptActive);
   assert                           (! extOptActive);
d5497 1
a5497 1
   witDeleteRun          (theWitRun);
d5530 1
a5530 1
/* testGetExtOptProb                                                          */
d5533 1
a5533 1
void testGetExtOptProb (WitRun * theWitRun)
a5544 3
   int *   intIndices;
   int     numIntCols;
   float   objSense;
d5546 1
a5546 1
   witGetExtOptProb (
d5557 1
a5557 4
      & rowub,
      & intIndices,
      & numIntCols,
      & objSense);
a5568 1
   witFree (intIndices);
d5572 1
a5572 1
/* testGetExtOptProbDbl                                                       */
d5575 1
a5575 1
void testGetExtOptProbDbl (WitRun * theWitRun)
a5588 1
   double   objSense;
d5590 1
a5590 1
   witGetExtOptProbDbl (
d5601 4
a5604 1
      & rowub,
d5606 1
a5606 2
      & numIntCols,
      & objSense);
@


1.190
log
@External opt implosion.
@
text
@d2409 2
a2410 2
   witSetAllowIntCons           (theObj1Run,                WitTRUE);
   witGetAllowIntCons           (theObj1Run,              & theBool);
@


1.189
log
@External opt implosion.
@
text
@d2409 2
a2410 2
   witSetEnforceIntCons         (theObj1Run,                WitTRUE);
   witGetEnforceIntCons         (theObj1Run,              & theBool);
@


1.188
log
@External opt implosion.
@
text
@d2409 5
@


1.187
log
@External opt implosion.
@
text
@a5459 1
   witInitialize         (theWitRun);
d5506 2
d5517 1
a5518 1

@


1.186
log
@External opt implosion.
@
text
@d116 1
d122 1
a5457 2
   float      offset[]   = {2.0, 2.0, 2.0};
   float      execSlb [] = {3.0, 4.0, 5.0};
d5471 1
a5471 13
   witSetNPeriods        (theWitRun,        3);

   witAddPart            (theWitRun,   "A", WitMATERIAL);
   witAddPart            (theWitRun,   "B", WitMATERIAL);
   witAddOperation       (theWitRun,   "C");
   witAddBomEntry        (theWitRun,   "C", "A");
   witAddBopEntry        (theWitRun,   "C", "B");
   witAddSubsBomEntry    (theWitRun,   "C",  0, "A");
   witAddDemand          (theWitRun,   "B", "D");
   witSetBomEntryOffset  (theWitRun,   "C",  0, offset);

   witSetOperationExecBounds (
                          theWitRun,   "C",     NULL, execSlb, NULL);
a5482 1

d5486 1
d5497 27
d5763 61
@


1.185
log
@External opt implosion.
@
text
@d115 6
a120 5
void testExtOpt           ();
void testGetExtOptProb    (WitRun *);
void testGetExtOptProbDbl (WitRun *);
void testGetConIndices    (WitRun *);
void testGetVarIndices    (WitRun *);
d5456 2
a5457 1
   float      offset[] = {2.0, 2.0, 2.0, 2.0};
d5459 2
a5460 2
   witNewRun          (& theWitRun);
   witInitialize        (theWitRun);
d5462 1
a5462 1
   witGetDevMode        (theWitRun, & devMode);
d5466 1
a5466 1
      witDeleteRun      (theWitRun);
d5471 10
a5480 1
   witSetNPeriods       (theWitRun,        3);
d5482 2
a5483 8
   witAddPart           (theWitRun,   "A", WitMATERIAL);
   witAddPart           (theWitRun,   "B", WitMATERIAL);
   witAddOperation      (theWitRun,   "C");
   witAddBomEntry       (theWitRun,   "C", "A");
   witAddBopEntry       (theWitRun,   "C", "B");
   witAddSubsBomEntry   (theWitRun,   "C",  0, "A");
   witAddDemand         (theWitRun,   "B", "D");
   witSetBomEntryOffset (theWitRun,   "C",  0, offset);
d5485 2
a5486 2
   witGetExtOptActive   (theWitRun, & extOptActive);
   assert                          (! extOptActive);
d5488 1
a5488 1
   witStartExtOpt       (theWitRun);
d5490 2
a5491 2
   witGetExtOptActive   (theWitRun, & extOptActive);
   assert                            (extOptActive);
d5493 2
a5494 2
   testGetExtOptProb    (theWitRun);
   testGetExtOptProbDbl (theWitRun);
d5496 3
a5498 2
   testGetConIndices    (theWitRun);
   testGetVarIndices    (theWitRun);
d5500 1
a5500 1
   witFinishExtOpt      (theWitRun);
d5502 2
a5503 2
   witGetExtOptActive   (theWitRun, & extOptActive);
   assert                          (! extOptActive);
d5505 1
a5505 1
   witDeleteRun         (theWitRun);
d5732 19
@


1.184
log
@External opt implosion.
@
text
@d5455 1
d5478 1
d5629 1
a5629 1
   witGetBomEntrySubConIndex (theWitRun, "C", 0, 2, & conIndex);
d5636 1
a5636 1
      "   Period:    2\n"
d5701 1
a5701 1
   witGetBomEntryNonSubVarIndex (theWitRun, "C", 0, 1, & varIndex);
d5708 1
a5708 1
      "   Period:    1\n"
@


1.183
log
@External opt implosion.
@
text
@d5604 1
a5604 1
   int rowIndex;
d5606 1
a5606 1
   witGetPartResourceConIndex (theWitRun, "A", 2, & rowIndex);
d5610 5
a5614 5
      "Resource Allocation Constraint:\n"
      "   Part:       A\n"
      "   Period:     2\n"
      "   Row Index: %2d\n",
      rowIndex);
d5616 1
a5616 1
   witGetDemandShipConIndex (theWitRun, "B", "D", 1, & rowIndex);
d5620 6
a5625 6
      "Shipment Cumulation Constraint:\n"
      "   Part:       B\n"
      "   Demand:     D\n"
      "   Period:     1\n"
      "   Row Index: %2d\n",
      rowIndex);
d5627 1
a5627 1
   witGetBomEntrySubConIndex (theWitRun, "C", 0, 2, & rowIndex);
d5631 6
a5636 6
      "Substitution Constraint:\n"
      "   Operation:  C\n"
      "   BOM Entry:  0\n"
      "   Period:     2\n"
      "   Row Index: %2d\n",
      rowIndex);
d5645 1
a5645 1
   int colIndex;
d5647 1
a5647 1
   witGetOperationExecVarIndex (theWitRun, "C", 1, & colIndex);
d5651 5
a5655 5
      "Execution Variable:\n"
      "   Operation:  C\n"
      "   Period:     1\n"
      "   Col Index: %2d\n",
      colIndex);
d5657 1
a5657 1
   witGetPartScrapVarIndex (theWitRun, "A", 2, & colIndex);
d5661 5
a5665 5
      "Scrap Variable:\n"
      "   Part:       A\n"
      "   Period:     2\n"
      "   Col Index: %2d\n",
      colIndex);
d5667 1
a5667 1
   witGetPartStockVarIndex (theWitRun, "B", 0, & colIndex);
d5671 5
a5675 5
      "Stock Variable:\n"
      "   Part:       B\n"
      "   Period:     0\n"
      "   Col Index: %2d\n",
      colIndex);
d5677 1
a5677 1
   witGetDemandShipVarIndex (theWitRun, "B", "D", 0, & colIndex);
d5681 6
a5686 6
      "Shipment Variable:\n"
      "   Part:       B\n"
      "   Demand:     D\n"
      "   Period:     0\n"
      "   Col Index: %2d\n",
      colIndex);
d5688 1
a5688 1
   witGetDemandCumShipVarIndex (theWitRun, "B", "D", 2, & colIndex);
d5692 6
a5697 6
      "Cumulative Shipment Variable:\n"
      "   Part:       B\n"
      "   Demand:     D\n"
      "   Period:     2\n"
      "   Col Index: %2d\n",
      colIndex);
d5699 1
a5699 1
   witGetBomEntryNonSubVarIndex (theWitRun, "C", 0, 1, & colIndex);
d5703 6
a5708 6
      "Non-Substitution Variable:\n"
      "   Operation:  C\n"
      "   BOM Entry:  0\n"
      "   Period:     1\n"
      "   Col Index: %2d\n",
      colIndex);
d5710 1
a5710 1
   witGetSubsBomEntrySubVarIndex (theWitRun, "C", 0, 0, 2, & colIndex);
d5714 1
a5714 1
      "Substitution Variable:\n"
d5719 2
a5720 2
      "   Col Index: %2d\n",
      colIndex);
@


1.182
log
@External opt implosion.
@
text
@d5717 1
a5717 1
      "   SubStitute: 0\n"
@


1.181
log
@External opt implosion.
@
text
@d114 7
a120 1
void testExtOpt ();
a5454 21
   int        numcols;
   int        numrows;
   int *      start;
   int *      index;
   float *    value;
   float *    collb;
   float *    colub;
   float *    obj;
   float *    rowlb;
   float *    rowub;
   double *   valueDbl;
   double *   collbDbl;
   double *   colubDbl;
   double *   objDbl;
   double *   rowlbDbl;
   double *   rowubDbl;
   int *      intIndices;
   int        numIntCols;
   float      objSense;
   double     objSenseDbl;
   int        rowIndex;
d5456 2
a5457 2
   witNewRun         (& theWitRun);
   witInitialize       (theWitRun);
d5459 1
a5459 1
   witGetDevMode       (theWitRun, & devMode);
d5463 1
a5463 1
      witDeleteRun     (theWitRun);
d5468 17
a5484 1
   witAddPart          (theWitRun,   "A", WitMATERIAL);
d5486 2
a5487 2
   witGetExtOptActive  (theWitRun, & extOptActive);
   assert                         (! extOptActive);
d5489 2
a5490 1
   witStartExtOpt      (theWitRun);
d5492 27
a5518 2
   witGetExtOptActive  (theWitRun, & extOptActive);
   assert                           (extOptActive);
d5547 21
d5575 6
a5580 6
      & valueDbl,
      & collbDbl,
      & colubDbl,
      & objDbl,
      & rowlbDbl,
      & rowubDbl,
d5583 1
a5583 1
      & objSenseDbl);
d5585 1
a5585 1
   witSetExtOptColSolDbl (theWitRun, collbDbl);
d5589 6
a5594 6
   witFree (valueDbl);
   witFree (collbDbl);
   witFree (colubDbl);
   witFree (objDbl);
   witFree (rowlbDbl);
   witFree (rowubDbl);
d5596 5
d5602 5
a5606 1
   witGetPartResourceConIndex (theWitRun,"A", 12, & rowIndex);
d5612 1
a5612 1
      "   Period:    12\n"
d5616 1
a5616 1
   witFinishExtOpt            (theWitRun);
d5618 24
a5641 2
   witGetExtOptActive         (theWitRun, & extOptActive);
   assert                                (! extOptActive);
d5643 78
a5720 1
   witDeleteRun               (theWitRun);
@


1.180
log
@External opt implosion.
@
text
@d5441 1
a5441 1
/* Tests external opt implosion.                                              */
d5469 1
d5485 1
a5485 1
   witGetExtOptActive (theWitRun, & extOptActive);
d5488 1
a5488 1
   witStartExtOpt     (theWitRun);
d5490 1
a5490 1
   witGetExtOptActive (theWitRun, & extOptActive);
d5549 1
a5549 1
   witFinishExtOpt    (theWitRun);
d5551 7
a5557 2
   witGetExtOptActive (theWitRun, & extOptActive);
   assert                        (! extOptActive);
d5559 6
a5564 1
   witDeleteRun       (theWitRun);
@


1.179
log
@External opt implosion.
@
text
@d5492 1
a5492 1
   witGetExtOptProblem (
d5508 1
a5508 1
   witSetExtOptColSolution (theWitRun, collb);
d5520 1
a5520 1
   witGetExtOptProblemDbl (
d5536 1
a5536 1
   witSetExtOptColSolutionDbl (theWitRun, collbDbl);
@


1.178
log
@External opt implosion.
@
text
@d114 1
a114 1
void testAppConOptImp ();
d2498 1
a2498 1
   testAppConOptImp ();
d5439 1
a5439 1
/* Function testAppConOptImp.                                                 */
d5441 1
a5441 1
/* Tests app controlled opt implosion.                                        */
d5444 1
a5444 1
void testAppConOptImp ()
d5492 1
a5492 1
   witGetOptProblem (
d5508 2
d5520 1
a5520 1
   witGetOptProblemDbl (
d5536 2
@


1.177
log
@External opt implosion.
@
text
@d2400 2
a2401 2
   witSetOperationIntConExecVols   (theObj1Run, "PS1",         WitTRUE);
   witGetOperationIntConExecVols   (theObj1Run, "PS1",       & theBool);
d2405 2
a2406 2
   witSetSubsBomEntryIntConSubVols (theObj1Run, "PS1", 0, 0,   WitTRUE);
   witGetSubsBomEntryIntConSubVols (theObj1Run, "PS1", 0, 0, & theBool);
d2410 2
a2411 2
   witSetDemandIntConShipVols      (theObj1Run, "PS1", "US",    WitTRUE);
   witGetDemandIntConShipVols      (theObj1Run, "PS1", "US",  & theBool);
@


1.176
log
@External opt implosion.
@
text
@d5448 1
a5448 1
   witBoolean asstOptActive;
d5484 2
a5485 2
   witGetAsstOptActive (theWitRun, & asstOptActive);
   assert                         (! asstOptActive);
d5487 1
a5487 1
   witStartAsstOpt     (theWitRun);
d5489 2
a5490 2
   witGetAsstOptActive (theWitRun, & asstOptActive);
   assert                           (asstOptActive);
d5544 1
a5544 1
   witFinishAsstOpt    (theWitRun);
d5546 2
a5547 2
   witGetAsstOptActive (theWitRun, & asstOptActive);
   assert                         (! asstOptActive);
d5549 1
a5549 1
   witDeleteRun        (theWitRun);
@


1.175
log
@Assisted opt implosion.
@
text
@d5544 1
a5544 2
   if (optImpAllowed)
      witSolveOptProblem (theWitRun);
d5546 2
a5547 1
   witFinishAsstOpt      (theWitRun);
d5549 1
a5549 4
   witGetAsstOptActive   (theWitRun, & asstOptActive);
   assert                           (! asstOptActive);

   witDeleteRun          (theWitRun);
@


1.174
log
@Assisted opt implosion.
@
text
@d5465 4
d5503 4
a5506 1
      & rowub);
d5516 1
d5529 4
a5532 1
      & rowubDbl);
d5542 1
@


1.173
log
@Custom opt implosion.
@
text
@d5448 1
a5448 1
   witBoolean custOptImpActive;
d5466 2
a5467 2
   witNewRun            (& theWitRun);
   witInitialize          (theWitRun);
d5469 1
a5469 1
   witGetDevMode          (theWitRun, & devMode);
d5473 1
a5473 1
      witDeleteRun        (theWitRun);
d5478 1
a5478 1
   witAddPart             (theWitRun,   "A", WitMATERIAL);
d5480 2
a5481 2
   witGetCustOptImpActive (theWitRun, & custOptImpActive);
   assert                            (! custOptImpActive);
d5483 1
a5483 1
   witStartCustOptImp     (theWitRun);
d5485 2
a5486 2
   witGetCustOptImpActive (theWitRun, & custOptImpActive);
   assert                              (custOptImpActive);
d5533 1
a5533 1
      witSolveOptProblem  (theWitRun);
d5535 1
a5535 1
   witFinishCustOptImp    (theWitRun);
d5537 2
a5538 2
   witGetCustOptImpActive (theWitRun, & custOptImpActive);
   assert                            (! custOptImpActive);
d5540 1
a5540 1
   witDeleteRun           (theWitRun);
@


1.172
log
@App controlled opt implosion.
@
text
@d5448 1
a5448 1
   witBoolean optImpActive;
d5466 2
a5467 2
   witNewRun        (& theWitRun);
   witInitialize      (theWitRun);
d5469 1
a5469 1
   witGetDevMode      (theWitRun, & devMode);
d5473 1
a5473 1
      witDeleteRun    (theWitRun);
d5478 1
a5478 1
   witAddPart         (theWitRun,   "A", WitMATERIAL);
d5480 2
a5481 2
   witGetOptImpActive (theWitRun, & optImpActive);
   assert                        (! optImpActive);
d5483 1
a5483 1
   witStartOptImp     (theWitRun);
d5485 2
a5486 2
   witGetOptImpActive (theWitRun, & optImpActive);
   assert                          (optImpActive);
d5533 1
a5533 1
      witSolveOptProblem (theWitRun);
d5535 1
a5535 1
   witFinishOptImp       (theWitRun);
d5537 2
a5538 2
   witGetOptImpActive    (theWitRun, & optImpActive);
   assert                           (! optImpActive);
d5540 1
a5540 1
   witDeleteRun          (theWitRun);
@


1.171
log
@App controlled opt implosion.
@
text
@d2498 1
a2498 2
   if (optImpAllowed)
      testAppConOptImp ();
d5532 4
a5535 2
   witSolveOptProblem (theWitRun);
   witFinishOptImp    (theWitRun);
d5537 2
a5538 2
   witGetOptImpActive (theWitRun, & optImpActive);
   assert                        (! optImpActive);
d5540 1
a5540 1
   witDeleteRun       (theWitRun);
@


1.170
log
@App controlled opt implosion.
@
text
@a18 4
#ifndef	NO_OPT_IMPLODE
#define OPT_IMPLODE
#endif

d129 2
d187 11
d330 1
a330 1
#ifdef OPT_IMPLODE
d332 1
a332 1
#endif
d334 1
a334 1
#ifdef OPT_IMPLODE
d336 1
a336 1
#endif
d338 1
a338 1
#ifdef OPT_IMPLODE
d340 1
a340 1
#endif
d1592 1
a1592 1
#ifdef OPT_IMPLODE
d1595 1
a1595 1
#endif
d1598 1
a1598 1
#ifdef OPT_IMPLODE
d1600 1
a1600 1
#endif
d1682 4
a1685 9
#ifdef OPT_IMPLODE

   witOptImplode  (theWitRun);

#else

   witHeurImplode (theWitRun);

#endif
a1701 12
#ifdef OPT_IMPLODE
   {
   float  objValue,  boundsValue,  rev,  inv,  serv,  sub;
   double objValueD, boundsValueD, revD, invD, servD, subD;
   witBoolean optSolved;

   witGetObjValues( theWitRun, &objValue, &boundsValue );
   printf( "objValue = %f, boundsValue = %f\n",objValue,boundsValue);

   witGetObj2Values( theWitRun, &rev, &inv, &serv, &sub );
   printf( "obj2Rev=%f, obj2Inv=%f, obj2Serv=%f, obj2Sub=%f\n",
           rev, inv, serv, sub );
d1703 16
a1718 3
   printf (
      "\n"
      "Objective function values in double precision:\n");
d1720 2
a1721 2
   witGetObjValuesDbl( theWitRun, &objValueD, &boundsValueD );
   printf( "objValue = %f, boundsValue = %f\n",objValueD,boundsValueD);
d1723 3
a1725 3
   witGetObj2ValuesDbl( theWitRun, &revD, &invD, &servD, &subD );
   printf( "obj2Rev=%f, obj2Inv=%f, obj2Serv=%f, obj2Sub=%f\n",
           revD, invD, servD, subD );
d1727 3
a1729 4
   witGetPostprocessed( theWitRun, &optSolved );
   assert( optSolved );
   }
#endif
d1738 5
a1742 6
#ifdef OPT_IMPLODE

   assert( accAfterOptImp );
   assert( accelerated );

#endif
d1748 4
a1751 1
#ifdef OPT_IMPLODE
d1753 2
a1754 6
   assert( !accelerated );
   assert( !accAfterOptImp );

   prtRemove ("solver-alt.log");

#endif
d2418 3
a2420 1
#ifdef OPT_IMPLODE
d2422 4
a2425 9
   witOptImplode( theObj1Run );

   prtRemove ("solver.log");

#else

   witHeurImplode( theObj1Run );

#endif
d2473 2
a2474 5
#ifdef OPT_IMPLODE

   testAccOptImp ();

#endif
d2498 2
a2499 5
#ifdef OPT_IMPLODE

   testAppConOptImp ();

#endif
d3806 3
a3808 1
#ifdef	OPT_IMPLODE
d3810 2
a3811 5
   witOptImplode (theWitRun);

   prtRemove ("solver.log");

#endif
a5241 2
#ifdef OPT_IMPLODE

a5351 2
#endif /* OPT_IMPLODE */

@


1.169
log
@App controlled opt implosion.
@
text
@d5538 1
a5538 1
   witFree (value);
@


1.168
log
@App controlled opt implosion.
@
text
@d118 1
d1675 1
a1675 29
   {
   witBoolean devMode;
   witBoolean optImpActive;

   witGetDevMode         (theWitRun, & devMode);

   if (devMode)
      {
      witGetOptImpActive (theWitRun, & optImpActive);
      assert                        (! optImpActive);

      witStartOptImp     (theWitRun);

      witGetOptImpActive (theWitRun, & optImpActive);
      assert                          (optImpActive);

      witSolveOptProblem (theWitRun);

      witGetOptImpActive (theWitRun, & optImpActive);
      assert                          (optImpActive);

      witFinishOptImp    (theWitRun);

      witGetOptImpActive (theWitRun, & optImpActive);
      assert                        (! optImpActive);
      }
   else
      witOptImplode (theWitRun);
   }
d1679 1
a1679 1
   witHeurImplode( theWitRun );
d2502 6
d5452 103
d5564 2
a5565 4
   witNewRun (& theWitRun1);

   witInitialize (theWitRun1);

d5567 1
a5567 2

   witDeleteRun (theWitRun1);
d5571 2
a5572 4
   witNewRun (& theWitRun2);

   witInitialize (theWitRun2);

d5575 1
a5575 1
   assert (theBool);
d5577 1
a5577 1
   witDeleteRun (theWitRun2);
@


1.167
log
@Heuristic search increment.
@
text
@a342 11
   if (devMode)
      {       
      witSetOptImpActive   (theWitRun,   WitTRUE); 
      witGetOptImpActive   (theWitRun, & bool);
      assert                            (bool);

      witSetOptImpActive   (theWitRun,   WitFALSE);
      witGetOptImpActive   (theWitRun, & bool);
      assert                          (! bool);
      }

d1674 29
a1702 1
   witOptImplode( theWitRun );
@


1.166
log
@Heuristic search increment.
@
text
@a895 1
   witBoolean devMode;
d914 2
a915 1
   witGetDevMode (theWitRun, & devMode);
d917 2
a918 7
   if (devMode)
      {
      witSetDemandSearchInc    (theWitRun, "PS1", "US", 0.1);
      witSetDemandSearchIncDbl (theWitRun, "PS1", "US", 0.01);

      witGetDemandSearchInc    (theWitRun, "PS1", "US", & theFlt);
      witGetDemandSearchIncDbl (theWitRun, "PS1", "US", & theDbl);
d920 2
a921 2
      assert (fabs (theFlt - 0.01) < dblEps);
      assert (fabs (theDbl - 0.01) < dblEps);
d923 1
a923 2
      witSetDemandSearchInc    (theWitRun, "PS1", "US", 1);
      }
@


1.165
log
@Heuristic search increment.
@
text
@a227 2
   witBoolean devMode;

a306 8

   witGetDevMode (theWitRun, & devMode);

   if (devMode)
      {
      witSetHeurSearchInc    (theWitRun, 0.1);
      witSetHeurSearchIncDbl (theWitRun, 0.01);
      }
a530 11

   if (devMode)
      {
      witGetHeurSearchInc    (theWitRun, & theFlt);
      witGetHeurSearchIncDbl (theWitRun, & theDbl);

      assert (fabs (theFlt - 0.01) < dblEps);
      assert (fabs (theDbl - 0.01) < dblEps);

      witSetHeurSearchInc    (theWitRun, 1);
      }
d896 1
d915 16
@


1.164
log
@Heuristic search increment.
@
text
@d549 2
@


1.163
log
@Heuristic search increment.
@
text
@d351 1
a351 1
         "WIT was not built in development mode.\n");
d354 2
a355 2
      {
      witSetOptImpActive   (theWitRun,   WitTRUE);
@


1.162
log
@App controlled opt implosion.
@
text
@d228 2
d309 8
d541 9
@


1.161
log
@App controlled opt implosion.
@
text
@d343 10
a352 9
   witSetMesgTimesPrint (theWitRun,   WitFALSE, 602, 103);
   witSetMesgTimesPrint (theWitRun,   WitFALSE, 602, 104);
   witGetOptImpActive   (theWitRun, & bool);
   assert                            (bool);

   witSetMesgTimesPrint (theWitRun,   WitFALSE, 602, 103);
   witSetMesgTimesPrint (theWitRun,   WitFALSE, 602, UCHAR_MAX);
   witGetOptImpActive   (theWitRun, & bool);
   assert                          (! bool);
@


1.160
log
@NSTN residualVol.
@
text
@d316 1
d332 11
@


1.159
log
@App controlled opt implosion.
@
text
@d303 4
d510 7
a516 1
   witGetTieBreakPropRt (theWitRun, &bool);
@


1.158
log
@App controlled opt implosion.
@
text
@d327 9
a335 17
#if 0

   witSetTitle (theWitRun, "57625: optImpActive = TRUE");

   witGetOptImpActive (theWitRun, & bool);

   assert (bool);

   witSetTitle (theWitRun, "57625: optImpActive = FALSE");

#endif

   witGetOptImpActive (theWitRun, & bool);

   assert (! bool);

   witSetTitle (theWitRun, "Invoke Each API Function");
@


1.157
log
@App controlled opt implode.
@
text
@d327 2
d337 2
@


1.156
log
@App controlled opt implosion.
@
text
@d326 15
a340 2
   witGetOptImpActive( theWitRun, &bool );
   assert( ! bool );
@


1.155
log
@App controlled opt implosion.
@
text
@d326 2
@


1.154
log
@Integrality constraints.
@
text
@a1538 1
#ifdef OPT_IMPLODE
a1539 1
#endif
d1689 2
a1692 2
   }
#endif
@


1.153
log
@Removed calls to witSet/GetOptWithLotSizes.
@
text
@d2365 2
a2366 2
   witSetOperationIntExecVols   (theObj1Run, "PS1",         WitTRUE);
   witGetOperationIntExecVols   (theObj1Run, "PS1",       & theBool);
d2370 2
a2371 2
   witSetSubsBomEntryIntSubVols (theObj1Run, "PS1", 0, 0,   WitTRUE);
   witGetSubsBomEntryIntSubVols (theObj1Run, "PS1", 0, 0, & theBool);
d2375 2
a2376 2
   witSetDemandIntShipVols      (theObj1Run, "PS1", "US",    WitTRUE);
   witGetDemandIntShipVols      (theObj1Run, "PS1", "US",  & theBool);
@


1.152
log
@Added code to test integrality functions.
@
text
@a2029 1
   witBoolean optWithLotSizes;
a2035 6

   witSetOptWithLotSizes (theObj1Run, WitTRUE);

   witGetOptWithLotSizes (theObj1Run, & optWithLotSizes);

   assert (optWithLotSizes);
@


1.151
log
@exexVol pegging for BOP entries.
@
text
@a2028 1
   /* Exercise Obj1 only functions */
d2369 19
@


1.150
log
@BOP entry execVol pegging.
@
text
@d69 1
a69 1
void testCoexVolPip   (WitRun *, const char *, const char *, int);
d89 1
a89 1
void testCoexVolPipDbl   (WitRun *, const char *, const char *, int);
d4143 1
a4143 1
   testCoexVolPip       (theWitRun, "PS1", "US", 2);
d4257 1
a4257 1
/* testCoexVolPip                                                             */
d4260 1
a4260 1
void testCoexVolPip (
d4270 1
a4270 1
   float *  peggedCoexVolList;
d4273 1
a4273 1
   witGetDemandCoexVolPip (
d4282 1
a4282 1
      & peggedCoexVolList);
d4286 1
a4286 1
      "CoexVol PIP for Part %s, Demand %s, Period %d:\n\n",
d4292 1
a4292 1
      printf ("   Operation %s, BOP Entry %d, Period %d, CoexVol: %.0f\n",
d4296 1
a4296 1
         peggedCoexVolList    [theIdx]);
d4304 1
a4304 1
   witFree (peggedCoexVolList);
d4579 1
a4579 1
   testCoexVolPipDbl    (theWitRun, "PS1", "US", 2);
d4690 1
a4690 1
/* testCoexVolPipDbl                                                          */
d4693 1
a4693 1
void testCoexVolPipDbl (
d4703 1
a4703 1
   double * peggedCoexVolList;
d4706 1
a4706 1
   witGetDemandCoexVolPipDbl (
d4715 1
a4715 1
      & peggedCoexVolList);
d4719 1
a4719 1
      "CoexVol PIP for Part %s, Demand %s, Period %d:\n\n",
d4725 1
a4725 1
      printf ("   Operation %s, BOP Entry %d, Period %d, CoexVol: %.0f\n",
d4729 1
a4729 1
         peggedCoexVolList    [theIdx]);
d4737 1
a4737 1
   witFree (peggedCoexVolList);
@


1.149
log
@BOP entry execVol pegging.
@
text
@d3925 4
a3928 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d3972 4
a3975 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4021 4
a4024 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4076 4
a4079 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4226 4
a4229 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4274 4
a4277 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4326 4
a4329 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4379 4
a4382 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4416 4
a4419 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4453 4
a4456 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4490 4
a4493 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4659 4
a4662 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4707 4
a4710 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4759 4
a4762 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4812 4
a4815 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4849 4
a4852 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4886 4
a4889 4
      theWitRun,
      partName,
      demandName,
      shipPer,
d4923 4
a4926 4
      theWitRun,
      partName,
      demandName,
      shipPer,
@


1.148
log
@GPIP migration.
@
text
@d69 1
d89 1
d4143 1
d4257 51
d4345 2
a4346 1
      printf ("   Operation %s, BOM Ent %d, Sub %d, Period %d, SubVol: %.0f\n",
d4579 1
d4690 51
d4778 2
a4779 1
      printf ("   Operation %s, BOM Ent %d, Sub %d, Period %d, SubVol: %.0f\n",
@


1.147
log
@GPIP migration.
@
text
@a3095 28
   /* pipShare */
   {
   float   goodPipShare[] = {1.0, 2.0, 0.0, 1.0, 2.0};
   float * pipShare;

   witSetBopEntryPipShare (wr1, "opn1", 0, goodPipShare);

   witGetBopEntryPipShare (wr1, "opn1", 0, & pipShare);

   compareFltVecs (pipShare, goodPipShare);

   witFree (pipShare);
   }

   /* pipShare: double */
   {
   double   goodPipShareDbl[] = {1.0, 2.0, 0.0, 1.0, 2.0};
   double * pipShareDbl;

   witSetBopEntryPipShareDbl (wr1, "opn1", 0, goodPipShareDbl);

   witGetBopEntryPipShareDbl (wr1, "opn1", 0, & pipShareDbl);

   compareDblVecs (pipShareDbl, goodPipShareDbl);

   witFree (pipShareDbl);
   }

@


1.146
log
@Updates for groupPipMode defaulting to TRUE.
@
text
@d26 1
a26 1
/* TRUE, iff WIT's error exception capability is available on the platform    */
a4145 5
   witSetGroupPipMode   (theWitRun,   WitFALSE);
   witGetGroupPipMode   (theWitRun, & theBool);

   assert               (! theBool);

a4528 5
   witSetGroupPipMode   (theWitRun,   WitTRUE);
   witGetGroupPipMode   (theWitRun, & theBool);

   assert               (theBool);

@


1.145
log
@Fixed some memory leaks found by Purify.
@
text
@d4146 5
@


1.144
log
@Fixed a memory leak.
@
text
@d208 2
d2739 10
a2748 4
   witSetOperationObj1ExecCost( wr1, "opn1", fltVec );
   witSetOperationExecCost    ( wr1, "opn1", fltVec );
   witGetOperationExecCost    ( wr1, "opn1", &fltVec1 );
   witGetOperationObj1ExecCost( wr1, "opn1", &fltVec1 );
d2750 1
a2750 1
   compareFltVecs(fltVec,fltVec1);
d2760 4
a2763 4
   witSetOperationObj1ExecCostDbl( wr1, "opn1", dblVec );
   witSetOperationExecCostDbl    ( wr1, "opn1", dblVec );
   witGetOperationExecCostDbl    ( wr1, "opn1", &dblVec1 );
   witGetOperationObj1ExecCostDbl( wr1, "opn1", &dblVec1 );
d2765 7
a2771 1
   compareDblVecs(dblVec,dblVec1);
d2818 1
d3280 2
d3294 2
d3309 2
@


1.143
log
@Added test code for the newPipPggOrder attribute.
@
text
@d5031 1
@


1.142
log
@Removed calls to postSolveRecovery functions.
@
text
@d4125 4
a4128 1
   witSetPipSeqFromHeur (theWitRun, WitTRUE);
d4130 2
a4131 1
   witGetPipSeqFromHeur (theWitRun, & theBool);
d4513 5
@


1.141
log
@Removed calls to witSetOslMesgFileName and witGetOslMesgFileName.
@
text
@a1635 10
   {
   witBoolean postSolveRecovery;

   witSetPostSolveRecovery (theWitRun, WitTRUE);

   witGetPostSolveRecovery (theWitRun, & postSolveRecovery);

   assert (postSolveRecovery);
   }

@


1.140
log
@Fixed a bug in the case of an empty pegging.
@
text
@a1575 4
   witSetOslMesgFileName( theWitRun, "solver-alt.log" );
   witGetOslMesgFileName( theWitRun, &string );
   assert( strcmp( string, "solver-alt.log" ) == 0 );

a2379 2
   witSetOslMesgFileName (theObj1Run, "solver.log");

a3779 2
   witSetOslMesgFileName (theWitRun, "solver.log");

a5150 1
   witSetOslMesgFileName      (theWitRunA, "solver-a.log");
a5173 1
   witSetOslMesgFileName      (theWitRunB, "solver-b.log");
@


1.139
log
@Added tests for group PIP.
@
text
@d4198 16
a4213 13
   witAppendToPipSeq (
      theWitRun,
      partNameList  [0],
      demandNameList[0],
      shipPerList   [0],
      incShipVolList[0]);

   witAppendToPipSeq (
      theWitRun,
      partNameList  [lenLists - 1],
      demandNameList[lenLists - 1],
      shipPerList   [lenLists - 1],
      incShipVolList[lenLists - 1]);
@


1.138
log
@Update to error exception capability.
@
text
@d4519 2
a4520 1
   witSetPipSeqFromHeur (theWitRun, WitTRUE);
d4522 3
@


1.137
log
@modified to run on windows with MS V6 compiler
@
text
@d24 22
d154 6
a159 7
#if !defined(_MSC_VER)
   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitTRUE);
#endif
d198 1
a198 2
#if !defined(_MSC_VER)
   witGetMesgThrowErrorExc (theWitRun, 74, & bool);
d200 4
a203 2
   assert (bool);
#endif
@


1.136
log
@[error recovery]
@
text
@d132 1
d138 1
d177 1
d181 1
@


1.135
log
@Added code to test copying a WitRun to itself.
@
text
@d25 1
a93 1
void testStandAlone ();
d121 2
a2443 2
   testStandAlone ();

d2456 19
a5282 19
/* testStandAlone                                                             */
/*----------------------------------------------------------------------------*/

void testStandAlone ()
   {
   char *   argv[2];
   WitRun * theWitRun;

   argv[0] = "";
   argv[1] = "data/diner.params";

   witNewRun       (& theWitRun);

   witExecStandAlone (theWitRun, 2, argv);

   witDeleteRun      (theWitRun);
   }

/*----------------------------------------------------------------------------*/
@


1.134
log
@[multi-thread]
@
text
@d2396 4
@


1.133
log
@[multi-thread]
@
text
@d5290 2
@


1.132
log
@[multi-thread]
@
text
@d2436 2
@


1.131
log
@Added a "normal termination" output.
@
text
@d93 1
d2436 2
d5258 19
@


1.130
log
@[multi-thread]
@
text
@d2437 5
@


1.129
log
@Test code for WIT's new exception throwing capability.
@
text
@d5261 1
a5261 1
   witSetMultiThread (theWitRun1);
@


1.128
log
@Removed all calls to variable-argument-list API functions.
@
text
@d129 1
a129 1
   witSetMesgThrowException (
d172 1
a172 1
   witGetMesgThrowException (theWitRun, 74, & bool);
@


1.127
log
@[multi-thread]
@
text
@d673 1
a673 1
   /* Part PS2, use va */
d685 1
a685 9
   witAddPartVa( theWitRun, "PS2", WitPRODUCT,
                 WitNunitCost, 100.,
                 WitNcycleTime, cycle,
                 WitNprodBounds, prodBoundsHL,prodBoundsSL,NULL,
                 WitNminLotSize, minLotSize,
                 WitNincLotSize, incLotSize, 
                 WitNstockBounds, NULL, NULL,stockBoundsHU,
                 WitNyield, yield,
                 NULL );
d694 2
a695 3
   witAddPartVa( theWitRun, "MOBILE", WitPRODUCT,
                 WitNunitCost, 50.,
                 NULL );
a981 2
   float *fv;
   witBoolean bool;
d983 1
a983 9
   witAddDemandVa( theWitRun, "PS1", "AGP",
                   WitNgrossRev, 75.,
                   WitNpriority, priority,
                   WitNdemandVol, demandVol,
                   WitNbuildAheadLimit, 2,
                   WitNshipLateLimit, 4,
                   WitNcumShipBounds, 
                        cumShipBoundsHL, cumShipBoundsSL, cumShipBoundsHU,
                   NULL );
a985 4
   witGetDemandDemandVol( theWitRun, "PS1", "AGP", &fv );
   compareFltVecs( fv, demandVol );
   witFree (fv);

a987 4

   witGetDemandPrefBuildAhead( theWitRun, "PS1", "AGP", &bool );
   assert( ! bool );

a1005 3
   int priority[] = { 2, 2, 2, 2, 2 };
   float demandVol[] = { 500., 500.,1000.,1500.,1500. };

a1006 1
   float *fv;
d1008 1
a1008 5
   witAddDemandVa( theWitRun, "PS2", "US",
                   WitNgrossRev, 200.,
                   WitNpriority, priority,
                   WitNdemandVol, demandVol,
                   NULL );
a1010 4
   witGetDemandDemandVol( theWitRun, "PS2", "US",  &fv );
   compareFltVecs( fv, demandVol );
   witFree (fv);

a1021 1
   float *fv;
d1023 1
a1023 5
   witAddDemandVa( theWitRun, "MOBILE", "US",
                   WitNgrossRev, 250.,
                   WitNpriority, priority,
                   WitNdemandVol, demandVol,
                   NULL );
a1025 4
   witGetDemandDemandVol( theWitRun, "MOBILE", "US", &fv );
   compareFltVecs( fv, demandVol );
   witFree (fv);

d1053 1
a1053 10
   witAddBomEntryVa(  theWitRun, "PS1", "CompB",
                      WitNusageTime, -0.11,
                      WitNusageRate,  1.11,
                      WitNoffset, offset,
                      WitNfallout,   2,
                      WitNearliestPeriod, 0,
                      WitNlatestPeriod, nPeriods-1,
                      WitNmandEC, WitFALSE,
                      NULL );

a1057 5
     witGetBomEntryOffset( theWitRun, "PS1", 1, &off );
     compareFltVecs( off, offset );

     witFree (off);
     off = NULL;
d1278 1
a1278 7
   witAddSubsBomEntryVa(  theWitRun, "PS1", 1, "CompA",
                      WitNusageRate, 2.11,
                      WitNfallout,   3,
                      WitNearliestPeriod, 1,
                      WitNlatestPeriod, nPeriods-2,
                      WitNobj2SubPenalty, 3.3,
                      NULL );
d2050 2
a2051 8
   witAddPartVa( theObj1Run, "PS2", WitPRODUCT,
                 WitNunitCost, 100.,
                 NULL );

   witAddPartVa( theObj1Run, "MOBILE", WitPRODUCT,
                 WitNunitCost, 50.,
                 NULL );

d2205 3
a2207 14
   witAddDemandVa( theObj1Run, "PS1", "AGP",
                   WitNgrossRev, 75.,
                   WitNdemandVol, demandVolPS1AGP,
                   WitNobj1CumShipReward, cumShipRewardPS1AGP,
                   WitNobj1ShipReward, shipRewardPS1AGP,
                   NULL );
   witAddDemandVa( theObj1Run, "PS2", "US",
                   WitNgrossRev, 200.,
                   WitNdemandVol, demandVolPS2US,
                   NULL );
   witAddDemandVa( theObj1Run, "MOBILE", "US",
                   WitNgrossRev, 250.,
                   WitNdemandVol, demandVolMOBILEUS,
                   NULL );
d2256 1
a2256 1
   witAddBomEntryVa(  theObj1Run, "PS1", "CompB", NULL );
d2306 1
a2306 3
   witAddSubsBomEntryVa(  theObj1Run, "PS1", 1, "CompB",
                      WitNobj1SubCost, subCostCompB,
                      NULL );
d3118 1
a3118 1
   witAddPartVa( wr1, "partRawVa", WitRAW, NULL );
d3121 1
a3121 1
   witAddPartVa( wr1, "partCapVa", WitCAPACITY, NULL );
d3124 1
a3124 1
   witAddPartVa( wr1, "partPrdVa", WitPRODUCT, NULL );
d3129 1
a3129 5
   witAddPartVa( wr1, "partPrdVa1", WitPRODUCT, 
                 WitNobj1ProdCost,   obj1ProdCost,
                 WitNyield,   yield,
                 WitNcycleTime, cycleTime,
                 NULL );
d3133 1
a3133 1
   witAddPartVa( wr1, "partMatVa", WitMATERIAL, NULL );
d3142 1
a3142 1
   witAddPartVa( wr1, "partCapVa", WitCAPACITY, NULL );
d3145 1
a3145 13
   witAddPartVa( wr1, "partMatVa", WitMATERIAL, NULL );

#if 0
   /* Test setting 34 attribute cycleTime when not in 34 mode */
   {
   float cycleTime[]  ={ 1., 2., 3., 4., 5.5 };
   float *ct;
#if 0
   witSetPartCycleTime( wr1, "partMat", cycleTime );
#endif
   witGetPartCycleTime( wr1, "partMat", &ct );
   }
#endif
a3148 11
#if 0
   /* Test setting 34 attribute usageTime when not in 34 mode */
   {
   float ut;
#if 0
   witSetBomEntryUsageTime( wr1, "partWithOperation", 0, 35. );
#endif
   witGetBomEntryUsageTime( wr1, "partWithOperation", 0, &ut );
   }
#endif

@


1.126
log
@Test code for [exceptions].
@
text
@d93 1
d111 2
a112 2
int main (int argc, char * argv[])
{
d2522 2
d2525 2
a2526 2

} /* main */
d5364 29
@


1.125
log
@Test code for [exceptions]
@
text
@d128 5
a132 1
   witSetThrowExcOnError (theWitRun, WitFALSE, WitTRUE);
d148 2
a149 2
   witSetMesgStopRunning( theWitRun, WitFALSE, WitSEVERE_MESSAGES, WitFALSE);
   witSetMesgStopRunning( theWitRun, WitFALSE, WitSEVERE_MESSAGES, WitTRUE); 
d171 1
a171 1
   witGetThrowExcOnError (theWitRun, & bool);
d184 1
a184 1
   witGetMesgStopRunning( theWitRun, 74, &bool );
@


1.124
log
@Reduced use of objective #2.
@
text
@d128 2
d167 4
@


1.123
log
@Added code to test set/get functions for the new names of obj1 attributes
like scrapCost.
@
text
@a215 1
   witSetObjChoice( theWitRun, 1 );
a2529 1
   witSetObjChoice( wr1, 1 );
a2931 1
   witSetObjChoice( wr1, 1 );
a3188 1
   witSetObjChoice( wr1, 1 );
a3216 1
   witSetObjChoice( wr1, 1 );
a3817 1
   witSetObjChoice   (theWitRun, 2);
@


1.122
log
@Changed test code and data to accommodate the change in the default value
of the objChoice attribute from 2 to 1.
@
text
@d2088 12
a2099 12
   float  supplyVolCompA   [] = {2000., 2000., 2000., 2000., 2000.};
   float  supplyVolCompB   [] = {3500., 2500., 2500., 2500., 2500.};
   float  supplyVolCompC   [] = {2000., 2000., 2000., 2000., 2000.};
   float  supplyVolCap     [] = {3500., 3500., 3500., 3500., 3500.};

   float  obj1ProdCost     [] = {1.1,  1.2,  1.3,  1.4,  1.5};
   float  obj1ScrapCost    [] = {0.1,  0.2,  0.3,  0.4,  0.5};
   double obj1ScrapCostDbl [] = {0.1,  0.2,  0.3,  0.4,  0.5};
   float  obj1StockCost    [] = {0.01, 0.02, 0.03, 0.04, 0.05};
   double obj1StockCostDbl [] = {0.01, 0.02, 0.03, 0.04, 0.05};
   float  incLotSize       [] = { 500.0,  500.0,  500.0,  500.0,  500.0};
   float  minLotSize       [] = {2500.0, 2500.0, 2500.0, 2500.0, 2500.0};
d2132 9
a2140 5
   witSetPartObj1ProdCost( theObj1Run, "PS1", obj1ProdCost );
   witSetPartObj1ScrapCost( theObj1Run, "PS1", obj1ScrapCost );
   witSetPartObj1ScrapCostDbl( theObj1Run, "PS1", obj1ScrapCostDbl );
   witSetPartObj1StockCost( theObj1Run, "PS1", obj1StockCost );
   witSetPartObj1StockCostDbl( theObj1Run, "PS1", obj1StockCostDbl );
d2157 14
d2174 1
a2174 1
   compareFltVecs( cost, obj1ScrapCost );
d2181 15
a2195 1
   compareDblVecs( cost, obj1ScrapCostDbl );
d2202 1
a2202 1
   compareFltVecs( cost, obj1StockCost );
d2209 1
a2209 1
   compareDblVecs( cost, obj1StockCostDbl );
d2236 12
a2247 12
   float  demandVolPS1US            [] = { 500., 500., 500., 500., 500. };
   float  demandVolPS1AGP           [] = { 500., 500., 500., 500., 500. };
   float  demandVolPS2US            [] = { 500., 500.,1000.,1500.,1500. };
   float  demandVolMOBILEUS         [] = { 1000., 1000.,1000.,1000.,1000. };

   float  obj1CumShipRewardPS1US    [] = { 50., 50., 40., 50., 50. };
   double obj1CumShipRewardDblPS1US [] = { 50., 50., 40., 50., 50. };
   float  obj1CumShipRewardPS1AGP   [] = { 150., 150., 140., 150., 150. };

   float  obj1ShipRewardPS1US       [] = { 5., 5., 4., 5., 5. };
   double obj1ShipRewardDblPS1US    [] = { 5., 5., 4., 5., 5. };
   float  obj1ShipRewardPS1AGP      [] = { 15., 15., 14., 15., 15. };
d2253 7
a2259 1
        obj1CumShipRewardPS1US );
d2261 1
a2261 1
        obj1ShipRewardPS1US );
d2263 5
a2267 1
        obj1ShipRewardDblPS1US );
d2272 2
a2273 2
                   WitNobj1CumShipReward, obj1CumShipRewardPS1AGP,
                   WitNobj1ShipReward, obj1ShipRewardPS1AGP,
d2289 8
d2298 1
a2298 1
   compareFltVecs( fv, obj1ShipRewardPS1US );
d2302 9
a2310 1
   compareDblVecs( dv, obj1ShipRewardDblPS1US );
d2314 1
a2314 1
   compareFltVecs( fv, obj1CumShipRewardPS1US );
d2318 1
a2318 1
   compareDblVecs( dv, obj1CumShipRewardDblPS1US );
d2364 5
a2368 5
   float  obj1SubCostCompA   []={ 1., 2., 3., 4., 5.};
   double obj1SubCostDblCompA[]={ 1., 2., 3., 4., 5.};
   float  obj1SubCostCompB   []={ 10., 20., 30., 40., 50.};
   float  offsetCompA        []={ 2., 2., 3., 3., 3.};
   double offsetDblCompA     []={ 2., 2., 3., 3., 3.};
d2371 1
a2371 1
   witSetSubsBomEntryObj1SubCost( theObj1Run, "PS1", 0, 0, obj1SubCostCompA);
d2373 4
a2376 1
      theObj1Run, "PS1", 0, 0, obj1SubCostDblCompA);
d2382 1
a2382 1
                      WitNobj1SubCost, obj1SubCostCompB,
d2387 14
d2402 1
a2402 1
   compareFltVecs( fv, obj1SubCostCompA );
d2409 1
a2409 1
   compareDblVecs( dv, obj1SubCostDblCompA );
d2765 1
a2765 1
   /* obj1ExecCost */
d2771 2
d2780 1
a2780 1
   /* obj1ExecCost */
d2786 2
@


1.121
log
@Updated apiAll and msgAll to reflect the unconditional use of COIN
when WIT is built with -DCOIN_BUILD.
@
text
@d3744 1
@


1.120
log
@Removed calls to tmpnam.
@
text
@a105 2
witBoolean coinMode;

a118 7
   coinMode = (argc > 1);

   if (coinMode)
      printf ("WIT will use COIN as its solver.\n");
   else
      printf ("WIT will use OSL as its solver.\n");

d1595 9
a1603 10
   float      prodVol    [] = {5000., 5000., 2000., 0000., 2000.};
   float      subVol1    [] = {4001., 4001., 1001., 501., 21.};
   float      subVol     [] = {4000., 4000., 1000., 500., 20.};
   double     subVolDbl  [] = {4000., 4000., 1000., 500., 20.};
   float      shipVol    [] = {6000., 6000., 3000., 0000., 3000.};
   double     shipVolDbl [] = {6000., 6000., 3000., 0000., 3000.};
   float *    fv;
   double *   dv;
   char *     string;
   witBoolean theBool;
a1608 1

a1613 8
   witSetSolverIsCoin (theWitRun, WitTRUE);
   witGetSolverIsCoin (theWitRun, & theBool);

   assert (theBool);

   if (! coinMode)
      witSetSolverIsCoin (theWitRun, WitFALSE);

d2357 1
a2357 4
   if (coinMode)
      witSetSolverIsCoin (theObj1Run, WitTRUE);
   else
      witSetOslMesgFileName (theObj1Run, "solver.log");
d3754 1
a3754 4
   if (coinMode)
      witSetSolverIsCoin (theWitRun, WitTRUE);
   else
      witSetOslMesgFileName (theWitRun, "solver.log");
d5119 2
a5120 8
   if (coinMode)
      {
      witSetSolverIsCoin      (theWitRunA, WitTRUE);

      witSetSolverLogFileName (theWitRunA, "solver-a.log" );
      }
   else
      witSetOslMesgFileName   (theWitRunA, "solver-a.log");
d5143 2
a5144 8
   if (coinMode)
      {
      witSetSolverIsCoin      (theWitRunB, WitTRUE);

      witSetSolverLogFileName (theWitRunB, "solver-b.log" );
      }
   else
      witSetOslMesgFileName   (theWitRunB, "solver-b.log");
@


1.119
log
@Added more code to test WIT in COIN mode.
@
text
@a120 3
   char savedSchdFile[L_tmpnam]; 
   strcpy(savedSchdFile,tmpnam(NULL));

a132 1
   char *tempFileName = tmpnam(NULL);
d139 1
a139 1
   witSetMesgFileName( theWitRun, WitFALSE, tempFileName );
d146 1
a146 1
   unlink( tempFileName );
a1603 1
   char       cat     [100];
d1713 1
a1713 1
   witWriteExecSched( theWitRun, savedSchdFile, WitBSV );
d1715 1
a1715 1
   witWriteShipSched( theWitRun, savedSchdFile, WitBSV );
a1716 2
   strcpy(cat,"cat ");
   strcat(cat,savedSchdFile);
d1718 2
a1719 2
   system(cat);
   unlink( savedSchdFile );
d2000 1
a2000 4
   char *tempWitData = tmpnam(NULL);
   char cat[100];

   witWriteData( theWitRun, tempWitData );
d2004 1
a2004 1
   witReadData( theMrpRun, tempWitData );
a2005 2
   strcpy(cat,"cat ");
   strcat(cat,tempWitData);
d2007 2
a2008 2
   system(cat);
   unlink( tempWitData );
@


1.118
log
@Added more code to test WIT in COIN mode.
@
text
@a23 16
/* USE_COIN                                                                   */
/* 1, if WIT is     to use COIN.                                              */
/* 0, if WIT is not to use COIN.                                              */
/*----------------------------------------------------------------------------*/

#ifdef COIN_BUILD

   #define USE_COIN 1

#else

   #define USE_COIN 0

#endif

/*----------------------------------------------------------------------------*/
d106 2
d124 4
a127 2
   if (USE_COIN)
      printf ("This is a COIN build of apiAll.\n");
d129 1
a129 1
      printf ("This is a non-COIN build of apiAll.\n");
d1635 1
a1635 1
   if (! USE_COIN)
d2388 1
a2388 1
   if (USE_COIN)
d3788 1
a3788 1
   if (USE_COIN)
d5156 1
a5156 1
   if (USE_COIN)
d5186 1
a5186 1
   if (USE_COIN)
@


1.117
log
@Added mode code to test WIT in COIN mode.
@
text
@d5160 1
a5160 1
   witSetMesgFileName    (theWitRunA, WitTRUE, "wit-a.log");
d5162 1
a5162 1
   witInitialize         (theWitRunA);
d5164 1
a5164 1
   witReadData           (theWitRunA, "data/obj1.data");
d5166 1
a5166 1
   witSetAccAfterOptImp  (theWitRunA, WitTRUE);
d5168 3
a5170 1
   witSetOslMesgFileName (theWitRunA, "osl-a.log");
d5172 6
a5177 1
   witOptImplode         (theWitRunA);
d5179 1
a5179 1
   witWriteExecSched     (theWitRunA, "exec-a1.out", WitBSV);
d5190 3
a5192 1
   witSetMesgFileName    (theWitRunB, WitTRUE, "wit-b.log");
d5194 1
a5194 1
   witInitialize         (theWitRunB);
d5196 1
a5196 1
   witReadData           (theWitRunB, "data/obj2.data");
d5198 3
a5200 1
   witSetAccAfterOptImp  (theWitRunB, WitTRUE);
d5202 4
a5205 1
   witSetOslMesgFileName (theWitRunB, "osl-b.log");
d5207 5
a5211 6
   witSetOperationExecBounds (
                          theWitRunB,
                          "SUBASMBL1",
                          hardLB,
                          NULL,
                          NULL);
d5213 1
a5213 1
   witOptImplode         (theWitRunB);
d5215 1
a5215 1
   witWriteExecSched     (theWitRunB, "exec-b1.out", WitBSV);
d5257 1
a5257 1
   prtRemove ("osl-a.log");
d5262 1
a5262 1
   prtRemove ("osl-b.log");
@


1.116
log
@Added more code to test WIT in COIN mode.
@
text
@a131 1
   char * oslMesgFileName;
d1632 1
a1632 3
   oslMesgFileName = tmpnam (NULL);

   witSetOslMesgFileName( theWitRun, oslMesgFileName );
d1634 1
a1634 1
   assert( strcmp( string, oslMesgFileName ) == 0 );
d1794 1
a1794 4
   if (USE_COIN)
      prtRemove ("solver-alt.log");
   else
      prtRemove (oslMesgFileName);
a2397 3
   char *oslMesgFileName = tmpnam(NULL);
   witSetOslMesgFileName( theObj1Run, oslMesgFileName );

d2402 2
d2407 1
a2407 4
   if (USE_COIN)
      prtRemove ("solver.log");
   else
      prtRemove (oslMesgFileName);
d3802 2
d3805 1
a3805 1
   witOptImplode     (theWitRun);
d3807 1
a3807 4
   if (USE_COIN)
      prtRemove      ("solver.log");
   else
      prtRemove      ("osl.log");
@


1.115
log
@Added code to do tests in COIN mode.
@
text
@d23 18
d139 4
a142 9
#ifdef COIN_BUILD

   printf ("This is a COIN build of apiAll.\n");

#else

   printf ("This is a non-COIN build of apiAll.\n");

#endif
d1650 2
a1651 5
#ifndef COIN_BUILD

   witSetSolverIsCoin (theWitRun, WitFALSE);

#endif
d1797 4
a1800 1
   prtRemove (oslMesgFileName);
d2409 3
d2414 4
a2417 1
   prtRemove (oslMesgFileName);
d3810 3
d3815 4
a3818 1
   prtRemove         ("osl.log");
@


1.114
log
@Added code to test the removal of restrictions on the obj1 attributes and
on objChoice.
@
text
@d121 10
d1637 2
d1641 2
@


1.113
log
@Added code to test API functions and messages for the vector propRtg
attribute.
@
text
@a2096 1
   witSetObjChoice( theObj1Run, 1 );
a2129 1

d2216 6
@


1.112
log
@Pegged Critical List
@
text
@d2124 4
a2127 2
   witBoolean singleSource;
   witBoolean propRouting;
d2163 2
a2164 2

   witSetPartPropRouting (theObj1Run, "PS2", WitTRUE);
d2209 5
a2213 1
   witGetPartPropRouting (theObj1Run, "PS2", & propRouting);
d2215 3
a2217 1
   assert (propRouting);
d2285 4
a2288 2
   witBoolean singleSource;
   witBoolean propRouting;
d2309 6
a2314 1
   witSetBomEntryPropRouting (theObj1Run, "PS1", 1, WitTRUE);
d2316 2
a2317 1
   witGetBomEntryPropRouting (theObj1Run, "PS1", 1, & propRouting);
d2319 1
a2319 1
   assert (propRouting);
@


1.111
log
@Pegged Critical List.
@
text
@d79 2
a80 1
void testPgdCritList (WitRun *);
a4864 7
   int        lenLists;
   char * *   critPartNameList;
   int *      critPerList;
   char * *   demPartNameList;
   char * *   demandNameList;
   int *      shipPerList;
   int        theIdx;
d4878 23
@


1.110
log
@Pegged Critical List.
@
text
@d4865 2
a4869 2
   char * *   critPartNameList;
   int *      critPerList;
d4887 2
d4891 1
a4891 3
      & shipPerList,
      & critPartNameList,
      & critPerList);
d4895 1
a4895 1
      "-----------------------------------------------\n"
d4897 1
a4897 1
      "-----------------------------------------------\n"
d4899 2
a4900 1
      "Idx  Part    Demand  ShipPer  CritPart  CritPer\n"
d4905 1
a4905 1
         "%3d  %-6s  %-6s  %7d  %-8s  %7d\n",
d4907 2
d4911 1
a4911 3
         shipPerList     [theIdx],
         critPartNameList[theIdx],
         critPerList     [theIdx]);
d4915 1
a4915 1
      "-----------------------------------------------\n"
d4920 1
a4922 1
      witFree (critPartNameList[theIdx]);
d4925 2
a4929 2
   witFree (critPartNameList);
   witFree (critPerList);
@


1.109
log
@Changed test code to accommodate a change in the names of some unreleased API
functions.
@
text
@d79 2
d2084 4
a2087 2
   witDeleteRun( theWitRun );
   witDeleteRun( theMrpRun );
d4856 76
@


1.108
log
@Added code to test API functions for Low-Pri Prop-Rt.
@
text
@d259 1
a259 1
   witSetLowPriPropRt (theWitRun, WitTRUE);
d452 1
a452 1
   witGetLowPriPropRt (theWitRun, &bool);
@


1.107
log
@Added code to test the "solverIsCoin" attribute.
@
text
@a18 1
/*in 64-bit mode, just use -DNO_OPT_IMPLODE */
d258 2
d451 3
@


1.106
log
@Added test code for pipShare API functions.
@
text
@d1591 11
a1601 10
   char     cat     [100];
   float    prodVol    [] = {5000., 5000., 2000., 0000., 2000.};
   float    subVol1    [] = {4001., 4001., 1001., 501., 21.};
   float    subVol     [] = {4000., 4000., 1000., 500., 20.};
   double   subVolDbl  [] = {4000., 4000., 1000., 500., 20.};
   float    shipVol    [] = {6000., 6000., 3000., 0000., 3000.};
   double   shipVolDbl [] = {6000., 6000., 3000., 0000., 3000.};
   float *  fv;
   double * dv;
   char *   string;
d1615 6
@


1.105
log
@Minor update to calls to message functions.
@
text
@d3023 28
@


1.104
log
@Double Precision.
@
text
@d136 1
a136 4
   witSetMesgStopRunning( theWitRun, WitFALSE, 
       WitSEVERE_MESSAGES, WitFALSE);

   witSetMesgTimesPrint( theWitRun, WitFALSE, WitWARNING_MESSAGES, 2 ); 
a137 1
   witSetMesgFileName( theWitRun, WitTRUE, WitSTDOUT );
d143 1
d146 1
@


1.103
log
@Double Precision.
@
text
@d2810 1
d2814 6
@


1.102
log
@Double Precision.
@
text
@d1842 19
@


1.101
log
@Double Precision.
@
text
@d41 9
a49 8
void testPip               (WitRun *);
void truncatePipSeq        (WitRun *);
void testExecVolPip        (WitRun *, const char *, const char *, int);
void testSubVolPip         (WitRun *, const char *, const char *, int);
void testSupplyVolPip      (WitRun *, const char *, const char *, int);
void testSideVolPip        (WitRun *, const char *, const char *, int);
void testProdVolPip        (WitRun *, const char *, const char *, int);
void testConsVolPip        (WitRun *, const char *, const char *, int);
d61 19
d2051 2
a2052 1
   testPip (theWitRun);
d4386 376
@


1.100
log
@Double Precision.
@
text
@d42 1
a42 1
void reversePipSeq         (WitRun *);
d4048 1
a4048 1
   reversePipSeq        (theWitRun);
a4050 7

   testExecVolPip       (theWitRun, "PS1", "US", 2);
   testSubVolPip        (theWitRun, "PS1", "US", 2);
   testSupplyVolPip     (theWitRun, "PS1", "US", 2);
   testSideVolPip       (theWitRun, "PS1", "US", 2);
   testProdVolPip       (theWitRun, "PS1", "US", 2);
   testConsVolPip       (theWitRun, "PS1", "US", 2);
d4054 1
a4054 1
/* reversePipSeq                                                              */
d4056 1
a4056 1
/* Reverses the order of the PIP shipment sequence.                           */
d4059 1
a4059 1
void reversePipSeq (WitRun * theWitRun)
a4066 1
   double   incShipVolDbl;
d4078 13
a4090 21
   for (theIdx = lenLists - 1; theIdx >= 0; theIdx --)
      {
      if (theIdx >= 10)
         witAppendToPipSeq (
            theWitRun,
            partNameList  [theIdx],
            demandNameList[theIdx],
            shipPerList   [theIdx],
            incShipVolList[theIdx]);
      else
         {
         incShipVolDbl = (double) incShipVolList[theIdx];

         witAppendToPipSeqDbl (
            theWitRun,
            partNameList  [theIdx],
            demandNameList[theIdx],
            shipPerList   [theIdx],
            incShipVolDbl);
         }
      }
@


1.99
log
@Double Precision.
@
text
@d37 12
a48 10
void testExecVolPegging (WitRun *, const char *, const char *, int);
void testSubVolPegging  (WitRun *, const char *, const char *, int);
void testPip            (WitRun *);
void reversePipSeq      (WitRun *);
void testExecVolPip     (WitRun *, const char *, const char *, int);
void testSubVolPip      (WitRun *, const char *, const char *, int);
void testSupplyVolPip   (WitRun *, const char *, const char *, int);
void testSideVolPip     (WitRun *, const char *, const char *, int);
void testProdVolPip     (WitRun *, const char *, const char *, int);
void testConsVolPip     (WitRun *, const char *, const char *, int);
d1932 6
a1937 4
   testExecVolPegging (theWitRun, "PS1", "US", 1);
   testSubVolPegging  (theWitRun, "PS1", "US", 1);
   testExecVolPegging (theWitRun, "PS1", "US", 2);
   testSubVolPegging  (theWitRun, "PS1", "US", 2);
d1939 1
a1939 1
   witClearPegging (theWitRun);
d1941 2
a1942 2
   testExecVolPegging (theWitRun, "PS1", "US", 2);
   testSubVolPegging  (theWitRun, "PS1", "US", 2);
d3859 47
d3938 55
@


1.98
log
@Double Precision.
@
text
@d29 1
d31 1
d2351 1
d2353 1
d3191 1
a3191 1
/* Tests heuristic allocation and equitable allocation.                       */
a3197 1
   double     incVolD;
d3203 1
a3203 1
      "--- Testing Heuristic Allocation ---\n"
d3275 109
d3390 1
a3390 1
      & incVolD);
d3392 1
a3392 1
   assert (incVolD == 4.0);
d3409 2
a3410 2
/* Tests heuristic allocation and equitable allocation in two-way multi-exec  */
/* mode.                                                                      */
a3416 1
   double     incVolD;
d3423 1
a3423 1
      "--- Testing Heuristic Allocation in Two-Way Multi-Exec Mode ---\n"
d3499 112
d3617 1
a3617 1
      & incVolD,
d3620 1
a3620 1
   assert (incVolD == 4.0);
@


1.97
log
@Double Precision.
@
text
@a502 1
   witSetPartUnitCostDbl( theWitRun, "PS1", 250.0 );
a560 1
   witGetPartUnitCostDbl( theWitRun, "PS1", & theDbl);
a562 1
   assert( fabs(theDbl - 50.0) < dblEps );
d610 15
@


1.96
log
@Comment change.
@
text
@d462 9
a470 9
   float      cycle[] = {0.0, 0.1, 0.2, 0.3, 0.4};
   float      prodBoundsHL[] = {1., 2.,  3., 4., 5.};
   float      prodBoundsSL[] = {2., 2.2, 4., 5., 6.};
   float      stockBoundsSL[]    = {20., 20.2, 40., 50., 60.};
   double     stockBoundsSLDbl[] = {10., 10.2, 30., 40., 50.};
   float      stockBoundsHU[]    = {20., 20.2, 40., 50., 60.};
   double     stockBoundsHUDbl[] = {10., 10.2, 30., 40., 50.};
   float      defaultBoundsHU[]    = {-1.0, -1.0, -1.0, -1.0, -1.0};
   float      defaultBoundsHL[]    = {0.0, 0.0, 0.0, 0.0, 0.0};
d472 4
a475 4
   float      defaultBoundsSL[]    = {0.0, 0.0, 0.0, 0.0, 0.0};
   float      minLotSize[] = {2., 2., 4., 5., 6.};
   float      incLotSize[] = {1., 1., 3., 4., 3.};
   int        yield[] = {90, 91, 92, 93, 94};
d702 1
a702 1
   double * theDblVec;
d713 1
a713 1
   witGetPartSupplyVolDbl (theWitRun, "CompB", & theDblVec);
d715 1
a715 1
   compareDblVecs (theDblVec, supplyVolDbl);
d717 1
a717 1
   witFree (theDblVec);
d772 4
a775 3
   int priority[] = { 3, 3, 3, 3, 3 };
   float demandVol[] = { 500., 500., 500., 500., 500. };
   float  cumShipBoundsHL[]    = {1.2, 2.2,  3.2, 4.2, 5.2};
d777 1
a777 1
   float  cumShipBoundsSL[]    = {2.2, 2.22, 4.2, 5.2, 6.2};
d779 1
a779 1
   float  cumShipBoundsHU[]    = {-1., 200., -1., -1., -1.};
d781 2
a782 1
   float fssShipVol[] = { 500., 500., 450., 500., 500. };
d788 1
d801 1
d803 1
d812 4
d820 4
d1032 6
a1037 3
   float offset[]       = {0.0, 0.5, 1.0, 0.0, 0.0};
   float consRate[]     = {1.2, 2.3, 3.4, 4.5, 5.6};
   float routingShare[] = {5.0, 4.0, 3.0, 2.0, 1.0};
d1043 1
d1051 1
d1085 14
d1184 11
d1206 11
d1269 4
a1272 2
   float consRate[]     = {6.5, 5.4, 4.3, 3.2, 2.1};
   float routingShare[] = {1.0, 3.0, 1.0, 3.0, 1.0};
d1277 1
d1290 1
d1420 11
d1442 12
d1557 10
a1566 7
   char cat[100];
   float prodVol[]      = {5000., 5000., 2000., 0000., 2000.};
   float subProdVol1[]   = {4001., 4001., 1001., 501., 21.};
   float subProdVol[]   = {4000., 4000., 1000., 500., 20.};
   float shipVol[]      = {6000., 6000., 3000., 0000., 3000.};
   float *fv;
   char *string;
d1591 6
a1596 1
   witSetSubsBomEntryProdVol( theWitRun, "PS1", 0, 0, subProdVol1);
d1598 2
a1599 1
   compareFltVecs( fv, subProdVol1 );
d1601 1
a1601 1
   witSetSubsBomEntrySubVol( theWitRun, "PS1", 0, 0, subProdVol );
d1603 2
a1604 1
   compareFltVecs( fv, subProdVol );
d1606 4
a1609 1
   witFree (fv);
d1808 2
a1809 2
   float *fv;
   double * theDblVec;
d1815 3
a1817 3
   witGetPartConsVolDbl( theWitRun, "CompA", &theDblVec);
   printDblVec ("ConsVol", theDblVec);
   witFree (theDblVec);
d1823 4
d1831 4
d1839 3
a1841 3
   witGetPartProdVolDbl (theWitRun, "PS2", & theDblVec);
   printDblVec ("ProdVol", theDblVec);
   witFree (theDblVec);
d1847 4
d1855 3
a1857 3
   witGetPartShadowPriceDbl (theWitRun, "CompA", & theDblVec);
   printDblVec ("ShadowPrice", theDblVec);
   witFree (theDblVec);
d1863 4
d1868 1
a1868 1
   printFltVec ("OperationFssExecVol", fv);
d1871 4
d1876 1
a1876 1
   printFltVec ("witGetSubsBomEntryFssSubVol", fv);
d1879 3
a1881 3
   witGetSubsBomEntryFssSubVol( theWitRun, "PS1", 1, 0, &fv );
   printFltVec ("witGetSubsBomEntryFssSubVol", fv);
   witFree (fv);
d1887 4
d1957 2
a1958 1
   float *fv;
d1964 4
d1976 4
d1984 4
d1992 4
d2000 4
d2007 4
d2048 1
d2086 1
d2124 7
d2142 12
a2153 10
   float demandVolPS1US[]  = { 500., 500., 500., 500., 500. };
   float demandVolPS1AGP[] = { 500., 500., 500., 500., 500. };
   float demandVolPS2US[]  = { 500., 500.,1000.,1500.,1500. };
   float demandVolMOBILEUS[] = { 1000., 1000.,1000.,1000.,1000. };

   float obj1CumShipRewardPS1US[]  = { 50., 50., 40., 50., 50. };
   float obj1CumShipRewardPS1AGP[] = { 150., 150., 140., 150., 150. };

   float obj1ShipRewardPS1US[]  = { 5., 5., 4., 5., 5. };
   float obj1ShipRewardPS1AGP[] = { 15., 15., 14., 15., 15. };
d2162 2
d2182 3
a2184 1
   float *fv;
d2188 5
d2196 4
d2236 5
a2240 3
   float obj1SubCostCompA[]={ 1., 2., 3., 4., 5.};
   float obj1SubCostCompB[]={ 10., 20., 30., 40., 50.};
   float offsetCompA[]     ={ 2., 2., 3., 3., 3.};
d2244 3
d2248 1
d2261 7
d2274 7
d2501 14
d2528 13
d2554 13
d2580 13
d2606 13
d2632 13
d2665 20
a2684 15
   float trueYieldRate1[] = {1.0, 0.876, 0.874, 0.01, 0.0};
   int   trueYield1    [] = {100,   88,    87,     1,   0};

   int   trueYield2    [] = {   2,   0,    3,   0,   99};
   float trueYieldRate2[] = {0.02, 0.0, 0.03, 0.0, 0.99};

   float * witYieldRate;
   int *   witYield;

   witSetOperationYieldRate (wr2, "opn1",  trueYieldRate1);
   witGetOperationYieldRate (wr2, "opn1", & witYieldRate);
   witGetOperationYield     (wr2, "opn1", & witYield);

   compareFltVecs (witYieldRate, trueYieldRate1);
   compareIntVecs (witYield,     trueYield1);
d2689 3
a2691 3
   witSetOperationYield     (wr2, "opn1",  trueYield2);
   witGetOperationYield     (wr2, "opn1", & witYield);
   witGetOperationYieldRate (wr2, "opn1", & witYieldRate);
d2693 2
a2694 2
   compareIntVecs (witYield,     trueYield2);
   compareFltVecs (witYieldRate, trueYieldRate2);
d2853 13
d2895 14
d2935 1
a2935 1
   witSetBopEntryRoutingShare (wr1, "opn1", 0,   goodRoutingShare);
d2942 14
@


1.95
log
@Double Precision.
@
text
@d5 1
a5 2
/* at least once.                                                             */
/* Its purpose is for testing WIT.                                            */
@


1.94
log
@Fixed a syntax error.
@
text
@d1738 4
d2265 14
a2278 1
   /* execVol */
@


1.93
log
@Attempt to fix a syntax error from the AIX compiler.
@
text
@d3976 1
a3976 3
#endif
   //
   // OPT_IMPLODE
@


1.92
log
@Fixed link trouble in non-OPT_IMPLODE mode.
@
text
@d3976 3
a3978 1
#endif // OPT_IMPLODE
@


1.91
log
@Double Precision.
@
text
@d2149 3
d2153 3
d3863 2
d3975 2
@


1.90
log
@Double Precision.
@
text
@d1722 4
@


1.89
log
@Double Precision.
@
text
@d4112 1
a4112 1
   printf ("%s= ", attrName);
d4128 1
a4128 1
   printf ("%s= ", attrName);
d4144 1
a4144 1
   printf ("%s= ", attrName);
@


1.88
log
@Double Precision.
@
text
@d1 7
a7 5
/*****************************************************************************
 *
 * Invoke each api function at least once.
 *
 *****************************************************************************/
a24 25
/*****************************************************************************/
/* STREQ  returns true if string s1 and string s2 are equal.                 */
/*                                                                           */
/*****************************************************************************/
#define STREQ(s1,s2) (strcmp((s1),(s2))==0)

#define compareFloatVec(v1,v2) \
  for ( t=0; t<nPeriods; t++ ) assert( fabs((v1)[t] - (v2)[t]) < fltEps );

#define compareDoubleVec(v1,v2) \
  for ( t=0; t<nPeriods; t++ ) assert( fabs((v1)[t] - (v2)[t]) < fltEps );

#define compareIntVec(v1,v2) \
  for ( t=0; t<nPeriods; t++ ) assert( (v1)[t] == (v2)[t] );

#define printVec(a,fv) \
   printf(#a "= "); \
   for ( t=0; t<nPeriods; t++ ) printf(" %f",fv[t]); \
   printf("\n");

#define printIntVec(a,v) \
   printf(#a "= "); \
   for ( t=0; t<nPeriods; t++ ) printf(" %d",v[t]); \
   printf("\n");

d67 13
a79 1
/******************************************************************************/
d81 1
a81 1
/******************************************************************************/
a84 1
   const float fltEps = .00001;
a85 1
   const int   nPeriods = 5;
d277 2
a278 2
   assert( fabs(theFlt - 12.3) < fltEps );
   assert( fabs(theDbl - 12.3) < fltEps );
d283 2
a284 2
   assert( fabs(theFlt - 6.78) < fltEps );
   assert( fabs(theDbl - 6.78) < fltEps );
d309 2
a310 2
   assert( fabs(theFlt - 1.0e-4 ) < fltEps );
   assert( fabs(theDbl - 1.0e-4 ) < fltEps );
d315 2
a316 2
   assert( fabs(theFlt - 1.0e-3 ) < fltEps );
   assert( fabs(theDbl - 1.0e-3 ) < fltEps );
d341 2
a342 2
   assert( fabs(theFlt - 11. ) < fltEps );
   assert( fabs(theDbl - 11. ) < fltEps );
d347 2
a348 2
   assert( fabs(theFlt - 22. ) < fltEps );
   assert( fabs(theDbl - 22. ) < fltEps );
d353 2
a354 2
   assert( fabs(theFlt - 33. ) < fltEps );
   assert( fabs(theDbl - 33. ) < fltEps );
d359 2
a360 2
   assert( fabs(theFlt - 44. ) < fltEps );
   assert( fabs(theDbl - 44. ) < fltEps );
d372 2
a373 2
   assert( fabs(theFlt - 44000. ) < fltEps );
   assert( fabs(theDbl - 44000. ) < fltEps );
d496 3
a498 3
   compareDoubleVec( hlb, defaultBoundsHLDbl );
   compareDoubleVec( slb, stockBoundsSLDbl );
   compareDoubleVec( hub, stockBoundsHUDbl );
d519 3
a521 3
   compareFloatVec( hlb, prodBoundsHL );
   compareFloatVec( slb, prodBoundsSL );
   compareFloatVec( hub, defaultBoundsHU );
d532 3
a534 3
   compareFloatVec( hlb, defaultBoundsHL );
   compareFloatVec( slb, stockBoundsSL );
   compareFloatVec( hub, stockBoundsHU );
d543 1
a543 1
   compareFloatVec( my_yield, yield );
d551 1
a551 1
   compareFloatVec( fv, minLotSize );
d555 1
a555 1
   compareFloatVec( fv, incLotSize );
d559 1
a559 1
   compareFloatVec( fv, cycle );
d565 2
a566 2
   assert( fabs(theFlt - 50.0) < fltEps );
   assert( fabs(theDbl - 50.0) < fltEps );
d607 1
a607 1
   compareIntVec (iv, buildAheadUB);
d691 1
a691 1
   compareFloatVec( fv, supplyVol );
d711 1
a711 1
   compareFloatVec( fv, supplyVol );
d716 1
a716 1
   compareDoubleVec (theDblVec, supplyVolDbl);
d736 1
a736 1
   compareFloatVec( fv, supplyVol );
d754 1
a754 1
   compareFloatVec( fv, supplyVol );
d805 1
a805 1
   compareFloatVec( fv, demandVol );
d809 1
a809 1
   compareFloatVec( fv, fssShipVol );
d821 3
a823 3
   compareDoubleVec( hlb, cumShipBoundsHLDbl );
   compareDoubleVec( slb, cumShipBoundsSLDbl );
   compareDoubleVec( hub, cumShipBoundsHUDbl );
d838 3
a840 3
   compareFloatVec( hlb, cumShipBoundsHL );
   compareFloatVec( slb, cumShipBoundsSL );
   compareFloatVec( hub, cumShipBoundsHU );
d867 1
a867 1
   compareIntVec (iv, buildAheadUB);
d893 1
a893 1
   compareIntVec (iv, shipLateUB);
d909 2
a910 2
   assert( fabs(theFlt - 200.0) < fltEps );
   assert( fabs(theDbl - 200.0) < fltEps );
d946 1
a946 1
   compareFloatVec( fv, demandVol );
d987 1
a987 1
   compareFloatVec( fv, demandVol );
d1011 1
a1011 1
   compareFloatVec( fv, demandVol );
d1051 1
a1051 1
     compareFloatVec( off, offset );
d1062 1
a1062 1
     compareFloatVec( off, offset );
d1070 1
a1070 1
     assert( STREQ(s,"TestCap") );
d1093 1
a1093 1
   assert (fabs (theFalloutRate - 0.026) < fltEps);
d1102 2
a1103 2
   assert (fabs (theFalloutRate    - 0.04) < fltEps);
   assert (fabs (theFalloutRateDbl - 0.04) < fltEps);
d1126 2
a1127 2
   assert (fabs (theFlt - 34.76) < fltEps);
   assert (fabs (theDbl - 34.76) < fltEps);
d1133 1
a1133 1
   assert( fabs( bomEntryUsageTime + 0.1 ) < fltEps );
d1143 1
a1143 1
   assert (fabs (usageRate - 1.2) < fltEps);
d1147 1
a1147 1
   compareFloatVec (consRate, goodConsRate);
d1158 1
a1158 1
   compareFloatVec (routingShare, goodRoutingShare);
d1194 1
a1194 1
   compareIntVec (impactPeriod, correctImpactPeriod);
d1251 1
a1251 1
   assert( STREQ(s,"CompB") );
d1274 2
a1275 2
   assert (fabs (theFalloutRate    - 0.054) < fltEps);
   assert (fabs (theFalloutRateDbl - 0.054) < fltEps);
d1283 1
a1283 1
   assert (fabs (theFalloutRate - 0.17) < fltEps);
d1302 2
a1303 2
   assert( fabs( subsBomEntryObj2SubPenalty    - 8.0 ) < fltEps );
   assert( fabs( subsBomEntryObj2SubPenaltyDbl - 8.0 ) < fltEps );
d1342 2
a1343 2
   assert (fabs (subsBomEntryExpNetAversion    - 1.2) < fltEps);
   assert (fabs (subsBomEntryExpNetAversionDbl - 1.2) < fltEps);
d1353 1
a1353 1
   assert (fabs (usageRate - 6.5) < fltEps);
d1357 1
a1357 1
   compareFloatVec (consRate, goodConsRate);
d1368 1
a1368 1
   compareFloatVec (routingShare, goodRoutingShare);
d1380 2
a1381 2
   assert (fabs (theFlt - 29.87) < fltEps);
   assert (fabs (theDbl - 29.87) < fltEps);
d1399 1
a1399 1
   compareIntVec (impactPeriod, correctImpactPeriod);
d1500 1
a1500 1
   compareFloatVec( fv, prodVol );
d1505 1
a1505 1
   compareFloatVec( fv, shipVol );
d1510 1
a1510 1
   compareFloatVec( fv, subProdVol1 );
d1514 1
a1514 1
   compareFloatVec( fv, subProdVol );
d1683 1
a1683 1
      printVec("focusedShortage", focShortVol[i] );
d1705 1
a1705 1
      printVec("focusedShortage", focShortVol[i] );
d1719 1
a1719 1
   printVec(ConsVol,fv);
d1723 1
a1723 1
   printVec(ResidualVol,fv);
d1727 1
a1727 1
   printVec(ExcessVol,fv);
d1731 1
a1731 1
   printVec(ProdVol,fv);
d1735 1
a1735 1
   printVec(ScrapVol,fv);
d1739 1
a1739 1
   printVec(ShadowPrice,fv);
d1743 1
a1743 1
   printVec (ShadowPrice, theDblVec);
d1747 1
a1747 1
   printVec(FocusShortageVol,fv);
d1751 1
a1751 1
   printVec(OperationFssExecVol,fv);
d1755 1
a1755 1
   printVec(witGetSubsBomEntryFssSubVol,fv);
d1759 1
a1759 1
   printVec(witGetSubsBomEntryFssSubVol,fv);
d1763 1
a1763 1
   printVec(StockVol,fv);
d1767 1
a1767 1
   printVec(SupplyVol,fv);
d1776 1
a1776 1
   printVec(ShipVol,fv);
d1784 1
a1784 1
   printVec(ProdVol,fv);
d1835 1
a1835 1
   printVec(ReqVol,fv);
d1839 1
a1839 1
   printVec(MrpProdVol,fv);
d1843 1
a1843 1
   printVec(MrpResidualVol,fv);
d1847 1
a1847 1
   printVec(MrpExcessVol,fv);
d1851 1
a1851 1
   printVec(MrpConsVol,fv);
d1855 1
a1855 1
   printVec(MrpExecVol,fv);
d1859 1
a1859 1
   printVec(MrpSubVol,fv);
d1947 1
a1947 1
   compareFloatVec( cost, obj1ProdCost );
d1954 1
a1954 1
   compareFloatVec( cost, obj1ScrapCost );
d1961 1
a1961 1
   compareDoubleVec( cost, obj1ScrapCostDbl );
d1968 1
a1968 1
   compareFloatVec( cost, obj1StockCost );
d2021 1
a2021 1
   compareFloatVec( fv, obj1ShipRewardPS1US );
d2024 1
a2024 1
   compareFloatVec( fv, obj1CumShipRewardPS1US );
d2077 1
a2077 1
   compareFloatVec( fv, obj1SubCostCompA );
d2084 1
a2084 1
   compareFloatVec( fv, offsetCompA );
a2173 1
   const float fltEps = .00001;
a2174 1
   const int   nPeriods = 5;
d2207 3
a2209 3
   compareFloatVec(hlb,hlb1);
   compareFloatVec(slb,slb1);
   compareFloatVec(hub,hub1);
d2226 3
a2228 3
   compareFloatVec(hlb,hlb1);
   compareFloatVec(slb,slb1);
   compareFloatVec(hub,hub1);
d2243 1
a2243 1
   assert( fabs(theDbl - 272.89) < fltEps );
d2248 1
a2248 1
   assert( fabs(theFlt - 72.89) < fltEps );
d2259 1
a2259 1
   compareFloatVec(fltVec,fltVec1);
d2282 1
a2282 1
   compareFloatVec(fltVec,fltVec1);
d2296 1
a2296 1
   compareFloatVec(fltVec,fltVec1);
d2309 1
a2309 1
   compareFloatVec(fltVec,fltVec1);
d2322 1
a2322 1
   compareFloatVec(fltVec,fltVec1);
d2335 1
a2335 1
   compareFloatVec(fltVec,fltVec1);
d2348 1
a2348 1
   compareFloatVec(fltVec,fltVec1);
d2362 1
a2362 1
   assert( fabs(theDbl - 4.51) < fltEps );
d2367 1
a2367 1
   assert( fabs(theFlt - 3.14) < fltEps );
d2386 2
a2387 2
   compareFloatVec (witYieldRate, trueYieldRate1);
   compareIntVec   (witYield,     trueYield1);
d2396 2
a2397 2
   compareIntVec   (witYield,     trueYield2);
   compareFloatVec (witYieldRate, trueYieldRate2);
d2425 1
a2425 1
   compareIntVec (executable, correctExecutable);
d2436 1
a2436 1
   assert( STREQ (operationList[0],"opn1"));
a2469 1
   const float fltEps = .00001;
a2470 1
   const int   nPeriods = 5;
d2551 1
a2551 1
   compareFloatVec(fltVec,fltVec1);
d2565 1
a2565 1
   assert (fabs (prodRateRet - 2.0) < fltEps);
d2569 1
a2569 1
   compareFloatVec (productRateRet, productRateEnt);
d2576 1
a2576 1
   assert (fabs (prodRateRet - 1.0) < fltEps);
d2580 1
a2580 1
   assert (fabs (productRateRet[2] - 1.0) < fltEps);
d2593 1
a2593 1
   assert (fabs (aversion + 4.0) < fltEps);
d2598 1
a2598 1
   assert (fabs (aversionDbl - 53.0) < fltEps);
d2603 1
a2603 1
   assert (fabs (aversion - 0.0) < fltEps);
d2615 1
a2615 1
   compareFloatVec (routingShare, goodRoutingShare);
d2624 1
a2624 1
   assert( STREQ(s,"part1") );
d2650 1
a2650 1
   compareIntVec (impactPeriod, correctImpactPeriod);
a2661 1
   const float fltEps = .00001;
a2662 1
   const int   nPeriods = 5;
d2803 1
a2803 1
   assert (STREQ (theOperationName, "OB"));
d2815 1
a2815 1
   assert (STREQ (theOperationName, "OA"));
d2828 1
a2828 1
   assert (STREQ (theOperationName, "OB"));
d4049 101
@


1.87
log
@Double Precision.
@
text
@d1729 1
d1754 4
@


1.86
log
@Double Precision.
@
text
@d1897 11
a1907 10
   float supplyVolCompA[] = {2000., 2000., 2000., 2000., 2000.};
   float supplyVolCompB[] = {3500., 2500., 2500., 2500., 2500.};
   float supplyVolCompC[] = {2000., 2000., 2000., 2000., 2000.};
   float supplyVolCap[] = {3500., 3500., 3500., 3500., 3500.};

   float obj1ProdCost  [] = {1.1,  1.2,  1.3,  1.4,  1.5};
   float obj1ScrapCost [] = {0.1,  0.2,  0.3,  0.4,  0.5};
   float obj1StockCost [] = {0.01, 0.02, 0.03, 0.04, 0.05};
   float incLotSize    [] = { 500.0,  500.0,  500.0,  500.0,  500.0};
   float minLotSize    [] = {2500.0, 2500.0, 2500.0, 2500.0, 2500.0};
d1941 1
d1963 7
@


1.85
log
@Double Precision.
@
text
@d479 8
a486 5
   float      stockBoundsSL[] = {20., 20.2, 40., 50., 60.};
   float      stockBoundsHU[] = {20., 20.2, 40., 50., 60.};
   float      defaultBoundsHU[] = {-1.0, -1.0, -1.0, -1.0, -1.0};
   float      defaultBoundsHL[] = {0.0, 0.0, 0.0, 0.0, 0.0};
   float      defaultBoundsSL[] = {0.0, 0.0, 0.0, 0.0, 0.0};
d502 15
d788 6
a793 3
   float cumShipBoundsHL[] = {1.2, 2.2,  3.2, 4.2, 5.2};
   float cumShipBoundsSL[] = {2.2, 2.22, 4.2, 5.2, 6.2};
   float cumShipBoundsHU[] = {-1., 200., -1., -1., -1.};
a812 2
   witSetDemandCumShipBounds( theWitRun, "PS1", "US", 
      cumShipBoundsHL, cumShipBoundsSL, cumShipBoundsHU);
d826 17
d846 3
d2198 20
a2217 1
   /* execBounds */
@


1.84
log
@Double Precision.
@
text
@d32 3
d698 1
d708 6
@


1.83
log
@Double Precision.
@
text
@d692 2
a693 1
   float supplyVol[] = {3500., 2500., 2500., 2500., 2500.};
d699 1
a699 1
   witSetPartSupplyVol( theWitRun, "CompB", supplyVol );
@


1.82
log
@Double Precision.
@
text
@a85 1
void testDoubleMode (witBoolean doubleMode);
a470 2
   testDoubleMode (argc > 1);

a3984 43
   }

/*----------------------------------------------------------------------------*/
/* testDoubleMode                                                             */
/*                                                                            */
/* If doubleMode is true, WIT is to be used in double mode.                   */
/*----------------------------------------------------------------------------*/

void testDoubleMode (witBoolean doubleMode)
   {
   WitRun *   theWitRun1;
   WitRun *   theWitRun2;
   witBoolean theBool;

   printf (
      "\n"
      "--- Testing Double Precision Mode ---\n");

   witNewRun      (& theWitRun1);

   witInitialize    (theWitRun1);

   witSetDoubleMode (theWitRun1,   WitTRUE);

   witDeleteRun     (theWitRun1);

   theWitRun1 = NULL;



   witNewRun      (& theWitRun2);

   witInitialize    (theWitRun2);

   witGetDoubleMode (theWitRun2, & theBool);

   assert                         (theBool);

   witSetDoubleMode (theWitRun2, doubleMode);

   witDeleteRun     (theWitRun2);

   theWitRun2 = NULL;
@


1.81
log
@Double Precision.
@
text
@d86 1
a86 1
void testDoubleMode ();
d472 1
a472 1
   testDoubleMode ();
d3992 2
d3996 1
a3996 1
void testDoubleMode ()
d4025 2
@


1.80
log
@Double Precision
@
text
@d472 1
a2117 2
   testDoubleMode ();

d3996 2
a3997 2
   WitRun *   theWitRun;
   WitRun *   secWitRun;
d4004 3
a4006 1
   witNewRun      (& theWitRun);
d4008 1
a4008 1
   witSetDoubleMode (theWitRun,   WitTRUE);
d4010 1
a4010 1
   witNewRun      (& secWitRun);
d4012 1
a4012 1
   witInitialize    (secWitRun);
a4013 1
   witGetDoubleMode (secWitRun, & theBool);
a4014 1
   assert                        (theBool);
d4016 1
a4016 1
   witDeleteRun     (secWitRun);
d4018 1
a4018 1
   secWitRun = NULL;
d4020 1
a4020 1
   witSetDoubleMode (theWitRun,   WitFALSE);
d4022 1
a4022 1
   witGetDoubleMode (theWitRun, & theBool);
d4024 1
a4024 1
   assert                      (! theBool);
d4026 1
a4026 1
   witDeleteRun     (theWitRun);
@


1.79
log
@Double precision.
@
text
@d2784 1
d2852 1
a2852 1
   witIncHeurAlloc  (
d2862 1
a2862 1
   witIncHeurAlloc  (
d2868 1
a2868 1
      & incVol);
d2870 1
a2870 1
   assert (incVol == 4.0);
d2895 1
d2978 1
a2978 1
   witIncHeurAllocTwme (
d2984 1
a2984 1
      & incVol,
d2987 1
a2987 1
   assert (incVol == 4.0);
@


1.78
log
@Double precision.
@
text
@d3333 1
d3346 20
a3365 6
      witAppendToPipSeq (
         theWitRun,
         partNameList  [theIdx],
         demandNameList[theIdx],
         shipPerList   [theIdx],
         incShipVolList[theIdx]);
@


1.77
log
@Continued double precision.
@
text
@d1547 2
a1548 1
   float objValue, boundsValue, rev, inv, serv, subs;
d1554 14
a1567 3
   witGetObj2Values( theWitRun, &rev, &inv, &serv, &subs );
   printf( "obj2Rev=%f, obj2Inv=%f, obj2Serv=%f, obj2Subs=%f\n",
           rev, inv, serv, subs );
@


1.76
log
@Continued double precision.
@
text
@d189 2
a190 1
   witSetCapCost( theWitRun, 12.3 );
d198 2
a199 1
   witSetInvCost( theWitRun, 6.78 );
d209 10
a218 5
   witSetObj2Winv( theWitRun, 11. );
   witSetObj2Wrev( theWitRun, 22. );
   witSetObj2Wserv(theWitRun, 33. );
   witSetObj2Wsub( theWitRun, 44. );
   witSetPeriodsPerYear( theWitRun, 12. );
d285 3
a287 1
   witGetCapCost( theWitRun, &theFlt );
d289 7
d317 3
a319 1
   witGetLotSizeTol( theWitRun, &theFlt );
d321 1
d323 2
a324 2
   witGetLotSizeTolDbl( theWitRun, &theDbl );
   assert( fabs(theDbl - 1.0e-4 ) < fltEps );
a325 1
   witGetExpCutoff( theWitRun, &theFlt );
a326 2

   witGetExpCutoffDbl( theWitRun, &theDbl );
d340 3
a342 1
   witGetPeriodsPerYear( theWitRun, &theFlt );
d344 1
d349 3
a351 1
   witGetObj2Winv( theWitRun, &theFlt );
d353 4
a357 1
   witGetObj2Wrev( theWitRun, &theFlt );
d359 4
a363 1
   witGetObj2Wserv( theWitRun, &theFlt );
d365 4
a369 1
   witGetObj2Wsub( theWitRun, &theFlt );
d371 1
d380 3
a382 1
   witGetWbounds( theWitRun, &theFlt );
a383 2

   witGetWboundsDbl( theWitRun, &theDbl );
d486 2
d498 2
a499 1
   witSetPartUnitCost( theWitRun, "PS1", 50.0 );
d556 6
d767 2
d778 1
d871 6
d997 2
a998 1
   witSetBomEntryExecPenalty  (theWitRun, "PS1", 0, 34.76);
d1049 8
a1056 6
   float theFalloutRate;
   int   theFallout;

   witSetBomEntryFalloutRate (theWitRun, "PS1", 0, 0.026);
   witGetBomEntryFalloutRate (theWitRun, "PS1", 0, & theFalloutRate);
   witGetBomEntryFallout     (theWitRun, "PS1", 0, & theFallout);
d1061 4
a1064 3
   witSetBomEntryFallout     (theWitRun, "PS1", 0, 4);
   witGetBomEntryFallout     (theWitRun, "PS1", 0, & theFallout);
   witGetBomEntryFalloutRate (theWitRun, "PS1", 0, & theFalloutRate);
d1067 2
a1068 1
   assert (fabs (theFalloutRate - 0.04) < fltEps);
d1085 2
a1086 1
   float execPenalty;
d1088 2
a1089 1
   witGetBomEntryExecPenalty (theWitRun, "PS1", 0, & execPenalty);
d1091 2
a1092 1
   assert (fabs (execPenalty - 34.76) < fltEps);
d1189 2
a1190 1
   witSetSubsBomEntryObj2SubPenalty( theWitRun, "PS1", 0, 0, 8. );
d1193 4
a1196 2
   witSetSubsBomEntryExpNetAversion (theWitRun, "PS1", 0, 0, 1.2);
   witSetSubsBomEntryExecPenalty (theWitRun, "PS1", 0, 0, 29.87);
d1228 10
a1237 6
   float theFalloutRate;
   int   theFallout;

   witSetSubsBomEntryFalloutRate (theWitRun, "PS1", 0, 0, 0.054);
   witGetSubsBomEntryFalloutRate (theWitRun, "PS1", 0, 0, & theFalloutRate);
   witGetSubsBomEntryFallout     (theWitRun, "PS1", 0, 0, & theFallout);
d1239 2
a1240 1
   assert (fabs (theFalloutRate - 0.054) < fltEps);
d1253 2
a1254 1
   witGetSubsBomEntryLatestPeriod( theWitRun, "PS1", 0, 0, &subsBomEntryLatestPeriod );
d1259 10
a1268 3
   float subsBomEntryObj2SubPenalty;
   witGetSubsBomEntryObj2SubPenalty( theWitRun, "PS1", 0, 0, &subsBomEntryObj2SubPenalty );
   assert( fabs( subsBomEntryObj2SubPenalty - 8.0 ) < fltEps );
d1299 3
a1301 1
   float subsBomEntryExpNetAversion;
d1304 2
d1307 2
a1308 1
   assert (fabs (subsBomEntryExpNetAversion - 1.2) < fltEps);
d1339 2
a1340 1
   float execPenalty;
d1342 2
a1343 1
   witGetSubsBomEntryExecPenalty (theWitRun, "PS1", 0, 0, & execPenalty);
d1345 2
a1346 1
   assert (fabs (execPenalty - 29.87) < fltEps);
d2161 7
a2167 1
   float flt;
d2170 1
a2170 1
   witGetOperationExecPenalty( wr2, "opn1", &flt );
d2172 1
a2172 1
   assert( fabs(flt - 72.89) < fltEps );
d2280 7
a2286 1
   float flt;
d2289 1
a2289 1
   witGetOperationObj2AuxCost( wr2, "opn1", &flt );
d2291 1
a2291 1
   assert( fabs(flt - 3.14) < fltEps );
@


1.75
log
@Continued double precision.
@
text
@d214 1
d351 3
@


1.74
log
@Continued double precision.
@
text
@d202 1
d247 2
a248 2
   float f;
   double d;
d277 2
a278 2
   witGetCapCost( theWitRun, &f );
   assert( fabs(f - 12.3) < fltEps );
d300 2
a301 2
   witGetLotSizeTol( theWitRun, &f );
   assert( fabs(f - 1.0e-4 ) < fltEps );
d303 2
a304 2
   witGetLotSizeTolDbl( theWitRun, &d );
   assert( fabs(d - 1.0e-4 ) < fltEps );
d306 5
a310 2
   witGetExpCutoff( theWitRun, &f );
   assert( fabs(f - 1.0e-3 ) < fltEps );
d323 2
a324 2
   witGetPeriodsPerYear( theWitRun, &f );
   assert( f == 12.0 );
d329 2
a330 2
   witGetObj2Winv( theWitRun, &f );
   assert( fabs(f - 11. ) < fltEps );
d332 2
a333 2
   witGetObj2Wrev( theWitRun, &f );
   assert( fabs(f - 22. ) < fltEps );
d335 2
a336 2
   witGetObj2Wserv( theWitRun, &f );
   assert( fabs(f - 33. ) < fltEps );
d338 2
a339 2
   witGetObj2Wsub( theWitRun, &f );
   assert( fabs(f - 44. ) < fltEps );
d348 2
a349 2
   witGetWbounds( theWitRun, &f );
   assert( fabs(f - 44000. ) < fltEps );
@


1.73
log
@Continued double precision.
@
text
@d200 1
d247 1
d301 3
@


1.72
log
@Continued double precision.
@
text
@d2410 6
a2415 2
   witSetBopEntryExpAversion    (wr1, "opn1", 0, -4.0);
   witGetBopEntryExpAversion    (wr1, "opn1", 0, & aversion);
d2418 1
a2418 2
   assert (fabs (aversion    + 4.0) < fltEps);
   assert (fabs (aversionDbl + 4.0) < fltEps);
@


1.71
log
@Continued double precision.
@
text
@a86 2
void testDPAtt ();
void testDPScalars ();
d2408 1
d2410 3
a2412 2
   witSetBopEntryExpAversion (wr1, "opn1", 0, -4.0);
   witGetBopEntryExpAversion (wr1, "opn1", 0, & aversion);
d2414 2
a2415 1
   assert (fabs (aversion + 4.0) < fltEps);
d3859 4
a3866 14
   testDPAtt ();
   testDPScalars ();
   }

/*----------------------------------------------------------------------------*/
/* testDPAtt                                                                  */
/*----------------------------------------------------------------------------*/

void testDPAtt ()
   {
   WitRun *   theWitRun;
   WitRun *   secWitRun;
   witBoolean theBool;

a3889 28
   }

/*----------------------------------------------------------------------------*/
/* testDPScalars                                                              */
/*----------------------------------------------------------------------------*/

void testDPScalars ()
   {
   WitRun * theWitRun;
   double   theDouble;

   witNewRun                  (& theWitRun);
   witSetDoubleMode             (theWitRun,   WitTRUE);
   witInitialize                (theWitRun);

   witSetNPeriods               (theWitRun, 1);

   witAddOperation              (theWitRun, "A");
   witAddPart                   (theWitRun, "B", WitCAPACITY);
   witAddBopEntry               (theWitRun, "A", "B");
   
   witSetBopEntryExpAversion    (theWitRun, "A", 0, 3.0);

   witGetBopEntryExpAversionDbl (theWitRun, "A", 0, & theDouble);

   assert (fabs (theDouble - 3.0) < 0.0001);

   witDeleteRun                 (theWitRun);
@


1.70
log
@Continued double precision testing.
@
text
@d86 1
a86 1
void testDoublePrecision ();
d2013 1
a2013 1
   testDoublePrecision ();
d3853 1
a3853 1
/* testDoublePrecision                                                        */
d3856 1
a3856 1
void testDoublePrecision ()
d3876 1
a3876 1
   witNewRun           (& theWitRun);
d3878 1
a3878 1
   witSetDoublePrecision (theWitRun,   WitTRUE);
d3880 1
a3880 1
   witNewRun           (& secWitRun);
d3882 1
a3882 1
   witInitialize         (secWitRun);
d3884 1
a3884 1
   witGetDoublePrecision (secWitRun, & theBool);
d3886 1
a3886 1
   assert                             (theBool);
d3888 1
a3888 1
   witDeleteRun          (secWitRun);
d3892 1
a3892 1
   witSetDoublePrecision (theWitRun,   WitFALSE);
d3894 1
a3894 1
   witGetDoublePrecision (theWitRun, & theBool);
d3896 1
a3896 1
   assert                           (! theBool);
d3898 1
a3898 1
   witDeleteRun          (theWitRun);
d3911 1
a3911 1
   witSetDoublePrecision        (theWitRun,   WitTRUE);
@


1.69
log
@Added code to test the API functions for the doublePrecision attribute.
@
text
@a44 1
void testDoublePrecision ();
d86 3
a108 2
   testDoublePrecision ();

d2013 2
a2019 35
/* testDoublePrecision                                                        */
/*----------------------------------------------------------------------------*/

void testDoublePrecision ()
   {
   WitRun *   wr1;
   WitRun *   wr2;
   witBoolean theBool;

   witNewRun           (& wr1);

   witSetDoublePrecision (wr1,   WitTRUE);

   witNewRun           (& wr2);

   witInitialize         (wr2);

   witGetDoublePrecision (wr2, & theBool);

   assert                       (theBool);

   witDeleteRun          (wr2);

   wr2 = NULL;

   witSetDoublePrecision (wr1,   WitFALSE);

   witGetDoublePrecision (wr1, & theBool);

   assert                     (! theBool);

   witDeleteRun          (wr1);
   }

/*----------------------------------------------------------------------------*/
d2409 1
a2409 1
   float aversion;
d3850 77
@


1.68
log
@Removed the code that tested the "pip" attribute.
@
text
@d45 1
d107 2
d2016 37
@


1.67
log
@Modified code to test PIP.
@
text
@a57 1
void testOldPip         (WitRun *);
d1716 1
a1716 2
   testOldPip (theWitRun);
   testPip    (theWitRun);
a3142 26
   }

/*----------------------------------------------------------------------------*/
/* testOldPip                                                                 */
/*----------------------------------------------------------------------------*/

void testOldPip (WitRun * theWitRun)
   {
   witBoolean theBool;

   witSetPip        (theWitRun, WitTRUE);

   witGetPip        (theWitRun, & theBool);

   assert           (theBool);

   witHeurImplode   (theWitRun);

   testExecVolPip   (theWitRun, "PS1", "US", 1);
   testSubVolPip    (theWitRun, "PS1", "US", 1);
   testSupplyVolPip (theWitRun, "PS1", "US", 1);
   testSideVolPip   (theWitRun, "PS1", "US", 1);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

   witSetPip        (theWitRun, WitFALSE);
@


1.66
log
@Decreased output From PIP.
@
text
@d3181 1
a3181 1
   witSetHeurPipSeq (theWitRun, WitTRUE);
d3183 1
a3183 1
   witGetHeurPipSeq (theWitRun, & theBool);
d3185 1
a3185 1
   assert           (theBool);
d3187 1
a3187 1
   witGetPipExists  (theWitRun, & theBool);
d3189 1
a3189 1
   assert           (! theBool);
d3191 1
a3191 1
   witHeurImplode   (theWitRun);
d3193 1
a3193 1
   witBuildPip      (theWitRun);
d3195 1
a3195 1
   witGetPipExists  (theWitRun, & theBool);
d3197 1
a3197 1
   assert           (theBool);
d3199 6
a3204 6
   testExecVolPip   (theWitRun, "PS1", "US", 2);
   testSubVolPip    (theWitRun, "PS1", "US", 2);
   testSupplyVolPip (theWitRun, "PS1", "US", 2);
   testSideVolPip   (theWitRun, "PS1", "US", 2);
   testProdVolPip   (theWitRun, "PS1", "US", 2);
   testConsVolPip   (theWitRun, "PS1", "US", 2);
d3206 1
a3206 1
   reversePipSeq    (theWitRun);
d3208 1
a3208 1
   witBuildPip      (theWitRun);
d3210 6
a3215 6
   testExecVolPip   (theWitRun, "PS1", "US", 2);
   testSubVolPip    (theWitRun, "PS1", "US", 2);
   testSupplyVolPip (theWitRun, "PS1", "US", 2);
   testSideVolPip   (theWitRun, "PS1", "US", 2);
   testProdVolPip   (theWitRun, "PS1", "US", 2);
   testConsVolPip   (theWitRun, "PS1", "US", 2);
@


1.65
log
@Replaced portableFree with witFree.
@
text
@a59 1
void printPipSeq        (WitRun *);
a3192 2
   printPipSeq      (theWitRun);

a3207 2
   printPipSeq      (theWitRun);

a3215 44
   }

/*----------------------------------------------------------------------------*/
/* printPipSeq                                                                */
/*----------------------------------------------------------------------------*/

void printPipSeq (WitRun * theWitRun)
   {
   int      lenLists;
   char * * partNameList;
   char * * demandNameList;
   int *    shipPerList;   
   float *  incShipVolList;
   int      theIdx;

   witGetPipSeq (
        theWitRun,
      & lenLists,
      & partNameList,
      & demandNameList,
      & shipPerList,
      & incShipVolList);

   printf (
      "\n"
      "PIP Shipment Sequence:\n\n");

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      printf ("   Part %s, Demand %s, ShipPer %d, IncShipVol: %.0f\n",
         partNameList  [theIdx],
         demandNameList[theIdx],
         shipPerList   [theIdx],
         incShipVolList[theIdx]);

   for (theIdx = 0; theIdx < lenLists; theIdx ++)
      {
      witFree (partNameList  [theIdx]);
      witFree (demandNameList[theIdx]);
      }

   witFree (partNameList);
   witFree (demandNameList);
   witFree (shipPerList);
   witFree (incShipVolList);
@


1.64
log
@Fixed a comment bug.
@
text
@a87 1
void portableFree (void *);
d338 1
a338 1
   portableFree ( title );
d470 3
a472 3
   portableFree (hlb);
   portableFree (slb);
   portableFree (hub);
d483 3
a485 3
   portableFree (hlb);
   portableFree (slb);
   portableFree (hub);
d492 1
a492 1
   portableFree (my_yield);
d500 1
a500 1
   portableFree (fv);
d504 1
a504 1
   portableFree (fv);
d508 1
a508 1
   portableFree (fv);
d543 1
a543 1
   portableFree (iv);
d551 1
a551 1
   portableFree (iv);
d614 4
a617 4
   portableFree ( partList[0] );
   portableFree ( partList[1] );
   portableFree ( partList[2] );
   portableFree ( partList );
d634 1
a634 1
   portableFree (fv);
d652 1
a652 1
   portableFree (fv);
d671 1
a671 1
   portableFree (fv);
d689 1
a689 1
   portableFree (fv);
d736 1
a736 1
   portableFree (fv);
d751 3
a753 3
   portableFree (hlb);
   portableFree (slb);
   portableFree (hub);
d771 1
a771 1
   portableFree (iv);
d779 1
a779 1
   portableFree (iv);
d797 1
a797 1
   portableFree (iv);
d805 1
a805 1
   portableFree (iv);
d851 1
a851 1
   portableFree (fv);
d869 3
a871 3
   portableFree ( demandList[0] );
   portableFree ( demandList[1] );
   portableFree ( demandList );
d892 1
a892 1
   portableFree (fv);
d916 1
a916 1
   portableFree (fv);
d956 1
a956 1
     portableFree (off);
d967 1
a967 1
     portableFree (off);
d974 1
a974 1
     portableFree (s);
d1045 1
a1045 1
   portableFree (consRate);
d1056 1
a1056 1
   portableFree (routingShare);
d1092 1
a1092 1
   portableFree (impactPeriod);
d1145 1
a1145 1
   portableFree (s);
d1234 1
a1234 1
   portableFree (consRate);
d1245 1
a1245 1
   portableFree (routingShare);
d1273 1
a1273 1
   portableFree (impactPeriod);
d1302 1
a1302 1
      portableFree (partNameList[i]);
d1304 1
a1304 1
   portableFree (partNameList);
d1373 1
a1373 1
   portableFree (fv);
d1378 1
a1378 1
   portableFree (fv);
d1388 1
a1388 1
   portableFree (fv);
d1524 1
a1524 1
      portableFree (critPartList[i]);
d1526 2
a1527 2
   portableFree (critPartList);
   portableFree (critPerList);
d1542 1
a1542 1
      portableFree (partList[i]);
d1544 1
a1544 1
      portableFree (focShortVol[i]);
d1546 2
a1547 2
   portableFree (partList);
   portableFree (focShortVol);
d1564 1
a1564 1
      portableFree (partList[i]);
d1566 1
a1566 1
      portableFree (focShortVol[i]);
d1568 2
a1569 2
   portableFree (partList);
   portableFree (focShortVol);
d1579 1
a1579 1
   portableFree (fv);
d1583 1
a1583 1
   portableFree (fv);
d1587 1
a1587 1
   portableFree (fv);
d1591 1
a1591 1
   portableFree (fv);
d1595 1
a1595 1
   portableFree (fv);
d1599 1
a1599 1
   portableFree (fv);
d1603 1
a1603 1
   portableFree (fv);
d1607 1
a1607 1
   portableFree (fv);
d1611 1
a1611 1
   portableFree (fv);
d1615 1
a1615 1
   portableFree (fv);
d1619 1
a1619 1
   portableFree (fv);
d1623 1
a1623 1
   portableFree (fv);
d1632 1
a1632 1
   portableFree (fv);
d1640 1
a1640 1
   portableFree (fv);
d1691 1
a1691 1
   portableFree (fv);
d1695 1
a1695 1
   portableFree (fv);
d1699 1
a1699 1
   portableFree (fv);
d1703 1
a1703 1
   portableFree (fv);
d1707 1
a1707 1
   portableFree (fv);
d1711 1
a1711 1
   portableFree (fv);
d1715 1
a1715 1
   portableFree (fv);
d1802 1
a1802 1
   portableFree (cost);
d1809 1
a1809 1
   portableFree (cost);
d1816 1
a1816 1
   portableFree (cost);
d1869 1
a1869 1
   portableFree (fv);
d1872 1
a1872 1
   portableFree (fv);
d1925 1
a1925 1
   portableFree (fv);
d1932 1
a1932 1
   portableFree (fv);
d2058 3
a2060 3
   portableFree (hlb1);
   portableFree (slb1);
   portableFree (hub1);
d2083 1
a2083 1
   portableFree (fltVec1);
d2106 1
a2106 1
   portableFree (fltVec1);
d2120 1
a2120 1
   portableFree (fltVec1);
d2133 1
a2133 1
   portableFree (fltVec1);
d2146 1
a2146 1
   portableFree (fltVec1);
d2159 1
a2159 1
   portableFree (fltVec1);
d2172 1
a2172 1
   portableFree (fltVec1);
d2205 2
a2206 2
   portableFree (witYieldRate);
   portableFree (witYield);
d2215 2
a2216 2
   portableFree (witYield);
   portableFree (witYieldRate);
d2243 1
a2243 1
   portableFree ( executable);
d2253 2
a2254 2
   portableFree ( operationList[0] );
   portableFree ( operationList );
d2371 1
a2371 1
   portableFree (fltVec1);
d2389 1
a2389 1
   portableFree (productRateRet);
d2400 1
a2400 1
   portableFree (productRateRet);
d2429 1
a2429 1
   portableFree (routingShare);
d2437 1
a2437 1
   portableFree (s);
d2464 1
a2464 1
   portableFree (impactPeriod);
d2722 1
a2722 1
      portableFree (incVolList);
d2836 1
a2836 1
      portableFree (incVolList);
d3086 1
a3086 1
      portableFree (operationNameList[theIdx]);
d3088 3
a3090 3
   portableFree (operationNameList);
   portableFree (execPeriodList);
   portableFree (peggedExecVolList);
d3139 1
a3139 1
      portableFree (operationNameList[theIdx]);
d3141 5
a3145 5
   portableFree (operationNameList);
   portableFree (bomEntryIndexList);
   portableFree (subsBomEntryIndexList);
   portableFree (execPeriodList);
   portableFree (peggedSubVolList);
d3257 2
a3258 2
      portableFree (partNameList  [theIdx]);
      portableFree (demandNameList[theIdx]);
d3261 4
a3264 4
   portableFree (partNameList);
   portableFree (demandNameList);
   portableFree (shipPerList);
   portableFree (incShipVolList);
d3302 2
a3303 2
      portableFree (partNameList  [theIdx]);
      portableFree (demandNameList[theIdx]);
d3306 4
a3309 4
   portableFree (partNameList);
   portableFree (demandNameList);
   portableFree (shipPerList);
   portableFree (incShipVolList);
d3352 1
a3352 1
      portableFree (operationNameList[theIdx]);
d3354 3
a3356 3
   portableFree (operationNameList);
   portableFree (execPeriodList);
   portableFree (peggedExecVolList);
d3405 1
a3405 1
      portableFree (operationNameList[theIdx]);
d3407 5
a3411 5
   portableFree (operationNameList);
   portableFree (bomEntryIndexList);
   portableFree (subsBomEntryIndexList);
   portableFree (execPeriodList);
   portableFree (peggedSubVolList);
d3592 1
a3592 1
      portableFree (partNameList[theIdx]);
d3594 3
a3596 3
   portableFree (partNameList);
   portableFree (periodList);
   portableFree (peggedVolList);
d3636 1
a3636 1
         portableFree (partName);
d3651 1
a3651 1
         portableFree (partName);
d3665 1
a3665 1
         portableFree (opnName);
d3681 1
a3681 1
         portableFree (opnName);
d3699 1
a3699 1
         portableFree (opnName);
d3715 1
a3715 1
         portableFree (opnName);
a3920 10

/*----------------------------------------------------------------------------*/
/* portableFree                                                               */
/*----------------------------------------------------------------------------*/

void portableFree (void * theMem)
   {
   witFree ((char *) theMem);
   }

@


1.63
log
@Aded test code fior witAppendToPipSeq.
@
text
@d3270 2
a3271 2
/*
/* Reverses the order of the PIP shipment sequence.
@


1.62
log
@Added code to test witClearPipSeq.
@
text
@d61 1
a3171 7
   testExecVolPip   (theWitRun, "PS1", "US", 2);
   testSubVolPip    (theWitRun, "PS1", "US", 2);
   testSupplyVolPip (theWitRun, "PS1", "US", 2);
   testSideVolPip   (theWitRun, "PS1", "US", 2);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

a3202 7
   testExecVolPip   (theWitRun, "PS1", "US", 1);
   testSubVolPip    (theWitRun, "PS1", "US", 1);
   testSupplyVolPip (theWitRun, "PS1", "US", 1);
   testSideVolPip   (theWitRun, "PS1", "US", 1);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

d3207 2
a3208 2
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);
d3210 1
a3210 1
   witClearPipSeq   (theWitRun);
d3213 9
d3251 45
@


1.61
log
@Added code to test witGetPipSeq.
@
text
@d60 1
a60 1
void testPipSeq         (WitRun *);
d3201 1
a3201 1
   testPipSeq       (theWitRun);
d3222 4
d3229 1
a3229 1
/* testPipSeq                                                                 */
d3232 1
a3232 1
void testPipSeq (WitRun * theWitRun)
@


1.60
log
@Added tests for witGetPipExists.
@
text
@d60 1
d3201 2
d3222 44
@


1.59
log
@Added code to test witBuildPip.
@
text
@d3194 4
d3201 4
@


1.58
log
@Modified code to test PIP functions.
@
text
@d3193 18
@


1.57
log
@Extended code to test PIP functions.
@
text
@d58 2
d1717 2
a1718 34
   /* Test Post-Implosion Pegging functions. */
   {
   witBoolean theBool;

   witSetPip        (theWitRun, WitTRUE);

   witGetPip        (theWitRun, & theBool);

   assert           (theBool);

   witHeurImplode   (theWitRun);

   testExecVolPip   (theWitRun, "PS1", "US", 1);
   testSubVolPip    (theWitRun, "PS1", "US", 1);
   testSupplyVolPip (theWitRun, "PS1", "US", 1);
   testSideVolPip   (theWitRun, "PS1", "US", 1);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

   testExecVolPip   (theWitRun, "PS1", "US", 2);
   testSubVolPip    (theWitRun, "PS1", "US", 2);
   testSupplyVolPip (theWitRun, "PS1", "US", 2);
   testSideVolPip   (theWitRun, "PS1", "US", 2);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

   witSetPip        (theWitRun, WitFALSE);

   witSetHeurPipSeq (theWitRun, WitTRUE);

   witGetHeurPipSeq (theWitRun, & theBool);

   assert           (theBool);
   }
d3145 48
@


1.56
log
@Added code to test witGetDemandSideVolPip.
@
text
@a233 2
   witSetPip (theWitRun, WitTRUE);

a386 3
   witGetPip (theWitRun, &bool);
   assert (bool);

a1653 18
   /* Test Post-Implosion Pegging */

   {
   testExecVolPip   (theWitRun, "PS1", "US", 1);
   testSubVolPip    (theWitRun, "PS1", "US", 1);
   testSupplyVolPip (theWitRun, "PS1", "US", 1);
   testSideVolPip   (theWitRun, "PS1", "US", 1);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);

   testExecVolPip   (theWitRun, "PS1", "US", 2);
   testSubVolPip    (theWitRun, "PS1", "US", 2);
   testSupplyVolPip (theWitRun, "PS1", "US", 2);
   testSideVolPip   (theWitRun, "PS1", "US", 2);
   testProdVolPip   (theWitRun, "PS1", "US", 1);
   testConsVolPip   (theWitRun, "PS1", "US", 1);
   }
   
d1713 35
@


1.55
log
@Added code to test API functions for Post-Implosion Pegging.
@
text
@d58 6
a63 5
void testExecVolPip (WitRun *, const char *, const char *, int);
void testSubVolPip  (WitRun *, const char *, const char *, int);
void testSupplyVolPip (WitRun *, const char *, const char *, int);
void testProdVolPip (WitRun *, const char *, const char *, int);
void testConsVolPip (WitRun *, const char *, const char *, int);
d943 1
a943 1
                      WitNusageRate, 1.11,
d1665 1
d1672 1
d3302 37
@


1.54
log
@Continued implementation of opt with COIN.
@
text
@d58 16
d233 2
d388 3
d1644 1
a1644 1
   /* Test Pegging */
d1658 16
d3160 250
@


1.53
log
@Altered the test code for the routingShare attributes to reflect their change
from scalars to vectors.
@
text
@d1344 2
a1345 2
   witSetCoinLogFileName (theWitRun, "coin-alt.log" );
   witGetCoinLogFileName (theWitRun, & string);
d1347 1
a1347 1
   assert (strcmp (string, "coin-alt.log") == 0);
@


1.52
log
@Continued implementation of opt with COIN.
@
text
@d904 3
a906 2
   float offset[] = { 0., .5, 1., 0., 0. };
   float consRate[] = { 1.2, 2.3, 3.4, 4.5, 5.6};
d916 2
a917 2
   witSetBomEntryExecPenalty (theWitRun, "PS1", 0, 34.76);
   witSetBomEntryRoutingShare( theWitRun, "PS1", 0, 2.0);
d1013 13
a1025 11
   float bomEntryUsageRate;
   float * bomEntryConsRate;
   float goodConsRate[] = { 1.2, 2.3, 3.4, 4.5, 5.6};
   float bomEntryRoutingShare;

   witGetBomEntryUsageRate( theWitRun, "PS1", 0, &bomEntryUsageRate );
   assert( fabs( bomEntryUsageRate - 1.2 ) < fltEps );
   witGetBomEntryConsRate( theWitRun, "PS1", 0, &bomEntryConsRate );
   compareFloatVec (bomEntryConsRate, goodConsRate);
   witGetBomEntryRoutingShare( theWitRun, "PS1", 0, &bomEntryRoutingShare );
   assert( fabs( bomEntryRoutingShare - 2.0 ) < fltEps );
d1028 10
d1092 2
a1093 1
   float consRate[] = { 6.5, 5.4, 4.3, 3.2, 2.1};
d1106 1
a1106 1
   witSetSubsBomEntryRoutingShare( theWitRun, "PS1", 0, 0, 3.0 );
d1202 5
a1206 3
   float   subsBomEntryUsageRate;
   float * subsBomEntryConsRate;
   float   subsBomEntryRoutingShare;
d1208 1
a1208 1
   float goodConsRate[] = {6.5, 5.4, 4.3, 3.2, 2.1};
d1210 1
a1210 2
   witGetSubsBomEntryUsageRate (
      theWitRun, "PS1", 0, 0, &subsBomEntryUsageRate );
d1212 1
a1212 1
   assert( fabs( subsBomEntryUsageRate - 6.5 ) < fltEps );
d1214 6
a1219 2
   witGetSubsBomEntryConsRate (
      theWitRun, "PS1", 0, 0, &subsBomEntryConsRate );
d1221 1
a1221 1
   compareFloatVec (subsBomEntryConsRate, goodConsRate);
d1223 1
a1223 2
   witGetSubsBomEntryRoutingShare (
      theWitRun, "PS1", 0, 0, &subsBomEntryRoutingShare );
d1225 1
a1225 1
   assert( fabs( subsBomEntryRoutingShare - 3.0 ) < fltEps );
d2366 2
d2376 2
d2397 4
a2400 1
   float routingShare;
a2401 1
   witSetBopEntryRoutingShare (wr1, "opn1", 0, 5.0);
d2404 3
a2406 1
   assert (fabs (routingShare - 5.0) < fltEps);
@


1.51
log
@Added code to test API functions for the coinMesgFileName attribute.
@
text
@a81 1
   char * coinMesgFileName;
d1326 2
a1327 1
   coinMesgFileName = "coin-alt.log";
d1329 1
a1329 4
   witSetCoinMesgFileName (theWitRun, coinMesgFileName );
   witGetCoinMesgFileName (theWitRun, & string);

   assert (strcmp (string, coinMesgFileName) == 0);
@


1.50
log
@Made main () return an int.
@
text
@d82 1
d1325 9
@


1.49
log
@Created a new samples/data subdirectory and copied the data files used by
apiAll to it. This should make the file names used in apiAll valid in both the
agora and linux environments.
@
text
@d72 2
a73 1
void main (int argc, char * argv[])
@


1.48
log
@Added more code to test API functions for proportionate routing.
@
text
@d1951 1
a1951 1
   witReadData(wr1, "/u/wit/wit-data/examples/ex1/wit.data");
d2613 1
a2613 3
   witReadData (
      theWitRun,
      "/u/wit/wit-data/examples/diner/wit.data");
d2724 1
a2724 3
   witReadData (
      theWitRun,
      "/u/wit/wit-data/examples/diner/wit.data");
d3256 1
a3256 1
   witReadData           (theWitRunA, "/u/wit/wit-data/standard/obj1/wit.data");
d3279 1
a3279 1
   witReadData           (theWitRunB, "/u/wit/wit-data/standard/obj2/wit.data");
@


1.47
log
@Added test code for proportionate routing.
@
text
@d915 1
d1014 1
d1020 2
d1091 1
d1189 1
d1202 5
d2363 10
@


1.46
log
@Added code to test API functions for OSL postSolve recovery.
@
text
@d1697 1
d1732 2
d1762 4
d1819 1
d1839 6
@


1.45
log
@Added test code for witShutDownHeurAlloc.
@
text
@d1358 9
@


1.44
log
@Modified test code for execPenalties on BOM entries and subs.
@
text
@d2558 1
d2652 4
d3337 5
a3341 4
   WitRun * theWitRun;
   float    supplyVol[] = {100.0,  0.0,  0.0};
   float    demandVol[] = { 30.0, 10.0, 10.0};
   float    incVol;
d3365 5
a3369 1
   witFinishHeurAlloc    (theWitRun);
@


1.43
log
@Added test code for the usePenalty attributes.
@
text
@d914 1
a914 1
   witSetBomEntryUsePenalty (theWitRun, "PS1", 0, 34.76);
d996 1
a996 1
   float usePenalty;
d998 1
a998 1
   witGetBomEntryUsePenalty (theWitRun, "PS1", 0, & usePenalty);
d1000 1
a1000 1
   assert (fabs (usePenalty - 34.76) < fltEps);
d1085 1
a1085 1
   witSetSubsBomEntryUsePenalty (theWitRun, "PS1", 0, 0, 29.87);
d1199 1
a1199 1
   float usePenalty;
d1201 1
a1201 1
   witGetSubsBomEntryUsePenalty (theWitRun, "PS1", 0, 0, & usePenalty);
d1203 1
a1203 1
   assert (fabs (usePenalty - 29.87) < fltEps);
@


1.42
log
@Made changes to accommodate WIT changes in the user-specified heuristic
starting solution feature.
@
text
@d914 2
d996 8
d1085 2
d1196 8
@


1.41
log
@changed abs to fabs
@
text
@d217 2
d371 5
d1413 2
a1414 1
   witBoolean imploded;
d1416 1
d1420 2
a1421 2
   witGetPostprocessed( theWitRun, &imploded );
   assert( imploded );
@


1.40
log
@Removed some C++ style comments.
@
text
@d253 1
a253 1
   assert( abs(f - 12.3) < fltEps );
d276 1
a276 1
   assert( abs(f - 1.0e-4 ) < fltEps );
d279 1
a279 1
   assert( abs(f - 1.0e-3 ) < fltEps );
d299 1
a299 1
   assert( abs(f - 11. ) < fltEps );
d302 1
a302 1
   assert( abs(f - 22. ) < fltEps );
d305 1
a305 1
   assert( abs(f - 33. ) < fltEps );
d308 1
a308 1
   assert( abs(f - 44. ) < fltEps );
d318 1
a318 1
   assert( abs(f - 44000. ) < fltEps );
d989 1
a989 1
   assert( abs( bomEntryUsageTime + 0.1 ) < fltEps );
d998 1
a998 1
   assert( abs( bomEntryUsageRate - 1.2 ) < fltEps );
d1124 1
a1124 1
   assert( abs( subsBomEntryObj2SubPenalty - 8.0 ) < fltEps );
d1159 1
a1159 1
   assert (abs (subsBomEntryExpNetAversion - 1.2) < fltEps);
d1171 1
a1171 1
   assert( abs( subsBomEntryUsageRate - 6.5 ) < fltEps );
d1958 1
a1958 1
   assert( abs(flt - 72.89) < fltEps );
d2071 1
a2071 1
   assert( abs(flt - 3.14) < fltEps );
d2271 1
a2271 1
   assert (abs (prodRateRet - 2.0) < fltEps);
d2280 1
a2280 1
   assert (abs (prodRateRet - 1.0) < fltEps);
d2284 1
a2284 1
   assert (abs (productRateRet[2] - 1.0) < fltEps);
d2294 1
a2294 1
   assert (abs (aversion + 4.0) < fltEps);
d2299 1
a2299 1
   assert (abs (aversion - 0.0) < fltEps);
@


1.39
log
@ApiAll updated to run from accounts other than Bob's and fixed to run on Wiindows.
@
text
@d3182 1
a3182 3
   witReadData           (theWitRunA,
                          //"/u/rjw/files/wit/data/standard/obj1/wit.data");
                          "/u/wit/wit-data/standard/obj1/wit.data");
d3205 1
a3205 3
   witReadData           (theWitRunB,
                          //"/u/rjw/files/wit/data/standard/obj2/wit.data");
                          "/u/wit/wit-data/standard/obj2/wit.data");
@


1.39.2.1
log
@Changed abs to be fabs to avoid correct compiler warnings
@
text
@d253 1
a253 1
   assert( fabs(f - 12.3) < fltEps );
d276 1
a276 1
   assert( fabs(f - 1.0e-4 ) < fltEps );
d279 1
a279 1
   assert( fabs(f - 1.0e-3 ) < fltEps );
d299 1
a299 1
   assert( fabs(f - 11. ) < fltEps );
d302 1
a302 1
   assert( fabs(f - 22. ) < fltEps );
d305 1
a305 1
   assert( fabs(f - 33. ) < fltEps );
d308 1
a308 1
   assert( fabs(f - 44. ) < fltEps );
d318 1
a318 1
   assert( fabs(f - 44000. ) < fltEps );
d989 1
a989 1
   assert( fabs( bomEntryUsageTime + 0.1 ) < fltEps );
d998 1
a998 1
   assert( fabs( bomEntryUsageRate - 1.2 ) < fltEps );
d1124 1
a1124 1
   assert( fabs( subsBomEntryObj2SubPenalty - 8.0 ) < fltEps );
d1159 1
a1159 1
   assert (fabs (subsBomEntryExpNetAversion - 1.2) < fltEps);
d1171 1
a1171 1
   assert( fabs( subsBomEntryUsageRate - 6.5 ) < fltEps );
d1958 1
a1958 1
   assert( fabs(flt - 72.89) < fltEps );
d2071 1
a2071 1
   assert( fabs(flt - 3.14) < fltEps );
d2271 1
a2271 1
   assert (fabs (prodRateRet - 2.0) < fltEps);
d2280 1
a2280 1
   assert (fabs (prodRateRet - 1.0) < fltEps);
d2284 1
a2284 1
   assert (fabs (productRateRet[2] - 1.0) < fltEps);
d2294 1
a2294 1
   assert (fabs (aversion + 4.0) < fltEps);
d2299 1
a2299 1
   assert (fabs (aversion - 0.0) < fltEps);
@


1.38
log
@Added code to test heuristic allocation's enforcement of the cumulative
shipment constraint.
@
text
@d11 3
a13 1
#include <unistd.h>
d3183 2
a3184 1
                          "/u/rjw/files/wit/data/standard/obj1/wit.data");
d3208 2
a3209 1
                          "/u/rjw/files/wit/data/standard/obj2/wit.data");
d3345 1
a3345 1
   free ((char *) theMem);
@


1.37
log
@Updated test code for two-level lot sizes.
@
text
@d64 1
d1879 1
a2167 1

d3293 40
@


1.36
log
@Updated test code for two-level lot sizes.
@
text
@d1970 10
@


1.35
log
@Added code to test 2-level lot size functions.
@
text
@d1999 1
a1999 1
   float fltVec[]={13., 19., 13., -1., 10.};
@


1.34
log
@Added code to print the OSL log file in the accelerated case.
@
text
@d1649 5
a1653 5
   float obj1ProdCost [] = {1.1,  1.2,  1.3,  1.4,  1.5};
   float obj1ScrapCost[] = {0.1,  0.2,  0.3,  0.4,  0.5};
   float obj1StockCost[] = {0.01, 0.02, 0.03, 0.04, 0.05};
   float incLotSize   [] = {500.0, 500.0, 500.0, 500.0, 500.0};
   float minLotSize   [] = {2500.0, 2500.0, 2500.0, 2500.0, 2500.0};
d1690 3
a1692 3
   witSetOperationIncLotSize (theObj1Run, "PS1", incLotSize);
   witSetOperationMinLotSize (theObj1Run, "PS1", minLotSize);
   witSetOperationIncLotSize (theObj1Run, "PS2", incLotSize);
d1997 38
@


1.33
log
@Added more test code for opt implosion with lot sizes.
@
text
@d77 1
a1268 1
   char *oslMesgFileName = tmpnam(NULL);
d1277 2
a1332 2
   prtRemove (oslMesgFileName);

d1379 1
d1381 1
d1384 1
d1386 1
d1390 1
d1392 1
d1395 3
@


1.32
log
@Updated test code for opt implosion with lot sizes.
@
text
@d1643 2
a1644 1
   float incLotSize   [] = {400.0, 0.0, 400.0, 0.0, 400.0};
d1682 2
@


1.31
log
@Added test code for opt implosion with lot sizes.
@
text
@d1643 1
a1643 1
   float incLotSize   [] = {1.0,  0.0,  1.0,  0.0,  1.0};
@


1.30
log
@Added code to print the OSL log files to stdout and remove them.
@
text
@d1616 1
d1624 6
d1640 2
a1641 2
   float obj1ProdCost[] = {1.1, 1.2, 1.3, 1.4, 1.5};
   float obj1ScrapCost[] = {0.1, 0.2, 0.3, 0.4, 0.5};
d1643 1
d1679 2
@


1.29
log
@Added test code for accelerated optimizing implosion.
@
text
@d7 2
a14 1
#include <wit.h>
d1331 1
a1331 5
   strcpy(cat,"cat ");
   strcat(cat,oslMesgFileName);
   fflush(stdout);
   system(cat);
   unlink( oslMesgFileName );
d1803 1
d1805 1
d1807 3
d1811 1
d1813 1
d1815 1
a1817 1
   unlink( oslMesgFileName );
d2696 1
d2698 1
d2700 3
d2704 1
@


1.28
log
@Added #ifdef for 64-bit mode; compile using -DNO_OPT_IMPLODE
@
text
@d56 7
d1851 1
d3057 155
@


1.27
log
@Wrapped a called to witOptImplode in #ifdef (to avoid calling in 64-bit mode).
@
text
@d15 2
d18 1
a18 1

@


1.26
log
@Added code to test API functions and messages for single-source.
@
text
@d2682 1
d2684 1
@


1.25
log
@Updated test code for object iteration.
@
text
@d1616 1
d1631 2
d1664 2
d1687 3
d1742 2
d1756 6
@


1.24
log
@Updated test code for object iteration.
@
text
@d2920 4
@


1.23
log
@Updated testing code for object iteration.
@
text
@d2924 1
a2924 1
      witAdvanceObjItr  (theWitRun, & objItrState);
@


1.22
log
@Added code to test object iteration.
@
text
@d53 1
a53 1
void testObjectItr (WitRun *);
d1220 1
a1220 1
   testObjectItr (theWitRun);
d2907 1
a2907 1
/* testObjectItr                                                              */
d2910 1
a2910 1
void testObjectItr (WitRun * theWitRun)
d2912 1
a2912 1
   witAttr curItrState;
d2920 1
a2920 1
   witResetItr (theWitRun);
d2924 1
a2924 1
      witAdvanceItr     (theWitRun, & curItrState);
d2926 1
a2926 1
      witGetCurItrState (theWitRun, & curItrState);
d2928 1
a2928 1
      if      (curItrState == WitAT_PART)
d2930 1
a2930 1
         witGetItrPart (theWitRun, & partName);
d2941 1
a2941 1
      else if (curItrState == WitAT_DEMAND)
d2943 1
a2943 1
         witGetItrDemand (theWitRun, & partName, & demandName);
d2956 1
a2956 1
      else if (curItrState == WitAT_OPERATION)
d2958 1
a2958 1
         witGetItrOperation (theWitRun, & opnName);
d2970 1
a2970 1
      else if (curItrState == WitAT_BOM_ENTRY)
d2972 1
a2972 1
         witGetItrBomEntry (theWitRun, & opnName, & bomEntIdx);
d2986 1
a2986 1
      else if (curItrState == WitAT_SUB_ENTRY)
d2988 1
a2988 1
         witGetItrSubsBomEntry (theWitRun, & opnName, & bomEntIdx, & subIdx);
d3004 1
a3004 1
      else if (curItrState == WitAT_BOP_ENTRY)
d3006 1
a3006 1
         witGetItrBopEntry (theWitRun, & opnName, & bopEntIdx);
d3020 1
a3020 1
      else if (curItrState == WitINACTIVE)
@


1.21
log
@Added a test of sel-split for pen-exec to apiAll;
@
text
@d53 1
d1216 8
d2904 121
@


1.20
log
@Made apiAll display and remove a temp file that it creates.
@
text
@a322 2
   witSetPenExec (theWitRun, WitFALSE);

@


1.19
log
@Added code to test API functions for selection splitting for multi-route.
@
text
@d1311 1
d1313 7
d1321 1
d1323 1
d1336 1
a1336 1
   strcat(cat,oslMesgFileName);
d1339 1
a1339 1
   unlink( oslMesgFileName );
@


1.18
log
@Changed test code to acommodate the fact that stockRealloc and stockReallocation
cannot both be TRUE.
@
text
@a155 1
   witSetComputeCriticalList( theWitRun, WitFALSE );
d191 4
d235 2
d323 2
d331 14
d1781 1
a1781 1
   /* Test Wit Run assignment */
@


1.17
log
@Change test code for recent attribute name changes.
@
text
@d188 2
a191 2
   witSetStockRealloc (theWitRun, WitTRUE);

d318 1
a318 1
   witGetStockReallocation (theWitRun, &bool);
d321 1
a321 1
   witGetStockRealloc (theWitRun, &bool);
@


1.16
log
@Changed testing code for name change of mandatory stock reallocation to
   unconditional stock reallocation.
@
text
@d188 1
a188 1
   witSetSelStockRe (theWitRun, WitTRUE);
d190 1
a190 3
   witSetStockRealloc (theWitRun, WitFALSE);

   witSetUncondStockRe (theWitRun, WitTRUE);
d318 1
a318 1
   witGetSelStockRe (theWitRun, &bool);
a321 3
   assert (bool);

   witGetUncondStockRe (theWitRun, &bool);
@


1.15
log
@Added code to test API functions and messages for:
   mandStockRe attribute
   selective stock reallocation
@
text
@d192 1
a192 1
   witSetMandStockRe (theWitRun, WitTRUE);
d326 1
a326 1
   witGetMandStockRe (theWitRun, &bool);
@


1.14
log
@added call to ekkMalloc
@
text
@d188 5
a192 1
   witSetStockRealloc (theWitRun, WitTRUE);
d320 3
d324 3
@


1.13
log
@Added code to test API functions for shadow prices.
@
text
@d1793 9
@


1.12
log
@Minor change.
@
text
@d195 2
d327 3
d1437 1
a1437 1
   witGetPartScrapVol( theWitRun, "CompC", &fv);
d1439 4
@


1.11
log
@Updated testing code for pegging.
@
text
@d194 1
a194 1
   witSetPeggingNeeded (theWitRun, WitTRUE);
d323 1
a323 1
   witGetPeggingNeeded (theWitRun, &bool);
@


1.10
log
@Minor change.
@
text
@d194 1
a194 1
   witSetPegging (theWitRun, WitTRUE);
d323 1
a323 1
   witGetPegging (theWitRun, &bool);
d2759 1
a2759 1
   witGetDemandPeggedExecVols (
d2808 1
a2808 1
   witGetDemandPeggedSubVols (
@


1.9
log
@Added code to test API functions and messages for pegging.
@
text
@d194 1
a194 1
   witSetPerfPegging (theWitRun, WitTRUE);
d323 1
a323 1
   witGetPerfPegging (theWitRun, &bool);
@


1.8
log
@Added code to test API functions for selection splitting for multi-exec.
@
text
@d51 2
d193 2
d322 3
d1478 13
d2741 102
@


1.7
log
@Added code to test api functions and messages for selection splitting for
build-ahead.
@
text
@d2029 10
@


1.6
log
@Changed data file names to use /u/wit instead of /u/implode.
@
text
@d369 1
d444 7
@


1.5
log
@Added test code for respectStockSLBs and prefHighStockSLBs attributes.
@
text
@d1752 1
a1752 1
   witReadData(wr1, "/u/implode/wit/data/examples/ex1/wit.data");
d2339 1
a2339 1
      "/u/implode/wit/data/examples/diner/wit.data");
d2448 1
a2448 1
      "/u/implode/wit/data/examples/diner/wit.data");
@


1.4
log
@Added code to test the new vector attributes:

   BOM entry  consRate
   substitute consRate
   BOP entry  productRate
@
text
@d187 4
d312 6
d356 1
d376 1
a376 1
   witSetPartStockBounds( theWitRun, "PS1", NULL, NULL,stockBoundsHU);
d401 1
a401 1
   compareFloatVec( slb, defaultBoundsSL );
@


1.3
log
@Made testing code assume that the default value of stockRealloc is FALSE.
@
text
@d827 2
d832 1
d924 3
d928 3
a930 1
   assert( abs( bomEntryUsageRate - 1.1 ) < fltEps );
d987 2
d991 1
d1093 14
a1106 3
   float subsBomEntryUsageRate;
   witGetSubsBomEntryUsageRate( theWitRun, "PS1", 0, 0, &subsBomEntryUsageRate );
   assert( abs( subsBomEntryUsageRate - 2.1 ) < fltEps );
d2049 1
a2049 1
   /* prodRate */
d2051 17
a2067 1
   float pr;
d2069 1
a2069 3
   witSetBopEntryProdRate( wr1, "opn1", 0, 4. );
   witGetBopEntryProdRate( wr1, "opn1", 0, &pr );
   assert( abs(pr - 4.0) < fltEps );
d2071 1
a2071 3
   witSetBopEntryProdRate( wr1, "opn1", 0, 1. );
   witGetBopEntryProdRate( wr1, "opn1", 0, &pr );
   assert( abs(pr - 1.0) < fltEps );
@


1.2
log
@Added code to test API functions and messages for stock reallocation.
@
text
@d186 1
a186 1
   witSetStockRealloc (theWitRun, WitFALSE);
d307 1
a307 1
   assert (! bool);
@


1.1
log
@Initial revision
@
text
@d186 1
d306 2
@


1.1.1.1
log
@Import samples
@
text
@@

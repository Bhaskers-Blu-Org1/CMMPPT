head	1.144;
access;
symbols;
locks; strict;
comment	@ * @;


1.144
date	2011.08.25.23.30.11;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2011.02.07.15.46.29;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2011.02.03.22.31.44;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2011.01.26.21.27.44;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2011.01.06.00.09.02;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2010.10.01.18.59.33;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2010.10.01.15.29.14;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2010.09.30.22.05.15;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2010.09.30.21.51.44;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2010.09.30.21.06.31;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2010.09.30.20.34.32;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.30.19.54.13;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.30.18.24.23;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2010.09.29.23.17.24;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2010.09.29.22.08.04;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2010.09.29.17.53.21;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2010.09.27.18.35.48;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2010.09.24.22.57.38;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2010.09.24.19.55.05;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2010.09.24.19.42.35;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2010.09.24.17.23.52;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2010.09.23.22.13.14;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.22.22.15.53;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2010.09.22.21.36.11;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2010.09.17.23.23.53;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2010.09.16.22.40.34;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2010.09.16.15.30.52;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2010.09.09.20.08.21;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2010.09.09.16.33.56;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2010.09.09.15.22.24;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.07.21.14.46;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.07.19.53.16;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.02.23.09.31;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.02.22.06.41;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.02.20.17.48;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.01.22.12.35;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.01.21.44.49;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2010.03.03.20.12.19;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2010.02.24.00.24.24;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.05.23.17.55;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.25.19.45.29;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.15.19.31.43;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.15.19.09.18;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.08.20.41.16;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.23.21.34.57;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.08.20.57.16;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2009.02.04.21.33.25;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2009.01.05.16.10.19;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2008.12.08.15.54.14;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.01.00.01.13;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.25.22.35.24;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2008.02.22.23.45.32;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2008.02.22.21.37.00;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.21.21.47.57;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2008.01.14.19.21.29;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.09.22.47.09;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.09.21.38.10;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.23.19.26.47;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.22.19.59.16;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.22.18.54.11;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.17.20.47.33;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.10.15.21.50.55;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.10.12.23.05.58;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.10.02.22.30.24;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.29.16.28.13;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.16.18.08.52;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.19.21.49.52;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.21.15.20.29;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.17.20.05.38;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.04.17.45.08;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.03.22.11.06;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.30.19.53.58;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.23.22.46.14;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.23.21.55.07;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.23.21.03.31;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.23.20.28.41;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.20.20.51.33;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.19.21.39.14;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.10.17.29.22;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.03.22.04.51;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.23.19.59.20;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.01.16.16.45.52;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.11.22.53.43;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.11.18.42.26;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.08.20.29.12;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.08.19.27.00;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.28.20.40.48;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.27.19.56.32;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.27.18.28.31;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.12.19.19.27.32;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.06.19.53.07;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.12.01.21.49.26;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.17.18.33.04;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.17.16.58.03;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.12.19.44.19;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.12.16.21.31;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.10.11.19.43.54;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.10.19.11.20;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.10.10.14.27.30;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.10.05.18.41.36;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.10.04.22.28.12;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.02.20.20.41;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.02.19.28.07;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.29.23.05.44;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.29.15.40.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.22.21.53.45;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.21.15.30.19;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.31.17.26.57;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.07.23.29.37;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.04.20.43.10;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.04.19.30.42;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.04.15.45.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.03.22.11.08;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.01.19.57.04;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.28.20.30.49;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.28.17.23.43;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.26.15.55.25;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.26.14.39.27;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.21.22.23.54;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.21.18.51.43;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.21.16.11.48;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.19.17.43.50;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.18.21.00.30;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.17.21.25.02;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.17.15.02.32;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.10.16.00.35;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.07.17.14.45;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.20.20.18.24;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.19.14.50.35;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.06.20.46.15;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.06.16.02.05;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.31.14.53.18;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.30.18.14.15;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.30.16.04.17;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.15.18.53.18;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.14.18.17.17;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.13.21.19.11;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.13.15.56.57;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.12.15.32.15;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.11.22.54.18;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.08.21.07.10;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.08.16.00.14;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.06.21.48.32;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.06.21.28.43;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.144
log
@Revisions for the removal of COIN from WIT.
@
text
@//------------------------------------------------------------------------------
// Source File: "errTest.C".
//
// A WIT application program whose purpose is to test WIT's handling of errors.
//------------------------------------------------------------------------------

#include <wit.h>

#include <string>
#include <iostream>

#include <assert.h>
#include <math.h>

//------------------------------------------------------------------------------

void testCase1   ();
void testCase2   ();
void testCase3   ();
void testCase4   ();
void doWitCalls4 ();
void testCase5   ();
void doWitCalls5 ();
void testCase6   ();
void testCase7   ();
void testCase8   ();
void testCase9   ();
void testCase10  ();
void testCase11  ();
void testCase12  ();
void testCase13  ();
void testCase14  ();
void testCase15  ();
void testCase16  ();
void testCase17  ();
void testCase18  ();
void testCase19  ();
void testCase20  ();
void testCase21  ();
void testCase22  ();
void testCase23  ();
void testCase24  ();
void testCase25  ();
void testCase26  ();
void testCase27  ();
void testCase28  ();
void testCase29  ();
void testCase30  ();
void testCase31  ();
void testCase32  ();
void testCase33  ();
void testCase34  ();
void testCase35  ();
void testCase36  ();
void testCase37  ();
void testCase38  ();
void testCase39  ();
void testCase40  ();
void testCase41  ();
void testCase42  ();
void testCase43  ();
void testCase44  ();
void testCase45  ();
void testCase46  ();
void testCase47  ();
void testCase48  ();
void testCase49  ();
void testCase50  ();
void testCase51  ();
void testCase52  ();
void testCase53  ();
void testCase54  ();
void testCase55  ();
void testCase56  ();
void testCase57  ();
void testCase58  ();
void testCase59  ();
void testCase60  ();
void testCase61  ();
void testCase62  ();
void testCase63  ();
void testCase64  ();
void testCase65  ();
void testCase66  ();
void testCase67  ();
void testCase68  ();
void testCase69  ();

//------------------------------------------------------------------------------

const float * floatVec (float theFlt0, float theFlt1);
   //
   // Returns a static float vector of length 2, populated with the arguments.

//------------------------------------------------------------------------------

void terminationExpected (const char * theFuncName);
   //
   // Issues an error message indicating that the call to the function whose
   // name is given by theFuncName should have terminated the program.
   // Terminates the program.

//------------------------------------------------------------------------------

void handleErrorExc (WitErrorExc & theErrorExc);
   //
   // Handles theErrorExc.

//------------------------------------------------------------------------------

void handleUnknownExc ();
   //
   // Handles an unknown exception.

//------------------------------------------------------------------------------

void makeNewWitRun (WitRun * & theWitRun);
   //
   // Creates a new WitRun and sets theWitRun to it.

//------------------------------------------------------------------------------

int main (int argc, char * argv[])
   {
   std::string theArg;

   if (argc != 2)
      {
      std::cerr
         << "ERROR: Exactly one argument must be passed to errTest."
         << std::endl
         << std::endl;

      exit (1);
      }

   theArg = argv[1];

   std::cout
      << "----------------------------------------"
      << "----------------------------------------"
      << std::endl
      << "Error Test, Case "
      << theArg
      << "."
      << std::endl
      << "----------------------------------------"
      << "----------------------------------------"
      << std::endl
      << std::endl;

   if      (theArg == "1")
      testCase1 ();

   else if (theArg == "2")
      testCase2 ();

   else if (theArg == "3")
      testCase3 ();

   else if (theArg == "4")
      testCase4 ();

   else if (theArg == "5")
      testCase5 ();

   else if (theArg == "6")
      testCase6 ();

   else if (theArg == "7")
      testCase7 ();

   else if (theArg == "8")
      testCase8 ();

   else if (theArg == "9")
      testCase9 ();

   else if (theArg == "10")
      testCase10 ();

   else if (theArg == "11")
      testCase11 ();

   else if (theArg == "12")
      testCase12 ();

   else if (theArg == "13")
      testCase13 ();

   else if (theArg == "14")
      testCase14 ();

   else if (theArg == "15")
      testCase15 ();

   else if (theArg == "16")
      testCase16 ();

   else if (theArg == "17")
      testCase17 ();

   else if (theArg == "18")
      testCase18 ();

   else if (theArg == "19")
      testCase19 ();

   else if (theArg == "20")
      testCase20 ();

   else if (theArg == "21")
      testCase21 ();

   else if (theArg == "22")
      testCase22 ();

   else if (theArg == "23")
      testCase23 ();

   else if (theArg == "24")
      testCase24 ();

   else if (theArg == "25")
      testCase25 ();

   else if (theArg == "26")
      testCase26 ();

   else if (theArg == "27")
      testCase27 ();

   else if (theArg == "28")
      testCase28 ();

   else if (theArg == "29")
      testCase29 ();

   else if (theArg == "30")
      testCase30 ();

   else if (theArg == "31")
      testCase31 ();

   else if (theArg == "32")
      testCase32 ();

   else if (theArg == "33")
      testCase33 ();

   else if (theArg == "34")
      testCase34 ();

   else if (theArg == "35")
      testCase35 ();

   else if (theArg == "36")
      testCase36 ();

   else if (theArg == "37")
      testCase37 ();

   else if (theArg == "38")
      testCase38 ();

   else if (theArg == "39")
      testCase39 ();

   else if (theArg == "40")
      testCase40 ();

   else if (theArg == "41")
      testCase41 ();

   else if (theArg == "42")
      testCase42 ();

   else if (theArg == "43")
      testCase43 ();

   else if (theArg == "44")
      testCase44 ();

   else if (theArg == "45")
      testCase45 ();

   else if (theArg == "46")
      testCase46 ();

   else if (theArg == "47")
      testCase47 ();

   else if (theArg == "48")
      testCase48 ();

   else if (theArg == "49")
      testCase49 ();

   else if (theArg == "50")
      testCase50 ();

   else if (theArg == "51")
      testCase51 ();

   else if (theArg == "52")
      testCase52 ();

   else if (theArg == "53")
      testCase53 ();

   else if (theArg == "54")
      testCase54 ();

   else if (theArg == "55")
      testCase55 ();

   else if (theArg == "56")
      testCase56 ();

   else if (theArg == "57")
      testCase57 ();

   else if (theArg == "58")
      testCase58 ();

   else if (theArg == "59")
      testCase59 ();

   else if (theArg == "60")
      testCase60 ();

   else if (theArg == "61")
      testCase61 ();

   else if (theArg == "62")
      testCase62 ();

   else if (theArg == "63")
      testCase63 ();

   else if (theArg == "64")
      testCase64 ();

   else if (theArg == "65")
      testCase65 ();

   else if (theArg == "66")
      testCase66 ();

   else if (theArg == "67")
      testCase67 ();

   else if (theArg == "68")
      testCase68 ();

   else if (theArg == "69")
      testCase69 ();

   else
      {
      std::cerr
         << "ERROR: The argument value must be an integer from 1 to 69."
         << std::endl
         << std::endl;

      exit (1);
      }

   std::cout
      << "Normal termination of errTest, Case " << theArg << "."
      << std::endl
      << std::endl;

   exit (0);
   }

//------------------------------------------------------------------------------

void testCase1 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of error handling by program termination."
      << std::endl;

   makeNewWitRun  (theWitRun);
   witInitialize  (theWitRun);
   witAddBomEntry (theWitRun, "Opn1", "Part1");

   terminationExpected ("witAddBomEntry");
   }

//------------------------------------------------------------------------------

void testCase2 ()
   {
   WitRun *      theWitRun;
   witReturnCode theRC;

   std::cout
      << "Test of error handling by returning with an error code."
      << std::endl;

   makeNewWitRun (theWitRun);

   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      521,
      WitFALSE);

   witInitialize (theWitRun);

   theRC = witAddBomEntry (theWitRun, "Opn2", "Part2");

   std::cout
      << std::endl
      << "The return code for the call to witAddBomEntry was "
      << theRC
      << "."
      << std::endl
      << std::endl;
   }

//------------------------------------------------------------------------------

void testCase3 ()
   {
   WitRun *      theWitRun;
   witReturnCode theRC;

   std::cout
      << "Test of error handling by returning with an error code."
      << std::endl
      << "Specified by message level."
      << std::endl;

   makeNewWitRun (theWitRun);

   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitFALSE);

   witInitialize (theWitRun);

   theRC = witAddBomEntry (theWitRun, "Opn3", "Part3");

   std::cout
      << std::endl
      << "The return code for the call to witAddBomEntry was "
      << theRC
      << "."
      << std::endl
      << std::endl;
   }

//------------------------------------------------------------------------------

void testCase4 ()
   {
   std::cout
      << "Test of error handling by throwing an exception."
      << std::endl;

   try
      {
      doWitCalls4 ();
      }

   catch (WitErrorExc & theErrorExc)
      {
      handleErrorExc (theErrorExc);
      }

   catch (...)
      {
      handleUnknownExc ();
      }
   }

//------------------------------------------------------------------------------

void doWitCalls4 ()
   {
   WitRun * theWitRun;

   makeNewWitRun (theWitRun);

   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      521,
      WitTRUE);

   witInitialize  (theWitRun);
   witAddBomEntry (theWitRun, "Opn4", "Part4");
   witDeleteRun   (theWitRun);
   }

//------------------------------------------------------------------------------

void testCase5 ()
   {
   std::cout
      << "Test of error handling by throwing an exception."
      << std::endl
      << "Specified by message level."
      << std::endl
      << "The exception is caught by value."
      << std::endl;

   try
      {
      doWitCalls5 ();
      }

   catch (WitErrorExc theErrorExc)
      {
      handleErrorExc (theErrorExc);
      }

   catch (...)
      {
      handleUnknownExc ();
      }
   }

//------------------------------------------------------------------------------

void doWitCalls5 ()
   {
   WitRun * theWitRun;

   makeNewWitRun (theWitRun);

   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitTRUE);

   witInitialize  (theWitRun);
   witAddBomEntry (theWitRun, "Opn5", "Part5");
   witDeleteRun   (theWitRun);
   }

//------------------------------------------------------------------------------

void testCase6 ()
   {
   std::cerr
      << std::endl
      << "ERROR: errTest case 6 is no longer available."
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase7 ()
   {
   WitRun *      theWitRun;
   witReturnCode theRC;

   std::cout
      << "Test of WIT's behavior when it runs out of memory."
      << std::endl
      << "Function return case."
      << std::endl;

   makeNewWitRun (theWitRun);
   witInitialize (theWitRun);

   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      404,
      WitFALSE);

   theRC = witExhaustMemory (theWitRun);

   std::cout
      << std::endl
      << "The return code for the call to witExhaustMemory was "
      << theRC
      << "."
      << std::endl
      << std::endl;
   }

//------------------------------------------------------------------------------

void testCase8 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when it runs out of memory."
      << std::endl
      << "Exception throw case."
      << std::endl;

   makeNewWitRun (theWitRun);
   witInitialize (theWitRun);

   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      404,
      WitTRUE);

   try
      {
      witExhaustMemory (theWitRun);
      }

   catch (WitErrorExc & theErrorExc)
      {
      handleErrorExc (theErrorExc);
      }

   catch (...)
      {
      handleUnknownExc ();
      }
   }

//------------------------------------------------------------------------------

void testCase9 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when witInterpretDevCmd is called "
      << std::endl
      << "with an invalid command."
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witInterpretDevCmd (theWitRun, "This is an invalid command.");

   terminationExpected ("witInterpretDevCmd");
   }

//------------------------------------------------------------------------------

void testCase10 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's response to an unknown exception."
      << std::endl;

   makeNewWitRun (theWitRun);
   witInitialize (theWitRun);

   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      849,
      WitTRUE);

   try
      {
      witInterpretDevCmd (theWitRun, "Throw an exception of unknown type.");
      }

   catch (WitErrorExc & theErrorExc)
      {
      handleErrorExc (theErrorExc);
      }

   catch (...)
      {
      handleUnknownExc ();
      }
   }

//------------------------------------------------------------------------------

void testCase11 ()
   {
   WitRun * origWitRun;
   WitRun *  dupWitRun;

   std::cout
      << "Test of WIT's behavior when witCopyData is called "
      << std::endl
      << "and the API had previously aborted from origWitRun."
      << std::endl;

   makeNewWitRun         (origWitRun);
   witInitialize         (origWitRun);
   witSetMesgStopRunning (origWitRun, WitFALSE, 521, WitFALSE);
   witAddBomEntry        (origWitRun, "Opn11",  "Part11");

   makeNewWitRun         (dupWitRun);
   witCopyData           (dupWitRun,  origWitRun);

   terminationExpected ("witCopyData");
   }

//------------------------------------------------------------------------------

void testCase12 ()
   {
   WitRun * origWitRun;
   WitRun *  dupWitRun;

   std::cout
      << "Test of WIT's behavior when an API function is called with "
      << std::endl
      << "origWitRun and the API had previously aborted from witCopyData."
      << std::endl;

   makeNewWitRun         (origWitRun);
   witSetMesgStopRunning (origWitRun, WitFALSE, 74, WitFALSE);
   witInitialize         (origWitRun); 
   witSetWbounds         (origWitRun, -1.0);
                                      
   makeNewWitRun         (dupWitRun);
   witCopyData           (dupWitRun, origWitRun);

   witAddOperation       (origWitRun, "Opn12");

   terminationExpected ("witAddOperation");
   }

//------------------------------------------------------------------------------

void testCase13 ()
   {
   WitRun *      origWitRun;
   WitRun *       dupWitRun;
   witReturnCode theRC;

   std::cout
      << "Test of WIT's behavior when witCopyData is called"
      << std::endl
      << "and the API had previously aborted from origWitRun."
      << std::endl
      << "Function return case."
      << std::endl;

   makeNewWitRun         (origWitRun);
   witInitialize         (origWitRun);
   witSetMesgStopRunning (origWitRun, WitFALSE, 521, WitFALSE);
   witAddBomEntry        (origWitRun, "Opn11", "Part11");

   makeNewWitRun         (dupWitRun);
   witSetMesgStopRunning (dupWitRun, WitFALSE, 873, WitFALSE);

   theRC = witCopyData   (dupWitRun, origWitRun);

   std::cout
      << std::endl
      << "The return code for the call to witCopyData was "
      << theRC
      << "."
      << std::endl
      << std::endl;
   }

//------------------------------------------------------------------------------

void testCase14 ()
   {
   WitRun *      theWitRunA;
   WitRun *      theWitRunB;
   witReturnCode theRC;

   std::cout
      << "Test of WIT's behavior when witReadData is called "
      << std::endl
      << "and the API had previously aborted from witReadData."
      << std::endl;

   makeNewWitRun         (theWitRunA);
   witInitialize         (theWitRunA);
   witSetMesgStopRunning (theWitRunA, WitFALSE, 631, WitFALSE);

   theRC = witReadData   (theWitRunA, "data/diner.params");

   std::cout
      << std::endl
      << "The return code for the call to witReadData was "
      << theRC
      << "."
      << std::endl
      << std::endl;

   makeNewWitRun         (theWitRunB);
   witInitialize         (theWitRunB);
   witReadData           (theWitRunB, "data/diner.data");

   terminationExpected ("witReadData");
   }

//------------------------------------------------------------------------------

void testCase15 ()
   {
   WitRun * theWitRunA;
   WitRun * theWitRunB;
   char *   argv[2];

   argv[0] = "";
   argv[1] = "";

   std::cout
      << "Test of WIT's behavior when witExecStandAlone is called"
      << std::endl
      << "and the value of the stopRunning attribute has been set."
      << std::endl;

   makeNewWitRun         (theWitRunA);
   witSetMesgStopRunning (theWitRunA, WitFALSE, 262, WitFALSE);
   witDeleteRun          (theWitRunA);

   makeNewWitRun         (theWitRunB);
   witExecStandAlone     (theWitRunB, 2, argv);

   terminationExpected ("witExecStandAlone");
   }

//------------------------------------------------------------------------------

void testCase16 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when an inappropriate function is called"
      << std::endl
      << "before witInitialize."
      << std::endl;

   makeNewWitRun  (theWitRun);

   witSetNPeriods (theWitRun, 2);

   terminationExpected ("witSetNPeriods");
   }

//------------------------------------------------------------------------------

void testCase17 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when an inappropriate function is called while"
      << std::endl
      << "external optimizing implosion is active."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witAddPart      (theWitRun, "A", WitMATERIAL);
   witStartExtOpt  (theWitRun);
   witAddOperation (theWitRun, "B");

   terminationExpected ("witAddOperation");
   }

//------------------------------------------------------------------------------

void testCase18 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when an inappropriate function is called while"
      << std::endl
      << "external optimizing implosion is inactive."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witFinishExtOpt (theWitRun);

   terminationExpected ("witFinishExtOpt");
   }

//------------------------------------------------------------------------------

void testCase19 ()
   {
   std::cout
      << "Test of WIT's behavior when a function is called with a NULL WitRun "
         "pointer."
      << std::endl;

   witInitialize (NULL);

   terminationExpected ("witInitialize");
   }

//------------------------------------------------------------------------------

void testCase20 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when a function is called with a deleted "
         "WitRun."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witDeleteRun    (theWitRun);
   witAddOperation (theWitRun, "A");

   terminationExpected ("witAddOperation");
   }

//------------------------------------------------------------------------------

void testCase21 ()
   {
   std::cerr
      << std::endl
      << "ERROR: errTest case 21 is no longer available."
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase22 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when witStartExtOpt is called while "
         "accAfterOptImp\n"
         "is TRUE."
      << std::endl;

   makeNewWitRun        (theWitRun);
   witInitialize        (theWitRun);
   witSetAccAfterOptImp (theWitRun, WitTRUE);
   witStartExtOpt       (theWitRun);

   terminationExpected ("witStartExtOpt");
   }

//------------------------------------------------------------------------------

void testCase23 ()
   {
   WitRun * theWitRun;
   int      stockVarIndex;

   std::cout
      << "Test of WIT's behavior when witGetPartStockVarIndex is called with "
         "an invalid\n"
         "period."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witAddPart              (theWitRun, "A", WitMATERIAL);
   witStartExtOpt          (theWitRun);
   witGetPartStockVarIndex (theWitRun, "A", 30, & stockVarIndex);

   terminationExpected ("witGetPartStockVarIndex");
   }

//------------------------------------------------------------------------------

void testCase24 ()
   {
   WitRun *  dupWitRun;
   WitRun * origWitRun;

   std::cout
      << "Test of WIT's behavior when witCopyData is called and\n"
         "ext opt implosion is active for dupWitRun."
      << std::endl;

   makeNewWitRun  (origWitRun);
   witInitialize  (origWitRun);

   makeNewWitRun  (dupWitRun);
   witInitialize  (dupWitRun);
   witAddPart     (dupWitRun, "A", WitMATERIAL);
   witStartExtOpt (dupWitRun);

   witCopyData    (dupWitRun, origWitRun);

   terminationExpected ("witCopyData");
   }

//------------------------------------------------------------------------------

void testCase25 ()
   {
   WitRun * origWitRun;
   WitRun *  dupWitRun;

   std::cout
      << "Test of WIT's behavior when witCopyData is called and\n"
         "ext opt implosion is active for origWitRun."
      << std::endl;

   makeNewWitRun  (origWitRun);
   witInitialize  (origWitRun);
   witAddPart     (origWitRun, "A", WitMATERIAL);
   witStartExtOpt (origWitRun);

   makeNewWitRun  (dupWitRun);
   witCopyData    (dupWitRun, origWitRun);

   terminationExpected ("witCopyData");
   }

//------------------------------------------------------------------------------

void testCase26 ()
   {
   WitRun * origWitRun;
   WitRun *  dupWitRun;

   std::cout
      << "Test of WIT's behavior when witCopyData is called and origWitRun is "
      << std::endl
      << "uninitialized."
      << std::endl;

   makeNewWitRun (origWitRun);

   makeNewWitRun (dupWitRun);
   witInitialize (dupWitRun);

   witCopyData   (dupWitRun, origWitRun);

   terminationExpected ("witCopyData");
   }

//------------------------------------------------------------------------------

void testCase27 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witCopyPartData with the same original and duplicate parts."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witAddPart      (theWitRun, "A", WitCAPACITY);

   witCopyPartData (theWitRun, "A", theWitRun, "A");

   terminationExpected ("witCopyPartData");
   }

//------------------------------------------------------------------------------

void testCase28 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witCopyPartData with "
         "a material duplicate and a capacity original."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witAddPart      (theWitRun, "A", WitMATERIAL);
   witAddPart      (theWitRun, "B", WitCAPACITY);

   witCopyPartData (theWitRun, "A", theWitRun, "B");

   terminationExpected ("witCopyPartData");
   }

//------------------------------------------------------------------------------

void testCase29 ()
   {
   WitRun * origWitRun;
   WitRun * dupWitRun;

   std::cout
      << "Test of witCopyPartData where origWitRun is not initialized."
      << std::endl;

   makeNewWitRun   (origWitRun);

   makeNewWitRun   (dupWitRun);
   witInitialize   (dupWitRun);

   witCopyPartData (dupWitRun, "A", origWitRun, "A");

   terminationExpected ("witCopyPartData");
   }

//------------------------------------------------------------------------------

void testCase30 ()
   {
   WitRun * origWitRun;
   WitRun * dupWitRun;

   std::cout
      << "Test of witCopyPartData where origWitRun issues a severe error, "
      << std::endl
      << "but does not terminate execution of the program."
      << std::endl;

   makeNewWitRun         (origWitRun);
   witInitialize         (origWitRun);
   witSetMesgStopRunning (origWitRun, WitFALSE, 178, WitFALSE);

   makeNewWitRun         (dupWitRun);
   witInitialize         (dupWitRun);
   witAddPart            (dupWitRun,  "A", WitCAPACITY);

   witCopyPartData       (dupWitRun,  "A", origWitRun, "B");

   witSetNPeriods        (origWitRun,  1);

   terminationExpected ("witSetNPeriods");
   }

//------------------------------------------------------------------------------

void testCase31 ()
   {
   WitRun * origWitRun;
   WitRun * dupWitRun;

   std::cout
      << "Test of witCopyPartData with two WitRuns with different values of "
         "nPeriods."
      << std::endl;

   makeNewWitRun   (origWitRun);
   witInitialize   (origWitRun);
   witSetNPeriods  (origWitRun,  4);
   witAddPart      (origWitRun, "A", WitCAPACITY);

   makeNewWitRun   (dupWitRun);
   witInitialize   (dupWitRun);
   witAddPart      (dupWitRun,  "A", WitCAPACITY);

   witCopyPartData (dupWitRun,  "A", origWitRun, "A");

   terminationExpected ("witCopyPartData");
   }

//------------------------------------------------------------------------------

void testCase32 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witPurgeData during stochastic mode."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witAddOperation          (theWitRun, "A");
   witAddPart               (theWitRun, "B", WitMATERIAL);
   witSetOperationSelForDel (theWitRun, "A", WitTRUE);
   witSetStageByObject      (theWitRun,      WitTRUE);
   witSetStochMode          (theWitRun,      WitTRUE);
   witPurgeData             (theWitRun);

   terminationExpected ("witPurgeData");
   }

//------------------------------------------------------------------------------

void testCase33 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witStochImplode without stochastic mode."
      << std::endl;

   makeNewWitRun   (theWitRun);
   witInitialize   (theWitRun);
   witStochImplode (theWitRun);

   terminationExpected ("witStochImplode");
   }

//------------------------------------------------------------------------------

void testCase34 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witStochImplode in stochastic solution mode."
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witAddPart            (theWitRun, "A", WitMATERIAL);
   witSetStageByObject   (theWitRun,      WitTRUE);
   witSetStochMode       (theWitRun,      WitTRUE);
   witSetPartObjectStage (theWitRun, "A", 1);
   witStochImplode       (theWitRun);
   witStochImplode       (theWitRun);

   terminationExpected ("witStochImplode");
   }

//------------------------------------------------------------------------------

void testCase35 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witClearStochSoln when not in stochastic solution mode."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witAddPart          (theWitRun, "A", WitMATERIAL);
   witSetStageByObject (theWitRun, WitTRUE);
   witSetStochMode     (theWitRun, WitTRUE);
   witClearStochSoln   (theWitRun);

   terminationExpected ("witClearStochSoln");
   }

//------------------------------------------------------------------------------

void testCase36 ()
   {
   WitRun * theWitRun;
   float    demandVolB[] = {100.0};

   std::cout
      << "Test of witSetDemandDemandVol in stochastic solution mode."
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witSetNPeriods        (theWitRun,           1);
   witAddPart            (theWitRun, "A",      WitMATERIAL);
   witAddDemand          (theWitRun, "A", "B");
   witSetStageByObject   (theWitRun,           WitTRUE);
   witSetStochMode       (theWitRun,           WitTRUE);
   witSetPartObjectStage (theWitRun, "A",      1);
   witStochImplode       (theWitRun);
   witSetDemandDemandVol (theWitRun, "A", "B", demandVolB);

   terminationExpected ("witSetDemandDemandVol");
   }

//------------------------------------------------------------------------------

void testCase37 ()
   {
   WitRun * origWitRun;
   WitRun * dupWitRun;

   std::cout
      << "Test of witCopyOperationData where origWitRun is in stochastic mode."
      << std::endl;

   makeNewWitRun        (origWitRun);
   witInitialize        (origWitRun);
   witAddOperation      (origWitRun, "A");
   witAddPart           (origWitRun, "B", WitMATERIAL);
   witSetStageByObject  (origWitRun, WitTRUE);
   witSetStochMode      (origWitRun, WitTRUE);

   makeNewWitRun        (dupWitRun);
   witInitialize        (dupWitRun);
   witAddOperation      (dupWitRun,  "A");

   witCopyOperationData (dupWitRun,  "A", origWitRun, "A");

   terminationExpected ("witCopyOperationData");
   }

//------------------------------------------------------------------------------

void testCase38 ()
   {
   WitRun * theWitRun;
   float    demandVolB[] = {100.0};

   std::cout
      << "Test of witSetPartObjectStage in stochastic solution mode."
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witSetNPeriods        (theWitRun,           1);
   witAddPart            (theWitRun, "A",      WitMATERIAL);
   witAddDemand          (theWitRun, "A", "B");
   witSetStageByObject   (theWitRun,           WitTRUE);
   witSetStochMode       (theWitRun,           WitTRUE);
   witSetPartObjectStage (theWitRun, "A",      1);
   witStochImplode       (theWitRun);
   witSetPartObjectStage (theWitRun, "A",      0);

   terminationExpected ("witSetPartObjectStage");
   }

//------------------------------------------------------------------------------

void testCase39 ()
   {
   WitRun * theWitRun;
   int      stageIdx;

   std::cout
      << "Test of witGetPartObjectStage without stochastic mode."
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witAddPart            (theWitRun, "A",   WitMATERIAL);
   witGetPartObjectStage (theWitRun, "A", & stageIdx);

   terminationExpected ("witGetPartObjectStage");
   }

//------------------------------------------------------------------------------

void testCase40 ()
   {
   WitRun * theWitRun;
   int      stageIdx;

   std::cout
      << "Test of witGetOperationObjectStage while stageByObject is FALSE."
      << std::endl;

   makeNewWitRun              (theWitRun);
   witInitialize              (theWitRun);
   witAddPart                 (theWitRun, "A",   WitMATERIAL);
   witAddOperation            (theWitRun, "B");
   witSetStochMode            (theWitRun,        WitTRUE);
   witGetOperationObjectStage (theWitRun, "B", & stageIdx);

   terminationExpected ("witGetOperationObjectStage");
   }

//------------------------------------------------------------------------------

void testCase41 ()
   {
   WitRun * theWitRun;
   int *    periodStage;

   std::cout
      << "Test of witGetPeriodStage while stageByObject is TRUE."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witAddPart          (theWitRun, "A", WitMATERIAL);
   witSetStageByObject (theWitRun,      WitTRUE);
   witSetStochMode     (theWitRun,      WitTRUE);
   witGetPeriodStage   (theWitRun,    & periodStage);

   terminationExpected ("witGetPeriodStage");
   }

//------------------------------------------------------------------------------

void testCase42 ()
   {
   WitRun * theWitRun;
   float    yieldRate []  = {1,   0};
   float    execCost  []  = {0.6, 0.6};
   float    shipReward[]  = {1.0, 1.0};
   int      periodStage[] = {0,   1};
   float    demandVol []  = {0,   0};
   WitRun * cpyWitRun;

   std::cout
      << "Test of witCopyData in stage-by-period mode."
      << std::endl;

   //---------------------------------------------------------------------------
   // Core Problem
   //---------------------------------------------------------------------------

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetNPeriods           (theWitRun, 2);

   witAddPart               (theWitRun, "Hold",         WitMATERIAL);
   witAddOperation          (theWitRun, "Buy");
   witAddBopEntry           (theWitRun, "Buy", "Hold");
   witAddDemand             (theWitRun, "Hold","Sell");

   witSetOperationYieldRate (theWitRun, "Buy",          yieldRate);
   witSetOperationExecCost  (theWitRun, "Buy",          execCost);

   witSetDemandShipReward   (theWitRun, "Hold", "Sell", shipReward);

   //---------------------------------------------------------------------------
   // Stochastic Data
   //---------------------------------------------------------------------------

   witSetNScenarios         (theWitRun,                 3);
   witSetStochMode          (theWitRun,                 WitTRUE);
   witSetPeriodStage        (theWitRun,                 periodStage);

   witSetCurrentScenario    (theWitRun,                 0);
   witSetProbability        (theWitRun,                 0.3);
   demandVol[1] =                                       200;
   witSetDemandDemandVol    (theWitRun, "Hold", "Sell", demandVol);

   witSetCurrentScenario    (theWitRun,                 1);
   witSetProbability        (theWitRun,                 0.4);
   demandVol[1] =                                       300;
   witSetDemandDemandVol    (theWitRun, "Hold", "Sell", demandVol);

   witSetCurrentScenario    (theWitRun,                 2);
   witSetProbability        (theWitRun,                 0.3);
   demandVol[1] =                                       400;
   witSetDemandDemandVol    (theWitRun, "Hold", "Sell", demandVol);

   //---------------------------------------------------------------------------
   // The copy WitRun.
   //---------------------------------------------------------------------------

   makeNewWitRun            (cpyWitRun);
   witCopyData              (cpyWitRun, theWitRun);
   witDisplayData           (cpyWitRun, WitSTDOUT);
   witDeleteRun             (cpyWitRun);

   witDeleteRun             (theWitRun);

   exit (0);
   }

//------------------------------------------------------------------------------

void testCase43 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witSetPartPartName with an empty partName."
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witAddPart         (theWitRun, "A", WitMATERIAL);
   witSetPartPartName (theWitRun, "A", "");
   
   terminationExpected ("witSetPartPartName");
   }

//------------------------------------------------------------------------------

void testCase44 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witSetOperationOperationName with a operationName that "
      << std::endl
      << "matches an existing operation."
      << std::endl;

   makeNewWitRun                (theWitRun);
   witInitialize                (theWitRun);
   witAddOperation              (theWitRun, "A");
   witAddOperation              (theWitRun, "B");
   witSetOperationOperationName (theWitRun, "A", "B");
   
   terminationExpected ("witSetOperationOperationName");
   }

//------------------------------------------------------------------------------

void testCase45 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witSetDemandDemandName with a demandName that "
      << std::endl
      << "matches an existing demand for the same part."
      << std::endl;

   makeNewWitRun          (theWitRun);
   witInitialize          (theWitRun);
   witAddPart             (theWitRun, "A", WitMATERIAL);
   witAddDemand           (theWitRun, "A", "B");
   witAddDemand           (theWitRun, "A", "C");
   witSetDemandDemandName (theWitRun, "A", "B", "C");
   
   terminationExpected ("witSetDemandDemandName");
   }

//------------------------------------------------------------------------------

void testCase46 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witIssueFatalMesg."
      << std::endl;

   makeNewWitRun     (theWitRun);
   witInitialize     (theWitRun);
   witIssueFatalMesg (theWitRun);

   terminationExpected ("witIssueFatalMesg");
   }

//------------------------------------------------------------------------------

void testCase47 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witSet34Compatible when not allowed."
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witSetWit34Allowed    (theWitRun, WitFALSE);
   witSetWit34Compatible (theWitRun, WitTRUE);

   terminationExpected ("witSetWit34Compatible");
   }

//------------------------------------------------------------------------------

void testCase48 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witSetCurrentObjective without multiple objectives mode."
      << std::endl;

   makeNewWitRun (theWitRun);
   witInitialize (theWitRun);

   witSetCurrentObjective (theWitRun, "First"); 

   terminationExpected ("witSetCurrentObjective");
  }

//------------------------------------------------------------------------------

void testCase49 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witStartExtOpt in multiple objectives mode."
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witSetMultiObjMode (theWitRun, WitTRUE);
   witStartExtOpt     (theWitRun);

   terminationExpected ("witStartExtOpt");
   }

//------------------------------------------------------------------------------

void testCase50 ()
   {
   WitRun *     theWitRun;
   const char * theObjList[] = {"High|Low"};

   std::cout
      << "Test of a vertical bar in an objective name."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witSetMultiObjMode  (theWitRun, WitTRUE);
   witSetObjectiveList (theWitRun, 1,       theObjList);

   terminationExpected ("witSetObjectiveList");
   }

//------------------------------------------------------------------------------

void testCase51 ()
   {
   WitRun *     theWitRun;
   const char * theObjList[] = {"High"};

   std::cout
      << "Test of witSetObjectiveList with a zero-length list."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witSetMultiObjMode  (theWitRun, WitTRUE);
   witSetObjectiveList (theWitRun, 0,       theObjList);

   terminationExpected ("witSetObjectiveList");
   }

//------------------------------------------------------------------------------

void testCase52 ()
   {
   WitRun *     theWitRun;
   const char * theObjList[] = {"High", NULL, "Low"};

   std::cout
      << "Test of witSetObjectiveList with a NULL element in the list."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witSetMultiObjMode  (theWitRun, WitTRUE);
   witSetObjectiveList (theWitRun, 3,       theObjList);

   terminationExpected ("witSetObjectiveList");
   }

//------------------------------------------------------------------------------

void testCase53 ()
   {
   WitRun *     origWitRun;
   WitRun *     dupWitRun;
   const char * theObjList[] = {"High", "Medium", "Low"};

   std::cout
      << "Test of witCopyOperationData where origWitRun is in "
      << "multiple objectives mode."
      << std::endl;

   makeNewWitRun        (origWitRun);
   witInitialize        (origWitRun);
   witSetMultiObjMode   (origWitRun,     WitTRUE);
   witSetObjectiveList  (origWitRun,     3, theObjList);
   witAddOperation      (origWitRun, "A");

   makeNewWitRun        (dupWitRun);
   witInitialize        (dupWitRun);
   witAddOperation      (dupWitRun,  "B");

   witCopyOperationData (dupWitRun,  "B", origWitRun, "A");

   terminationExpected ("witCopyOperationData");
   }

//------------------------------------------------------------------------------

void testCase54 ()
   {
   WitRun *     origWitRun;
   WitRun *     dupWitRun;
   const char * theObjList[] = {"High", "Medium", "Low"};

   std::cout
      << "Test of witCopyPartData where dupWitRun is in "
      << "multiple objectives mode."
      << std::endl;

   makeNewWitRun       (origWitRun);
   witInitialize       (origWitRun);
   witAddPart          (origWitRun, "A", WitCAPACITY);

   makeNewWitRun       (dupWitRun);
   witInitialize       (dupWitRun);
   witSetMultiObjMode  (dupWitRun,       WitTRUE);
   witAddPart          (dupWitRun,  "B", WitCAPACITY);

   witCopyPartData     (dupWitRun,  "B", origWitRun, "A");

   terminationExpected ("witCopyPartData");
   }

//------------------------------------------------------------------------------

void testCase55 ()
   {
   WitRun *   theWitRun;
   witBoolean modHeurAlloc;
   float      incVol;

   std::cout
      << "Test of modifiable heuristic allocation."
      << std::endl;

   //...........................................................................

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetNPeriods           (theWitRun, 2);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetIndependentOffsets (theWitRun, WitTRUE);
   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witGetModHeurAlloc       (theWitRun, & modHeurAlloc);

   assert                                (modHeurAlloc);

   //...........................................................................

   witAddPart               (theWitRun, "A", WitMATERIAL);
   witAddPart               (theWitRun, "B", WitMATERIAL);
   witAddPart               (theWitRun, "C", WitMATERIAL);
   witAddPart               (theWitRun, "D", WitMATERIAL);

   witAddOperation          (theWitRun, "E");
   witAddOperation          (theWitRun, "F");

   witAddBomEntry           (theWitRun, "E", "A");
   witAddBomEntry           (theWitRun, "F", "A");
   witAddBomEntry           (theWitRun, "F", "B");

   witAddSubsBomEntry       (theWitRun, "E", 0,   "B");

   witAddBopEntry           (theWitRun, "E", "C");
   witAddBopEntry           (theWitRun, "E", "D");
   witAddBopEntry           (theWitRun, "F", "D");

   witAddDemand             (theWitRun, "C", "G");
   witAddDemand             (theWitRun, "D", "H");

   //...........................................................................

   witSetBomEntryOffset       (theWitRun, "F", 0,    floatVec (-1, -1));
   witSetSubsBomEntryOffset   (theWitRun, "E", 0, 0, floatVec ( 1,  1));
   witSetBopEntryOffset       (theWitRun, "E", 1,    floatVec ( 1,  1));

   witSetBomEntryConsRate     (theWitRun, "F", 0,    floatVec ( 4,  4));
   witSetBomEntryConsRate     (theWitRun, "F", 1,    floatVec ( 3,  3));
   witSetSubsBomEntryConsRate (theWitRun, "E", 0, 0, floatVec ( 2,  2));
   witSetBopEntryProductRate  (theWitRun, "E", 1,    floatVec ( 2,  2));
   witSetBopEntryProductRate  (theWitRun, "F", 0,    floatVec ( 3,  3));

   witSetPartSupplyVol        (theWitRun, "A",       floatVec (500, 0));
   witSetPartSupplyVol        (theWitRun, "B",       floatVec (500, 0));

   witSetDemandDemandVol      (theWitRun, "C", "G",  floatVec (100, 0));
   witSetDemandDemandVol      (theWitRun, "D", "H",  floatVec (100, 0));

   //...........................................................................

   witStartHeurAlloc        (theWitRun);

   witIncHeurAlloc          (theWitRun, "D", "H", 0, 30, & incVol);

   witInterpretDevCmd       (theWitRun, "Print availability schedule.");

   witSetSubsBomEntrySubVol (theWitRun, "E",  0,  0, floatVec (0, 30));

   witSetDemandShipVol      (theWitRun, "C", "G",    floatVec (0, 30));

   witSetOperationExecVol   (theWitRun, "E", floatVec (0, 40));
   witSetOperationExecVol   (theWitRun, "F", floatVec (20, 0));

   witInterpretDevCmd       (theWitRun, "Print availability schedule.");

   witIncHeurAlloc          (theWitRun, "D", "H", 1, 40, & incVol);

   witInterpretDevCmd       (theWitRun, "Print availability schedule.");

   witFinishHeurAlloc       (theWitRun);

   //...........................................................................

   witDeleteRun             (theWitRun);
   }

//------------------------------------------------------------------------------

void testCase56 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of modifiable heuristic allocation when selectionRecovery is "
         "FALSE."
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witSetSkipFailures  (theWitRun, WitFALSE);
   witSetModHeurAlloc  (theWitRun, WitTRUE);

   witStartHeurAlloc   (theWitRun);

   terminationExpected ("witStartHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase57 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of setting modHeurAlloc during heuristic allocation."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);

   witAddPart              (theWitRun, "A", WitMATERIAL);

   witAddDemand            (theWitRun, "A", "B");

   witSetPartSupplyVol     (theWitRun, "A",       floatVec (100, 100));

   witSetDemandDemandVol   (theWitRun, "A", "B",  floatVec (100, 100));

   witStartHeurAlloc       (theWitRun);

   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witIncHeurAlloc         (theWitRun, "A", "B", 1, 30, & incVol);

   terminationExpected     ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase58 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the non-executable constraint during "
      << std::endl
      << "modifiable heuristic allocation."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetExecEmptyBom      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);
   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A", WitMATERIAL);

   witAddOperation         (theWitRun, "B");

   witAddDemand            (theWitRun, "A", "C");

   witSetDemandDemandVol   (theWitRun, "A", "C", floatVec (10, 10));

   witStartHeurAlloc       (theWitRun);

   witSetOperationExecVol  (theWitRun, "B",      floatVec (0, 0.1));

   witIncHeurAlloc         (theWitRun, "A", "C", 1, 7, & incVol);

   terminationExpected     ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase59 ()
   {
   WitRun * theWitRun;
   char *   thePartNames  [] = {"A"};
   char *   theDemandNames[] = {"C"};
   int      shipPers      [] = {1};
   float    desIncVols    [] = {7};
   float *  incVols;

   std::cout
      << "Test of violation of the execVol hard upper bound constraint during "
      << std::endl
      << "modifiable heuristic allocation."
      << std::endl;

   makeNewWitRun             (theWitRun);
   witInitialize             (theWitRun);
   witSetSelectionRecovery   (theWitRun, WitTRUE);
   witSetSkipFailures        (theWitRun, WitFALSE);
   witSetNPeriods            (theWitRun, 2);
   witSetModHeurAlloc        (theWitRun, WitTRUE);

   witAddPart                (theWitRun, "A", WitMATERIAL);

   witAddOperation           (theWitRun, "B");

   witAddDemand              (theWitRun, "A", "C");

   witSetDemandDemandVol     (theWitRun, "A", "C", floatVec (10, 10));

   witSetOperationExecBounds (theWitRun, "B", NULL, NULL, floatVec (10, 10));

   witStartHeurAlloc         (theWitRun);

   witSetOperationExecVol    (theWitRun, "B", floatVec (10, 11));

   witEqHeurAlloc            (theWitRun,
                              1,
                              thePartNames,
                              theDemandNames,
                              shipPers,
                              desIncVols,
                            & incVols);

   terminationExpected       ("witEqHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase60 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of violation of the lot-size constraint during"
      << std::endl
      << "modifiable heuristic allocation."
      << std::endl;

   makeNewWitRun             (theWitRun);
   witInitialize             (theWitRun);
   witSetSelectionRecovery   (theWitRun, WitTRUE);
   witSetSkipFailures        (theWitRun, WitFALSE);
   witSetNPeriods            (theWitRun, 2);
   witSetModHeurAlloc        (theWitRun, WitTRUE);

   witAddOperation           (theWitRun, "A");

   witSetOperationIncLotSize (theWitRun, "A", floatVec (10, 10));
                                              
   witStartHeurAlloc         (theWitRun);

   witSetOperationExecVol    (theWitRun, "A", floatVec (10, 11));

   witFinishHeurAlloc        (theWitRun);

   terminationExpected       ("witFinishHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase61 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of violation of the cumulative shipment constraint during"
      << std::endl
      << "modifiable heuristic allocation."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);
   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A", WitMATERIAL);
   witAddDemand            (theWitRun, "A", "B");

   witSetPartSupplyVol     (theWitRun, "A",      floatVec (30,  0));

   witSetDemandDemandVol   (theWitRun, "A", "B", floatVec (10, 10));

   witStartHeurAlloc       (theWitRun);

   witSetDemandShipVol     (theWitRun, "A", "B", floatVec ( 7, 15));

   witFinishHeurAlloc      (theWitRun);

   terminationExpected     ("witFinishHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase62 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the substitution constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   SubVol case."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetUserHeurStart      (theWitRun, WitTRUE);
   witSetNPeriods           (theWitRun, 2);
   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witAddPart               (theWitRun, "A", WitMATERIAL);

   witAddOperation          (theWitRun, "B");

   witAddBomEntry           (theWitRun, "B", "A");
   witAddBomEntry           (theWitRun, "B", "A");
   witAddBomEntry           (theWitRun, "B", "A");

   witAddSubsBomEntry       (theWitRun, "B",  2, "A");
   witAddSubsBomEntry       (theWitRun, "B",  2, "A");

   witAddDemand             (theWitRun, "A", "C");

   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100, 100));

   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec (100, 100));

   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10,  10));

   witStartHeurAlloc        (theWitRun);

   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 1, floatVec (5, 17));

   witIncHeurAlloc          (theWitRun, "A", "C", 1, 30, & incVol);

   terminationExpected      ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase63 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the substitution constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   ExecVol case."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetUserHeurStart      (theWitRun, WitTRUE);
   witSetNPeriods           (theWitRun, 2);
   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witAddPart               (theWitRun, "A", WitMATERIAL);

   witAddOperation          (theWitRun, "B");

   witAddBomEntry           (theWitRun, "B", "A");
   witAddBomEntry           (theWitRun, "B", "A");
   witAddBomEntry           (theWitRun, "B", "A");

   witAddSubsBomEntry       (theWitRun, "B",  2, "A");
   witAddSubsBomEntry       (theWitRun, "B",  2, "A");

   witAddDemand             (theWitRun, "A", "C");

   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100, 100));

   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec (100, 100));

   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10,  10));

   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 0, floatVec   (5,   3));
   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 1, floatVec   (5,   4));

   witStartHeurAlloc        (theWitRun);

   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10,   5));

   witIncHeurAlloc          (theWitRun, "A", "C", 1, 30, & incVol);

   terminationExpected      ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase64 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the scrapVol constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   ShipVol case."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);
   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A", WitCAPACITY);

   witAddDemand            (theWitRun, "A", "B");

   witSetPartSupplyVol     (theWitRun, "A",       floatVec (10, 10));

   witSetDemandDemandVol   (theWitRun, "A", "B",  floatVec ( 0, 50));

   witStartHeurAlloc       (theWitRun);

   witSetDemandShipVol     (theWitRun, "A", "B",  floatVec ( 0, 10.0012));

   witIncHeurAlloc         (theWitRun, "A", "B", 0, 2, & incVol);

   terminationExpected     ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase65 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the scrapVol constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   ExecVol, BOM entry & material case."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);

   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A", WitMATERIAL);

   witAddOperation         (theWitRun, "B");

   witAddBomEntry          (theWitRun, "B", "A");

   witAddDemand            (theWitRun, "A", "C");

   witSetPartSupplyVol     (theWitRun, "A",       floatVec (10,  0));

   witSetDemandDemandVol   (theWitRun, "A", "C",  floatVec ( 0, 10));

   witStartHeurAlloc       (theWitRun);

   witIncHeurAlloc         (theWitRun, "A", "C", 1, 7, & incVol);

   witSetOperationExecVol  (theWitRun, "B",       floatVec ( 7,  0));

   witIncHeurAlloc         (theWitRun, "A", "C", 1, 3, & incVol);

   terminationExpected     ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase66 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the scrapVol constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   ExecVol & BOP entry case."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 2);

   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A", WitCAPACITY);

   witAddOperation         (theWitRun, "B");
   witAddOperation         (theWitRun, "C");

   witAddBomEntry          (theWitRun, "C", "A");

   witAddBopEntry          (theWitRun, "B", "A");

   witAddDemand            (theWitRun, "A", "C");

   witSetBopEntryOffset    (theWitRun, "B",  0,   floatVec (-1, -1)); 

   witSetPartSupplyVol     (theWitRun, "A",       floatVec (10, 10));

   witSetDemandDemandVol   (theWitRun, "A", "C",  floatVec ( 0, 20));

   witStartHeurAlloc       (theWitRun);

   witIncHeurAlloc         (theWitRun, "A", "C", 1, 17, & incVol);

   witSetOperationExecVol  (theWitRun, "B",       floatVec ( 4,  0));

   witSetPartSupplyVol     (theWitRun, "A",       floatVec (20, 20));

   terminationExpected     ("witSetPartSupplyVol");
   }

//------------------------------------------------------------------------------

void testCase67 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the scrapVol constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   SubVol & Substitute case."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);

   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witAddPart               (theWitRun, "A", WitCAPACITY);
   witAddPart               (theWitRun, "B", WitCAPACITY);

   witAddOperation          (theWitRun, "C");

   witAddBomEntry           (theWitRun, "C", "A");

   witAddSubsBomEntry       (theWitRun, "C",  0, "B");

   witSetPartSupplyVol      (theWitRun, "A",         floatVec (10, 10));
   witSetPartSupplyVol      (theWitRun, "B",         floatVec (10, 10));

   witStartHeurAlloc        (theWitRun);

   witSetOperationExecVol   (theWitRun, "C",         floatVec ( 0, 27));

   witSetSubsBomEntrySubVol (theWitRun, "C",  0,  0, floatVec ( 0, 19));

   witFinishHeurAlloc       (theWitRun);

   terminationExpected      ("witFinishHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase68 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of violation of the scrapVol constraint during"
      << std::endl
      << "modifiable heuristic allocation:"
      << std::endl
      << std::endl
      << "   SubVol & BOM entry case."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetUserHeurStart      (theWitRun, WitTRUE);
   witSetNPeriods           (theWitRun, 2);

   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witAddPart               (theWitRun, "A", WitCAPACITY);
   witAddPart               (theWitRun, "B", WitCAPACITY);

   witAddOperation          (theWitRun, "C");

   witAddBomEntry           (theWitRun, "C", "A");

   witAddSubsBomEntry       (theWitRun, "C",  0, "B");

   witSetPartSupplyVol      (theWitRun, "A",         floatVec (10, 10));
   witSetPartSupplyVol      (theWitRun, "B",         floatVec (10, 10));

   witSetOperationExecVol   (theWitRun, "C",         floatVec ( 0, 17));

   witSetSubsBomEntrySubVol (theWitRun, "C",  0,  0, floatVec ( 0,  9));

   witStartHeurAlloc        (theWitRun);

   witSetSubsBomEntrySubVol (theWitRun, "C",  0,  0, floatVec ( 0,  0));

   witFinishHeurAlloc       (theWitRun);

   terminationExpected      ("witFinishHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase69 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of adding a CPLEX parameter specification with the name: "
      << "\"NO_PARAM\".";

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witAddIntCplexParSpec (theWitRun, "NO_PARAM", 17);

   terminationExpected   ("witAddIntCplexParSpec");
   }

//------------------------------------------------------------------------------

const float * floatVec (float theFlt0, float theFlt1)
   {
   static float theVec[2];

   theVec[0] = theFlt0;
   theVec[1] = theFlt1;

   return theVec;
   }

//------------------------------------------------------------------------------

void terminationExpected (const char * theFuncName)
   {
   std::cerr
      << std::endl
      << "ERROR: errTest should have terminated during the call to "
      << theFuncName
      << "."
      << std::endl
      << std::endl
      << "       errTest now terminates."
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void handleErrorExc (WitErrorExc & theErrorExc)
   {
   std::cerr
      << std::endl
      << "WIT has thrown an exception of type WitErrorExc."
      << std::endl
      << "The API function was "
      << theErrorExc.funcName ()
      << "."
      << std::endl
      << "The message number was "
      << theErrorExc.mesgNum ()
      << "."
      << std::endl
      << "The return code was "
      << theErrorExc.retCode ()
      << "."
      << std::endl
      << std::endl;
   }

//------------------------------------------------------------------------------

void handleUnknownExc ()
   {
   std::cerr
      << std::endl
      << "ERROR: WIT has thrown an exception of unknown type."
      << std::endl
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void makeNewWitRun (WitRun * & theWitRun)
   {
   witNewRun (& theWitRun);
   }
@


1.143
log
@CPLEX Parameters
@
text
@a87 1
void testCase70  ();
a358 3
   else if (theArg == "70")
      testCase70 ();

d362 1
a362 1
         << "ERROR: The argument value must be an integer from 1 to 70."
a2363 35
// Case 70
//
// This case should not be run as part of the routine test battery, because it
// requires a build of WIT without COIN embedded."
//------------------------------------------------------------------------------

void testCase70 ()
   {
   WitRun *   theWitRun;
   witBoolean coinEmbedded;

   std::cout
      << "Test of witStartExtOpt with COIN selected, but not embedded."
      << std::endl
      << std::endl
      << "(This is not actually an error case.)"
      << std::endl;

   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witGetCoinEmbedded  (theWitRun, & coinEmbedded);

   assert                         (! coinEmbedded);

   witSetCoinSelected  (theWitRun,   WitTRUE);

   witAddPart          (theWitRun, "A", WitCAPACITY);

   witStartExtOpt      (theWitRun);

   witDeleteRun        (theWitRun);

   }

//------------------------------------------------------------------------------
@


1.142
log
@CPLEX
@
text
@d2360 3
a2362 3
   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witAddIntCpxParSpec (theWitRun, "NO_PARAM", 17);
d2364 1
a2364 1
   terminationExpected ("witAddIntCpxParSpec");
@


1.141
log
@CPLEX Parameters
@
text
@d88 1
d360 3
d366 1
a366 1
         << "ERROR: The argument value must be an integer from 1 to 69."
d2368 35
@


1.140
log
@De-implemented case 21.
@
text
@d87 1
d356 3
d362 1
a362 1
         << "ERROR: The argument value must be an integer from 1 to 68."
d2348 17
@


1.139
log
@Modifiable Heuristic Allocation
@
text
@d925 3
a927 4
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when intSubVols is TRUE and mipMode is FALSE."
d930 1
a930 12
   makeNewWitRun                (theWitRun);
   witInitialize                (theWitRun);

   witAddPart                   (theWitRun, "A", WitCAPACITY);
   witAddOperation              (theWitRun, "B");
   witAddBomEntry               (theWitRun, "B", "A");
   witAddSubsBomEntry           (theWitRun, "B",  0, "A");
   witSetSubsBomEntryIntSubVols (theWitRun, "B",  0,  0, WitTRUE);

   witOptImplode                (theWitRun);

   terminationExpected ("witOptImplode");
d2375 1
a2375 1
   std::cout
d2398 1
a2398 1
   std::cout
@


1.138
log
@Modifiable Heuristic Allocation
@
text
@d2126 1
a2126 1
      << "Test of violation of the availability constraint during"
d2166 1
a2166 1
      << "Test of violation of the availability constraint during"
d2213 1
a2213 1
      << "Test of violation of the availability constraint during"
d2265 1
a2265 1
      << "Test of violation of the availability constraint during"
d2312 1
a2312 1
      << "Test of violation of the availability constraint during"
@


1.137
log
@Modifiable Heuristic Allocation
@
text
@d1983 1
a1983 1
      << "Test of violation of the cumulative demand constraint during"
@


1.136
log
@Modifiable Heuristic Allocation
@
text
@a1722 3

   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

d1813 4
a1816 7
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSkipFailures      (theWitRun, WitFALSE);

   witInterpretDevCmd      (theWitRun, "Allow modifiable heuristic.");

   witSetModHeurAlloc      (theWitRun, WitTRUE);
d1818 1
a1818 1
   witStartHeurAlloc       (theWitRun);
d1834 5
a1838 5
   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);
d1840 1
a1840 1
   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");
d1842 1
a1842 1
   witAddPart               (theWitRun, "A", WitMATERIAL);
d1844 1
a1844 1
   witAddDemand             (theWitRun, "A", "B");
d1846 1
a1846 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100, 100));
d1848 1
a1848 1
   witSetDemandDemandVol    (theWitRun, "A", "B",  floatVec (100, 100));
d1850 1
a1850 3
   witStartHeurAlloc        (theWitRun);

   witSetModHeurAlloc       (theWitRun, WitTRUE);
d1852 1
a1852 1
   witIncHeurAlloc          (theWitRun, "A", "B", 1, 30, & incVol);
d1854 1
a1854 1
   terminationExpected      ("witIncHeurAlloc");
a1875 3

   witInterpretDevCmd      (theWitRun, "Allow modifiable heuristic.");

a1916 3

   witInterpretDevCmd        (theWitRun, "Allow modifiable heuristic.");

a1960 3

   witInterpretDevCmd        (theWitRun, "Allow modifiable heuristic.");

d1988 6
a1993 5
   makeNewWitRun             (theWitRun);
   witInitialize             (theWitRun);
   witSetSelectionRecovery   (theWitRun, WitTRUE);
   witSetSkipFailures        (theWitRun, WitFALSE);
   witSetNPeriods            (theWitRun, 2);
d1995 2
a1996 6
   witInterpretDevCmd        (theWitRun, "Allow modifiable heuristic.");

   witSetModHeurAlloc        (theWitRun, WitTRUE);

   witAddPart                (theWitRun, "A", WitMATERIAL);
   witAddDemand              (theWitRun, "A", "B");
d1998 1
a1998 1
   witSetPartSupplyVol       (theWitRun, "A",      floatVec (30,  0));
d2000 1
a2000 1
   witSetDemandDemandVol     (theWitRun, "A", "B", floatVec (10, 10));
d2002 1
a2002 1
   witStartHeurAlloc         (theWitRun);
d2004 1
a2004 1
   witSetDemandShipVol       (theWitRun, "A", "B", floatVec ( 7, 15));
d2006 1
a2006 1
   witFinishHeurAlloc        (theWitRun);
d2008 1
a2008 1
   terminationExpected       ("witFinishHeurAlloc");
a2032 3

   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

a2084 3

   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

d2134 6
a2139 9
   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);

   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

   witSetModHeurAlloc       (theWitRun, WitTRUE);
d2141 1
a2141 1
   witAddPart               (theWitRun, "A", WitCAPACITY);
d2143 1
a2143 1
   witAddDemand             (theWitRun, "A", "B");
d2145 1
a2145 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10, 10));
d2147 1
a2147 1
   witSetDemandDemandVol    (theWitRun, "A", "B",  floatVec ( 0, 50));
d2149 1
a2149 1
   witStartHeurAlloc        (theWitRun);
d2151 1
a2151 1
   witSetDemandShipVol      (theWitRun, "A", "B",  floatVec ( 0, 10.0012));
d2153 1
a2153 1
   witIncHeurAlloc          (theWitRun, "A", "B", 0, 2, & incVol);
d2155 1
a2155 1
   terminationExpected      ("witIncHeurAlloc");
d2174 5
a2178 5
   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);
d2180 1
a2180 1
   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");
d2182 1
a2182 1
   witSetModHeurAlloc       (theWitRun, WitTRUE);
d2184 1
a2184 1
   witAddPart               (theWitRun, "A", WitMATERIAL);
d2186 1
a2186 1
   witAddOperation          (theWitRun, "B");
d2188 1
a2188 1
   witAddBomEntry           (theWitRun, "B", "A");
d2190 1
a2190 1
   witAddDemand             (theWitRun, "A", "C");
d2192 1
a2192 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10,  0));
d2194 1
a2194 1
   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec ( 0, 10));
d2196 1
a2196 1
   witStartHeurAlloc        (theWitRun);
d2198 1
a2198 1
   witIncHeurAlloc          (theWitRun, "A", "C", 1, 7, & incVol);
d2200 1
a2200 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 7,  0));
d2202 1
a2202 3
   witIncHeurAlloc          (theWitRun, "A", "C", 1, 3, & incVol);

   terminationExpected      ("witIncHeurAlloc");
d2221 5
a2225 5
   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);
d2227 1
a2227 1
   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");
d2229 1
a2229 1
   witSetModHeurAlloc       (theWitRun, WitTRUE);
d2231 2
a2232 1
   witAddPart               (theWitRun, "A", WitCAPACITY);
d2234 1
a2234 2
   witAddOperation          (theWitRun, "B");
   witAddOperation          (theWitRun, "C");
d2236 1
a2236 1
   witAddBomEntry           (theWitRun, "C", "A");
d2238 1
a2238 1
   witAddBopEntry           (theWitRun, "B", "A");
d2240 1
a2240 1
   witAddDemand             (theWitRun, "A", "C");
d2242 1
a2242 1
   witSetBopEntryOffset     (theWitRun, "B",  0,   floatVec (-1, -1)); 
d2244 1
a2244 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10, 10));
d2246 1
a2246 1
   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec ( 0, 20));
d2248 1
a2248 1
   witStartHeurAlloc        (theWitRun);
d2250 1
a2250 1
   witIncHeurAlloc          (theWitRun, "A", "C", 1, 17, & incVol);
d2252 1
a2252 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 4,  0));
d2254 1
a2254 3
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (20, 20));

   terminationExpected      ("witSetPartSupplyVol");
a2278 2
   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

a2326 2
   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

@


1.135
log
@Modifiable Heuristic Allocation
@
text
@a86 1
void testCase69  ();
a354 3
   else if (theArg == "69")
      testCase69 ();

d358 1
a358 1
         << "ERROR: The argument value must be an integer from 1 to 69."
d1812 2
a1813 2
      << "Test of witSetModHeurAlloc when modifiable heuristic allocation "
         "is not allowed."
d1816 7
a1822 2
   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
d1824 1
a1824 1
   witSetModHeurAlloc (theWitRun, WitTRUE);
d1826 1
a1826 1
   terminationExpected ("witSetModHeurAlloc");
d1837 36
d1908 1
a1908 1
void testCase58 ()
d1960 1
a1960 1
void testCase59 ()
d1995 1
a1995 1
void testCase60 ()
a2032 24
void testCase61 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of modifiable heuristic allocation when selectionRecovery is "
         "FALSE."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSkipFailures      (theWitRun, WitFALSE);

   witInterpretDevCmd      (theWitRun, "Allow modifiable heuristic.");

   witSetModHeurAlloc      (theWitRun, WitTRUE);

   witStartHeurAlloc       (theWitRun);

   terminationExpected ("witStartHeurAlloc");
   }

//------------------------------------------------------------------------------

a2151 36
      << "Test of setting modHeurAlloc during heuristic allocation."
      << std::endl;

   makeNewWitRun            (theWitRun);
   witInitialize            (theWitRun);
   witSetSelectionRecovery  (theWitRun, WitTRUE);
   witSetSkipFailures       (theWitRun, WitFALSE);
   witSetNPeriods           (theWitRun, 2);

   witInterpretDevCmd       (theWitRun, "Allow modifiable heuristic.");

   witAddPart               (theWitRun, "A", WitMATERIAL);

   witAddDemand             (theWitRun, "A", "B");

   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100, 100));

   witSetDemandDemandVol    (theWitRun, "A", "B",  floatVec (100, 100));

   witStartHeurAlloc        (theWitRun);

   witSetModHeurAlloc       (theWitRun, WitTRUE);

   witIncHeurAlloc          (theWitRun, "A", "B", 1, 30, & incVol);

   terminationExpected      ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase65 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
d2189 1
a2189 1
void testCase66 ()
d2238 1
a2238 1
void testCase67 ()
d2292 1
a2292 1
void testCase68 ()
d2341 1
a2341 1
void testCase69 ()
@


1.134
log
@Modifiable Heuristic Allocation
@
text
@a96 6
void printAvailSched (WitRun * theWitRun);
   //
   // Prints the availability schedule.

//------------------------------------------------------------------------------

d1787 1
a1787 4
   printAvailSched          (theWitRun);

   witSetOperationExecVol   (theWitRun, "E", floatVec (0, 40));
   witSetOperationExecVol   (theWitRun, "F", floatVec (20, 0));
d1793 4
a1796 1
   printAvailSched          (theWitRun);
d1800 1
a1800 1
   printAvailSched          (theWitRun);
a2427 7
void printAvailSched (WitRun * theWitRun)
   {
   witInterpretDevCmd (theWitRun, "Print availability schedule.");
   }

//------------------------------------------------------------------------------

@


1.133
log
@Modifiable Heuristic Allocation
@
text
@d2270 1
a2284 1
   witSetUserHeurStart      (theWitRun, WitTRUE);
d2300 2
d2306 1
a2306 2
   witSetOperationExecVol   (theWitRun, "B",       floatVec (10,  0));
   witSetOperationExecVol   (theWitRun, "C",       floatVec ( 0, 17));
d2310 3
a2312 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 3,  0));
@


1.132
log
@Modifiable Heuristic Allocation
@
text
@d2229 1
a2229 1
      << "   ExecVol & BOM entry case."
d2242 1
a2242 1
   witAddPart               (theWitRun, "A", WitCAPACITY);
d2248 1
a2248 1
   witSetBomEntryOffset     (theWitRun, "B",  0,   floatVec ( 1,  1)); 
d2250 1
a2250 1
   witSetBomEntryConsRate   (theWitRun, "B",  0,   floatVec ( 3,  3)); 
d2252 1
a2252 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10, 10));
d2256 3
a2258 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 0,  4));
d2260 1
a2260 1
   witShutDownHeurAlloc     (theWitRun);
d2262 1
a2262 1
   terminationExpected      ("witShutDownHeurAlloc");
@


1.131
log
@Modifiable Heuristic Allocation
@
text
@d86 2
d359 6
d368 1
a368 1
         << "ERROR: The argument value must be an integer from 1 to 67."
d1791 1
a1791 1
   witIncHeurAlloc          (theWitRun, "D", "H", 0, 30.0, & incVol);
d1804 1
a1804 1
   witIncHeurAlloc          (theWitRun, "D", "H", 1, 40.0, & incVol);
d1870 1
a1870 1
   witIncHeurAlloc         (theWitRun, "A", "C", 1, 7.0, & incVol);
d2064 1
a2064 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100.0, 100.0));
d2066 1
a2066 1
   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec (100.0, 100.0));
d2068 1
a2068 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10.0,  10.0));
d2072 1
a2072 1
   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 1, floatVec (5.0, 17.0));
d2074 1
a2074 1
   witIncHeurAlloc          (theWitRun, "A", "C", 1, 30.0, & incVol);
d2119 1
a2119 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100.0, 100.0));
d2121 1
a2121 1
   witSetDemandDemandVol    (theWitRun, "A", "C",  floatVec (100.0, 100.0));
d2123 1
a2123 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10.0,  10.0));
d2125 2
a2126 2
   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 0, floatVec   (5.0,   3.0));
   witSetSubsBomEntrySubVol (theWitRun, "B", 2, 1, floatVec   (5.0,   4.0));
d2130 1
a2130 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec  (10.0,   5.0));
d2132 1
a2132 1
   witIncHeurAlloc          (theWitRun, "A", "C", 1, 30.0, & incVol);
d2160 1
a2160 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (100.0, 100.0));
d2162 1
a2162 1
   witSetDemandDemandVol    (theWitRun, "A", "B",  floatVec (100.0, 100.0));
d2168 1
a2168 1
   witIncHeurAlloc          (theWitRun, "A", "B", 1, 30.0, & incVol);
d2203 1
a2203 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10.0, 10.0));
d2205 1
a2205 1
   witSetDemandDemandVol    (theWitRun, "A", "B",  floatVec ( 0.0, 50.0));
d2209 1
a2209 1
   witSetDemandShipVol      (theWitRun, "A", "B",  floatVec ( 0.0, 10.0012));
d2211 1
a2211 1
   witIncHeurAlloc          (theWitRun, "A", "B", 0, 2.0, & incVol);
d2248 1
a2248 1
   witSetBomEntryOffset     (theWitRun, "B",  0,   floatVec ( 1.0,  1.0)); 
d2250 1
a2250 1
   witSetBomEntryConsRate   (theWitRun, "B",  0,   floatVec ( 3.0,  3.0)); 
d2252 1
a2252 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10.0, 10.0));
d2256 1
a2256 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 0.0,  4.0));
a2267 1
   float    incVol;
d2298 1
a2298 1
   witSetBopEntryOffset     (theWitRun, "B",  0,   floatVec (-1.0, -1.0)); 
d2300 1
a2300 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (10.0, 10.0));
d2302 2
a2303 2
   witSetOperationExecVol   (theWitRun, "B",       floatVec (10.0,  0.0));
   witSetOperationExecVol   (theWitRun, "C",       floatVec ( 0.0, 17.0));
d2307 1
a2307 1
   witSetOperationExecVol   (theWitRun, "B",       floatVec ( 3.0,  0.0));
d2309 1
a2309 1
   witSetPartSupplyVol      (theWitRun, "A",       floatVec (20.0, 20.0));
d2316 101
@


1.130
log
@Modifiable Heuristic Allocation
@
text
@d85 1
d91 1
a91 1
   // Returns floatVec2, populated with the arguments.
a126 6
float floatVec2[2];
   //
   // The vector returned by floatVec (*, *).

//------------------------------------------------------------------------------

d354 3
d360 1
a360 1
         << "ERROR: The argument value must be an integer from 1 to 66."
d2257 52
d2311 4
a2314 2
   floatVec2[0] = theFlt0;
   floatVec2[1] = theFlt1;
d2316 1
a2316 1
   return floatVec2;
@


1.129
log
@Modifiable Heuristic Allocation
@
text
@d83 2
d353 6
d362 1
a362 1
         << "ERROR: The argument value must be an integer from 1 to 64."
d2030 1
d2085 1
d2169 90
@


1.128
log
@Modifiable Heuristic Allocation
@
text
@d1973 2
d1981 3
a1983 1
   terminationExpected       ("witSetDemandShipVol");
@


1.127
log
@Modifiable Heuristic Allocation
@
text
@d82 1
d348 3
d354 1
a354 1
         << "ERROR: The argument value must be an integer from 1 to 63."
d2119 36
@


1.126
log
@Modifiable Heuristic Allocation
@
text
@d1821 1
d1840 7
a1846 1
   witAddOperation         (theWitRun, "A");
d1850 1
a1850 1
   witSetOperationExecVol  (theWitRun, "A", floatVec (0, 0.1));
d1852 3
a1854 1
   terminationExpected     ("witSetOperationExecVol");
d1862 5
d1884 7
a1890 1
   witAddOperation           (theWitRun, "A");
d1892 1
a1892 1
   witSetOperationExecBounds (theWitRun, "A", NULL, NULL, floatVec (10, 10));
d1896 9
a1904 1
   witSetOperationExecVol    (theWitRun, "A", floatVec (10, 11));
d1906 1
a1906 1
   terminationExpected       ("witSetOperationExecVol");
d1939 3
a1941 1
   terminationExpected       ("witSetOperationExecVol");
@


1.125
log
@Modifiable Heuristic Allocation
@
text
@d1708 1
a1708 1
      << "Test of heuristic adjustment."
d1804 2
a1805 2
      << "Test of witSetModHeurAlloc when heuristic adjustment is not "
         "allowed."
d1823 3
a1825 2
      << "Test of violation of the non-executable constraint during heuristic "
         "adjustment."
d1857 1
a1857 1
      << "heuristic adjustment."
d1888 3
a1890 2
      << "Test of violation of the lot-size constraint during heuristic "
         "adjustment."
d1923 1
a1923 1
      << "heuristic adjustment."
d1955 2
a1956 1
      << "Test of heuristic adjustment when selectionRecovery is FALSE."
d1980 3
a1982 2
      << "Test of violation of the substitution constraint during heuristic "
         "adjustment:"
d2034 3
a2036 2
      << "Test of violation of the substitution constraint during heuristic "
         "adjustment:"
@


1.124
log
@Heuristic Adjustment
@
text
@d1704 1
a1704 1
   witBoolean heurAdjustEnabled;
d1716 1
a1716 1
   witInterpretDevCmd       (theWitRun, "Allow heuristic adjustment.");
d1722 1
a1722 1
   witSetHeurAdjustEnabled  (theWitRun, WitTRUE);
d1724 1
a1724 1
   witGetHeurAdjustEnabled  (theWitRun, & heurAdjustEnabled);
d1726 1
a1726 1
   assert                                (heurAdjustEnabled);
d1804 1
a1804 1
      << "Test of witSetHeurAdjustEnabled when heuristic adjustment is not "
d1808 2
a1809 2
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
d1811 1
a1811 1
   witSetHeurAdjustEnabled (theWitRun, WitTRUE);
d1813 1
a1813 1
   terminationExpected ("witSetHeurAdjustEnabled");
d1834 1
a1834 1
   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");
d1836 1
a1836 1
   witSetHeurAdjustEnabled (theWitRun, WitTRUE);
d1865 1
a1865 1
   witInterpretDevCmd        (theWitRun, "Allow heuristic adjustment.");
d1867 1
a1867 1
   witSetHeurAdjustEnabled   (theWitRun, WitTRUE);
d1897 1
a1897 1
   witInterpretDevCmd        (theWitRun, "Allow heuristic adjustment.");
d1899 1
a1899 1
   witSetHeurAdjustEnabled   (theWitRun, WitTRUE);
d1930 1
a1930 1
   witInterpretDevCmd        (theWitRun, "Allow heuristic adjustment.");
d1932 1
a1932 1
   witSetHeurAdjustEnabled   (theWitRun, WitTRUE);
d1960 1
a1960 1
   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");
d1962 1
a1962 1
   witSetHeurAdjustEnabled (theWitRun, WitTRUE);
d1990 1
a1990 1
   witInterpretDevCmd       (theWitRun, "Allow heuristic adjustment.");
d1992 1
a1992 1
   witSetHeurAdjustEnabled  (theWitRun, WitTRUE);
d2043 1
a2043 1
   witInterpretDevCmd       (theWitRun, "Allow heuristic adjustment.");
d2045 1
a2045 1
   witSetHeurAdjustEnabled  (theWitRun, WitTRUE);
@


1.123
log
@Heuristic Adjustment
@
text
@a81 5
void testCase64  ();
void testCase65  ();
void testCase66  ();
void testCase67  ();
void testCase68  ();
a346 15
   else if (theArg == "64")
      testCase64 ();

   else if (theArg == "65")
      testCase65 ();

   else if (theArg == "66")
      testCase66 ();

   else if (theArg == "67")
      testCase67 ();

   else if (theArg == "68")
      testCase68 ();

d350 1
a350 1
         << "ERROR: The argument value must be an integer from 1 to 68."
a1704 1
   witBoolean heurAdjustActive;
a1776 8
   witGetHeurAdjustActive   (theWitRun, & heurAdjustActive);
   assert                              (! heurAdjustActive);

   witStartHeurAdjust       (theWitRun);

   witGetHeurAdjustActive   (theWitRun, & heurAdjustActive);
   assert                                (heurAdjustActive);

a1785 5
   witFinishHeurAdjust      (theWitRun);

   witGetHeurAdjustActive   (theWitRun, & heurAdjustActive);
   assert                              (! heurAdjustActive);

a1822 124
      << "Test of witStartHeurAdjust when heuristic adjustment is not enabled."
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);

   witInterpretDevCmd (theWitRun, "Allow heuristic adjustment.");

   witStartHeurAlloc  (theWitRun);
   witStartHeurAdjust (theWitRun);

   terminationExpected ("witStartHeurAdjust");
   }

//------------------------------------------------------------------------------

void testCase58 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witStartHeurAdjust when heurAllocActive is FALSE."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);

   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

   witSetHeurAdjustEnabled (theWitRun, WitTRUE);

   witStartHeurAdjust      (theWitRun);

   terminationExpected ("witStartHeurAdjust");
   }

//------------------------------------------------------------------------------

void testCase59 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witStartHeurAdjust when heurAdjustActive is TRUE."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);

   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

   witSetHeurAdjustEnabled (theWitRun, WitTRUE);

   witStartHeurAlloc       (theWitRun);

   witStartHeurAdjust      (theWitRun);
   witStartHeurAdjust      (theWitRun);

   terminationExpected ("witStartHeurAdjust");
   }

//------------------------------------------------------------------------------

void testCase60 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witFinishHeurAdjust when heuristic adjustment is inactive."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);

   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

   witSetHeurAdjustEnabled (theWitRun, WitTRUE);

   witFinishHeurAdjust     (theWitRun);

   terminationExpected ("witFinishHeurAdjust");
   }

//------------------------------------------------------------------------------

void testCase61 ()
   {
   WitRun * theWitRun;
   float    incVol;

   std::cout
      << "Test of call to witIncHeurAlloc during heuristic adjustment."
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);

   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

   witSetHeurAdjustEnabled (theWitRun, WitTRUE);

   witAddPart              (theWitRun, "A",      WitMATERIAL);
   witAddDemand            (theWitRun, "A",      "B");

   witStartHeurAlloc       (theWitRun);

   witStartHeurAdjust      (theWitRun);

   witIncHeurAlloc         (theWitRun, "A", "B", 3, 10.0, & incVol);

   terminationExpected ("witIncHeurAlloc");
   }

//------------------------------------------------------------------------------

void testCase62 ()
   {
   WitRun * theWitRun;

   std::cout
a1841 2
   witStartHeurAdjust      (theWitRun);

d1849 1
a1849 1
void testCase63 ()
a1874 2
   witStartHeurAdjust        (theWitRun);

d1882 1
a1882 1
void testCase64 ()
a1906 2
   witStartHeurAdjust        (theWitRun);

d1914 1
a1914 1
void testCase65 ()
a1940 2
   witStartHeurAdjust        (theWitRun);

d1948 1
a1948 1
void testCase66 ()
d1971 1
a1971 1
void testCase67 ()
d1974 1
d2005 5
a2009 1
   witSetPartSupplyVol      (theWitRun, "A", floatVec (100.0, 100.0));
d2011 1
a2011 1
   witSetOperationExecVol   (theWitRun, "B", floatVec  (10.0,  10.0));
a2014 2
   witStartHeurAdjust       (theWitRun);

d2017 1
a2017 1
   witFinishHeurAdjust      (theWitRun);
d2019 1
a2019 1
   terminationExpected      ("witFinishHeurAdjust");
d2024 1
a2024 1
void testCase68 ()
d2027 1
d2058 2
d2062 2
a2070 2
   witStartHeurAdjust       (theWitRun);

d2073 1
a2073 1
   witFinishHeurAdjust      (theWitRun);
d2075 1
a2075 1
   terminationExpected      ("witFinishHeurAdjust");
@


1.122
log
@Heuristic Adjustment
@
text
@d86 1
d364 3
d370 1
a370 1
         << "ERROR: The argument value must be an integer from 1 to 67."
a392 1
      << std::endl                          
a410 1
      << std::endl                          
d426 1
a426 1
      << std::endl                          
d430 1
a430 1
      << std::endl                          
d443 1
a443 1
      << std::endl                          
a444 1
      << std::endl                          
d460 1
a460 1
      << std::endl                          
d464 1
a464 1
      << std::endl                          
a473 1
      << std::endl                          
d517 1
a517 1
      << std::endl                          
d519 1
a519 1
      << std::endl                          
a520 1
      << std::endl                          
d563 1
a563 1
      << std::endl                          
a564 1
      << std::endl                          
d579 1
a579 1
      << std::endl                          
a580 1
      << std::endl                          
d595 1
a595 1
      << std::endl                          
d599 1
a599 1
      << std::endl                          
d611 1
a611 1
      << std::endl                          
a612 1
      << std::endl                          
a649 1
      << std::endl
a666 1
      << std::endl                          
d703 1
a703 1
      << std::endl                          
a704 1
      << std::endl                          
d727 1
a727 1
      << std::endl                          
a728 1
      << std::endl                          
d754 1
a754 1
      << std::endl                          
d756 1
a756 1
      << std::endl                          
a757 1
      << std::endl                          
d771 1
a771 1
      << std::endl                          
d775 1
a775 1
      << std::endl                          
d789 1
a789 1
      << std::endl                          
a790 1
      << std::endl                          
d800 1
a800 1
      << std::endl                          
d804 1
a804 1
      << std::endl                          
d827 1
a827 1
      << std::endl                          
a828 1
      << std::endl                          
d849 1
a849 1
      << std::endl                          
a850 1
      << std::endl                          
d868 1
a868 1
      << std::endl                          
a869 1
      << std::endl                          
d889 1
a889 1
      << std::endl                          
a890 1
      << std::endl
a906 1
      << std::endl
a922 1
      << std::endl
a940 1
      << std::endl
a966 1
      << std::endl
a987 1
      << std::endl
a1008 1
      << std::endl
a1033 1
      << std::endl
a1057 1
      << std::endl
a1192 1
      << std::endl                          
a1214 1
      << std::endl                          
a1231 1
      << std::endl                          
a1253 1
      << std::endl                          
a1274 1
      << std::endl
a1326 1
      << std::endl
a1351 1
      << std::endl
a1370 1
      << std::endl
a1391 1
      << std::endl
a1417 1
      << std::endl
a1482 1
      << std::endl
a1502 1
      << std::endl
a1523 1
      << std::endl
a1543 1
      << std::endl
a1560 1
      << std::endl
a1578 1
      << std::endl
a1596 1
      << std::endl
a1615 1
      << std::endl
a1634 1
      << std::endl
a1653 1
      << std::endl
a1729 1
      << std::endl
a1839 1
      << std::endl
a1857 1
      << std::endl
a1878 1
      << std::endl
a1900 1
      << std::endl
a1927 1
      << std::endl
a1950 1
      << std::endl
a1982 1
      << std::endl
a2016 1
      << std::endl
a2050 1
      << std::endl
a2085 1
      << std::endl
a2119 1
      << std::endl
d2143 1
a2143 1
         "adjustment."
d2145 1
d2187 53
d2264 2
a2265 2
      << std::endl                          
      << std::endl                          
d2277 1
a2277 1
      << std::endl                          
d2279 1
a2279 1
      << std::endl                          
d2283 1
a2283 1
      << std::endl                          
d2287 1
a2287 1
      << std::endl                          
d2291 1
a2291 1
      << std::endl                          
d2300 1
a2300 1
      << std::endl                          
d2302 1
a2302 1
      << std::endl                          
@


1.121
log
@Heuristic Adjustment
@
text
@d85 1
d360 3
d366 1
a366 1
         << "ERROR: The argument value must be an integer from 1 to 66."
a2027 1
   float    incVol;
d2191 49
@


1.120
log
@Heuristic Adjustment
@
text
@d84 1
d356 3
d362 1
a362 1
         << "ERROR: The argument value must be an integer from 1 to 65."
d1762 1
d1775 4
d1782 3
a1784 1
   witSetNPeriods           (theWitRun, 2);
d1786 1
a1786 1
   witInterpretDevCmd       (theWitRun, "Allow heuristic adjustment.");
d1874 1
a1874 2
   WitRun *   theWitRun;
   witBoolean heurAdjustActive;
d1877 1
a1877 1
      << "Test of witGetHeurAdjustActive when heuristic adjustment is not "
d1882 2
a1883 2
   makeNewWitRun          (theWitRun);
   witInitialize          (theWitRun);
d1885 1
a1885 1
   witGetHeurAdjustActive (theWitRun, & heurAdjustActive);
d1887 1
a1887 1
   terminationExpected ("witGetHeurAdjustActive");
d1897 1
a1897 1
      << "Test of witStartHeurAdjust when heuristic adjustment is not allowed."
d1904 3
d1923 4
a1926 2
   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
d1928 1
a1928 1
   witInterpretDevCmd    (theWitRun, "Allow heuristic adjustment.");
d1930 1
a1930 1
   witStartHeurAdjust    (theWitRun);
d1953 2
d1979 2
d2005 2
d2041 2
d2075 2
d2110 2
d2146 2
d2164 24
@


1.119
log
@Heuristic Adjustment
@
text
@d82 2
d349 6
d358 1
a358 1
         << "ERROR: The argument value must be an integer from 1 to 63."
d2067 68
@


1.118
log
@Heuristic Adjustment
@
text
@d80 2
d341 6
d350 1
a350 1
         << "ERROR: The argument value must be an integer from 1 to 61."
d1992 67
@


1.117
log
@Heuristic Adjustment
@
text
@d83 12
d121 6
d350 1
a350 1
      << "Normal termination of errTest."
a1744 8
   float      supplyVolA[] = {500.};
   float      supplyVolB[] = {500.};
   float      demandVolE[] = {100.};
   float      demandVolF[] = {100.};
   float      execVolD  [] = {130.};
   float      subVolB   [] = {110.};
   float      shipVolF  [] = { 30.};

d1752 15
a1766 5
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 1);
d1768 2
a1769 1
   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");
d1771 3
a1773 3
   witAddPart              (theWitRun, "A", WitMATERIAL);
   witAddPart              (theWitRun, "B", WitMATERIAL);
   witAddPart              (theWitRun, "C", WitMATERIAL);
d1775 1
a1775 1
   witAddOperation         (theWitRun, "D");
d1777 3
a1779 1
   witAddBomEntry          (theWitRun, "D", "A");
d1781 2
a1782 1
   witAddSubsBomEntry      (theWitRun, "D", 0,   "B");
d1784 1
a1784 1
   witAddBopEntry          (theWitRun, "D", "C");
d1786 9
a1794 2
   witAddDemand            (theWitRun, "C", "E");
   witAddDemand            (theWitRun, "C", "F");
d1796 2
a1797 2
   witSetPartSupplyVol     (theWitRun, "A", supplyVolA);
   witSetPartSupplyVol     (theWitRun, "B", supplyVolB);
d1799 2
a1800 2
   witSetDemandDemandVol   (theWitRun, "C", "E", demandVolE);
   witSetDemandDemandVol   (theWitRun, "C", "F", demandVolF);
d1804 8
a1811 1
   witStartHeurAlloc       (theWitRun);
d1813 1
a1813 1
   witIncHeurAlloc         (theWitRun, "C", "E", 0, 100.0, & incVol);
d1815 2
a1816 1
   assert                  (fabs (incVol - 100.0) < .001);
d1818 2
a1819 2
   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                             (! heurAdjustActive);
d1821 1
a1821 1
   witStartHeurAdjust      (theWitRun);
d1823 1
a1823 2
   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                               (heurAdjustActive);
d1825 1
a1825 3
   witSetOperationExecVol  (theWitRun, "D",         execVolD);
   witSetDemandShipVol     (theWitRun, "C", "F",    shipVolF);
   witSetSubsBomEntrySubVol(theWitRun, "D",  0,  0, subVolB);
d1827 1
a1827 1
   witFinishHeurAdjust     (theWitRun);
d1829 2
a1830 2
   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                             (! heurAdjustActive);
d1832 1
a1832 1
   witIncHeurAlloc         (theWitRun, "C", "F", 0, 100.0, & incVol);
d1834 1
a1834 1
   assert                  (fabs (incVol - 70.0) < .001);
d1836 1
a1836 1
   witFinishHeurAlloc      (theWitRun);
d1838 1
a1838 1
   witWriteExecSched       (theWitRun, WitSTDOUT, WitBSV);
d1840 1
a1840 1
   witDeleteRun            (theWitRun);
d1984 17
@


1.116
log
@Heuristic Adjustment
@
text
@d1727 2
a1728 2
   float      supplyVolA[] = {157.};
   float      demandVolD[] = {100.};
d1730 4
a1733 1
   float      execVolC  [] = {170.};
d1752 1
d1754 1
a1754 1
   witAddOperation         (theWitRun, "C");
d1756 1
a1756 1
   witAddBomEntry          (theWitRun, "C", "A");
d1758 1
a1758 1
   witAddBopEntry          (theWitRun, "C", "B");
d1760 4
a1763 2
   witAddDemand            (theWitRun, "B", "D");
   witAddDemand            (theWitRun, "B", "E");
d1766 1
d1768 2
a1769 2
   witSetDemandDemandVol   (theWitRun, "B", "D", demandVolD);
   witSetDemandDemandVol   (theWitRun, "B", "E", demandVolE);
d1775 1
a1775 1
   witIncHeurAlloc         (theWitRun, "B", "D", 0, 100.0, & incVol);
d1787 3
a1789 1
   witSetOperationExecVol  (theWitRun, "C" , execVolC);
d1796 1
a1796 1
   witIncHeurAlloc         (theWitRun, "B", "E", 0, 100.0, & incVol);
d1802 2
@


1.115
log
@Heuristic Adjustment
@
text
@d1725 77
d1819 1
a1819 1
void testCase56 ()
d1838 1
a1838 1
void testCase57 ()
d1859 1
a1859 1
void testCase58 ()
d1885 1
a1885 1
void testCase59 ()
d1906 1
a1906 1
void testCase60 ()
a1936 74
void testCase61 ()
   {
   WitRun *   theWitRun;
   witBoolean heurAdjustActive;
   float      incVol;

   float      supplyVolA[] = {157.0};
   float      demandVolD[] = {100.0};
   float      demandVolE[] = {100.0};

   std::cout
      << "Test of heuristic adjustment."
      << std::endl
      << std::endl;

   //...........................................................................

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetSelectionRecovery (theWitRun, WitTRUE);
   witSetSkipFailures      (theWitRun, WitFALSE);
   witSetNPeriods          (theWitRun, 1);

   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

   witAddPart              (theWitRun, "A", WitMATERIAL);
   witAddPart              (theWitRun, "B", WitMATERIAL);

   witAddOperation         (theWitRun, "C");

   witAddBomEntry          (theWitRun, "C", "A");

   witAddBopEntry          (theWitRun, "C", "B");

   witAddDemand            (theWitRun, "B", "D");
   witAddDemand            (theWitRun, "B", "E");

   witSetPartSupplyVol     (theWitRun, "A", supplyVolA);

   witSetDemandDemandVol   (theWitRun, "B", "D", demandVolD);
   witSetDemandDemandVol   (theWitRun, "B", "E", demandVolE);

   //...........................................................................

   witStartHeurAlloc       (theWitRun);

   witIncHeurAlloc         (theWitRun, "B", "D", 0, 100.0, & incVol);

   assert                  (fabs (incVol - 100.0) < .001);

   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                             (! heurAdjustActive);

   witStartHeurAdjust      (theWitRun);

   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                               (heurAdjustActive);

   witFinishHeurAdjust     (theWitRun);

   witGetHeurAdjustActive  (theWitRun, & heurAdjustActive);
   assert                             (! heurAdjustActive);

   witIncHeurAlloc         (theWitRun, "B", "E", 0, 100.0, & incVol);

   assert                  (fabs (incVol - 57.0) < .001);

   witFinishHeurAlloc      (theWitRun);

   witDeleteRun            (theWitRun);
   }

//------------------------------------------------------------------------------

@


1.114
log
@Heuristic Adjustment
@
text
@d13 1
a1794 1
   witStartHeurAlloc       (theWitRun);
d1798 2
d1843 3
a1850 2
   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");

d1864 5
d1875 2
d1881 23
d1906 3
a1908 1
   witInterpretDevCmd      (theWitRun, "Allow heuristic adjustment.");
d1923 4
@


1.113
log
@Heuristic Adjustment
@
text
@d78 1
d317 3
d323 1
a323 1
         << "ERROR: The argument value must be an integer from 1 to 60."
d1829 30
d1863 1
a1863 1
      << "Test of solution adjiustment."
@


1.112
log
@Pause/Resume
@
text
@d76 2
d310 6
d319 1
a319 1
         << "ERROR: The argument value must be an integer from 1 to 58."
d1719 1
a1719 1
   witBoolean heurAllocPaused;
d1722 2
a1723 1
      << "Test of witGetHeurAllocPaused when pause heur-alloc is not allowed."
d1727 2
a1728 2
   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
d1730 1
a1730 1
   witGetHeurAllocPaused (theWitRun, & heurAllocPaused);
d1732 1
a1732 1
   terminationExpected ("witGetHeurAllocPaused");
d1742 1
a1742 1
      << "Test of witPauseHeurAlloc when pause heur-alloc is not allowed."
d1746 2
a1747 2
   makeNewWitRun     (theWitRun);
   witInitialize     (theWitRun);
d1749 1
a1749 1
   witPauseHeurAlloc (theWitRun);
d1751 1
a1751 1
   terminationExpected ("witPauseHeurAlloc");
d1761 1
a1761 1
      << "Test of witPauseHeurAlloc when heurAllocActive is FALSE."
d1768 1
a1768 1
   witInterpretDevCmd    (theWitRun, "Allow pause/resume.");
d1770 1
a1770 1
   witPauseHeurAlloc     (theWitRun);
d1772 1
a1772 1
   terminationExpected ("witPauseHeurAlloc");
d1779 46
d1826 1
a1826 1
   witBoolean heurAllocPaused;
d1829 1
a1829 1
      << "Test of partially implemented witPauseHeurAlloc."
d1839 11
a1849 1
   witInterpretDevCmd      (theWitRun, "Allow pause/resume.");
d1851 2
a1852 2
   witGetHeurAllocPaused   (theWitRun, & heurAllocPaused);
   assert                             (! heurAllocPaused);
d1854 1
a1854 1
   witPauseHeurAlloc       (theWitRun);
d1856 1
a1856 1
   terminationExpected ("witPauseHeurAlloc");
@


1.111
log
@Pause/Resume
@
text
@d1778 5
a1782 2
   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
d1784 1
a1784 1
   witInterpretDevCmd    (theWitRun, "Allow pause/resume.");
d1786 2
a1787 1
   witGetHeurAllocPaused (theWitRun, & heurAllocPaused);
d1789 1
a1789 4
   assert (! heurAllocPaused);

   witStartHeurAlloc     (theWitRun);
   witPauseHeurAlloc     (theWitRun);
@


1.110
log
@Pause/Resume
@
text
@d12 2
d75 9
d305 3
d311 1
a311 1
         << "ERROR: The argument value must be an integer from 1 to 57."
d341 1
a341 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witAddBomEntry."
      << std::endl                          
      << std::endl;

   exit (1);
d606 1
a606 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witInterpretDevCmd."
      << std::endl                          
      << std::endl;

   exit (1);
d667 1
a667 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyData."
      << std::endl                          
      << std::endl;

   exit (1);
d694 1
a694 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witAddOperation."
      << std::endl                          
      << std::endl;

   exit (1);
d766 1
a766 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witReadData."
      << std::endl                          
      << std::endl;

   exit (1);
d794 1
a794 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witExecStandAlone."
      << std::endl                          
      << std::endl;

   exit (1);
d814 1
a814 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witSetNPeriods."
      << std::endl                          
      << std::endl;

   exit (1);
d836 1
a836 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witAddOperation."
      << std::endl                          
      << std::endl;

   exit (1);
d856 1
a856 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witFinishExtOpt."
      << std::endl                          
      << std::endl;

   exit (1);
d871 1
a871 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witInitialize."
      << std::endl                          
      << std::endl;

   exit (1);
d891 1
a891 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witAddOperation."
      << std::endl                          
      << std::endl;

   exit (1);
d916 1
a916 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witOptImplode."
      << std::endl                          
      << std::endl;

   exit (1);
d937 1
a937 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witStartExtOpt."
      << std::endl                          
      << std::endl;

   exit (1);
d960 1
a960 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witGetPartStockVarIndex."
      << std::endl                          
      << std::endl;

   exit (1);
d986 1
a986 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyData."
      << std::endl                          
      << std::endl;

   exit (1);
d1010 1
a1010 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyData."
      << std::endl                          
      << std::endl;

   exit (1);
d1034 1
a1034 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyData."
      << std::endl                          
      << std::endl;

   exit (1);
d1053 1
a1053 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyPartData."
      << std::endl                          
      << std::endl;

   exit (1);
d1074 1
a1074 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyPartData."
      << std::endl                          
      << std::endl;

   exit (1);
d1095 1
a1095 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyPartData."
      << std::endl                          
      << std::endl;

   exit (1);
d1123 1
a1123 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witSetNPeriods."
      << std::endl                          
      << std::endl;

   exit (1);
d1149 1
a1149 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyPartData."
      << std::endl                          
      << std::endl;

   exit (1);
d1172 1
a1172 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witPurgeData."
      << std::endl                          
      << std::endl;

   exit (1);
d1190 1
a1190 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witStochImplode."
      << std::endl                          
      << std::endl;

   exit (1);
d1213 1
a1213 9
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during the second call to "
      << std::endl                          
      << "       witStochImplode."
      << std::endl                          
      << std::endl;

   exit (1);
d1234 1
a1234 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witClearStochSoln."
      << std::endl                          
      << std::endl;

   exit (1);
d1260 1
a1260 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witSetDemandDemandVol."
      << std::endl                          
      << std::endl;

   exit (1);
d1287 1
a1287 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witCopyOperationData."
      << std::endl                          
      << std::endl;

   exit (1);
d1313 1
a1313 7
   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witSetPartObjectStage."
      << std::endl                          
      << std::endl;

   exit (1);
d1333 1
a1333 7
   std::cerr
      << std::endl
      << "ERROR: errTest should have terminated during witGetPartObjectStage."
      << std::endl                          
      << std::endl;

   exit (1);
d1355 1
a1355 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witGetOperationObjectStage."
      << std::endl                          
      << std::endl;

   exit (1);
d1377 1
a1377 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witGetPeriodStage."
      << std::endl                          
      << std::endl;

   exit (1);
d1468 1
a1468 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetPartPartName."
      << std::endl                          
      << std::endl;

   exit (1);
d1490 1
a1490 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetOperationOperationName."
      << std::endl                          
      << std::endl;

   exit (1);
d1513 1
a1513 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetDemandDemandName."
      << std::endl                          
      << std::endl;

   exit (1);
d1531 1
a1531 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witIssueFatalMesg."
      << std::endl                          
      << std::endl;

   exit (1);
d1550 1
a1550 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetWit34Compatible."
      << std::endl                          
      << std::endl;

   exit (1);
d1569 1
a1569 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetCurrentObjective."
      << std::endl                          
      << std::endl;

   exit (1);
d1588 1
a1588 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witStartExtOpt."
      << std::endl                          
      << std::endl;

   exit (1);
d1608 1
a1608 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetObjectiveList."
      << std::endl                          
      << std::endl;

   exit (1);
d1628 1
a1628 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetObjectiveList."
      << std::endl                          
      << std::endl;

   exit (1);
d1648 1
a1648 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetObjectiveList."
      << std::endl                          
      << std::endl;

   exit (1);
d1676 1
a1676 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witCopyOperationData."
      << std::endl                          
      << std::endl;

   exit (1);
d1703 1
a1703 8
   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witCopyPartData."
      << std::endl                          
      << std::endl;

   exit (1);
d1723 11
a1733 1
   std::cerr
a1734 3
      << "ERROR: "
         "errTest should have terminated during witGetHeurAllocPaused."
      << std::endl                          
d1737 6
a1742 1
   exit (1);
d1747 1
a1747 1
void testCase56 ()
d1752 1
a1752 1
      << "Test of witPauseHeurAlloc when pause heur-alloc is not allowed."
d1759 2
d1762 2
d1768 1
a1768 1
void testCase57 ()
d1774 1
a1774 1
      << "Test of partially implemented witPauseHeurAlloc (...)."
d1785 1
a1785 12
   if (heurAllocPaused)
      {
      std::cout
         << "Heuristic allocation is paused."
         << std::endl;
      }
   else
      {
      std::cout
         << "Heuristic allocation is not paused."
         << std::endl;
      }
d1787 1
d1789 19
@


1.109
log
@Pause/Resume
@
text
@d72 1
d291 3
d297 1
a297 1
         << "ERROR: The argument value must be an integer from 1 to 56."
d2003 17
d2024 1
a2024 1
      << "Test of pause/resume (no errors)."
d2047 2
@


1.108
log
@Pause/Resume
@
text
@d71 1
d287 3
d293 1
a293 1
         << "ERROR: The argument value must be an integer from 1 to 55."
d1997 33
@


1.107
log
@Reduced message 903 from severe to warning.
@
text
@d70 1
d283 3
d289 1
a289 1
         << "ERROR: The argument value must be an integer from 1 to 54."
d1966 27
@


1.106
log
@Multi-Obj Mode
@
text
@a69 1
void testCase55  ();
a281 3
   else if (theArg == "55")
      testCase55 ();

d285 1
a285 1
         << "ERROR: The argument value must be an integer from 1 to 55."
a1024 68
   WitRun * theWitRun;
   int      numcols;
   int      numrows;
   int *    start;
   int *    index;
   double * value;
   double * collb;
   double * colub;
   double * obj;
   double * rowlb;
   double * rowub;
   int      scrapVarIndex;

   std::cout
      << "Test of WIT's behavior when an infeasible solution is passed in "
         "through\n"
         "witSetExtOptSolnDbl."
      << std::endl
      << std::endl;

   makeNewWitRun  (theWitRun);
   witInitialize  (theWitRun);
   witAddPart     (theWitRun, "A", WitMATERIAL);
   witStartExtOpt (theWitRun);

   witGetExtOptLpProbDbl (
        theWitRun,
      & numcols,
      & numrows,
      & start,
      & index,
      & value,
      & collb,
      & colub,
      & obj,
      & rowlb,
      & rowub);

   witGetPartScrapVarIndex (
        theWitRun,
        "A",
        5,
      & scrapVarIndex);

   std::cout
      << "A.scrapVarIndex[5] = "
      << scrapVarIndex
      << std::endl
      << std::endl;

   collb[scrapVarIndex] = -2.7;

   witSetExtOptSolnDbl (theWitRun, collb);
   witFinishExtOpt     (theWitRun);

   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witFinishExtOpt."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase25 ()
   {
d1055 1
a1055 1
void testCase26 ()
d1085 1
a1085 1
void testCase27 ()
d1115 1
a1115 1
void testCase28 ()
d1140 1
a1140 1
void testCase29 ()
d1167 1
a1167 1
void testCase30 ()
d1194 1
a1194 1
void testCase31 ()
d1228 1
a1228 1
void testCase32 ()
d1260 1
a1260 1
void testCase33 ()
d1289 1
a1289 1
void testCase34 ()
d1313 1
a1313 1
void testCase35 ()
d1344 1
a1344 1
void testCase36 ()
d1371 1
a1371 1
void testCase37 ()
d1403 1
a1403 1
void testCase38 ()
d1436 1
a1436 1
void testCase39 ()
d1468 1
a1468 1
void testCase40 ()
d1494 1
a1494 1
void testCase41 ()
d1523 1
a1523 1
void testCase42 ()
d1552 1
a1552 1
void testCase43 ()
d1624 1
a1624 1
void testCase44 ()
d1650 1
a1650 1
void testCase45 ()
d1679 1
a1679 1
void testCase46 ()
d1709 1
a1709 1
void testCase47 ()
d1734 1
a1734 1
void testCase48 ()
d1760 1
a1760 1
void testCase49 ()
d1786 1
a1786 1
void testCase50 ()
d1812 1
a1812 1
void testCase51 ()
d1839 1
a1839 1
void testCase52 ()
d1866 1
a1866 1
void testCase53 ()
d1893 1
a1893 1
void testCase54 ()
d1928 1
a1928 1
void testCase55 ()
@


1.105
log
@Multi-obj mode
@
text
@d69 2
d280 6
d289 1
a289 1
         << "ERROR: The argument value must be an integer from 1 to 53."
d1965 69
@


1.104
log
@Multi-objective mode
@
text
@d64 5
d263 15
d281 1
a281 1
         << "ERROR: The argument value must be an integer from 1 to 48."
d1824 133
@


1.103
log
@Multi-Objective Mode
@
text
@a63 2
void testCase49  ();
void testCase50  ();
a257 6
   else if (theArg == "49")
      testCase49 ();

   else if (theArg == "50")
      testCase50 ();

d261 1
a261 1
         << "ERROR: The argument value must be an integer from 1 to 50."
a1803 57
void testCase49 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when witStartExtOpt is called while"
      << std::endl                          
      << "WIT is in multiple objectives mode."
      << std::endl                          
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witInterpretDevCmd (theWitRun, "Allow multiObjMode.");
   witSetMultiObjMode (theWitRun, WitTRUE);
   witAddPart         (theWitRun, "A", WitMATERIAL);
   witStartExtOpt     (theWitRun);

   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witStartExtOpt."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase50 ()
   {
   WitRun * theWitRun;
   int      lenList;
   char * * objectiveList;

   std::cout
      << "Test of WIT's behavior when witGetObjectives is called while"
      << std::endl                          
      << "WIT is not in multiple objectives mode."
      << std::endl                          
      << std::endl;

   makeNewWitRun    (theWitRun);
   witInitialize    (theWitRun);
   witGetObjectives (theWitRun, & lenList, & objectiveList);

   std::cerr
      << std::endl                          
      << "ERROR: errTest should have terminated during witGetObjectives."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

@


1.102
log
@Multi-Objective Mode
@
text
@d65 1
d263 3
d269 1
a269 1
         << "ERROR: The argument value must be an integer from 1 to 49."
d1841 28
@


1.101
log
@Revised for the removal of the multiThread attribute.
@
text
@d64 1
d259 3
d265 1
a265 1
         << "ERROR: The argument value must be an integer from 1 to 48."
a1130 1

d1808 29
@


1.100
log
@Revised wit34Allowed.
@
text
@a463 14
   WitRun * theWitRun;

   std::cout
      << "Test of witOptImplode in multiThread mode."
      << std::endl                          
      << std::endl;

   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetMultiThread       (theWitRun, WitTRUE);
   witAddPartWithOperation (theWitRun, "A");
   witOptImplode           (theWitRun);
   witDeleteRun            (theWitRun);

d466 1
a466 1
      << "The call to witOptimplode was successful."
d470 1
a470 1
   exit (0);
@


1.99
log
@Revised wit34Allowed.
@
text
@a63 2
void testCase49  ();
void testCase50  ();
a257 6
   else if (theArg == "49")
      testCase49 ();

   else if (theArg == "50")
      testCase50 ();

d261 1
a261 1
         << "ERROR: The argument value must be an integer from 1 to 50."
a1818 51
void testCase49 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of setting wit34Allowed to TRUE."
      << std::endl
      << std::endl;

   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witSetWit34Allowed (theWitRun, WitTRUE);

   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetWit34Allowed."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase50 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of setting wit34Allowed when wit34Compatiable is TRUE."
      << std::endl
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witSetWit34Compatible (theWitRun, WitTRUE);
   witSetWit34Allowed    (theWitRun, WitFALSE);

   std::cerr
      << std::endl
      << "ERROR: "
         "errTest should have terminated during witSetWit34Allowed."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

@


1.98
log
@wit34Allowed
@
text
@d65 1
d263 3
d269 1
a269 1
         << "ERROR: The argument value must be an integer from 1 to 49."
d1852 26
@


1.97
log
@Added a test for witIssueFatalMesg.
@
text
@d63 2
d256 6
d265 1
a265 1
         << "ERROR: The argument value must be an integer from 1 to 47."
d1753 6
a1758 6
   makeNewWitRun                (theWitRun);
   witInitialize                (theWitRun);
   witAddPart                   (theWitRun, "A", WitMATERIAL);
   witAddDemand                 (theWitRun, "A", "B");
   witAddDemand                 (theWitRun, "A", "C");
   witSetDemandDemandName       (theWitRun, "A", "B", "C");
d1781 3
a1783 3
   makeNewWitRun                (theWitRun);
   witInitialize                (theWitRun);
   witIssueFatalMesg            (theWitRun);
d1797 51
@


1.96
log
@Removed some calls that set mesgFileAccessMode to "w".
@
text
@d62 1
d251 3
d257 1
a257 1
         << "ERROR: The argument value must be an integer from 1 to 46."
d1764 25
@


1.95
log
@Stochastic Implosion
@
text
@d79 1
a79 2
   // Creates a new WitRun, sets theWitRun to it, and sets the message file
   // mode to "w" to specify writing a new file.
d1798 1
a1798 3
   witNewRun              (& theWitRun);

   witSetMesgFileAccessMode (theWitRun, WitFALSE, "w");
@


1.94
log
@Object name change.
@
text
@a1557 1
   witInterpretDevCmd         (theWitRun, "Allow stage-by-period.");
a1624 1
   witInterpretDevCmd       (theWitRun, "Allow stage-by-period.");
@


1.93
log
@Object name changing.
@
text
@d61 1
d248 3
d254 1
a254 1
         << "ERROR: The argument value must be an integer from 1 to 45."
d1733 30
@


1.92
log
@Object name changing.
@
text
@d1705 3
a1707 2
      << "Test of witSetPartPartName with a partName that matches an existing "
         "part."
d1711 5
a1715 5
   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witAddPart         (theWitRun, "A", WitMATERIAL);
   witAddPart         (theWitRun, "B", WitCAPACITY);
   witSetPartPartName (theWitRun, "A", "B");
d1720 1
a1720 1
         "errTest should have terminated during witSetPartPartName."
@


1.91
log
@Stochastic Implosion
@
text
@d59 2
d241 6
d250 1
a250 1
         << "ERROR: The argument value must be an integer from 1 to 43."
d1674 54
@


1.90
log
@Stochastic Implosion
@
text
@d1362 8
a1369 8
   makeNewWitRun        (theWitRun);
   witInitialize        (theWitRun);
   witAddPart           (theWitRun, "A", WitMATERIAL);
   witSetStageByObject  (theWitRun,      WitTRUE);
   witSetStochMode      (theWitRun,      WitTRUE);
   witSetPartStageIndex (theWitRun, "A", 1);
   witStochImplode      (theWitRun);
   witStochImplode      (theWitRun);
d1428 1
a1428 1
   witSetPartStageIndex  (theWitRun, "A",      1);
d1482 1
a1482 1
      << "Test of witSetPartStageIndex in stochastic solution mode."
d1486 10
a1495 10
   makeNewWitRun        (theWitRun);
   witInitialize        (theWitRun);
   witSetNPeriods       (theWitRun,           1);
   witAddPart           (theWitRun, "A",      WitMATERIAL);
   witAddDemand         (theWitRun, "A", "B");
   witSetStageByObject  (theWitRun,           WitTRUE);
   witSetStochMode      (theWitRun,           WitTRUE);
   witSetPartStageIndex (theWitRun, "A",      1);
   witStochImplode      (theWitRun);
   witSetPartStageIndex (theWitRun, "A",      0);
d1499 1
a1499 1
      << "ERROR: errTest should have terminated during witSetPartStageIndex."
d1514 1
a1514 1
      << "Test of witGetPartStageIndex without stochastic mode."
d1518 4
a1521 4
   makeNewWitRun        (theWitRun);
   witInitialize        (theWitRun);
   witAddPart           (theWitRun, "A",   WitMATERIAL);
   witGetPartStageIndex (theWitRun, "A", & stageIdx);
d1525 1
a1525 1
      << "ERROR: errTest should have terminated during witGetPartStageIndex."
d1540 1
a1540 1
      << "Test of witGetOperationStageIndex while stageByObject is FALSE."
d1544 7
a1550 7
   makeNewWitRun             (theWitRun);
   witInitialize             (theWitRun);
   witInterpretDevCmd        (theWitRun, "Allow stage-by-period.");
   witAddPart                (theWitRun, "A",   WitMATERIAL);
   witAddOperation           (theWitRun, "B");
   witSetStochMode           (theWitRun,        WitTRUE);
   witGetOperationStageIndex (theWitRun, "B", & stageIdx);
d1555 1
a1555 1
         "errTest should have terminated during witGetOperationStageIndex."
d1567 1
a1567 1
   int *    stageIdx;
d1570 1
a1570 1
      << "Test of witGetPerStageIndex while stageByObject is TRUE."
d1579 1
a1579 1
   witGetPerStageIndex (theWitRun,    & stageIdx);
d1584 1
a1584 1
         "errTest should have terminated during witGetPerStageIndex."
d1596 5
a1600 5
   float    yieldRate []    = {1,   0};
   float    execCost  []    = {0.6, 0.6};
   float    shipReward[]    = {1.0, 1.0};
   int      perStageIndex[] = {0,   1};
   float    demandVol []    = {0,   0};
d1633 1
a1633 1
   witSetPerStageIndex      (theWitRun,                 perStageIndex);
d1635 1
a1635 1
   witSetCurScenarioIndex   (theWitRun,                 0);
d1640 1
a1640 1
   witSetCurScenarioIndex   (theWitRun,                 1);
d1645 1
a1645 1
   witSetCurScenarioIndex   (theWitRun,                 2);
@


1.89
log
@Stochastic Implosion
@
text
@d57 2
d233 6
d242 1
a242 1
         << "ERROR: The argument value must be an integer from 1 to 41."
d1564 102
@


1.88
log
@Stochastic Implosion
@
text
@d56 1
d228 3
d234 1
a234 1
         << "ERROR: The argument value must be an integer from 1 to 40."
d1491 1
a1491 2
      << "ERROR: "
         "errTest should have terminated during witSetPartStageIndex."
a1511 1
   witSetNPeriods       (theWitRun,        1);
d1517 29
d1547 1
a1547 1
         "errTest should have terminated during witGetPartStageIndex."
@


1.87
log
@Stochastic Implosion
@
text
@d55 1
d224 3
d230 1
a230 1
         << "ERROR: The argument value must be an integer from 1 to 39."
d262 1
a262 1
      << "ERROR: The program should have terminated during witAddBomEntry."
d547 1
a547 1
      << "ERROR: The program should have terminated during witInterpretDevCmd."
d614 1
a614 1
      << "ERROR: The program should have terminated during witCopyData."
d647 1
a647 1
      << "ERROR: The program should have terminated during witAddOperation."
d725 1
a725 1
      << "ERROR: The program should have terminated during witReadData."
d759 1
a759 1
      << "ERROR: The program should have terminated during witExecStandAlone."
d785 1
a785 1
      << "ERROR: The program should have terminated during witSetNPeriods."
d813 1
a813 1
      << "ERROR: The program should have terminated during witAddOperation."
d839 1
a839 1
      << "ERROR: The program should have terminated during witFinishExtOpt."
d860 1
a860 1
      << "ERROR: The program should have terminated during witInitialize."
d886 1
a886 1
      << "ERROR: The program should have terminated during witAddOperation."
d917 1
a917 1
      << "ERROR: The program should have terminated during witOptImplode."
d944 1
a944 1
      << "ERROR: The program should have terminated during witStartExtOpt."
d973 1
a973 2
      << "ERROR: The program should have terminated during "
         "witGetPartStockVarIndex."
d1041 1
a1041 1
      << "ERROR: The program should have terminated during witFinishExtOpt."
d1073 1
a1073 1
      << "ERROR: The program should have terminated during witCopyData."
d1103 1
a1103 1
      << "ERROR: The program should have terminated during witCopyData."
d1134 1
a1134 1
      << "ERROR: The program should have terminated during witCopyData."
d1159 1
a1159 1
      << "ERROR: The program should have terminated during witCopyPartData."
d1186 1
a1186 1
      << "ERROR: The program should have terminated during witCopyPartData."
d1213 1
a1213 1
      << "ERROR: The program should have terminated during witCopyPartData."
d1247 1
a1247 1
      << "ERROR: The program should have terminated during witSetNPeriods."
d1279 1
a1279 1
      << "ERROR: The program should have terminated during witCopyPartData."
d1308 1
a1308 1
      << "ERROR: The program should have terminated during witPurgeData."
d1332 1
a1332 1
      << "ERROR: The program should have terminated during witStochImplode."
d1361 1
a1361 1
      << "ERROR: The program should have terminated during the second call to "
d1390 1
a1390 1
      << "ERROR: The program should have terminated during witClearStochSoln."
d1422 1
a1422 2
      << "ERROR: The program should have terminated during "
         "witSetDemandDemandVol."
d1455 1
a1455 2
      << "ERROR: The program should have terminated during "
         "witCopyOperationData."
d1488 29
a1516 1
         "The program should have terminated during witSetPartStageIndex."
@


1.86
log
@Stochastic Implosion
@
text
@d1290 1
a1290 1
      << "Test of witPurgeData during stochastic implosion mode."
d1319 1
a1319 1
      << "Test of witStochImplode without stochastic implosion mode."
@


1.85
log
@Stochastic Implosion
@
text
@d1347 8
a1354 8
   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witAddPart          (theWitRun, "A", WitMATERIAL);
   witSetStageByObject (theWitRun,      WitTRUE);
   witSetStochMode     (theWitRun,      WitTRUE);
   witSetPartStageNo   (theWitRun, "A", 1);
   witStochImplode     (theWitRun);
   witStochImplode     (theWitRun);
d1413 1
a1413 1
   witSetPartStageNo     (theWitRun, "A",      1);
d1469 1
a1469 1
      << "Test of witSetPartStageNo in stochastic solution mode."
d1473 10
a1482 10
   makeNewWitRun       (theWitRun);
   witInitialize       (theWitRun);
   witSetNPeriods      (theWitRun,           1);
   witAddPart          (theWitRun, "A",      WitMATERIAL);
   witAddDemand        (theWitRun, "A", "B");
   witSetStageByObject (theWitRun,           WitTRUE);
   witSetStochMode     (theWitRun,           WitTRUE);
   witSetPartStageNo   (theWitRun, "A",      1);
   witStochImplode     (theWitRun);
   witSetPartStageNo   (theWitRun, "A",      0);
d1486 2
a1487 1
      << "ERROR: The program should have terminated during witSetPartStageNo."
@


1.84
log
@Stochastic Implosion
@
text
@d1374 1
a1374 1
      << "Test of witDiscardStochSoln when not in stochastic solution mode."
d1383 1
a1383 1
   witDiscardStochSoln (theWitRun);
d1387 1
a1387 1
      << "ERROR: The program should have terminated during witDiscardStochSoln."
@


1.83
log
@Stochastic Implosion
@
text
@d1297 1
d1435 1
a1435 2
      << "Test of witCopyOperationData where origWitRun is in stochastic data "
         "mode."
d1441 1
@


1.82
log
@Stochastic Implosion
@
text
@a54 1
void testCase40  ();
a222 3
   else if (theArg == "40")
      testCase40 ();

d226 1
a226 1
         << "ERROR: The argument value must be an integer from 1 to 40."
a1429 32
   WitRun * theWitRun;
   float *  theFltVec;

   std::cout
      << "Test of witGetPartResidualVol in stochastic mode "
      << std::endl
      << "without stochastic solution mode."
      << std::endl
      << std::endl;

   makeNewWitRun         (theWitRun);
   witInitialize         (theWitRun);
   witSetNPeriods        (theWitRun, 1);
   witAddPart            (theWitRun, "A", WitCAPACITY);
   witSetStageByObject   (theWitRun, WitTRUE);
   witSetStochMode       (theWitRun, WitTRUE);
   witGetPartResidualVol (theWitRun, "A", & theFltVec);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during "
         "witGetPartResidualVol."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase39 ()
   {
d1462 1
a1462 1
void testCase40 ()
@


1.81
log
@Stochastic Implosion
@
text
@d1438 1
a1438 1
      << "Test of witGetOperationExecVol in stochastic data mode "
d1444 7
a1450 7
   makeNewWitRun          (theWitRun);
   witInitialize          (theWitRun);
   witSetNPeriods         (theWitRun, 1);
   witAddOperation        (theWitRun, "A");
   witSetStageByObject    (theWitRun, WitTRUE);
   witSetStochMode        (theWitRun, WitTRUE);
   witGetOperationExecVol (theWitRun, "A", & theFltVec);
d1455 1
a1455 1
         "witSetDemandDemandVol."
@


1.80
log
@Stochastic Implosion
@
text
@a1301 1
   witInterpretDevCmd       (theWitRun,     "Allow stochastic implosion.");
d1326 3
a1328 4
   makeNewWitRun      (theWitRun);
   witInitialize      (theWitRun);
   witInterpretDevCmd (theWitRun, "Allow stochastic implosion.");
   witStochImplode    (theWitRun);
a1352 1
   witInterpretDevCmd  (theWitRun,      "Allow stochastic implosion.");
a1383 1
   witInterpretDevCmd  (theWitRun, "Allow stochastic implosion.");
a1413 1
   witInterpretDevCmd    (theWitRun,          "Allow stochastic implosion.");
a1447 1
   witInterpretDevCmd     (theWitRun, "Allow stochastic implosion.");
a1476 1
   witInterpretDevCmd   (origWitRun, "Allow stochastic implosion.");
a1512 1
   witInterpretDevCmd  (theWitRun,          "Allow stochastic implosion.");
@


1.79
log
@Changed the message file open mode to "w".
@
text
@d1352 9
a1360 9
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witAddPart              (theWitRun, "A", WitMATERIAL);
   witInterpretDevCmd      (theWitRun,      "Allow stochastic implosion.");
   witSetStageByObject     (theWitRun,      WitTRUE);
   witSetStochMode         (theWitRun,      WitTRUE);
   witSetPartRecourseStage (theWitRun, "A", WitTRUE);
   witStochImplode         (theWitRun);
   witStochImplode         (theWitRun);
d1413 11
a1423 11
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetNPeriods          (theWitRun,           1);
   witAddPart              (theWitRun, "A",      WitMATERIAL);
   witAddDemand            (theWitRun, "A", "B");
   witInterpretDevCmd      (theWitRun,          "Allow stochastic implosion.");
   witSetStageByObject     (theWitRun,           WitTRUE);
   witSetStochMode         (theWitRun,           WitTRUE);
   witSetPartRecourseStage (theWitRun, "A",      WitTRUE);
   witStochImplode         (theWitRun);
   witSetDemandDemandVol   (theWitRun, "A", "B", demandVolB);
d1511 1
a1511 1
      << "Test of witSetPartRecourseStage in stochastic solution mode."
d1515 11
a1525 11
   makeNewWitRun           (theWitRun);
   witInitialize           (theWitRun);
   witSetNPeriods          (theWitRun,           1);
   witAddPart              (theWitRun, "A",      WitMATERIAL);
   witAddDemand            (theWitRun, "A", "B");
   witInterpretDevCmd      (theWitRun,          "Allow stochastic implosion.");
   witSetStageByObject     (theWitRun,           WitTRUE);
   witSetStochMode         (theWitRun,           WitTRUE);
   witSetPartRecourseStage (theWitRun, "A",      WitTRUE);
   witStochImplode         (theWitRun);
   witSetPartRecourseStage (theWitRun, "A",      WitFALSE);
d1529 1
a1529 2
      << "ERROR: The program should have terminated during "
         "witSetPartRecourseStage."
@


1.78
log
@Stochastic Implosion
@
text
@d71 7
d256 1
a256 1
   witNewRun    (& theWitRun);
d281 1
a281 1
   witNewRun (& theWitRun);
d316 1
a316 1
   witNewRun (& theWitRun);
d368 1
a368 1
   witNewRun (& theWitRun);
d416 1
a416 1
   witNewRun (& theWitRun);
d440 1
a440 1
   witNewRun             (& theWitRun);
d470 2
a471 2
   witNewRun      (& theWitRun);
   witInitialize    (theWitRun);
d503 2
a504 2
   witNewRun      (& theWitRun);
   witInitialize    (theWitRun);
d541 1
a541 1
   witNewRun        (& theWitRun);
d565 2
a566 2
   witNewRun      (& theWitRun);
   witInitialize    (theWitRun);
d604 1
a604 1
   witNewRun           (& origWitRun);
d609 1
a609 1
   witNewRun           (& dupWitRun);
d635 1
a635 1
   witNewRun           (& origWitRun);
d640 1
a640 1
   witNewRun           (& dupWitRun); 
d671 1
a671 1
   witNewRun           (& origWitRun);
d676 1
a676 1
   witNewRun           (& dupWitRun);
d705 1
a705 1
   witNewRun           (& theWitRunA);
d719 1
a719 1
   witNewRun           (& theWitRunB);
d750 1
a750 1
   witNewRun           (& theWitRunA);
d754 1
a754 1
   witNewRun           (& theWitRunB);
d779 1
a779 1
   witNewRun    (& theWitRun);
d805 1
a805 1
   witNewRun     (& theWitRun);
d833 1
a833 1
   witNewRun     (& theWitRun);
d879 1
a879 1
   witNewRun     (& theWitRun);
d904 1
a904 1
   witNewRun                  (& theWitRun);
d937 1
a937 1
   witNewRun          (& theWitRun);
d965 1
a965 1
   witNewRun             (& theWitRun);
d1005 1
a1005 1
   witNewRun    (& theWitRun);
d1062 1
a1062 1
   witNewRun    (& origWitRun);
d1065 1
a1065 1
   witNewRun    (& dupWitRun);
d1094 1
a1094 1
   witNewRun    (& origWitRun);
d1099 1
a1099 1
   witNewRun    (& dupWitRun);
d1126 1
a1126 1
   witNewRun    (& origWitRun);
d1128 2
a1129 2
   witNewRun    (& dupWitRun);
   witInitialize  (dupWitRun);
d1131 1
a1131 1
   witCopyData    (dupWitRun, origWitRun);
d1152 1
a1152 1
   witNewRun     (& theWitRun);
d1178 1
a1178 1
   witNewRun     (& theWitRun);
d1205 1
a1205 1
   witNewRun     (& origWitRun);
d1207 1
a1207 1
   witNewRun     (& dupWitRun);
d1234 1
a1234 1
   witNewRun           (& origWitRun);
d1238 1
a1238 1
   witNewRun           (& dupWitRun);
d1267 1
a1267 1
   witNewRun     (& origWitRun);
d1272 1
a1272 1
   witNewRun     (& dupWitRun);
d1298 1
a1298 1
   witNewRun              (& theWitRun);
d1327 1
a1327 1
   witNewRun        (& theWitRun);
d1352 1
a1352 1
   witNewRun             (& theWitRun);
d1384 1
a1384 1
   witNewRun         (& theWitRun);
d1413 1
a1413 1
   witNewRun             (& theWitRun);
d1449 1
a1449 1
   witNewRun            (& theWitRun);
d1480 1
a1480 1
   witNewRun          (& origWitRun);
d1487 1
a1487 1
   witNewRun          (& dupWitRun);
d1515 1
a1515 1
   witNewRun             (& theWitRun);
d1572 9
@


1.77
log
@Stochastic Implosion
@
text
@d55 1
d217 3
d223 1
a223 1
         << "ERROR: The argument value must be an integer from 1 to 39."
d1498 34
@


1.76
log
@Stochastic Implosion
@
text
@d1293 1
a1293 1
   witSetStochDataMode      (theWitRun,      WitTRUE);
d1346 1
a1346 1
   witSetStochDataMode     (theWitRun,      WitTRUE);
d1378 1
a1378 1
   witSetStochDataMode (theWitRun, WitTRUE);
d1409 1
a1409 1
   witSetStochDataMode     (theWitRun,           WitTRUE);
d1444 1
a1444 1
   witSetStochDataMode    (theWitRun, WitTRUE);
d1474 1
a1474 1
   witSetStochDataMode  (origWitRun, WitTRUE);
@


1.75
log
@Stochastic Implosion
@
text
@d1341 9
a1349 8
   witNewRun          (& theWitRun);
   witInitialize        (theWitRun);
   witAddPart           (theWitRun, "A", WitMATERIAL);
   witInterpretDevCmd   (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject  (theWitRun, WitTRUE);
   witSetStochDataMode  (theWitRun, WitTRUE);
   witStochImplode      (theWitRun);
   witStochImplode      (theWitRun);
d1402 11
a1412 10
   witNewRun           (& theWitRun);
   witInitialize         (theWitRun);
   witSetNPeriods        (theWitRun, 1);
   witAddPart            (theWitRun, "A", WitMATERIAL);
   witAddDemand          (theWitRun, "A", "B");
   witInterpretDevCmd    (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject   (theWitRun, WitTRUE);
   witSetStochDataMode   (theWitRun, WitTRUE);
   witStochImplode       (theWitRun);
   witSetDemandDemandVol (theWitRun, "A", "B", demandVolB);
@


1.74
log
@Stochastic Implosion.
@
text
@d54 1
d213 3
d219 1
a219 1
         << "ERROR: The argument value must be an integer from 1 to 38."
d1457 35
@


1.73
log
@Stochastic Implosion
@
text
@d53 1
d209 3
d215 1
a215 1
         << "ERROR: The argument value must be an integer from 1 to 37."
d520 3
a522 2
      << "Test of WIT's behavior when witInterpretDevCmd is called with an "
         "invalid command."
d1333 1
a1333 2
      << "Test of witStochImplode when a stochastic implosion solution already "
      << "exists."
d1364 1
a1364 2
      << "Test of witDiscardStochSoln when no stochastic implosion solution "
      << "exists."
d1393 2
a1394 3
      << "Test of witSetDemandDemandVol when a stochastic implosion solution "
      << "exists."
      << std::endl                          
d1420 33
@


1.72
log
@Stochastic Implosion
@
text
@a52 1
void testCase38  ();
a207 3
   else if (theArg == "38")
      testCase38 ();

d211 1
a211 1
         << "ERROR: The argument value must be an integer from 1 to 38."
a1386 30

   std::cout
      << "Test of witSetScenarioIndex when a stochastic implosion solution "
      << "exists."
      << std::endl                          
      << std::endl;

   witNewRun         (& theWitRun);
   witInitialize       (theWitRun);
   witAddPart          (theWitRun, "A", WitMATERIAL);
   witInterpretDevCmd  (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject (theWitRun, WitTRUE);
   witSetStochDataMode (theWitRun, WitTRUE);
   witStochImplode     (theWitRun);
   witSetScenarioIndex (theWitRun, 0);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witSetScenarioIndex."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase38 ()
   {
   WitRun * theWitRun;
@


1.71
log
@Stochastic Implosion
@
text
@d53 1
d209 3
d215 1
a215 1
         << "ERROR: The argument value must be an integer from 1 to 37."
d1418 34
@


1.70
log
@Stochastic Implosion
@
text
@d52 1
d205 3
d211 1
a211 1
         << "ERROR: The argument value must be an integer from 1 to 36."
d1384 30
@


1.69
log
@Stochastic Implosion
@
text
@d1280 1
a1280 1
   witSetStochasticMode     (theWitRun,      WitTRUE);
d1334 1
a1334 1
   witSetStochasticMode (theWitRun, WitTRUE);
d1361 7
a1367 7
   witNewRun          (& theWitRun);
   witInitialize        (theWitRun);
   witAddPart           (theWitRun, "A", WitMATERIAL);
   witInterpretDevCmd   (theWitRun, "Allow stochastic implosion.");
   witSetStageByObject  (theWitRun, WitTRUE);
   witSetStochasticMode (theWitRun, WitTRUE);
   witDiscardStochSoln  (theWitRun);
@


1.68
log
@Stochastic Implosion
@
text
@d50 2
d198 6
d207 1
a207 1
         << "ERROR: The argument value must be an integer from 1 to 34."
d1319 61
@


1.67
log
@Stochastic Implosion
@
text
@d1272 1
a1272 1
   witSetStochImpMode       (theWitRun,      WitTRUE);
@


1.66
log
@Stochastic Implosion
@
text
@d49 1
d193 3
d199 1
a199 1
         << "ERROR: The argument value must be an integer from 1 to 33."
d1262 1
a1262 1
      << "Test of witPurgeData while stochastic implosion is active."
d1286 25
@


1.65
log
@Stochastic Implosion.
@
text
@d1268 1
a1268 1
   witSetStochImpActive     (theWitRun,      WitTRUE);
@


1.64
log
@witCopy<Object>Data
@
text
@d48 1
d189 3
d195 1
a195 1
         << "ERROR: The argument value must be an integer from 1 to 32."
d1253 29
@


1.63
log
@witCopy<Object>Data
@
text
@d43 5
d173 15
d191 1
a191 1
         << "ERROR: The argument value must be an integer from 1 to 27."
d1104 145
@


1.62
log
@witCopy<Object>Data
@
text
@d534 2
a535 2
   WitRun * srcWitRun;
   WitRun * dstWitRun;
d540 1
a540 1
      << "and the API had previously aborted from srcWitRun."
d544 4
a547 4
   witNewRun           (& srcWitRun);
   witInitialize         (srcWitRun);
   witSetMesgStopRunning (srcWitRun, WitFALSE, 521, WitFALSE);
   witAddBomEntry        (srcWitRun, "Opn11",  "Part11");
d549 2
a550 2
   witNewRun           (& dstWitRun);
   witCopyData           (dstWitRun, srcWitRun);
d565 2
a566 2
   WitRun * srcWitRun;
   WitRun * dstWitRun;
d569 1
a569 1
      << "Test of WIT's behavior when an API function is called with srcWitRun "
d571 1
a571 1
      << "and the API had previously aborted from witCopyData."
d575 4
a578 4
   witNewRun           (& srcWitRun);
   witSetMesgStopRunning (srcWitRun, WitFALSE, 74, WitFALSE);
   witInitialize         (srcWitRun); 
   witSetWbounds         (srcWitRun, -1.0);
d580 2
a581 2
   witNewRun           (& dstWitRun); 
   witCopyData           (dstWitRun, srcWitRun);
d583 1
a583 1
   witAddOperation       (srcWitRun, "Opn12");
d598 2
a599 2
   WitRun *      srcWitRun;
   WitRun *      dstWitRun;
d605 1
a605 1
      << "and the API had previously aborted from srcWitRun."
d611 4
a614 4
   witNewRun           (& srcWitRun);
   witInitialize         (srcWitRun);
   witSetMesgStopRunning (srcWitRun, WitFALSE, 521, WitFALSE);
   witAddBomEntry        (srcWitRun, "Opn11", "Part11");
d616 2
a617 2
   witNewRun           (& dstWitRun);
   witSetMesgStopRunning (dstWitRun, WitFALSE, 873, WitFALSE);
d619 1
a619 1
   theRC = witCopyData   (dstWitRun, srcWitRun);
d993 2
a994 2
   WitRun * dstWitRun;
   WitRun * srcWitRun;
d998 1
a998 1
         "ext opt implosion is active for dstWitRun."
d1002 2
a1003 2
   witNewRun    (& srcWitRun);
   witInitialize  (srcWitRun);
d1005 4
a1008 4
   witNewRun    (& dstWitRun);
   witInitialize  (dstWitRun);
   witAddPart     (dstWitRun, "A", WitMATERIAL);
   witStartExtOpt (dstWitRun);
d1010 1
a1010 1
   witCopyData    (dstWitRun, srcWitRun);
d1025 2
a1026 2
   WitRun * srcWitRun;
   WitRun * dstWitRun;
d1030 1
a1030 1
         "ext opt implosion is active for srcWitRun."
d1034 4
a1037 4
   witNewRun    (& srcWitRun);
   witInitialize  (srcWitRun);
   witAddPart     (srcWitRun, "A", WitMATERIAL);
   witStartExtOpt (srcWitRun);
d1039 2
a1040 2
   witNewRun    (& dstWitRun);
   witCopyData    (dstWitRun, srcWitRun);
d1056 2
a1057 2
   WitRun * srcWitRun;
   WitRun * dstWitRun;
d1060 1
a1060 1
      << "Test of WIT's behavior when witCopyData is called and srcWitRun is "
d1066 1
a1066 1
   witNewRun    (& srcWitRun);
d1068 2
a1069 2
   witNewRun    (& dstWitRun);
   witInitialize  (dstWitRun);
d1071 1
a1071 1
   witCopyData    (dstWitRun, srcWitRun);
@


1.61
log
@witCopy<Object>Data
@
text
@d576 1
a580 1
   witSetMesgStopRunning (dstWitRun, WitFALSE, 74, WitFALSE);
@


1.60
log
@witCopy<Object>Data.
@
text
@d14 4
a17 25
void testCase1 ();
   //
   // Tests error handling by termination.

//------------------------------------------------------------------------------

void testCase2 ();
   //
   // Tests error handling by returning with a error code.

//------------------------------------------------------------------------------

void testCase3 ();
   //
   // Tests error handling by returning with a error code, specified by msg
   // level.

//------------------------------------------------------------------------------

void testCase4 ();
   //
   // Tests error handling by throwing an exception.

//------------------------------------------------------------------------------

d19 1
a19 11
   //
   // Does the WIT API calls for case 4.

//------------------------------------------------------------------------------

void testCase5 ();
   //
   // Tests error handling by throwing an exception, specified by msg level.

//------------------------------------------------------------------------------

d21 22
a42 157
   //
   // Does the WIT API calls for the "test exception by level" case.

//------------------------------------------------------------------------------

void testCase6 ();
   //
   // Test of witOptImplode in multiThread mode.

//------------------------------------------------------------------------------

void testCase7 ();
   //
   // Test of WIT's behavior when:
   //    It runs out of memory.
   //    Function return case.

//------------------------------------------------------------------------------

void testCase8 ();
   //
   // Test of WIT's behavior when:
   //    It runs out of memory.
   //    Exception throw case.

//------------------------------------------------------------------------------

void testCase9 ();
   //
   // Test of WIT's behavior when:
   //    witInterpDevCmd is called with an invalid command.

//------------------------------------------------------------------------------

void testCase10 ();
   //
   // Test of WIT's behavior when:
   //    An unknown exception is issued.

//------------------------------------------------------------------------------

void testCase11 ();
   //
   // Test of WIT's behavior when:
   //    witCopyData (dstWitRun, srcWitRun) is called and the API had
   //    previously aborted from srcWitRun.

//------------------------------------------------------------------------------

void testCase12 ();
   //
   // Test of WIT's behavior when:
   //    An API function is called with srcWitRun and the API had previously
   //    aborted from witCopyData (dstWitRun, srcWitRun).

//------------------------------------------------------------------------------

void testCase13 ();
   //
   // Test of WIT's behavior when:
   //    witCopyData (dstWitRun, srcWitRun) is called and the API had previously
   //    aborted from srcWitRun.

//------------------------------------------------------------------------------

void testCase14 ();
   //
   // Test of WIT's behavior when:
   //    witReadData is called and the API had previously aborted from
   //    witReadData.

//------------------------------------------------------------------------------

void testCase15 ();
   //
   // Test of WIT's behavior when:
   //    witExecStandAlone is called and the value of the stopRunning attribute
   //    has been set.

//------------------------------------------------------------------------------

void testCase16 ();
   //
   // Test of WIT's behavior when:
   //    An inappropriate function is called before witInitialize.

//------------------------------------------------------------------------------

void testCase17 ();
   //
   // Test of WIT's behavior when:
   //    An inappropriate function is called while external optimizing implosion
   //    is active.

//------------------------------------------------------------------------------

void testCase18 ();
   //
   // Test of WIT's behavior when:
   //    An inappropriate function is called while external optimizing implosion
   //    is inactive.

//------------------------------------------------------------------------------

void testCase19 ();
   //
   // Test of WIT's behavior when:
   //    A function is called with a NULL WitRun pointer.

//------------------------------------------------------------------------------

void testCase20 ();
   //
   // Test of WIT's behavior when:
   //    A function is called with a deleted WitRun.

//------------------------------------------------------------------------------

void testCase21 ();
   //
   // Test of WIT's behavior when:
   //    intSubVols is TRUE and mipMode is FALSE.

//------------------------------------------------------------------------------

void testCase22 ();
   //
   // Test of WIT's behavior when:
   //    witStartExtOpt is called while accAfterOptImp is TRUE.

//------------------------------------------------------------------------------

void testCase23 ();
   //
   // Test of WIT's behavior when:
   //    witGetPartStockVarIndex is called with an invalid period.

//------------------------------------------------------------------------------

void testCase24 ();
   //
   // Test of WIT's behavior when:
   //    an infeasible solution is passed in through witSetExtOptSolnDbl.

//------------------------------------------------------------------------------

void testCase25 ();
   //
   // Test of WIT's behavior when:
   //    witCopyData is called and ext opt implosion is active for dstWitRun.

//------------------------------------------------------------------------------

void testCase26 ();
   //
   // Test of WIT's behavior when:
   //    witCopyData is called and ext opt implosion is active for srcWitRun.
d165 3
d171 1
a171 1
         << "ERROR: The argument value must be an integer from 1 to 26."
d476 1
a476 1
      << "Test of WIT's behavior when witInterpDevCmd is called with an "
d481 3
a483 3
   witNewRun     (& theWitRun);
   witInitialize   (theWitRun);
   witInterpDevCmd (theWitRun, "This is an invalid command.");
d487 1
a487 1
      << "ERROR: The program should have terminated during witInterpDevCmda."
d516 1
a516 1
      witInterpDevCmd (theWitRun, "Throw an exception of unknown type.");
d538 1
a538 1
      << "Test of WIT's behavior when witCopyData (dstWitRun, srcWitRun) "
d540 1
a540 1
      << "is called and the API had previously aborted from srcWitRun."
d571 1
a571 2
      << "and the API had previously aborted from "
         "witCopyData (dstWitRun, srcWitRun)."
d603 1
a603 1
      << "Test of WIT's behavior when witCopyData (dstWitRun, srcWitRun) "
d605 1
a605 1
      << "is called and the API had previously aborted from srcWitRun."
d1051 31
@


1.59
log
@witCopy<Object>Data.
@
text
@d82 1
a82 1
   //    It issues a fatal error message in exception mode.
a211 7
void testCase27 ();
   //
   // Test of WIT's behavior when:
   //    witInterpDevCmd is called with an invalid command.

//------------------------------------------------------------------------------

a330 3
   else if (theArg == "27")
      testCase27 ();

d334 1
a334 1
         << "ERROR: The argument value must be an integer from 1 to 27."
d639 3
a641 2
      << "Test of WIT's behavior when it issues a fatal message."
      << std::endl                          
d644 3
a646 2
   witNewRun      (& theWitRun);
   witInitialize    (theWitRun);
d648 5
a652 5
   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      875,
      WitTRUE);
d654 1
a654 14
   try
      {
      witInterpDevCmd (theWitRun, "Issue a fatal error message.");
      }

   catch (WitErrorExc & theErrorExc)
      {
      handleErrorExc (theErrorExc);
      }

   catch (...)
      {
      handleUnknownExc ();
      }
d679 1
a679 1
      witThrowUnknownExc (theWitRun);
a1216 25
void testCase27 ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of WIT's behavior when witInterpDevCmd is called with an "
         "invalid command."
      << std::endl
      << std::endl;

   witNewRun     (& theWitRun);
   witInitialize   (theWitRun);
   witInterpDevCmd (theWitRun, "This is an invalid command.");

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witInterpDevCmda."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

@


1.58
log
@External opt implosion.
@
text
@d65 3
a67 2
   // Test of WIT's behavior when it runs out of memory.
   // Function return case.
d73 3
a75 2
   // Test of WIT's behavior when it runs out of memory.
   // Exception throw case.
d81 2
a82 2
   // Test of WIT's behavior when it issues a fatal error message in exception
   // mode.
d88 2
a89 1
   // Test of WIT's response to an unknown exception.
d95 3
a97 2
   // Test of WIT's behavior when witCopyData (dstWitRun, srcWitRun) is called
   // and the API had previously aborted from srcWitRun.
d103 3
a105 3
   // Test of WIT's behavior when an API function is called with srcWitRun
   // and the API had previously aborted from
   // witCopyData (dstWitRun, srcWitRun).
d111 3
a113 3
   // Test of WIT's behavior when witCopyData (dstWitRun, srcWitRun) is called
   // and the API had previously aborted from srcWitRun.
   // Function return case.
d119 3
a121 2
   // Test of WIT's behavior when witReadData is called and the API had
   // previously aborted from witReadData.
d127 3
a129 2
   // Test of WIT's behavior when witExecStandAlone is called and the value of
   // the stopRunning attribute has been set.
d135 2
a136 2
   // Test of WIT's behavior when an inappropriate function is called before
   // witInitialize.
d142 3
a144 2
   // Test of WIT's behavior when an inappropriate function is called while opt
   // external optimizing implosion is active.
d150 3
a152 2
   // Test of WIT's behavior when an inappropriate function is called while
   // external optimizing implosion is inactive.
d158 2
a159 2
   // Test of WIT's behavior when a function is called with a NULL WitRun
   // pointer.
d165 2
a166 1
   // Test of WIT's behavior when a function is called with a deleted WitRun.
d172 2
a173 1
   // Test of WIT's behavior when intSubVols is TRUE and mipMode is FALSE.
d179 2
a180 2
   // Test of WIT's behavior when witStartExtOpt is called while accAfterOptImp
   // is TRUE.
d186 2
a187 2
   // Test of WIT's behavior when witGetPartStockVarIndex is called with an
   // invalid period.
d193 2
a194 2
   // Test of WIT's behavior when an infeasible solution is passed in through
   // witSetExtOptSolnDbl.
d200 2
a201 2
   // Test of WIT's behavior when witCopyData is called and ext opt implosion
   // is active for dstWitRun.
d207 9
a215 2
   // Test of WIT's behavior when witCopyData is called and ext opt implosion
   // is active for srcWitRun.
d338 3
d344 1
a344 1
         << "ERROR: The argument value must be an integer from 1 to 26."
d664 1
a664 1
      witTestFatalMesg (theWitRun);
d1238 25
d1267 1
a1267 1
      << "WIT has thrown a WitErrorExc."
@


1.57
log
@Added a test for entering an infeasible solution through witSetExtOptSolhDbl.
@
text
@d188 14
d315 6
d324 1
a324 1
         << "ERROR: The argument value must be an integer from 1 to 24."
d1156 62
@


1.56
log
@External opt implosion.
@
text
@d181 7
d298 3
d304 1
a304 1
         << "ERROR: The argument value must be an integer from 1 to 23."
d1068 68
@


1.55
log
@External Optimizing Implosion
@
text
@d163 1
a163 2
   // Test of WIT's behavior when witStartExtOpt is called while accAfterOptImp
   // is TRUE.
d169 2
a170 2
   // Test of WIT's behavior when witGetPartStockVarIndex is called with an
   // invalid period.
d176 2
a177 1
   // Test of WIT's behavior when intSubVols is TRUE and mipMode is FALSE.
d975 1
a975 3
      << "Test of WIT's behavior when witStartExtOpt is called while "
         "accAfterOptImp\n"
         "is TRUE."
d979 10
a988 4
   witNewRun          (& theWitRun);
   witInitialize        (theWitRun);
   witSetAccAfterOptImp (theWitRun, WitTRUE);
   witStartExtOpt       (theWitRun);
d992 1
a992 1
      << "ERROR: The program should have terminated during witStartExtOpt."
a1003 1
   int      stockVarIndex;
d1006 3
a1008 3
      << "Test of WIT's behavior when witGetPartStockVarIndex is called with "
         "an invalid\n"
         "period."
d1012 4
a1015 5
   witNewRun             (& theWitRun);
   witInitialize           (theWitRun);
   witAddPart              (theWitRun, "A", WitMATERIAL);
   witStartExtOpt          (theWitRun);
   witGetPartStockVarIndex (theWitRun, "A", 30, & stockVarIndex);
d1019 1
a1019 2
      << "ERROR: The program should have terminated during "
         "witGetPartStockVarIndex."
d1031 1
d1034 3
a1036 1
      << "Test of WIT's behavior when intSubVols is TRUE and mipMode is FALSE."
d1040 5
a1044 10
   witNewRun                  (& theWitRun);
   witInitialize                (theWitRun);

   witAddPart                   (theWitRun, "A", WitCAPACITY);
   witAddOperation              (theWitRun, "B");
   witAddBomEntry               (theWitRun, "B", "A");
   witAddSubsBomEntry           (theWitRun, "B",  0, "A");
   witSetSubsBomEntryIntSubVols (theWitRun, "B",  0,  0, WitTRUE);

   witOptImplode                (theWitRun);
d1048 2
a1049 1
      << "ERROR: The program should have terminated during witOptImplode."
@


1.54
log
@external opt implosion.
@
text
@d137 1
a137 1
   // implosion is active.
d143 2
a144 2
   // Test of WIT's behavior when an inappropriate function is called while opt
   // implosion is inactive.
d876 1
a876 1
      << "opt implosion is active."
d904 1
a904 1
      << "opt implosion is inactive."
d914 1
a914 1
      << "ERROR: The program should have terminated during witSolveOptProblem."
@


1.53
log
@External opt implosion.
@
text
@d177 1
a177 1
   // Test of WIT's behavior when intSubVols is TRUE and allowIntCons is FALSE.
d1032 1
a1032 2
      << "Test of WIT's behavior when intSubVols is TRUE "
         "and allowIntCons is FALSE."
@


1.52
log
@External opt implosion.
@
text
@d175 6
d288 3
d294 1
a294 1
         << "ERROR: The argument value must be an integer from 1 to 22."
d1027 32
@


1.51
log
@External opt implosion.
@
text
@d991 1
a991 1
   int      colIndex;
d1004 1
a1004 1
   witGetPartStockVarIndex (theWitRun, "A", 30, & colIndex);
@


1.50
log
@External opt implosion.
@
text
@d168 7
d279 3
d285 1
a285 1
         << "ERROR: The argument value must be an integer from 1 to 21."
d988 30
@


1.49
log
@External opt implosion.
@
text
@d163 1
a163 1
   // Test of WIT's behavior when witStartAsstOpt is called while accAfterOptImp
d864 1
a864 1
   witStartAsstOpt (theWitRun);
d889 3
a891 3
   witNewRun      (& theWitRun);
   witInitialize    (theWitRun);
   witFinishAsstOpt (theWitRun);
d956 1
a956 1
      << "Test of WIT's behavior when witStartAsstOpt is called while "
d965 1
a965 1
   witStartAsstOpt      (theWitRun);
d969 1
a969 1
      << "ERROR: The program should have terminated during witStartAsstOpt."
@


1.48
log
@Assisted opt implosion.
@
text
@d889 3
a891 3
   witNewRun        (& theWitRun);
   witInitialize      (theWitRun);
   witSolveOptProblem (theWitRun);
@


1.47
log
@Assisted opt implosion.
@
text
@d161 7
d269 3
d275 1
a275 1
         << "ERROR: The argument value must be an integer from 1 to 19."
d951 27
@


1.46
log
@Custom opt implosion.
@
text
@d851 5
a855 5
   witNewRun        (& theWitRun);
   witInitialize      (theWitRun);
   witAddPart         (theWitRun, "A", WitMATERIAL);
   witStartCustOptImp (theWitRun);
   witAddOperation    (theWitRun, "B");
@


1.45
log
@Added tests for calls with NULL WitRun pointer and deleted WitRun.
@
text
@d851 5
a855 5
   witNewRun     (& theWitRun);
   witInitialize   (theWitRun);
   witAddPart      (theWitRun, "A", WitMATERIAL);
   witStartOptImp  (theWitRun);
   witAddOperation (theWitRun, "B");
@


1.44
log
@Removed test for a call to witOptImplode after a previous abort from
witOptImplode.
@
text
@d137 1
a137 1
   // implosion is inactive.
d144 14
a157 1
   // implosion is active.
d256 6
d265 1
a265 1
         << "ERROR: The argument value must be an integer from 1 to 18."
d847 28
d894 22
a915 1
void testCase18 ()
d920 3
a922 4
      << "Test of WIT's behavior when an inappropriate function is called while"
      << std::endl                          
      << "opt implosion is active."
      << std::endl                          
d927 2
a928 3
   witAddPart      (theWitRun, "A", WitMATERIAL);
   witStartOptImp  (theWitRun);
   witAddOperation (theWitRun, "B");
@


1.43
log
@App controlled opt implosion.
@
text
@a121 7
   // Test of WIT's behavior when witOptOmplode is called and the API had
   // previously aborted from witOptOmplode.

//------------------------------------------------------------------------------

void testCase16 ();
   //
d127 1
a127 1
void testCase17 ();
d134 1
a134 1
void testCase18 ();
d141 1
a141 1
void testCase19 ();
a242 3
   else if (theArg == "19")
      testCase19 ();

d246 1
a246 1
         << "ERROR: The argument value must be an integer from 1 to 19."
a762 44
   WitRun *      theWitRunA;
   WitRun *      theWitRunB;
   witReturnCode theRC;

   std::cout
      << "Test of WIT's behavior when witOptImplode is called "
      << std::endl                          
      << "and the API had previously aborted from witOptImplode."
      << std::endl                          
      << std::endl;

   witNewRun           (& theWitRunA);
   witInitialize         (theWitRunA);
   witSetMesgStopRunning (theWitRunA, WitFALSE, 262, WitFALSE);

   theRC = witOptImplode (theWitRunA);

   std::cout
      << std::endl                          
      << "The return code for the call to witOptImplode was "
      << theRC
      << "."
      << std::endl                          
      << std::endl;


   witNewRun           (& theWitRunB);
   witInitialize         (theWitRunB);
   witReadData           (theWitRunB, "data/diner.data");
   witOptImplode         (theWitRunB);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witOptImplode."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

void testCase16 ()
   {
d795 1
a795 1
void testCase17 ()
d821 1
a821 1
void testCase18 ()
d847 1
a847 1
void testCase19 ()
@


1.42
log
@App controlled opt implosion.
@
text
@d144 7
d250 3
d256 1
a256 1
         << "ERROR: The argument value must be an integer from 1 to 18."
d882 26
@


1.41
log
@App controlled opt implosion.
@
text
@d876 5
a880 4
   witNewRun        (& theWitRun);
   witInitialize      (theWitRun);
   witSetOptImpActive (theWitRun, WitTRUE);
   witAddOperation    (theWitRun, "A");
@


1.40
log
@App controlled opt implosion.
@
text
@d272 2
a273 4
   witNewRun (& theWitRun);

   witInitialize (theWitRun);

d392 1
a392 2
   witInitialize (theWitRun);

d394 1
a394 2

   witDeleteRun (theWitRun);
d440 1
a440 2
   witInitialize (theWitRun);

d442 1
a442 2

   witDeleteRun (theWitRun);
a456 1

a457 1

a458 1

a459 1

a460 1

a486 1

a519 1

a555 1

a591 1

a630 1

a631 1

d633 1
a633 2

   witAddBomEntry        (srcWitRun, "Opn11", "Part11");
a635 1

a662 1

a663 1
                                      
a666 1
                                      
a667 1

a698 1

a699 1

a700 1

a703 1

a732 1

a733 1

a746 1

a747 1

a774 1

a775 1

a789 1

a790 1

a791 1

a821 1

a822 1

a825 1

d876 4
a879 8
   witNewRun          (& theWitRun);

   witInitialize        (theWitRun);

   witSetMesgTimesPrint (theWitRun, WitFALSE, 602, 103);
   witSetMesgTimesPrint (theWitRun, WitFALSE, 602, 104);

   witAddOperation      (theWitRun, "A");
@


1.39
log
@Added a test for calling the wrong function before witInitialize.
@
text
@d141 7
d240 3
d246 1
a246 1
         << "ERROR: The argument value must be an integer from 1 to 17."
d904 31
@


1.38
log
@Reinstsated code to test catching of unknown exceptions.
@
text
@d134 7
d230 3
d236 1
a236 1
         << "ERROR: The argument value must be an integer from 1 to 16."
d868 26
@


1.37
log
@Updated unknown exception test.
@
text
@d589 6
d607 1
a607 7
      std::cout
         << std::endl                          
         << "WIT has correctly thrown an exception of unknown type."
         << std::endl                          
         << std::endl;

      exit (0);
@


1.36
log
@Case 5 now catches the WitErrorExc by value.
@
text
@a588 6
   witSetMesgThrowErrorExc (
      theWitRun,
      WitFALSE,
      849,
      WitTRUE);

d601 7
a607 1
      handleUnknownExc ();
@


1.35
log
@[error recovery]
@
text
@d390 2
d399 1
a399 1
   catch (WitErrorExc & theErrorExc)
@


1.34
log
@[error recovery]
@
text
@a297 10

   theRC = witSetNPeriods (theWitRun, 2);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witSetNPeriods."
      << std::endl                          
      << std::endl;

   exit (1);
d304 1
a304 2
   WitRun *      theWitRunA;
   WitRun *      theWitRunB;
d314 1
a314 1
   witNewRun (& theWitRunA);
d317 1
a317 1
      theWitRunA,
d322 1
a322 1
   witInitialize (theWitRunA);
d324 1
a324 1
   theRC = witAddBomEntry (theWitRunA, "Opn3", "Part3");
a332 10

   theRC = witNewRun (& theWitRunB);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witNewRun."
      << std::endl                          
      << std::endl;

   exit (1);
a626 2
   witSetErrorRecovery   (srcWitRun);

a662 2
   witSetErrorRecovery   (srcWitRun);

a702 2
   witSetErrorRecovery   (srcWitRun);

a740 2
   witSetErrorRecovery   (theWitRunA);

a786 2
   witSetErrorRecovery   (theWitRunA);

@


1.33
log
@Minor update.
@
text
@d127 7
d220 3
d226 1
a226 1
         << "ERROR: The argument value must be an integer from 1 to 15."
d850 37
@


1.32
log
@[error recovery]
@
text
@d762 1
a762 1
   theRC = witReadData   (theWitRunA, "errTest.C");
@


1.31
log
@Added catching of unknown exceptions.
@
text
@d120 7
d210 3
d216 1
a216 1
         << "ERROR: The argument value must be an integer from 1 to 14."
d760 1
a760 1
   witSetMesgStopRunning (theWitRunA, WitFALSE, 75, WitFALSE);
d762 1
a762 1
   theRC = witReadData   (theWitRunA, "no-file.data");
d789 51
@


1.30
log
@Experiment for MS trouble with WitErrorExc.
@
text
@d120 1
a120 1
void handleExc (WitErrorExc & theErrorExc);
d126 6
d352 1
a352 1
      handleExc (theErrorExc);
d357 1
a357 7
      std::cout
         << std::endl                          
         << "ERROR: WIT has thrown an exception of unknown type."
         << std::endl                          
         << std::endl;

      exit (1);
d400 6
a405 1
      handleExc (theErrorExc);
d527 6
a532 1
      handleExc (theErrorExc);
d564 6
a569 1
      handleExc (theErrorExc);
d601 6
a606 1
      handleExc (theErrorExc);
d779 1
a779 1
void handleExc (WitErrorExc & theErrorExc)
d799 13
@


1.29
log
@Experiment for WitErrorExc trouble with MS complier.
@
text
@a348 21
   catch (WitTempExc & theTempExc)
      {
      std::cout
         << std::endl                          
         << "WIT has thrown a WitTempExc."
         << std::endl                          
         << "The API function was "
         << theTempExc.funcName ()
         << "."
         << std::endl                          
         << "The message number was "
         << theTempExc.mesgNum ()
         << "."
         << std::endl                          
         << "The return code was "
         << theTempExc.retCode ()
         << "."
         << std::endl                          
         << std::endl;
      }

@


1.28
log
@Minor change.
@
text
@d349 21
@


1.27
log
@Experiment.
@
text
@d353 1
a353 1
         << "WIT has thrown an exception of unknown type."
d356 2
@


1.26
log
@[error recovery]
@
text
@d348 9
@


1.25
log
@Minor update.
@
text
@d113 7
d194 3
d200 1
a200 1
         << "ERROR: The argument value must be an integer from 1 to 13."
d700 48
@


1.24
log
@Added case 13.
@
text
@a626 2
   witSetMesgStopRunning (srcWitRun, WitFALSE, 74, WitFALSE);

d631 2
@


1.23
log
@Minor updates.
@
text
@d105 8
d184 3
d190 1
a190 1
         << "ERROR: The argument value must be an integer from 1 to 12."
d648 42
@


1.22
log
@Minor update.
@
text
@d14 1
a14 1
void testTerminate ();
d20 1
a20 1
void testReturn ();
d26 1
a26 1
void testReturnByLevel ();
d33 1
a33 1
void testException ();
d39 1
a39 1
void doWitCalls ();
d41 1
a41 1
   // Does the WIT API calls for the "test exception" case.
d45 1
a45 1
void testExcByLevel ();
d51 1
a51 1
void doWitCallsByLevel ();
d57 1
a57 1
void testOptImplode ();
d63 1
a63 1
void testMemoryReturn ();
d70 1
a70 1
void testMemoryExc ();
d77 1
a77 1
void testFatal ();
d84 1
a84 1
void testUnknownExc ();
d90 1
a90 1
void testPostErrCopyData ();
d97 1
a97 1
void testPostCopyDataErrCall ();
d140 2
a141 2
   if      (theArg == "A")
      testTerminate ();
d143 2
a144 2
   else if (theArg == "B")
      testReturn ();
d146 2
a147 2
   else if (theArg == "C")
      testReturnByLevel ();
d149 2
a150 2
   else if (theArg == "D")
      testException ();
d152 2
a153 2
   else if (theArg == "E")
      testExcByLevel ();
d155 2
a156 2
   else if (theArg == "F")
      testOptImplode ();
d158 2
a159 2
   else if (theArg == "G")
      testMemoryReturn ();
d161 2
a162 2
   else if (theArg == "H")
      testMemoryExc ();
d164 2
a165 2
   else if (theArg == "I")
      testFatal ();
d167 2
a168 2
   else if (theArg == "J")
      testUnknownExc ();
d170 2
a171 2
   else if (theArg == "K")
      testPostErrCopyData ();
d173 2
a174 2
   else if (theArg == "L")
      testPostCopyDataErrCall ();
d179 1
a179 2
         << "ERROR: The argument value must be one of the following letters: "
            "\"ABCDEFGHIJK\"."
d196 1
a196 1
void testTerminate ()
d209 1
a209 1
   witAddBomEntry (theWitRun, "Opn-A", "Part-A");
d222 1
a222 1
void testReturn ()
d242 1
a242 1
   theRC = witAddBomEntry (theWitRun, "Opn-B", "Part-B");
d265 1
a265 1
void testReturnByLevel ()
d267 2
a268 2
   WitRun *      theWitRun;
   WitRun *      theWitRun2;
d278 1
a278 1
   witNewRun (& theWitRun);
d281 1
a281 1
      theWitRun,
d286 1
a286 1
   witInitialize (theWitRun);
d288 1
a288 1
   theRC = witAddBomEntry (theWitRun, "Opn-C", "Part-C");
d298 1
a298 1
   theRC = witNewRun (& theWitRun2);
d311 1
a311 1
void testException ()
d320 1
a320 1
      doWitCalls ();
d331 1
a331 1
void doWitCalls ()
d345 1
a345 1
   witAddBomEntry (theWitRun, "Opn-D", "Part-D");
d352 1
a352 1
void testExcByLevel ()
d363 1
a363 1
      doWitCallsByLevel ();
d374 1
a374 1
void doWitCallsByLevel ()
d388 1
a388 1
   witAddBomEntry (theWitRun, "Opn-E", "Part-E");
d395 1
a395 1
void testOptImplode ()
d427 1
a427 1
void testMemoryReturn ()
d462 1
a462 1
void testMemoryExc ()
d496 1
a496 1
void testFatal ()
d528 1
a528 1
void testUnknownExc ()
d560 1
a560 1
void testPostErrCopyData ()
d580 1
a580 1
   witAddBomEntry        (srcWitRun, "Opn-K", "Part-K");
d597 1
a597 1
void testPostCopyDataErrCall ()
d624 1
a624 1
   witAddOperation       (srcWitRun, "Opn-L");
@


1.21
log
@[error recovery]
@
text
@d513 1
a513 1
      283,
d526 1
@


1.20
log
@[error recovery]
@
text
@d92 1
a92 1
   // Test of WIT's behavior when witCopyData (..., srcWitRun) is called
d100 2
a101 1
   // and the API had previously aborted from witCopyData (..., srcWitRun).
d566 1
a566 1
      << "Test of WIT's behavior when witCopyData (..., srcWitRun) is called "
d568 1
a568 1
      << "and the API had previously aborted from srcWitRun."
d605 2
a606 1
      << "and the API had previously aborted from witCopyData (..., srcWitRun)."
@


1.19
log
@[multi-thread]
@
text
@d90 14
d169 6
d179 1
a179 1
            "\"ABCDEFGHIJ\"."
d268 1
d297 10
d559 76
@


1.18
log
@[multi-thread]
@
text
@a62 6
void testReadData ();
   //
   // Test of witReadData in multiThread mode.

//------------------------------------------------------------------------------

d144 1
a144 1
      testReadData ();
d147 1
a147 1
      testMemoryReturn ();
d150 1
a150 1
      testMemoryExc ();
a152 3
      testFatal ();

   else if (theArg == "K")
d159 1
a159 1
            "\"ABCDEFGHIJK\"."
a395 29
void testReadData ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witReadData in multiThread mode."
      << std::endl                          
      << std::endl;

   witNewRun       (& theWitRun);

   witInitialize     (theWitRun);

   witSetMultiThread (theWitRun, WitTRUE);

   witReadData       (theWitRun,
      "/home/rjw/main/wit/data/brenda/denise/wit.data");

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witReadData."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

@


1.17
log
@[multi-thread]
@
text
@a56 6
void testCopyData ();
   //
   // Test of witCopyData in multiThread mode.

//------------------------------------------------------------------------------

d147 1
a147 1
      testCopyData ();
d150 1
a150 1
      testOptImplode ();
d153 1
a153 1
      testReadData ();
d156 1
a156 1
      testMemoryReturn ();
d159 1
a159 1
      testMemoryExc ();
a161 3
      testFatal ();

   else if (theArg == "L")
d168 1
a168 1
            "\"ABCDEFGHIJKL\"."
a372 28
void testCopyData ()
   {
   WitRun * theWitRun;

   std::cout
      << "Test of witCopyData in multiThread mode."
      << std::endl                          
      << std::endl;

   witNewRun       (& theWitRun);

   witInitialize     (theWitRun);

   witSetMultiThread (theWitRun, WitTRUE);

   witCopyData       (theWitRun, theWitRun);

   std::cerr
      << std::endl                          
      << "ERROR: The program should have terminated during witCopyData."
      << std::endl                          
      << std::endl;

   exit (1);
   }

//------------------------------------------------------------------------------

@


1.16
log
@Test code for WIT's new exception throwing capability.
@
text
@d395 1
a395 1
   witSetMultiThread (theWitRun);
d423 1
a423 1
   witSetMultiThread       (theWitRun);
d455 1
a455 1
   witSetMultiThread (theWitRun);
@


1.15
log
@[multi-thread]
@
text
@d89 19
d167 6
d177 1
a177 1
            "\"ABCDEFGHIJ\"."
d310 1
a310 1
   catch (WitException theExc)
d312 1
a312 17
      std::cout
         << std::endl                          
         << "WIT has thrown an exception."
         << std::endl                          
         << "The API function was "
         << theExc.funcName
         << "."
         << std::endl                          
         << "The message number was "
         << theExc.mesgNum
         << "."
         << std::endl                          
         << "The return code was "
         << theExc.retCode
         << "."
         << std::endl                          
         << std::endl;
d324 1
a324 1
   witSetMesgThrowException (
d353 1
a353 1
   catch (WitException theExc)
d355 1
a355 17
      std::cout
         << std::endl                          
         << "WIT has thrown an exception."
         << std::endl                          
         << "The API function was "
         << theExc.funcName
         << "."
         << std::endl                          
         << "The message number was "
         << theExc.mesgNum
         << "."
         << std::endl                          
         << "The return code was "
         << theExc.retCode
         << "."
         << std::endl                          
         << std::endl;
d367 1
a367 1
   witSetMesgThrowException (
d521 1
a521 1
   witSetMesgThrowException (
d532 59
a590 1
   catch (WitException theExc)
d592 6
a597 17
      std::cout
         << std::endl                          
         << "WIT has thrown an exception."
         << std::endl                          
         << "The API function was "
         << theExc.funcName
         << "."
         << std::endl                          
         << "The message number was "
         << theExc.mesgNum
         << "."
         << std::endl                          
         << "The return code was "
         << theExc.retCode
         << "."
         << std::endl                          
         << std::endl;
d600 23
@


1.14
log
@[thread-test]
@
text
@d497 1
a497 1
      870,
d531 1
a531 1
      870,
@


1.13
log
@[multi-thread]
@
text
@d75 14
d142 6
d151 2
a152 2
         << "ERROR: The argument value must be "
            "\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", or \"H\"."
d476 84
@


1.12
log
@[multi-thread]
@
text
@d57 1
a57 1
void testWitCopyData ();
d63 1
a63 1
void testWitOptImplode ();
d69 6
d120 1
a120 1
      testWitCopyData ();
d123 4
a126 1
      testWitOptImplode ();
d132 1
a132 1
            "\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", or \"G\"."
d369 1
a369 1
void testWitCopyData ()
d397 1
a397 1
void testWitOptImplode ()
d426 30
@


1.11
log
@[multi-thread]
@
text
@d63 6
d116 3
d123 1
a123 1
            "\"A\", \"B\", \"C\", \"D\", \"E\", or \"F\"."
d385 32
@


1.10
log
@[exceptions]
@
text
@d57 6
d107 3
d114 1
a114 1
            "\"A\", \"B\", \"C\", \"D\", or \"E\"."
d348 28
@


1.9
log
@[exceptions]
@
text
@d253 1
a253 1
         << theExc.myReturnCode
d312 1
a312 1
         << theExc.myReturnCode
@


1.8
log
@Test code for [exceptions].
@
text
@d238 1
a238 1
   catch (witException theExc)
d297 1
a297 1
   catch (witException theExc)
@


1.7
log
@Test code for [exceptions].
@
text
@d242 1
a242 1
         << "An error exception from WIT has been caught."
d245 5
a249 1
         << theExc.functionName_
d253 1
a253 1
         << theExc.myReturnCode_
d301 1
a301 1
         << "An error exception from WIT has been caught."
d304 5
a308 1
         << theExc.functionName_
d312 1
a312 1
         << theExc.myReturnCode_
@


1.6
log
@Test code for [exceptions].
@
text
@d238 1
a238 1
   catch (witErrorExc theErrorExc)
d245 1
a245 1
         << theErrorExc.functionName_
d249 1
a249 1
         << theErrorExc.myReturnCode_
d293 1
a293 1
   catch (witErrorExc theErrorExc)
d300 1
a300 1
         << theErrorExc.functionName_
d304 1
a304 1
         << theErrorExc.myReturnCode_
@


1.5
log
@Test code for [exceptions].
@
text
@d26 7
d86 1
a86 1
   if (theArg == "A")
d93 3
d98 1
a98 1
   else if (theArg == "D")
d104 2
a105 1
         << "ERROR: The argument value must be \"A\", \"B\", or \"C\"."
d163 1
a163 1
      WitSEVERE_MESSAGES,
d180 35
d217 1
a217 1
      << "The return code for the call to witSetNPeriods was "
d272 1
a272 1
   witAddBomEntry (theWitRun, "Opn-C", "Part-C");
d327 1
a327 1
   witAddBomEntry (theWitRun, "Opn-D", "Part-D");
@


1.4
log
@Test code for [exceptions]
@
text
@d38 12
d88 3
d124 1
a124 1
   witAddBomEntry (theWitRun, "Z", "Y");
d157 1
a157 1
   theRC = witAddBomEntry (theWitRun, "Z", "Y");
d218 56
a273 1
   witSetThrowExcOnError (
d276 1
d281 1
a281 1
   witAddBomEntry (theWitRun, "Z", "Y");
@


1.3
log
@Test code for [exceptions].
@
text
@d183 4
d203 1
a203 1
   witSetThrowOnErrors (
a207 12
   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      WitSEVERE_MESSAGES,
      WitFALSE);

   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      WitFATAL_MESSAGES,
      WitFALSE);

@


1.2
log
@Minor change.
@
text
@d26 12
a41 6
   std::cout
      << std::endl
      << "----- errTest -----"
      << std::endl
      << std::endl;

d55 4
a58 1
      << "Argument value: \""
d60 4
a63 1
      << "\""
d73 3
d79 1
a79 1
         << "ERROR: The argument value must be \"A\" or \"B\"."
d101 1
a101 1
      << "Testing error handling by program termination."
d128 1
a128 1
      << "Testing error handling by returning with an error code."
a139 6
   witSetMesgStopRunning (
      theWitRun,
      WitFALSE,
      WitFATAL_MESSAGES,
      WitFALSE);

d142 1
a142 1
   theRC = witAddBomEntry (theWitRun, "A", "B");
d144 7
a150 9
   if (theRC != WitSEVERE_RC)
      {
      std::cerr
         << std::endl                          
         << "ERROR: An incorrect return code of "
         << theRC
         << " was returned for the first error."
         << std::endl                          
         << std::endl;
d152 1
a152 2
      exit (1);
      }
d156 1
a156 1
      << "The correct return code of "
d158 11
a168 1
      << " was returned for the first error."
d172 4
a175 1
   theRC = witSetNPeriods (theWitRun, 2);
d177 1
a177 1
   if (theRC != WitSEVERE_RC)
d179 3
a181 1
      std::cerr
d183 3
a185 3
         << "ERROR: An incorrect return code of "
         << theRC
         << " was returned for the second error."
d188 27
d216 3
a218 2
      exit (1);
      }
d220 1
a220 7
   std::cout
      << std::endl                          
      << "The correct return code of "
      << theRC
      << " was returned for the second error."
      << std::endl                          
      << std::endl;
@


1.1
log
@Adding errTest, a WIT application program whose purpose is to test WIT's
handling of errors.
@
text
@d55 1
a55 1
   if (theArg == "a")
d58 1
a58 1
   else if (theArg == "b")
d64 1
a64 1
         << "ERROR: The argument value must be \"a\" or \"b\"."
d94 1
a94 1
   witAddBomEntry (theWitRun, "A", "B");
@


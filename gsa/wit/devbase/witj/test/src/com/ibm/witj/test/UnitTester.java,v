head	1.183;
access;
symbols;
locks; strict;
comment	@# @;


1.183
date	2011.08.25.23.21.05;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2011.06.27.15.01.21;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2011.06.08.17.28.45;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2011.06.03.15.13.43;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2011.06.02.18.07.21;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2011.06.02.16.02.14;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2011.06.01.23.36.55;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2011.06.01.23.05.06;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2011.05.04.22.15.56;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2011.05.02.18.32.45;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2011.04.22.20.00.44;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2011.04.08.20.56.51;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2011.04.07.22.11.33;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2011.04.07.21.39.39;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2011.04.07.19.07.50;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2011.04.06.23.29.40;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2011.04.06.21.56.59;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2011.04.06.20.34.47;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2011.03.31.17.35.56;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2011.03.30.23.23.20;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2011.03.28.15.57.28;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2011.03.22.22.24.26;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2011.03.19.00.26.31;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2011.03.12.00.32.11;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2011.03.11.23.49.53;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2011.03.03.22.10.15;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2011.02.25.16.07.26;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2011.02.16.21.38.37;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2011.02.16.21.03.29;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2011.02.16.19.56.06;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2011.02.16.17.35.00;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2011.02.14.19.59.28;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2011.02.11.17.07.09;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2010.10.14.20.04.11;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2010.10.01.14.47.19;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2010.08.13.22.38.24;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2010.08.06.17.50.39;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2010.04.26.22.06.22;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2010.04.26.21.09.30;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2010.04.26.20.04.58;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2010.04.26.19.32.48;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2010.04.26.18.45.59;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2010.04.23.22.41.24;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2010.04.15.21.33.57;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2010.04.14.15.42.17;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2010.04.13.23.10.44;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2010.04.12.22.28.18;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2010.04.12.20.22.32;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2010.04.12.19.30.30;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2010.04.05.22.49.46;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.04.05.21.31.02;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2009.10.28.21.47.37;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2009.10.08.19.19.00;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2009.10.01.20.10.04;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2009.10.01.15.59.55;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2009.09.30.22.47.15;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2009.09.25.20.19.34;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2009.08.06.14.40.10;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2009.08.05.21.17.55;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.05.18.54.36;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2009.08.04.23.09.46;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2009.08.01.00.04.56;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2009.07.31.21.57.36;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2009.07.31.20.09.22;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.30.21.05.30;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2009.06.29.19.56.33;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2009.06.17.20.27.58;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2009.06.16.21.50.33;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.16.18.04.01;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.15.15.54.13;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.10.14.38.45;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.09.18.52.52;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.09.16.10.57;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.05.17.55.45;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.03.19.51.25;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2009.06.03.18.25.57;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.02.21.57.31;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.29.23.42.02;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2009.05.29.17.59.40;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2009.05.26.20.07.12;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2009.05.26.18.31.45;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.21.22.29.20;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.21.20.07.03;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.21.20.05.50;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2009.05.20.18.47.33;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2009.05.08.22.13.14;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2009.05.05.19.18.40;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2009.04.24.17.42.53;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2009.04.21.20.56.08;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.04.20.18.00.04;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.04.20.16.09.14;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.04.17.19.52.00;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.04.16.21.08.40;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.04.10.21.18.20;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2009.04.10.20.21.34;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.08.21.02.40;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2009.04.07.22.13.31;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2009.04.03.23.12.05;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.03.22.33.52;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2009.04.02.14.57.42;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.30.20.19.56;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.25.14.44.28;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.23.21.51.41;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.20.19.47.01;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.20.16.08.11;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.19.22.30.32;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2009.03.19.20.45.28;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.16.20.05.00;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2009.03.16.19.35.46;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.13.22.31.00;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.13.21.09.00;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.13.19.32.24;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.13.16.36.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.12.22.45.22;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.12.19.02.43;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.05.23.02.44;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2009.02.25.23.06.45;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.25.22.26.08;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.25.22.13.54;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.25.18.30.40;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.24.23.49.21;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.24.22.45.08;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.24.22.18.46;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.20.17.18.46;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.19.19.51.48;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.19.17.39.22;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.17.20.18.43;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.14.00.51.32;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2009.02.11.18.59.30;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.02.09.22.50.21;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.06.23.27.13;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.06.22.41.00;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.04.21.51.55;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.04.20.16.01;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.04.17.06.05;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.03.21.31.11;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.12.17.24.15;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.08.22.00.10;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.07.18.21.29;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.06.23.46.00;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.06.22.09.42;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.22.21.27.18;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.18.22.00.09;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.18.20.39.35;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.18.19.48.27;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.16.23.43.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.16.16.13.32;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.11.22.21.53;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.09.22.58.43;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.09.19.09.06;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.08.23.15.50;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.03.18.28.50;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.26.20.11.00;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.25.15.28.49;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.21.15.29.02;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.20.22.07.23;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.20.20.05.51;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.20.19.27.13;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.14.22.52.53;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.14.21.47.42;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.14.20.37.43;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.12.20.40.33;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.08.00.20.29;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.08.00.06.28;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.07.21.41.10;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.07.21.32.18;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.07.21.26.00;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.07.20.52.31;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.06.23.29.45;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.05.23.14.57;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.05.19.25.34;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.05.16.52.14;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.04.23.08.00;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.04.22.22.25;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.31.14.53.30;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.29.20.27.20;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.22.13.43.31;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.15.17.31.00;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.14.22.04.39;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.14.21.37.00;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.14.16.29.42;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.10.09.21.20.23;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.07.21.13.01;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.183
log
@Revisions for the removal of COIN from WIT.
@
text
@
//==============================================================================
// WIT-J/Test Source File UnitTester.java.
//==============================================================================

package       com.ibm.witj.test;

import        com.ibm.witj.*;
import static com.ibm.witj.Attribute.*;
import static com.ibm.witj.Part.Category.*;

import                java.util.*;

//==============================================================================
// Class UnitTester
//
// Responsible for performing a unit test on WIT-J.
//==============================================================================

final class UnitTester
{
//==============================================================================
// Package Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// performTest ()
//
// Performs the unit test.
//------------------------------------------------------------------------------

   static void performTest ()
      {
      UnitTester theUnitTester;

      theUnitTester = new UnitTester ();

      theUnitTester.perfTest ();
      }

//==============================================================================
// Private Constructor
//==============================================================================

   private UnitTester ()
      {
      allComponentClasses = new ArrayList <Class <? extends Component>> (7);

      allComponentClasses.add (Problem   .class);
      allComponentClasses.add (Part      .class);
      allComponentClasses.add (Demand    .class);
      allComponentClasses.add (Operation .class);
      allComponentClasses.add (BomEntry  .class);
      allComponentClasses.add (Substitute.class);
      allComponentClasses.add (BopEntry  .class);

      undisplayedAttributes =
         new HashSet <Attribute <?>> (getAttributes ().size () * 2);

      for (Attribute <?> theAtt: getAttributes ())
         {
         undisplayedAttributes.add (theAtt);
         }
      }

//==============================================================================
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// perfTest ().
//
// Internal implementation of performTest ().
//------------------------------------------------------------------------------

   private void perfTest ()
      {
      boolean cplexEmb;

      println (
           "\n"
         + "Unit test of WIT-J.");

      assert (! TerminalException.witjHasTerminated ());

      myProblem = Problem.newInstance ();

      testMessageMgr               ();
      setUpNPeriods                ();
      myProblem.performAction      ("self-test");
      buildComponents              ();
      testClearData                ();
      printPublicObjects           ();
      testAssocMethods             ();
      displayAttributes            ();
      checkForNonAppAttributes     ();
      verifyDefaultValues          ();
      testIsValidFor               ();
      testSetGet                   ();
      testCustAtts                 ();
      testOptInitMethod            ();
      setAttributes                ();
      testCopyData                 ();
      testCopyCompData             ();
      testExpCycle                 ();
      testBelowList                ();
      testHeurAlloc                ();
      testEqHeurAlloc              ();
      myProblem.heurImplode        ();
      testPip                      ();
      testCPeg                     ();
      testCriticalList             ();
      testPgdCritList              ();
      testWriteMethods             ();
      testMultiObjMode             ();
      displayNonDefGlobalBoolAtts  (myProblem);

      myProblem.generatePriorities ();
      myProblem.postprocess        ();
      myProblem.evalObjectives     ();
      testCplexParSpecs            ();

      cplexEmb = myProblem.get (cplexEmbedded);

      if (cplexEmb)
         myProblem.optImplode      ();

      myProblem.deactivate         ();

      assert (! myProblem.isActive ());

      testSortedParts              ();
      testSortedOperations         ();

      testReadData                 ();

      testUnicode                  ();

      PurgeTester.performTest      ();

      if (cplexEmb)
         NewsVendor.performTest    ();

      println (
         "\n"
       + "Normal termination of unit test.");
      }

//------------------------------------------------------------------------------
// testMessageMgr ()
//
// Test of the MessageMgr.
//------------------------------------------------------------------------------

   private void testMessageMgr ()
      {
      boolean quietVal;
      String  theName;
      String  theMode;
      int     theInt;

      myMessageMgr = myProblem   .getMessageMgr ();
      quietVal     = myMessageMgr.isQuiet       ();

      assert (quietVal);

      myMessageMgr.setMesgFileName ("UnitTester.output");
      myMessageMgr.setQuiet        (false);

      quietVal = myMessageMgr.isQuiet ();

      assert (! quietVal);

      myMessageMgr.setMesgFileName ("stdout");

      theName = myMessageMgr.getMesgFileName ();

      assert (theName.equals ("stdout"));

      myMessageMgr.setMesgFileName ("UnitTester.output");

      theName = myMessageMgr.getMesgFileName ();

      assert (theName.equals ("UnitTester.output"));

      myMessageMgr.setMesgFileAccessMode ("a");

      theMode = myMessageMgr.getMesgFileAccessMode ();

      assert (theMode.equals ("a"));

      myMessageMgr.setMesgFileAccessMode ("w");

      myMessageMgr.setMesgTimesPrint (101, 50);

      theInt = myMessageMgr.getMesgTimesPrint (101);

      assert (theInt == 50);

      myMessageMgr.setMesgTimesPrint (MessageGroup.INFORMATIONAL, -7);

      theInt = myMessageMgr.getMesgTimesPrint (101);

      assert (theInt == -1);
      }

//------------------------------------------------------------------------------
// setUpNPeriods ().
//
// Sets up nPeriods.
//------------------------------------------------------------------------------

   private void setUpNPeriods ()
      {
      int nPeriodsVal;

      myProblem.set (nPeriods, 3);

      nPeriodsVal = myProblem.get (nPeriods);

      assert (nPeriodsVal == 3);
      }

//------------------------------------------------------------------------------
// buildComponents ().
//
// Builds the Components for the unit test.
//------------------------------------------------------------------------------

   private void buildComponents ()
      {
      myPartA     = Part      .newInstance (myProblem,  "A", CAPACITY);
      myPartB     = Part      .newInstance (myProblem,  "B", CAPACITY);
      myPartC     = Part      .newInstance (myProblem,  "C", MATERIAL);
      myPartG     = Part      .newInstance (myProblem,  "G", MATERIAL);
      myDemandD   = Demand    .newInstance (myPartC,    "D");
      myDemandE   = Demand    .newInstance (myPartB,    "E");
      myDemandH   = Demand    .newInstance (myPartG,    "H");
      myOpnF      = Operation .newInstance (myProblem,  "F");
      myBomEntFA  = BomEntry  .newInstance (myOpnF,     myPartA);
      myBomEntFB1 = BomEntry  .newInstance (myOpnF,     myPartB);
      myBomEntFB2 = BomEntry  .newInstance (myOpnF,     myPartB);
      mySubFAB    = Substitute.newInstance (myBomEntFA, myPartB);
      myBopEntFC  = BopEntry  .newInstance (myOpnF,     myPartC);
      myBopEntFG  = BopEntry  .newInstance (myOpnF,     myPartG);

      myMessageMgr.flushFile ();
      }

//------------------------------------------------------------------------------
// printPublicObjects ().
//
// Prints the Problem and the public objects that it owns.
//------------------------------------------------------------------------------

   private void printPublicObjects ()
      {
      println ("");
      println (myProblem);
      println (myMessageMgr);
      println (myPartA);
      println (myPartB);
      println (myPartC);
      println (myDemandD);
      println (myDemandE);
      println (myOpnF);
      println (myBomEntFA);
      println (myBomEntFB1);
      println (myBomEntFB2);
      println (mySubFAB);
      println (myBopEntFC);

      println (myOpnF + ": " + myOpnF.getThread ());
      }

//------------------------------------------------------------------------------
// testAssocMethods ()
//
// Tests methods that return Objects associated with a particular Object.
//------------------------------------------------------------------------------

   private void testAssocMethods ()
      {
      testProblemAssocMethods    ();
      testPartAssocMethods       ();
      testDemandAssocMethods     ();
      testOperationAssocMethods  ();
      testBomEntryAssocMethods   ();
      testSubstituteAssocMethods ();
      testBopEntryAssocMethods   ();
      }

//------------------------------------------------------------------------------
// testProblemAssocMethods ()
//
// Tests methods that return Objects associated with a Problem
//------------------------------------------------------------------------------

   private void testProblemAssocMethods ()
      {
      println ("");

      println ("myProblem.getPart      (\"B\"): "
              + myProblem.getPart      ( "B" ));
      println ("myProblem.getOperation (\"F\"): "
              + myProblem.getOperation ( "F" ));

      printList (
          myProblem.getComponents (),
         "myProblem.getComponents ()");

      printList (
          myProblem.getParts (),
         "myProblem.getParts ()");

      printList (
          myProblem.getDemands (),
         "myProblem.getDemands ()");

      printList (
          myProblem.getOperations (),
         "myProblem.getOperations ()");

      printList (
          myProblem.getBomEntries (),
         "myProblem.getBomEntries ()");

      printList (
          myProblem.getSubstitutes (),
         "myProblem.getSubstitutes ()");

      printList (
          myProblem.getBopEntries (),
         "myProblem.getBopEntries ()");
      }

//------------------------------------------------------------------------------
// testPartAssocMethods ()
//
// Tests methods that return Objects associated with a Part
//------------------------------------------------------------------------------

   private void testPartAssocMethods ()
      {
      println ("");

      println ("myPartC.getProblem  ():    "
              + myPartC.getProblem  ());
      println ("myPartC.getDemand   (\"D\"): "
              + myPartC.getDemand   ( "D" ));
      println ("myPartC.getCategory ():    "
              + myPartC.getCategory ());

      printList (
          myPartC.getDemands (),
         "myPartC.getDemands ()");

      printList (
          myPartB.getBomEntries (),
         "myPartB.getBomEntries ()");

      printList (
          myPartB.getSubstitutes (),
         "myPartB.getSubstitutes ()");

      printList (
          myPartC.getBopEntries (),
         "myPartC.getBopEntries ()");
      }

//------------------------------------------------------------------------------
// testDemandAssocMethods ()
//
// Tests methods that return Objects associated with a Demand
//------------------------------------------------------------------------------

   private void testDemandAssocMethods ()
      {
      println ("");

      println ("myDemandD.getPart (): "
              + myDemandD.getPart ());
      }

//------------------------------------------------------------------------------
// testOperationAssocMethods ()
//
// Tests methods that return Objects associated with an Operation
//------------------------------------------------------------------------------

   private void testOperationAssocMethods ()
      {
      printList (
          myOpnF.getBomEntries (),
         "myOpnF.getBomEntries ()");

      printList (
          myOpnF.getBomEntriesTo (myPartB),
         "myOpnF.getBomEntriesTo (myPartB)");

      printList (
          myOpnF.getBomEntriesTo (myPartG),
         "myOpnF.getBomEntriesTo (myPartG)");

      println (
         "\n"
       + "myOpnF.getUniqueBomEntryTo (myPartA):\n"
       + "   "
       +  myOpnF.getUniqueBomEntryTo (myPartA));

      println (
         "\n"
       + "myOpnF.getUniqueBomEntryTo (myPartG):\n"
       + "   "
       +  myOpnF.getUniqueBomEntryTo (myPartG));

      printList (
          myOpnF.getBopEntries (),
         "myOpnF.getBopEntries ()");

      printList (
          myOpnF.getBopEntriesTo (myPartG),
         "myOpnF.getBopEntriesTo (myPartG)");

      println (
         "\n"
       + "myOpnF.getUniqueBopEntryTo (myPartC):\n"
       + "   "
       +  myOpnF.getUniqueBopEntryTo (myPartC));
      }

//------------------------------------------------------------------------------
// testBomEntryAssocMethods ().
//
// Tests methods that return Objects associated with a BomEntry.
//------------------------------------------------------------------------------

   private void testBomEntryAssocMethods ()
      {
      println ("");

      println ("myBomEntFB1.getOperation (): "
              + myBomEntFB1.getOperation ());
      println ("myBomEntFB1.getPart      (): "
              + myBomEntFB1.getPart      ());

      printList (
          myBomEntFA.getSubstitutes (),
         "myBomEntFA.getSubstitutes ()");

      printList (
          myBomEntFA.getSubstitutesTo (myPartB),
         "myBomEntFA.getSubstitutesTo (myPartB)");

      println (
         "\n"
       + "myBomEntFA.getUniqueSubstituteTo (myPartB):\n"
       + "   "
       +  myBomEntFA.getUniqueSubstituteTo (myPartB));

      }

//------------------------------------------------------------------------------
// testSubstituteAssocMethods ().
//
// Tests methods that return Objects associated with a Substitute.
//------------------------------------------------------------------------------

   private void testSubstituteAssocMethods ()
      {
      println ("");

      println ("mySubFAB.getBomEntry (): "
              + mySubFAB.getBomEntry ());
      println ("mySubFAB.getPart     (): "
              + mySubFAB.getPart     ());
      }

//------------------------------------------------------------------------------
// testBopEntryAssocMethods ().
//
// Tests methods that return Objects associated with a BopEntry.
//------------------------------------------------------------------------------

   private void testBopEntryAssocMethods ()
      {
      println ("");

      println ("myBopEntFC .getOperation (): "
              + myBopEntFC .getOperation ());
      println ("myBopEntFC .getPart      (): "
              + myBopEntFC .getPart      ());
      }

//------------------------------------------------------------------------------
// displayAttributes ()
//------------------------------------------------------------------------------

   private void displayAttributes ()
      {
      println (
           "\n"
         + "Attributes:");

      display (accAfterOptImp);
      display (accAfterSoftLB);
      display (accelerated);
      display (asapPipOrder);
      display (autoPriority);
      display (bomIndex);
      display (bopIndex);
      display (boundedLeadTimes);
      display (boundsValue);
      display (buildAheadUB);
      display (buildAsap);
      display (buildNstn);
      display (compPrices);
      display (computeCriticalList);
      display (consRate);
      display (consVol);
      display (cplexEmbedded);
      display (cplexMipBound);
      display (cplexMipRelGap);
      display (cplexParSpecDblVal);
      display (cplexParSpecIntVal);
      display (cplexParSpecName);
      display (cplexStatusCode);
      display (cplexStatusText);
      display (cumShipBounds);
      display (cumShipReward);
      display (currentObjective);
      display (currentScenario);
      display (demandName);
      display (demandVol);
      display (earliestPeriod);
      display (equitability);
      display (excessVol);
      display (execBounds);
      display (execCost);
      display (execEmptyBom);
      display (execPenalty);
      display (execVol);
      display (executable);
      display (expAllowed);
      display (expAversion);
      display (expCutoff);
      display (expNetAversion);
      display (extOptActive);
      display (falloutRate);
      display (feasible);
      display (focusHorizon);
      display (focusShortageVol);
      display (forcedMultiEq);
      display (fssExecVol);
      display (fssShipVol);
      display (fssSubVol);
      display (heurAllocActive);
      display (highPrecisionWD);
      display (impactPeriod);
      display (incLotSize);
      display (incLotSize2);
      display (independentOffsets);
      display (intExecVols);
      display (intShipVols);
      display (intSubVols);
      display (latestPeriod);
      display (leadTimeUB);
      display (lotSize2Thresh);
      display (lotSizeTol);
      display (mandEC);
      display (minLotSize);
      display (minLotSize2);
      display (minimalExcess);
      display (mipMode);
      display (modHeurAlloc);
      display (mrpConsVol);
      display (mrpExcessVol);
      display (mrpExecVol);
      display (mrpNetAllowed);
      display (mrpResidualVol);
      display (mrpSubVol);
      display (multiExec);
      display (multiObjMode);
      display (multiObjTol);
      display (multiRoute);
      display (nPeriods);
      display (nScenarios);
      display (netAllowed);
      display (nstnResidual);
      display (objValue);
      display (objectStage);
      display (objectiveListSpec);
      display (objectiveRank);
      display (offset);
      display (operationName);
      display (partName);
      display (penExec);
      display (perfPegging);
      display (periodStage);
      display (pgdCritListMode);
      display (pipExists);
      display (pipSeqFromHeur);
      display (postprocessed);
      display (prefHighStockSLBs);
      display (preprocessed);
      display (priority);
      display (probability);
      display (prodVol);
      display (productRate);
      display (propRtg);
      display (reqVol);
      display (residualVol);
      display (respectStockSLBs);
      display (roundReqVols);
      display (routingShare);
      display (scrapAllowed);
      display (scrapCost);
      display (scrapVol);
      display (searchInc);
      display (selForDel);
      display (selSplit);
      display (selectionRecovery);
      display (shadowPrice);
      display (shipLateAllowed);
      display (shipLateUB);
      display (shipReward);
      display (shipVol);
      display (singleSource);
      display (skipFailures);
      display (solverLogFileName);
      display (stageByObject);
      display (stochMode);
      display (stochSolnMode);
      display (stockBounds);
      display (stockCost);
      display (stockReallocation);
      display (stockVol);
      display (subCost);
      display (subIndex);
      display (subVol);
      display (supplyVol);
      display (tieBreakPropRt);
      display (title);
      display (truncOffsets);
      display (twoLevelLotSizes);
      display (twoWayMultiExec);
      display (useFocusHorizons);
      display (userHeurStart);
      display (wbounds);
      display (yieldRate);

      if (undisplayedAttributes.isEmpty ())
         {
         println (
              "\n"
            + "All Attributes have been displayed.");
         }
      else
         {
         println (
            "\n"
          + "The following Attributes were missing from the above listing:\n");

         for (Attribute <?> theAtt: undisplayedAttributes)
            {
            println ("   " + theAtt);
            }
         }
      }

//------------------------------------------------------------------------------
// display (theAtt)
//
// Displays information about theAtt.
// To be invoked exactly once for each Attribute.
//------------------------------------------------------------------------------

   private void display (Attribute <?> theAtt)
      {
      assert (undisplayedAttributes.contains (theAtt));

      println (
           "\n"
         + "   " + theAtt + ":");

      for (Class <? extends Component> theClass: allComponentClasses)
         {
         if (theAtt.appliesTo (theClass))
            {
            println ("      Applies to: " + theClass.getSimpleName ());
            }
         }

      println (
           "      Value Type: "
         + theAtt.getValueType ().getSimpleName ());

      println ("      Modifiable: " + theAtt.isModifiable ());

      println ("      Default:    " + defaultValText (theAtt));

      undisplayedAttributes.remove (theAtt);
      }

//------------------------------------------------------------------------------
// defaultValText (theAtt)
//
// Returns the default value for theAtt, converted to a String, or "None", if
// theAtt does not have a default value.
//------------------------------------------------------------------------------

   private String defaultValText (Attribute <?> theAtt)
      {
      Class <?> theValueType;

      if (! theAtt.hasDefaultValue ())
         return "None";

      theValueType = theAtt.getValueType ();

      if (theValueType == Boolean.class)
         return
            asString (
               myProblem.getDefaultValue (theAtt.asAttribute (Boolean.class)));

      if (theValueType == Integer.class)
         return
            asString (
               myProblem.getDefaultValue (theAtt.asAttribute (Integer.class)));

      if (theValueType == Double.class)
         return
            asString (
               myProblem.getDefaultValue (theAtt.asAttribute (Double.class)));

      if (theValueType == String.class)
         return
            "\""
          + myProblem.getDefaultValue (theAtt.asAttribute (String.class))
          + "\"";

      if (theValueType == boolean[].class)
         return
            defaultValTextBV (theAtt.asAttribute (boolean[].class));

      if (theValueType == int[].class)
         return
            defaultValTextIV (theAtt.asAttribute (int[].class));

      if (theValueType == double[].class)
         return
            defaultValTextDV (theAtt.asAttribute (double[].class));

      if (theValueType == BoundSet.class)
         return
            defaultValTextBS (theAtt.asAttribute (BoundSet.class));

      throw new AssertionError ();
      }

//------------------------------------------------------------------------------
// defaultValTextBV (theAtt)
//
// Returns the default value for theAtt, converted to a String.
//------------------------------------------------------------------------------

   private String defaultValTextBV (Attribute <boolean[]> theAtt)
      {
      boolean[] theBoolVec = new boolean[3];

      myProblem.getDefaultValue (theAtt, theBoolVec);

      return
         asString (theBoolVec[0])
       + " "
       + asString (theBoolVec[1])
       + " "
       + asString (theBoolVec[2]);
      }

//------------------------------------------------------------------------------
// defaultValTextIV (theAtt)
//
// Returns the default value for theAtt, converted to a String.
//------------------------------------------------------------------------------

   private String defaultValTextIV (Attribute <int[]> theAtt)
      {
      int[] theIntVec = new int[3];

      myProblem.getDefaultValue (theAtt, theIntVec);

      return
         asString (theIntVec[0])
       + " "
       + asString (theIntVec[1])
       + " "
       + asString (theIntVec[2]);
      }

//------------------------------------------------------------------------------
// defaultValTextDV (theAtt)
//
// Returns the default value for theAtt, converted to a String.
//------------------------------------------------------------------------------

   private String defaultValTextDV (Attribute <double[]> theAtt)
      {
      double[] theDblVec = new double[3];

      myProblem.getDefaultValue (theAtt, theDblVec);

      return
         asString (theDblVec[0])
       + " "
       + asString (theDblVec[1])
       + " "
       + asString (theDblVec[2]);
      }

//------------------------------------------------------------------------------
// defaultValTextBS (theAtt)
//
// Returns the default value for theAtt, converted to a String.
//------------------------------------------------------------------------------

   private String defaultValTextBS (Attribute <BoundSet> theAtt)
      {
      double[] hardLB = new double[3];
      double[] softLB = new double[3];
      double[] hardUB = new double[3];

      myProblem.getDefaultValue (theAtt, hardLB, softLB, hardUB);

      return
         "\n"
       + "         hardLB: "
       + " "
       + asString (hardLB[0])
       + " "
       + asString (hardLB[1])
       + " "
       + asString (hardLB[2])
       + "\n"
       + "         softLB: "
       + " "
       + asString (softLB[0])
       + " "
       + asString (softLB[1])
       + " "
       + asString (softLB[2])
       + "\n"
       + "         hardUB: "
       + " "
       + asString (hardUB[0])
       + " "
       + asString (hardUB[1])
       + " "
       + asString (hardUB[2]);
      }

//------------------------------------------------------------------------------
// checkForNonAppAttributes ()
//
// Displays all Attributes that don't apply to any Component class.
//------------------------------------------------------------------------------

   private void checkForNonAppAttributes ()
      {
      boolean nonAppFound;
      boolean appFound;

      nonAppFound = false;

      for (Attribute <?> theAtt: getAttributes ())
         {
         if (theAtt == null)
            continue;

         appFound = false;

         for (Class <? extends Component> theClass: allComponentClasses)
            {
            if (theAtt.appliesTo (theClass))
               appFound = true;
            }

         if (! appFound)
            {
            if (! nonAppFound)
               println (
                  "\n"
                + "The following Attributes do not apply to any Component "
                + "class:\n");

            nonAppFound = true;

            println ("   " + theAtt);
            }
         }

      if (! nonAppFound)
         println (
            "\n"
          + "All Attributes apply to at least one Component class.");
      }

//------------------------------------------------------------------------------
// verifyDefaultValues ()
//
// Verifies that WIT-J's default value for each Attribute matches that in WIT.
//------------------------------------------------------------------------------

   private void verifyDefaultValues ()
      {
      Attribute <?>[]         theAttsToSkipArr;
      HashSet <Attribute <?>> theAttsToSkip;

      println (
         "\n"
       + "Verifying Attribute default values:");

      theAttsToSkipArr =
         new Attribute <?>[]
            {
            currentScenario,
            multiObjTol,
            nPeriods,
            objectStage,
            objectiveListSpec,
            periodStage,
            probability,
            };

      theAttsToSkip =
         new HashSet <Attribute <?>> (Arrays.asList (theAttsToSkipArr));

      for (Attribute <?> theAtt: getAttributes ())
         {
         if (! theAtt.hasDefaultValue ())
            continue;

         if (theAttsToSkip.contains (theAtt))
            continue;

         println ("   " + theAtt);

         verifyDefaultValue (theAtt, myProblem);
         verifyDefaultValue (theAtt, myPartC);
         verifyDefaultValue (theAtt, myDemandD);
         verifyDefaultValue (theAtt, myOpnF);
         verifyDefaultValue (theAtt, myBomEntFA);
         verifyDefaultValue (theAtt, mySubFAB);
         verifyDefaultValue (theAtt, myBopEntFC);
         }

      println ("");
      }

//------------------------------------------------------------------------------
// verifyDefaultValue (theAtt, theComp)
//
// If theAtt appliesTo theComp, this method verifies that WIT-J's default value
// for theAtt matches that in WIT.
//------------------------------------------------------------------------------

   private void verifyDefaultValue (Attribute <?> theAtt, Component theComp)
      {

      if (! theAtt.appliesTo (theComp.getClass ()))
         return;

      verifyBoolDefault     (theAtt, theComp);
      verifyIntDefault      (theAtt, theComp);
      verifyDblDefault      (theAtt, theComp);
      verifyStringDefault   (theAtt, theComp);
      verifyBoolVecDefault  (theAtt, theComp);
      verifyIntVecDefault   (theAtt, theComp);
      verifyDblVecDefault   (theAtt, theComp);
      verifyBoundSetDefault (theAtt, theComp);
      }

//------------------------------------------------------------------------------
// verify{ValueType}Default methods
//
// Each of these methods checks that theAtt has the indicated value type and,
// if so, verifies that WIT-J's default value for theAtt matches that in WIT.
//------------------------------------------------------------------------------

   private void verifyBoolDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <Boolean> theBoolAtt;
      
      if (theAtt.getValueType () != Boolean.class)
         return;

      theBoolAtt = theAtt.asAttribute (Boolean.class);

      assert (
         myProblem.getDefaultValue (theBoolAtt) == theComp.get (theBoolAtt));
      }

   private void verifyIntDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <Integer> theIntAtt;
      
      if (theAtt.getValueType () != Integer.class)
         return;

      theIntAtt = theAtt.asAttribute (Integer.class);

      assert (
            myProblem.getDefaultValue (theIntAtt)
         == theComp  .get             (theIntAtt));
      }

   private void verifyDblDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <Double> theDblAtt;
      
      if (theAtt.getValueType () != Double.class)
         return;

      theDblAtt = theAtt.asAttribute (Double.class);

      assertApproxEq (
         myProblem.getDefaultValue (theDblAtt),
         theComp  .get             (theDblAtt));
      }

   private void verifyStringDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <String> theStringAtt;
      
      if (theAtt.getValueType () != String.class)
         return;

      theStringAtt = theAtt.asAttribute (String.class);

      assert (
         myProblem.getDefaultValue (theStringAtt).equals (
         theComp  .get             (theStringAtt)));
      }

   private void verifyBoolVecDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <boolean[]> theBoolVecAtt;
      boolean[]             theBoolVec;
      
      if (theAtt.getValueType () != boolean[].class)
         return;

      theBoolVecAtt = theAtt.asAttribute (boolean[].class);

      theBoolVec    = new boolean[3];

      myProblem.getDefaultValue (theBoolVecAtt, theBoolVec);

      assertEq (theBoolVec, theComp.get (theBoolVecAtt));
      }

   private void verifyIntVecDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <int[]> theIntVecAtt;
      int[]             theIntVec;
      
      if (theAtt.getValueType () != int[].class)
         return;

      theIntVecAtt = theAtt.asAttribute (int[].class);

      theIntVec    = new int[3];

      myProblem.getDefaultValue (theIntVecAtt, theIntVec);

      assertEq (theIntVec, theComp.get (theIntVecAtt));
      }

   private void verifyDblVecDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <double[]> theDblVecAtt;
      double[]             theDblVec;
      
      if (theAtt.getValueType () != double[].class)
         return;

      theDblVecAtt = theAtt.asAttribute (double[].class);

      theDblVec    = new double[3];

      myProblem.getDefaultValue (theDblVecAtt, theDblVec);

      assertApproxEq (theDblVec, theComp.get (theDblVecAtt));
      }

   private void verifyBoundSetDefault (Attribute <?> theAtt, Component theComp)
      {
      Attribute <BoundSet> theBoundSetAtt;
      double[]             hardLBDef;
      double[]             softLBDef;
      double[]             hardUBDef;
      double[]             hardLBVal;
      double[]             softLBVal;
      double[]             hardUBVal;
      
      if (theAtt.getValueType () != BoundSet.class)
         return;

      theBoundSetAtt = theAtt.asAttribute (BoundSet.class);

      hardLBDef      = new double[3];
      softLBDef      = new double[3];
      hardUBDef      = new double[3];
      hardLBVal      = new double[3];
      softLBVal      = new double[3];
      hardUBVal      = new double[3];

      myProblem.
         getDefaultValue (theBoundSetAtt, hardLBDef, softLBDef, hardUBDef);

      theComp.get        (theBoundSetAtt, hardLBVal, softLBVal, hardUBVal);

      assertApproxEq (hardLBDef, hardLBVal);
      assertApproxEq (softLBDef, softLBVal);
      assertApproxEq (hardUBDef, hardUBVal);
      }

//------------------------------------------------------------------------------
// testIsValidFor ()
//
// Tests the isValidFor method of class Attribute <V>.
//------------------------------------------------------------------------------

   private void testIsValidFor ()
      {
      boolean isValid;

      //------------------------------------------------------------------------

      isValid = demandName.isValidFor (myOpnF);

      assert (! isValid);
         //
         // demandName does not apply to class Operation.

      //------------------------------------------------------------------------

      isValid = buildAsap.isValidFor (myPartA);

      assert (! isValid);
         //
         // buildAsap requires a material Part and myPartA is a capacity part.

      //------------------------------------------------------------------------

      isValid = probability.isValidFor (myPartA);

      assert (! isValid);
         //
         // probability requires stochastic mode.

      //------------------------------------------------------------------------

      isValid = objectiveListSpec.isValidFor (myProblem);

      assert (! isValid);
         //
         // objectiveListSpec requires multiple objectives mode.

      //------------------------------------------------------------------------

      myProblem.set (stageByObject, true);
      myProblem.set (stochMode,     true);

      isValid = periodStage.isValidFor (myProblem);

      assert (! isValid);

      isValid = objectStage.isValidFor (myPartA);

      assert (isValid);

      myProblem.set (stochMode,     false);
      myProblem.set (stageByObject, false);
      myProblem.set (stochMode,     true);

      isValid = periodStage.isValidFor (myProblem);

      assert (isValid);

      isValid = objectStage.isValidFor (myPartA);

      assert (! isValid);

      myProblem.set (stochMode, false);
      }

//------------------------------------------------------------------------------
// testSetGet ()
//
// Tests Attribute set, setVectorToScalar, and get methods of class Component.
//------------------------------------------------------------------------------

   private void testSetGet ()
      {
      testSetGetBool    ();
      testSetGetInt     ();
      testSetGetDbl     ();
      testSetGetString  ();
      testSetGetBoolVec ();
      testSetGetIntVec  ();
      testSetGetDblVec  ();
      }

//------------------------------------------------------------------------------
// testSetGetBool ()
//
// Tests Attribute set and get methods for Attributes of value type boolean.
//------------------------------------------------------------------------------

   private void testSetGetBool ()
      {
      boolean expAllowedOut;

      myBopEntFC.set (expAllowed, false);

      expAllowedOut = myBopEntFC.get (expAllowed);

      assert (! expAllowedOut);

      myBopEntFC.set (expAllowed, true);
      }

//------------------------------------------------------------------------------
// testSetGetInt ()
//
// Tests Attribute set and get methods for Attributes of value type int.
//------------------------------------------------------------------------------

   private void testSetGetInt ()
      {
      int earliestPeriodOut;

      myBopEntFC.set (earliestPeriod, 1);

      earliestPeriodOut = myBopEntFC.get (earliestPeriod);

      assert (earliestPeriodOut == 1);

      myBopEntFC.set (earliestPeriod, 0);
      }

//------------------------------------------------------------------------------
// testSetGetDbl ()
//
// Tests Attribute set and get methods for Attributes of value type double.
//------------------------------------------------------------------------------

   private void testSetGetDbl ()
      {
      double execPenaltyOut;

      myOpnF.set (execPenalty, 2.0);

      execPenaltyOut = myOpnF.get (execPenalty);

      assert (execPenaltyOut == 2.0);

      myOpnF.set (execPenalty, 0.0);
      }

//------------------------------------------------------------------------------
// testSetGetString ()
//
// Tests Attribute set and get methods for Attributes of value type String.
//------------------------------------------------------------------------------

   private void testSetGetString ()
      {
      String titleIn;
      String titleOut;

      titleIn  = "WIT-J Test Problem";

      myProblem.set (title, titleIn);

      titleOut = myProblem.get (title);

      assert (titleOut.equals (titleIn));
      }

//------------------------------------------------------------------------------
// testSetGetBoolVec ()
//
// Tests Attribute set, setVectorToScalar, and get methods for Attributes of
// value type boolean[].
//------------------------------------------------------------------------------

   private void testSetGetBoolVec ()
      {
      boolean[] propRtgIn;
      boolean[] propRtgOut;

      propRtgIn  = new boolean[] {true, false, true};

      myPartB.set (propRtg, propRtgIn);

      propRtgOut = myPartB.get (propRtg);

      assertEq (propRtgOut, propRtgIn);

      //------------------------------------------------------------------------

      myPartB.setVectorToScalar (propRtg, true);

      myPartB.get               (propRtg, propRtgOut);

      assertEq                  (propRtgOut, new boolean[] {true, true, true});

      myPartB.setVectorToScalar (propRtg, false);
      }

//------------------------------------------------------------------------------
// testSetGetIntVec ()
//
// Tests Attribute set, setVectorToScalar, and get methods for Attributes of
// value type int[].
//------------------------------------------------------------------------------

   private void testSetGetIntVec ()
      {
      int[] priorityIn;
      int[] priorityOut;

      priorityIn  = new int[] {2, 7, 3};

      myDemandD.set (priority, priorityIn);

      priorityOut = myDemandD.get (priority);

      assertEq (priorityOut, priorityIn);

      //------------------------------------------------------------------------

      myDemandD.setVectorToScalar (priority, 6);

      myDemandD.get               (priority, priorityOut);

      assertEq                    (priorityOut, new int[] {6, 6, 6});

      myDemandD.setVectorToScalar (priority, 0);
      }

//------------------------------------------------------------------------------
// testSetGetDblVec ()
//
// Tests Attribute set, setVectorToScalar, and get methods for Attributes of
// value type double[].
//------------------------------------------------------------------------------

   private void testSetGetDblVec ()
      {
      double[] supplyVolIn;
      double[] supplyVolOut;

      supplyVolIn  = new double[] {40,  0, 50};

      myPartB.set (supplyVol, supplyVolIn);

      supplyVolOut = myPartB.get (supplyVol);

      assertApproxEq (supplyVolOut, supplyVolIn);

      //------------------------------------------------------------------------

      myPartB.setVectorToScalar (supplyVol, 20);

      myPartB.get               (supplyVol, supplyVolOut);

      assertApproxEq            (supplyVolOut, new double[] {20, 20, 20});

      myPartB.setVectorToScalar (supplyVol, 0);
      }

//------------------------------------------------------------------------------
// testCustAtts ()
//
// Tests customized Attributes.
//------------------------------------------------------------------------------

   private void testCustAtts ()
      {
      testBomIndex      ();
      testBopIndex      ();
      testCumShipBounds ();
      testDemandName    ();
      testExecBounds    ();
      testOperationName ();
      testPartName      ();
      testStockBounds   ();
      testSubIndex      ();
      }

//------------------------------------------------------------------------------
// testBomIndex ()
//
// Tests the "bomIndex" Attribute.
//------------------------------------------------------------------------------

   private void testBomIndex ()
      {
      int bomIndexOut;

      bomIndexOut = myBomEntFB1.get (bomIndex);

      assert (bomIndexOut == 1);
      }

//------------------------------------------------------------------------------
// testBopIndex ()
//
// Tests the "bopIndex" Attribute.
//------------------------------------------------------------------------------

   private void testBopIndex ()
      {
      int bopIndexOut;

      bopIndexOut = myBopEntFC.get (bopIndex);

      assert (bopIndexOut == 0);
      }

//------------------------------------------------------------------------------
// testSubIndex ()
//
// Tests the "subIndex" Attribute.
//------------------------------------------------------------------------------

   private void testSubIndex ()
      {
      int subIndexOut;

      subIndexOut = mySubFAB.get (subIndex);

      assert (subIndexOut == 0);
      }

//------------------------------------------------------------------------------
// testCumShipBounds ()
//
// Tests the "cumShipBounds" Attribute.
//------------------------------------------------------------------------------

   private void testCumShipBounds ()
      {
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      myDemandD.setBoundSetToScalars (cumShipBounds, 210, 240, 270);

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myDemandD.get (cumShipBounds, hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout[0], 210);
      assertApproxEq (hardLBout[1], 210);
      assertApproxEq (hardLBout[2], 210);

      assertApproxEq (softLBout[0], 240);
      assertApproxEq (softLBout[1], 240);
      assertApproxEq (softLBout[2], 240);

      assertApproxEq (hardUBout[0], 270);
      assertApproxEq (hardUBout[1], 270);
      assertApproxEq (hardUBout[2], 270);

      myDemandD.setBoundSetToScalars (cumShipBounds, 0, 0, -1);
      }

//------------------------------------------------------------------------------
// testDemandName ()
//
// Tests the "demandName" Attribute.
//------------------------------------------------------------------------------

   private void testDemandName ()
      {
      String demandNameIn;
      String demandNameOut;

      demandNameIn  = "Temporary Name for Demand D";

      myDemandD.set (demandName, demandNameIn);

      demandNameOut = myDemandD.get (demandName);

      assert (demandNameOut.equals (demandNameIn));

      myDemandD.set (demandName, "D");
      }

//------------------------------------------------------------------------------
// testExecBounds ()
//
// Tests the "execBounds" Attribute.
// The hard lower and hard upper bounds are left at their default values.
//------------------------------------------------------------------------------

   private void testExecBounds ()
      {
      double[] zeroVec;
      double[] softLBin;
      double[] neg1Vec;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      zeroVec   = new double[] { 0.0,  0.0,  0.0};
      softLBin  = new double[] {40.0, 50.0, 60.0};
      neg1Vec   = new double[] {-1.0, -1.0, -1.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myOpnF.set (execBounds, null,      softLBin,  null);
      myOpnF.get (execBounds, hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, zeroVec);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, neg1Vec);

      myOpnF.setBoundSetToScalars (execBounds, 0, 0, -1);
      }

//------------------------------------------------------------------------------
// testOperationName ()
//
// Tests the "operationName" Attribute.
//------------------------------------------------------------------------------

   private void testOperationName ()
      {
      String operationNameIn;
      String operationNameOut;

      operationNameIn  = "Temporary Name for Operation F";

      myOpnF.set (operationName, operationNameIn);

      operationNameOut = myOpnF.get (operationName);

      assert (operationNameOut.equals (operationNameIn));

      myOpnF.set (operationName, "F");
      }

//------------------------------------------------------------------------------
// testPartName ()
//
// Tests the "partName" Attribute.
//------------------------------------------------------------------------------

   private void testPartName ()
      {
      String partNameIn;
      String partNameOut;

      partNameIn  = "Temporary Name for Part A";

      myPartA.set (partName, partNameIn);

      partNameOut = myPartA.get (partName);

      assert (partNameOut.equals (partNameIn));

      myPartA.set (partName, "A");
      }

//------------------------------------------------------------------------------
// testStockBounds ()
//
// Tests the "stockBounds" Attribute.
//------------------------------------------------------------------------------

   private void testStockBounds ()
      {
      double[] hardLBin;
      double[] softLBin;
      double[] hardUBin;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;
      double[] zeroArr;

      hardLBin  = new double[] {110.0, 120.0, 130.0};
      softLBin  = new double[] {140.0, 150.0, 160.0};
      hardUBin  = new double[] {170.0, 180.0, 190.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      zeroArr   = new double[] {  0.0,   0.0,   0.0};

      myPartC.set (stockBounds, hardLBin,  softLBin,  hardUBin);
      myPartC.get (stockBounds, hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, hardLBin);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, hardUBin);

      myPartC.set (stockBounds, zeroArr,   null,      null);

      myPartC.setBoundSetToScalars (stockBounds, 0, 0, -1);
      }

//------------------------------------------------------------------------------
// testOptInitMethod ()
//
// Tests OptInitMethod
//------------------------------------------------------------------------------

   private void testOptInitMethod ()
      {
      OptInitMethod theMethod;

      myProblem.setOptInitMethod (OptInitMethod.CRASH);

      theMethod = myProblem.getOptInitMethod ();

      assert         (theMethod.equals (OptInitMethod.CRASH));

      myProblem.setOptInitMethod (OptInitMethod.HEURISTIC);
      }

//------------------------------------------------------------------------------
// testClearData ()
//
// Tests theProblem.clearData ().
//------------------------------------------------------------------------------

   private void testClearData ()
      {
      myProblem.clearData ();

      myProblem.set (nPeriods, 3);

      buildComponents ();
      }

//------------------------------------------------------------------------------
// testCopyData ()
//
// Tests theProblem.copyData (...).
//------------------------------------------------------------------------------

   private void testCopyData ()
      {
      Problem cpyProblem;

      myProblem.copyData (myProblem);

      cpyProblem = Problem.newInstance ();

      cpyProblem.getMessageMgr ().setMesgFileName ("copyData.output");

      cpyProblem.copyData (myProblem);

      println ("Components for the copied Problem:");

      for (Component theComp: cpyProblem.getComponents ())
         {
         println ("   " + theComp);
         }

      println ("");

      cpyProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// testCopyCompData ()
//
// Tests theComp.copyComponentData (...).
//------------------------------------------------------------------------------

   private void testCopyCompData ()
      {
      Problem    theProblem;

      Part       thePartA1;
      Part       thePartA2;
      Demand     theDemandD1;
      Demand     theDemandD2;
      Operation  theOpnF1;
      Operation  theOpnF2;
      BomEntry   theBomEntFA1;
      BomEntry   theBomEntFA2;
      Substitute theSubFAA1;
      Substitute theSubFAA2;
      BopEntry   theBopEntFA1;
      BopEntry   theBopEntFA2;

      theProblem   = Problem   .newInstance ();

      theProblem.set (nPeriods, 3);

      thePartA1    = Part      .newInstance (theProblem,  "A1", CAPACITY);
      thePartA2    = Part      .newInstance (theProblem,  "A2", CAPACITY);
      theDemandD1  = Demand    .newInstance (thePartA1,   "D1");
      theDemandD2  = Demand    .newInstance (thePartA2,   "D2");
      theOpnF1     = Operation .newInstance (theProblem,  "F1");
      theOpnF2     = Operation .newInstance (theProblem,  "F2");
      theBomEntFA1 = BomEntry  .newInstance (theOpnF1,     thePartA1);
      theBomEntFA2 = BomEntry  .newInstance (theOpnF2,     thePartA2);
      theSubFAA1   = Substitute.newInstance (theBomEntFA1, thePartA1);
      theSubFAA2   = Substitute.newInstance (theBomEntFA2, thePartA2);
      theBopEntFA1 = BopEntry  .newInstance (theOpnF1,     thePartA1);
      theBopEntFA2 = BopEntry  .newInstance (theOpnF2,     thePartA2);

      thePartA1   .copyComponentData  (myPartA);
      thePartA2   .copyComponentData (thePartA1);

      theDemandD1 .copyComponentData  (myDemandD);
      theDemandD2 .copyComponentData (theDemandD1);

      theOpnF1    .copyComponentData  (myOpnF);
      theOpnF2    .copyComponentData (theOpnF1);

      theBomEntFA1.copyComponentData  (myBomEntFA);
      theBomEntFA2.copyComponentData (theBomEntFA1);

      theSubFAA1  .copyComponentData  (mySubFAB);
      theSubFAA2  .copyComponentData (theSubFAA1);

      theBopEntFA1.copyComponentData  (myBopEntFC);
      theBopEntFA2.copyComponentData (theBopEntFA1);

      theProblem.displayData ("");

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// testExpCycle ()
//
// Tests theProblem.getExpCycle ().
//------------------------------------------------------------------------------

   private void testExpCycle ()
      {
      Operation theOpnI;
      ArrayList <Part>      thePartList;
      ArrayList <Operation> theOpnList;
      int                   theIdx;

      theOpnI = Operation.newInstance (myProblem,  "I");

      BomEntry.newInstance (theOpnI, myPartC);
      BopEntry.newInstance (theOpnI, myPartA);

      thePartList = new ArrayList <Part>      (0);
      theOpnList  = new ArrayList <Operation> (0);

      myProblem.getExpCycle (thePartList, theOpnList);

      println ("Explodable Cycle:\n");

      for (theIdx = 0; theIdx < thePartList.size (); theIdx ++)
         {
         println ("   " + thePartList.get (theIdx));
         println ("   " + theOpnList .get (theIdx));
         }

      println ("");

      theOpnI.set (selForDel, true);

      myProblem.purgeData ();
      }

//------------------------------------------------------------------------------
// setAttributes ()
//
// Sets various Attributes of the Components of myProblem in order to form an
// implosion problem appropriate for the unit test.
//------------------------------------------------------------------------------

   private void setAttributes ()
      {
      myProblem  .set (computeCriticalList, true);
      myProblem  .set (pgdCritListMode,     true);
      myProblem  .set (perfPegging,         true);
      myProblem  .set (skipFailures,        false);
      myPartC    .set (buildNstn,           true);
      myPartA    .set (supplyVol,           new double[] {10, 10, 10});
      myPartB    .set (supplyVol,           new double[] {60,  0, 50});
      myDemandD  .set (demandVol,           new double[] {20,  0, 30});
      myDemandE  .set (demandVol,           new double[] {20, 10, 10});
      myDemandH  .set (demandVol,           new double[] {25,  0, 35});
      myBomEntFB2.set (consRate,            new double[] { 0,  0,  0});
      myBopEntFG .set (expAllowed,          false);
      }

//------------------------------------------------------------------------------
// testBelowList ()
//
// Tests thePart.getBelowList (...).
//------------------------------------------------------------------------------

   private void testBelowList ()
      {
      ArrayList <Part> theBelowList;

      theBelowList = myPartC.getBelowList ();

      println ("Below List for Part C:\n");

      for (Part thePart: theBelowList)
         println ("   " + thePart);

      println ("");
      }

//------------------------------------------------------------------------------
// testHeurAlloc ()
//
// Tests heuristic allocation.
//------------------------------------------------------------------------------

   private void testHeurAlloc ()
      {
      boolean activeVal;
      double  incVol;

      myProblem.startHeurAlloc ();

      activeVal = myProblem.get (heurAllocActive);

      assert (activeVal);

      incVol = myDemandD.incHeurAlloc (2, 90);

      myProblem.shutDownHeurAlloc ();

      activeVal = myProblem.get (heurAllocActive);

      assert (! activeVal);

      println ("incVol = " + incVol);
      println ();
      }

//------------------------------------------------------------------------------
// testEqHeurAlloc ()
//
// Tests equitable heuristic allocation.
//------------------------------------------------------------------------------

   private void testEqHeurAlloc ()
      {
      ArrayList <Demand>  theDemandList;
      ArrayList <Integer> shipPeriodList;
      ArrayList <Double>  desIncVolList;
      ArrayList <Double>  incVolList;

      theDemandList  = new ArrayList <Demand>  (2);
      shipPeriodList = new ArrayList <Integer> (2);
      desIncVolList  = new ArrayList <Double>  (2);
      incVolList     = new ArrayList <Double>  (0);

      theDemandList .add (myDemandD);
      shipPeriodList.add (2);
      desIncVolList .add (50.0);

      theDemandList .add (myDemandE);
      shipPeriodList.add (2);
      desIncVolList .add (40.0);

      myProblem.set (equitability, 100);

      myProblem.startHeurAlloc ();

      myProblem.
         eqHeurAlloc (
            theDemandList,
            shipPeriodList,
            desIncVolList,
            incVolList);

      myProblem.finishHeurAlloc ();

      myProblem.set (equitability, 1);

      println ("incVolList.get (0) = " + incVolList.get (0));
      println ("incVolList.get (1) = " + incVolList.get (1));
      println ();
      }

//------------------------------------------------------------------------------
// testPip ()
//
// Tests PIP.
//------------------------------------------------------------------------------

   private void testPip ()
      {
      testPipShipSeq ();

      myProblem.buildPip ();

      testConsVolPip   ();
      testCoExecVolPip ();
      testExecVolPip   ();
      testProdVolPip   ();
      testSideVolPip   ();
      testSubVolPip    ();
      testSupplyVolPip ();
      }

//------------------------------------------------------------------------------
// testPipShipSeq ()
//
// Tests the methods for storing and retrieving the PIP shipment sequence.
//------------------------------------------------------------------------------

   private void testPipShipSeq ()
      {
      ArrayList <PeggingTriple <Demand>> theTripleList;

      theTripleList = new ArrayList <PeggingTriple <Demand>> (0);

      myDemandD.appendToPipSeq (1, 14);

      myProblem.clearPipSeq ();

      myDemandD.appendToPipSeq (0, 20);
      myDemandE.appendToPipSeq (0, 20);
      myDemandD.appendToPipSeq (2, 30);
      myDemandE.appendToPipSeq (2, 10);
      myDemandH.appendToPipSeq (0, 20);
      myDemandH.appendToPipSeq (2, 30);

      theTripleList = myProblem.getPipSeq ();

      println ("Shipment Sequence:\n");

      for (PeggingTriple <Demand> theTriple: theTripleList)
         {
         println (
           "   "
          + theTriple.getRoot   ()
          + ", Ship Period = "
          + theTriple.getPeriod ()
          + ", Inc ShipVol = "
          + theTriple.getVolume ());
         }

      println ();
      }

//------------------------------------------------------------------------------
// testConsVolPip ()
//
// Tests Demand.getConsVolPip.
//------------------------------------------------------------------------------

   private void testConsVolPip ()
      {
      ArrayList <PeggingTriple <Part>> theTripleList;

      theTripleList = myDemandD.getConsVolPip (2);

      printPegging ("ConsVol PIP", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testCoExecVolPip ()
//
// Tests Demand.getCoExecVolPip.
//------------------------------------------------------------------------------

   private void testCoExecVolPip ()
      {
      ArrayList <PeggingTriple <BopEntry>> theTripleList;

      theTripleList = myDemandD.getCoExecVolPip (2);

      printPegging ("CoExecVol PIP", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testExecVolPip ()
//
// Tests Demand.getExecVolPip.
//------------------------------------------------------------------------------

   private void testExecVolPip ()
      {
      ArrayList <PeggingTriple <Operation>> theTripleList;

      theTripleList = myDemandD.getExecVolPip (2);

      printPegging ("ExecVol PIP", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testProdVolPip ()
//
// Tests Demand.getProdVolPip.
//------------------------------------------------------------------------------

   private void testProdVolPip ()
      {
      ArrayList <PeggingTriple <Part>> theTripleList;

      theTripleList = myDemandD.getProdVolPip (2);

      printPegging ("ProdVol PIP", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testSideVolPip ()
//
// Tests Demand.getSideVolPip.
//------------------------------------------------------------------------------

   private void testSideVolPip ()
      {
      ArrayList <PeggingTriple <Part>> theTripleList;

      theTripleList = myDemandH.getSideVolPip (2);

      printPegging ("SideVol PIP", myDemandH, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testSubVolPip ()
//
// Tests Demand.getSubVolPip.
//------------------------------------------------------------------------------

   private void testSubVolPip ()
      {
      ArrayList <PeggingTriple <Substitute>> theTripleList;

      theTripleList = myDemandD.getSubVolPip (2);

      printPegging ("SubVol PIP", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testSupplyVolPip ()
//
// Tests Demand.getSupplyVolPip.
//------------------------------------------------------------------------------

   private void testSupplyVolPip ()
      {
      ArrayList <PeggingTriple <Part>> theTripleList;
      double                           supVolPip;

      theTripleList = myDemandD.getSupplyVolPip (2);

      printPegging ("SupplyVol PIP", myDemandD, 2, theTripleList);

      supVolPip = getSpecificSupplyVolPip (myPartB, 2, myDemandD, 2);

      assertApproxEq (supVolPip, 40.0);

      supVolPip = getSpecificSupplyVolPip (myPartB, 1, myDemandD, 2);

      assertApproxEq (supVolPip,  0.0);
      }

//------------------------------------------------------------------------------
// testCPeg ()
//
// Tests concurrent pegging.
//------------------------------------------------------------------------------

   private void testCPeg ()
      {
      testExecVolCPeg ();
      testSubVolCPeg  ();

      myProblem.clearPegging ();

      testExecVolCPeg ();
      }

//------------------------------------------------------------------------------
// testExecVolCPeg ()
//
// Tests Demand.getExecVolPegging.
//------------------------------------------------------------------------------

   private void testExecVolCPeg ()
      {
      ArrayList <PeggingTriple <Operation>> theTripleList;

      theTripleList = myDemandD.getExecVolPegging (2);

      printPegging ("ExecVol Concurrent Pegging", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// testSubVolCPeg ()
//
// Tests Demand.getSubVolPegging.
//------------------------------------------------------------------------------

   private void testSubVolCPeg ()
      {
      ArrayList <PeggingTriple <Substitute>> theTripleList;

      theTripleList = myDemandD.getSubVolPegging (2);

      printPegging ("SubVol Concurrent Pegging", myDemandD, 2, theTripleList);
      }

//------------------------------------------------------------------------------
// printPegging (pggTypeName, theDemand, shipPer, theTripleList)
//
// Prints the pegging for theDemand in shipPer given in theTripleList
// pggTypeName indicates the type of the pegging.
//------------------------------------------------------------------------------

   private <C extends Component> void printPegging (
         String                        pggTypeName,
         Demand                        theDemand,
         int                           shipPer,
         ArrayList <PeggingTriple <C>> theTripleList)
      {
      println (
         "\n"
       + pggTypeName
       + " for "
       + theDemand
       + " in Period "
       +  shipPer
       + ":\n");

      for (PeggingTriple <C> theTriple: theTripleList)
         println ("   " + theTriple);
      }

//------------------------------------------------------------------------------
// testCriticalList ()
//
// Tests Problem.getCriticalList (...).
//------------------------------------------------------------------------------

   private void testCriticalList ()
      {
      ArrayList <Part>    critPartList;
      ArrayList <Integer> critPeriodList;
      int                 theIdx;

      critPartList   = new ArrayList <Part>    (0);
      critPeriodList = new ArrayList <Integer> (0);

      critPartList  .add (myPartC);
      critPeriodList.add (17);
      critPeriodList.add (92);
         //
         // These should be cleared by getCriticalList.

      myProblem.getCriticalList (critPartList, critPeriodList);

      println ("Critical Parts List:");

      for (theIdx = 0; theIdx < critPartList.size (); theIdx ++)
         println (
            "   "          + critPartList  .get (theIdx)
          + " in Period "  + critPeriodList.get (theIdx));
      }

//------------------------------------------------------------------------------
// testPgdCritList ()
//
// Tests Problem.getPgdCritList (...).
//------------------------------------------------------------------------------

   private void testPgdCritList ()
      {
      ArrayList <Part>    critPartList;
      ArrayList <Integer> critPeriodList;
      ArrayList <Demand>  theDemandList;
      ArrayList <Integer> shipPeriodList;
      int                 theIdx;

      critPartList   = new ArrayList <Part>    (0);
      critPeriodList = new ArrayList <Integer> (0);
      theDemandList  = new ArrayList <Demand>  (0);
      shipPeriodList = new ArrayList <Integer> (0);

      critPartList  .add (myPartB);
      critPeriodList.add (9);
      theDemandList .add (myDemandE);
      shipPeriodList.add (21);

      critPartList  .add (myPartA);
      critPeriodList.add (12);
      theDemandList .add (myDemandH);
      shipPeriodList.add (14);
         //
         // These should be cleared by getPgdCritList.

      myProblem.
         getPgdCritList (
            critPartList,
            critPeriodList,
            theDemandList,
            shipPeriodList);

      println ();
      println ("Pegged Critical List:");

      for (theIdx = 0; theIdx < critPartList.size (); theIdx ++)
         println (
            "   "         + critPartList  .get (theIdx)
          + " in Period " + critPeriodList.get (theIdx)
          + " blocked "   + theDemandList .get (theIdx)
          + " in Period " + shipPeriodList.get (theIdx)
          + ".");
      }

//------------------------------------------------------------------------------
// testWriteMethods ()
//
// Tests the "write" methods.
//------------------------------------------------------------------------------

   private void testWriteMethods ()
      {
      myProblem.writeData         ("unit-test.data");
      myProblem.preprocess        ();
      myProblem.displayData       ("");
      myProblem.writeExecSched    ("",               FileFormat.BSV);
      myProblem.writeExecSched    ("unit-test.exec", FileFormat.BSV);
      myProblem.writeShipSched    ("unit-test.ship", FileFormat.CSV);
      myProblem.writeCriticalList ("unit-test.crit", FileFormat.BSV, 100);
      myProblem.mrp               ();
      myProblem.writeReqSched     ("unit-test.req",  FileFormat.BSV);
      }

//------------------------------------------------------------------------------
// testMultiObjMode ()
//
// Tests WIT-J in multiple objectives mode.
//------------------------------------------------------------------------------

   private void testMultiObjMode ()
      {
      Problem theProblem;

      theProblem = Problem.newInstance ();

      theProblem.set (multiObjMode, true);

      testObjectiveListSpec (theProblem);
      testObjectiveList     (theProblem);
      testCurObjObjRank     (theProblem);

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// testObjectiveListSpec (theProblem)
//------------------------------------------------------------------------------

   private void testObjectiveListSpec (Problem theProblem)
      {
      String             theSpec;
      ArrayList <String> theObjNameList;

      theProblem.set (objectiveListSpec, "First|Second|Third|Fourth");

      theSpec = theProblem.get (objectiveListSpec);

      assert (theSpec.equals ("First|Second|Third|Fourth"));

      theObjNameList = theProblem.getObjectiveList ();

      assert (theObjNameList.size () == 4);

      assert (theObjNameList.get (0).equals ("First" ));
      assert (theObjNameList.get (1).equals ("Second"));
      assert (theObjNameList.get (2).equals ("Third" ));
      assert (theObjNameList.get (3).equals ("Fourth"));
      }

//------------------------------------------------------------------------------
// testObjectiveList (theProblem)
//------------------------------------------------------------------------------

   private void testObjectiveList (Problem theProblem)
      {
      String             theSpec;
      ArrayList <String> theObjNameList;

      theProblem.setObjectiveList ("High", "Medium", "Low");

      theSpec = theProblem.get (objectiveListSpec);

      assert (theSpec.equals ("High|Medium|Low"));

      theObjNameList = theProblem.getObjectiveList ();

      assert (theObjNameList.size () == 3);

      assert (theObjNameList.get (0).equals ("High"  ));
      assert (theObjNameList.get (1).equals ("Medium"));
      assert (theObjNameList.get (2).equals ("Low"   ));

      //------------------------------------------------------------------------

      theObjNameList.clear ();

      theObjNameList.add ("A");
      theObjNameList.add ("B");
      theObjNameList.add ("C");

      theProblem.setObjectiveList (theObjNameList);

      theSpec = theProblem.get (objectiveListSpec);

      assert (theSpec.equals ("A|B|C"));
      }

//------------------------------------------------------------------------------
// testCurObjObjRank (theProblem)
//
// Tests currentObjective and objectiveRank.
//------------------------------------------------------------------------------

   private void testCurObjObjRank (Problem theProblem)
      {
      theProblem.set (currentObjective, "B");
      theProblem.set (objectiveRank,     3);
      theProblem.set (currentObjective, "C");
      theProblem.set (objectiveRank,     2);

      verifyObjRank (theProblem, "A", 1);
      verifyObjRank (theProblem, "B", 3);
      verifyObjRank (theProblem, "C", 2);
      }

//------------------------------------------------------------------------------
// verifyObjRank (theProblem, theObjName, theRank)
//
// Verifies that the objective indicated by theObjName has objectiveRank equal
// to theRank.
//------------------------------------------------------------------------------

   private void verifyObjRank (
         Problem theProblem,
         String  theObjName,
         int     theRank)
      {
      int curRank;

      theProblem.set (currentObjective, theObjName);

      curRank = theProblem.get (objectiveRank);

      assert (curRank == theRank);
      }

//------------------------------------------------------------------------------
// displayNonDefGlobalBoolAtts (theProblem)
//
// For each global boolean Attribute, if the Attribute is currently valid but
// not at its default value in theProblem, the Attribute, the default value and
// and current value are displayed.
//
// This method is used as an example in the WIT-J Guide.
//------------------------------------------------------------------------------

   private static void displayNonDefGlobalBoolAtts (Problem theProblem)
      {
      Attribute <Boolean> theBoolAtt;
      boolean             defValue;
      boolean             theValue;

      for (Attribute <?> theAtt: getAttributes ())
         {
         if (theAtt.isValidFor (theProblem))
            {
            if (theAtt.getValueType () == Boolean.class)
               {
               theBoolAtt = theAtt.asAttribute (Boolean.class);

               if (theBoolAtt.hasDefaultValue ())
                  {
                  defValue = theProblem .getDefaultValue (theBoolAtt);

                  theValue = theProblem.get (theBoolAtt);

                  if (theValue != defValue)
                     {
                     System.out.printf (
                        "%n"
                      + "Non-default global boolean Attribute found.%n"
                      + "%n"
                      + "   Attribute:     %s%n"
                      + "   Default Value: %s%n"
                      + "   Current Value: %s%n",
                        theBoolAtt.toString (),
                        defValue,
                        theValue);
                     }
                  }
               }
            }
         }
      }

//------------------------------------------------------------------------------
// getSpecificSupplyVolPip (thePart, supPer, theDemand, shipPer)
//
// Returns the amount of supplyVol of the supplyVol of thePart in supPer that
// has been pegged by PIP to theDemand in shipPer.
//
// This method is used as an example in the WIT-J Guide.
//------------------------------------------------------------------------------

   private static double getSpecificSupplyVolPip (
         Part   thePart,
         int    supPer,
         Demand theDemand,
         int    shipPer)
      {
      ArrayList <PeggingTriple <Part>> theTripleList;

      theTripleList = theDemand.getSupplyVolPip (shipPer);

      for (PeggingTriple <Part> theTriple: theTripleList)
         {
         if    (theTriple.getRoot   () == thePart)
            {
            if (theTriple.getPeriod () == supPer)
               {
               return theTriple.getVolume ();
               }
            }
         }

      return 0.0;
         //
         // If no PeggingTriple is found matching thePart and supPer, the amount
         // pegged is 0.
      }

//------------------------------------------------------------------------------
// testCplexParSpecs ()
//
// Tests methods for working with CPLEX parameters specifications.
//------------------------------------------------------------------------------

   private void testCplexParSpecs ()
      {
      Integer simDisplaySpec;
      Double  tilimSpec;

      simDisplaySpec = myProblem.getIntCplexParSpec ("SIMDISPLAY");
      tilimSpec      = myProblem.getDblCplexParSpec ("TILIM");

      assert (simDisplaySpec == null);
      assert (tilimSpec      == null);

      myProblem.addIntCplexParSpec ("SIMDISPLAY", 2);
      myProblem.addDblCplexParSpec ("TILIM",      10.0);

      simDisplaySpec = myProblem.getIntCplexParSpec ("SIMDISPLAY");
      tilimSpec      = myProblem.getDblCplexParSpec ("TILIM");

      assert (simDisplaySpec.   intValue () ==  2);
      assert (tilimSpec     .doubleValue () == 10.0);

      myProblem.clearCplexParSpecs ();

      simDisplaySpec = myProblem.getIntCplexParSpec ("SIMDISPLAY");
      tilimSpec      = myProblem.getDblCplexParSpec ("TILIM");

      assert (simDisplaySpec == null);
      assert (tilimSpec      == null);
      }

//------------------------------------------------------------------------------
// testSortedParts ()
//
// Tests Problem.getSortedParts ().
//
// Builds a separate Problem for this purpose.
//------------------------------------------------------------------------------

   private void testSortedParts ()
      {
      Problem          theProblem;
      List <Part>      unsortedPartList;
      ArrayList <Part> sortedPartList;

      theProblem       = Problem.newInstance ();

      buildProblemForSortTest (theProblem);

      unsortedPartList = theProblem.getParts       ();
      sortedPartList   = theProblem.getSortedParts ();

      println ("");

      println ("Unsorted Parts:\n");

      for (Part thePart: unsortedPartList)
         println ("   " + thePart);

      println ("");

      println ("Sorted Parts:\n");

      for (Part thePart: sortedPartList)
         println ("   " + thePart);

      println ("");

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// testSortedOperations ()
//
// Tests Problem.getSortedOperations ().
//
// Builds a separate Problem for this purpose.
//------------------------------------------------------------------------------

   private void testSortedOperations ()
      {
      Problem               theProblem;
      List <Operation>      unsortedOpnList;
      ArrayList <Operation> sortedOpnList;

      theProblem      = Problem.newInstance ();

      buildProblemForSortTest (theProblem);

      unsortedOpnList = theProblem.getOperations       ();
      sortedOpnList   = theProblem.getSortedOperations ();

      println ("");

      println ("Unsorted Operations:\n");

      for (Operation theOpn: unsortedOpnList)
         println ("   " + theOpn);

      println ("");

      println ("Sorted Operations:\n");

      for (Operation theOpn: sortedOpnList)
         println ("   " + theOpn);

      println ("");

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// buildProblemForSortTest (theProblem)
//
// Populates theProblem for testSortedParts ().
//------------------------------------------------------------------------------

   private void buildProblemForSortTest (Problem theProblem)
      {
      Part      thePartA;
      Part      thePartB;
      Part      thePartC;
      Operation theOpnD;
      Operation theOpnE;

      thePartA = Part     .newInstance (theProblem, "A", MATERIAL);
      thePartB = Part     .newInstance (theProblem, "B", MATERIAL);
      thePartC = Part     .newInstance (theProblem, "C", MATERIAL);

      theOpnD  = Operation.newInstance (theProblem, "D");
      theOpnE  = Operation.newInstance (theProblem, "E");

      BomEntry.newInstance (theOpnD, thePartB);
      BomEntry.newInstance (theOpnE, thePartC);

      BopEntry.newInstance (theOpnD, thePartA);
      BopEntry.newInstance (theOpnE, thePartB);
      }

//------------------------------------------------------------------------------
// testReadData ()
//
// Tests Problem.readData (...).
//------------------------------------------------------------------------------

   private void testReadData ()
      {
      Problem theProblem;
      int     nPeriodsVal;

      theProblem = Problem.newInstance ();

      theProblem.getMessageMgr ().setMesgFileAccessMode ("a");

      theProblem.getMessageMgr ().setMesgFileName ("UnitTester.output");

      theProblem.readData ("diner-utf8.data");

      nPeriodsVal = theProblem.get (nPeriods);

      assert (theProblem.get (nPeriods) == 2);

      println (
         "\n"
       + "The following Components were read in from file "
       + "\"diner-utf8.data\":\n");

      for (Component theComp: theProblem.getComponents ())
         {
         Tester.printlnUTF8 ("   " + theComp);
         }

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// testUnicode ()
//
// Tests WIT-J with an Operation name that has a non-ASCII Unicode character.
//------------------------------------------------------------------------------

   private void testUnicode ()
      {
      Problem   theProblem;
      Operation theOpn;

      theProblem = Problem.newInstance ();

      Operation.newInstance (theProblem, "S\u00e3o Paulo");

      theProblem.writeData ("sao-paulo.data");

      theProblem.deactivate ();

      theProblem = Problem.newInstance ();

      theProblem.readData ("sao-paulo.data");

      theProblem.getMessageMgr ().flushFile ();

      theOpn = theProblem.getOperation ("S\u00e3o Paulo");

      println ();

      Tester.printlnUTF8 ("theOpn.toString (): " + theOpn.toString () + "\n");

      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// assertEq (theVec1, theVec2) methods
//
// Each of these methods asserts that the elements of theVec1 and theVec2 are
// equal.
//------------------------------------------------------------------------------

   private static void assertEq (
         boolean[] theVec1,
         boolean[] theVec2)
      {
      int theIdx;

      assert (theVec1.length == theVec2.length);

      for (theIdx = 0; theIdx < theVec1.length; theIdx ++)
         assert (theVec1[theIdx] == theVec2[theIdx]);
      }

//------------------------------------------------------------------------------

   private static void assertEq (
         int[] theVec1,
         int[] theVec2)
      {
      int theIdx;

      assert (theVec1.length == theVec2.length);

      for (theIdx = 0; theIdx < theVec1.length; theIdx ++)
         assert (theVec1[theIdx] == theVec2[theIdx]);
      }

//------------------------------------------------------------------------------
// assertApproxEq (theDblVec1, theDblVec2)
//
// Asserts that the elements of theDblVec1 and theDblVec2 are nearly equal.
//------------------------------------------------------------------------------

   private static void assertApproxEq (
         double[] theDblVec1,
         double[] theDblVec2)
      {
      int theIdx;

      assert (theDblVec1.length == theDblVec2.length);

      for (theIdx = 0; theIdx < theDblVec1.length; theIdx ++)
         {
         assertApproxEq (theDblVec1[theIdx], theDblVec2[theIdx]);
         }
      }

//------------------------------------------------------------------------------
// assertApproxEq (theDbl1, theDbl2)
//
// Asserts that theDbl1 and theDbl2 are (nearly) equal.
//------------------------------------------------------------------------------

   private static void assertApproxEq (
         double theDbl1,
         double theDbl2)
      {
      assert (StrictMath.abs (theDbl1 - theDbl2) < .0001);
      }

//------------------------------------------------------------------------------
// printList (theList, theListName)
//
// Prints the contents of theList, whose name is given by theListName.
//------------------------------------------------------------------------------

   private static void printList (List <?> theList, String theListName)
      {
      println (
         "\n"
       + theListName + ":");

      for (Object theObject: theList)
         println ("   " + theObject);
      }

//------------------------------------------------------------------------------
// println ()
//
// Wrapper method.
//------------------------------------------------------------------------------

   private static void println ()
      {
      println ("");
      }

//------------------------------------------------------------------------------
// println (theObject)
//
// Wrapper method.
//------------------------------------------------------------------------------

   private static void println (Object theObject)
      {
      System.out.println (theObject);
      }

//------------------------------------------------------------------------------
// asString (theObject)
//------------------------------------------------------------------------------

   private static String asString (Object theObject)
      {
      return theObject.toString ();
      }

//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// WIT-J objects for the unit test.
//------------------------------------------------------------------------------

   private Problem    myProblem;
   private MessageMgr myMessageMgr;
   private Part       myPartA;
   private Part       myPartB;
   private Part       myPartC;
   private Part       myPartG;
   private Demand     myDemandD;
   private Demand     myDemandE;
   private Demand     myDemandH;
   private Operation  myOpnF;
   private BomEntry   myBomEntFA;
   private BomEntry   myBomEntFB1;
   private BomEntry   myBomEntFB2;
   private Substitute mySubFAB;
   private BopEntry   myBopEntFC;
   private BopEntry   myBopEntFG;

//------------------------------------------------------------------------------
// allComponentClasses
//
// Contains the Class object for each subclass of class Component.
//------------------------------------------------------------------------------

   private final List <Class <? extends Component>> allComponentClasses;

//------------------------------------------------------------------------------
// undisplayedAttributes
//
// undisplayedAttributes.contains (theAtt) is true, iff display has not
// been invoked on theAtt.
//------------------------------------------------------------------------------

   private final HashSet <Attribute <?>> undisplayedAttributes;

//------------------------------------------------------------------------------
}
@


1.182
log
@Removed AppObject.
@
text
@d78 1
a78 1
      boolean solverEmbedded;
d123 1
a123 3
      solverEmbedded =
            myProblem.get (coinEmbedded)
         || myProblem.get (cplexEmbedded);
d125 1
a125 2
      if (solverEmbedded)
         {
a126 2
         testCplex                 ();
         }
d141 1
a141 1
      if (solverEmbedded)
a516 2
      display (coinEmbedded);
      display (coinSelected);
a526 1
      display (cplexSelected);
a2496 25
// testCplex ()
//
// Tests optimizing implosion with CPLEX, if appropriate.
//------------------------------------------------------------------------------

   private void testCplex ()
      {
      boolean cplexEmb;
      boolean coinEmb;

      cplexEmb = myProblem.get (cplexEmbedded);
      coinEmb  = myProblem.get (coinEmbedded);

      if (! cplexEmb)
         return;

      myProblem.set (cplexSelected, true);

      myProblem.optImplode ();

      if (coinEmb)
         myProblem.set (coinSelected, true);
      }

//------------------------------------------------------------------------------
@


1.181
log
@Revised tests to accomodate all 4 solver embedded modes.
@
text
@a101 1
      testAppObject                ();
a1649 17
// testAppObject ()
//
// Tests setAppObject and getAppObject.
//------------------------------------------------------------------------------

   private void testAppObject ()
      {
      Object theAppObject;

      myPartA.setAppObject (this);

      theAppObject = myPartA.getAppObject ();

      assert (theAppObject == this);
      }

//------------------------------------------------------------------------------
@


1.180
log
@Removed Pair and Quadruple.
@
text
@d78 2
a120 1
      myProblem.optImplode         ();
d123 11
a133 1
      testCplex                    ();
d146 3
a148 1
      NewsVendor .performTest      ();
d2531 1
d2534 1
d2539 1
a2539 1
       myProblem.set (cplexSelected, true);
d2541 1
a2541 1
       myProblem.optImplode ();
d2543 2
a2544 1
       myProblem.set  (coinSelected, true);
@


1.179
log
@getPgdCritList
@
text
@d1770 4
a1773 2
      Operation                     theOpnI;
      List <Pair <Part, Operation>> theCycle;
d1780 4
a1783 1
      theCycle = myProblem.getExpCycle ();
d1787 1
a1787 1
      for (Pair <Part, Operation> thePair: theCycle)
d1789 2
a1790 2
         println ("   " + thePair.getElement1 ());
         println ("   " + thePair.getElement2 ());
d2174 12
a2185 3
      List <Pair <Part, Integer>> critList;
      Part                        thePart;
      int                         thePer;
d2187 1
a2187 1
      critList = myProblem.getCriticalList ();
d2191 4
a2194 7
      for (Pair <Part, Integer> thePair: critList)
         {
         thePart = thePair.getElement1 ();
         thePer  = thePair.getElement2 ();

         println ("   " + thePart + " in Period "  + thePer);
         }
d2205 10
a2214 5
      List <Quadruple <Part, Integer, Demand, Integer>> pgdCritList;
      Part                                              thePart;
      int                                               critPer;
      Demand                                            theDemand;
      int                                               shipPer;
d2216 18
a2233 1
      pgdCritList = myProblem.getPgdCritList ();
d2238 1
a2238 7
      for (Quadruple <Part, Integer, Demand, Integer> theQuad: pgdCritList)
         {
         thePart   = theQuad.getElement1 ();
         critPer   = theQuad.getElement2 ();
         theDemand = theQuad.getElement3 ();
         shipPer   = theQuad.getElement4 ();

d2240 4
a2243 4
            "   "         + thePart
          + " in Period " + critPer
          + " blocked "   + theDemand
          + " in Period " + shipPer
a2244 1
         }
@


1.178
log
@Pair
@
text
@d2170 2
d2179 4
a2182 3
         println (
            "   "          + thePair.getElement1 ()
          + " in Period "  + thePair.getElement2 ());
d2194 5
a2198 22
      ArrayList <Part>    critPartList;
      ArrayList <Integer> critPeriodList;
      ArrayList <Demand>  theDemandList;
      ArrayList <Integer> shipPeriodList;
      int                 theIdx;

      critPartList   = new ArrayList <Part>    (0);
      critPeriodList = new ArrayList <Integer> (0);
      theDemandList  = new ArrayList <Demand>  (0);
      shipPeriodList = new ArrayList <Integer> (0);

      critPartList  .add (myPartB);
      critPeriodList.add (9);
      theDemandList .add (myDemandE);
      shipPeriodList.add (21);

      critPartList  .add (myPartA);
      critPeriodList.add (12);
      theDemandList .add (myDemandH);
      shipPeriodList.add (14);
         //
         // These should be cleared by getPgdCritList.
d2200 1
a2200 6
      myProblem.
         getPgdCritList (
            critPartList,
            critPeriodList,
            theDemandList,
            shipPeriodList);
d2205 7
a2211 1
      for (theIdx = 0; theIdx < critPartList.size (); theIdx ++)
d2213 4
a2216 4
            "   "         + critPartList  .get (theIdx)
          + " in Period " + critPeriodList.get (theIdx)
          + " blocked "   + theDemandList .get (theIdx)
          + " in Period " + shipPeriodList.get (theIdx)
d2218 1
@


1.177
log
@getExpCycle
@
text
@d1770 2
a1771 2
      Operation                          theOpnI;
      ArrayList <Pair <Part, Operation>> theCycle;
@


1.176
log
@Revised getCriticalList
@
text
@d1770 2
a1771 4
      Operation theOpnI;
      ArrayList <Part>      thePartList;
      ArrayList <Operation> theOpnList;
      int                   theIdx;
d1778 1
a1778 4
      thePartList = new ArrayList <Part>      (0);
      theOpnList  = new ArrayList <Operation> (0);

      myProblem.getExpCycle (thePartList, theOpnList);
d1782 1
a1782 1
      for (theIdx = 0; theIdx < thePartList.size (); theIdx ++)
d1784 2
a1785 2
         println ("   " + thePartList.get (theIdx));
         println ("   " + theOpnList .get (theIdx));
@


1.175
log
@setValue ==> set
getValue ==> get
@
text
@d2174 1
a2174 3
      ArrayList <Part>    critPartList;
      ArrayList <Integer> critPeriodList;
      int                 theIdx;
d2176 1
a2176 10
      critPartList   = new ArrayList <Part>    (0);
      critPeriodList = new ArrayList <Integer> (0);

      critPartList  .add (myPartC);
      critPeriodList.add (17);
      critPeriodList.add (92);
         //
         // These should be cleared by getCriticalList.

      myProblem.getCriticalList (critPartList, critPeriodList);
d2180 2
a2181 1
      for (theIdx = 0; theIdx < critPartList.size (); theIdx ++)
d2183 3
a2185 2
            "   "          + critPartList  .get (theIdx)
          + " in Period "  + critPeriodList.get (theIdx));
@


1.174
log
@Reduced heading comments.
@
text
@d210 1
a210 1
      myProblem.setValue (nPeriods, 3);
d212 1
a212 1
      nPeriodsVal = myProblem.getValue (nPeriods);
d996 1
a996 2
            myProblem.getDefaultValue (theBoolAtt)
         == theComp  .getValue        (theBoolAtt));
d1010 1
a1010 1
         == theComp  .getValue        (theIntAtt));
d1024 1
a1024 1
         theComp  .getValue        (theDblAtt));
d1038 1
a1038 1
         theComp  .getValue        (theStringAtt)));
d1055 1
a1055 1
      assertEq (theBoolVec, theComp.getValue (theBoolVecAtt));
d1072 1
a1072 1
      assertEq (theIntVec, theComp.getValue (theIntVecAtt));
d1089 1
a1089 1
      assertApproxEq (theDblVec, theComp.getValue (theDblVecAtt));
d1117 1
a1117 1
      theComp.getValue   (theBoundSetAtt, hardLBVal, softLBVal, hardUBVal);
d1168 2
a1169 2
      myProblem.setValue (stageByObject, true);
      myProblem.setValue (stochMode,     true);
d1179 3
a1181 3
      myProblem.setValue (stochMode,     false);
      myProblem.setValue (stageByObject, false);
      myProblem.setValue (stochMode,     true);
d1191 1
a1191 1
      myProblem.setValue (stochMode, false);
d1197 1
a1197 2
// Tests Attribute setValue, setVectorToScalar, and getValue methods of class
// Component.
d1214 1
a1214 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// boolean.
d1221 1
a1221 1
      myBopEntFC.setValue (expAllowed, false);
d1223 1
a1223 1
      expAllowedOut = myBopEntFC.getValue (expAllowed);
d1227 1
a1227 1
      myBopEntFC.setValue (expAllowed, true);
d1233 1
a1233 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// int.
d1240 1
a1240 1
      myBopEntFC.setValue (earliestPeriod, 1);
d1242 1
a1242 1
      earliestPeriodOut = myBopEntFC.getValue (earliestPeriod);
d1246 1
a1246 1
      myBopEntFC.setValue (earliestPeriod, 0);
d1252 1
a1252 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// double.
d1259 1
a1259 1
      myOpnF.setValue (execPenalty, 2.0);
d1261 1
a1261 1
      execPenaltyOut = myOpnF.getValue (execPenalty);
d1265 1
a1265 1
      myOpnF.setValue (execPenalty, 0.0);
d1271 1
a1271 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// String.
d1281 1
a1281 1
      myProblem.setValue (title, titleIn);
d1283 1
a1283 1
      titleOut = myProblem.getValue (title);
d1291 2
a1292 2
// Tests Attribute setValue, setVectorToScalar, and getValue methods for
// Attributes of value type boolean[].
d1302 1
a1302 1
      myPartB.setValue (propRtg, propRtgIn);
d1304 1
a1304 1
      propRtgOut = myPartB.getValue (propRtg);
d1312 1
a1312 1
      myPartB.getValue          (propRtg, propRtgOut);
d1322 2
a1323 2
// Tests Attribute setValue, setVectorToScalar, and getValue methods for
// Attributes of value type int[].
d1333 1
a1333 1
      myDemandD.setValue (priority, priorityIn);
d1335 1
a1335 1
      priorityOut = myDemandD.getValue (priority);
d1343 1
a1343 1
      myDemandD.getValue          (priority, priorityOut);
d1353 2
a1354 2
// Tests Attribute setValue, setVectorToScalar, and getValue methods for
// Attributes of value type double[].
d1364 1
a1364 1
      myPartB.setValue (supplyVol, supplyVolIn);
d1366 1
a1366 1
      supplyVolOut = myPartB.getValue (supplyVol);
d1374 1
a1374 1
      myPartB.getValue          (supplyVol, supplyVolOut);
d1410 1
a1410 1
      bomIndexOut = myBomEntFB1.getValue (bomIndex);
d1425 1
a1425 1
      bopIndexOut = myBopEntFC.getValue (bopIndex);
d1440 1
a1440 1
      subIndexOut = mySubFAB.getValue (subIndex);
d1463 1
a1463 1
      myDemandD.getValue (cumShipBounds, hardLBout, softLBout, hardUBout);
d1493 1
a1493 1
      myDemandD.setValue (demandName, demandNameIn);
d1495 1
a1495 1
      demandNameOut = myDemandD.getValue (demandName);
d1499 1
a1499 1
      myDemandD.setValue (demandName, "D");
d1526 2
a1527 2
      myOpnF.setValue (execBounds, null,      softLBin,  null);
      myOpnF.getValue (execBounds, hardLBout, softLBout, hardUBout);
d1549 1
a1549 1
      myOpnF.setValue (operationName, operationNameIn);
d1551 1
a1551 1
      operationNameOut = myOpnF.getValue (operationName);
d1555 1
a1555 1
      myOpnF.setValue (operationName, "F");
d1571 1
a1571 1
      myPartA.setValue (partName, partNameIn);
d1573 1
a1573 1
      partNameOut = myPartA.getValue (partName);
d1577 1
a1577 1
      myPartA.setValue (partName, "A");
d1606 2
a1607 2
      myPartC.setValue (stockBounds, hardLBin,  softLBin,  hardUBin);
      myPartC.getValue (stockBounds, hardLBout, softLBout, hardUBout);
d1613 1
a1613 1
      myPartC.setValue (stockBounds, zeroArr,   null,      null);
d1664 1
a1664 1
      myProblem.setValue (nPeriods, 3);
d1724 1
a1724 1
      theProblem.setValue (nPeriods, 3);
d1795 1
a1795 1
      theOpnI.setValue (selForDel, true);
d1809 12
a1820 12
      myProblem  .setValue (computeCriticalList, true);
      myProblem  .setValue (pgdCritListMode,     true);
      myProblem  .setValue (perfPegging,         true);
      myProblem  .setValue (skipFailures,        false);
      myPartC    .setValue (buildNstn,           true);
      myPartA    .setValue (supplyVol,           new double[] {10, 10, 10});
      myPartB    .setValue (supplyVol,           new double[] {60,  0, 50});
      myDemandD  .setValue (demandVol,           new double[] {20,  0, 30});
      myDemandE  .setValue (demandVol,           new double[] {20, 10, 10});
      myDemandH  .setValue (demandVol,           new double[] {25,  0, 35});
      myBomEntFB2.setValue (consRate,            new double[] { 0,  0,  0});
      myBopEntFG .setValue (expAllowed,          false);
d1856 1
a1856 1
      activeVal = myProblem.getValue (heurAllocActive);
d1864 1
a1864 1
      activeVal = myProblem.getValue (heurAllocActive);
d1898 1
a1898 1
      myProblem.setValue (equitability, 100);
d1911 1
a1911 1
      myProblem.setValue (equitability, 1);
d2278 1
a2278 1
      theProblem.setValue (multiObjMode, true);
d2296 1
a2296 1
      theProblem.setValue (objectiveListSpec, "First|Second|Third|Fourth");
d2298 1
a2298 1
      theSpec = theProblem.getValue (objectiveListSpec);
d2323 1
a2323 1
      theSpec = theProblem.getValue (objectiveListSpec);
d2345 1
a2345 1
      theSpec = theProblem.getValue (objectiveListSpec);
d2358 4
a2361 4
      theProblem.setValue (currentObjective, "B");
      theProblem.setValue (objectiveRank,     3);
      theProblem.setValue (currentObjective, "C");
      theProblem.setValue (objectiveRank,     2);
d2382 1
a2382 1
      theProblem.setValue (currentObjective, theObjName);
d2384 1
a2384 1
      curRank = theProblem.getValue (objectiveRank);
d2417 1
a2417 1
                  theValue = theProblem.getValue (theBoolAtt);
d2519 1
a2519 1
      cplexEmb = myProblem.getValue (cplexEmbedded);
d2524 1
a2524 1
       myProblem.setValue   (cplexSelected, true);
d2528 1
a2528 1
       myProblem.setValue   ( coinSelected, true);
d2658 1
a2658 1
      nPeriodsVal = theProblem.getValue (nPeriods);
d2660 1
a2660 1
      assert (theProblem.getValue (nPeriods) == 2);
@


1.173
log
@Cleared up some of the code that was flagged with warnings by Eclipse.
@
text
@a3 2
//
// Contains the declaration of class UnitTester.
@


1.172
log
@copyComponentData
@
text
@a1626 17
// resetBoundSet (theComp, theAtt)
//
// Sets theAtt to the default value for an Attribute <BoundSet>.
//------------------------------------------------------------------------------

   private void resetBoundSet (Component theComp, Attribute <BoundSet> theAtt)
      {
      double[] zeroArr;
      double[] neg1Arr;

      zeroArr = new double[] { 0.0,  0.0,  0.0};
      neg1Arr = new double[] {-1.0, -1.0, -1.0};

      theComp.setValue (theAtt, zeroArr, zeroArr, neg1Arr);
      }

//------------------------------------------------------------------------------
a2717 13
// printSeparator ()
//------------------------------------------------------------------------------

   private void printSeparator ()
      {
      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         );
      }

//------------------------------------------------------------------------------
a2783 22
// printArray (arrName, theDblArr)
//
// Prints theDblArr with name arrName.
//------------------------------------------------------------------------------

   private static void printArray (String arrName, double[] theDblArr)
      {
      int theIdx;

      println ("\n");

      System.out.print   (arrName + " = [");

      for (theIdx = 0; theIdx < theDblArr.length - 1; theIdx ++)
         {
         System.out.print (theDblArr[theIdx] + ", ");
         }
         
      println (theDblArr[theDblArr.length - 1] + "]");
      }

//------------------------------------------------------------------------------
@


1.171
log
@getSortedOperations
@
text
@d105 1
d238 1
a238 1
      mySubEAB    = Substitute.newInstance (myBomEntFA, myPartB);
d265 1
a265 1
      println (mySubEAB);
d468 4
a471 4
      println ("mySubEAB.getBomEntry (): "
              + mySubEAB.getBomEntry ());
      println ("mySubEAB.getPart     (): "
              + mySubEAB.getPart     ());
d951 1
a951 1
         verifyDefaultValue (theAtt, mySubEAB);
d1448 1
a1448 1
      subIndexOut = mySubEAB.getValue (subIndex);
d1725 63
d2903 1
a2903 1
   private Substitute mySubEAB;
@


1.170
log
@getSortedParts
@
text
@d129 1
d2506 1
a2506 1
      theProblem = Problem.newInstance ();
d2533 40
@


1.169
log
@getExpCycle
@
text
@d128 2
d2492 68
@


1.168
log
@getBelowList
@
text
@d105 1
d1721 38
@


1.167
log
@Critical parts list
@
text
@d105 1
d1743 20
@


1.166
log
@getPgdCritList
@
text
@d2072 2
a2073 2
      ArrayList <Part>    thePartList;
      ArrayList <Integer> thePeriodList;
d2076 2
a2077 2
      thePartList   = new ArrayList <Part>    (0);
      thePeriodList = new ArrayList <Integer> (0);
d2079 3
a2081 3
      thePartList  .add (myPartC);
      thePeriodList.add (17);
      thePeriodList.add (92);
d2085 1
a2085 1
      myProblem.getCriticalList (thePartList, thePeriodList);
d2089 1
a2089 1
      for (theIdx = 0; theIdx < thePartList.size (); theIdx ++)
d2091 2
a2092 2
            "   "          + thePartList  .get (theIdx)
          + " in Period "  + thePeriodList.get (theIdx));
@


1.165
log
@Problem.setObjectiveList
@
text
@d111 1
d1728 11
a1738 11

      myProblem  .setValue (perfPegging,  true);
      myProblem  .setValue (skipFailures, false);
      myPartC    .setValue (buildNstn,    true);
      myPartA    .setValue (supplyVol,    new double[] {10, 10, 10});
      myPartB    .setValue (supplyVol,    new double[] {60,  0, 50});
      myDemandD  .setValue (demandVol,    new double[] {20,  0, 30});
      myDemandE  .setValue (demandVol,    new double[] {20, 10, 10});
      myDemandH  .setValue (demandVol,    new double[] {25,  0, 35});
      myBomEntFB2.setValue (consRate,     new double[] { 0,  0,  0});
      myBopEntFG .setValue (expAllowed,   false);
d2091 52
a2142 4
            "   "
          + thePartList  .get (theIdx)
          + ", "
          + thePeriodList.get (theIdx));
@


1.164
log
@Revised set/get ObjectiveList for ArrayList <String>.
@
text
@d2186 7
a2192 1
      theProblem.setObjectiveList ("A", "B", "C");
@


1.163
log
@Changed name of class AllocTriple to PeggingTriple.
@
text
@d2142 2
a2143 2
      String   theSpec;
      String[] theObjNameArr;
d2151 1
a2151 1
      theObjNameArr = theProblem.getObjectiveList ();
d2153 1
a2153 1
      assert (theObjNameArr.length == 4);
d2155 4
a2158 4
      assert (theObjNameArr[0].equals ("First" ));
      assert (theObjNameArr[1].equals ("Second"));
      assert (theObjNameArr[2].equals ("Third" ));
      assert (theObjNameArr[3].equals ("Fourth"));
d2167 2
a2168 2
      String   theSpec;
      String[] theObjNameArr;
d2176 1
a2176 1
      theObjNameArr = theProblem.getObjectiveList ();
d2178 1
a2178 1
      assert (theObjNameArr.length == 3);
d2180 3
a2182 3
      assert (theObjNameArr[0].equals ("High"  ));
      assert (theObjNameArr[1].equals ("Medium"));
      assert (theObjNameArr[2].equals ("Low"   ));
d2186 1
a2186 3
      theObjNameArr = new String[] {"A", "B", "C"};

      theProblem.setObjectiveList (theObjNameArr);
@


1.162
log
@Replaced setPipSeq with clearPipSeq and appendToPipSeq.
@
text
@d1844 1
a1844 1
      ArrayList <AllocTriple <Demand>> theTripleList;
d1846 1
a1846 1
      theTripleList = new ArrayList <AllocTriple <Demand>> (0);
d1863 1
a1863 1
      for (AllocTriple <Demand> theTriple: theTripleList)
d1885 1
a1885 1
      ArrayList <AllocTriple <Part>> theTripleList;
d1900 1
a1900 1
      ArrayList <AllocTriple <BopEntry>> theTripleList;
d1915 1
a1915 1
      ArrayList <AllocTriple <Operation>> theTripleList;
d1930 1
a1930 1
      ArrayList <AllocTriple <Part>> theTripleList;
d1945 1
a1945 1
      ArrayList <AllocTriple <Part>> theTripleList;
d1960 1
a1960 1
      ArrayList <AllocTriple <Substitute>> theTripleList;
d1975 2
a1976 2
      ArrayList <AllocTriple <Part>> theTripleList;
      double                         supVolPip;
d2015 1
a2015 1
      ArrayList <AllocTriple <Operation>> theTripleList;
d2030 1
a2030 1
      ArrayList <AllocTriple <Substitute>> theTripleList;
d2045 4
a2048 4
         String                      pggTypeName,
         Demand                      theDemand,
         int                         shipPer,
         ArrayList <AllocTriple <C>> theTripleList)
d2059 1
a2059 1
      for (AllocTriple <C> theTriple: theTripleList)
d2298 1
a2298 1
      ArrayList <AllocTriple <Part>> theTripleList;
d2302 1
a2302 1
      for (AllocTriple <Part> theTriple: theTripleList)
d2315 1
a2315 1
         // If no AllocTriple is found matching thePart and supPer, the amount
@


1.161
log
@Revised the arguments to eqHeurAlloc.
@
text
@d1844 1
a1844 25
      AllocTriple <Demand>             theTriple0;
      AllocTriple <Demand>             theTriple1;
      AllocTriple <Demand>             theTriple2;
      AllocTriple <Demand>             theTriple3;
      AllocTriple <Demand>             theTriple4;
      AllocTriple <Demand>             theTriple5;
      ArrayList <AllocTriple <Demand>> theTripleListIn;
      ArrayList <AllocTriple <Demand>> theTripleListOut;

      theTriple0       = AllocTriple.newInstance (myDemandD, 0, 20);
      theTriple1       = AllocTriple.newInstance (myDemandE, 0, 20);
      theTriple2       = AllocTriple.newInstance (myDemandD, 2, 30);
      theTriple3       = AllocTriple.newInstance (myDemandE, 2, 10);
      theTriple4       = AllocTriple.newInstance (myDemandH, 0, 20);
      theTriple5       = AllocTriple.newInstance (myDemandH, 2, 30);

      theTripleListIn  = new ArrayList <AllocTriple <Demand>> (6);
      theTripleListOut = new ArrayList <AllocTriple <Demand>> (0);

      theTripleListIn.add (0, theTriple0);
      theTripleListIn.add (1, theTriple1);
      theTripleListIn.add (2, theTriple2);
      theTripleListIn.add (3, theTriple3);
      theTripleListIn.add (4, theTriple4);
      theTripleListIn.add (5, theTriple5);
d1846 1
a1846 1
      myProblem.setPipSeq (theTripleListIn);
d1848 12
a1859 1
      theTripleListOut = myProblem.getPipSeq ();
d1863 1
a1863 1
      for (AllocTriple <Demand> theTriple: theTripleListOut)
@


1.160
log
@Problem.getCriticalList ()
@
text
@d1777 17
a1793 13
      AllocTriple <Demand>             theTriple0;
      AllocTriple <Demand>             theTriple1;
      ArrayList <AllocTriple <Demand>> theTripleList;
      double[]                         incVolVec;


      theTriple0    = AllocTriple.newInstance (myDemandD, 2, 50);
      theTriple1    = AllocTriple.newInstance (myDemandE, 2, 40);

      theTripleList = new ArrayList <AllocTriple <Demand>> (2);

      theTripleList.add (0, theTriple0);
      theTripleList.add (1, theTriple1);
d1799 6
a1804 1
      incVolVec = myProblem.eqHeurAlloc (theTripleList);
d1810 2
a1811 2
      println ("incVolVec[0] = " + incVolVec[0]);
      println ("incVolVec[1] = " + incVolVec[1]);
d2091 6
@


1.159
log
@Problem.getCriticalList ()
@
text
@d2075 2
a2076 2
      ArrayList <Part>    theParts;
      ArrayList <Integer> thePeriods;
d2079 2
a2080 2
      theParts   = new ArrayList <Part>    (0);
      thePeriods = new ArrayList <Integer> (0);
d2082 1
a2082 1
      myProblem.getCriticalList (theParts, thePeriods);
d2086 1
a2086 1
      for (theIdx = 0; theIdx < theParts.size (); theIdx ++)
d2089 1
a2089 1
          + theParts.get (theIdx)
d2091 1
a2091 1
          + thePeriods.get (theIdx));
@


1.158
log
@Fixed a bug in isValidFor.
@
text
@d110 1
d2068 27
@


1.157
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@d1163 8
a1170 1
      isValid = buildAsap.isValidFor (myPartC);
d1173 14
a1186 2
         //
         // All conditions are satisified.
@


1.156
log
@CPLEX
@
text
@d51 7
a57 7
      allComponentClasses.add (GlobalAspect.class);
      allComponentClasses.add (Part        .class);
      allComponentClasses.add (Demand      .class);
      allComponentClasses.add (Operation   .class);
      allComponentClasses.add (BomEntry    .class);
      allComponentClasses.add (Substitute  .class);
      allComponentClasses.add (BopEntry    .class);
d89 1
a89 1
      setUpGlobalAspect            ();
d195 1
a195 1
// setUpGlobalAspect ().
d197 1
a197 1
// Sets up the GlobalAspect.
d200 1
a200 1
   private void setUpGlobalAspect ()
d204 1
a204 1
      myGlobalAspect = myProblem.getGlobalAspect ();
d206 1
a206 3
      myGlobalAspect.setValue (nPeriods, 3);

      nPeriodsVal    = myGlobalAspect.getValue (nPeriods);
d938 1
a938 1
         verifyDefaultValue (theAtt, myGlobalAspect);
d1155 1
a1155 1
      isValid = objectiveListSpec.isValidFor (myGlobalAspect);
d1262 1
a1262 1
      myGlobalAspect.setValue (title, titleIn);
d1264 1
a1264 1
      titleOut = myGlobalAspect.getValue (title);
d1626 1
a1626 1
      myGlobalAspect.setOptInitMethod (OptInitMethod.CRASH);
d1628 1
a1628 1
      theMethod = myGlobalAspect.getOptInitMethod ();
d1632 1
a1632 1
      myGlobalAspect.setOptInitMethod (OptInitMethod.HEURISTIC);
d1662 1
a1662 1
      myGlobalAspect.setValue (nPeriods, 3);
d1706 1
a1706 1
      myGlobalAspect.setValue (computeCriticalList, true);
d1708 10
a1717 10
      myGlobalAspect.setValue (perfPegging,  true);
      myGlobalAspect.setValue (skipFailures, false);
      myPartC       .setValue (buildNstn,    true);
      myPartA       .setValue (supplyVol,    new double[] {10, 10, 10});
      myPartB       .setValue (supplyVol,    new double[] {60,  0, 50});
      myDemandD     .setValue (demandVol,    new double[] {20,  0, 30});
      myDemandE     .setValue (demandVol,    new double[] {20, 10, 10});
      myDemandH     .setValue (demandVol,    new double[] {25,  0, 35});
      myBomEntFB2   .setValue (consRate,     new double[] { 0,  0,  0});
      myBopEntFG    .setValue (expAllowed,   false);
d1733 1
a1733 1
      activeVal = myGlobalAspect.getValue (heurAllocActive);
d1741 1
a1741 1
      activeVal = myGlobalAspect.getValue (heurAllocActive);
d1771 1
a1771 1
      myGlobalAspect.setValue (equitability, 100);
d1779 1
a1779 1
      myGlobalAspect.setValue (equitability, 1);
d1841 1
a1841 1
      myGlobalAspect.setPipSeq (theTripleListIn);
d1843 1
a1843 1
      theTripleListOut = myGlobalAspect.getPipSeq ();
d2074 1
a2074 2
      Problem      theProblem;
      GlobalAspect theGlobalAspect;
d2076 1
a2076 3
      theProblem      = Problem.newInstance ();

      theGlobalAspect = theProblem.getGlobalAspect ();
d2078 1
a2078 1
      theGlobalAspect.setValue (multiObjMode, true);
d2096 1
a2096 3
      theProblem.
         getGlobalAspect ().
            setValue (objectiveListSpec, "First|Second|Third|Fourth");
d2098 1
a2098 1
      theSpec = theProblem.getGlobalAspect ().getValue (objectiveListSpec);
d2102 1
a2102 1
      theObjNameArr = theProblem.getGlobalAspect ().getObjectiveList ();
d2121 1
a2121 1
      theProblem.getGlobalAspect ().setObjectiveList ("High", "Medium", "Low");
d2123 1
a2123 1
      theSpec = theProblem.getGlobalAspect ().getValue (objectiveListSpec);
d2127 1
a2127 1
      theObjNameArr = theProblem.getGlobalAspect ().getObjectiveList ();
d2139 1
a2139 1
      theProblem.getGlobalAspect ().setObjectiveList (theObjNameArr);
d2141 1
a2141 1
      theSpec = theProblem.getGlobalAspect ().getValue (objectiveListSpec);
d2154 4
a2157 4
      theProblem.getGlobalAspect ().setValue (currentObjective, "B");
      theProblem.getGlobalAspect ().setValue (objectiveRank,     3);
      theProblem.getGlobalAspect ().setValue (currentObjective, "C");
      theProblem.getGlobalAspect ().setValue (objectiveRank,     2);
d2178 1
a2178 1
      theProblem.getGlobalAspect ().setValue (currentObjective, theObjName);
d2180 1
a2180 1
      curRank = theProblem.getGlobalAspect ().getValue (objectiveRank);
d2203 1
a2203 1
         if (theAtt.isValidFor (theProblem.getGlobalAspect ()))
d2213 1
a2213 2
                  theValue =
                     theProblem.getGlobalAspect ().getValue (theBoolAtt);
d2315 1
a2315 1
      cplexEmb = myGlobalAspect.getValue (cplexEmbedded);
d2320 1
a2320 1
       myGlobalAspect.setValue   (cplexSelected, true);
d2322 1
a2322 1
       myProblem     .optImplode ();
d2324 1
a2324 1
       myGlobalAspect.setValue   ( coinSelected, true);
d2346 1
a2346 1
      nPeriodsVal = theProblem.getGlobalAspect ().getValue (nPeriods);
d2348 1
a2348 1
      assert (theProblem.getGlobalAspect ().getValue (nPeriods) == 2);
d2553 16
a2568 17
   private Problem      myProblem;
   private MessageMgr   myMessageMgr;
   private GlobalAspect myGlobalAspect;
   private Part         myPartA;
   private Part         myPartB;
   private Part         myPartC;
   private Part         myPartG;
   private Demand       myDemandD;
   private Demand       myDemandE;
   private Demand       myDemandH;
   private Operation    myOpnF;
   private BomEntry     myBomEntFA;
   private BomEntry     myBomEntFB1;
   private BomEntry     myBomEntFB2;
   private Substitute   mySubEAB;
   private BopEntry     myBopEntFC;
   private BopEntry     myBopEntFG;
@


1.155
log
@CPLEX
@
text
@d2303 8
@


1.154
log
@CPLEX
@
text
@d2287 1
d2290 1
d2293 1
d2299 1
d2301 2
a2302 1
      assert (simDisplaySpec.intValue () == 2);
@


1.153
log
@CPLEX
@
text
@d2286 6
d2294 4
@


1.152
log
@CPLEX
@
text
@d513 2
a514 1
      display (cplexObjBound);
@


1.151
log
@CPLEX
@
text
@d118 1
d2278 12
@


1.150
log
@CPLEX
@
text
@d512 4
d517 2
d728 3
a730 1
            myProblem.getDefaultValue (theAtt.asAttribute (String.class));
@


1.149
log
@Modifiable Heuristic Allocation
@
text
@d118 1
d505 2
d511 2
d2269 22
@


1.148
log
@Lead Time Bounds
@
text
@d554 1
@


1.147
log
@Selection Recovery
@
text
@d499 1
d546 1
@


1.146
log
@Multi-Obj Mode
@
text
@d598 1
@


1.145
log
@Multi-Obj Mode
@
text
@d560 1
d900 1
@


1.144
log
@Multi-Obj Mode
@
text
@d568 1
a897 1
            currentObjective,
d2066 1
d2133 39
@


1.143
log
@Multi-Obj Mode
@
text
@a2056 2
      String       theSpec;
      String[]     theObjNameArr;
d2064 14
a2077 1
      //------------------------------------------------------------------------
d2079 3
a2081 1
      theGlobalAspect.setValue (objectiveListSpec, "First|Second|Third|Fourth");
d2083 1
a2083 1
      theSpec       = theGlobalAspect.getValue (objectiveListSpec);
d2087 1
a2087 1
      theObjNameArr = theGlobalAspect.getObjectiveList ();
d2095 1
d2097 8
a2104 1
      //------------------------------------------------------------------------
d2106 1
a2106 1
      theGlobalAspect.setObjectiveList ("High", "Medium", "Low");
d2108 1
a2108 1
      theSpec = theGlobalAspect.getValue (objectiveListSpec);
d2112 1
a2112 1
      theObjNameArr = theGlobalAspect.getObjectiveList ();
d2122 1
a2122 1
      theObjNameArr = new String[] {"One", "Two", "Three"};
d2124 1
a2124 1
      theGlobalAspect.setObjectiveList (theObjNameArr);
d2126 1
a2126 1
      theSpec = theGlobalAspect.getValue (objectiveListSpec);
d2128 1
a2128 5
      assert (theSpec.equals ("One|Two|Three"));

      //------------------------------------------------------------------------

      theProblem.deactivate ();
@


1.142
log
@Multi-Obj Mode
@
text
@d509 1
d887 3
d894 15
d914 1
a914 16
         if (theAtt == currentScenario)
            continue;

         if (theAtt == nPeriods)
            continue;

         if (theAtt == objectStage)
            continue;

         if (theAtt == periodStage)
            continue;

         if (theAtt == probability)
            continue;

         if (theAtt == objectiveListSpec)
@


1.141
log
@Multi-Obj Mode.
@
text
@d2097 10
@


1.140
log
@Multi-Obj Mode
@
text
@d2054 1
d2066 1
a2066 1
      theSpec = theGlobalAspect.getValue (objectiveListSpec);
d2070 9
d2087 8
@


1.139
log
@Multi-Obj Mode
@
text
@d2061 11
a2071 1
      theGlobalAspect.setValue (objectiveListSpec, "High|Medium|Low");
d2077 2
@


1.138
log
@Implemented String StdAttImps.
@
text
@d1106 2
d1114 2
d1122 2
d1130 10
@


1.137
log
@Multi-Obj Mode
@
text
@d1143 1
d1210 21
d1331 9
a1339 11
      testBomIndex          ();
      testBopIndex          ();
      testCumShipBounds     ();
      testDemandName        ();
      testExecBounds        ();
      testOperationName     ();
      testPartName          ();
      testSolverLogFileName ();
      testStockBounds       ();
      testSubIndex          ();
      testTitle             ();
a1522 20
// testSolverLogFileName ()
//
// Tests the "solverLogFileName" Attribute.
//------------------------------------------------------------------------------

   private void testSolverLogFileName ()
      {
      String solverLogFileNameIn;
      String solverLogFileNameOut;

      solverLogFileNameIn  = "wit-j.test.solver.log";

      myGlobalAspect.setValue (solverLogFileName, solverLogFileNameIn);

      solverLogFileNameOut = myGlobalAspect.getValue (solverLogFileName);

      assert (solverLogFileNameOut.equals (solverLogFileNameIn));
      }

//------------------------------------------------------------------------------
a1577 20
// testTitle ()
//
// Tests the "title" Attribute.
//------------------------------------------------------------------------------

   private void testTitle ()
      {
      String titleIn;
      String titleOut;

      titleIn  = "WIT-J Test Problem";

      myGlobalAspect.setValue (title, titleIn);

      titleOut = myGlobalAspect.getValue (title);

      assert (titleOut.equals (titleIn));
      }

//------------------------------------------------------------------------------
@


1.136
log
@Multi-Obj Mode
@
text
@d566 1
d910 3
d2055 11
a2065 1
      Problem theProblem;
d2067 1
a2067 1
      theProblem = Problem.newInstance ();
d2069 1
a2069 1
      theProblem.getGlobalAspect ().setValue (multiObjMode, true);
@


1.135
log
@Multi-Obj Mode.
@
text
@d111 1
d2025 2
d2044 17
@


1.134
log
@Minor revision.
@
text
@d557 1
d2045 1
a2045 1
// and actual value are displayed.
d2058 1
a2058 1
         if (theAtt.appliesTo (GlobalAspect.class))
d2064 1
a2064 1
               if (theAtt.isValidFor (theProblem.getGlobalAspect ()))
d2066 1
a2066 3
                  if (theBoolAtt.hasDefaultValue ())
                     {
                     defValue = theProblem .getDefaultValue (theBoolAtt);
d2068 2
a2069 2
                     theValue =
                        theProblem.getGlobalAspect ().getValue (theBoolAtt);
d2071 12
a2082 13
                     if (theValue != defValue)
                        {
                        System.out.printf (
                           "%n"
                         + "Non-default global boolean Attribute found.%n"
                         + "%n"
                         + "   Attribute:     %s%n"
                         + "   Default Value: %s%n"
                         + "   Actual  Value: %s%n",
                           theBoolAtt.toString (),
                           defValue,
                           theValue);
                        }
@


1.133
log
@Replaced Attribute methods requiresStochMode and requiresMaterialPart
with isValidFor.
@
text
@d2042 3
a2044 5
// For each global boolean Attribute:
// * If the Attribute is not currently valid for the GlobalAspect of
//   theProblem, it is displayed as such.
// * If the Attribute is valid but not at its default value in theProblem, the
//   Attribute, the default value and and actual value are displayed.
d2063 1
a2063 1
               if (! theAtt.isValidFor (theProblem.getGlobalAspect ()))
d2065 3
a2067 9
                  System.out.printf (
                     "%n"
                   + "Currently invalid global boolean Attribute found.%n"
                   + "%n"
                   + "   Attribute:     %s%n",
                     theBoolAtt.toString ());

                  continue;
                  }
d2069 2
a2070 6
               if (theBoolAtt.hasDefaultValue ())
                  {
                  defValue = theProblem .getDefaultValue (theBoolAtt);

                  theValue =
                     theProblem.getGlobalAspect ().getValue (theBoolAtt);
d2072 13
a2084 12
                  if (theValue != defValue)
                     {
                     System.out.printf (
                        "%n"
                      + "Non-default global boolean Attribute found.%n"
                      + "%n"
                      + "   Attribute:     %s%n"
                      + "   Default Value: %s%n"
                      + "   Actual  Value: %s%n",
                        theBoolAtt.toString (),
                        defValue,
                        theValue);
@


1.132
log
@Changed the extensions of test output files from out to output.
@
text
@d98 1
a670 6
      if (theAtt.requiresMaterialPart ())
         println ("      Requires:   Material Part");

      if (theAtt.requiresStochMode ())
         println ("      Requires:   Stochastic Mode");

d1091 35
d2042 5
a2046 4
// For each global boolean Attribute, if the Attribute is not at its default
// value in theProblem, the Attribute, the default value and and actual value
// are displayed.
// Attributes that require stochastic mode are skipped.
a2058 3
         if (theAtt.requiresStochMode ())
            continue;

d2065 12
d2088 1
a2088 1
                      + "Non-Default Global Boolean Attribute Found.%n"
@


1.131
log
@Added the thread test as a separate test.
@
text
@d150 1
a150 1
      myMessageMgr.setMesgFileName ("UnitTester.out");
d163 1
a163 1
      myMessageMgr.setMesgFileName ("UnitTester.out");
d167 1
a167 1
      assert (theName.equals ("UnitTester.out"));
d1626 1
a1626 1
      cpyProblem.getMessageMgr ().setMesgFileName ("copyData.out");
d2114 1
a2114 1
      theProblem.getMessageMgr ().setMesgFileName ("UnitTester.out");
@


1.130
log
@Implemented test of getThread.
@
text
@d124 2
a125 3
      PurgeTester .performTest     ();
      ThreadTester.performTest     ();
      NewsVendor  .performTest     ();
@


1.129
log
@Removed Problem.getActiveProblems ().
@
text
@d258 2
@


1.128
log
@Initial implementation of class ThreadTester.
@
text
@a110 1
      testActiveProblems           ();
a2098 30
// testActiveProblems ()
//
// Tests Problem.getActiveProblems ().
//------------------------------------------------------------------------------

   private void testActiveProblems ()
      {
      Set <Problem> theActiveProblems;
      Problem       theProblem;

      theProblem        = Problem.newInstance ();

      theActiveProblems = Problem.getActiveProblems ();

      assert (  theActiveProblems.size () == 2);

      assert (  theActiveProblems.contains  (myProblem));
      assert (  theActiveProblems.contains (theProblem));

      theProblem.deactivate ();

      theActiveProblems = Problem.getActiveProblems ();

      assert (  theActiveProblems.size () == 1);

      assert (  theActiveProblems.contains  (myProblem));
      assert (! theActiveProblems.contains (theProblem));
      }

//------------------------------------------------------------------------------
@


1.127
log
@Moved active Set from class Problem to class Coordinator.
@
text
@d125 3
a127 2
      PurgeTester.performTest      ();
      NewsVendor .performTest      ();
@


1.126
log
@Moved the UTF-8 logic to a special print method and re-used it.
@
text
@d2109 2
a2112 6
      assert (  theActiveProblems.size () == 1);

      assert (  theActiveProblems.contains  (myProblem));

      theProblem = Problem.newInstance ();

d2120 2
@


1.125
log
@Trying FileDescriptor.out.
@
text
@a14 1
import                java.io.*;
d2160 1
a2160 1
         println ("   " + theComp);
d2195 1
a2195 21
      try
         {
         FileOutputStream   theOutStream;
         OutputStreamWriter theUTF8Writer;

         theOutStream  = new FileOutputStream (FileDescriptor.out);

         theUTF8Writer = new OutputStreamWriter (theOutStream, "UTF-8");

         theUTF8Writer.
            write ("theOpn.toString (): " + theOpn.toString () + "\n");

         theUTF8Writer.flush ();
         }

      catch (IOException theExc)
         {
         theExc.printStackTrace ();

         System.exit (4);
         }
@


1.124
log
@Tried writing UTF-8 to a file.
@
text
@d2194 2
d2198 1
a2198 1
         FileOutputStream   theUTF8Stream;
d2201 1
a2201 1
         theUTF8Stream = new FileOutputStream ("unit-test.utf8");
d2203 1
a2203 1
         theUTF8Writer = new OutputStreamWriter (theUTF8Stream, "UTF-8");
d2205 2
a2206 1
         theUTF8Writer.write (theOpn.toString () + "\n");
d2208 1
a2208 1
         theUTF8Writer.close ();
@


1.123
log
@Tried a new way to print in UTF-8.
@
text
@a2193 2
      println ();

d2196 1
d2199 3
a2201 1
         theUTF8Writer = new OutputStreamWriter (System.out, "UTF-8");
d2205 1
a2205 1
         theUTF8Writer.flush ();
@


1.122
log
@Simplified the printing of a non-ASCII character.
@
text
@d15 1
a15 1
import                java.nio.charset.*;
a2176 2
      Charset   theUFT8Charset;
      byte[]    theBuffer;
d2196 5
a2200 1
      theUFT8Charset = Charset.forName ("UTF-8");
d2202 1
a2202 1
      theBuffer      = theOpn.toString ().getBytes (theUFT8Charset);
d2204 2
a2205 1
      System.out.write (theBuffer, 0, theBuffer.length);
d2207 6
a2212 1
      println ();
@


1.121
log
@Made the Unit Test print the Sao Paulo Operation name in UTF-8 format.
@
text
@d15 1
d2177 2
d2198 1
a2198 8
      try
         {
         byte[] theBuffer;

         theBuffer = theOpn.toString ().getBytes ("UTF-8");

         System.out.write (theBuffer, 0, theBuffer.length);
         }
d2200 1
a2200 3
      catch (java.io.UnsupportedEncodingException theExc)
         {
         theExc.printStackTrace ();
d2202 1
a2202 2
         System.exit (4);
         }
@


1.120
log
@Replaced UTF-8 characters with explicit Unicode.
@
text
@d2189 2
d2193 19
a2211 1
      println ("\n" + theOpn);
@


1.119
log
@Replaced "SubComponent" with "Root".
@
text
@d123 1
a123 1
      testUTF8                     ();
d2167 1
a2167 1
// testUTF8 ()
d2169 1
a2169 1
// Tests operation names with UTF8 characters.
d2172 1
a2172 1
   private void testUTF8 ()
d2179 1
a2179 1
      Operation.newInstance (theProblem, "São Paulo");
d2189 1
a2189 1
      theOpn = theProblem.getOperation ("São Paulo");
@


1.118
log
@Removed the "place element request" capability.
@
text
@d1795 1
a1795 1
          + theTriple.getSubComponent ()
d1968 1
a1968 1
// Prints the pegging for theDemand D in shipPer given in theTripleList
d1972 1
a1972 1
   private <S extends Component> void printPegging (
d1976 1
a1976 1
         ArrayList <AllocTriple <S>> theTripleList)
d1987 1
a1987 1
      for (AllocTriple <S> theTriple: theTripleList)
d2083 1
a2083 1
         if (theTriple.getSubComponent () == thePart)
@


1.117
log
@Changed name of appData to appObject.
@
text
@a98 1
      testSetElementsByRequest     ();
a1264 59
// testSetElementsByRequest ()
//
// Tests:
//    theComp   .placeVectorElementRequest (...)
//    theComp   .placeHardLBElementRequest (...)
//    theComp   .placeSoftLBElementRequest (...)
//    theComp   .placeHardUBElementRequest (...)
//    theProblem.fulfillElementRequests    ()
//------------------------------------------------------------------------------

   private void testSetElementsByRequest ()
      {
      double[] zeroArr;
      double[] neg1Arr;

      zeroArr = new double[]{ 0,  0,  0};
      neg1Arr = new double[]{-1, -1, -1};

      myPartA   .setVectorToScalar         (supplyVol,        91);
      myBomEntFA.setVectorToScalar         (offset,           -1);

      myPartA   .placeVectorElementRequest (supplyVol,     1, 17);
      myPartA   .placeVectorElementRequest (propRtg,       2,  true);
      myPartB   .placeVectorElementRequest (supplyVol,     1, 43);
      myBomEntFA.placeVectorElementRequest (offset,        2,  1);
      myBopEntFG.placeVectorElementRequest (offset,        0,  2);
      myDemandD .placeVectorElementRequest (priority,      1, 59);
      myPartA   .placeVectorElementRequest (supplyVol,     1, 82);
      myPartA   .placeVectorElementRequest (supplyVol,     0, 35);

      myDemandD .placeHardLBElementRequest (cumShipBounds, 2, 10);
      myDemandD .placeSoftLBElementRequest (cumShipBounds, 2, 20);
      myDemandD .placeHardUBElementRequest (cumShipBounds, 2, 50);
      myDemandD .placeHardLBElementRequest (cumShipBounds, 2, 15);
      myOpnF    .placeHardUBElementRequest (execBounds,    1, 34);
      myDemandH .placeHardUBElementRequest (cumShipBounds, 2, 47);

      myProblem .fulfillElementRequests    ();
      myProblem .fulfillElementRequests    ();

      myPartA   .setVectorToScalar         (supplyVol,        0);
      myPartB   .setVectorToScalar         (supplyVol,        0);
      myPartA   .setVectorToScalar         (propRtg,          false);
      myBomEntFA.setVectorToScalar         (offset,           0);
      myBopEntFG.setVectorToScalar         (offset,           0);
      myDemandD .setVectorToScalar         (priority,         0);

      myDemandD .setValue                  (cumShipBounds,    zeroArr,
                                                                 zeroArr,
                                                                 neg1Arr);
      myDemandH .setValue                  (cumShipBounds,    zeroArr,
                                                                 zeroArr,
                                                                 neg1Arr);
      myOpnF    .setValue                  (execBounds,       zeroArr,
                                                                 zeroArr,
                                                                 neg1Arr);
      }

//------------------------------------------------------------------------------
@


1.116
log
@Removed the hashCode from class Attribute <V>.
@
text
@d102 1
a102 1
      testAppData                  ();
d1640 1
a1640 1
// testAppData ()
d1642 1
a1642 1
// Tests setAppData and getAppData.
d1645 1
a1645 1
   private void testAppData ()
d1647 1
a1647 1
      Object theAppData;
d1649 1
a1649 1
      myPartA.setAppData (this);
d1651 1
a1651 1
      theAppData = myPartA.getAppData ();
d1653 1
a1653 1
      assert (theAppData == this);
@


1.115
log
@Changed a generic type parameter.
@
text
@d60 1
a60 1
         new HashSet <Attribute <?>> (getAttributes ().size (), 1.0f);
@


1.114
log
@Replaced public accessor methods for the Attributes with piublic fields.
@
text
@d2032 1
a2032 1
   private <C extends Component> void printPegging (
d2036 1
a2036 1
         ArrayList <AllocTriple <C>> theTripleList)
d2047 1
a2047 1
      for (AllocTriple <C> theTriple: theTripleList)
@


1.113
log
@Implemented the null string convention for file names.
@
text
@d204 1
a204 1
      myGlobalAspect.setValue (nPeriods (), 3);
d206 1
a206 1
      nPeriodsVal    = myGlobalAspect.getValue (nPeriods ());
d490 129
a618 129
      display (accAfterOptImp      ());
      display (accAfterSoftLB      ());
      display (accelerated         ());
      display (asapPipOrder        ());
      display (autoPriority        ());
      display (bomIndex            ());
      display (bopIndex            ());
      display (boundsValue         ());
      display (buildAheadUB        ());
      display (buildAsap           ());
      display (buildNstn           ());
      display (compPrices          ());
      display (computeCriticalList ());
      display (consRate            ());
      display (consVol             ());
      display (cumShipBounds       ());
      display (cumShipReward       ());
      display (currentScenario     ());
      display (demandName          ());
      display (demandVol           ());
      display (earliestPeriod      ());
      display (equitability        ());
      display (excessVol           ());
      display (execBounds          ());
      display (execCost            ());
      display (execEmptyBom        ());
      display (execPenalty         ());
      display (execVol             ());
      display (executable          ());
      display (expAllowed          ());
      display (expAversion         ());
      display (expCutoff           ());
      display (expNetAversion      ());
      display (extOptActive        ());
      display (falloutRate         ());
      display (feasible            ());
      display (focusHorizon        ());
      display (focusShortageVol    ());
      display (forcedMultiEq       ());
      display (fssExecVol          ());
      display (fssShipVol          ());
      display (fssSubVol           ());
      display (heurAllocActive     ());
      display (highPrecisionWD     ());
      display (impactPeriod        ());
      display (incLotSize          ());
      display (incLotSize2         ());
      display (independentOffsets  ());
      display (intExecVols         ());
      display (intShipVols         ());
      display (intSubVols          ());
      display (latestPeriod        ());
      display (lotSize2Thresh      ());
      display (lotSizeTol          ());
      display (mandEC              ());
      display (minLotSize          ());
      display (minLotSize2         ());
      display (minimalExcess       ());
      display (mipMode             ());
      display (mrpConsVol          ());
      display (mrpExcessVol        ());
      display (mrpExecVol          ());
      display (mrpNetAllowed       ());
      display (mrpResidualVol      ());
      display (mrpSubVol           ());
      display (multiExec           ());
      display (multiRoute          ());
      display (nPeriods            ());
      display (nScenarios          ());
      display (netAllowed          ());
      display (nstnResidual        ());
      display (objValue            ());
      display (objectStage         ());
      display (offset              ());
      display (operationName       ());
      display (partName            ());
      display (penExec             ());
      display (perfPegging         ());
      display (periodStage         ());
      display (pgdCritListMode     ());
      display (pipExists           ());
      display (pipSeqFromHeur      ());
      display (postprocessed       ());
      display (prefHighStockSLBs   ());
      display (preprocessed        ());
      display (priority            ());
      display (probability         ());
      display (prodVol             ());
      display (productRate         ());
      display (propRtg             ());
      display (reqVol              ());
      display (residualVol         ());
      display (respectStockSLBs    ());
      display (roundReqVols        ());
      display (routingShare        ());
      display (scrapAllowed        ());
      display (scrapCost           ());
      display (scrapVol            ());
      display (searchInc           ());
      display (selForDel           ());
      display (selSplit            ());
      display (shadowPrice         ());
      display (shipLateAllowed     ());
      display (shipLateUB          ());
      display (shipReward          ());
      display (shipVol             ());
      display (singleSource        ());
      display (skipFailures        ());
      display (solverLogFileName   ());
      display (stageByObject       ());
      display (stochMode           ());
      display (stochSolnMode       ());
      display (stockBounds         ());
      display (stockCost           ());
      display (stockReallocation   ());
      display (stockVol            ());
      display (subCost             ());
      display (subIndex            ());
      display (subVol              ());
      display (supplyVol           ());
      display (tieBreakPropRt      ());
      display (title               ());
      display (truncOffsets        ());
      display (twoLevelLotSizes    ());
      display (twoWayMultiExec     ());
      display (useFocusHorizons    ());
      display (userHeurStart       ());
      display (wbounds             ());
      display (yieldRate           ());
d897 1
a897 1
         if (theAtt == currentScenario ())
d900 1
a900 1
         if (theAtt == nPeriods ())
d903 1
a903 1
         if (theAtt == objectStage ())
d906 1
a906 1
         if (theAtt == periodStage ())
d909 1
a909 1
         if (theAtt == probability ())
d1123 1
a1123 1
      myBopEntFC.setValue (expAllowed (), false);
d1125 1
a1125 1
      expAllowedOut = myBopEntFC.getValue (expAllowed ());
d1129 1
a1129 1
      myBopEntFC.setValue (expAllowed (), true);
d1143 1
a1143 1
      myBopEntFC.setValue (earliestPeriod (), 1);
d1145 1
a1145 1
      earliestPeriodOut = myBopEntFC.getValue (earliestPeriod ());
d1149 1
a1149 1
      myBopEntFC.setValue (earliestPeriod (), 0);
d1163 1
a1163 1
      myOpnF.setValue (execPenalty (), 2.0);
d1165 1
a1165 1
      execPenaltyOut = myOpnF.getValue (execPenalty ());
d1169 1
a1169 1
      myOpnF.setValue (execPenalty (), 0.0);
d1186 1
a1186 1
      myPartB.setValue (propRtg (), propRtgIn);
d1188 1
a1188 1
      propRtgOut = myPartB.getValue (propRtg ());
d1194 1
a1194 1
      myPartB.setVectorToScalar (propRtg (), true);
d1196 1
a1196 1
      myPartB.getValue          (propRtg (), propRtgOut);
d1200 1
a1200 1
      myPartB.setVectorToScalar (propRtg (), false);
d1217 1
a1217 1
      myDemandD.setValue (priority (), priorityIn);
d1219 1
a1219 1
      priorityOut = myDemandD.getValue (priority ());
d1225 1
a1225 1
      myDemandD.setVectorToScalar (priority (), 6);
d1227 1
a1227 1
      myDemandD.getValue          (priority (), priorityOut);
d1231 1
a1231 1
      myDemandD.setVectorToScalar (priority (), 0);
d1248 1
a1248 1
      myPartB.setValue (supplyVol (), supplyVolIn);
d1250 1
a1250 1
      supplyVolOut = myPartB.getValue (supplyVol ());
d1256 1
a1256 1
      myPartB.setVectorToScalar (supplyVol (), 20);
d1258 1
a1258 1
      myPartB.getValue          (supplyVol (), supplyVolOut);
d1262 1
a1262 1
      myPartB.setVectorToScalar (supplyVol (), 0);
d1284 2
a1285 2
      myPartA   .setVectorToScalar         (supplyVol     (),    91);
      myBomEntFA.setVectorToScalar         (offset        (),    -1);
d1287 15
a1301 15
      myPartA   .placeVectorElementRequest (supplyVol     (), 1, 17);
      myPartA   .placeVectorElementRequest (propRtg       (), 2,  true);
      myPartB   .placeVectorElementRequest (supplyVol     (), 1, 43);
      myBomEntFA.placeVectorElementRequest (offset        (), 2,  1);
      myBopEntFG.placeVectorElementRequest (offset        (), 0,  2);
      myDemandD .placeVectorElementRequest (priority      (), 1, 59);
      myPartA   .placeVectorElementRequest (supplyVol     (), 1, 82);
      myPartA   .placeVectorElementRequest (supplyVol     (), 0, 35);

      myDemandD .placeHardLBElementRequest (cumShipBounds (), 2, 10);
      myDemandD .placeSoftLBElementRequest (cumShipBounds (), 2, 20);
      myDemandD .placeHardUBElementRequest (cumShipBounds (), 2, 50);
      myDemandD .placeHardLBElementRequest (cumShipBounds (), 2, 15);
      myOpnF    .placeHardUBElementRequest (execBounds    (), 1, 34);
      myDemandH .placeHardUBElementRequest (cumShipBounds (), 2, 47);
d1306 6
a1311 6
      myPartA   .setVectorToScalar         (supplyVol     (),    0);
      myPartB   .setVectorToScalar         (supplyVol     (),    0);
      myPartA   .setVectorToScalar         (propRtg       (),    false);
      myBomEntFA.setVectorToScalar         (offset        (),    0);
      myBopEntFG.setVectorToScalar         (offset        (),    0);
      myDemandD .setVectorToScalar         (priority      (),    0);
d1313 1
a1313 1
      myDemandD .setValue                  (cumShipBounds (),    zeroArr,
d1316 1
a1316 1
      myDemandH .setValue                  (cumShipBounds (),    zeroArr,
d1319 1
a1319 1
      myOpnF    .setValue                  (execBounds    (),    zeroArr,
d1355 1
a1355 1
      bomIndexOut = myBomEntFB1.getValue (bomIndex ());
d1370 1
a1370 1
      bopIndexOut = myBopEntFC.getValue (bopIndex ());
d1385 1
a1385 1
      subIndexOut = mySubEAB.getValue (subIndex ());
d1402 1
a1402 1
      myDemandD.setBoundSetToScalars (cumShipBounds (), 210, 240, 270);
d1408 1
a1408 1
      myDemandD.getValue (cumShipBounds (), hardLBout, softLBout, hardUBout);
d1422 1
a1422 1
      myDemandD.setBoundSetToScalars (cumShipBounds (), 0, 0, -1);
d1438 1
a1438 1
      myDemandD.setValue (demandName (), demandNameIn);
d1440 1
a1440 1
      demandNameOut = myDemandD.getValue (demandName ());
d1444 1
a1444 1
      myDemandD.setValue (demandName (), "D");
d1471 2
a1472 2
      myOpnF.setValue (execBounds (), null,      softLBin,  null);
      myOpnF.getValue (execBounds (), hardLBout, softLBout, hardUBout);
d1478 1
a1478 1
      myOpnF.setBoundSetToScalars (execBounds (), 0, 0, -1);
d1494 1
a1494 1
      myOpnF.setValue (operationName (), operationNameIn);
d1496 1
a1496 1
      operationNameOut = myOpnF.getValue (operationName ());
d1500 1
a1500 1
      myOpnF.setValue (operationName (), "F");
d1516 1
a1516 1
      myPartA.setValue (partName (), partNameIn);
d1518 1
a1518 1
      partNameOut = myPartA.getValue (partName ());
d1522 1
a1522 1
      myPartA.setValue (partName (), "A");
d1538 1
a1538 1
      myGlobalAspect.setValue (solverLogFileName (), solverLogFileNameIn);
d1540 1
a1540 1
      solverLogFileNameOut = myGlobalAspect.getValue (solverLogFileName ());
d1571 2
a1572 2
      myPartC.setValue (stockBounds (), hardLBin,  softLBin,  hardUBin);
      myPartC.getValue (stockBounds (), hardLBout, softLBout, hardUBout);
d1578 1
a1578 1
      myPartC.setValue (stockBounds (), zeroArr,   null,      null);
d1580 1
a1580 1
      myPartC.setBoundSetToScalars (stockBounds (), 0, 0, -1);
d1613 1
a1613 1
      myGlobalAspect.setValue (title (), titleIn);
d1615 1
a1615 1
      titleOut = myGlobalAspect.getValue (title ());
d1666 1
a1666 1
      myGlobalAspect.setValue (nPeriods (), 3);
d1710 1
a1710 1
      myGlobalAspect.setValue (computeCriticalList (), true);
d1712 10
a1721 10
      myGlobalAspect.setValue (perfPegging  (), true);
      myGlobalAspect.setValue (skipFailures (), false);
      myPartC       .setValue (buildNstn    (), true);
      myPartA       .setValue (supplyVol    (), new double[] {10, 10, 10});
      myPartB       .setValue (supplyVol    (), new double[] {60,  0, 50});
      myDemandD     .setValue (demandVol    (), new double[] {20,  0, 30});
      myDemandE     .setValue (demandVol    (), new double[] {20, 10, 10});
      myDemandH     .setValue (demandVol    (), new double[] {25,  0, 35});
      myBomEntFB2   .setValue (consRate     (), new double[] { 0,  0,  0});
      myBopEntFG    .setValue (expAllowed   (), false);
d1737 1
a1737 1
      activeVal = myGlobalAspect.getValue (heurAllocActive ());
d1745 1
a1745 1
      activeVal = myGlobalAspect.getValue (heurAllocActive ());
d1775 1
a1775 1
      myGlobalAspect.setValue (equitability (), 100);
d1783 1
a1783 1
      myGlobalAspect.setValue (equitability (), 1);
d2209 1
a2209 1
      nPeriodsVal = theProblem.getGlobalAspect ().getValue (nPeriods ());
d2211 1
a2211 1
      assert (theProblem.getGlobalAspect ().getValue (nPeriods ()) == 2);
@


1.112
log
@Implemented file name of "stdout" for stdout.
@
text
@d2060 1
@


1.111
log
@Made a null string argument to setMesgFileName interpreted as stdout.
@
text
@d159 1
a159 1
      myMessageMgr.setMesgFileName ("");
@


1.110
log
@Changed getCInstance () to getSubComponent ().
@
text
@d159 8
@


1.109
log
@Made methods that retrieve an ArrayList <AllocTriple>> return it instead.
@
text
@d1847 1
a1847 1
          + theTriple.getCInstance ()
d2134 1
a2134 1
         if (theTriple.getCInstance () == thePart)
@


1.108
log
@Added method getSpecificSupplyVolPip to UnitTester.
@
text
@d1838 2
a1839 1
      myGlobalAspect.getPipSeq (theTripleListOut);
d1867 1
a1867 3
      theTripleList = new ArrayList <AllocTriple <Part>> (0);

      myDemandD.getConsVolPip (2, theTripleList);
d1882 1
a1882 3
      theTripleList = new ArrayList <AllocTriple <BopEntry>> (0);

      myDemandD.getCoExecVolPip (2, theTripleList);
d1897 1
a1897 3
      theTripleList = new ArrayList <AllocTriple <Operation>> (0);

      myDemandD.getExecVolPip (2, theTripleList);
d1912 1
a1912 3
      theTripleList = new ArrayList <AllocTriple <Part>> (0);

      myDemandD.getProdVolPip (2, theTripleList);
d1927 1
a1927 3
      theTripleList = new ArrayList <AllocTriple <Part>> (0);

      myDemandH.getSideVolPip (2, theTripleList);
d1942 1
a1942 3
      theTripleList = new ArrayList <AllocTriple <Substitute>> (0);

      myDemandD.getSubVolPip (2, theTripleList);
d1958 1
a1958 3
      theTripleList = new ArrayList <AllocTriple <Part>> (0);

      myDemandD.getSupplyVolPip (2, theTripleList);
a1970 1

d1997 1
a1997 3
      theTripleList = new ArrayList <AllocTriple <Operation>> (0);

      myDemandD.getExecVolPegging (2, theTripleList);
d2012 1
a2012 3
      theTripleList = new ArrayList <AllocTriple <Substitute>> (0);

      myDemandD.getSubVolPegging (2, theTripleList);
d2130 1
a2130 3
      theTripleList = new ArrayList <AllocTriple <Part>> (0);

      theDemand.getSupplyVolPip (shipPer, theTripleList);
@


1.107
log
@Made pegging retrieval methods not use enum PeggingAtt.
@
text
@d1967 1
d1974 8
d1984 1
d2132 38
@


1.106
log
@Revised pegging to use PeggingAtt in the public interface.
@
text
@a12 1
import static com.ibm.witj.PeggingAtt.*;
d1868 1
a1868 1
      myDemandD.getPegging (CONS_VOL_PIP, 2, theTripleList, Part.class);
d1885 1
a1885 1
      myDemandD.getPegging (CO_EXEC_VOL_PIP, 2, theTripleList, BopEntry.class);
d1902 1
a1902 1
      myDemandD.getPegging (EXEC_VOL_PIP, 2, theTripleList, Operation.class);
d1919 1
a1919 1
      myDemandD.getPegging (PROD_VOL_PIP, 2, theTripleList, Part.class);
d1936 1
a1936 1
      myDemandH.getPegging (SIDE_VOL_PIP, 2, theTripleList, Part.class);
d1953 1
a1953 1
      myDemandD.getPegging (SUB_VOL_PIP, 2, theTripleList, Substitute.class);
d1970 1
a1970 1
      myDemandD.getPegging (SUPPLY_VOL_PIP, 2, theTripleList, Part.class);
d2003 1
a2003 1
      myDemandD.getPegging (EXEC_VOL_CP, 2, theTripleList, Operation.class);
d2020 1
a2020 1
      myDemandD.getPegging (SUB_VOL_CP, 2, theTripleList, Substitute.class);
@


1.105
log
@Changed name of clear methods to clearData.
@
text
@d13 1
d1869 1
a1869 1
      myDemandD.getConsVolPip (2, theTripleList);
d1886 1
a1886 1
      myDemandD.getCoExecVolPip (2, theTripleList);
d1903 1
a1903 1
      myDemandD.getExecVolPip (2, theTripleList);
d1920 1
a1920 1
      myDemandD.getProdVolPip (2, theTripleList);
d1937 1
a1937 1
      myDemandH.getSideVolPip (2, theTripleList);
d1954 1
a1954 1
      myDemandD.getSubVolPip (2, theTripleList);
d1971 1
a1971 1
      myDemandD.getSupplyVolPip (2, theTripleList);
d2004 1
a2004 1
      myDemandD.getExecVolPegging (2, theTripleList);
d2021 1
a2021 1
      myDemandD.getSubVolPegging (2, theTripleList);
@


1.104
log
@getActiveInstances ==> getActiveProblems
@
text
@d92 1
a92 1
      testClear                    ();
d1649 1
a1649 1
// testClear ()
d1651 1
a1651 1
// Tests theProblem.clear ().
d1654 1
a1654 1
   private void testClear ()
d1656 1
a1656 1
      myProblem.clear ();
@


1.103
log
@Changed names of instances of class C in generic class AllocTriple <C>.
@
text
@d112 1
a112 1
      testActiveInstances          ();
d1666 1
a1666 2
// Tests theProblem.copyData          (...).
// Tests Problem   .getActiveProblems ().
d2122 1
a2122 1
// testActiveInstances ()
d2124 1
a2124 1
// Tests Problem.getActiveInstances ().
d2127 1
a2127 1
   private void testActiveInstances ()
d2132 1
a2132 1
      theActiveProblems = Problem.getActiveInstances ();
@


1.102
log
@Minor revision.
@
text
@d1847 1
a1847 1
          + theTriple.getC     ()
@


1.101
log
@Added a comment.
@
text
@d2112 1
a2112 1
                        theBoolAtt,
@


1.100
log
@Added displayNonDefGlobalBoolAtts (...) to UnitTester.
@
text
@d2075 2
@


1.99
log
@Changed terminology:
   "Queueing element values" was replaced by
   "Placing element requests".
@
text
@d111 1
d2069 52
@


1.98
log
@Removed the "enabled" concept from WIT-J.
@
text
@d99 1
a99 1
      testSetElementsFromQueue     ();
d1257 1
a1257 1
// testSetElementsFromQueue ()
d1260 5
a1264 3
//    theComp   .queueVectorElement   (...)
//    theComp   .queueBoundElements   (...)
//    theProblem.setElementsFromQueue ()
d1267 1
a1267 1
   private void testSetElementsFromQueue ()
d1275 2
a1276 2
      myPartA   .setVectorToScalar    (supplyVol     (),    91);
      myBomEntFA.setVectorToScalar    (offset        (),    -1);
d1278 35
a1312 35
      myPartA   .queueVectorElement   (supplyVol     (), 1, 17);
      myPartA   .queueVectorElement   (propRtg       (), 2,  true);
      myPartB   .queueVectorElement   (supplyVol     (), 1, 43);
      myBomEntFA.queueVectorElement   (offset        (), 2,  1);
      myBopEntFG.queueVectorElement   (offset        (), 0,  2);
      myDemandD .queueVectorElement   (priority      (), 1, 59);
      myPartA   .queueVectorElement   (supplyVol     (), 1, 82);
      myPartA   .queueVectorElement   (supplyVol     (), 0, 35);

      myDemandD .queueHardLBElement   (cumShipBounds (), 2, 10);
      myDemandD .queueSoftLBElement   (cumShipBounds (), 2, 20);
      myDemandD .queueHardUBElement   (cumShipBounds (), 2, 50);
      myDemandD .queueHardLBElement   (cumShipBounds (), 2, 15);
      myOpnF    .queueHardUBElement   (execBounds    (), 1, 34);
      myDemandH .queueHardUBElement   (cumShipBounds (), 2, 47);

      myProblem .setElementsFromQueue ();
      myProblem .setElementsFromQueue ();

      myPartA   .setVectorToScalar    (supplyVol     (),    0);
      myPartB   .setVectorToScalar    (supplyVol     (),    0);
      myPartA   .setVectorToScalar    (propRtg       (),    false);
      myBomEntFA.setVectorToScalar    (offset        (),    0);
      myBopEntFG.setVectorToScalar    (offset        (),    0);
      myDemandD .setVectorToScalar    (priority      (),    0);

      myDemandD .setValue             (cumShipBounds (),    zeroArr,
                                                            zeroArr,
                                                            neg1Arr);
      myDemandH .setValue             (cumShipBounds (),    zeroArr,
                                                            zeroArr,
                                                            neg1Arr);
      myOpnF    .setValue             (execBounds    (),    zeroArr,
                                                            zeroArr,
                                                            neg1Arr);
@


1.97
log
@Implemented Problem.getActiveInstances ().
@
text
@d88 2
a89 3
      testMsgMgr1                  ();
      enableProblem                ();
      testMsgMgr2                  ();
d134 1
a134 1
// testMsgMgr1 ()
d136 1
a136 1
// Test of the MessageMgr before the Problem is constructed.
d139 1
a139 1
   private void testMsgMgr1 ()
d142 3
a156 43
      }

//------------------------------------------------------------------------------
// enableProblem ().
//
// Performs tasks associated with enabling myProblem.
//------------------------------------------------------------------------------

   private void enableProblem ()
      {
      boolean enabledState;
      int     nPeriodsVal;

      enabledState = myProblem.isEnabled ();

      assert (! enabledState);

      myProblem.enable ();

      enabledState = myProblem.isEnabled ();

      assert (enabledState);

      myGlobalAspect = myProblem.getGlobalAspect ();

      myGlobalAspect.setValue (nPeriods (), 3);

      nPeriodsVal = myGlobalAspect.getValue (nPeriods ());

      assert (nPeriodsVal == 3);
      }

//------------------------------------------------------------------------------
// testMsgMgr2 ()
//
// Test of the MessageMgr after the Problem has been constructed.
//------------------------------------------------------------------------------

   private void testMsgMgr2 ()
      {
      String theName;
      String theMode;
      int    theInt;
d184 19
a1674 2
      cpyProblem.getMessageMgr ().setQuiet (true);

a1676 2
      cpyProblem.enable ();

a2109 2
      theProblem.getMessageMgr ().setQuiet (true);

a2113 2
      theProblem.enable ();

a2145 2
      theProblem.enable ();

a2153 2
      theProblem.enable ();

@


1.96
log
@Timing test.
@
text
@d112 1
d1685 2
a1686 1
// Tests theProblem.copyData (...).
d2092 32
@


1.95
log
@Aded temporary code to test the ability to measure CPU time.
@
text
@a14 1
import                java.lang.management.*;
d29 1
a29 1
// performUnitTest ()
d34 1
a34 1
   static void performUnitTest ()
d40 1
a40 1
      theUnitTester.performTest ();
d73 1
a73 1
// performTest ().
d75 1
a75 2
// Performs the unit test.
// (non-static internal implementation)
d78 1
a78 1
   private void performTest ()
d125 1
a125 2
      PurgeTester.performPurgeTest ();

a127 2
//    testTiming                   ();

a2163 55
// testTiming ()
//------------------------------------------------------------------------------

   private void testTiming ()
      {
      Problem theProblem;
      double  timeBefore;
      double  timeForHeur;

      theProblem = Problem.newInstance ();

      theProblem.
         getMessageMgr ().
            setMesgTimesPrint (MessageGroup.INFORMATIONAL, 0);

      theProblem.enable ();

      theProblem.readData ("benson.data");

      timeBefore  = getCpuTime ();

      theProblem.performAction ("time-heur-implode");

      timeForHeur = getCpuTime () - timeBefore;

      System.out.printf (
         "\n"
       + "CPU time for theProblem.heurImplode (): %.2f seconds\n\n",
         timeForHeur);
      
      theProblem.deactivate ();
      }

//------------------------------------------------------------------------------
// getCpuTime ()
//
// Returns the current cumulative CPU time of the program process in seconds.
//------------------------------------------------------------------------------

   private static double getCpuTime ()
      {
      long   nanoTime;
      double secTime;

      nanoTime =
         ManagementFactory.
            getThreadMXBean ().
               getCurrentThreadCpuTime ();

      secTime  = ((double) nanoTime) / 1000000000.0;

      return secTime;
      }

//------------------------------------------------------------------------------
@


1.94
log
@News Vendor Test
@
text
@d15 1
d131 2
d2169 55
@


1.93
log
@Changed the name of class NewsVender to NewsVendor.
Further implementation of class NewsVendor.
@
text
@d128 1
a128 1
      NewsVendor .doDemo           ();
@


1.92
log
@theProblem.copyData (...).
@
text
@d128 2
@


1.91
log
@theProblem.clear ().
@
text
@d106 1
d1682 34
@


1.90
log
@Added the UTF-8 test.
@
text
@d94 1
d1666 15
@


1.89
log
@Added a test for reading a WIT data file containing part names in UTF-8 format.
@
text
@d122 2
d2079 34
@


1.88
log
@Added theComp.setBoundSetToScalars (...).
@
text
@d2057 1
a2057 1
      theProblem.readData ("diner.data");
d2065 2
a2066 1
       + "The following Components were read in from file \"diner.data\":\n");
@


1.87
log
@Setting BoundSet Attributes elements from a queue.
@
text
@a1403 3
      double[] hardLBin;
      double[] softLBin;
      double[] hardUBin;
d1408 1
a1408 3
      hardLBin  = new double[] {210.0, 220.0, 230.0};
      softLBin  = new double[] {240.0, 250.0, 260.0};
      hardUBin  = new double[] {270.0, 280.0, 290.0};
a1413 1
      myDemandD.setValue (cumShipBounds (), hardLBin,  softLBin,  hardUBin);
d1416 11
a1426 3
      assertApproxEq (hardLBout, hardLBin);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, hardUBin);
d1428 1
a1428 1
      resetBoundSet (myDemandD, cumShipBounds ());
d1484 1
a1484 1
      resetBoundSet (myOpnF, execBounds ());
d1586 1
a1586 1
      resetBoundSet (myPartC, stockBounds ());
@


1.86
log
@Setting boolean vector elements from queue.
@
text
@d1277 2
a1278 1
//    theComp   .queueElementValue    (...)
d1284 8
a1291 2
      myPartA   .setVectorToScalar (supplyVol (), 91);
      myBomEntFA.setVectorToScalar (offset    (), -1);
d1293 35
a1327 17
      myPartA   .queueElementValue (supplyVol (), 1, 17);
      myPartA   .queueElementValue (propRtg   (), 2,  true);
      myPartB   .queueElementValue (supplyVol (), 1, 43);
      myBomEntFA.queueElementValue (offset    (), 2,  1);
      myBopEntFG.queueElementValue (offset    (), 0,  2);
      myDemandD .queueElementValue (priority  (), 1, 59);
      myPartA   .queueElementValue (supplyVol (), 1, 82);
      myPartA   .queueElementValue (supplyVol (), 0, 35);

      myProblem.setElementsFromQueue ();

      myPartA   .setVectorToScalar (supplyVol (), 0);
      myPartB   .setVectorToScalar (supplyVol (), 0);
      myPartA   .setVectorToScalar (propRtg   (), false);
      myBomEntFA.setVectorToScalar (offset    (), 0);
      myBopEntFG.setVectorToScalar (offset    (), 0);
      myDemandD .setVectorToScalar (priority  (), 0);
@


1.85
log
@Setting integer vector elements from a queue.
@
text
@d1287 1
d1299 1
@


1.84
log
@Test code for setting vector elements from a queue.
@
text
@d1288 3
a1290 2
      myBomEntFA.queueElementValue (offset (),    2,  1);
      myBopEntFG.queueElementValue (offset (),    0,  2);
d1300 1
@


1.83
log
@Replaced theProblem.getInstances (theClass) with theProblem.GetParts (),
etc.
@
text
@d100 1
d1274 28
@


1.82
log
@Changed name of method setValueToScalar to setVectorToScalar.
@
text
@d305 2
a306 2
          myProblem.getInstances (Component.class),
         "myProblem.getInstances (Component.class)");
d309 2
a310 2
          myProblem.getInstances (GlobalAspect.class),
         "myProblem.getInstances (GlobalAspect.class)");
d313 2
a314 2
          myProblem.getInstances (Part.class),
         "myProblem.getInstances (Part.class)");
d317 2
a318 2
          myProblem.getInstances (Demand.class),
         "myProblem.getInstances (Demand.class)");
d321 2
a322 2
          myProblem.getInstances (Operation.class),
         "myProblem.getInstances (Operation.class)");
d325 2
a326 10
          myProblem.getInstances (BomEntry.class),
         "myProblem.getInstances (BomEntry.class)");

      printList (
          myProblem.getInstances (Substitute.class),
         "myProblem.getInstances (Substitute.class)");

      printList (
          myProblem.getInstances (BopEntry.class),
         "myProblem.getInstances (BopEntry.class)");
@


1.81
log
@Added theComp.setValueToScalar (...) methods.
@
text
@d99 1
a99 1
      testSetGetValue              ();
d1111 1
a1111 1
// testSetGetValue ()
d1113 1
a1113 1
// Tests Attribute setValue, setValueToScalar, and getValue methods of class
d1117 1
a1117 1
   private void testSetGetValue ()
d1190 1
a1190 1
// Tests Attribute setValue, setValueToScalar, and getValue methods for
d1209 1
a1209 1
      myPartB.setValueToScalar (propRtg (), true);
d1211 1
a1211 1
      myPartB.getValue         (propRtg (), propRtgOut);
d1213 1
a1213 1
      assertEq                 (propRtgOut, new boolean[] {true, true, true});
d1215 1
a1215 1
      myPartB.setValueToScalar (propRtg (), false);
d1221 1
a1221 1
// Tests Attribute setValue, setValueToScalar, and getValue methods for
d1240 1
a1240 1
      myDemandD.setValueToScalar (priority (), 6);
d1242 1
a1242 1
      myDemandD.getValue         (priority (), priorityOut);
d1244 1
a1244 1
      assertEq                   (priorityOut, new int[] {6, 6, 6});
d1246 1
a1246 1
      myDemandD.setValueToScalar (priority (), 0);
d1252 1
a1252 1
// Tests Attribute setValue, setValueToScalar, and getValue methods for
d1271 1
a1271 1
      myPartB.setValueToScalar (supplyVol (), 20);
d1273 1
a1273 1
      myPartB.getValue         (supplyVol (), supplyVolOut);
d1275 1
a1275 1
      assertApproxEq           (supplyVolOut, new double[] {20, 20, 20});
d1277 1
a1277 1
      myPartB.setValueToScalar (supplyVol (), 0);
@


1.80
log
@Added:
   theOpn     .getUniqueBomEntryTo   (thePart)
   theOpn     .getUniqueBopEntryTo   (thePart)
   theBomEntry.getUniqueSubstituteTo (thePart)
@
text
@d1113 2
a1114 1
// Tests Attribute setValue and getValue methods of class Component.
d1190 2
a1191 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// boolean[].
d1197 1
a1197 2
      boolean[] propRtgOut1;
      boolean[] propRtgOut2;
d1199 1
a1199 2
      propRtgIn   = new boolean[] {true, false, true};
      propRtgOut1 = new boolean[3];
a1201 1
      myPartB.getValue (propRtg (), propRtgOut1);
d1203 7
a1209 1
      propRtgOut2 = myPartB.getValue (propRtg ());
d1211 1
a1211 2
      assertEq (propRtgOut1, propRtgIn);
      assertEq (propRtgOut2, propRtgIn);
d1213 3
a1215 1
      myPartB.setValue (propRtg (), new boolean[] {false, false, false});
d1221 2
a1222 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// int[].
d1228 1
a1228 2
      int[] priorityOut1;
      int[] priorityOut2;
d1230 1
a1230 2
      priorityIn   = new int[] {2, 7, 3};
      priorityOut1 = new int[3];
a1232 1
      myDemandD.getValue (priority (), priorityOut1);
d1234 5
a1238 1
      priorityOut2 = myDemandD.getValue (priority ());
d1240 1
a1240 2
      assertEq (priorityOut1, priorityIn);
      assertEq (priorityOut2, priorityIn);
d1242 5
a1246 1
      myDemandD.setValue (priority (), new int[] {0, 0, 0});
d1252 2
a1253 2
// Tests Attribute setValue and getValue methods for Attributes of value type
// double[].
d1259 1
a1259 2
      double[] supplyVolOut1;
      double[] supplyVolOut2;
d1261 1
a1261 2
      supplyVolIn   = new double[] {40,  0, 50};
      supplyVolOut1 = new double[3];
a1263 1
      myPartB.getValue (supplyVol (), supplyVolOut1);
d1265 9
a1273 1
      supplyVolOut2 = myPartB.getValue (supplyVol ());
d1275 1
a1275 2
      assertApproxEq (supplyVolOut1, supplyVolIn);
      assertApproxEq (supplyVolOut2, supplyVolIn);
d1277 1
a1277 1
      myPartB.setValue (supplyVol (), new double[] {0, 0, 0});
@


1.79
log
@Added:
   theOpn     .getBomEntriesTo  (thePart)
   theOpn     .getBopEntriesTo  (thePart)
   theBomEntry.getSubstitutesTo (thePart)
@
text
@d95 1
a95 5
      testScalarNavMethods         ();
      testProblemListMethods       ();
      testPartListMethods          ();
      testOperationListMethods     ();
      testBomEntryListMethods      ();
d269 1
a269 1
// testScalarNavMethods ().
d271 1
a271 1
// Tests the navigational methods that return scalar Objects.
d274 1
a274 1
   private void testScalarNavMethods ()
d276 7
a282 26
      println ("");

      println ("myProblem  .getPart       (\"B\"): "
              + myProblem  .getPart       ( "B" ));
      println ("myProblem  .getOperation  (\"F\"): "
              + myProblem  .getOperation  ( "F" ));
      println ("myPartC    .getProblem    ():    "
              + myPartC    .getProblem    ());
      println ("myPartC    .getDemand     (\"D\"): "
              + myPartC    .getDemand     ( "D" ));
      println ("myPartC    .getCategory   ():    "
              + myPartC    .getCategory   ());
      println ("myDemandD  .getPart       ():    "
              + myDemandD  .getPart       ());
      println ("myBomEntFB1.getOperation  ():    "
              + myBomEntFB1.getOperation  ());
      println ("myBomEntFB1.getPart       ():    "
              + myBomEntFB1.getPart       ());
      println ("mySubEAB   .getBomEntry   ():    "
              + mySubEAB   .getBomEntry   ());
      println ("mySubEAB   .getPart       ():    "
              + mySubEAB   .getPart       ());
      println ("myBopEntFC .getOperation  ():    "
              + myBopEntFC .getOperation  ());
      println ("myBopEntFC .getPart       ():    "
              + myBopEntFC .getPart       ());
d286 1
a286 1
// testProblemListMethods ()
d288 1
a288 1
// Tests methods that return Lists of Objects associated with a Problem
d291 1
a291 1
   private void testProblemListMethods ()
d293 7
d338 1
a338 1
// testPartListMethods ()
d340 1
a340 1
// Tests methods that return Lists of Objects associated with a Part
d343 1
a343 1
   private void testPartListMethods ()
d345 9
d372 15
a386 1
// testOperationListMethods ()
d388 1
a388 1
// Tests methods that return Lists of Objects associated with an Operation
d391 1
a391 1
   private void testOperationListMethods ()
d405 12
d424 6
d433 1
a433 1
// testBomEntryListMethods ().
d435 1
a435 1
// Tests methods that return Lists of Objects associated with a BomEntry.
d438 1
a438 1
   private void testBomEntryListMethods ()
d440 7
d454 39
@


1.78
log
@Added theOpn.getBomEntriesTo (thePart).
@
text
@d401 4
d418 4
@


1.77
log
@Implemented theProblem.getInstances (theCompClass).
@
text
@d96 4
a99 1
      testArrayNavMethods          ();
d230 14
a243 13
      myPartA    = Part      .newInstance (myProblem,  "A", CAPACITY);
      myPartB    = Part      .newInstance (myProblem,  "B", CAPACITY);
      myPartC    = Part      .newInstance (myProblem,  "C", MATERIAL);
      myPartG    = Part      .newInstance (myProblem,  "G", MATERIAL);
      myDemandD  = Demand    .newInstance (myPartC,    "D");
      myDemandE  = Demand    .newInstance (myPartB,    "E");
      myDemandH  = Demand    .newInstance (myPartG,    "H");
      myOpnF     = Operation .newInstance (myProblem,  "F");
      myBomEntFA = BomEntry  .newInstance (myOpnF,     myPartA);
      myBomEntFB = BomEntry  .newInstance (myOpnF,     myPartB);
      mySubEAB   = Substitute.newInstance (myBomEntFA, myPartB);
      myBopEntFC = BopEntry  .newInstance (myOpnF,     myPartC);
      myBopEntFG = BopEntry  .newInstance (myOpnF,     myPartG);
d266 2
a267 1
      println (myBomEntFB);
d282 24
a305 24
      println ("myProblem .getPart       (\"B\"): "
              + myProblem .getPart       ( "B" ));
      println ("myProblem .getOperation  (\"F\"): "
              + myProblem .getOperation  ( "F" ));
      println ("myPartC   .getProblem    ():    "
              + myPartC   .getProblem    ());
      println ("myPartC   .getDemand     (\"D\"): "
              + myPartC   .getDemand     ( "D" ));
      println ("myPartC   .getCategory   ():    "
              + myPartC   .getCategory   ());
      println ("myDemandD .getPart       ():    "
              + myDemandD .getPart       ());
      println ("myBomEntFB.getOperation  ():    "
              + myBomEntFB.getOperation  ());
      println ("myBomEntFB.getPart       ():    "
              + myBomEntFB.getPart       ());
      println ("mySubEAB  .getBomEntry   ():    "
              + mySubEAB  .getBomEntry   ());
      println ("mySubEAB  .getPart       ():    "
              + mySubEAB  .getPart       ());
      println ("myBopEntFC.getOperation  ():    "
              + myBopEntFC.getOperation  ());
      println ("myBopEntFC.getPart       ():    "
              + myBopEntFC.getPart       ());
d309 1
a309 1
// testArrayNavMethods ().
d311 1
a311 1
// Tests the navigational methods that return arrays of Objects.
d314 1
a314 1
   private void testArrayNavMethods ()
d351 7
d359 2
d376 7
d384 2
d391 8
d401 1
d403 8
d1219 1
a1219 1
      bomIndexOut = myBomEntFB.getValue (bomIndex ());
d1537 1
d2099 2
a2100 1
   private BomEntry     myBomEntFB;
@


1.76
log
@Removed:
   theOpn     .getBomEntry   (theIdx)
   theOpn     .getBopEntry   (theIdx)
   theBomEntry.getSubstitute (theIdx)
@
text
@d316 32
@


1.75
log
@Replaced Attribute.getAllAttributes () with Attribute.getAttributes (),
which returns an unmodifiable List.
@
text
@a288 4
      println ("myOpnF    .getBomEntry   (1):   "
              + myOpnF    .getBomEntry   (1));
      println ("myOpnF    .getBopEntry   (0):   "
              + myOpnF    .getBopEntry   (0));
a292 2
      println ("myBomEntFA.getSubstitute (0):   "
              + myBomEntFA.getSubstitute (0));
@


1.74
log
@Changed the following methods to return an unmodifiable List:

   thePart     .getDemands     ()
   thePart     .getBomEntries  ()
   thePart     .getSubstitutes ()
   thePart     .getBopEntries  ()
   theOperation.getBomEntries  ()
   theOperation.getBopEntries  ()
   theBomEntry .getSubstitutes ()
@
text
@d60 1
a60 1
         new HashSet <Attribute <?>> (getAllAttributes ().length, 1.0f);
d62 2
a63 1
      for (Attribute <?> theAtt: getAllAttributes ())
d65 1
d717 1
a717 1
      for (Attribute <?> theAtt: getAllAttributes ())
d762 1
a762 1
      for (Attribute <?> theAtt: getAllAttributes ())
@


1.73
log
@Changed theProblem.getComponents () to return an unmodifiable view.
@
text
@d319 1
a319 1
      printArray (
d323 1
a323 1
      printArray (
d327 1
a327 1
      printArray (
d331 1
a331 1
      printArray (
d335 1
a335 1
      printArray (
d339 1
a339 1
      printArray (
d343 1
a343 1
      printArray (
a1963 16
// printArray (theArr, theArrName)
//
// Prints the contents of theArr, whose name is given by theArrName.
//------------------------------------------------------------------------------

   private static void printArray (Object[] theArr, String theArrName)
      {
      println (
         "\n"
       + theArrName + ":");

      for (Object theObject: theArr)
         println ("   " + theObject);
      }

//------------------------------------------------------------------------------
@


1.72
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@d315 1
a315 1
      printArray (
d1980 16
@


1.71
log
@Changed name of GlobalComponent classes to GlobalAspect.
@
text
@d49 1
a49 1
      allElementClasses = new ArrayList <Class <? extends Element>> (7);
d51 7
a57 7
      allElementClasses.add (GlobalAspect.class);
      allElementClasses.add (Part        .class);
      allElementClasses.add (Demand      .class);
      allElementClasses.add (Operation   .class);
      allElementClasses.add (BomEntry    .class);
      allElementClasses.add (Substitute  .class);
      allElementClasses.add (BopEntry    .class);
d91 1
a91 1
      buildElements                ();
d218 1
a218 1
// buildElements ().
d220 1
a220 1
// Builds the Elements for the unit test.
d223 1
a223 1
   private void buildElements ()
d316 2
a317 2
          myProblem.getElements (),
         "myProblem.getElements ()");
d522 1
a522 1
      for (Class <? extends Element> theClass: allElementClasses)
d705 1
a705 1
// Displays all Attributes that don't apply to any Element class.
d722 1
a722 1
         for (Class <? extends Element> theClass: allElementClasses)
d733 2
a734 2
                + "The following Attributes do not apply to any Element class:"
                + "\n");
d745 1
a745 1
          + "All Attributes apply to at least one Element class.");
d795 1
a795 1
// verifyDefaultValue (theAtt, theElem)
d797 1
a797 1
// If theAtt appliesTo theElem, this method verifies that WIT-J's default value
d801 1
a801 1
   private void verifyDefaultValue (Attribute <?> theAtt, Element theElem)
d804 1
a804 1
      if (! theAtt.appliesTo (theElem.getClass ()))
d807 8
a814 8
      verifyBoolDefault     (theAtt, theElem);
      verifyIntDefault      (theAtt, theElem);
      verifyDblDefault      (theAtt, theElem);
      verifyStringDefault   (theAtt, theElem);
      verifyBoolVecDefault  (theAtt, theElem);
      verifyIntVecDefault   (theAtt, theElem);
      verifyDblVecDefault   (theAtt, theElem);
      verifyBoundSetDefault (theAtt, theElem);
d824 1
a824 1
   private void verifyBoolDefault (Attribute <?> theAtt, Element theElem)
d835 1
a835 1
         == theElem  .getValue        (theBoolAtt));
d838 1
a838 1
   private void verifyIntDefault (Attribute <?> theAtt, Element theElem)
d849 1
a849 1
         == theElem  .getValue        (theIntAtt));
d852 1
a852 1
   private void verifyDblDefault (Attribute <?> theAtt, Element theElem)
d863 1
a863 1
         theElem  .getValue        (theDblAtt));
d866 1
a866 1
   private void verifyStringDefault (Attribute <?> theAtt, Element theElem)
d877 1
a877 1
         theElem  .getValue        (theStringAtt)));
d880 1
a880 1
   private void verifyBoolVecDefault (Attribute <?> theAtt, Element theElem)
d894 1
a894 1
      assertEq (theBoolVec, theElem.getValue (theBoolVecAtt));
d897 1
a897 1
   private void verifyIntVecDefault (Attribute <?> theAtt, Element theElem)
d911 1
a911 1
      assertEq (theIntVec, theElem.getValue (theIntVecAtt));
d914 1
a914 1
   private void verifyDblVecDefault (Attribute <?> theAtt, Element theElem)
d928 1
a928 1
      assertApproxEq (theDblVec, theElem.getValue (theDblVecAtt));
d931 1
a931 1
   private void verifyBoundSetDefault (Attribute <?> theAtt, Element theElem)
d956 1
a956 1
      theElem.getValue   (theBoundSetAtt, hardLBVal, softLBVal, hardUBVal);
d966 1
a966 1
// Tests Attribute setValue and getValue methods of class Element.
d1378 1
a1378 1
// resetBoundSet (theElem, theAtt)
d1383 1
a1383 1
   private void resetBoundSet (Element theElem, Attribute <BoundSet> theAtt)
d1391 1
a1391 1
      theElem.setValue (theAtt, zeroArr, zeroArr, neg1Arr);
d1453 1
a1453 1
// Sets various Attributes of the Elements of myProblem in order to form an
d1602 1
a1602 1
          + theTriple.getE     ()
d1788 1
a1788 1
   private <E extends Element> void printPegging (
d1792 1
a1792 1
         ArrayList <AllocTriple <E>> theTripleList)
d1803 1
a1803 1
      for (AllocTriple <E> theTriple: theTripleList)
d1852 1
a1852 1
       + "The following Elements were read in from file \"diner.data\":\n");
d1854 1
a1854 1
      for (Element theElement: theProblem.getElements ())
d1856 1
a1856 1
         println ("   " + theElement);
d2036 1
a2036 1
// allElementClasses
d2038 1
a2038 1
// Contains the Class object for each subclass of class Element.
d2041 1
a2041 1
   private final List <Class <? extends Element>> allElementClasses;
@


1.70
log
@Changed name of GlobalElement classes to GlobalComponent.
@
text
@d51 7
a57 7
      allElementClasses.add (GlobalComponent.class);
      allElementClasses.add (Part           .class);
      allElementClasses.add (Demand         .class);
      allElementClasses.add (Operation      .class);
      allElementClasses.add (BomEntry       .class);
      allElementClasses.add (Substitute     .class);
      allElementClasses.add (BopEntry       .class);
d171 1
a171 1
      myGlobalComponent = myProblem.getGlobalComponent ();
d173 1
a173 1
      myGlobalComponent.setValue (nPeriods (), 3);
d175 1
a175 1
      nPeriodsVal       = myGlobalComponent.getValue (nPeriods ());
d782 1
a782 1
         verifyDefaultValue (theAtt, myGlobalComponent);
d1332 1
a1332 1
      myGlobalComponent.setValue (solverLogFileName (), solverLogFileNameIn);
d1334 1
a1334 1
      solverLogFileNameOut = myGlobalComponent.getValue (solverLogFileName ());
d1407 1
a1407 1
      myGlobalComponent.setValue (title (), titleIn);
d1409 1
a1409 1
      titleOut = myGlobalComponent.getValue (title ());
d1424 1
a1424 1
      myGlobalComponent.setOptInitMethod (OptInitMethod.CRASH);
d1426 1
a1426 1
      theMethod = myGlobalComponent.getOptInitMethod ();
d1430 1
a1430 1
      myGlobalComponent.setOptInitMethod (OptInitMethod.HEURISTIC);
d1459 1
a1459 1
      myGlobalComponent.setValue (computeCriticalList (), true);
d1461 9
a1469 9
      myGlobalComponent.setValue (perfPegging  (), true);
      myGlobalComponent.setValue (skipFailures (), false);
      myPartC          .setValue (buildNstn    (), true);
      myPartA          .setValue (supplyVol    (), new double[] {10, 10, 10});
      myPartB          .setValue (supplyVol    (), new double[] {60,  0, 50});
      myDemandD        .setValue (demandVol    (), new double[] {20,  0, 30});
      myDemandE        .setValue (demandVol    (), new double[] {20, 10, 10});
      myDemandH        .setValue (demandVol    (), new double[] {25,  0, 35});
      myBopEntFG       .setValue (expAllowed   (), false);
d1485 1
a1485 1
      activeVal = myGlobalComponent.getValue (heurAllocActive ());
d1493 1
a1493 1
      activeVal = myGlobalComponent.getValue (heurAllocActive ());
d1523 1
a1523 1
      myGlobalComponent.setValue (equitability (), 100);
d1531 1
a1531 1
      myGlobalComponent.setValue (equitability (), 1);
d1593 2
a1594 2
      myGlobalComponent.setPipSeq (theTripleListIn);
      myGlobalComponent.getPipSeq (theTripleListOut);
d1846 1
a1846 1
      nPeriodsVal = theProblem.getGlobalComponent ().getValue (nPeriods ());
d1848 1
a1848 1
      assert (theProblem.getGlobalComponent ().getValue (nPeriods ()) == 2);
d2018 16
a2033 16
   private Problem         myProblem;
   private MessageMgr      myMessageMgr;
   private GlobalComponent myGlobalComponent;
   private Part            myPartA;
   private Part            myPartB;
   private Part            myPartC;
   private Part            myPartG;
   private Demand          myDemandD;
   private Demand          myDemandE;
   private Demand          myDemandH;
   private Operation       myOpnF;
   private BomEntry        myBomEntFA;
   private BomEntry        myBomEntFB;
   private Substitute      mySubEAB;
   private BopEntry        myBopEntFC;
   private BopEntry        myBopEntFG;
@


1.69
log
@Changed name of Problem method shutDown to deactivate.
@
text
@d51 7
a57 7
      allElementClasses.add (GlobalElement.class);
      allElementClasses.add (Part         .class);
      allElementClasses.add (Demand       .class);
      allElementClasses.add (Operation    .class);
      allElementClasses.add (BomEntry     .class);
      allElementClasses.add (Substitute   .class);
      allElementClasses.add (BopEntry     .class);
d171 1
a171 1
      myGlobalElement = myProblem.getGlobalElement ();
d173 1
a173 1
      myGlobalElement.setValue (nPeriods (), 3);
d175 1
a175 1
      nPeriodsVal     = myGlobalElement.getValue (nPeriods ());
d782 1
a782 1
         verifyDefaultValue (theAtt, myGlobalElement);
d1332 1
a1332 1
      myGlobalElement.setValue (solverLogFileName (), solverLogFileNameIn);
d1334 1
a1334 1
      solverLogFileNameOut = myGlobalElement.getValue (solverLogFileName ());
d1407 1
a1407 1
      myGlobalElement.setValue (title (), titleIn);
d1409 1
a1409 1
      titleOut = myGlobalElement.getValue (title ());
d1424 1
a1424 1
      myGlobalElement.setOptInitMethod (OptInitMethod.CRASH);
d1426 1
a1426 1
      theMethod = myGlobalElement.getOptInitMethod ();
d1430 1
a1430 1
      myGlobalElement.setOptInitMethod (OptInitMethod.HEURISTIC);
d1459 1
a1459 1
      myGlobalElement.setValue (computeCriticalList (), true);
d1461 9
a1469 9
      myGlobalElement.setValue (perfPegging  (), true);
      myGlobalElement.setValue (skipFailures (), false);
      myPartC        .setValue (buildNstn    (), true);
      myPartA        .setValue (supplyVol    (), new double[] {10, 10, 10});
      myPartB        .setValue (supplyVol    (), new double[] {60,  0, 50});
      myDemandD      .setValue (demandVol    (), new double[] {20,  0, 30});
      myDemandE      .setValue (demandVol    (), new double[] {20, 10, 10});
      myDemandH      .setValue (demandVol    (), new double[] {25,  0, 35});
      myBopEntFG     .setValue (expAllowed   (), false);
d1485 1
a1485 1
      activeVal = myGlobalElement.getValue (heurAllocActive ());
d1493 1
a1493 1
      activeVal = myGlobalElement.getValue (heurAllocActive ());
d1523 1
a1523 1
      myGlobalElement.setValue (equitability (), 100);
d1531 1
a1531 1
      myGlobalElement.setValue (equitability (), 1);
d1593 2
a1594 2
      myGlobalElement.setPipSeq (theTripleListIn);
      myGlobalElement.getPipSeq (theTripleListOut);
d1846 1
a1846 1
      nPeriodsVal = theProblem.getGlobalElement ().getValue (nPeriods ());
d1848 1
a1848 1
      assert (theProblem.getGlobalElement ().getValue (nPeriods ()) == 2);
d2018 16
a2033 16
   private Problem       myProblem;
   private MessageMgr    myMessageMgr;
   private GlobalElement myGlobalElement;
   private Part          myPartA;
   private Part          myPartB;
   private Part          myPartC;
   private Part          myPartG;
   private Demand        myDemandD;
   private Demand        myDemandE;
   private Demand        myDemandH;
   private Operation     myOpnF;
   private BomEntry      myBomEntFA;
   private BomEntry      myBomEntFB;
   private Substitute    mySubEAB;
   private BopEntry      myBopEntFC;
   private BopEntry      myBopEntFG;
@


1.68
log
@purgeData
@
text
@d114 1
a114 1
      myProblem.shutDown           ();
d1859 1
a1859 1
      theProblem.shutDown ();
@


1.67
log
@writeCriticalList
@
text
@d118 3
a120 1
      testReadData ();
@


1.66
log
@Revised testing of write methods.
@
text
@d1451 2
a1452 2
// Sets various Attributes of the Elements of myProblem in order to form a
// non-trivial implosion problem.
d1457 2
d1811 8
a1818 10
      myProblem.writeData      ("unit-test.data");
      myProblem.preprocess     ();
      myProblem.displayData    ("");

      myProblem.writeExecSched ("unit-test.exec", FileFormat.BSV);
      myProblem.writeShipSched ("unit-test.ship", FileFormat.CSV);

      myProblem.mrp            ();

      myProblem.writeReqSched  ("unit-test.req",  FileFormat.BSV);
@


1.65
log
@Implemented writeExecSched, writeShipSched, and writeReqSched.
@
text
@d105 1
d1457 1
a1541 2
      myProblem.heurImplode ();

a1734 4
      myGlobalElement.setValue (perfPegging (), true);

      myProblem.heurImplode ();

a1740 2

      myGlobalElement.setValue (perfPegging (), false);
@


1.64
log
@Concurrent pegging.
@
text
@d107 1
a108 3
      myProblem.writeData          ("unit-test.data");
      myProblem.preprocess         ();
      myProblem.displayData        ("");
a110 1
      myProblem.heurImplode        ();
a112 1
      myProblem.mrp                ();
d1540 1
a1540 1
      implodeForPip ();
a1555 41
// implodeForPip ()
//
// Does implosion for the test of PIP.
//------------------------------------------------------------------------------

   private void implodeForPip ()
      {
      double[] shipVolVal;
      double[] execVolVal;

      myProblem.heurImplode ();

      shipVolVal = myDemandD.getValue (shipVol ());

      println ("D.shipVol[0] = " + shipVolVal[0]);
      println ("D.shipVol[1] = " + shipVolVal[1]);
      println ("D.shipVol[2] = " + shipVolVal[2]);

      shipVolVal = myDemandE.getValue (shipVol ());

      println ("E.shipVol[0] = " + shipVolVal[0]);
      println ("E.shipVol[1] = " + shipVolVal[1]);
      println ("E.shipVol[2] = " + shipVolVal[2]);
      println ();

      shipVolVal = myDemandH.getValue (shipVol ());

      println ("H.shipVol[0] = " + shipVolVal[0]);
      println ("H.shipVol[1] = " + shipVolVal[1]);
      println ("H.shipVol[2] = " + shipVolVal[2]);
      println ();

      execVolVal = myOpnF.getValue (execVol ());

      println ("F.execVol[0] = " + execVolVal[0]);
      println ("F.execVol[1] = " + execVolVal[1]);
      println ("F.execVol[2] = " + execVolVal[2]);
      println ();
      }

//------------------------------------------------------------------------------
d1810 18
@


1.63
log
@SideVol PIP.
@
text
@d106 1
d1667 1
a1667 1
      printPip ("ConsVol", myDemandD, 2, theTripleList);
d1684 1
a1684 1
      printPip ("CoExecVol", myDemandD, 2, theTripleList);
d1701 1
a1701 1
      printPip ("ExecVol", myDemandD, 2, theTripleList);
d1718 1
a1718 1
      printPip ("ProdVol", myDemandD, 2, theTripleList);
d1735 1
a1735 1
      printPip ("SideVol", myDemandH, 2, theTripleList);
d1752 1
a1752 1
      printPip ("SubVol", myDemandD, 2, theTripleList);
d1769 1
a1769 1
      printPip ("SupplyVol", myDemandD, 2, theTripleList);
d1773 1
a1773 1
// printPip (theAttName, theDemand, shipPer, theTripleList)
d1775 1
a1775 2
// Prints the PIP for theDemand D in shipPer given in theTripleList for the
// pegging attribute indicated by theAttName.
d1778 59
a1836 2
   private <E extends Element> void printPip (
         String                      theAttName,
d1843 2
a1844 2
       + theAttName
       + " PIP for "
@


1.62
log
@PIP
@
text
@d228 1
d231 1
d233 5
a237 4
      myBomEntEA = BomEntry  .newInstance (myOpnF,     myPartA);
      myBomEntEB = BomEntry  .newInstance (myOpnF,     myPartB);
      mySubEAB   = Substitute.newInstance (myBomEntEA, myPartB);
      myBopEntEC = BopEntry  .newInstance (myOpnF,     myPartC);
d259 2
a260 2
      println (myBomEntEA);
      println (myBomEntEB);
d262 1
a262 1
      println (myBopEntEC);
d291 6
a296 6
      println ("myBomEntEB.getOperation  ():    "
              + myBomEntEB.getOperation  ());
      println ("myBomEntEB.getPart       ():    "
              + myBomEntEB.getPart       ());
      println ("myBomEntEA.getSubstitute (0):   "
              + myBomEntEA.getSubstitute (0));
d301 4
a304 4
      println ("myBopEntEC.getOperation  ():    "
              + myBopEntEC.getOperation  ());
      println ("myBopEntEC.getPart       ():    "
              + myBopEntEC.getPart       ());
d344 2
a345 2
          myBomEntEA.getSubstitutes (),
         "myBomEntEA.getSubstitutes ()");
d786 1
a786 1
         verifyDefaultValue (theAtt, myBomEntEA);
d788 1
a788 1
         verifyDefaultValue (theAtt, myBopEntEC);
d990 1
a990 1
      myBopEntEC.setValue (expAllowed (), false);
d992 1
a992 1
      expAllowedOut = myBopEntEC.getValue (expAllowed ());
d996 1
a996 1
      myBopEntEC.setValue (expAllowed (), true);
d1010 1
a1010 1
      myBopEntEC.setValue (earliestPeriod (), 1);
d1012 1
a1012 1
      earliestPeriodOut = myBopEntEC.getValue (earliestPeriod ());
d1016 1
a1016 1
      myBopEntEC.setValue (earliestPeriod (), 0);
d1151 1
a1151 1
      bomIndexOut = myBomEntEB.getValue (bomIndex ());
d1166 1
a1166 1
      bopIndexOut = myBopEntEC.getValue (bopIndex ());
d1459 8
a1466 5
      myPartC  .setValue (buildNstn (), true);
      myPartA  .setValue (supplyVol (), new double[] {10, 10, 10});
      myPartB  .setValue (supplyVol (), new double[] {60,  0, 50});
      myDemandD.setValue (demandVol (), new double[] {20,  0, 30});
      myDemandE.setValue (demandVol (), new double[] {20, 10, 10});
d1584 7
d1611 2
d1620 2
d1623 1
a1623 1
      theTripleListIn  = new ArrayList <AllocTriple <Demand>> (4);
d1630 2
d1666 1
a1666 1
      printPip ("ConsVol", theTripleList);
d1683 1
a1683 1
      printPip ("CoExecVol", theTripleList);
d1700 1
a1700 1
      printPip ("ExecVol", theTripleList);
d1717 1
a1717 1
      printPip ("ProdVol", theTripleList);
d1721 1
a1721 1
// testSubVolPip ()
d1723 1
a1723 1
// Tests Demand.getSubVolPip.
d1726 1
a1726 1
   private void testSubVolPip ()
d1728 1
a1728 1
      ArrayList <AllocTriple <Substitute>> theTripleList;
d1730 1
a1730 1
      theTripleList = new ArrayList <AllocTriple <Substitute>> (0);
d1732 1
a1732 1
      myDemandD.getSubVolPip (2, theTripleList);
d1734 1
a1734 1
      printPip ("SubVol", theTripleList);
d1738 1
a1738 1
// testSideVolPip ()
d1740 1
a1740 1
// Tests Demand.getSideVolPip.
d1743 1
a1743 1
   private void testSideVolPip ()
d1745 1
a1745 1
      ArrayList <AllocTriple <Part>> theTripleList;
d1747 1
a1747 1
      theTripleList = new ArrayList <AllocTriple <Part>> (0);
d1749 1
a1749 1
      myDemandD.getSideVolPip (2, theTripleList);
d1751 1
a1751 1
      printPip ("SideVol", theTripleList);
d1768 1
a1768 1
      printPip ("SupplyVol", theTripleList);
d1772 1
a1772 1
// printPip (theAttName, theTripleList)
d1774 2
a1775 2
// Print the PIP for Demand D in Period 2 given in theTripleList for the
// peggoing attribute indicated by theAttName.
d1780 2
d1786 6
a1791 1
       + theAttName + " PIP for Demand D in Period 2:\n");
d1998 1
d2001 1
d2003 2
a2004 2
   private BomEntry      myBomEntEA;
   private BomEntry      myBomEntEB;
d2006 2
a2007 1
   private BopEntry      myBopEntEC;
@


1.61
log
@PIP.
@
text
@d1543 7
a1549 2
      testConsVolPip ();
      testExecVolPip ();
d1651 17
d1685 68
@


1.60
log
@Added the AllocTripleList classes.
@
text
@d1543 1
d1556 1
d1565 1
a1565 1
      
d1572 7
d1629 17
d1659 17
a1675 1
      println ("ExecVol PIP for Operation F in Period 2:\n");
d1677 1
a1677 1
      for (AllocTriple <Operation> theTriple: theTripleList)
@


1.59
log
@Moved set/get-PipSeq from class Problem to class GlobalElement.
@
text
@d1502 1
a1502 1
      ArrayList <AllocTriple <Demand>> theTriples;
d1506 2
a1507 2
      theTriple0 = AllocTriple.newInstance (myDemandD, 2, 50);
      theTriple1 = AllocTriple.newInstance (myDemandE, 2, 40);
d1509 1
a1509 1
      theTriples = new ArrayList <AllocTriple <Demand>> (2);
d1511 2
a1512 2
      theTriples.add (0, theTriple0);
      theTriples.add (1, theTriple1);
d1518 1
a1518 1
      incVolVec = myProblem.eqHeurAlloc (theTriples);
d1584 2
a1585 2
      ArrayList <AllocTriple <Demand>> theTriplesIn;
      ArrayList <AllocTriple <Demand>> theTriplesOut;
d1587 12
a1598 12
      theTriple0    = AllocTriple.newInstance (myDemandD, 0, 20);
      theTriple1    = AllocTriple.newInstance (myDemandE, 0, 20);
      theTriple2    = AllocTriple.newInstance (myDemandD, 2, 30);
      theTriple3    = AllocTriple.newInstance (myDemandE, 2, 10);

      theTriplesIn  = new ArrayList <AllocTriple <Demand>> (4);
      theTriplesOut = new ArrayList <AllocTriple <Demand>> (0);

      theTriplesIn.add (0, theTriple0);
      theTriplesIn.add (1, theTriple1);
      theTriplesIn.add (2, theTriple2);
      theTriplesIn.add (3, theTriple3);
d1600 2
a1601 2
      myGlobalElement.setPipSeq (theTriplesIn);
      myGlobalElement.getPipSeq (theTriplesOut);
d1605 1
a1605 1
      for (AllocTriple <Demand> theTriple: theTriplesOut)
d1627 1
a1627 1
      ArrayList <AllocTriple <Operation>> theTriples;
d1629 1
a1629 1
      theTriples = new ArrayList <AllocTriple <Operation>> (0);
d1631 1
a1631 1
      myDemandD.getExecVolPip (2, theTriples);
d1635 1
a1635 1
      for (AllocTriple <Operation> theTriple: theTriples)
@


1.58
log
@Demand.getExecVolPip
@
text
@d1600 2
a1601 2
      myProblem.setPipSeq (theTriplesIn);
      myProblem.getPipSeq (theTriplesOut);
@


1.57
log
@Added unit test code for class AllocTriple <E>.
@
text
@d1458 3
a1460 3
      myPartB  .setValue (supplyVol (), new double[] {40,  0, 50});
      myDemandD.setValue (demandVol (), new double[] {20, 20, 20});
      myDemandE.setValue (demandVol (), new double[] {10, 10, 10});
d1480 1
a1480 1
      incVol = myDemandD.incHeurAlloc (1, 30);
d1488 2
a1489 1
      assertApproxEq (incVol, 25);
a1501 1
      AllocTriple <Demand>             theTriple2;
d1506 2
a1507 3
      theTriple0 = AllocTriple.newInstance (myDemandD, 0, 20);
      theTriple1 = AllocTriple.newInstance (myDemandD, 1, 10);
      theTriple2 = AllocTriple.newInstance (myDemandE, 0, 10);
d1509 1
a1509 1
      theTriples = new ArrayList <AllocTriple <Demand>> (3);
a1512 1
      theTriples.add (2, theTriple2);
d1514 1
a1514 1
      myGlobalElement.setValue (equitability (), 10);
d1524 3
a1526 3
      assertApproxEq (incVolVec[0], 14);
      assertApproxEq (incVolVec[1],  7);
      assertApproxEq (incVolVec[2],  8);
d1537 19
d1558 1
a1558 1
      myProblem.buildPip    ();
d1560 10
a1569 1
      testPipShipSeq        ();
d1588 2
a1589 2
      theTriple1    = AllocTriple.newInstance (myDemandE, 0, 10);
      theTriple2    = AllocTriple.newInstance (myDemandD, 2, 25);
d1603 2
d1608 2
a1609 1
            theTriple.getE     ()
d1616 21
a1636 2
      for (AllocTriple <Demand> theTriple: theTriplesOut)
         println (theTriple);
d1796 11
@


1.56
log
@Implemented getPipSeq.
@
text
@d1579 9
a1588 1
         }
@


1.55
log
@Implemented buildPip and setPipSeq.
@
text
@d1558 2
a1559 1
      ArrayList <AllocTriple <Demand>> theTriples;
d1561 12
a1572 4
      theTriple0 = AllocTriple.newInstance (myDemandD, 0, 20);
      theTriple1 = AllocTriple.newInstance (myDemandE, 0, 10);
      theTriple2 = AllocTriple.newInstance (myDemandD, 2, 25);
      theTriple3 = AllocTriple.newInstance (myDemandE, 2, 10);
d1574 2
a1575 1
      theTriples = new ArrayList <AllocTriple <Demand>> (4);
d1577 4
a1580 6
      theTriples.add (0, theTriple0);
      theTriples.add (1, theTriple1);
      theTriples.add (2, theTriple2);
      theTriples.add (3, theTriple3);

      myProblem.setPipSeq (theTriples);
@


1.54
log
@Replaced Java class AllocTarget with AllocTriple <Demand>.
@
text
@d105 1
d1456 5
a1460 6
      myGlobalElement.setValue (equitability (), 10);
      myPartC        .setValue (buildNstn (),    true);
      myPartA        .setValue (supplyVol (),    new double[] {10, 10, 10});
      myPartB        .setValue (supplyVol (),    new double[] {40,  0, 50});
      myDemandD      .setValue (demandVol (),    new double[] {20, 20, 20});
      myDemandE      .setValue (demandVol (),    new double[] {10, 10, 10});
d1516 2
d1520 1
a1520 1
      incVolVec  = myProblem.eqHeurAlloc (theTriples);
d1524 2
d1532 44
@


1.53
log
@Removed eqHeurAllocTwme
@
text
@d104 1
d1471 2
a1472 4
      boolean       activeVal;
      double        incVol;
      AllocTarget[] theTargetArr;

d1489 1
d1491 5
a1495 1
      //........................................................................
d1497 14
a1510 1
      myProblem.startHeurAlloc ();
d1512 3
a1514 1
      theTargetArr    = new AllocTarget[3];
d1516 1
a1516 3
      theTargetArr[0] = AllocTarget.newInstance (myDemandD, 0, 20);
      theTargetArr[1] = AllocTarget.newInstance (myDemandD, 1, 10);
      theTargetArr[2] = AllocTarget.newInstance (myDemandE, 0, 10);
d1518 1
a1518 1
      myProblem.eqHeurAlloc (theTargetArr);
d1522 3
a1524 3
      assertApproxEq (theTargetArr[0].getIncVol (), 14);
      assertApproxEq (theTargetArr[1].getIncVol (),  7);
      assertApproxEq (theTargetArr[2].getIncVol (),  8);
@


1.52
log
@Problem.eqHeurAlloc.
@
text
@d1472 1
a1472 1
      AllocTarget[] theAllocArr;
a1473 1
      myGlobalElement.setValue (twoWayMultiExec (), true);
d1481 1
a1481 3
      incVol = myDemandD.incHeurAllocTwme (2, 80, true);

      assertApproxEq (incVol, 55);
a1488 8
      //........................................................................

      myGlobalElement.setValue (twoWayMultiExec (), false);

      myProblem.startHeurAlloc ();

      incVol = myDemandD.incHeurAlloc (1, 30);

a1490 2
      myProblem.finishHeurAlloc ();

d1495 1
a1495 1
      theAllocArr    = new AllocTarget[3];
d1497 3
a1499 3
      theAllocArr[0] = AllocTarget.newInstance (myDemandD, 0, 20);
      theAllocArr[1] = AllocTarget.newInstance (myDemandD, 1, 10);
      theAllocArr[2] = AllocTarget.newInstance (myDemandE, 0, 10);
d1501 1
a1501 1
      myProblem.eqHeurAlloc (theAllocArr);
d1504 4
@


1.51
log
@Heuristic Allocation
@
text
@d227 4
a230 3
      myOpnE     = Operation .newInstance (myProblem,  "E");
      myBomEntEA = BomEntry  .newInstance (myOpnE,     myPartA);
      myBomEntEB = BomEntry  .newInstance (myOpnE,     myPartB);
d232 1
a232 1
      myBopEntEC = BopEntry  .newInstance (myOpnE,     myPartC);
d252 2
a253 1
      println (myOpnE);
d272 2
a273 2
      println ("myProblem .getOperation  (\"E\"): "
              + myProblem .getOperation  ( "E" ));
d282 4
a285 4
      println ("myOpnE    .getBomEntry   (1):   "
              + myOpnE    .getBomEntry   (1));
      println ("myOpnE    .getBopEntry   (0):   "
              + myOpnE    .getBopEntry   (0));
d331 2
a332 2
          myOpnE.getBomEntries (),
         "myOpnE.getBomEntries ()");
d335 2
a336 2
          myOpnE.getBopEntries (),
         "myOpnE.getBopEntries ()");
d780 1
a780 1
         verifyDefaultValue (theAtt, myOpnE);
d1025 1
a1025 1
      myOpnE.setValue (execPenalty (), 2.0);
d1027 1
a1027 1
      execPenaltyOut = myOpnE.getValue (execPenalty ());
d1031 1
a1031 1
      myOpnE.setValue (execPenalty (), 0.0);
d1260 2
a1261 2
      myOpnE.setValue (execBounds (), null,      softLBin,  null);
      myOpnE.getValue (execBounds (), hardLBout, softLBout, hardUBout);
d1267 1
a1267 1
      resetBoundSet (myOpnE, execBounds ());
d1281 1
a1281 1
      operationNameIn  = "Temporary Name for Operation E";
d1283 1
a1283 1
      myOpnE.setValue (operationName (), operationNameIn);
d1285 1
a1285 1
      operationNameOut = myOpnE.getValue (operationName ());
d1289 1
a1289 1
      myOpnE.setValue (operationName (), "E");
d1454 6
a1459 5
      myPartC  .setValue (buildNstn (), true);

      myPartA  .setValue (supplyVol (), new double[] {10, 10, 10});
      myPartB  .setValue (supplyVol (), new double[] {40,  0, 50});
      myDemandD.setValue (demandVol (), new double[] {20, 20, 20});
d1470 3
a1472 1
      double incVol;
d1478 3
a1480 1
      assert (  myGlobalElement.getValue (heurAllocActive ()));
d1488 3
a1490 1
      assert (! myGlobalElement.getValue (heurAllocActive ()));
d1503 14
d1710 2
a1711 1
   private Operation     myOpnE;
@


1.50
log
@Heuristic Allocation
@
text
@d1469 2
d1475 4
d1483 4
@


1.49
log
@Heuristic Allocation
@
text
@d102 1
a980 1
      boolean expAllowedIn;
d983 1
a983 1
      expAllowedIn  = false;
d985 1
a985 1
      myBopEntEC.setValue (expAllowed (), expAllowedIn);
d987 1
a987 1
      expAllowedOut = myBopEntEC.getValue (expAllowed ());
d989 1
a989 1
      assert (expAllowedOut == expAllowedIn);
a1000 1
      int earliestPeriodIn;
d1003 1
a1003 1
      earliestPeriodIn  = 1;
d1005 1
a1005 1
      myBopEntEC.setValue (earliestPeriod (), earliestPeriodIn);
d1007 1
a1007 1
      earliestPeriodOut = myBopEntEC.getValue (earliestPeriod ());
d1009 1
a1009 1
      assert (earliestPeriodOut == earliestPeriodIn);
a1020 1
      double execPenaltyIn;
d1023 1
a1023 1
      execPenaltyIn  = 2.0;
d1025 1
a1025 1
      myOpnE.setValue (execPenalty (), execPenaltyIn);
d1027 1
a1027 1
      execPenaltyOut = myOpnE.getValue (execPenalty ());
d1029 1
a1029 1
      assert (execPenaltyOut == execPenaltyIn);
d1055 2
d1082 2
d1109 2
a1192 1
      double[] zeroArr;
a1201 2
      zeroArr   = new double[] {  0.0,   0.0,   0.0};

d1209 1
a1209 1
      myDemandD.setValue (cumShipBounds (), zeroArr,   null,      null);
d1264 2
d1366 19
d1421 3
a1423 1
      assert (theMethod.equals (OptInitMethod.CRASH));
d1444 16
d1467 1
a1467 1
      assert (! myGlobalElement.getValue (heurAllocActive ()));
d1479 3
a1481 1
      assert (  myGlobalElement.getValue (heurAllocActive ()));
a1483 2

      assert (! myGlobalElement.getValue (heurAllocActive ()));
d1572 1
a1572 1
// assertApproxEq (theDblVec1, theDblVec2) methods
d1592 1
a1592 1
// assertApproxEq (theDbl1, theDbl2) methods
@


1.48
log
@OptInitMethod.
@
text
@d102 2
d1420 27
@


1.47
log
@Implemented method writeData of class Problem.
@
text
@d100 1
d1384 18
a1401 1
// testSetGetAppData ()
@


1.46
log
@Implemented the following methods of class Problem:
   mrp
   optImplode
   preprocess
@
text
@d101 1
@


1.45
log
@Removed Attribute wit34Compatible.
@
text
@d101 1
d106 1
d108 1
d1185 1
d1195 2
d1203 2
d1339 1
d1349 2
d1357 2
@


1.44
log
@Added Attribute wit34Compatible.
@
text
@a470 1
      display (wit34Compatible     ());
@


1.43
log
@Added setAppData and getAppData methods to class Element.
@
text
@d471 1
@


1.42
log
@Minor revisions.
@
text
@d100 1
d1105 1
a1105 1
// Tests customized attributes.
d1126 1
a1126 1
// Tests the "bomIndex" attribute.
d1141 1
a1141 1
// Tests the "bopIndex" attribute.
d1156 1
a1156 1
// Tests the "subIndex" attribute.
d1171 1
a1171 1
// Tests the "cumShipBounds" attribute.
d1202 1
a1202 1
// Tests the "demandName" attribute.
d1224 1
a1224 1
// Tests the "execBounds" attribute.
d1256 1
a1256 1
// Tests the "operationName" attribute.
d1278 1
a1278 1
// Tests the "partName" attribute.
d1300 1
a1300 1
// Tests the "solverLogFileName" attribute.
d1320 1
a1320 1
// Tests the "stockBounds" attribute.
d1351 1
a1351 1
// Tests the "title" attribute.
d1369 17
@


1.41
log
@theProblem.performAction (theCommand)
@
text
@d1548 1
a1548 1
// Public WIT-J objects for the unit test.
@


1.40
log
@theProblem.performAction (theCommand)
@
text
@d87 19
a105 19
      testMsgMgr1                   ();
      enableProblem                 ();
      testMsgMgr2                   ();
      myProblem.performActionInJava ("self-test");
      buildElements                 ();
      printPublicObjects            ();
      testScalarNavMethods          ();
      testArrayNavMethods           ();
      displayAttributes             ();
      checkForNonAppAttributes      ();
      verifyDefaultValues           ();
      testSetGetValue               ();
      testCustAtts                  ();
      myProblem.displayData         ("");
      myProblem.generatePriorities  ();
      myProblem.postprocess         ();
      myProblem.heurImplode         ();
      myProblem.evalObjectives      ();
      myProblem.shutDown            ();
d107 1
a107 1
      assert (! myProblem.isActive  ());
@


1.39
log
@Implemented the recovery test.
@
text
@a82 2
      Problem.selfTest ();

d87 19
a105 18
      testMsgMgr1                  ();
      enableProblem                ();
      testMsgMgr2                  ();
      buildElements                ();
      printPublicObjects           ();
      testScalarNavMethods         ();
      testArrayNavMethods          ();
      displayAttributes            ();
      checkForNonAppAttributes     ();
      verifyDefaultValues          ();
      testSetGetValue              ();
      testCustAtts                 ();
      myProblem.displayData        ("");
      myProblem.generatePriorities ();
      myProblem.postprocess        ();
      myProblem.heurImplode        ();
      myProblem.evalObjectives     ();
      myProblem.shutDown           ();
d107 1
a107 1
      assert (! myProblem.isActive ());
@


1.38
log
@Changed a Java class name: WitjAbortsException ==> TerminalException
@
text
@d111 4
@


1.37
log
@Changed class name: NonFunctionalException ==> WitjAbortsException
@
text
@d85 1
a85 1
      assert (! WitjAbortsException.witjHasAborted ());
@


1.36
log
@Moved more responsibility into class NonFunctionalException.
@
text
@d85 1
a85 1
      assert (NonFunctionalException.witjIsFunctional ());
@


1.35
log
@Initial implementation of class ExceptionHandler.
@
text
@d85 1
a85 1
      assert (Problem.witjIsFunctional ());
@


1.34
log
@Replaced "assert (false)" with "throw new AssertionError ()"
@
text
@d85 2
@


1.33
log
@Attributes
@
text
@d577 1
a577 3
      assert (false);

      return null;
@


1.32
log
@Changed name of method Attribute.allowsSetValue to isModifiable.
@
text
@d544 2
a545 1
            asString (myProblem.getDefaultValue (theAtt.asBoolAtt ()));
d549 2
a550 1
            asString (myProblem.getDefaultValue (theAtt.asIntAtt ()));
d554 2
a555 1
            asString (myProblem.getDefaultValue (theAtt.asDblAtt ()));
d559 1
a559 1
            myProblem.getDefaultValue (theAtt.asStringAtt ());
d563 1
a563 1
            defaultValTextBV (theAtt.asBoolVecAtt ());
d567 1
a567 1
            defaultValTextIV (theAtt.asIntVecAtt ());
d571 1
a571 1
            defaultValTextDV (theAtt.asDblVecAtt ());
d575 1
a575 1
            defaultValTextBS (theAtt.asBoundSetAtt ());
d812 1
a812 1
      theBoolAtt = theAtt.asBoolAtt ();
d826 1
a826 1
      theIntAtt = theAtt.asIntAtt ();
d840 1
a840 1
      theDblAtt = theAtt.asDblAtt ();
d854 1
a854 1
      theStringAtt = theAtt.asStringAtt ();
d869 1
a869 1
      theBoolVecAtt = theAtt.asBoolVecAtt ();
d886 1
a886 1
      theIntVecAtt = theAtt.asIntVecAtt ();
d903 1
a903 1
      theDblVecAtt = theAtt.asDblVecAtt ();
d925 1
a925 1
      theBoundSetAtt = theAtt.asBoundSetAtt ();
@


1.31
log
@Changed the default value of quite mode from false to true.
Changed MessageMgr method names:
   setQuietMode ==> setQuiet
   getQuietMode ==> isQuiet
@
text
@d513 1
a513 1
      println ("      Allows Set: " + theAtt.allowsSetValue ());
@


1.30
log
@Removed class Session from the public interface.
@
text
@d119 1
a119 1
      boolean theQuietMode;
d121 2
a122 1
      myMessageMgr = myProblem.getMessageMgr ();
d124 1
a124 1
      myMessageMgr.setQuietMode (true);
d126 2
a127 3
      theQuietMode = myMessageMgr.getQuietMode ();

      assert (theQuietMode);
d129 1
a129 1
      myMessageMgr.setMesgFileName ("UnitTester.out");
d131 1
a131 1
      myMessageMgr.setQuietMode (false);
a161 2

      assert (myProblem.getMessageMgr () == myMessageMgr);
d1374 1
a1374 1
      theProblem.getMessageMgr ().setQuietMode (true);
@


1.29
log
@Replaced theAtt.getIsInputAtt (theProblem) with theAtt.allowsSetValue ().
@
text
@d83 1
a83 1
      Session.selfTest ();
d85 1
a85 1
      mySession = Session.newInstance ();
d88 1
a88 1
      setUpProblem                 ();
d104 1
a104 1
      mySession.shutDown           ();
d121 1
a121 1
      myMessageMgr = mySession.getMessageMgr ();
d135 1
a135 1
// setUpProblem ().
d137 1
a137 1
// Performs initial set-up of the Problem the for unit test.
d140 1
a140 1
   private void setUpProblem ()
d142 10
a151 1
      int nPeriodsVal;
d153 1
a153 1
      myProblem       = Problem.newInstance (mySession);
d227 1
a227 1
// Prints the Session and the public objects that it owns.
d233 1
a233 1
      println (mySession);
a234 1
      println (myProblem);
a1370 1
      Session theSession;
d1374 1
a1374 1
      theSession = Session.newInstance ();
d1376 1
a1376 1
      theSession.getMessageMgr ().setQuietMode (true);
d1378 1
a1378 1
      theSession.getMessageMgr ().setMesgFileAccessMode ("a");
d1380 1
a1380 1
      theSession.getMessageMgr ().setMesgFileName ("UnitTester.out");
d1382 1
a1382 1
      theProblem = Problem.newInstance (theSession);
d1399 1
a1399 1
      theProblem.getSession ().shutDown ();
d1547 1
a1547 1
   private Session       mySession;
a1548 1
   private Problem       myProblem;
@


1.28
log
@Made enum DefaultCase non-nested.
@
text
@d507 1
a507 4
      if (theAtt.getIsInputAtt (myProblem))
         println ("      Access:     Input");
      else
         println ("      Access:     Output");
@


1.27
log
@Method name changes:
   theElement.set (...) ==> theElement.setValue (...)
   theElement.get (...) ==> theElement.getValue (...)
@
text
@d796 1
a796 1
// of so, verifies that WIT-J's default value for theAtt matches that in WIT.
@


1.26
log
@Changed method name:
   Attribute.values () ==> Attribute.getAllAttributes ()
@
text
@d97 1
a97 1
      testSetGet                   ();
d148 1
a148 1
      myGlobalElement.set (nPeriods (), 3);
d150 1
a150 1
      nPeriodsVal     = myGlobalElement.get (nPeriods ());
d810 1
a810 1
         == theElem  .get             (theBoolAtt));
d824 1
a824 1
         == theElem  .get             (theIntAtt));
d838 1
a838 1
         theElem  .get             (theDblAtt));
d852 1
a852 1
         theElem  .get             (theStringAtt)));
d869 1
a869 1
      assertEq (theBoolVec, theElem.get (theBoolVecAtt));
d886 1
a886 1
      assertEq (theIntVec, theElem.get (theIntVecAtt));
d903 1
a903 1
      assertApproxEq (theDblVec, theElem.get (theDblVecAtt));
d930 2
a931 1
      theElem.get        (theBoundSetAtt, hardLBVal, softLBVal, hardUBVal);
d939 1
a939 1
// testSetGet ()
d941 1
a941 1
// Tests Attribute set and get methods of class Element.
d944 1
a944 1
   private void testSetGet ()
d957 2
a958 1
// Tests Attribute set and get methods for Attributes of value type boolean.
d968 1
a968 1
      myBopEntEC.set (expAllowed (), expAllowedIn);
d970 1
a970 1
      expAllowedOut = myBopEntEC.get (expAllowed ());
d978 2
a979 1
// Tests Attribute set and get methods for Attributes of value type int.
d989 1
a989 1
      myBopEntEC.set (earliestPeriod (), earliestPeriodIn);
d991 1
a991 1
      earliestPeriodOut = myBopEntEC.get (earliestPeriod ());
d999 2
a1000 1
// Tests Attribute set and get methods for Attributes of value type double.
d1010 1
a1010 1
      myOpnE.set (execPenalty (), execPenaltyIn);
d1012 1
a1012 1
      execPenaltyOut = myOpnE.get (execPenalty ());
d1020 2
a1021 1
// Tests Attribute set and get methods for Attributes of value type boolean[].
d1033 2
a1034 2
      myPartB.set (propRtg (), propRtgIn);
      myPartB.get (propRtg (), propRtgOut1);
d1036 1
a1036 1
      propRtgOut2 = myPartB.get (propRtg ());
d1045 2
a1046 1
// Tests Attribute set and get methods for Attributes of value type int[].
d1058 2
a1059 2
      myDemandD.set (priority (), priorityIn);
      myDemandD.get (priority (), priorityOut1);
d1061 1
a1061 1
      priorityOut2 = myDemandD.get (priority ());
d1070 2
a1071 1
// Tests Attribute set and get methods for Attributes of value type double[].
d1083 2
a1084 2
      myPartB.set (supplyVol (), supplyVolIn);
      myPartB.get (supplyVol (), supplyVolOut1);
d1086 1
a1086 1
      supplyVolOut2 = myPartB.get (supplyVol ());
d1123 1
a1123 1
      bomIndexOut = myBomEntEB.get (bomIndex ());
d1138 1
a1138 1
      bopIndexOut = myBopEntEC.get (bopIndex ());
d1153 1
a1153 1
      subIndexOut = mySubEAB.get (subIndex ());
d1181 2
a1182 2
      myDemandD.set (cumShipBounds (), hardLBin,  softLBin,  hardUBin);
      myDemandD.get (cumShipBounds (), hardLBout, softLBout, hardUBout);
d1202 1
a1202 1
      myDemandD.set (demandName (), demandNameIn);
d1204 1
a1204 1
      demandNameOut = myDemandD.get (demandName ());
d1208 1
a1208 1
      myDemandD.set (demandName (), "D");
d1235 2
a1236 2
      myOpnE.set (execBounds (), null,      softLBin,  null);
      myOpnE.get (execBounds (), hardLBout, softLBout, hardUBout);
d1256 1
a1256 1
      myOpnE.set (operationName (), operationNameIn);
d1258 1
a1258 1
      operationNameOut = myOpnE.get (operationName ());
d1262 1
a1262 1
      myOpnE.set (operationName (), "E");
d1278 1
a1278 1
      myPartA.set (partName (), partNameIn);
d1280 1
a1280 1
      partNameOut = myPartA.get (partName ());
d1284 1
a1284 1
      myPartA.set (partName (), "A");
d1300 1
a1300 1
      myGlobalElement.set (solverLogFileName (), solverLogFileNameIn);
d1302 1
a1302 1
      solverLogFileNameOut = myGlobalElement.get (solverLogFileName ());
d1330 2
a1331 2
      myPartC.set (stockBounds (), hardLBin,  softLBin,  hardUBin);
      myPartC.get (stockBounds (), hardLBout, softLBout, hardUBout);
d1351 1
a1351 1
      myGlobalElement.set (title (), titleIn);
d1353 1
a1353 1
      titleOut = myGlobalElement.get (title ());
d1382 1
a1382 1
      nPeriodsVal = theProblem.getGlobalElement ().get (nPeriods ());
d1384 1
a1384 1
      assert (theProblem.getGlobalElement ().get (nPeriods ()) == 2);
@


1.25
log
@Name change in class RetainedObject: getActiveState ==> isActive.
@
text
@d60 1
a60 1
         new HashSet <Attribute <?>> (Attribute.values ().length, 1.0f);
d62 1
a62 1
      for (Attribute <?> theAtt: Attribute.values ())
d690 1
a690 1
      for (Attribute <?> theAtt: Attribute.values ())
d735 1
a735 1
      for (Attribute <?> theAtt: Attribute.values ())
@


1.24
log
@Implemented method theAtt.requiresStochMode ().
@
text
@d106 1
a106 1
      assert (! myProblem.getActiveState ());
@


1.23
log
@Added theAtt.requiresMaterialPart ().
@
text
@d517 3
@


1.22
log
@Replaced Attribute partCategory with thePart.getCategory ().
@
text
@d514 3
@


1.21
log
@Re-directed the WIT output for the readData test to the disk file.
@
text
@d256 2
a405 1
      display (partCategory        ());
a1092 1
      testPartCategory      ();
a1252 15
// testPartCategory ()
//
// Tests the "partCategory" attribute.
//------------------------------------------------------------------------------

   private void testPartCategory ()
      {
      Part.Category partCategoryOut;

      partCategoryOut = myPartA.get (partCategory ());

      assert (partCategoryOut == CAPACITY);
      }

//------------------------------------------------------------------------------
@


1.20
log
@Added code to verify that the Attribute default values in WIT-J match those
in WIT.
@
text
@d121 1
a121 1
      myMgrMgr = mySession.getMessageMgr ();
d123 1
a123 1
      myMgrMgr.setQuietMode (true);
d125 1
a125 1
      theQuietMode = myMgrMgr.getQuietMode ();
d129 1
a129 1
      myMgrMgr.setMesgFileName ("UnitTester.out");
d131 1
a131 1
      myMgrMgr.setQuietMode (false);
d154 1
a154 1
      assert (myProblem.getMessageMgr () == myMgrMgr);
d169 1
a169 1
      theName = myMgrMgr.getMesgFileName ();
d173 1
a173 1
      myMgrMgr.setMesgFileAccessMode ("a");
d175 1
a175 1
      theMode = myMgrMgr.getMesgFileAccessMode ();
d179 1
a179 1
      myMgrMgr.setMesgFileAccessMode ("w");
d181 1
a181 1
      myMgrMgr.setMesgTimesPrint (101, 50);
d183 1
a183 1
      theInt = myMgrMgr.getMesgTimesPrint (101);
d187 1
a187 1
      myMgrMgr.setMesgTimesPrint (MessageGroup.INFORMATIONAL, -7);
d189 1
a189 1
      theInt = myMgrMgr.getMesgTimesPrint (101);
d212 1
a212 1
      myMgrMgr.flushFile ();
d225 1
a225 1
      println (myMgrMgr);
d1373 7
d1546 1
a1546 1
   private MessageMgr    myMgrMgr;
@


1.19
log
@Added Attribute fssShipVol.
@
text
@d96 1
d717 214
@


1.18
log
@Removed earlier test code for default values.
@
text
@d368 1
@


1.17
log
@Removed the earlier test code for the Attribute type conversion methods.
@
text
@a89 3
      testScalarAttDefaults        ();
      testVectorAttDefaults        ();
      testBoundSetAttDefaults      ();
a192 111

//------------------------------------------------------------------------------
// testScalarAttDefaults ().
//
// Tests methods for default values of scalar Attributes.
//------------------------------------------------------------------------------

   private void testScalarAttDefaults ()
      {
      System.out.printf (
         "%n"
       + "Attribute Default Values:%n"
       + "%n");

      System.out.printf (
         "   expAllowed:   %s%n",
         myProblem.getDefaultValue (expAllowed ()));

      System.out.printf (
         "   latestPeriod: %d%n",
         myProblem.getDefaultValue (latestPeriod ()));

      System.out.printf (
         "   lotSizeTol:   %.5f%n",
         myProblem.getDefaultValue (lotSizeTol ()));

      System.out.printf (
         "   title:        %s%n",
         myProblem.getDefaultValue (title ()));
      }

//------------------------------------------------------------------------------
// testVectorAttDefaults ().
//
// Tests methods for default values of vector Attributes.
//------------------------------------------------------------------------------

   private void testVectorAttDefaults ()
      {
      boolean[] theBoolArr;
      int[]     theIntArr;
      double[]  theDblArr;

      theBoolArr = new boolean[3];
      theIntArr  = new int    [3];
      theDblArr  = new double [3];

      myProblem.getDefaultValue (propRtg (),      theBoolArr);
      myProblem.getDefaultValue (buildAheadUB (), theIntArr);
      myProblem.getDefaultValue (consRate (),     theDblArr);

      System.out.printf (
         "   propRtg:      %s %s %s%n",
         theBoolArr[0],
         theBoolArr[1],
         theBoolArr[2]);

      System.out.printf (
         "   buildAheadUB: %d %d %d%n",
         theIntArr[0],
         theIntArr[1],
         theIntArr[2]);

      System.out.printf (
         "   consRate:     %.0f %.0f %.0f%n",
         theDblArr[0],
         theDblArr[1],
         theDblArr[2]);
      }

//------------------------------------------------------------------------------
// testBoundSetAttDefaults ().
//
// Tests the method for default values of BoundSet Attributes.
//------------------------------------------------------------------------------

   private void testBoundSetAttDefaults ()
      {
      double[] hardLB;
      double[] softLB;
      double[] hardUB;

      hardLB = new double [3];
      softLB = new double [3];
      hardUB = new double [3];

      myProblem.
         getDefaultValue (execBounds (), hardLB, softLB, hardUB);

      System.out.printf (
         "   execBounds:%n");

      System.out.printf (
         "      hardLB:    %.0f %.0f %.0f%n",
         hardLB[0],
         hardLB[1],
         hardLB[2]);

      System.out.printf (
         "      softLB:    %.0f %.0f %.0f%n",
         softLB[0],
         softLB[1],
         softLB[2]);

      System.out.printf (
         "      hardUB:    %.0f %.0f %.0f%n",
         hardUB[0],
         hardUB[1],
         hardUB[2]);
      }

@


1.16
log
@Added display of default values to the unit test.
@
text
@a93 1
      testAttConversions           ();
a328 86
// testAttConversions ()
//
// Tests Attribute type conversion methods.
//------------------------------------------------------------------------------

   private void testAttConversions ()
      {
      Attribute <Boolean>       theBoolAtt;
      Attribute <Integer>       theIntAtt;
      Attribute <Double>        theDblAtt;
      Attribute <String>        theStringAtt;
      Attribute <Part.Category> thePartCatAtt;
      Attribute <boolean[]>     theBoolVecAtt;
      Attribute <int[]>         theIntVecAtt;
      Attribute <double[]>      theDblVecAtt;
      Attribute <BoundSet>      theBoundSetAtt;
      double[]                  hardLB;
      double[]                  softLB;
      double[]                  hardUB;

      theBoolAtt     = firstAttFor (Boolean      .class).asBoolAtt         ();
      theIntAtt      = firstAttFor (Integer      .class).asIntAtt          ();
      theDblAtt      = firstAttFor (Double       .class).asDblAtt          ();
      theStringAtt   = firstAttFor (String       .class).asStringAtt       ();
      thePartCatAtt  = firstAttFor (Part.Category.class).asPartCategoryAtt ();
      theBoolVecAtt  = firstAttFor (boolean[]    .class).asBoolVecAtt      ();
      theIntVecAtt   = firstAttFor (int[]        .class).asIntVecAtt       ();
      theDblVecAtt   = firstAttFor (double[]     .class).asDblVecAtt       ();
      theBoundSetAtt = firstAttFor (BoundSet     .class).asBoundSetAtt     ();

      System.out.printf (
         "%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n"
       + "%s = %s%n",
                              theBoolAtt,
         myGlobalElement.get (theBoolAtt),
                              theIntAtt,
         myBomEntEA     .get (theIntAtt),
                              theDblAtt,
         myGlobalElement.get (theDblAtt),
                              theStringAtt,
         myDemandD      .get (theStringAtt),
                              thePartCatAtt,
         myPartC        .get (thePartCatAtt),
                              theBoolVecAtt,
         myOpnE         .get (theBoolVecAtt)[0],
                              theIntVecAtt,
         myPartC        .get (theIntVecAtt)[0],
                              theDblVecAtt,
         myBomEntEA     .get (theDblVecAtt)[0]);

      hardLB = new double[3];
      softLB = new double[3];
      hardUB = new double[3];

      myDemandD.get (theBoundSetAtt, hardLB, softLB, hardUB);

      System.out.printf (
         "%s = %s%n",
         theBoundSetAtt,
         hardLB[0]);
      }

//------------------------------------------------------------------------------
// firstAttFor (theValueType)
//
// Returns the first Attribute whose value type is theValueType.
//------------------------------------------------------------------------------

   private Attribute <?> firstAttFor (Class <?> theValueType)
      {
      for (Attribute <?> theAtt: Attribute.values ())
         if (theAtt.getValueType () == theValueType)
            return theAtt;

      assert (false);
            
      return null;
      }
//------------------------------------------------------------------------------
@


1.15
log
@Attribute type conversion.
@
text
@d710 2
d716 154
d1485 1
a1485 1
   static void printArray (Object[] theArr, String theArrName)
d1501 1
a1501 1
   static void println (Object theObject)
d1506 9
@


1.14
log
@Minor revision.
@
text
@d94 1
d197 1
d330 86
@


1.13
log
@Default values.
@
text
@d62 2
a63 2
      for (Attribute <?> theAttribute: Attribute.values ())
         undisplayedAttributes.add (theAttribute);
d583 1
a583 1
         for (Attribute <?> theAttribute: undisplayedAttributes)
d585 1
a585 1
            println ("   " + theAttribute);
d591 1
a591 1
// display (theAttribute)
d593 1
a593 1
// Displays information about theAttribute.
d597 1
a597 1
   private void display (Attribute <?> theAttribute)
d599 1
a599 1
      assert (undisplayedAttributes.contains (theAttribute));
d603 1
a603 1
         + "   " + theAttribute + ":");
d607 1
a607 1
         if (theAttribute.appliesTo (theClass))
d615 1
a615 1
         + theAttribute.getValueType ().getSimpleName ());
d617 1
a617 1
      if (theAttribute.getIsInputAtt (myProblem))
d622 1
a622 1
      undisplayedAttributes.remove (theAttribute);
d638 1
a638 1
      for (Attribute <?> theAttribute: Attribute.values ())
d640 1
a640 1
         if (theAttribute == null)
d647 1
a647 1
            if (theAttribute.appliesTo (theClass))
d661 1
a661 1
            println ("   " + theAttribute);
d1295 2
a1296 2
// undisplayedAttributes.contains (theAttribute) is true, iff display has not
// been invoked on theAttribute.
@


1.12
log
@Default values.
@
text
@d92 1
d266 41
@


1.11
log
@Default Values.
@
text
@d90 2
a91 1
      testAttDefaults              ();
d196 1
a196 1
// testAttDefaults ().
d198 1
a198 1
// Tests methods for Attribute default values.
d201 1
a201 1
   private void testAttDefaults ()
d226 39
@


1.10
log
@Default values.
@
text
@d204 2
a205 1
       + "Attribute   Default%n");
d208 1
a208 1
         "expAllowed  %7s%n",
d210 12
@


1.9
log
@Added theProblem.postprocess ().
@
text
@d90 1
d195 17
@


1.8
log
@Implemented theAttribute.appliesTo (theClass).
@
text
@d100 1
@


1.7
log
@Changed name of generic class AttSpec <V> to Attribute <V>.
@
text
@d49 10
a210 12

      exampleElements =
         new Element[]
            {
            myGlobalElement,
            myPartC,
            myDemandD,
            myOpnE,
            myBomEntEB,
            mySubEAB,
            myBopEntEC,
            };
d491 1
a491 1
      for (Element theElement: exampleElements)
d493 1
a493 1
         if (theAttribute.appliesTo (theElement))
d495 1
a495 3
            println (
               "      Applies to: "
             + theElement.getClass ().getSimpleName ());
d531 1
a531 1
         for (Element theElement: exampleElements)
d533 1
a533 1
            if (theAttribute.appliesTo (theElement))
d1171 1
a1171 1
// exampleElements
d1173 1
a1173 1
// Contains one Element of each Element class.
d1176 1
a1176 1
   private Element[] exampleElements;
@


1.6
log
@Removed Lister from the test battery.
@
text
@d11 1
a11 1
import static com.ibm.witj.AttSpec.*;
d49 2
a50 2
      undisplayedAttSpecs =
         new HashSet <AttSpec <?>> (AttSpec.values ().length, 1.0f);
d52 2
a53 2
      for (AttSpec <?> theAttSpec: AttSpec.values ())
         undisplayedAttSpecs.add (theAttSpec);
d84 2
a85 2
      displayAttSpecs              ();
      checkForNonAppAttSpecs       ();
d320 1
a320 1
// displayAttSpecs ()
d323 1
a323 1
   private void displayAttSpecs ()
d327 1
a327 1
         + "AttSpecs:");
d459 1
a459 1
      if (undisplayedAttSpecs.isEmpty ())
d463 1
a463 1
            + "All AttSpecs have been displayed.");
d469 1
a469 1
          + "The following AttSpecs were missing from the above listing:\n");
d471 1
a471 1
         for (AttSpec <?> theAttSpec: undisplayedAttSpecs)
d473 1
a473 1
            println ("   " + theAttSpec);
d479 1
a479 1
// display (theAttSpec)
d481 2
a482 2
// Displays information about theAttSpec.
// To be invoked exactly once for each AttSpec.
d485 1
a485 1
   private void display (AttSpec <?> theAttSpec)
d487 1
a487 1
      assert (undisplayedAttSpecs.contains (theAttSpec));
d491 1
a491 1
         + "   " + theAttSpec + ":");
d495 1
a495 1
         if (theAttSpec.appliesTo (theElement))
d505 1
a505 1
         + theAttSpec.getValueType ().getSimpleName ());
d507 1
a507 1
      if (theAttSpec.getIsInputAtt (myProblem))
d512 1
a512 1
      undisplayedAttSpecs.remove (theAttSpec);
d516 1
a516 1
// checkForNonAppAttSpecs ()
d518 1
a518 1
// Displays all AttSpecs that don't apply to any Element class.
d521 1
a521 1
   private void checkForNonAppAttSpecs ()
d528 1
a528 1
      for (AttSpec <?> theAttSpec: AttSpec.values ())
d530 1
a530 1
         if (theAttSpec == null)
d537 1
a537 1
            if (theAttSpec.appliesTo (theElement))
d546 1
a546 1
                + "The following AttSpecs do not apply to any Element class:"
d551 1
a551 1
            println ("   " + theAttSpec);
d558 1
a558 1
          + "All AttSpecs apply to at least one Element class.");
d564 1
a564 1
// Tests AttSpec set and get methods of class Element.
d580 1
a580 1
// Tests AttSpec set and get methods for AttSpecs of value type boolean.
d600 1
a600 1
// Tests AttSpec set and get methods for AttSpecs of value type int.
d620 1
a620 1
// Tests AttSpec set and get methods for AttSpecs of value type double.
d640 1
a640 1
// Tests AttSpec set and get methods for AttSpecs of value type boolean[].
d664 1
a664 1
// Tests AttSpec set and get methods for AttSpecs of value type int[].
d688 1
a688 1
// Tests AttSpec set and get methods for AttSpecs of value type double[].
d1183 1
a1183 1
// undisplayedAttSpecs
d1185 2
a1186 2
// undisplayedAttSpecs.contains (theAttSpec) is true, iff display has not been
// invoked on theAttSpec.
d1189 1
a1189 1
   private final HashSet <AttSpec <?>> undisplayedAttSpecs;
@


1.5
log
@Minor Revision.
@
text
@d1006 1
a1006 1
      theProblem.readData ("test.data");
d1014 1
a1014 1
       + "The following Elements were read in from file \"test.data\":\n");
@


1.4
log
@Minor revision.
@
text
@d498 1
a498 1
               "      Applies to:   "
d504 1
a504 1
           "      Value Type:   "
d507 2
a508 2
      if (theAttSpec.getInputAccess (myProblem))
         println ("      Access Style: Input");
d510 1
a510 1
         println ("      Access Style: Output");
@


1.3
log
@Made bomIndex, subIndex, and bopIndex into formal attributes.
@
text
@d94 1
a94 1
      assert (! myProblem.getActiveMode ());
@


1.2
log
@Revised factory methods.
@
text
@a265 2
      println ("myBomEntEB.getBomIndex   ():    "
              + myBomEntEB.getBomIndex   ());
a271 2
      println ("mySubEAB  .getSubIndex   ():    "
              + mySubEAB  .getSubIndex   ());
a275 2
      println ("myBopEntEC.getBopIndex   ():    "
              + myBopEntEC.getBopIndex   ());
d334 2
d446 1
d717 2
d727 1
d732 45
@


1.1
log
@Moved unit test to class UnitTester.
@
text
@d75 1
a75 1
      mySession = Session.newSession ();
d132 1
a132 1
      myProblem       = mySession.newProblem ();
d190 9
a198 9
      myPartA    = myProblem .newPart       ("A", CAPACITY);
      myPartB    = myProblem .newPart       ("B", CAPACITY);
      myPartC    = myProblem .newPart       ("C", MATERIAL);
      myDemandD  = myPartC   .newDemand     ("D");
      myOpnE     = myProblem .newOperation  ("E");
      myBomEntEA = myOpnE    .newBomEntry   (myPartA);
      myBomEntEB = myOpnE    .newBomEntry   (myPartB);
      mySubEAB   = myBomEntEA.newSubstitute (myPartB);
      myBopEntEC = myOpnE    .newBopEntry   (myPartC);
a257 2
      println ("myDemandD .getDemandName ():    "
              + myDemandD .getDemandName ());
d954 1
d958 2
a959 1
      theProblem = Problem.newProblem ();
@


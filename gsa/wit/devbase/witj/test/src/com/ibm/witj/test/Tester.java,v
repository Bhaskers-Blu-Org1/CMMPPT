head	1.136;
access;
symbols;
locks; strict;
comment	@# @;


1.136
date	2011.05.02.19.05.06;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2011.05.02.18.32.44;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2009.10.28.20.02.04;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2009.10.08.19.18.59;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2009.08.06.14.40.10;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2009.04.24.17.42.53;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2009.04.09.19.50.15;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2009.04.02.17.49.29;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2008.12.18.19.48.26;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2008.11.07.16.26.39;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.15.17.31.00;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2008.10.08.17.58.52;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2008.10.07.22.16.19;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2008.10.07.21.27.24;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2008.10.07.21.13.01;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2008.10.07.18.50.28;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2008.10.06.22.43.10;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2008.10.06.22.25.45;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2008.10.06.22.14.08;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2008.10.06.14.42.40;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2008.10.02.15.13.51;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2008.10.01.22.55.34;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2008.10.01.22.19.15;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2008.10.01.22.10.11;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2008.10.01.18.29.03;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2008.09.24.16.26.37;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.19.21.59.27;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2008.09.19.16.29.51;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2008.09.19.15.52.57;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2008.09.19.14.56.46;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2008.09.18.21.45.12;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2008.09.18.21.12.29;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.18.20.38.24;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.18.20.22.14;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2008.09.18.19.10.41;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.18.18.18.53;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.18.18.10.19;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2008.09.18.17.41.45;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2008.09.18.16.25.39;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2008.09.18.16.01.32;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2008.09.18.14.56.25;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2008.09.17.21.42.24;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.17.21.01.37;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.17.19.10.19;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.16.22.21.40;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2008.09.16.22.14.01;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.16.21.08.17;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2008.09.16.20.39.16;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2008.09.16.20.08.54;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2008.09.16.18.57.30;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.15.22.03.46;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2008.09.15.22.00.45;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2008.09.15.21.24.56;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2008.09.15.16.20.40;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.12.23.00.34;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.12.21.54.16;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.12.19.44.34;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2008.09.12.16.09.37;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.11.19.10.26;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2008.09.11.15.20.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.10.21.32.35;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2008.09.08.19.45.37;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.05.22.06.52;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.09.05.20.20.52;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.05.18.34.06;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2008.09.04.21.47.41;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2008.09.04.21.24.30;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2008.09.04.20.36.23;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.02.14.37.24;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.29.18.36.44;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.29.17.19.07;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.29.14.22.02;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.28.21.13.42;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2008.08.28.18.30.39;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2008.08.28.15.37.58;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.08.26.21.40.31;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.26.15.39.01;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.22.14.06.24;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.21.20.53.12;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.08.20.18.49.28;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.08.19.14.32.06;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.07.15.25.51;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.08.06.18.48.23;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.01.22.40.55;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.01.21.57.48;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.01.21.38.57;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.31.16.40.35;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.31.15.52.02;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.30.22.05.24;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.30.19.39.40;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.30.19.22.16;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.30.16.18.47;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.25.20.30.58;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.25.17.45.57;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.25.17.22.52;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.25.16.20.14;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.25.15.53.51;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.25.15.01.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.24.22.19.49;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.24.20.19.52;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.24.17.55.32;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.24.15.21.44;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.21.19.36.33;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.21.18.27.31;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.14.21.14.22;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.10.21.44.25;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.10.21.20.10;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.09.20.41.34;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.09.15.45.40;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.08.19.31.02;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.08.18.26.01;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.01.21.18.09;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.30.22.02.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.27.16.34.07;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.27.15.13.20;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.20.19.53;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.19.48.04;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.19.18.08;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.25.14.46.35;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.24.22.16.56;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.24.14.29.08;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.19.22.16.56;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.19.20.15.07;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.19.19.31.14;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.19.18.36.41;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.17.19.46.03;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.17.18.58.41;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.27.18.45.56;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.27.16.18.51;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.27.14.57.45;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.23.15.14.09;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.22.21.23.01;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.22.21.03.00;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.22.15.18.40;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.16.22.10.24;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.21.25.56;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.136
log
@Revised some comments.
@
text
@
//==============================================================================
// WIT-J/Test Source File Tester.java.
//==============================================================================

package com.ibm.witj.test;

import java.io.*;

//==============================================================================
// Class Tester
//
// Noninstantiable class.
//
// Responsible for performing a test of WIT-J indicated by the command line
// arguments.
//==============================================================================

public final class Tester
{
//==============================================================================
// Public Methods
//==============================================================================

//------------------------------------------------------------------------------
// Main Program.
//------------------------------------------------------------------------------

   public static void main (String[] theArgs)
      {
      if (theArgs.length == 0)
         {
         abortWmsg (
            "   The WIT-J Tester requires at least one command line argument.");
         }

      if      (theArgs[0].equals ("unit-test"))
         {
         UnitTester.performTest ();
         }
      else if (theArgs[0].equals ("status-quo-test"))
         {
         StatusQuoTester.performTest ();
         }
      else if (theArgs[0].equals ("error-test"))
         {
         ErrTester.performTest (theArgs);
         }
      else if (theArgs[0].equals ("thread-test"))
         {
         ThreadTester.performTest ();
         }
      else if (theArgs[0].equals ("timing-test"))
         {
         TimingTester.performTest (theArgs);
         }
      else
         {
         abortWmsg (
            "   The first argument to the WIT-J Tester must be "
          +    "one of the following:\n"
          + "      \"unit-test\"\n"
          + "      \"status-quo-test\"\n"
          + "      \"error-test\"\n"
          + "      \"thread-test\"\n"
          + "      \"timing-test\"\n"
            );
         }
      }

//==============================================================================
// Package internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// abortWmsg (errorText)
//
// Aborts the program with a message that includes errorText.
//------------------------------------------------------------------------------

   static void abortWmsg (String errorText)
      {
      System.out.println (
           "\n"
         + "Error:\n"
         + "\n"
         + errorText
         + "\n"
         + "\n"
         + "WIT-J Test aborted.\n");
   
      System.exit (3);
      }

//------------------------------------------------------------------------------
// printlnUTF8 (String theString)
//
// Prints theString to the standard output stream, followed by a line break.
// Uses UTF-8 encoding.
//------------------------------------------------------------------------------

   static void printlnUTF8 (String theString)
      {
      FileOutputStream   stdout;
      OutputStreamWriter stdoutUTF8;

      try
         {
         stdout     = new FileOutputStream   (FileDescriptor.out);

         stdoutUTF8 = new OutputStreamWriter (stdout, "UTF-8");

         stdoutUTF8.write (theString + "\n");

         stdoutUTF8.flush ();
         }

      catch (IOException theExc)
         {
         theExc.printStackTrace ();

         System.exit (4);
         }
      }

//==============================================================================
// Private Constructor
//
// Prevents instantiation.
//==============================================================================

   private Tester ()
      {
      }

//==============================================================================
}
@


1.135
log
@Reduced heading comments.
@
text
@d13 2
d128 2
@


1.134
log
@Made the tester into a single jar file.
@
text
@a3 2
//
// Contains the declaration of class Tester.
@


1.133
log
@Added the thread test as a separate test.
@
text
@d65 1
@


1.132
log
@Moved the UTF-8 logic to a special print method and re-used it.
@
text
@d49 4
@


1.131
log
@Timing test.
@
text
@d10 2
d70 7
a76 1
   static void abortWmsg (String errorTxt)
d82 1
a82 1
         + errorTxt
d90 31
@


1.130
log
@Renamed recovering test to status quo test.
@
text
@d37 1
a37 1
         UnitTester.performUnitTest ();
d41 1
a41 1
         StatusQuoTester.performStatusQuoTest ();
d45 5
a49 1
         ErrTester.performErrorTest (theArgs);
d54 7
a60 2
            "   The first argument to the WIT-J Tester must be either\n"
          + "   \"unit-test\" or \"error-test\".");
@


1.129
log
@Changed name of recovery test to recovering test.
@
text
@d39 1
a39 1
      else if (theArgs[0].equals ("recovering-test"))
d41 1
a41 1
         RecoveringTester.performRecoveringTest ();
@


1.128
log
@Implemented the recovery test.
@
text
@d39 1
a39 1
      else if (theArgs[0].equals ("recovery-test"))
d41 1
a41 1
         RecoveryTester.performRecoveryTest ();
@


1.127
log
@Added type checking to Attribute type conversion methods.
@
text
@d39 4
@


1.126
log
@Removed Lister from the test battery.
@
text
@d35 1
a35 1
      if      (theArgs[0].equals ("u"))
d39 1
a39 1
      else if (theArgs[0].equals ("e"))
d46 2
a47 2
            "   The first argument to the WIT-J Tester must be either "
          +    "\"u\" or \"e\".");
@


1.125
log
@Added the "l" option to the Tester.
@
text
@a42 4
      else if (theArgs[0].equals ("l"))
         {
         Lister.listElements (theArgs);
         }
d47 1
a47 1
          +    "\"u\", \"e\", or \"l\".");
@


1.124
log
@Improved argument checking.
@
text
@d41 5
a45 1
         ErrTester.performErrorTest (theArgs[1]);
d51 1
a51 1
          +    "\"u\" or \"e\".");
d56 1
a56 9
// Private Constructor
//==============================================================================

   private Tester ()
      {
      }

//==============================================================================
// Private Methods
d59 1
a59 1
   private static void abortWmsg (String errorTxt)
d74 8
@


1.123
log
@Revised testing command line arguments.
@
text
@d29 6
d45 3
a47 7
         System.out.println (
              "\n"
            + "ERROR:\n"
            + "   The first argument to tIT-J tester must be either "
            +    "\"u\" or \"e\".\n");

         System.exit (3);
d58 20
@


1.122
log
@Moved unit test to class UnitTester.
@
text
@d29 1
a29 1
      if (theArgs.length == 0)
d33 4
a36 4

      else if (theArgs.length == 1)
         ErrTester.performErrorTest (theArgs[0]);

d42 2
a43 2
            + "   The WIT-J tester must be invoked "
            +    "with at most one argument.\n");
@


1.121
log
@Name change.
@
text
@d3 1
a3 1
// Java Program witj.test.
d5 1
a5 1
// This program performs a unit test of WIT-J.
d8 1
a8 7
package       com.ibm.witj.test;

import        com.ibm.witj.*;
import static com.ibm.witj.AttSpec.*;
import static com.ibm.witj.Part.Category.*;

import          java.util.*;
d13 2
a14 1
// Main class for witj.test.
d31 1
a31 5
         Tester theTester;

         theTester = new Tester ();

         theTester.performUnitTest ();
d39 1
a39 1
         println (
d50 1
a50 1
// Private Methods
a52 4
//------------------------------------------------------------------------------
// Constructor.
//------------------------------------------------------------------------------

a54 1051
      undisplayedAttSpecs =
         new HashSet <AttSpec <?>> (AttSpec.values ().length, 1.0f);

      for (AttSpec <?> theAttSpec: AttSpec.values ())
         undisplayedAttSpecs.add (theAttSpec);
      }

//------------------------------------------------------------------------------
// performUnitTest ().
//
// Performs the unit test.
//------------------------------------------------------------------------------

   private void performUnitTest ()
      {
      println (
           "\n"
         + "Unit test of WIT-J.");

      Session.selfTest ();

      mySession = Session.newSession ();

      testMsgMgr1                  ();
      setUpProblem                 ();
      testMsgMgr2                  ();
      buildElements                ();
      printPublicObjects           ();
      testScalarNavMethods         ();
      testArrayNavMethods          ();
      displayAttSpecs              ();
      checkForNonAppAttSpecs       ();
      testSetGet                   ();
      testCustAtts                 ();
      myProblem.displayData        ("");
      myProblem.generatePriorities ();
      myProblem.heurImplode        ();
      myProblem.evalObjectives     ();
      mySession.shutDown           ();

      assert (! myProblem.getActiveMode ());

      testReadData ();
      }

//------------------------------------------------------------------------------
// testMsgMgr1 ()
//
// Test of the MessageMgr before the Problem is constructed.
//------------------------------------------------------------------------------

   private void testMsgMgr1 ()
      {
      boolean theQuietMode;

      myMgrMgr = mySession.getMessageMgr ();

      myMgrMgr.setQuietMode (true);

      theQuietMode = myMgrMgr.getQuietMode ();

      assert (theQuietMode);

      myMgrMgr.setMesgFileName ("Tester.out");

      myMgrMgr.setQuietMode (false);
      }

//------------------------------------------------------------------------------
// setUpProblem ().
//
// Performs initial set-up of the Problem the for unit test.
//------------------------------------------------------------------------------

   private void setUpProblem ()
      {
      int nPeriodsVal;

      myProblem       = mySession.newProblem ();

      myGlobalElement = myProblem.getGlobalElement ();

      myGlobalElement.set (nPeriods (), 3);

      nPeriodsVal     = myGlobalElement.get (nPeriods ());

      assert (nPeriodsVal == 3);

      assert (myProblem.getMessageMgr () == myMgrMgr);
      }

//------------------------------------------------------------------------------
// testMsgMgr2 ()
//
// Test of the MessageMgr after the Problem has been constructed.
//------------------------------------------------------------------------------

   private void testMsgMgr2 ()
      {
      String theName;
      String theMode;
      int    theInt;

      theName = myMgrMgr.getMesgFileName ();

      assert (theName.equals ("Tester.out"));

      myMgrMgr.setMesgFileAccessMode ("a");

      theMode = myMgrMgr.getMesgFileAccessMode ();

      assert (theMode.equals ("a"));

      myMgrMgr.setMesgFileAccessMode ("w");

      myMgrMgr.setMesgTimesPrint (101, 50);

      theInt = myMgrMgr.getMesgTimesPrint (101);

      assert (theInt == 50);

      myMgrMgr.setMesgTimesPrint (MessageGroup.INFORMATIONAL, -7);

      theInt = myMgrMgr.getMesgTimesPrint (101);

      assert (theInt == -1);
      }

//------------------------------------------------------------------------------
// buildElements ().
//
// Builds the Elements for the unit test.
//------------------------------------------------------------------------------

   private void buildElements ()
      {
      myPartA    = myProblem .newPart       ("A", CAPACITY);
      myPartB    = myProblem .newPart       ("B", CAPACITY);
      myPartC    = myProblem .newPart       ("C", MATERIAL);
      myDemandD  = myPartC   .newDemand     ("D");
      myOpnE     = myProblem .newOperation  ("E");
      myBomEntEA = myOpnE    .newBomEntry   (myPartA);
      myBomEntEB = myOpnE    .newBomEntry   (myPartB);
      mySubEAB   = myBomEntEA.newSubstitute (myPartB);
      myBopEntEC = myOpnE    .newBopEntry   (myPartC);

      myMgrMgr.flushFile ();

      exampleElements =
         new Element[]
            {
            myGlobalElement,
            myPartC,
            myDemandD,
            myOpnE,
            myBomEntEB,
            mySubEAB,
            myBopEntEC,
            };
      }

//------------------------------------------------------------------------------
// printPublicObjects ().
//
// Prints the Session and the public objects that it owns.
//------------------------------------------------------------------------------

   private void printPublicObjects ()
      {
      println ("");
      println (mySession);
      println (myMgrMgr);
      println (myProblem);
      println (myPartA);
      println (myPartB);
      println (myPartC);
      println (myDemandD);
      println (myOpnE);
      println (myBomEntEA);
      println (myBomEntEB);
      println (mySubEAB);
      println (myBopEntEC);
      }

//------------------------------------------------------------------------------
// testScalarNavMethods ().
//
// Tests the navigational methods that return scalar Objects.
//------------------------------------------------------------------------------

   private void testScalarNavMethods ()
      {
      println ("");

      println ("myProblem .getPart       (\"B\"): "
              + myProblem .getPart       ( "B" ));
      println ("myProblem .getOperation  (\"E\"): "
              + myProblem .getOperation  ( "E" ));
      println ("myPartC   .getProblem    ():    "
              + myPartC   .getProblem    ());
      println ("myPartC   .getDemand     (\"D\"): "
              + myPartC   .getDemand     ( "D" ));
      println ("myDemandD .getPart       ():    "
              + myDemandD .getPart       ());
      println ("myDemandD .getDemandName ():    "
              + myDemandD .getDemandName ());
      println ("myOpnE    .getBomEntry   (1):   "
              + myOpnE    .getBomEntry   (1));
      println ("myOpnE    .getBopEntry   (0):   "
              + myOpnE    .getBopEntry   (0));
      println ("myBomEntEB.getOperation  ():    "
              + myBomEntEB.getOperation  ());
      println ("myBomEntEB.getPart       ():    "
              + myBomEntEB.getPart       ());
      println ("myBomEntEB.getBomIndex   ():    "
              + myBomEntEB.getBomIndex   ());
      println ("myBomEntEA.getSubstitute (0):   "
              + myBomEntEA.getSubstitute (0));
      println ("mySubEAB  .getBomEntry   ():    "
              + mySubEAB  .getBomEntry   ());
      println ("mySubEAB  .getPart       ():    "
              + mySubEAB  .getPart       ());
      println ("mySubEAB  .getSubIndex   ():    "
              + mySubEAB  .getSubIndex   ());
      println ("myBopEntEC.getOperation  ():    "
              + myBopEntEC.getOperation  ());
      println ("myBopEntEC.getPart       ():    "
              + myBopEntEC.getPart       ());
      println ("myBopEntEC.getBopIndex   ():    "
              + myBopEntEC.getBopIndex   ());
      }

//------------------------------------------------------------------------------
// testArrayNavMethods ().
//
// Tests the navigational methods that return arrays of Objects.
//------------------------------------------------------------------------------

   private void testArrayNavMethods ()
      {
      printArray (
          myProblem.getElements (),
         "myProblem.getElements ()");

      printArray (
          myPartC.getDemands (),
         "myPartC.getDemands ()");

      printArray (
          myPartB.getBomEntries (),
         "myPartB.getBomEntries ()");

      printArray (
          myPartB.getSubstitutes (),
         "myPartB.getSubstitutes ()");

      printArray (
          myPartC.getBopEntries (),
         "myPartC.getBopEntries ()");

      printArray (
          myOpnE.getBomEntries (),
         "myOpnE.getBomEntries ()");

      printArray (
          myOpnE.getBopEntries (),
         "myOpnE.getBopEntries ()");

      printArray (
          myBomEntEA.getSubstitutes (),
         "myBomEntEA.getSubstitutes ()");
      }

//------------------------------------------------------------------------------
// displayAttSpecs ()
//------------------------------------------------------------------------------

   private void displayAttSpecs ()
      {
      println (
           "\n"
         + "AttSpecs:");

      display (accAfterOptImp      ());
      display (accAfterSoftLB      ());
      display (accelerated         ());
      display (asapPipOrder        ());
      display (autoPriority        ());
      display (boundsValue         ());
      display (buildAheadUB        ());
      display (buildAsap           ());
      display (buildNstn           ());
      display (compPrices          ());
      display (computeCriticalList ());
      display (consRate            ());
      display (consVol             ());
      display (cumShipBounds       ());
      display (cumShipReward       ());
      display (currentScenario     ());
      display (demandName          ());
      display (demandVol           ());
      display (earliestPeriod      ());
      display (equitability        ());
      display (excessVol           ());
      display (execBounds          ());
      display (execCost            ());
      display (execEmptyBom        ());
      display (execPenalty         ());
      display (execVol             ());
      display (executable          ());
      display (expAllowed          ());
      display (expAversion         ());
      display (expCutoff           ());
      display (expNetAversion      ());
      display (extOptActive        ());
      display (falloutRate         ());
      display (feasible            ());
      display (focusHorizon        ());
      display (focusShortageVol    ());
      display (forcedMultiEq       ());
      display (fssExecVol          ());
      display (fssSubVol           ());
      display (heurAllocActive     ());
      display (highPrecisionWD     ());
      display (impactPeriod        ());
      display (incLotSize          ());
      display (incLotSize2         ());
      display (independentOffsets  ());
      display (intExecVols         ());
      display (intShipVols         ());
      display (intSubVols          ());
      display (latestPeriod        ());
      display (lotSize2Thresh      ());
      display (lotSizeTol          ());
      display (mandEC              ());
      display (minLotSize          ());
      display (minLotSize2         ());
      display (minimalExcess       ());
      display (mipMode             ());
      display (mrpConsVol          ());
      display (mrpExcessVol        ());
      display (mrpExecVol          ());
      display (mrpNetAllowed       ());
      display (mrpResidualVol      ());
      display (mrpSubVol           ());
      display (multiExec           ());
      display (multiRoute          ());
      display (nPeriods            ());
      display (nScenarios          ());
      display (netAllowed          ());
      display (nstnResidual        ());
      display (objValue            ());
      display (objectStage         ());
      display (offset              ());
      display (operationName       ());
      display (partCategory        ());
      display (partName            ());
      display (penExec             ());
      display (perfPegging         ());
      display (periodStage         ());
      display (pgdCritListMode     ());
      display (pipExists           ());
      display (pipSeqFromHeur      ());
      display (postprocessed       ());
      display (prefHighStockSLBs   ());
      display (preprocessed        ());
      display (priority            ());
      display (probability         ());
      display (prodVol             ());
      display (productRate         ());
      display (propRtg             ());
      display (reqVol              ());
      display (residualVol         ());
      display (respectStockSLBs    ());
      display (roundReqVols        ());
      display (routingShare        ());
      display (scrapAllowed        ());
      display (scrapCost           ());
      display (scrapVol            ());
      display (searchInc           ());
      display (selForDel           ());
      display (selSplit            ());
      display (shadowPrice         ());
      display (shipLateAllowed     ());
      display (shipLateUB          ());
      display (shipReward          ());
      display (shipVol             ());
      display (singleSource        ());
      display (skipFailures        ());
      display (solverLogFileName   ());
      display (stageByObject       ());
      display (stochMode           ());
      display (stochSolnMode       ());
      display (stockBounds         ());
      display (stockCost           ());
      display (stockReallocation   ());
      display (stockVol            ());
      display (subCost             ());
      display (subVol              ());
      display (supplyVol           ());
      display (tieBreakPropRt      ());
      display (title               ());
      display (truncOffsets        ());
      display (twoLevelLotSizes    ());
      display (twoWayMultiExec     ());
      display (useFocusHorizons    ());
      display (userHeurStart       ());
      display (wbounds             ());
      display (yieldRate           ());

      if (undisplayedAttSpecs.isEmpty ())
         {
         println (
              "\n"
            + "All AttSpecs have been displayed.");
         }
      else
         {
         println (
            "\n"
          + "The following AttSpecs were missing from the above listing:\n");

         for (AttSpec <?> theAttSpec: undisplayedAttSpecs)
            {
            println ("   " + theAttSpec);
            }
         }
      }

//------------------------------------------------------------------------------
// display (theAttSpec)
//
// Displays information about theAttSpec.
// To be invoked exactly once for each AttSpec.
//------------------------------------------------------------------------------

   private void display (AttSpec <?> theAttSpec)
      {
      assert (undisplayedAttSpecs.contains (theAttSpec));

      println (
           "\n"
         + "   " + theAttSpec + ":");

      for (Element theElement: exampleElements)
         {
         if (theAttSpec.appliesTo (theElement))
            {
            println (
               "      Applies to:   "
             + theElement.getClass ().getSimpleName ());
            }
         }

      println (
           "      Value Type:   "
         + theAttSpec.getValueType ().getSimpleName ());

      if (theAttSpec.getInputAccess (myProblem))
         println ("      Access Style: Input");
      else
         println ("      Access Style: Output");

      undisplayedAttSpecs.remove (theAttSpec);
      }

//------------------------------------------------------------------------------
// checkForNonAppAttSpecs ()
//
// Displays all AttSpecs that don't apply to any Element class.
//------------------------------------------------------------------------------

   private void checkForNonAppAttSpecs ()
      {
      boolean nonAppFound;
      boolean appFound;

      nonAppFound = false;

      for (AttSpec <?> theAttSpec: AttSpec.values ())
         {
         if (theAttSpec == null)
            continue;

         appFound = false;

         for (Element theElement: exampleElements)
            {
            if (theAttSpec.appliesTo (theElement))
               appFound = true;
            }

         if (! appFound)
            {
            if (! nonAppFound)
               println (
                  "\n"
                + "The following AttSpecs do not apply to any Element class:"
                + "\n");

            nonAppFound = true;

            println ("   " + theAttSpec);
            }
         }

      if (! nonAppFound)
         println (
            "\n"
          + "All AttSpecs apply to at least one Element class.");
      }

//------------------------------------------------------------------------------
// testSetGet ()
//
// Tests AttSpec set and get methods of class Element.
//------------------------------------------------------------------------------

   private void testSetGet ()
      {
      testSetGetBool    ();
      testSetGetInt     ();
      testSetGetDbl     ();
      testSetGetBoolVec ();
      testSetGetIntVec  ();
      testSetGetDblVec  ();
      }

//------------------------------------------------------------------------------
// testSetGetBool ()
//
// Tests AttSpec set and get methods for AttSpecs of value type boolean.
//------------------------------------------------------------------------------

   private void testSetGetBool ()
      {
      boolean expAllowedIn;
      boolean expAllowedOut;

      expAllowedIn  = false;

      myBopEntEC.set (expAllowed (), expAllowedIn);

      expAllowedOut = myBopEntEC.get (expAllowed ());

      assert (expAllowedOut == expAllowedIn);
      }

//------------------------------------------------------------------------------
// testSetGetInt ()
//
// Tests AttSpec set and get methods for AttSpecs of value type int.
//------------------------------------------------------------------------------

   private void testSetGetInt ()
      {
      int earliestPeriodIn;
      int earliestPeriodOut;

      earliestPeriodIn  = 1;

      myBopEntEC.set (earliestPeriod (), earliestPeriodIn);

      earliestPeriodOut = myBopEntEC.get (earliestPeriod ());

      assert (earliestPeriodOut == earliestPeriodIn);
      }

//------------------------------------------------------------------------------
// testSetGetDbl ()
//
// Tests AttSpec set and get methods for AttSpecs of value type double.
//------------------------------------------------------------------------------

   private void testSetGetDbl ()
      {
      double execPenaltyIn;
      double execPenaltyOut;

      execPenaltyIn  = 2.0;

      myOpnE.set (execPenalty (), execPenaltyIn);

      execPenaltyOut = myOpnE.get (execPenalty ());

      assert (execPenaltyOut == execPenaltyIn);
      }

//------------------------------------------------------------------------------
// testSetGetBoolVec ()
//
// Tests AttSpec set and get methods for AttSpecs of value type boolean[].
//------------------------------------------------------------------------------

   private void testSetGetBoolVec ()
      {
      boolean[] propRtgIn;
      boolean[] propRtgOut1;
      boolean[] propRtgOut2;

      propRtgIn   = new boolean[] {true, false, true};
      propRtgOut1 = new boolean[3];

      myPartB.set (propRtg (), propRtgIn);
      myPartB.get (propRtg (), propRtgOut1);

      propRtgOut2 = myPartB.get (propRtg ());

      assertEq (propRtgOut1, propRtgIn);
      assertEq (propRtgOut2, propRtgIn);
      }

//------------------------------------------------------------------------------
// testSetGetIntVec ()
//
// Tests AttSpec set and get methods for AttSpecs of value type int[].
//------------------------------------------------------------------------------

   private void testSetGetIntVec ()
      {
      int[] priorityIn;
      int[] priorityOut1;
      int[] priorityOut2;

      priorityIn   = new int[] {2, 7, 3};
      priorityOut1 = new int[3];

      myDemandD.set (priority (), priorityIn);
      myDemandD.get (priority (), priorityOut1);

      priorityOut2 = myDemandD.get (priority ());

      assertEq (priorityOut1, priorityIn);
      assertEq (priorityOut2, priorityIn);
      }

//------------------------------------------------------------------------------
// testSetGetDblVec ()
//
// Tests AttSpec set and get methods for AttSpecs of value type double[].
//------------------------------------------------------------------------------

   private void testSetGetDblVec ()
      {
      double[] supplyVolIn;
      double[] supplyVolOut1;
      double[] supplyVolOut2;

      supplyVolIn   = new double[] {40,  0, 50};
      supplyVolOut1 = new double[3];

      myPartB.set (supplyVol (), supplyVolIn);
      myPartB.get (supplyVol (), supplyVolOut1);

      supplyVolOut2 = myPartB.get (supplyVol ());

      assertApproxEq (supplyVolOut1, supplyVolIn);
      assertApproxEq (supplyVolOut2, supplyVolIn);
      }

//------------------------------------------------------------------------------
// testCustAtts ()
//
// Tests customized attributes.
//------------------------------------------------------------------------------

   private void testCustAtts ()
      {
      testCumShipBounds     ();
      testDemandName        ();
      testExecBounds        ();
      testOperationName     ();
      testPartCategory      ();
      testPartName          ();
      testSolverLogFileName ();
      testStockBounds       ();
      testTitle             ();
      }

//------------------------------------------------------------------------------
// testCumShipBounds ()
//
// Tests the "cumShipBounds" attribute.
//------------------------------------------------------------------------------

   private void testCumShipBounds ()
      {
      double[] hardLBin;
      double[] softLBin;
      double[] hardUBin;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      hardLBin  = new double[] {210.0, 220.0, 230.0};
      softLBin  = new double[] {240.0, 250.0, 260.0};
      hardUBin  = new double[] {270.0, 280.0, 290.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myDemandD.set (cumShipBounds (), hardLBin,  softLBin,  hardUBin);
      myDemandD.get (cumShipBounds (), hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, hardLBin);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, hardUBin);
      }

//------------------------------------------------------------------------------
// testDemandName ()
//
// Tests the "demandName" attribute.
//------------------------------------------------------------------------------

   private void testDemandName ()
      {
      String demandNameIn;
      String demandNameOut;

      demandNameIn  = "Temporary Name for Demand D";

      myDemandD.set (demandName (), demandNameIn);

      demandNameOut = myDemandD.get (demandName ());

      assert (demandNameOut.equals (demandNameIn));

      myDemandD.set (demandName (), "D");
      }

//------------------------------------------------------------------------------
// testExecBounds ()
//
// Tests the "execBounds" attribute.
// The hard lower and hard upper bounds are left at their default values.
//------------------------------------------------------------------------------

   private void testExecBounds ()
      {
      double[] zeroVec;
      double[] softLBin;
      double[] neg1Vec;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      zeroVec   = new double[] { 0.0,  0.0,  0.0};
      softLBin  = new double[] {40.0, 50.0, 60.0};
      neg1Vec   = new double[] {-1.0, -1.0, -1.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myOpnE.set (execBounds (), null,      softLBin,  null);
      myOpnE.get (execBounds (), hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, zeroVec);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, neg1Vec);
      }

//------------------------------------------------------------------------------
// testOperationName ()
//
// Tests the "operationName" attribute.
//------------------------------------------------------------------------------

   private void testOperationName ()
      {
      String operationNameIn;
      String operationNameOut;

      operationNameIn  = "Temporary Name for Operation E";

      myOpnE.set (operationName (), operationNameIn);

      operationNameOut = myOpnE.get (operationName ());

      assert (operationNameOut.equals (operationNameIn));

      myOpnE.set (operationName (), "E");
      }

//------------------------------------------------------------------------------
// testPartCategory ()
//
// Tests the "partCategory" attribute.
//------------------------------------------------------------------------------

   private void testPartCategory ()
      {
      Part.Category partCategoryOut;

      partCategoryOut = myPartA.get (partCategory ());

      assert (partCategoryOut == CAPACITY);
      }

//------------------------------------------------------------------------------
// testPartName ()
//
// Tests the "partName" attribute.
//------------------------------------------------------------------------------

   private void testPartName ()
      {
      String partNameIn;
      String partNameOut;

      partNameIn  = "Temporary Name for Part A";

      myPartA.set (partName (), partNameIn);

      partNameOut = myPartA.get (partName ());

      assert (partNameOut.equals (partNameIn));

      myPartA.set (partName (), "A");
      }

//------------------------------------------------------------------------------
// testSolverLogFileName ()
//
// Tests the "solverLogFileName" attribute.
//------------------------------------------------------------------------------

   private void testSolverLogFileName ()
      {
      String solverLogFileNameIn;
      String solverLogFileNameOut;

      solverLogFileNameIn  = "wit-j.test.solver.log";

      myGlobalElement.set (solverLogFileName (), solverLogFileNameIn);

      solverLogFileNameOut = myGlobalElement.get (solverLogFileName ());

      assert (solverLogFileNameOut.equals (solverLogFileNameIn));
      }

//------------------------------------------------------------------------------
// testStockBounds ()
//
// Tests the "stockBounds" attribute.
//------------------------------------------------------------------------------

   private void testStockBounds ()
      {
      double[] hardLBin;
      double[] softLBin;
      double[] hardUBin;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      hardLBin  = new double[] {110.0, 120.0, 130.0};
      softLBin  = new double[] {140.0, 150.0, 160.0};
      hardUBin  = new double[] {170.0, 180.0, 190.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myPartC.set (stockBounds (), hardLBin,  softLBin,  hardUBin);
      myPartC.get (stockBounds (), hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, hardLBin);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, hardUBin);
      }

//------------------------------------------------------------------------------
// testTitle ()
//
// Tests the "title" attribute.
//------------------------------------------------------------------------------

   private void testTitle ()
      {
      String titleIn;
      String titleOut;

      titleIn  = "WIT-J Test Problem";

      myGlobalElement.set (title (), titleIn);

      titleOut = myGlobalElement.get (title ());

      assert (titleOut.equals (titleIn));
      }

//------------------------------------------------------------------------------
// testReadData ()
//
// Tests Problem.readData (...).
//------------------------------------------------------------------------------

   private void testReadData ()
      {
      Problem theProblem;
      int     nPeriodsVal;

      theProblem = Problem.newProblem ();

      theProblem.readData ("test.data");

      nPeriodsVal = theProblem.getGlobalElement ().get (nPeriods ());

      assert (theProblem.getGlobalElement ().get (nPeriods ()) == 2);

      println (
         "\n"
       + "The following Elements were read in from file \"test.data\":\n");

      for (Element theElement: theProblem.getElements ())
         {
         println ("   " + theElement);
         }

      theProblem.getSession ().shutDown ();
      }

//------------------------------------------------------------------------------
// printSeparator ()
//------------------------------------------------------------------------------

   private void printSeparator ()
      {
      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         );
      }

//------------------------------------------------------------------------------
// assertEq (theVec1, theVec2) methods
//
// Each of these methods asserts that the elements of theVec1 and theVec2 are
// equal.
//------------------------------------------------------------------------------

   private static void assertEq (
         boolean[] theVec1,
         boolean[] theVec2)
      {
      int theIdx;

      assert (theVec1.length == theVec2.length);

      for (theIdx = 0; theIdx < theVec1.length; theIdx ++)
         assert (theVec1[theIdx] == theVec2[theIdx]);
      }

//------------------------------------------------------------------------------

   private static void assertEq (
         int[] theVec1,
         int[] theVec2)
      {
      int theIdx;

      assert (theVec1.length == theVec2.length);

      for (theIdx = 0; theIdx < theVec1.length; theIdx ++)
         assert (theVec1[theIdx] == theVec2[theIdx]);
      }

//------------------------------------------------------------------------------
// assertApproxEq (theDblVec1, theDblVec2) methods
//
// Asserts that the elements of theDblVec1 and theDblVec2 are nearly equal.
//------------------------------------------------------------------------------

   private static void assertApproxEq (
         double[] theDblVec1,
         double[] theDblVec2)
      {
      int theIdx;

      assert (theDblVec1.length == theDblVec2.length);

      for (theIdx = 0; theIdx < theDblVec1.length; theIdx ++)
         {
         assertApproxEq (theDblVec1[theIdx], theDblVec2[theIdx]);
         }
      }

//------------------------------------------------------------------------------
// assertApproxEq (theDbl1, theDbl2) methods
//
// Asserts that theDbl1 and theDbl2 are (nearly) equal.
//------------------------------------------------------------------------------

   private static void assertApproxEq (
         double theDbl1,
         double theDbl2)
      {
      assert (StrictMath.abs (theDbl1 - theDbl2) < .0001);
      }

//------------------------------------------------------------------------------
// printArray (arrName, theDblArr)
//
// Prints theDblArr with name arrName.
//------------------------------------------------------------------------------

   private static void printArray (String arrName, double[] theDblArr)
      {
      int theIdx;

      println ("\n");

      System.out.print   (arrName + " = [");

      for (theIdx = 0; theIdx < theDblArr.length - 1; theIdx ++)
         {
         System.out.print (theDblArr[theIdx] + ", ");
         }
         
      println (theDblArr[theDblArr.length - 1] + "]");
      }

//------------------------------------------------------------------------------
// printArray (theArr, theArrName)
//
// Prints the contents of theArr, whose name is given by theArrName.
//------------------------------------------------------------------------------

   static void printArray (Object[] theArr, String theArrName)
      {
      println (
         "\n"
       + theArrName + ":");

      for (Object theObject: theArr)
         println ("   " + theObject);
      }

//------------------------------------------------------------------------------
// println (theObject)
//
// Wrapper method.
//------------------------------------------------------------------------------

   static void println (Object theObject)
      {
      System.out.println (theObject);
a55 41

//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// Public WIT-J objects for the unit test.
//------------------------------------------------------------------------------

   private Session       mySession;
   private MessageMgr    myMgrMgr;
   private Problem       myProblem;
   private GlobalElement myGlobalElement;
   private Part          myPartA;
   private Part          myPartB;
   private Part          myPartC;
   private Demand        myDemandD;
   private Operation     myOpnE;
   private BomEntry      myBomEntEA;
   private BomEntry      myBomEntEB;
   private Substitute    mySubEAB;
   private BopEntry      myBopEntEC;

//------------------------------------------------------------------------------
// exampleElements
//
// Contains one Element of each Element class.
//------------------------------------------------------------------------------

   private Element[] exampleElements;

//------------------------------------------------------------------------------
// undisplayedAttSpecs
//
// undisplayedAttSpecs.contains (theAttSpec) is true, iff display has not been
// invoked on theAttSpec.
//------------------------------------------------------------------------------

   private final HashSet <AttSpec <?>> undisplayedAttSpecs;

//------------------------------------------------------------------------------
@


1.120
log
@Minor revision.
@
text
@d94 1
a94 1
      buildEntities                ();
d146 1
a146 1
      myProblem      = mySession.newProblem      ();
d148 1
a148 1
      myGlobalEntity = myProblem.getGlobalEntity ();
d150 1
a150 1
      myGlobalEntity.set (nPeriods (), 3);
d152 1
a152 1
      nPeriodsVal    = myGlobalEntity.get (nPeriods ());
d197 1
a197 1
// buildEntities ().
d199 1
a199 1
// Builds the Entities for the unit test.
d202 1
a202 1
   private void buildEntities ()
d216 2
a217 2
      exampleEntities =
         new Entity[]
d219 1
a219 1
            myGlobalEntity,
d309 2
a310 2
          myProblem.getEntities (),
         "myProblem.getEntities ()");
d512 1
a512 1
      for (Entity theEntity: exampleEntities)
d514 1
a514 1
         if (theAttSpec.appliesTo (theEntity))
d517 2
a518 1
               "      Applies to:   " + theEntity.getClass ().getSimpleName ());
d537 1
a537 1
// Displays all AttSpecs that don't apply to any Entity class.
d554 1
a554 1
         for (Entity theEntity: exampleEntities)
d556 1
a556 1
            if (theAttSpec.appliesTo (theEntity))
d565 2
a566 1
                + "The following AttSpecs do not apply to any Entity class:\n");
d577 1
a577 1
          + "All AttSpecs apply to at least one Entity class.");
d583 1
a583 1
// Tests AttSpec set and get methods of class Entity.
d904 1
a904 1
      myGlobalEntity.set (solverLogFileName (), solverLogFileNameIn);
d906 1
a906 1
      solverLogFileNameOut = myGlobalEntity.get (solverLogFileName ());
d955 1
a955 1
      myGlobalEntity.set (title (), titleIn);
d957 1
a957 1
      titleOut = myGlobalEntity.get (title ());
d977 1
a977 1
      nPeriodsVal = theProblem.getGlobalEntity ().get (nPeriods ());
d979 1
a979 1
      assert (theProblem.getGlobalEntity ().get (nPeriods ()) == 2);
d983 1
a983 1
       + "The following Entities were read in from file \"test.data\":\n");
d985 1
a985 1
      for (Entity theEntity: theProblem.getEntities ())
d987 1
a987 1
         println ("   " + theEntity);
d1129 13
a1141 13
   private Session      mySession;
   private MessageMgr   myMgrMgr;
   private Problem      myProblem;
   private GlobalEntity myGlobalEntity;
   private Part         myPartA;
   private Part         myPartB;
   private Part         myPartC;
   private Demand       myDemandD;
   private Operation    myOpnE;
   private BomEntry     myBomEntEA;
   private BomEntry     myBomEntEB;
   private Substitute   mySubEAB;
   private BopEntry     myBopEntEC;
d1144 1
a1144 1
// exampleEntities
d1146 1
a1146 1
// Contains one Entity of each Entity class.
d1149 1
a1149 1
   private Entity[] exampleEntities;
@


1.119
log
@Minor corrections.
@
text
@d106 1
a106 1
      mySession.shutDownAll        ();
d988 1
a988 1
      theProblem.getSession ().shutDownAll ();
@


1.118
log
@Changed name of Component to Entity.
@
text
@d216 1
a216 1
      exampleComps =
d512 1
a512 1
      for (Entity theEntity: exampleComps)
d553 1
a553 1
         for (Entity theEntity: exampleComps)
d1142 1
a1142 1
// exampleComps
d1147 1
a1147 1
   private Entity[] exampleComps;
@


1.117
log
@Minor revision.
@
text
@d94 1
a94 1
      buildComponents              ();
d146 1
a146 1
      myProblem    = mySession.newProblem    ();
d148 1
a148 1
      myGlobalComp = myProblem.getGlobalComp ();
d150 1
a150 1
      myGlobalComp.set (nPeriods (), 3);
d152 1
a152 1
      nPeriodsVal  = myGlobalComp.get (nPeriods ());
d197 1
a197 1
// buildComponents ().
d199 1
a199 1
// Builds the Components for the unit test.
d202 1
a202 1
   private void buildComponents ()
d217 1
a217 1
         new Component[]
d219 1
a219 1
            myGlobalComp,
d309 2
a310 2
          myProblem.getComponents (),
         "myProblem.getComponents ()");
d512 1
a512 1
      for (Component theComp: exampleComps)
d514 1
a514 1
         if (theAttSpec.appliesTo (theComp))
d517 1
a517 1
               "      Applies to:   " + theComp.getClass ().getSimpleName ());
d536 1
a536 1
// Displays all AttSpecs that don't apply to any Component class.
d553 1
a553 1
         for (Component theComp: exampleComps)
d555 1
a555 1
            if (theAttSpec.appliesTo (theComp))
d564 1
a564 2
                + "The following AttSpecs do not apply "
                + "to any Component class:\n");
d575 1
a575 1
          + "All AttSpecs apply to at least one Component class.");
d581 1
a581 1
// Tests AttSpec set and get methods of class Component.
d902 1
a902 1
      myGlobalComp.set (solverLogFileName (), solverLogFileNameIn);
d904 1
a904 1
      solverLogFileNameOut = myGlobalComp.get (solverLogFileName ());
d953 1
a953 1
      myGlobalComp.set (title (), titleIn);
d955 1
a955 1
      titleOut = myGlobalComp.get (title ());
d975 1
a975 1
      nPeriodsVal = theProblem.getGlobalComp ().get (nPeriods ());
d977 1
a977 1
      assert (theProblem.getGlobalComp ().get (nPeriods ()) == 2);
d981 1
a981 1
       + "The following Components were read in from file \"test.data\":\n");
d983 1
a983 1
      for (Component theComp: theProblem.getComponents ())
d985 1
a985 1
         println ("   " + theComp);
d1127 13
a1139 13
   private Session    mySession;
   private MessageMgr myMgrMgr;
   private Problem    myProblem;
   private GlobalComp myGlobalComp;
   private Part       myPartA;
   private Part       myPartB;
   private Part       myPartC;
   private Demand     myDemandD;
   private Operation  myOpnE;
   private BomEntry   myBomEntEA;
   private BomEntry   myBomEntEB;
   private Substitute mySubEAB;
   private BopEntry   myBopEntEC;
d1144 1
a1144 1
// Contains one Component of each Component class.
d1147 1
a1147 1
   private Component[] exampleComps;
@


1.116
log
@Implemented extraction of Parts.
@
text
@d525 1
a525 1
      if (theAttSpec.getInputMode (myProblem))
@


1.115
log
@Minor revision.
@
text
@d982 1
a982 1
       + "The following components were read in from file \"test.data\":\n");
@


1.114
log
@Minor revision.
@
text
@d525 1
a525 1
      if (theAttSpec.isAnInputAtt (myProblem))
@


1.113
log
@Extraction.
@
text
@d108 1
a108 1
      assert (! myProblem.isActive ());
@


1.112
log
@Extraction
@
text
@d121 1
a121 1
      boolean isQuietVal;
d125 1
a125 1
      myMgrMgr.setQuiet (true);
d127 1
a127 1
      isQuietVal = myMgrMgr.isQuiet ();
d129 1
a129 1
      assert (isQuietVal);
d133 1
a133 1
      myMgrMgr.setQuiet (false);
@


1.111
log
@Intitial implementation of extraction of nPeriods.
@
text
@d980 9
@


1.110
log
@Began implementation of Problem.readData (...).
@
text
@d970 1
d976 4
@


1.109
log
@Class name change.
@
text
@d87 1
a87 1
      Session.selfTest       ();
a101 1

d109 2
d962 17
@


1.108
log
@Minor revision.
@
text
@d115 1
a115 1
// Test of the MessageManager before the Problem is constructed.
d122 1
a122 1
      myMgrMgr = mySession.getMessageManager ();
d155 1
a155 1
      assert (myProblem.getMessageManager () == myMgrMgr);
d161 1
a161 1
// Test of the MessageManager after the Problem has been constructed.
d1096 13
a1108 13
   private Session        mySession;
   private MessageManager myMgrMgr;
   private Problem        myProblem;
   private GlobalComp     myGlobalComp;
   private Part           myPartA;
   private Part           myPartB;
   private Part           myPartC;
   private Demand         myDemandD;
   private Operation      myOpnE;
   private BomEntry       myBomEntEA;
   private BomEntry       myBomEntEB;
   private Substitute     mySubEAB;
   private BopEntry       myBopEntEC;
@


1.107
log
@Minor revision.
@
text
@d120 1
a120 1
      boolean theQuietMode;
d124 1
a124 1
      myMgrMgr.setQuietMode (true);
d126 1
a126 1
      theQuietMode = myMgrMgr.getQuietMode ();
d128 1
a128 1
      assert (theQuietMode);
d132 1
a132 1
      myMgrMgr.setQuietMode (false);
@


1.106
log
@Implemented theBomEnt.getSubstitute (theSubIndex).
@
text
@d109 1
a109 1
      assert (! myProblem.getActive ());
@


1.105
log
@Implemented theBomEnt.getSubstitutes ().
@
text
@d283 2
@


1.104
log
@Implemented theOpn.getBopEntry (theBopIndex).
@
text
@d332 4
@


1.103
log
@Implemented theOpn.getBomEntry (theBomIndex).
@
text
@d275 2
@


1.102
log
@Implemented theOpn.getBomEntries ().
Implemented theOpn.getBopEntries ().
@
text
@d273 2
@


1.101
log
@Implemented thePart.getBopEntries ().
@
text
@d320 8
@


1.100
log
@Implemented thePart.getSubstitutes ().
@
text
@d316 4
@


1.99
log
@Implemented thePart.getBomEntries ().
@
text
@d312 4
@


1.98
log
@Implemented thePart.getDemand (theDemandName).
@
text
@d308 4
@


1.97
log
@Implemented thePart.getDemands ().
@
text
@d267 2
@


1.96
log
@Implemented theComp.getProblem ().
@
text
@d302 4
@


1.95
log
@Implemented theProblem.getOperation (theOpnName).
@
text
@d265 2
@


1.94
log
@Implemented theProblem.getPart (thePartName).
@
text
@d262 3
a264 1
              + myProblem .getPart       ("B"));
@


1.93
log
@Implemented theProblem.getComponents ().
@
text
@d96 2
a97 1
      testNavMethods               ();
d252 1
a252 1
// testNavMethods ().
d254 1
a254 1
// Tests the navigational methods.
d257 37
a293 1
   private void testNavMethods ()
a297 12

      println (myDemandD .getPart       ());
      println (myDemandD .getDemandName ());
      println (myBomEntEB.getOperation  ());
      println (myBomEntEB.getPart       ());
      println (myBomEntEB.getBomIndex   ());
      println (mySubEAB  .getBomEntry   ());
      println (mySubEAB  .getPart       ());
      println (mySubEAB  .getSubIndex   ());
      println (myBopEntEC.getOperation  ());
      println (myBopEntEC.getPart       ());
      println (myBopEntEC.getBopIndex   ());
d1029 3
a1031 1
      println (theArrName + ":");
@


1.92
log
@Wrapped witGeneratePriorities.
@
text
@d48 1
a48 1
         System.out.println (
d83 1
a83 1
      System.out.println (
d96 1
a96 1
      testStructCompMethods        ();
d235 13
a247 13
      System.out.println ();
      System.out.println (mySession);
      System.out.println (myMgrMgr);
      System.out.println (myProblem);
      System.out.println (myPartA);
      System.out.println (myPartB);
      System.out.println (myPartC);
      System.out.println (myDemandD);
      System.out.println (myOpnE);
      System.out.println (myBomEntEA);
      System.out.println (myBomEntEB);
      System.out.println (mySubEAB);
      System.out.println (myBopEntEC);
d251 22
a272 18
// testStructCompMethods ().
//
// Tests the structural methods of the Components.
//------------------------------------------------------------------------------

   private void testStructCompMethods ()
      {
      System.out.println (myDemandD .getPart          ());
      System.out.println (myDemandD .getDemandName    ());
      System.out.println (myBomEntEB.getOperation     ());
      System.out.println (myBomEntEB.getPart          ());
      System.out.println (myBomEntEB.getBomIndex      ());
      System.out.println (mySubEAB  .getBomEntry      ());
      System.out.println (mySubEAB  .getPart          ());
      System.out.println (mySubEAB  .getSubIndex      ());
      System.out.println (myBopEntEC.getOperation     ());
      System.out.println (myBopEntEC.getPart          ());
      System.out.println (myBopEntEC.getBopIndex      ());
d281 1
a281 1
      System.out.println (
d414 1
a414 1
         System.out.println (
d420 1
a420 1
         System.out.println (
d426 1
a426 1
            System.out.println ("   " + theAttSpec);
d442 1
a442 1
      System.out.println (
d450 1
a450 1
            System.out.println (
d455 1
a455 1
      System.out.println (
d460 1
a460 1
         System.out.println ("      Access Style: Input");
d462 1
a462 1
         System.out.println ("      Access Style: Output");
d496 1
a496 1
               System.out.println (
d503 1
a503 1
            System.out.println ("   " + theAttSpec);
d508 1
a508 1
         System.out.println (
d901 1
a901 1
      System.out.println (
d984 1
a984 1
      System.out.println ("\n");
d993 26
a1018 1
      System.out.println (theDblArr[theDblArr.length - 1] + "]");
@


1.91
log
@Wrapped witEvalObjectives.
@
text
@d91 16
a106 15
      testMsgMgr1              ();
      setUpProblem             ();
      testMsgMgr2              ();
      buildComponents          ();
      printPublicObjects       ();
      testStructCompMethods    ();
      displayAttSpecs          ();
      checkForNonAppAttSpecs   ();
      testSetGet               ();
      testCustAtts             ();

      myProblem.displayData    ("");
      myProblem.heurImplode    ();
      myProblem.evalObjectives ();
      mySession.shutDownAll    ();
@


1.90
log
@Implemented negative numbers as infinity for mesgTimesPrint.
@
text
@d91 15
a105 14
      testMsgMgr1            ();
      setUpProblem           ();
      testMsgMgr2            ();
      buildComponents        ();
      printPublicObjects     ();
      testStructCompMethods  ();
      displayAttSpecs        ();
      checkForNonAppAttSpecs ();
      testSetGet             ();
      testCustAtts           ();

      myProblem.displayData  ("");
      myProblem.heurImplode  ();
      mySession.shutDownAll  ();
@


1.89
log
@Allowed mesgTimesPrint to be set by message group.
@
text
@d91 1
a91 1
      testMsgMgrPreProblem   ();
d93 1
a93 1
      testMsgMgrWithProblem  ();
d110 1
a110 1
// testMsgMgrPreProblem ()
d115 1
a115 1
   private void testMsgMgrPreProblem ()
d156 1
a156 1
// testMsgMgrWithProblem ()
d161 1
a161 1
   private void testMsgMgrWithProblem ()
d185 5
a189 1
      myMgrMgr.setMesgTimesPrint (MessageGroup.WARNING, 100);
@


1.88
log
@Revised the mesgTimesPrint attribute.
@
text
@d184 2
@


1.87
log
@Implemented the mesgTimesPrint attribute.
@
text
@d181 1
a181 1
      theInt =  myMgrMgr.getMesgTimesPrint (101);
@


1.86
log
@Minor revision.
@
text
@d127 1
a127 1
      myMgrMgr.setFileName ("Tester.out");
d165 1
d167 1
a167 1
      theName = myMgrMgr.getFileName ();
d171 1
a171 1
      myMgrMgr.setFileAccessMode ("a");
d173 1
a173 1
      theMode = myMgrMgr.getFileAccessMode ();
d177 7
a183 1
      myMgrMgr.setFileAccessMode ("w");
@


1.85
log
@Added a test of the MessageManager before the Problem is constructed.
@
text
@d91 1
a91 1
      testMsgMgr1            ();
d93 1
a93 1
      testMsgMgr2            ();
d110 1
a110 1
// testMsgMgr1 ()
d112 1
a112 1
// Test of the MessageManager, part 1.
d115 1
a115 1
   private void testMsgMgr1 ()
d156 1
a156 1
// testMsgMgr2 ()
d158 1
a158 1
// Test of the MessageManager, part 2.
d161 1
a161 1
   private void testMsgMgr2 ()
@


1.84
log
@Added the fileName msg attribute.
@
text
@d89 5
a93 2
      setUpSession           ();
      testMsgMgr             ();
d110 1
a110 1
// setUpSession ().
d112 1
a112 1
// Performs initial set-up of the Session the for unit test.
d115 1
a115 1
   private void setUpSession ()
d117 9
a125 1
      int nPeriodsVal;
d127 1
a127 1
      mySession    = Session  .newSession        ();
d129 2
a130 1
      myMgrMgr     = mySession.getMessageManager ();
d132 5
a136 1
      myProblem    = mySession.newProblem        ();
d138 7
a144 1
      myGlobalComp = myProblem.getGlobalComp     ();
d156 1
a156 1
// testMsgMgr ()
d158 1
a158 1
// Tests the MessageManager.
d161 1
a161 1
   private void testMsgMgr ()
d163 2
a164 3
      boolean theQuietMode;
      String  theMode;
      String  theName;
d166 1
a166 1
      myMgrMgr.setQuietMode (true);
d168 1
a168 3
      theQuietMode = myMgrMgr.getQuietMode ();

      assert (theQuietMode);
a175 2
      myMgrMgr.setQuietMode (false);

a176 6

      myMgrMgr.setFileName ("Tester.out");

      theName = myMgrMgr.getFileName ();

      assert (theName.equals ("Tester.out"));
@


1.83
log
@Class name changes.
@
text
@d143 1
d160 6
@


1.82
log
@Implemented msg attribute fileAccessMode.
@
text
@d90 1
a90 1
      testMsgHandler         ();
d116 1
a116 1
      mySession    = Session  .newSession    ();
d118 1
a118 1
      myMsgHandler = mySession.getMsgHandler ();
d120 1
a120 1
      myProblem    = mySession.newProblem    ();
d122 1
a122 1
      myGlobalComp = myProblem.getGlobalComp ();
d130 1
a130 1
      assert (myProblem.getMsgHandler () == myMsgHandler);
d134 1
a134 1
// testMsgHandler ()
d136 1
a136 1
// Tests the MsgHandler.
d139 1
a139 1
   private void testMsgHandler ()
d144 1
a144 1
      myMsgHandler.setQuietMode (true);
d146 1
a146 1
      theQuietMode = myMsgHandler.getQuietMode ();
d150 1
a150 1
      myMsgHandler.setFileAccessMode ("a");
d152 1
a152 1
      theMode = myMsgHandler.getFileAccessMode ();
d156 1
a156 1
      myMsgHandler.setQuietMode (false);
d158 1
a158 1
      myMsgHandler.setFileAccessMode ("w");
d179 1
a179 1
      myMsgHandler.flushFile ();
d204 1
a204 1
      System.out.println (myMsgHandler);
d967 13
a979 13
   private Session    mySession;
   private MsgHandler myMsgHandler;
   private Problem    myProblem;
   private GlobalComp myGlobalComp;
   private Part       myPartA;
   private Part       myPartB;
   private Part       myPartC;
   private Demand     myDemandD;
   private Operation  myOpnE;
   private BomEntry   myBomEntEA;
   private BomEntry   myBomEntEB;
   private Substitute mySubEAB;
   private BopEntry   myBopEntEC;
@


1.81
log
@Implemented theMsgHandler.quiteMode.
@
text
@d89 1
a89 2
      mySession = Session.newSession ();

a90 1
      setUpProblem           ();
d107 1
a107 1
// testMsgHandler ()
d109 1
a109 1
// Tests the MsgHandler.
d112 1
a112 1
   private void testMsgHandler ()
d114 3
a116 1
      boolean theQuietMode;
d120 7
a126 1
      myMsgHandler.setQuietMode (true);
d128 1
a128 1
      theQuietMode = myMsgHandler.getQuietMode ();
d130 1
a130 1
      assert (theQuietMode);
d134 1
a134 1
// setUpProblem ().
d136 1
a136 1
// Performs initial set-up of the Problem the for unit test.
d139 1
a139 1
   private void setUpProblem ()
d141 6
a146 1
      int nPeriodsVal;
d148 1
a148 1
      myProblem    = mySession.newProblem    ();
d150 1
a150 1
      assert (myProblem.getMsgHandler () == myMsgHandler);
d152 1
a152 1
      myGlobalComp = myProblem.getGlobalComp ();
d154 1
a154 1
      myGlobalComp.set (nPeriods (), 3);
d156 1
a156 1
      nPeriodsVal  = myGlobalComp.get (nPeriods ());
d158 1
a158 1
      assert (nPeriodsVal == 3);
@


1.80
log
@Implemented theMsgHandler.flushFile ().
@
text
@d89 4
a92 1
      setUpSession           ();
d109 1
a109 1
// setUpSession ().
d111 1
a111 1
// Performs initial set-up of the Session the for unit test.
d114 20
a133 1
   private void setUpSession ()
a136 2
      mySession    = Session  .newSession    ();
      myMsgHandler = mySession.getMsgHandler ();
a137 1
      myGlobalComp = myProblem.getGlobalComp ();
d141 2
@


1.79
log
@Active state / shutDown method.
@
text
@d91 1
a91 1
      printComponents        ();
d116 1
d120 2
d147 1
a147 1
      myProblem.flushMsgFile ();
d163 1
a163 1
// printComponents ().
d165 1
a165 1
// Prints the Session, Problem, and Components for the unit test.
d168 1
a168 1
   private void printComponents ()
d172 1
d932 1
a932 1
// Session, Problem and Components for unit test.
d936 1
@


1.78
log
@Revised the factory methods.
@
text
@d100 1
a100 1
      mySession.releaseAll   ();
d102 1
a102 1
      assert (myProblem.getReleased ());
@


1.77
log
@Disallowed creating a Problem for a Session that already has one.
@
text
@d115 2
a116 6
      mySession = Session.makeInstance ();

      myProblem = Problem.makeInstance (mySession);

      assert (! myProblem.getReleased ());

d121 1
a121 1
      nPeriodsVal = myGlobalComp.get (nPeriods ());
d134 9
a142 9
      myPartA    = Part      .makeInstance (myProblem, "A", CAPACITY);
      myPartB    = Part      .makeInstance (myProblem, "B", CAPACITY);
      myPartC    = Part      .makeInstance (myProblem, "C", MATERIAL);
      myDemandD  = Demand    .makeInstance (myPartC,   "D");
      myOpnE     = Operation .makeInstance (myProblem, "E");
      myBomEntEA = BomEntry  .makeInstance (myOpnE,     myPartA);
      myBomEntEB = BomEntry  .makeInstance (myOpnE,     myPartB);
      mySubEAB   = Substitute.makeInstance (myBomEntEA, myPartB);
      myBopEntEC = BopEntry  .makeInstance (myOpnE,     myPartC);
@


1.76
log
@Initial implementation of creating a Session without a Problem.
@
text
@a112 34
      Problem    theProblem;
      GlobalComp theGlobalComp;
      int        nPeriodsVal;

      mySession     = Session.makeInstance ();

      theProblem    = Problem.makeInstance (mySession);
      
      theGlobalComp = theProblem.getGlobalComp ();
      
      theGlobalComp.set (nPeriods (), 17);

      nPeriodsVal   = theGlobalComp.get (nPeriods ());

      assert (nPeriodsVal == 17);

      myProblem     = Problem.makeInstance (mySession);

      myGlobalComp  = myProblem.getGlobalComp ();

      assert (theProblem   .getReleased ());
      assert (theGlobalComp.getReleased ());

      nPeriodsVal   = myGlobalComp.get (nPeriods ());

      assert (nPeriodsVal == 26);

      myGlobalComp.set (nPeriods (), 3);
      }

/*

   private void setUpSession ()
      {
a129 2
*/

@


1.75
log
@Initial implementation of the Session classes.
@
text
@d113 34
d151 1
a151 1
      myProblem = mySession.getProblem ();
d164 2
@


1.74
log
@Terminology change.
@
text
@d87 1
a87 1
      Problem.selfTest       ();
d89 1
a89 1
      setUpProblem           ();
d100 1
a100 1
      myProblem.release      ();
d106 1
a106 1
// setUpProblem ().
d108 1
a108 1
// Performs initial set-up of the Problem the for unit test.
d111 1
a111 1
   private void setUpProblem ()
d115 3
a117 1
      myProblem = Problem.makeInstance ();
d166 1
a166 1
// Prints the Components for the unit test.
d172 2
d932 1
a932 1
// Problem and Components for unit test.
d935 1
@


1.73
log
@Minor change.
@
text
@d100 1
a100 1
      myProblem.shutDown     ();
d102 1
a102 1
      assert (! myProblem.getActive ());
d117 1
a117 1
      assert (myProblem.getActive ());
@


1.72
log
@BoundSet attributes.
@
text
@a82 2
      boolean isActive;

d102 1
a102 3
      isActive = myProblem.isActive ();

      assert (! isActive);
d113 1
a113 4
      boolean isActive;
      int     nPeriodsVal;

      myProblem    = Problem.makeInstance ();
d115 1
a115 1
      isActive     = myProblem.isActive ();
d117 1
a117 1
      assert (isActive);
@


1.71
log
@Added attribute cumShipBounds.
@
text
@d671 1
d676 1
a676 1
      double[] hardLBin;
d678 1
a678 1
      double[] hardUBin;
d683 1
a683 1
      hardLBin  = new double[] {10.0, 20.0, 30.0};
d685 1
a685 1
      hardUBin  = new double[] {70.0, 80.0, 90.0};
d691 1
a691 1
      myOpnE.set (execBounds (), hardLBin,  softLBin,  hardUBin);
d694 1
a694 1
      assertApproxEq (hardLBout, hardLBin);
d696 1
a696 1
      assertApproxEq (hardUBout, hardUBin);
@


1.70
log
@Added attribute "stockBounds".
@
text
@d232 1
d603 1
d615 31
a698 31
// testStockBounds ()
//
// Tests the "stockBounds" attribute.
//------------------------------------------------------------------------------

   private void testStockBounds ()
      {
      double[] hardLBin;
      double[] softLBin;
      double[] hardUBin;
      double[] hardLBout;
      double[] softLBout;
      double[] hardUBout;

      hardLBin  = new double[] {110.0, 120.0, 130.0};
      softLBin  = new double[] {140.0, 150.0, 160.0};
      hardUBin  = new double[] {170.0, 180.0, 190.0};

      hardLBout = new double[3];
      softLBout = new double[3];
      hardUBout = new double[3];

      myPartC.set (stockBounds (), hardLBin,  softLBin,  hardUBin);
      myPartC.get (stockBounds (), hardLBout, softLBout, hardUBout);

      assertApproxEq (hardLBout, hardLBin);
      assertApproxEq (softLBout, softLBin);
      assertApproxEq (hardUBout, hardUBin);
      }

//------------------------------------------------------------------------------
d778 31
@


1.69
log
@Added attribute "execBounds".
@
text
@d328 1
d608 1
d666 31
@


1.68
log
@"partCategory" attribute.
@
text
@d239 1
d601 7
a607 6
             demandNameTest ();
          operationNameTest ();
           partCategoryTest ();
               partNameTest ();
      solverLogFileNameTest ();
                  titleTest ();
d611 1
a611 1
// demandNameTest ()
d616 1
a616 1
   private void demandNameTest ()
d633 32
a664 1
// operationNameTest ()
d669 1
a669 1
   private void operationNameTest ()
d686 1
a686 1
// partCategoryTest ()
d691 1
a691 1
   private void partCategoryTest ()
d701 1
a701 1
// partNameTest ()
d706 1
a706 1
   private void partNameTest ()
d723 1
a723 1
// solverLogFileNameTest ()
d728 1
a728 1
   private void solverLogFileNameTest ()
d743 1
a743 1
// titleTest ()
d748 1
a748 1
   private void titleTest ()
@


1.67
log
@"demandName" attribute.
@
text
@d289 1
d602 1
d653 15
@


1.66
log
@"operationName" attribute.
@
text
@d234 1
d599 5
a603 4
      testOperationName     ();
      testPartName          ();
      testSolverLogFileName ();
      testTitle             ();
d607 23
a629 1
// testOperationName ()
d634 1
a634 1
   private void testOperationName ()
d651 1
a651 1
// testPartName ()
d656 1
a656 1
   private void testPartName ()
d673 1
a673 1
// testSolverLogFileName ()
d678 1
a678 1
   private void testSolverLogFileName ()
d693 1
a693 1
// testTitle ()
d698 1
a698 1
   private void testTitle ()
@


1.65
log
@"partName" attribute.
@
text
@a197 1
      System.out.println (myOpnE    .getOperationName ());
d287 1
d598 2
a600 1
      testPartName          ();
d605 1
a605 1
// testSolverLogFileName ()
d607 1
a607 1
// Tests the "solverLogFileName" attribute.
d610 1
a610 1
   private void testSolverLogFileName ()
d612 4
a615 2
      String solverLogFileNameIn;
      String solverLogFileNameOut;
d617 1
a617 1
      solverLogFileNameIn  = "wit-j.test.solver.log";
d619 1
a619 1
      myGlobalComp.set (solverLogFileName (), solverLogFileNameIn);
d621 1
a621 1
      solverLogFileNameOut = myGlobalComp.get (solverLogFileName ());
d623 1
a623 1
      assert (solverLogFileNameOut.equals (solverLogFileNameIn));
d649 20
@


1.64
log
@"solverLogFileName" attribute.
@
text
@a195 1
      System.out.println (myPartA   .getPartName      ());
d288 1
d599 1
d624 22
@


1.63
log
@Name change: Global --> GlobalComp.
@
text
@d321 1
a392 3
      System.out.println (
           "      Hash Code:    " + theAttSpec.hashCode ());

d598 22
a619 1
      testTitle ();
@


1.62
log
@"title" attribute.
@
text
@d120 1
a120 1
      myProblem   = Problem.makeInstance ();
d122 1
a122 1
      isActive    = myProblem.isActive ();
d126 1
a126 1
      myGlobal    = myProblem.getGlobal ();
d128 1
a128 1
      myGlobal.set (nPeriods (), 3);
d130 1
a130 1
      nPeriodsVal = myGlobal.get (nPeriods ());
d158 1
a158 1
            myGlobal,
d616 1
a616 1
      myGlobal.set (title (), titleIn);
d618 1
a618 1
      titleOut = myGlobal.get (title ());
d733 1
a733 1
   private Global     myGlobal;
@


1.61
log
@Added "title" attribute (set only).
@
text
@d600 21
a620 1
      myGlobal.set (title (), "WIT-J Test Problem");
@


1.60
log
@Added attributes:
   objValue
   bpundsValue
@
text
@d98 1
d331 1
a373 11
      System.out.println (
           "      Hash Code:  " + theAttSpec.hashCode ());

      if (theAttSpec.isAnInputAtt (myProblem))
         System.out.println ("      Access:     Input");
      else
         System.out.println ("      Access:     Output");

      System.out.println (
           "      Value Type: " + theAttSpec.getValueType ().getSimpleName ());

d379 1
a379 1
               "      Applies to: " + theComp.getClass ().getSimpleName ());
d383 12
d593 11
@


1.59
log
@Attributes.
@
text
@d225 1
d285 1
@


1.58
log
@Attributes.
@
text
@d368 4
a371 1
         + "   " + theAttSpec + ":"); 
@


1.57
log
@Customized Attributes.
@
text
@d14 1
a14 1
import       java.util.*;
a211 4
//
// Attempts to display all AttSpecs, by explicitly invoking their access
// methods.
// Lists any AttSpecs missed.
d368 1
a368 1
         + "   " + theAttSpec + ":");
@


1.56
log
@Attributes.
@
text
@d127 1
a127 1
      myGlobal.setNPeriods (3);
d129 1
a129 1
      nPeriodsVal = myGlobal.getNPeriods ();
d284 1
@


1.55
log
@Attributes.
@
text
@d69 1
a69 1
         new HashSet <AttSpec> (AttSpec.values ().length, 1.0f);
d71 1
a71 1
      for (AttSpec theAttSpec: AttSpec.values ())
d351 1
a351 1
         for (AttSpec theAttSpec: undisplayedAttSpecs)
d365 1
a365 1
   private void display (AttSpec theAttSpec)
d406 1
a406 1
      for (AttSpec theAttSpec: AttSpec.values ())
d723 1
a723 1
   private final HashSet <AttSpec> undisplayedAttSpecs;
@


1.54
log
@Classes Global and GlobalCI.
@
text
@d11 1
a11 1
import static com.ibm.witj.Attribute.*;
d68 2
a69 2
      undisplayedAtts =
         new HashSet <Attribute> (Attribute.values ().length, 1.0f);
d71 2
a72 2
      for (Attribute theAtt: Attribute.values ())
         undisplayedAtts.add (theAtt);
d89 1
a89 1
      Problem.selfTest      ();
d91 11
a101 11
      setUpProblem          ();
      buildComponents       ();
      printComponents       ();
      testStructCompMethods ();
      displayAtts           ();
      checkForNonAppAtts    ();
      testSetGet            ();

      myProblem.displayData ("");
      myProblem.heurImplode ();
      myProblem.shutDown    ();
d211 1
a211 1
// displayAtts ()
d213 1
a213 1
// Attempts to display all Attributes, by explicitly invoking their access
d215 1
a215 1
// Lists any Attributes missed.
d218 1
a218 1
   private void displayAtts ()
d222 1
a222 1
         + "Attributes:");
d339 1
a339 1
      if (undisplayedAtts.isEmpty ())
d343 1
a343 1
            + "All Attributes have been displayed.");
d349 1
a349 1
          + "The following Attributes were missing from the above listing:\n");
d351 1
a351 1
         for (Attribute theAtt: undisplayedAtts)
d353 1
a353 1
            System.out.println ("   " + theAtt);
d359 1
a359 1
// display (theAtt)
d361 2
a362 2
// Displays information about theAtt.
// To be invoked exactly once for each Attribute.
d365 1
a365 1
   private void display (Attribute theAtt)
d367 1
a367 1
      assert (undisplayedAtts.contains (theAtt));
d371 1
a371 1
         + "   " + theAtt + ":");
d373 1
a373 1
      if (theAtt.isAnInputAtt (myProblem))
d379 1
a379 1
           "      Value Type: " + theAtt.getValueType ().getSimpleName ());
d383 1
a383 1
         if (theAtt.appliesTo (theComp))
d390 1
a390 1
      undisplayedAtts.remove (theAtt);
d394 1
a394 1
// checkForNonAppAtts ()
d396 1
a396 1
// Displays all Attributes that don't apply to any Component class.
d399 1
a399 1
   private void checkForNonAppAtts ()
d406 1
a406 1
      for (Attribute theAtt: Attribute.values ())
d408 1
a408 1
         if (theAtt == null)
d415 1
a415 1
            if (theAtt.appliesTo (theComp))
d424 1
a424 1
                + "The following Attributes do not apply "
d429 1
a429 1
            System.out.println ("   " + theAtt);
d436 1
a436 1
          + "All Attributes apply to at least one Component class.");
d442 1
a442 1
// Tests Attribute set and get methods of class Component.
d458 1
a458 1
// Tests Attribute set and get methods for Attributes of value type boolean.
d478 1
a478 1
// Tests Attribute set and get methods for Attributes of value type int.
d498 1
a498 1
// Tests Attribute set and get methods for Attributes of value type double.
d518 1
a518 1
// Tests Attribute set and get methods for Attributes of value type boolean[].
d542 1
a542 1
// Tests Attribute set and get methods for Attributes of value type int[].
d566 1
a566 1
// Tests Attribute set and get methods for Attributes of value type double[].
d717 1
a717 1
// undisplayedAtts
d719 2
a720 2
// undisplayedAtts.contains (theAtt) is true, iff display has not been invoked
// on theAtt.
d723 1
a723 1
   private final HashSet <Attribute> undisplayedAtts;
@


1.53
log
@Attributes
@
text
@d119 1
a119 1
      myProblem = Problem.makeInstance ();
d121 1
a121 1
      isActive  = myProblem.isActive ();
d125 1
a125 1
      myGlobalComp = myProblem.getGlobalComp ();
d127 1
a127 1
      myGlobalComp.setNPeriods (3);
d129 1
a129 1
      nPeriodsVal = myGlobalComp.getNPeriods ();
d157 1
a157 1
            myGlobalComp,
d697 1
a697 1
   private GlobalComp myGlobalComp;
@


1.52
log
@Attributes.
@
text
@d447 6
a452 2
      testSetGetBool   ();
      testSetGetDblVec ();
d476 88
@


1.51
log
@Attributes.
@
text
@d224 114
a337 5
      display (supplyVol     ());
      display (demandVol     ());
      display (mrpNetAllowed ());
      display (expAllowed    ());
      display (scrapVol      ());
@


1.50
log
@Attributes.
@
text
@d213 1
a213 1
// Attempts to display all Attributes, but explicitly invoking thier access
d239 2
a240 2
              "\n"
            + "The following Attributes were missed:\n");
@


1.49
log
@Attributes.
@
text
@d96 1
d285 46
@


1.48
log
@Attributes.
@
text
@d89 2
a91 1
      myProblem.selfTest    ();
a98 1

a99 1

@


1.47
log
@Attributes.
@
text
@d90 1
@


1.46
log
@Attributes.
@
text
@a67 2
      setUpTestedAttComps ();

a75 23
// setUpTestedAttComps ()
//
// Sets up testedAttComps.
//------------------------------------------------------------------------------

   private void setUpTestedAttComps ()
      {
      HashSet <Class> theClassSet;

      testedAttComps =
         new HashMap <Attribute, HashSet <Class>> (
            Attribute.values ().length,
            1.0f);

      for (Attribute theAtt: Attribute.values ())
         {
         theClassSet = new HashSet <Class> (15);

         testedAttComps.put (theAtt, theClassSet);
         }
      }

//------------------------------------------------------------------------------
a94 1
      testInputAtts         ();
a99 4
      testPostImpAtts       ();

      checkTestedAtts       ();

a339 324
// testInputAtts ()
//
// Tests input Attributes.
//------------------------------------------------------------------------------

   private void testInputAtts ()
      {
      myProblem.flushMsgFile ();

      testInAtt (supplyVol     (), myPartB,    new double[] {40,  0, 50});
      testInAtt (demandVol     (), myDemandD,  new double[] {10, 20, 50});
      testInAtt (mrpNetAllowed (), mySubEAB,   true);
      testInAtt (expAllowed    (), mySubEAB,   false);
      testInAtt (expAllowed    (), myBopEntEC, false);

      printSeparator ();
      }

//------------------------------------------------------------------------------
// testPostImpAtts ()
//
// Tests post-implosion Attributes.
//------------------------------------------------------------------------------

   private void testPostImpAtts ()
      {
      myProblem.flushMsgFile ();

      testOutAtt (scrapVol (), myPartB, new double[] {40,  0, 50});

      printSeparator ();
      }

//------------------------------------------------------------------------------
// testInAtt (theAtt, theComp, theValue) methods
//
// Each of these method performs the following tests on theAtt:
//
// * Displays theAtt and theComp.
// * Sets the value of theAtt for theComp to theValue.
// * Retrieves the value of theAtt for theComp.
// * Verifies that the retrieved value matches theValue.
//------------------------------------------------------------------------------

   private void testInAtt (
         BooleanAtt theAtt,
         Component  theComp,
         boolean    theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

   private void testInAtt (
         IntegerAtt theAtt,
         Component  theComp,
         int        theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

   private void testInAtt (
         DoubleAtt  theAtt,
         Component  theComp,
         double     theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

   private void testInAtt (
         BooleanVectorAtt theAtt,
         Component        theComp,
         boolean[]        theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

   private void testInAtt (
         IntegerVectorAtt theAtt,
         Component        theComp,
         int[]            theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

   private void testInAtt (
         DoubleVectorAtt theAtt,
         Component       theComp,
         double[]        theValue)
      {
      testAtt (theAtt, theComp, theValue, true);
      }

//------------------------------------------------------------------------------
// testOutAtt (theAtt, theComp, theValue) methods
//
// Each of these method performs the following tests on theAtt:
//
// * Displays theAtt and theComp.
// * Retrieves the value of theAtt for theComp.
// * Verifies that the retrieved value matches theValue.
//------------------------------------------------------------------------------

   private void testOutAtt (
         BooleanAtt theAtt,
         Component  theComp,
         boolean    theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

   private void testOutAtt (
         IntegerAtt theAtt,
         Component  theComp,
         int        theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

   private void testOutAtt (
         DoubleAtt  theAtt,
         Component  theComp,
         double     theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

   private void testOutAtt (
         BooleanVectorAtt theAtt,
         Component        theComp,
         boolean[]        theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

   private void testOutAtt (
         IntegerVectorAtt theAtt,
         Component        theComp,
         int[]            theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

   private void testOutAtt (
         DoubleVectorAtt theAtt,
         Component       theComp,
         double[]        theValue)
      {
      assert (! theAtt.isAnInputAtt (myProblem));

      testAtt (theAtt, theComp, theValue, false);
      }

//------------------------------------------------------------------------------
// testAtt (theAtt, theComp, theValue) methods
//
// Each of these methods performs the following tests on theAtt:
//
// * Displays theAtt and theComp.
// * If testSetNeeded is true, sets the value of theAtt for theComp to theValue.
// * Retrieves the value of theAtt for theComp.
// * Verifies that the retrieved value matches theValue.
//------------------------------------------------------------------------------

   private void testAtt (
         BooleanAtt theAtt,
         Component  theComp,
         boolean    theValue,
         boolean    testSetNeeded)
      {
      boolean retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assert (retValue == theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------

   private void testAtt (
         IntegerAtt theAtt,
         Component  theComp,
         int        theValue,
         boolean    testSetNeeded)
      {
      int retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assert (retValue == theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------

   private void testAtt (
         DoubleAtt theAtt,
         Component theComp,
         double    theValue,
         boolean   testSetNeeded)
      {
      double retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assertApproxEq (retValue, theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------

   private void testAtt (
         BooleanVectorAtt theAtt,
         Component        theComp,
         boolean[]        theValue,
         boolean          testSetNeeded)
      {
      boolean[] retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assertEq (retValue, theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------

   private void testAtt (
         IntegerVectorAtt theAtt,
         Component        theComp,
         int[]            theValue,
         boolean          testSetNeeded)
      {
      int[] retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assertEq (retValue, theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------

   private void testAtt (
         DoubleVectorAtt theAtt,
         Component       theComp,
         double[]        theValue,
         boolean         testSetNeeded)
      {
      double[] retValue;

      displayAtt (theAtt, theComp);

      if (testSetNeeded)
         theComp.set (theAtt, theValue);

      retValue = theComp.get (theAtt);

      assertApproxEq (retValue, theValue);

      myProblem.flushMsgFile ();
      }

//------------------------------------------------------------------------------
// displayAtt (theAtt, theComp)
//
// Displays theAtt and theComp for testing purposes.
// Records the fact that theAtt is being tested for theComp.
//------------------------------------------------------------------------------

   private void displayAtt (
         Attribute theAtt,
         Component theComp)
      {
      printSeparator ();

      System.out.println (
           "Testing the " + theAtt + " Attribute for " + theComp + "."
         );

      testedAttComps.get (theAtt).add (theComp.getClass ());
      }

//------------------------------------------------------------------------------
d422 1
a439 36
//------------------------------------------------------------------------------
// checkTestedAtts ()
//
// Verifies that all Attributes have been tested for Component classes to which
// they apply.
//------------------------------------------------------------------------------

   void checkTestedAtts ()
      {
      boolean missedFound;

      missedFound = false;

      for (Attribute theAtt: Attribute.values ())
         {
         for (Component theComp: exampleComps)
            {
            if (theAtt.appliesTo (theComp))
               {
               if (! testedAttComps.get (theAtt).contains (theComp.getClass ()))
                  {
                  System.out.println (
                       "Attribute not tested: " + theAtt
                     + " for " + theComp.getClass ().getSimpleName ());

                  missedFound = true;
                  }
               }
            }
         }

      if (! missedFound)
         System.out.println (
            "All Attributes were tested on all applicable Component classes.");
      }

a468 9
// testedAttComps
//
// testedAttComps.get (theAtt).contains (theClass), iff a testAtt method has
// been invoked for theAtt and a Component whose Class ID is theClass.
//------------------------------------------------------------------------------

   private HashMap <Attribute, HashSet <Class>> testedAttComps;

//------------------------------------------------------------------------------
@


1.45
log
@Attributes.
@
text
@d119 1
d164 76
d314 1
a314 1
// buildComponents ().
d316 1
a316 1
// Builds the Components for the unit test.
d319 1
a319 1
   private void buildComponents ()
d321 2
a322 23
      myPartA    = Part      .makeInstance (myProblem, "A", CAPACITY);
      myPartB    = Part      .makeInstance (myProblem, "B", CAPACITY);
      myPartC    = Part      .makeInstance (myProblem, "C", MATERIAL);
      myDemandD  = Demand    .makeInstance (myPartC,   "D");
      myOpnE     = Operation .makeInstance (myProblem, "E");
      myBomEntEA = BomEntry  .makeInstance (myOpnE,     myPartA);
      myBomEntEB = BomEntry  .makeInstance (myOpnE,     myPartB);
      mySubEAB   = Substitute.makeInstance (myBomEntEA, myPartB);
      myBopEntEC = BopEntry  .makeInstance (myOpnE,     myPartC);

      myProblem.flushMsgFile ();

      exampleComps =
         new Component[]
            {
            myGlobalComp,
            myPartC,
            myDemandD,
            myOpnE,
            myBomEntEB,
            mySubEAB,
            myBopEntEC,
            };
d326 1
a326 1
// printComponents ().
d328 1
a328 1
// Prints the Components for the unit test.
d331 1
a331 1
   private void printComponents ()
d333 10
a342 10
      System.out.println ();
      System.out.println (myPartA);
      System.out.println (myPartB);
      System.out.println (myPartC);
      System.out.println (myDemandD);
      System.out.println (myOpnE);
      System.out.println (myBomEntEA);
      System.out.println (myBomEntEB);
      System.out.println (mySubEAB);
      System.out.println (myBopEntEC);
d346 1
a346 1
// testStructCompMethods ().
d348 1
a348 1
// Tests the structural methods of the Components.
d351 1
a351 1
   private void testStructCompMethods ()
d353 14
a366 13
      System.out.println (myPartA   .getPartName      ());
      System.out.println (myDemandD .getPart          ());
      System.out.println (myDemandD .getDemandName    ());
      System.out.println (myOpnE    .getOperationName ());
      System.out.println (myBomEntEB.getOperation     ());
      System.out.println (myBomEntEB.getPart          ());
      System.out.println (myBomEntEB.getBomIndex      ());
      System.out.println (mySubEAB  .getBomEntry      ());
      System.out.println (mySubEAB  .getPart          ());
      System.out.println (mySubEAB  .getSubIndex      ());
      System.out.println (myBopEntEC.getOperation     ());
      System.out.println (myBopEntEC.getPart          ());
      System.out.println (myBopEntEC.getBopIndex      ());
@


1.44
log
@Attributes.
@
text
@d69 6
d118 1
a118 1
      displayAllAtts        ();
d137 1
a137 1
// displayAllAtts ()
d139 1
a139 1
// Displays all Attributes.
d142 29
a170 1
   private void displayAllAtts ()
d174 1
a174 1
         + "List of all Attributes:");
d176 13
a188 1
      for (Attribute theAtt: Attribute.values ())
d192 1
a192 2
            + "   " + theAtt + ":\n"
            + "      Value Type: " + theAtt.getValueType ().getSimpleName ());
d194 1
a194 1
         for (Component theComp: exampleComps)
d196 1
a196 5
            if (theAtt.appliesTo (theComp))
               {
               System.out.println (
                  "      Applies to: " + theComp.getClass ().getSimpleName ());
               }
d202 1
a202 1
// setUpProblem ().
d204 2
a205 1
// Performs initial set-up of the Problem the for unit test.
d208 1
a208 1
   private void setUpProblem ()
d210 1
a210 2
      boolean isActive;
      int     nPeriodsVal;
d212 3
a214 1
      myProblem = Problem.makeInstance ();
d216 4
a219 1
      isActive  = myProblem.isActive ();
d221 2
a222 1
      assert (isActive);
d224 8
a231 3
      myGlobalComp = myProblem.getGlobalComp ();

      myGlobalComp.setNPeriods (3);
d233 1
a233 3
      nPeriodsVal = myGlobalComp.getNPeriods ();

      assert (nPeriodsVal == 3);
d810 9
@


1.43
log
@Attributes.
@
text
@d14 2
d68 24
d121 2
a137 14
      Component[] repComps;

      repComps =
         new Component[]
            {
            myGlobalComp,
            myPartC,
            myDemandD,
            myOpnE,
            myBomEntEB,
            mySubEAB,
            myBopEntEC,
            };

d149 1
a149 1
         for (Component theComp: repComps)
d205 12
d569 2
a570 1
// Displays theAtt and theComp.
d582 2
a668 1
//------------------------------------------------------------------------------
d686 36
d743 17
@


1.42
log
@Attributes.
@
text
@d282 3
a284 3
         BooleanScalarAtt theAtt,
         Component        theComp,
         boolean          theValue)
d290 3
a292 3
         IntegerScalarAtt theAtt,
         Component        theComp,
         int              theValue)
d298 3
a300 3
         DoubleScalarAtt  theAtt,
         Component        theComp,
         double           theValue)
d340 3
a342 3
         BooleanScalarAtt theAtt,
         Component        theComp,
         boolean          theValue)
d350 3
a352 3
         IntegerScalarAtt theAtt,
         Component        theComp,
         int              theValue)
d360 3
a362 3
         DoubleScalarAtt  theAtt,
         Component        theComp,
         double           theValue)
d411 4
a414 4
         BooleanScalarAtt theAtt,
         Component        theComp,
         boolean          theValue,
         boolean          testSetNeeded)
d433 4
a436 4
         IntegerScalarAtt theAtt,
         Component        theComp,
         int              theValue,
         boolean          testSetNeeded)
d455 4
a458 4
         DoubleScalarAtt theAtt,
         Component       theComp,
         double          theValue,
         boolean         testSetNeeded)
@


1.41
log
@Attributes.
@
text
@d290 32
d340 50
@


1.40
log
@Attributes.
@
text
@d282 3
a284 3
         Attribute.BooleanScalar theAtt,
         Component               theComp,
         boolean                 theValue)
d290 3
a292 3
         Attribute.DoubleVector theAtt,
         Component              theComp,
         double[]               theValue)
d308 3
a310 3
         Attribute.DoubleVector theAtt,
         Component              theComp,
         double[]               theValue)
d329 4
a332 4
         Attribute.BooleanScalar theAtt,
         Component               theComp,
         boolean                 theValue,
         boolean                 testSetNeeded)
d351 4
a354 4
         Attribute.IntegerScalar theAtt,
         Component               theComp,
         int                     theValue,
         boolean                 testSetNeeded)
d373 4
a376 4
         Attribute.DoubleScalar theAtt,
         Component              theComp,
         double                 theValue,
         boolean                testSetNeeded)
d395 4
a398 4
         Attribute.BooleanVector theAtt,
         Component               theComp,
         boolean[]               theValue,
         boolean                 testSetNeeded)
d417 4
a420 4
         Attribute.IntegerVector theAtt,
         Component               theComp,
         int[]                   theValue,
         boolean                 testSetNeeded)
d439 4
a442 4
         Attribute.DoubleVector theAtt,
         Component              theComp,
         double[]               theValue,
         boolean                testSetNeeded)
@


1.39
log
@Attributes.
@
text
@d312 2
@


1.38
log
@Attributes.
@
text
@d133 1
a133 1
            + "      Value Type: " + theAtt.valueType ().getSimpleName ());
@


1.37
log
@Attributes.
@
text
@a110 1
      String      theClassName;
d132 2
a133 1
            + "   " + theAtt + ":");
d139 2
a140 3
               theClassName = theComp.getClass ().toString ().substring (19);

               System.out.println ("      " + theClassName);
@


1.36
log
@Attributes.
@
text
@d283 3
a285 3
         Attribute <Boolean> theAtt,
         Component           theComp,
         boolean             theValue)
d291 3
a293 3
         Attribute <double[]> theAtt,
         Component            theComp,
         double[]             theValue)
d309 3
a311 3
         Attribute <double[]> theAtt,
         Component            theComp,
         double[]             theValue)
d328 4
a331 4
         Attribute <Boolean> theAtt,
         Component           theComp,
         boolean             theValue,
         boolean             testSetNeeded)
d350 4
a353 4
         Attribute <Integer> theAtt,
         Component           theComp,
         int                 theValue,
         boolean             testSetNeeded)
d372 4
a375 4
         Attribute <Double> theAtt,
         Component          theComp,
         double             theValue,
         boolean            testSetNeeded)
d394 4
a397 4
         Attribute <boolean[]> theAtt,
         Component             theComp,
         boolean[]             theValue,
         boolean               testSetNeeded)
d416 4
a419 4
         Attribute <int[]> theAtt,
         Component         theComp,
         int[]             theValue,
         boolean           testSetNeeded)
d438 4
a441 4
         Attribute <double[]> theAtt,
         Component            theComp,
         double[]             theValue,
         boolean              testSetNeeded)
@


1.35
log
@Attributes.
@
text
@a81 1
      displayAllAtts        ();
d86 1
d110 15
d127 1
a127 1
         + "List of all Attributes:\n");
d131 13
a143 1
         System.out.println ("   " + theAtt);
@


1.34
log
@Attributes.
@
text
@d82 1
d103 18
@


1.33
log
@Attributes.
@
text
@d241 46
d291 2
a292 1
      theComp.set (theAtt, theValue);
d303 49
a351 4
   private void testInAtt (
         Attribute <double[]> theAtt,
         Component            theComp,
         double[]             theValue)
d353 1
a353 1
      double[] retValue;
d357 2
a358 1
      theComp.set (theAtt, theValue);
d362 1
a362 1
      assertEqual (retValue, theValue);
d368 21
a388 7
// testOutAtt (theAtt, theComp, theValue) methods
//
// Each of these method performs the following tests on theAtt:
//
// * Displays theAtt and theComp.
// * Retrieves the value of theAtt for theComp.
// * Verifies that the retrieved value matches theValue.
d391 1
a391 1
   private void testOutAtt (
d394 2
a395 1
         double[]             theValue)
d401 3
d406 1
a406 1
      assertEqual (retValue, theValue);
d442 1
a442 1
// assertEqual (...)
d444 2
a445 1
// Asserts that the elements of the two vectors are (nearly) equal.
d448 33
a480 1
   private static void assertEqual (
d489 16
a504 3
         assert (
              StrictMath.abs (theDblVec1[theIdx] - theDblVec2[theIdx])
            < .0001);
@


1.32
log
@Attributes.
@
text
@a81 1
      testAttAccessors      ();
d86 1
a86 4
      testSupplyVol         ();
      testDemandVol         ();
      testMrpNetAllowed     ();
      testExpAllowed        ();
d92 1
a92 1
      testScrapVol          ();
d94 1
a94 1
      myProblem.shutDown ();
a101 19
// testAttAccessors ().
//
// Tests the Attribute Accessor methods.
//------------------------------------------------------------------------------

   private void testAttAccessors ()
      {
      System.out.println (
           "\n"
         + "Attributes:\n"
         + "   " + demandVol     () + "\n"
         + "   " + expAllowed    () + "\n"
         + "   " + mrpNetAllowed () + "\n"
         + "   " + scrapVol      () + "\n"
         + "   " + supplyVol     () + "\n"
         );
      }

//------------------------------------------------------------------------------
d192 1
a192 1
// testSupplyVol.
d194 1
a194 1
// Tests the supplyVol attribute.
d197 1
a197 1
   private void testSupplyVol ()
d199 1
a199 2
      double[] supplyVolIn;
      double[] supplyVolOut;
d201 5
a205 1
      supplyVolIn = new double[] {40, 0, 50};
d207 2
a208 1
      myPartB.set (supplyVol (), supplyVolIn);
d210 5
a214 1
      supplyVolOut = myPartB.get (supplyVol ());
d216 3
a218 1
      assertEqual (supplyVolOut, supplyVolIn);
d220 3
a222 1
      myPartC.set (supplyVol (), new double[] {60, 0, 0});
d226 3
a228 1
// testDemandVol.
d230 4
a233 1
// Tests the demandVol attribute.
d236 4
a239 1
   private void testDemandVol ()
d241 3
a243 2
      double[] demandVolIn;
      double[] demandVolOut;
d245 1
a245 2
      demandVolIn  = new double[] {10, 20, 50};
      demandVolOut = new double[3];
d247 1
a247 2
      myDemandD.set (demandVol (), demandVolIn);
      myDemandD.get (demandVol (), demandVolOut);
d249 3
a251 1
      assertEqual (demandVolOut, demandVolIn);
a254 4
// testMrpNetAllowed.
//
// Tests the mrpNetAllowed attribute.
//------------------------------------------------------------------------------
d256 4
a259 1
   private void testMrpNetAllowed ()
d261 3
a263 1
      boolean mrpNetAllowedOut;
d265 1
a265 1
      mySubEAB.set (mrpNetAllowed (), true);
d267 1
a267 1
      mrpNetAllowedOut = mySubEAB.get (mrpNetAllowed ());
d269 3
a271 1
      assert (mrpNetAllowedOut);
d275 3
a277 1
// testExpAllowed.
d279 3
a281 1
// Tests the expAllowed attribute.
d284 4
a287 1
   private void testExpAllowed ()
d289 1
a289 1
      boolean expAllowedOut;
d291 1
d293 1
a293 1
      mySubEAB.set (expAllowed (), false);
d295 1
a295 1
      expAllowedOut = mySubEAB.get (expAllowed ());
d297 2
a298 1
      assert (! expAllowedOut);
d300 5
d306 5
a310 1
      myBopEntEC.set (expAllowed (), false);
d312 3
a314 3
      expAllowedOut = myBopEntEC.get (expAllowed ());

      assert (! expAllowedOut);
d318 1
a318 3
// testScrapVol.
//
// Tests the scrapVol attribute.
d321 1
a321 1
   private void testScrapVol ()
d323 5
a327 5
      double[] scrapVolOut;

      scrapVolOut = myPartB.get (scrapVol ());

      printArray ("myPartB.scrapVol", scrapVolOut);
@


1.31
log
@Attributes.
@
text
@d90 1
a115 2
         + "   " + supplyVol     () + "\n"
         + "   " + scrapVol      () + "\n"
d117 1
d119 2
d274 25
@


1.30
log
@Attributes.
@
text
@a81 4
      System.out.println (
           "\n"
         + AttribOld.supplyVol ());

a138 2
      myProblem.selfTest ();

@


1.29
log
@Attributes.
@
text
@d231 1
a231 1
      myPartB.set (AttribOld.supplyVol (), supplyVolIn);
d233 1
a233 1
      supplyVolOut = myPartB.get (AttribOld.supplyVol ());
d237 1
a237 1
      myPartC.set (AttribOld.supplyVol (), new double[] {60, 0, 0});
d254 2
a255 2
      myDemandD.set (AttribOld.demandVol (), demandVolIn);
      myDemandD.get (AttribOld.demandVol (), demandVolOut);
d270 1
a270 1
      mySubEAB.set (AttribOld.mrpNetAllowed (), true);
d272 1
a272 1
      mrpNetAllowedOut = mySubEAB.get (AttribOld.mrpNetAllowed ());
d287 1
a287 1
      scrapVolOut = myPartB.get (AttribOld.scrapVol ());
@


1.28
log
@Attributes.
@
text
@d8 1
a8 1
package        com.ibm.witj.test;
d10 3
a12 3
import         com.ibm.witj.*;
import  static com.ibm.witj.AttribOld.*;
import  static com.ibm.witj.Part.Category.*;
d84 1
a84 1
         + supplyVol ());
d86 1
d109 18
d231 1
a231 1
      myPartB.set (supplyVol (), supplyVolIn);
d233 1
a233 1
      supplyVolOut = myPartB.get (supplyVol ());
d237 1
a237 1
      myPartC.set (supplyVol (), new double[] {60, 0, 0});
d254 2
a255 2
      myDemandD.set (demandVol (), demandVolIn);
      myDemandD.get (demandVol (), demandVolOut);
d270 1
a270 1
      mySubEAB.set (mrpNetAllowed (), true);
d272 1
a272 1
      mrpNetAllowedOut = mySubEAB.get (mrpNetAllowed ());
d287 1
a287 1
      scrapVolOut = myPartB.get (scrapVol ());
@


1.27
log
@Changed name of class AttID to Attribute.
@
text
@d11 1
a11 1
import  static com.ibm.witj.Attribute.*;
@


1.26
log
@Attributes.
@
text
@d11 1
a11 1
import  static com.ibm.witj.AttID.*;
@


1.25
log
@Replaced classes Material and Capacity with an enum.
@
text
@d84 1
a84 1
         + SUPPLY_VOL);
d212 1
a212 1
      myPartB.set (SUPPLY_VOL, supplyVolIn);
d214 1
a214 1
      supplyVolOut = myPartB.get (SUPPLY_VOL);
d218 1
a218 1
      myPartC.set (SUPPLY_VOL, new double[] {60, 0, 0});
d235 2
a236 2
      myDemandD.set (DEMAND_VOL, demandVolIn);
      myDemandD.get (DEMAND_VOL, demandVolOut);
d251 1
a251 1
      mySubEAB.set (MRP_NET_ALLOWED, true);
d253 1
a253 1
      mrpNetAllowedOut = mySubEAB.get (MRP_NET_ALLOWED);
d268 1
a268 1
      scrapVolOut = myPartB.get (SCRAP_VOL);
@


1.24
log
@Made accessor names begin with "get".
@
text
@d12 1
d143 4
a146 4
      myCapA     = Capacity  .makeInstance (myProblem, "A");
      myCapB     = Capacity  .makeInstance (myProblem, "B");
      myMatC     = Material  .makeInstance (myProblem, "C");
      myDemandD  = Demand    .makeInstance (myMatC,    "D");
d148 4
a151 4
      myBomEntEA = BomEntry  .makeInstance (myOpnE,     myCapA);
      myBomEntEB = BomEntry  .makeInstance (myOpnE,     myCapB);
      mySubEAB   = Substitute.makeInstance (myBomEntEA, myCapB);
      myBopEntEC = BopEntry  .makeInstance (myOpnE,     myMatC);
d165 3
a167 3
      System.out.println (myCapA);
      System.out.println (myCapB);
      System.out.println (myMatC);
d184 1
a184 1
      System.out.println (myCapA    .getPartName      ());
d212 1
a212 1
      myCapB.set (SUPPLY_VOL, supplyVolIn);
d214 1
a214 1
      supplyVolOut = myCapB.get (SUPPLY_VOL);
d218 1
a218 1
      myMatC.set (SUPPLY_VOL, new double[] {60, 0, 0});
d268 1
a268 1
      scrapVolOut = myCapB.get (SCRAP_VOL);
d270 1
a270 1
      printArray ("myCapB.scrapVol", scrapVolOut);
d325 3
a327 3
   private Capacity   myCapA;
   private Capacity   myCapB;
   private Material   myMatC;
@


1.23
log
@Initial implementation of self-test.
@
text
@d125 1
a125 1
      myGlobalComp = myProblem.myGlobalComp ();
d183 13
a195 13
      System.out.println (myCapA    .partName      ());
      System.out.println (myDemandD .myPart        ());
      System.out.println (myDemandD .demandName    ());
      System.out.println (myOpnE    .operationName ());
      System.out.println (myBomEntEB.myOperation   ());
      System.out.println (myBomEntEB.myPart        ());
      System.out.println (myBomEntEB.bomIndex      ());
      System.out.println (mySubEAB  .myBomEntry    ());
      System.out.println (mySubEAB  .myPart        ());
      System.out.println (mySubEAB  .subIndex      ());
      System.out.println (myBopEntEC.myOperation   ());
      System.out.println (myBopEntEC.myPart        ());
      System.out.println (myBopEntEC.bopIndex      ());
@


1.22
log
@Attributes.
@
text
@d123 2
@


1.21
log
@Attributes.
@
text
@d230 1
d233 1
a233 2

      demandVolOut = myDemandD.get (DEMAND_VOL);
@


1.20
log
@Attributes.
@
text
@d248 1
a248 1
      mySubEAB.setMrpNetAllowed (true);
d250 1
a250 1
      mrpNetAllowedOut = mySubEAB.getMrpNetAllowed ();
@


1.19
log
@Attributes.
@
text
@d211 1
a211 1
      supplyVolOut = myCapB.getSupplyVol ();
d233 1
a233 1
      demandVolOut = myDemandD.getDemandVol ();
d265 1
a265 1
      scrapVolOut = myCapB.getScrapVol ();
@


1.18
log
@Attributes
@
text
@d8 1
a8 3
package com.ibm.witj.test;

import  com.ibm.witj.*;
d10 1
a88 1
      testExecCost          ();
d176 1
a176 1
// Tests the strructural methods of the Components.
a196 20
// testExecCost.
//
// Tests the execCost attribute.
//------------------------------------------------------------------------------

   private void testExecCost ()
      {
      double[] execCostIn;
      double[] execCostOut;

      execCostIn = new double[] {10, 20, 30};

      myOpnE.setExecCost (execCostIn);

      execCostOut = myOpnE.getExecCost ();

      assertEqual (execCostOut, execCostIn);
      }

//------------------------------------------------------------------------------
d209 1
a209 1
      myCapB.setSupplyVol (supplyVolIn);
d215 1
a215 1
      myMatC.setSupplyVol (new double[] {60, 0, 0});
d229 1
a229 1
      demandVolIn = new double[] {10, 20, 50};
d231 1
a231 1
      myDemandD.setDemandVol (demandVolIn);
@


1.17
log
@Initial implementation of AttID classes.
@
text
@d99 1
a99 1
      testStockVol          ();
d278 1
a278 1
// testStockVol.
d280 1
a280 1
// Tests the stockVol attribute.
d283 1
a283 1
   private void testStockVol ()
d285 1
a285 1
      double[] stockVolOut;
d287 1
a287 1
      stockVolOut = myMatC.getStockVol ();
d289 1
a289 1
      printArray ("myMatC.stockVol", stockVolOut);
@


1.16
log
@Attributes.
@
text
@d12 2
d82 4
@


1.15
log
@Implemented of class DblVecOutAttAcc.
@
text
@d225 1
a225 1
      myCapB.supplyVol ().setValue (supplyVolIn);
d227 1
a227 1
      supplyVolOut = myCapB.supplyVol ().getValue ();
d231 1
a231 5
      System.out.println (
              "\n"
            + myMatC.supplyVol ());

      myMatC.supplyVol ().setValue (new double[] {60, 0, 0});
d247 1
a247 1
      myDemandD.demandVol ().setValue (demandVolIn);
d249 1
a249 1
      demandVolOut = myDemandD.demandVol ().getValue ();
a251 4

      System.out.println (
              "\n"
            + myDemandD.demandVol ());
d264 1
a264 1
      mySubEAB.mrpNetAllowed ().setValue (true);
d266 1
a266 1
      mrpNetAllowedOut = mySubEAB.mrpNetAllowed ().getValue ();
a268 4

      System.out.println (
              "\n"
            + mySubEAB.mrpNetAllowed ());
d281 1
a281 1
      stockVolOut = myMatC.stockVol ().getValue ();
a283 4

      System.out.println (
              "\n"
            + myMatC.stockVol ());
@


1.14
log
@Implemented the demandVol attribute.
@
text
@d93 2
d234 2
d284 19
d322 22
@


1.13
log
@Implemented Problem.heurImplode.
@
text
@d86 1
d235 24
@


1.12
log
@Attributes.
@
text
@d90 2
@


1.11
log
@Attributes.
@
text
@d86 1
d232 21
@


1.10
log
@Attributes.
@
text
@d224 4
@


1.9
log
@Moved error testing to its own class.
@
text
@d219 1
a219 1
      myCapB.setSupplyVol (supplyVolIn);
d221 1
a221 1
      supplyVolOut = myCapB.getSupplyVol ();
@


1.8
log
@*** empty log message ***
@
text
@d20 4
d30 3
a32 1
      Tester theTester;
d34 1
a34 1
      theTester = new Tester ();
d36 2
a37 23
      theTester.performTest (theArgs);

      System.gc ();
      }

//------------------------------------------------------------------------------
// Constructor.
//------------------------------------------------------------------------------

   private Tester ()
      {
      }

//------------------------------------------------------------------------------
// performTest (...).
//
// Performs a test on WIT-J, depending on theArgs.
//------------------------------------------------------------------------------

   private void performTest (String[] theArgs)
      {
      if (theArgs.length == 0)
         performUnitTest ();
d40 1
a40 1
         performErrorTest (theArgs[0]);
d54 12
a226 208
// performErrorTest ().
//
// Performs an error test.
//------------------------------------------------------------------------------

   private void performErrorTest (String arg1)
      {
      int caseIdx = -1;

      try
         {
         caseIdx = Integer.parseInt (arg1);
         }

      catch (NumberFormatException theExc)
         {
         System.out.println (
              "\n"
            + "ERROR:\n"
            + "   The argument to the WIT-J tester must be an integer.\n");

         System.exit (3);
         }

      if (caseIdx == 1)
         errorTestCase1 ();

      else if (caseIdx == 2)
         errorTestCase2 ();

      else if (caseIdx == 3)
         errorTestCase3 ();

      else if (caseIdx == 4)
         errorTestCase4 ();

      else if (caseIdx == 5)
         errorTestCase5 ();

      else if (caseIdx == 6)
         errorTestCase6 ();

      else
         {
         System.out.println (
              "\n"
            + "ERROR:\n"
            + "   The argument to the WIT-J tester must be an integer "
            +    "from 1 to 6.\n");

         System.exit (3);
         }
      }

//------------------------------------------------------------------------------
// errorTestCase1 ().
//
// Performs error test case #1.
//------------------------------------------------------------------------------

   private void errorTestCase1 ()
      {
      Problem theProblem;

      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #1:\n"
         + "   Garbage collection of an active InterfaceObject.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      theProblem = Problem.makeInstance ();

      Operation.makeInstance (theProblem, "Test Opn #2");
      }

//------------------------------------------------------------------------------
// errorTestCase2 ().
//
// Performs error test case #2.
//------------------------------------------------------------------------------

   private void errorTestCase2 ()
      {
      Problem theProblem;

      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #2:\n"
         + "   Calling an active method on an inactive InterfaceObject.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      theProblem = Problem.makeInstance ();

      theProblem.shutDown ();

      theProblem.displayData ("error.txt");
      }

//------------------------------------------------------------------------------
// errorTestCase3 ().
//
// Performs error test case #3.
//------------------------------------------------------------------------------

   private void errorTestCase3 ()
      {
      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #3:\n"
         + "   Passing null to the Operation ctor.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      Operation.makeInstance (null, "Null Operation");
      }

//------------------------------------------------------------------------------
// errorTestCase4 ().
//
// Performs error test case #4.
//------------------------------------------------------------------------------

   private void errorTestCase4 ()
      {
      Problem   theProblem;
      Operation theOpnA;
      double[]  execCostVal;

      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #4:\n"
         + "   Operation.setexecCost (...) "
         +    "with an array whose length != nPeriods.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      theProblem  = Problem.makeInstance ();

      theOpnA     = Operation.makeInstance (theProblem, "A");

      execCostVal = new double[]{1, 2, 3, 4};

      theOpnA.setExecCost (execCostVal);
      }

//------------------------------------------------------------------------------
// errorTestCase5 ().
//
// Performs error test case #5.
//------------------------------------------------------------------------------

   private void errorTestCase5 ()
      {
      Problem theProblem;

      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #5:\n"
         + "   setNPeriods(...) in a Problem that has an Operation.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      theProblem = Problem.makeInstance ();

      Operation.makeInstance (theProblem, "Test Opn #5");

      theProblem.myGlobalComp ().setNPeriods (7);
      }

//------------------------------------------------------------------------------
// errorTestCase6 ().
//
// Performs error test case #6.
//------------------------------------------------------------------------------

   private void errorTestCase6 ()
      {
      Problem theProblem;

      System.out.println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "WIT-J Error Test Case #6:\n"
         + "   Capacity.makeInstance (...) with an inactive Problem.\n"
         + "----------------------------------------"
         + "----------------------------------------\n");

      theProblem = Problem.makeInstance ();

      theProblem.shutDown ();

      Capacity.makeInstance (theProblem, "Test Cap #2");
      }

//------------------------------------------------------------------------------
@


1.7
log
@*** empty log message ***
@
text
@d77 1
a77 17
      Problem    theProblem;
      boolean    isActive;
      GlobalComp theGlobalComp;
      int        nPeriodsVal;
      Capacity   theCapA;
      Capacity   theCapB;
      Material   theMatC;
      Demand     theDemandD;
      Operation  theOpnE;
      BomEntry   theBomEntEA;
      BomEntry   theBomEntEB;
      Substitute theSubEAB;
      BopEntry   theBopEntEC;
      double[]   execCostIn;
      double[]   execCostOut;
      double[]   supplyVolIn;
      double[]   supplyVolOut;
d83 28
a110 1
      theProblem = Problem.makeInstance ();
d112 1
a112 1
      isActive   = theProblem.isActive ();
d116 1
a116 1
      theGlobalComp = theProblem.myGlobalComp ();
d118 1
a118 1
      theGlobalComp.setNPeriods (3);
d120 1
a120 1
      nPeriodsVal = theGlobalComp.getNPeriods ();
d123 1
d125 5
a129 9
      theCapA     = Capacity  .makeInstance (theProblem, "A");
      theCapB     = Capacity  .makeInstance (theProblem, "B");
      theMatC     = Material  .makeInstance (theProblem, "C");
      theDemandD  = Demand    .makeInstance (theMatC,    "D");
      theOpnE     = Operation .makeInstance (theProblem, "E");
      theBomEntEA = BomEntry  .makeInstance (theOpnE,     theCapA);
      theBomEntEB = BomEntry  .makeInstance (theOpnE,     theCapB);
      theSubEAB   = Substitute.makeInstance (theBomEntEA, theCapB);
      theBopEntEC = BopEntry  .makeInstance (theOpnE,     theMatC);
d131 14
a144 1
      theProblem.flushMsgFile ();
d146 8
d155 44
a198 23
      System.out.println (theCapA);
      System.out.println (theCapB);
      System.out.println (theMatC);
      System.out.println (theDemandD);
      System.out.println (theOpnE);
      System.out.println (theBomEntEA);
      System.out.println (theBomEntEB);
      System.out.println (theSubEAB);
      System.out.println (theBopEntEC);

      System.out.println (theCapA    .partName      ());
      System.out.println (theDemandD .myPart        ());
      System.out.println (theDemandD .demandName    ());
      System.out.println (theOpnE    .operationName ());
      System.out.println (theBomEntEB.myOperation   ());
      System.out.println (theBomEntEB.myPart        ());
      System.out.println (theBomEntEB.bomIndex      ());
      System.out.println (theSubEAB  .myBomEntry    ());
      System.out.println (theSubEAB  .myPart        ());
      System.out.println (theSubEAB  .subIndex      ());
      System.out.println (theBopEntEC.myOperation   ());
      System.out.println (theBopEntEC.myPart        ());
      System.out.println (theBopEntEC.bopIndex      ());
d202 1
a202 1
      theOpnE.setExecCost (execCostIn);
d204 1
a204 1
      execCostOut = theOpnE.getExecCost ();
d207 12
d222 1
a222 1
      theCapB.setSupplyVol (supplyVolIn);
d224 1
a224 1
      supplyVolOut = theCapB.getSupplyVol ();
a226 8

      theProblem.displayData ("");

      theProblem.shutDown ();

      isActive = theProblem.isActive ();

      assert (! isActive);
d443 3
a445 1
   private static void assertEqual (double[] theDblVec1, double[] theDblVec2)
d457 20
@


1.6
log
@*** empty log message ***
@
text
@d92 2
d158 8
@


1.5
log
@*** empty log message ***
@
text
@d134 14
@


1.4
log
@*** empty log message ***
@
text
@d121 2
@


1.3
log
@*** empty log message ***
@
text
@d81 9
a89 7
      Material   theMat;
      Capacity   theCap;
      Demand     theDemand;
      Operation  theOpn;
      BomEntry   theBomEnt0;
      BomEntry   theBomEnt1;
      BopEntry   theBopEnt;
d111 9
a119 7
      theMat     = Material .makeInstance (theProblem, "Test Mat #1");
      theCap     = Capacity .makeInstance (theProblem, "Test Cap #1");
      theDemand  = Demand   .makeInstance (theMat,     "Test Dem #1");
      theOpn     = Operation.makeInstance (theProblem, "Test Opn #1");
      theBomEnt0 = BomEntry .makeInstance (theOpn,      theCap);
      theBomEnt1 = BomEntry .makeInstance (theOpn,      theCap);
      theBopEnt  = BopEntry .makeInstance (theOpn,      theMat);
d122 9
a130 7
      System.out.println (theMat);
      System.out.println (theCap);
      System.out.println (theDemand);
      System.out.println (theOpn);
      System.out.println (theBomEnt0);
      System.out.println (theBomEnt1);
      System.out.println (theBopEnt);
d134 1
a134 1
      theOpn.setExecCost (execCostIn);
d136 1
a136 1
      execCostOut = theOpn.getExecCost ();
d283 1
a283 1
      Operation theOpn;
d298 1
a298 1
      theOpn      = Operation.makeInstance (theProblem, "Test Opn #4");
d302 1
a302 1
      theOpn.setExecCost (execCostVal);
@


1.2
log
@*** empty log message ***
@
text
@d87 1
d113 1
a113 1
      theBomEnt0 = BomEntry .makeInstance (theOpn,      theMat);
d115 1
d124 1
@


1.1
log
@*** empty log message ***
@
text
@d85 2
d108 14
a121 15
      theMat    = Material .makeInstance (theProblem, "Test Mat #1");
      theCap    = Capacity .makeInstance (theProblem, "Test Cap #1");
      theDemand = Demand   .makeInstance (theMat,     "Test Dem #1");
      theOpn    = Operation.makeInstance (theProblem, "Test Opn #1");

      System.out.println (
           "\n"
         + theMat
         + "\n"
         + theCap
         + "\n"
         + theDemand
         + "\n"
         + theOpn
         + "\n");
@


head	1.53;
access;
symbols;
locks; strict;
comment	@# @;


1.53
date	2009.05.05.20.17.07;	author rjw;	state dead;
branches;
next	1.52;

1.52
date	2009.04.17.15.38.25;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.16.21.08.39;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.08.19.18.02;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.30.21.07.32;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.13.19.32.22;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.13.16.36.09;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.12.22.45.21;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.12.19.02.42;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.10.18.58.10;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.06.23.23.05;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.05.20.49.00;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.17.23.46.02;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.10.23.19.30;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.06.22.40.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.03.16.32.28;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.31.00.56.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.22.23.12.42;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.21.21.43.25;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.16.23.45.57;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.22.47.10;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.16.23.43.04;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.16.16.13.30;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.15.15.35.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.11.19.06.23;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.11.17.01.29;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.11.16.48.31;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.11.15.37.40;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.10.20.54.10;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.10.19.20.41;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.10.18.49.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.09.18.38.19;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.04.16.56.33;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.03.23.02.22;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.26.14.48.19;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.25.21.58.17;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.25.15.28.48;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.21.23.07.39;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.21.15.29.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.14.22.52.53;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.21.15.03.42;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.14.21.37.00;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.08.19.03.38;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.07.18.50.28;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.06.22.14.07;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.01.22.19.14;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.26.22.21.27;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.19.14.56.42;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.12.16.09.37;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.09.19.00.01;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.09.15.38.19;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.08.19.45.36;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.05.22.06.52;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Changed name of Java class RetainedObject to PreservedObject.
@
text
@
//==============================================================================
// WIT-J Java Source File RetainedObject.java.
//
// Contains the declaration of class RetainedObject.
//==============================================================================

package       com.ibm.witj;

import static com.ibm.witj.Utility.*;

import       java.util.*;

//==============================================================================
// Class RetainedObject
//
// A RetainedObject is an object that is made unavailable for garbage-collection
// until it is deactivated.
//
// At any point in time, a RetainedObject is in an "active" state or an
// "inactive" state:
//
// * Initially, a RetainedObject is "active" (just after construction).
// * When its deactivate method is called, it enters into its "inactive" state.
// * From that point, on it remains in its "inactive" state.
//
// Most of the public methods of any RetainedObject subclass are allowed to be
// called only when the RetainedObject is in an active state. The exceptions
// to this rule are the following methods, which may be called regardless of
// whether or not the RetainedObject is active:
//
// * isActive ()
// * All methods inherited from class Object
//
// If  any other public method is called when the RetainedObject is inactive,
// a StatusQuoException is thrown.
// 
// When a RetainedObject is in an inactive state, the following conditions hold:
// 
// * It no longer owns any C++ objects.
// * All RetainedObjects that it owns are inactive.
// * There are no references to it from active RetainedObjects.
// * There are no static references to it from WIT-J.
//
// The deactivate method is responsible for putting the RetainedObject into this
// state.
//
// When a RetainedObject is active, WIT-J maintains a static reference to it
// (perhaps indirectly). This prevents the RetainedObject from being garbage
// collected while it is active, which, in turn, prevents the C++ objects
// that it owns from becoming memory leaks. The deactivate method removes this
// static reference and deletes all C++ objects that the RetainedObject owns.
// Thus when a RetainedObject is inactive and all references to it from the
// application program are removed, it is ready for safe garbage collection.
//
// Class Hierarchy:
//
// RetainedObject
//    Problem
//    Coordinator
//    AttImp
//       StdAttImp
//       CustAttImp
//          {Anonymous Inner Classes}
//    MessageMgr
//    Component
//       GlobalAspect
//       Part
//       Demand
//       Operation
//       BomEntry
//       Substitute
//       BopEntry
//    CppObjRep
//       ProblemCOR
//       CoordinatorCOR
//       AttBldrCOR
//       AttCOR
//       MessageMgrCOR
//       ComponentCOR
//          GlobalAspectCOR
//          PartCOR
//          DemandCOR
//          OperationCOR
//          BomEntryCOR
//          SubstituteCOR
//          BopEntryCOR
//==============================================================================

public abstract class RetainedObject
{
//==============================================================================
// Public Methods
//==============================================================================

//------------------------------------------------------------------------------
// toString ().
//
// Override from class Object.
//------------------------------------------------------------------------------

   public final String toString ()
      {
      try
         {
         notAllowedWhenTerminated ("RetainedObject.toString");

         return
            active?
               toStringActive ():
               "Inactive " + getClass ().getSimpleName ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   public final boolean isActive ()
      {
      try
         {
         notAllowedWhenTerminated ("RetainedObject.isActive");

         return active;
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//==============================================================================
// Protected Methods
//==============================================================================

//------------------------------------------------------------------------------
// finalize ()
//
// Override from class Object.
//------------------------------------------------------------------------------

   protected final void finalize () throws Throwable
      {
      assert (! active);

      super.finalize ();
      }

//==============================================================================
// Package-Internal Constructor
//==============================================================================

   RetainedObject ()
      {
      }

//==============================================================================
// Package-Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// toStringActive ().
//
// Returns the value for toString () for this RetainedObject when it is active.
//------------------------------------------------------------------------------

   abstract String toStringActive ();

//------------------------------------------------------------------------------
// deactivate ().
//
// "Deactivates" this RetainedObject, i.e., puts it into an inactive state.
// See the comment at the top of this class declaration.
//------------------------------------------------------------------------------

   void deactivate ()
      {
      assert (active);

      active = false;
      }

//------------------------------------------------------------------------------
// mustBeActive (methName)
//
// Verifies that the RetainedObject is currently active.
//
// Arguments:
//    methName: The name of the method.
//------------------------------------------------------------------------------

   final void mustBeActive (String methName)
      {
      notAllowedWhenTerminated (methName);

      if (! active)
         throw
            new StatusQuoException (
               "   A method that requires an active RetainedObject was called\n"
             + "   with an inactive RetainedObject\n"
             + "\n"
             + "      Method: " + methName + "\n"
             + "      Object: " + this);
      }

//------------------------------------------------------------------------------
// mustBeActive (theArg, argName, methName)
//
// Verifies that a RetainedObject argument to a method is non-null and active.
//
// Arguments:
//    theArg:   The argument being checked.
//    argName:  The name of the argument being checked.
//    methName: The name of the method.
//------------------------------------------------------------------------------

   static void mustBeActive (
         RetainedObject theArg,
         String         argName,
         String         methName)
      {
      mustBeNonNull (theArg, argName, methName);

      if (! theArg.active)
         throw
            new StatusQuoException (
               "   An inactive RetainedObject was passed as an argument to\n"
             + "   a method that requires an active RetainedObject.\n"
             + "\n"
             + "      Method:         " + methName + "\n"
             + "      Argument:       " + argName  + "\n"
             + "      Argument Value: " + theArg);
      }

//------------------------------------------------------------------------------
// removeInactive (theArrayList)
//
// Removes all inactive RetainedObjects from theArrayList.
// Reduces the capacity of theArrayList to its new size.
//------------------------------------------------------------------------------

   static
      <R extends RetainedObject>
         void removeInactive (ArrayList <R> theArrayList)
      {
      ArrayList <R> activeObjects;

      activeObjects = new ArrayList <R> (theArrayList.size ());

      for (R theR: theArrayList)
         {
         if (theR.active)
            activeObjects.add (theR);
         }

      theArrayList.clear          ();
      theArrayList.trimToSize     ();
      theArrayList.ensureCapacity (activeObjects.size ());
      
      for (R theR: activeObjects)
         {
         theArrayList.add (theR);
         }
      }

//------------------------------------------------------------------------------
// activeOnly (theHashMap)
//
// Creates and returns a copy of theHashMap with all mappings to inactive
// RetainedObjects removed.
//------------------------------------------------------------------------------

   static
      <R extends RetainedObject>
         HashMap <String, R>
            activeOnly (HashMap <String, R> theHashMap)
      {
      HashMap <String, R> tmpHashMap;

      tmpHashMap = new HashMap <String, R> (theHashMap);

      for (String theKey: theHashMap.keySet ())
         {
         if (! tmpHashMap.get    (theKey).active)
               tmpHashMap.remove (theKey);
         }

      return new HashMap <String, R> (tmpHashMap);
      }

//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// active.
//
// True, iff this RetainedObject is currently active
//------------------------------------------------------------------------------

   private boolean active = true;

//==============================================================================
}
@


1.52
log
@Argument checking.
@
text
@@


1.51
log
@theProblem.clear ().
@
text
@d214 1
a214 1
// mustBeActiveAsArg
d216 1
a216 2
// Verifies that this RetainedObject is currently active when it is an argument
// to a method.
d219 1
d224 4
a227 1
   final void mustBeActiveAsArg (String argName, String methName)
d229 3
a231 1
      if (! active)
d239 1
a239 1
             + "      Argument Value: " + this);
@


1.50
log
@Made some methods final.
@
text
@d36 1
a36 1
// WIT-J throws a StatusQuoException.
d41 1
a41 1
// * All Java objects that it owns are inactive.
@


1.49
log
@Changed names of AttRep classes to AttImp.
@
text
@d124 1
a124 1
   public boolean isActive ()
d149 1
a149 1
   protected void finalize () throws Throwable
d199 1
a199 1
   void mustBeActive (String methName)
d224 1
a224 1
   void mustBeActiveAsArg (String argName, String methName)
@


1.48
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@d61 3
a63 3
//    AttRep
//       StdAttRep
//       CustAttRep
@


1.47
log
@Changed name of GlobalComponent classes to GlobalAspect.
@
text
@d66 1
a66 1
//    Element
d80 1
a80 1
//       ElementCOR
@


1.46
log
@Changed name of GlobalElement classes to GlobalComponent.
@
text
@d67 1
a67 1
//       GlobalComponent
d81 1
a81 1
//          GlobalComponentCOR
@


1.45
log
@Changed name of Problem method shutDown to deactivate.
@
text
@d67 1
a67 1
//       GlobalElement
d81 1
a81 1
//          GlobalElementCOR
@


1.44
log
@purgeData
@
text
@d18 1
a18 1
// until it is shut down.
d24 1
a24 1
// * When its shutDown method is called, it enters into its "inactive" state.
d45 1
a45 1
// The shutDown method is responsible for putting the RetainedObject into this
d51 1
a51 1
// that it owns from becoming memory leaks. The shutDown method removes this
d177 1
a177 1
// shutDown ().
d179 1
a179 1
// "shuts down" this RetainedObject, i.e., puts it into an inactive state.
d183 1
a183 1
   void shutDown ()
@


1.43
log
@purgeData
@
text
@d238 1
a238 1
// activeOnly (theArrayList)
d240 2
a241 2
// Creates and returns a copy of theArrayList with all inactive RetainedObjects
// removed.
d246 1
a246 1
         ArrayList <R> activeOnly (ArrayList <R> theArrayList)
d258 8
a265 3
      activeObjects.trimToSize ();

      return activeObjects;
@


1.42
log
@purgeData
@
text
@d97 24
d169 8
@


1.41
log
@Removed the ShipTriple classes.
@
text
@d12 2
d205 51
@


1.40
log
@Replaced the AllocTarget classes with ShipTriple classes.
@
text
@a85 1
//       ShipTripleCOR
@


1.39
log
@Problem.eqHeurAlloc.
@
text
@d86 1
a86 1
//       AllocTargetCOR
@


1.38
log
@Removed the Alternative classes.
@
text
@d36 1
a36 1
// When a RetainedObject is in a inactive state, the following conditions hold:
d86 1
a86 1
//
d196 1
a196 1
               "   A inactive RetainedObject was passed as an argument to\n"
@


1.37
log
@Part.Category as Alternative
@
text
@a76 1
//       AlternativeCOR
@


1.36
log
@Removed java class ElementMgr, moving its responsibilities to class
Coordinator.
@
text
@d73 2
d77 1
a77 1
//       ProblemCOR
@


1.35
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@a63 1
//    ElementMgr
@


1.34
log
@Java ProbMgr
@
text
@d58 1
a58 1
//    ProbMgr
@


1.33
log
@ProbMgr classes.
@
text
@a58 1
//    AttRepMgr
@


1.32
log
@Changed a Java class name: WitjAbortsException ==> TerminalException
@
text
@d58 1
@


1.31
log
@Changed class name: NonFunctionalException ==> WitjAbortsException
@
text
@d34 1
a34 1
// the program aborts with an error message.
d103 1
a103 1
         witjAbortedNotAllowed ("RetainedObject.isActive");
d168 1
a168 1
      witjAbortedNotAllowed (methName);
@


1.30
log
@Minor revision.
@
text
@d103 1
a103 1
         witjMustBeFunctional ("RetainedObject.isActive");
d168 1
a168 1
      witjMustBeFunctional (methName);
@


1.29
log
@Added text to the detail message of StatusQuoExceptions.
@
text
@d56 30
a85 30
//    RetainedObject
//       Problem
//       AttRepMgr
//       AttRep
//          StdAttRep
//          CustAttRep
//             {Anonymous Inner Classes}
//       MessageMgr
//       ElementMgr
//       Element
//          GlobalElement
//          Part
//          Demand
//          Operation
//          BomEntry
//          Substitute
//          BopEntry
//       CppObjRep
//          AttBldrCOR
//          AttCOR
//          ProblemCOR
//          MessageMgrCOR
//          ElementCOR
//             GlobalElementCOR
//             PartCOR
//             DemandCOR
//             OperationCOR
//             BomEntryCOR
//             SubstituteCOR
//             BopEntryCOR
@


1.28
log
@Changed name of class IntactException to StatusQuoException.
@
text
@d171 7
a177 7
         throw new StatusQuoException (
              "\n\n"
            + "   A method that requires an active RetainedObject was called\n"
            + "   with an inactive RetainedObject\n"
            + "\n"
            + "      Method: " + methName + "\n"
            + "      Object: " + this     + "\n");
d194 8
a201 8
         throw new StatusQuoException (
              "\n\n"
            + "   A inactive RetainedObject was passed as an argument to\n"
            + "   a method that requires an active RetainedObject.\n"
            + "\n"
            + "      Method:         " + methName + "\n"
            + "      Argument:       " + argName  + "\n"
            + "      Argument Value: " + this     + "\n");
@


1.27
log
@Removed some internal calls to public methods.
@
text
@d171 1
a171 1
         throw new IntactException (
d194 1
a194 1
         throw new IntactException (
@


1.26
log
@Added the uniform try block whereever it was needed.
@
text
@d180 24
@


1.25
log
@Added a call to witjMustBeFunctional whereever it was needed.
@
text
@d101 11
a111 3
      witjMustBeFunctional ("RetainedObject.isActive");

      return active;
@


1.24
log
@Changed class names:
   HarmlessException ==> IntactException
   UnknownException  ==> UnexpectedException
@
text
@d101 2
d106 4
d153 1
d160 2
@


1.23
log
@Exceptions
@
text
@d154 1
a154 1
         throw new HarmlessException (
@


1.22
log
@Replaced standard Exceptions with HarmlessExceptions in throw statements.
@
text
@a160 1

@


1.21
log
@Exceptions
@
text
@d154 1
a154 1
         throw new IllegalStateException (
@


1.20
log
@Exceptions
@
text
@d156 2
a157 2
            + "   A public method that requires an active RetainedObject\n"
            + "   was called on an inactive RetainedObject\n"
@


1.19
log
@Removed Java class SessionCOR.
@
text
@d154 8
a161 9
         abortWmsg (
            "   A public method that requires an active RetainedObject\n"
          + "   was called with an inactive RetainedObject\n"
          + "\n"
          + "      Method: "
          + methName
          + "\n"
          + "      Object: "
          + this);
@


1.18
log
@Dismantling class SessionCOR.
@
text
@d58 7
a72 6
//       ElementMgr
//       AttRepMgr
//       AttRep
//          StdAttRep
//          CustAttRep
//             {Anonymous Inner Classes}
d74 2
a75 1
//          SessionCOR
d77 1
a85 2
//          AttBldrCOR
//          AttCOR
@


1.17
log
@Removed class Session from the public interface.
@
text
@a56 1
//       Session
@


1.16
log
@Minor revision.
@
text
@d144 1
a144 1
// mustBeActive (theArg, argName)
@


1.15
log
@Replaced theAtt.getIsInputAtt (theProblem) with theAtt.allowsSetValue ().
@
text
@d101 1
a101 1
      return iAmActive;
d112 1
a112 1
      assert (! iAmActive);
d138 1
a138 1
      assert (iAmActive);
d140 1
a140 1
      iAmActive = false;
d153 1
a153 1
      if (! iAmActive)
d170 1
a170 1
// iAmActive.
d175 1
a175 1
   private boolean iAmActive = true;
@


1.14
log
@Name change in class RetainedObject: getActiveState ==> isActive.
@
text
@d101 1
a101 1
      return isActive;
d112 1
a112 1
      assert (! isActive);
d138 1
a138 1
      assert (isActive);
d140 1
a140 1
      isActive = false;
d153 1
a153 1
      if (! isActive)
d170 1
a170 1
// isActive.
d175 1
a175 1
   private boolean isActive = true;
@


1.13
log
@Revised the check for garbage collection of an active object.
@
text
@d30 1
a30 1
// * getActiveState ()
d99 1
a99 1
   public boolean getActiveState ()
d101 1
a101 1
      return myActiveState;
d112 1
a112 1
      assert (! myActiveState);
d138 1
a138 1
      assert (myActiveState);
d140 1
a140 1
      myActiveState = false;
d153 1
a153 1
      if (! myActiveState)
d170 1
a170 1
// myActiveState.
d175 1
a175 1
   private boolean myActiveState = true;
@


1.12
log
@Minor revision.
@
text
@d104 13
@


1.11
log
@Added test for active Session at finalize time.
@
text
@d30 1
a30 1
// * getActiveMode ()
d99 1
a99 1
   public boolean getActiveMode ()
d101 1
a101 1
      return myActiveMode;
d125 1
a125 1
      assert (myActiveMode);
d127 1
a127 1
      myActiveMode = false;
d140 1
a140 1
      if (! myActiveMode)
d157 1
a157 1
// myActiveMode.
d162 1
a162 1
   private boolean myActiveMode = true;
@


1.10
log
@Name change.
@
text
@a104 17
// Protected Methods
//==============================================================================

//------------------------------------------------------------------------------
// finalize ()
//
// Override from class Object.
//------------------------------------------------------------------------------

   protected void finalize () throws Throwable
      {
      super.finalize ();

      assert (! myActiveMode);
      }

//==============================================================================
@


1.9
log
@Changed name of Component to Entity.
@
text
@d59 2
a60 2
//       Entity
//          GlobalEntity
d67 1
a67 1
//       EntityMgr
d76 2
a77 2
//          EntityCOR
//             GlobalEntityCOR
@


1.8
log
@Minor revision.
@
text
@d59 2
a60 2
//       Component
//          GlobalComp
d67 1
a67 1
//       CompMgr
d76 2
a77 2
//          ComponentCOR
//             GlobalCompCOR
@


1.7
log
@Numerous class name changes.
@
text
@d30 1
a30 1
// * isActive ()
d99 1
a99 1
   public boolean isActive ()
d101 1
a101 1
      return iAmActive;
d118 1
a118 1
      assert (! iAmActive);
d142 1
a142 1
      assert (iAmActive);
d144 1
a144 1
      iAmActive = false;
d157 1
a157 1
      if (! iAmActive)
d174 1
a174 1
// iAmActive.
d179 1
a179 1
   private boolean iAmActive = true;
@


1.6
log
@Minor revision.
@
text
@d73 13
a85 13
//       CppInterface
//          SessionCI
//          ProblemCI
//          ComponentCI
//             GlobalCompCI
//             PartCI
//             DemandCI
//             OperationCI
//             BomEntryCI
//             SubstituteCI
//             BopEntryCI
//          AttBldrCI
//          AttCI
@


1.5
log
@Active state / shutDown method.
@
text
@d16 1
a16 1
// until it is explictly shut down.
d30 1
a30 1
// * getActive ()
d34 1
a34 1
// the program aborts with an application program error message.
d99 1
a99 1
   public boolean getActive ()
d101 1
a101 1
      return isActive;
d118 1
a118 1
      assert (! isActive);
d142 1
a142 1
      assert (isActive);
d144 1
a144 1
      isActive = false;
d157 1
a157 1
      if (! isActive)
d174 1
a174 1
// isActive.
d179 1
a179 1
   private boolean isActive = true;
@


1.4
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@d16 1
a16 1
// until it is explictly released.
d18 2
a19 2
// At any point in time, a RetainedObject is in an "unreleased" state or an
// "released" state:
d21 3
a23 3
// * Initially, a RetainedObject is "unreleased" (just after construction).
// * When its release method is called, it enters into its "released" state.
// * From that point, on it remains in its "released" state.
d26 1
a26 1
// called only when the RetainedObject is in an unreleased state. The exceptions
d28 1
a28 1
// whether or not the RetainedObject is released:
d30 1
a30 1
// * getReleased ()
d33 1
a33 1
// If  any other public method is called when the RetainedObject is released,
d36 1
a36 1
// When a RetainedObject is in a released state, the following conditions hold:
d39 2
a40 2
// * All Java objects that it owns are released.
// * There are no references to it from unreleased RetainedObjects.
d43 1
a43 1
// The release method is responsible for putting the RetainedObject into this
d46 1
a46 1
// When a RetainedObject is unreleased, WIT-J maintains a static reference to it
d48 2
a49 2
// collected while it is unreleased, which, in turn, prevents the C++ objects
// that it owns from becoming memory leaks. The release method removes this
d51 1
a51 1
// Thus when a RetainedObject is released and all references to it from the
d99 1
a99 1
   public boolean getReleased ()
d101 1
a101 1
      return isReleased;
d118 1
a118 1
      assert (isReleased);
d134 1
a134 1
// release ().
d136 1
a136 1
// Puts this RetainedObject into an released state.
d140 1
a140 1
   void release ()
d142 1
a142 1
      assert (! isReleased);
d144 1
a144 1
      isReleased = true;
d148 1
a148 1
// mustBeUnreleased (theArg, argName)
d150 1
a150 1
// Verifies that the RetainedObject has not been released.
d155 1
a155 1
   void mustBeUnreleased (String methName)
d157 1
a157 1
      if (isReleased)
d159 2
a160 2
            "   A public method that requires an unreleased RetainedObject\n"
          + "   was called on an released RetainedObject\n"
d174 1
a174 1
// isReleased.
d176 1
a176 1
// True, iff this RetainedObject has been released
d179 1
a179 1
   private boolean isReleased = false;
@


1.3
log
@Removed Java class SessionCI.
Removed C++  class Session.
Kept the empty source files.
@
text
@d74 1
a75 1
//          ProbCoordCI
@


1.2
log
@Initial implementation of the Session classes.
@
text
@a66 1
//       ProbCoord
a73 1
//          SessionCI
@


1.1
log
@Terminology change.
@
text
@d57 1
d75 1
@


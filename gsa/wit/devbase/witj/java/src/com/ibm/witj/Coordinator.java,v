head	1.71;
access;
symbols;
locks; strict;
comment	@# @;


1.71
date	2011.05.02.18.32.22;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.30.16.20.49;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.03.29.23.38.56;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.03.22.22.24.13;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.19.00.26.22;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.02.25.16.07.06;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.09.19.54.32;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.07.22.43.38;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.06.16.38.56;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.05.23.20.12;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.01.15.59.54;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.09.29.20.43.56;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.09.29.19.33.01;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.29.19.09.24;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2009.09.25.23.44.30;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.25.22.42.42;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.25.20.19.34;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.09.25.18.52.37;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.09.25.16.22.05;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.09.18.23.31.38;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.30.21.05.30;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.11.23.00.16;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.11.20.11.48;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.05.17.55.44;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.29.17.59.39;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.26.18.31.44;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.08.22.13.11;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.05.20.17.06;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2009.05.05.18.29.01;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.05.17.56.47;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.04.21.49.57;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.16.21.08.38;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.10.16.16.19;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.30.21.07.31;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.30.20.19.55;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.30.18.15.00;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.19.20.45.27;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.16.19.35.44;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.13.22.30.58;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.13.21.08.58;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.13.19.32.21;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.13.16.36.08;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.12.22.45.19;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.12.19.02.42;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.10.19.08.39;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.10.18.58.10;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.06.23.27.44;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.06.23.23.04;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.05.23.02.43;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.05.21.31.43;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.05.20.49.00;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.05.19.09.18;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.05.17.21.27;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.27.15.41.53;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.26.16.51.28;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.20.17.18.44;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.19.19.51.46;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.18.22.10.22;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.18.17.16.03;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.18.17.00.43;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.14.00.51.30;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.03.16.51.23;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.03.16.32.28;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.31.00.56.26;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.27.19.25.58;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.27.16.56.21;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.23.20.38.22;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.23.19.46.29;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.23.18.46.54;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.22.23.12.41;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.21.21.43.24;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Reduced heading comments.
@
text
@
//==============================================================================
// WIT-J Java Source File Coordinator.java.
//==============================================================================

package       com.ibm.witj;

import static com.ibm.witj.Utility.*;

import       java.util.*;

//==============================================================================
// Class Coordinator
//
// Facilitates interactions between the objects of a Problem.
//
// Class Hierarchy:
//
// PreservedInternal
//    Coordinator
//==============================================================================

final class Coordinator extends PreservedInternal
{
//==============================================================================
// Package Internal Constructor
//==============================================================================

   Coordinator (boolean forSelfTest)
      {
      selfTesting      = forSelfTest;

      myCoordinatorCOR = new CoordinatorCOR ();

      myAttImpArr      = new AttImp[Attribute.getAttributes ().size ()];

      CustAttImp.buildInstances (this);
      StdAttImp .buildInstances (this);

      myMessageMgr     = new MessageMgr (this);

      myComponents     = new ArrayList <Component>  ();

      unmodComponents  = Collections.unmodifiableList (myComponents);

      myConcComps      =
         new EnumMap <CompClassID, ArrayList <? extends Component>> (
            CompClassID.class);

      unmodConcComps   =
         new EnumMap <CompClassID,      List <? extends Component>> (
            CompClassID.class);

      createConcCompList (Problem     .class);
      createConcCompList (Part        .class);
      createConcCompList (Demand      .class);
      createConcCompList (Operation   .class);
      createConcCompList (BomEntry    .class);
      createConcCompList (Substitute  .class);
      createConcCompList (BopEntry    .class);

      myPartMap        = new HashMap <String, Part>      ();
      myOpnMap         = new HashMap <String, Operation> ();

      myProblem        = new Problem (this);

      recordConcComp (myProblem);

      allActiveCoordinators.get ().add (this);
      }

//==============================================================================
// Package-Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// store (theAttImp)
//
// Stores theAttImp in myAttImpArr.
//------------------------------------------------------------------------------

   void store (AttImp theAttImp)
      {
      int theIdx;

      theIdx              = theAttImp.getAttribute ().getIndex ();

      myAttImpArr[theIdx] = theAttImp;
      }

//------------------------------------------------------------------------------
// getAttImpFor (theAtt)
//
// Returns the AttImp that belongs to this Coordinator corresponding to theAtt.
//------------------------------------------------------------------------------

   AttImp getAttImpFor (Attribute <?> theAtt)
      {
      return myAttImpArr[theAtt.getIndex ()];
      }

//------------------------------------------------------------------------------
// recordPart (thePart)
//
// Records the fact that thePart has been created.
//------------------------------------------------------------------------------

   void recordPart (Part thePart)
      {
      recordConcComp (thePart);

      myPartMap.put (thePart.getPartName (), thePart);
      }

//------------------------------------------------------------------------------
// recordOperation (theOpn)
//
// Records the fact that theOpn has been created.
//------------------------------------------------------------------------------

   void recordOperation (Operation theOpn)
      {
      recordConcComp (theOpn);

      myOpnMap.put (theOpn.getOperationName (), theOpn);
      }

//------------------------------------------------------------------------------
// recordConcComp (theConcComp)
//
// Records the fact that theConcComp has been created.
//------------------------------------------------------------------------------

  @@SuppressWarnings ("unchecked")

   <C extends Component> void recordConcComp (C theConcComp)
      {
      ArrayList <C> theConcCompList;

      assert (theConcComp.getCoordinator () == this);

      myComponents.add (theConcComp);

      theConcCompList =
         (ArrayList <C>) myConcComps.get (theConcComp.getCompClassID ());

      theConcCompList.add (theConcComp);

      theConcComp.getComponentCOR ().setComponent (theConcComp);
      }

//------------------------------------------------------------------------------
// getPart (thePartName)
//
// Returns the Part that belongs to this Coordinator whose PartName matches
// thePartName, if any; otherwise null.
//------------------------------------------------------------------------------

   Part getPart (String thePartName)
      {
      return myPartMap.get (thePartName);
      }

//------------------------------------------------------------------------------
// getOperation (theOpnName)
//
// Returns the Operation that belongs to this Coordinator whose OperationName
// matches theOpnName, if any; otherwise null.
//------------------------------------------------------------------------------

   Operation getOperation (String theOpnName)
      {
      return myOpnMap.get (theOpnName);
      }

//------------------------------------------------------------------------------
// selfTest ()
//
// Performs various tests of WIT-J that cannot be done by calling public
// methods.
//------------------------------------------------------------------------------

   static void selfTest ()
      {
      Coordinator theCoord;

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Performing a self-test.\n"
         + "----------------------------------------"
         + "----------------------------------------");

      Attribute.selfTest ();

      theCoord = new Coordinator (true);

      theCoord.selfTestAttImps ();

      theCoord.myProblem.deactivate ();

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Self-test complete.\n"
         + "----------------------------------------"
         + "----------------------------------------");
      }

//------------------------------------------------------------------------------
// restoreAfterPurge ()
//
// Updates the state of WIT-J to match that of WIT just after a call to
// witPurgeData.
//------------------------------------------------------------------------------

   void restoreAfterPurge ()
      {
      for (Component theComp: myComponents)
         if (theComp != myProblem)
            theComp.getComponentCOR ().setWasDeletedInWit (true);

      myCoordinatorCOR.restoreAfterPurge ();

      deactivateComponentsDeletedInWit ();

      PreservedObject.removeInactive (myComponents);

      for (CompClassID theCompClassID: CompClassID.values ())
         {
         PreservedObject.removeInactive (myConcComps.get (theCompClassID));
         }

      myPartMap = PreservedObject.activeOnly (myPartMap);
      myOpnMap  = PreservedObject.activeOnly (myOpnMap);

      for (Component theComp: myComponents)
         {
         theComp.restoreAfterPurge ();
         }
      }

//------------------------------------------------------------------------------
// clearData ()
//
// Restores this Coordinator to its default state.
//------------------------------------------------------------------------------

   void clearData ()
      {
      int       theIdx;
      Component theComp;

      myPartMap = new HashMap <String, Part>      ();
      myOpnMap  = new HashMap <String, Operation> ();

      for (CompClassID theCompClassID: CompClassID.values ())
         if (theCompClassID != CompClassID.PROBLEM)
            {
            myConcComps.get (theCompClassID).clear      ();
            myConcComps.get (theCompClassID).trimToSize ();
            }

      for (theIdx = myComponents.size () - 1; theIdx >= 0; theIdx --)
         {
         theComp = myComponents.get (theIdx);

         if (theComp != myProblem)
            theComp.deactivate ();
         }

      myComponents.clear      ();
      myComponents.add        (myProblem);
      myComponents.trimToSize ();

      myCoordinatorCOR.clearData ();
      }

//------------------------------------------------------------------------------
// hasPartsOrOperations ()
//
// Returns true iff there is at least one Part or Operation in myProblem.
//------------------------------------------------------------------------------

   boolean hasPartsOrOperations ()
      {
      return
            (myConcComps.get (CompClassID.PART)     .size () > 0)
         || (myConcComps.get (CompClassID.OPERATION).size () > 0);
      }

//------------------------------------------------------------------------------
// getInstances (theCompClass, theCompClassID)
//
// Verifies that theCompClass and theCompClassID correspond to the same class.
// Let C be that Component class. Returns an unmodifiable List of all instances
// of class C that belong to this Coordinator, listed in creation order.
//------------------------------------------------------------------------------

  @@SuppressWarnings ("unchecked")

   <C extends Component> List <C> getInstances (
         Class <C>   theCompClass,
         CompClassID theCompClassID)
      {
      assert (theCompClassID.getCompClass () == theCompClass);

      return (List <C>) unmodConcComps.get (theCompClassID);
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   boolean isSelfTesting ()
      {
      return selfTesting;
      }

   CoordinatorCOR getCoordinatorCOR ()
      {
      return myCoordinatorCOR;
      }

   MessageMgr getMessageMgr ()
      {
      return myMessageMgr;
      }

   List <Component> getComponents ()
      {
      return unmodComponents;
      }

   Problem getProblem ()
      {
      return myProblem;
      }

//------------------------------------------------------------------------------
// deactivate ().
//
// Override from class PreservedInternal.
//------------------------------------------------------------------------------

   void deactivate ()
      {
      int       theIdx;
      Component theComp;

      for (theIdx = myComponents.size () - 1; theIdx >= 0; theIdx --)
         {
         theComp = myComponents.get (theIdx);

         if (theComp != myProblem)
            theComp.deactivate ();
         }

      myMessageMgr.deactivate ();

      for (Attribute <?> theAtt: Attribute.getAttributes ())
         {
         getAttImpFor (theAtt).deactivate ();
         }

      myCoordinatorCOR.deactivate ();
      super           .deactivate ();

      assert (allActiveCoordinators.get ().contains (this));

      allActiveCoordinators.get ().remove (this);
      }

//==============================================================================
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// createConcCompList (theClass)
//
// Creates and stores the ArrayList that is to be used as the List of all
// instances of the class represented by theClass that are owned by this
// Coordinator.
// Creates and stores an unmodifiable view of the List.
//------------------------------------------------------------------------------

   private <C extends Component> void createConcCompList (Class <C> theClass)
      {
      CompClassID   theCompClassID;
      ArrayList <C> theConcCompList;
      List <C>      unmodConcCompList;

      theCompClassID    = CompClassID.getInstanceFor (theClass);

      theConcCompList   = new ArrayList <C> ();

      unmodConcCompList = Collections.unmodifiableList (theConcCompList);

      myConcComps   .put (theCompClassID, theConcCompList);
      unmodConcComps.put (theCompClassID, unmodConcCompList);
      }

//------------------------------------------------------------------------------
// deactivateComponentsDeletedInWit ()
//
// Shuts down all Components corresponding to elements in WIT that have been
// deleted by witPurgeData.
//------------------------------------------------------------------------------

   private void deactivateComponentsDeletedInWit ()
      {
      int       theIdx;
      Component theComp;

      for (theIdx = myComponents.size () - 1; theIdx >= 0; theIdx --)
         {
         theComp = myComponents.get (theIdx);

         if (theComp != myProblem)
            if (theComp.getComponentCOR ().wasDeletedInWit ())
               theComp.deactivate ();
         }
      }

//------------------------------------------------------------------------------
// selfTestAttImps ()
//
// Performs a self-test on the AttImps that belong to this Coordinator.
//------------------------------------------------------------------------------

   private void selfTestAttImps ()
      {
      for (Attribute <?> theAtt: Attribute.getAttributes ())
         {
         getAttImpFor (theAtt).verifyIsModifiable ();
         getAttImpFor (theAtt).verifyAppliesTo    ();
         }
      }

//==============================================================================
// Private Fields
//==============================================================================
 
//------------------------------------------------------------------------------
// allActiveCoordinators
//
// allActiveCoordinators.get () is the set of all currently active Coordinators
// that were created in the current thread. Their presence in this Set prevents
// them from being garbage-collected until they are deactivated.
//------------------------------------------------------------------------------

   private
      static final ThreadLocal <HashSet <Coordinator>> allActiveCoordinators;

//------------------------------------------------------------------------------
// selfTesting
//
// True, iff WIT-J is currently performing a self-test.
//------------------------------------------------------------------------------

   private final boolean selfTesting;

//------------------------------------------------------------------------------
// myCoordinatorCOR.
//
// The CoordinatorCOR that belongs to this Coordinator.
//------------------------------------------------------------------------------

   private final CoordinatorCOR myCoordinatorCOR;

//------------------------------------------------------------------------------
// myProblem.
//
// The Problem that owns this Coordinator.
//------------------------------------------------------------------------------

   private final Problem myProblem;

//------------------------------------------------------------------------------
// myAttImpArr
//
// myAttImpArr[theAtt.getIndex ()] is the AttImp that belongs to this
// Coordinator corresponding to theAtt.
//------------------------------------------------------------------------------

   private final AttImp[] myAttImpArr;

//------------------------------------------------------------------------------
// myMessageMgr.
//
// The MessageMgr that belongs to this Problem.
//------------------------------------------------------------------------------

   private final MessageMgr myMessageMgr;

//------------------------------------------------------------------------------
// myComponents.
//
// The list of all Components that belong to this Coordinator.
//------------------------------------------------------------------------------

   private final ArrayList <Component>  myComponents;

//------------------------------------------------------------------------------
// unmodComponents.
//
// Unmodifiable view of myComponents.
//------------------------------------------------------------------------------

   private final List <Component> unmodComponents;

//------------------------------------------------------------------------------
// myConcComps.
// "My Concrete Components"
//
// myConcComps.get (theCompClassID) is a List of all instances of the Class
// corresponding to theCompClassID that belong to this Coordinator, listed in
// creation order.
//------------------------------------------------------------------------------

   private
      final
         EnumMap <CompClassID, ArrayList <? extends Component>> myConcComps;

//------------------------------------------------------------------------------
// unmodConcComps.
//
// "Unmodified Concrete Components"
// unmodConcComps.get (theCompClassID) is an unmodifiable view of
// myConcComps   .get (theCompClassID).
//------------------------------------------------------------------------------

   private
      final
         EnumMap <CompClassID, List <? extends Component>> unmodConcComps;

//------------------------------------------------------------------------------
// myPartMap
// myOpnMap
//
// myPartMap.get (thePartName) is the Part that belongs to this Coordinator
// whose PartName matches thePartName, if any; otherwise null.
//
// myOpnMap.get (theOpnName) is the Operation that belongs to this Coordinator
// whose OperationName matches theOpnName, if any; otherwise null.
//------------------------------------------------------------------------------

   private HashMap <String, Part>      myPartMap = null;
   private HashMap <String, Operation> myOpnMap  = null;

//==============================================================================
// Static initialization block
//==============================================================================

   static
      {
      allActiveCoordinators =
         new ThreadLocal <HashSet <Coordinator>> ()
            {
            protected HashSet <Coordinator> initialValue ()
               {
               return new HashSet <Coordinator> (10);
               }
            };
      }

//==============================================================================
}
@


1.70
log
@Revised CppObjRep class ctors.
@
text
@a3 2
//
// Contains the declaration of class Coordinator.
@


1.69
log
@Replaced C++ class CORJOR with ComponentJOR.
@
text
@d35 1
a35 1
      myCoordinatorCOR = new CoordinatorCOR (this);
@


1.68
log
@Replaced setPipSeq with clearPipSeq and appendToPipSeq.
@
text
@d150 2
@


1.67
log
@Revised the arguments to eqHeurAlloc.
@
text
@a212 50
// checkDemandTriples (theTripleList, theMethName)
//
// Performs error checking for a call to a method whose name is given by
// theMethName, where theTripleList is its argument.
//------------------------------------------------------------------------------

   void checkDemandTriples (
         ArrayList <AllocTriple <Demand>> theTripleList,
         String                           theMethName)
      {
      int                  theIdx;
      AllocTriple <Demand> theTriple;

      mustBeNonNull (theTripleList, "theTripleList", theMethName);

      for (theIdx = 0; theIdx < theTripleList.size (); theIdx ++)
         {
         theTriple = theTripleList.get (theIdx);

         if (theTriple == null)
            throw
               new StatusQuoException (
                  "   In a call to " + theMethName + " (theTripleList),\n"
                + "   theTripleList contained a null reference.\n"
                + "\n"
                + "      List Index: " + theIdx);

         if (! theTriple.getRoot ().isActive ())
            throw
               new StatusQuoException (
                  "   In a call to " + theMethName + " (theTripleList),\n"
                + "   theTripleList contained an AllocTriple <Demand> whose\n"
                + "   Demand was inactive.\n"
                + "\n"
                + "      List Index: " + theIdx);

         if (theTriple.getRoot ().getCoordinator () != this)
            throw
               new StatusQuoException (
                  "   In a call to " + theMethName + " (theTripleList),\n"
                + "   theTripleList contained an AllocTriple <Demand> whose\n"
                + "   Demand does not belong to the Problem for which\n"
                + "   " + theMethName + " was called.\n"
                + "\n"
                + "      List Index: " + theIdx + "\n"
                + "      Demand:     " + theTriple.getRoot ());
         }
      }

//------------------------------------------------------------------------------
@


1.66
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@d232 8
@


1.65
log
@Minor revision.
@
text
@a35 1
      myProblem        = new Problem        (this);
d56 1
a56 1
      createConcCompList (GlobalAspect.class);
d67 1
a67 1
      myGlobalAspect   = new GlobalAspect (this);
d69 1
a69 1
      recordConcComp (myGlobalAspect);
d264 2
a265 3
         {
         theComp.getComponentCOR ().setWasDeletedInWit (true);
         }
d295 2
a296 1
      int theIdx;
d302 1
a302 2
         {
         if (theCompClassID != CompClassID.GLOBAL_ASPECT)
a306 1
         }
d308 1
a308 1
      for (theIdx = myComponents.size () - 1; theIdx >= 1; theIdx --)
d310 4
a313 1
         myComponents.get (theIdx).deactivate ();
d317 1
a317 1
      myComponents.add        (myGlobalAspect);
a319 1
      myGlobalAspect  .clearData ();
a383 5
   GlobalAspect getGlobalAspect ()
      {
      return myGlobalAspect;
      }

d392 2
a393 1
      int theIdx;
d397 4
a400 1
         myComponents.get (theIdx).deactivate ();
d463 3
a465 4
         if (theComp.getComponentCOR ().wasDeletedInWit ())
            {
            theComp.deactivate ();
            }
a581 8
// myGlobalAspect.
//
// The GlobalAspect that belongs to this Coordinator.
//------------------------------------------------------------------------------

   private final GlobalAspect myGlobalAspect;

//------------------------------------------------------------------------------
@


1.64
log
@Removed synchronization of CoordinatorCOR ctor.
@
text
@d439 1
a439 1
      theCompClassID    = CompClassID.getInstance (theClass);
@


1.63
log
@Moved ctor synchronization logic from class Coordinator to class
CoordinatorCOR.
@
text
@d35 2
a36 3
      myCoordinatorCOR = CoordinatorCOR.newInstance (this);

      myProblem        = new Problem (this);
@


1.62
log
@Made calls to CoordinatorCOR ctor synchronized only with the first call.
@
text
@d35 1
a35 1
      myCoordinatorCOR = newCoordinatorCOR ();
a425 29
// newCoordinatorCOR ()
//
// Constructs and returns a new CoordinatorCOR for this Coordinator.
//
// After the CoordinatorCOR ctor has been called for the first time, all
// subsequent calls to it are synchronized with the first call to it, but are
// not synchronized with each other.
//------------------------------------------------------------------------------

   private CoordinatorCOR newCoordinatorCOR ()
      {
      CoordinatorCOR theCoordCOR;

      synchronized (Coordinator.class)
         {
         if (! calledCoordCORCtor)
            {
            theCoordCOR        = new CoordinatorCOR (this);

            calledCoordCORCtor = true;

            return theCoordCOR;
            }
         }

      return new CoordinatorCOR (this);
      }

//------------------------------------------------------------------------------
a492 9
// calledCoordCORCtor
//
// true, iff the CoordinatorCOR ctor has been called at least once in this
// program process.
//------------------------------------------------------------------------------

   private static boolean calledCoordCORCtor = false;

//------------------------------------------------------------------------------
@


1.61
log
@Removed Problem.getActiveProblems ().
@
text
@d35 3
a37 2
      myCoordinatorCOR = new CoordinatorCOR (this);
      myProblem        = new Problem        (this);
d426 29
d522 9
@


1.60
log
@Initial implementation of class ThreadedObject.
@
text
@a79 12
// getActiveCoordinators ()
//
// Returns an unmodifiable view of the Set of all currently active Coordinators
// created in the current Thread.
//------------------------------------------------------------------------------

   static Set <Coordinator> getActiveCoordinators ()
      {
      return Collections.unmodifiableSet (allActiveCoordinators.get ());
      }

//------------------------------------------------------------------------------
@


1.59
log
@Implememented thePreservedObject.getThread ().
@
text
@a34 2
      myThread         = Thread.currentThread ();

a376 5
   Thread getThread ()
      {
      return myThread;
      }

a522 8
// myThread
//
// The Thread in which this Coordinator was created.
//------------------------------------------------------------------------------

   private final Thread myThread;

//------------------------------------------------------------------------------
@


1.58
log
@Implemented class PreservedInternal and made several classes extend it
   instead of class PreservedObject.
@
text
@d379 5
@


1.57
log
@Moved myCoordinator to PreservedObject.
@
text
@d21 1
a21 1
// PreservedObject
d25 1
a25 1
final class Coordinator extends PreservedObject
a32 4
      super (null);

      setCoordinatorToThis ();

d74 1
a74 1
      allActives.get ().add (this);
d82 1
a82 1
// getActives ()
d88 1
a88 1
   static Set <Coordinator> getActives ()
d90 1
a90 1
      return Collections.unmodifiableSet (allActives.get ());
d287 1
a287 1
      removeInactive (myComponents);
d291 1
a291 1
         removeInactive (myConcComps.get (theCompClassID));
d294 2
a295 2
      myPartMap = activeOnly (myPartMap);
      myOpnMap  = activeOnly (myOpnMap);
a338 11
// toStringActive ().
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   String toStringActive ()
      {
      return "Coordinator";
      }

//------------------------------------------------------------------------------
d407 1
a407 1
// Override from class PreservedObject.
d429 1
a429 1
      assert (allActives.get ().contains (this));
d431 1
a431 1
      allActives.get ().remove (this);
d506 1
a506 1
// allActives
d508 3
a510 3
// allActives.get () is the set of all currently active Coordinators that were
// created in the current thread. Their presence in this Set prevents them from
// being garbage-collected until they are deactivated.
d513 2
a514 1
   private static final ThreadLocal <HashSet <Coordinator>> allActives;
d634 1
a634 1
      allActives =
@


1.56
log
@Implemented thePreservedObject.getCoordinator ().
@
text
@d33 4
a419 11
// getCoordinator ()
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   Coordinator getCoordinator ()
      {
      return this;
      }

//------------------------------------------------------------------------------
@


1.55
log
@Moved active Set from class Problem to class Coordinator.
@
text
@d416 11
@


1.54
log
@Made the Coordinator own the Problem.
@
text
@d35 2
d73 2
d82 12
d439 4
d517 10
d535 8
d638 17
a654 1
//------------------------------------------------------------------------------
@


1.53
log
@Added theProblem.myThread.
@
text
@d31 1
a31 1
   Coordinator (Problem theProblem, boolean forSelfTest)
a34 2
      myProblem        = theProblem;

d36 1
d184 1
a184 1
      Problem theProblem;
d196 1
a196 1
      theProblem = Problem.newInstanceForSelfTest ();
d198 1
a198 1
      theProblem.getCoordinator ().selfTestAttImps ();
d200 1
a200 1
      theProblem.deactivate ();
d505 1
a505 1
// myProblem.
d507 1
a507 1
// The Problem that owns this Coordinator.
d510 1
a510 1
   private final Problem myProblem;
d513 1
a513 1
// myCoordinatorCOR.
d515 1
a515 1
// The CoordinatorCOR that belongs to this Coordinator.
d518 1
a518 1
   private final CoordinatorCOR myCoordinatorCOR;
@


1.52
log
@Maded the static field Coordinator.selfTesting non-static.
@
text
@a601 1

@


1.51
log
@Replaced "SubComponent" with "Root".
@
text
@d28 1
a28 1
// Package-Internal Methods
d31 39
a69 5
//------------------------------------------------------------------------------
// newInstance (theProblem)
//
// Constructs and returns a new Coordinator.
//------------------------------------------------------------------------------
d71 1
a71 3
   static Coordinator newInstance (Problem theProblem)
      {
      return new Coordinator (theProblem);
d74 4
a194 2
      iAmSelfTesting = true;

d197 1
a197 1
      theProblem = Problem.newInstance ();
a202 2
      iAmSelfTesting = false;

d370 1
a370 1
   static boolean isSelfTesting ()
d372 1
a372 1
      return iAmSelfTesting;
a426 45
// Private Constructor
//==============================================================================

   private Coordinator (Problem theProblem)
      {
      myProblem        = theProblem;

      myCoordinatorCOR = new CoordinatorCOR (this);

      myAttImpArr      = new AttImp[Attribute.getAttributes ().size ()];

      CustAttImp.buildInstances (this);
      StdAttImp .buildInstances (this);

      myMessageMgr     = new MessageMgr (this);

      myComponents     = new ArrayList <Component>  ();

      unmodComponents  = Collections.unmodifiableList (myComponents);

      myConcComps      =
         new EnumMap <CompClassID, ArrayList <? extends Component>> (
            CompClassID.class);

      unmodConcComps   =
         new EnumMap <CompClassID,      List <? extends Component>> (
            CompClassID.class);

      createConcCompList (GlobalAspect.class);
      createConcCompList (Part        .class);
      createConcCompList (Demand      .class);
      createConcCompList (Operation   .class);
      createConcCompList (BomEntry    .class);
      createConcCompList (Substitute  .class);
      createConcCompList (BopEntry    .class);

      myPartMap        = new HashMap <String, Part>      ();
      myOpnMap         = new HashMap <String, Operation> ();

      myGlobalAspect   = new GlobalAspect (this);

      recordConcComp (myGlobalAspect);
      }

//==============================================================================
d498 1
a498 1
// iAmSelfTesting
d503 1
a503 1
   private static boolean iAmSelfTesting = false;
d602 1
@


1.50
log
@AttID to Attribute.
@
text
@d200 1
a200 1
         if (! theTriple.getSubComponent ().isActive ())
d209 1
a209 1
         if (theTriple.getSubComponent ().getCoordinator () != this)
d218 1
a218 1
                + "      Demand:     " + theTriple.getSubComponent ());
@


1.49
log
@AttID to Attribute.
@
text
@d45 1
a45 1
// Stores theAttImp in myAttImpMap.
d50 1
a50 1
      AttID theAttID;
d52 1
a52 1
      theAttID = theAttImp.getAttribute ().getAttID ();
d54 1
a54 1
      myAttImpMap.put (theAttID, theAttImp);
d65 1
a65 1
      return myAttImpMap.get (theAtt.getAttID ());
d404 1
a404 1
      myAttImpMap      = new EnumMap <AttID, AttImp> (AttID.class);
d499 1
a499 1
      for (AttID theAttID: AttID.values ())
d501 2
a502 2
         myAttImpMap.get (theAttID).verifyIsModifiable ();
         myAttImpMap.get (theAttID).verifyAppliesTo    ();
d535 1
a535 1
// myAttImpMap
d537 2
a538 2
// myAttImpMap.get (theAttID) is the AttImp that belongs to this Coordinator
// corresponding to theAttID.
d541 1
a541 1
   private final Map <AttID, AttImp> myAttImpMap;
@


1.48
log
@Changed getCInstance () to getSubComponent ().
@
text
@d161 1
a161 1
      AttID.selfTest ();
@


1.47
log
@Changed name of clear methods to clearData.
@
text
@d200 1
a200 1
         if (! theTriple.getCInstance ().isActive ())
d209 1
a209 1
         if (theTriple.getCInstance ().getCoordinator () != this)
d218 1
a218 1
                + "      Demand:     " + theTriple.getCInstance ());
@


1.46
log
@Changed names of instances of class C in generic class AllocTriple <C>.
@
text
@d257 1
a257 1
// clear ()
d262 1
a262 1
   void clear ()
d287 2
a288 2
      myGlobalAspect  .clear ();
      myCoordinatorCOR.clear ();
@


1.45
log
@Removed the "enabled" concept from WIT-J.
@
text
@d200 1
a200 1
         if (! theTriple.getC ().isActive ())
d209 1
a209 1
         if (theTriple.getC ().getCoordinator () != this)
d218 1
a218 1
                + "      Demand:     " + theTriple.getC ());
@


1.44
log
@Changed name of Java class RetainedObject to PreservedObject.
@
text
@a68 15
// recordGlobalAspect (theGlobalAspect)
//
// Records the fact that theGlobalAspect has been created.
//------------------------------------------------------------------------------

   void recordGlobalAspect (GlobalAspect theGlobalAspect)
      {
      assert (myGlobalAspect == null);

      recordConcComp (theGlobalAspect);

      myGlobalAspect = theGlobalAspect;
      }

//------------------------------------------------------------------------------
d433 4
d598 1
a598 1
   private GlobalAspect myGlobalAspect = null;
@


1.43
log
@Removed Coordinator.staticInstance
@
text
@d21 1
a21 1
// RetainedObject
d25 1
a25 1
final class Coordinator extends RetainedObject
d309 1
a309 1
// Override from class RetainedObject.
d386 1
a386 1
// Override from class RetainedObject.
@


1.42
log
@Made theAttribute.appliesTo (...) based on data on the Java side.
@
text
@a306 12

   static Coordinator getStaticInstance ()
      {
      if (staticInstance == null)
         {
         staticInstance = Problem.newInstance ().getCoordinator ();
         }

      return staticInstance;
      }

//------------------------------------------------------------------------------
a625 8
// staticInstance
//
// A Coordinator to be used as needed by various static methods.
//------------------------------------------------------------------------------

   private static Coordinator staticInstance = null;

//------------------------------------------------------------------------------
@


1.41
log
@Moved the iAmModifiable field to AttID class.
@
text
@d525 1
@


1.40
log
@theProblem.clear ().
@
text
@d174 1
a174 1
      selfTesting = true;
d180 2
d184 1
a184 1
      selfTesting = false;
d367 1
a367 1
      return selfTesting;
d514 14
d533 1
a533 1
// selfTesting
d538 1
a538 1
   private static boolean selfTesting = false;
@


1.39
log
@Minor revisions.
@
text
@d110 1
a110 1
// recordConcComp (theC)
d112 1
a112 1
// Records the fact that theC has been created.
d117 1
a117 1
   <C extends Component> void recordConcComp (C theC)
d121 1
a121 1
      assert (theC.getCoordinator () == this);
d123 1
a123 1
      myComponents.add (theC);
d126 1
a126 1
         (ArrayList <C>) myConcComps.get (theC.getCompClassID ());
d128 1
a128 1
      theConcCompList.add (theC);
d270 35
a407 7
      for (CompClassID theCompClassID: CompClassID.values ())
         {
         myConcComps.get (theCompClassID).clear ();
         }

      myComponents .clear ();

@


1.38
log
@Changed names of AttRep classes to AttImp.
@
text
@d78 1
a78 1
      record (theGlobalAspect);
d91 1
a91 1
      record (thePart);
d104 1
a104 1
      record (theOpn);
d110 1
a110 1
// record (theC)
d117 1
a117 1
   <C extends Component> void record (C theC)
d119 1
a119 1
      ArrayList <C> theArrayList;
d125 2
a126 1
      theArrayList = (ArrayList <C>) myConcComps.get (theC.getCompClassID ());
d128 1
a128 1
      theArrayList.add (theC);
@


1.37
log
@Replaced theProblem.getInstances (theClass) with theProblem.GetParts (),
etc.
@
text
@d43 1
a43 1
// store (theAttRep)
d45 1
a45 1
// Stores theAttRep in myAttRepMap.
d48 1
a48 1
   void store (AttRep theAttRep)
d52 1
a52 1
      theAttID = theAttRep.getAttribute ().getAttID ();
d54 1
a54 1
      myAttRepMap.put (theAttID, theAttRep);
d58 1
a58 1
// getAttRepFor (theAtt)
d60 1
a60 1
// Returns the AttRep that belongs to this Coordinator corresponding to theAtt.
d63 1
a63 1
   AttRep getAttRepFor (Attribute <?> theAtt)
d65 1
a65 1
      return myAttRepMap.get (theAtt.getAttID ());
d383 1
a383 1
         getAttRepFor (theAtt).deactivate ();
d400 1
a400 1
      myAttRepMap      = new EnumMap <AttID, AttRep> (AttID.class);
d402 2
a403 2
      CustAttRep.buildInstances (this);
      StdAttRep .buildInstances (this);
d512 1
a512 1
// myAttRepMap
d514 1
a514 1
// myAttRepMap.get (theAttID) is the AttRep that belongs to this Coordinator
d518 1
a518 1
   private final Map <AttID, AttRep> myAttRepMap;
@


1.36
log
@Revised theProblem.getComponents ().
@
text
@d125 1
a125 1
      theArrayList = (ArrayList <C>) mySubComps.get (theC.getCompClassID ());
d256 1
a256 1
         removeInactive (mySubComps.get (theCompClassID));
d300 2
a301 2
            (getInstances (Part     .class).size () > 0)
         || (getInstances (Operation.class).size () > 0);
d305 1
a305 1
// getInstances (theCompClass)
d307 3
a309 3
// Returns an unmodifiable List of all instances of the Component class
// represented by theCompClass that belong to this Coordinator, listed in
// creation order.
d314 3
a316 1
   <C extends Component> List <C> getInstances (Class <C> theCompClass)
d318 1
a318 6
      CompClassID theCompClassID;

      if (theCompClass == Component.class)
         {
         return (List <C>) unmodComponents;
         }
d320 1
a320 3
      theCompClassID = CompClassID.getInstance (theCompClass);

      return (List <C>) unmodSubComps.get (theCompClassID);
d342 5
d374 1
a374 1
         mySubComps.get (theCompClassID).clear ();
d411 1
a411 1
      mySubComps       =
d415 1
a415 1
      unmodSubComps    =
d419 7
a425 7
      createSubCompList (GlobalAspect.class);
      createSubCompList (Part        .class);
      createSubCompList (Demand      .class);
      createSubCompList (Operation   .class);
      createSubCompList (BomEntry    .class);
      createSubCompList (Substitute  .class);
      createSubCompList (BopEntry    .class);
d436 1
a436 1
// createSubCompList (theClass)
d444 1
a444 1
   private <C extends Component> void createSubCompList (Class <C> theClass)
d447 2
a448 2
      ArrayList <C> theSubCompList;
      List <C>      unmodSubCompList;
d450 1
a450 1
      theCompClassID   = CompClassID.getInstance (theClass);
d452 1
a452 1
      theSubCompList   = new ArrayList <C> ();
d454 1
a454 1
      unmodSubCompList = Collections.unmodifiableList (theSubCompList);
d456 2
a457 2
      mySubComps   .put (theCompClassID, theSubCompList);
      unmodSubComps.put (theCompClassID, unmodSubCompList);
d545 2
a546 1
// mySubComps.
d548 1
a548 1
// mySubComps.get (theCompClassID) is a List of all instances of the Class
d555 1
a555 1
         EnumMap <CompClassID, ArrayList <? extends Component>> mySubComps;
d558 1
a558 1
// unmodSubComps.
d560 3
a562 2
// unmodSubComps.get (theCompClassID) is an unmodifiable view of
// mySubComps   .get (theCompClassID).
d567 1
a567 1
         EnumMap <CompClassID, List <? extends Component>> unmodSubComps;
@


1.35
log
@Implemented theProblem.getInstances (theCompClass).
@
text
@d320 1
a320 1
         return (List <C>) myComponents;
a351 5
   List <Component> getComponents ()
      {
      return unmodComponents;
      }

@


1.34
log
@Replaced Attribute.getAllAttributes () with Attribute.getAttributes (),
which returns an unmodifiable List.
@
text
@d69 1
a69 1
// record (theComp)
d71 1
a71 1
// Records the fact that theComp has been created.
d74 1
a74 1
   void record (Component theComp)
d76 3
a78 1
      assert (theComp.getCoordinator () == this);
d80 1
a80 1
      myComponents.add (theComp);
d84 1
a84 1
// record (theGlobalAspect)
d86 1
a86 1
// Records the fact that theGlobalAspect has been created.
d89 1
a89 1
   void record (GlobalAspect theGlobalAspect)
d91 1
a91 1
      assert (theGlobalAspect.getCoordinator () == this);
d93 1
a93 3
      assert (myGlobalAspect == null);

      myGlobalAspect = theGlobalAspect;
d97 1
a97 1
// record (thePart)
d99 1
a99 1
// Records the fact that thePart has been created.
d102 1
a102 1
   void record (Part thePart)
d104 1
a104 1
      assert (thePart.getCoordinator () == this);
d106 1
a106 1
      myPartMap.put (thePart.getPartName (), thePart);
d110 1
a110 1
// record (theOpn)
d112 1
a112 1
// Records the fact that theOpn has been created.
d115 3
a117 1
   void record (Operation theOpn)
d119 7
a125 1
      assert (theOpn.getCoordinator () == this);
d127 1
a127 1
      myOpnMap.put (theOpn.getOperationName (), theOpn);
d254 5
d292 37
d377 6
a382 1
      myComponents.clear ();
d412 1
a412 1
      myComponents     = new ArrayList <Component> ();
d416 16
d441 25
d539 1
a539 1
   private final ArrayList <Component> myComponents;
d550 23
d582 1
a585 6
//------------------------------------------------------------------------------

   private HashMap <String, Part> myPartMap = null;

//------------------------------------------------------------------------------
// myOpnMap
d591 2
a592 1
   private HashMap <String, Operation> myOpnMap = null;
@


1.33
log
@Changed the following methods to return an unmodifiable List:

   thePart     .getDemands     ()
   thePart     .getBomEntries  ()
   thePart     .getSubstitutes ()
   thePart     .getBopEntries  ()
   theOperation.getBomEntries  ()
   theOperation.getBopEntries  ()
   theBomEntry .getSubstitutes ()
@
text
@d331 1
a331 1
      for (Attribute <?> theAtt: Attribute.getAllAttributes ())
@


1.32
log
@Changed theProblem.getComponents () to return an unmodifiable view.
@
text
@d304 1
a304 1
      return viewedComponents;
d359 1
a359 1
      viewedComponents = Collections.unmodifiableList (myComponents);
d446 1
a446 1
// viewedComponents.
d451 1
a451 1
   private final List <Component> viewedComponents;
@


1.31
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@a122 11
// hasPartsOpns ()
//
// Returns true, iff this Coordinator owns at least one Part or Operation.
//------------------------------------------------------------------------------

   boolean hasPartsOpns ()
      {
      return (myComponents.size () > 1);
      }

//------------------------------------------------------------------------------
d302 1
a302 1
   Component[] getComponents ()
d304 1
a304 1
      return myComponents.toArray (new Component[0]);
d359 2
d446 8
@


1.30
log
@Changed name of GlobalComponent classes to GlobalAspect.
@
text
@d69 1
a69 1
// record (theElement)
d71 1
a71 1
// Records the fact that theElement has been created.
d74 1
a74 1
   void record (Element theElement)
d76 1
a76 1
      assert (theElement.getCoordinator () == this);
d78 1
a78 1
      myElements.add (theElement);
d130 1
a130 1
      return (myElements.size () > 1);
d215 1
a215 1
         if (! theTriple.getE ().isActive ())
d224 1
a224 1
         if (theTriple.getE ().getCoordinator () != this)
d233 1
a233 1
                + "      Demand:     " + theTriple.getE ());
d246 4
a249 4
      for (Element theElement: myElements)
         theElement.
            getElementCOR ().
               setWasDeletedInWit (true);
d253 1
a253 1
      deactivateElementsDeletedInWit ();
d255 1
a255 1
      removeInactive (myElements);
d257 2
a258 2
      myPartMap  = activeOnly (myPartMap);
      myOpnMap   = activeOnly (myOpnMap);
d260 4
a263 3
      for (Element theElement: myElements)
         theElement.
            restoreAfterPurge ();
d313 1
a313 1
   Element[] getElements ()
d315 1
a315 1
      return myElements.toArray (new Element[0]);
d333 1
a333 1
      for (theIdx = myElements.size () - 1; theIdx >= 0; theIdx --)
d335 1
a335 1
         myElements.get (theIdx).deactivate ();
d338 1
a338 1
      myElements.clear ();
d368 1
a368 1
      myElements       = new ArrayList <Element> ();
d379 1
a379 1
// deactivateElementsDeletedInWit ()
d381 1
a381 1
// Shuts down all Elements corresponding to elements in WIT that have been
d385 1
a385 1
   private void deactivateElementsDeletedInWit ()
d387 2
a388 2
      int     theIdx;
      Element theElement;
d390 1
a390 1
      for (theIdx = myElements.size () - 1; theIdx >= 0; theIdx --)
d392 1
a392 1
         theElement = myElements.get (theIdx);
d394 4
a397 2
         if (theElement.getElementCOR ().wasDeletedInWit ())
            theElement.deactivate ();
d447 1
a447 1
// myElements.
d449 1
a449 1
// The list of all Elements that belong to this Coordinator.
d452 1
a452 1
   private final ArrayList <Element> myElements;
@


1.29
log
@Changed name of GlobalElement classes to GlobalComponent.
@
text
@d82 1
a82 1
// record (theGlobalComp)
d84 1
a84 1
// Records the fact that theGlobalComp has been created.
d87 1
a87 1
   void record (GlobalComponent theGlobalComp)
d89 1
a89 1
      assert (theGlobalComp.getCoordinator () == this);
d91 1
a91 1
      assert (myGlobalComponent == null);
d93 1
a93 1
      myGlobalComponent = theGlobalComp;
d317 1
a317 1
   GlobalComponent getGlobalComponent ()
d319 1
a319 1
      return myGlobalComponent;
d452 1
a452 1
// myGlobalComponent.
d454 1
a454 1
// The GlobalComponent that belongs to this Coordinator.
d457 1
a457 1
   private GlobalComponent myGlobalComponent = null;
@


1.28
log
@Changed name of Problem method shutDown to deactivate.
@
text
@d82 1
a82 1
// record (theGlobalElement)
d84 1
a84 1
// Records the fact that theGlobalElement has been created.
d87 1
a87 1
   void record (GlobalElement theGlobalElement)
d89 1
a89 1
      assert (theGlobalElement.getCoordinator () == this);
d91 1
a91 1
      assert (myGlobalElement == null);
d93 1
a93 1
      myGlobalElement = theGlobalElement;
d317 1
a317 1
   GlobalElement getGlobalElement ()
d319 1
a319 1
      return myGlobalElement;
d452 1
a452 1
// myGlobalElement.
d454 1
a454 1
// The GlobalElement that belongs to this Coordinator.
d457 1
a457 1
   private GlobalElement myGlobalElement = null;
@


1.27
log
@purgeData
@
text
@d182 1
a182 1
      theProblem.shutDown ();
d253 1
a253 1
      shutDownElementsDeletedInWit ();
d323 1
a323 1
// shutDown ().
d328 1
a328 1
   void shutDown ()
d334 1
a334 1
         myElements.get (theIdx).shutDown ();
d339 1
a339 1
      myMessageMgr.shutDown ();
d343 1
a343 1
         getAttRepFor (theAtt).shutDown ();
d346 2
a347 2
      myCoordinatorCOR.shutDown ();
      super           .shutDown ();
d378 1
a378 1
// shutDownElementsDeletedInWit ()
d384 1
a384 1
   private void shutDownElementsDeletedInWit ()
d394 1
a394 1
            theElement.shutDown ();
@


1.26
log
@purgeData
@
text
@d449 1
a449 1
   private ArrayList <Element> myElements = null;
@


1.25
log
@purgeData
@
text
@d255 2
a256 1
      myElements = activeOnly (myElements);
@


1.24
log
@purgeData
@
text
@d222 1
a222 2
                + "      List Index: " + theIdx + "\n"
                + "      Demand:     " + theTriple.getE ());
@


1.23
log
@purgeData
@
text
@d278 11
@


1.22
log
@purgeData
@
text
@a242 2
//
// Implementation in progress.
a262 4

      throw new AssertionError (
         "\n\n"
       + "   The purgeData method is not yet available.\n");
@


1.21
log
@purgeData
@
text
@d258 7
a264 3
      myElements = RetainedObject.activeOnly (myElements);
      myPartMap  = RetainedObject.activeOnly (myPartMap);
      myOpnMap   = RetainedObject.activeOnly (myOpnMap);
@


1.20
log
@purgeData
@
text
@a256 1
      unlistInactiveElements       ();
d258 3
a260 2
      myPartMap = removeInactiveElements (myPartMap);
      myOpnMap  = removeInactiveElements (myOpnMap);
a388 55
//------------------------------------------------------------------------------
// unlistInactiveElements ()
//
// Removes all inactive Elements from myElements.
//------------------------------------------------------------------------------

   private void unlistInactiveElements ()
      {
      ArrayList <Element> activeElems;

      activeElems = new ArrayList <Element> (myElements.size ());

      for (Element theElement: myElements)
         {
         if (theElement.isActive ())
            activeElems.add (theElement);
         }

      activeElems.trimToSize ();

      myElements.clear          ();
      myElements.trimToSize     ();
      myElements.ensureCapacity (activeElems.size ());

      for (Element theElement: activeElems)
         {
         myElements.add (theElement);
         }
      }

//------------------------------------------------------------------------------
// removeInactiveElements (theHashMap)
//
// Removes all inactive Elements from theHashMap.
// Returns a rehashed copy of theHashMap.
//------------------------------------------------------------------------------

   private <E extends Element> HashMap <String, E> removeInactiveElements (
         HashMap <String, E> theHashMap)
      {
      List <String> theKeys;

      theKeys = new ArrayList <String> (theHashMap.keySet ());

      for (String theKey: theKeys)
         {
         if (! theHashMap.get (theKey).isActive ())
            {
            theHashMap.remove (theKey);
            }
         }

      return new HashMap <String, E> (theHashMap);
      }

d440 1
a440 1
   private final ArrayList <Element> myElements;
@


1.19
log
@purgeData
@
text
@d239 4
a242 1
// purgeData ()
a243 2
// Invokes WIT's witPurgeData function and then updates the state of WIT-J to
// match that of the purged WitRun.
d247 1
a247 1
   void purgeData ()
d250 3
a252 5
         {
         theElement.getElementCOR ().setWasDeletedInWit (true);
         }

      myGlobalElement.getGlobalElementCOR ().setWasDeletedInWit (false);
d254 1
a254 1
      myCoordinatorCOR.purgeData ();
@


1.18
log
@purgeData
@
text
@d241 2
a242 2
// Invokes WIT's witPurgeData and then updates the state of WIT-J to match that
// of the purged WitRun.
d250 1
a250 1
         theElement.setToBeShutDown (true);
d253 2
d257 6
d366 80
d496 1
a496 1
   private final List <Element> myElements;
d513 1
a513 1
   private final Map <String, Part> myPartMap;
d522 1
a522 1
   private final Map <String, Operation> myOpnMap;
@


1.17
log
@PurgeData
@
text
@d241 3
a243 2
// Invokes WIT's witPurgeData and then updates the state of WIT-J to match the
// purged WitRun.
d253 2
@


1.16
log
@Added the AllocTripleList classes.
@
text
@d239 19
@


1.15
log
@Moved set/get-PipSeq from class Problem to class GlobalElement.
@
text
@d196 1
a196 1
// checkDemandTriples (theTriples, theMethName)
d199 1
a199 1
// theMethName, where theTriples is its argument.
d203 1
a203 1
         ArrayList <AllocTriple <Demand>> theTriples,
d209 1
a209 1
      mustBeNonNull (theTriples, "theTriples", theMethName);
d211 1
a211 1
      for (theIdx = 0; theIdx < theTriples.size (); theIdx ++)
d213 1
a213 1
         theTriple = theTriples.get (theIdx);
d218 2
a219 2
                  "   In a call to " + theMethName + " (theTriples),\n"
                + "   theTriples contained an AllocTriple <Demand> whose\n"
d228 2
a229 2
                  "   In a call to " + theMethName + " (theTriples),\n"
                + "   theTriples contained an AllocTriple <Demand> whose\n"
a238 73
// holdAllocTripleList (theTripleList, theElementClass)
//
// Causes this Coordinator to hold theTripleList as its current List of
// AllocTriples, where theElementClass is the underlying Element class.
// Verifies that this Coordinator is not currently holding a List of
// AllocTriples.
//------------------------------------------------------------------------------

  @@SuppressWarnings ("unchecked")

   <E extends Element> void holdAllocTripleList (
         ArrayList <AllocTriple <E>> theTripleList,
         Class <E>                   theElementClass)
      {
      assert (myAllocTripleList == null);

      myAllocTripleList    =
         (ArrayList <AllocTriple <Element>>) (ArrayList <?>) theTripleList;

      myTripleElementClass = theElementClass;
      }

//------------------------------------------------------------------------------
// releaseAllocTripleList ()
//
// Causes this Coordinator to cease holding a List of AllocTriples.
// Verifies that this Coordinator is currently holding a List of AllocTriples,
//------------------------------------------------------------------------------

   void releaseAllocTripleList ()
      {
      assert (myAllocTripleList != null);

      myTripleElementClass = null;
      myAllocTripleList    = null;
      }

//------------------------------------------------------------------------------
// prepAllocTripleList (nTriples)
//
// Clears the current List of AllocTriples held by this Coordinator and
// increases its capacity to nTriples.
//------------------------------------------------------------------------------

   void prepAllocTripleList (int nTriples)
      {
      myAllocTripleList.ensureCapacity (nTriples);
      myAllocTripleList.clear          ();
      }

//------------------------------------------------------------------------------
// addAllocTriple (theElement, thePeriod, theVolume)
//
// Creates a new AllocTriple from the arguments and adds it to the current List
// of AllocTriples held by this Coordinator.
// Verifies that theElement belongs to this Coordinator and is an instance of
// the Element class required by the current List of AllocTriples.
//------------------------------------------------------------------------------

   void addAllocTriple (Element theElement, int thePeriod, double theVolume)
      {
      AllocTriple <Element> theTriple;

      assert (theElement.getCoordinator () == this);
                                                             
      assert (myTripleElementClass.isInstance (theElement));

      theTriple = AllocTriple.newInstance (theElement, thePeriod, theVolume);

      myAllocTripleList.add (theTriple);
      }

//------------------------------------------------------------------------------
a414 18
// myAllocTripleList
//
// The current List of AllocTriples held by this Coordinator, if any;
// otherwise null.
//------------------------------------------------------------------------------

   private ArrayList <AllocTriple <Element>> myAllocTripleList = null;

//------------------------------------------------------------------------------
// myTripleElementClass
//
// The underlying Element class for the current List of AllocTriples held by
// this Coordinator, if any; otherwise null.
//------------------------------------------------------------------------------

   private Class <? extends Element> myTripleElementClass = null;

//------------------------------------------------------------------------------
@


1.14
log
@PIP
@
text
@d196 43
@


1.13
log
@Revised some comments.
@
text
@d234 1
a234 1
// storeAllocTriples (theElementCORArr, thePeriodArr, theVolumeArr)
d236 3
a238 16
// Loads the AllocTriples corrsponding to the arguments into the current List of
// AllocTriples held by this Coordinator.
// Verifies that this Coordinator is currently holding a List of AllocTriples,
// Verifies that the Elements listed in theElementCORArr are instances of the
// Element class required by the current List of AllocTriples.
//------------------------------------------------------------------------------

   void storeAllocTriples (
         ElementCOR[] theElementCORArr,
         int[]        thePeriodArr,
         double[]     theVolumeArr)
      {
      int                   nTriples;
      int                   theIdx;
      Element               theElement;
      AllocTriple <Element> theTriple;
d240 5
a244 1
      assert (myAllocTripleList != null);
d246 8
a253 1
      nTriples = theElementCORArr.length;
d255 3
a257 9
      assert (thePeriodArr.length == nTriples);
      assert (theVolumeArr.length == nTriples);

      myAllocTripleList.clear          ();
      myAllocTripleList.ensureCapacity (nTriples);

      for (theIdx = 0; theIdx < nTriples; theIdx ++)
         {
         theElement = theElementCORArr[theIdx].getElement ();
d259 1
a259 1
         assert (theElement.getCoordinator () == this);
d261 1
a261 1
         assert (myTripleElementClass.isInstance (theElement));
d263 1
a263 6
         theTriple =
            AllocTriple.
               newInstance (
                  theElement,
                  thePeriodArr[theIdx],
                  theVolumeArr[theIdx]);
d265 1
a265 2
         myAllocTripleList.add (theTriple);
         }
@


1.12
log
@PIP
@
text
@d200 2
a201 1
// This Coordinator must not already be holding a List of AllocTriples,
d222 1
a222 1
// This Coordinator must currently be holding a List of AllocTriples,
d238 3
a240 1
// This Coordinator must currently be holding a List of AllocTriples,
@


1.11
log
@Implemented getPipSeq.
@
text
@d196 37
d235 3
a237 1
// Sets this Coordinator's AllocTriple List to match the arguments.
d245 4
a248 4
      int                             nTriples;
      int                             theIdx;
      Element                         theElement;
      AllocTriple <? extends Element> theTriple;
d250 1
a250 1
      assert (myAllocTriples.isEmpty ());
d257 2
a258 1
      myAllocTriples.ensureCapacity (nTriples);
d266 2
d269 5
a273 2
            theElement.
               newAllocTriple (thePeriodArr[theIdx], theVolumeArr[theIdx]);
d275 1
a275 1
         myAllocTriples.add (theTriple);
a279 29
// acquireAllocTriples (theTriples, theElementClass)
//
// Takes the AllocTriples of this Coordinator's AllocTriple List and stores them
// in theTriples (in order), removing them from this Coordinator's List.
// The AllocTriples are safely cast to type AllocTriple <E>, where E is
// represented by theElementClass.
//------------------------------------------------------------------------------

   <E extends Element> void acquireAllocTriples (
         ArrayList <AllocTriple <E>> theTriples,
         Class <E>                   theElementClass)
      {
      AllocTriple <E> theTypedTriple;

      theTriples.clear ();

      myAllocTriples.ensureCapacity (myAllocTriples.size ());

      for (AllocTriple <? extends Element> theUntypedTriple: myAllocTriples)
         {
         theTypedTriple = theUntypedTriple.asAllocTripleOf (theElementClass);

         theTriples.add (theTypedTriple);
         }

      myAllocTriples.clear ();
      }

//------------------------------------------------------------------------------
a373 2

      myAllocTriples   = new ArrayList <AllocTriple <? extends Element>> (0);
d456 10
a465 1
// myAllocTriples
d467 2
a468 1
// The AllocTriple List owned by this Coordinator.
d471 1
a471 1
   private ArrayList <AllocTriple <? extends Element>> myAllocTriples;
@


1.10
log
@Simplified the static instance logic.
@
text
@d196 68
d358 2
d442 8
@


1.9
log
@Removed the Alternative classes.
@
text
@a38 3
      if (! creatingStaticInstance)
         getStaticInstance ();

d201 1
a201 5
         creatingStaticInstance = true;

         staticInstance         = Problem.newInstance ().getCoordinator ();

         creatingStaticInstance = false;
d277 1
a277 1
      myCoordinatorCOR = new CoordinatorCOR (this, creatingStaticInstance);
a379 8
// creatingStaticInstance
//
// True, iff staticInstance is currently being constructed.
//------------------------------------------------------------------------------

   private static boolean creatingStaticInstance = false;

//------------------------------------------------------------------------------
@


1.8
log
@Part.Category as Alternative
@
text
@a207 2
         Part.Category.setUp ();

@


1.7
log
@Self-Test.
@
text
@d28 1
a28 1
// Package-Internal Constructor
d31 7
a37 1
   Coordinator (Problem theProblem)
d39 2
a40 12
      myProblem        = theProblem;

      myCoordinatorCOR = new CoordinatorCOR (this);

      myAttRepMap      = new EnumMap <AttID, AttRep> (AttID.class);

      CustAttRep.buildInstances (this);
      StdAttRep .buildInstances (this);

      myMessageMgr     = new MessageMgr (this);

      myElements       = new ArrayList <Element> ();
d42 1
a42 2
      myPartMap        = new HashMap <String, Part>      ();
      myOpnMap         = new HashMap <String, Operation> ();
a44 4
//==============================================================================
// Package-Internal Methods
//==============================================================================

d203 9
a211 1
         staticInstance = Problem.newInstance ().getCoordinator ();
d279 23
d389 8
@


1.6
log
@Coordinator
@
text
@d31 1
a31 1
   Coordinator (Problem theProblem, boolean forSelfTest)
a32 2
      selfTesting      = forSelfTest;

d176 1
a176 1
   void selfTest ()
d188 2
d192 1
a192 1
      theProblem = new Problem (true);
d194 1
a194 1
      theProblem.enable ();
d196 1
a196 1
      theProblem.shutDown ();
d221 1
a221 1
   boolean isSelfTesting ()
d286 1
a286 1
// True, iff this Coordinator is currently performing a self-test.
d289 1
a289 1
   private final boolean selfTesting;
@


1.5
log
@Coordinator
@
text
@d208 10
d359 8
@


1.4
log
@Coordinator
@
text
@d31 1
a31 1
   Coordinator (Problem theProblem)
d33 2
d44 1
a44 1
      myMessageMgr = new MessageMgr (this);
d46 1
a46 1
      myElements   = new ArrayList <Element> ();
d48 2
a49 2
      myPartMap    = new HashMap <String, Part>      ();
      myOpnMap     = new HashMap <String, Operation> ();
d172 36
d211 5
d274 8
@


1.3
log
@Coordinator
@
text
@d42 1
a42 1
      myElements = new ArrayList <Element> ();
d44 4
a47 2
      myPartMap  = new HashMap <String, Part>      ();
      myOpnMap   = new HashMap <String, Operation> ();
d178 5
d215 2
d256 8
@


1.2
log
@Removed java class ElementMgr, moving its responsibilities to class
Coordinator.
@
text
@d35 1
a35 1
      myCoordinatorCOR = new CoordinatorCOR ();
@


1.1
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@d41 5
d79 89
d181 10
d199 9
d247 34
@


head	1.112;
access;
symbols;
locks; strict;
comment	@# @;


1.112
date	2011.05.02.18.32.28;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.06.23.29.31;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2011.03.30.16.20.52;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2011.03.29.23.38.57;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2009.09.30.18.44.12;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2009.09.29.20.43.57;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.17.21.46.46;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2009.05.13.19.15.30;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2009.05.12.22.11.31;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2009.05.12.19.29.51;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.12.15.57.58;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.08.22.13.12;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.05.20.17.07;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2009.04.17.19.51.59;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2009.04.17.15.38.24;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2009.04.10.16.16.20;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2009.03.30.20.19.55;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2009.03.20.19.47.00;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.20.16.08.10;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.19.20.45.27;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.16.19.35.45;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.13.22.30.59;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.13.19.32.22;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.12.19.02.42;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.10.19.08.39;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.10.18.58.10;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.06.23.23.05;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.05.21.31.44;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.05.17.21.27;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.24.17.44.57;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.21.01.00.57;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2009.02.03.23.18.08;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2009.02.03.16.32.28;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2009.01.31.00.56.27;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.23.19.32.25;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.23.18.46.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.22.23.12.42;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2008.12.16.23.43.04;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2008.12.16.16.13.30;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.12.15.15.35.34;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.12.11.15.37.40;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2008.12.10.20.54.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2008.12.03.18.55.08;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.25.15.28.48;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.12.20.40.33;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.14.22.17.46;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.14.20.05.46;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2008.10.11.00.10.38;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2008.10.10.22.25.15;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.09.21.20.22;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.07.18.50.27;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.10.06.22.14.06;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.30.15.17.42;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2008.09.29.22.43.48;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2008.09.26.22.21.26;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.09.19.15.11.14;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.09.18.18.18.53;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.18.18.10.16;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.18.17.41.45;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.18.16.25.36;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.18.16.01.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.17.21.01.37;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.12.16.09.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.12.14.43.24;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.11.19.10.25;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.09.19.00.00;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.09.16.27.06;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.09.15.15.30;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.08.19.45.36;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.05.22.06.51;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.09.05.15.53.04;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.03.20.18.07;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.03.18.03.08;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.29.15.07.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.29.14.22.01;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.19.22.14.33;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.08.18.22.16.58;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.01.21.18.08;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.30.22.02.11;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.30.19.56.04;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.26.19.48.04;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.26.19.18.08;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.25.21.43.51;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.25.14.46.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.24.18.18.47;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.24.15.39.28;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.24.14.29.08;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.19.22.16.55;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.19.15.05.16;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.19.13.36.45;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.18.14.06.24;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.17.18.58.40;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.17.18.41.31;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.17.16.19.46;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.17.16.09.56;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.16.20.41.02;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.13.22.42.17;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.13.18.09.32;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.13.15.57.10;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.12.21.16.40;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.12.15.37.20;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.12.14.54.24;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.29.22.03.31;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.29.20.53.57;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.27.14.57.44;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.23.15.14.09;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.22.21.02.59;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.19.19.04.43;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.16.14.37.27;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.15.19.45.19;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.21.06.37;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.112
log
@Reduced heading comments.
@
text
@
//==============================================================================
// WIT-J Java Source File Part.java.
//==============================================================================

package       com.ibm.witj;

import static com.ibm.witj.Utility.*;

import           java.util.*;

//==============================================================================
// Class Part
//
// Represents a part in an implosion problem.
//
// Class Hierarchy:
//
// ThreadedObject
//    PreservedObject
//       Component
//          Part
//==============================================================================

public final class Part extends Component
{
//==============================================================================
// Public Static Nested Enum Category
//
// Indicates the part category of a part.
//==============================================================================

   public static enum Category
   {
      MATERIAL,
      CAPACITY,
   }

//==============================================================================
// Public Methods
//==============================================================================

//------------------------------------------------------------------------------
// newInstance (theProblem, thePartName, theCategory)
//
// Factory method: Constructs and returns a new Part for the arguments.
//------------------------------------------------------------------------------

   public static Part newInstance (
         Problem  theProblem,
         String   thePartName,
         Category theCategory)
      {
      try
         {
         notAllowedWhenTerminated                  ("Part.newInstance");
         mustBeActive  (theProblem,  "theProblem",  "Part.newInstance");
         mustBeNonNull (thePartName, "thePartName", "Part.newInstance");
         mustBeNonNull (theCategory, "theCategory", "Part.newInstance");

         return
            new Part (theProblem.getCoordinator (), thePartName, theCategory);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getCategory ()
//
// Returns the Part Category for this Part.
//------------------------------------------------------------------------------

   public Category getCategory ()
      {
      try
         {
         mustBeActive ("Part.getCategory");

         return myCategory;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getDemands ()
//
// Returns an unmodifiable List of all the Demands associated with this Part,
// listed in the order of creation.
//------------------------------------------------------------------------------

   public List <Demand> getDemands ()
      {
      try
         {
         mustBeActive ("Part.getDemands");

         return unmodDemands;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getBomEntries ()
//
// Returns an unmodifiable List of all the BomEntries associated with this Part,
// listed in the order of creation.
//------------------------------------------------------------------------------

   public List <BomEntry> getBomEntries ()
      {
      try
         {
         mustBeActive ("Part.getBomEntries");

         return unmodBomEntries;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getSubstitutes ()
//
// Returns an unmodifiable List of all the Substitutes associated with this
// Part, listed in the order of creation.
//------------------------------------------------------------------------------

   public List <Substitute> getSubstitutes ()
      {
      try
         {
         mustBeActive ("Part.getSubstitutes");

         return unmodSubstitutes;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getBopEntries ()
//
// Returns an unmodifiable List of all the BopEntries associated with this Part,
// listed in the order of creation.
//------------------------------------------------------------------------------

   public List <BopEntry> getBopEntries ()
      {
      try
         {
         mustBeActive ("Part.getBopEntries");

         return unmodBopEntries;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getDemand (theDemandName)
//
// Returns the Demand that's associated with this Part and whose DemandName
// matches theDemandName, if any; otherwise null.
//------------------------------------------------------------------------------

   public Demand getDemand (String theDemandName)
      {
      try
         {
         mustBeActive ("Part.getDemand");

         for (Demand theDemand: myDemands)
            if (theDemand.getDemandName ().equals (theDemandName))
               return theDemand;

         return null;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getBelowList ()
//
// Returns the below list for this Part.
//------------------------------------------------------------------------------

   public ArrayList <Part> getBelowList ()
      {
      try
         {
         ArrayList <Part> theBelowList;

         mustBeActive ("Part.getBelowList");

         theBelowList = new ArrayList <Part> (0);

         myPartCOR.getBelowList (theBelowList);

         return theBelowList;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//==============================================================================
// Package-Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// toStringActive ().
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   String toStringActive ()
      {
      String theCategoryName;

      theCategoryName =
         (myCategory == Category.MATERIAL)?
            "Material":
            "Capacity";

      return theCategoryName + " Part \"" + myPartName + "\"";
      }

//------------------------------------------------------------------------------
// deactivate
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   void deactivate ()
      {
      myPartCOR.deactivate ();
      super    .deactivate ();
      }

//------------------------------------------------------------------------------
// recordDemand     (theDemand)
// recordBomEntry   (theBomEnt)
// recordSubstitute (theSub)
// recordBopEntry   (theBopEnt)
//
// Each of these methods records the fact that the argument has been created.
//------------------------------------------------------------------------------

   void recordDemand (Demand theDemand)
      {
      assert (theDemand.getPart () == this);

      myDemands.add (theDemand);
      }

   void recordBomEntry (BomEntry theBomEnt)
      {
      assert (theBomEnt.getPart () == this);

      myBomEntries.add (theBomEnt);
      }

   void recordSubstitute (Substitute theSub)
      {
      assert (theSub.getPart () == this);

      mySubstitutes.add (theSub);
      }

   void recordBopEntry (BopEntry theBopEnt)
      {
      assert (theBopEnt.getPart () == this);

      myBopEntries.add (theBopEnt);
      }

//------------------------------------------------------------------------------
// restoreAfterPurge ()
//
// Override from class Component.
//------------------------------------------------------------------------------

   void restoreAfterPurge ()
      {
      removeInactive (myDemands);
      removeInactive (myBomEntries);
      removeInactive (mySubstitutes);
      removeInactive (myBopEntries);
      }

//------------------------------------------------------------------------------
// findAssociatesIn (theList)
//
// Creates and returns a List of the A's in theList that are associated with
// this Part. The returned List retains the order of theList.
//------------------------------------------------------------------------------

   <A extends Associate>
         List <A> findAssociatesIn (List <A> theList)
      {
      ArrayList <A> theAssocs;

      theAssocs = new ArrayList <A> (theList.size ());

      for (A theA: theList)
         if (theA.getPart () == this)
            theAssocs.add (theA);

      theAssocs.trimToSize ();

      return theAssocs;
      }

//------------------------------------------------------------------------------
// findUniqueAssociateIn (theList, errText)
//
// If there is exactly one A in theList that's associated with this Part, it is
//    returned.
// If there are none, null is returned.
// If there are more than one, a StatusQuoExeption is thrown whose message
//    with errText.
//------------------------------------------------------------------------------

   <A extends Associate>
         A findUniqueAssociateIn (List <A> theList, String errText)
      {
      A uniqueA;

      uniqueA = null;

      for (A theA: theList)
         if (theA.getPart () == this)
            {
            if (uniqueA == null)
               {
               uniqueA = theA;
               }
            else
               {
               throw
                  new StatusQuoException (
                     errText + "\n"
                   + "\n"
                   + "      " + uniqueA + "\n"
                   + "      " + theA);
               }
            }
      
      return uniqueA;
      }

//------------------------------------------------------------------------------
// getCompClassID
//
// Override from class Component.
//------------------------------------------------------------------------------

   CompClassID getCompClassID ()
      {
      return CompClassID.PART;
      }

//------------------------------------------------------------------------------
// getComponentCOR
//
// Override from class Component.
//------------------------------------------------------------------------------

   ComponentCOR getComponentCOR ()
      {
      return myPartCOR;
      }

//------------------------------------------------------------------------------
// setPartName
//
// Sets the PartName of this Part.
//------------------------------------------------------------------------------

   void setPartName (String thePartName)
      {
      myPartCOR.setPartName (thePartName);

      myPartName = thePartName;
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   String getPartName ()
      {
      return myPartName;
      }

//------------------------------------------------------------------------------

   PartCOR getPartCOR ()
      {
      return myPartCOR;
      }

//==============================================================================
// Package-Internal Static Nested Interface Part.Associate.
//
// An interface to an Object that's associated with a particular Part.
//
// Class Hierarchy:
//
// Part.Associate
//    BomEntry
//    Substitute
//    BopEntry
//==============================================================================

   static interface Associate
   {
   //---------------------------------------------------------------------------
   // getPart ()
   //
   // Returns the Part associated with this Part.Associate.
   //---------------------------------------------------------------------------

      Part getPart ();
   }

//==============================================================================
// Private Constructor.
//
// Arguments:
//    theCoord:    The Coordinator  for the Part
//    thePartName: The PartName      of the Part
//    theCategory: The Part Category of the Part
//==============================================================================

   private Part (
         Coordinator theCoord,
         String      thePartName,
         Category    theCategory)
      {
      super (theCoord);

      boolean isMaterial;

      myPartName       = thePartName;

      myCategory       = theCategory;

      isMaterial       = (theCategory == Part.Category.MATERIAL);

      myPartCOR        =
         new PartCOR (theCoord.getCoordinatorCOR (), thePartName, isMaterial);

      myDemands        = new ArrayList <Demand>     (0);
      myBomEntries     = new ArrayList <BomEntry>   (0);
      mySubstitutes    = new ArrayList <Substitute> (0);
      myBopEntries     = new ArrayList <BopEntry>   (0);

      unmodDemands     = Collections.unmodifiableList (myDemands);
      unmodBomEntries  = Collections.unmodifiableList (myBomEntries);
      unmodSubstitutes = Collections.unmodifiableList (mySubstitutes);
      unmodBopEntries  = Collections.unmodifiableList (myBopEntries);

      getCoordinator ().recordPart (this);
      }

//==============================================================================
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// makeInstance (theProblem, thePartName, isMaterial)  
//
// Constructs a new Part for the arguments.
// To be called from WIT-J/C++.
//------------------------------------------------------------------------------

   private static void makeInstance (
         Problem theProblem,
         String  thePartName,
         boolean isMaterial)
      {
      Part.Category theCategory;

      theCategory =
         isMaterial?
            Part.Category.MATERIAL:
            Part.Category.CAPACITY;

      Part.newInstance (theProblem, thePartName, theCategory);
      }

//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// myPartName
//
// The PartName of this Part.
//------------------------------------------------------------------------------

   private String myPartName;

//------------------------------------------------------------------------------
// myCategory
//
// The Category of this Part.
//------------------------------------------------------------------------------

   private final Category myCategory;

//------------------------------------------------------------------------------
// myPartCOR
//
// The PartCOR that belongs to this Part.
//------------------------------------------------------------------------------

   private final PartCOR myPartCOR;

//------------------------------------------------------------------------------
// myDemands
// myBomEntries
// mySubstitutes
// myBopEntries
//
// A List of all Demands     associated with this Part.
// A List of all BomEntries  associated with this Part.
// A List of all Substitutes associated with this Part.
// A List of all BopEntries  associated with this Part.
//
// The Components are listed in the order of creation.
//------------------------------------------------------------------------------
                                              
   private final ArrayList <Demand>     myDemands;
   private final ArrayList <BomEntry>   myBomEntries;
   private final ArrayList <Substitute> mySubstitutes;
   private final ArrayList <BopEntry>   myBopEntries;

//------------------------------------------------------------------------------
// unmodDemands
// unmodBomEntries
// unmodSubstitutes
// unmodBopEntries
//
// Unmodifiable views of:
//    myDemands
//    myBomEntries
//    mySubstitutes
//    myBopEntries
//------------------------------------------------------------------------------

   private final List <Demand>     unmodDemands;
   private final List <BomEntry>   unmodBomEntries;
   private final List <Substitute> unmodSubstitutes;
   private final List <BopEntry>   unmodBopEntries;

//==============================================================================
}
@


1.111
log
@getBelowList
@
text
@a3 2
//
// Contains the declaration of class Part.
@


1.110
log
@Revised CppObjRep class ctors.
@
text
@d208 27
@


1.109
log
@Replaced C++ class CORJOR with ComponentJOR.
@
text
@d445 1
a445 6
      CoordinatorCOR theCoordCOR;
      boolean        isMaterial;

      theCoordCOR      = theCoord.getCoordinatorCOR ();

      isMaterial       = (theCategory == Part.Category.MATERIAL);
d451 4
a454 1
      myPartCOR        = new PartCOR (theCoordCOR, thePartName, isMaterial);
@


1.108
log
@Further implementation of class ThreadedObject.
@
text
@d445 7
d456 1
a456 1
      myPartCOR        = new PartCOR (this);
d472 26
@


1.107
log
@Initial implementation of class ThreadedObject.
@
text
@d58 4
a61 4
         notAllowedWhenTerminated                         ("Part.newInstance");
         Problem.mustBeActive (theProblem,  "theProblem",  "Part.newInstance");
         mustBeNonNull        (thePartName, "thePartName", "Part.newInstance");
         mustBeNonNull        (theCategory, "theCategory", "Part.newInstance");
@


1.106
log
@Implemented minimal thread safety:
   All calls to WIT-J must be from the same Thread or a StatusQuoException
   will be thrown.
@
text
@d21 4
a24 3
// PreservedObject
//    Component
//       Part
@


1.105
log
@Made getBomEntriesTo, etc. return modifiable Lists.
@
text
@d422 1
a422 1
   // Returns the associated Part for this Part.Associate.
@


1.104
log
@Removed lazy evaluation of unmodifiable views.
@
text
@d295 2
a296 2
// Creates and returns an unmodifiable List of the A's in theList that are
// associated with this Part. The returned List retains the order of theList.
d312 1
a312 1
      return Collections.unmodifiableList (theAssocs);
@


1.103
log
@Replaced the throwExceptionFor method with getExeceptionToThrow.
@
text
@d96 2
a97 1
// Returns an unmodifiable List of all the Demands associated with this Part.
a105 3
         if (unmodDemands == null)
             unmodDemands = Collections.unmodifiableList (myDemands);

d118 2
a119 1
// Returns an unmodifiable List of all the BomEntries associated with this Part.
a127 3
         if (unmodBomEntries == null)
             unmodBomEntries = Collections.unmodifiableList (myBomEntries);

d141 1
a141 1
// Part.
a149 3
         if (unmodSubstitutes == null)
             unmodSubstitutes = Collections.unmodifiableList (mySubstitutes);

d162 2
a163 1
// Returns an unmodifiable List of all the BopEntries associated with this Part.
a171 3
         if (unmodBopEntries == null)
             unmodBopEntries = Collections.unmodifiableList (myBopEntries);

d444 1
a444 1
      myPartName    = thePartName;
d446 1
a446 1
      myCategory    = theCategory;
d448 1
a448 1
      myPartCOR     = new PartCOR (this);
d450 9
a458 4
      myDemands     = new ArrayList <Demand>     (0);
      myBomEntries  = new ArrayList <BomEntry>   (0);
      mySubstitutes = new ArrayList <Substitute> (0);
      myBopEntries  = new ArrayList <BopEntry>   (0);
d497 6
a502 4
// The list of all Demands     associated with this Part.
// The list of all BomEntries  associated with this Part.
// The list of all Substitutes associated with this Part.
// The list of all BopEntries  associated with this Part.
a520 2
//
// The view Lists are created by lazy evaluation.
d523 4
a526 4
   private List <Demand>     unmodDemands     = null;
   private List <BomEntry>   unmodBomEntries  = null;
   private List <Substitute> unmodSubstitutes = null;
   private List <BopEntry>   unmodBopEntries  = null;
@


1.102
log
@Changed name of Java class WitjException to GeneralException.
@
text
@d66 1
a66 1
      catch (Throwable theThrowable)
d68 1
a68 3
         throwExceptionFor (theThrowable);

         return null;
d87 1
a87 1
      catch (Throwable theThrowable)
d89 1
a89 3
         throwExceptionFor (theThrowable);

         return null;
d111 1
a111 1
      catch (Throwable theThrowable)
d113 1
a113 3
         throwExceptionFor (theThrowable);

         return null;
d135 1
a135 1
      catch (Throwable theThrowable)
d137 1
a137 3
         throwExceptionFor (theThrowable);

         return null;
d160 1
a160 1
      catch (Throwable theThrowable)
d162 1
a162 3
         throwExceptionFor (theThrowable);

         return null;
d184 1
a184 1
      catch (Throwable theThrowable)
d186 1
a186 3
         throwExceptionFor (theThrowable);

         return null;
d210 1
a210 1
      catch (Throwable theThrowable)
d212 1
a212 3
         throwExceptionFor (theThrowable);

         return null;
@


1.101
log
@Removed the "enabled" concept from WIT-J.
@
text
@d68 3
a70 1
         throw getWitjExceptionFor (theThrowable);
d91 3
a93 1
         throw getWitjExceptionFor (theThrowable);
d117 3
a119 1
         throw getWitjExceptionFor (theThrowable);
d143 3
a145 1
         throw getWitjExceptionFor (theThrowable);
d170 3
a172 1
         throw getWitjExceptionFor (theThrowable);
d196 3
a198 1
         throw getWitjExceptionFor (theThrowable);
d224 3
a226 1
         throw getWitjExceptionFor (theThrowable);
@


1.100
log
@Changed name of Java class RetainedObject to PreservedObject.
@
text
@d57 4
a60 5
         notAllowedWhenTerminated ("Part.newInstance");

         Problem.mustBeEnabled (theProblem,                 "Part.newInstance");
         mustBeNonNull         (thePartName, "thePartName", "Part.newInstance");
         mustBeNonNull         (theCategory, "theCategory", "Part.newInstance");
@


1.99
log
@theProblem.copyData (...).
@
text
@d21 1
a21 1
// RetainedObject
d224 1
a224 1
// Override from class RetainedObject.
d242 1
a242 1
// Override from class RetainedObject.
@


1.98
log
@Argument checking.
@
text
@d59 3
a61 4
         Problem.
            mustBeEnabled (theProblem,                  "Part.newInstance");
         mustBeNonNull    (thePartName,  "thePartName", "Part.newInstance");
         mustBeNonNull    (theCategory,  "theCategory", "Part.newInstance");
@


1.97
log
@Minor revisions.
@
text
@d59 2
a60 1
         argMustBeEnabled (theProblem,                  "Part.newInstance");
@


1.96
log
@Replaced theProblem.getInstances (theClass) with theProblem.GetParts (),
etc.
@
text
@d252 4
a255 1
// record (theArg) methods
d257 1
a257 1
// Each of these methods records the fact that theArg has been created.
d260 1
a260 1
   void record (Demand theDemand)
d267 1
a267 1
   void record (BomEntry theBomEnt)
d274 1
a274 1
   void record (Substitute theSub)
d281 1
a281 1
   void record (BopEntry theBopEnt)
@


1.95
log
@Added:
   theOpn     .getUniqueBomEntryTo   (thePart)
   theOpn     .getUniqueBopEntryTo   (thePart)
   theBomEntry.getUniqueSubstituteTo (thePart)
@
text
@d97 1
a97 1
// Return an unmodifiable List of all the Demands associated with this Part.
d121 1
a121 1
// Return an unmodifiable List of all the BomEntries associated with this Part.
d145 2
a146 1
// Return an unmodifiable List of all the Substitutes associated with this Part.
d170 1
a170 1
// Return an unmodifiable List of all the BopEntries associated with this Part.
@


1.94
log
@Added:
   theOpn     .getBomEntriesTo  (thePart)
   theOpn     .getBopEntriesTo  (thePart)
   theBomEntry.getSubstitutesTo (thePart)
@
text
@d305 2
a306 1
   <A extends Associate> List <A> findAssociatesIn (List <A> theList)
d322 38
@


1.93
log
@Implemented theProblem.getInstances (theCompClass).
@
text
@d299 22
d372 24
@


1.92
log
@Replaced Attribute.getAllAttributes () with Attribute.getAttributes (),
which returns an unmodifiable List.
@
text
@d365 1
a365 1
      myPartName      = thePartName;
d367 1
a367 1
      myCategory      = theCategory;
d369 1
a369 1
      myPartCOR       = new PartCOR (this);
d371 4
a374 4
      myDemands       = new ArrayList <Demand>     (0);
      myBomEntries    = new ArrayList <BomEntry>   (0);
      mySubstitutes   = new ArrayList <Substitute> (0);
      myBopEntries    = new ArrayList <BopEntry>   (0);
d376 1
a376 1
      getCoordinator ().record (this);
@


1.91
log
@Changed the following methods to return an unmodifiable List:

   thePart     .getDemands     ()
   thePart     .getBomEntries  ()
   thePart     .getSubstitutes ()
   thePart     .getBopEntries  ()
   theOperation.getBomEntries  ()
   theOperation.getBopEntries  ()
   theBomEntry .getSubstitutes ()
@
text
@d436 1
a436 1
// The view Lists are constructed by lazy evaluation.
@


1.90
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@d97 1
a97 1
// Returns an array of all the Demands associated with this Part.
d100 1
a100 1
   public Demand[] getDemands ()
d106 4
a109 1
         return myDemands.toArray (new Demand[0]);
d121 1
a121 1
// Returns an array of all the BomEntries associated with this Part.
d124 1
a124 1
   public BomEntry[] getBomEntries ()
d130 4
a133 1
         return myBomEntries.toArray (new BomEntry[0]);
d145 1
a145 1
// Returns an array of all the Substitutes associated with this Part.
d148 1
a148 1
   public Substitute[] getSubstitutes ()
d154 4
a157 1
         return mySubstitutes.toArray (new Substitute[0]);
d169 1
a169 1
// Returns an array of all the BopEntries associated with this Part.
d172 1
a172 1
   public BopEntry[] getBopEntries ()
d178 4
a181 1
         return myBopEntries.toArray (new BopEntry[0]);
d424 20
@


1.89
log
@Changed name of Problem method shutDown to deactivate.
@
text
@d22 1
a22 1
//    Element
d26 1
a26 1
public final class Part extends Element
d275 1
a275 1
// Override from class Element.
d287 1
a287 1
// getElemClassID
d289 1
a289 1
// Override from class Element.
d292 1
a292 1
   ElemClassID getElemClassID ()
d294 1
a294 1
      return ElemClassID.PART;
d298 1
a298 1
// getElementCOR
d300 1
a300 1
// Override from class Element.
d303 1
a303 1
   ElementCOR getElementCOR ()
@


1.88
log
@purgeData
@
text
@d227 1
a227 1
// shutDown
d232 1
a232 1
   void shutDown ()
d234 2
a235 2
      myPartCOR.shutDown ();
      super    .shutDown ();
@


1.87
log
@purgeData
@
text
@d407 4
a410 4
   private ArrayList <Demand>     myDemands     = null;
   private ArrayList <BomEntry>   myBomEntries  = null;
   private ArrayList <Substitute> mySubstitutes = null;
   private ArrayList <BopEntry>   myBopEntries  = null;
@


1.86
log
@purgeData
@
text
@d280 4
a283 4
      myDemands     = activeOnly (myDemands);
      myBomEntries  = activeOnly (myBomEntries);
      mySubstitutes = activeOnly (mySubstitutes);
      myBopEntries  = activeOnly (myBopEntries);
@


1.85
log
@purgeData
@
text
@d204 4
d209 1
a209 1
// toString ().
d211 1
a211 1
// Override from class Object.
d214 1
a214 1
   public String toString ()
d216 1
a216 5
      try
         {
         String theCategoryName;

         notAllowedWhenTerminated ("Part.toString");
d218 4
a221 4
         theCategoryName =
            (myCategory == Category.MATERIAL)?
               "Material":
               "Capacity";
d223 1
a223 7
         return theCategoryName + " Part \"" + myPartName + "\"";
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
a225 4
//==============================================================================
// Package-Internal Methods
//==============================================================================

@


1.84
log
@purgeData
@
text
@d283 1
a283 1
// reconcileForPurge ()
d288 1
a288 1
   void reconcileForPurge ()
d290 4
a293 6
      myDemands    .clear ();
      myBomEntries .clear ();
      mySubstitutes.clear ();
      myBopEntries .clear ();

      assert (false);
d416 5
a420 5

   private final List <Demand>     myDemands;
   private final List <BomEntry>   myBomEntries;
   private final List <Substitute> mySubstitutes;
   private final List <BopEntry>   myBopEntries;
@


1.83
log
@Part.Category by boolean.
@
text
@d283 16
@


1.82
log
@PIP.
@
text
@d45 1
a45 1
// newInstance (theProblem, thePartName, thePartCat)
d53 1
a53 1
         Category thePartCat)
d59 3
a61 3
         argMustBeEnabled (theProblem,                 "Part.newInstance");
         mustBeNonNull    (thePartName, "thePartName", "Part.newInstance");
         mustBeNonNull    (thePartCat,  "thePartCat",  "Part.newInstance");
d64 1
a64 1
            new Part (theProblem.getCoordinator (), thePartName, thePartCat);
a82 2
         String thePartCatName;

d85 1
a85 3
         thePartCatName = myPartCOR.getCategory ();

         return Category.valueOf (thePartCatName);
d214 2
d218 6
a223 1
         return "Part \"" + myPartName + "\"";
d339 1
a339 1
//    thePartCat:  The Part Category of the Part
d345 1
a345 1
         Category    thePartCat)
d349 10
a358 12
      String thePartCatName;
  
      myPartName     = thePartName;

      thePartCatName = thePartCat.name ();

      myPartCOR      = new PartCOR (this, thePartCatName);

      myDemands      = new ArrayList <Demand>     (0);
      myBomEntries   = new ArrayList <BomEntry>   (0);
      mySubstitutes  = new ArrayList <Substitute> (0);
      myBopEntries   = new ArrayList <BopEntry>   (0);
d376 8
@


1.81
log
@Part Category
@
text
@d29 1
a29 5
// Public Static Nested Enums
//==============================================================================

//------------------------------------------------------------------------------
// Nested Enum Category
d32 1
a32 1
//------------------------------------------------------------------------------
d34 1
a34 1
   public enum Category
@


1.80
log
@Removed the Alternative classes.
@
text
@d87 1
a87 1
         int thePartCatIdx;
d91 1
a91 1
         thePartCatIdx = myPartCOR.getCategoryIndex ();
d93 1
a93 1
         return Category.values ()[thePartCatIdx];
d350 1
a350 1
      int thePartCatIdx;
d352 1
a352 1
      myPartName    = thePartName;
d354 1
a354 1
      thePartCatIdx = thePartCat.ordinal ();
d356 1
a356 1
      myPartCOR     = new PartCOR (this, thePartCatIdx);
d358 4
a361 4
      myDemands     = new ArrayList <Demand>     (0);
      myBomEntries  = new ArrayList <BomEntry>   (0);
      mySubstitutes = new ArrayList <Substitute> (0);
      myBopEntries  = new ArrayList <BopEntry>   (0);
@


1.79
log
@Part.Category as Alternative
@
text
@d38 1
a38 1
   public enum Category implements Alternative
a39 4
   //===========================================================================
   // Enum Constants
   //===========================================================================

a41 44
      ;

   //===========================================================================
   // Package-Internal Methods
   //===========================================================================

   //---------------------------------------------------------------------------
   // setUp ()
   //
   // Sets up this Enum.
   // To be called once.
   //---------------------------------------------------------------------------

      static void setUp ()
         {
         for (Category theCat: values ())
            {
            assert (theCat.myAlternativeCOR == null);

            theCat.myAlternativeCOR =
               new AlternativeCOR (theCat, theCat.name ());
            }
         }

   //---------------------------------------------------------------------------
   // Accessors
   //---------------------------------------------------------------------------

      AlternativeCOR getAlternativeCOR ()
         {
         return myAlternativeCOR;
         }

   //===========================================================================
   // Private Fields
   //===========================================================================

   //---------------------------------------------------------------------------
   // myAlternativeCOR
   //
   // The AlternativeCOR owned by this Category.
   //---------------------------------------------------------------------------

      private AlternativeCOR myAlternativeCOR = null;
d49 1
a49 1
// newInstance (theProblem, thePartName, theCategory)
d57 1
a57 1
         Category theCategory)
d65 1
a65 1
         mustBeNonNull    (theCategory, "theCategory", "Part.newInstance");
d68 1
a68 1
            new Part (theProblem.getCoordinator (), thePartName, theCategory);
d87 1
a87 1
         Alternative thePartCatAlt;
d91 1
a91 1
         thePartCatAlt = myPartCOR.getCategory ().getAlternative ();
d93 1
a93 1
         return (Category) thePartCatAlt;
d340 1
a340 1
//    theCategory: The Part Category of the Part
d346 1
a346 1
         Category    theCategory)
d349 2
d354 3
a356 1
      myPartCOR     = new PartCOR (this, theCategory);
@


1.78
log
@Coordinator
@
text
@d38 1
a38 1
   public enum Category
d40 4
d46 44
d135 2
d139 3
a141 4
         return
            myPartCOR.getCategoryIsMat ()?
               Category.MATERIAL:
               Category.CAPACITY;
a410 29
// Private methods
//==============================================================================

//------------------------------------------------------------------------------
// makePart (theCoord, thePartName, theCategoryIsMat)
//
// Static Factory method: Constructs a new Part for the arguments.
//
// Argument: theCategoryIsMat: True, iff the Part is to be a material Part.
//
// Intended for invocation from WIT-J/C++.
//------------------------------------------------------------------------------

   private static void makePart (
         Coordinator theCoord,
         String      thePartName,
         boolean     theCategoryIsMat)
      {
      Category theCategory;

      theCategory =
         theCategoryIsMat?
            Category.MATERIAL:
            Category.CAPACITY;

      new Part (theCoord, thePartName, theCategory);
      }

//==============================================================================
@


1.77
log
@Coordinator
@
text
@d337 3
a339 3
//    theCoordinator: The Coordinator  for the Part
//    thePartName:    The PartName      of the Part
//    theCategory:    The Part Category of the Part
d343 1
a343 1
         Coordinator theCoordinator,
d347 1
a347 1
      super (theCoordinator);
d366 1
a366 1
// makePart (theCoordinator, thePartName, theCategoryIsMat)
d376 1
a376 1
         Coordinator theCoordinator,
d387 1
a387 1
      new Part (theCoordinator, thePartName, theCategory);
@


1.76
log
@Removed java class ElementMgr, moving its responsibilities to class
Coordinator.
@
text
@d67 2
a68 1
         return new Part (theProblem, thePartName, theCategory);
d337 3
a339 3
//    theProblem:  The Problem for the Part
//    thePartName: The PartName of the Part
//    theCategory: The Part Category of the Part.
d343 3
a345 3
         Problem  theProblem,
         String   thePartName,
         Category theCategory)
d347 1
a347 1
      super (theProblem.getCoordinator ());
d366 1
a366 1
// makePart (theProblem, thePartName, theCategoryIsMat)
d376 3
a378 3
         Problem theProblem,
         String  thePartName,
         boolean theCategoryIsMat)
d387 1
a387 1
      new Part (theProblem, thePartName, theCategory);
@


1.75
log
@Changed a Java class name: WitjAbortsException ==> TerminalException
@
text
@d346 1
a346 1
      super (theProblem.getElementMgr ());
d357 1
a357 1
      getElementMgr ().record (this);
@


1.74
log
@Changed class name: NonFunctionalException ==> WitjAbortsException
@
text
@d61 1
a61 1
         witjAbortedNotAllowed ("Part.newInstance");
d220 1
a220 1
         witjAbortedNotAllowed ("Part.toString");
@


1.73
log
@Minor revision.
@
text
@d61 1
a61 1
         witjMustBeFunctional ("Part.newInstance");
d220 1
a220 1
         witjMustBeFunctional ("Part.toString");
@


1.72
log
@Added the uniform try block whereever it was needed.
@
text
@d21 3
a23 3
//    RetainedObject
//       Element
//          Part
@


1.71
log
@Added a call to witjMustBeFunctional whereever it was needed.
@
text
@d59 15
a73 7
      witjMustBeFunctional ("Part.newInstance");

      argMustBeEnabled (theProblem,                 "Part.newInstance");
      mustBeNonNull    (thePartName, "thePartName", "Part.newInstance");
      mustBeNonNull    (theCategory, "theCategory", "Part.newInstance");

      return new Part (theProblem, thePartName, theCategory);
d84 14
a97 6
      mustBeActive ("Part.getCategory");

      return
         myPartCOR.getCategoryIsMat ()?
            Category.MATERIAL:
            Category.CAPACITY;
d108 11
a118 3
      mustBeActive ("Part.getDemands");

      return myDemands.toArray (new Demand[0]);
d129 11
a139 3
      mustBeActive ("Part.getBomEntries");

      return myBomEntries.toArray (new BomEntry[0]);
d150 11
a160 3
      mustBeActive ("Part.getSubstitutes");

      return mySubstitutes.toArray (new Substitute[0]);
d171 11
a181 3
      mustBeActive ("Part.getBopEntries");

      return myBopEntries.toArray (new BopEntry[0]);
d193 15
a207 7
      mustBeActive ("Part.getDemand");

      for (Demand theDemand: myDemands)
         if (theDemand.getDemandName ().equals (theDemandName))
            return theDemand;

      return null;
d218 11
a228 3
      witjMustBeFunctional ("Part.toString");

      return "Part \"" + myPartName + "\"";
@


1.70
log
@Minor changes.
@
text
@d59 2
d162 2
@


1.69
log
@Removed class Session from the public interface.
@
text
@d168 1
a168 1
// shutDown ().
d214 1
a214 1
// getElemClassID ()
d225 1
a225 1
// getElementCOR ().
d236 1
a236 1
// setPartName (...)
@


1.68
log
@Replaced Attribute partCategory with thePart.getCategory ().
@
text
@d59 3
a61 3
      argMustBeActive (theProblem,  "theProblem",  "Part.newInstance");
      mustBeNonNull   (thePartName, "thePartName", "Part.newInstance");
      mustBeNonNull   (theCategory, "theCategory", "Part.newInstance");
@


1.67
log
@Minot revision.
@
text
@d67 16
@


1.66
log
@Conditional expressions.
@
text
@d281 1
a281 1
// makePart (theProblem, thePartName, theMaterialCase)
d285 1
a285 1
// Argument: theMaterialCase: True, iff the Part is to be a material Part.
d293 1
a293 1
         boolean theMaterialCase)
d298 1
a298 1
         theMaterialCase?
@


1.65
log
@Call-back infrastructure.
@
text
@d297 4
a300 4
      if (theMaterialCase)
         theCategory = Category.MATERIAL;
      else
         theCategory = Category.CAPACITY;
@


1.64
log
@Call-back infrastructure.
@
text
@d277 29
@


1.63
log
@Revised factory methods.
@
text
@a276 17
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// newDemand (theDemandName)
//
// Factory method: Constructs and returns a new Demand for the arguments.
//
// Intended for invocation from WIT-J/C++.
//------------------------------------------------------------------------------

   private Demand newDemand (String theDemandName)
      {
      return Demand.newInstance (this, theDemandName);
      }

//==============================================================================
@


1.62
log
@Name change.
@
text
@d49 1
a49 3
// newDemand (theDemandName)
//
// Factory method: Constructs and returns a new Demand for this Part.
d51 1
a51 2
// Argument:
//    theDemandName: The DemandName of the Demand.
d54 4
a57 1
   public Demand newDemand (String theDemandName)
d59 3
a61 1
      mustBeActive                                  ("Part.newDemand");
d63 1
a63 3
      mustBeNonNull (theDemandName, "theDemandName", "Part.newDemand");

      return new Demand (this, theDemandName);
a147 28
// Package-Internal Constructor.
//
// Arguments:
//    theProblem:  The Problem for the Part
//    thePartName: The PartName of the Part
//    theCategory: The Part Category of the Part.
//==============================================================================

   Part (
         Problem  theProblem,
         String   thePartName,
         Category theCategory)
      {
      super (theProblem.getElementMgr ());
  
      myPartName    = thePartName;

      myPartCOR     = new PartCOR (this, theCategory);

      myDemands     = new ArrayList <Demand>     (0);
      myBomEntries  = new ArrayList <BomEntry>   (0);
      mySubstitutes = new ArrayList <Substitute> (0);
      myBopEntries  = new ArrayList <BopEntry>   (0);

      getElementMgr ().record (this);
      }

//==============================================================================
d249 45
@


1.61
log
@Changed name of Component to Entity.
@
text
@d22 1
a22 1
//       Entity
d26 1
a26 1
public final class Part extends Entity
d161 1
a161 1
      super (theProblem.getEntityMgr ());
d172 1
a172 1
      getEntityMgr ().record (this);
d226 1
a226 1
// getEntityClassID ()
d228 1
a228 1
// Override from class Entity.
d231 1
a231 1
   EntityClassID getEntityClassID ()
d233 1
a233 1
      return EntityClassID.PART;
d237 1
a237 1
// getEntityCOR ().
d239 1
a239 1
// Override from class Entity.
d242 1
a242 1
   EntityCOR getEntityCOR ()
@


1.60
log
@Call-back infrastructure.
@
text
@d22 1
a22 1
//       Component
d26 1
a26 1
public final class Part extends Component
d161 1
a161 1
      super (theProblem.getCompMgr ());
d172 1
a172 1
      getCompMgr ().record (this);
d226 1
a226 1
// getCompClassID ()
d228 1
a228 1
// Override from class Component.
d231 1
a231 1
   CompClassID getCompClassID ()
d233 1
a233 1
      return CompClassID.PART;
d237 1
a237 1
// getCompCOR ().
d239 1
a239 1
// Override from class Component.
d242 1
a242 1
   ComponentCOR getCompCOR ()
@


1.59
log
@Call-back infrastructure.
@
text
@a153 2
//
// To be called only from theProblem.newPart (thePartName, theCategory).
@


1.58
log
@Numerous class name changes.
@
text
@a164 3
      ProblemCOR theProblemCOR;
      boolean    toBeAMaterial;
  
d167 1
a167 5
      theProblemCOR = theProblem.getProblemCOR ();

      toBeAMaterial = (theCategory == Category.MATERIAL);

      myPartCOR     = new PartCOR (theProblemCOR, thePartName, toBeAMaterial);
@


1.57
log
@Minor revision.
@
text
@d165 2
a166 2
      ProblemCI theProblemCI;
      boolean   toBeAMaterial;
d170 1
a170 1
      theProblemCI  = theProblem.getProblemCI ();
d174 1
a174 1
      myPartCI      = new PartCI (theProblemCI, thePartName, toBeAMaterial);
d196 2
a197 2
      myPartCI.shutDown ();
      super   .shutDown ();
d246 1
a246 1
// getCompCI ().
d251 1
a251 1
   ComponentCI getCompCI ()
d253 1
a253 1
      return myPartCI;
d264 1
a264 1
      myPartCI.setPartName (thePartName);
d280 1
a280 1
   PartCI getPartCI ()
d282 1
a282 1
      return myPartCI;
d298 1
a298 1
// myPartCI
d300 1
a300 1
// The PartCI that belongs to this Part.
d303 1
a303 1
   private final PartCI myPartCI;
@


1.56
log
@Implemented thePart.getBopEntries ().
@
text
@d166 1
a166 1
      boolean   isMaterialBool;
d168 1
a168 1
      myPartName     = thePartName;
d170 1
a170 1
      theProblemCI   = theProblem.getProblemCI ();
d172 1
a172 1
      isMaterialBool = (theCategory == Category.MATERIAL);
d174 1
a174 1
      myPartCI       = new PartCI (theProblemCI, thePartName, isMaterialBool);
d176 4
a179 4
      myDemands      = new ArrayList <Demand>     (0);
      myBomEntries   = new ArrayList <BomEntry>   (0);
      mySubstitutes  = new ArrayList <Substitute> (0);
      myBopEntries   = new ArrayList <BopEntry>   (0);
@


1.55
log
@Implemented thePart.getSubstitutes ().
@
text
@d106 13
d179 1
d227 7
d309 1
d314 1
d320 1
@


1.54
log
@Implemented thePart.getBomEntries ().
@
text
@d93 13
d163 3
a165 2
      myDemands      = new ArrayList <Demand>   (0);
      myBomEntries   = new ArrayList <BomEntry> (0);
a198 2
//------------------------------------------------------------------------------

d206 7
d269 1
a269 1
// myPartName;
d277 1
a277 1
// myPartCI.
d285 7
a291 11
// myDemands.
//
// The list of all Demands associated with this Part.
//------------------------------------------------------------------------------

   private final List <Demand> myDemands;

//------------------------------------------------------------------------------
// myBomEntries.
//
// The list of all BomEntries associated with this Part.
d294 3
a296 1
   private final List <BomEntry> myBomEntries;
@


1.53
log
@Implemented thePart.getDemand (theDemandName).
@
text
@d80 13
d150 2
a151 1
      myDemands      = new ArrayList <Demand> (0);
d173 1
a173 1
// record (theDemand)
d175 1
a175 1
// Records the fact that theDemand has been created.
d186 9
d273 8
@


1.52
log
@Implemented thePart.getDemands ().
@
text
@d80 18
@


1.51
log
@Implemented theProblem.getPart (thePartName).
@
text
@d12 2
d67 13
d119 3
a121 1
      getCompMgr ().add (this);
d141 13
d224 8
@


1.50
log
@Active state / shutDown method.
@
text
@d103 2
@


1.49
log
@Revised the use of class CTVecRes.
@
text
@d57 1
a57 1
      mustBeUnreleased                              ("Part.newDemand");
d110 1
a110 1
// release ().
d115 1
a115 1
   void release ()
d117 2
a118 2
      myPartCI.release ();
      super   .release ();
@


1.48
log
@Revised the factory methods.
@
text
@d93 1
a93 1
      SessionCI theSessionCI;
d98 1
a98 1
      theSessionCI   = theProblem.getSession ().getSessionCI ();
d102 1
a102 1
      myPartCI       = new PartCI (theSessionCI, thePartName, isMaterialBool);
@


1.47
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@d47 1
a47 1
// makeInstance (theProblem, thePartName)
d49 4
a52 5
// Factory method: Constructs and returns a new Part.
// Arguments:
//    theProblem:  The Problem that will own the Part.
//    thePartName: The PartName of the Part.
//    theCategory: The Part Category of the Part.
d55 1
a55 4
   public static Part makeInstance (
         Problem  theProblem,
         String   thePartName,
         Category theCategory)
d57 1
a57 3
      argMustBeUnreleased (theProblem,  "theProblem",  "Part.makeInstance");
      mustBeNonNull       (thePartName, "thePartName", "Part.makeInstance");
      mustBeNonNull       (theCategory, "theCategory", "Part.makeInstance");
d59 3
a61 1
      return new Part (theProblem, thePartName, theCategory);
d76 30
a172 28
// Private Constructor.
//
// Arguments:
//    theProblem:  The Problem for the Part
//    thePartName: The PartName of the Part
//    theCategory: The Part Category of the Part.
//==============================================================================

   private Part (
         Problem  theProblem,
         String   thePartName,
         Category theCategory)
      {
      super (theProblem.getCompMgr ());
  
      SessionCI theSessionCI;
      boolean   isMaterialBool;
  
      myPartName     = thePartName;

      theSessionCI   = theProblem.getSession ().getSessionCI ();

      isMaterialBool = (theCategory == Category.MATERIAL);

      myPartCI       = new PartCI (theSessionCI, thePartName, isMaterialBool);
      }

//==============================================================================
@


1.46
log
@Moved onwership of the ProbCoordCI from class Problem to class Session.
@
text
@d162 2
a163 2
      ProbCoordCI theProbCoordCI;
      boolean     isMaterialBool;
d167 1
a167 1
      theProbCoordCI = theProblem.getSession ().getProbCoordCI ();
d171 1
a171 1
      myPartCI       = new PartCI (theProbCoordCI, thePartName, isMaterialBool);
@


1.45
log
@Removed Java class ProbCoord.
@
text
@d162 2
a163 5
      myPartCI      =
         new PartCI (
            theProblem.getProbCoordCI (),
            thePartName,
            (theCategory == Category.MATERIAL));
d165 7
a171 1
      myPartName = thePartName;
@


1.44
log
@Initial implementation of the Session classes.
@
text
@d65 1
a65 1
      return new Part (theProblem.getProbCoord (), thePartName, theCategory);
d150 3
a152 3
//    theProbCoord: The ProbCoord for the Part
//    thePartName:  The PartName of the Part
//    theCategory:  The Part Category of the Part.
d156 3
a158 3
         ProbCoord theProbCoord,
         String    thePartName,
         Category  theCategory)
d160 1
a160 1
      super (theProbCoord.getCompMgr ());
d164 1
a164 1
            theProbCoord.getProbCoordCI (),
@


1.43
log
@Terminology change.
@
text
@d147 1
a147 5
// Private Methods.
//==============================================================================

//------------------------------------------------------------------------------
// Constructor.
d153 1
a153 1
//------------------------------------------------------------------------------
@


1.42
log
@Added checking for null arguments.
@
text
@d19 1
a19 1
//    VitalObject
d61 1
a61 1
      mustBeNonNullActive (theProblem,  "theProblem",  "Part.makeInstance");
d84 1
a84 1
// shutDown ().
d86 1
a86 1
// Override from class VitalObject.
d89 1
a89 1
   void shutDown ()
d91 2
a92 2
      myPartCI.shutDown ();
      super   .shutDown ();
@


1.41
log
@Replaced class PublicObject with class VitalObject.
@
text
@d61 3
a63 1
      mustBeNonNullActive (theProblem, "theProblem", "Part.makeInstance");
@


1.40
log
@Replaced toStringActive () with toString ().
@
text
@d19 1
a19 1
//    PublicObject
d84 1
a84 1
// Override from class PublicObject.
@


1.39
log
@"partName" attribute.
@
text
@d66 11
a93 11
// toStringActive ().
//
// Override from class PublicObject.
//------------------------------------------------------------------------------

   String toStringActive ()
      {
      return "Part \"" + myPartName + "\"";
      }

//------------------------------------------------------------------------------
@


1.38
log
@"partName" attribute.
@
text
@d52 2
a53 2
//    thePartName: The partName of the Part.
//    theCategory: The part category of the Part.
d118 1
a118 1
// Sets the partName of this Part.
d121 1
a121 1
   void setPartName (String partNameVal)
d123 1
a123 1
      myPartCI.setPartName (partNameVal);
d125 1
a125 1
      myPartName = partNameVal;
d153 2
a154 2
//    thePartName:  The partName of the Part
//    theCategory:  The part category of the Part.
d180 1
a180 1
// The partName of this Part.
@


1.37
log
@Revised the shut-down model.
@
text
@a65 11
//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   public String getPartName ()
      {
      mustBeActive ("Part.getPartName");

      return myPartName;
      }

d116 1
a116 1
// getPartCI ().
d118 19
a136 1
// Accessor.
@


1.36
log
@Implemented Utility class.
@
text
@a89 3

      myPartCI = null;

d184 1
a184 1
   private PartCI myPartCI;
@


1.35
log
@Replaced classes Material and Capacity with an enum.
@
text
@d8 3
a10 1
package com.ibm.witj;
@


1.34
log
@Made accessor names begin with "get".
@
text
@a19 2
//             Material
//             Capacity
d22 1
a22 1
public abstract class Part extends Component
d25 16
d45 20
d80 1
a80 1
// Constructor.
d82 1
a82 4
// Arguments:
//    theProbCoord: The ProbCoord for the Part
//    thePartName:  The partName of the Part
//    isaMaterial:  True, iff the Part is a Material.
d85 1
a85 1
   Part (ProbCoord theProbCoord, String thePartName, boolean isaMaterial)
d87 5
a91 9
      super (theProbCoord.getCompMgr ());
  
      myPartCI      =
         new PartCI (
            theProbCoord.getProbCoordCI (),
            thePartName,
            isaMaterial);
  
      myPartName = thePartName;
d95 1
a95 1
// shutDown ().
d100 1
a100 1
   void shutDown ()
d102 1
a102 5
      myPartCI.shutDown ();

      myPartCI = null;

      super   .shutDown ();
d139 29
@


1.33
log
@Minor update.
@
text
@d34 1
a34 1
   public String partName ()
d36 1
a36 1
      mustBeActive ("Part.partName");
d38 1
a38 1
      return partName;
d50 1
a50 1
//    partName:     The partName of the Part
d54 1
a54 1
   Part (ProbCoord theProbCoord, String partNameVal, boolean isaMaterial)
d56 1
a56 1
      super (theProbCoord.myCompMgr ());
d60 2
a61 2
            theProbCoord.myProbCoordCI (),
            partNameVal,
d64 1
a64 1
      partName = partNameVal;
d83 1
a83 1
// myCompClassID ()
d88 1
a88 1
   CompClassID myCompClassID ()
d94 1
a94 1
// myCompCI ().
d99 1
a99 1
   ComponentCI myCompCI ()
d105 1
a105 1
// myPartCI ().
d110 1
a110 1
   PartCI myPartCI ()
d120 1
a120 1
// partName;
d122 1
a122 1
// The name of this Part.
d125 1
a125 1
   private String partName;
@


1.32
log
@Attributes.
@
text
@d31 1
a31 3
// partName ().
//
// Accessor.
@


1.31
log
@Attributes.
@
text
@d8 1
a8 3
package        com.ibm.witj;

import  static com.ibm.witj.AttID.*;
a30 44
// getSupplyVol ()
//
// Returns the current value of the supplyVol attribute for this Part.
//------------------------------------------------------------------------------

   public double[] getSupplyVol ()
      {
      AttCI    theAttCI;
      double[] theDblArr;

      mustBeActive ("Part.getSupplyVol");

      theAttCI  = myProbCoord ().myAttMgr ().myAttCIFor (SUPPLY_VOL);

      theDblArr = new double[nPeriods ()];

      theAttCI.getDblVec (myCompCI (), theDblArr);

      return theDblArr;
      }

//------------------------------------------------------------------------------
// getScrapVol ()
//
// Returns the current value of the scrapVol attribute for this Part.
//------------------------------------------------------------------------------

   public double[] getScrapVol ()
      {
      AttCI    theAttCI;
      double[] theDblArr;

      mustBeActive ("Part.getScrapVol");

      theAttCI  = myProbCoord ().myAttMgr ().myAttCIFor (SCRAP_VOL);

      theDblArr = new double[nPeriods ()];

      theAttCI.getDblVec (myCompCI (), theDblArr);

      return theDblArr;
      }

//------------------------------------------------------------------------------
@


1.30
log
@Attributes.
@
text
@d8 1
a8 1
package com.ibm.witj;
a32 29
// setSupplyVol (theDblArr)
//
// Sets the value of the supplyVol attribute for this Part to theDblArr.
// theDblArr must be of length nPeriods.
//------------------------------------------------------------------------------

   public void setSupplyVol (double[] theDblArr)
      {
      AttCI theAttCI;

      mustBeActive ("Part.setSupplyVol");

      if (theDblArr.length != nPeriods ())
         abortWmsg (
              "   Part.setSupplyVol (...) was called with an array\n"
            + "   whose length does not match nPeriods for the Problem.\n"
            + "\n"
            + "      Array Length: "
            +        theDblArr.length
            + "\n"
            + "      nPeriods:     "
            +        nPeriods ());

      theAttCI = myProbCoord ().myAttMgr ().myAttCIFor (SUPPLY_VOL);

      theAttCI.setDblVec (myCompCI (), theDblArr);
      }

//------------------------------------------------------------------------------
d131 11
@


1.29
log
@Attributes
@
text
@d10 2
d56 1
a56 1
      theAttCI = myProbCoord ().myAttMgr ().myAttCIFor ("supplyVol");
d74 1
a74 1
      theAttCI  = myProbCoord ().myAttMgr ().myAttCIFor ("supplyVol");
d96 1
a96 1
      theAttCI  = myProbCoord ().myAttMgr ().myAttCIFor ("scrapVol");
@


1.28
log
@Removed enum AttID.
@
text
@d82 22
@


1.27
log
@Removed AttAcc classes.
@
text
@d54 1
a54 1
      theAttCI = myProbCoord ().myAttMgr ().myAttCIFor (AttID.supplyVol);
d72 1
a72 1
      theAttCI  = myProbCoord ().myAttMgr ().myAttCIFor (AttID.supplyVol);
@


1.26
log
@Attributes.
@
text
@d39 2
d43 14
a56 1
      getDblVecInAttAccFor (AttID.supplyVol).setValue (theDblArr);
d67 3
d72 7
a78 1
      return getDblVecInAttAccFor (AttID.supplyVol).getValue ();
@


1.25
log
@Implemented of class DblVecOutAttAcc.
@
text
@d31 1
a31 1
// supplyVol ()
d33 2
a34 2
// Locates the DblVecInAttAcc for this Part's Problem, associates it with the
// supplyVol attribute of this Part and then returns it.
d37 1
a37 1
   public final DblVecInAttAcc supplyVol ()
d39 16
a54 3
      mustBeActive ("Part.supplyVol");
      
      return getDblVecInAttAccFor (AttID.supplyVol);
@


1.24
log
@Changed class name DblVecAttAcc to DblVecInAttAcc.
@
text
@d33 1
a33 1
// Retrieves the DblVecInAttAcc for this Part's Problem, associates it with the
@


1.23
log
@Changed class name       AttI to       AttAcc.
Changed class name DblVecAttI to DblVecAttAcc.
@
text
@d33 1
a33 1
// Retrieves the DblVecAttAcc for this Part's Problem, associates it with the
d37 1
a37 1
   public final DblVecAttAcc supplyVol ()
d41 1
a41 1
      return getDblVecAttAccFor (AttID.supplyVol);
@


1.22
log
@Changed name of class       AttRep to       AttI.
Changed name of class DblVecAttRep to DblVecAttI.
@
text
@d33 1
a33 1
// Retrieves the DblVecAttI for this Part's Problem, associates it with the
d37 1
a37 1
   public final DblVecAttI supplyVol ()
d41 1
a41 1
      return getDblVecAttIFor (AttID.supplyVol);
@


1.21
log
@Attributes.
@
text
@d33 2
a34 2
// Causes the DblVecAttRep for this Part's Problem to represent the supplyVol
// attribute of this Part and then returns the DblVecAttRep.
d37 1
a37 1
   public final DblVecAttRep supplyVol ()
d41 1
a41 1
      return getDblVecAttRepFor (AttID.supplyVol);
@


1.20
log
@Attributes.
@
text
@d31 1
a31 1
// setSupplyVol (...)
d33 2
a34 1
// Wrapper for witSetPartSupplyVolDbl (...).
d37 1
a37 1
   public void setSupplyVol (double[] supplyVolVal)
d39 3
a41 27
      mustBeActive ("Part.setSupplyVol");

      if (supplyVolVal.length != nPeriods ())
         abortWmsg (
              "   Part.setSupplyVol (...) was called with an array whose\n"
            + "   length does not match nPeriods for the Problem.\n"
            + "\n"
            + "      Array Length: "
            + supplyVolVal.length
            + "\n"
            + "      nPeriods:     "
            + nPeriods ());

      getDblVecAttRepFor (AttID.supplyVol).setValue (supplyVolVal);
      }

//------------------------------------------------------------------------------
// getSupplyVol ()
//
// Wrapper for witGetPartSupplyVolDbl (...).
//------------------------------------------------------------------------------

   public double[] getSupplyVol ()
      {
      mustBeActive ("Part.getSupplyVol");

      return getDblVecAttRepFor (AttID.supplyVol).getValue ();
@


1.19
log
@Attributes.
@
text
@d51 1
a51 9
      myProbCoord ().
         myAttMgr ().
            myDblVecAttRep ().
               represent (AttID.supplyVol, this);

      myProbCoord ().
         myAttMgr ().
            myDblVecAttRep ().
               setValue (supplyVolVal);
d62 3
a64 10
      myProbCoord ().
         myAttMgr ().
            myDblVecAttRep ().
               represent (AttID.supplyVol, this);

      return
         myProbCoord ().
            myAttMgr ().
               myDblVecAttRep ().
                  getValue ();
@


1.18
log
@Attributes.
@
text
@a37 2
      AttCI supplyVolCI;

d70 4
a73 10
      AttCI    supplyVolCI;
      double[] supplyVolVal;

      mustBeActive ("Part.getSupplyVol");

      supplyVolCI  = myProbCoord ().myAttMgr ().myAttCIFor (AttID.supplyVol);

      supplyVolVal = new double[nPeriods ()];
      
      supplyVolCI.getDblVec (myPartCI, supplyVolVal);
d75 5
a79 1
      return supplyVolVal;
@


1.17
log
@Created Java class CompMgr.
@
text
@d53 9
a61 3
      supplyVolCI = myProbCoord ().myAttMgr ().myAttCIFor (AttID.supplyVol);

      supplyVolCI.setDblVec (myPartCI, supplyVolVal);
@


1.16
log
@Attributes.
@
text
@d108 1
a108 1
      super (theProbCoord);
@


1.15
log
@Removed class LTPubObject.
@
text
@d135 11
d171 1
a171 1
// The C++ Part interface that belongs to this Part.
@


1.14
log
@Added Java class LTPubObject.
@
text
@d18 4
a21 5
//       LTPubObject
//          Component
//             Part
//                Material
//                Capacity
@


1.13
log
@Added enum AttID.
@
text
@d18 5
a22 4
//       Component
//          Part
//             Material
//             Capacity
@


1.12
log
@Added Java class AttMgr.
@
text
@d38 2
d53 3
a55 4
      myProbCoord ().
         myAttMgr ().
            supplyVolCI ().
               setDblVec (myPartCI, supplyVolVal);
d66 1
d71 2
d75 1
a75 4
      myProbCoord ().
         myAttMgr ().
            supplyVolCI ().
               getDblVec (myPartCI, supplyVolVal);
@


1.11
log
@Comments, etc.
@
text
@d51 4
a54 1
      myProbCoord ().supplyVolCI ().setDblVec (myPartCI, supplyVolVal);
d71 4
a74 1
      myProbCoord ().supplyVolCI ().getDblVec (myPartCI, supplyVolVal);
@


1.10
log
@Attributes
@
text
@d1 7
@


1.9
log
@Attributes.
@
text
@d61 1
a61 1
      myPartCI.getSupplyVol (supplyVolVal);
@


1.8
log
@*** empty log message ***
@
text
@d44 1
a44 1
      myPartCI.setSupplyVol (supplyVolVal);
@


1.7
log
@*** empty log message ***
@
text
@d24 43
@


1.6
log
@*** empty log message ***
@
text
@d20 17
a77 11
// partName ().
//
// Accessor.
//------------------------------------------------------------------------------

   String partName ()
      {
      return partName;
      }

//------------------------------------------------------------------------------
@


1.5
log
@*** empty log message ***
@
text
@d6 1
a6 1
// Represents an part in an implosion problem.
@


1.4
log
@*** empty log message ***
@
text
@d54 3
d100 1
a100 1
   private final PartCI myPartCI;
@


1.3
log
@*** empty log message ***
@
text
@d10 1
a10 1
//    ExportedObject
d48 1
a48 1
// Override from class ExportedObject.
@


1.2
log
@*** empty log message ***
@
text
@d27 3
a29 3
//    theProblem:  The Problem that will own the Part
//    partName:    The partName of the Part
//    isaMaterial: True, iff the Part is a Material.
d32 1
a32 1
   Part (Problem theProblem, String partNameVal, boolean isaMaterial)
d34 1
a34 1
      super (theProblem.myProbCoord ());
d38 1
a38 1
            theProblem.myProblemCI (),
d94 1
a94 1
// The Java interface to the C++ Part that belongs to this Part.
@


1.1
log
@*** empty log message ***
@
text
@d34 1
a34 1
      super (theProblem.myCompMgr ());
@


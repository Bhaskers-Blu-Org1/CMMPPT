head	1.243;
access;
symbols;
locks; strict;
comment	@# @;


1.243
date	2011.08.25.23.20.44;	author rjw;	state Exp;
branches;
next	1.242;

1.242
date	2011.06.03.15.13.36;	author rjw;	state Exp;
branches;
next	1.241;

1.241
date	2011.06.02.18.07.14;	author rjw;	state Exp;
branches;
next	1.240;

1.240
date	2011.06.02.16.02.09;	author rjw;	state Exp;
branches;
next	1.239;

1.239
date	2011.06.01.23.36.49;	author rjw;	state Exp;
branches;
next	1.238;

1.238
date	2011.06.01.23.04.54;	author rjw;	state Exp;
branches;
next	1.237;

1.237
date	2011.05.04.22.15.43;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2011.05.02.18.32.30;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2011.04.08.20.56.40;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2011.04.07.22.11.27;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2011.04.07.21.39.32;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2011.04.07.19.07.43;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2011.04.06.21.56.56;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2011.04.06.20.34.34;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2011.03.31.17.35.47;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2011.03.30.23.23.10;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2011.03.29.23.38.58;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2011.03.28.15.57.22;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2011.03.23.20.30.13;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2011.03.22.22.24.14;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2011.03.19.00.26.23;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2011.03.12.00.30.00;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2011.03.11.23.49.41;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2011.03.03.00.31.08;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2011.03.02.23.53.57;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2011.03.02.22.35.36;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2011.02.28.23.17.51;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2011.02.25.16.07.10;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2011.02.16.21.38.29;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2011.02.16.21.03.21;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2011.02.16.19.55.52;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2011.02.14.19.59.19;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2009.10.01.23.00.54;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2009.10.01.15.59.54;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2009.09.30.19.23.26;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2009.09.30.18.02.10;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2009.09.29.20.43.57;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2009.09.29.19.09.25;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2009.09.25.23.44.30;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2009.09.25.22.42.43;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2009.09.25.20.19.34;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2009.09.25.18.52.37;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2009.09.25.16.22.05;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2009.09.24.21.41.50;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2009.09.18.23.31.38;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2009.07.22.21.49.47;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2009.06.30.21.05.30;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2009.06.29.19.56.31;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2009.06.29.15.18.11;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.05.17.55.44;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2009.05.29.17.59.39;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2009.05.28.20.13.16;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2009.05.26.20.07.12;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2009.05.26.18.31.44;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2009.05.20.18.47.32;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2009.05.12.19.29.51;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2009.05.12.15.57.58;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2009.05.11.22.20.34;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2009.05.08.23.28.39;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2009.05.08.22.13.12;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2009.05.05.20.17.07;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2009.05.05.19.18.40;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2009.04.24.17.42.51;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2009.04.21.20.56.07;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2009.04.20.16.09.12;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2009.04.17.19.51.59;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2009.04.17.15.38.25;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2009.04.16.21.08.39;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2009.04.16.16.11.43;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2009.04.08.23.18.44;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2009.04.07.22.13.29;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2009.04.02.17.49.27;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2009.04.01.21.33.04;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2009.03.30.20.19.55;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2009.03.30.18.15.01;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2009.03.19.20.45.27;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2009.03.13.22.30.59;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2009.03.13.21.08.59;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2009.03.13.19.32.22;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2009.03.13.16.36.09;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2009.03.12.22.45.20;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2009.03.12.19.02.42;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2009.03.06.23.23.05;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2009.03.05.19.09.18;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2009.02.26.16.51.28;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2009.02.25.23.06.45;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2009.02.25.22.13.53;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2009.02.25.18.30.39;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2009.02.20.17.18.45;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2009.02.19.19.51.47;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2009.02.18.17.00.44;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2009.02.17.23.46.02;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2009.02.17.20.59.28;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2009.02.17.19.53.01;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2009.02.17.19.26.13;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2009.02.14.00.51.31;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2009.02.11.18.59.29;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2009.02.10.23.19.30;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2009.02.09.22.50.20;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2009.02.06.22.40.59;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2009.02.04.17.06.04;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2009.01.31.00.56.27;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2009.01.27.19.25.58;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2009.01.27.16.56.21;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2009.01.23.20.38.23;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2009.01.23.20.06.20;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2009.01.23.19.46.29;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2009.01.23.19.32.25;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2009.01.23.18.46.54;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2009.01.22.23.12.42;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2009.01.21.21.43.25;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2009.01.21.20.31.26;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2009.01.21.20.21.04;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2009.01.20.22.05.03;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2009.01.16.23.45.56;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2009.01.16.22.47.10;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2009.01.16.20.55.49;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2009.01.16.17.30.24;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2009.01.16.17.03.36;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2009.01.16.16.32.03;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2009.01.15.22.50.32;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2009.01.15.17.03.29;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2009.01.14.22.24.34;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2009.01.12.17.24.14;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2009.01.08.22.00.09;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2009.01.08.21.13.52;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2009.01.05.19.06.01;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2009.01.05.17.28.57;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2008.12.24.20.34.22;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2008.12.24.00.18.56;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2008.12.23.15.30.36;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2008.12.22.20.21.39;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.22.17.12.09;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2008.12.18.23.03.42;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2008.12.18.22.12.34;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2008.12.18.22.00.08;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2008.12.18.20.39.34;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2008.12.18.20.06.54;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2008.12.18.17.02.11;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2008.12.16.23.43.04;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2008.12.16.16.13.30;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2008.12.15.22.31.41;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2008.12.15.15.35.34;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.12.22.53.06;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.11.23.39.51;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2008.12.11.22.21.52;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.11.21.54.03;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2008.12.11.21.37.15;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2008.12.11.19.06.23;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2008.12.11.17.01.29;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2008.12.11.16.48.31;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2008.12.10.23.10.15;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2008.12.10.22.27.43;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2008.12.10.20.54.10;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2008.12.10.19.20.41;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2008.12.10.18.49.23;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2008.12.09.22.58.42;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.09.18.38.19;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2008.12.04.18.55.08;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2008.12.04.16.56.33;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2008.12.03.23.02.21;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.03.18.55.08;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.26.20.11.00;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.26.14.48.19;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2008.11.25.21.58.17;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.25.21.04.03;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.25.20.47.40;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.25.20.25.12;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.25.20.11.08;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.25.19.37.04;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.25.19.24.17;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.25.19.01.44;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.25.16.39.38;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.25.15.28.48;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.20.22.07.23;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.13.23.36.14;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.05.23.14.56;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.05.19.25.33;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.05.17.12.28;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.05.16.52.13;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.04.23.08.00;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.04.22.22.24;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.10.31.14.53.29;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.27.20.43.48;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.11.00.10.38;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2008.10.10.17.33.18;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.09.21.20.22;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.07.18.50.28;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.06.22.14.07;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.06.14.52.40;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.02.15.13.51;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.30.15.17.42;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.26.22.21.26;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.19.22.21.37;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.19.21.59.27;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.19.16.29.51;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.18.16.01.32;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.17.21.42.24;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.17.21.01.37;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.17.19.10.19;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.16.22.21.40;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.09.16.22.14.01;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.15.16.20.40;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.12.19.44.33;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.12.16.09.37;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.09.11.20.16.25;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.11.19.10.26;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.11.15.20.54;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.10.21.32.35;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.09.19.00.01;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.09.16.27.07;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.09.15.15.31;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.08.19.45.36;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.05.22.06.52;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.05.15.53.04;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.03.20.18.07;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.03.18.03.08;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.28.18.30.38;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.19.22.14.33;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.18.22.16.58;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.06.18.48.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.31.15.52.01;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.30.22.05.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.18.15.49.41;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.10.21.44.25;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.09.15.45.40;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.30.22.02.11;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.30.19.56.05;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.27.16.34.07;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.19.19.31.14;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.17.13.38.08;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.16.20.41.02;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.13.18.09.32;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.13.15.57.10;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.12.14.54.24;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.22.21.23.00;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.19.19.04.43;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.19.18.20.08;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.16.14.37.27;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.15.22.11.58;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.15.19.45.19;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.21.06.37;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.243
log
@Revisions for the removal of COIN from WIT.
@
text
@
//==============================================================================
// WIT-J Java Source File Problem.java.
//==============================================================================

package       com.ibm.witj;

import static com.ibm.witj.Utility.*;
import static com.ibm.witj.Attribute.*;
import static com.ibm.witj.CompClassID.*;

import       java.util.*;

//==============================================================================
// Class Problem
//
// The governing interface class of WIT-J.
// Each instance of class Problem corresponds to a WitRun.
//
// Class Hierarchy:
//
// ThreadedObject
//    PreservedObject
//       Component
//          Problem
//==============================================================================

public final class Problem extends Component
{
//==============================================================================
// Public Methods
//==============================================================================

//------------------------------------------------------------------------------
// newInstance ()
//
// Factory method:
//    Constructs a new Problem and returns it.
//------------------------------------------------------------------------------

   public static Problem newInstance ()
      {
      try
         {
         Coordinator theCoord;

         notAllowedWhenTerminated ("Problem.newInstance");

         theCoord = new Coordinator (false);

         return theCoord.getProblem ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// clearData ()
//
// Restores this Problem to a base state:
//    Invokes witInitialize on the underlying WitRun.
//    All Components owned by this Problem except itself are removed from this
//       Problem and deactivatived.
//    All global Attributes are restored to their default values.
//    The state of the message system is left unchanged.
//------------------------------------------------------------------------------

   public void clearData ()
      {
      try
         {
         mustBeActive ("Problem.clearData");

         getCoordinator ().clearData ();

         nPeriods = 26;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// performAction (theCommand)
//
// Performs the action indicated by theCommand.
//------------------------------------------------------------------------------

   public void performAction (String theCommand)
      {
      try
         {
         mustBeActive ("Problem.performAction");

         if (isForCpp (theCommand))
            {
            myProblemCOR.performAction (theCommand);
            }

         else if (theCommand.equals ("self-test"))
            {
            Coordinator.selfTest ();
            }

         else if (theCommand.equals ("fail-java-assert"))
            {
            assert (false);
            }

         else if (theCommand.equals ("exhaust-memory-in-witj-java"))
            {
            exhaustMemory ();
            }

         else if (theCommand.equals ("throw-unexpected-java-throwable"))
            {
            Coordinator theCoord;

            theCoord = null;

            theCoord.getPart ("No Part");
            }

         else if (theCommand.equals ("throw-unexpected-c++-exception"))
            {
            myProblemCOR.throwUnexpException ();
            }

         else if (theCommand.equals ("call-unimplemented-native-method"))
            {
            myProblemCOR.notImplemented ();
            }

         else
            {
            throw
               new StatusQuoException (
                  "   Problem.performAction (theCommand) was called\n"
                + "   with an unrecoginized command string.\n"
                + "\n"
                + "      Command: \"" + theCommand + "\"");
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// Wrappers for WIT API Functions:
//------------------------------------------------------------------------------

   public void addDblCplexParSpec (String theName, double theValue)
      {
      try
         {
         mustBeActive ("Problem.addDblCplexParSpec");

         myProblemCOR.addDblCplexParSpec (theName, theValue);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void addIntCplexParSpec (String theName, int theValue)
      {
      try
         {
         mustBeActive ("Problem.addIntCplexParSpec");

         myProblemCOR.addIntCplexParSpec (theName, theValue);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void buildPip ()
      {
      try
         {
         mustBeActive ("Problem.buildPip");

         callSimpleWitFunc ("witBuildPip");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void clearCplexParSpecs ()
      {
      try
         {
         mustBeActive ("Problem.clearCplexParSpecs");

         callSimpleWitFunc ("witClearCplexParSpecs");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void clearPegging ()
      {
      try
         {
         mustBeActive ("Problem.clearPegging");

         callSimpleWitFunc ("witClearPegging");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void clearPipSeq ()
      {
      try
         {
         mustBeActive ("Problem.clearPipSeq");

         callSimpleWitFunc ("witClearPipSeq");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void clearStochSoln ()
      {
      try
         {
         mustBeActive ("Problem.clearStochSoln");

         callSimpleWitFunc ("witClearStochSoln");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void copyData (Problem origProblem)
      {
      try
         {
         ProblemCOR origProblemCOR;

         mustBeActive                             ("Problem.copyData");
         mustBeActive (origProblem, "origProblem", "Problem.copyData");

         if (origProblem == this)
            return;

         getCoordinator ().clearData ();

         origProblemCOR = origProblem.myProblemCOR;

         myProblemCOR.copyData (origProblemCOR);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void displayData (String fileName)
      {
      try
         {
         mustBeActive                        ("Problem.displayData");
         mustBeNonNull (fileName, "fileName", "Problem.displayData");

         myProblemCOR.displayData (fileName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void eqHeurAlloc (
         ArrayList <Demand>  theDemandList,
         ArrayList <Integer> shipPeriodList,
         ArrayList <Double>  desIncVolList,
         ArrayList <Double>  incVolList)
      {
      try
         {
         mustBeActive ("Problem.eqHeurAlloc");

         checkEqHeurAlloc (
            theDemandList,
            shipPeriodList,
            desIncVolList,
            incVolList);

         myProblemCOR.
            eqHeurAlloc (
               theDemandList,
               shipPeriodList,
               desIncVolList,
               incVolList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void evalObjectives ()
      {
      try
         {
         mustBeActive ("Problem.evalObjectives");

         callSimpleWitFunc ("witEvalObjectives");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void finishHeurAlloc ()
      {
      try
         {
         mustBeActive ("Problem.finishHeurAlloc");

         callSimpleWitFunc ("witFinishHeurAlloc");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void generatePriorities ()
      {
      try
         {
         mustBeActive ("Problem.generatePriorities");

         callSimpleWitFunc ("witGeneratePriorities");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void getCriticalList (
         ArrayList <Part>    critPartList,
         ArrayList <Integer> critPeriodList)
      {
      try
         {
         mustBeActive                        ("Problem.getCriticalList");

         mustBeNonNull (
            critPartList,   "critPartList",   "Problem.getCriticalList");

         mustBeNonNull (
            critPeriodList, "critPeriodList", "Problem.getCriticalList");

         myProblemCOR.getCriticalList (critPartList, critPeriodList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public Double getDblCplexParSpec (String theName)
      {
      try
         {
         mustBeActive                      ("Problem.getDblCplexParSpec");
         mustBeNonNull (theName, "theName", "Problem.getDblCplexParSpec");

         return myProblemCOR.getDblCplexParSpec (theName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void getExpCycle (
         ArrayList <Part>      thePartList,
         ArrayList <Operation> theOpnList)
      {
      try
         {
         mustBeActive                  ("Problem.getExpCycle");

         mustBeNonNull (
            thePartList, "thePartList", "Problem.getExpCycle");

         mustBeNonNull (
            theOpnList,  "theOpnList",  "Problem.getExpCycle");

         myProblemCOR.getExpCycle (thePartList, theOpnList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public Integer getIntCplexParSpec (String theName)
      {
      try
         {
         mustBeActive                      ("Problem.getIntCplexParSpec");
         mustBeNonNull (theName, "theName", "Problem.getIntCplexParSpec");

         return myProblemCOR.getIntCplexParSpec (theName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public ArrayList <String> getObjectiveList ()
      {
      try
         {
         ArrayList <String> theObjNameList;

         mustBeActive ("Problem.getObjectiveList");

         theObjNameList = new ArrayList <String> (0);

         myProblemCOR.getObjectiveList (theObjNameList);

         return theObjNameList;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public OptInitMethod getOptInitMethod ()
      {
      try
         {
         String theMethodName;

         mustBeActive ("Problem.getOptInitMethod");

         theMethodName = myProblemCOR.getOptInitMethod ();

         return OptInitMethod.valueOf (theMethodName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void getPgdCritList (
         ArrayList <Part>    critPartList,
         ArrayList <Integer> critPeriodList,
         ArrayList <Demand>  theDemandList,
         ArrayList <Integer> shipPeriodList)
      {
      try
         {
         mustBeActive                        ("Problem.getPgdCritList");

         mustBeNonNull (
            critPartList,   "critPartList",   "Problem.getPgdCritList");

         mustBeNonNull (
            critPeriodList, "critPeriodList", "Problem.getPgdCritList");

         mustBeNonNull (
            theDemandList,  "theDemandList",  "Problem.getPgdCritList");

         mustBeNonNull (
            shipPeriodList, "shipPeriodList", "Problem.getPgdCritList");

         myProblemCOR.
            getPgdCritList (
               critPartList,
               critPeriodList,
               theDemandList,
               shipPeriodList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public ArrayList <PeggingTriple <Demand>> getPipSeq ()
      {
      try
         {
         ArrayList <PeggingTriple <Demand>> theDemandTripList;

         mustBeActive ("Problem.getPipSeq");

         theDemandTripList = new ArrayList <PeggingTriple <Demand>> (0);

         myProblemCOR.getPipSeq (theDemandTripList);

         return theDemandTripList;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getSortedOperations ()
//
// Returns a list of all Operations in this Problem, sorted (by WIT) in BOM
// order.
//------------------------------------------------------------------------------

   public ArrayList <Operation> getSortedOperations ()
      {
      try
         {
         ArrayList <Operation> theOpnList;

         mustBeActive ("Problem.getSortedOperations");

         theOpnList = new ArrayList <Operation> (0);

         myProblemCOR.getSortedOperations (theOpnList);

         return theOpnList;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getSortedParts ()
//
// Returns a list of all Parts in this Problem, sorted (by WIT) in BOM order.
//------------------------------------------------------------------------------

   public ArrayList <Part> getSortedParts ()
      {
      try
         {
         ArrayList <Part> thePartList;

         mustBeActive ("Problem.getSortedParts");

         thePartList = new ArrayList <Part> (0);

         myProblemCOR.getSortedParts (thePartList);

         return thePartList;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void heurImplode ()
      {
      try
         {
         mustBeActive ("Problem.heurImplode");

         callSimpleWitFunc ("witHeurImplode");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void mrp ()
      {
      try
         {
         mustBeActive ("Problem.mrp");

         callSimpleWitFunc ("witMrp");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void optImplode ()
      {
      try
         {
         mustBeActive ("Problem.optImplode");

         callSimpleWitFunc ("witOptImplode");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void postprocess ()
      {
      try
         {
         mustBeActive ("Problem.postprocess");

         callSimpleWitFunc ("witPostprocess");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void preprocess ()
      {
      try
         {
         mustBeActive ("Problem.preprocess");

         callSimpleWitFunc ("witPreprocess");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void purgeData ()
      {
      try
         {
         mustBeActive ("Problem.purgeData");

         callSimpleWitFunc ("witPurgeData");

         getCoordinator ().restoreAfterPurge ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// readData (fileName)
//
// Calls witReadData on fileName and copies the resulting structure into this
// Problem and the corresponding C++ Problem.
// The call to the underlying native method is globally synchronized with all
// other such calls. This prevents asynchronous calls to witReadData, which are
// not allowed.
//------------------------------------------------------------------------------

   public void readData (String fileName)
      {
      try
         {
         mustBeActive                        ("Problem.readData");
         mustBeNonNull (fileName, "fileName", "Problem.readData");

         if (getCoordinator ().hasPartsOrOperations ())
            {
            throw
               new StatusQuoException (
                  "   Problem.readData was called with a Problem\n"
                + "   that has one or more Parts or Operations.");
            }

         synchronized (readDataLock)
            {
            myProblemCOR.readData (fileName);
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void setObjectiveList (String... theObjNames)
      {
      try
         {
         ArrayList <String> theObjNameList;

         theObjNameList = new ArrayList <String> (Arrays.asList (theObjNames));

         setObjectiveList (theObjNameList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void setObjectiveList (ArrayList <String> theObjNameList)
      {
      try
         {
         checkArrayListArg (
            theObjNameList,
           "theObjNameList",
           "Problem.setObjectiveList");

         myProblemCOR.setObjectiveList (theObjNameList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void setOptInitMethod (OptInitMethod theMethod)
      {
      try
         {
         mustBeActive ("Problem.setOptInitMethod");

         myProblemCOR.setOptInitMethod (theMethod.name ());
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void shutDownHeurAlloc ()
      {
      try
         {
         mustBeActive ("Problem.shutDownHeurAlloc");

         callSimpleWitFunc ("witShutDownHeurAlloc");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void startHeurAlloc ()
      {
      try
         {
         mustBeActive ("Problem.startHeurAlloc");

         callSimpleWitFunc ("witStartHeurAlloc");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void stochImplode ()
      {
      try
         {
         mustBeActive ("Problem.stochImplode");

         callSimpleWitFunc ("witStochImplode");
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void writeCriticalList (
         String     fileName,
         FileFormat theFormat,
         int        maxListLen)
      {
      try
         {
         boolean theFormatIsBSV;

         mustBeActive                          ("Problem.writeCriticalList");
         mustBeNonNull (fileName,  "fileName",  "Problem.writeCriticalList");
         mustBeNonNull (theFormat, "theFormat", "Problem.writeCriticalList");

         theFormatIsBSV = (theFormat == FileFormat.BSV);

         myProblemCOR.writeCriticalList (fileName, theFormatIsBSV, maxListLen);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void writeData (String fileName)
      {
      try
         {
         mustBeActive                        ("Problem.writeData");
         mustBeNonNull (fileName, "fileName", "Problem.writeData");

         myProblemCOR.writeData (fileName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void writeExecSched (String fileName, FileFormat theFormat)
      {
      try
         {
         boolean theFormatIsBSV;

         mustBeActive                          ("Problem.writeExecSched");
         mustBeNonNull (fileName,  "fileName",  "Problem.writeExecSched");
         mustBeNonNull (theFormat, "theFormat", "Problem.writeExecSched");

         theFormatIsBSV = (theFormat == FileFormat.BSV);

         myProblemCOR.writeSched ("Exec", fileName, theFormatIsBSV);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void writeReqSched (String fileName, FileFormat theFormat)
      {
      try
         {
         boolean theFormatIsBSV;

         mustBeActive                          ("Problem.writeReqSched");
         mustBeNonNull (fileName,  "fileName",  "Problem.writeReqSched");
         mustBeNonNull (theFormat, "theFormat", "Problem.writeReqSched");

         theFormatIsBSV = (theFormat == FileFormat.BSV);

         myProblemCOR.writeSched ("Req", fileName, theFormatIsBSV);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void writeShipSched (String fileName, FileFormat theFormat)
      {
      try
         {
         boolean theFormatIsBSV;

         mustBeActive                          ("Problem.writeShipSched");
         mustBeNonNull (fileName,  "fileName",  "Problem.writeShipSched");
         mustBeNonNull (theFormat, "theFormat", "Problem.writeShipSched");

         theFormatIsBSV = (theFormat == FileFormat.BSV);

         myProblemCOR.writeSched ("Ship", fileName, theFormatIsBSV);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getComponents ()
//
// Returns an unmodifiable List of all Components that belong to this Problem,
// listed in creation order.
//------------------------------------------------------------------------------

   public List <Component> getComponents ()
      {
      try
         {
         mustBeActive ("Problem.getComponents");

         return getCoordinator ().getComponents ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getParts       ()
// getDemands     ()
// getOperations  ()
// getBomEntries  ()
// getSubstitutes ()
// getBopEntries  ()
//
// Each of these methods returns an unmodifiable List of all the instances of
// the indicated Component class that belong to this Problem, listed in creation
// order.
//------------------------------------------------------------------------------

   public List <Part> getParts ()
      {
      try
         {
         mustBeActive ("Problem.getParts");

         return getCoordinator ().getInstances (Part.class, PART);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public List <Demand> getDemands ()
      {
      try
         {
         mustBeActive ("Problem.getDemands");

         return getCoordinator ().getInstances (Demand.class, DEMAND);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public List <Operation> getOperations ()
      {
      try
         {
         mustBeActive ("Problem.getOperations");

         return getCoordinator ().getInstances (Operation.class, OPERATION);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public List <BomEntry> getBomEntries ()
      {
      try
         {
         mustBeActive ("Problem.getBomEntries");

         return getCoordinator ().getInstances (BomEntry.class, BOM_ENTRY);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public List <Substitute> getSubstitutes ()
      {
      try
         {
         mustBeActive ("Problem.getSubstitutes");

         return getCoordinator ().getInstances (Substitute.class, SUBSTITUTE);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public List <BopEntry> getBopEntries ()
      {
      try
         {
         mustBeActive ("Problem.getBopEntries");

         return getCoordinator ().getInstances (BopEntry.class, BOP_ENTRY);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getPart (thePartName)
//                                  
// Returns the Part for this Problem whose PartName matches thePartName, if any;
// otherwise null.
//------------------------------------------------------------------------------

   public Part getPart (String thePartName)
      {
      try
         {
         mustBeActive ("Problem.getPart");

         return getCoordinator ().getPart (thePartName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getOperation (theOpnName)
//                                  
// Returns the Operation for this Problem whose OperationName matches
// theOpnName, if any; otherwise null.
//------------------------------------------------------------------------------

   public Operation getOperation (String theOpnName)
      {
      try
         {
         mustBeActive ("Problem.getOperation");

         return getCoordinator ().getOperation (theOpnName);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getDefaultValue (theAtt) methods
//
// Each of these methods returns the default value for theAtt in the context of
// this Problem.
//------------------------------------------------------------------------------

   public boolean getDefaultValue (Attribute <Boolean> theAtt)
      {
      try
         {
         checkForDefault (theAtt);

         assert (theAtt.hasSpecDefValue ());

         return theAtt.getSpecDefValue ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public int getDefaultValue (Attribute <Integer> theAtt)
      {
      try
         {
         checkForDefault (theAtt);

         if (theAtt.hasSpecDefValue ())
            {
            return theAtt.getSpecDefValue ();
            }
         else
            {
            assert (theAtt == latestPeriod);

            return nPeriods - 1;
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public double getDefaultValue (Attribute <Double> theAtt)
      {
      try
         {
         checkForDefault (theAtt);

         return theAtt.getSpecDefValue ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public String getDefaultValue (Attribute <String> theAtt)
      {
      try
         {
         checkForDefault (theAtt);

         return theAtt.getSpecDefValue ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getDefaultValue (theAtt, theArray) methods
//
// Each of these methods copies the default value for theAtt into theArray.
// theArray must be of length nPeriods for this Problem.
//------------------------------------------------------------------------------

   public void getDefaultValue (
         Attribute <boolean[]> theAtt,
         boolean[]             theBoolArr)
      {
      try
         {
         boolean theDefVal;
         int     theIdx;

         checkForDefault  (theAtt);
      
         mustBeNonNull    (theBoolArr, "theBoolArr", "Problem.getDefaultValue");

         checkArrayLength (theAtt, theBoolArr.length);

         theDefVal = theAtt.getSpecDefValue ()[0];

         for (theIdx = 0; theIdx < theBoolArr.length; theIdx ++)
            {
            theBoolArr[theIdx] = theDefVal;
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void getDefaultValue (
         Attribute <int[]> theAtt,
         int[]             theIntArr)
      {
      try
         {
         int theDefVal = -1;
         int theIdx;

         checkForDefault  (theAtt);
      
         mustBeNonNull    (theIntArr, "theIntArr", "Problem.getDefaultValue");

         checkArrayLength (theAtt, theIntArr.length);

         if (theAtt.hasSpecDefValue ())
            {
            theDefVal = theAtt.getSpecDefValue ()[0];
            }
         else
            {
            assert (   (theAtt == buildAheadUB)
                    || (theAtt == leadTimeUB)
                    || (theAtt == shipLateUB));

            theDefVal = nPeriods - 1;
            }

         for (theIdx = 0; theIdx < theIntArr.length; theIdx ++)
            {
            theIntArr[theIdx] = theDefVal;
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------

   public void getDefaultValue (
         Attribute <double[]> theAtt,
         double[]             theDblArr)
      {
      try
         {
         double theDefVal;
         int    theIdx;

         checkForDefault  (theAtt);
      
         mustBeNonNull    (theDblArr, "theDblArr", "Problem.getDefaultValue");

         checkArrayLength (theAtt, theDblArr.length);

         theDefVal = theAtt.getSpecDefValue ()[0];

         for (theIdx = 0; theIdx < theDblArr.length; theIdx ++)
            {
            theDblArr[theIdx] = theDefVal;
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getDefaultValue (theAtt, hardLBArr, softLBArr, hardUBArr)
//
// Given a BoundSet Attribute, theAtt, this method sets the 3 argument arrays to
// their respective default values.
// The arrays must be of length nPeriods for this Problem.
//------------------------------------------------------------------------------

   public void getDefaultValue (
         Attribute <BoundSet> theAtt,
         double[]             hardLBArr,
         double[]             softLBArr,
         double[]             hardUBArr)
      {
      try
         {
         int theIdx;

         checkForDefault  (theAtt);

         mustBeNonNull    (hardLBArr, "hardLBArr", "Problem.getDefaultValue");
         mustBeNonNull    (softLBArr, "softLBArr", "Problem.getDefaultValue");
         mustBeNonNull    (hardUBArr, "hardUBArr", "Problem.getDefaultValue");

         checkArrayLength (theAtt, hardLBArr.length);
         checkArrayLength (theAtt, softLBArr.length);
         checkArrayLength (theAtt, hardUBArr.length);

         assert (! theAtt.hasSpecDefValue ());

         for (theIdx = 0; theIdx < nPeriods; theIdx ++)
            {
            hardLBArr[theIdx] =  0.0;
            softLBArr[theIdx] =  0.0;
            hardUBArr[theIdx] = -1.0;
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// deactivate ()
//
// Puts this Problem and the PreservedObjects that it owns into an inactive
// state. This Problem and the PreservedObjects that it owns cannot be
// garbage-collected until this method is called.
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   public void deactivate ()
      {
      try
         {
         mustBeActive ("Problem.deactivate");

         myProblemCOR     .deactivate ();
         getCoordinator ().deactivate ();
         super            .deactivate ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   public MessageMgr getMessageMgr ()
      {
      try
         {
         mustBeActive ("Problem.getMessageMgr");

         return getCoordinator ().getMessageMgr ();
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//==============================================================================
// Package-Internal Constructor
//==============================================================================

   Problem (Coordinator theCoord)
      {
      super (theCoord);

      nPeriods     = 26;

      myProblemCOR = new ProblemCOR (theCoord.getCoordinatorCOR ());
      }

//==============================================================================
// Package-Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// toStringActive ().
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   String toStringActive ()
      {
      return "Problem";
      }

//------------------------------------------------------------------------------
// getCompClassID ()
//
// Override from class Component.
//------------------------------------------------------------------------------

   CompClassID getCompClassID ()
      {
      return CompClassID.PROBLEM;
      }

//------------------------------------------------------------------------------
// getComponentCOR ().
//
// Override from class Component.
//------------------------------------------------------------------------------

   ComponentCOR getComponentCOR ()
      {
      return myProblemCOR;
      }

//------------------------------------------------------------------------------
// setNPeriods (theValue)
//
// Setter for nPeriods.
//------------------------------------------------------------------------------

   void setNPeriods (int theValue)
      {
      assert (! getCoordinator ().hasPartsOrOperations ());

      myProblemCOR.setNPeriods (theValue);

      nPeriods = theValue;
      }

//------------------------------------------------------------------------------
// getNPeriods ()
//
// Accessor.
//------------------------------------------------------------------------------

   int getNPeriods ()
      {
      return nPeriods;
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   ProblemCOR getProblemCOR ()
      {
      return myProblemCOR;
      }

//==============================================================================
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// callSimpleWitFunc
//
// Calls the simple WIT API function whose name is given by theFuncName.
// Asserts that such a function has been defined.
//------------------------------------------------------------------------------

   private void callSimpleWitFunc (String theFuncName)
      {
      myProblemCOR.callSimpleWitFunc (theFuncName);
      }

//------------------------------------------------------------------------------
// isForCpp (theCommand)
//
// Returns true, iff theCommand is to be passed through to the C++ side of
// WIT-J.
//------------------------------------------------------------------------------

   private boolean isForCpp (String theCommand)
      {
      return
         theCommand.equals ("fail-c++-exception-assert")  ||
         theCommand.equals ("fail-c++-aborting-assert")   ||
         theCommand.equals ("exhaust-memory-in-witj-c++") ||
         theCommand.equals ("trigger-jni-exception")      ||
         theCommand.equals ("exhaust-memory-in-jni")      ||
         theCommand.equals ("exhaust-memory-in-wit")      ||
         theCommand.equals ("trigger-wit-fatal-message");
      }

//------------------------------------------------------------------------------
// exhaustMemory ()
//
// Repeatedly allocates memory in 100MB increments until memory is exhausted.
// Used for testing.
//------------------------------------------------------------------------------

   private void exhaustMemory ()
      {
      LinkedList <byte[]> the100MBChunks;
      int                 totDiscarded;
      byte[]              the100MB;

      the100MBChunks = new LinkedList <byte[]> ();

      for (totDiscarded = 100; true; totDiscarded += 100)
         {
         the100MB = new byte[104857600];

         the100MBChunks.addLast (the100MB);

         println (
            totDiscarded + "MB of memory have been allocated by WIT-J/Java.");
         }
      }

//------------------------------------------------------------------------------
// checkForDefault (theAtt)
//
// Checks the validity of a call to a getDefaultValue method.
//------------------------------------------------------------------------------

   private void checkForDefault (Attribute <?> theAtt)
      {
      mustBeActive ("Problem.getDefaultValue");

      if (! theAtt.hasDefaultValue ())
         throw
            new StatusQuoException (
               "   Problem.getDefaultValue was called with\n"
             + "   an Attribute that does not have a default value.");
      }

//------------------------------------------------------------------------------
// checkArrayLength (theAtt, methodName, theLength)
//
// Verifies that theLength == nPeriods for setting/getting a vector attribute.
// methodName is the name of the calling method.
//------------------------------------------------------------------------------

   private void checkArrayLength (Attribute <?> theAtt, int theLength)
      {
      if (theLength != nPeriods)
         throw
            new StatusQuoException (
               "   Problem.getDefaultValue was called with an array\n"
             + "   whose length does not match nPeriods for the Problem.\n"
             + "\n"
             + "      Attribute:    " + theAtt       + "\n"
             + "      Array Length: " + theLength    + "\n"
             + "      nPeriods:     " + nPeriods);
      }

//------------------------------------------------------------------------------
// checkEqHeurAlloc
//
// Checks the arguments to eqHeurAlloc..
//------------------------------------------------------------------------------

   private void checkEqHeurAlloc (
         ArrayList <Demand>  theDemandList,
         ArrayList <Integer> shipPeriodList,
         ArrayList <Double>  desIncVolList,
         ArrayList <Double>  incVolList)
      {
      checkDemandListArg (
         theDemandList,
        "Problem.eqHeurAlloc");

      checkArrayListArg (
         shipPeriodList,
        "shipPeriodList",
        "Problem.eqHeurAlloc");

      sizeMustMatch (
         shipPeriodList,
        "shipPeriodList",
         theDemandList,
        "theDemandList",
        "Problem.eqHeurAlloc");

      checkArrayListArg (
         desIncVolList,
        "desIncVolList",
        "Problem.eqHeurAlloc");

      sizeMustMatch (
         desIncVolList,
        "desIncVolList",
         theDemandList,
        "theDemandList",
        "Problem.eqHeurAlloc");

      mustBeNonNull (
         incVolList,
        "incVolList",
        "Problem.eqHeurAlloc");
      }

//------------------------------------------------------------------------------
// checkDemandListArg (theDemandList, methName)
//
// Performs error checking for an ArrayList <Demand> argument to a public
// method.
//    theDemandList: The ArrayList <Demand> argument
//    methName:      The name of the method
//------------------------------------------------------------------------------

   private void checkDemandListArg (
         ArrayList <Demand> theDemandList, 
         String             methName)
      {     
      int    theIdx;
      Demand theDemand;

      checkArrayListArg (theDemandList, "theDemandList", methName);

      for (theIdx = 0; theIdx < theDemandList.size (); theIdx ++)
         {
         theDemand = theDemandList.get (theIdx);

         if (! theDemand.isActive ())
            throw
               new StatusQuoException (
                  "   A method was called with an ArrayList <Demand> argument\n"
                + "   that contained an inactive Demand.\n"
                + "\n"
                + "      Method:     " + methName + "\n"
                + "      Argument:   theDemandList\n"
                + "      List Index: " + theIdx);

          if (theDemand.getCoordinator () != getCoordinator ())
            throw
               new StatusQuoException (
                  "   A method was called with an ArrayList <Demand> argument\n"
                + "   that contained a Demand that did not belong to\n"
                + "   the Problem on which the method was called.\n"
                + "\n"
                + "      Method:     " + methName + "\n"
                + "      Argument:   theDemandList\n"
                + "      List Index: " + theIdx   + "\n"
                + "      Demand:     " + theDemand);
         }
      }

//------------------------------------------------------------------------------
// checkArrayListArg (theArrayList, argName, methName)
//
// Performs error checking for an ArrayList argument to a public method.
//    theArrayList: The ArrayList argument
//    argName:      The name of ArrayList argument
//    methName:     The name of the method
//------------------------------------------------------------------------------

   private void checkArrayListArg (
         ArrayList <?> theArrayList,
         String        argName,
         String        methName)
      {     
      int    theIdx;
      Object theElem;

      mustBeNonNull (theArrayList, argName, methName);

      for (theIdx = 0; theIdx < theArrayList.size (); theIdx ++)
         {
         theElem = theArrayList.get (theIdx);

         if (theElem == null)
            throw
               new StatusQuoException (
                  "   A method was called with an ArrayList argument\n"
                + "   that contained a null reference.\n"
                + "\n"
                + "      Method:     " + methName + "\n"
                + "      Argument:   " + argName  + "\n"
                + "      List Index: " + theIdx);
         }
      }

//------------------------------------------------------------------------------
// sizeMustMatch (theArrayList2, arg2Name, theArrayList1, arg1Name, methName)
//
// Verifies that two ArrayList arguments are the same size.
//------------------------------------------------------------------------------

   private void sizeMustMatch (
         ArrayList <?> theArrayList2,
         String        arg2Name,
         ArrayList <?> theArrayList1,
         String        arg1Name,
         String        methName)
      {
      if (theArrayList2.size () != theArrayList1.size ())
         throw
            new StatusQuoException (
               "   A method was called with two ArrayList arguments "
             +    "whose sizes do not match.\n"
             + "\n"
             + "      Method:           " + methName              + "\n"
             + "      First  ArrayList: " + arg1Name              + "\n"
             + "         Size:          " + theArrayList1.size () + "\n"
             + "      Second ArrayList: " + arg2Name              + "\n"
             + "         Size:          " + theArrayList2.size ());

      }
      
//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// readDataLock
//
// The synchronization lock for this Object is used to globally synchronize all
// calls to readData.
//------------------------------------------------------------------------------

   private static final Object readDataLock = new Object ();

//------------------------------------------------------------------------------
// nPeriods
//
// Cached copy of the value stored in WIT.
//------------------------------------------------------------------------------

   private int nPeriods;

//------------------------------------------------------------------------------
// myProblemCOR.
//
// The ProblemCOR that belongs to this Problem.
//------------------------------------------------------------------------------

   private final ProblemCOR myProblemCOR;

//==============================================================================
}
@


1.242
log
@Removed Pair and Quadruple.
@
text
@d1204 1
a1204 19
         if (theAtt.hasSpecDefValue ())
            {
            return theAtt.getSpecDefValue ();
            }
         else
            {
            if      (theAtt == cplexSelected)
               {
               return get (cplexEmbedded);
               }
            else if (theAtt == coinSelected)
               {
               return
                       get  (coinEmbedded)
                  && ! get (cplexEmbedded);
               }
            else
               {
               assert (false);
d1206 1
a1206 3
               return false;
               }
            }
@


1.241
log
@getPgdCritList
@
text
@d407 3
a409 1
   public List <Pair <Part, Integer>> getCriticalList ()
d413 1
a413 2
         ArrayList <Part>    critPartList;
         ArrayList <Integer> critPeriodList;
d415 2
a416 1
         mustBeActive ("Problem.getCriticalList");
d418 2
a419 2
         critPartList   = new ArrayList <Part>    (0);
         critPeriodList = new ArrayList <Integer> (0);
a421 2

         return Pair.newList          (critPartList, critPeriodList);
d450 3
a452 1
   public List <Pair <Part, Operation>> getExpCycle ()
d456 1
a456 2
         ArrayList <Part>      thePartList;
         ArrayList <Operation> theOpnList;
d458 2
a459 1
         mustBeActive ("Problem.getExpCycle");
d461 2
a462 2
         thePartList = new ArrayList <Part>      (0);
         theOpnList  = new ArrayList <Operation> (0);
a464 2
         
         return Pair.newList      (thePartList, theOpnList);
d537 5
a541 1
   public List <Quadruple <Part, Integer, Demand, Integer>> getPgdCritList ()
d545 7
a551 4
         ArrayList <Part>    critPartList;
         ArrayList <Integer> critPeriodList;
         ArrayList <Demand>  theDemandList;
         ArrayList <Integer> shipPeriodList;
d553 2
a554 1
         mustBeActive ("Problem.getPgdCritList");
d556 2
a557 4
         critPartList   = new ArrayList <Part>    (0);
         critPeriodList = new ArrayList <Integer> (0);
         theDemandList  = new ArrayList <Demand>  (0);
         shipPeriodList = new ArrayList <Integer> (0);
a564 7

         return
            Quadruple.newList (
               critPartList,
               critPeriodList,
               theDemandList,
               shipPeriodList);
@


1.240
log
@Pair
@
text
@d421 1
a421 1
         return Pair.newArrayList     (critPartList, critPeriodList);
d464 1
a464 1
         return Pair.newArrayList (thePartList, theOpnList);
d537 1
a537 5
   public void getPgdCritList (
         ArrayList <Part>    critPartList,
         ArrayList <Integer> critPeriodList,
         ArrayList <Demand>  theDemandList,
         ArrayList <Integer> shipPeriodList)
d541 4
a544 4
         mustBeActive                        ("Problem.getPgdCritList");

         mustBeNonNull (
            critPartList,   "critPartList",   "Problem.getPgdCritList");
d546 1
a546 2
         mustBeNonNull (
            critPeriodList, "critPeriodList", "Problem.getPgdCritList");
d548 4
a551 5
         mustBeNonNull (
            theDemandList,  "theDemandList",  "Problem.getPgdCritList");

         mustBeNonNull (
            shipPeriodList, "shipPeriodList", "Problem.getPgdCritList");
d559 7
@


1.239
log
@getExpCycle
@
text
@d450 1
a450 1
   public ArrayList <Pair <Part, Operation>> getExpCycle ()
@


1.238
log
@Revised getCriticalList
@
text
@d450 1
a450 3
   public void getExpCycle (
         ArrayList <Part>      thePartList,
         ArrayList <Operation> theOpnList)
d454 2
a455 1
         mustBeActive                  ("Problem.getExpCycle");
d457 1
a457 2
         mustBeNonNull (
            thePartList, "thePartList", "Problem.getExpCycle");
d459 2
a460 2
         mustBeNonNull (
            theOpnList,  "theOpnList",  "Problem.getExpCycle");
d463 2
@


1.237
log
@setValue ==> set
getValue ==> get
@
text
@d407 1
a407 3
   public void getCriticalList (
         ArrayList <Part>    critPartList,
         ArrayList <Integer> critPeriodList)
d411 2
a412 1
         mustBeActive                        ("Problem.getCriticalList");
d414 1
a414 2
         mustBeNonNull (
            critPartList,   "critPartList",   "Problem.getCriticalList");
d416 2
a417 2
         mustBeNonNull (
            critPeriodList, "critPeriodList", "Problem.getCriticalList");
d420 2
@


1.236
log
@Reduced heading comments.
@
text
@d1212 1
a1212 1
               return getValue (cplexEmbedded);
d1217 2
a1218 2
                       getValue  (coinEmbedded)
                  && ! getValue (cplexEmbedded);
@


1.235
log
@copyComponentData
@
text
@a3 2
//
// Contains the declaration of class Problem.
@


1.234
log
@getSortedOperations
@
text
@d281 1
a281 1
   public void copyData (Problem srcProblem)
d285 1
a285 1
         ProblemCOR srcProblemCOR;
d287 2
a288 2
         mustBeActive                           ("Problem.copyData");
         mustBeActive (srcProblem, "srcProblem", "Problem.copyData");
d290 1
a290 1
         if (srcProblem == this)
d295 1
a295 1
         srcProblemCOR = srcProblem.myProblemCOR;
d297 1
a297 1
         myProblemCOR.copyData (srcProblemCOR);
@


1.233
log
@getSortedParts
@
text
@d599 28
@


1.232
log
@getExpCycle
@
text
@d599 27
@


1.231
log
@Critical parts list
@
text
@d434 1
a434 5
   public void getPgdCritList (
         ArrayList <Part>    critPartList,
         ArrayList <Integer> critPeriodList,
         ArrayList <Demand>  theDemandList,
         ArrayList <Integer> shipPeriodList)
d438 2
a439 1
         mustBeActive                        ("Problem.getPgdCritList");
d441 1
a441 18
         mustBeNonNull (
            critPartList,   "critPartList",   "Problem.getPgdCritList");

         mustBeNonNull (
            critPeriodList, "critPeriodList", "Problem.getPgdCritList");

         mustBeNonNull (
            theDemandList,  "theDemandList",  "Problem.getPgdCritList");

         mustBeNonNull (
            shipPeriodList, "shipPeriodList", "Problem.getPgdCritList");

         myProblemCOR.
            getPgdCritList (
               critPartList,
               critPeriodList,
               theDemandList,
               shipPeriodList);
d452 3
a454 1
   public Double getDblCplexParSpec (String theName)
d458 7
a464 2
         mustBeActive                      ("Problem.getDblCplexParSpec");
         mustBeNonNull (theName, "theName", "Problem.getDblCplexParSpec");
d466 1
a466 1
         return myProblemCOR.getDblCplexParSpec (theName);
d539 38
@


1.230
log
@getPgdCritList
@
text
@d410 2
a411 2
         ArrayList <Part>    thePartList,
         ArrayList <Integer> thePeriodList)
d415 1
a415 1
         mustBeActive                      ("Problem.getCriticalList");
d418 1
a418 1
            thePartList,   "thePartList",   "Problem.getCriticalList");
d421 1
a421 1
            thePeriodList, "thePeriodList", "Problem.getCriticalList");
d423 1
a423 1
         myProblemCOR.getCriticalList (thePartList, thePeriodList);
@


1.229
log
@Problem.setObjectiveList
@
text
@d415 1
a415 2
         mustBeActive                              ("Problem.getCriticalList");
         mustBeNonNull (thePartList, "thePartList", "Problem.getCriticalList");
d418 4
a421 3
            thePeriodList,
           "thePeriodList",
           "Problem.getCriticalList");
d434 38
@


1.228
log
@Revised set/get ObjectiveList for ArrayList <String>.
@
text
@d686 15
d703 1
a703 1
           "theObjNames",
@


1.227
log
@Replaced C++ class CORJOR with ComponentJOR.
@
text
@d470 1
a470 1
   public String[] getObjectiveList ()
d474 2
d478 5
a482 1
         return myProblemCOR.getObjectiveList ();
d682 8
a689 1
         mustBeActive ("Problem.setObjectiveList");
d691 1
a691 1
         myProblemCOR.setObjectiveList (theObjNames);
@


1.226
log
@Changed name of class AllocTriple to PeggingTriple.
@
text
@d1359 1
a1359 1
      myProblemCOR = new ProblemCOR (this);
@


1.225
log
@AllocTripleALJOR
@
text
@d508 1
a508 1
   public ArrayList <AllocTriple <Demand>> getPipSeq ()
d512 1
a512 1
         ArrayList <AllocTriple <Demand>> theDemandTripList;
d516 1
a516 1
         theDemandTripList = new ArrayList <AllocTriple <Demand>> (0);
@


1.224
log
@Replaced setPipSeq with clearPipSeq and appendToPipSeq.
@
text
@d512 2
d516 5
a520 1
         return getPipSeqInt ();
a1438 22
// getPipSeqInt ()
//
// Internal implementation of getPipSeq ().
//------------------------------------------------------------------------------

   private ArrayList <AllocTriple <Demand>> getPipSeqInt ()
      {
      AllocTripleVecCOR                theAllocTripleVecCOR;
      ArrayList <AllocTriple <Demand>> theTripleList;

      theAllocTripleVecCOR = new AllocTripleVecCOR (getCoordinator ());

      myProblemCOR.getPipSeq (theAllocTripleVecCOR);

      theTripleList = theAllocTripleVecCOR.newAllocTripleList (Demand.class);

      theAllocTripleVecCOR.deactivate ();

      return theTripleList;
      }

//------------------------------------------------------------------------------
@


1.223
log
@Revised the arguments to eqHeurAlloc.
@
text
@d247 17
a862 21
// setPipSeq (theTripleList)
//
// Sets the PIP shipment sequence to the list of AllocTriples in theTripleList.
//------------------------------------------------------------------------------

   public void setPipSeq (ArrayList <AllocTriple <Demand>> theTripleList)
      {
      try
         {
         mustBeActive ("Problem.setPipSeq");

         setPipSeqInt (theTripleList);
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
a1432 27
// setPipSeqInt (theTripleList)
//
// Internal implementation of setPipSeq (theTripleList).
//------------------------------------------------------------------------------

   private void setPipSeqInt (ArrayList <AllocTriple <Demand>> theTripleList)
      {
      DemandCOR theDemandCOR;
      int       theShipPer;
      double    incShipVol;

      getCoordinator ().
         checkDemandTriples (theTripleList, "theProblem.setPipSeq");

      myProblemCOR.callSimpleWitFunc ("witClearPipSeq");

      for (AllocTriple <Demand> theTriple: theTripleList)
         {
         theDemandCOR = theTriple.getRoot   ().getDemandCOR ();
         theShipPer   = theTriple.getPeriod ();
         incShipVol   = theTriple.getVolume ();

         theDemandCOR.appendToPipSeq (theShipPer, incShipVol);
         }
      }

//------------------------------------------------------------------------------
@


1.222
log
@Problem.getCriticalList ()
@
text
@d309 5
a313 1
   public double[] eqHeurAlloc (ArrayList <AllocTriple <Demand>> theTripleList)
d319 12
a330 1
         return eqHeurAllocInt (theTripleList);
a1436 39
// eqHeurAllocInt (theTripleList)
//
// Internal implementation of eqHeurAlloc (theTripleList)
//------------------------------------------------------------------------------

   private double[] eqHeurAllocInt (
         ArrayList <AllocTriple <Demand>> theTripleList)
      {
      DemandCOR[]          theDemandCORArr;
      int[]                shipPerArr;
      double[]             desIncVolArr;
      int                  nTriples;
      int                  theIdx;
      AllocTriple <Demand> theTriple;


      getCoordinator ().
         checkDemandTriples (theTripleList, "theProblem.eqHeurAlloc");

      nTriples        = theTripleList.size ();

      theDemandCORArr = new DemandCOR[nTriples];
      shipPerArr      = new int      [nTriples];
      desIncVolArr    = new double   [nTriples];

      for (theIdx = 0; theIdx < theTripleList.size (); theIdx ++)
         {
         theTriple               = theTripleList.get (theIdx);

         theDemandCORArr[theIdx] = theTriple.getRoot   ().getDemandCOR ();
         shipPerArr     [theIdx] = theTriple.getPeriod ();
         desIncVolArr   [theIdx] = theTriple.getVolume ();
         }

      return
          myProblemCOR.eqHeurAlloc (theDemandCORArr, shipPerArr, desIncVolArr);
      }

//------------------------------------------------------------------------------
d1579 154
@


1.221
log
@Problem.getCriticalList ()
@
text
@d378 2
a379 2
         ArrayList <Part>    theParts,
         ArrayList <Integer> thePeriods)
d383 2
a384 3
         mustBeActive                            ("Problem.getCriticalList");
         mustBeNonNull (theParts,   "theParts",   "Problem.getCriticalList");
         mustBeNonNull (thePeriods, "thePeriods", "Problem.getCriticalList");
d386 6
a391 1
         myProblemCOR.getCriticalList (theParts, thePeriods);
@


1.220
log
@DefaultCase
@
text
@d377 21
@


1.219
log
@DefaultCase
@
text
@a10 1
import static com.ibm.witj.DefaultCase.*;
@


1.218
log
@DefaultCase == CALCULATED
@
text
@d1019 1
a1019 1
         switch (theAtt.getDefaultCase ())
d1021 15
a1035 22
            case SPECIFIED:
               return theAtt.getSpecDefValue ();

            case CALCULATED:
               if      (theAtt == cplexSelected)
                  {
                  return getValue (cplexEmbedded);
                  }
               else if (theAtt == coinSelected)
                  {
                  return
                          getValue  (coinEmbedded)
                     && ! getValue (cplexEmbedded);
                  }
               else
                  {
                  assert (false);

                  return false;
                  }

            default:
d1058 5
a1062 1
         switch (theAtt.getDefaultCase ())
d1064 1
a1064 9
            case SPECIFIED:
               return theAtt.getSpecDefValue ();

            case CALCULATED:
               {
               assert (theAtt == latestPeriod);

               return nPeriods - 1;
               }
d1066 1
a1066 6
            default:
               {
               assert (false);

               return -1;
               }
d1163 1
a1163 1
         switch (theAtt.getDefaultCase ())
d1165 7
a1171 3
            case SPECIFIED:
               {
               theDefVal = theAtt.getSpecDefValue ()[0];
d1173 1
a1173 16
               break;
               }

            case CALCULATED:
               {
               assert (   (theAtt == buildAheadUB)
                       || (theAtt == leadTimeUB)
                       || (theAtt == shipLateUB));

               theDefVal = nPeriods - 1;

               break;
               }

            default:
               assert (false);
d1247 1
a1247 1
         assert (theAtt.getDefaultCase () == CALCULATED);
@


1.217
log
@Revised the default values for coinSelected and cplexSelected.
@
text
@d1019 30
a1048 4
         if (theAtt.getDefaultCase () == CALCULATED)
            return calcDefaultValue (theAtt);
         else
            return theAtt.getDefaultValue ();
d1065 19
a1083 4
         if (theAtt.getDefaultCase () == LAST_PERIOD)
            return nPeriods - 1;
         else
            return theAtt.getDefaultValue ();
d1100 1
a1100 1
         return theAtt.getDefaultValue ();
d1117 1
a1117 1
         return theAtt.getDefaultValue ();
d1148 1
a1148 1
         theDefVal = theAtt.getDefaultValue ()[0];
d1170 1
a1170 1
         int theDefVal;
d1179 23
a1201 4
         if (theAtt.getDefaultCase () == LAST_PERIOD)
            theDefVal = nPeriods - 1;
         else
            theDefVal = theAtt.getDefaultValue ()[0];
d1232 1
a1232 1
         theDefVal = theAtt.getDefaultValue ()[0];
d1274 2
a1512 29
// calcDefaultValue (theAtt)
//
// Calculates and returns the default value for theAtt.
// The DefaultCase of theAtt must be CALCULATED.
//------------------------------------------------------------------------------

   private boolean calcDefaultValue (Attribute <Boolean> theAtt)
      {
      assert (theAtt.getDefaultCase () == CALCULATED);

      if (theAtt == cplexSelected)
         {
         return getValue (cplexEmbedded);
         }
      else if (theAtt == coinSelected)
         {
         return
                 getValue  (coinEmbedded)
            && ! getValue (cplexEmbedded);
         }
      else
         {
         assert (false);

         return false;
         }
      }

//------------------------------------------------------------------------------
@


1.216
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@d12 1
d1019 4
a1022 1
         return theAtt.getDefaultValue ();
d1451 29
@


1.215
log
@CPLEX
@
text
@d26 2
a27 1
//       Problem
d30 1
a30 1
public final class Problem extends PreservedObject
d67 2
a68 2
//    All Components owned by this Problem except its GlobalAspect are removed
//       from this Problem and deactivatived.
d80 2
d162 1
a162 1
   public void buildPip ()
d166 1
a166 1
         mustBeActive ("Problem.buildPip");
d168 1
a168 1
         callSimpleWitFunc ("witBuildPip");
d179 1
a179 1
   public void clearCplexParSpecs ()
d183 1
a183 1
         mustBeActive ("Problem.clearCplexParSpecs");
d185 1
a185 1
         callSimpleWitFunc ("witClearCplexParSpecs");
d196 1
a196 1
   public void clearPegging ()
d200 1
a200 1
         mustBeActive ("Problem.clearPegging");
d202 1
a202 1
         callSimpleWitFunc ("witClearPegging");
d213 1
a213 1
   public void clearStochSoln ()
d217 1
a217 1
         mustBeActive ("Problem.clearStochSoln");
d219 1
a219 1
         callSimpleWitFunc ("witClearStochSoln");
d230 1
a230 1
   public void addDblCplexParSpec (String theName, double theValue)
d234 1
a234 1
         mustBeActive ("Problem.addDblCplexParSpec");
d236 1
a236 1
         myProblemCOR.addDblCplexParSpec (theName, theValue);
d247 1
a247 1
   public void addIntCplexParSpec (String theName, int theValue)
d251 1
a251 1
         mustBeActive ("Problem.addIntCplexParSpec");
d253 1
a253 1
         myProblemCOR.addIntCplexParSpec (theName, theValue);
d377 37
a413 1
   public void heurImplode ()
d417 1
a417 1
         mustBeActive ("Problem.heurImplode");
d419 1
a419 1
         callSimpleWitFunc ("witHeurImplode");
d430 1
a430 1
   public void mrp ()
d434 5
a438 1
         mustBeActive ("Problem.mrp");
d440 1
a440 1
         callSimpleWitFunc ("witMrp");
d451 1
a451 1
   public void optImplode ()
d455 1
a455 1
         mustBeActive ("Problem.optImplode");
d457 1
a457 1
         callSimpleWitFunc ("witOptImplode");
d468 1
a468 1
   public void postprocess ()
d472 1
a472 1
         mustBeActive ("Problem.postprocess");
d474 1
a474 1
         callSimpleWitFunc ("witPostprocess");
d485 1
a485 1
   public void preprocess ()
d489 1
a489 1
         mustBeActive ("Problem.preprocess");
d491 1
a491 1
         callSimpleWitFunc ("witPreprocess");
d502 1
a502 1
   public void purgeData ()
d506 12
a517 1
         mustBeActive ("Problem.purgeData");
d519 5
a523 1
         callSimpleWitFunc ("witPurgeData");
d525 1
a525 1
         getCoordinator ().restoreAfterPurge ();
d536 1
a536 1
   public Double getDblCplexParSpec (String theName)
d540 1
a540 2
         mustBeActive                      ("Problem.getDblCplexParSpec");
         mustBeNonNull (theName, "theName", "Problem.getDblCplexParSpec");
d542 1
a542 1
         return myProblemCOR.getDblCplexParSpec (theName);
d553 1
a553 1
   public Integer getIntCplexParSpec (String theName)
d557 3
a559 2
         mustBeActive                      ("Problem.getIntCplexParSpec");
         mustBeNonNull (theName, "theName", "Problem.getIntCplexParSpec");
d561 1
a561 1
         return myProblemCOR.getIntCplexParSpec (theName);
d609 34
d806 1
a806 1
// getComponents ()
d808 1
a808 2
// Returns an unmodifiable List of all Components that belong to this Problem,
// listed in creation order.
d811 1
a811 1
   public List <Component> getComponents ()
d815 1
a815 1
         mustBeActive ("Problem.getComponents");
d817 1
a817 1
         return getCoordinator ().getComponents ();
d827 1
a827 1
// getGlobalAspect ().
d829 2
a830 1
// Access wrapper.
d833 1
a833 1
   public GlobalAspect getGlobalAspect ()
d837 1
a837 1
         mustBeActive ("Problem.getGlobalAspect");
d839 1
a839 1
         return getCoordinator ().getGlobalAspect ();
d1036 1
a1036 1
            return getGlobalAspect ().getNPeriods () - 1;
d1135 1
a1135 1
            theDefVal = getGlobalAspect ().getNPeriods () - 1;
a1197 1
         int nPeriodsVal;
d1210 1
a1210 3
         nPeriodsVal = getGlobalAspect ().getNPeriods ();

         for (theIdx = 0; theIdx < nPeriodsVal; theIdx ++)
d1277 3
a1279 1
      myProblemCOR = new ProblemCOR (theCoord);
d1298 48
d1398 49
d1529 1
a1529 1
      if (theLength != getGlobalAspect ().getNPeriods ())
d1537 1
a1537 1
             + "      nPeriods:     " + getGlobalAspect ().getNPeriods ());
d1554 8
@


1.214
log
@CPLEX
@
text
@d176 17
@


1.213
log
@CPLEX
@
text
@d461 18
@


1.212
log
@CPLEX
@
text
@d460 18
@


1.211
log
@Fixed bug: The WIT multiThread attribute is now set to true.
Implemented the test for calls to readData from two Threads.
@
text
@d210 34
@


1.210
log
@Removed Problem.getActiveProblems ().
@
text
@d430 3
a432 2
// The implementation is globally synchronized with all other calls to this
// method.
d1272 2
a1273 1
// Global synchronization lock for all calls to readData.
d1276 1
a1276 1
   private static final String readDataLock = new String ("readDataLock");
@


1.209
log
@Synchronized readData.
@
text
@a1047 33
// getActiveProblems ()
//
// Builds and returns a Set consisting of all currently active Problems created
// in the current Thread.
//------------------------------------------------------------------------------

   public static Set <Problem> getActiveProblems ()
      {
      try
         {
         HashSet <Problem> theProblems;

         notAllowedWhenTerminated ("Problem.getActiveProblems");

         theProblems =
            new HashSet <Problem> (
               Coordinator.getActiveCoordinators ().size ());

         for (Coordinator theCoord: Coordinator.getActiveCoordinators ())
            {
            theProblems.add (theCoord.getProblem ());
            }

         return theProblems;
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
@


1.208
log
@Further implementation of class ThreadedObject.
@
text
@d426 7
d449 4
a452 1
         myProblemCOR.readData (fileName);
d1302 8
@


1.207
log
@Initial implementation of class ThreadedObject.
@
text
@d259 2
a1170 2
      mustBeActive ("Problem.eqHeurAlloc");

@


1.206
log
@Implemented class PreservedInternal and made several classes extend it
   instead of class PreservedObject.
@
text
@d24 3
a26 2
// PreservedObject
//    Problem
@


1.205
log
@Moved myCoordinator to PreservedObject.
@
text
@d1050 2
a1051 1
            new HashSet <Problem> (Coordinator.getActives ().size ());
d1053 1
a1053 1
         for (Coordinator theCoord: Coordinator.getActives ())
@


1.204
log
@Implemented thePreservedObject.getCoordinator ().
@
text
@d77 1
a77 1
         myCoordinator.clearData ();
d221 1
a221 1
         myCoordinator.clearData ();
d413 1
a413 1
         myCoordinator.restoreAfterPurge ();
d431 1
a431 1
         if (myCoordinator.hasPartsOrOperations ())
d625 1
a625 1
         return myCoordinator.getComponents ();
d646 1
a646 1
         return myCoordinator.getGlobalAspect ();
d674 1
a674 1
         return myCoordinator.getInstances (Part.class, PART);
d691 1
a691 1
         return myCoordinator.getInstances (Demand.class, DEMAND);
d708 1
a708 1
         return myCoordinator.getInstances (Operation.class, OPERATION);
d725 1
a725 1
         return myCoordinator.getInstances (BomEntry.class, BOM_ENTRY);
d742 1
a742 1
         return myCoordinator.getInstances (Substitute.class, SUBSTITUTE);
d759 1
a759 1
         return myCoordinator.getInstances (BopEntry.class, BOP_ENTRY);
d781 1
a781 1
         return myCoordinator.getPart (thePartName);
d803 1
a803 1
         return myCoordinator.getOperation (theOpnName);
d1081 3
a1083 3
         myProblemCOR .deactivate ();
         myCoordinator.deactivate ();
         super        .deactivate ();
d1102 1
a1102 1
         return myCoordinator.getMessageMgr ();
d1117 1
a1117 1
      myCoordinator = theCoord;
d1119 1
a1119 1
      myProblemCOR  = new ProblemCOR (theCoord);
a1137 11
// getCoordinator ()
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   Coordinator getCoordinator ()
      {
      return myCoordinator;
      }

//------------------------------------------------------------------------------
d1169 1
a1169 1
      myCoordinator.
a1289 8
// myCoordinator.
//
// The Coordinator that belongs to this Problem.
//------------------------------------------------------------------------------

   private final Coordinator myCoordinator;

//------------------------------------------------------------------------------
@


1.203
log
@Moved active Set from class Problem to class Coordinator.
@
text
@d1119 1
a1119 1
      myProblemCOR  = new ProblemCOR (myCoordinator.getCoordinatorCOR ());
d1138 3
a1140 1
// Accessors.
d1148 4
@


1.202
log
@Made the Coordinator own the Problem.
@
text
@d1037 2
a1038 2
// Returns an unmodifiable view of an internal Set of all currently active
// Problems in the program process.
d1045 2
d1049 9
a1057 1
         return Collections.unmodifiableSet (allActiveProblems.get ());
a1083 4

         assert (allActiveProblems.get ().contains (this));

         allActiveProblems.get ().remove (this);
a1116 2
      myThread      = Thread.currentThread ();

a1119 2

      allActiveProblems.get ().add (this);
a1294 18
// allActiveProblems
//
// allActiveProblems.get () is the set of all currently active Problems that
// were created in the current thread. Their presence in this Set prevents them
// from being garbage-collected until they are deactivated.
//------------------------------------------------------------------------------

   private static final ThreadLocal <HashSet <Problem>> allActiveProblems;

//------------------------------------------------------------------------------
// myThread
//
// The Thread in which this Problem was created.
//------------------------------------------------------------------------------

   private final Thread myThread;

//------------------------------------------------------------------------------
a1310 16
// Static initialization block
//==============================================================================

   static
      {
      allActiveProblems =
         new ThreadLocal <HashSet <Problem>> ()
            {
            protected HashSet <Problem> initialValue ()
               {
               return new HashSet <Problem> (10);
               }
            };
      }

//==============================================================================
@


1.201
log
@Added theProblem.myThread.
@
text
@d45 2
d49 3
a51 1
         return new Problem (false);
d1105 3
a1107 6
//------------------------------------------------------------------------------
// newInstanceForSelfTest ()
//
// Factory method:
//    Constructs a new Problem to be used for self-test and returns it.
//------------------------------------------------------------------------------
d1109 1
a1109 1
   static Problem newInstanceForSelfTest ()
d1111 7
a1117 1
      return new Problem (true);
a1149 15
// Private Constructor
//==============================================================================

   private Problem (boolean forSelfTest)
      {
      myThread      = Thread.currentThread ();

      myCoordinator = new Coordinator (this, forSelfTest);

      myProblemCOR  = new ProblemCOR (myCoordinator.getCoordinatorCOR ());

      allActiveProblems.get ().add (this);
      }

//==============================================================================
@


1.200
log
@Made theProblem.allActiveProblems thread-local.
@
text
@d1148 1
a1148 1
      allActiveProblems.get ().add (this);
d1153 2
d1301 18
a1333 10
//------------------------------------------------------------------------------
// allActiveProblems
//
// allActiveProblems.get () is the set of all currently active Problems that
// were created in the current thread. Their presence in this Set prevents them
// from being garbage-collected until they are deactivated.
//------------------------------------------------------------------------------

   private static final ThreadLocal <HashSet <Problem>> allActiveProblems;

@


1.199
log
@Maded the static field Coordinator.selfTesting non-static.
@
text
@d1043 1
a1043 1
         return Collections.unmodifiableSet (allActiveProblems);
d1071 1
a1071 1
         assert (allActiveProblems.contains (this));
d1073 1
a1073 1
         allActiveProblems.remove (this);
d1148 1
a1148 1
      allActiveProblems.add (this);
d1317 3
a1319 3
// The set of all currently active Problems in the program process. Their
// presence in this Set prevents them from being garbage-collected until they
// are deactivated.
d1322 1
a1322 1
   private static final HashSet <Problem> allActiveProblems;
d1330 8
a1337 1
      allActiveProblems = new HashSet <Problem> (10);
@


1.198
log
@Made WIT-J throw an InternalErrorException instead of a
   TerminalAppErrorException when the native library fails to load.
@
text
@d38 1
a38 1
// Constructs a new Problem and returns it.
d47 1
a47 1
         return new Problem ();
d1101 12
d1146 1
a1146 1
   private Problem ()
d1150 1
a1150 1
      myCoordinator = Coordinator.newInstance (this);
@


1.197
log
@Replaced "SubComponent" with "Root".
@
text
@d128 5
@


1.196
log
@Removed the "place element request" capability.
@
text
@d1174 3
a1176 3
         theDemandCORArr[theIdx] = theTriple.getSubComponent ().getDemandCOR ();
         shipPerArr     [theIdx] = theTriple.getPeriod                       ();
         desIncVolArr   [theIdx] = theTriple.getVolume                       ();
@


1.195
log
@Method argument name change.
@
text
@a1025 30
// fulfillElementRequests ()
//
// For each vector element request stored for any vector Attribute and for any
// Component of this Problem, this method sets the requested vector element of
// the represented WIT attribute to the requested value.
// For each bound element request stored for any BoundSet Attribute and for any
// Component of this Problem, this method sets the requested bound element of
// the represented WIT attribute to the requested value.
// Clears the element requests for this Problem.
//------------------------------------------------------------------------------

   public void fulfillElementRequests ()
      {
      try
         {
         mustBeActive ("Problem.fulfillElementRequests");

         for (Attribute <?> theAtt: Attribute.getAttributes ())
            {
            myCoordinator.getAttImpFor (theAtt).fulfillElementRequests ();
            }
         }

      catch (Throwable              theThrowable)
         {
         throw getExceptionToThrow (theThrowable);
         }
      }

//------------------------------------------------------------------------------
@


1.194
log
@Changed getCInstance () to getSubComponent ().
@
text
@d200 1
a200 1
   public void copyData (Problem otherProblem)
d204 1
a204 1
         ProblemCOR otherProblemCOR;
d206 2
a207 2
         mustBeActive                               ("Problem.copyData");
         mustBeActive (otherProblem, "otherProblem", "Problem.copyData");
d209 1
a209 1
         if (otherProblem == this)
d214 1
a214 1
         otherProblemCOR = otherProblem.myProblemCOR;
d216 1
a216 1
         myProblemCOR.copyData (otherProblemCOR);
@


1.193
log
@Changed name of clear methods to clearData.
@
text
@d1204 3
a1206 3
         theDemandCORArr[theIdx] = theTriple.getCInstance ().getDemandCOR ();
         shipPerArr     [theIdx] = theTriple.getPeriod    ();
         desIncVolArr   [theIdx] = theTriple.getVolume    ();
@


1.192
log
@Minor alteration.
@
text
@d57 1
a57 1
// clear ()
d67 1
a67 1
   public void clear ()
d71 1
a71 1
         mustBeActive ("Problem.clear");
d73 1
a73 1
         myCoordinator.clear ();
d212 1
a212 1
         myCoordinator.clear ();
@


1.191
log
@getActiveInstances ==> getActiveProblems
@
text
@d62 1
a62 1
//       from this Problem and deactiveatived.
d200 1
a200 1
   public void copyData (Problem theProblem)
d204 1
a204 1
         ProblemCOR theProblemCOR;
d206 2
a207 2
         mustBeActive                           ("Problem.copyData");
         mustBeActive (theProblem, "theProblem", "Problem.copyData");
d209 1
a209 1
         if (theProblem == this)
d214 1
a214 1
         theProblemCOR = theProblem.myProblemCOR;
d216 1
a216 1
         myProblemCOR.copyData (theProblemCOR);
@


1.190
log
@Changed names of instances of class C in generic class AllocTriple <C>.
@
text
@d1056 1
a1056 1
// getActiveInstances ()
d1062 1
a1062 1
   public static Set <Problem> getActiveInstances ()
d1066 1
a1066 1
         notAllowedWhenTerminated ("Problem.getActiveInstances");
d1068 1
a1068 1
         return Collections.unmodifiableSet (ourActiveInstances);
d1096 1
a1096 1
         assert (ourActiveInstances.contains (this));
d1098 1
a1098 1
         ourActiveInstances.remove (this);
d1161 1
a1161 1
      ourActiveInstances.add (this);
d1328 1
a1328 1
// ourActiveInstances
d1335 1
a1335 1
   private static final HashSet <Problem> ourActiveInstances;
d1343 1
a1343 1
      ourActiveInstances = new HashSet <Problem> (10);
@


1.189
log
@Changed terminology:
   "Queueing element values" was replaced by
   "Placing element requests".
@
text
@d1204 3
a1206 3
         theDemandCORArr[theIdx] = theTriple.getC      ().getDemandCOR ();
         shipPerArr     [theIdx] = theTriple.getPeriod ();
         desIncVolArr   [theIdx] = theTriple.getVolume ();
@


1.188
log
@Replaced the throwExceptionFor method with getExeceptionToThrow.
@
text
@d1026 1
a1026 1
// setElementsFromQueue ()
d1028 7
a1034 4
// For each element value queued for any vector Attribute, this method sets the
// corresponding vector element of the represented WIT attribute to the value.
// The same is done for each element value queued for any BoundSet Attribute.
// Clears the queue of all element values.
d1037 1
a1037 1
   public void setElementsFromQueue ()
d1041 1
a1041 1
         mustBeActive ("Problem.setElementsFromQueue");
d1045 1
a1045 1
            myCoordinator.getAttImpFor (theAtt).setElementsFromQueue ();
@


1.187
log
@Changed name of Java class WitjException to GeneralException.
@
text
@d50 1
a50 1
      catch (Throwable theThrowable)
d52 1
a52 3
         throwExceptionFor (theThrowable);

         return null;
d76 1
a76 1
      catch (Throwable theThrowable)
d78 1
a78 1
         throwExceptionFor (theThrowable);
d139 1
a139 1
      catch (Throwable theThrowable)
d141 1
a141 1
         throwExceptionFor (theThrowable);
d158 1
a158 1
      catch (Throwable theThrowable)
d160 1
a160 1
         throwExceptionFor (theThrowable);
d175 1
a175 1
      catch (Throwable theThrowable)
d177 1
a177 1
         throwExceptionFor (theThrowable);
d192 1
a192 1
      catch (Throwable theThrowable)
d194 1
a194 1
         throwExceptionFor (theThrowable);
d219 1
a219 1
      catch (Throwable theThrowable)
d221 1
a221 1
         throwExceptionFor (theThrowable);
d237 1
a237 1
      catch (Throwable theThrowable)
d239 1
a239 1
         throwExceptionFor (theThrowable);
d252 1
a252 1
      catch (Throwable theThrowable)
d254 1
a254 3
         throwExceptionFor (theThrowable);

         return null;
d269 1
a269 1
      catch (Throwable theThrowable)
d271 1
a271 1
         throwExceptionFor (theThrowable);
d286 1
a286 1
      catch (Throwable theThrowable)
d288 1
a288 1
         throwExceptionFor (theThrowable);
d303 1
a303 1
      catch (Throwable theThrowable)
d305 1
a305 1
         throwExceptionFor (theThrowable);
d320 1
a320 1
      catch (Throwable theThrowable)
d322 1
a322 1
         throwExceptionFor (theThrowable);
d337 1
a337 1
      catch (Throwable theThrowable)
d339 1
a339 1
         throwExceptionFor (theThrowable);
d354 1
a354 1
      catch (Throwable theThrowable)
d356 1
a356 1
         throwExceptionFor (theThrowable);
d371 1
a371 1
      catch (Throwable theThrowable)
d373 1
a373 1
         throwExceptionFor (theThrowable);
d388 1
a388 1
      catch (Throwable theThrowable)
d390 1
a390 1
         throwExceptionFor (theThrowable);
d407 1
a407 1
      catch (Throwable theThrowable)
d409 1
a409 1
         throwExceptionFor (theThrowable);
d433 1
a433 1
      catch (Throwable theThrowable)
d435 1
a435 1
         throwExceptionFor (theThrowable);
d450 1
a450 1
      catch (Throwable theThrowable)
d452 1
a452 1
         throwExceptionFor (theThrowable);
d467 1
a467 1
      catch (Throwable theThrowable)
d469 1
a469 1
         throwExceptionFor (theThrowable);
d484 1
a484 1
      catch (Throwable theThrowable)
d486 1
a486 1
         throwExceptionFor (theThrowable);
d510 1
a510 1
      catch (Throwable theThrowable)
d512 1
a512 1
         throwExceptionFor (theThrowable);
d528 1
a528 1
      catch (Throwable theThrowable)
d530 1
a530 1
         throwExceptionFor (theThrowable);
d551 1
a551 1
      catch (Throwable theThrowable)
d553 1
a553 1
         throwExceptionFor (theThrowable);
d574 1
a574 1
      catch (Throwable theThrowable)
d576 1
a576 1
         throwExceptionFor (theThrowable);
d597 1
a597 1
      catch (Throwable theThrowable)
d599 1
a599 1
         throwExceptionFor (theThrowable);
d619 1
a619 1
      catch (Throwable theThrowable)
d621 1
a621 3
         throwExceptionFor (theThrowable);

         return null;
d640 1
a640 1
      catch (Throwable theThrowable)
d642 1
a642 3
         throwExceptionFor (theThrowable);

         return null;
d668 1
a668 1
      catch (Throwable theThrowable)
d670 1
a670 3
         throwExceptionFor (theThrowable);

         return null;
d685 1
a685 1
      catch (Throwable theThrowable)
d687 1
a687 3
         throwExceptionFor (theThrowable);

         return null;
d702 1
a702 1
      catch (Throwable theThrowable)
d704 1
a704 3
         throwExceptionFor (theThrowable);

         return null;
d719 1
a719 1
      catch (Throwable theThrowable)
d721 1
a721 3
         throwExceptionFor (theThrowable);

         return null;
d736 1
a736 1
      catch (Throwable theThrowable)
d738 1
a738 3
         throwExceptionFor (theThrowable);

         return null;
d753 1
a753 1
      catch (Throwable theThrowable)
d755 1
a755 3
         throwExceptionFor (theThrowable);

         return null;
d775 1
a775 1
      catch (Throwable theThrowable)
d777 1
a777 3
         throwExceptionFor (theThrowable);

         return null;
d797 1
a797 1
      catch (Throwable theThrowable)
d799 1
a799 3
         throwExceptionFor (theThrowable);

         return null;
d819 1
a819 1
      catch (Throwable theThrowable)
d821 1
a821 3
         throwExceptionFor (theThrowable);

         return false;
d839 1
a839 1
      catch (Throwable theThrowable)
d841 1
a841 3
         throwExceptionFor (theThrowable);

         return 0;
d856 1
a856 1
      catch (Throwable theThrowable)
d858 1
a858 3
         throwExceptionFor (theThrowable);

         return 0.0;
d873 1
a873 1
      catch (Throwable theThrowable)
d875 1
a875 3
         throwExceptionFor (theThrowable);

         return null;
d909 1
a909 1
      catch (Throwable theThrowable)
d911 1
a911 1
         throwExceptionFor (theThrowable);
d943 1
a943 1
      catch (Throwable theThrowable)
d945 1
a945 1
         throwExceptionFor (theThrowable);
d974 1
a974 1
      catch (Throwable theThrowable)
d976 1
a976 1
         throwExceptionFor (theThrowable);
d1019 1
a1019 1
      catch (Throwable theThrowable)
d1021 1
a1021 1
         throwExceptionFor (theThrowable);
d1046 1
a1046 1
      catch (Throwable theThrowable)
d1048 1
a1048 1
         throwExceptionFor (theThrowable);
d1068 1
a1068 1
      catch (Throwable theThrowable)
d1070 1
a1070 3
         throwExceptionFor (theThrowable);

         return null;
d1098 1
a1098 1
      catch (Throwable theThrowable)
d1100 1
a1100 1
         throwExceptionFor (theThrowable);
d1117 1
a1117 1
      catch (Throwable theThrowable)
d1119 1
a1119 3
         throwExceptionFor (theThrowable);

         return null;
@


1.186
log
@Revised some comments.
@
text
@d52 3
a54 1
         throw getWitjExceptionFor (theThrowable);
d80 1
a80 1
         throw getWitjExceptionFor (theThrowable);
d143 1
a143 1
         throw getWitjExceptionFor (theThrowable);
d162 1
a162 1
         throw getWitjExceptionFor (theThrowable);
d179 1
a179 1
         throw getWitjExceptionFor (theThrowable);
d196 1
a196 1
         throw getWitjExceptionFor (theThrowable);
d223 1
a223 1
         throw getWitjExceptionFor (theThrowable);
d241 1
a241 1
         throw getWitjExceptionFor (theThrowable);
d256 3
a258 1
         throw getWitjExceptionFor (theThrowable);
d275 1
a275 1
         throw getWitjExceptionFor (theThrowable);
d292 1
a292 1
         throw getWitjExceptionFor (theThrowable);
d309 1
a309 1
         throw getWitjExceptionFor (theThrowable);
d326 1
a326 1
         throw getWitjExceptionFor (theThrowable);
d343 1
a343 1
         throw getWitjExceptionFor (theThrowable);
d360 1
a360 1
         throw getWitjExceptionFor (theThrowable);
d377 1
a377 1
         throw getWitjExceptionFor (theThrowable);
d394 1
a394 1
         throw getWitjExceptionFor (theThrowable);
d413 1
a413 1
         throw getWitjExceptionFor (theThrowable);
d439 1
a439 1
         throw getWitjExceptionFor (theThrowable);
d456 1
a456 1
         throw getWitjExceptionFor (theThrowable);
d473 1
a473 1
         throw getWitjExceptionFor (theThrowable);
d490 1
a490 1
         throw getWitjExceptionFor (theThrowable);
d516 1
a516 1
         throw getWitjExceptionFor (theThrowable);
d534 1
a534 1
         throw getWitjExceptionFor (theThrowable);
d557 1
a557 1
         throw getWitjExceptionFor (theThrowable);
d580 1
a580 1
         throw getWitjExceptionFor (theThrowable);
d603 1
a603 1
         throw getWitjExceptionFor (theThrowable);
d625 3
a627 1
         throw getWitjExceptionFor (theThrowable);
d648 3
a650 1
         throw getWitjExceptionFor (theThrowable);
d678 3
a680 1
         throw getWitjExceptionFor (theThrowable);
d697 3
a699 1
         throw getWitjExceptionFor (theThrowable);
d716 3
a718 1
         throw getWitjExceptionFor (theThrowable);
d735 3
a737 1
         throw getWitjExceptionFor (theThrowable);
d754 3
a756 1
         throw getWitjExceptionFor (theThrowable);
d773 3
a775 1
         throw getWitjExceptionFor (theThrowable);
d797 3
a799 1
         throw getWitjExceptionFor (theThrowable);
d821 3
a823 1
         throw getWitjExceptionFor (theThrowable);
d845 3
a847 1
         throw getWitjExceptionFor (theThrowable);
d867 3
a869 1
         throw getWitjExceptionFor (theThrowable);
d886 3
a888 1
         throw getWitjExceptionFor (theThrowable);
d905 3
a907 1
         throw getWitjExceptionFor (theThrowable);
d943 1
a943 1
         throw getWitjExceptionFor (theThrowable);
d977 1
a977 1
         throw getWitjExceptionFor (theThrowable);
d1008 1
a1008 1
         throw getWitjExceptionFor (theThrowable);
d1053 1
a1053 1
         throw getWitjExceptionFor (theThrowable);
d1080 1
a1080 1
         throw getWitjExceptionFor (theThrowable);
d1102 3
a1104 1
         throw getWitjExceptionFor (theThrowable);
d1134 1
a1134 1
         throw getWitjExceptionFor (theThrowable);
d1153 3
a1155 1
         throw getWitjExceptionFor (theThrowable);
@


1.185
log
@Revised theProblem.clear ().
@
text
@d59 6
a64 5
// Restores this Problem to its default state, i.e., equivalent to being newly
// constructed.
// Deactivates all Components owned by this Problem (except the GlobalAspect)
// and removes them from all Lists of Components owned by this Problem.
// Invokes witInitialize on the WitRun.
@


1.184
log
@Removed the "enabled" concept from WIT-J.
@
text
@a72 2

         callSimpleWitFunc ("witInitialize");
@


1.183
log
@Changed name of Java class RetainedObject to PreservedObject.
@
text
@a56 33
// enable ()
//
// Puts this Problem into an enabled state.
// Invokes witInitialize on the WitRun.
// Must not be called if this Problem is already enabled.
//------------------------------------------------------------------------------

   public void enable ()
      {
      try
         {
         mustBeActive ("Problem.enable");

         if (enabled)
            throw
               new StatusQuoException (
                  "   The enable method was called "
                +    "with a Problem that was already enabled.");

         myProblemCOR.enable ();

         new GlobalAspect (myCoordinator);

         enabled = true;
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
d60 1
a60 1
// enabled.
d70 1
a70 1
         mustBeEnabled ("Problem.clear");
d107 1
a107 7
            Problem theProblem;

            theProblem = Problem.newInstance ();

            theProblem.enable ();

            myCoordinator.recordGlobalAspect (theProblem.getGlobalAspect ());
d154 1
a154 1
         mustBeEnabled ("Problem.buildPip");
d171 1
a171 1
         mustBeEnabled ("Problem.clearPegging");
d188 1
a188 1
         mustBeEnabled ("Problem.clearStochSoln");
d207 2
a208 2
         mustBeEnabled             ("Problem.copyData");
         mustBeEnabled (theProblem, "Problem.copyData");
d232 1
a232 1
         mustBeEnabled                       ("Problem.displayData");
d265 1
a265 1
         mustBeEnabled ("Problem.evalObjectives");
d282 1
a282 1
         mustBeEnabled ("Problem.finishHeurAlloc");
d299 1
a299 1
         mustBeEnabled ("Problem.generatePriorities");
d316 1
a316 1
         mustBeEnabled ("Problem.heurImplode");
d333 1
a333 1
         mustBeEnabled ("Problem.mrp");
d350 1
a350 1
         mustBeEnabled ("Problem.optImplode");
d367 1
a367 1
         mustBeEnabled ("Problem.postprocess");
d384 1
a384 1
         mustBeEnabled ("Problem.preprocess");
d401 1
a401 1
         mustBeEnabled ("Problem.purgeData");
d420 1
a420 1
         mustBeEnabled                       ("Problem.readData");
d446 1
a446 1
         mustBeEnabled ("Problem.shutDownHeurAlloc");
d463 1
a463 1
         mustBeEnabled ("Problem.startHeurAlloc");
d480 1
a480 1
         mustBeEnabled ("Problem.stochImplode");
d502 1
a502 1
         mustBeEnabled                         ("Problem.writeCriticalList");
d523 1
a523 1
         mustBeEnabled                       ("Problem.writeData");
d543 1
a543 1
         mustBeEnabled                         ("Problem.writeExecSched");
d566 1
a566 1
         mustBeEnabled                         ("Problem.writeReqSched");
d589 1
a589 1
         mustBeEnabled                         ("Problem.writeShipSched");
d615 1
a615 1
         mustBeEnabled ("Problem.getComponents");
d636 1
a636 1
         mustBeEnabled ("Problem.getGlobalAspect");
d664 1
a664 1
         mustBeEnabled ("Problem.getParts");
d681 1
a681 1
         mustBeEnabled ("Problem.getDemands");
d698 1
a698 1
         mustBeEnabled ("Problem.getOperations");
d715 1
a715 1
         mustBeEnabled ("Problem.getBomEntries");
d732 1
a732 1
         mustBeEnabled ("Problem.getSubstitutes");
d749 1
a749 1
         mustBeEnabled ("Problem.getBopEntries");
d771 1
a771 1
         mustBeEnabled ("Problem.getPart");
d793 1
a793 1
         mustBeEnabled ("Problem.getOperation");
d1039 1
a1039 1
         mustBeEnabled ("Problem.setElementsFromQueue");
a1123 17
//------------------------------------------------------------------------------

   public boolean isEnabled ()
      {
      try
         {
         mustBeActive ("Problem.isEnabled");

         return enabled;
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

a1128 24
// mustBeEnabled
//
// Verifies that a Problem argument to a method is non-null, active, and
// enabled.
//
// Arguments:
//    theProblem: The argument being checked.
//    methName:   The name of the method.
//------------------------------------------------------------------------------

   static void mustBeEnabled (Problem theProblem, String methName)
      {
      mustBeActive (theProblem, "theProblem", methName);

      if (! theProblem.enabled)
         throw
            new StatusQuoException (
               "   A unenabled Problem was passed as an argument to a method\n"
             + "   that requires an enabled Problem.\n"
             + "\n"
             + "      Method: " + methName);
      }

//------------------------------------------------------------------------------
d1187 1
a1187 1
      mustBeEnabled ("Problem.eqHeurAlloc");
d1276 1
a1276 1
      mustBeEnabled ("Problem.getDefaultValue");
a1304 21
//------------------------------------------------------------------------------
// mustBeEnabled (methName)
//
// Verifies that this Problem is currently active and enabled.
// Arguments:
//    methName: The name of the method.
//------------------------------------------------------------------------------

   private void mustBeEnabled (String methName)
      {
      mustBeActive (methName);

      if (! enabled)
         throw
            new StatusQuoException (
               "   A method that requires an enabled Problem was called with\n"
             + "   a Problem that was not enabled.\n"
             + "\n"
             + "      Method: " + methName);
      }

a1325 25
// enabled
//
// True, iff this Problem is currently in an "enabled" state. A Problem is
// considered to be enabled, iff witInitialize has been invoked on the WitRun
// owned by the Problem. When a Problem is constructed, it is initially in an
// unenabled state. When the enable method is invoked on the Problem,
// witInitialize is invoked on the WitRun and the Problem becomes enabled.
//
// The following methods are the only non-static Problem methods that may be
// invoked on a Problem that is not enabled:
//
//    enable
//    isEnabled
//    deactivate
//    isActive
//    getMessageMgr
//    toString
//
// All other methods terminate the program with an error message if the Problem
// is not enabled.
//------------------------------------------------------------------------------

   private boolean enabled = false;

//------------------------------------------------------------------------------
@


1.182
log
@Implemented Problem.getActiveInstances ().
@
text
@d24 1
a24 1
// RetainedObject
d28 1
a28 1
public final class Problem extends RetainedObject
d1117 2
a1118 2
// Puts this Problem and the RetainedObjects that it owns into an inactive
// state. This Problem and the RetainedObjects that it owns cannot be
d1120 1
a1120 1
// Override from class RetainedObject.
d1211 1
a1211 1
// Override from class RetainedObject.
@


1.181
log
@Timing test.
@
text
@d1093 22
d1133 1
a1133 1
         assert (activeInstances.contains (this));
d1135 1
a1135 1
         activeInstances.remove (this);
d1239 1
a1239 1
      activeInstances.add (this);
d1452 1
a1452 1
// activeInstances
d1459 1
a1459 1
   private static final Set <Problem> activeInstances;
d1467 1
a1467 1
      activeInstances = new HashSet <Problem> (10);
@


1.180
log
@Aded temporary code to test the ability to measure CPU time.
@
text
@a1290 1
         theCommand.equals ("time-heur-implode")          ||
@


1.179
log
@Changed the name of class NewsVender to NewsVendor.
Further implementation of class NewsVendor.
@
text
@d1291 1
@


1.178
log
@theProblem.copyData (...).
@
text
@d223 17
d515 17
@


1.177
log
@Argument checking.
@
text
@d227 9
a235 5
         if (myCoordinator != null)
            throw
               new StatusQuoException (
                  "   The copyData method of class Problem was called.\n"
                + "   This method is not yet available.");
d237 1
a237 1
         assert (false);
d239 1
a239 1
         mustBeEnabled ("Problem.copyData");
@


1.176
log
@theProblem.clear ().
@
text
@a96 2
//
// Not yet available.
d223 23
d1125 24
a1345 23
//------------------------------------------------------------------------------
// mustBeEnabledAsArg
//
// Verifies that this Problem is currently active and enabled when it is an
// argument to a method.
//
// Arguments:
//    methName: The name of the method.
//------------------------------------------------------------------------------

   void mustBeEnabledAsArg (String methName)
      {
      mustBeActiveAsArg ("theProblem", methName);

      if (! enabled)
         throw
            new StatusQuoException (
               "   A unenabled Problem was passed as an argument to a method\n"
             + "   that requires an enabled Problem.\n"
             + "\n"
             + "      Method: " + methName);
      }

@


1.175
log
@Began implementation of theProblem.clear ().
@
text
@d92 2
a93 2
// Restores this Problem to a state equivalent to being newly enabled.
// Invokes witInitialize on the WitRun.
d96 1
a96 1
// Must not be called in this Problem is not enabled.
d107 3
a109 4
         throw
            new StatusQuoException (
               "   The clear method of class Problem was called.\n"
             + "   This method is not yet available.");
@


1.174
log
@Trivial revision.
@
text
@d61 1
a61 1
// Must not be called in this Problem is already enabled.
d90 30
@


1.173
log
@Setting BoundSet Attributes elements from a queue.
@
text
@d74 1
a74 1
                +    "with a Problem that's already enabled.");
@


1.172
log
@Changed name of recovery test to recovering test.
@
text
@d980 1
a980 1
// For each vector element value queued any Attribute, this method sets the
d982 1
@


1.171
log
@Setting vector elements from the queue.
@
text
@d992 3
a994 3
            myCoordinator.
               getAttImpFor (theAtt).
                  setElementsFromQueue ();
@


1.170
log
@Replaced theProblem.getInstances (theClass) with theProblem.GetParts (),
etc.
@
text
@d978 26
@


1.169
log
@Revised theProblem.getComponents ().
@
text
@d12 1
d568 1
a568 1
         return myCoordinator.getInstances (Component.class);
d578 1
a578 1
// getInstances (theCompClass)
d580 1
a580 3
// Returns an unmodifiable List of all instances of the Component class
// represented by theCompClass that belong to this Problem, listed in
// creation order.
d583 1
a583 1
   public <C extends Component> List <C> getInstances (Class <C> theCompClass)
d587 1
a587 1
         mustBeEnabled ("Problem.getInstances");
d589 1
a589 1
         return myCoordinator.getInstances (theCompClass);
d599 6
a604 1
// getGlobalAspect ().
d606 88
a693 1
// Access wrapper.
d696 1
a696 1
   public GlobalAspect getGlobalAspect ()
d700 1
a700 1
         mustBeEnabled ("Problem.getGlobalAspect");
d702 1
a702 1
         return myCoordinator.getGlobalAspect ();
@


1.168
log
@Implemented theProblem.getInstances (theCompClass).
@
text
@d128 1
a128 1
            Coordinator theCoord = null;
d130 3
a132 1
            theCoord.getComponents ();
d567 1
a567 1
         return myCoordinator.getComponents ();
@


1.167
log
@Changed the following methods to return an unmodifiable List:

   thePart     .getDemands     ()
   thePart     .getBomEntries  ()
   thePart     .getSubstitutes ()
   thePart     .getBopEntries  ()
   theOperation.getBomEntries  ()
   theOperation.getBopEntries  ()
   theBomEntry .getSubstitutes ()
@
text
@d79 1
a79 1
         enabled      = true;
d118 1
a118 1
            myCoordinator.record (theProblem.getGlobalAspect ());
d388 2
a389 1
         if (myCoordinator.getComponents ().size () > 1)
d394 1
d555 2
a556 1
// Return an unmodifiable List of all the Components for this Problem.
d575 23
@


1.166
log
@Changed theProblem.getComponents () to return an unmodifiable view.
@
text
@d553 1
a553 2
// Returns an unmodifiable view of a List of all the Components for this
// Problem.
@


1.165
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@d388 1
a388 1
         if (myCoordinator.hasPartsOpns ())
d553 2
a554 1
// Returns an array of all the Components for this Problem.
d557 1
a557 1
   public Component[] getComponents ()
@


1.164
log
@Changed name of GlobalComponent classes to GlobalAspect.
@
text
@d130 1
a130 1
            theCoord.getElements ();
d551 1
a551 1
// getElements ()
d553 1
a553 1
// Returns an array of all the Elements for this Problem.
d556 1
a556 1
   public Element[] getElements ()
d560 1
a560 1
         mustBeEnabled ("Problem.getElements");
d562 1
a562 1
         return myCoordinator.getElements ();
d1002 1
a1002 1
         theDemandCORArr[theIdx] = theTriple.getE      ().getDemandCOR ();
@


1.163
log
@Changed name of GlobalElement classes to GlobalComponent.
@
text
@d77 1
a77 1
         new GlobalComponent (myCoordinator);
d118 1
a118 1
            myCoordinator.record (theProblem.getGlobalComponent ());
d572 1
a572 1
// getGlobalComponent ().
d577 1
a577 1
   public GlobalComponent getGlobalComponent ()
d581 1
a581 1
         mustBeEnabled ("Problem.getGlobalComponent");
d583 1
a583 1
         return myCoordinator.getGlobalComponent ();
d667 1
a667 1
            return getGlobalComponent ().getNPeriods () - 1;
d766 1
a766 1
            theDefVal = getGlobalComponent ().getNPeriods () - 1;
d842 1
a842 1
         nPeriodsVal = getGlobalComponent ().getNPeriods ();
d1094 1
a1094 1
      if (theLength != getGlobalComponent ().getNPeriods ())
d1102 1
a1102 1
             + "      nPeriods:     " + getGlobalComponent ().getNPeriods ());
@


1.162
log
@Changed name of Problem method shutDown to deactivate.
@
text
@d77 1
a77 1
         new GlobalElement (myCoordinator);
d118 1
a118 1
            myCoordinator.record (theProblem.getGlobalElement ());
d572 1
a572 1
// getGlobalElement ().
d577 1
a577 1
   public GlobalElement getGlobalElement ()
d581 1
a581 1
         mustBeEnabled ("Problem.getGlobalElement");
d583 1
a583 1
         return myCoordinator.getGlobalElement ();
d667 1
a667 1
            return getGlobalElement ().getNPeriods () - 1;
d766 1
a766 1
            theDefVal = getGlobalElement ().getNPeriods () - 1;
d842 1
a842 1
         nPeriodsVal = getGlobalElement ().getNPeriods ();
d1094 1
a1094 1
      if (theLength != getGlobalElement ().getNPeriods ())
d1102 1
a1102 1
             + "      nPeriods:     " + getGlobalElement ().getNPeriods ());
@


1.161
log
@purgeData
@
text
@d859 1
a859 1
// shutDown ()
d861 3
a863 3
// Shuts down this Problem and the objects that it owns.
// This Problem and the objects it owns cannot be garbage-collected until this
// method is called.
d867 1
a867 1
   public void shutDown ()
d871 1
a871 1
         mustBeActive ("Problem.shutDown");
d873 3
a875 3
         myProblemCOR .shutDown ();
         myCoordinator.shutDown ();
         super        .shutDown ();
d1183 1
a1183 1
//    shutDown
d1199 1
a1199 1
// are shut down.
@


1.160
log
@purgeData
@
text
@a888 21
// toString ().
//
// Override from class Object.
//------------------------------------------------------------------------------

   public String toString ()
      {
      try
         {
         notAllowedWhenTerminated ("Problem.toString");

         return "Problem";
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
d929 11
@


1.159
log
@PurgeData
@
text
@d368 3
a370 1
         myCoordinator.purgeData ();
@


1.158
log
@writeCriticalList
@
text
@d362 17
@


1.157
log
@Implemented writeExecSched, writeShipSched, and writeReqSched.
@
text
@d420 26
@


1.156
log
@Concurrent pegging.
@
text
@d437 69
@


1.155
log
@Added the AllocTripleList classes.
@
text
@d176 17
@


1.154
log
@Moved set/get-PipSeq from class Problem to class GlobalElement.
@
text
@d194 1
a194 1
   public double[] eqHeurAlloc (ArrayList <AllocTriple <Demand>> theTriples)
d198 1
a198 1
         return eqHeurAllocInt (theTriples);
d850 1
a850 1
// eqHeurAllocInt (theTriples)
d852 1
a852 1
// Internal implementation of eqHeurAlloc (theTriples)
d855 2
a856 1
   private double[] eqHeurAllocInt (ArrayList <AllocTriple <Demand>> theTriples)
d868 2
a869 1
      myCoordinator.checkDemandTriples (theTriples, "theProblem.eqHeurAlloc");
d871 1
a871 1
      nTriples        = theTriples.size ();
d877 1
a877 1
      for (theIdx = 0; theIdx < theTriples.size (); theIdx ++)
d879 1
a879 1
         theTriple               = theTriples.get (theIdx);
@


1.153
log
@PIP
@
text
@a155 44
// setPipSeq (theTriples)
//
// Sets the PIP shipment sequence to the list of AllocTriples in theTriples.
//------------------------------------------------------------------------------

   public void setPipSeq (ArrayList <AllocTriple <Demand>> theTriples)
      {
      try
         {
         setPipSeqInt (theTriples);
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// getPipSeq (theTriples)
//
// Sets theTriples to the PIP shipment sequence.
//------------------------------------------------------------------------------

   public void getPipSeq (ArrayList <AllocTriple <Demand>> theTriples)
      {
      try
         {
         mustBeEnabled ("Problem.getPipSeq");

         myCoordinator.holdAllocTripleList (theTriples, Demand.class);

         myProblemCOR.getPipSeq ();

         myCoordinator.releaseAllocTripleList ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
a849 26
// setPipSeqInt (theTriples)
//
// Internal implementation of setPipSeq (theTriples)
//------------------------------------------------------------------------------

   private void setPipSeqInt (ArrayList <AllocTriple <Demand>> theTriples)
      {
      DemandCOR theDemandCOR;
      int       theShipPer;
      double    incShipVol;

      checkDemandTriples (theTriples, "setPipSeq");

      callSimpleWitFunc ("witClearPipSeq");

      for (AllocTriple <Demand> theTriple: theTriples)
         {
         theDemandCOR = theTriple.getE      ().getDemandCOR ();
         theShipPer   = theTriple.getPeriod ();
         incShipVol   = theTriple.getVolume ();

         theDemandCOR.appendToPipSeq (theShipPer, incShipVol);
         }
      }

//------------------------------------------------------------------------------
a863 1
      checkDemandTriples (theTriples, "eqHeurAlloc");
d865 5
a869 1
      nTriples = theTriples.size ();
a888 47
// checkDemandTriples (theTriples, theMethName)
//
// Performs error checking for a call to a method whose name is given by
// theMethName, where theTriples is its argument.
//------------------------------------------------------------------------------

   private void checkDemandTriples (
         ArrayList <AllocTriple <Demand>> theTriples,
         String                           theMethName)
      {
      int                  theIdx;
      AllocTriple <Demand> theTriple;

      mustBeEnabled              ("Problem." + theMethName);
      mustBeNonNull (theTriples,
                    "theTriples", "Problem." + theMethName);

      for (theIdx = 0; theIdx < theTriples.size (); theIdx ++)
         {
         theTriple = theTriples.get (theIdx);

         if (! theTriple.getE ().isActive ())
            throw
               new StatusQuoException (
                  "   In a call to theProblem."
                +     theMethName + " (theTriples),\n"
                + "   theTriples contained an AllocTriple <Demand> whose\n"
                + "   Demand was inactive.\n"
                + "\n"
                + "      List Index: " + theIdx + "\n"
                + "      Demand:     " + theTriple.getE ());

         if (theTriple.getE ().getCoordinator () != myCoordinator)
            throw
               new StatusQuoException (
                  "   In a call to theProblem."
                +     theMethName + " (theTriples),\n"
                + "   theTriples contained an AllocTriple <Demand> whose\n"
                + "   Demand does not belong to the Problem for which\n"
                + "   " + theMethName + " was called.\n"
                + "\n"
                + "      List Index: " + theIdx + "\n"
                + "      Demand:     " + theTriple.getE ());
         }
      }

//------------------------------------------------------------------------------
d897 1
a897 1
      getProblemCOR ().callSimpleWitFunc (theFuncName);
@


1.152
log
@Removed the ShipTriple classes.
@
text
@d186 2
d190 1
a190 1
         myCoordinator.acquireAllocTriples (theTriples, Demand.class);
@


1.151
log
@PIP
@
text
@d925 6
a930 2
      ShipTripleCOR[] theTripleCORArr;
      double[]        theIncVolArr;
d934 1
a934 1
      theTripleCORArr = AllocTriple.newShipTripleCORArr (theTriples);
d936 3
a938 1
      theIncVolArr    = myProblemCOR.eqHeurAlloc (theTripleCORArr);
d940 3
a942 2
      for (ShipTripleCOR theTripleCOR: theTripleCORArr)
         theTripleCOR.shutDown ();
d944 7
a950 1
      return theIncVolArr;
@


1.150
log
@*** empty log message ***
@
text
@d240 1
a240 13
         ShipTripleCOR[] theTripleCORArr;
         double[]        theIncVolArr;

         checkDemandTriples (theTriples, "eqHeurAlloc");

         theTripleCORArr = AllocTriple.newShipTripleCORArr (theTriples);

         theIncVolArr    = myProblemCOR.eqHeurAlloc (theTripleCORArr);

         for (ShipTripleCOR theTripleCOR: theTripleCORArr)
            theTripleCOR.shutDown ();

         return theIncVolArr;
d918 23
@


1.149
log
@PIP.
@
text
@d243 1
a243 1
         checkAllocTriples (theTriples, "eqHeurAlloc");
d915 1
a915 1
      checkAllocTriples (theTriples, "setPipSeq");
d921 3
a923 3
         theDemandCOR = theTriple.getSubElement ().getDemandCOR ();
         theShipPer   = theTriple.getPeriod     ();
         incShipVol   = theTriple.getVolume     ();
d930 1
a930 1
// checkAllocTriples (theTriples, theMethName)
d936 1
a936 1
   private void checkAllocTriples (
d951 1
a951 1
         if (! theTriple.getSubElement ().isActive ())
d960 1
a960 1
                + "      Demand:     " + theTriple.getSubElement ());
d962 1
a962 1
         if (theTriple.getSubElement ().getCoordinator () != myCoordinator)
d972 1
a972 1
                + "      Demand:     " + theTriple.getSubElement ());
@


1.148
log
@Implemented getPipSeq.
@
text
@d165 1
a165 10
         ShipTripleCOR[] theTripleCORArr;

         checkValidity (theTriples, "setPipSeq");

         theTripleCORArr = AllocTriple.newShipTripleCORArr (theTriples);

         myProblemCOR.setPipSeq (theTripleCORArr);

         for (ShipTripleCOR theTripleCOR: theTripleCORArr)
            theTripleCOR.shutDown ();
d243 1
a243 1
         checkValidity (theTriples, "eqHeurAlloc");
d904 27
a930 1
// checkValidity (theTriples, theMethName)
d936 1
a936 1
   private void checkValidity (
@


1.147
log
@Implemented buildPip and setPipSeq.
@
text
@d184 23
d934 1
a934 1
         if (! theTriple.getE ().isActive ())
d943 1
a943 1
                + "      Demand:     " + theTriple.getE ());
d945 1
a945 1
         if (theTriple.getE ().getCoordinator () != myCoordinator)
d955 1
a955 1
                + "      Demand:     " + theTriple.getE ());
@


1.146
log
@Replaced the AllocTarget classes with ShipTriple classes.
@
text
@d156 28
d187 17
d226 4
a229 1
         eqHeurAllocErrorCheck  (theTriples);
d231 8
a238 1
         return eqHeurAllocMain (theTriples);
d890 1
a890 1
// eqHeurAllocErrorCheck (theTriples)
d892 2
a893 1
// Performs error checking for eqHeurAlloc.
d896 3
a898 2
   private void eqHeurAllocErrorCheck (
         ArrayList <AllocTriple <Demand>> theTriples)
d903 1
a903 1
      mustBeEnabled              ("Problem.eqHeurAlloc");
d905 1
a905 1
                    "theTriples", "Problem.eqHeurAlloc");
d914 2
a915 1
                  "   In a call to theProblem.eqHeurAlloc (theTriples),\n"
d925 2
a926 1
                  "   In a call to theProblem.eqHeurAlloc (theTriples),\n"
d929 1
a929 1
                + "   eqHeurAlloc was called.\n"
a936 41
// eqHeurAllocMain (theTriples)
//
// Performs the main logic of eqHeurAlloc
//------------------------------------------------------------------------------

   private double[] eqHeurAllocMain (
         ArrayList <AllocTriple <Demand>> theTriples)
      {
      int                  nTriples;
      ShipTripleCOR[]      theTripleCORArr;
      int                  theIdx;
      AllocTriple <Demand> theTriple;
      double[]             theIncVolArr;


      nTriples        = theTriples.size ();

      theTripleCORArr = new ShipTripleCOR[nTriples];

      for (theIdx = 0; theIdx < nTriples; theIdx ++)
         {
         theTriple = theTriples.get (theIdx);

         theTripleCORArr[theIdx] =
            new ShipTripleCOR (
               theTriple.getE      ().getDemandCOR (),
               theTriple.getPeriod (),
               theTriple.getVolume ());
         }

      theIncVolArr = myProblemCOR.eqHeurAlloc (theTripleCORArr);

      for (theIdx = 0; theIdx < nTriples; theIdx ++)
         {
         theTripleCORArr[theIdx].shutDown ();
         }

      return theIncVolArr;
      }

//------------------------------------------------------------------------------
@


1.145
log
@Replaced Java class AllocTarget with AllocTriple <Demand>.
@
text
@d887 1
a887 1
      AllocTargetCOR[]     theTargetCORArr;
d895 1
a895 1
      theTargetCORArr = new AllocTargetCOR[nTriples];
d901 2
a902 2
         theTargetCORArr[theIdx] =
            new AllocTargetCOR (
d908 1
a908 3
      myProblemCOR.eqHeurAlloc (theTargetCORArr);

      theIncVolArr = new double[nTriples];
d912 1
a912 3
         theIncVolArr[theIdx] = theTargetCORArr[theIdx].getIncVol ();

         theTargetCORArr[theIdx].shutDown ();
@


1.144
log
@Problem.eqHeurAlloc.
@
text
@d177 1
a177 1
   public void eqHeurAlloc (AllocTarget[] theTargetArr)
d181 3
a183 2
         eqHeurAllocErrorCheck (theTargetArr);
         eqHeurAllocMain       (theTargetArr);
d835 1
a835 1
// eqHeurAllocErrorCheck (theTargetArr)
d840 2
a841 1
   private void eqHeurAllocErrorCheck (AllocTarget[] theTargetArr)
d843 2
a844 2
      int         theIdx;
      AllocTarget theTarget;
d846 3
a848 3
      mustBeEnabled                ("Problem.eqHeurAlloc");
      mustBeNonNull (theTargetArr,
                    "theTargetArr", "Problem.eqHeurAlloc");
d850 1
a850 1
      for (theIdx = 0; theIdx < theTargetArr.length; theIdx ++)
d852 1
a852 1
         theTarget = theTargetArr[theIdx];
d854 1
a854 1
         if (! theTarget.getDemand ().isActive ())
d857 2
a858 2
                  "   The AllocTarget array argument that was passed to\n"
                + "   Problem.eqHeurAlloc contained an AllocTarget whose\n"
d861 2
a862 2
                + "      Array Index: " + theIdx + "\n"
                + "      Demand:      " + theTarget.getDemand ());
d864 1
a864 1
         if (theTarget.getDemand ().getCoordinator () != myCoordinator)
d867 2
a868 2
                  "   The AllocTarget array argument that was passed to\n"
                + "   Problem.eqHeurAlloc contained an AllocTarget whose\n"
d872 2
a873 2
                + "      Array Index: " + theIdx + "\n"
                + "      Demand:      " + theTarget.getDemand ());
d878 1
a878 1
// eqHeurAllocMain (theTargetArr)
d883 2
a884 1
   private void eqHeurAllocMain (AllocTarget[] theTargetArr)
d886 6
a891 5
      int              nTargets;
      AllocTargetCOR[] theTargetCORArr;
      int              theIdx;
      AllocTarget      theTarget;
      double           theIncVol;
d893 1
a893 1
      nTargets        = theTargetArr.length;
d895 1
a895 1
      theTargetCORArr = new AllocTargetCOR[nTargets];
d897 1
a897 1
      for (theIdx = 0; theIdx < nTargets; theIdx ++)
d899 1
a899 1
         theTarget = theTargetArr[theIdx];
d903 3
a905 3
               theTarget.getDemand    ().getDemandCOR (),
               theTarget.getShipPer   (),
               theTarget.getDesIncVol ());
d910 3
a912 1
      for (theIdx = 0; theIdx < nTargets; theIdx ++)
d914 1
a914 3
         theIncVol = theTargetCORArr[theIdx].getIncVol ();

         theTargetArr   [theIdx].setIncVol (theIncVol);
d918 2
@


1.143
log
@Heuristic Allocation
@
text
@d177 16
d834 83
@


1.142
log
@Part.Category as Alternative
@
text
@d194 17
d337 34
@


1.141
log
@Self-Test.
@
text
@d757 1
a757 1
      myCoordinator = new Coordinator (this);
@


1.140
log
@Coordinator
@
text
@d46 1
a46 1
         return new Problem (false);
d107 1
a107 1
            myCoordinator.selfTest ();
a731 13
// Package-Internal Constructor
//==============================================================================

   Problem (boolean forSelfTest)
      {
      activeInstances.add (this);

      myCoordinator = new Coordinator (this, forSelfTest);

      myProblemCOR  = new ProblemCOR (myCoordinator.getCoordinatorCOR ());
      }

//==============================================================================
d750 13
@


1.139
log
@Coordinator
@
text
@a730 10
//------------------------------------------------------------------------------

   static Problem getStaticInstance ()
      {
      if (myStaticInstance == null)
         myStaticInstance = Problem.newInstance ();

      return myStaticInstance;
      }

a949 8
// myStaticInstance
//
// A Problem to be used as needed by various static methods.
//------------------------------------------------------------------------------

   private static Problem myStaticInstance = null;

//------------------------------------------------------------------------------
@


1.138
log
@Coordinator
@
text
@d107 1
a107 1
            selfTest ();
d742 13
a771 20
   boolean isSelfTesting ()
      {
      return selfTesting;
      }

//==============================================================================
// Private Constructor
//==============================================================================

   private Problem (boolean selfTestingVal)
      {
      activeInstances.add (this);

      selfTesting   = selfTestingVal;

      myCoordinator = new Coordinator (this);

      myProblemCOR  = new ProblemCOR (myCoordinator.getCoordinatorCOR ());
      }

a776 36
// selfTest ()
//
// Performs various tests of WIT-J that cannot be done by calling public
// methods.
//------------------------------------------------------------------------------

   private void selfTest ()
      {
      Problem theProblem;

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Performing a self-test.\n"
         + "----------------------------------------"
         + "----------------------------------------");

      AttID.selfTest ();

      theProblem = new Problem (true);

      theProblem.enable ();

      theProblem.shutDown ();

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Self-test complete.\n"
         + "----------------------------------------"
         + "----------------------------------------");
      }

//------------------------------------------------------------------------------
a918 8
// selfTesting
//
// True, iff this Problem is currently performing a self-test.
//------------------------------------------------------------------------------

   private final boolean selfTesting;

//------------------------------------------------------------------------------
@


1.137
log
@Coordinator
@
text
@d772 1
a772 1
      selfTesting  = selfTestingVal;
d941 1
a941 1
//    methName:   The name of the method.
@


1.136
log
@Coordinator
@
text
@a658 1
         myMessageMgr .shutDown ();
d705 1
a705 1
         return myMessageMgr;
a776 2

      myMessageMgr  = new MessageMgr (myCoordinator);
a985 8
// myMessageMgr.
//
// The MessageMgr that belongs to this Problem.
//------------------------------------------------------------------------------

   private final MessageMgr myMessageMgr;

//------------------------------------------------------------------------------
@


1.135
log
@Coordinator
@
text
@d128 1
a128 1
            Coordinator theCoordinator = null;
d130 1
a130 1
            theCoordinator.getElements ();
@


1.134
log
@Removed java class ElementMgr, moving its responsibilities to class
Coordinator.
@
text
@d777 1
a777 1
      myProblemCOR  = new ProblemCOR (this, myCoordinator.getCoordinatorCOR ());
@


1.133
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@d77 1
a77 1
         myElementMgr = new ElementMgr (this);
d116 3
a118 1
            theProblem.getElementMgr ();
d128 1
a128 1
            ElementMgr theElementMgr = null;
d130 1
a130 1
            theElementMgr.getElements ();
d303 1
a303 1
         if (myElementMgr.hasPartsOpns ())
d348 1
a348 1
         return myElementMgr.getElements ();
d369 1
a369 1
         return myElementMgr.getGlobalElement ();
d391 1
a391 1
         return myElementMgr.getPart (thePartName);
d413 1
a413 1
         return myElementMgr.getOperation (theOpnName);
d659 4
a662 7
         if (enabled)
            myElementMgr.shutDown ();

         myMessageMgr   .shutDown ();
         myProblemCOR   .shutDown ();
         myCoordinator  .shutDown ();
         super          .shutDown ();
a759 7
   ElementMgr getElementMgr ()
      {
      assert (enabled);

      return myElementMgr;
      }

a996 8
// myElementMgr.
//
// The ElementMgr that belongs to this Problem.
//------------------------------------------------------------------------------

   private ElementMgr myElementMgr = null;

//------------------------------------------------------------------------------
@


1.132
log
@Continued implementation of Java class ProbMgr.
@
text
@d662 1
a662 1
         myProbMgr      .shutDown ();
d751 1
a751 1
   ProbMgr getProbMgr ()
d753 1
a753 1
      return myProbMgr;
d783 5
a787 3
      myProbMgr    = new ProbMgr    (this);
      myProblemCOR = new ProblemCOR (this, myProbMgr.getProbMgrCOR ());
      myMessageMgr = new MessageMgr (myProbMgr);
d981 1
a981 1
// myProbMgr.
d983 1
a983 1
// The ProbMgr that belongs to this Problem.
d986 1
a986 1
   private final ProbMgr myProbMgr;
@


1.131
log
@Continued implementation of java class ProbMgr.
@
text
@d664 4
d779 2
d1043 19
@


1.130
log
@Continued implementation of the ProbMgr classes.
@
text
@d729 10
d1029 8
@


1.129
log
@Java ProbMgr
@
text
@d821 1
a821 1
      myProbMgr.getProbMgrCOR ().callSimpleWitFunc (theFuncName);
@


1.128
log
@ProbMgr classes.
@
text
@a660 1
         myAttRepMgr    .shutDown ();
a746 5
   AttRepMgr getAttRepMgr ()
      {
      return myAttRepMgr;
      }

a768 1
      myAttRepMgr  = new AttRepMgr  (this);
a978 8
// myAttRepMgr.
//
// The AttRepMgr that belongs to this Problem.
//------------------------------------------------------------------------------

   private final AttRepMgr myAttRepMgr;

//------------------------------------------------------------------------------
@


1.127
log
@ProbMgr classes.
@
text
@a664 4

         assert (activeInstances.contains (this));

         activeInstances.remove (this);
a764 8
   static Problem getStaticInstance ()
      {
      if (ourStaticInstance == null)
          ourStaticInstance = Problem.newInstance ();

      return ourStaticInstance;
      }

a770 2
      activeInstances.add (this);

d773 1
a773 1
      myProbMgr    = new ProbMgr    ();
a1033 27
//------------------------------------------------------------------------------
// ourStaticInstance
//
// A Problem to be used as needed by various static methods.
//------------------------------------------------------------------------------

   private static Problem ourStaticInstance = null;

//------------------------------------------------------------------------------
// activeInstances
//
// The set of all Problems in the program process that are currently active.
// Their presence in this Set prevents them from being garbage-collected until
// they are shut down.
//------------------------------------------------------------------------------

   private static final Set <Problem> activeInstances;

//==============================================================================
// Static initialization block
//==============================================================================

   static
      {
      activeInstances = new HashSet <Problem> (10);
      }

@


1.126
log
@ProbMgr classes.
@
text
@d181 1
a181 1
         myProblemCOR.callSimpleWitFunc ("witEvalObjectives");
d198 1
a198 1
         myProblemCOR.callSimpleWitFunc ("witGeneratePriorities");
d215 1
a215 1
         myProblemCOR.callSimpleWitFunc ("witHeurImplode");
d232 1
a232 1
         myProblemCOR.callSimpleWitFunc ("witMrp");
d249 1
a249 1
         myProblemCOR.callSimpleWitFunc ("witOptImplode");
d266 1
a266 1
         myProblemCOR.callSimpleWitFunc ("witPostprocess");
d283 1
a283 1
         myProblemCOR.callSimpleWitFunc ("witPreprocess");
d834 12
@


1.125
log
@Change the mname of the ProbCtr classes to ProbMgr in both Java and C++.
@
text
@d790 1
a790 1
      myMessageMgr = new MessageMgr (this);
@


1.124
log
@Continued implementation of the ProbCtr classes.
@
text
@d663 1
a663 1
         myProbCtr      .shutDown ();
d742 1
a742 1
   ProbCtr getProbCtr ()
d744 1
a744 1
      return myProbCtr;
d787 2
a788 2
      myProbCtr    = new ProbCtr    ();
      myProblemCOR = new ProblemCOR (this, myProbCtr.getProbCtrCOR ());
d972 1
a972 1
// myProbCtr.
d974 1
a974 1
// The ProbCtr that belongs to this Problem.
d977 1
a977 1
   private final ProbCtr myProbCtr;
@


1.123
log
@Continued implementation of ProbCtr classes.
@
text
@d660 2
a663 2
         myMessageMgr   .shutDown ();
         myAttRepMgr    .shutDown ();
d742 1
a742 1
   AttRepMgr getAttRepMgr ()
d744 1
a744 1
      return myAttRepMgr;
d752 5
d972 1
a972 1
// myProblemCOR.
d974 1
a974 1
// The ProblemCOR that belongs to this Problem.
d977 1
a977 1
   private final ProblemCOR myProblemCOR;
d980 1
a980 1
// myProbCtr.
d982 1
a982 1
// The ProbCtr that belongs to this Problem.
d985 1
a985 1
   private final ProbCtr myProbCtr;
@


1.122
log
@Initial implementation of Java classes ProbCtrCOR ProbCtr.
@
text
@d782 2
a783 2
      myProblemCOR = new ProblemCOR (this);
      myProbCtr    = new ProbCtr    (this);
@


1.121
log
@Initial implementation of C++ class ProbCtr.
@
text
@d661 1
d783 1
d975 8
@


1.120
log
@Implemented method writeData of class Problem.
@
text
@d19 1
a19 2
// Each instance of class Problem corresponds to a WitRun which may or may not
// be initialized.
@


1.119
log
@Implemented the following methods of class Problem:
   mrp
   optImplode
   preprocess
@
text
@d318 18
@


1.118
log
@Implemented SimpleWitFuncs and used them for 4 methods.
@
text
@d227 34
d278 17
@


1.117
log
@Added code to handle running out of memory in WIT.
@
text
@d182 1
a182 1
         myProblemCOR.evalObjectives ();
d199 1
a199 1
         myProblemCOR.generatePriorities ();
d216 1
a216 1
         myProblemCOR.heurImplode ();
d233 1
a233 1
         myProblemCOR.postprocess ();
@


1.116
log
@Implemented the handling of fatal errors from WIT.
@
text
@d773 1
@


1.115
log
@Added code to handle memory errors in makeJString.
@
text
@d772 2
a773 1
         theCommand.equals ("exhaust-memory-in-jni");
@


1.114
log
@Added code to handle Java exceptions raised during the execution of JNI
   functions.
@
text
@d771 2
a772 1
         theCommand.equals ("trigger-jni-exception");
@


1.113
log
@Added code to handle a memory overflow in the C++ side of WIT-J.
@
text
@d101 6
a106 1
         if (theCommand.equals ("self-test"))
a136 15
         else if (theCommand.equals ("fail-c++-exception-assert"))
            {
            myProblemCOR.performAction (theCommand);
            }

         else if (theCommand.equals ("fail-c++-aborting-assert"))
            {
            myProblemCOR.performAction (theCommand);
            }

         else if (theCommand.equals ("exhaust-memory-in-witj-c++"))
            {
            myProblemCOR.performAction (theCommand);
            }

d759 16
@


1.112
log
@Split unrecoverable error testing from the rest of the tests.
@
text
@d105 2
a106 1
         else if (theCommand.equals ("incur-java-assertion-error"))
d114 1
d119 1
d126 1
d131 1
d136 1
d141 6
d789 2
a790 1
         println (totDiscarded + "MB of memory have been allocated.");
@


1.111
log
@Added a test for ABORTING_ASSERT.
@
text
@d105 1
a105 1
         else if (theCommand.equals ("incur-assertion-error"))
d113 5
a117 1
         else if (theCommand.equals ("throw-unexpected-Throwable"))
d757 25
@


1.110
log
@Allowed all WitjExceptions to pass through the canonical try-block.
@
text
@d123 5
a127 1
         else if (theCommand.equals ("incur-c++-assertion-failure"))
@


1.109
log
@Removed an unneeded test case.
@
text
@d70 11
a80 1
         enablePvt ();
d579 11
a589 1
         shutDownPvt ();
a659 36
// selfTest ()
//
// Performs various tests of WIT-J that cannot be done by calling public
// methods.
//------------------------------------------------------------------------------

   void selfTest ()
      {
      Problem theProblem;

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Performing a self-test.\n"
         + "----------------------------------------"
         + "----------------------------------------");

      AttID.selfTest ();

      theProblem = new Problem (true);

      theProblem.enablePvt ();

      theProblem.shutDownPvt ();

      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Self-test complete.\n"
         + "----------------------------------------"
         + "----------------------------------------");
      }

//------------------------------------------------------------------------------
d713 36
a829 46
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// enablePvt ()
//
// Private version of enable.
//------------------------------------------------------------------------------

   private void enablePvt ()
      {
      if (enabled)
         throw
            new StatusQuoException (
               "   The enable method was called "
             +    "with a Problem that's already enabled.");

      myProblemCOR.enable ();

      myElementMgr = new ElementMgr (this);

      enabled      = true;
      }

//------------------------------------------------------------------------------
// shutDownPvt ()
//
// Private version of shutDown.
//------------------------------------------------------------------------------

   private void shutDownPvt ()
      {
      if (enabled)
         myElementMgr.shutDown ();

      myProblemCOR   .shutDown ();
      myMessageMgr   .shutDown ();
      myAttRepMgr    .shutDown ();
      super          .shutDown ();

      assert (activeInstances.contains (this));

      activeInstances.remove (this);
      }

//==============================================================================
@


1.108
log
@theProblem.performAction (theCommand)
@
text
@d111 1
a111 5
            myProblemCOR.performAction (theCommand);
            }
         else if (theCommand.equals ("throw-unexpected-c++-exception-value"))
            {
            myProblemCOR.throwUnexpExceptionBool ();
@


1.107
log
@theProblem.performAction (theCommand)
@
text
@d80 1
a80 1
// performActionInJava (theCommand)
a82 1
// The action is performed in the Java code.
d85 1
a85 1
   public void performActionInJava (String theCommand)
d89 1
a89 1
         mustBeActive ("Problem.performActionInJava");
d109 12
d125 1
a125 1
                  "   Problem.performActionInJava (theCommand) was called\n"
a138 67
// throwUnexpCppException
//
// Causes the C++ portion of WIT-J to throw an exception of unexpected type.
// For testing purposes.
//------------------------------------------------------------------------------

   public void throwUnexpCppException ()
      {
      try
         {
         mustBeEnabled ("Problem.throwUnexpCppException");

         myProblemCOR.throwUnexpException ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// throwUnexpCppExceptionBool
//
// Causes the C++ portion of WIT-J to throw an exception of unexpected type.
// Nominally returns a (meaningless) boolean.
// For testing purposes.
//------------------------------------------------------------------------------

   public boolean throwUnexpCppExceptionBool ()
      {
      try
         {
         mustBeEnabled ("Problem.throwUnexpCppExceptionBool");

         return myProblemCOR.throwUnexpExceptionBool ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
// incurCppAssertFailure
//
// Causes the C++ portion of WIT-J to throw an exception of unexpected type.
// For testing purposes.
//------------------------------------------------------------------------------

   public void incurCppAssertFailure ()
      {
      try
         {
         mustBeEnabled ("Problem.incurCppAssertFailure");

         myProblemCOR.incurAssertFailure ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
@


1.106
log
@Partial implementation of Problem.performActionIJava (...).
@
text
@d92 13
a104 1
         if (theCommand.equals ("throw-unexpected-Throwable"))
a127 46
// selfTest ()
//
// Performs various tests of WIT-J that cannot be done by calling (other) public
// methods.
//------------------------------------------------------------------------------

   public static void selfTest ()
      {
      try
         {
         Problem theProblem;

         notAllowedWhenTerminated ("Problem.selfTest");

         println (
              "\n"
            + "----------------------------------------"
            + "----------------------------------------\n"
            + "Performing a self-test.\n"
            + "----------------------------------------"
            + "----------------------------------------");

         AttID.selfTest ();

         theProblem = new Problem (true);

         theProblem.enablePvt ();

         theProblem.shutDownPvt ();

         println (
              "\n"
            + "----------------------------------------"
            + "----------------------------------------\n"
            + "Self-test complete.\n"
            + "----------------------------------------"
            + "----------------------------------------");
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
d700 36
@


1.105
log
@Added test for an invalid command to performActionInJava.
@
text
@d92 1
a92 1
         if (false)
d94 3
@


1.104
log
@Changed a Java class name: WitjAbortsException ==> TerminalException
@
text
@d80 33
@


1.103
log
@Changed class name: NonFunctionalException ==> WitjAbortsException
@
text
@d45 1
a45 1
         witjAbortedNotAllowed ("Problem.newInstance");
d92 1
a92 1
         witjAbortedNotAllowed ("Problem.selfTest");
d646 1
a646 1
         witjAbortedNotAllowed ("Problem.toString");
@


1.102
log
@Added test of C++ assertion failure.
@
text
@d45 1
a45 1
         witjMustBeFunctional ("Problem.newInstance");
d92 1
a92 1
         witjMustBeFunctional ("Problem.selfTest");
d646 1
a646 1
         witjMustBeFunctional ("Problem.toString");
@


1.101
log
@Minor revision.
@
text
@d171 22
@


1.100
log
@Implemented the C++ canonical try block macros.
@
text
@d24 2
a25 2
//    RetainedObject
//       Problem
@


1.99
log
@Implementated class AssertionErrorException.
@
text
@d126 45
@


1.98
log
@Moved more responsibility into class NonFunctionalException.
@
text
@a590 24
// throwUnexpectedThrowable
//
// Throws an instance of Throwable class not expected by WIT-J.
// Used for testing WIT-J.
//------------------------------------------------------------------------------

   public void throwUnexpectedThrowable ()
      {
      try
         {
         ElementMgr theElementMgr = null;

         theElementMgr.getElements ();
            //
            // Causes a NullPointerException to be thrown.
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
@


1.97
log
@Changed class name: FatalException ==> NonFunctionalException
@
text
@a614 19
// witjIsFunctional ()
//
// Returns true, iff WIT-J is currently considered to be in a functional state.
//------------------------------------------------------------------------------

   public static boolean witjIsFunctional ()
      {
      try
         {
         return NonFunctionalException.witjIsFunctional ();
         }

      catch (Throwable theThrowable)
         {
         throw getWitjExceptionFor (theThrowable);
         }
      }

//------------------------------------------------------------------------------
@


1.96
log
@Added code to test WIT-J's response to catching an instance of an
unexpected Throwable class.
@
text
@d624 1
a624 1
         return FatalException.witjIsFunctional ();
@


1.95
log
@Added text to the detail message of StatusQuoExceptions.
@
text
@d591 24
@


1.94
log
@Changed name of class IntactException to StatusQuoException.
@
text
@d223 4
a226 4
            throw new StatusQuoException (
                 "\n\n"
               + "   Problem.readData was called with a Problem\n"
               + "   that has one or more Parts or Operations.\n");
d713 4
a716 4
         throw new StatusQuoException (
              "\n\n"
            + "   Problem.getDefaultValue was called with\n"
            + "   an Attribute that does not have a default value.\n");
d729 8
a736 9
         throw new StatusQuoException (
              "\n\n"
            + "   Problem.getDefaultValue was called with an array\n"
            + "   whose length does not match nPeriods for the Problem.\n"
            + "\n"
            + "      Attribute:    " + theAtt       + "\n"
            + "      Array Length: " + theLength    + "\n"
            + "      nPeriods:     " + getGlobalElement ().getNPeriods ()
                                     + "\n");
d752 6
a757 6
         throw new StatusQuoException (
              "\n\n"
            + "   A method that requires an enabled Problem was called with\n"
            + "   a Problem that was not enabled.\n"
            + "\n"
            + "      Method: " + methName + "\n");
d775 6
a780 6
         throw new StatusQuoException (
              "\n\n"
            + "   A unenabled Problem was passed as an argument to a method\n"
            + "   that requires an enabled Problem.\n"
            + "\n"
            + "      Method: " + methName + "\n");
d796 4
a799 4
         throw new StatusQuoException (
              "\n\n"
            + "   The enable method was called " 
            +    "with a Problem that's already enabled.\n");
@


1.93
log
@Removed some internal calls to public methods.
@
text
@d223 1
a223 1
            throw new IntactException (
d713 1
a713 1
         throw new IntactException (
d729 1
a729 1
         throw new IntactException (
d753 1
a753 1
         throw new IntactException (
d776 1
a776 1
         throw new IntactException (
d797 1
a797 1
         throw new IntactException (
@


1.92
log
@Added canonical try blocks to all public methods of class Problem.
@
text
@d70 1
a70 11
         if (enabled)
            throw new IntactException (
                 "\n\n"
               + "   The enable method was called " 
               +    "with a Problem that's already enabled.\n");

         myProblemCOR.enable ();

         myElementMgr = new ElementMgr (this);

         enabled      = true;
d106 1
a106 1
         theProblem.enable ();
d108 1
a108 1
         theProblem.shutDown ();
d145 2
d162 2
d179 2
d196 2
d213 2
d345 2
d365 2
d382 2
d435 2
d469 2
d560 1
a560 11
         if (enabled)
            myElementMgr.shutDown ();

         myProblemCOR   .shutDown ();
         myMessageMgr   .shutDown ();
         myAttRepMgr    .shutDown ();
         super          .shutDown ();

         assert (activeInstances.contains (this));

         activeInstances.remove (this);
d628 2
d761 69
@


1.91
log
@Added class FatalException.
Removed class ExceptionHandler.
@
text
@d43 6
a48 1
      witjMustBeFunctional ("Problem.newInstance");
d50 4
a53 1
      return new Problem (false);
d66 3
a68 1
      mustBeActive ("Problem.enable");
d70 5
a74 5
      if (enabled)
         throw new IntactException (
              "\n\n"
            + "   The enable method was called " 
            +    "with a Problem that's already enabled.\n");
d76 1
a76 1
      myProblemCOR.enable ();
d78 1
a78 1
      myElementMgr = new ElementMgr (this);
d80 7
a86 1
      enabled      = true;
d98 3
a100 1
      Problem theProblem;
d102 1
a102 1
      witjMustBeFunctional ("Problem.selfTest");
d104 7
a110 7
      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Performing a self-test.\n"
         + "----------------------------------------"
         + "----------------------------------------");
d112 1
a112 1
      AttID.selfTest ();
d114 1
a114 1
      theProblem = new Problem (true);
d116 1
a116 1
      theProblem.enable ();
d118 1
a118 1
      theProblem.shutDown ();
d120 13
a132 7
      println (
           "\n"
         + "----------------------------------------"
         + "----------------------------------------\n"
         + "Self-test complete.\n"
         + "----------------------------------------"
         + "----------------------------------------");
d141 7
a147 2
      mustBeEnabled                       ("Problem.displayData");
      mustBeNonNull (fileName, "fileName", "Problem.displayData");
d149 4
a152 1
      myProblemCOR.displayData (fileName);
d157 6
a162 1
      mustBeEnabled ("Problem.evalObjectives");
d164 4
a167 1
      myProblemCOR.evalObjectives ();
d172 6
a177 1
      mustBeEnabled ("Problem.generatePriorities");
d179 4
a182 1
      myProblemCOR.generatePriorities ();
d187 3
a189 1
      mustBeEnabled ("Problem.heurImplode");
d191 7
a197 1
      myProblemCOR.heurImplode ();
d202 3
a204 1
      mustBeEnabled ("Problem.postprocess");
d206 7
a212 1
      myProblemCOR.postprocess ();
d217 4
a220 2
      mustBeEnabled                       ("Problem.readData");
      mustBeNonNull (fileName, "fileName", "Problem.readData");
d222 8
a229 5
      if (myElementMgr.hasPartsOpns ())
         throw new IntactException (
              "\n\n"
            + "   Problem.readData was called with a Problem\n"
            + "   that has one or more Parts or Operations.\n");
d231 4
a234 1
      myProblemCOR.readData (fileName);
d245 3
a247 1
      mustBeEnabled ("Problem.getElements");
d249 7
a255 1
      return myElementMgr.getElements ();
d266 3
a268 1
      mustBeEnabled ("Problem.getGlobalElement");
d270 7
a276 1
      return myElementMgr.getGlobalElement ();
d288 6
a293 1
      mustBeEnabled ("Problem.getPart");
d295 4
a298 1
      return myElementMgr.getPart (thePartName);
d310 6
a315 1
      mustBeEnabled ("Problem.getOperation");
d317 4
a320 1
      return myElementMgr.getOperation (theOpnName);
d332 3
a334 1
      checkForDefault (theAtt);
d336 7
a342 1
      return theAtt.getDefaultValue ();
d347 3
a349 1
      checkForDefault (theAtt);
d351 10
a360 4
      if (theAtt.getDefaultCase () == LAST_PERIOD)
         return getGlobalElement ().getNPeriods () - 1;
      else
         return theAtt.getDefaultValue ();
d365 3
a367 1
      checkForDefault (theAtt);
d369 7
a375 1
      return theAtt.getDefaultValue ();
d380 3
a382 1
      checkForDefault (theAtt);
d384 7
a390 1
      return theAtt.getDefaultValue ();
d404 4
a407 2
      boolean theDefVal;
      int     theIdx;
d409 1
a409 1
      checkForDefault  (theAtt);
d411 1
a411 1
      mustBeNonNull    (theBoolArr, "theBoolArr", "Problem.getDefaultValue");
d413 3
a415 1
      checkArrayLength (theAtt, theBoolArr.length);
d417 5
a421 1
      theDefVal = theAtt.getDefaultValue ()[0];
d423 1
a423 1
      for (theIdx = 0; theIdx < theBoolArr.length; theIdx ++)
d425 1
a425 1
         theBoolArr[theIdx] = theDefVal;
d433 4
a436 2
      int theDefVal;
      int theIdx;
d438 1
a438 1
      checkForDefault  (theAtt);
d440 1
a440 1
      mustBeNonNull    (theIntArr, "theIntArr", "Problem.getDefaultValue");
d442 1
a442 1
      checkArrayLength (theAtt, theIntArr.length);
d444 10
a453 4
      if (theAtt.getDefaultCase () == LAST_PERIOD)
         theDefVal = getGlobalElement ().getNPeriods () - 1;
      else
         theDefVal = theAtt.getDefaultValue ()[0];
d455 1
a455 1
      for (theIdx = 0; theIdx < theIntArr.length; theIdx ++)
d457 1
a457 1
         theIntArr[theIdx] = theDefVal;
d465 4
a468 2
      double theDefVal;
      int    theIdx;
d470 1
a470 1
      checkForDefault  (theAtt);
d472 1
a472 1
      mustBeNonNull    (theDblArr, "theDblArr", "Problem.getDefaultValue");
d474 1
a474 1
      checkArrayLength (theAtt, theDblArr.length);
d476 1
a476 1
      theDefVal = theAtt.getDefaultValue ()[0];
d478 7
a484 1
      for (theIdx = 0; theIdx < theDblArr.length; theIdx ++)
d486 1
a486 1
         theDblArr[theIdx] = theDefVal;
d504 4
a507 2
      int nPeriodsVal;
      int theIdx;
d509 1
a509 1
      checkForDefault  (theAtt);
d511 17
a527 7
      mustBeNonNull    (hardLBArr, "hardLBArr", "Problem.getDefaultValue");
      mustBeNonNull    (softLBArr, "softLBArr", "Problem.getDefaultValue");
      mustBeNonNull    (hardUBArr, "hardUBArr", "Problem.getDefaultValue");

      checkArrayLength (theAtt, hardLBArr.length);
      checkArrayLength (theAtt, softLBArr.length);
      checkArrayLength (theAtt, hardUBArr.length);
d529 1
a529 3
      nPeriodsVal = getGlobalElement ().getNPeriods ();

      for (theIdx = 0; theIdx < nPeriodsVal; theIdx ++)
d531 1
a531 3
         hardLBArr[theIdx] =  0.0;
         softLBArr[theIdx] =  0.0;
         hardUBArr[theIdx] = -1.0;
d546 3
a548 1
      mustBeActive ("Problem.shutDown");
d550 2
a551 2
      if (enabled)
         myElementMgr.shutDown ();
d553 4
a556 4
      myProblemCOR   .shutDown ();
      myMessageMgr   .shutDown ();
      myAttRepMgr    .shutDown ();
      super          .shutDown ();
d558 1
a558 1
      assert (activeInstances.contains (this));
d560 7
a566 1
      activeInstances.remove (this);
d577 6
a582 1
      witjMustBeFunctional ("Problem.toString");
d584 4
a587 1
      return "Problem";
d598 9
a606 1
      return FatalException.witjIsFunctional ();
d615 6
a620 1
      mustBeActive ("Problem.getMessageMgr");
d622 4
a625 1
      return myMessageMgr;
d630 3
a632 1
      mustBeActive ("Problem.isEnabled");
d634 7
a640 1
      return enabled;
@


1.90
log
@Added a call to witjMustBeFunctional whereever it was needed.
@
text
@d414 1
a414 1
      return ExceptionHandler.witjIsFunctional ();
@


1.89
log
@Changed class names:
   HarmlessException ==> IntactException
   UnknownException  ==> UnexpectedException
@
text
@d84 2
d401 2
@


1.88
log
@Exceptions
@
text
@d61 1
a61 1
         throw new HarmlessException (
d155 1
a155 1
         throw new HarmlessException (
d499 1
a499 1
         throw new HarmlessException (
d515 1
a515 1
         throw new HarmlessException (
d539 1
a539 1
         throw new HarmlessException (
@


1.87
log
@Initial implementation of class ExceptionHandler.
@
text
@d43 2
@


1.86
log
@Replaced standard Exceptions with HarmlessExceptions in throw statements.
@
text
@d401 11
@


1.85
log
@Exceptions
@
text
@d59 1
a59 1
         throw new IllegalStateException (
d153 1
a153 1
         throw new IllegalStateException (
d486 1
a486 1
         throw new UnsupportedOperationException (
d502 1
a502 1
         throw new IllegalArgumentException (
d526 1
a526 1
         throw new IllegalStateException (
@


1.84
log
@Exceptions
@
text
@d486 1
a486 1
         throw new IllegalStateException (
@


1.83
log
@Exceptions
@
text
@d528 2
a529 2
            + "   A public method that requires an enabled Problem\n"
            + "   was called with a Problem that has not been enabled.\n"
@


1.82
log
@Minor changes.
@
text
@d59 4
a62 3
         abortWmsg (
            "   The enable method was called " 
          +    "on a Problem that is already enabled.\n");
d153 4
a156 3
         abortWmsg (
            "   Problem.readData was called on a Problem\n"
          + "   that has at least one Part or at least one Operation.");
d486 4
a489 3
         abortWmsg (
            "   Problem.getDefaultValue was called with\n"
          + "   an Attribute that does not have a default value.");
d502 3
a504 2
         abortWmsg (
              "   Problem.getDefaultValue was called with an array\n"
d509 2
a510 1
            + "      nPeriods:     " + getGlobalElement ().getNPeriods ());
d526 6
a531 7
         abortWmsg (
            "   A public method that requires an enabled Problem\n"
          + "   was called with a Problem that has not been enabled.\n"
          + "\n"
          + "      Method: "
          + methName
          + "\n");
@


1.81
log
@Changed the default value of quite mode from false to true.
Changed MessageMgr method names:
   setQuietMode ==> setQuiet
   getQuietMode ==> isQuiet
@
text
@d153 1
a153 1
            "   Problem.readData (...) was called for a Problem\n"
d485 1
a485 1
            "   Problem.getDefaultValue (...) was called with\n"
d500 1
a500 1
              "   Problem.getDefaultValue (...) was called with an array\n"
@


1.80
log
@Removed Java class SessionCOR.
@
text
@d458 1
a458 1
   private Problem (boolean selfTestingState)
d462 1
a462 1
      selfTesting  = selfTestingState;
@


1.79
log
@Dismantling class SessionCOR.
@
text
@a379 1
      mySessionCOR   .shutDown ();
a423 5
   SessionCOR getSessionCOR ()
      {
      return mySessionCOR;
      }

a463 2
      mySessionCOR = new SessionCOR ();

a542 8
// mySessionCOR.
//
// The SessionCOR that belongs to this Problem.
//------------------------------------------------------------------------------

   private final SessionCOR mySessionCOR;

//------------------------------------------------------------------------------
@


1.78
log
@Removed Java class Session.
@
text
@d472 1
a474 1
      myProblemCOR = new ProblemCOR (this);
d559 8
a582 8
// myProblemCOR.
//
// The ProblemCOR that belongs to this Problem.
//------------------------------------------------------------------------------

   private final ProblemCOR myProblemCOR;

//------------------------------------------------------------------------------
a605 1
//    getSession
@


1.77
log
@Dismantling Session.
@
text
@d38 1
a38 1
// Constructs a new Problem and a new Session for it and returns the Problem.
d380 1
a380 1
      mySession      .shutDown ();
a402 7
   public Session getSession ()
      {
      mustBeActive ("Problem.getSession");

      return mySession;
      }

d425 5
d470 2
a471 1
      mySession    = new Session    ();
d551 1
a551 1
// mySession.
d553 1
a553 1
// The Session that owns this Problem.
d556 1
a556 1
   private final Session mySession;
@


1.76
log
@Dismantling class Session.
@
text
@d472 3
a474 3
      mySession    = new Session    (this);
      myAttRepMgr  = new AttRepMgr  (mySession);
      myMessageMgr = new MessageMgr (mySession);
@


1.75
log
@Dismantling class Session.
@
text
@d379 1
d432 5
d473 1
a473 1

a474 1

d560 8
@


1.74
log
@Session removal.
@
text
@d378 1
d413 1
a413 1
      return mySession.getMessageMgr ();
d467 3
d555 8
@


1.73
log
@Session removal.
@
text
@d447 8
d593 8
@


1.72
log
@Moved self-test responsibility from class Session to class Problem.
@
text
@d13 2
d380 4
d453 2
d584 19
@


1.71
log
@Moved some responsibility from Session to Problem.
@
text
@d436 5
d447 1
a447 1
      mySession    = new Session (selfTestingState);
d449 1
a450 2

      mySession.record (this);
d519 8
@


1.70
log
@Removed class Session from the public interface.
@
text
@d41 1
a41 1
      return new Problem ();
d77 25
a101 1
      Session.selfTest ();
a420 14
// newInstance (theSession)
//
// Factory method:
// Constructs a new Problem for theSession and returns it.
//------------------------------------------------------------------------------

   static Problem newInstance (Session theSession)
      {
      assert (theSession.getProblem () == null);

      return new Problem (theSession);
      }

//------------------------------------------------------------------------------
d440 1
a440 14
   private Problem (Session theSession)
      {
      mySession    = theSession;

      myProblemCOR = new ProblemCOR (this);

      enable ();

      theSession.record (this);
      }

//------------------------------------------------------------------------------

   private Problem ()
d442 1
a442 1
      mySession    = Session.newInstance ();
@


1.69
log
@Made enum DefaultCase non-nested.
@
text
@d16 3
a18 2
// An instance of class Problem represents an implosion problem and
// corresponds to an initialized WitRun.
d33 1
a33 1
// newInstance (theSession)
d36 14
a49 1
// Constructs a new Problem for theSession and returns it.
d52 1
a52 1
   public static Problem newInstance (Session theSession)
d54 1
a54 1
      argMustBeActive (theSession, "theSession", "Problem.newInstance");
d56 1
a56 1
      if (theSession.getProblem () != null)
d58 16
a73 2
            "   Problem.newInstance (Session) was called\n"
          + "   with a Session that already has a Problem.");
d75 3
a77 1
      return new Problem (theSession);
d86 1
a86 1
      mustBeActive                        ("Problem.displayData");
d94 1
a94 1
      mustBeActive ("Problem.evalObjectives");
d101 1
a101 1
      mustBeActive ("Problem.generatePriorities");
d108 1
a108 1
      mustBeActive ("Problem.heurImplode");
d115 1
a115 1
      mustBeActive ("Problem.postprocess");
d122 1
a122 1
      mustBeActive                        ("Problem.readData");
d141 1
a141 1
      mustBeActive ("Problem.getElements");
d154 1
a154 1
      mustBeActive ("Problem.getGlobalElement");
d168 1
a168 1
      mustBeActive ("Problem.getPart");
d182 1
a182 1
      mustBeActive ("Problem.getOperation");
d336 21
d385 7
d397 1
a397 1
// shutDown ()
d399 2
a400 1
// Override from class RetainedObject.
d403 1
a403 1
   void shutDown ()
d405 3
a407 3
      myProblemCOR.shutDown ();
      myElementMgr.shutDown ();
      super       .shutDown ();
d421 2
d435 2
a436 1
      myElementMgr = new ElementMgr (this);
d441 11
d464 1
a464 1
      mustBeActive ("Problem.getDefaultValue");
d491 22
d539 27
a565 1
   private final ElementMgr myElementMgr;
@


1.68
log
@Attributes.
@
text
@d11 1
a11 1
import static com.ibm.witj.Attribute.DefaultCase.*;
@


1.67
log
@Minor revision.
@
text
@d11 1
d175 1
a175 1
      if (theAtt.defaultIsLastPeriod ())
d236 1
a236 1
      if (theAtt.defaultIsLastPeriod ())
@


1.66
log
@Default values.
@
text
@d399 1
a399 1
// checkArrayLength (theAttribute, methodName, theLength)
@


1.65
log
@Default values.
@
text
@d268 37
@


1.64
log
@Default values.
@
text
@d210 2
d231 2
d255 2
@


1.63
log
@Default Values.
@
text
@d174 4
a177 4
      return
         theAtt.defaultIsLastPeriod ()?
            getGlobalElement ().getNPeriods () - 1:
            theAtt.getDefaultValue ();
d195 67
d355 19
@


1.62
log
@Default values.
@
text
@d165 21
a185 1
      mustBeActive ("Problem.getDefaultValue");
d187 3
a189 4
      if (! theAtt.hasDefaultValue ())
         abortWmsg (
            "   Problem.getDefaultValue (Attribute <?>) was called\n"
          + "   with an Attribute that does not have a default value.");
d269 20
@


1.61
log
@Added theProblem.postprocess ().
@
text
@d157 19
@


1.60
log
@Changed ownership of AttRepMgr from Problem to Session.
@
text
@d82 7
@


1.59
log
@Call-back infrastructure.
@
text
@a190 1
      myAttRepMgr .shutDown ();
a208 5
   AttRepMgr getAttRepMgr ()
      {
      return myAttRepMgr;
      }

a218 1
      myAttRepMgr  = new AttRepMgr  (this);
a250 8
//------------------------------------------------------------------------------
// myAttRepMgr.
//
// The AttRepMgr that belongs to this Problem.
//------------------------------------------------------------------------------

   private final AttRepMgr myAttRepMgr;

@


1.58
log
@Call-back infrastructure.
@
text
@a230 28
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// newPart (thePartName, theMaterialCase)
//
// Factory method: Constructs and returns a new Part for this Problem.
//
// Arguments:
//    thePartName:     The PartName of the Part.
//    theMaterialCase: True, iff the Part is to be a material Part.
//
// Intended for invocation from WIT-J/C++.
//------------------------------------------------------------------------------

   private Part newPart (String thePartName, boolean theMaterialCase)
      {
      Part.Category theCategory;

      if (theMaterialCase)
         theCategory = Part.Category.MATERIAL;
      else
         theCategory = Part.Category.CAPACITY;

      return Part.newInstance (this, thePartName, theCategory);
      }

//==============================================================================
@


1.57
log
@Revised factory methods.
@
text
@a257 16
//------------------------------------------------------------------------------
// newOperation (theOpnName)
//
// Factory method: Constructs and returns a new Operation for this Problem.
//
// Argument:
//    theOpnName: The OperationName of the Operation.
//
// Intended for invocation from WIT-J/C++.
//------------------------------------------------------------------------------

   private Operation newOperation (String theOpnName)
      {
      return Operation.newInstance (this, theOpnName);
      }

@


1.56
log
@Name change.
@
text
@d31 1
a31 1
// newProblem ()
d33 2
a34 2
// Factory method: Constructs a new Session and a new Problem for it and returns
// the new Problem.
d37 1
a37 1
   public static Problem newProblem ()
d39 1
a39 2
      return Session.newSession ().newProblem ();
      }
d41 4
a44 32
//------------------------------------------------------------------------------
// newPart (thePartName, theCategory)
//
// Factory method: Constructs and returns a new Part for this Problem.
//
// Arguments:
//    thePartName: The PartName of the Part.
//    theCategory: The Part Category of the Part.
//------------------------------------------------------------------------------

   public Part newPart (String thePartName, Part.Category theCategory)
      {
      mustBeActive                              ("Problem.newPart");
      mustBeNonNull (thePartName, "thePartName", "Problem.newPart");
      mustBeNonNull (theCategory, "theCategory", "Problem.newPart");

      return new Part (this, thePartName, theCategory);
      }

//------------------------------------------------------------------------------
// newOperation (theOpnName)
//
// Factory method: Constructs and returns a new Operation for this Problem.
//
// Argument:
//    theOpnName: The OperationName of the Operation.
//------------------------------------------------------------------------------

   public Operation newOperation (String theOpnName)
      {
      mustBeActive                            ("Problem.newOperation");
      mustBeNonNull (theOpnName, "theOpnName", "Problem.newOperation");
d46 1
a46 1
      return new Operation (this, theOpnName);
a178 15
// Package-Internal Constructor
//==============================================================================

   Problem (Session theSession)
      {
      mySession    = theSession;

      myProblemCOR = new ProblemCOR (this);
      myElementMgr = new ElementMgr (this);
      myAttRepMgr  = new AttRepMgr  (this);

      theSession.record (this);
      }

//==============================================================================
d216 15
d235 1
a235 1
// newPart (thePartName, theCategory)
d255 17
a271 1
      return new Part (this, thePartName, theCategory);
@


1.55
log
@Changed name of Component to Entity.
@
text
@d116 1
a116 1
      if (myEntityMgr.hasPartsOpns ())
d125 1
a125 1
// getEntities ()
d127 1
a127 1
// Returns an array of all the Entities for this Problem.
d130 1
a130 1
   public Entity[] getEntities ()
d132 1
a132 1
      mustBeActive ("Problem.getEntities");
d134 1
a134 1
      return myEntityMgr.getEntities ();
d138 1
a138 1
// getGlobalEntity ().
d143 1
a143 1
   public GlobalEntity getGlobalEntity ()
d145 1
a145 1
      mustBeActive ("Problem.getGlobalEntity");
d147 1
a147 1
      return myEntityMgr.getGlobalEntity ();
d161 1
a161 1
      return myEntityMgr.getPart (thePartName);
d175 1
a175 1
      return myEntityMgr.getOperation (theOpnName);
d216 1
a216 1
      myEntityMgr  = new EntityMgr  (this);
d236 1
a236 1
      myEntityMgr .shutDown ();
d249 1
a249 1
   EntityMgr getEntityMgr ()
d251 1
a251 1
      return myEntityMgr;
d308 1
a308 1
// myEntityMgr.
d310 1
a310 1
// The EntityMgr that belongs to this Problem.
d313 1
a313 1
   private final EntityMgr myEntityMgr;
@


1.54
log
@Minor revision
@
text
@d116 1
a116 1
      if (myCompMgr.hasPartsOpns ())
d125 1
a125 1
// getComponents ()
d127 1
a127 1
// Returns an array of all the Components for this Problem.
d130 1
a130 1
   public Component[] getComponents ()
d132 1
a132 1
      mustBeActive ("Problem.getComponents");
d134 1
a134 1
      return myCompMgr.getComponents ();
d138 1
a138 1
// getGlobalComp ().
d143 1
a143 1
   public GlobalComp getGlobalComp ()
d145 1
a145 1
      mustBeActive ("Problem.getGlobalComp");
d147 1
a147 1
      return myCompMgr.getGlobalComp ();
d161 1
a161 1
      return myCompMgr.getPart (thePartName);
d175 1
a175 1
      return myCompMgr.getOperation (theOpnName);
d216 1
a216 1
      myCompMgr    = new CompMgr    (this);
d236 1
a236 1
      myCompMgr   .shutDown ();
d249 1
a249 1
   CompMgr getCompMgr ()
d251 1
a251 1
      return myCompMgr;
d308 1
a308 1
// myCompMgr.
d310 1
a310 1
// The CompMgr that belongs to this Problem.
d313 1
a313 1
   private final CompMgr myCompMgr;
@


1.53
log
@Implemented extraction of Parts.
@
text
@d270 1
a270 1
//    theMaterialMode: True, iff the Part is to be a material Part.
d275 1
a275 1
   private Part newPart (String thePartName, boolean theMaterialMode)
d279 1
a279 1
      if (theMaterialMode)
@


1.52
log
@Call-back infrastructure.
@
text
@d260 28
@


1.51
log
@Numerous class name changes.
@
text
@a208 2
//
// To be called only from theSession.newProblem ().
d215 3
a217 3
      myProblemCOR = new ProblemCOR (mySession.getSessionCOR ());

      myCompMgr    = new CompMgr   (this);
d219 1
a219 1
      myAttRepMgr  = new AttRepMgr (this);
@


1.50
log
@Minor revision.
@
text
@d87 1
a87 1
      myProblemCI.displayData (fileName);
d94 1
a94 1
      myProblemCI.evalObjectives ();
d101 1
a101 1
      myProblemCI.generatePriorities ();
d108 1
a108 1
      myProblemCI.heurImplode ();
d121 1
a121 1
      myProblemCI.readData (fileName);
d215 1
a215 1
      mySession   = theSession;
d217 1
a217 1
      myProblemCI = new ProblemCI (mySession.getSessionCI ());
d219 1
a219 1
      myCompMgr   = new CompMgr   (this);
d221 1
a221 1
      myAttRepMgr = new AttRepMgr (this);
d236 4
a239 4
      myProblemCI.shutDown ();
      myAttRepMgr.shutDown ();
      myCompMgr  .shutDown ();
      super      .shutDown ();
d246 1
a246 1
   ProblemCI getProblemCI ()
d248 1
a248 1
      return myProblemCI;
d274 1
a274 1
// myProblemCI.
d276 1
a276 1
// The C++ Problem interface that belongs to this Problem.
d279 1
a279 1
   private final ProblemCI myProblemCI;
@


1.49
log
@Began implementation of Problem.readData (...).
@
text
@d116 1
a116 1
      if (myCompMgr.getNPeriodsFrozen ())
@


1.48
log
@Class name change.
@
text
@d111 13
@


1.47
log
@Implemented thePart.getDemands ().
@
text
@d187 1
a187 1
   public MessageManager getMessageManager ()
d189 1
a189 1
      mustBeActive ("Problem.getMessageManager");
d191 1
a191 1
      return mySession.getMessageManager ();
@


1.46
log
@Implemented theProblem.getOperation (theOpnName).
@
text
@d114 1
a114 1
// Returns an array of all the Components for thois Problem.
@


1.45
log
@Implemented theProblem.getPart (thePartName).
@
text
@d152 14
@


1.44
log
@Implemented theProblem.getComponents ().
@
text
@d138 14
@


1.43
log
@Wrapped witGeneratePriorities.
@
text
@d112 13
@


1.42
log
@Wrapped witEvalObjectives.
@
text
@d97 7
@


1.41
log
@Class name changes.
@
text
@a79 6
//
// Problem Method    WIT API Function
// ------- ------    --- --- --------
//
// displayData       witDisplayData
// heurImplode       witHeurImplode
d90 7
@


1.40
log
@Implemented theMsgHandler.flushFile ().
@
text
@d138 1
a138 1
   public MsgHandler getMsgHandler ()
d140 1
a140 1
      mustBeActive ("Problem.getMsgHandler");
d142 1
a142 1
      return mySession.getMsgHandler ();
@


1.39
log
@Active state / shutDown method.
@
text
@a78 13
// flushMsgFile ()
//
// Flushes WIT's message file.
//------------------------------------------------------------------------------

   public void flushMsgFile ()
      {
      mustBeActive ("Problem.flushMsgFile");

      myProblemCI.flushMsgFile ();
      }

//------------------------------------------------------------------------------
d138 7
@


1.38
log
@Added Problem.newProblem ().
@
text
@d54 3
a56 3
      mustBeUnreleased                             ("Problem.newPart");
      mustBeNonNull    (thePartName, "thePartName", "Problem.newPart");
      mustBeNonNull    (theCategory, "theCategory", "Problem.newPart");
d72 2
a73 2
      mustBeUnreleased                           ("Problem.newOperation");
      mustBeNonNull    (theOpnName, "theOpnName", "Problem.newOperation");
d86 1
a86 1
      mustBeUnreleased ("Problem.flushMsgFile");
d103 1
a103 2
      mustBeUnreleased ("Problem.displayData");

d111 1
a111 1
      mustBeUnreleased ("Problem.heurImplode");
d124 1
a124 1
      mustBeUnreleased ("Problem.getGlobalComp");
d146 1
a146 1
      mustBeUnreleased ("Problem.getSession");
d173 1
a173 1
// release ()
d178 1
a178 1
   void release ()
d180 4
a183 4
      myProblemCI.release ();
      myAttRepMgr.release ();
      myCompMgr  .release ();
      super      .release ();
@


1.37
log
@Revised the factory methods.
@
text
@d31 12
@


1.36
log
@Disallowed creating a Problem for a Session that already has one.
@
text
@d31 1
a31 1
// makeInstance ()
d33 5
a37 2
// Factory method:
// Constructs a new Session and a new Problem and returns the new Problem.
d40 1
a40 1
   public static Problem makeInstance ()
d42 3
a44 3
      Session theSession;

      theSession = Session.makeInstance ();
d46 1
a46 1
      return makeInstance (theSession);
d50 3
a52 1
// makeInstance (theSession)
d54 2
a55 3
// Factory method:
// Releases the current Problem for theSession, if any, constructs a new Problem
// for theSession, and returns it.
d58 1
a58 1
   public static Problem makeInstance (Session theSession)
d60 2
a61 8
      Problem theProblem;

      argMustBeUnreleased (theSession, "theSession", "Problem.makeInstance");

      if (theSession.getProblem () != null)
         abortWmsg (
            "   Problem.makeInstance (theSession) was called\n"
          + "   with a Session that already has a Problem.");
d63 1
a63 5
      theProblem = new Problem (theSession);

      theSession.store (theProblem);

      return theProblem;
d141 17
a194 15
// Private Constructor
//==============================================================================

   private Problem (Session theSession)
      {
      mySession   = theSession;

      myProblemCI = new ProblemCI (mySession.getSessionCI ());

      myCompMgr   = new CompMgr   (this);

      myAttRepMgr = new AttRepMgr (this);
      }

//==============================================================================
@


1.35
log
@Initial implementation of creating a Session without a Problem.
@
text
@d58 6
a63 1
      theSession.clearProblem ();
@


1.34
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@d15 2
a16 3
// The governing interface class of WIT-J.
// Represents an implosion problem.
// Corresponds to an initialized WitRun.
d33 2
a34 1
// Factory method: Constructs and returns a new Problem.
d43 22
a64 1
      return theSession.getProblem ();
d136 2
a140 25
   public CompMgr getCompMgr ()
      {
      return myCompMgr;
      }

   AttRepMgr getAttRepMgr ()
      {
      return myAttRepMgr;
      }

//==============================================================================
// Package-Internal Constructor
//==============================================================================

   Problem (Session theSession)
      {
      mySession   = theSession;

      myCompMgr   = new CompMgr   (this);

      myAttRepMgr = new AttRepMgr (this);

      myProblemCI = new ProblemCI (mySession.getSessionCI ());
      }

d168 25
d206 8
a228 8
//------------------------------------------------------------------------------
// myProblemCI.
//
// The C++ Problem interface that belongs to this Problem.
//------------------------------------------------------------------------------

   private final ProblemCI myProblemCI;

@


1.33
log
@Moved onwership of the ProbCoordCI from class Problem to class Session.
@
text
@d140 1
a140 1
      myProblemCI = new ProblemCI (mySession.getProbCoordCI ());
@


1.32
log
@Removed Java class ProbCoord.
@
text
@d134 1
a134 1
      mySession     = theSession;
d136 1
a136 1
      myProbCoordCI = new ProbCoordCI ();
d138 1
a138 1
      myCompMgr     = new CompMgr   (this);
d140 1
a140 3
      myAttRepMgr   = new AttRepMgr (this);

      myProblemCI   = new ProblemCI (myProbCoordCI);
d155 4
a158 5
      myProblemCI  .release ();
      myAttRepMgr  .release ();
      myCompMgr    .release ();
      myProbCoordCI.release ();
      super        .release ();
a164 5
   ProbCoordCI getProbCoordCI ()
      {
      return myProbCoordCI;
      }

a182 8
// myProbCoordCI.
//
// The C++ ProbCoord interface that belongs to this Problem.
//------------------------------------------------------------------------------

   private final ProbCoordCI myProbCoordCI;

//------------------------------------------------------------------------------
@


1.31
log
@Initial implementation of the Session classes.
@
text
@d95 1
a95 1
      return myProbCoord.getCompMgr ().getGlobalComp ();
d118 10
d132 1
a132 1
   Problem (Session theSession, boolean selfTestModeVal)
d134 1
a134 1
      mySession   = theSession;
d136 1
a136 1
      myProbCoord = new ProbCoord (this, selfTestModeVal);
d138 5
a142 1
      myProblemCI = new ProblemCI (myProbCoord.getProbCoordCI ());
d157 5
a161 3
      myProblemCI.release ();
      myProbCoord.release ();
      super      .release ();
d168 1
a168 1
   ProbCoord getProbCoord ()
d170 1
a170 1
      return myProbCoord;
d191 17
a207 1
// myProblemCI.
d209 1
a209 1
// The C++ Problem interface that belongs to this Problem.
d212 1
a212 1
   private final ProblemCI myProblemCI;
d215 1
a215 1
// myProbCoord.
d217 1
a217 1
// Coordinates the objects of this Problem.
d220 1
a220 1
   private final ProbCoord myProbCoord;
@


1.30
log
@Terminology change.
@
text
@d39 1
a39 20
      return new Problem (false);
      }

//------------------------------------------------------------------------------
// release ()
//
// Override from class RetainedObject.
// Releases this Problem.
// This problem and the objects it owns cannot be garbage-collected until this
// method is called.
//------------------------------------------------------------------------------

   public void release ()
      {
      mustBeUnreleased ("Problem.release");

      myProblemCI.release ();
      myProbCoord.release ();
      super      .release ();
      }
d41 1
a41 6
//------------------------------------------------------------------------------
// selfTest ()
//
// Performs various tests of WIT-J that cannot be done by calling (other) public
// methods.
//------------------------------------------------------------------------------
d43 1
a43 9
   public static void selfTest ()
      {
      Problem theProblem;

      println (
           "\n"
         + "Performing self-test.");

      theProblem = new Problem (true);
d109 22
d136 13
d163 1
a163 1
// Private Methods
d167 3
a169 1
// Constructor.
d172 1
a172 10
   private Problem (boolean selfTestModeVal)
      {
      myProbCoord  = new ProbCoord (this, selfTestModeVal);

      myProblemCI  = new ProblemCI (myProbCoord.getProbCoordCI ());
      }

//==============================================================================
// Private Fields
//==============================================================================
@


1.29
log
@Added checking for null arguments.
@
text
@d21 1
a21 1
//    VitalObject
d25 1
a25 1
public final class Problem extends VitalObject
d32 1
a32 1
// makeInstance ().
d43 1
a43 1
// shutDown ().
d45 4
a48 3
// Override from class VitalObject.
// Puts this Problem into an inactive state.
// This problem cannot be garbage-collected until this method is called.
d51 1
a51 1
   public void shutDown ()
d53 1
a53 1
      mustBeActive ("Problem.shutDown");
d55 3
a57 3
      myProblemCI.shutDown ();
      myProbCoord.shutDown ();
      super      .shutDown ();
d86 1
a86 1
      mustBeActive ("Problem.flushMsgFile");
d103 1
a103 1
      mustBeActive ("Problem.displayData");
d112 1
a112 1
      mustBeActive ("Problem.heurImplode");
d125 1
a125 1
      mustBeActive ("Problem.getGlobalComp");
@


1.28
log
@Replaced class PublicObject with class VitalObject.
@
text
@d104 2
@


1.27
log
@Replaced toStringActive () with toString ().
@
text
@d21 1
a21 1
//    PublicObject
d25 1
a25 1
public final class Problem extends PublicObject
d45 1
a45 1
// Override from class PublicObject.
d47 1
a47 1
// This method must be called before this Problem is garbage-collected.
@


1.26
log
@Name change: Global --> GlobalComp.
@
text
@d127 11
a155 11
//------------------------------------------------------------------------------
// toStringActive ().
//
// Override from class PublicObject.
//------------------------------------------------------------------------------

   String toStringActive ()
      {
      return "Problem";
      }

@


1.25
log
@Revised the shut-down model.
@
text
@d115 1
a115 1
// getGlobal ().
d120 1
a120 1
   public Global getGlobal ()
d122 1
a122 1
      mustBeActive ("Problem.getGlobal");
d124 1
a124 1
      return myProbCoord.getCompMgr ().getGlobal ();
@


1.24
log
@Implemented Utility class.
@
text
@a55 4

      myProblemCI = null;
      myProbCoord = null;

a127 16
// Protected Methods
//==============================================================================

//------------------------------------------------------------------------------
// finalize ()
//------------------------------------------------------------------------------

   protected void finalize () throws Throwable
      {
      super.finalize ();

      if (isActive ())
         abortWmsg ("   Garbage-collection was invoked on an active Problem.");
      }

//==============================================================================
d181 1
a181 1
   private ProblemCI myProblemCI;
d189 1
a189 1
   private ProbCoord myProbCoord;
@


1.23
log
@Classes Global and GlobalCI.
@
text
@d8 3
a10 1
package com.ibm.witj;
d74 1
a74 1
      System.out.println (
@


1.22
log
@Attributes.
@
text
@d117 1
a117 1
// getGlobalComp ().
d122 1
a122 1
   public GlobalComp getGlobalComp ()
d124 1
a124 1
      mustBeActive ("Problem.getGlobalComp");
d126 1
a126 1
      return myProbCoord.getCompMgr ().getGlobalComp ();
@


1.21
log
@Attributes.
@
text
@d37 1
a37 1
      return new Problem ();
d68 1
a68 1
   public void selfTest ()
d70 7
a76 1
      myProbCoord.selfTest ();
d182 1
a182 1
   private Problem ()
d184 1
a184 1
      myProbCoord = new ProbCoord (this);
d186 1
a186 1
      myProblemCI = new ProblemCI (myProbCoord.getProbCoordCI ());
@


1.20
log
@Attributes.
@
text
@d62 12
@


1.19
log
@Attributes.
@
text
@d52 1
a53 1
      myProblemCI.shutDown ();
d55 1
a56 1
      myProblemCI = null;
@


1.18
log
@Attributes.
@
text
@a61 20
// selfTest ()
//
// Verifies internal consistency of the various aspects of WIT-J.
//------------------------------------------------------------------------------

   public void selfTest ()
      {
      mustBeActive ("Problem.selfTest");

      System.out.println (
           "\n"
         + "WIT-J is performing a Self-Test.\n");

      myProbCoord.getAttOldMgr ().selfTest ();

      System.out.println (
           "WIT-J Self-Test completed successfully.");
      }

//------------------------------------------------------------------------------
@


1.17
log
@Made accessor names begin with "get".
@
text
@d75 1
a75 1
      myProbCoord.getAttMgr ().selfTest ();
@


1.16
log
@Minor update.
@
text
@d75 1
a75 1
      myProbCoord.myAttMgr ().selfTest ();
d119 1
a119 1
// myGlobalComp ().
d124 1
a124 1
   public GlobalComp myGlobalComp ()
d126 1
a126 1
      mustBeActive ("Problem.myGlobalComp");
d128 1
a128 1
      return myProbCoord.myCompMgr ().myGlobalComp ();
d155 1
a155 1
   ProbCoord myProbCoord ()
d160 1
a160 1
   ProblemCI myProblemCI ()
d188 1
a188 1
      myProblemCI = new ProblemCI (myProbCoord.myProbCoordCI ());
@


1.15
log
@Initial implementation of self-test.
@
text
@a159 2
//------------------------------------------------------------------------------

@


1.14
log
@Implemented Problem.heurImplode.
@
text
@d62 20
@


1.13
log
@Implemented Java class AttRep.
@
text
@d75 1
a75 1
// displayData (fileName).
d77 5
a81 1
// Calls witDisplayData on fileName.
d91 7
d106 2
@


1.12
log
@Created Java class CompMgr.
@
text
@d41 1
a41 1
// shutdown ().
@


1.11
log
@Removed class LTPubObject.
@
text
@d95 1
a95 1
      return myProbCoord.myGlobalComp ();
@


1.10
log
@Added Java class LTPubObject.
@
text
@d20 1
a20 2
//       LTPubObject
//          Problem
d23 1
a23 1
public final class Problem extends LTPubObject
@


1.9
log
@Comments, etc.
@
text
@d20 2
a21 1
//       Problem
d24 1
a24 1
public final class Problem extends PublicObject
d51 2
d100 16
@


1.8
log
@*** empty log message ***
@
text
@d1 7
@


1.7
log
@*** empty log message ***
@
text
@d53 13
@


1.6
log
@*** empty log message ***
@
text
@d45 4
d132 1
a132 1
   private final ProblemCI myProblemCI;
d140 1
a140 1
   private final ProbCoord myProbCoord;
@


1.5
log
@*** empty log message ***
@
text
@a61 11
// toString ().
//
// Override from class Object.
//------------------------------------------------------------------------------

   public String toString ()
      {
      return "Problem";
      }

//------------------------------------------------------------------------------
d92 11
@


1.4
log
@*** empty log message ***
@
text
@d12 1
a12 1
//    ExportedObject
d16 1
a16 1
public final class Problem extends ExportedObject
d36 1
a36 1
// Override from class ExportedObject.
@


1.3
log
@*** empty log message ***
@
text
@a112 1
      myProblemCI = new ProblemCI ();
d114 2
@


1.2
log
@*** empty log message ***
@
text
@d122 1
a122 1
// myProbCoord.
d124 1
a124 1
// Coordinates the objects of this Problem.
d127 1
a127 1
   private final ProbCoord myProbCoord;
d130 1
a130 1
// myProblemCI.
d132 1
a132 1
// The Java interface to the C++ Problem that belongs to this Problem.
d135 1
a135 1
   private final ProblemCI myProblemCI;
@


1.1
log
@*** empty log message ***
@
text
@d43 1
a43 1
      myCompMgr  .shutDown ();
d80 1
a80 1
      return myCompMgr.myGlobalComp ();
d91 1
a91 1
   CompMgr myCompMgr ()
d93 1
a93 1
      return myCompMgr;
d114 1
a114 1
      myCompMgr   = new CompMgr   (this);
d122 1
a122 1
// myCompMgr.
d124 1
a124 1
// Coordinates the Components owned by this Problem.
d127 1
a127 1
   private final CompMgr myCompMgr;
@


head	1.21;
access;
symbols;
locks; strict;
comment	@# @;


1.21
date	2011.05.02.18.32.18;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.22.20.00.23;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.02.25.16.07.03;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.29.19.09.23;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.25.23.44.30;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.25.22.42.42;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.29.19.56.31;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.20.18.47.32;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.05.20.17.05;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.05.17.56.47;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.04.21.49.56;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.08.19.18.01;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.08.17.57.03;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.07.22.13.29;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.03.23.12.03;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.03.22.33.51;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.03.20.43.04;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.02.18.44.09;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.01.21.33.04;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.01.16.34.49;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.30.21.07.31;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Reduced heading comments.
@
text
@
//==============================================================================
// WIT-J Java Source File AttImp.java.
//==============================================================================

package       com.ibm.witj;

import static com.ibm.witj.Utility.*;

//==============================================================================
// Class AttImp
//
// "Attribute Implementation"
// Fulfills the main responsibilities of an Attribute.
// Each AttImp corresponds to one Problem and one Attribute.
//
// Class Hierarchy:
//
// PreservedInternal
//    AttImp
//       StdAttImp
//       CustAttImp
//          {Anonymous Inner Classes}
//==============================================================================

abstract class AttImp extends PreservedInternal
{
//==============================================================================
// Package-Internal Constructor
//==============================================================================

   AttImp (Attribute <?> theAtt, Coordinator theCoord)
      {
      myAttribute   = theAtt;
      myCoordinator = theCoord;
      }

//==============================================================================
// Package-Internal Methods
//==============================================================================

//------------------------------------------------------------------------------
// verifyIsModifiable ().
//
// Verifies that the value returned by myAttribute.isModifiable () matches the
// value returned by theAttCOR.isModifiable () for each cooresponding AttCOR.
// The verification is done only for StdAttImps.
//------------------------------------------------------------------------------

   void verifyIsModifiable ()
      {
      }

//------------------------------------------------------------------------------
// verifyAppliesTo ()
//
// Verifies that myAttribute.appliesTo (theCompClassID) returns true, iff
// there is a corrsponding Att in the C++ side.
// The verification is done only for StdAttImps.
//------------------------------------------------------------------------------

   void verifyAppliesTo ()
      {
      }

//------------------------------------------------------------------------------
// set... (theComp, theValue) methods
//
// Each of these methods sets the represented attribute's value associated with 
// theComp to theValue.
//
// Issues an internal error if any of the following conditions occur:
//
//    The represented attribute is not an input attribute.
//    The type of the represented attribute does not match the scalar type
//       indicated by the method name.
//    The Component class of the represented attribute does not match that of
//       theComp.
//    The concrete AttImp class does not provide an overriding implementation
//       for the method.
//------------------------------------------------------------------------------

   void setBool     (Component    theComp, boolean   theValue)
      {
      notOverridden ("setBool",   theComp);
      }

   void setInt      (Component    theComp, int       theValue)
      {
      notOverridden ("setInt",    theComp);
      }

   void setDbl      (Component    theComp, double    theValue)
      {
      notOverridden ("setDbl",    theComp);
      }

   void setString   (Component    theComp, String    theValue)
      {
      notOverridden ("setString", theComp);
      }

//------------------------------------------------------------------------------
// set...Vec (theComp, theArray) methods
//
// Each of these methods sets the represented attribute's value associated with 
// theComp to theArray.
//
// Issues an internal error if any of the following conditions occur:
//
//    The represented attribute is not an input attribute.
//    The type of the represented attribute does not match the vector type
//       indicated by the method name.
//    The Component class of the represented attribute does not match that of
//       theComp.
//    The length of theArray != nPeriods.
//    The concrete AttImp class does not provide an overriding implementation
//       for the method.
//------------------------------------------------------------------------------

   void setBoolVec (Component theComp, boolean[] theArray)
      {
      notOverridden ("setBoolVec", theComp);
      }

   void setIntVec  (Component theComp, int[]     theArray)
      {
      notOverridden ("setIntVec", theComp);
      }

   void setDblVec  (Component theComp, double[]  theArray)
      {
      notOverridden ("setDblVec", theComp);
      }

//------------------------------------------------------------------------------
// set...VecToScalar (theComp, theValue) methods
//
// Each of these methods sets each element of the represented vector attribute's
// value associated with theComp to theValue.
//
// Issues an internal error if any of the following conditions occur:
//
//    The represented attribute is not an input attribute.
//    The type of the represented attribute does not match the vector type
//       indicated by the method name.
//    The Component class of the represented attribute does not match that of
//       theComp.
//    The concrete AttImp class does not provide an overriding implementation
//       for the method.
//------------------------------------------------------------------------------

   void setBoolVecToScalar (Component theComp, boolean theValue)
      {
      notOverridden ("setBoolVecToScalar", theComp);
      }

   void setIntVecToScalar (Component theComp, int theValue)
      {
      notOverridden ("setIntVecToScalar", theComp);
      }

   void setDblVecToScalar (Component theComp, double theValue)
      {
      notOverridden ("setDblVecToScalar", theComp);
      }

//------------------------------------------------------------------------------
// get... (theComp) methods
//
// Each of these methods returns the represented attribute's value associated
// with theComp.
//
// Issues an internal error if either of the following conditions occur:
//
//    The type of the represented attribute does not match the scalar type
//       indicated by the method name.
//    The Component class of the represented attribute does not match that of
//       theComp.
//    The concrete AttImp class does not provide an overriding implementation
//       for the method.
//------------------------------------------------------------------------------

   boolean            getBool    (Component theComp)
      {
      notOverridden ("getBool",             theComp);

      return false;
      }

   int                getInt     (Component theComp)
      {
      notOverridden ("getInt",              theComp);

      return 0;
      }

   double             getDbl     (Component theComp)
      {
      notOverridden ("getDbl",              theComp);

      return 0.0;
      }

   String             getString  (Component theComp)
      {
      notOverridden ("getString",           theComp);

      return null;
      }

//------------------------------------------------------------------------------
// get...Vec (theComp, theArray) methods
//
// Each of these methods sets theArray to the represented attribute's value
// associated with theComp.
//
// Issues an internal error if any of the following conditions occur:
//
//    The type of the represented attribute does not match the vector type
//       indicated by the method name.
//    The Component class of the represented attribute does not match that of
//       theComp.
//    The length of theArray != nPeriods.
//    The concrete AttImp class does not provide an overriding implementation
//       for the method.
//------------------------------------------------------------------------------

   void getBoolVec (Component theComp, boolean[] theArray)
      {
      notOverridden ("getBoolVec", theComp);
      }

   void getIntVec  (Component theComp, int[]     theArray)
      {
      notOverridden ("getIntVec", theComp);
      }

   void getDblVec  (Component theComp, double[]  theArray)
      {
      notOverridden ("getDblVec", theComp);
      }

//------------------------------------------------------------------------------
// Accessors.
//------------------------------------------------------------------------------

   final Attribute <?> getAttribute ()
      {
      return myAttribute;
      }

//==============================================================================
// Private Methods
//==============================================================================

//------------------------------------------------------------------------------
// notOverridden (methodName, theComp)
//------------------------------------------------------------------------------

   private void notOverridden (String methodName, Component theComp)
      {
      internalError (
           "   The \"" + methodName + "\" method "
         +    "was invoked on an AttImp whose concrete\n"
         + "   class does not provide an overriding implementation.\n"
         + "\n"
         + "      Attribute: " + myAttribute + "\n"
         + "      Component: " + theComp);
      }

//==============================================================================
// Private Fields
//==============================================================================

//------------------------------------------------------------------------------
// myAttribute
//
// The Attribute for this AttImp.
//------------------------------------------------------------------------------
 
   private final Attribute <?> myAttribute;

//------------------------------------------------------------------------------
// myCoordinator
//
// The Coordinator for this AttImp.
//------------------------------------------------------------------------------

   private final Coordinator myCoordinator;

//==============================================================================
}
@


1.20
log
@Cleared up some of the code that was flagged with warnings by Eclipse.
@
text
@a3 2
//
// Contains the declaration of class AttImp.
@


1.19
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@a273 9
//------------------------------------------------------------------------------
// getNPeriods ()
//------------------------------------------------------------------------------

   private int getNPeriods ()
      {
      return myCoordinator.getProblem ().getNPeriods ();
      }

@


1.18
log
@Implemented class PreservedInternal and made several classes extend it
   instead of class PreservedObject.
@
text
@d280 1
a280 1
      return myCoordinator.getGlobalAspect ().getNPeriods ();
@


1.17
log
@Moved myCoordinator to PreservedObject.
@
text
@d21 1
a21 1
// PreservedObject
d28 1
a28 1
abstract class AttImp extends PreservedObject
d36 2
a37 3
      super (theCoord);

      myAttribute = theAtt;
a246 11
// toStringActive ().
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   final String toStringActive ()
      {
      return "AttImp";
      }

//------------------------------------------------------------------------------
d280 1
a280 1
      return getCoordinator ().getGlobalAspect ().getNPeriods ();
d295 8
@


1.16
log
@Implemented thePreservedObject.getCoordinator ().
@
text
@d36 3
a38 2
      myAttribute   = theAtt;
      myCoordinator = theCoord;
a247 11
// getCoordinator ()
//
// Override from class PreservedObject.
//------------------------------------------------------------------------------

   Coordinator getCoordinator ()
      {
      return myCoordinator;
      }

//------------------------------------------------------------------------------
d292 1
a292 1
      return myCoordinator.getGlobalAspect ().getNPeriods ();
a306 8
//------------------------------------------------------------------------------
// myCoordinator
//
// The Coordinator for this AttImp.
//------------------------------------------------------------------------------
 
   private final Coordinator myCoordinator;

@


1.15
log
@Removed the "place element request" capability.
@
text
@d247 11
@


1.14
log
@Changed terminology:
   "Queueing element values" was replaced by
   "Placing element requests".
@
text
@a10 3
import static com.ibm.witj.BoundSet.BoundID.*;

import       java.util.*;
a170 109
// placeVectorElementRequest (theComp, thePeriod, theValue)
//
// Places a request to set the value of the represented WIT attribute for
// theComp in thePeriod to theValue.
//------------------------------------------------------------------------------

   final void placeVectorElementRequest (
         Component theComp,
         int       thePeriod,
         Object    theValue)
      {
      Object[] vectorElReqArr;

      if (vectorElReqMap == null)
         {
         vectorElReqMap   = new HashMap <Component, Object[]> ();

         vectorElReqComps = new ArrayList <Component> (16);
         }

      vectorElReqArr = vectorElReqMap.get (theComp);

      if (vectorElReqArr == null)
         {
         vectorElReqArr = new Object[getNPeriods ()];

         vectorElReqMap  .put (theComp, vectorElReqArr);

         vectorElReqComps.add (theComp);
         }

      vectorElReqArr[thePeriod] = theValue;
      }

//------------------------------------------------------------------------------
// placeBoundElementRequest (theComp, theBoundID, thePeriod, theValue)
//
// This AttImp and theBoundID identify a bound of a BoundSet WIT attribute. 
// This method places a request to set the value of the bound fortheComp in
// thePeriod to theValue.
//------------------------------------------------------------------------------

   final void placeBoundElementRequest (
         Component        theComp,
         BoundSet.BoundID theBoundID,
         int              thePeriod,
         double           theValue)
      {
      EnumMap <BoundSet.BoundID, Double[]> theBoundIDMap;
      Double[]                             boundElReqArr;

      if (boundElReqMap == null)
         {
         boundElReqMap   =
            new HashMap <Component, EnumMap <BoundSet.BoundID, Double[]>> ();

         boundElReqComps = new ArrayList <Component> (16);
         }

      theBoundIDMap = boundElReqMap.get (theComp);

      if (theBoundIDMap == null)
         {
         theBoundIDMap =
            new EnumMap <BoundSet.BoundID, Double[]> (BoundSet.BoundID.class);

         boundElReqMap  .put (theComp, theBoundIDMap);

         boundElReqComps.add (theComp);
         }

      boundElReqArr = theBoundIDMap.get (theBoundID);

      if (boundElReqArr == null)
         {
         boundElReqArr = new Double[getNPeriods ()];

         theBoundIDMap.put (theBoundID, boundElReqArr);
         }

      boundElReqArr[thePeriod] = theValue;
      }

//------------------------------------------------------------------------------
// fulfillElementRequests ()
//
// For each vector element request stored by this AttImp, this method sets the
// requested vector element of the represented WIT attribute to the requested
// value.
// For each bound element request stored by this AttImp, this method sets the
// requested bound element of the represented WIT attribute to the requested
// value.
// Clears the element requests for this AttImp.
//------------------------------------------------------------------------------

   final void fulfillElementRequests ()
      {
      if (vectorElReqMap != null)
         {
         fulfillVectorElementRequests ();
         }

      if (boundElReqMap != null)
         {
         fulfillBoundElementRequests ();
         }
      }

//------------------------------------------------------------------------------
a285 198
// fulfillVectorElementRequests ()
//
// For each vector element request stored by this AttImp, this method sets the
// requested vector element of the represented WIT attribute to the requested
// value.
// Clears the vector element requests for this AttImp.
//------------------------------------------------------------------------------

   private void fulfillVectorElementRequests ()
      {
      if      (myAttribute.getValueType () ==  double[].class)
         {
         fulfillDblElementRequests ();
         }
      else if (myAttribute.getValueType () ==     int[].class)
         {
         fulfillIntElementRequests ();
         }
      else if (myAttribute.getValueType () == boolean[].class)
         {
         fulfillBoolElementRequests ();
         }
      else
         assert (false);

      vectorElReqComps = null;
      vectorElReqMap   = null;
      }

//------------------------------------------------------------------------------
// fulfillBoolElementRequests ()
// fulfillIntElementRequests  ()
// fulfillDblElementRequests  ()
//
// Each of these methods assumes that this AttImp corresponds to a WIT attribute
// whose value type is vector of the type indicated in the method name.
// For each vector element request stored by this AttImp, this method sets the
// requested vector element of the represented WIT attribute to the requested
// value.
//------------------------------------------------------------------------------

   private void fulfillBoolElementRequests ()
      {
      boolean[] theBoolArr;
      Object [] vectorElReqArr;
      int       thePer;

      theBoolArr = new boolean[getNPeriods ()];
      
      for (Component theComp: vectorElReqComps)
         {
         vectorElReqArr = vectorElReqMap.get (theComp);

         getBoolVec (theComp, theBoolArr);

         for (thePer = getNPeriods () - 1; thePer >= 0; thePer --)
            {
            if (vectorElReqArr[thePer] != null)
               {
               theBoolArr[thePer] = (Boolean) vectorElReqArr[thePer];
               }
            }

         setBoolVec (theComp, theBoolArr);
         }
      }

//------------------------------------------------------------------------------

   private void fulfillIntElementRequests ()
      {
      int   [] theIntArr;
      Object[] vectorElReqArr;
      int      thePer;

      theIntArr = new int[getNPeriods ()];
      
      for (Component theComp: vectorElReqComps)
         {
         vectorElReqArr = vectorElReqMap.get (theComp);

         getIntVec (theComp, theIntArr);

         for (thePer = getNPeriods () - 1; thePer >= 0; thePer --)
            {
            if (vectorElReqArr[thePer] != null)
               {
               theIntArr[thePer] = (Integer) vectorElReqArr[thePer];
               }
            }

         setIntVec (theComp, theIntArr);
         }
      }

//------------------------------------------------------------------------------

   private void fulfillDblElementRequests ()
      {
      double[] theDblArr;
      Object[] vectorElReqArr;
      int      thePer;

      theDblArr = new double[getNPeriods ()];
      
      for (Component theComp: vectorElReqComps)
         {
         vectorElReqArr = vectorElReqMap.get (theComp);

         getDblVec (theComp, theDblArr);

         for (thePer = getNPeriods () - 1; thePer >= 0; thePer --)
            {
            if (vectorElReqArr[thePer] != null)
               {
               theDblArr[thePer] = (Double) vectorElReqArr[thePer];
               }
            }

         setDblVec (theComp, theDblArr);
         }
      }

//------------------------------------------------------------------------------
// fulfillBoundElementRequests ()
//
// For each bound element request stored by this AttImp, this method sets the
// requested bound element of the represented WIT attribute to the requested
// value.
// Clears the bound element requests for this AttImp.
//------------------------------------------------------------------------------

   private void fulfillBoundElementRequests ()
      {
      double[]                             hardLBArr;
      double[]                             softLBArr;
      double[]                             hardUBArr;
      ComponentCOR                         theCompCOR;
      EnumMap <BoundSet.BoundID, Double[]> theBoundIDMap;

      hardLBArr = new double[getNPeriods ()];
      softLBArr = new double[getNPeriods ()];
      hardUBArr = new double[getNPeriods ()];

      for (Component theComp: boundElReqComps)
         {
         theCompCOR    = theComp.getComponentCOR ();

         theBoundIDMap = boundElReqMap.get (theComp);

         theCompCOR.getBoundSet (hardLBArr, softLBArr, hardUBArr);

         hardLBArr = compBoundVector (theBoundIDMap, HARD_LB, hardLBArr);
         softLBArr = compBoundVector (theBoundIDMap, SOFT_LB, softLBArr);
         hardUBArr = compBoundVector (theBoundIDMap, HARD_UB, hardUBArr);

         theCompCOR.setBoundSet (hardLBArr, softLBArr, hardUBArr);
         }

      boundElReqComps = null;
      boundElReqMap   = null;
      }

//------------------------------------------------------------------------------
// compBoundVector (theBoundIDMap, theBoundID, theBoundArr)
//
// Computes and returns the bound vector value to be passed to the represented
// BoundSet WIT attribute for the bound corresponding to theBoundIDMap and
// theBoundID, where theBoundArr is the current value of the bound vector.
//------------------------------------------------------------------------------

   private double[] compBoundVector (
         EnumMap <BoundSet.BoundID, Double[]> theBoundIDMap,
         BoundSet.BoundID                     theBoundID,
         double[]                             theBoundArr)
      {
      Double[] boundElReqArr;
      int      thePer;

      boundElReqArr = theBoundIDMap.get (theBoundID);

      if (boundElReqArr == null)
         {
         return null;
         }

      for (thePer = getNPeriods () - 1; thePer >= 0; thePer --)
         {
         if (boundElReqArr[thePer] != null)
            {
            theBoundArr[thePer] = boundElReqArr[thePer];
            }
         }

      return theBoundArr;
      }

//------------------------------------------------------------------------------
a313 83
//------------------------------------------------------------------------------
// vectorElReqMap
//
// Given:
//    Component theComp
//    period    thePeriod
//
// If:
//    The value type of myAttribute is an array type, and
//    a request as been placed to set the value of myAttribute for theComp in
//       thePeriod.
//
// Then:
//       vectorElReqMap.get (theComp)[thePeriod] is the requested value.
//
// Otherwise:
//       vectorElReqMap                          is null.
//    Or:
//       vectorElReqMap.get (theComp)            is null.
//    Or:
//       vectorElReqMap.get (theComp)[thePeriod] is null.
//------------------------------------------------------------------------------

   private HashMap <Component, Object[]> vectorElReqMap = null;

//------------------------------------------------------------------------------
// vectorElReqComps
//
// A List of all Components for which vectorElReqMap.get (theComp) is non-null,
// if any, otherwise null.
// This List enables traversal of vectorElReqMap in a consistent order.
//------------------------------------------------------------------------------

   private ArrayList <Component> vectorElReqComps = null;

//------------------------------------------------------------------------------
// boundElReqMap
//
// Given:
//    Component theComp
//    BoundID   theBoundID
//    period    thePeriod
//
// If:
//    The value type of myAttribute is BoundSet, and
//    a request as been placed to set the value of myAttribute for theComp and
//       for theBoundID in thePeriod.
//
// Then:
//       boundElReqMap.
//          get (theComp).
//             get (theBoundID)[thePeriod] is the requested value.
//
// Otherwise:
//       boundElReqMap                     is null.
//    Or:
//       boundElReqMap.
//          get (theComp)                  is null.
//    Or:
//       boundElReqMap.
//          get (theComp).
//             get (theBoundID)            is null.
//    Or:
//       boundElReqMap.
//          get (theComp).
//             get (theBoundID)[thePeriod] is null.
//------------------------------------------------------------------------------

   private
      HashMap <
         Component,
         EnumMap <BoundSet.BoundID, Double[]>> boundElReqMap = null;

//------------------------------------------------------------------------------
// boundElReqComps
//
// A List of all Components for which boundElReqMap.get (theComp) is non-null,
// if any, otherwise null.
// This List enables traversal of boundElReqMap in a consistent order.
//------------------------------------------------------------------------------

   private ArrayList <Component> boundElReqComps = null;

@


1.13
log
@Changed name of Java class RetainedObject to PreservedObject.
@
text
@d174 1
a174 1
// queueVectorElement (theComp, thePeriod, theValue)
d176 2
a177 2
// Queues theValue as a value to which the represented WIT attribute is to be
// set (later) for theComp in thePeriod.
d180 1
a180 1
   final void queueVectorElement (
d185 1
a185 1
      Object[] queuedVectorElArr;
d187 1
a187 1
      if (queuedVectorElMap == null)
d189 1
a189 1
         queuedVectorElMap   = new HashMap <Component, Object[]> ();
d191 1
a191 1
         queuedVectorElComps = new ArrayList <Component> (16);
d194 1
a194 1
      queuedVectorElArr = queuedVectorElMap.get (theComp);
d196 1
a196 1
      if (queuedVectorElArr == null)
d198 1
a198 1
         queuedVectorElArr = new Object[getNPeriods ()];
d200 1
a200 1
         queuedVectorElMap  .put (theComp, queuedVectorElArr);
d202 1
a202 1
         queuedVectorElComps.add (theComp);
d205 1
a205 1
      queuedVectorElArr[thePeriod] = theValue;
d209 1
a209 1
// queueBoundElement (theComp, theBoundID, thePeriod, theValue)
d212 2
a213 2
// This method queues theValue as a value to which the bound is to be
// set (later) for theComp in thePeriod.
d216 1
a216 1
   final void queueBoundElement (
d223 1
a223 1
      Double[]                             queuedBoundElArr;
d225 1
a225 1
      if (queuedBoundElMap == null)
d227 1
a227 1
         queuedBoundElMap   =
d230 1
a230 1
         queuedBoundElComps = new ArrayList <Component> (16);
d233 1
a233 1
      theBoundIDMap = queuedBoundElMap.get (theComp);
d240 1
a240 1
         queuedBoundElMap  .put (theComp, theBoundIDMap);
d242 1
a242 1
         queuedBoundElComps.add (theComp);
d245 1
a245 1
      queuedBoundElArr = theBoundIDMap.get (theBoundID);
d247 1
a247 1
      if (queuedBoundElArr == null)
d249 1
a249 1
         queuedBoundElArr = new Double[getNPeriods ()];
d251 1
a251 1
         theBoundIDMap.put (theBoundID, queuedBoundElArr);
d254 1
a254 1
      queuedBoundElArr[thePeriod] = theValue;
d258 1
a258 1
// setElementsFromQueue ()
d260 7
a266 5
// For each vector element value queued by this AttImp, this method sets the
// corresponding vector element of the represented WIT attribute to the value.
// For each bound element value queued by this AttImp, this method sets the
// corresponding bound element of the represented WIT attribute to the value.
// Clears the queue of element values for this AttImp.
d269 1
a269 1
   final void setElementsFromQueue ()
d271 1
a271 1
      if (queuedVectorElMap != null)
d273 1
a273 1
         setVectorElementsFromQueue ();
d276 1
a276 1
      if (queuedBoundElMap != null)
d278 1
a278 1
         setBoundElementsFromQueue ();
d398 1
a398 1
// setVectorElementsFromQueue ()
d400 4
a403 3
// For each vector element value queued by this AttImp, this method sets the
// corresponding vector element of the represented WIT attribute to the value.
// Clears the queue of vector element values for this AttImp.
d406 1
a406 1
   private void setVectorElementsFromQueue ()
d410 1
a410 1
         setDblElementsFromQueue ();
d414 1
a414 1
         setIntElementsFromQueue ();
d418 1
a418 1
         setBoolElementsFromQueue ();
d423 2
a424 2
      queuedVectorElComps = null;
      queuedVectorElMap   = null;
d428 3
a430 3
// setBoolElementsFromQueue ()
// setIntElementsFromQueue  ()
// setDblElementsFromQueue  ()
d434 3
a436 2
// For each vector element value queued by this AttImp, this method sets the
// corresponding vector element of the represented WIT attribute to the value.
d439 1
a439 1
   private void setBoolElementsFromQueue ()
d442 1
a442 1
      Object [] queuedVectorElArr;
d447 1
a447 1
      for (Component theComp: queuedVectorElComps)
d449 1
a449 1
         queuedVectorElArr = queuedVectorElMap.get (theComp);
d455 1
a455 1
            if (queuedVectorElArr[thePer] != null)
d457 1
a457 1
               theBoolArr[thePer] = (Boolean) queuedVectorElArr[thePer];
d467 1
a467 1
   private void setIntElementsFromQueue ()
d470 1
a470 1
      Object[] queuedVectorElArr;
d475 1
a475 1
      for (Component theComp: queuedVectorElComps)
d477 1
a477 1
         queuedVectorElArr = queuedVectorElMap.get (theComp);
d483 1
a483 1
            if (queuedVectorElArr[thePer] != null)
d485 1
a485 1
               theIntArr[thePer] = (Integer) queuedVectorElArr[thePer];
d495 1
a495 1
   private void setDblElementsFromQueue ()
d498 1
a498 1
      Object[] queuedVectorElArr;
d503 1
a503 1
      for (Component theComp: queuedVectorElComps)
d505 1
a505 1
         queuedVectorElArr = queuedVectorElMap.get (theComp);
d511 1
a511 1
            if (queuedVectorElArr[thePer] != null)
d513 1
a513 1
               theDblArr[thePer] = (Double) queuedVectorElArr[thePer];
d522 1
a522 1
// setBoundElementsFromQueue ()
d524 4
a527 3
// For each bound element value queued by this AttImp, this method sets the
// corresponding bound element of the represented WIT attribute to the value.
// Clears the queue of bound element values for this AttImp.
d530 1
a530 1
   private void setBoundElementsFromQueue ()
d542 1
a542 1
      for (Component theComp: queuedBoundElComps)
d546 1
a546 1
         theBoundIDMap = queuedBoundElMap.get (theComp);
d557 2
a558 2
      queuedBoundElComps = null;
      queuedBoundElMap   = null;
d574 1
a574 1
      Double[] queuedBoundElArr;
d577 1
a577 1
      queuedBoundElArr = theBoundIDMap.get (theBoundID);
d579 1
a579 1
      if (queuedBoundElArr == null)
d586 1
a586 1
         if (queuedBoundElArr[thePer] != null)
d588 1
a588 1
            theBoundArr[thePer] = queuedBoundElArr[thePer];
d625 1
a625 1
// queuedVectorElMap
d632 3
a634 2
//    The value type of myAttribute is an array type.
//    A value to myAttribute for theComp in thePeriod has been queued.
d637 1
a637 1
//       queuedVectorElMap.get (theComp)[thePeriod] is the queued value.
d640 1
a640 1
//       queuedVectorElMap                          is null.
d642 1
a642 1
//       queuedVectorElMap.get (theComp)            is null.
d644 1
a644 1
//       queuedVectorElMap.get (theComp)[thePeriod] is null.
d647 1
a647 1
   private HashMap <Component, Object[]> queuedVectorElMap = null;
d650 1
a650 1
// queuedVectorElComps
d652 3
a654 3
// A List of all Components for which queuedVectorElMap.get (theComp) is
// non-null, if any, otherwise null.
// This List enables traversal of queuedVectorElMap in a consistent order.
d657 1
a657 1
   private ArrayList <Component> queuedVectorElComps = null;
d660 1
a660 1
// queuedBoundElMap
d668 3
a670 3
//    The value type of myAttribute is BoundSet.
//    A value to myAttribute for theComp and for theBoundID in thePeriod has
//       been queued.
d673 1
a673 1
//       queuedBoundElMap.
d675 1
a675 1
//             get (theBoundID)[thePeriod] is the queued value.
d678 1
a678 1
//       queuedBoundElMap                  is null.
d680 1
a680 1
//       queuedBoundElMap.
d683 1
a683 1
//       queuedBoundElMap.
d687 1
a687 1
//       queuedBoundElMap.
d695 1
a695 1
         EnumMap <BoundSet.BoundID, Double[]>> queuedBoundElMap = null;
d698 1
a698 1
// queuedVectorElComps
d700 3
a702 3
// A List of all Components for which queuedBoundElMap.get (theComp) is
// non-null, if any, otherwise null.
// This List enables traversal of queuedBoundElMap in a consistent order.
d705 1
a705 1
   private ArrayList <Component> queuedBoundElComps = null;
@


1.12
log
@Made theAttribute.appliesTo (...) based on data on the Java side.
@
text
@d24 1
a24 1
// RetainedObject
d31 1
a31 1
abstract class AttImp extends RetainedObject
d359 1
a359 1
// Override from class RetainedObject.
@


1.11
log
@Moved the iAmModifiable field to AttID class.
@
text
@d48 1
a48 1
// appliesTo (theCompClassID)
d50 3
a52 2
// Returns true, iff this AttImp applies to the Component class identified by
// theCompClassID.
d55 3
a57 1
   abstract boolean appliesTo (CompClassID theCompClassID);
d60 1
a60 1
// verifyIsModifiable ().
d62 3
a64 2
// Verifies that myAttribute.isModifiable () returns the right value.
// The verification is only done for StdAttImps.
d67 1
a67 1
   void verifyIsModifiable ()
@


1.10
log
@Made some methods final.
@
text
@d57 1
a57 1
// isModifiable ()
d59 2
a60 2
// Returns true, iff the corresponding setValue method(s) of class Component can
// validly be invoked for myAttribute.
d63 3
a65 1
   abstract boolean isModifiable ();
@


1.9
log
@Removed setBoundSet and getBoundSet methods from classes AttImp and
   CustAttgImp.
@
text
@d174 4
a177 1
   void queueVectorElement (Component theComp, int thePeriod, Object theValue)
d210 1
a210 1
   void queueBoundElement (
d261 1
a261 1
   void setElementsFromQueue ()
d356 1
a356 1
   String toStringActive ()
d378 1
a378 1
   private final void notOverridden (String methodName, Component theComp)
@


1.8
log
@Setting BoundSet Attributes elements from a queue.
@
text
@a134 9
   void setBoundSet (
         Component  theComp,
         double[] hardLBArr,
         double[] softLBArr,
         double[] hardUBArr)
      {
      notOverridden ("setBoundSet", theComp);
      }

a346 9
   void getBoundSet (
         Component theComp,
         double[]  hardLBArr,
         double[]  softLBArr,
         double[]  hardUBArr)
      {
      notOverridden ("getBoundSet", theComp);
      }

d521 1
d530 2
d534 1
a534 1
         getBoundSet (theComp, hardLBArr, softLBArr, hardUBArr);
d540 1
a540 1
         setBoundSet (theComp, hardLBArr, softLBArr, hardUBArr);
@


1.7
log
@Setting boolean vector elements from queue.
@
text
@d11 1
d177 1
a177 1
// queueElementValue (theComp, thePeriod, theValue)
d183 1
a183 1
   void queueElementValue (Component theComp, int thePeriod, Object theValue)
d185 1
a185 2
      Object[] queuedValueArr;
      int      nPers;
d187 1
a187 1
      if (queuedValueMap == null)
d189 1
a189 1
         queuedValueMap = new HashMap <Component, Object[]> ();
d191 1
a191 1
         queuedComps    = new ArrayList <Component> (16);
d194 1
a194 1
      queuedValueArr = queuedValueMap.get (theComp);
d196 1
a196 1
      if (queuedValueArr == null)
d198 1
a198 1
         nPers          = myCoordinator.getGlobalAspect ().getNPeriods ();
d200 1
a200 1
         queuedValueArr = new Object[nPers];
d202 30
a231 1
         queuedValueMap.put (theComp, queuedValueArr);
d233 19
a251 1
         queuedComps   .add (theComp);
d254 1
a254 1
      queuedValueArr[thePeriod] = theValue;
d262 2
d269 1
a269 4
      if (queuedValueMap == null)
         return;

      if      (myAttribute.getValueType () == double [].class)
d271 1
a271 1
         setDblElementsFromQueue ();
d273 2
a274 5
      else if (myAttribute.getValueType () == int    [].class)
         {
         setIntElementsFromQueue ();
         }
      else if (myAttribute.getValueType () == boolean[].class)
d276 1
a276 1
         setBoolElementsFromQueue ();
a277 5
      else
         assert (false);

      queuedComps    = null;
      queuedValueMap = null;
d405 29
d444 1
a444 1
   void setBoolElementsFromQueue ()
d447 1
a447 1
      Object [] queuedValueArr;
d452 1
a452 1
      for (Component theComp: queuedComps)
d454 1
a454 1
         queuedValueArr = queuedValueMap.get (theComp);
d460 1
a460 1
            if (queuedValueArr[thePer] != null)
d462 1
a462 1
               theBoolArr[thePer] = (Boolean) queuedValueArr[thePer];
d472 1
a472 1
   void setIntElementsFromQueue ()
d475 1
a475 1
      Object[] queuedValueArr;
d480 1
a480 1
      for (Component theComp: queuedComps)
d482 1
a482 1
         queuedValueArr = queuedValueMap.get (theComp);
d488 1
a488 1
            if (queuedValueArr[thePer] != null)
d490 1
a490 1
               theIntArr[thePer] = (Integer) queuedValueArr[thePer];
d500 1
a500 1
   void setDblElementsFromQueue ()
d503 1
a503 1
      Object[] queuedValueArr;
d508 1
a508 1
      for (Component theComp: queuedComps)
d510 1
a510 1
         queuedValueArr = queuedValueMap.get (theComp);
d516 1
a516 1
            if (queuedValueArr[thePer] != null)
d518 1
a518 1
               theDblArr[thePer] = (Double) queuedValueArr[thePer];
d527 70
d626 1
a626 1
// queuedValueMap
d637 1
a637 1
//       queuedValueMap.get (theComp)[thePeriod] is the queued value.
d640 42
a681 1
//       queuedValueMap                          is null.
d683 3
a685 1
//       queuedValueMap.get (theComp)            is null.
d687 3
a689 1
//       queuedValueMap.get (theComp)[thePeriod] is null.
d692 4
a695 1
   private HashMap <Component, Object[]> queuedValueMap = null;
d698 1
a698 1
// queuedComps
d700 3
a702 3
// A List of all Components for which queuedValueMap.get (theComp) is non-null,
// if any, otherwise null.
// This List enables traversal of queuedValueMap in a consistent order.
d705 1
a705 1
   private ArrayList <Component> queuedComps = null;
@


1.6
log
@Setting integer vector elements from a queue.
@
text
@d223 1
a223 1
      if      (myAttribute.getValueType () == double[].class)
d227 1
a227 1
      else if (myAttribute.getValueType () == int   [].class)
d231 4
d367 3
a369 2
// setIntElementsFromQueue ()
// setDblElementsFromQueue ()
d377 28
@


1.5
log
@queueElementValue (...) and setElementsFromQueue ().
@
text
@a219 5
      int      nPers;
      double[] theDblArr;
      Object[] queuedValueArr;
      int      thePer;

d223 5
a227 5
      nPers     = myCoordinator.getGlobalAspect ().getNPeriods ();

      theDblArr = new double[nPers];
      
      for (Component theComp: queuedComps)
d229 1
a229 13
         queuedValueArr = queuedValueMap.get (theComp);

         getDblVec (theComp, theDblArr);

         for (thePer = 0; thePer < nPers; thePer ++)
            {
            if (queuedValueArr[thePer] != null)
               {
               theDblArr[thePer] = (Double) queuedValueArr[thePer];
               }
            }

         setDblVec (theComp, theDblArr);
d231 2
d362 73
d462 2
a463 2
// Assume:
//    The value type of myAttribute is double[].
@


1.4
log
@Added queuedComps List to class AttImp.
@
text
@d182 1
a182 1
   void queueElementValue (Component theComp, int thePeriod, double theValue)
d184 2
a185 3
      boolean[] valueIsQueuedArr;
      double [] queuedValueArr;
      int       nPers;
d187 1
a187 1
      if (valueIsQueuedMap == null)
d189 1
a189 2
         valueIsQueuedMap = new HashMap <Component, boolean[]> ();
         queuedValueMap   = new HashMap <Component, double []> ();
d191 1
a191 1
         queuedComps      = new ArrayList <Component> (16);
d194 1
a194 2
      valueIsQueuedArr = valueIsQueuedMap.get (theComp);
      queuedValueArr   = queuedValueMap  .get (theComp);
d196 1
a196 1
      if (valueIsQueuedArr == null)
d198 1
a198 1
         nPers = myCoordinator.getGlobalAspect ().getNPeriods ();
d200 1
a200 2
         valueIsQueuedArr = new boolean[nPers];
         queuedValueArr   = new double [nPers];
d202 1
a202 2
         valueIsQueuedMap.put (theComp, valueIsQueuedArr);
         queuedValueMap  .put (theComp, queuedValueArr);
d204 1
a204 1
         queuedComps     .add (theComp);
d207 1
a207 2
      valueIsQueuedArr[thePeriod] = true;
      queuedValueArr  [thePeriod] = theValue;
d220 4
a223 5
      int       nPers;
      boolean[] valueIsQueuedArr;
      double [] queuedValueArr;
      double [] theDblArr;
      int       thePer;
d225 1
a225 1
      if (valueIsQueuedMap == null)
d231 1
a231 1

d234 1
a234 2
         valueIsQueuedArr = valueIsQueuedMap.get (theComp);
         queuedValueArr   = queuedValueMap  .get (theComp);
d240 1
a240 1
            if (valueIsQueuedArr[thePer])
d242 1
a242 1
               theDblArr[thePer] = queuedValueArr[thePer];
d249 2
a250 3
      queuedComps      = null;
      valueIsQueuedMap = null;
      queuedValueMap   = null;
a397 1
// valueIsQueuedMap
d409 1
a409 2
//    valueIsQueuedMap.get (theComp)[thePeriod] is true.
//    queuedValueMap  .get (theComp)[thePeriod] is the queued value.
d412 1
a412 2
//       valueIsQueuedMap                       is null.
//       queuedValueMap                         is null.
d414 1
a414 2
//       valueIsQueuedMap.get (theComp)         is null.
//       queuedValueMap  .get (theComp)         is null.
d416 1
a416 2
//       valueIsQueuedMap.get (theComp)[thePeriod] is false.
//       queuedValueMap  .get (theComp)[thePeriod] is undefined.
d419 1
a419 2
   private HashMap <Component, boolean[]> valueIsQueuedMap = null;
   private HashMap <Component, double []> queuedValueMap   = null;
d424 3
a426 3
// List of Components for which valueIsQueuedMap.get (theComp) is non-null, if
// any, otherwise null.
// This List enables traversal of valueIsQueuedMap in a consistent order.
@


1.3
log
@Setting vector elements from the queue.
@
text
@d192 2
d208 2
d239 1
a239 1
      for (Component theComp: valueIsQueuedMap.keySet ())
d257 1
d436 10
@


1.2
log
@Initial implementation of theComp.queueElementValue (...).
@
text
@d178 2
a179 2
// Queues theValue as a value to which myAttribute is to be set (later) for 
// theComp in thePeriod.
d213 45
@


1.1
log
@Changed names of AttRep classes to AttImp.
@
text
@d12 2
d36 1
a36 1
   AttImp (Attribute <?> theAtt)
d38 2
a39 1
      myAttribute = theAtt;
d176 37
d348 38
@


head	1.102;
access;
symbols;
locks; strict;
comment	@ * @;


1.102
date	2011.04.12.00.33.13;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.08.20.56.20;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.07.22.11.21;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.07.21.39.27;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.07.19.07.39;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.06.21.56.49;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2011.04.06.20.34.27;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2011.03.30.23.23.02;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2011.03.28.15.57.08;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2011.03.28.15.27.44;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2011.03.25.22.49.16;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2011.03.23.20.30.07;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2011.03.22.20.17.24;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2011.03.19.00.26.12;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2011.03.15.23.02.51;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.03.12.00.29.52;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.03.11.23.49.24;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.02.25.16.06.52;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.02.16.21.03.10;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2011.02.15.19.38.02;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2011.02.14.19.59.10;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.20.20.55.07;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.29.15.18.10;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.08.22.13.11;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2009.04.24.17.42.51;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.21.20.56.07;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.17.19.51.59;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.25.23.06.44;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.25.22.13.53;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2009.02.19.19.51.46;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2009.02.18.17.00.43;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2009.02.17.23.46.01;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.17.19.26.13;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.17.17.23.49;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2009.02.14.00.51.29;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2009.02.11.18.59.29;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.10.23.19.29;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.06.22.40.58;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.23.20.49.54;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.01.23.18.46.54;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.21.21.43.23;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.20.22.05.03;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.16.21.11.47;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.16.20.55.48;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.16.19.42.43;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.16.19.09.00;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.16.18.49.18;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.16.17.03.35;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.15.22.50.31;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.15.20.46.52;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.15.17.03.29;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.14.22.24.34;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.12.17.24.13;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.08.21.13.52;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.24.00.18.55;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.23.15.30.36;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.22.16.29.12;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.18.22.12.34;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.18.22.00.08;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.15.22.31.41;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.15.17.28.48;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.15.17.17.39;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.12.22.53.06;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.12.19.29.26;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.26.18.33.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.26.14.48.19;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.25.15.28.47;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.31.14.53.29;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.07.18.50.24;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.06.22.14.03;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.03.18.07.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.02.21.45.13;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.02.17.34.36;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.30.15.17.41;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.26.22.50.17;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.24.16.26.36;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.22.15.26.56;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.19.21.59.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.16.22.21.40;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.16.22.14.01;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.12.19.44.33;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.12.18.57.24;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.12.15.22.02;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.12.14.43.23;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.11.22.22.46;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.10.21.32.34;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.09.20.04.07;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.09.18.59.59;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.27.15.30.46;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.01.16.09.22;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.19.19.31.13;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.18.21.28.18;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.22.21.23.00;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.21.22.09.35;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.21.14.33.48;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.19.22.20.55;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.19.16.15.30;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.16.18.37.16;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.15.22.11.57;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.15.21.03.30;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.15.19.45.17;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.20.54.11;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.102
log
@Class StringJOR
@
text
@//------------------------------------------------------------------------------
// WIT-J C++ Header File Problem.h.
//
// Contains the declaration of typedef SimpleWitFunc
// Contains the declaration of class Problem.
//------------------------------------------------------------------------------

#ifndef Problem_h
#define Problem_h

#include <Component.h>

#include       <wit.h>

#include       <map>
#include    <string>

//------------------------------------------------------------------------------
// Typedef SimpleWitFunc
// "Simple WIT API Function"
//
// A pointer to a WIT API function whose only argument is the WitRun *.
//------------------------------------------------------------------------------

namespace WitJ
{
typedef WIT_DECLSPEC witReturnCode STDCALL (* SimpleWitFunc) (WitRun * const);
}

//------------------------------------------------------------------------------
// Class Problem
//
// An instance of class Problem represents an implosion problem and corresponds
// to a WitRun.
// The public member functions of this class mostly correspond to public methods
// of Java class Problem.
//
// Class Hierarchy:
//
// JavaAccObj
//    Component
//       Problem
//------------------------------------------------------------------------------

namespace WitJ
{
class Problem: public Component
   {
   //---------------------------------------------------------------------------
   // Public member functions.
   //---------------------------------------------------------------------------

   public:

   explicit Problem (Coordinator *);
      //
      // Constructor.

   ~Problem ();
      //
      // Destructor.
   
   virtual Problem * asProblem ();
      //
      // Override from class JavaAccObj.

   virtual void copyComponentData (Component *);
      //
      // Override from class Component.

   void callSimpleWitFunc (const char * theFuncName);
      //
      // Calls the simple WIT API function whose name is given by theFuncName.
      // Asserts that such a function has been defined.

   void writeSched (
         const char * schedName,
         const char * fileName,
         bool         theFormatIsBSV);
      //
      // Calls the appropriate WIT API function to write the schedule indicated
      // by schedName to a file whose name is given by fileName, using either
      // the BSV file format if theFormatIsBSV is true, or otherwise the CSV
      // file format.

   void setNPeriods (int theInt);
      //
      // Wrapper for witSetNPeriods.

   int getNPeriods ();
      //
      // Returns nPeriods.

   void clearData ();
      //
      // Restores this Problem to its default state.

   void performAction (const char * theCommand);
      //
      // Performs the action indicated by theCommand.

   bool throwUnexpException ();
      //
      // Throws an exception of a type not expected by WIT-J.
      // Used for testing.
      // A special function that returns a bool is used for this case, in order
      // to test a canonical try block whose return statement returns a value.

   //---------------------------------------------------------------------------
   // Wrappers for WIT API Functions.
   //---------------------------------------------------------------------------

   void addDblCplexParSpec  (const char *            theName,
                             double                  theValue);

   void addIntCplexParSpec  (const char *            theName,
                             int                     theValue);

   void copyData            (Problem *               origProblem);

   void displayData         (const char *            fileName);

   void eqHeurAlloc         (DemandALJOR &           theDemandALJOR,
                             IntALJOR &              shipPeriodALJOR,
                             DblALJOR &              desIncVolALJOR,
                             DblALJOR &              incVolALJOR);

   void getCriticalList     (CompALJOR <Part> &      critPartALJOR,
                             IntALJOR &              critPeriodALJOR);

   void getDblCplexParSpec  (const char *            theName,
                             bool &                  dblSpecExists,
                             double &                dblValue);

   void getExpCycle         (CompALJOR <Part> &      thePartALJOR,
                             CompALJOR <Operation> & theOpnALJOR);

   void getIntCplexParSpec  (const char *            theName,
                             bool &                  intSpecExists,
                             int &                   intValue);

   void getObjectiveList    (StringALJOR &           theObjNameALJOR);

   void getOptInitMethod    (StringJOR &             theMethodNameSJOR);

   void getPgdCritList      (CompALJOR <Part> &      critPartALJOR,
                             IntALJOR &              critPeriodALJOR,
                             CompALJOR <Demand> &    theDemandALJOR,
                             IntALJOR &              shipPeriodALJOR);

   void getPipSeq           (PeggingTripleALJOR &    theDemandPTALJOR);

   void getSortedOperations (CompALJOR <Operation> & theOpnALJOR);

   void getSortedParts      (CompALJOR <Part> &      thePartALJOR);

   void readData            (const char *            fileName);

   void setObjectiveList    (StringALJOR &           theObjNameALJOR);

   void setOptInitMethod    (const char *            theMethodNameCStr);

   void writeCriticalList   (const char *            fileName,
                             bool                    theFormatIsBSV,
                             int                     maxListLen);

   void writeData           (const char *            fileName);

   //---------------------------------------------------------------------------
   // Private member functions.
   //---------------------------------------------------------------------------

   private:

   void defineAllSimpleWitFuncs ();
      //
      // Populates mySimpleWitFuncMap_.

   void defineSimpleWitFunc (const char * theFuncName, SimpleWitFunc theFunc);
      //
      // Creates an entry in mySimpleWitFuncMap_ mapping theFuncName to theFunc;

   void exhaustMemory ();
      //
      // Repeatedly allocates memory in 100MB increments until memory is
      // exhausted.
      // Used for testing.

   Problem              (const Problem &);
   Problem & operator = (const Problem &);
      //
      // Not implemented; prevents accidental copying and assignment.

   //---------------------------------------------------------------------------
   // Private member data.
   //---------------------------------------------------------------------------

   std::map <std::string, SimpleWitFunc> mySimpleWitFuncMap_;
      //
      // Maps the name of a simple WIT API function to the corresponding
      // function pointer.

   int nPeriods_;
      //
      // Cached copy of the value stored in WIT.
   };
};
//
// End of namespace WitJ.

#endif
@


1.101
log
@copyComponentData
@
text
@d113 2
a114 2
   void         addDblCplexParSpec  (const char *            theName,
                                     double                  theValue);
d116 2
a117 2
   void         addIntCplexParSpec  (const char *            theName,
                                     int                     theValue);
d119 1
a119 1
   void         copyData            (Problem *               origProblem);
d121 1
a121 1
   void         displayData         (const char *            fileName);
d123 4
a126 4
   void         eqHeurAlloc         (DemandALJOR &           theDemandALJOR,
                                     IntALJOR &              shipPeriodALJOR,
                                     DblALJOR &              desIncVolALJOR,
                                     DblALJOR &              incVolALJOR);
d128 2
a129 2
   void         getCriticalList     (CompALJOR <Part> &      critPartALJOR,
                                     IntALJOR &              critPeriodALJOR);
d131 3
a133 3
   void         getDblCplexParSpec  (const char *            theName,
                                     bool &                  dblSpecExists,
                                     double &                dblValue);
d135 2
a136 2
   void         getExpCycle         (CompALJOR <Part> &      thePartALJOR,
                                     CompALJOR <Operation> & theOpnALJOR);
d138 3
a140 3
   void         getIntCplexParSpec  (const char *            theName,
                                     bool &                  intSpecExists,
                                     int &                   intValue);
d142 1
a142 1
   void         getObjectiveList    (StringALJOR &           theObjNameALJOR);
d144 1
a144 1
   const char * getOptInitMethod    ();
d146 4
a149 4
   void         getPgdCritList      (CompALJOR <Part> &      critPartALJOR,
                                     IntALJOR &              critPeriodALJOR,
                                     CompALJOR <Demand> &    theDemandALJOR,
                                     IntALJOR &              shipPeriodALJOR);
d151 1
a151 1
   void         getPipSeq           (PeggingTripleALJOR &    theDemandPTALJOR);
d153 1
a153 1
   void         getSortedOperations (CompALJOR <Operation> & theOpnALJOR);
d155 1
a155 1
   void         getSortedParts      (CompALJOR <Part> &      thePartALJOR);
d157 1
a157 1
   void         readData            (const char *            fileName);
d159 1
a159 1
   void         setObjectiveList    (StringALJOR &           theObjNameALJOR);
d161 1
a161 1
   void         setOptInitMethod    (const char *            theMethodNameCStr);
d163 3
a165 3
   void         writeCriticalList   (const char *            fileName,
                                     bool                    theFormatIsBSV,
                                     int                     maxListLen);
d167 1
a167 1
   void         writeData           (const char *            fileName);
@


1.100
log
@getSortedOperations
@
text
@d67 4
d119 1
a119 1
   void         copyData            (Problem *               srcProblem);
@


1.99
log
@getSortedParts
@
text
@d109 2
a110 2
   void         addDblCplexParSpec (const char *           theName,
                                    double                 theValue);
d112 2
a113 2
   void         addIntCplexParSpec (const char *           theName,
                                    int                    theValue);
d115 1
a115 1
   void         copyData           (Problem *              srcProblem);
d117 1
a117 1
   void         displayData        (const char *           fileName);
d119 4
a122 4
   void         eqHeurAlloc        (DemandALJOR &          theDemandALJOR,
                                    IntALJOR &             shipPeriodALJOR,
                                    DblALJOR &             desIncVolALJOR,
                                    DblALJOR &             incVolALJOR);
d124 2
a125 2
   void         getCriticalList    (CompALJOR <Part> &     critPartALJOR,
                                    IntALJOR &             critPeriodALJOR);
d127 3
a129 3
   void         getDblCplexParSpec (const char *           theName,
                                    bool &                 dblSpecExists,
                                    double &               dblValue);
d131 2
a132 2
   void         getExpCycle       (CompALJOR <Part> &      thePartALJOR,
                                   CompALJOR <Operation> & theOpnALJOR);
d134 3
a136 3
   void         getIntCplexParSpec (const char *           theName,
                                    bool &                 intSpecExists,
                                    int &                  intValue);
d138 1
a138 1
   void         getObjectiveList   (StringALJOR &          theObjNameALJOR);
d140 1
a140 1
   const char * getOptInitMethod   ();
d142 4
a145 4
   void         getPgdCritList     (CompALJOR <Part> &     critPartALJOR,
                                    IntALJOR &             critPeriodALJOR,
                                    CompALJOR <Demand> &   theDemandALJOR,
                                    IntALJOR &             shipPeriodALJOR);
d147 1
a147 1
   void         getPipSeq          (PeggingTripleALJOR &   theDemandPTALJOR);
d149 1
a149 1
   void         getSortedParts     (CompALJOR <Part> &     thePartALJOR);
d151 1
a151 1
   void         readData           (const char *           fileName);
d153 1
a153 1
   void         setObjectiveList   (StringALJOR &          theObjNameALJOR);
d155 1
a155 1
   void         setOptInitMethod   (const char *           theMethodNameCStr);
d157 1
a157 3
   void         writeCriticalList  (const char *           fileName,
                                    bool                   theFormatIsBSV,
                                    int                    maxListLen);
d159 5
a163 1
   void         writeData          (const char *           fileName);
@


1.98
log
@getExpCycle
@
text
@d149 2
@


1.97
log
@Critical parts list
@
text
@d109 2
a110 2
   void         addDblCplexParSpec (const char *         theName,
                                    double               theValue);
d112 2
a113 2
   void         addIntCplexParSpec (const char *         theName,
                                    int                  theValue);
d115 1
a115 1
   void         copyData           (Problem *            srcProblem);
d117 1
a117 1
   void         displayData        (const char *         fileName);
d119 4
a122 5
   void         eqHeurAlloc (
                   DemandALJOR &                         theDemandALJOR,
                   IntALJOR &                            shipPeriodALJOR,
                   DblALJOR &                            desIncVolALJOR,
                   DblALJOR &                            incVolALJOR);
d124 2
a125 3
   void         getCriticalList    (
                   CompALJOR <Part> &                    critPartALJOR,
                   IntALJOR &                            critPeriodALJOR);
d127 3
a129 5
   void         getPgdCritList     (
                   CompALJOR <Part> &                    critPartALJOR,
                   IntALJOR &                            critPeriodALJOR,
                   CompALJOR <Demand> &                  theDemandALJOR,
                   IntALJOR &                            shipPeriodALJOR);
d131 2
a132 3
   void         getDblCplexParSpec (const char *         theName,
                                    bool &               dblSpecExists,
                                    double &             dblValue);
d134 3
a136 3
   void         getIntCplexParSpec (const char *         theName,
                                    bool &               intSpecExists,
                                    int &                intValue);
d138 1
a138 1
   void         getObjectiveList   (StringALJOR &        theObjNameALJOR);
d142 4
a145 1
   void         getPipSeq          (PeggingTripleALJOR & theDemandPTALJOR);
d147 1
a147 1
   void         readData           (const char *         fileName);
d149 1
a149 1
   void         setObjectiveList   (StringALJOR &        theObjNameALJOR);
d151 1
a151 1
   void         setOptInitMethod   (const char *         theMethodNameCStr);
d153 1
a153 3
   void         writeCriticalList  (const char *         fileName,
                                    bool                 theFormatIsBSV,
                                    int                  maxListLen);
d155 5
a159 1
   void         writeData          (const char *         fileName);
@


1.96
log
@getPgdCritList
@
text
@d126 2
a127 2
                   CompALJOR <Part> &                    thePartALJOR,
                   IntALJOR &                            thePeriodALJOR);
@


1.95
log
@Revised set/get ObjectiveList for ArrayList <String>.
@
text
@d129 6
@


1.94
log
@Changed name of class AllocTriple to PeggingTriple.
@
text
@d137 1
a137 2

   void         getObjectiveList   (WitStrVecOwner &     theObjNameWSVO);
d141 1
a141 1
   void         getPipSeq          (PeggingTripleALJOR & theDemandATALJOR);
d145 1
a145 1
   void         setObjectiveList   (const StringVec &    theObjNameVec);
@


1.93
log
@Removed some #includes.
@
text
@d109 2
a110 2
   void         addDblCplexParSpec (const char *       theName,
                                    double             theValue);
d112 2
a113 2
   void         addIntCplexParSpec (const char *       theName,
                                    int                theValue);
d115 1
a115 1
   void         copyData           (Problem *          srcProblem);
d117 1
a117 1
   void         displayData        (const char *       fileName);
d120 4
a123 4
                   DemandALJOR &                       theDemandALJOR,
                   IntALJOR &                          shipPeriodALJOR,
                   DblALJOR &                          desIncVolALJOR,
                   DblALJOR &                          incVolALJOR);
d126 2
a127 2
                   CompALJOR <Part> &                  thePartALJOR,
                   IntALJOR &                          thePeriodALJOR);
d129 3
a131 3
   void         getDblCplexParSpec (const char *       theName,
                                    bool &             dblSpecExists,
                                    double &           dblValue);
d133 3
a135 3
   void         getIntCplexParSpec (const char *       theName,
                                    bool &             intSpecExists,
                                    int &              intValue);
d138 1
a138 1
   void         getObjectiveList   (WitStrVecOwner &   theObjNameWSVO);
d142 1
a142 1
   void         getPipSeq          (AllocTripleALJOR & theDemandATALJOR);
d144 1
a144 1
   void         readData           (const char *       fileName);
d146 1
a146 1
   void         setObjectiveList   (const StringVec &  theObjNameVec);
d148 1
a148 1
   void         setOptInitMethod   (const char *       theMethodNameCStr);
d150 3
a152 3
   void         writeCriticalList  (const char *       fileName,
                                    bool               theFormatIsBSV,
                                    int                maxListLen);
d154 1
a154 1
   void         writeData          (const char *       fileName);
@


1.92
log
@ArrayListJOR
@
text
@a16 1
#include    <vector>
@


1.91
log
@AllocTripleALJOR
@
text
@d110 2
a111 2
   void         addDblCplexParSpec (const char *      theName,
                                    double            theValue);
d113 2
a114 2
   void         addIntCplexParSpec (const char *      theName,
                                    int               theValue);
d116 1
a116 1
   void         copyData           (Problem *         srcProblem);
d118 1
a118 1
   void         displayData        (const char *      fileName);
d121 4
a124 4
                   CompALJOR <Demand> &               theDemandALJOR,
                   IntALJOR &                         shipPeriodALJOR,
                   DblALJOR &                         desIncVolALJOR,
                   DblALJOR &                         incVolALJOR);
d127 2
a128 2
                   CompALJOR <Part> &                 thePartALJOR,
                   IntALJOR &                         thePeriodALJOR);
d130 3
a132 3
   void         getDblCplexParSpec (const char *      theName,
                                    bool &            dblSpecExists,
                                    double &          dblValue);
d134 3
a136 3
   void         getIntCplexParSpec (const char *      theName,
                                    bool &            intSpecExists,
                                    int &             intValue);
d139 1
a139 1
   void         getObjectiveList   (WitStrVecOwner &  theObjNameWSVO);
d143 1
d145 1
a145 1
   void         getPipSeq          (AllocTripleVec *  theTripleVec);
d147 1
a147 2
   void         getPipSeq          (AllocTripleALJOR <Demand> &
                                                      theDemandATALJOR);
d149 1
a149 1
   void         readData           (const char *      fileName);
d151 3
a153 1
   void         setObjectiveList   (const StringVec & theObjNameVec);
d155 1
a155 7
   void         setOptInitMethod   (const char *      theMethodNameCStr);

   void         writeCriticalList  (const char *      fileName,
                                    bool              theFormatIsBSV,
                                    int               maxListLen);

   void         writeData          (const char *      fileName);
@


1.90
log
@getCriticialList and eqHeurAlloc.
@
text
@d144 4
a147 1
   void         getPipSeq          (AllocTripleVec *    theTripleVec);
@


1.89
log
@Revised the arguments to eqHeurAlloc.
@
text
@d121 1
a121 1
                   DemandALJOR &                      theDemandALJOR,
d127 1
a127 1
                   PartALJOR &                        thePartALJOR,
@


1.88
log
@Name changes.
@
text
@d121 4
a124 4
                   const std::vector <Demand *> &     theDemandVec,
                   const std::vector <int> &          shipPerVec,
                   const std::vector <double> &       desIncVolVec,
                   WitVecOwner <double> &             incVolWVO);
d127 1
a127 1
                   CompALJOR <Part> &                 thePartALJOR,
@


1.87
log
@Problem.getCriticalList ()
@
text
@d127 2
a128 2
                   CompJArrayList <Part> &            thePartJAL,
                   IntJArrayList &                    thePeriodJAL);
@


1.86
log
@Problem.getCriticalList ()
@
text
@d127 2
a128 2
                   CompJArrayList <Part> &            thePartsJAL,
                   IntJArrayList &                    thePeriodsJAL);
@


1.85
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@d126 4
@


1.84
log
@CPLEX
@
text
@d11 1
a11 1
#include <JavaAccObj.h>
d13 1
a13 1
#include        <wit.h>
d15 3
a17 3
#include        <map>
#include     <string>
#include     <vector>
d42 2
a43 1
//    Problem
d48 1
a48 1
class Problem: public JavaAccObj
d83 12
d110 7
a116 2
   void addDblCplexParSpec (const char *                   theName,
                            double                         theValue);
d118 1
a118 2
   void addIntCplexParSpec (const char *                   theName,
                            int                            theValue);
d120 5
a124 1
   void copyData           (Problem *                      srcProblem);
d126 3
a128 1
   void displayData        (const char *                   fileName);
d130 3
a132 3
   void getDblCplexParSpec (const char *                   theName,
                            bool &                         dblSpecExists,
                            double &                       dblValue);
a133 3
   void getIntCplexParSpec (const char *                   theName,
                            bool &                         intSpecExists,
                            int &                          intValue);
d135 1
a135 4
   void eqHeurAlloc        (const std::vector <Demand *> & theDemandVec,
                            const std::vector <int> &      shipPerVec,
                            const std::vector <double> &   desIncVolVec,
                            WitVecOwner <double> &         incVolWVO);
d137 1
a137 1
   void readData           (const char *                   fileName);
a138 3
   void writeCriticalList  (const char *                   fileName,
                            bool                           theFormatIsBSV,
                            int                            maxListLen);
d140 13
a152 1
   void writeData          (const char *                   fileName);
d187 4
@


1.83
log
@CPLEX
@
text
@d107 4
@


1.82
log
@CPLEX
@
text
@a106 2
#if 0

a110 2
#endif

@


1.81
log
@Multi-Obj Mode
@
text
@d97 2
a98 1
   void copyData          (Problem *                      srcProblem);
d100 2
a101 1
   void displayData       (const char *                   fileName);
d103 1
a103 4
   void eqHeurAlloc       (const std::vector <Demand *> & theDemandVec,
                           const std::vector <int> &      shipPerVec,
                           const std::vector <double> &   desIncVolVec,
                           WitVecOwner <double> &         incVolWVO);
d105 1
a105 1
   void readData          (const char *                   fileName);
d107 1
a107 3
   void writeCriticalList (const char *                   fileName,
                           bool                           theFormatIsBSV,
                           int                            maxListLen);
d109 18
a126 1
   void writeData         (const char *                   fileName);
@


1.80
log
@Method argument name change.
@
text
@d104 1
a104 1
                           VecWoa <double> &              incVolVecWoa);
@


1.79
log
@Removed the "enabled" concept from WIT-J.
@
text
@d97 1
a97 1
   void copyData          (Problem *                      theProblem);
@


1.78
log
@Timing test.
@
text
@a66 4
   void enable ();
      //
      // Puts this Problem into an enabled state.

a142 6
   bool enabled_;
      //
      // True, iff this Problem is considered to be "enabled". This will be the
      // case precisely when the Java Problem that owns this Problem is enabled.
      // For more details, see the enabled field of the Java class Problem.

@


1.77
log
@Aded temporary code to test the ability to measure CPU time.
@
text
@a137 4
   void timeHeurImplode ();
      //
      // Performs heuristic implosion and displays its CPU time.

@


1.76
log
@theProblem.copyData (...).
@
text
@d138 4
@


1.75
log
@writeCriticalList
@
text
@d101 2
@


1.74
log
@Implemented writeExecSched, writeShipSched, and writeReqSched.
@
text
@d101 1
a101 1
   void displayData (const char *                   fileName);
d103 4
a106 4
   void eqHeurAlloc (const std::vector <Demand *> & theDemandVec,
                     const std::vector <int> &      shipPerVec,
                     const std::vector <double> &   desIncVolVec,
                     VecWoa <double> &              incVolVecWoa);
d108 1
a108 1
   void readData    (const char *                   fileName);
d110 5
a114 1
   void writeData   (const char *                   fileName);
@


1.73
log
@Moved set/get-PipSeq from class Problem to class GlobalElement.
@
text
@d76 10
@


1.72
log
@PIP
@
text
@a86 5
   void getPipSeq ();
      //
      // Retrieves the PIP shipment sequence and stores it in the Java
      // Coordinator's currently held AllocTriple List.

@


1.71
log
@Removed the ShipTriple classes.
@
text
@d90 1
a90 1
      // Coordinator's AllocTriple List.
@


1.70
log
@PIP.
@
text
@d96 1
a96 1
   void displayData (const char *                       fileName);
d98 4
a101 2
   void eqHeurAlloc (const std::vector <ShipTriple *> & theTripleVec,
                     VecWoa <double> &                  incVolVecWoa);
d103 1
a103 1
   void readData    (const char *                       fileName);
d105 1
a105 1
   void writeData   (const char *                       fileName);
@


1.69
log
@PIP.
@
text
@a86 5
   void setPipSeq (const std::vector <ShipTriple *> & theTripleVec);
      //
      // Sets the PIP shipment sequence to the list of ShipTriples in
      // theTripleVec.

@


1.68
log
@Implemented getPipSeq.
@
text
@d92 5
a105 4
   void getPipSeq   (std::vector <Element *> &          theElementVec,
                     VecWoa <int> &                     theShipPerVecWoa,
                     VecWoa <double> &                  incShipVolVecWoa);

@


1.67
log
@Implemented buildPip and setPipSeq.
@
text
@d101 4
@


1.66
log
@Replaced the AllocTarget classes with ShipTriple classes.
@
text
@d87 5
a105 4
   // Accessors.
   //---------------------------------------------------------------------------

   //---------------------------------------------------------------------------
@


1.65
log
@Problem.eqHeurAlloc.
@
text
@d91 1
a91 1
   void displayData (const char *                        fileName);
d93 2
a94 1
   void eqHeurAlloc (const std::vector <AllocTarget *> & theTargetVec);
d96 1
a96 1
   void readData    (const char *                        fileName);
d98 1
a98 1
   void writeData   (const char *                        fileName);
@


1.64
log
@Coordinator
@
text
@d17 1
d91 7
a97 3
   void displayData (const char * fileName);
   void readData    (const char * fileName);
   void writeData   (const char * fileName);
@


1.63
log
@Coordinator
@
text
@a85 4
   WitRun * getWitRun ();
      //
      // Pass thru to myCoordinator_.

a97 5
   inline Coordinator * getCoordinator ()
      {
      return myCoordinator_;
      }

a126 4
   Coordinator * const myCoordinator_;
      //
      // The Coordinator for this Problem.

@


1.62
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@d54 1
a54 1
   explicit Problem (JavaObjRep *, Coordinator *);
a106 5
   inline JavaObjRep * getJavaObjRep ()
      {
      return myJavaObjRep_;
      }

a139 4
   JavaObjRep * const myJavaObjRep_;
      //
      // The JavaObjRep for this Problem.

@


1.61
log
@Continued implementation of the ProbMgr classes.
@
text
@d54 1
a54 1
   explicit Problem (JavaObjRep *, ProbMgr *);
d88 1
a88 1
      // Pass thru to myProbMgr_.
d102 1
a102 1
   inline ProbMgr * getProbMgr ()
d104 1
a104 1
      return myProbMgr_;
d141 1
a141 1
   ProbMgr * const myProbMgr_;
d143 1
a143 1
      // The ProbMgr for this Problem.
@


1.60
log
@ProbMgr classes.
@
text
@d4 1
d13 17
d70 5
d118 8
d154 5
@


1.59
log
@ProbMgr classes.
@
text
@a75 13
   // Find{Element Class} functions.
   //
   // Each of these functions finds and returns the instance of the indicated
   // Element class identified by the arguments.
   // If the Element does not exist, WIT will issue a severe error.
   //---------------------------------------------------------------------------

   Part *      findPart      (const char * thePartName);
   Operation * findOperation (const char * theOpnName);
   BomEntry *  findBomEntry  (const char * theOpnName,
                              int          theBomIndex);

   //---------------------------------------------------------------------------
@


1.58
log
@ProbMgr classes.
@
text
@a11 16
#include        <wit.h>

#include        <map>

//------------------------------------------------------------------------------
// Typedef SimpleWitFunc
// "Simple WIT API Function"
//
// A pointer to a WIT API function whose only argument is the WitRun *.
//------------------------------------------------------------------------------

namespace WitJ
{
typedef WIT_DECLSPEC witReturnCode STDCALL (* SimpleWitFunc) (WitRun * const);
}

d17 2
a51 5
   void callSimpleWitFunc (const char * theFuncName);
      //
      // Calls the simple WIT API function whose name is given by theFuncName.
      // Asserts that such a function has been defined.

a107 8
   void defineAllSimpleWitFuncs ();
      //
      // Populates mySimpleWitFuncMap_.

   void defineSimpleWitFunc (const char * theFuncName, SimpleWitFunc theFunc);
      //
      // Creates an entry in mySimpleWitFuncMap_ mapping theFuncName to theFunc;

a135 5

   std::map <std::string, SimpleWitFunc> mySimpleWitFuncMap_;
      //
      // Maps the name of a simple WIT API function to the corresponding
      // function pointer.
@


1.57
log
@ProbMgr classes.
@
text
@a120 5
   inline Extractor * getExtractor ()
      {
      return myExtractor_;
      }

a157 4
   Extractor * myExtractor_;
      // 
      // The Extractor that belongs to this Problem.

@


1.56
log
@ProbMgr classes.
@
text
@a65 5
   void freezeNPeriods ();
      //
      // Indicates that nPeriods can no longer be changed because at least one
      // Part or Operation exists.

a120 7
   inline CTVecRes * getCTVecRes ()
      {
      EXCEPTION_ASSERT (myCTVecRes_ != NULL);

      return myCTVecRes_;
      }

a162 4
   CTVecRes * myCTVecRes_;
      //
      // The CTVecRes that belongs to this Problem, if any; otherwise NULL.

@


1.55
log
@Change the mname of the ProbCtr classes to ProbMgr in both Java and C++.
@
text
@a65 5
   void store (GlobalElement * theGlobalElement);
      //
      // Stores theGlobalElement as myGlobalElement_.
      // Must be called exactly once.

a125 5
   inline GlobalElement * getGlobalElement ()
      {
      return myGlobalElement_;
      }

a174 4
   GlobalElement * myGlobalElement_;
      //
      // The GlobalElement for this Problem.

@


1.54
log
@Continued implementation of ProbCtr classes.
@
text
@d50 1
a50 1
   explicit Problem (JavaObjRep *, ProbCtr *);
d94 1
a94 1
      // Pass thru to myProbCtr_.
d121 1
a121 1
   inline ProbCtr * getProbCtr ()
d123 1
a123 1
      return myProbCtr_;
d177 1
a177 1
   ProbCtr * const myProbCtr_;
d179 1
a179 1
      // The ProbCtr for this Problem.
@


1.53
log
@Continued implementation of the ProbCtr classes.
@
text
@d50 1
a50 1
   static Problem * newInstance  (JavaObjRep * theProblemJOR);
d52 1
a52 1
      // Constructs and returns a new Problem for theProblemJOR.
a95 5
   void relinquishProbCtr ();
      //
      // Asserts that this Problem owns myProbCtr_.
      // Transfers ownership of myProbCtr_ to the caller.

a153 2
   explicit Problem (JavaObjRep *, ProbCtr *);

a176 4
   ProbCtr * ownedProbCtr_;
      //
      // The ProbCtr owned by this Problem, if any.

@


1.52
log
@Initial implementation of Java classes ProbCtrCOR ProbCtr.
@
text
@d50 3
a52 1
   explicit Problem (JavaObjRep * theProblemJOR);
d159 2
d188 1
a188 1
   ProbCtr * myProbCtr_;
@


1.51
log
@Initial implementation of C++ class ProbCtr.
@
text
@d94 5
d180 4
d186 1
a186 1
      // The ProbCtr owned by this Problem.
@


1.50
log
@Implemented method writeData of class Problem.
@
text
@d31 2
a32 2
// An instance of class Problem represents an implosion problem and
// corresponds to an initialized WitRun.
a51 4
   static void deleteInstance (Problem * theProblem);
      //
      // Deletes theProblem and the Session that it owns.

d90 4
d119 1
a119 1
   inline WitRun * getWitRun ()
d121 1
a121 1
      return myWitRun_;
d175 1
a175 1
   WitRun * myWitRun_;
d177 1
a177 1
      // The WitRun owned by this Session.
@


1.49
log
@Implemented SimpleWitFuncs and used them for 4 methods.
@
text
@d100 1
@


1.48
log
@Added code to handle Java exceptions raised during the execution of JNI
   functions.
@
text
@d12 16
d78 5
d98 2
a99 6
   void displayData        (const char * fileName);
   void evalObjectives     ();
   void generatePriorities ();
   void heurImplode        ();
   void postprocess        ();
   void readData           (const char * fileName);
d151 8
d199 5
@


1.47
log
@Added code to handle a memory overflow in the C++ side of WIT-J.
@
text
@a68 1
      // Bool return type.
d70 2
@


1.46
log
@Implemented EXCEPTION_ASSERT and ABORTING_ASSERT.
@
text
@d133 6
@


1.45
log
@Removed an unneeded test case.
@
text
@d117 1
a117 1
      WITJ_ASSERT (myCTVecRes_ != NULL);
@


1.44
log
@theProblem.performAction (theCommand)
@
text
@d66 1
a66 1
   bool throwUnexpExceptionBool ();
@


1.43
log
@Added test of C++ assertion failure.
@
text
@d62 1
a62 1
   void throwUnexpException ();
d64 1
a64 2
      // Throws an exception of a type not expected by WIT-J.
      // Used for testing.
a71 5
   void incurAssertFailure ();
      //
      // Incurs an assertion failure.
      // Used for testing.

@


1.42
log
@Updated some comments.
@
text
@d65 1
d71 6
@


1.41
log
@Initial implementation of class ExceptionHandler.
@
text
@d135 1
a135 1
      // Not defined; prevents accidental copying and assignment.
@


1.40
log
@Implemented the C++ canonical try block macros.
@
text
@d20 2
a21 2
//    JavaAccObj
//       Problem
@


1.39
log
@Changed to all upper case for the names of macros.
@
text
@d62 9
@


1.38
log
@Removed C++ class Session.
@
text
@d107 1
a107 1
      witjAssert (myCTVecRes_ != NULL);
@


1.37
log
@Removed Java class SessionCOR.
@
text
@d34 5
a38 1
   explicit Problem (Session * theSession, JavaObjRep * theProblemJOR);
a47 4
   virtual bool isProblem ();
      //
      // Override from class JavaAccObj.

d90 5
d132 4
d138 1
a138 1
      // The JavaObjRep for this Element.
@


1.36
log
@Removed class Session from the public interface.
@
text
@d44 4
@


1.35
log
@Added theProblem.postprocess ().
@
text
@d44 4
d138 6
@


1.34
log
@Name change.
@
text
@d62 1
@


1.33
log
@Changed name of Component to Entity.
@
text
@d44 1
a44 1
   void store (GlobalEntity * theGlobalEntity);
d46 1
a46 1
      // Stores theGlobalEntity as myGlobalEntity_.
d65 1
a65 1
   // Find{Entity Class} functions.
d68 2
a69 2
   // Entity class identified by the arguments.
   // If the Entity does not exist, WIT will issue a severe error.
d86 1
a86 1
   inline GlobalEntity * getGlobalEntity ()
d88 1
a88 1
      return myGlobalEntity_;
d120 1
a120 1
      // The JavaObjRep for this Entity.
d122 1
a122 1
   GlobalEntity * myGlobalEntity_;
d124 1
a124 1
      // The GlobalEntity for this Problem.
@


1.32
log
@Revised class StringWoa.
@
text
@d44 1
a44 1
   void store (GlobalComp * theGlobalComp);
d46 1
a46 1
      // Stores theGlobalComp as myGlobalComp_.
d65 1
a65 1
   // Find{Component Class} functions.
d68 2
a69 2
   // Component class identified by the arguments.
   // If the Component does not exist, WIT will issue a severe error.
d86 1
a86 1
   inline GlobalComp * getGlobalComp ()
d88 1
a88 1
      return myGlobalComp_;
d120 1
a120 1
      // The JavaObjRep for this Component.
d122 1
a122 1
   GlobalComp * myGlobalComp_;
d124 1
a124 1
      // The GlobalComp for this Problem.
@


1.31
log
@Implemented extraction of BOM entries.
@
text
@d72 4
a75 4
   Part *      findPart      (const StringWoa & thePartNameWoa);
   Operation * findOperation (const StringWoa & theOpnNameWoa);
   BomEntry *  findBomEntry  (const StringWoa & theOpnNameWoa,
                              int               theBomIndex);
@


1.30
log
@Call-back infrastructure.
Implemented extraction of Demands.
@
text
@d68 1
a68 1
   // Component class for this Problem.
d72 4
a75 1
   Part * findPart (const char * thePartName);
@


1.29
log
@Call-back infrastructure.
@
text
@d55 20
a100 10
   // Wrappers for WIT API Functions.
   //---------------------------------------------------------------------------

   void displayData        (const char * fileName);
   void evalObjectives     ();
   void generatePriorities ();
   void heurImplode        ();
   void readData           (const char * fileName);

   //---------------------------------------------------------------------------
@


1.28
log
@Changed name of C++ class JAccObject to JavaAccObj.
@
text
@d34 1
a34 3
   explicit Problem (Session *);
      //
      // Constructor.
d58 5
d105 4
@


1.27
log
@Intitial implementation of extraction of nPeriods.
@
text
@d10 1
a10 1
#include <JAccObject.h>
d20 1
a20 1
//    JAccObject
d26 1
a26 1
class Problem: public JAccObject
d44 1
a44 1
      // Override from class JAccObject.
@


1.26
log
@Continued implementation of readData.
@
text
@d72 5
a92 2
   void changedNPeriodsError ();

@


1.25
log
@Began implementation of Problem.readData (...).
@
text
@a61 2
      witjAssert (myGlobalComp_ != NULL);

@


1.24
log
@Wrapped witGeneratePriorities.
@
text
@d82 1
d90 2
d107 5
a111 1
      // The CTVecRes owned by this Problem, if any; otherwise NULL.
@


1.23
log
@Wrapped witEvalObjectives.
@
text
@d78 4
a81 3
   void displayData    (const char * fileName);
   void evalObjectives ();
   void heurImplode    ();
@


1.22
log
@Implemented theMsgHandler.flushFile ().
@
text
@d78 3
a80 2
   void displayData (const char * fileName);
   void heurImplode ();
@


1.21
log
@Initial implementation of MsgHandler classes.
@
text
@a55 4
   void flushMsgFile ();
      //
      // Flushes WIT's message file.

@


1.20
log
@Minor change.
@
text
@d15 2
a16 3
// The governing class of WIT-J's C++ code.
// Represents an implosion problem.
// Corresponds to an initialized WitRun.
@


1.19
log
@Revised the use of class CTVecRes.
@
text
@d52 1
a52 1
   void lockNPeriods ();
@


1.18
log
@Moves C++ GlobalComp from Session to Problem.
@
text
@d52 5
d72 7
d104 4
@


1.17
log
@Initial implementation of creating a Session without a Problem.
@
text
@d47 5
d57 11
d84 8
@


1.16
log
@Minor update.
@
text
@a12 6
// Forward declaration.
//------------------------------------------------------------------------------

class WitRun;

//------------------------------------------------------------------------------
@


1.15
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@a69 4
   inline WitRun * getWitRun ();
      //
      // Pass thru to getSession ().

@


1.14
log
@Attributes.
@
text
@d41 1
a41 1
   explicit Problem (ProbCoord *);
d72 1
a72 1
      // Pass thru to getProbCoord ().
@


1.13
log
@Changed the names of access functions beginning with "my"
to begin with "get".
@
text
@d49 1
a49 1
   virtual Problem * thisProblem ();
@


1.12
log
@Implemented Problem.heurImplode.
@
text
@d70 1
a70 1
   inline WitRun * myWitRun ();
d72 1
a72 1
      // Pass thru to myProbCoord ().
@


1.11
log
@Attributes.
@
text
@d62 1
@


1.10
log
@*** empty log message ***
@
text
@d7 2
a8 2
#ifndef ProblemH
#define ProblemH
@


1.9
log
@*** empty log message ***
@
text
@d53 4
@


1.8
log
@*** empty log message ***
@
text
@d67 1
a67 1
      // Pass thru to myProbCoord_.
a72 8

   //---------------------------------------------------------------------------
   // Private member data.
   //---------------------------------------------------------------------------

   ProbCoord * const myProbCoord_;
      //
      // The ProbCoord for this Problem.
@


1.7
log
@*** empty log message ***
@
text
@a48 4
   virtual void getDerivedInstance (Problem * &);
      //
      // Override from class JAccObject.

@


1.6
log
@*** empty log message ***
@
text
@d53 4
@


1.5
log
@*** empty log message ***
@
text
@d41 1
a41 1
   Problem (ProbCoord *);
@


1.4
log
@*** empty log message ***
@
text
@d57 1
a57 1
   void displayData (const StringJia & fileNameJia);
@


1.3
log
@*** empty log message ***
@
text
@d41 1
a41 1
   Problem ();
a52 5
   void store (ProbCoord * theProbCoord);
      //
      // Stores theProbCoord as myProbCoord_;
      // Must be called exactly once.

d78 1
a78 1
   ProbCoord * myProbCoord_;
@


1.2
log
@*** empty log message ***
@
text
@d53 5
a64 9
   // Accessors.
   //---------------------------------------------------------------------------

   inline WitRun * myWitRun ()
      {
      return myWitRun_;
      }

   //---------------------------------------------------------------------------
d70 4
d83 1
a83 1
   WitRun * myWitRun_;
d85 1
a85 1
      // The WitRun owned by this Problem.
@


1.1
log
@*** empty log message ***
@
text
@a52 4
   void recNewPartOpn ();
      //
      // Records the fact that a new Part or Operation is being created.

a67 12
   inline GlobalComp * myGlobalComp ()
      {
      return myGlobalComp_;
      }

   inline DblTVecJiaRepos * myDblTVecJiaRepos ()
      {
      assert (myDblTVecJiaRepos_ != NULL);

      return myDblTVecJiaRepos_;
      }

a85 8

   GlobalComp * myGlobalComp_;
      //
      // The GlobalComp for this Problem.

   DblTVecJiaRepos * myDblTVecJiaRepos_;
      //
      // The DblTVecJiaRepos owned by this Problem.
@


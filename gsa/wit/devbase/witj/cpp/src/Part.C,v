head	1.70;
access;
symbols;
locks; strict;
comment	@ * @;


1.70
date	2011.04.13.16.00.17;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.04.08.20.56.19;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.04.06.23.29.23;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.29.23.38.48;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.20.20.55.07;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.19.20.48.01;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2010.04.17.00.20.19;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.15.23.33.27;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.15.22.14.55;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.04.15.21.11.57;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.14.16.17.18;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.04.13.19.51.40;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.04.09.19.26.41;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2009.04.09.16.28.31;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.13.19.32.19;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.05.19.09.17;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.05.17.21.26;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.28.00.27.54;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.27.23.12.29;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.27.21.22.39;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.27.18.44.24;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.26.22.46.58;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.24.17.44.57;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.14.00.51.29;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.03.23.18.07;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.03.19.01.03;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.03.16.32.27;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.31.00.56.26;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.29.22.06.38;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.23.19.32.23;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.21.21.43.23;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.16.19.08.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.16.17.03.34;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.16.16.32.02;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.15.17.28.48;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.26.18.33.05;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.14.22.17.46;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.07.18.50.24;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.06.22.14.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.06.14.52.39;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.03.19.06.59;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.02.17.34.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.01.22.33.04;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.01.22.10.11;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.29.22.43.46;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.19.15.11.10;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.12.15.22.02;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.12.14.43.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.09.18.59.59;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.04.21.24.30;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.02.14.37.21;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.29.15.34.42;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.29.15.07.56;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.29.14.21.58;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.28.18.50.40;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.27.15.30.45;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.01.17.49.16;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.01.16.09.22;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.10.23.21.36;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.10.22.32.35;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.30.15.52.20;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.28.22.29.36;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.28.20.24.47;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.28.18.10.12;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.27.14.57.44;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.21.14.33.48;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.20.20.37.02;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.19.22.20.55;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.15.19.45.17;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.20.54.11;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.70
log
@ArrayJOR classes
@
text
@//------------------------------------------------------------------------------
// WIT-J C++ Source File Part.C.
//
// Contains the implementation of class Part.
//------------------------------------------------------------------------------

#include        <Part.h>
#include <Coordinator.h>
#include    <ArrayJOR.h>

//------------------------------------------------------------------------------

WitJ::Part::Part (
         Coordinator * theCoord,
         const char *  thePartNameCStr,
         bool          isMaterial):

      Component   (theCoord),
      myPartName_ (thePartNameCStr)
   {
   witAttr theCategoryAttr;

   if (! extractInProgress ())
      {
      theCategoryAttr =
         isMaterial?
            WitMATERIAL:
            WitCAPACITY;

      witAddPart (getWitRun (), getPartName (), theCategoryAttr);
      }

   witSetPartAppData (getWitRun (), getPartName (), this);

   theCoord->recordCreatePartOpn ();
   }

//------------------------------------------------------------------------------

WitJ::Part::~Part ()
   {
   getCoordinator ()->recordDeletePartOpn ();
   }

//------------------------------------------------------------------------------

WitJ::Part * WitJ::Part::asPart ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitJ::Part::getBelowList (CompALJOR <Part> & theBelowALJOR)
   {
   int      lenList;
   char * * partNameList;

   witGetPartBelowList (
      getWitRun (),
      getPartName (),
    & lenList,
    & partNameList);

   getCoordinator ()->populate (theBelowALJOR, partNameList, lenList);

   freeWitStrVec (partNameList, lenList);
   }

//------------------------------------------------------------------------------

void WitJ::Part::setBoundSet (
      const double * hardLBCVec,
      const double * softLBCVec,
      const double * hardUBCVec)
   {
   witSetPartStockBoundsDbl (
      getWitRun   (),
      getPartName (),
      hardLBCVec,
      softLBCVec,
      hardUBCVec);
   }

//------------------------------------------------------------------------------

void WitJ::Part::getBoundSet (
      DblArrayJOR & hardLBAJOR,
      DblArrayJOR & softLBAJOR,
      DblArrayJOR & hardUBAJOR)
   {
   double * hardLBCVec;
   double * softLBCVec;
   double * hardUBCVec;

   witGetPartStockBoundsDbl (
      getWitRun   (),
      getPartName (),
    & hardLBCVec,
    & softLBCVec,
    & hardUBCVec);

   hardLBAJOR.copyFrom (hardLBCVec);
   softLBAJOR.copyFrom (softLBCVec);
   hardUBAJOR.copyFrom (hardUBCVec);

   witFree (hardLBCVec);
   witFree (softLBCVec);
   witFree (hardUBCVec);
   }

//------------------------------------------------------------------------------

void WitJ::Part::copyComponentData (Component * origComp)
   {
   Part * origPart;

   origPart = origComp->asPart ();

   witCopyPartData (
                getWitRun   (),
                getPartName (),
      origPart->getWitRun   (),
      origPart->getPartName ());
   }

//------------------------------------------------------------------------------

void WitJ::Part::setPartName (const char * thePartNameCStr)
   {
   witSetPartPartName (
      getWitRun (),
      getPartName (),
      thePartNameCStr);

   myPartName_ = thePartNameCStr;
   }

//------------------------------------------------------------------------------

const char * WitJ::Part::getPartName ()
   {
   return myPartName_.c_str ();
   }
@


1.69
log
@copyComponentData
@
text
@d9 1
a9 1
#include <WitVecOwner.h>
d88 7
a94 7
      WitVecOwner <double> & hardLBWVO,
      WitVecOwner <double> & softLBWVO,
      WitVecOwner <double> & hardUBWVO)
   {
   double * hardLBWitVec;
   double * softLBWitVec;
   double * hardUBWitVec;
d99 11
a109 7
    & hardLBWitVec,
    & softLBWitVec,
    & hardUBWitVec);

   hardLBWVO.acquireWitVec (hardLBWitVec);
   softLBWVO.acquireWitVec (softLBWitVec);
   hardUBWVO.acquireWitVec (hardUBWitVec);
@


1.68
log
@getBelowList
@
text
@d110 15
@


1.67
log
@Replaced C++ class CORJOR with ComponentJOR.
@
text
@d54 18
@


1.66
log
@Multi-Obj Mode
@
text
@d16 1
a16 1
         bool          theCategoryIsMaterial):
d26 1
a26 1
         theCategoryIsMaterial?
@


1.65
log
@Multi-Obj Mode
@
text
@d9 1
a9 1
#include      <VecWoa.h>
d70 3
a72 3
      VecWoa <double> & hardLBWoa,
      VecWoa <double> & softLBWoa,
      VecWoa <double> & hardUBWoa)
d85 3
a87 3
   hardLBWoa.acquireWitVec (hardLBWitVec);
   softLBWoa.acquireWitVec (softLBWitVec);
   hardUBWoa.acquireWitVec (hardUBWitVec);
@


1.64
log
@Multi-Obj Mode
@
text
@d74 3
a76 3
   double * hardLBCVec;
   double * softLBCVec;
   double * hardUBCVec;
d81 7
a87 7
    & hardLBCVec,
    & softLBCVec,
    & hardUBCVec);

   hardLBWoa.acquire (hardLBCVec);
   softLBWoa.acquire (softLBCVec);
   hardUBWoa.acquire (hardUBCVec);
@


1.63
log
@Moved findInstsnce functions into class Component.
@
text
@d74 4
d79 9
a87 5
      getWitRun             (),
      getPartName           (),
      hardLBWoa.getCVecAddr (),
      softLBWoa.getCVecAddr (),
      hardUBWoa.getCVecAddr ());
@


1.62
log
@Moved restoreInstance functions from the Component classes to class
   Coordinator.
@
text
@d9 1
a9 2
#include   <StringWoa.h>
#include  <JavaObjRep.h>
a95 13
WitJ::Part * WitJ::Part::findInstance (
      Coordinator * theCoord,
      const char *  thePartName)
   {
   void * theAppData;

   witGetPartAppData (theCoord->getWitRun (), thePartName, & theAppData);

   return static_cast <Part *> (theAppData);
   }

//------------------------------------------------------------------------------

@


1.61
log
@Moved Component extraction functions to class Coordinator.
Removed debugging output code from createMyCppCoordinator implementation.
@
text
@a96 16
void WitJ::Part::restoreInstance (Coordinator * theCoord)
   {
   StringWoa thePartNameWoa;
   Part *    thePart;

   witGetObjItrPart (
      theCoord     ->getWitRun   (),
      thePartNameWoa.getCStrAddr ());

   thePart = findInstance (theCoord, thePartNameWoa.getCString ());

   thePart->setWasDeletedInWit (false);
   }

//------------------------------------------------------------------------------

@


1.60
log
@Detection of non-UTF-8.
@
text
@a96 27
void WitJ::Part::extractInstance (Coordinator * theCoord)
   {
   StringWoa thePartNameWoa;
   witAttr   theCategoryAttr;
   bool      theCategoryIsMaterial;

   witGetObjItrPart (
      theCoord     ->getWitRun   (),
      thePartNameWoa.getCStrAddr ());

   theCoord->verifyUTF8 (thePartNameWoa.getCString ());

   witGetPartCategory (
      theCoord     ->getWitRun  (),
      thePartNameWoa.getCString (),
    & theCategoryAttr);

   theCategoryIsMaterial = (theCategoryAttr == WitMATERIAL);

   JavaObjRep::makePart (
      theCoord,
      thePartNameWoa.getCString (),
      theCategoryIsMaterial);
   }

//------------------------------------------------------------------------------

@


1.59
log
@Detection of  non-UFT-8 strings.
@
text
@d107 2
@


1.58
log
@Fixed bug: The C++ Coordinator new deletes the CTVecSupply when it needs to.
@
text
@d131 1
a131 1
   thePart = Part::findInstance (theCoord, thePartNameWoa.getCString ());
@


1.57
log
@Fixed the memory leak in theCoord->freezeNPeriods ().
@
text
@d36 1
a36 1
   theCoord->recordPartOpn ();
d43 1
@


1.56
log
@Changed name of Element classes in Java and C++ to Component.
@
text
@d36 1
a36 1
   theCoord->freezeNPeriods ();
@


1.55
log
@purgeData
@
text
@d19 1
a19 1
      Element     (theCoord),
@


1.54
log
@purgeData
@
text
@d121 1
a121 1
void WitJ::Part::preserveInstance (Coordinator * theCoord)
@


1.53
log
@purgeData
@
text
@d132 1
a132 1
   thePart->setToBeShutDown (false);
@


1.52
log
@purgeData
@
text
@d9 1
a9 1
#include      <VecWoa.h>
d103 2
a104 2
      theCoord->getWitRun (),
      thePartNameWoa.getCVecAddr ());
d107 2
a108 2
      theCoord->getWitRun (),
      thePartNameWoa.getCVec (),
d115 1
a115 1
      thePartNameWoa.getCVec (),
d128 1
a128 1
      thePartNameWoa.getCVecAddr ());
d130 1
a130 1
   thePart = Part::findInstance (theCoord, thePartNameWoa.getCVec ());
@


1.51
log
@purgeData
@
text
@d130 1
a130 1
   thePart = theCoord->findPart (thePartNameWoa.getCVec ());
d137 13
@


1.50
log
@purgeData
@
text
@d121 16
@


1.49
log
@Removed C++ class Extractor.
@
text
@d10 1
d96 25
@


1.48
log
@Part.Category by boolean.
@
text
@d23 1
a23 1
   if (! getExtractMode ())
@


1.47
log
@Implemented getPipSeq.
@
text
@d16 1
a16 1
         const char *  thePartCatNameCStr):
d21 1
a21 1
   witAttr thePartCatAttr;
d25 4
a28 4
      thePartCatAttr =
         equal (thePartCatNameCStr, "MATERIAL")? WitMATERIAL:
         equal (thePartCatNameCStr, "CAPACITY")? WitCAPACITY:
                                                 NULL;
d30 1
a30 3
      EXCEPTION_ASSERT (thePartCatAttr != NULL);

      witAddPart (getWitRun (), getPartName (), thePartCatAttr);
a94 21
const char * WitJ::Part::getCategory ()
   {
   witAttr thePartCatAttr;

   witGetPartCategory (getWitRun (), getPartName (), & thePartCatAttr);

   return findCategoryName (thePartCatAttr);
   }

//------------------------------------------------------------------------------

const char * WitJ::Part::findCategoryName (witAttr thePartCatAttr)
   {
   return 
      (thePartCatAttr == WitMATERIAL)? "MATERIAL":
      (thePartCatAttr == WitCAPACITY)? "CAPACITY":
                                        "INVALID";
   }

//------------------------------------------------------------------------------

@


1.46
log
@Part Category
@
text
@d76 5
a80 5
      getWitRun   (),
      getPartName (),
    & hardLBWoa,
    & softLBWoa,
    & hardUBWoa);
@


1.45
log
@Message Group by group name.
@
text
@a12 8
witAttr WitJ::Part::allPartCatAttrs_[] =
   {
   WitMATERIAL,
   WitCAPACITY,
   };

//------------------------------------------------------------------------------

d16 1
a16 1
         int           thePartCatIdx):
d25 6
a30 1
      thePartCatAttr = allPartCatAttrs_[thePartCatIdx];
d97 1
a97 1
int WitJ::Part::getCategoryIndex ()
d103 1
a103 1
   return findCategoryIndex (thePartCatAttr);
d108 1
a108 1
int WitJ::Part::findCategoryIndex (witAttr thePartCatAttr)
d110 4
a113 11
   int thePartCatIdx;

   for (thePartCatIdx = 0; thePartCatIdx < 2; thePartCatIdx ++)
      {
      if (allPartCatAttrs_[thePartCatIdx] == thePartCatAttr)
         return thePartCatIdx;
      }

   EXCEPTION_ASSERT (false);

   return -1;
@


1.44
log
@Removed the Alternative classes.
@
text
@d16 1
a16 1
   WitCAPACITY
@


1.43
log
@Part.Category as Alternative
@
text
@a8 1
#include <Alternative.h>
d11 7
a17 1
#include         <wit.h>
d24 1
a24 1
         Alternative * thePartCatAlt):
d29 1
a29 1
   witAttr theCategory;
d33 1
a33 1
      theCategory = thePartCatAlt->getPartCategory ();
d35 1
a35 1
      witAddPart (getWitRun (), getPartName (), theCategory);
d100 1
a100 1
WitJ::Alternative * WitJ::Part::getCategory ()
d102 18
a119 1
   witAttr theAttr;
d121 1
a121 1
   witGetPartCategory (getWitRun (), getPartName (), & theAttr);
d123 1
a123 1
   return Alternative::findInstanceForPartCategory (theAttr);
@


1.42
log
@Implemented Java class CppGateway.
@
text
@d9 1
d19 1
a19 1
         bool          theCategoryIsMat):
d28 1
a28 4
      theCategory =
         theCategoryIsMat?
            WitMATERIAL:
            WitCAPACITY;
d95 1
a95 1
bool WitJ::Part::getCategoryIsMat ()
d97 1
a97 1
   witAttr theCategory;
d99 1
a99 4
   witGetPartCategory (
      getWitRun (),
      getPartName (),
    & theCategory);
d101 1
a101 1
   return (theCategory == WitMATERIAL);
@


1.41
log
@Coordinator
@
text
@d18 1
a18 2
         bool          theCategoryIsMat,
         JavaObjRep *  thePartJOR):
d20 1
a20 1
      Element     (theCoord, thePartJOR),
@


1.40
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@d16 1
a16 1
         Coordinator * theCoordinator,
d21 1
a21 1
      Element     (theCoordinator, thePartJOR),
d38 1
a38 1
   theCoordinator->freezeNPeriods ();
@


1.39
log
@ProbMgr classes.
@
text
@d7 3
a9 3
#include    <Part.h>
#include <ProbMgr.h>
#include  <VecWoa.h>
d11 1
a11 1
#include     <wit.h>
d16 4
a19 4
         ProbMgr *    theProbMgr,
         const char * thePartNameCStr,
         bool         theCategoryIsMat,
         JavaObjRep * thePartJOR):
d21 1
a21 1
      Element     (theProbMgr, thePartJOR),
d38 1
a38 1
   theProbMgr->freezeNPeriods ();
@


1.38
log
@Change the mname of the ProbCtr classes to ProbMgr in both Java and C++.
@
text
@a7 1
#include <Problem.h>
d38 1
a38 1
   theProbMgr->getProblem ()->freezeNPeriods ();
@


1.37
log
@Continued implementation of the ProbCtr classes.
@
text
@d9 1
a9 1
#include <ProbCtr.h>
d17 1
a17 1
         ProbCtr *    theProbCtr,
d22 1
a22 1
      Element     (theProbCtr, thePartJOR),
d39 1
a39 1
   theProbCtr->getProblem ()->freezeNPeriods ();
@


1.36
log
@Updated some comments.
@
text
@d9 1
d17 1
a17 1
         Problem *    theProblem,
d22 1
a22 1
      Element     (theProblem, thePartJOR),
d39 1
a39 1
   theProblem->freezeNPeriods ();
@


1.35
log
@Removed C++ class Session.
@
text
@d4 1
a4 1
// Contains the definition of class Part.
@


1.34
log
@Minot revision.
@
text
@d21 1
a21 1
      Element     (theProblem->getSession (), thePartJOR),
@


1.33
log
@Name change.
@
text
@d18 1
a18 1
         bool         theMaterialCase,
d29 1
a29 1
         theMaterialCase?
d98 1
a98 1
bool WitJ::Part::getMaterialCase ()
@


1.32
log
@Changed name of Component to Entity.
@
text
@d21 1
a21 1
      Entity      (theProblem->getSession (), thePartJOR),
@


1.31
log
@Minor revision
@
text
@d21 1
a21 1
      Component   (theProblem->getSession (), thePartJOR),
@


1.30
log
@Revised C++ class template VecWoa.
@
text
@d18 1
a18 1
         bool         theMaterialMode,
d29 1
a29 1
         theMaterialMode?
d98 1
a98 1
bool WitJ::Part::getMaterialMode ()
@


1.29
log
@Call-back infrastructure.
Implemented extraction of Demands.
@
text
@d77 5
a81 5
      getWitRun             (),
      getPartName           (),
      hardLBWoa.getCVecAddr (),
      softLBWoa.getCVecAddr (),
      hardUBWoa.getCVecAddr ());
@


1.28
log
@Minor revision.
@
text
@d36 2
@


1.27
log
@Extraction.
@
text
@d18 1
a18 1
         bool         toBeAMaterial,
d29 1
a29 1
         toBeAMaterial?
d96 1
a96 1
bool WitJ::Part::isAMaterial ()
@


1.26
log
@Call-back infrastructure.
@
text
@d26 6
a31 4
   theCategory =
      toBeAMaterial?
         WitMATERIAL:
         WitCAPACITY;
d33 2
a34 4
   witAddPart (
      getWitRun (),
      getPartName (),
      theCategory);
@


1.25
log
@Minor revision.
@
text
@d18 2
a19 1
         bool         toBeAMaterial):
d21 1
a21 1
      Component   (theProblem->getSession ()),
@


1.24
log
@Minor change.
@
text
@d18 1
a18 1
         bool         isMaterialBool):
d26 1
a26 1
      isMaterialBool?
d95 1
a95 1
bool WitJ::Part::isMaterial ()
@


1.23
log
@Revised the use of class CTVecRes.
@
text
@d35 1
a35 1
   theProblem->lockNPeriods ();
@


1.22
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@d8 1
a8 1
#include <Session.h>
d16 1
a16 1
         Session *    theSession,
d20 1
a20 1
      Component   (theSession),
d35 1
a35 1
   theSession->lockNPeriods ();
@


1.21
log
@Added attribute "stockBounds".
@
text
@d7 3
a9 3
#include      <Part.h>
#include <ProbCoord.h>
#include    <VecWoa.h>
d11 1
a11 1
#include       <wit.h>
d16 1
a16 1
         ProbCoord *  theProbCoord,
d20 1
a20 1
      Component   (theProbCoord),
d35 1
a35 1
   theProbCoord->lockNPeriods ();
@


1.20
log
@"partCategory" attribute.
@
text
@d9 1
d53 30
@


1.19
log
@Attributes.
@
text
@d17 1
a17 1
         bool         isaMaterial):
d25 1
a25 1
      isaMaterial?
d64 14
@


1.18
log
@"partName" attribute.
@
text
@d31 1
a31 1
      getPartCName (),
d56 1
a56 1
      getPartCName (),
d64 1
a64 1
const char * WitJ::Part::getPartCName ()
@


1.17
log
@"partName" attribute.
@
text
@d16 1
a16 1
         const char * partNameCStr,
d20 1
a20 1
      myPartName_ (partNameCStr)
d22 1
a22 1
   witAttr partCategory;
d24 1
a24 1
   partCategory =
d32 1
a32 1
      partCategory);
d52 1
a52 1
void WitJ::Part::setPartName (const char * theCStr)
d57 1
a57 1
      theCStr);
d59 1
a59 1
   myPartName_ = theCStr;
@


1.16
log
@Removed some debugging output.
@
text
@d52 12
@


1.15
log
@Attributes.
@
text
@a11 2
#include  <iostream>

a40 6
   std::cout
      << std::endl
      << "Destroying Part \""
      << getPartCName ()
      << "\"."
      << std::endl;
@


1.14
log
@Accessor names.
@
text
@d53 1
a53 1
WitJ::Part * WitJ::Part::thisPart ()
@


1.13
log
@Changed the names of access functions beginning with "my"
to begin with "get".
@
text
@d21 2
a22 2
      Component (theProbCoord),
      partName_ (partNameCStr)
d33 1
a33 1
      partCName (),
d46 1
a46 1
      << partCName ()
d60 1
a60 1
const char * WitJ::Part::partCName ()
d62 1
a62 1
   return partName_.c_str ();
@


1.12
log
@Strings.
@
text
@d32 1
a32 1
      myWitRun (),
@


1.11
log
@Replaced class WitJ::String with class std::string.
@
text
@d33 1
a33 1
      partName_.c_str (),
d46 1
a46 1
      << partName_
d57 7
@


1.10
log
@JniHandler
@
text
@d17 3
a19 3
      ProbCoord *  theProbCoord,
      const char * partNameCStr,
      bool         isaMaterial):
d33 1
a33 1
      partName_,
@


1.9
log
@Added myName_ to class Att.
@
text
@a25 2
   myProbCoord ()->recNewPartOpn ();

d35 2
@


1.8
log
@Attributes
@
text
@d45 1
a45 1
      << "Destroying WitJ::Part \""
@


1.7
log
@Initial implementation of attributes.
@
text
@a8 1
#include    <VecWoa.h>
a56 10

//------------------------------------------------------------------------------

void WitJ::Part::getSupplyVol (DblVecWoa & supplyVolWoa)
   {
   witGetPartSupplyVolDbl (
      myWitRun (),
      partName_,
      supplyVolWoa.myDblCVecAddr ());
   }
@


1.6
log
@*** empty log message ***
@
text
@a60 10
void WitJ::Part::setSupplyVol (const double * supplyVolCVec)
   {
   witSetPartSupplyVolDbl (
      myWitRun (),
      partName_,
      supplyVolCVec);
   }

//------------------------------------------------------------------------------

@


1.5
log
@*** empty log message ***
@
text
@d9 1
d58 20
@


1.4
log
@*** empty log message ***
@
text
@a52 7
void WitJ::Part::getDerivedInstance (Part * & thePart)
   {
   thePart = this;
   }

//------------------------------------------------------------------------------

@


1.3
log
@*** empty log message ***
@
text
@d18 1
a18 1
      const char * partNameVal,
d22 1
a22 1
      partName_ (partNameVal)
@


1.2
log
@*** empty log message ***
@
text
@d57 7
@


1.1
log
@*** empty log message ***
@
text
@d8 1
a8 2
#include     <CIJia.h>
#include <StringJia.h>
d17 3
a19 3
         const CIJia <Problem> & theProblemJia,
         const StringJia &       partNameJia,
         bool                    isaMaterial):
d21 2
a22 2
      Component (theProblemJia.myDerJAccObject ()),
      partName_ (partNameJia  .myCString       ())
d26 1
a26 1
   myProblem ()->recNewPartOpn ();
@


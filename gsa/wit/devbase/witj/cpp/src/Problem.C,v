head	1.127;
access;
symbols;
locks; strict;
comment	@ * @;


1.127
date	2011.04.13.16.00.18;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2011.04.12.00.33.13;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2011.04.08.20.56.20;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2011.04.07.22.11.19;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2011.04.07.21.39.26;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2011.04.07.19.07.39;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2011.04.06.21.56.48;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.06.20.34.27;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.05.22.25.45;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.30.23.23.02;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.29.23.38.48;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2011.03.28.15.57.08;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.25.22.49.16;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2011.03.24.15.26.27;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2011.03.23.20.30.06;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2011.03.23.14.58.56;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2011.03.22.20.17.23;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2011.03.19.00.26.12;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2011.03.15.23.02.51;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2011.03.15.20.56.47;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2011.03.12.00.29.52;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2011.03.11.23.49.23;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.02.25.16.06.52;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.02.16.21.38.24;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.02.16.21.03.10;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.02.16.19.08.31;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.02.15.19.38.01;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.02.14.19.59.09;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.20.20.55.07;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.19.20.48.02;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.17.00.20.19;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2009.07.07.22.14.36;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2009.07.07.18.48.20;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.29.15.18.10;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.10.14.38.44;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.08.23.34.57;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.08.22.13.11;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.04.24.17.42.51;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2009.04.21.20.56.06;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.17.19.51.58;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2009.04.13.22.19.44;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2009.04.10.16.16.19;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.12.22.45.19;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.26.22.46.58;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.25.23.06.44;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.25.22.13.53;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2009.02.19.19.51.46;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2009.02.18.22.10.22;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2009.02.17.23.46.01;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.17.19.26.13;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.17.17.23.49;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2009.02.14.00.51.29;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.11.18.59.28;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.10.23.19.29;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2009.02.06.22.40.58;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.30.16.24.36;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.29.22.06.38;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.23.20.49.54;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2009.01.23.19.32.23;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2009.01.23.18.46.54;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2009.01.21.21.43.23;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2009.01.20.22.05.03;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.16.21.11.47;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.16.20.55.48;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.01.16.19.42.43;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.16.19.09.00;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.16.18.49.18;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.16.17.03.35;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.15.22.50.31;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.15.20.46.51;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.15.17.03.29;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.14.22.24.34;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.12.17.24.13;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.08.21.13.52;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.05.19.06.01;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.05.17.28.57;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.12.24.22.59.46;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.24.20.34.22;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.24.00.18.55;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.23.15.30.36;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.22.17.12.09;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.22.16.29.12;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.18.22.12.34;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.18.22.00.08;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.16.20.47.28;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.15.22.31.41;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.15.17.28.48;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.12.22.53.06;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.12.19.29.26;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.26.18.33.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.26.14.48.19;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.25.15.28.47;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.31.14.53.29;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.07.18.50.24;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.06.22.14.03;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.03.18.07.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.02.21.45.13;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.02.17.34.35;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.30.15.17.41;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.26.22.50.17;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.24.16.26.36;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.19.21.59.26;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.16.22.21.37;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.16.22.13.58;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.12.19.44.33;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.12.15.22.02;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.12.14.58.07;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.12.14.43.23;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.11.22.22.46;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.11.21.14.41;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.10.21.32.31;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.09.20.04.07;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.09.18.59.59;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.28.18.50.40;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.27.15.30.46;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.01.16.09.22;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.19.19.31.11;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.28.22.29.36;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.22.21.23.00;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.21.22.09.35;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.21.14.33.48;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.19.22.20.55;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.16.18.37.16;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.15.22.11.57;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.15.21.03.30;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.15.19.45.17;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.13.20.54.11;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.127
log
@ArrayJOR classes
@
text
@//------------------------------------------------------------------------------
// WIT-J C++ Source File Problem.C.
//
// Contains the implementation of class Problem.
//------------------------------------------------------------------------------

#include          <Problem.h>
#include      <Coordinator.h>
#include           <Demand.h>
#include        <StringVec.h>
#include <PreJavaException.h>
#include     <ComponentJOR.h>
#include        <StringJOR.h>
#include     <ArrayListJOR.h>

#include         <iostream>
#include           <string.h>

//------------------------------------------------------------------------------

WitJ::Problem::Problem (Coordinator * theCoord):

      Component           (theCoord),
      mySimpleWitFuncMap_ (),
      nPeriods_           (0)
   {
   defineAllSimpleWitFuncs ();

   clearData ();

   theCoord->store (this);
   }

//------------------------------------------------------------------------------

WitJ::Problem::~Problem ()
   {
   }

//------------------------------------------------------------------------------

WitJ::Problem * WitJ::Problem::asProblem ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::copyComponentData (Component *)
   {
   EXCEPTION_ASSERT (false);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::callSimpleWitFunc (const char * theFuncName)
   {
   std::map <std::string, SimpleWitFunc>::iterator theItr;
   SimpleWitFunc                                   theFunc;

   theItr = mySimpleWitFuncMap_.find (theFuncName);

   EXCEPTION_ASSERT (theItr != mySimpleWitFuncMap_.end ());

   theFunc = theItr->second;

   theFunc (getWitRun ());
   }

//------------------------------------------------------------------------------

void WitJ::Problem::writeSched (
      const char * schedName,
      const char * fileName,
      bool         theFormatIsBSV)
   {
   std::string   schedNameStr;
   witFileFormat theFormat;

   WIT_DECLSPEC witReturnCode STDCALL (* theWriteFunc) (
      WitRun * const,
      const char * const,
      const witFileFormat);

   schedNameStr = schedName;

   theWriteFunc =
      (schedNameStr == "Exec")? witWriteExecSched:
      (schedNameStr == "Req" )? witWriteReqSched:
      (schedNameStr == "Ship")? witWriteShipSched:
                                NULL;

   EXCEPTION_ASSERT (theWriteFunc != NULL);

   if (strlen (fileName) == 0)
      fileName = NULL;

   theFormat =
      theFormatIsBSV? WitBSV:
                      WitCSV;

   theWriteFunc (getWitRun (), fileName, theFormat);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::setNPeriods (int theInt)
   {
   nPeriods_ = theInt;

   if (! extractInProgress ())
      witSetNPeriods (getWitRun (), theInt);
   }

//------------------------------------------------------------------------------

int WitJ::Problem::getNPeriods ()
   {
   return nPeriods_;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::clearData ()
   {
   nPeriods_ = 26;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::performAction (const char * theCommand)
   {
   std::string theCmdStr;

   theCmdStr = theCommand;

   if (theCmdStr == "fail-c++-exception-assert")
      {
      callSimpleWitFunc ("No-Function");
      }

   else if (theCmdStr == "fail-c++-aborting-assert")
      {
      ABORTING_ASSERT (false);
      }

   else if (theCmdStr == "exhaust-memory-in-witj-c++")
      {
      exhaustMemory ();
      }

   else if (theCmdStr == "trigger-jni-exception")
      {
      getComponentJOR ()->findNonsense ();
      }

   else if (theCmdStr == "exhaust-memory-in-jni")
      {
      getComponentJOR ()->exhaustJniMemory ();
      }

   else if (theCmdStr == "exhaust-memory-in-wit")
      {
      witExhaustMemory (getWitRun ());
      }

   else if (theCmdStr == "trigger-wit-fatal-message")
      {
      witIssueFatalMesg (getWitRun ());
      }

   else
      {
      EXCEPTION_ASSERT (false);
      }
   }

//------------------------------------------------------------------------------

bool WitJ::Problem::throwUnexpException ()
   {
   throw 7;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::addDblCplexParSpec (const char * theName, double theValue)
   {
   witAddDblCplexParSpecDbl (getWitRun (), theName, theValue);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::addIntCplexParSpec (const char * theName, int theValue)
   {
   witAddIntCplexParSpec (getWitRun (), theName, theValue);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::copyData (Problem * origProblem)
   {
   witCopyData (
                   getWitRun (),
      origProblem->getWitRun ());

   getCoordinator ()->extract (false);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::displayData (const char * fileName)
   {
   if (strlen (fileName) == 0)
      fileName = NULL;

   witDisplayData (getWitRun (), fileName);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::eqHeurAlloc (
      DemandALJOR & theDemandALJOR,
      IntALJOR &    shipPeriodALJOR,
      DblALJOR &    desIncVolALJOR,
      DblALJOR &    incVolALJOR)
   {
   std::vector <const char *> thePartNameVec;
   std::vector <const char *> theDemandNameVec;
   std::vector <int>          shipPeriodVec;
   std::vector <double>       desIncVolVec;
   double *                   incVolVec;

   theDemandALJOR .populateIDVecs (thePartNameVec, theDemandNameVec);
   shipPeriodALJOR.copyInto       (shipPeriodVec);
   desIncVolALJOR .copyInto       (desIncVolVec);

   witEqHeurAllocDbl (
      getWitRun (),
      thePartNameVec.size (),
    & thePartNameVec  [0],
    & theDemandNameVec[0],
    & shipPeriodVec   [0],
    & desIncVolVec    [0],
    & incVolVec);

   incVolALJOR.copyFrom (incVolVec, thePartNameVec.size ());

   witFree (incVolVec);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getCriticalList (
      CompALJOR <Part> & critPartALJOR,
      IntALJOR &         critPeriodALJOR)
   {
   int      lenCritList;
   char * * critPartList;
   int *    critPeriod;

   witGetCriticalList (
      getWitRun (),
    & lenCritList,
    & critPartList,
    & critPeriod);

   getCoordinator ()->populate (critPartALJOR, critPartList, lenCritList);

   critPeriodALJOR.   copyFrom                (critPeriod,   lenCritList);

   freeWitStrVec (critPartList, lenCritList);
   witFree       (critPeriod);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getDblCplexParSpec (
      const char * theName,
      bool &       dblSpecExists,
      double &     dblValue)
   {
   witBoolean theWitBool;

   witGetDblCplexParSpecDbl (
      getWitRun (),
      theName,
    & theWitBool,
    & dblValue);

   dblSpecExists = theWitBool;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getExpCycle (
      CompALJOR <Part> &      thePartALJOR,
      CompALJOR <Operation> & theOpnALJOR)
   {
   int      lenLists;
   char * * partNameList;
   char * * opnNameList;

   witGetExpCycle (getWitRun (), & lenLists, & partNameList, & opnNameList);

   getCoordinator ()->populate (thePartALJOR, partNameList, lenLists);
   getCoordinator ()->populate (theOpnALJOR,  opnNameList,  lenLists);

   freeWitStrVec (partNameList, lenLists);
   freeWitStrVec (opnNameList,  lenLists);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getIntCplexParSpec (
      const char * theName,
      bool &       intSpecExists,
      int &        intValue)
   {
   witBoolean theWitBool;

   witGetIntCplexParSpec (
      getWitRun (),
      theName,
    & theWitBool,
    & intValue);

   intSpecExists = theWitBool;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getObjectiveList (StringALJOR & theObjNameALJOR)
   {
   int      theLength;
   char * * theObjNameCVec;

   witGetObjectiveList (
      getWitRun (),
    & theLength,
    & theObjNameCVec);

   theObjNameALJOR.copyFrom (theObjNameCVec, theLength);

   freeWitStrVec (theObjNameCVec, theLength);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getOptInitMethod (StringJOR & theMethodNameSJOR)
   {
   witAttr      theMethodAttr;
   const char * theMethodNameSJORCStr;

   witGetOptInitMethod (getWitRun (), & theMethodAttr);

   theMethodNameSJORCStr =
      (theMethodAttr ==   WitACC_OPT_INIT_METHOD)? "ACCELERATED":
      (theMethodAttr ==  WitHEUR_OPT_INIT_METHOD)?   "HEURISTIC":
      (theMethodAttr == WitSCHED_OPT_INIT_METHOD)?    "SCHEDULE":
      (theMethodAttr == WitCRASH_OPT_INIT_METHOD)?       "CRASH":
                                                       "INVALID";

   theMethodNameSJOR.makeJavaString (theMethodNameSJORCStr);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getPgdCritList (
      CompALJOR <Part> &   critPartALJOR,
      IntALJOR &           critPeriodALJOR,
      CompALJOR <Demand> & theDemandALJOR,
      IntALJOR &           shipPeriodALJOR)
   {
   int      lenLists;
   char * * critPartNameList;
   int *    critPerList;
   char * * demPartNameList;
   char * * demandNameList;
   int *    shipPerList;

   witGetPgdCritList (
      getWitRun (),
    & lenLists,
    & critPartNameList,
    & critPerList,
    & demPartNameList,
    & demandNameList,
    & shipPerList);

   getCoordinator ()->populate (critPartALJOR,  critPartNameList, lenLists);

   critPeriodALJOR.   copyFrom                 (critPerList,      lenLists);

   getCoordinator ()->populate (theDemandALJOR, demPartNameList,
                                                demandNameList,   lenLists);

   shipPeriodALJOR.   copyFrom                 (shipPerList,      lenLists);

   freeWitStrVec (critPartNameList, lenLists);
   witFree       (critPerList);
   freeWitStrVec (demPartNameList,  lenLists);
   freeWitStrVec (demandNameList,   lenLists);
   witFree       (shipPerList);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getPipSeq (PeggingTripleALJOR & theDemandPTALJOR)
   {
   int      nTriples;
   char * * partNameCVec;
   char * * demandNameCVec;
   int *    thePeriodCVec;
   double * theVolumeCVec;
   int      theIdx;
   Demand * theDemand;

   witGetPipSeqDbl (
      getWitRun (),
    & nTriples,
    & partNameCVec,
    & demandNameCVec,
    & thePeriodCVec,
    & theVolumeCVec);

   theDemandPTALJOR.clearAndAllocate (nTriples);

   for (theIdx = 0; theIdx < nTriples; theIdx ++)
      {
      theDemand =
         getCoordinator ()->
            findDemand (
               partNameCVec  [theIdx],
               demandNameCVec[theIdx]);

      theDemandPTALJOR.
         add (
            theDemand,
            thePeriodCVec[theIdx],
            theVolumeCVec[theIdx]);
      }

   freeWitStrVec (partNameCVec,   nTriples);
   freeWitStrVec (demandNameCVec, nTriples);

   witFree       (thePeriodCVec);
   witFree       (theVolumeCVec);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getSortedOperations (CompALJOR <Operation> & theOpnALJOR)
   {
   int      lenList;
   char * * opnNameList;

   witPreprocess (getWitRun ());

   witGetOperations (getWitRun (), & lenList, & opnNameList);

   getCoordinator ()->populate (theOpnALJOR, opnNameList, lenList);

   freeWitStrVec (opnNameList, lenList);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getSortedParts (CompALJOR <Part> & thePartALJOR)
   {
   int      lenList;
   char * * partNameList;

   witPreprocess (getWitRun ());

   witGetParts (getWitRun (), & lenList, & partNameList);

   getCoordinator ()->populate (thePartALJOR, partNameList, lenList);

   freeWitStrVec (partNameList, lenList);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::readData (const char * fileName)
   {
   try
      {
      witReadData (getWitRun (), fileName);
      }

   catch (WitErrorExc & theWitErrorExc)
      {
      throw PreJavaException ("ReadDataException", "");
      }

   getCoordinator ()->extract (true);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::setObjectiveList (StringALJOR & theObjNameALJOR)
   {
   StringVec theObjNameVec;

   theObjNameALJOR.copyInto (theObjNameVec);

   witSetObjectiveList (
      getWitRun                    (),
      theObjNameVec.getLength      (),
      theObjNameVec.getCStringCVec ());
   }

//------------------------------------------------------------------------------

void WitJ::Problem::setOptInitMethod (const char * theMethodNameCStr)
   {
   std::string theMethodName;
   witAttr     theMethodAttr;

   theMethodName = theMethodNameCStr;

   theMethodAttr =
      (theMethodName == "ACCELERATED")?   WitACC_OPT_INIT_METHOD:
      (theMethodName ==   "HEURISTIC")?  WitHEUR_OPT_INIT_METHOD:
      (theMethodName ==    "SCHEDULE")? WitSCHED_OPT_INIT_METHOD:
      (theMethodName ==       "CRASH")? WitCRASH_OPT_INIT_METHOD:
                                                            NULL;

   EXCEPTION_ASSERT (theMethodAttr != NULL);

   witSetOptInitMethod (getWitRun (), theMethodAttr);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::writeCriticalList (
      const char * fileName,
      bool         theFormatIsBSV,
      int          maxListLen)
   {
   witFileFormat theFormat;

   if (strlen (fileName) == 0)
      fileName = NULL;

   theFormat =
      theFormatIsBSV? WitBSV:
                      WitCSV;

   witWriteCriticalList (getWitRun (), fileName, theFormat, maxListLen);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::writeData (const char * fileName)
   {
   if (strlen (fileName) == 0)
      fileName = NULL;

   witWriteData (getWitRun (), fileName);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::defineAllSimpleWitFuncs ()
   {
   defineSimpleWitFunc ("witBuildPip",           witBuildPip);
   defineSimpleWitFunc ("witClearCplexParSpecs", witClearCplexParSpecs);
   defineSimpleWitFunc ("witClearPegging",       witClearPegging);
   defineSimpleWitFunc ("witClearPipSeq",        witClearPipSeq);
   defineSimpleWitFunc ("witClearStochSoln",     witClearStochSoln);
   defineSimpleWitFunc ("witEvalObjectives",     witEvalObjectives);
   defineSimpleWitFunc ("witFinishExtOpt",       witFinishExtOpt);
   defineSimpleWitFunc ("witFinishHeurAlloc",    witFinishHeurAlloc);
   defineSimpleWitFunc ("witGeneratePriorities", witGeneratePriorities);
   defineSimpleWitFunc ("witHeurImplode",        witHeurImplode);
   defineSimpleWitFunc ("witMrp",                witMrp);
   defineSimpleWitFunc ("witOptImplode",         witOptImplode);
   defineSimpleWitFunc ("witPreprocess",         witPreprocess);
   defineSimpleWitFunc ("witPostprocess",        witPostprocess);
   defineSimpleWitFunc ("witPurgeData",          witPurgeData);
   defineSimpleWitFunc ("witShutDownExtOpt",     witShutDownExtOpt);
   defineSimpleWitFunc ("witShutDownHeurAlloc",  witShutDownHeurAlloc);
   defineSimpleWitFunc ("witStartExtOpt",        witStartExtOpt);
   defineSimpleWitFunc ("witStartHeurAlloc",     witStartHeurAlloc);
   defineSimpleWitFunc ("witStochImplode",       witStochImplode);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::defineSimpleWitFunc (
      const char *  theFuncName,
      SimpleWitFunc theFunc)
   {
   EXCEPTION_ASSERT (mySimpleWitFuncMap_.count (theFuncName) == 0);

   mySimpleWitFuncMap_[theFuncName] = theFunc;
   }

//------------------------------------------------------------------------------

void WitJ::Problem::exhaustMemory ()
   {
   int totDiscarded;

   for (totDiscarded = 100; true; totDiscarded += 100)
      {
      new char[104857600];

      std::cout
         << totDiscarded << "MB of memory have been allocated by WIT-J/C++.\n";

      std::cout.flush ();
      }
   }
@


1.126
log
@Class StringJOR
@
text
@a9 1
#include      <WitVecOwner.h>
@


1.125
log
@copyComponentData
@
text
@d14 1
d351 1
a351 1
const char * WitJ::Problem::getOptInitMethod ()
d353 2
a354 1
   witAttr theMethodAttr;
d358 1
a358 1
   return
d364 2
@


1.124
log
@getSortedOperations
@
text
@d49 7
d201 1
a201 1
void WitJ::Problem::copyData (Problem * srcProblem)
d203 3
a205 7
   WitRun * dstWitRun;
   WitRun * srcWitRun;

   dstWitRun =             getWitRun ();
   srcWitRun = srcProblem->getWitRun ();

   witCopyData (dstWitRun, srcWitRun);
@


1.123
log
@getSortedParts
@
text
@d447 16
@


1.122
log
@getExpCycle
@
text
@d447 16
@


1.121
log
@Critical parts list
@
text
@a274 40
void WitJ::Problem::getPgdCritList (
      CompALJOR <Part> &   critPartALJOR,
      IntALJOR &           critPeriodALJOR,
      CompALJOR <Demand> & theDemandALJOR,
      IntALJOR &           shipPeriodALJOR)
   {
   int      lenLists;
   char * * critPartNameList;
   int *    critPerList;
   char * * demPartNameList;
   char * * demandNameList;
   int *    shipPerList;

   witGetPgdCritList (
      getWitRun (),
    & lenLists,
    & critPartNameList,
    & critPerList,
    & demPartNameList,
    & demandNameList,
    & shipPerList);

   getCoordinator ()->populate (critPartALJOR,  critPartNameList, lenLists);

   critPeriodALJOR.   copyFrom                 (critPerList,      lenLists);

   getCoordinator ()->populate (theDemandALJOR, demPartNameList,
                                                demandNameList,   lenLists);

   shipPeriodALJOR.   copyFrom                 (shipPerList,      lenLists);

   freeWitStrVec (critPartNameList, lenLists);
   witFree       (critPerList);
   freeWitStrVec (demPartNameList,  lenLists);
   freeWitStrVec (demandNameList,   lenLists);
   witFree       (shipPerList);
   }

//------------------------------------------------------------------------------

d293 19
d363 40
@


1.120
log
@getPgdCritList
@
text
@d252 2
a253 2
      CompALJOR <Part> & thePartALJOR,
      IntALJOR &         thePeriodALJOR)
d265 1
a265 1
   getCoordinator ()->populate (thePartALJOR, critPartList, lenCritList);
d267 1
a267 1
   thePeriodALJOR.    copyFrom               (critPeriod,   lenCritList);
@


1.119
log
@Namespace JniUtil.
@
text
@d267 1
a267 1
   thePeriodALJOR.copyFrom (critPeriod, lenCritList);
d275 40
@


1.118
log
@Revised set/get ObjectiveList for ArrayList <String>.
@
text
@d137 1
a137 1
      getComponentJOR ()->newJString (NULL);
@


1.117
log
@Replaced C++ class CORJOR with ComponentJOR.
@
text
@a11 1
#include   <WitStrVecOwner.h>
d311 1
a311 1
void WitJ::Problem::getObjectiveList (WitStrVecOwner & theObjNameWSVO)
d314 1
a314 1
   char * * theObjNameWSV;
d319 1
a319 1
    & theObjNameWSV);
d321 3
a323 1
   theObjNameWSVO.acquireWitStrVec (theObjNameWSV, theLength);
d344 1
a344 1
void WitJ::Problem::getPipSeq (PeggingTripleALJOR & theDemandATALJOR)
d362 1
a362 1
   theDemandATALJOR.clearAndAllocate (nTriples);
d372 1
a372 1
      theDemandATALJOR.
d405 1
a405 1
void WitJ::Problem::setObjectiveList (const StringVec & theObjNameVec)
d407 4
@


1.116
log
@Changed name of class AllocTriple to PeggingTriple.
@
text
@d14 1
a14 1
#include           <CORJOR.h>
d138 1
a138 1
      getCORJOR ()->newJString (NULL);
d148 1
a148 1
      CORJOR::findNonsense (getCoordinator ());
d153 1
a153 1
      getCORJOR ()->exhaustJniMemory ();
@


1.115
log
@ArrayListJOR
@
text
@d343 1
a343 1
void WitJ::Problem::getPipSeq (AllocTripleALJOR & theDemandATALJOR)
@


1.114
log
@"populate" functions.
@
text
@a9 1
#include   <AllocTripleVec.h>
d221 4
a224 4
      CompALJOR <Demand> & theDemandALJOR,
      IntALJOR &           shipPeriodALJOR,
      DblALJOR &           desIncVolALJOR,
      DblALJOR &           incVolALJOR)
d232 3
a234 3
   theDemandALJOR .copyDemandIDsInto (thePartNameVec, theDemandNameVec);
   shipPeriodALJOR.copyInto          (shipPeriodVec);
   desIncVolALJOR .copyInto          (desIncVolVec);
d256 3
a258 4
   int                  lenCritList;
   char * *             critPartList;
   int *                critPeriod;
   std::vector <Part *> thePartVec;
d266 1
a266 1
   getCoordinator ()->populate (thePartVec, critPartList, lenCritList);
a267 1
   thePartALJOR  .copyFrom (thePartVec);
d343 1
a343 1
void WitJ::Problem::getPipSeq (AllocTripleVec * theTripleVec)
d345 7
a351 7
   int       nTriples;
   char * *  partNameWitStrVec;
   char * *  demandNameWitStrVec;
   int *     thePeriodWitVec;
   double *  theVolumeWitVec;
   int       theIdx;
   Demand *  theDemand;
d356 6
a361 8
    & partNameWitStrVec,
    & demandNameWitStrVec,
    & thePeriodWitVec,
    & theVolumeWitVec);

   theTripleVec->resize              (nTriples);
   theTripleVec->acquirePeriodWitVec (thePeriodWitVec);
   theTripleVec->acquireVolumeWitVec (theVolumeWitVec);
d365 1
a365 1
      theDemand  =
d368 2
a369 2
               partNameWitStrVec  [theIdx],
               demandNameWitStrVec[theIdx]);
d371 5
a375 1
      theTripleVec->setComponent (theIdx, theDemand);
d378 2
a379 30
   freeWitStrVec (demandNameWitStrVec, nTriples);
   freeWitStrVec (partNameWitStrVec,   nTriples);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::getPipSeq (AllocTripleALJOR <Demand> & theDemandATALJOR)
   {
   int                    nTriples;
   char * *               partNameCStrVec;
   char * *               demandNameCStrVec;
   int *                  thePeriodCVec;
   double *               theVolumeCVec;
   std::vector <Demand *> theDemandVec;

   witGetPipSeqDbl (
      getWitRun (),
    & nTriples,
    & partNameCStrVec,
    & demandNameCStrVec,
    & thePeriodCVec,
    & theVolumeCVec);

   getCoordinator ()->
      populate (theDemandVec, partNameCStrVec, demandNameCStrVec, nTriples);

   theDemandATALJOR.populateFrom (theDemandVec, thePeriodCVec, theVolumeCVec);

   freeWitStrVec (partNameCStrVec,   nTriples);
   freeWitStrVec (demandNameCStrVec, nTriples);
@


1.113
log
@AllocTripleALJOR
@
text
@d268 1
a268 1
   getCoordinator ()->findParts (thePartVec, critPartList, lenCritList);
d403 1
a403 1
      findDemands (theDemandVec, partNameCStrVec, demandNameCStrVec, nTriples);
@


1.112
log
@ArrayListJOR
@
text
@d268 1
a268 1
   getCoordinator ()->copyInto (thePartVec, critPartList, lenCritList);
d385 31
@


1.111
log
@getCriticialList and eqHeurAlloc.
@
text
@d233 3
a235 5
   ArrayListJOR::copyFrom (  theDemandALJOR,
                             thePartNameVec,
                             theDemandNameVec);
   shipPeriodALJOR.copyInto (shipPeriodVec);
   desIncVolALJOR .copyInto (desIncVolVec);
@


1.110
log
@Revised the arguments to eqHeurAlloc.
@
text
@d222 4
a225 4
      DemandALJOR & theDemandALJOR,
      IntALJOR &    shipPeriodALJOR,
      DblALJOR &    desIncVolALJOR,
      DblALJOR &    incVolALJOR)
d233 2
a234 1
   theDemandALJOR .copyInto (thePartNameVec,
d256 2
a257 2
      PartALJOR & thePartALJOR,
      IntALJOR &  thePeriodALJOR)
d259 4
a262 3
   int      lenCritList;
   char * * critPartList;
   int *    critPeriod;
d270 4
a273 2
   thePartALJOR  .copyFrom (critPartList, lenCritList, getCoordinator ());
   thePeriodALJOR.copyFrom (critPeriod,   lenCritList);
@


1.109
log
@Name changes.
@
text
@d222 4
a225 4
      const std::vector <Demand *> & theDemandVec,
      const std::vector <int> &      shipPerVec,
      const std::vector <double> &   desIncVolVec,
      WitVecOwner <double> &         incVolWVO)
d229 8
a236 17
   int                        nTriples;
   int                        theIdx;
   Demand *                   theDemand;
   double *                   incVolWitVec;

   nTriples = theDemandVec.size ();

   thePartNameVec  .resize (nTriples);
   theDemandNameVec.resize (nTriples);

   for (theIdx = 0; theIdx < nTriples; theIdx ++)
      {
      theDemand                = theDemandVec[theIdx];

      thePartNameVec  [theIdx] = theDemand->getPartName   ();
      theDemandNameVec[theIdx] = theDemand->getDemandName ();
      }
d240 1
a240 1
      nTriples,
d243 1
a243 1
    & shipPerVec      [0],
d245 1
a245 1
    & incVolWitVec);
d247 3
a249 1
   incVolWVO.acquireWitVec (incVolWitVec);
d255 2
a256 2
      CompALJOR <Part> & thePartALJOR,
      IntALJOR &         thePeriodALJOR)
a260 2
   int      theIdx;
   Part *   thePart;
d268 2
a269 10
   thePartALJOR  .ensureCapacity (lenCritList);
   thePeriodALJOR.ensureCapacity (lenCritList);

   for (theIdx = 0; theIdx < lenCritList; theIdx ++)
      {
      thePart = getCoordinator ()->findPart (critPartList[theIdx]);

      thePartALJOR  .add (thePart);
      thePeriodALJOR.add (critPeriod[theIdx]);
      }
d271 1
a272 1
   freeWitStrVec (critPartList, lenCritList);
@


1.108
log
@Renamed JavaObjRep to CORJOR.
@
text
@d16 1
a16 1
#include       <JArrayList.h>
d262 2
a263 2
      CompJArrayList <Part> & thePartJAL,
      IntJArrayList &         thePeriodJAL)
d277 2
a278 2
   thePartJAL  .ensureCapacity (lenCritList);
   thePeriodJAL.ensureCapacity (lenCritList);
d284 2
a285 2
      thePartJAL  .add (thePart);
      thePeriodJAL.add (critPeriod[theIdx]);
@


1.107
log
@Problem.getCriticalList ()
@
text
@a8 1
#include       <JavaObjRep.h>
d15 1
d139 1
a139 1
      getJavaObjRep ()->newJString (NULL);
d149 1
a149 1
      JavaObjRep::findNonsense (getCoordinator ());
d154 1
a154 1
      getJavaObjRep ()->exhaustJniMemory ();
@


1.106
log
@Problem.getCriticalList ()
@
text
@d262 2
a263 2
      CompJArrayList <Part> & thePartsJAL,
      IntJArrayList &         thePeriodsJAL)
d277 2
a278 2
   thePartsJAL  .ensureCapacity (lenCritList);
   thePeriodsJAL.ensureCapacity (lenCritList);
d284 2
a285 2
      thePartsJAL  .add (thePart);
      thePeriodsJAL.add (critPeriod[theIdx]);
@


1.105
log
@Moved GlobalAspect responsibilities to class Problem.
Removed class GlobalAspect.
@
text
@d16 1
d261 33
@


1.104
log
@CPLEX
@
text
@d11 1
d13 2
d24 3
a26 2
      JavaAccObj          (theCoord),
      mySimpleWitFuncMap_ ()
d29 4
d101 24
d220 40
d296 16
a311 5
void WitJ::Problem::eqHeurAlloc (
      const std::vector <Demand *> & theDemandVec,
      const std::vector <int> &      shipPerVec,
      const std::vector <double> &   desIncVolVec,
      WitVecOwner <double> &         incVolWVO)
d313 13
a325 6
   std::vector <const char *> thePartNameVec;
   std::vector <const char *> theDemandNameVec;
   int                        nTriples;
   int                        theIdx;
   Demand *                   theDemand;
   double *                   incVolWitVec;
d327 9
a335 1
   nTriples = theDemandVec.size ();
d337 11
a347 2
   thePartNameVec  .resize (nTriples);
   theDemandNameVec.resize (nTriples);
d351 5
a355 1
      theDemand                = theDemandVec[theIdx];
d357 1
a357 2
      thePartNameVec  [theIdx] = theDemand->getPartName   ();
      theDemandNameVec[theIdx] = theDemand->getDemandName ();
d360 2
a361 10
   witEqHeurAllocDbl (
      getWitRun (),
      nTriples,
    & thePartNameVec  [0],
    & theDemandNameVec[0],
    & shipPerVec      [0],
    & desIncVolVec    [0],
    & incVolWitVec);

   incVolWVO.acquireWitVec (incVolWitVec);
d383 31
@


1.103
log
@CPLEX
@
text
@d313 1
@


1.102
log
@CPLEX
@
text
@d188 18
d211 1
a211 1
   witBoolean intSpecExistsWB;
d216 1
a216 1
    & intSpecExistsWB,
d219 1
a219 1
   intSpecExists = intSpecExistsWB;
@


1.101
log
@CPLEX
@
text
@d106 1
a106 1
      getJavaObjRep ()->makeJString (NULL);
@


1.100
log
@CPLEX
@
text
@a187 2
#if 0

a203 2
#endif

@


1.99
log
@Multi-Obj Mode
@
text
@d149 14
d188 22
@


1.98
log
@Multi-Obj Mode
@
text
@d11 1
a11 1
#include           <VecWoa.h>
d178 1
a178 1
      VecWoa <double> &              incVolVecWoa)
d209 1
a209 1
   incVolVecWoa.acquireWitVec (incVolWitVec);
@


1.97
log
@Multi-Obj Mode
@
text
@d185 1
a185 1
   double *                   incVolCVec;
d207 1
a207 1
    & incVolCVec);
d209 1
a209 1
   incVolVecWoa.acquire (incVolCVec);
@


1.96
log
@Added an #include needed on some platforms.
@
text
@d185 1
d207 3
a209 1
      incVolVecWoa.getCVecAddr ());
@


1.95
log
@Changed some #includes.
@
text
@d15 1
@


1.94
log
@Method argument name change.
@
text
@a13 2
#include           <string.h>

@


1.93
log
@Implemented the null string convention for file names.
@
text
@d150 1
a150 1
void WitJ::Problem::copyData (Problem * theProblem)
d156 1
a156 1
   srcWitRun = theProblem->getWitRun ();
@


1.92
log
@Minor revision.
@
text
@d82 3
d236 3
d250 3
@


1.91
log
@Removed the "enabled" concept from WIT-J.
@
text
@a259 1
   defineSimpleWitFunc ("witInitialize",         witInitialize);
@


1.90
log
@Timing test.
@
text
@a22 1
      enabled_            (false),
a42 13
void WitJ::Problem::enable ()
   {
   EXCEPTION_ASSERT (! enabled_);

   witInitialize (getWitRun ());

   witSetWit34Allowed (getWitRun (), WitFALSE);

   enabled_ = true;
   }

//------------------------------------------------------------------------------

a94 2
   EXCEPTION_ASSERT (enabled_);

d99 1
a99 1
      enable ();
@


1.89
log
@Aded temporary code to test the ability to measure CPU time.
@
text
@a147 5
   else if (theCmdStr == "time-heur-implode")
      {
      timeHeurImplode ();
      }

a315 20

//------------------------------------------------------------------------------

void WitJ::Problem::timeHeurImplode ()
   {
   double timeBefore;
   double timeForHeur;

   timeBefore  = cpuTime ();

   witHeurImplode (getWitRun ());

   timeForHeur = cpuTime () - timeBefore;

   std::cout
      << "\n"
      << "CPU time for witHeurImplode (theWitRun): "
      << timeForHeur
      << " seconds\n\n";
   }
@


1.88
log
@theProblem.copyData (...).
@
text
@d148 5
d321 20
@


1.87
log
@Implemented C++ class PreJavaException.
@
text
@d163 15
d237 1
a237 1
   getCoordinator ()->extract ();
@


1.86
log
@Minor revisions.
@
text
@d7 6
a12 5
#include     <Problem.h>
#include <Coordinator.h>
#include  <JavaObjRep.h>
#include      <Demand.h>
#include      <VecWoa.h>
d14 1
a14 1
#include      <string.h>
d16 1
a16 1
#include    <iostream>
d212 9
a220 1
   witReadData (getWitRun (), fileName);
@


1.85
log
@Changed name of GlobalElement classes to GlobalComponent.
@
text
@d252 1
@


1.84
log
@Removed C++ class Extractor.
@
text
@d7 5
a11 6
#include       <Problem.h>
#include   <Coordinator.h>
#include    <JavaObjRep.h>
#include <GlobalElement.h>
#include        <Demand.h>
#include        <VecWoa.h>
d13 1
a13 1
#include        <string.h>
d15 1
a15 1
#include      <iostream>
@


1.83
log
@writeCriticalList
@
text
@a10 1
#include     <Extractor.h>
d214 1
a214 1
   getCoordinator ()->getExtractor ()->extract ();
@


1.82
log
@Implemented writeExecSched, writeShipSched, and writeReqSched.
@
text
@d220 16
@


1.81
log
@Moved set/get-PipSeq from class Problem to class GlobalElement.
@
text
@d74 32
@


1.80
log
@PIP
@
text
@a13 1
#include     <StrVecWoa.h>
a131 39
void WitJ::Problem::getPipSeq ()
   {
   int             nTriples         (0);
   StrVecWoa       partNameVecWoa   (nTriples);
   StrVecWoa       demandNameVecWoa (nTriples);
   VecWoa <int>    theShipPerVecWoa;
   VecWoa <double> incShipVolVecWoa;
   int             theIdx;
   const char *    partName;
   const char *    demandName;
   int             shipPer;
   double          incShipVol;
   Demand *        theDemand;

   witGetPipSeqDbl (
      getWitRun (),
    & nTriples,
      partNameVecWoa  .getCVecAddr (),
      demandNameVecWoa.getCVecAddr (),
      theShipPerVecWoa.getCVecAddr (),
      incShipVolVecWoa.getCVecAddr ());

   JavaObjRep::prepAllocTripleList (getCoordinator (), nTriples);

   for (theIdx = 0; theIdx < nTriples; theIdx ++)
      {
      partName   = partNameVecWoa  [theIdx];
      demandName = demandNameVecWoa[theIdx];
      shipPer    = theShipPerVecWoa[theIdx];
      incShipVol = incShipVolVecWoa[theIdx];

      theDemand  = getCoordinator ()->findDemand (partName, demandName);

      JavaObjRep::addAllocTriple (theDemand, shipPer, incShipVol);
      }
   }

//------------------------------------------------------------------------------

@


1.79
log
@Removed the ShipTriple classes.
@
text
@d135 11
a145 6
   int                     nTriples         (0);
   StrVecWoa               partNameVecWoa   (nTriples);
   StrVecWoa               demandNameVecWoa (nTriples);
   VecWoa <int>            theShipPerVecWoa;
   VecWoa <double>         incShipVolVecWoa;
   std::vector <Element *> theElementVec;
d155 1
a155 2
   getCoordinator ()->
      fillWithDemands (theElementVec, partNameVecWoa, demandNameVecWoa);
d157 11
a167 5
   JavaObjRep::storeAllocTriples (
      getCoordinator (),
      theElementVec,
      theShipPerVecWoa.getCVec (),
      incShipVolVecWoa.getCVec ());
@


1.78
log
@PIP.
@
text
@a11 1
#include    <ShipTriple.h>
d173 4
a176 2
      const std::vector <ShipTriple *> & theTripleVec,
      VecWoa <double> &                  incVolVecWoa)
d180 3
a182 2
   std::vector <int>          shipPerVec;
   std::vector <double>       desIncVolVec;
d184 1
a184 6
   int          nTriples;
   int          theIdx;
   ShipTriple * theTriple;
   Demand *     theDemand;

   nTriples = theTripleVec.size ();
a187 2
   shipPerVec      .resize (nTriples);
   desIncVolVec    .resize (nTriples);
d191 2
a192 2
      theTriple                = theTripleVec[theIdx];
      theDemand                = theTriple->getDemand     ();
a194 2
      shipPerVec      [theIdx] = theTriple->getShipPer    ();
      desIncVolVec    [theIdx] = theTriple->getIncShipVol ();
@


1.77
log
@PIP.
@
text
@a133 28
void WitJ::Problem::setPipSeq (const std::vector <ShipTriple *> & theTripleVec)
   {
   int          nTriples;
   int          theIdx;
   ShipTriple * theTriple;
   Demand *     theDemand;

   nTriples = theTripleVec.size ();

   witClearPipSeq (getWitRun ());

   for (theIdx = 0; theIdx < nTriples; theIdx ++)
      {
      theTriple = theTripleVec[theIdx];

      theDemand = theTriple->getDemand ();

      witAppendToPipSeqDbl (
         getWitRun                (),
         theDemand->getPartName   (),
         theDemand->getDemandName (),
         theTriple->getShipPer    (),
         theTriple->getIncShipVol ());
      }
   }

//------------------------------------------------------------------------------

@


1.76
log
@Implemented getPipSeq.
@
text
@d162 29
a243 27
void WitJ::Problem::getPipSeq (
      std::vector <Element *> & theElementVec,
      VecWoa <int> &            theShipPerVecWoa,
      VecWoa <double> &         incShipVolVecWoa)
   {
   int       nTriples;
   StrVecWoa partNameVecWoa   (nTriples);
   StrVecWoa demandNameVecWoa (nTriples);

   witGetPipSeqDbl (
      getWitRun (),
    & nTriples,
      partNameVecWoa  .getCVecAddr (),
      demandNameVecWoa.getCVecAddr (),
      theShipPerVecWoa.getCVecAddr (),
      incShipVolVecWoa.getCVecAddr ());

   getCoordinator ()->
      fillWithDemands (
         theElementVec,
         nTriples,
         partNameVecWoa,
         demandNameVecWoa);
   }

//------------------------------------------------------------------------------

@


1.75
log
@Implemented buildPip and setPipSeq.
@
text
@d15 1
d210 28
a237 1
    & incVolVecWoa);
@


1.74
log
@Replaced the AllocTarget classes with ShipTriple classes.
@
text
@d133 28
@


1.73
log
@Problem.eqHeurAlloc.
@
text
@d12 1
a12 1
#include   <AllocTarget.h>
d144 2
a145 1
      const std::vector <AllocTarget *> & theTargetVec)
a150 1
   VecWoa <double>            incVolVecWoa;
d152 20
a171 19
   int           nTargets;
   int           theIdx;
   AllocTarget * theTarget;

   nTargets = theTargetVec.size ();

   thePartNameVec  .resize (nTargets);
   theDemandNameVec.resize (nTargets);
   shipPerVec      .resize (nTargets);
   desIncVolVec    .resize (nTargets);

   for (theIdx = 0; theIdx < nTargets; theIdx ++)
      {
      theTarget                = theTargetVec[theIdx];

      thePartNameVec  [theIdx] = theTarget->getDemand ()->getPartName ();
      theDemandNameVec[theIdx] = theTarget->getDemand ()->getDemandName ();
      shipPerVec      [theIdx] = theTarget->getShipPer ();
      desIncVolVec    [theIdx] = theTarget->getDesIncVol ();
d176 1
a176 1
      nTargets,
a181 5

   for (theIdx = 0; theIdx < nTargets; theIdx ++)
      {
      theTargetVec[theIdx]->setIncVol (incVolVecWoa[theIdx]);
      }
@


1.72
log
@Setting wit34Allowed to false.
@
text
@d12 3
d17 1
d143 47
@


1.71
log
@Implemented Java class CppGateway.
@
text
@a23 3
   witSetMesgThrowErrorExc (getWitRun (), WitTRUE, WitSEVERE_MESSAGES, WitTRUE);
   witSetMesgThrowErrorExc (getWitRun (), WitTRUE,  WitFATAL_MESSAGES, WitTRUE);

d48 2
@


1.70
log
@Coordinator
@
text
@d87 1
a87 1
      getCoordinator ()->getJavaObjRep ()->makeJString (NULL);
d97 1
a97 1
      JavaObjRep::makeNonsense (getCoordinator (), "No Name");
d102 1
a102 1
      getCoordinator ()->getJavaObjRep ()->exhaustJniMemory ();
@


1.69
log
@Coordinator
@
text
@a20 1
      myCoordinator_      (theCoord),
d87 1
a87 1
      myCoordinator_->getJavaObjRep ()->makeJString (NULL);
d97 1
a97 1
      JavaObjRep::makeNonsense (myCoordinator_, "No Name");
d102 1
a102 1
      myCoordinator_->getJavaObjRep ()->exhaustJniMemory ();
a129 7
WitRun * WitJ::Problem::getWitRun ()
   {
   return myCoordinator_->getWitRun ();
   }

//------------------------------------------------------------------------------

d144 1
a144 1
   myCoordinator_->getExtractor ()->extract ();
@


1.68
log
@Coordinator
@
text
@d18 1
a18 1
WitJ::Problem::Problem (Coordinator * theCoordinator):
d20 2
a21 2
      JavaAccObj          (theCoordinator),
      myCoordinator_      (theCoordinator),
@


1.67
log
@Change the names of the ProbMgr classes to Coordinator, etc.
@
text
@d18 1
a18 3
WitJ::Problem::Problem (
         JavaObjRep *  theProblemJOR,
         Coordinator * theCoordinator):
a21 1
      myJavaObjRep_       (theProblemJOR),
a24 2
   myCoordinator_->store (this);

a34 1
   delete myJavaObjRep_;
d88 1
a88 1
      myJavaObjRep_->makeJString (NULL);
d98 1
a98 1
      JavaObjRep::makeNonsense (this, "No Name");
d103 1
a103 1
      myJavaObjRep_->exhaustJniMemory ();
@


1.66
log
@Continued implementation of the ProbMgr classes.
@
text
@d8 1
a8 1
#include       <ProbMgr.h>
d18 3
a20 1
WitJ::Problem::Problem (JavaObjRep * theProblemJOR, ProbMgr * theProbMgr):
d22 2
a23 2
      JavaAccObj          (theProbMgr),
      myProbMgr_          (theProbMgr),
d28 1
a28 1
   myProbMgr_->store (this);
d139 1
a139 1
   return myProbMgr_->getWitRun ();
d158 1
a158 1
   myProbMgr_->getExtractor ()->extract ();
@


1.65
log
@ProbMgr classes.
@
text
@d20 5
a24 4
      JavaAccObj    (theProbMgr),
      myProbMgr_    (theProbMgr),
      myJavaObjRep_ (theProblemJOR),
      enabled_      (false)
d30 2
d61 16
d168 36
@


1.64
log
@ProbMgr classes.
@
text
@a148 39
WitJ::Part * WitJ::Problem::findPart (const char * thePartName)
   {
   void * theAppData;

   witGetPartAppData (getWitRun (), thePartName, & theAppData);

   return static_cast <Part *> (theAppData);
   }

//------------------------------------------------------------------------------

WitJ::Operation * WitJ::Problem::findOperation (const char * theOpnName)
   {
   void * theAppData;

   witGetOperationAppData (getWitRun (), theOpnName, & theAppData);

   return static_cast <Operation *> (theAppData);
   }

//------------------------------------------------------------------------------

WitJ::BomEntry * WitJ::Problem::findBomEntry (
      const char * theOpnName,
      int          theBomIndex)
   {
   void * theAppData;

   witGetBomEntryAppData (
      getWitRun (),
      theOpnName,
      theBomIndex,
    & theAppData);

   return static_cast <BomEntry *> (theAppData);
   }

//------------------------------------------------------------------------------

@


1.63
log
@ProbMgr classes.
@
text
@a28 2

   defineAllSimpleWitFuncs ();
a57 16
void WitJ::Problem::callSimpleWitFunc (const char * theFuncName)
   {
   std::map <std::string, SimpleWitFunc>::iterator theItr;
   SimpleWitFunc                                   theFunc;

   theItr = mySimpleWitFuncMap_.find (theFuncName);

   EXCEPTION_ASSERT (theItr != mySimpleWitFuncMap_.end ());

   theFunc = theItr->second;

   theFunc (getWitRun ());
   }

//------------------------------------------------------------------------------

a187 36
void WitJ::Problem::defineAllSimpleWitFuncs ()
   {
   defineSimpleWitFunc ("witBuildPip",           witBuildPip);
   defineSimpleWitFunc ("witClearPegging",       witClearPegging);
   defineSimpleWitFunc ("witClearPipSeq",        witClearPipSeq);
   defineSimpleWitFunc ("witClearStochSoln",     witClearStochSoln);
   defineSimpleWitFunc ("witEvalObjectives",     witEvalObjectives);
   defineSimpleWitFunc ("witFinishExtOpt",       witFinishExtOpt);
   defineSimpleWitFunc ("witFinishHeurAlloc",    witFinishHeurAlloc);
   defineSimpleWitFunc ("witGeneratePriorities", witGeneratePriorities);
   defineSimpleWitFunc ("witHeurImplode",        witHeurImplode);
   defineSimpleWitFunc ("witMrp",                witMrp);
   defineSimpleWitFunc ("witOptImplode",         witOptImplode);
   defineSimpleWitFunc ("witPreprocess",         witPreprocess);
   defineSimpleWitFunc ("witPostprocess",        witPostprocess);
   defineSimpleWitFunc ("witPurgeData",          witPurgeData);
   defineSimpleWitFunc ("witShutDownExtOpt",     witShutDownExtOpt);
   defineSimpleWitFunc ("witShutDownHeurAlloc",  witShutDownHeurAlloc);
   defineSimpleWitFunc ("witStartExtOpt",        witStartExtOpt);
   defineSimpleWitFunc ("witStartHeurAlloc",     witStartHeurAlloc);
   defineSimpleWitFunc ("witStochImplode",       witStochImplode);
   }

//------------------------------------------------------------------------------

void WitJ::Problem::defineSimpleWitFunc (
      const char *  theFuncName,
      SimpleWitFunc theFunc)
   {
   EXCEPTION_ASSERT (mySimpleWitFuncMap_.count (theFuncName) == 0);

   mySimpleWitFuncMap_[theFuncName] = theFunc;
   }

//------------------------------------------------------------------------------

@


1.62
log
@ProbMgr classes.
@
text
@a22 1
      myExtractor_  (NULL),
a29 2
   myExtractor_ = new Extractor (this);

a36 1
   delete myExtractor_;
d155 1
a155 1
   myExtractor_->extract ();
@


1.61
log
@ProbMgr classes.
@
text
@a10 1
#include      <CTVecRes.h>
a22 1
      myCTVecRes_   (NULL),
a40 1
   delete myCTVecRes_;
a63 7
void WitJ::Problem::freezeNPeriods ()
   {
   myCTVecRes_ = new CTVecRes (myProbMgr_->getGlobalElement ()->getNPeriods ());
   }

//------------------------------------------------------------------------------

@


1.60
log
@Change the mname of the ProbCtr classes to ProbMgr in both Java and C++.
@
text
@d21 6
a26 7
      JavaAccObj       (theProbMgr),
      myProbMgr_       (theProbMgr),
      myJavaObjRep_    (theProblemJOR),
      myGlobalElement_ (NULL),
      myCTVecRes_      (NULL),
      myExtractor_     (NULL),
      enabled_         (false)
a66 12
void WitJ::Problem::store (GlobalElement * theGlobalElement)
   {
   EXCEPTION_ASSERT (myGlobalElement_ == NULL);
   EXCEPTION_ASSERT (theGlobalElement != NULL);

   EXCEPTION_ASSERT (theGlobalElement->getProblem () == this);

   myGlobalElement_ = theGlobalElement;
   }

//------------------------------------------------------------------------------

d69 1
a69 1
   myCTVecRes_ = new CTVecRes (myGlobalElement_->getNPeriods ());
@


1.59
log
@Continued implementation of ProbCtr classes.
@
text
@d8 1
a8 1
#include       <ProbCtr.h>
d19 1
a19 1
WitJ::Problem::Problem (JavaObjRep * theProblemJOR, ProbCtr * theProbCtr):
d21 2
a22 2
      JavaAccObj       (theProbCtr),
      myProbCtr_       (theProbCtr),
d29 1
a29 1
   myProbCtr_->store (this);
d163 1
a163 1
   return myProbCtr_->getWitRun ();
@


1.58
log
@Continued implementation of the ProbCtr classes.
@
text
@d19 9
a27 1
WitJ::Problem * WitJ::Problem::newInstance  (JavaObjRep * theProblemJOR)
d29 1
a29 1
   ProbCtr * theProbCtr;
d31 2
a32 1
   theProbCtr = new ProbCtr;
d34 3
a36 1
   return new Problem (theProblemJOR, theProbCtr);
a45 2

   delete ownedProbCtr_;
a167 9
void WitJ::Problem::relinquishProbCtr ()
   {
   EXCEPTION_ASSERT (ownedProbCtr_ != NULL);

   ownedProbCtr_ = NULL;
   }

//------------------------------------------------------------------------------

a232 23
WitJ::Problem::Problem (JavaObjRep * theProblemJOR, ProbCtr * theProbCtr):

      JavaAccObj       (theProbCtr),
      ownedProbCtr_    (theProbCtr),
      myProbCtr_       (theProbCtr),
      myJavaObjRep_    (theProblemJOR),
      myGlobalElement_ (NULL),
      myCTVecRes_      (NULL),
      myExtractor_     (NULL),
      enabled_         (false)
   {
   ownedProbCtr_->store (this);

   witSetMesgThrowErrorExc (getWitRun (), WitTRUE, WitSEVERE_MESSAGES, WitTRUE);
   witSetMesgThrowErrorExc (getWitRun (), WitTRUE,  WitFATAL_MESSAGES, WitTRUE);

   myExtractor_ = new Extractor (this);

   defineAllSimpleWitFuncs ();
   }

//------------------------------------------------------------------------------

@


1.57
log
@Initial implementation of Java classes ProbCtrCOR ProbCtr.
@
text
@d19 1
a19 10
WitJ::Problem::Problem (JavaObjRep * theProblemJOR):

      JavaAccObj       (this),
      ownedProbCtr_    (NULL),
      myProbCtr_       (NULL),
      myJavaObjRep_    (theProblemJOR),
      myGlobalElement_ (NULL),
      myCTVecRes_      (NULL),
      myExtractor_     (NULL),
      enabled_         (false)
d21 1
a21 1
   ownedProbCtr_ = new ProbCtr (this);
d23 1
a23 1
   myProbCtr_    = ownedProbCtr_;
d25 1
a25 6
   witSetMesgThrowErrorExc (getWitRun (), WitTRUE, WitSEVERE_MESSAGES, WitTRUE);
   witSetMesgThrowErrorExc (getWitRun (), WitTRUE,  WitFATAL_MESSAGES, WitTRUE);

   myExtractor_ = new Extractor (this);

   defineAllSimpleWitFuncs ();
d233 23
@


1.56
log
@Initial implementation of C++ class ProbCtr.
@
text
@d22 1
d30 3
a32 1
   myProbCtr_ = new ProbCtr (this);
d49 2
a50 1
   delete myProbCtr_;
d173 9
@


1.55
log
@Implemented method writeData of class Problem.
@
text
@d8 1
d22 1
a22 1
      myWitRun_        (NULL),
d29 1
a29 1
   witNewRun (& myWitRun_);
d31 2
a32 2
   witSetMesgThrowErrorExc (myWitRun_, WitTRUE, WitSEVERE_MESSAGES, WitTRUE);
   witSetMesgThrowErrorExc (myWitRun_, WitTRUE,  WitFATAL_MESSAGES, WitTRUE);
a40 7
void WitJ::Problem::deleteInstance (Problem * theProblem)
   {
   delete theProblem;
   }

//------------------------------------------------------------------------------

d46 1
a46 2

   witDeleteRun (myWitRun_);
d162 7
@


1.54
log
@Implemented SimpleWitFuncs and used them for 4 methods.
@
text
@d188 7
@


1.53
log
@Added code to handle running out of memory in WIT.
@
text
@a12 2
#include           <wit.h>

d34 2
d95 16
a178 28
void WitJ::Problem::evalObjectives ()
   {
   witEvalObjectives (getWitRun ());
   }

//------------------------------------------------------------------------------

void WitJ::Problem::generatePriorities ()
   {
   witGeneratePriorities (getWitRun ());
   }

//------------------------------------------------------------------------------

void WitJ::Problem::heurImplode ()
   {
   witHeurImplode (getWitRun ());
   }

//------------------------------------------------------------------------------

void WitJ::Problem::postprocess ()
   {
   witPostprocess (getWitRun ());
   }

//------------------------------------------------------------------------------

d227 36
@


1.52
log
@Implemented the handling of fatal errors from WIT.
@
text
@d128 5
@


1.51
log
@Added code to handle severe errors from WIT.
@
text
@d33 1
d128 5
@


1.50
log
@Added code to handle memory errors in makeJString.
@
text
@d32 2
@


1.49
log
@Added code to handle Java exceptions raised during the execution of JNI
   functions.
@
text
@d120 5
d135 1
a135 1
   throw "Hello.";
@


1.48
log
@Added code to handle a memory overflow in the C++ side of WIT-J.
@
text
@d115 5
@


1.47
log
@Added a test for ABORTING_ASSERT.
@
text
@d104 1
d109 6
d213 17
@


1.46
log
@Implemented EXCEPTION_ASSERT and ABORTING_ASSERT.
@
text
@d96 2
d100 5
a104 1
   if (theCmdStr == "incur-c++-assertion-failure")
d106 1
a106 1
      EXCEPTION_ASSERT (false);
@


1.45
log
@Removed an unneeded test case.
@
text
@a12 5

#include <AssertException.h>



d64 1
a64 1
   WITJ_ASSERT (! enabled_);
d75 2
a76 2
   WITJ_ASSERT (myGlobalElement_ == NULL);
   WITJ_ASSERT (theGlobalElement != NULL);
d78 1
a78 1
   WITJ_ASSERT (theGlobalElement->getProblem () == this);
d100 1
a100 3
      AssertException theAssertException ("Problem.C", -1);

      throw theAssertException;
d104 1
a104 1
      WITJ_ASSERT (false);
@


1.44
log
@theProblem.performAction (theCommand)
@
text
@a102 4
   if (theCmdStr == "throw-unexpected-c++-exception")
      {
      throw 7;
      }
d117 1
a117 1
bool WitJ::Problem::throwUnexpExceptionBool ()
@


1.43
log
@Initial C++ implementation of class AssertException.
@
text
@d97 1
a97 1
void WitJ::Problem::throwUnexpException ()
d99 18
a116 1
   throw 7;
a127 9
void WitJ::Problem::incurAssertFailure ()
   {
   AssertException theAssertException ("Problem.C", 113);

   throw theAssertException;
   }

//------------------------------------------------------------------------------

@


1.42
log
@Added test of C++ assertion failure.
@
text
@d13 5
d113 3
a115 1
   WITJ_ASSERT (false);
@


1.41
log
@Updated some comments.
@
text
@d106 7
@


1.40
log
@Implemented the C++ canonical try block macros.
@
text
@d4 1
a4 1
// Contains the definition of class Problem.
@


1.39
log
@Changed to all upper case for the names of macros.
@
text
@d92 14
@


1.38
log
@Removed C++ class Session.
@
text
@d64 1
a64 1
   witjAssert (! enabled_);
d75 2
a76 2
   witjAssert (myGlobalElement_ == NULL);
   witjAssert (theGlobalElement != NULL);
d78 1
a78 1
   witjAssert (theGlobalElement->getProblem () == this);
@


1.37
log
@Removed Java class SessionCOR.
@
text
@a7 1
#include       <Session.h>
d20 1
a20 1
WitJ::Problem::Problem (Session * theSession, JavaObjRep * theProblemJOR):
d22 2
a23 1
      JavaAccObj       (theSession),
d30 1
a30 1
   theSession->store (this);
d37 7
d49 2
a61 7
bool WitJ::Problem::isProblem ()
   {
   return true;
   }

//------------------------------------------------------------------------------

d78 1
a78 1
   witjAssert (theGlobalElement->getSession () == getSession ());
@


1.36
log
@Removed class Session from the public interface.
@
text
@a19 2
// Non-Inlines.
//------------------------------------------------------------------------------
d53 7
a172 1

@


1.35
log
@Added theProblem.postprocess ().
@
text
@d29 2
a30 1
      myExtractor_     (NULL)
a33 2
   witInitialize (getWitRun ());

d55 11
@


1.34
log
@Name change.
@
text
@d106 7
@


1.33
log
@Changed name of Component to Entity.
@
text
@d7 6
a12 6
#include      <Problem.h>
#include      <Session.h>
#include   <JavaObjRep.h>
#include <GlobalEntity.h>
#include     <CTVecRes.h>
#include    <Extractor.h>
d14 1
a14 1
#include          <wit.h>
d16 2
a17 2
#include       <string.h>
#include     <iostream>
d25 5
a29 5
      JavaAccObj      (theSession),
      myJavaObjRep_   (theProblemJOR),
      myGlobalEntity_ (NULL),
      myCTVecRes_     (NULL),
      myExtractor_    (NULL)
d56 1
a56 1
void WitJ::Problem::store (GlobalEntity * theGlobalEntity)
d58 2
a59 2
   witjAssert (myGlobalEntity_ == NULL);
   witjAssert (theGlobalEntity != NULL);
d61 1
a61 1
   witjAssert (theGlobalEntity->getSession () == getSession ());
d63 1
a63 1
   myGlobalEntity_ = theGlobalEntity;
d70 1
a70 1
   myCTVecRes_ = new CTVecRes (myGlobalEntity_->getNPeriods ());
@


1.32
log
@Revised class StringWoa.
@
text
@d7 6
a12 6
#include    <Problem.h>
#include    <Session.h>
#include <JavaObjRep.h>
#include <GlobalComp.h>
#include   <CTVecRes.h>
#include  <Extractor.h>
d14 1
a14 1
#include        <wit.h>
d16 2
a17 2
#include     <string.h>
#include   <iostream>
d25 5
a29 5
      JavaAccObj    (theSession),
      myJavaObjRep_ (theProblemJOR),
      myGlobalComp_ (NULL),
      myCTVecRes_   (NULL),
      myExtractor_  (NULL)
d56 1
a56 1
void WitJ::Problem::store (GlobalComp * theGlobalComp)
d58 2
a59 2
   witjAssert (myGlobalComp_ == NULL);
   witjAssert (theGlobalComp != NULL);
d61 1
a61 1
   witjAssert (theGlobalComp->getSession () == getSession ());
d63 1
a63 1
   myGlobalComp_ = theGlobalComp;
d70 1
a70 1
   myCTVecRes_ = new CTVecRes (myGlobalComp_->getNPeriods ());
@


1.31
log
@Implemented extraction of BOM entries.
@
text
@a8 1
#include  <StringWoa.h>
d115 1
a115 1
WitJ::Part * WitJ::Problem::findPart (const StringWoa & thePartNameWoa)
d119 1
a119 4
   witGetPartAppData (
      getWitRun (),
      thePartNameWoa.getCString (),
    & theAppData);
d126 1
a126 1
WitJ::Operation * WitJ::Problem::findOperation (const StringWoa & theOpnNameWoa)
d130 1
a130 4
   witGetOperationAppData (
      getWitRun (),
      theOpnNameWoa.getCString (),
    & theAppData);
d138 2
a139 2
      const StringWoa & theOpnNameWoa,
      int               theBomIndex)
d145 1
a145 1
      theOpnNameWoa.getCString (),
@


1.30
log
@Call-back infrastructure.
Implemented extraction of Demands.
@
text
@d9 1
d116 1
a116 1
WitJ::Part * WitJ::Problem::findPart (const char * thePartName)
d118 1
a118 1
   void * thePartVoid;
d120 4
a123 1
   witGetPartAppData (getWitRun (), thePartName, & thePartVoid);
d125 1
a125 1
   return static_cast <Part *> (thePartVoid);
d127 32
@


1.29
log
@Call-back infrastructure.
@
text
@d112 11
@


1.28
log
@Changed name of C++ class JAccObject to JavaAccObj.
@
text
@d9 1
d23 1
a23 1
WitJ::Problem::Problem (Session * theSession):
d26 1
d44 1
@


1.27
log
@Intitial implementation of extraction of nPeriods.
@
text
@d24 1
a24 1
      JAccObject    (theSession),
@


1.26
log
@Began implementation of Problem.readData (...).
@
text
@d105 1
a105 11
   int nPeriodsBef;
   int nPeriodsAft;

   witGetNPeriods (getWitRun (), & nPeriodsBef);

   witReadData    (getWitRun (),   fileName);

   witGetNPeriods (getWitRun (), & nPeriodsAft);

   if (nPeriodsAft != nPeriodsBef)
      changedNPeriodsError ();
a108 16

//------------------------------------------------------------------------------

void WitJ::Problem::changedNPeriodsError ()
   {
   std::cout
      << "\n"
      << "WIT-J Application Program Error:\n"
      << "\n"
      << "   Problem.readData was called on a file that changes the value of "
      <<    "nPeriods.\n"
      << "\n"
      << "Application Program aborted by WIT-J.\n";

   exit (3);
   }
@


1.25
log
@Wrapped witGeneratePriorities.
@
text
@d11 1
d16 1
d26 2
a27 1
      myCTVecRes_   (NULL)
d32 2
d40 1
d100 35
@


1.24
log
@Wrapped witEvalObjectives.
@
text
@d83 7
@


1.23
log
@Implemented theMsgHandler.flushFile ().
@
text
@d76 7
@


1.22
log
@Minor change.
@
text
@a65 11
void WitJ::Problem::flushMsgFile ()
   {
   FILE * msgFile;

   witGetMesgFile (getWitRun (), & msgFile);

   fflush (msgFile);
   }

//------------------------------------------------------------------------------

@


1.21
log
@Revised class CTVecRes.
@
text
@d59 1
a59 1
void WitJ::Problem::lockNPeriods ()
@


1.20
log
@Revised the use of class CTVecRes.
@
text
@d61 1
a61 1
   myCTVecRes_ = new CTVecRes (getSession ());
@


1.19
log
@Moves C++ GlobalComp from Session to Problem.
@
text
@d10 1
d23 2
a24 1
      myGlobalComp_ (NULL)
d35 1
d59 7
@


1.18
log
@Added theSession.myProblem_.
@
text
@d7 3
a9 2
#include <Problem.h>
#include <Session.h>
d11 1
a11 1
#include     <wit.h>
d13 1
a13 1
#include  <string.h>
d21 2
a22 1
      JAccObject (theSession)
d44 12
@


1.17
log
@Initial implementation of creating a Session without a Problem.
@
text
@d8 1
d22 2
@


1.16
log
@Minor update.
@
text
@d21 1
@


1.15
log
@Renamed Java class ProbCoordCI to SessionCI.
Renamed C++  class ProbCoord   to Session.
@
text
@a7 1
#include <Session.h>
a13 9
// Inlines.
//------------------------------------------------------------------------------

inline WitRun * WitJ::Problem::getWitRun ()
   {
   return getSession ()->getWitRun ();
   }

//------------------------------------------------------------------------------
@


1.14
log
@Removed some debugging output.
@
text
@d7 2
a8 2
#include   <Problem.h>
#include <ProbCoord.h>
d10 1
a10 1
#include       <wit.h>
d12 1
a12 1
#include    <string.h>
d20 1
a20 1
   return getProbCoord ()->getWitRun ();
d27 1
a27 1
WitJ::Problem::Problem (ProbCoord * theProbCoord):
d29 1
a29 1
      JAccObject (theProbCoord)
@


1.13
log
@Attributes.
@
text
@d12 1
a12 1
#include  <iostream>
a36 4
   std::cout
      << std::endl
      << "Destroying a Problem."
      << std::endl;
@


1.12
log
@Changed the names of access functions beginning with "my"
to begin with "get".
@
text
@d45 1
a45 1
WitJ::Problem * WitJ::Problem::thisProblem ()
@


1.11
log
@Implemented Problem.heurImplode.
@
text
@d18 1
a18 1
inline WitRun * WitJ::Problem::myWitRun ()
d20 1
a20 1
   return myProbCoord ()->myWitRun ();
d56 1
a56 1
   witGetMesgFile (myWitRun (), & msgFile);
d68 1
a68 1
   witDisplayData (myWitRun (), fileName);
d75 1
a75 1
   witHeurImplode (myWitRun ());
@


1.10
log
@Added myName_ to class Att.
@
text
@d70 7
@


1.9
log
@*** empty log message ***
@
text
@d39 1
a39 1
      << "Destroying a WitJ::Problem."
@


1.8
log
@*** empty log message ***
@
text
@d52 11
@


1.7
log
@*** empty log message ***
@
text
@d20 1
a20 1
   return myProbCoord_->myWitRun ();
d29 1
a29 1
      myProbCoord_ (theProbCoord)
@


1.6
log
@*** empty log message ***
@
text
@a44 7
void WitJ::Problem::getDerivedInstance (Problem * & theProblem)
   {
   theProblem = this;
   }

//------------------------------------------------------------------------------

@


1.5
log
@*** empty log message ***
@
text
@d52 7
@


1.4
log
@*** empty log message ***
@
text
@a7 1
#include <StringJia.h>
d52 1
a52 1
void WitJ::Problem::displayData (const StringJia & fileNameJia)
a53 4
   const char * fileName;

   fileName = fileNameJia.myCString ();

@


1.3
log
@*** empty log message ***
@
text
@d28 1
a28 1
WitJ::Problem::Problem ():
d30 1
a30 1
      myProbCoord_ (NULL)
a52 10
void WitJ::Problem::store (ProbCoord * theProbCoord)
   {
   assert (myProbCoord_ == NULL);
   assert (theProbCoord != NULL);

   myProbCoord_ = theProbCoord;
   }

//------------------------------------------------------------------------------

@


1.2
log
@*** empty log message ***
@
text
@d9 1
d16 11
d30 1
a30 1
      myWitRun_ (NULL)
a31 5
   witNewRun              (& myWitRun_);

   witSetMesgFileAccessMode (myWitRun_, WitTRUE, "w");

   witInitialize            (myWitRun_);
a41 2

   witDeleteRun (myWitRun_);
d53 10
d72 1
a72 1
   witDisplayData (myWitRun_, fileName);
@


1.1
log
@*** empty log message ***
@
text
@d7 2
a8 4
#include      <Problem.h>
#include <TVecJiaRepos.h>
#include    <StringJia.h>
#include   <GlobalComp.h>
d10 1
a10 1
#include          <wit.h>
d12 1
a12 1
#include     <iostream>
d18 1
a18 2
      myWitRun_          (NULL),
      myDblTVecJiaRepos_ (NULL)
a24 2

   myGlobalComp_ = new GlobalComp (this);
a35 2
   delete myDblTVecJiaRepos_;

a47 8
void WitJ::Problem::recNewPartOpn ()
   {
   if (myDblTVecJiaRepos_ == NULL)
      myDblTVecJiaRepos_ = new DblTVecJiaRepos (this);
   }

//------------------------------------------------------------------------------

@


head	1.170;
access;
symbols;
locks; strict;
comment	@// @;


1.170
date	2006.05.15.14.07.57;	author gresh;	state Exp;
branches;
next	1.169;

1.169
date	2006.02.06.17.58.25;	author gresh;	state Exp;
branches;
next	1.168;

1.168
date	2006.01.30.15.46.57;	author gresh;	state Exp;
branches;
next	1.167;

1.167
date	2006.01.23.12.42.43;	author gresh;	state Exp;
branches;
next	1.166;

1.166
date	2005.12.22.17.09.03;	author gresh;	state Exp;
branches;
next	1.165;

1.165
date	2005.12.21.17.45.56;	author gresh;	state Exp;
branches;
next	1.164;

1.164
date	2005.12.15.18.26.20;	author gresh;	state Exp;
branches;
next	1.163;

1.163
date	2005.09.13.17.53.29;	author gresh;	state Exp;
branches;
next	1.162;

1.162
date	2005.09.08.14.57.48;	author gresh;	state Exp;
branches;
next	1.161;

1.161
date	2005.08.19.19.15.24;	author gresh;	state Exp;
branches;
next	1.160;

1.160
date	2005.08.18.13.58.25;	author gresh;	state Exp;
branches;
next	1.159;

1.159
date	2005.08.16.16.58.43;	author gresh;	state Exp;
branches;
next	1.158;

1.158
date	2005.08.16.16.21.19;	author gresh;	state Exp;
branches;
next	1.157;

1.157
date	2005.08.15.17.32.41;	author gresh;	state Exp;
branches;
next	1.156;

1.156
date	2005.08.05.14.52.37;	author gresh;	state Exp;
branches;
next	1.155;

1.155
date	2005.08.04.18.33.05;	author gresh;	state Exp;
branches;
next	1.154;

1.154
date	2004.10.19.17.12.21;	author gresh;	state Exp;
branches;
next	1.153;

1.153
date	2004.10.18.17.27.28;	author gresh;	state Exp;
branches;
next	1.152;

1.152
date	2004.10.18.16.25.41;	author gresh;	state Exp;
branches;
next	1.151;

1.151
date	2004.10.16.12.54.42;	author gresh;	state Exp;
branches;
next	1.150;

1.150
date	2004.10.15.18.53.15;	author gresh;	state Exp;
branches;
next	1.149;

1.149
date	2004.10.15.14.05.06;	author gresh;	state Exp;
branches;
next	1.148;

1.148
date	2004.08.17.13.44.25;	author gresh;	state Exp;
branches;
next	1.147;

1.147
date	2004.08.17.13.36.11;	author gresh;	state Exp;
branches;
next	1.146;

1.146
date	2004.08.16.17.19.03;	author gresh;	state Exp;
branches;
next	1.145;

1.145
date	2004.08.10.16.44.10;	author gresh;	state Exp;
branches;
next	1.144;

1.144
date	2004.08.10.14.31.39;	author gresh;	state Exp;
branches;
next	1.143;

1.143
date	2004.08.05.17.40.52;	author gresh;	state Exp;
branches;
next	1.142;

1.142
date	2004.08.03.15.32.00;	author dpc;	state Exp;
branches;
next	1.141;

1.141
date	2004.07.30.18.31.07;	author dpc;	state Exp;
branches;
next	1.140;

1.140
date	2004.07.26.18.22.18;	author gresh;	state Exp;
branches;
next	1.139;

1.139
date	2004.07.26.17.54.12;	author gresh;	state Exp;
branches;
next	1.138;

1.138
date	2004.07.26.14.27.38;	author gresh;	state Exp;
branches;
next	1.137;

1.137
date	2004.07.21.17.42.02;	author gresh;	state Exp;
branches;
next	1.136;

1.136
date	2004.07.21.14.47.28;	author gresh;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.15.16.50.58;	author gresh;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.14.16.38.22;	author gresh;	state Exp;
branches;
next	1.133;

1.133
date	2004.07.14.16.16.51;	author gresh;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.24.21.36.09;	author dpc;	state Exp;
branches;
next	1.131;

1.131
date	2004.06.24.18.18.54;	author gresh;	state Exp;
branches;
next	1.130;

1.130
date	2004.06.22.19.58.38;	author gresh;	state Exp;
branches;
next	1.129;

1.129
date	2004.06.22.19.45.46;	author gresh;	state Exp;
branches;
next	1.128;

1.128
date	2004.06.22.19.15.32;	author gresh;	state Exp;
branches;
next	1.127;

1.127
date	2004.06.21.14.32.09;	author gresh;	state Exp;
branches;
next	1.126;

1.126
date	2004.06.18.17.31.25;	author gresh;	state Exp;
branches;
next	1.125;

1.125
date	2004.06.17.14.50.43;	author gresh;	state Exp;
branches;
next	1.124;

1.124
date	2004.06.07.18.42.30;	author dpc;	state Exp;
branches;
next	1.123;

1.123
date	2004.06.04.17.07.37;	author gresh;	state Exp;
branches;
next	1.122;

1.122
date	2004.06.02.13.50.01;	author gresh;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.17.19.06.19;	author dpc;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.17.17.02.03;	author gresh;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.17.15.41.29;	author gresh;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.14.17.41.38;	author gresh;	state Exp;
branches;
next	1.117;

1.117
date	2004.05.14.13.15.05;	author gresh;	state Exp;
branches;
next	1.116;

1.116
date	2004.05.11.19.16.26;	author dpc;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.11.18.25.28;	author gresh;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.11.16.38.27;	author gresh;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.11.15.40.08;	author gresh;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.11.14.39.19;	author gresh;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.06.21.32.36;	author gresh;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.03.23.08.35;	author dpc;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.03.17.08.38;	author gresh;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.03.14.49.37;	author gresh;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.03.13.20.59;	author fasano;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.30.17.13.50;	author gresh;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.29.17.44.15;	author gresh;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.21.19.01.50;	author gresh;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.20.14.19.47;	author dpc;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.16.14.28.43;	author gresh;	state Exp;
branches;
next	1.101;

1.101
date	2004.04.15.19.39.29;	author gresh;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.15.16.54.23;	author gresh;	state Exp;
branches;
next	1.99;

1.99
date	2004.04.15.15.32.30;	author fasano;	state Exp;
branches;
next	1.98;

1.98
date	2004.04.15.15.28.00;	author gresh;	state Exp;
branches;
next	1.97;

1.97
date	2004.04.15.14.59.17;	author gresh;	state Exp;
branches;
next	1.96;

1.96
date	2004.04.15.13.29.14;	author gresh;	state Exp;
branches;
next	1.95;

1.95
date	2004.04.14.18.55.32;	author dpc;	state Exp;
branches;
next	1.94;

1.94
date	2004.04.14.17.05.53;	author gresh;	state Exp;
branches;
next	1.93;

1.93
date	2004.04.14.16.01.21;	author gresh;	state Exp;
branches;
next	1.92;

1.92
date	2004.04.14.14.52.40;	author gresh;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.13.20.59.29;	author fasano;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.13.20.16.50;	author fasano;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.13.19.59.19;	author fasano;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.13.19.26.54;	author gresh;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.13.19.20.01;	author gresh;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.13.14.23.41;	author gresh;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.12.17.47.31;	author fasano;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.12.15.59.13;	author dpc;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.09.17.22.21;	author gresh;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.09.15.18.52;	author gresh;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.02.21.48.55;	author gresh;	state Exp;
branches;
next	1.80;

1.80
date	2004.03.31.16.05.43;	author gresh;	state Exp;
branches;
next	1.79;

1.79
date	2004.03.30.23.42.47;	author fasano;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.29.13.46.59;	author gresh;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.24.19.20.33;	author gresh;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.24.17.41.51;	author gresh;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.23.22.47.21;	author gresh;	state Exp;
branches;
next	1.74;

1.74
date	2004.03.22.20.40.30;	author gresh;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.22.16.03.39;	author gresh;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.22.15.51.17;	author gresh;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.22.13.40.16;	author gresh;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.19.19.27.52;	author fasano;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.18.22.13.00;	author fasano;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.18.21.09.38;	author fasano;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.18.20.35.19;	author fasano;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.18.15.46.12;	author gresh;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.18.15.41.46;	author fasano;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.18.15.10.34;	author gresh;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.18.14.18.39;	author gresh;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.18.03.18.02;	author fasano;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.17.22.34.40;	author fasano;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.17.17.44.08;	author gresh;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.17.03.08.15;	author fasano;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.16.21.46.08;	author gresh;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.16.21.23.58;	author gresh;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.16.20.48.21;	author dpc;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.16.20.35.42;	author gresh;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.16.20.25.59;	author gresh;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.16.18.41.05;	author gresh;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.16.17.23.33;	author gresh;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.15.21.12.25;	author gresh;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.15.20.56.44;	author gresh;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.15.20.12.30;	author gresh;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.14.13.45.47;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.13.23.18.50;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.10.19.16.59;	author gresh;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.10.17.37.43;	author gresh;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.09.20.36.38;	author gresh;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.09.14.23.56;	author gresh;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.08.21.01.48;	author gresh;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.08.14.34.25;	author gresh;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.01.22.54.03;	author dpc;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.12.17.56.03;	author gresh;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.12.17.26.59;	author gresh;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.12.16.06.21;	author gresh;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.12.15.24.09;	author gresh;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.11.19.39.09;	author gresh;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.10.19.43.32;	author gresh;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.30.15.16.09;	author gresh;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.30.13.28.08;	author dpc;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.29.15.00.55;	author gresh;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.26.18.32.09;	author gresh;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.22.16.55.44;	author gresh;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.22.16.50.00;	author gresh;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.22.14.51.28;	author gresh;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.21.20.40.03;	author dpc;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.21.19.07.29;	author gresh;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.21.15.47.32;	author gresh;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.21.14.43.07;	author dpc;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.13.00.14.33;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.12.17.39.32;	author gresh;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.12.14.51.38;	author dpc;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.11.17.40.44;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.10.03.16.42;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.21.39.49;	author dpc;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.08.20.00.04;	author dpc;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.07.23.18.32;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.07.22.18.34;	author dpc;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.07.19.30.01;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.07.14.01.52;	author dpc;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.06.17.10.02;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.13.04.52.48;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.09.19.03.27;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.09.17.46.05;	author dpc;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.09.14.17.45;	author dpc;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.21.55.08;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.21.33.16;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.19.40.42;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.03.19.30.04;	author dpc;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.01.20.14.28;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.01.17.44.13;	author gresh;	state Exp;
branches;
next	;


desc
@@


1.170
log
@added engagement families for the "portfolio" option.
@
text
@#if defined(_MSC_VER)
  #pragma warning(disable:4786)
  #pragma warning(disable:4503)
  #pragma warning(disable:4290)
#endif



#include "populateRCP.h"
#include "problemBase.h"
#include "rcpOptException.h"
#include "engagementFile.h"
#include "engagementFamilyFile.h"
#include "demandEngagementFile.h"
#include "supplyAdjustmentsFile.h"
#include "globalAttrFile.h"
#include "prioritySubsFile.h"
#include "skillsFile.h"
#include "nascoSupplyFile.h"
#include "nascoSupplyAssignmentFile.h"
#include "toFromSubsFile.h"
#include "resourceIdPriorityFile.h"
#include "gnrlResourceFile.h"
#include "gnrlBomFile.h"
#include "gnrlMatchFile.h"
#include "gnrlResourceActionFile.h"
#include <cstdio>
#include <iostream>
#include <sstream>

void readResourceFile(
                      RCPproblem & prob, 
                      const std::string & resourceFileName,
                      bool isOptimal, // read fixedCosted from file
                      bool isGapGlut, //don't want to default acquire time to a large value
                      std::vector<int> matchFlags, //needed to stick in "unmatched" if appropriate
                      RcpOptCalendar & rcpCal
                      )
{
  int nPeriods = prob.getNPeriods();  
  float infeasibleAcquireTime = 10.f*nPeriods;
  int numAttributes = prob.getResourceIdentifierNames().size();  
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,isOptimal,rcpCal.getCalendarType());
  RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
  
  // loop once for each record in resource file
  
  int foo=1;
  std::vector<std::string> resourceAttributeValues(numAttributes);
  for ( ; resourceFileIter()!=NULL; ) {
    for (int j=0; j<numAttributes; j++) {
      std::string attributeName = prob.getResourceIdentifierNames()[j];
      std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
      if (matchFlags.size()!=0 && matchFlags[j]==0)
          attributeValue = "unmatched";
      resourceAttributeValues[j]=attributeValue;
    }
    int period;
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
       period = resourceFileIter.periodAsInt();
    else {
       period = rcpCal.computePeriodFromMonthAndYear(resourceFileIter.monthAsInt(), resourceFileIter.yearAsInt());
    }
    float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
    // test to ensure quantity is non-negative
    if ( supplyQuantity < 0) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"   Error: supplyQuantity is negative"                                    <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()                <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()              <<std::endl            
        <<"   period: " <<period                                                    <<std::endl                          <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }

    float fixedCost;
    if (isOptimal) {
      fixedCost = resourceFileIter.fieldOnRecordAsFloat("fixedCost");  //DLG check for negative
    }
    // test to ensure period is within the planning horizon
    if ( period <0 || period >= nPeriods ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: period is beyond planning horizion"                               <<std::endl
        <<"   filename: " <<resourceFile.filename().c_str()                         <<std::endl
        <<"   file line number: " <<resourceFileIter.recNum()                       <<std::endl            
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
    
    
    if ( !prob.resourceExists(resourceAttributeValues) )
      prob.addResource(resourceAttributeValues);
      
    if (isOptimal) 
      prob.setResourceFixedCost(resourceAttributeValues,period,fixedCost);
    if (!isGapGlut) {
      //default the acquire time to something large
      prob.setResourceAcquireTime(resourceAttributeValues,infeasibleAcquireTime);
    }
    float largeCost = 1e10;
    prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
      

    std::vector<float> priorQuantity = prob.getResourceSupplyQuantity(resourceAttributeValues);
    supplyQuantity=supplyQuantity+priorQuantity[period];
    prob.setResourceSupplyQuantity(resourceAttributeValues,period,supplyQuantity);
    if (period == 0){
      prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,supplyQuantity);
    }    
  }
}
MapStringToFlexSkillsObject readFlexSkillsFile(
                      RCPproblem & prob, 
                      const std::string & skillsFileName,
                      std::set<std::string> supplySet 
                      )
{
  RCPskillsFile skillsFile(skillsFileName);
  RCPskillsFileIterator skillsFileIter(skillsFile);
  

  MapStringToFlexSkillsObject map;
 
  // loop once for each record in skills file
  for ( ; skillsFileIter()!=NULL; ) {
    std::string jobRole = skillsFileIter.fieldOnRecord("jobRole");
    std::string primarySkill = skillsFileIter.fieldOnRecord("primarySkill");
    std::string skillSet = skillsFileIter.fieldOnRecord("skillGroup");
    float percentage = skillsFileIter.fieldOnRecordAsFloat("percentage");
    
    //check whether or not we have any demand for this jobRole, primarySkill 
    //combination
    std::string name = makeJobRolePrimarySkillName(jobRole,primarySkill);
    if (supplySet.find(name) != supplySet.end()) {
      //get the current flexskillsobject associated with this jobRole/primarySkill
      MapStringToFlexSkillsObjectIterator flexSkillsIt = map.find(name);
      if( flexSkillsIt == map.end() ) {
         //this name is not yet in the map
        FlexSkillsObject obj;
        std::pair<std::vector<std::string>, float> p1;
        std::vector<std::string> g1 = getSkillSet(skillSet);
        p1.first = g1;
        p1.second = percentage;
        obj.push_back(p1);
        map[name] = obj;
         
      }
      else {
        FlexSkillsObject & obj = flexSkillsIt->second;
        std::pair<std::vector<std::string>, float> p1;
        std::vector<std::string> g1 = getSkillSet(skillSet);
        p1.first = g1;
        p1.second = percentage;
        obj.push_back(p1);
        map[name] = obj;
      }
    
    
    }
  }
  return map;
}
std::vector<std::string>  getSkillSet(std::string skillSet) {
  std::vector<std::string> retVal;
  int dividerLoc;
  std::string newone;
  std::string copy = skillSet;
  dividerLoc = copy.find("$#$");
  std::string temp;
  while (dividerLoc != -1) {
      //extract the next token
      std::string next = copy.substr(0,dividerLoc);
      retVal.push_back(next);
      //now take the rest of the string
      int start = dividerLoc + 3;
      int end = copy.size();
      int len = end-start;
      temp = copy.substr(start,len);
      dividerLoc = temp.find("$#$");
      copy = temp;
  }
  retVal.push_back(copy);
  return retVal;
  
  
}



 //learn about which fields are going to allow priority substitution,
//and what the allowed field names are
//without cost and leadtime, for backward compatibility with format 04feb
void readPrioritySubsDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & substitutionFileName
                      )
{
    RCPprioritySubsFile file(substitutionFileName);
    RCPprioritySubsFileIterator fileIter(file);
    
    std::string fromResourceIdValue, toResourceIdValue;
    std::string resourceIdName;
    fromResourceIdValue = "PRIORITY";
    int priority;

    // loop over the records
    //int recNo=0;
    for ( ; fileIter()!=NULL; ) {     
      resourceIdName = fileIter.resourceIdName();
      if ( !prob.resourceIdentifierNameExists(resourceIdName) ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
	     <<"Error: "+resourceIdName+" is not a defined resourceId in globalAttr.csv"   <<std::endl
	     <<"   filename: " << substitutionFileName                                     <<std::endl
         <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      toResourceIdValue = fileIter.resourceIdValue();
      priority = fileIter.priorityAsInt();

     
      // test to ensure that substitute does not already exist
      if ( prob.subsExists(resourceIdName,fromResourceIdValue,toResourceIdValue) ) {
      //  Write warning message
      std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: "+resourceIdName+" substitute already exists"                <<std::endl
        <<"   filename: " << substitutionFileName                        <<std::endl
        <<"   from: " <<fromResourceIdValue.c_str()                                  <<std::endl
        <<"   to: " <<toResourceIdValue.c_str()                                      <<std::endl
        <<"   record will be ignored. "                                    <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      continue;
    }
    
    prob.addSubs(resourceIdName,fromResourceIdValue,toResourceIdValue);
    prob.setSubsAversion(resourceIdName,fromResourceIdValue,toResourceIdValue,priority);
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,(float)priority);
    prob.setSubsLeadTime(resourceIdName,fromResourceIdValue,toResourceIdValue,0.0);
  }
 }
//learn about which fields are going to allow to from substitution,
void readToFromSubsDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & substitutionFileName
                      )
{
    RCPtoFromSubsFile file(substitutionFileName);
    RCPtoFromSubsFileIterator fileIter(file);
    
    std::string fromResourceIdValue, toResourceIdValue;
    std::string resourceIdName;
    int priority;
    float cost;
    float leadTime;
    // loop over the records
    //int recNo=0;
    for ( ; fileIter()!=NULL; ) {     
      resourceIdName = fileIter.resourceIdName();
      if ( !prob.resourceIdentifierNameExists(resourceIdName) ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
	     <<"Error: "+resourceIdName+" is not a defined resourceId in globalAttr.csv"   <<std::endl
	     <<"   filename: " << substitutionFileName                                     <<std::endl
         <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      toResourceIdValue = fileIter.resourceIdToValue();
      fromResourceIdValue = fileIter.resourceIdFromValue();
      priority = fileIter.priorityAsInt();  //DLG check these values
      cost = fileIter.costAsFloat();
      leadTime = fileIter.leadTimeAsFloat();
     
      // test to ensure that substitute does not already exist
      if ( prob.subsExists(resourceIdName,fromResourceIdValue,toResourceIdValue) ) {
      //  Write warning message
      std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: "+resourceIdName+" substitute already exists"                <<std::endl
        <<"   filename: " << substitutionFileName                        <<std::endl
        <<"   from: " <<fromResourceIdValue.c_str()                                  <<std::endl
        <<"   to: " <<toResourceIdValue.c_str()                                      <<std::endl
        <<"   record will be ignored. "                                    <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      continue;
    }
    
    prob.addSubs(resourceIdName,fromResourceIdValue,toResourceIdValue);
    prob.setSubsAversion(resourceIdName,fromResourceIdValue,toResourceIdValue,priority);
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,cost);
    prob.setSubsLeadTime(resourceIdName,fromResourceIdValue,toResourceIdValue,leadTime);
  }
 }

// read the resource ID priorities
void readResourceIdPriorityDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & resourceIdPriorityFileName
                      )
{
    RCPresourceIdPriorityFile file(resourceIdPriorityFileName);
    RCPresourceIdPriorityFileIterator fileIter(file);
    
    std::string resourceIdName;
    int priority;
    // loop over the records
    //int recNo=0;
    for ( ; fileIter()!=NULL; ) {     
      resourceIdName = fileIter.resourceIdName();
      priority = fileIter.priorityAsInt();  //DLG check this value
     
      // test to ensure that the resource ID name exists
      if ( !prob.resourceIdentifierNameExists(resourceIdName) ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
	     <<"Error: "+resourceIdName+" is not a defined resourceId in globalAttr.csv"   <<std::endl
	     <<"   filename: " << resourceIdPriorityFileName                                     <<std::endl
         <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }

      // test to ensure that the resource priority is no greater than 1 million
      if ( priority > 1000000) {
	    //  Write warning message
	    std::cout 
	      <<"-------------------------------------------------------"        <<std::endl
	      <<"Warning: " +resourceIdName+ "'s priority:"<<priority <<" is too large"                <<std::endl
	      <<"The priority will be truncated to 1000000"                      <<std::endl
	      <<"   filename: " << resourceIdPriorityFileName                        <<std::endl
	      <<"-------------------------------------------------------"        <<std::endl;
	      priority = 1000000;
      }
      prob.setResourceIdentifierPriority(resourceIdName,priority);
    }
}



void populate(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              RcpOptCalendar & rcpCal) 
{

   

    // Get number of periods
    std::string globalAttrFileName = idir + "/globalAttr.csv";
    RCPglobalAttrFile globalAttrFile(globalAttrFileName);
    int nPeriods=globalAttrFile.fieldAsInt("nPeriods","attrValue");
    if (nPeriods < 1) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  nPeriods in globalAttr.csv is less than 1"                         <<std::endl
            <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
    }

    std::string fileFormat = globalAttrFile.fieldAsString("fileFormat","attrValue");
    std::string theAlg = globalAttrFile.fieldAsString("algorithm","attrValue");
    std::string theProb = globalAttrFile.fieldAsString("problem","attrValue");
    std::string resourceFileName = "resource.csv";
    if ( globalAttrFile.keyExists("resourceFileName") ) {
       resourceFileName = globalAttrFile.fieldAsString("resourceFileName","attrValue");
    }
    std::string bomFileName = "bom.csv";
    if ( globalAttrFile.keyExists("bomFileName") ) {
       bomFileName = globalAttrFile.fieldAsString("bomFileName","attrValue");
    }

    // Get the calendar type
    RcpOptCalendar::CalendarType calendarType = RcpOptCalendar::PERIOD;
    rcpCal.setCalendarType(calendarType);
    
    if ( globalAttrFile.keyExists("calendarType") ) {
      std::string ct = globalAttrFile.fieldAsString("calendarType","attrValue");
      if ( ct=="period" )
        calendarType = RcpOptCalendar::PERIOD;
      else if ( ct=="monthYear" )  {     
        calendarType = RcpOptCalendar::MONTH_YEAR;
        rcpCal.setCalendarType(calendarType);
      
        // need to get the starting month and year
        int startmonth, startyear;
        if (globalAttrFile.keyExists("startMonth"))
            startmonth = globalAttrFile.fieldAsInt("startMonth","attrValue");
        else {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  calendarType specified as monthYear"                               <<std::endl
            <<"   globalAttr filename: " <<globalAttrFile.filename()                      <<std::endl
            <<"   but no startMonth specified "                                           <<std::endl                             <<std::endl
            <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
        }
        rcpCal.setStartMonth(startmonth);
        if (globalAttrFile.keyExists("startYear"))
            startyear = globalAttrFile.fieldAsInt("startYear","attrValue");
        else {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error:  calendarType specified as monthYear"                                 <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename()                        <<std::endl
          <<"   but no startYear specified "                                              <<std::endl
          <<"   startYear assumed to be 2004 "                                            <<std::endl
          <<"-------------------------------------------------------"                     <<std::endl;
          throw ( RcpOptException(msgStream.str()) );
        }
        rcpCal.setStartYear(startyear);
      }
      else {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: unknown calendarType specified."                                   <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename()                     <<std::endl
          <<"   calendarType specified: " <<ct                                         <<std::endl
          <<"   allowed values: period monthYear"                                      <<std::endl                                 <<std::endl
           <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
    }
    if ((theAlg=="priorityPlan")&&(theProb=="resourceAction")) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  unsupported combination: priorityPlan/resourceAction"              <<std::endl
            <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
    }
    
    prob.setAlgorithmName(theAlg);
    prob.setProblemName(theProb);
    prob.setFormatName(fileFormat);
    
    // Check the name of the problem
    if ( theProb!="resourceAction" && theProb!="gapGlut" ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: unknown problem specified."                                       <<std::endl
        <<"   globalAttr filename: " <<globalAttrFile.filename()                    <<std::endl
        <<"   problem specified: " <<theProb                                        <<std::endl
        <<"   allowed values: resourceAction gapGlut"                               <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
     }
    
    // Check the name of the algorithm to be used
    
    if ( theAlg!="optimalPlan" && theAlg!="priorityPlan" ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
       <<"Error: unknown algorithm specified."                        <<std::endl
        <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
        <<"   algorithm specified: " <<theAlg                            <<std::endl
        <<"   allowed values: optimalPlan priorityPlan"                  <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
    
    
    
    if ( fileFormat!="03Dec" &&  fileFormat!="04Feb" && fileFormat!="FlexMix" && fileFormat!="DemandEngagement" && fileFormat!="NASCO") {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: unknown fileFormat specified."                       <<std::endl
        <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
        <<"   fileFormat specified: " <<fileFormat                       <<std::endl
        <<"   allowed values: 03Dec 04Feb FlexMix DemandEngagement NASCO"                               <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }  
    //format 04feb does not support optimal
    if ((fileFormat=="04Feb")&&(theAlg=="optimalPlan")) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: unsupported algorithm for 04Feb format: optimalPlan"   <<std::endl
        <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }  
    
    
    //initialize the fields
    char name[100];
    int numResourceIds = globalAttrFile.fieldAsInt("nResourceIds","attrValue");
    if (numResourceIds < 1) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  nResourceIds in globalAttr.csv is less than 1"                               <<std::endl
             <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
    }
    

      
    for (int j=0; j<numResourceIds; j++) {
        sprintf(name,"resourceId%d",j);
        std::string attr = globalAttrFile.fieldAsString(name,"attrValue");
        prob.addResourceIdentifierName(attr);
    }
    //check for resourceIdPriority 
    bool rIdPriority;
    if (globalAttrFile.keyExists("resourceIdPriority")) {
        std::string resourceIdPriority = globalAttrFile.fieldAsString("resourceIdPriority","attrValue");
        if (resourceIdPriority =="no") 
        rIdPriority = false;
        else if (resourceIdPriority =="yes") 
        rIdPriority = true;
        else {
        std::ostringstream msgStream;
        msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: resourceIdPriority value must be yes or no"             <<std::endl
            <<"-------------------------------------------------------"                 <<std::endl;
        throw ( RcpOptException(msgStream.str()) );
        }
    }
    else
      rIdPriority=false;

    if (fileFormat=="DemandEngagement") {
      populateDemandEngagement(prob, idir, odir,nPeriods,rcpCal);
    }
    else if (fileFormat=="NASCO") {
    
        //check for onlyPrimary 
        bool considerMultSkills;
        if (globalAttrFile.keyExists("considerMultSkills")) {
            std::string considerMultSkillsStr = globalAttrFile.fieldAsString("considerMultSkills","attrValue");
            if (considerMultSkillsStr =="no") 
              considerMultSkills = false;
            else if (considerMultSkillsStr =="yes") 
              considerMultSkills = true;
            else {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
                <<"Error: considerMultSkills value must be yes or no"             <<std::endl
                <<"-------------------------------------------------------"                 <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
            }
        }
        else
            considerMultSkills=false;      
        populateNASCO(prob,idir,odir,nPeriods,rcpCal,considerMultSkills);
        }
    else if (fileFormat=="03Dec") {
	   //this is for the "portfolio" option (only one of a family of projects gets done)
	   bool portfolio;
	   if (!globalAttrFile.keyExists("portfolio") )
		   portfolio = false;
	   else {
		   std::string portFlag = globalAttrFile.fieldAsString("portfolio","attrValue");
		   if (portFlag == "no")
			   portfolio = false;
		   else if (portFlag == "yes")
			   portfolio = true;
		   else {
			 std::ostringstream msgStream;
             msgStream <<"-------------------------------------------------------"         <<std::endl
             <<"Error: portfolio value in globalAttr.csv must be yes or no"             <<std::endl
             <<"-------------------------------------------------------"                 <<std::endl;
             throw ( RcpOptException(msgStream.str()) );
		   }
	   }

       //the following determines whether substitution is on a line by line or global
       //basis
       bool globalSubstitution;
       //hasResourceCosts is only relevant for optimalPlan.
       bool hasResourceCosts;
       if (theAlg=="optimalPlan") 
         hasResourceCosts = true;
       else
         hasResourceCosts = false;

       
       if (!globalAttrFile.keyExists("globalSubstitution"))
         globalSubstitution = false;
       else {
          std::string subsFlag = globalAttrFile.fieldAsString("globalSubstitution","attrValue");
          if (subsFlag == "no")
             globalSubstitution = false;
          else if (subsFlag == "yes")
             globalSubstitution = true;
          else {
             std::ostringstream msgStream;
             msgStream <<"-------------------------------------------------------"         <<std::endl
             <<"Error: globalSubstitution value in globalAttr.csv must be yes or no"             <<std::endl
             <<"-------------------------------------------------------"                 <<std::endl;
             throw ( RcpOptException(msgStream.str()) );
          }
       }
       
       std::string toFromSubs = globalAttrFile.fieldAsString("toFromSubs","attrValue");
       bool tfSubs;
       if (toFromSubs =="no") 
         tfSubs = false;
       else if (toFromSubs =="yes") 
         tfSubs = true;
       else {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: toFromSubs value in globalAttr.csv must be yes or no"                     <<std::endl
         <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }
      bool isGapGlut = false;
      if (theProb=="gapGlut")
        isGapGlut=true;
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods, tfSubs, globalSubstitution, rIdPriority, rcpCal, hasResourceCosts,isGapGlut,portfolio);
    }  
    else if (fileFormat=="FlexMix") {
       bool pSubs;
       if (theAlg=="priorityPlan") 
           pSubs = true;
       else 
           pSubs = false;
       bool isGapGlut = true;
       if (theProb!="gapGlut") {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: FlexMix format supports only GapGlut model"                               <<std::endl
         <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) ); 

       }
       //resourceIDpriority???
 
      populateFlexMix(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs, rIdPriority, rcpCal);    
    }
    else {
       //check for priority substitution; this is necessary to coallesce two formats including an older one
       std::string prioritySubs = globalAttrFile.fieldAsString("prioritySubs","attrValue");
       bool pSubs;
       if (prioritySubs =="no") 
          pSubs = false;
       else if (prioritySubs =="yes") 
          pSubs = true;
       else {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: prioritySubstitution value in globalAttr.csv must be yes or no"           <<std::endl
         <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }
      bool isGapGlut = false;
      if (theProb=="gapGlut")
        isGapGlut=true;
      
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs, rIdPriority, rcpCal,isGapGlut);
    }
  //}
  //catch ( SCOexception e ) {
  //  std::cout <<e.what() <<std::endl;
  //}
 }
 
void populate03Dec(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              const std::string & rFileName,
              const std::string & bFileName,
              int   nPeriods,
              bool  toFromSubs,
              bool  globalSubstitution,
	          bool  resourceIdPriority,
              RcpOptCalendar & rcpCal,
              bool hasResourceCosts,
              bool isGapGlut,
			  bool portfolio) 
{
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  int numidentifiers = prob.getResourceIdentifierNames().size();

  //read portfolio file if necessary
  {
	  if (portfolio) {
		// Read engagement File and set up structures for using data
		  std::string engagementFamilyFileName = idir + "/engagementFamily.csv";
		  RCPengagementFamilyFile engagementFamilyFile(engagementFamilyFileName);
		  RCPengagementFamilyFileIterator engagementFamilyFileIter(engagementFamilyFile);
    
		 // loop once for each record in engagementFamily file
		 for ( ; engagementFamilyFileIter()!=NULL; ) {
			 std::string engagementFamilyName = engagementFamilyFileIter.engagementFamilyName();
			 prob.addEngagementFamily(engagementFamilyName);
		 }
	  }
  }

  //---------------------------------------------------------
  // Read engagement file
  //---------------------------------------------------------
  {
    // Read engagement File and set up structures for using data
    std::string engagementFileName = idir + "/engagement.csv";
    RCPengagementFile engagementFile(engagementFileName,rcpCal.getCalendarType(),portfolio);
    RCPengagementFileIterator engagementFileIter(engagementFile);
    
    // loop once for each record in engagement file
    for ( ; engagementFileIter()!=NULL; ) {
      std::string engagementName = engagementFileIter.engagementName();
      float revenue = engagementFileIter.revenueAsFloat(); //DLG check for negative revenue
      
      int startPeriod;
      if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
         startPeriod = engagementFileIter.startPeriodAsInt();
      else {
         startPeriod = rcpCal.computePeriodFromMonthAndYear(engagementFileIter.startMonthAsInt(), engagementFileIter.startYearAsInt());
      }   
	  std::string familyName;
	  if (portfolio) {
		  familyName = engagementFileIter.family();
		  bool engFamilyExists = prob.engagementFamilyExists(familyName);
		  if (!engFamilyExists) {
			std::ostringstream msgStream;
			msgStream <<"-------------------------------------------------------"         <<std::endl
			<<"Error: engagementFamily does not exist in engagementFamily.csv"  <<std::endl
			<<"   engagementFamily: " <<familyName <<std::endl
			<<"   engagement filename: " <<engagementFile.filename().c_str()         <<std::endl
			<<"   engagement file line number: " <<engagementFileIter.recNum()            <<std::endl
			<<"   engagementName: " <<engagementName.c_str()                              <<std::endl                              <<std::endl
			<<"-------------------------------------------------------"                   <<std::endl;
			throw ( RcpOptException(msgStream.str()) );
		  }

	  }
      
      
      //int duration =  engagementFileIter.durationAsInt();
      int lateAllowance = engagementFileIter.lateAllowanceAsInt();
      int priority = engagementFileIter.priorityAsInt();  //should we check < 1? DLG
      float quantity = engagementFileIter.quantityAsFloat();
      // test to ensure quantity is non-negative
      if (quantity < 0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: quantity is negative"                                               <<std::endl
         <<"   engagement filename: " <<engagementFile.filename().c_str()              <<std::endl
         <<"   engagement file line number: " <<engagementFileIter.recNum()            <<std::endl
         <<"   engagementName: " <<engagementName.c_str()                              <<std::endl                              <<std::endl
         <<"   quantity will be set to zero. "                                         <<std::endl
         <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }

      // test to ensure startPeriod is within the planning horizon
      if ( startPeriod <0 || startPeriod >= nPeriods ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: startPeriod is beyond planning horizion"                <<std::endl
          <<"   engagement filename: " <<engagementFile.filename().c_str()    <<std::endl
          <<"   engagement file line number: " <<engagementFileIter.recNum()  <<std::endl
          <<"   engagementName: " <<engagementName.c_str()                    <<std::endl
          <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      //test to see that the engagement does not already exist
      if ( prob.engagementExists(engagementName)) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: engagement already exists"                                <<std::endl
          <<"   engagement filename: " <<engagementFile.filename().c_str()    <<std::endl
          <<"   engagement file line number: " <<engagementFileIter.recNum()  <<std::endl
          <<"   engagementName: " <<engagementName.c_str()                    <<std::endl
          <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }


       prob.addEngagement(engagementName);
       prob.setEngagementRevenue(engagementName,revenue);
       prob.setEngagementStartPeriod(engagementName,startPeriod);
       //prob.setEngagementDuration(engagementName,duration);
       prob.setEngagementLateAllowance(engagementName,lateAllowance);
       prob.setEngagementPriority(engagementName,priority);
       prob.setEngagementQuantity(engagementName,quantity);

	   if (portfolio) 
		   prob.setEngagementFamily(engagementName,familyName);

    }
  }
  //---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------

  
  std::vector<int> globalMatchVector(numidentifiers);
  std::vector<int> subVector(numidentifiers);
  std::vector<int> localMatchVector(numidentifiers);

  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPgnrlMatchFile matchFile(matchFileName,prob.getResourceIdentifierNames().size());
    RCPgnrlMatchFileIterator matchFileIter(matchFile);
    matchFileIter(); 
    

    for (int i=0; i<numidentifiers; i++) {
       std::string attributeMatchName = prob.getResourceIdentifierNames()[i]+"Match";
       int matchValue = matchFileIter.fieldOnRecordAsInt(attributeMatchName);
       if ((matchValue < 0) || (matchValue > 1)) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  matchValue must be 0 or 1"                                         <<std::endl
            <<"   filename: match.csv"                                                    <<std::endl
            <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
        }

       globalMatchVector[i] = matchValue;
    }
        
  }  
  
  //---------------------------------------------------------
  // If it is global substitution, read the substitution file
  //---------------------------------------------------------

  
  std::vector<int> globalSubstituteVector(numidentifiers);
  //std::vector<int> subVector(numidentifiers);
  //std::vector<int> localMatchVector(numidentifiers);

  if (globalSubstitution)
  {
    // Read substitute File; has same structure as match file
    std::string subsFileName = idir + "/substitute.csv";
    RCPgnrlMatchFile subsFile(subsFileName,prob.getResourceIdentifierNames().size());
    RCPgnrlMatchFileIterator subsFileIter(subsFile);
    subsFileIter(); 
    

    for (int i=0; i<numidentifiers; i++) {
       std::string attributeSubsName = prob.getResourceIdentifierNames()[i]+"Subs";
       int subsValue = subsFileIter.fieldOnRecordAsInt(attributeSubsName);
       if ((subsValue < 0) || (subsValue > 1)) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error:  subsValue must be 0 or 1"                                         <<std::endl
            <<"   filename: substitute.csv"                                                    <<std::endl
            <<"-------------------------------------------------------"                   <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
        }

       globalSubstituteVector[i] = subsValue;
    }
        
  }  
  
    
  
  //---------------------------------------------------------
  // Read to-from priority substitution file. 
  //---------------------------------------------------------
  if (toFromSubs) {
    std::string subsfile = idir+"/toFromSubs.csv";
    readToFromSubsDescriptionFile(prob,subsfile);
  }
  

  



  
  //---------------------------------------------------------
  // Read resource ID priority file. This simply defines which
  // priorities for the resource IDs.
  //---------------------------------------------------------
  if (resourceIdPriority) {
    std::string resourceIdPriorityFile = idir+"/idPriority.csv";
    readResourceIdPriorityDescriptionFile(prob,resourceIdPriorityFile);
  }
  
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/"+rFileName.c_str();
    std::vector<int> matchFlags;
    readResourceFile(prob,resourceFileName,hasResourceCosts,isGapGlut, matchFlags,rcpCal);

   }

  
    
  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read bom File and set up structures for using data
    std::string bomFileName = idir + "/"+bFileName.c_str();
    RCPgnrlBomFile bomFile(bomFileName,numidentifiers,true, !globalSubstitution, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    std::vector<std::string> resourceAttributeValues(numidentifiers);
    // loop once for each record in bom file
    for ( ; bomFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      for (int ii=0; ii<numidentifiers; ii++)
         localMatchVector[ii] = 1;
      
      
      for (int j=0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);
         
         if (globalMatchVector[j]==0)
             attributeValue = "unmatched";
         std::string substitutename = attributeName+"Sub";
         
         int value;
         if (globalSubstitution)
            value = globalSubstituteVector[j];
         else {
            value = bomFileIter.fieldOnRecordAsInt(substitutename);
            if ((value < 0) || (value > 1)) {
                std::ostringstream msgStream;
                msgStream <<"-------------------------------------------------------"         <<std::endl
                <<"Error:  matchValue must be 0 or 1"                                         <<std::endl
                <<"   filename: " + bomFileName                                               <<std::endl
                <<"   file line number: " <<bomFileIter.recNum()                              <<std::endl            
                <<"-------------------------------------------------------"                   <<std::endl;
                throw ( RcpOptException(msgStream.str()) );
            }  
         }
            
         if ((attributeValue=="PRIORITY")) {
           subVector[j]=1;
         }
         else if ((attributeValue=="UNSPECIFIED")) {
           localMatchVector[j]=0; //overwrite the match value with 0 for this bom entry
           subVector[j]=0;
         }
         else 
           subVector[j]=value;
           
         resourceAttributeValues[j]=attributeValue;
      }
      
      std::string engagementName = bomFileIter.fieldOnRecord("engagementName");
      int period;
      if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD) 
         period = bomFileIter.periodAsInt();
      else {
         period = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      }      
      
      // test to ensure period is within the planning horizon
      if ( period <0 || period >= nPeriods ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: period is beyond planning horizion"                     <<std::endl
         <<"   filename: " <<bomFileName                                   <<std::endl
         <<"   file line number: " <<bomFileIter.recNum()                  <<std::endl            
         <<"-------------------------------------------------------"                   <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      } 
  
      // test to ensure that engagement exist
      if ( !prob.engagementExists(engagementName) ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: Engagement does not exist"                                         <<std::endl
          <<"   filename: " <<bomFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<bomFileIter.recNum()                             <<std::endl
          <<"   engagement: " <<engagementName.c_str()                                 <<std::endl
          <<"   period: " <<period                                                     <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. add it.

         prob.addResource(resourceAttributeValues);
         float infeasibletime = 10.f*nPeriods;
         //this will serve to make it infeasible to acquire the phantom resource
         if (!isGapGlut) 
            prob.setResourceAcquireTime(resourceAttributeValues,infeasibletime);

         float largeCost = 1e10;
         prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
       }
      
      // test to ensure period is within the planning horizon
      if ( period < 0 || period >= nPeriods ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: period is beyond planning horizion"                                <<std::endl
          <<"   filename: " <<bomFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<bomFileIter.recNum()                             <<std::endl
          <<"   engagement: " <<engagementName.c_str()                                 <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }

      int i;

      
      // test to ensure that each sub has a valid value
      int resourceSub;
      for (i=0; i<numidentifiers; i++) {
         resourceSub=subVector[i];
         if ( resourceSub < 0 || resourceSub > 1 ) {
           std::string subString =  prob.getResourceIdentifierNames()[i]+"Sub";
           std::ostringstream msgStream;
           msgStream <<"-------------------------------------------------------"         <<std::endl
             <<"Error: substitution value out of bounds"                              <<std::endl
             <<"   filename: " <<bomFile.filename().c_str()                  <<std::endl
             <<"   file line number: " <<bomFileIter.recNum()                <<std::endl
             <<"   engagement: " <<engagementName.c_str()                        <<std::endl
             <<"   subFlag: " <<     subString                                   <<std::endl
             <<"   valid range: 0 <= subString  <= 1"                            <<std::endl
             <<"-------------------------------------------------------"                   <<std::endl;
           throw ( RcpOptException(msgStream.str()) );
          }
      }
 
      if ( !prob.bomExists(engagementName,resourceAttributeValues) )
         prob.addBom(engagementName,resourceAttributeValues);
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
      // test to ensure quantity is non-negative
      if ( usageQuantity < 0.0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: quantity is less than zero"                                         <<std::endl
          <<"   filename: " <<bomFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<bomFileIter.recNum()                             <<std::endl
          <<"   engagement: " <<engagementName.c_str()                                 <<std::endl
          <<"   period: " <<period                                                     <<std::endl
          <<"   quantity will be set to 0. "                                           <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }

      //get prior usageQuantity
      float priorUsageQuantity = prob.getBomUsageQuantity(engagementName, resourceAttributeValues,period);
      usageQuantity=usageQuantity+priorUsageQuantity;
      prob.setBomUsageQuantity(engagementName,resourceAttributeValues,period,usageQuantity);


      prob.setBomUsageQuantity(engagementName,resourceAttributeValues,period,usageQuantity);
      for (i=0; i<numidentifiers; i++) {
         std::string resourceIdName = prob.getResourceIdentifierNames()[i];
         prob.setBomMatch(engagementName, resourceAttributeValues, period, resourceIdName, localMatchVector[i]);
         prob.setBomSub(engagementName,resourceAttributeValues,period,resourceIdName,subVector[i]);
      }
    }
    
  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
  if (hasResourceCosts)
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resourceaction.csv";
    RCPgnrlResourceActionFile resourceActionFile(resourceFileName,numidentifiers);
    RCPgnrlResourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      resourceIdValues.clear();
      for (int j =0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = resourceActionFileIter.fieldOnRecord(attributeName);
         resourceIdValues.push_back(attributeValue);
      }
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat(); //check for negative values DLG
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();

      // test to ensure that resource exists
      if ( !prob.resourceExists(resourceIdValues) ) {
         //add it with zero supply
         prob.addResource(resourceIdValues);
      }
 
      prob.setResourceAcquireTime(resourceIdValues,acquireTime);
      prob.setResourceAcquireCost(resourceIdValues,acquireCost);
      prob.setResourceReleaseTime(resourceIdValues,releaseTime);
      prob.setResourceReleaseCost(resourceIdValues,releaseCost);
      // finish building resource model now that all the resource action data is available
      prob.addReleaseLeadtimeStructure(resourceIdValues);
    }
  }

}
}
void populateDemandEngagement(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              int   nPeriods, RcpOptCalendar & rcpCal) 
{
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  int numidentifiers = prob.getResourceIdentifierNames().size();


 
  
 
 //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/supply.csv";
    
    int nPeriods = prob.getNPeriods();  
    float infeasibleAcquireTime = 10.f*nPeriods;
    int numAttributes = prob.getResourceIdentifierNames().size();  
    RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,false,rcpCal.getCalendarType());
    RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
  
    // loop once for each record in resource file
  
    int foo=1;
    std::vector<std::string> resourceAttributeValues(numAttributes);
    for ( ; resourceFileIter()!=NULL; ) {

    for (int j=0; j<numAttributes; j++) {
      std::string attributeName = prob.getResourceIdentifierNames()[j];
      std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
      resourceAttributeValues[j]=attributeValue;
    }
    int period;
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
       period = resourceFileIter.periodAsInt();
    else {
       period = rcpCal.computePeriodFromMonthAndYear(resourceFileIter.monthAsInt(), resourceFileIter.yearAsInt());
    }
    float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
    // test to ensure quantity is non-negative
    if ( supplyQuantity < 0) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"   Error: supplyQuantity is negative"                                    <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()                <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()              <<std::endl            
        <<"   period: " <<period                                                    <<std::endl                          <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }

    // test to ensure period is within the planning horizon
    if ( period <0 || period >= nPeriods ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: period is beyond planning horizion"                               <<std::endl
        <<"   filename: " <<resourceFile.filename().c_str()                         <<std::endl
        <<"   file line number: " <<resourceFileIter.recNum()                       <<std::endl            
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
    
    
    if (!prob.workingResourceExists(resourceAttributeValues)) {
      prob.addSimpleResource(resourceAttributeValues);
      
    }

    float * priorQuantity = prob.getSimpleResourceSupplyQuantity(resourceAttributeValues);
    priorQuantity[period] = priorQuantity[period]+supplyQuantity;
    prob.setSimpleResourceSupplyQuantity(resourceAttributeValues,priorQuantity);
    delete [] priorQuantity;
 
    }
  } 
 }
 void populateNASCO(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              int   nPeriods, RcpOptCalendar & rcpCal,
              bool considerMultSkills) 
{
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  int numidentifiers = prob.getResourceIdentifierNames().size();

  //overall process:
  //First read the "project" file. This describes properties of
  //the projects (name of project, desired start time, flexible, mustDo, etc.)
  //This process performs "addEngagement" for the named
  //project (engagement). This in turn does the following:
  //adds the "engagement part", the demand, the operation to make the
  //engagement part, and the bop.
  //then set some attributes on the engagement: mustDo, lateAllowance, desired period
  
  //Next read the "demand" file, which describes the bill of resources for each
  //project. The project should have been defined by this point
  //As each resource is seen, a "working" part along with an acquire of that 
  //part is added. I'm assuming that they may wish to define the periods in
  //absolute periods, thus we will have to convert from absolute to relative
  //(using the "desired" period as a point of reference) before adding the
  //boms for the "project operation"
  
  //Next the various files associated with supply must be read. NOT DONE YET


  //do the project file
  //For NASCO this must be done before the engagement (demand) file
  //so that we can convert from absolute to relative periods
  {
    std::string demandFileName = idir + "/project.csv";
    bool hasFlexibleFlag=true, hasRequiredFlag=true;
    RCPdemandEngagementFile demandFile(demandFileName,hasRequiredFlag, hasFlexibleFlag, rcpCal.getCalendarType());
    RCPdemandEngagementFileIterator demandEngagementFileIter(demandFile);
    
    for ( ; demandEngagementFileIter()!=NULL; ) {
         std::string engagementName = demandEngagementFileIter.engagement();
         int period;
         if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            period = demandEngagementFileIter.periodAsInt();
         else {
            period = rcpCal.computePeriodFromMonthAndYear(demandEngagementFileIter.monthAsInt(), demandEngagementFileIter.yearAsInt());
         }
         char periodchar[100];
         sprintf( periodchar, "%d", period );
         float quantity = demandEngagementFileIter.usageQuantityAsFloat();
         int isFlexible = demandEngagementFileIter.fieldOnRecordAsInt("flexible");
         int mustDo = demandEngagementFileIter.fieldOnRecordAsInt("mustDo");
         prob.addEngagement(engagementName);
         //STILL need to add the isFlexible and mustDo information
         prob.setEngagementStartPeriod(engagementName,period);
         prob.setEngagementQuantity(engagementName,quantity);
         if (isFlexible>nPeriods-1) isFlexible=nPeriods-1;
         prob.setEngagementLateAllowance(engagementName,isFlexible);
         prob.setEngagementMustDo(engagementName,mustDo);

    }
  }

  float infeasibleAcquireTime = 10.*nPeriods;
  
  //---------------------------------------------------------
  // Read demand files
  // These files define the resources used by each project
  // They are separated into "new" and "ongoing" because of
  // some different attributes of each
  //---------------------------------------------------------
  {
    std::string bomFileName = idir + "/newdemand.csv";
    RCPgnrlBomFile bomFile(bomFileName,numidentifiers,true, false, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    std::vector<std::string> resourceAttributeValues(numidentifiers);
    // loop once for each record in bom file
    for ( ; bomFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      for (int j=0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);           
         resourceAttributeValues[j]=attributeValue;
      }
      
      // note "engagementName" is integral to the gnrlBom file, so I have
      // left it thus. If necessary we could preprocess to change "projectName"
      // to "engagementName"
      std::string engagementName = bomFileIter.fieldOnRecord("engagementName");
      if (!prob.engagementExists(engagementName)) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
           <<"   Error: project (engagement) in demand.csv not defined in project.csv "                                    <<std::endl
           <<"   project: " <<engagementName.c_str()           <<std::endl
           <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );    
      }

      int period; 
      
      //new demands get lower priority (default) than ongoing demands
      //thus do nothing here
      
      // for NASCO they may want to give absolute periods, and to create
      // relative we would have to do the difference from the "desired"
      // period. NEED TO CONVERT TO RELATIVE
      int absperiod = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      
      int desiredStartPeriod = prob.getEngagementRequestedStartPeriod(engagementName);
      period = absperiod-desiredStartPeriod;
      if (period<0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
           <<"   Error: project requests resources before project start "              <<std::endl
           <<"   project: " <<engagementName.c_str()                                   <<std::endl
           <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );    
      }      
      
      // test to ensure that resource exist
      // addSimpleResource adds a working part and an acquire operation
      if (!prob.workingResourceExists(resourceAttributeValues)) {
           prob.addSimpleResource(resourceAttributeValues);       
           prob.setSimpleResourceAcquireAppData(resourceAttributeValues,infeasibleAcquireTime);
           prob.setSimpleResourceAcquireAversion(resourceAttributeValues,1);
      }
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
      int mustDo = prob.getEngagementMustDo(engagementName);
      prob.updateEngagementBom(engagementName,resourceAttributeValues,period, usageQuantity, mustDo);
      
      // test to ensure quantity is non-negative
      if ( usageQuantity < 0.0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: quantity is less than zero"                                         <<std::endl
          <<"   filename: " <<bomFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<bomFileIter.recNum()                             <<std::endl
          <<"   engagement: " <<engagementName.c_str()                                 <<std::endl
          <<"   period: " <<period                                                     <<std::endl
          <<"   quantity will be set to 0. "                                           <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
    }
  }
  {
    std::string bomFileName = idir + "/ongoingdemand.csv";
    RCPgnrlBomFile bomFile(bomFileName,numidentifiers,true, false, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    std::vector<std::string> resourceAttributeValues(numidentifiers);
    // loop once for each record in bom file
    for ( ; bomFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      for (int j=0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);           
         resourceAttributeValues[j]=attributeValue;
      }
      
      // note "engagementName" is integral to the gnrlBom file, so I have
      // left it thus. If necessary we could preprocess to change "projectName"
      // to "engagementName"
      std::string engagementName = bomFileIter.fieldOnRecord("engagementName");
      
      //for the case of ongoing demand, it won't already have been defined, so
      //we need to add it
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         //STILL need to add the isFlexible and mustDo information
         prob.setEngagementStartPeriod(engagementName,0);
         prob.setEngagementQuantity(engagementName,1.0);
         
         //cannot be done late
         prob.setEngagementLateAllowance(engagementName,0);
         //ongoing demand has higher priority than new work
         prob.setEngagementPriority(engagementName,1);

         //these are not used at the moment
         int mustDo = 1;
         int isFlexible = 0;
      }

      int period; 
      
      // for NASCO they may want to give absolute periods.
      // because these are ongoing demand, the relative period is simply
      // the period from now (or the absperiod).
      int absperiod = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      
      int desiredStartPeriod = 0;
      period = absperiod-desiredStartPeriod;
      if (period<0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
           <<"   Error: project requests resources before project start "              <<std::endl
           <<"   project: " <<engagementName.c_str()                                   <<std::endl
           <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );    
      }      
      
      // test to ensure that resource exist
      // addSimpleResource adds a working part and an acquire operation
      if (!prob.workingResourceExists(resourceAttributeValues)) {
           prob.addSimpleResource(resourceAttributeValues);
           prob.setSimpleResourceAcquireAppData(resourceAttributeValues,infeasibleAcquireTime);
           prob.setSimpleResourceAcquireAversion(resourceAttributeValues,1);
      }

      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
      int mustDo=1;
      prob.updateEngagementBom(engagementName,resourceAttributeValues,period, usageQuantity,mustDo);
      // test to ensure quantity is non-negative
      if ( usageQuantity < 0.0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: quantity is less than zero"                                         <<std::endl
          <<"   filename: " <<bomFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<bomFileIter.recNum()                             <<std::endl
          <<"   engagement: " <<engagementName.c_str()                                 <<std::endl
          <<"   period: " <<period                                                     <<std::endl
          <<"   quantity will be set to 0. "                                           <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
  }
  }

 
  
  std::map<std::string,std::vector<std::string> >  mapNameToSkills;
  std::map<std::string,std::vector<std::vector<std::string> > > mapNameToMultipleSkills;
  std::vector<std::string> peopleNames;
  //---------------------------------------------------------
  // Read resource (supply) files this will need to be done
  // explicitly for NASCO
  //---------------------------------------------------------
  {
    //the first file we read is one that specifies the resource names,
    //their system and skill levels, and whether or not the skill is primary.
    //For the first iteration, we will only consider primary skills.
    std::string supplyFileName = idir + "/supply.csv";
    RCPnascoSupplyFile supplyFile(supplyFileName,numidentifiers);
    RCPnascoSupplyFileIterator supplyFileIter(supplyFile);
    
    std::vector<std::string> resourceAttributeValues(numidentifiers);
    // loop once for each record in supply file
    for ( ; supplyFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      for (int j=0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = supplyFileIter.fieldOnRecord(attributeName);           
         resourceAttributeValues[j]=attributeValue;
      }
      
      //get the name, and primary
      std::string name = supplyFileIter.fieldOnRecord("name");
      int primary = supplyFileIter.fieldOnRecordAsInt("primary");
      

      //add this new "skill description" (system + level) to the 
      //set for this employee
      //first, does this employee have any skills defined yet?
      if (mapNameToMultipleSkills.find(name) == mapNameToMultipleSkills.end()) {
         peopleNames.push_back(name);
         std::vector<std::vector<std::string> > skillSets;
         skillSets.push_back(resourceAttributeValues);
         mapNameToMultipleSkills[name]=skillSets;
      }
      else {
         std::vector<std::vector<std::string> > skillSets = mapNameToMultipleSkills[name];
         skillSets.push_back(resourceAttributeValues);
         mapNameToMultipleSkills[name]=skillSets;
      }
      //check that we haven't seen this person with another primary
      //skill before
      if (primary && (mapNameToSkills.find(name) != mapNameToSkills.end())) {
                std::ostringstream msgStream;
                msgStream <<"-------------------------------------------------------"         <<std::endl
                <<"Error: person cannot have more than one primary skill"                                         <<std::endl
                <<"   filename: " <<supplyFile.filename().c_str()                               <<std::endl
                <<"   file line number: " <<supplyFileIter.recNum()                             <<std::endl
                <<"   name: " <<name.c_str()                                 <<std::endl
                <<std::endl
                <<"-------------------------------------------------------"                  <<std::endl;
                throw ( RcpOptException(msgStream.str()) );           
       }
      
      //create a map of name to (primary) resourceAttributeValues
      if (!considerMultSkills && primary) {
         mapNameToSkills[name]=resourceAttributeValues;
         
         //let's just say that for now, we will assume availablity in each
         //month of 162 hours for each person. We need to check that there's 
         //only one primary per person so we don't double count.
           
         //if we don't already have one of these resources, we need to add it
         if (!prob.workingResourceExists(resourceAttributeValues)) {
                prob.addSimpleResource(resourceAttributeValues);
                prob.setSimpleResourceAcquireAppData(resourceAttributeValues,infeasibleAcquireTime);
                prob.setSimpleResourceAcquireAversion(resourceAttributeValues,1);
         }
                
         //now need to increment the supply by 162 (hours per month)
         //we only do this when we are doing the simple case (no multiple skills)
         float * supplyQ = prob.getSimpleResourceSupplyQuantity(resourceAttributeValues);
         for (int i=0; i<nPeriods; i++) {
               supplyQ[i]+=162.0;
         }
         prob.setSimpleResourceSupplyQuantity(resourceAttributeValues,supplyQ);
           
     }
         
         
    }

   
  } //end of supply file (names, primary skills etc.)
  
  //now do the stuff for multiple skills, if appropriate
  if (considerMultSkills) {
    //go through the names and get the "skill set"
    int numPeople = peopleNames.size();
    for (int i=0; i<numPeople; i++) {
       std::string name = peopleNames.at(i);
       std::vector<std::vector<std::string> > skillSet = mapNameToMultipleSkills[name];
       
       //this not only adds the "skill group" resource, it also creates
       //the appropriate operations to connect it to "real" working resources
       prob.addMultipleSkillGroups(skillSet); 
       
       //set the supply 
       for (int i=0; i<nPeriods; i++)
          prob.setMultipleSkillResourceSupplyQuantity(skillSet,162.0,i);
    
    }
  
  
  }
  
  {
    //now read the supply assignment file
    std::string supplyAssignmentFileName = idir + "/supplyAssignment.csv";
    RCPnascoSupplyAssignmentFile supplyAssignmentFile(supplyAssignmentFileName,numidentifiers);
    RCPnascoSupplyAssignmentFileIterator supplyAssignmentFileIter(supplyAssignmentFile);
    
    std::vector<std::string> actingAsResourceAttributeValues(numidentifiers);
    // loop once for each record in supply file
    for ( ; supplyAssignmentFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      for (int j=0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = supplyAssignmentFileIter.fieldOnRecord(attributeName);           
         actingAsResourceAttributeValues[j]=attributeValue;
      }
      
      //get the name, project, period, and quantity
      std::string name = supplyAssignmentFileIter.fieldOnRecord("name");
      std::string engagement = supplyAssignmentFileIter.fieldOnRecord("engagementName");
      int period = rcpCal.computePeriodFromMonthAndYear(supplyAssignmentFileIter.monthAsInt(), supplyAssignmentFileIter.yearAsInt());
      float quantity = supplyAssignmentFileIter.fieldOnRecordAsFloat("quantity");
      
      //to compute appropriate gaps and gluts we need to 
      // a) increase the supply of "working resource" by "quantity"
      // b) decease the supply of "name"'s primary (or group) by "quantity" 
      // in appropriate periods.
      
      //now need to decrement the supply of "name"
      //look up name
      if (!considerMultSkills) {
        if (mapNameToSkills.find(name) == mapNameToSkills.end()) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: name has not been defined with a primary skill in supply.csv"       <<std::endl
            <<"   filename: " <<supplyAssignmentFile.filename().c_str()                               <<std::endl
            <<"   file line number: " <<supplyAssignmentFileIter.recNum()                             <<std::endl
            <<"   name: " <<name.c_str()                                 <<std::endl
            <<"-------------------------------------------------------"                  <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
        }     
        std::vector<std::string> resourceAttributeValues = mapNameToSkills[name]; 
        float * supplyQ = prob.getSimpleResourceSupplyQuantity(resourceAttributeValues);
        supplyQ[period]-=quantity;           
        prob.setSimpleResourceSupplyQuantity(resourceAttributeValues,supplyQ);
      }
      else {
        if (mapNameToMultipleSkills.find(name) == mapNameToMultipleSkills.end()) {
            std::ostringstream msgStream;
            msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: name has not been defined with any skills in supply.csv"       <<std::endl
            <<"   filename: " <<supplyAssignmentFile.filename().c_str()                               <<std::endl
            <<"   file line number: " <<supplyAssignmentFileIter.recNum()                             <<std::endl
            <<"   name: " <<name.c_str()                                 <<std::endl
            <<"-------------------------------------------------------"                  <<std::endl;
            throw ( RcpOptException(msgStream.str()) );
        }     
        std::vector<std::vector<std::string> > skillGroup = mapNameToMultipleSkills[name]; 
        float * supplyQ = prob.getMultipleSkillResourceSupplyQuantity(skillGroup);
        float currentSupply = supplyQ[period];
        float newSupply = currentSupply-quantity;         
        prob.setMultipleSkillResourceSupplyQuantity(skillGroup,newSupply,period);
        witFree(supplyQ);
      }
      
      //need to increase supply of "actingAs"
      float * supplyQ = prob.getSimpleResourceSupplyQuantity(actingAsResourceAttributeValues);
      supplyQ[period]+=quantity;           
      prob.setSimpleResourceSupplyQuantity(actingAsResourceAttributeValues,supplyQ);
      witFree(supplyQ);
    }

    
  } //end of supply assignment file
  
}
void populate04Feb(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              const std::string & rFileName,
              const std::string & bFileName,
              int   nPeriods,
              bool  prioritySubs,
	          bool  resourceIdPriority,
              RcpOptCalendar & rcpCal,
              bool isGapGlut) 
{
  prob.setNPeriods(nPeriods);  
  float infeasibleAcquireTime = 10.f*nPeriods;
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  //prob.getTimer().printElapsedTime("begining populate04feb");

  //---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------
  int numidentifiers = prob.getResourceIdentifierNames().size();
  
  std::vector<int> globalMatchVector(numidentifiers);
  std::vector<int> subVector(numidentifiers);
  std::vector<int> localMatchVector(numidentifiers);

  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPgnrlMatchFile matchFile(matchFileName,prob.getResourceIdentifierNames().size());
    RCPgnrlMatchFileIterator matchFileIter(matchFile);
    matchFileIter(); 
    

    for (int i=0; i<numidentifiers; i++) {
       std::string attributeMatchName = prob.getResourceIdentifierNames()[i]+"Match";
       int matchValue = matchFileIter.fieldOnRecordAsInt(attributeMatchName);
       if ( (matchValue < 0) || (matchValue > 1)) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: match value must be 0 or 1"                                      <<std::endl
            <<"   filename: match.csv"                                                <<std::endl
            <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }

       globalMatchVector[i] = matchValue;
    }
        
  }  
  
  //---------------------------------------------------------
  // Read priority substitution file. This simply defines which
  // fields implement priority substitition.
  //---------------------------------------------------------
  if (prioritySubs) {
    std::string subsfile = idir+"/priority.csv";
    readPrioritySubsDescriptionFile(prob,subsfile);
  }
  

  
  //---------------------------------------------------------
  // Read resource ID priority file. This simply defines which
  // priorities for the resource IDs.
  //---------------------------------------------------------
  if (resourceIdPriority) {
    std::string resourceIdPriorityFile = idir+"/idPriority.csv";
    readResourceIdPriorityDescriptionFile(prob,resourceIdPriorityFile);
  }
  
  
   
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/"+rFileName.c_str();
    bool hasResourceCosts = false;
    readResourceFile(prob,resourceFileName,hasResourceCosts, isGapGlut, globalMatchVector,rcpCal);
  }

  

  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read bom File and set up structures for using data
    std::string bomFileName = idir + "/"+ bFileName.c_str();
    int numAttributes=prob.getResourceIdentifierNames().size();
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, 0, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    // loop once for each record in bom file    
    //initialize with the global match vector
 
    std::vector<std::string> resourceAttributeValues(numAttributes);
    for ( ; bomFileIter()!=NULL; ) {
      for (int ii=0; ii<numAttributes; ii++)
         localMatchVector[ii] = 1;
      
      
      for (int j=0; j<numAttributes; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);
         if (globalMatchVector[j]==0)
             attributeValue = "unmatched";
         if ((attributeValue=="PRIORITY")) {
           subVector[j]=1;
         }
         else if ((attributeValue=="UNSPECIFIED")) {
           localMatchVector[j]=0; //overwrite the match value with 0 for this bom entry
           subVector[j]=0;
         }
         else 
           subVector[j]=0;
           
         resourceAttributeValues[j]=attributeValue;
      }
      
      int period;
      if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD) 
         period = bomFileIter.periodAsInt();
      else {
         period = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      }
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
      // test to ensure quantity is non-negative
      if ( usageQuantity < 0.0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: quantity is less than zero"                                      <<std::endl
             <<"   filename: " <<bomFile.filename().c_str()                            <<std::endl
             <<"   file line number: " <<bomFileIter.recNum()                          <<std::endl                     <<std::endl
             <<"   period: " <<period                                                  <<std::endl
             <<"   quantity will be set to 0. "                                        <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      // test to ensure period is within the planning horizon
      if ( period < 0 || period >= nPeriods ) {
           std::ostringstream msgStream;
           msgStream <<"-------------------------------------------------------"         <<std::endl
           <<"Error: period is beyond planning horizion"                     <<std::endl
           <<"   filename: " <<bomFile.filename().c_str()                  <<std::endl
           <<"   file line number: " <<bomFileIter.recNum()                <<std::endl
           <<"-------------------------------------------------------"                   <<std::endl;
           throw ( RcpOptException(msgStream.str()) );
      }
 
     
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. add it with zero supply

       prob.addResource(resourceAttributeValues);
       //prob.setResourceSupplyQuantity(resourceAttributeValues,period,0.0);
       //if (period == 0){
       //  prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,0.0);
       //}
       //prob.setResourceFixedCost(resourceAttributeValues,period,1.0);
       //prob.setResourceAcquireCost(resourceAttributeValues,100.0);
       //prob.setResourceReleaseCost(resourceAttributeValues,1000000.0);
       if (!isGapGlut)
           prob.setResourceAcquireTime(resourceAttributeValues,infeasibleAcquireTime);

       float largeCost = 1e10;
       prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
      }
      
     
      //need to create an engagement name
      std::string engagementName= createEngagementName(resourceAttributeValues);
      //we do not need to test to see that the engagement does not already exist
      //because we simply don't add it if it does. We need to allow multiple bom's with
      //the same resource request
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         prob.setEngagementStartPeriod(engagementName,0);
         //prob.setEngagementDuration(engagementName,nPeriods);
         prob.setEngagementLateAllowance(engagementName,0);
         prob.setEngagementQuantity(engagementName,1.f);
      }


      if ( !prob.bomExists(engagementName,resourceAttributeValues) )
         prob.addBom(engagementName,resourceAttributeValues);
         
      //get prior usageQuantity
      float priorUsageQuantity = prob.getBomUsageQuantity(engagementName, resourceAttributeValues,period);
      usageQuantity=usageQuantity+priorUsageQuantity;
      prob.setBomUsageQuantity(engagementName,resourceAttributeValues,period,usageQuantity);

      unsigned int i;
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         prob.setBomMatch(engagementName, resourceAttributeValues, period, prob.getResourceIdentifierNames()[i], localMatchVector[i]);
      }
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         std::string resourceName = prob.getResourceIdentifierNames()[i];
         prob.setBomSub(engagementName,resourceAttributeValues,period,resourceName,subVector[i]);
      }
     }

    {
        //see whether the "supply adjustment" file exists. If it does, read it and
        //adjust the supply line.
        std::string supplyAdjustmentsFileName = idir + "/supplyAdjustments.csv";
        int numAttributes=prob.getResourceIdentifierNames().size();
        
        //check whether the file exists:

        FILE *foo = fopen(supplyAdjustmentsFileName.c_str(),"r");
        if (foo) {
            RCPsupplyAdjustmentsFile supplyAdjustmentsFile(supplyAdjustmentsFileName,numAttributes,rcpCal.getCalendarType());
            RCPsupplyAdjustmentsFileIterator supplyAdjustmentsFileIter(supplyAdjustmentsFile);
           
            std::vector<std::string> resourceAttributeValues(numAttributes);
            for ( ; supplyAdjustmentsFileIter()!=NULL; ) {
              
                for (int j=0; j<numAttributes; j++) {
                    std::string attributeName = prob.getResourceIdentifierNames()[j];
                    std::string attributeValue = supplyAdjustmentsFileIter.fieldOnRecord(attributeName);
                    resourceAttributeValues[j]=attributeValue;
                }
                  
                int period;
                if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD) 
                    period = supplyAdjustmentsFileIter.periodAsInt();
                else {
                    period = rcpCal.computePeriodFromMonthAndYear(supplyAdjustmentsFileIter.monthAsInt(), supplyAdjustmentsFileIter.yearAsInt());
                }
                float supplyAdjustment =  supplyAdjustmentsFileIter.supplyAdjustmentAsFloat();

                // test to ensure period is within the planning horizon
                if ( period < 0 || period >= nPeriods ) {
                    std::ostringstream msgStream;
                    msgStream <<"-------------------------------------------------------"         <<std::endl
                    <<"Error: period is beyond planning horizion"                     <<std::endl
                    <<"   filename: " <<supplyAdjustmentsFile.filename().c_str()                  <<std::endl
                    <<"   file line number: " <<supplyAdjustmentsFileIter.recNum()                <<std::endl
                    <<"-------------------------------------------------------"                   <<std::endl;
                    throw ( RcpOptException(msgStream.str()) );
                }
             
                 
                // test to ensure that resource exist
                if ( !prob.resourceExists(resourceAttributeValues) ) {
                    // Resource does not exist. add it with zero supply

                    prob.addResource(resourceAttributeValues);

                    if (!isGapGlut)
                        prob.setResourceAcquireTime(resourceAttributeValues,infeasibleAcquireTime);

                    float largeCost = 1e10;
                    prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
                }
                      
             
               //get prior supply; adjust out to end of planning horizon
               std::vector<float> priorQuantity = prob.getResourceSupplyQuantity(resourceAttributeValues);
                for (int jj = period; jj<nPeriods; jj++) {
                    float Quantity=supplyAdjustment+priorQuantity[jj];
                    if (Quantity<0) {
                                std::ostringstream msgStream;
                                msgStream <<"-------------------------------------------------------"         <<std::endl
                                <<"Error: quantity is negative"                     <<std::endl
                                <<"   filename: " <<supplyAdjustmentsFile.filename().c_str()                  <<std::endl
                                <<"   file line number: " <<supplyAdjustmentsFileIter.recNum()                <<std::endl
                                <<"   period: " <<jj               <<std::endl
                                <<"-------------------------------------------------------"                   <<std::endl;
                                throw ( RcpOptException(msgStream.str()) );      
                    }

                    prob.setResourceSupplyQuantity(resourceAttributeValues,jj,Quantity);

                }
            }
              
      }
    }
   
    //now that we've read all the boms, create a reasonable engagment
    //revenue. It ought to be more than nPeriods*(total num required per period)
    //loop once for each engagment 
    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); e++) {
      
      // loop once for each resource consumed be engagementNames[e]
      float engagementRevenue=0.f;
      std::vector<RCPvectorString> consumedResources = prob.getEngagementConsumedResources(engagementNames[e]);
      unsigned int r;
      for (r=0; r<consumedResources.size(); ++ r ) {
        std::vector<float> uq = prob.getBomUsageQuantity(engagementNames[e],consumedResources[r]);
        std::vector<float> fc = prob.getResourceFixedCost(consumedResources[r]);
        unsigned int t;
        for ( t=0; t<uq.size(); ++t ) {
          engagementRevenue = engagementRevenue + uq[t]*fc[t];
        }
      }
      engagementRevenue = 1000.0f * engagementRevenue;
      prob.setEngagementRevenue(engagementNames[e],engagementRevenue);
    }


  }
     
 
}


void populateFlexMix(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              const std::string & rFileName,
              const std::string & bFileName,
              int   nPeriods,
              bool  prioritySubs,
	          bool  resourceIdPriority,
              RcpOptCalendar & rcpCal) 
{
  prob.setNPeriods(nPeriods);  
  float infeasibleAcquireTime = 10.f*nPeriods;
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");

  //---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------
  int numidentifiers = prob.getResourceIdentifierNames().size();
  
  std::vector<int> globalMatchVector(numidentifiers);
  std::vector<int> subVector(numidentifiers);
  std::vector<int> localMatchVector(numidentifiers);

  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPgnrlMatchFile matchFile(matchFileName,prob.getResourceIdentifierNames().size());
    RCPgnrlMatchFileIterator matchFileIter(matchFile);
    matchFileIter(); 
    

    for (int i=0; i<numidentifiers; i++) {
       std::string attributeMatchName = prob.getResourceIdentifierNames()[i]+"Match";
       int matchValue = matchFileIter.fieldOnRecordAsInt(attributeMatchName);
       if ( (matchValue < 0) || (matchValue > 1)) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: match value must be 0 or 1"                                      <<std::endl
            <<"   filename: match.csv"                                                <<std::endl
            <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }

       globalMatchVector[i] = matchValue;
    }
        
  }  
  
//---------------------------------------------------------
  // Read priority substitution file. This simply defines which
  // fields implement priority substitition.
  //---------------------------------------------------------
  std::string subsfile = idir+"/priority.csv";
  readPrioritySubsDescriptionFile(prob,subsfile);
 
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  std::set<std::string> supplySet;
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/"+rFileName.c_str();
    
  int nPeriods = prob.getNPeriods();  
  float infeasibleAcquireTime = 10.f*nPeriods;
  int numAttributes = prob.getResourceIdentifierNames().size();  
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,false,rcpCal.getCalendarType());
  RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
  
  // loop once for each record in resource file
  
  int foo=1;
  std::vector<std::string> resourceAttributeValues(numAttributes);
  for ( ; resourceFileIter()!=NULL; ) {
        //this is for the flex mix stuff
      std::string jobRole = resourceFileIter.fieldOnRecord("jobRole");
      std::string primarySkill = resourceFileIter.fieldOnRecord("skillSet");
      std::string name = makeJobRolePrimarySkillName(jobRole,primarySkill);
      supplySet.insert(name);

    for (int j=0; j<numAttributes; j++) {
      std::string attributeName = prob.getResourceIdentifierNames()[j];
      std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
      if (globalMatchVector.size()!=0 && globalMatchVector[j]==0)
          attributeValue = "unmatched";
      resourceAttributeValues[j]=attributeValue;
    }
    int period;
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
       period = resourceFileIter.periodAsInt();
    else {
       period = rcpCal.computePeriodFromMonthAndYear(resourceFileIter.monthAsInt(), resourceFileIter.yearAsInt());
    }
    float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
    // test to ensure quantity is non-negative
    if ( supplyQuantity < 0) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"   Error: supplyQuantity is negative"                                    <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()                <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()              <<std::endl            
        <<"   period: " <<period                                                    <<std::endl                          <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }

    // test to ensure period is within the planning horizon
    if ( period <0 || period >= nPeriods ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: period is beyond planning horizion"                               <<std::endl
        <<"   filename: " <<resourceFile.filename().c_str()                         <<std::endl
        <<"   file line number: " <<resourceFileIter.recNum()                       <<std::endl            
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
    
    
    if ( !prob.resourceExists(resourceAttributeValues) )
      prob.addFlexibleResource(resourceAttributeValues, true);
 

    float * priorQuantity = prob.getFlexibleResourceSupplyQuantity(resourceAttributeValues);
    priorQuantity[period] = priorQuantity[period]+supplyQuantity;
    prob.setFlexibleResourceSupplyQuantity(resourceAttributeValues,priorQuantity);
    //free (priorQuantity);
  } 
 }



  //---------------------------------------------------------
  // Read bom file
  // Note that this does an addFlexResource and also adds an aquire operation
  // as a substitute
  //---------------------------------------------------------
  {
    // Read bom File and set up structures for using data
    std::string bomFileName = idir + "/"+ bFileName.c_str();
    int numAttributes=prob.getResourceIdentifierNames().size();
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, 0, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    // loop once for each record in bom file    
    //initialize with the global match vector
 
    std::vector<std::string> resourceAttributeValues(numAttributes);
     for ( ; bomFileIter()!=NULL; ) {
      
      for (int ii=0; ii<numAttributes; ii++)
         localMatchVector[ii] = 1;
      
      
      for (int j=0; j<numAttributes; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);
         if (globalMatchVector[j]==0)
             attributeValue = "unmatched";
         if ((attributeValue=="PRIORITY")) {
           subVector[j]=1;
         }
         else if ((attributeValue=="UNSPECIFIED")) {
           localMatchVector[j]=0; //overwrite the match value with 0 for this bom entry
           subVector[j]=0;
         }
         else 
           subVector[j]=0;
           
         resourceAttributeValues[j]=attributeValue;
      }
      
      int period;
      if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD) 
         period = bomFileIter.periodAsInt();
      else {
         period = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      }
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
      // test to ensure quantity is non-negative
      if ( usageQuantity < 0.0) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
            <<"Error: quantity is less than zero"                                      <<std::endl
             <<"   filename: " <<bomFile.filename().c_str()                            <<std::endl
             <<"   file line number: " <<bomFileIter.recNum()                          <<std::endl                     <<std::endl
             <<"   period: " <<period                                                  <<std::endl
             <<"   quantity will be set to 0. "                                        <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
      }
      // test to ensure period is within the planning horizon
      if ( period < 0 || period >= nPeriods ) {
           std::ostringstream msgStream;
           msgStream <<"-------------------------------------------------------"         <<std::endl
           <<"Error: period is beyond planning horizion"                     <<std::endl
           <<"   filename: " <<bomFile.filename().c_str()                  <<std::endl
           <<"   file line number: " <<bomFileIter.recNum()                <<std::endl
           <<"-------------------------------------------------------"                   <<std::endl;
           throw ( RcpOptException(msgStream.str()) );
      }
      
      //check to see whether we have already added this resource. If not, add it
      //with 0 supply.
      std::string engagementName = createEngagementName(resourceAttributeValues);
      if (!prob.resourceExists(resourceAttributeValues))
        prob.addFlexibleResource(resourceAttributeValues,true);
 
     
       prob.addFlexibleDemand(resourceAttributeValues, engagementName, period, usageQuantity);

     
      
     


      unsigned int i;
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         prob.setBomMatch(engagementName, resourceAttributeValues, 0, prob.getResourceIdentifierNames()[i], localMatchVector[i]);
      }
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         std::string resourceName = prob.getResourceIdentifierNames()[i];
         prob.setBomSub(engagementName,resourceAttributeValues,0,resourceName,subVector[i]);
      }
    
       
     }
     
     //now that we've read the demand, we need to read the flex skills file
     std::string skillsFileName = idir + "/skills/skills.csv";
     MapStringToFlexSkillsObject flexSkillsMap = readFlexSkillsFile(prob, skillsFileName, supplySet);
     
       
       
     //now we have to add all the flexible mix extra stuff.
     //need to loop through all the resources
     std::vector<RCPvectorString> names;
     prob.getResourceNames(names);
     int numResources = names.size();
     std::string jobRole, skillSet, country, resourceType;
     int jobRolePosition, skillSetPosition, countryPosition, resourceTypePosition;
     jobRolePosition = prob.getIndexOfAttribute("jobRole");
     skillSetPosition = prob.getIndexOfAttribute("skillSet");
     prob.setSkillSetPosition(skillSetPosition);
     countryPosition = prob.getIndexOfAttribute("country");
     resourceTypePosition = prob.getIndexOfAttribute("resourceType");
     //if (jobRolePosition==-1 || skillSetPosition==-1 || countryPosition==-1 || resourceTypePosition==-1) {
     if (jobRolePosition==-1 || skillSetPosition==-1 ) {

              std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: FlexMix requires jobRole, skillSet attributes"          <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;

     }
     else {
        for (int i=0; i<numResources; i++) {
            //get the set of skill sets related to the job role
            std::vector<std::string> originalResource = names[i];
            jobRole = names[i][jobRolePosition];
            skillSet = names[i][skillSetPosition];
            //country = names[i][countryPosition];
            //resourceType = names[i][resourceTypePosition];
            
            
            std::vector<std::pair<std::vector<std::string>,float> > alternativeSkillGroups = getAltSkills(jobRole,skillSet, flexSkillsMap);
            //for each alternate skill group
            int numAlternateGroups = alternativeSkillGroups.size();
            int singleton = -1;
            for (int j=0; j<numAlternateGroups; j++) {
                std::pair<std::vector<std::string>,float> alternativeSkillGroup = alternativeSkillGroups[j];
                std::vector<std::string> skillList = alternativeSkillGroup.first;
                if (skillList.size()==1) //save for later
                   singleton = j;
                else {
                    float fraction = alternativeSkillGroup.second;
                   
                    float * supplyPrimary;
                    supplyPrimary = prob.getFlexibleResourceSupplyQuantity(originalResource);
                    int n = prob.getNPeriods();
                    float * supplyAlternate = new float[n];
                    for (int k=0; k<nPeriods; k++) {
                        supplyAlternate[k] = supplyPrimary[k]*fraction;
                    }
                    prob.addAlternateResource(skillList, skillSetPosition, originalResource, supplyAlternate);
                    //free(supplyPrimary);
                    //free(supplyAlternate);
                }
            }
            
            //now do the singleton
            if (singleton==-1) {
              if (numAlternateGroups!=0) {
                //make the main supply 0, as it has been used everywhere else; there is
                //no singleton
                  float * vecZero = new float[prob.getNPeriods()];
                  for (int i=0; i<prob.getNPeriods(); i++)
                     vecZero[i] = 0;
                  prob.setFlexibleResourceSupplyQuantity(originalResource, vecZero); 
              }
            }
            else {
                std::pair<std::vector<std::string>,float> alternativeSkillGroup = alternativeSkillGroups[singleton];
                std::vector<std::string> skillList = alternativeSkillGroup.first;

                float fraction = alternativeSkillGroup.second;
                float * supplyPrimary = prob.getFlexibleResourceSupplyQuantity(originalResource);
                float * supplyAlternate = new float[prob.getNPeriods()];
                for (int k=0; k<nPeriods; k++) {
                    float s = supplyPrimary[k];
                    supplyAlternate[k] = (s*fraction);
                }
                prob.addAlternateResource(skillList, skillSetPosition, originalResource, supplyAlternate);
                //free(supplyPrimary);
                //free(supplyAlternate);
            }
           
           
            }
        
        }
    }





  }
  


//get information about alternate skills
FlexSkillsObject getAltSkills(std::string jobRole, std::string primarySkillSet, MapStringToFlexSkillsObject map) {
    
    // This routine, given country, resourceType, jobRole and primarySkillSet, should return a
    //vector of pairs. The first element of each pair should be a vector of strings,
    //representing the skills in the group. The second element of each pair should
    //be the fraction of the total having that set.
    std::string name = makeJobRolePrimarySkillName(jobRole,primarySkillSet);
    FlexSkillsObject returnVal;
    
    //look it up in the map
    MapStringToFlexSkillsObjectIterator flexSkillsIt = map.find(name);
    if( flexSkillsIt == map.end() ) {
       return returnVal;
    }
  
    returnVal = map[name];
    return returnVal;
    
 
}

//---------------------------------------------------------
// Read a substitute file.
//---------------------------------------------------------
void readSubsFile(
                  RCPproblem & prob, 
                  const SCOcsvFormatFile & file,
                  const std::string & resourceIdName)
{
  SCOfileIterator fileIter(file);
  
  // loop once for each record in bom file
  for ( ; fileIter()!=NULL; ) {
    std::string from = fileIter.fieldOnRecord("from");
    std::string to = fileIter.fieldOnRecord("to");
    float cost = fileIter.fieldOnRecordAsFloat("cost");  //DLG check these values
    float leadTime = fileIter.fieldOnRecordAsFloat("leadTime");
    
    // test to ensure that subSkill does not exist
    if ( prob.subsExists(resourceIdName,from,to) ) {
      // skillSubs does exist. Write warning message
      std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: "+resourceIdName+" substitute already exists"          <<std::endl
        <<"   filename: " <<file.filename().c_str()                        <<std::endl
        <<"   file line number: " <<fileIter.recNum()                      <<std::endl
        <<"   from: " <<from.c_str()                                       <<std::endl
        <<"   to: " <<to.c_str()                                           <<std::endl
        <<"   cost: " <<cost                                               <<std::endl
        <<"   leadTime: " <<leadTime                                       <<std::endl
        <<"   record will be ignored. "                                    <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      continue;
    }
    
    prob.addSubs(resourceIdName,from,to);
    prob.setSubsCost(resourceIdName,from,to,cost);
    prob.setSubsLeadTime(resourceIdName,from,to,leadTime);
    //set to reasonable value
    prob.setSubsAversion(resourceIdName,from,to,1);
  }
} //end of reading skillSubs file
//---------------------------------------------------------


std::string createEngagementName(std::vector<std::string> resourceAttributeVector) {
  std::string retVal;
  int numAttributes = resourceAttributeVector.size();
  for (int i=0; i<numAttributes; i++) {
    std::string attributeValue = resourceAttributeVector.at(i);
    retVal = retVal +  attributeValue + " ";
  }
  return retVal;
}
std::string makeJobRolePrimarySkillName(std::string jobRole, std::string primarySkill) {
  std::string retVal;
  retVal = jobRole + ":::" + primarySkill;
  return retVal;
}@


1.169
log
@modifications for supplyAdjustment file
@
text
@d13 1
d548 19
d611 1
a611 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods, tfSubs, globalSubstitution, rIdPriority, rcpCal, hasResourceCosts,isGapGlut);
d671 2
a672 1
              bool isGapGlut) 
d678 15
d700 1
a700 1
    RCPengagementFile engagementFile(engagementFileName,rcpCal.getCalendarType());
d713 18
a730 1
      }      
d782 3
@


1.168
log
@changes for nasco multiple skills
@
text
@d14 1
d1748 47
d1796 30
@


1.167
log
@checked in some NASCO specific code
@
text
@d524 21
a544 2
      populateNASCO(prob,idir,odir,nPeriods,rcpCal);
    }
d1112 1
a1112 1
    if (!prob.workingResourceExists(resourceAttributeValues))
d1114 2
d1129 2
a1130 1
              int   nPeriods, RcpOptCalendar & rcpCal) 
d1182 4
d1189 1
d1227 3
d1248 5
a1252 2
      if (!prob.workingResourceExists(resourceAttributeValues))
           prob.addSimpleResource(resourceAttributeValues);
d1254 3
a1256 1
      prob.updateEngagementBom(engagementName,resourceAttributeValues,period, usageQuantity);
d1299 5
d1305 1
d1330 1
a1330 1
      if (!prob.workingResourceExists(resourceAttributeValues))
d1332 4
d1337 2
a1338 1
      prob.updateEngagementBom(engagementName,resourceAttributeValues,period, usageQuantity);
d1358 2
d1386 29
d1416 2
a1417 6
      if (primary) {
      
         //check that we haven't seen this person with another primary
         //skill before
         if (mapNameToSkills.find(name) == mapNameToSkills.end()) {
            mapNameToSkills[name]=resourceAttributeValues;
d1419 3
a1421 3
           //let's just say that for now, we will assume availablity in each
           //month of 162 hours for each person. We need to check that there's 
           //only one primary per person so we don't double count.
d1423 2
a1424 2
           //if we don't already have one of these resources, we need to add it
           if (!prob.workingResourceExists(resourceAttributeValues))
d1426 3
d1430 7
a1436 6
           //now need to increment the supply by 162 (hours per month)
           float * supplyQ = prob.getSimpleResourceSupplyQuantity(resourceAttributeValues);
           for (int i=0; i<nPeriods; i++) {
              supplyQ[i]+=162.0;
           }
           prob.setSimpleResourceSupplyQuantity(resourceAttributeValues,supplyQ);
d1438 1
a1438 1
         }
d1441 1
a1441 1
      }
d1443 1
a1443 1
    }   
d1446 21
d1491 1
a1491 1
      // b) decease the supply of "name"'s primary by "quantity" 
d1496 34
a1529 14
      if (mapNameToSkills.find(name) == mapNameToSkills.end()) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: name has not been defined with a primary skill in supply.csv"       <<std::endl
          <<"   filename: " <<supplyAssignmentFile.filename().c_str()                               <<std::endl
          <<"   file line number: " <<supplyAssignmentFileIter.recNum()                             <<std::endl
          <<"   name: " <<name.c_str()                                 <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
          throw ( RcpOptException(msgStream.str()) );
      }     
      std::vector<std::string> resourceAttributeValues = mapNameToSkills[name]; 
      float * supplyQ = prob.getSimpleResourceSupplyQuantity(resourceAttributeValues);
      supplyQ[period]-=quantity;           
      prob.setSimpleResourceSupplyQuantity(resourceAttributeValues,supplyQ);
d1532 1
a1532 1
      supplyQ = prob.getSimpleResourceSupplyQuantity(actingAsResourceAttributeValues);
d1535 1
@


1.166
log
@fixed the reporting of required supply in the output gapGlut file.
@
text
@d17 2
d462 1
a462 1
    if ( fileFormat!="03Dec" &&  fileFormat!="04Feb" && fileFormat!="FlexMix" && fileFormat!="DemandEngagement") {
d468 1
a468 1
        <<"   allowed values: 03Dec 04Feb FlexMix DemandEngagement"                               <<std::endl
d523 3
d1103 10
a1112 1
 
d1114 48
d1165 4
a1168 2
  // Read engagement file
  // This file defines the resources used by each engagement
d1171 1
a1171 1
    std::string bomFileName = idir + "/engagement.csv";
d1179 36
a1214 1
   
d1216 30
d1252 3
d1256 30
a1285 4
      if (!prob.engagementExists(engagementName))
          prob.addEngagementNoDemand(engagementName);
      int period; //note that this is RELATIVE period. calendar doesn't make sense
      period = bomFileIter.periodAsInt();
d1288 1
a1288 1

a1290 3
       
      
     
d1308 8
a1315 1
      //do the demand file
d1317 6
a1322 3
    std::string demandFileName = idir + "/demand.csv";
    RCPdemandEngagementFile demandFile(demandFileName,rcpCal.getCalendarType());
    RCPdemandEngagementFileIterator demandEngagementFileIter(demandFile);
d1324 93
a1416 8
    for ( ; demandEngagementFileIter()!=NULL; ) {
         std::string engagementName = demandEngagementFileIter.engagement();
         int period = demandEngagementFileIter.periodAsInt();
         char periodchar[100];
         sprintf( periodchar, "%d", period );
         float quantity = demandEngagementFileIter.usageQuantityAsFloat();
         std::string demandName = engagementName + " period: " + periodchar;
         prob.addDemandForEngagement(engagementName, demandName, period, quantity);
d1418 3
a1420 2
    //fix up the *cumulative* demands
    prob.computeCumDemands();
a1421 1
  }
@


1.165
log
@changes for deal hub example (demandengagement format)
@
text
@d1094 1
a1094 1
   
@


1.164
log
@some changes for flex mix
@
text
@d13 1
d26 1
d460 1
a460 1
    if ( fileFormat!="03Dec" &&  fileFormat!="04Feb" && fileFormat!="FlexMix") {
d466 1
a466 1
        <<"   allowed values: 03Dec 04Feb FlexMix"                               <<std::endl
d518 4
a521 2

    if (fileFormat=="03Dec") {
a1015 2
  }
     
d1017 83
a1099 1
   //---------------------------------------------------------
d1101 71
a1410 1

@


1.163
log
@more support of flex mix. Now actually reading the skills file.
@
text
@d1503 3
a1505 1
     if (jobRolePosition==-1 || skillSetPosition==-1 || countryPosition==-1 || resourceTypePosition==-1) {
d1508 1
a1508 1
        <<"Warning: FlexMix requires jobRole, skillSet, country, and resourceType attributes"          <<std::endl
d1518 2
a1519 2
            country = names[i][countryPosition];
            resourceType = names[i][resourceTypePosition];
d1522 1
a1522 1
            std::vector<std::pair<std::vector<std::string>,float> > alternativeSkillGroups = getAltSkills(country, resourceType, jobRole,skillSet, flexSkillsMap);
d1589 1
a1589 1
FlexSkillsObject getAltSkills(std::string country, std::string resourceType, std::string jobRole, std::string primarySkillSet, MapStringToFlexSkillsObject map) {
@


1.162
log
@getting the flex mix stuff working. Seems to be pretty close to correct
@
text
@d15 1
d108 1
a108 4

//this one is different because it's going to add a different
//kind of resource for the flex mix model.
void readResourceFileFlexMix(
d110 2
a111 3
                      const std::string & resourceFileName,
                      std::vector<int> matchFlags, //needed to stick in "unmatched" if appropriate
                      RcpOptCalendar & rcpCal
d114 2
a115 5
  int nPeriods = prob.getNPeriods();  
  float infeasibleAcquireTime = 10.f*nPeriods;
  int numAttributes = prob.getResourceIdentifierNames().size();  
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,false,rcpCal.getCalendarType());
  RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
a116 30
  // loop once for each record in resource file
  
  int foo=1;
  std::vector<std::string> resourceAttributeValues(numAttributes);
  for ( ; resourceFileIter()!=NULL; ) {
    for (int j=0; j<numAttributes; j++) {
      std::string attributeName = prob.getResourceIdentifierNames()[j];
      std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
      if (matchFlags.size()!=0 && matchFlags[j]==0)
          attributeValue = "unmatched";
      resourceAttributeValues[j]=attributeValue;
    }
    int period;
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
       period = resourceFileIter.periodAsInt();
    else {
       period = rcpCal.computePeriodFromMonthAndYear(resourceFileIter.monthAsInt(), resourceFileIter.yearAsInt());
    }
    float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
    // test to ensure quantity is non-negative
    if ( supplyQuantity < 0) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"   Error: supplyQuantity is negative"                                    <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()                <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()              <<std::endl            
        <<"   period: " <<period                                                    <<std::endl                          <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
d118 35
a152 10
    // test to ensure period is within the planning horizon
    if ( period <0 || period >= nPeriods ) {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: period is beyond planning horizion"                               <<std::endl
        <<"   filename: " <<resourceFile.filename().c_str()                         <<std::endl
        <<"   file line number: " <<resourceFileIter.recNum()                       <<std::endl            
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
d155 22
a176 8
    if ( !prob.resourceExists(resourceAttributeValues) )
      prob.addFlexibleResource(resourceAttributeValues, true);
 

    float * priorQuantity = prob.getFlexibleResourceSupplyQuantity(resourceAttributeValues);
    priorQuantity[period] = priorQuantity[period]+supplyQuantity;
    prob.setFlexibleResourceSupplyQuantity(resourceAttributeValues,priorQuantity);
    free (priorQuantity);
d178 4
d185 1
d1316 1
d1320 66
a1385 3
    bool hasResourceCosts = false;
    readResourceFileFlexMix(prob,resourceFileName, globalMatchVector,rcpCal);
  }
d1405 2
a1406 1
    for ( ; bomFileIter()!=NULL; ) {
d1485 4
d1520 1
a1520 1
            std::vector<std::pair<std::vector<std::string>,float> > alternativeSkillGroups = getAltSkills(country, resourceType, jobRole,skillSet);
d1540 2
a1541 2
                    free(supplyPrimary);
                    free(supplyAlternate);
d1568 2
a1569 2
                free(supplyPrimary);
                free(supplyAlternate);
d1587 1
a1587 1
std::vector<std::pair<std::vector<std::string>,float> > getAltSkills(std::string country, std::string resourceType, std::string jobRole, std::string primarySkillSet) {
d1589 1
a1589 1
    //NEEDS CODE. This routine, given country, resourceType, jobRole and primarySkillSet, should return a
d1593 2
d1596 4
a1599 18
    std::vector<std::pair<std::vector<std::string>, float> > returnVector;
    //return returnVector;
    if (jobRole=="developer" && primarySkillSet=="c++") {
        std::pair<std::vector<std::string>, float> p1, p2, p3;
        std::vector<std::string> g1, g2, g3;
        g1.push_back("c++");
        g2.push_back("c++");
        g2.push_back("java");
        g2.push_back("db2");
        g3.push_back("c++");
        g3.push_back("java");
        g3.push_back("sql");
        p1 = make_pair(g1,.5f);
        p2 = make_pair(g2,.3f);
        p3 = make_pair(g3,.2f);
        returnVector.push_back(p1);
        returnVector.push_back(p2);
        returnVector.push_back(p3);
d1601 3
d1605 1
a1605 1
    return returnVector;
d1661 5
a1665 1

@


1.161
log
@many changes to support the "simple" flexmix model. Doesn't work yet.
@
text
@d167 2
a168 9
      prob.addFlexibleResource(resourceAttributeValues, true, false, "");
      //prob.addResource(resourceAttributeValues);
      
    //float fixedCost = 1.0f; //DLG WHAT SHOULD THIS BE
    //prob.setResourceFixedCost(resourceAttributeValues,period,fixedCost);
    
    //float largeCost = 1e10; //DLG WHAT SHOULD THIS BE
    //prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
      
a489 1
    std::string resourceIdPriority = globalAttrFile.fieldAsString("resourceIdPriority","attrValue");
d491 13
a503 10
    if (resourceIdPriority =="no") 
       rIdPriority = false;
    else if (resourceIdPriority =="yes") 
       rIdPriority = true;
    else {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
        <<"Error: resourceIdPriority value must be yes or no"             <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
d505 2
d1298 1
a1298 1
  //---------------------------------------------------------
d1302 3
a1304 18
  if (prioritySubs) {
    std::string subsfile = idir+"/priority.csv";
    readPrioritySubsDescriptionFile(prob,subsfile);
  }
  

  
  //---------------------------------------------------------
  // Read resource ID priority file. This simply defines which
  // priorities for the resource IDs.
  //---------------------------------------------------------
  if (resourceIdPriority) {
    std::string resourceIdPriorityFile = idir+"/idPriority.csv";
    readResourceIdPriorityDescriptionFile(prob,resourceIdPriorityFile);
  }
  
  
   
d1315 1
a1315 1
  
d1385 6
d1393 2
a1394 13
      //need to create an engagement name
      std::string engagementName= createEngagementName(resourceAttributeValues);
      //we do not need to test to see that the engagement does not already exist
      //because we simply don't add it if it does. We need to allow multiple bom's with
      //the same resource request
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         prob.setEngagementStartPeriod(engagementName,0);
         //prob.setEngagementDuration(engagementName,nPeriods);
         prob.setEngagementLateAllowance(engagementName,0);
         prob.setEngagementQuantity(engagementName,1.f);
         prob.setEngagementRevenue(engagementName,2.f);
      }
a1395 12
     
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. add it with zero supply
       bool isActual = true;
       bool isDemanded = true;
       prob.addFlexibleResource(resourceAttributeValues,isActual,isDemanded,engagementName);
           
       //float largeCost = 1e10;
       //prob.setResourceAcquireCost(resourceAttributeValues,largeCost); 
 
      }
a1399 8
      if ( !prob.bomExists(engagementName,resourceAttributeValues) )
         prob.addBom(engagementName,resourceAttributeValues);
         
      //get prior usageQuantity
      float priorUsageQuantity = prob.getBomUsageQuantity(engagementName, resourceAttributeValues,period);
      usageQuantity=usageQuantity+priorUsageQuantity;
      prob.setBomUsageQuantity(engagementName,resourceAttributeValues,period,usageQuantity);

d1402 1
a1402 1
         prob.setBomMatch(engagementName, resourceAttributeValues, period, prob.getResourceIdentifierNames()[i], localMatchVector[i]);
d1406 1
a1406 1
         prob.setBomSub(engagementName,resourceAttributeValues,period,resourceName,subVector[i]);
d1408 1
a1408 1
      
d1423 1
d1503 1
a1503 24
   
    //now that we've read all the boms, create a reasonable engagment
    //revenue. It ought to be more than nPeriods*(total num required per period)
    //loop once for each engagment 
    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); e++) {
      
      // loop once for each resource consumed be engagementNames[e]
      float engagementRevenue=0.f;
      std::vector<RCPvectorString> consumedResources = prob.getEngagementConsumedResources(engagementNames[e]);
      unsigned int r;
      for (r=0; r<consumedResources.size(); ++ r ) {
        std::vector<float> uq = prob.getBomUsageQuantity(engagementNames[e],consumedResources[r]);
        std::vector<float> fc = prob.getResourceFixedCost(consumedResources[r]);
        unsigned int t;
        for ( t=0; t<uq.size(); ++t ) {
          engagementRevenue = engagementRevenue + uq[t]*fc[t];
        }
      }
      engagementRevenue = 1000.0f * engagementRevenue;
      prob.setEngagementRevenue(engagementNames[e],engagementRevenue);
    }
d1519 1
a1519 1
    if (primarySkillSet=="java") {
d1522 2
a1523 1
        g1.push_back("java");
a1524 1
        g2.push_back("c++");
d1526 1
a1527 1
        g3.push_back("c++");
d1529 1
a1529 1
        p1 = make_pair(g1,.3f);
d1531 1
a1531 1
        p3 = make_pair(g3,.4f);
@


1.160
log
@attach acquire as a substitute for each demanded resource
@
text
@d10 1
d167 1
a167 1
      prob.addFlexibleResource(resourceAttributeValues);
d177 4
a180 6
    std::vector<float> priorQuantity = prob.getResourceSupplyQuantity(resourceAttributeValues);
    supplyQuantity=supplyQuantity+priorQuantity[period];
    prob.setResourceSupplyQuantity(resourceAttributeValues,period,supplyQuantity);
    if (period == 0){
      prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,supplyQuantity);
    }    
a1404 11
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. add it with zero supply
       prob.addFlexibleResource(resourceAttributeValues);
           
       //float largeCost = 1e10;
       //prob.setResourceAcquireCost(resourceAttributeValues,largeCost); 
 
      }
      
     
d1416 1
d1418 15
d1452 1
a1452 4
      //This adds an "aquired worker" part, and an acquire operation, with high cost/aversion
      prob.addFlexibleResourceAcquisition(resourceAttributeValues);  
      //DLG need to add it as a substitute, one way or another  
      
d1497 4
a1500 2
                    std::vector<float> supplyPrimary = prob.getResourceSupplyQuantity(originalResource);
                    std::vector<float> supplyAlternate;
d1502 1
a1502 2
                        float &s = supplyPrimary.at(k);
                        supplyAlternate.push_back(s*fraction);
d1505 2
d1515 4
a1518 3
                for (int k=0; k<nPeriods; k++) {
                    prob.setResourceSupplyQuantity(originalResource, k, 0.0); 
                }
d1526 2
a1527 2
                std::vector<float> supplyPrimary = prob.getResourceSupplyQuantity(originalResource);
                std::vector<float> supplyAlternate;
d1529 2
a1530 2
                    float &s = supplyPrimary.at(k);
                    supplyAlternate.push_back(s*fraction);
d1533 2
@


1.159
log
@do the right thing when there is no flex mix
@
text
@d166 2
a167 3
      //DLG add it in the normal way for now
      //prob.addFlexibleResource(resourceAttributeValues);
      prob.addResource(resourceAttributeValues);
d169 2
a170 2
    float fixedCost = 1.0f; //DLG WHAT SHOULD THIS BE
    prob.setResourceFixedCost(resourceAttributeValues,period,fixedCost);
d172 2
a173 2
    float largeCost = 1e10; //DLG WHAT SHOULD THIS BE
    prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
d1338 2
d1409 5
a1413 7

       //prob.addFlexibleResource(resourceAttributeValues);
       //DLG for now, I'm going to add it in the normal way
       prob.addResource(resourceAttributeValues);
       
       float largeCost = 1e10;
       prob.setResourceAcquireCost(resourceAttributeValues,largeCost);
d1447 5
d1454 2
@


1.158
log
@supporting flex mix
@
text
@d1502 6
a1507 4
              //make the main supply 0, as it has been used everywhere else; there is
              //no singleton
              for (int k=0; k<nPeriods; k++) {
                prob.setResourceSupplyQuantity(originalResource, k, 0.0); 
d1570 1
@


1.157
log
@flexible mix groups. Beginning changes
@
text
@d1481 1
a1483 1
                
d1485 7
a1491 4
                float fraction = alternativeSkillGroup.second;
                //
                std::vector<float> supplyPrimary = prob.getResourceSupplyQuantity(originalResource);
                std::vector<float> supplyAlternate;
d1499 25
a1557 9
RCPvectorString replaceSkillSet(RCPvectorString names,int skillSetPosition,std::string alternateSkillSet) {
  
   //This routine replaces one skill set with another skill set. 
   RCPvectorString newResourceName;
   for (unsigned int i=0; i<names.size(); i++) {
      newResourceName.push_back(names[i]);
   }
   names[skillSetPosition]=alternateSkillSet;
   return newResourceName;
a1558 1
}
d1578 3
a1580 3
        p1 = make_pair(g1,.3);
        p2 = make_pair(g2,.3);
        p3 = make_pair(g3,.4);
@


1.156
log
@more additions for flexible mix
@
text
@d166 3
a168 1
      prob.addFlexibleResource(resourceAttributeValues);
a457 6
    //hasResourceCosts is only relevant for optimalPlan.
    bool hasResourceCosts;
    if (theAlg=="optimalPlan") 
        hasResourceCosts = true;
    else
        hasResourceCosts = false;
d518 7
a561 2
       //check for priority substitution; this is necessary to coallesce two formats including an older one
       std::string prioritySubs = globalAttrFile.fieldAsString("prioritySubs","attrValue");
d563 6
a568 13
       if (prioritySubs =="no") 
          pSubs = false;
       else if (prioritySubs =="yes") 
          pSubs = true;
       else {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: prioritySubstitution value in globalAttr.csv must be yes or no"           <<std::endl
         <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }
      bool isGapGlut = true;
      if (theProb!="gapGlut") {
d575 2
a576 1
      }
d578 1
a578 15
      std::string solutionMethod = globalAttrFile.fieldAsString("flexMixSolutionMethod","attrValue");
      bool optimalSolutionMethod;
      if (solutionMethod =="optimal") 
          optimalSolutionMethod = true;
      else if (solutionMethod =="priority") 
          optimalSolutionMethod = false;
       else {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: solutionMethod value in globalAttr.csv must be optimal or priority"           <<std::endl
         <<"-------------------------------------------------------"                 <<std::endl;
         throw ( RcpOptException(msgStream.str()) );
       }
     
      populateFlexMix(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs, rIdPriority, rcpCal,optimalSolutionMethod);    
d1263 1
a1263 2
              RcpOptCalendar & rcpCal,
              bool optimalSolutionMethod) 
a1267 1
  //prob.getTimer().printElapsedTime("begining populate04feb");
d1409 4
a1412 1
       prob.addFlexibleResource(resourceAttributeValues);
d1455 2
a1456 2
     std::string jobRole, skillSet;
     int jobRolePosition, skillSetPosition;
d1459 3
a1461 1
     if (jobRolePosition==-1 || skillSetPosition==-1) {
d1464 1
a1464 1
        <<"Warning: FlexMix requires jobRole and skillSet attributes"          <<std::endl
d1471 1
d1473 19
a1491 20
            std::string primarySkillSet = names[i][skillSetPosition];
            std::vector<std::string> alternativeSkills = getAltSkills(jobRole,primarySkillSet);
            //for each alternate skill, need to add a alt->prim part
            int numalternates = alternativeSkills.size();
            for (int j=0; j<numalternates; j++) {
                std::string alternativeSkillSet = alternativeSkills[j];
                float fraction = getAltSkillsFraction(jobRole,primarySkillSet, alternativeSkillSet);
                //check whether there is any demand for the alternate skill
                RCPvectorString originalResource = names[i];
                RCPvectorString resourceWithAlternate = replaceSkillSet(names[i],skillSetPosition,alternativeSkillSet);
                if (prob.engagementExists(createEngagementName(resourceWithAlternate))) {
                    //AddAlternateResource should figure out the name for the "skill by..." part
                    //it should also create the operation to turn skill1 into skill2 for this part
                    //it should connect up the arcs from the new part to the operation, and from
                    //the new operation to the working as skill2 part, with some aversion.
                    //it should also connect the real part to this operation (skill2)
                    std::vector<float> supplyPrimary = prob.getResourceSupplyQuantity(originalResource);
                    std::vector<float> supplyAlternate;
                    for (int k=0; j<nPeriods; k++) {
                        supplyAlternate[k]= supplyPrimary[k]*fraction;
d1493 1
a1493 1
                    prob.addAlternateResource(resourceWithAlternate, originalResource, supplyAlternate);
a1495 22
        //now we have to loop through again to add the "cross resources"
        for (int i=0; i<numResources; i++) {
            //get the set of skill sets related to the job role
            jobRole = names[i][jobRolePosition];
            std::string primarySkillSet = names[i][skillSetPosition];
            std::vector<std::string> alternativeSkills = getAltSkills(jobRole,primarySkillSet);
            int numalternates = alternativeSkills.size();
            for (int j=0; j<numalternates; j++) {
                std::string alternativeSkillSet = alternativeSkills[j];
                float fraction = getAltSkillsFraction(jobRole,primarySkillSet, alternativeSkillSet);
                //check whether there is any demand for the alternate skill
                RCPvectorString originalResource = names[i];
                RCPvectorString resourceWithAlternate = replaceSkillSet(names[i],skillSetPosition,alternativeSkillSet);
                if (prob.engagementExists(createEngagementName(resourceWithAlternate))) {
                    for (int k=0; k<numalternates; k++) {
                        if (k != j) {
                            prob.AttachCrossTerm(originalResource, resourceWithAlternate, skillSetPosition, fraction); 
                        }
                    }
                }
            }
            
a1526 1

d1528 1
a1528 3
     
 }
}
d1542 1
a1542 1
std::vector<std::string> getAltSkills(std::string jobRole, std::string primarySkillSet) {
d1544 6
a1549 3
    //NEEDS CODE. This routine, given jobRole and primarySkillSet, should return a
    //vector of strings of all of the other skill sets found.
    std::vector<std::string> returnVector;
d1551 15
a1565 10
        returnVector.push_back("c++");
        returnVector.push_back("db2");
    }
    else if (primarySkillSet=="c++") {
         returnVector.push_back("java");
        returnVector.push_back("db2");
    }
    else  {
        returnVector.push_back("java");
        returnVector.push_back("c++");
d1567 1
a1569 16
float getAltSkillsFraction(std::string jobRole, std::string primarySkillSet, std::string skillSet) {
    //NEEDS CODE. This routine, given a job role, a primary skill set, and an alternate
    //skill set, returns the fraction having that alternate skill set.
    if (primarySkillSet=="java") {
       if (skillSet=="c++") return .2f;
       else  return .3f;
    }
    else if (primarySkillSet=="c++") {
       if (skillSet=="java") return .1f;
       else return .2f;
    }
    else {
       if (skillSet=="java") return .3f;
       else return .1f;
    }
}
@


1.155
log
@skeleton for flexible mix changes
@
text
@d1477 33
a1509 23
     for (int i=0; i<numResources; i++) {
        //get the set of skill sets related to the job role
        jobRole = names[i][jobRolePosition];
        std::string primarySkillSet = names[i][skillSetPosition];
        std::vector<std::string> alternativeSkills = getAltSkills(jobRole,primarySkillSet);
        //for each alternate skill, need to add a alt->prim part
        int numalternates = alternativeSkills.size();
        for (int j=0; j<numalternates; j++) {
            std::string alternativeSkillSet = alternativeSkills[j];
            float fraction = getAltSkillsFraction(jobRole,primarySkillSet, alternativeSkillSet);
            //check whether there is any demand for the alternate skill
            RCPvectorString originalResource = names[i];
            RCPvectorString resourceWithAlternate = replaceSkillSet(names[i],skillSetPosition,alternativeSkillSet);
            if (prob.engagementExists(createEngagementName(resourceWithAlternate))) {
                //AddAlternateResource should figure out the name for the "skill by..." part
                //it should also create the operation to turn skill1 into skill2 for this part
                //it should connect up the arcs from the new part to the operation, and from
                //the new operation to the working as skill2 part, with some aversion.
                //it should also connect the real part to this operation (skill2)
                std::vector<float> supplyPrimary = prob.getResourceSupplyQuantity(originalResource);
                std::vector<float> supplyAlternate;
                for (int k=0; j<nPeriods; k++) {
                    supplyAlternate[k]= supplyPrimary[k]*fraction;
a1510 1
                prob.addAlternateResource(resourceWithAlternate, originalResource, supplyAlternate);
d1512 19
a1530 19
        }
     //now we have to loop through again to add the "cross resources"
     for (int i=0; i<numResources; i++) {
        //get the set of skill sets related to the job role
        jobRole = names[i][jobRolePosition];
        std::string primarySkillSet = names[i][skillSetPosition];
        std::vector<std::string> alternativeSkills = getAltSkills(jobRole,primarySkillSet);
        int numalternates = alternativeSkills.size();
        for (int j=0; j<numalternates; j++) {
            std::string alternativeSkillSet = alternativeSkills[j];
            float fraction = getAltSkillsFraction(jobRole,primarySkillSet, alternativeSkillSet);
            //check whether there is any demand for the alternate skill
            RCPvectorString originalResource = names[i];
            RCPvectorString resourceWithAlternate = replaceSkillSet(names[i],skillSetPosition,alternativeSkillSet);
            if (prob.engagementExists(createEngagementName(resourceWithAlternate))) {
                for (int k=0; k<numalternates; k++) {
                   if (k != j) {
                      prob.AttachCrossTerm(originalResource, resourceWithAlternate, skillSetPosition, fraction); 
                   }
d1533 2
d1536 1
a1536 4
        
    
     }
    
d1572 2
d1584 3
d1603 2
@


1.154
log
@simplify and rationalize the logic for what params are acceptable together. Also fixed up the default leadtime/costs for the various scenarios.
@
text
@d107 77
d463 1
a463 1
    if ( fileFormat!="03Dec" &&  fileFormat!="04Feb") {
d469 1
a469 1
        <<"   allowed values: 03Dec 04Feb"                               <<std::endl
d558 41
d1271 333
@


1.153
log
@in optimal case (with costs) set the acquire time for non-existant resources to
a very large number
@
text
@a6 1
//#define DOTIMING
a22 1

d26 2
a27 12
                      bool readFixedCost, // read fixedCosted from file
                      float fixedCost,    // value to set fixed cost (ignored if readFixedCost=true).

                      bool setAcquireCost,  // if true, then acquireCost is set to value of next parameter
                      float acquireCost,   // value to set acquire cost
                      bool setAcquireTime, // if true, then acquireTime is set to value of next paramente
                      float acquireTime, // value to set acquire time
                      bool setReleaseCost, //if true, then releaseCost is set to value of next parameter
                      float releaseCost, // value to set release cost
                      bool setReleaseTime, //if true, then releaseTime is set to valueof next parameter
                      float releaseTime,
                      
d33 1
d35 1
a35 1
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,readFixedCost,rcpCal.getCalendarType());
d69 2
a70 1
    if (readFixedCost)
d72 1
a72 1
    
d87 11
d103 1
a103 13
    }

    prob.setResourceFixedCost(resourceAttributeValues,period,fixedCost);
    if ( setAcquireTime )
      prob.setResourceAcquireTime(resourceAttributeValues, acquireTime);
    if ( setAcquireCost )
      prob.setResourceAcquireCost(resourceAttributeValues,acquireCost);
    if (setReleaseTime)
      prob.setResourceReleaseTime(resourceAttributeValues,releaseTime);
    if (setReleaseCost)
      prob.setResourceReleaseCost(resourceAttributeValues,releaseCost);
    
    
a107 1

a263 2

   //prob.getTimer().printElapsedTime("done with everything before populate");
d341 7
d378 7
a384 2
    prob.setAlgorithmName(theAlg);
    prob.setProblemName(theProb);
d396 10
a417 19
    bool hRC;
    std::string hasResourceCosts;
    
    if ( !globalAttrFile.keyExists("hasResourceCosts") )
       hasResourceCosts = "yes";
    else
       hasResourceCosts = globalAttrFile.fieldAsString("hasResourceCosts","attrValue");

    if (hasResourceCosts =="no") 
         hRC = false;
    else if (hasResourceCosts =="yes") 
         hRC = true;
    else {
      std::ostringstream msgStream;
      msgStream <<"-------------------------------------------------------"         <<std::endl
         <<"Error: hasResourceCosts value in globalAttr.csv must be yes or no"               <<std::endl
        <<"-------------------------------------------------------"                 <<std::endl;
      throw ( RcpOptException(msgStream.str()) );
    }
d476 4
a479 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods, tfSubs, globalSubstitution, rIdPriority, rcpCal, hRC);
d496 3
a498 1

d500 1
a500 1
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs, rIdPriority, rcpCal);
d519 2
a520 1
              int hasResourceCosts) 
d701 1
a701 32
    float infeasibletime = 10.f*nPeriods;
    //if we are doing costs, then set the default acquire time to be
    //infeasible (in case it's not defined in the resourceaction file)
    if (hasResourceCosts)
       readResourceFile(prob,resourceFileName,true,0.0f,false, 0, true,infeasibletime,false, 0, false, 0, matchFlags,rcpCal);
    else
       readResourceFile(prob,resourceFileName,false,1.f,true, 100, true,0, true, 1000000, true, 0, globalMatchVector,rcpCal);
  }

  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
  if (hasResourceCosts)
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resourceaction.csv";
    RCPgnrlResourceActionFile resourceActionFile(resourceFileName,numidentifiers);
    RCPgnrlResourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      RCPvectorString resourceIdValues;
      resourceIdValues.clear();
      for (int j =0; j<numidentifiers; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = resourceActionFileIter.fieldOnRecord(attributeName);
         resourceIdValues.push_back(attributeValue);
      }
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat(); //check for negative values DLG
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();
d703 1
a703 11
      // test to ensure that resource exists
      if ( !prob.resourceExists(resourceIdValues) ) //{
         continue;
         //std::ostringstream msgStream;
         //msgStream <<"-------------------------------------------------------"         <<std::endl
         // <<"Error: Resource does not exist"                                         <<std::endl
         // <<"   filename: " <<resourceActionFile.filename().c_str()    <<std::endl
         // <<"   file line number: " <<resourceActionFileIter.recNum()  <<std::endl
         // <<"-------------------------------------------------------"                   <<std::endl;
         // throw ( RcpOptException(msgStream.str()) );
      //}
d705 1
a705 8
      prob.setResourceAcquireTime(resourceIdValues,acquireTime);
      prob.setResourceAcquireCost(resourceIdValues,acquireCost);
      prob.setResourceReleaseTime(resourceIdValues,releaseTime);
      prob.setResourceReleaseCost(resourceIdValues,releaseCost);
      // finish building resource model now that all the resource action data is available
      prob.addReleaseLeadtimeStructure(resourceIdValues);
    }
  }
d797 8
a804 4
       prob.addResource(resourceAttributeValues);
       prob.setResourceSupplyQuantity(resourceAttributeValues,period,0.0);
       if (period == 0){
         prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,0.0);
a805 7
       prob.setResourceFixedCost(resourceAttributeValues,period,1.0);
       prob.setResourceAcquireCost(resourceAttributeValues,100.0);
       prob.setResourceReleaseCost(resourceAttributeValues,1000000.0);
       float infeasibletime = 10.f*nPeriods;
       if (hasResourceCosts) prob.setResourceAcquireTime(resourceAttributeValues,infeasibletime);
       
      }
d871 39
d925 2
a926 1
              RcpOptCalendar & rcpCal) 
d929 1
d995 2
a996 1
    readResourceFile(prob,resourceFileName,false,1.f,true, 100, true,0, true, 1000000, true, 0, globalMatchVector,rcpCal);
a1000 1
  //prob.getTimer().printElapsedTime("done reading resource file");
d1071 1
a1071 1
        // Resource does not exist. add it.
d1074 12
a1085 8
       prob.setResourceSupplyQuantity(resourceAttributeValues,period,0.0);
       if (period == 0){
         prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,0.0);
       }
       prob.setResourceFixedCost(resourceAttributeValues,period,1.0);
       prob.setResourceAcquireCost(resourceAttributeValues,100.0);
       prob.setResourceReleaseCost(resourceAttributeValues,1000000.0);
       
a1120 1
    //prob.getTimer().printElapsedTime("done reading bom file");
@


1.152
log
@write out something in the engagement file even when nothing was executed. Also fixed a few casts.
@
text
@d706 3
d710 1
a710 1
       readResourceFile(prob,resourceFileName,true,0.0f,false, 0, false,0,false, 0, false, 0, matchFlags,rcpCal);
d740 10
a749 9
      if ( !prob.resourceExists(resourceIdValues) ) {
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: Resource does not exist"                                         <<std::endl
          <<"   filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"-------------------------------------------------------"                   <<std::endl;
          throw ( RcpOptException(msgStream.str()) );
      }
d858 2
@


1.151
log
@replacing with dan's working copies
@
text
@d51 1
a51 1
  
@


1.150
log
@undid some changes
@
text
@d738 7
a744 8
         continue;
         //std::ostringstream msgStream;
         //msgStream <<"-------------------------------------------------------"         <<std::endl
         // <<"Error: Resource does not exist"                                         <<std::endl
         // <<"   filename: " <<resourceActionFile.filename().c_str()    <<std::endl
         // <<"   file line number: " <<resourceActionFileIter.recNum()  <<std::endl
         // <<"-------------------------------------------------------"                   <<std::endl;
         // throw ( RcpOptException(msgStream.str()) );
@


1.149
log
@softened a thrown exception if a resource was defined in toFrom.csv that wasn't defined in supply.csv to be just ignored.
Also, set the acquiretime and releasetime defaults to be 10 times the horizon, so that we don't acquire demanded resources "for free" instead of substituting for them.
@
text
@a705 3
    //the defaults on release cost etc. ought to be very high. As an alternative,
    //we can just set the acquire/release times to be infeasible.
    int infeasiblehorizon = 10*nPeriods;
d707 1
a707 1
       readResourceFile(prob,resourceFileName,true,0.0f,false, 0, false,infeasiblehorizon,false, 0, false, infeasiblehorizon, matchFlags,rcpCal);
d717 1
a717 1
    // Read resourceaction File and set up structures for using data
a738 3
         //I don't think it's necessary to flag this as an error. There may
         //just not be a particular resource in this supply list, but it's
         //still ok to define the costs related to it.
a766 1
    int infeasiblehorizon = 10*nPeriods;
d853 1
a853 1
       prob.setResourceAcquireCost(resourceAttributeValues,1000000.0);
a854 2
       prob.setResourceAcquireTime(resourceAttributeValues,infeasiblehorizon);
       prob.setResourceReleaseTime(resourceAttributeValues,infeasiblehorizon);
a1003 1
    int infeasiblehorizon = 10*nPeriods;
d1005 1
a1005 1
    readResourceFile(prob,resourceFileName,false,1.f,true, 100, true,infeasiblehorizon, true, 1000000, true, infeasiblehorizon, globalMatchVector,rcpCal);
d1023 1
a1023 1
    int infeasiblehorizon = 10*nPeriods;
d1089 1
a1089 1
       prob.setResourceAcquireCost(resourceAttributeValues,1000000.0);
a1090 2
       prob.setResourceAcquireTime(resourceAttributeValues,infeasiblehorizon);
       prob.setResourceReleaseTime(resourceAttributeValues,infeasiblehorizon);
@


1.148
log
@remove some unused methods
@
text
@d706 3
d710 1
a710 1
       readResourceFile(prob,resourceFileName,true,0.0f,false, 0, false,0,false, 0, false, 0, matchFlags,rcpCal);
d720 1
a720 1
    // Read resource File and set up structures for using data
d741 11
a751 7
         std::ostringstream msgStream;
         msgStream <<"-------------------------------------------------------"         <<std::endl
          <<"Error: Resource does not exist"                                         <<std::endl
          <<"   filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"-------------------------------------------------------"                   <<std::endl;
          throw ( RcpOptException(msgStream.str()) );
d773 1
d860 1
a860 1
       prob.setResourceAcquireCost(resourceAttributeValues,100.0);
d862 2
d1013 1
d1015 1
a1015 1
    readResourceFile(prob,resourceFileName,false,1.f,true, 100, true,0, true, 1000000, true, 0, globalMatchVector,rcpCal);
d1033 1
a1033 1
 
d1099 1
a1099 1
       prob.setResourceAcquireCost(resourceAttributeValues,100.0);
d1101 2
@


1.147
log
@just added a comment to clarify something
@
text
@d1212 1
a1212 9
std::string createEngagementName(std::vector<std::string> resourceAttributeVector, std::string demandType) {
  std::string retVal="*"+demandType + "*";
  int numAttributes = resourceAttributeVector.size();
  for (int i=0; i<numAttributes; i++) {
    std::string attributeValue = resourceAttributeVector.at(i);
    retVal = retVal +  attributeValue + " ";
  }
  return retVal;
}
@


1.146
log
@do a check for whether the engagement already exists before adding it
@
text
@a1094 1

d1096 3
a1104 1

@


1.145
log
@fix case of filename
@
text
@d582 11
a592 1

@


1.144
log
@changed many warnings to exceptions.
@
text
@d11 1
a11 1
#include "RcpOptException.h"
@


1.143
log
@check for negative quantities on supply and/or demand so wit doesn't crash
@
text
@d11 1
a20 1
//#include "gnrlSubsFile.h"
d23 1
a23 1

d44 2
a45 2
  int nPeriods = prob.getNPeriods();
  int numAttributes = prob.getResourceIdentifierNames().size();
d70 8
a77 10
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"         <<std::endl
        <<"Warning: supplyQuantity is negative"                     <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl            
        <<"   period: " <<period                                            <<std::endl
        <<"   quantity will be set to 0. "                                     <<std::endl
        <<"-------------------------------------------------------"         <<std::endl;
      supplyQuantity = 0.0;
d81 1
a81 1
      fixedCost = resourceFileIter.fieldOnRecordAsFloat("fixedCost");
d85 7
a91 11
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"         <<std::endl
        <<"Warning: period is beyond planning horizion"                     <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl            
        <<"   period: " <<period                                            <<std::endl
        <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
        <<"   record will be ignored. "                                     <<std::endl
        <<"-------------------------------------------------------"         <<std::endl;
      continue;
d141 6
a146 8
	  //  Write warning message
	  std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: "+resourceIdName+" does not exist"                     <<std::endl
	  <<"   filename: " << substitutionFileName                          <<std::endl
	  <<"   record will be ignored. "                                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	    continue;
d191 6
a196 8
	  //  Write warning message
	  std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: "+resourceIdName+" does not exist"                     <<std::endl
	  <<"   filename: " << substitutionFileName                          <<std::endl
	  <<"   record will be ignored. "                                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	    continue;
d200 1
a200 1
      priority = fileIter.priorityAsInt();
d240 1
a240 1
      priority = fileIter.priorityAsInt();
d244 6
a249 8
	//  Write warning message
	std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: "+resourceIdName+" does not exist"                <<std::endl
	  <<"   filename: " << resourceIdPriorityFileName                        <<std::endl
	  <<"   record will be ignored. "                                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	continue;
d254 8
a261 8
	//  Write warning message
	std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: " +resourceIdName+ "'s priority:"<<priority <<" is too large"                <<std::endl
	  <<"The priority will be truncated to 1000000"                      <<std::endl
	  <<"   filename: " << resourceIdPriorityFileName                        <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	priority = 1000000;
a262 2

      
d279 1
a279 1
  //try {
d284 8
d321 7
a327 8
          std::cout 
          <<"-------------------------------------------------------"      <<std::endl
          <<"Warning:  calendarType specified as monthYear"                <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
          <<"   but no startMonth specified "                              <<std::endl
          <<"   startMonth assumed to be 1 "                               <<std::endl
          <<"-------------------------------------------------------"      <<std::endl;
          startmonth=1;
d333 8
a340 8
          std::cout 
          <<"-------------------------------------------------------"      <<std::endl
          <<"Warning:  calendarType specified as monthYear"                <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
          <<"   but no startYear specified "                               <<std::endl
          <<"   startYear assumed to be 2004 "                             <<std::endl
          <<"-------------------------------------------------------"      <<std::endl;
          startyear=2004;
d345 8
a352 9
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"      <<std::endl
          <<"Warning: unknown calendarType specified."                     <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
          <<"   calendarType specified: " <<ct                             <<std::endl
          <<"   allowed values: period monthYear"                          <<std::endl
          <<"   Assumed type is period "                                   <<std::endl
          <<"-------------------------------------------------------"      <<std::endl;
d362 9
a370 11
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"      <<std::endl
        <<"Warning: unknown problem specified."                          <<std::endl
        <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
        <<"   problem specified: " <<theProb                             <<std::endl
        <<"   allowed values: resourceAction gapGlut"                    <<std::endl
        <<"   resourceAction performed "                                 <<std::endl
        <<"-------------------------------------------------------"      <<std::endl;
      theProb="resourceAction";
    }
d375 3
a377 4
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"      <<std::endl
        <<"Warning: unknown algorithm specified."                        <<std::endl
d381 2
a382 3
        <<"   resourceAction will be performed "                         <<std::endl
        <<"-------------------------------------------------------"      <<std::endl;
      theAlg="optimalPlan";
d389 3
a391 4
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"      <<std::endl
        <<"Warning: unknown fileFormat specified."                       <<std::endl
d395 2
a396 3
        <<"   03Dec will be performed "                                  <<std::endl
        <<"-------------------------------------------------------"      <<std::endl;
      fileFormat="03Dec";
d402 7
d423 5
a427 5
          std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: hasResourceCosts value must be yes or no"               <<std::endl
          <<"   It is assumed to be no. "                                     <<std::endl          <<"-------------------------------------------------------"         <<std::endl;
          hRC=false;
d444 5
a448 6
      std::cout 
      <<"-------------------------------------------------------"         <<std::endl
      <<"Warning: resourceIdPriority value must be yes or no"             <<std::endl
      <<"   It is assumed to be no. "                                     <<std::endl
      <<"-------------------------------------------------------"         <<std::endl;
      rIdPriority = false;
d466 5
a470 6
             std::cout 
             <<"-------------------------------------------------------"         <<std::endl
             <<"Warning: globalSubstitution value must be yes or no"             <<std::endl
             <<"   It is assumed to be no. "                                     <<std::endl
             <<"-------------------------------------------------------"         <<std::endl;
             globalSubstitution=false;
d481 5
a485 6
          std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: toFromSubs value must be yes or no"                     <<std::endl
          <<"   It is assumed to be no. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
          tfSubs=false;
a486 1

d498 5
a502 6
          std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: prioritySubstitution value must be yes or no"           <<std::endl
          <<"   It is assumed to be no. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
          pSubs=false;
d544 1
a544 1
      float revenue = engagementFileIter.revenueAsFloat();
d556 1
a556 1
      int priority = engagementFileIter.priorityAsInt();
d560 9
a568 10
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: quantity is negative"                <<std::endl
          <<"   engagement filename: " <<engagementFile.filename().c_str()    <<std::endl
          <<"   engagement file line number: " <<engagementFileIter.recNum()  <<std::endl
          <<"   engagementName: " <<engagementName.c_str()                    <<std::endl                              <<std::endl
          <<"   quantity will be set to zero. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        quantity = 0.0;
d573 3
a575 4
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: startPeriod is beyond planning horizion"                <<std::endl
d579 2
a580 5
          <<"   startPeriod: " <<startPeriod                                  <<std::endl
          <<"   allowed range: 0<=startPeriod<" <<nPeriods                    <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
d615 9
d650 9
d721 1
a721 1
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat();
d728 7
a734 9
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"                  <<std::endl
          <<"Warning: Resource does not exist"                                         <<std::endl
          <<"   resource action filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   resource action file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"   record will be ignored. "                                              <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
        continue;
d766 1
d774 1
a774 1
         else
d776 10
d810 7
a816 11
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<bomFileName                            <<std::endl
          <<"   resource file line number: " <<bomFileIter.recNum()      <<std::endl            
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
d821 9
a829 11
        // Engagement does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Engagement does not exist"                             <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
d849 8
a856 12
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
d868 5
a872 6
          // Write warning message
           std::cout 
             <<"-------------------------------------------------------"         <<std::endl
             <<"Warning: resourceSub out of bounds"                              <<std::endl
             <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
             <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
a873 1
             <<"   period: " <<period                                            <<std::endl
d876 3
a878 4
             <<"   record will be ignored. "                                     <<std::endl
             <<"-------------------------------------------------------"         <<std::endl;
           continue;
         }
d886 10
a895 11
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: quantity is less than zero"                <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   quantity will be set to 0. "                                  <<std::endl
          <<"-------------------------------------------------------"         <<std::endl; 
          usageQuantity = 0.0;
d913 1
a913 15
  //read the substitution files
  #if 0
  if (!prioritySubs) {
  for (int i=0; i<numidentifiers; i++) {

    // Read subs file and pass info to rcp problem
    std::string SubsFileName = idir + "/"+prob.getResourceIdentifierNames()[i]+"Subs.csv";
    RCPgnrlSubsFile SubsFile(SubsFileName);
    readSubsFile(
      prob,
      SubsFile,
      prob.getResourceIdentifierNames()[i]);
  } 
  }
  #endif
d952 9
d1046 9
a1054 10
             // Write warning message
            std::cout 
            <<"-------------------------------------------------------"         <<std::endl
            <<"Warning: quantity is less than zero"                             <<std::endl
             <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
             <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl                     <<std::endl
             <<"   period: " <<period                                            <<std::endl
             <<"   quantity will be set to 0. "                                     <<std::endl
             <<"-------------------------------------------------------"         <<std::endl;
             usageQuantity=0.0;
d1058 7
a1064 11
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
d1162 1
a1162 1
    float cost = fileIter.fieldOnRecordAsFloat("cost");
@


1.142
log
@Added quantity to the engagement file.  The BOM or demand file is now more like a description of the offering.  Updated the reporting in engagementO.csv.
@
text
@d68 14
d570 13
d887 15
d1053 13
a1065 1

@


1.141
log
@Removed MULTIPLEENGAGEMENT ifdef's
Changed the start period of an engagement to it's real start period.
@
text
@d555 1
d581 2
d1052 2
@


1.140
log
@a few fixes to clean things up and put back the check on period being within the horizon
@
text
@a6 1
#define MULTIPLEENGAGEMENTS
a1148 1
#ifdef MULTIPLEENGAGEMENTS
a1153 3
#else
  retVal="engagement";
#endif
a1157 1
#ifdef MULTIPLEENGAGEMENTS
a1162 3
#else
  retVal="engagement";
#endif
@


1.139
log
@undid some changes
@
text
@d722 1
a722 1
    // Read resource File and set up structures for using data
d769 14
a782 1
      
@


1.138
log
@added a check that the supply period was within the planning horizon
@
text
@d722 1
a722 1
    // Read bom File and set up structures for using data
d770 1
a770 15
      // test to ensure period is within the planning horizon
      if ( period <0 || period >= nPeriods ) {
      // Write warning message
        std::cout 
        <<"-------------------------------------------------------"         <<std::endl
        <<"Warning: period is beyond planning horizion"                     <<std::endl
        <<"   demand filename: " <<bomFileName                              <<std::endl
        <<"   resource file line number: " << bomFileIter.recNum()          <<std::endl            
        <<"   period: " <<period                                            <<std::endl
        <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
        <<"   record will be ignored. "                                     <<std::endl
        <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

@


1.137
log
@remove "duration" from engagement files, along with "engagement location". Also, implement month/year format for engagement start times.
@
text
@d722 1
a722 1
    // Read resource File and set up structures for using data
d768 16
@


1.136
log
@change a 0 to a "no" in input files for consistency
@
text
@d278 1
a278 1
   prob.getTimer().printElapsedTime("done with everything before populate");
d307 1
a307 1
      rcpCal.setCalendarType(calendarType);
d537 1
a537 1
    RCPengagementFile engagementFile(engagementFileName);
a542 1
      std::string engLocName = engagementFileIter.engLocationName();
d544 10
a553 2
      int startPeriod =  engagementFileIter.startPeriodAsInt();
      int duration =  engagementFileIter.durationAsInt();
d578 1
a578 1
       prob.setEngagementDuration(engagementName,duration);
a579 1
       prob.setEngagementLocation(engagementName,engLocName);
d949 1
a949 1
  prob.getTimer().printElapsedTime("done reading resource file");
d1033 1
a1033 1
         prob.setEngagementDuration(engagementName,nPeriods);
a1034 1
         prob.setEngagementLocation(engagementName,"dummy");
d1056 1
a1056 1
   prob.getTimer().printElapsedTime("done reading bom file");
@


1.135
log
@found a bug in the substitution arcs when substitution was requested but no
substitution arcs given
@
text
@d404 5
a408 3
    int hasResourceCosts;
    if (!globalAttrFile.keyExists("hasResourceCosts"))
      hasResourceCosts=1;
d410 14
a423 2
      hasResourceCosts = globalAttrFile.fieldAsInt("hasResourceCosts","attrValue");
      
d440 1
a440 1
      <<"Warning: resourceIdPriority value must be yes or no"                <<std::endl
d485 1
a485 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods, tfSubs, globalSubstitution, rIdPriority, rcpCal, hasResourceCosts);
@


1.134
log
@when to look for per-line subs flags in bom file
@
text
@d728 4
a731 1
         if ((attributeValue=="UNSPECIFIED")) {
@


1.133
log
@changes to merge various formats together
@
text
@d704 1
a704 1
    RCPgnrlBomFile bomFile(bomFileName,numidentifiers,true, true, rcpCal.getCalendarType());
@


1.132
log
@populate.cpp:  added newline at the end of the file

rcpProblem.cpp:  Added some new structure to handle the sorting layer;
modified the sorting test case

rcpProblem.h:  modified the comparison operator for the sorting of the id
priorities to handle ids that default to zero.
@
text
@a14 1
#include "expPrioritySubsFile.h"
d112 1
a112 56
//learn about which fields are going to allow priority substitution,
//and what the allowed field names are
//with cost and leadtime
void readExpPrioritySubsDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & substitutionFileName
                      )
{
    RCPexpPrioritySubsFile file(substitutionFileName);
    RCPexpPrioritySubsFileIterator fileIter(file);
    
    std::string fromResourceIdValue, toResourceIdValue;
    std::string resourceIdName;
    fromResourceIdValue = "PRIORITY";
    int priority;
    float leadTime;
    float cost;
    // loop over the records
    //int recNo=0;
    for ( ; fileIter()!=NULL; ) {     
      resourceIdName = fileIter.resourceIdName();
      if ( !prob.resourceIdentifierNameExists(resourceIdName) ) {
	  //  Write warning message
	  std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: "+resourceIdName+" does not exist"                     <<std::endl
	  <<"   filename: " << substitutionFileName                          <<std::endl
	  <<"   record will be ignored. "                                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	    continue;
      }
      toResourceIdValue = fileIter.resourceIdValue();
      priority = fileIter.priorityAsInt();
      cost = fileIter.costAsFloat();
      leadTime = fileIter.leadTimeAsFloat();
     
      // test to ensure that substitute does not already exist
      if ( prob.subsExists(resourceIdName,fromResourceIdValue,toResourceIdValue) ) {
      //  Write warning message
      std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: "+resourceIdName+" substitute already exists"                <<std::endl
        <<"   filename: " << substitutionFileName                        <<std::endl
        <<"   from: " <<fromResourceIdValue.c_str()                                  <<std::endl
        <<"   to: " <<toResourceIdValue.c_str()                                      <<std::endl
        <<"   record will be ignored. "                                    <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      continue;
    }
    
    prob.addSubs(resourceIdName,fromResourceIdValue,toResourceIdValue);
    prob.setSubsAversion(resourceIdName,fromResourceIdValue,toResourceIdValue,priority);
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,cost);
    prob.setSubsLeadTime(resourceIdName,fromResourceIdValue,toResourceIdValue,leadTime);
  }
 }
d387 1
a387 1
    if ( fileFormat!="03Dec" &&  fileFormat!="04Feb" && fileFormat!="04Jun") {
d394 1
a394 1
        <<"   allowed values: 03Dec 04Feb 04Jun"                         <<std::endl
d410 1
a430 15
    //check for priority substitution; this is necessary to coallesce two formats including an older one
    std::string prioritySubs = globalAttrFile.fieldAsString("prioritySubs","attrValue");
    bool pSubs;
    if (prioritySubs =="no") 
       pSubs = false;
    else if (prioritySubs =="yes") 
       pSubs = true;
    else {
       std::cout 
       <<"-------------------------------------------------------"         <<std::endl
       <<"Warning: prioritySubstitution value must be yes or no"           <<std::endl
       <<"   It is assumed to be no. "                                     <<std::endl
       <<"-------------------------------------------------------"         <<std::endl;
       pSubs=false;
    }
d434 22
d471 1
a471 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods,pSubs, tfSubs, rIdPriority, rcpCal, hasResourceCosts);
d474 15
a505 1
              bool  prioritySubs,
d507 1
d588 4
d593 20
d614 1
a614 8
  //---------------------------------------------------------
  // Read priority substitution file. This simply defines which
  // fields implement priority substitition.
  //---------------------------------------------------------
  if (prioritySubs) {
    std::string subsfile = idir+"/priority.csv";
    readPrioritySubsDescriptionFile(prob,subsfile);
  }
d722 6
a727 1
         int value = bomFileIter.fieldOnRecordAsInt(substitutename);
@


1.131
log
@modifications to support ER5 format
@
text
@d1147 1
a1147 1
}@


1.130
log
@few more changes
@
text
@d15 2
d22 1
a22 1
#include "gnrlSubsFile.h"
d115 57
d184 1
d201 1
a218 1
    //set the cost to the same value
d223 54
d503 18
a520 3
    if (fileFormat=="03Dec") 
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods,pSubs, rIdPriority, rcpCal, hasResourceCosts);
       
d540 1
d623 1
a623 1
 //---------------------------------------------------------
d632 8
d847 1
d860 1
@


1.129
log
@few more changes to support new/updated format
@
text
@d491 3
a493 1
  //---------------------------------------------------------
d504 4
d598 1
a598 1
         std::string matchname = attributeName+"Sub";
d600 1
d606 1
a606 1
           subVector[j]=bomFileIter.fieldOnRecordAsInt(matchname);
@


1.128
log
@folding together original "engagement" oriented files with new ER5 files
@
text
@a18 1
//#include "bomFile.h"
d629 11
a639 11
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Resource does not exist"                               <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
d686 5
d702 1
d713 1
@


1.127
log
@more changes to support demandType
@
text
@a14 2
//#include "priority04JunFile.h"
#include "demandTypePriorityFile.h"
d19 1
a19 1
#include "bomFile.h"
a163 17
//learn about which fields are going to allow priority substitution,
//and what the to and from priorities are
#if 0
void readPriority04JunDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & substitutionFileName
                      )
{
    RCPpriority04JunFile file(substitutionFileName);
    RCPpriority04JunFileIterator fileIter(file);
    
    std::string fromResourceIdValue, toResourceIdValue;
    std::string resourceIdName;
    int priority;
    // loop over the records
    //int recNo=0;
    for ( ; fileIter()!=NULL; ) {     
a164 37
      resourceIdName = fileIter.resourceIdName();
      if ( !prob.resourceIdentifierNameExists(resourceIdName) ) {
	  //  Write warning message
	  std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: "+resourceIdName+" does not exist"                     <<std::endl
	  <<"   filename: " << substitutionFileName                          <<std::endl
	  <<"   record will be ignored. "                                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	    continue;
      }
      toResourceIdValue = fileIter.to();
      fromResourceIdValue = fileIter.from();
      priority = fileIter.priorityAsInt();
     
      // test to ensure that substitute does not already exist
      if ( prob.subsExists(resourceIdName,fromResourceIdValue,toResourceIdValue) ) {
      //  Write warning message
      std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: "+resourceIdName+" substitute already exists"                <<std::endl
        <<"   filename: " << substitutionFileName                        <<std::endl
        <<"   from: " <<fromResourceIdValue.c_str()                                  <<std::endl
        <<"   to: " <<toResourceIdValue.c_str()                                      <<std::endl
        <<"   record will be ignored. "                                    <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      continue;
    }
    
    prob.addSubs(resourceIdName,fromResourceIdValue,toResourceIdValue);
    prob.setSubsAversion(resourceIdName,fromResourceIdValue,toResourceIdValue,priority);
    //set the cost to the same value
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,(float)priority);
    prob.setSubsLeadTime(resourceIdName,fromResourceIdValue,toResourceIdValue,0.0);
  }
 }
#endif
a210 27
void readDemandTypePriorityFile(
                      RCPproblem & prob, 
                      const std::string & demandTypePriorityFileName
                      )
{
    RCPdemandTypePriorityFile file(demandTypePriorityFileName);
    RCPdemandTypePriorityFileIterator fileIter(file);
    
    std::string demandType;
    int priority;
    // loop over the records
    for ( ; fileIter()!=NULL; ) {     
      demandType = fileIter.demandType();
      priority = fileIter.priorityAsInt();
     

      // test to ensure that the resource priority is no greater than 1 million
      if ( priority > 1000000) {
	  //  Write warning message
	  std::cout 
	  <<"-------------------------------------------------------"        <<std::endl
	  <<"Warning: " +demandType+ "'s priority:"<<priority <<" is too large"                <<std::endl
	  <<"The priority will be truncated to 1000000"                      <<std::endl
	  <<"   filename: " << demandTypePriorityFileName                    <<std::endl
	  <<"-------------------------------------------------------"        <<std::endl;
	  priority = 1000000;
      }
a211 4
      
      prob.setDemandTypePriority(demandType,priority);
    }
}
d346 7
d358 31
d391 2
a392 3
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods,rcpCal);
    else if (fileFormat=="04Jun")
      populate04Jun(prob, idir, odir, resourceFileName, bomFileName, nPeriods, rcpCal);    
a393 15
        //check for priority substitution; this is necessary to coallesce two formats including an older one
        std::string prioritySubs = globalAttrFile.fieldAsString("prioritySubs","attrValue");
        bool pSubs;
        if (prioritySubs =="no") 
           pSubs = false;
        else if (prioritySubs =="yes") 
           pSubs = true;
        else {
          std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: prioritySubstitution value must be yes or no"                <<std::endl
          <<"   It is assumed to be no. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
          pSubs=false;
        }
a394 15
        //check for resourceIdPriority 
        std::string resourceIdPriority = globalAttrFile.fieldAsString("resourceIdPriority","attrValue");
        bool rIdPriority;
        if (resourceIdPriority =="no") 
           rIdPriority = false;
        else if (resourceIdPriority =="yes") 
           rIdPriority = true;
        else {
          std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: resourceIdPriority value must be yes or no"                <<std::endl
          <<"   It is assumed to be no. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
          rIdPriority = false;
        }
d411 4
a414 1
              RcpOptCalendar & rcpCal) 
d438 1
d464 24
d489 21
d519 4
a522 1
    readResourceFile(prob,resourceFileName,true,0.0f,false, 0, false,0,false, 0, false, 0, matchFlags,rcpCal);
d528 1
d577 2
a578 2
    RCPbomFile bomFile(bomFileName);
    RCPbomFileIterator bomFileIter(bomFile);
d580 1
d584 5
a588 5
      std::vector<int> resourceMatchFlags, resourceSubFlags;
      resourceIdValues.clear();
      resourceMatchFlags.clear();
      resourceSubFlags.clear();
      for (int j =0; j<numidentifiers; j++) {
a589 3
         std::string matchName = attributeName+"Match";
         std::string subName = attributeName+"Sub";

d591 3
a593 2
         int matchValue = bomFileIter.fieldOnRecordAsInt(matchName);
         int subValue = bomFileIter.fieldOnRecordAsInt(subName);
d595 8
a602 3
         resourceIdValues.push_back(attributeValue);
         resourceMatchFlags.push_back(matchValue);
         resourceSubFlags.push_back(subValue);
a603 3
      std::string engagementName = bomFileIter.engagementName();
      int period = bomFileIter.periodAsInt();
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();
d605 7
d629 1
a629 1
      if ( !prob.resourceExists(resourceIdValues) ) {
a660 21
      // test to ensure that each match has a valid value
      int resourceMatch;
      for (i=0; i<numidentifiers; i++) {
         resourceMatch=resourceMatchFlags.at(i);
         if ( resourceMatch < 0 || resourceMatch > 1 ) {
           std::string matchString =  prob.getResourceIdentifierNames()[i]+"Match";
          // Write warning message
           std::cout 
             <<"-------------------------------------------------------"         <<std::endl
             <<"Warning: resourceMatch out of bounds"                             <<std::endl
             <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
             <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
             <<"   engagement: " <<engagementName.c_str()                        <<std::endl
             <<"   period: " <<period                                            <<std::endl
             <<"   matchFlag: " <<     matchString                               <<std::endl
             <<"   valid range: 0 <= matchString  <= 1"                          <<std::endl
             <<"   record will be ignored. "                                     <<std::endl
             <<"-------------------------------------------------------"         <<std::endl;
           continue;
         }
      }
d665 1
a665 1
         resourceSub=resourceSubFlags.at(i);
d684 3
a686 2
      if ( !prob.bomExists(engagementName,resourceIdValues) )
         prob.addBom(engagementName,resourceIdValues);
d688 1
a688 1
      prob.setBomUsageQuantity(engagementName,resourceIdValues,period,usageQuantity);
d691 2
a692 2
         prob.setBomMatch(engagementName, resourceIdValues, period, resourceIdName, resourceMatchFlags.at(i));
         prob.setBomSub(engagementName,resourceIdValues,period,resourceIdName,resourceSubFlags.at(i));
d726 1
a726 1
//---------------------------------------------------------
d770 3
a772 1
    //prob.getTimer().printElapsedTime("about to read resource file");
d792 1
a792 1
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, false, 0, rcpCal.getCalendarType());
a799 1
      //localMatchVector = globalMatchVector;
a892 221

   
    //now that we've read all the boms, create a reasonable engagment
    //revenue. It ought to be more than nPeriods*(total num required per period)
    //loop once for each engagment 
    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); e++) {
      
      // loop once for each resource consumed be engagementNames[e]
      float engagementRevenue=0.f;
      std::vector<RCPvectorString> consumedResources = prob.getEngagementConsumedResources(engagementNames[e]);
      unsigned int r;
      for (r=0; r<consumedResources.size(); ++ r ) {
        std::vector<float> uq = prob.getBomUsageQuantity(engagementNames[e],consumedResources[r]);
        std::vector<float> fc = prob.getResourceFixedCost(consumedResources[r]);
        unsigned int t;
        for ( t=0; t<uq.size(); ++t ) {
          engagementRevenue = engagementRevenue + uq[t]*fc[t];
        }
      }
      engagementRevenue = 1000.0f * engagementRevenue;
      prob.setEngagementRevenue(engagementNames[e],engagementRevenue);
    }


  }
     
 
}
void populate04Jun(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              const std::string & rFileName,
              const std::string & bFileName,
              int   nPeriods,
              RcpOptCalendar & rcpCal) 
{
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  //prob.getTimer().printElapsedTime("begining populate04feb");

//---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------
  int numidentifiers = prob.getResourceIdentifierNames().size();
  
  std::vector<int> globalMatchVector(numidentifiers);
  std::vector<int> subVector(numidentifiers);
  std::vector<int> localMatchVector(numidentifiers);

  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPgnrlMatchFile matchFile(matchFileName,prob.getResourceIdentifierNames().size());
    RCPgnrlMatchFileIterator matchFileIter(matchFile);
    matchFileIter(); 
    

    for (int i=0; i<numidentifiers; i++) {
       std::string attributeMatchName = prob.getResourceIdentifierNames()[i]+"Match";
       int matchValue = matchFileIter.fieldOnRecordAsInt(attributeMatchName);
       globalMatchVector[i] = matchValue;
    }
        
  }  
  
  //---------------------------------------------------------
  // Read priority substitution file. 
  //---------------------------------------------------------
  std::string subsfile = idir+"/priority.csv";
  readPrioritySubsDescriptionFile(prob,subsfile);
  

  
  //---------------------------------------------------------
  // Read resource ID priority file. This simply defines which
  // priorities for the resource IDs.
  //---------------------------------------------------------

  std::string resourceIdPriorityFile = idir+"/idPriority.csv";
  readResourceIdPriorityDescriptionFile(prob,resourceIdPriorityFile);
  
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/"+rFileName.c_str();
    readResourceFile(prob,resourceFileName,false,1.f,true, 100, true,0, true, 1000000, true, 0, globalMatchVector,rcpCal);
  }

  

  //--------------------------------------------------------
  // Read demand type priority file
  //--------------------------------------------------------
  {
      std::string demandTypePriorityFilename = idir + "/demandTypePriority.csv";
      readDemandTypePriorityFile(prob,demandTypePriorityFilename);
  }
  
  
  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read bom File and set up structures for using data
    std::string bomFileName = idir + "/"+ bFileName.c_str();
    int numAttributes=prob.getResourceIdentifierNames().size();
    int numSubsColumns = numAttributes; //DLG assume that there is one for each column
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, true, numSubsColumns, rcpCal.getCalendarType());
    RCPgnrlBomFileIterator bomFileIter(bomFile);
    
    // loop once for each record in bom file    
    //initialize with the global match vector
 
    std::vector<std::string> resourceAttributeValues(numAttributes);
    for ( ; bomFileIter()!=NULL; ) {
      //localMatchVector = globalMatchVector;
      for (int ii=0; ii<numAttributes; ii++)
         localMatchVector[ii] = 1;
      
      //int demandPriority;
      std::string demandType;
      
      for (int j=0; j<numAttributes; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = bomFileIter.fieldOnRecord(attributeName);
         if (globalMatchVector[j]==0)
             attributeValue = "unmatched";
             
         std::string attributeSubs = attributeName+"Subs";
         subVector[j] = bomFileIter.fieldOnRecordAsInt(attributeSubs);
 
         if ((attributeValue=="UNSPECIFIED")) {
           localMatchVector[j]=0; //overwrite the match value with 0 for this bom entry
           subVector[j]=0;
         }
         else 
           subVector[j]=0;
           
         resourceAttributeValues[j]=attributeValue;
         
      }
      demandType = bomFileIter.demandType();
      //demandPriority = prob.getDemandTypePriority(demandType); //DLG now we need to do something with it
     
      int period;
      if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD) 
         period = bomFileIter.periodAsInt();
      else {
         period = rcpCal.computePeriodFromMonthAndYear(bomFileIter.monthAsInt(), bomFileIter.yearAsInt());
      }
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();

      // test to ensure period is within the planning horizon
      if ( period < 0 || period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
 
     
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. add it.

       prob.addResource(resourceAttributeValues);
       prob.setResourceSupplyQuantity(resourceAttributeValues,period,0.0);
       if (period == 0){
         prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,0.0);
       }
       prob.setResourceFixedCost(resourceAttributeValues,period,1.0);
       prob.setResourceAcquireCost(resourceAttributeValues,100.0);
       prob.setResourceReleaseCost(resourceAttributeValues,1000000.0);
       
      }
      
     
      //need to create an engagement name

      std::string engagementName= createEngagementName(resourceAttributeValues, demandType);
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         prob.setEngagementStartPeriod(engagementName,0);
         prob.setEngagementDuration(engagementName,nPeriods);
         prob.setEngagementLateAllowance(engagementName,0);
         prob.setEngagementLocation(engagementName,"dummy");
      }


      if ( !prob.bomExists(engagementName,resourceAttributeValues) )
         prob.addBom(engagementName,resourceAttributeValues);
         
      //get prior usageQuantity
      float priorUsageQuantity = prob.getBomUsageQuantity(engagementName, resourceAttributeValues,period);
      usageQuantity=usageQuantity+priorUsageQuantity;
      prob.setBomUsageQuantity(engagementName,resourceAttributeValues,period,usageQuantity);

      unsigned int i;
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         prob.setBomMatch(engagementName, resourceAttributeValues, period, prob.getResourceIdentifierNames()[i], localMatchVector[i]);
      }
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         std::string resourceName = prob.getResourceIdentifierNames()[i];
         prob.setBomSub(engagementName,resourceAttributeValues,period,resourceName,subVector[i]);
      }
     }

   //prob.getTimer().printElapsedTime("done reading bom file");
@


1.126
log
@support for handling demandType and demandTypePriority
@
text
@d1056 1
a1056 1
      int demandPriority;
d1079 1
a1079 1
      demandPriority = prob.getDemandTypePriority(demandType); //DLG now we need to do something with it
d1123 1
a1123 1
      std::string engagementName= createEngagementName(resourceAttributeValues);
d1151 1
a1151 1
   prob.getTimer().printElapsedTime("done reading bom file");
d1241 13
@


1.125
log
@some changes to support ER5; adding columns for demand type, flags for substituion
@
text
@d16 1
d267 15
d283 16
d1027 9
a1035 1

a1037 2
  // DLG this has to change to look for "demandType"; we also need to read the
  // demandTypePriority file and do something with it
d1056 2
d1076 1
d1078 3
a1080 1
      
@


1.124
log
@Implemented the reasource action leadtime notification model and updated some unitTest cases to reflect this change.  In earlier versions, although we read in the leadtime parameter, the optimization model didn't implement the leadtime and set it to zero.
@
text
@d15 1
d165 17
d183 37
d385 1
a385 1
    if ( fileFormat!="03Dec" &&  fileFormat!="04JanSubs" && fileFormat!="04Feb") {
d392 1
a392 1
        <<"   allowed values: 03Dec 04Feb"               <<std::endl
d409 2
d412 1
a412 1
        //check for priority substitution
d797 1
a797 1
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, rcpCal.getCalendarType());
d809 1
a809 3
      //DLG note that there is no requirement that
      //"UNSPECIFIED" be found only in the "allowed" fields.
      //
d819 210
@


1.123
log
@commented out assorted asserts and did things to make the eclipse compiler happy. Also for cleanliness, added "acquireTime" to readResourceFile.
@
text
@d504 2
a505 1

a507 1

@


1.122
log
@undefine "DOTIMING"
@
text
@d34 2
d98 2
d127 1
a127 1
    int recNo=0;
d177 1
a177 1
    int recNo=0;
d461 1
a461 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0,false, 0, false, 0, matchFlags,rcpCal);
d727 1
a727 1
    readResourceFile(prob,resourceFileName,false,1.f,true,100, true, 1000000, true, 0, globalMatchVector,rcpCal);
@


1.121
log
@Removed compilation of a Java file.  Changed an for (int i=0,....) scoping because AIX didn't like it.
@
text
@d8 1
a8 1
#define DOTIMING
@


1.120
log
@put initialization of timer in rcpProblem constructor.
@
text
@d584 3
a586 1
      
d589 1
a589 1
      for (int i=0; i<numidentifiers; i++) {
d611 1
a611 1
      for (int i=0; i<numidentifiers; i++) {
d635 1
a635 1
      for (int i=0; i<numidentifiers; i++) {
@


1.119
log
@fixed timing issues
@
text
@d51 1
a51 1
  std::vector<std::string> resourceAttributeValues;
a52 1
    resourceAttributeValues.clear();
d58 1
a58 1
      resourceAttributeValues.push_back(attributeValue);
d740 1
a740 1

a744 3

      std::vector<std::string> resourceAttributeValues;
      resourceAttributeValues.clear();
d764 1
a764 1
         resourceAttributeValues.push_back(attributeValue);
@


1.118
log
@adding timing capability
@
text
@d218 1
a218 1
   prob.getTimer().printElapsedTime("beginning populate");
d669 1
a669 1
  prob.getTimer().printElapsedTime("begining populate04feb");
d715 1
a715 1
    prob.getTimer().printElapsedTime("about to read resource file");
d727 1
a727 1
  prob.getTimer().printElapsedTime("about to read bom file");
d841 2
a842 1
 
@


1.117
log
@just removed some old comments
@
text
@d8 2
d218 2
d669 1
a669 1
   
d715 1
a715 1
  
d727 1
a727 1
    
@


1.116
log
@Changed some j's to i's in loops that were just changed.
@
text
@a669 2
  //int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, regionMatch, countryMatch, cityMatch;
  //int bandMatch, reportingUnitMatch,globalMatch, competencyMatch, industryMatch;
d734 1
a734 5
    // loop once for each record in bom file
    
    //int jobRoleSub, skillSetSub, lobSub, sourceSub, regionSub, countrySub, citySub;
    //int bandSub, globalSub, competencySub, reportingUnitSub, industrySub;
    
a870 1
// This used for reading jobRoleSubs, skillSubs, locationSubs, lobSubs, and sourceSubs
@


1.115
log
@updates for more genearlity in the substitution
@
text
@d587 1
a587 1
           std::string matchString =  prob.getResourceIdentifierNames()[j]+"Match";
d609 1
a609 1
           std::string subString =  prob.getResourceIdentifierNames()[j]+"Sub";
@


1.114
log
@continuing the process of generalizing 03Dec format
@
text
@d19 1
a19 5
#include "jobRoleSubsFile.h"
#include "skillSubsFile.h"
#include "locationSubsFile.h"
#include "lobSubsFile.h"
#include "sourceSubsFile.h"
d638 2
a639 29
  //---------------------------------------------------------
  // Read jobRoleSubs file
  //---------------------------------------------------------
  {
    // Read jobRole subs file and pass info to rcp problem
    std::string jobRoleSubsFileName = idir + "/jobRoleSubs.csv";
    RCPjobRoleSubsFile jobRoleSubsFile(jobRoleSubsFileName);
    readSubsFile(
      prob,
      jobRoleSubsFile,
      "jobRole",
      "JobRole");
  } //end of reading jobRoleSubs file
  //---------------------------------------------------------
     
  //---------------------------------------------------------
  // Read skillSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string skillSubsFileName = idir + "/skillSubs.csv";
    RCPskillSubsFile skillSubsFile(skillSubsFileName);
    readSubsFile(
      prob,
      skillSubsFile,
      "skillSet",
      "Skill");
  } //end of reading skillSubs file
  //---------------------------------------------------------
d641 3
a643 7
  //---------------------------------------------------------
  // Read locationSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string locationSubsFileName = idir + "/locationSubs.csv";
    RCPlocationSubsFile locationSubsFile(locationSubsFileName);
d646 4
a649 35
      locationSubsFile,
      "resourceLocName",
      "Location" );
  } //end of reading locationSubs file
  //---------------------------------------------------------

  //---------------------------------------------------------
  // Read lobSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string lobSubsFileName = idir + "/lobSubs.csv";
    RCPlobSubsFile lobSubsFile(lobSubsFileName);
    readSubsFile(
      prob,
      lobSubsFile,
      "LOB",
      "Lob");
  } //end of reading lobSubs file
  //---------------------------------------------------------

  //---------------------------------------------------------
  // Read sourceSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string sourceSubsFileName = idir + "/sourceSubs.csv";
    RCPsourceSubsFile sourceSubsFile(sourceSubsFileName);
    readSubsFile(
      prob,
      sourceSubsFile,
      "resourceLocName",
      "Source" );
  } //end of reading sourceSubs file
  //---------------------------------------------------------
d882 1
a882 2
                  const std::string & resourceIdName,
                  const std::string & subsName )
d888 2
a889 2
    std::string fromSkill = fileIter.fieldOnRecord(std::string("from")+subsName);
    std::string toSkill = fileIter.fieldOnRecord(std::string("to")+subsName);
d894 1
a894 1
    if ( prob.subsExists(resourceIdName,fromSkill,toSkill) ) {
d898 1
a898 1
        <<"Warning: "+subsName+" substitute already exists"                <<std::endl
d901 2
a902 2
        <<"   from: " <<fromSkill.c_str()                                  <<std::endl
        <<"   to: " <<toSkill.c_str()                                      <<std::endl
d910 3
a912 3
    prob.addSubs(resourceIdName,fromSkill,toSkill);
    prob.setSubsCost(resourceIdName,fromSkill,toSkill,cost);
    prob.setSubsLeadTime(resourceIdName,fromSkill,toSkill,leadTime);
d914 1
a914 1
    prob.setSubsAversion(resourceIdName,fromSkill,toSkill,1);
@


1.113
log
@more progress to generalizing the 03Dec format
@
text
@d467 1
a467 1
    RCPgnrlResourceActionFile resourceActionFile(resourceFileName,5);
d472 7
a478 5
      std::string jobRole = resourceActionFileIter.jobRole();
      std::string skillSet = resourceActionFileIter.skillSet();
      std::string LOB = resourceActionFileIter.LOB();
      std::string source = resourceActionFileIter.source();
      std::string resourceLoc = resourceActionFileIter.resourceLocName();
a482 8
      

      RCPvectorString resourceIdValues;
      resourceIdValues.push_back(jobRole);
      resourceIdValues.push_back(skillSet);
      resourceIdValues.push_back(LOB);
      resourceIdValues.push_back(source);
      resourceIdValues.push_back(resourceLoc);
a491 2
          <<"   resource: " <<jobRole.c_str()                                     <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                             <<std::endl
d517 18
a534 5
      std::string jobRole = bomFileIter.jobRole();
      std::string skillSet = bomFileIter.skillSet();
      std::string LOB = bomFileIter.LOB();
      std::string source = bomFileIter.source();
      std::string resourceLoc = bomFileIter.resourceLocName();
a537 11
      int jobRoleMatch  = bomFileIter.jobRoleMatchAsInt();
      int skillSetMatch = bomFileIter.skillSetMatchAsInt();
      int locationMatch = bomFileIter.locationMatchAsInt();
      int lobMatch      = bomFileIter.lobMatchAsInt();
      int sourceMatch   = bomFileIter.sourceMatchAsInt();
      int jobRoleSub  = bomFileIter.jobRoleSubAsInt();
      int skillSetSub = bomFileIter.skillSetSubAsInt();
      int locationSub = bomFileIter.locationSubAsInt();
      int lobSub      = bomFileIter.lobSubAsInt();
      int sourceSub   = bomFileIter.sourceSubAsInt();

a538 6
      RCPvectorString resourceIdValues;
      resourceIdValues.push_back(jobRole);
      resourceIdValues.push_back(skillSet);
      resourceIdValues.push_back(LOB);
      resourceIdValues.push_back(source);
      resourceIdValues.push_back(resourceLoc);
a548 2
          <<"   resource: " <<jobRole.c_str()                           <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                   <<std::endl
a563 2
          <<"   resource: " <<jobRole.c_str()                           <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                   <<std::endl
a578 2
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
d586 42
a627 130
      // test to ensure jobRolMatch has a valid value
      if ( jobRoleMatch < 0 || jobRoleMatch > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: jobRoleMatch out of bounds"                             <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   jobRoleMatch: " <<jobRoleMatch                                <<std::endl
          <<"   valid range: 0 <= jobRoleMatch <= 1"                          <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure skillSetMatch has a valid value
      if ( skillSetMatch < 0 || skillSetMatch > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: skillSetMatch out of bounds"                            <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   skillSetMatch: " <<skillSetMatch                              <<std::endl
          <<"   valid range: 0 <= skillSetMatch <= 1"                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure locationMatch has a valid value
      if ( locationMatch < 0 || locationMatch > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: locationMatch out of bounds"                            <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   locationmatch: " <<locationMatch                              <<std::endl
          <<"   valid range: 0 <= locationMatch <= 1"                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure lobMatch has a valid value
      if ( lobMatch < 0 || lobMatch > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: lobSub out of bounds"                                   <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   lobMatch: " <<lobMatch                                        <<std::endl
          <<"   valid range: 0 <= lobMatch <= 1"                              <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure sourceMatch has a valid value
      if ( sourceMatch < 0 || sourceMatch > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: sourceMatch out of bounds"                              <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   sourceMatch: " <<sourceMatch                                  <<std::endl
          <<"   valid range: 0 <= sourceMatch <= 1"                           <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
       // test to ensure jobRolSub has a valid value
      if ( jobRoleSub < 0 || jobRoleSub > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: jobRoleSub out of bounds"                               <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   jobRoleSub: " <<jobRoleSub                                    <<std::endl
          <<"   valid range: 0 <= jobRoleSub <= 1"                            <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure skillSetSub has a valid value
      if ( skillSetSub < 0 || skillSetSub > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: skillSetSub out of bounds"                              <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   skillSetSub: " <<skillSetSub                                  <<std::endl
          <<"   valid range: 0 <= skillSetSub <= 1"                           <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
d629 1
a629 60
      
      // test to ensure locationSub has a valid value
      if ( locationSub < 0 || locationSub > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: locationSub out of bounds"                              <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   locationSub: " <<locationSub                                  <<std::endl
          <<"   valid range: 0 <= locationSub <= 1"                           <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure lobSub has a valid value
      if ( lobSub < 0 || lobSub > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: lobSub out of bounds"                                   <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   lobSub: " <<lobSub                                            <<std::endl
          <<"   valid range: 0 <= lobSub <= 1"                                <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      // test to ensure sourceSub has a valid value
      if ( sourceSub < 0 || sourceSub > 1 ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: sourceSub out of bounds"                                <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                                  <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   sourceSub: " <<sourceSub                                      <<std::endl
          <<"   valid range: 0 <= sourceSub <= 1"                             <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }



d634 5
a638 10
      prob.setBomMatch(engagementName,resourceIdValues,period,"jobRole",jobRoleMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"skillSet",skillSetMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"resourceLocName",locationMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"LOB",lobMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"source",sourceMatch);
      prob.setBomSub(engagementName,resourceIdValues,period,"jobRole",jobRoleSub);
      prob.setBomSub(engagementName,resourceIdValues,period,"skillSet",skillSetSub);
      prob.setBomSub(engagementName,resourceIdValues,period,"resourceLocName",locationSub);
      prob.setBomSub(engagementName,resourceIdValues,period,"LOB",lobSub);
      prob.setBomSub(engagementName,resourceIdValues,period,"source",sourceSub);
@


1.112
log
@support more general input files for the 03dec format (no hardwired column names"
@
text
@d18 1
a18 1
#include "resourceActionFile.h"
d467 2
a468 2
    RCPresourceActionFile resourceActionFile(resourceFileName);
    RCPresourceActionFileIterator resourceActionFileIter(resourceActionFile);
@


1.111
log
@changed unspecified and priority to UNSPECIFIED and PRIORITY
@
text
@d339 10
a351 8
        //initialize the fields
      char name[100];
      int numResourceIds = globalAttrFile.fieldAsInt("nResourceIds","attrValue");
      for (int j=0; j<numResourceIds; j++) {
        sprintf(name,"resourceId%d",j);
        std::string attr = globalAttrFile.fieldAsString(name,"attrValue");
        prob.addResourceIdentifierName(attr);
      }
d403 2
a404 9
  
  // define resourceIdNames
  {
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    prob.addResourceIdentifierName("LOB");
    prob.addResourceIdentifierName("source");
    prob.addResourceIdentifierName("resourceLocName");
  }
d895 2
a896 2
              bool   prioritySubs,
	      bool   resourceIdPriority,
@


1.110
log
@priorityGapGlut1 now works off the multiple demands that get created, one for each resource, in populate.  Turn off the definition of MULTIPLEENGAGEMENTS at the top of rcpProblem.cpp and populate.cpp to get back to the old approach of one engagement.
@
text
@d123 1
a123 1
    fromResourceIdValue = "priority";
d159 1
a159 1
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,priority);
d994 1
a994 1
      //"unspecified" be found only in the "allowed" fields.
d1001 1
a1001 1
         if ((attributeValue=="priority")) {
d1004 1
a1004 1
         else if ((attributeValue=="unspecified")) {
@


1.109
log
@reorder tests, and fix comment about tests
@
text
@d7 1
a7 1
//#define MULTIPLEENGAGEMENTS
d1174 1
a1174 1
}@


1.108
log
@fix up unit test for checking for subs. arcs
@
text
@d7 1
a7 1
#define MULTIPLEENGAGEMENTS
@


1.107
log
@Modified implementation of MULTIPLEENGAGEMENTS so that the difference is now contained in the engagementName method, rather than the code that calls engagementName.
@
text
@d7 1
a7 1
//#define MULTIPLEENGAGEMENTS
a1001 1
           attributeValue="priority";
a1004 1
           attributeValue="unspecified"; //lower case is looked for elsewhere
@


1.106
log
@added in one engagement per bom entry. Ifdef'd out currently
@
text
@d1057 1
a1057 1
#ifdef MULTIPLEENGAGEMENTS
a1058 4
#else
      std::string engagementName= createEngagementName();
#endif
 
a1163 5
std::string createEngagementName(){
   //this needs to be defined!
   std::string returnval = "engagement";
   return returnval;
}
d1166 1
d1172 3
@


1.105
log
@accept UNSPECIFIED and PRIORITY
@
text
@d7 2
d1001 1
a1001 1
         if ((attributeValue=="priority")||(attributeValue=="PRIORITY")) {
d1005 1
a1005 1
         else if ((attributeValue=="unspecified")||(attributeValue=="UNSPECIFIED")) {
d1057 3
d1061 2
d1173 9
a1181 1

@


1.104
log
@need to check the planning horizon before setting some attributes on the resource
@
text
@d34 5
d99 4
d156 2
a157 2
    //set these to reasonable values
    prob.setSubsCost(resourceIdName,fromResourceIdValue,toResourceIdValue,0.0);
d461 1
a461 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0,matchFlags,rcpCal);
d959 1
a959 1
    readResourceFile(prob,resourceFileName,false,1.f,true,1.5, globalMatchVector,rcpCal);
d999 2
a1000 1
         if (attributeValue=="priority") 
d1002 3
a1004 1
         else if (attributeValue=="unspecified") {
d1040 1
a1040 1
        // Resource does not exist. Write warning message
d1047 3
a1049 2
       prob.setResourceFixedCost(resourceAttributeValues,period,0.0);
       prob.setResourceAcquireCost(resourceAttributeValues,0.0);
d1105 1
a1105 1
      engagementRevenue = 4.0f * engagementRevenue;
@


1.103
log
@populate.cpp will truncate resource ID priorities to 1 million
@
text
@a1009 25

     
      // test to ensure that resource exist
      if ( !prob.resourceExists(resourceAttributeValues) ) {
        // Resource does not exist. Write warning message
#if 0
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Resource does not exist"                               <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
           <<"   period: " <<period                                           <<std::endl
          <<"   a dummy resource with 0 supply will be added. "               <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
#endif
       prob.addResource(resourceAttributeValues);
       prob.setResourceSupplyQuantity(resourceAttributeValues,period,0.0);
       if (period == 0){
         prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,0.0);
       }
       prob.setResourceFixedCost(resourceAttributeValues,period,0.0);
       prob.setResourceAcquireCost(resourceAttributeValues,0.0);
       
      }
      
d1024 15
d1040 1
@


1.102
log
@removed some warnings
@
text
@d181 13
@


1.101
log
@cleaner handling of match=0; just set that field to "unmatched"
@
text
@d1002 1
d1011 1
a1011 5
       //DLG NOTE WE HAVE MAY A LITTLE PROBLEM HERE
       //we may need to not add the capability of acquiring new resources
       //for this type, since that's not really relevant. Should we 
       //have a different version of addResource which doesn't add the
       //whole structure?
@


1.100
log
@trivial changes
@
text
@d34 1
d52 2
d84 2
d438 2
a439 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0,rcpCal);
d937 1
a937 1
    readResourceFile(prob,resourceFileName,false,1.f,true,1.5, rcpCal);
d962 3
a964 1
      localMatchVector = globalMatchVector;
d975 2
d1053 4
a1056 1

@


1.99
log
@Minor cosmetic change. Assignment of stl vector to anthor stl vector is now longer being done in a loop
@
text
@a45 1
  //std::vector<std::string> *resourceAttributeValues=new std::vector<std::string>;
d85 1
@


1.98
log
@fixed something that the linux compiler was unhappy about
@
text
@d956 1
a956 3
       for (int ii = 0; ii<numidentifiers; ii++) {
          localMatchVector[ii] = globalMatchVector[ii];
       } 
d1045 3
a1047 2
      
      for (unsigned int i=0; i<prob.getResourceIdentifierNames().size(); i++) {
d1050 1
a1050 1
      for (unsigned int i=0; i<prob.getResourceIdentifierNames().size(); i++) {
@


1.97
log
@fixed header in writing out files.
In populate, need to reinitialize match vector *each* time a bom record is read
@
text
@d956 2
a957 2
       for (int i = 0; i<numidentifiers; i++) {
          localMatchVector[i] = globalMatchVector[i];
d959 1
d1048 1
a1048 1
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
d1051 1
a1051 1
      for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
@


1.96
log
@warn if a column name doesn't exist when reading priority.csv
@
text
@d118 1
a118 1
	  <<"   filename: " << substitutionFileName                    <<std::endl
a952 3
    for (int i = 0; i<numidentifiers; i++) {
       localMatchVector[i] = globalMatchVector[i];
    }
d956 3
a958 3

       unsigned int i;
 
@


1.95
log
@New file:  resourceIdPriorityFile.h  defines a new input file format for resource identifier priorities
and added code to read in this file in populate

Changed the spelling of ...Identifer... to ...Identifier...

Modified priorityGapGlut1(), but this is not invoked yet.
@
text
@d113 10
@


1.94
log
@more calendar handling
@
text
@d11 1
d138 34
d326 16
d343 1
a343 1
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs,rcpCal);
d861 1
d902 11
@


1.93
log
@use month/year format
@
text
@a32 2

                      RcpOptCalendar::CalendarType calendarType,
d38 1
a38 1
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,readFixedCost,calendarType);
d54 1
a54 1
    if (calendarType==RcpOptCalendar::PERIOD)
d165 2
d173 2
d266 1
a266 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods,calendarType, rcpCal);
d292 1
a292 1
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs,calendarType, rcpCal);
a306 1
              RcpOptCalendar::CalendarType calendarType,
d372 1
a372 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0,calendarType, rcpCal);
a809 1
              RcpOptCalendar::CalendarType calendarType,
d858 1
a858 1
    readResourceFile(prob,resourceFileName,false,1.f,true,1.5,calendarType, rcpCal);
d871 1
a871 1
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false, calendarType);
d911 1
a911 1
      if (calendarType==RcpOptCalendar::PERIOD) 
@


1.92
log
@preparation for handling calendar style period information.
@
text
@d871 1
a871 1
    RCPgnrlBomFile bomFile(bomFileName,numAttributes,false);
d910 6
a915 1
      int period = bomFileIter.periodAsInt();
@


1.91
log
@added methods
void setResourceIdentifierSubstitutePriority(const std::string & identifierName, int priority );
int getResourceIdentifierSubstitutePriority(const std::string & identifierName )const;
@
text
@d34 2
a35 1
                      RcpOptCalendar::CalendarType calendarType
d55 6
a60 1
    int period = resourceFileIter.periodAsInt();
d143 2
a144 1
              const std::string & odir) 
d171 1
a171 1
      else if ( ct=="monthYear" )        
d173 29
d264 1
a264 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods,calendarType);
d290 1
a290 1
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs,calendarType);
d305 2
a306 1
              RcpOptCalendar::CalendarType calendarType) 
d371 1
a371 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0,calendarType);
d809 2
a810 1
              RcpOptCalendar::CalendarType calendarType) 
d858 1
a858 1
    readResourceFile(prob,resourceFileName,false,1.f,true,1.5,calendarType);
d868 1
a868 1
    // Read resource File and set up structures for using data
@


1.90
log
@added method
bool resourceIdentiferNameExists( const std::string & name ) const
@
text
@d32 3
a34 1
                      float acquireCost   // value to set acquire cost
d39 1
a39 1
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,readFixedCost,RcpOptCalendar::PERIOD);
d160 18
d228 1
a228 1
      populate03Dec(prob, idir, odir,resourceFileName, bomFileName, nPeriods);
d254 1
a254 1
      populate04Feb(prob, idir, odir, resourceFileName, bomFileName, nPeriods, pSubs);
d268 2
a269 1
              int   nPeriods) 
d334 1
a334 1
    readResourceFile(prob,resourceFileName,true,0.0f,false,0);
d771 2
a772 1
              bool   prioritySubs) 
d820 1
a820 1
    readResourceFile(prob,resourceFileName,false,1.f,true,1.5);
@


1.89
log
@modified to include cassert instead of assert.h
@
text
@d155 3
@


1.88
log
@avoid potential memory leaks
@
text
@d37 1
a37 1
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,readFixedCost);
@


1.87
log
@removed some unused files
@
text
@d760 3
a762 5
  //std::vector<int> globalMatchVector(size);
  //globalMatchVector[5]=4;
  int * globalMatchVector = new int[numidentifiers];  
  int * subVector = new int[numidentifiers];
  int * localMatchVector = new int[numidentifiers];
d918 1
a918 4
    //free the match and substitute vectors
    free(globalMatchVector);
    free(localMatchVector);
    free(subVector);
@


1.86
log
@changed "prioritySubs" to "priority"
@
text
@d759 3
@


1.85
log
@Modified so specifying resource and bom file names in globalAttr.csv is optional
@
text
@d784 1
a784 1
    std::string subsfile = idir+"/prioritySubs.csv";
@


1.84
log
@appl.mk :  added rcpOptCal and rcpOptException to the list of files that get compiles
rcpOptCal.cpp and .h : new files that implement rcpOptCalendar
populateRCP.cpp : added tests to see if period is negative
rcpProblem.cpp : In priorityGapGlut1(), I now check to see that there is just one engagement and it
has a startPeriod of 0
unitTest.cpp : Call added to test rcpOptCalendar
@
text
@d147 8
a154 2
    std::string resourceFileName = globalAttrFile.fieldAsString("resourceFileName","attrValue");
    std::string bomFileName = globalAttrFile.fieldAsString("bomFileName","attrValue");
@


1.83
log
@allow variable names for resource and bom (supply and demand)
@
text
@d58 1
a58 1
    if ( period >= nPeriods ) {
d272 1
a272 1
      if ( startPeriod >= nPeriods ) {
d433 1
a433 1
      if ( period >= nPeriods ) {
d872 1
a872 1
      if ( period >= nPeriods ) {
@


1.82
log
@changed "prioritySubstitute" to "priority"
@
text
@d147 2
d199 1
a199 1
      populate03Dec(prob, idir, odir,nPeriods);
d225 1
a225 1
      populate04Feb(prob, idir, odir, nPeriods, pSubs);
d237 2
d303 1
a303 1
    std::string resourceFileName = idir + "/resource.csv";
d365 1
a365 1
    std::string bomFileName = idir + "/bom.csv";
d738 2
d787 1
a787 1
    std::string resourceFileName = idir + "/resource.csv";
d799 1
a799 1
    std::string bomFileName = idir + "/bom.csv";
@


1.81
log
@fixed a memory leak for the globalMatchVector, localMatchVector, and subsVector
@
text
@d100 1
a100 1
    fromResourceIdValue = "prioritySubstitute";
d822 1
a822 1
         if (attributeValue=="prioritySubstitute") 
@


1.80
log
@changes to the format of the priority substitution files; cleaner and neater
@
text
@d748 3
a801 2
    int * subVector = new int[numidentifiers];
    int * localMatchVector = new int[numidentifiers];
d905 4
@


1.79
log
@Cleaning up last vestiges of old style code. Removed dead files and if defed out sections.
@
text
@d10 1
d87 4
a90 3
//read the desired priority for each allowed fieldname in the
//substitute file
void readPrioritySubsFile(
d92 1
a92 4
                      const std::string & rootFileName,
                      const std::string & resourceIdName,
                      std::vector<std::string> & fieldValues,
                      int *currentAversionMax
d95 6
a100 5
    //a priority substitution file looks like a global attribute file
    std::string subsFileName = rootFileName + "/" + resourceIdName + "PrioritySubs.csv";
    RCPglobalAttrFile prioritySubsFile(subsFileName);
    int nFields= fieldValues.size();
    char name[100];
d102 6
a107 9
    std::string fromResourceIdName, toResourceIdName;
    fromResourceIdName = "unspecified";
    int thisFieldAversionMax = 0;
    for (int i = 0 ; i < nFields; i++) {
      sprintf(name,"%sPrioritySubs",fieldValues.at(i).c_str());
      priority = prioritySubsFile.fieldAsInt(name,"attrValue");
      if (priority>thisFieldAversionMax) thisFieldAversionMax=priority;
      priority = priority*(*currentAversionMax);
      toResourceIdName = fieldValues.at(i);
d110 2
a111 2
      if ( prob.subsExists(resourceIdName,fromResourceIdName,toResourceIdName) ) {
      // skillSubs does exist. Write warning message
d115 3
a117 3
        <<"   filename: " << subsFileName                        <<std::endl
        <<"   from: " <<fromResourceIdName.c_str()                                  <<std::endl
        <<"   to: " <<toResourceIdName.c_str()                                      <<std::endl
d123 2
a124 2
    prob.addSubs(resourceIdName,fromResourceIdName,toResourceIdName);
    prob.setSubsAversion(resourceIdName,fromResourceIdName,toResourceIdName,priority);
d126 2
a127 3
    prob.setSubsCost(resourceIdName,fromResourceIdName,toResourceIdName,0.0);
    prob.setSubsLeadTime(resourceIdName,fromResourceIdName,toResourceIdName,0.0);
 
a128 1
  *currentAversionMax = (*currentAversionMax)*thisFieldAversionMax;
a130 47
//learn about which fields are going to allow priority substitution,
//and what the allowed field names are
void readPrioritySubsDescriptionFile(
                      RCPproblem & prob, 
                      const std::string & rootFileName,
                      const std::string & substitutionFileName
                      )
{
    //a priority substitution file looks like a global attribute file
    std::string fileToRead = rootFileName + substitutionFileName;
    RCPglobalAttrFile prioritySubsFile(fileToRead);
    int nPriorityFields=prioritySubsFile.fieldAsInt("numPriorityFields","attrValue");
    char name[100];
    int currentAversionMax=1;
    for (int i = 0 ; i < nPriorityFields; i++) {
      sprintf(name,"priorityField%d",i);
      std::string fieldName = prioritySubsFile.fieldAsString(name,"attrValue");
      //DLG check that fieldName is one of our fields
      std::vector<std::string> resourceIdNames = prob.getResourceIdentifierNames();
      bool found = false;
      unsigned int j;
      for (j=0; j<resourceIdNames.size(); j++) {
         if (fieldName==resourceIdNames.at(j)) {
            found=true;
            break;
         }
      }
      if (!found) {
        std::cout 
        <<"-------------------------------------------------------"        <<std::endl
        <<"Warning: unknown fieldname specified."                          <<std::endl
        <<"   file: " <<fileToRead                                         <<std::endl
        <<"   fieldName: " <<fieldName                                     <<std::endl
        <<"-------------------------------------------------------"        <<std::endl;
      }
      sprintf(name,"%dNumLegalValues",i);
      int nLegalValues = prioritySubsFile.fieldAsInt(name,"attrValue");
      std::vector<std::string> fieldValues;
      for ( j=0; j<nLegalValues; j++) {
        sprintf(name,"%dField%d",i,j);
        std::string fieldValue = prioritySubsFile.fieldAsString(name,"attrValue");
        fieldValues.push_back(fieldValue);
      }
      readPrioritySubsFile(prob, rootFileName, fieldName, fieldValues, &currentAversionMax);
    }
}

d201 3
a203 3
      int numAttr = globalAttrFile.fieldAsInt("numAttributes","attrValue");
      for (int j=0; j<numAttr; j++) {
        sprintf(name,"attribute%d",j);
d208 1
a208 1
        int prioritySubs = globalAttrFile.fieldAsInt("prioritySubstitution","attrValue");
d210 1
a210 1
        if (prioritySubs ==0) 
d212 1
a212 1
        else if (prioritySubs ==1) 
d217 2
a218 2
          <<"Warning: prioritySubstitution value must be 0 or 1"                <<std::endl
          <<"   It is assumed to be 0. "                                     <<std::endl
d746 2
a747 2
  
  std::vector<int> matchValues;  
d756 1
a756 1
    for (unsigned int i=0; i<prob.getResourceIdentifierNames().size(); i++) {
d759 1
a759 1
       matchValues.push_back(matchValue);
d769 2
a770 1
    readPrioritySubsDescriptionFile(prob,idir,"/prioritySubs.csv");
d799 8
a806 13
    std::vector<int> subVector;
     //jobRoleSub=0;
    //skillSetSub=0;
    //lobSub=0;
    //sourceSub=0;
    //regionSub=0;
    //countrySub=0;
    //citySub=0;
    //reportingUnitSub=0;
    //bandSub=0;
    //globalSub=0;
    //competencySub=0;
    //industrySub=0;
d809 1
a809 3
       //each row of the bom has its own substitute vector
       subVector.clear();
       //start with no substitution allowed
d821 9
a829 4
         if (attributeValue=="unspecified") 
           subVector.push_back(1);
         else
           subVector.push_back(0);
d896 1
a896 1
         prob.setBomMatch(engagementName, resourceAttributeValues, period, prob.getResourceIdentifierNames()[i], matchValues.at(i));
d900 1
a900 1
         prob.setBomSub(engagementName,resourceAttributeValues,period,resourceName,subVector.at(i));
@


1.78
log
@fix to how aversions are combined
@
text
@d156 2
a157 1
      for (unsigned int j=0; j<resourceIdNames.size(); j++) {
d174 1
a174 1
      for (int j=0; j<nLegalValues; j++) {
d957 1
a957 12
#if 0
    //now that we've read all the boms, create a reasonable engagment
    //revenue. It ought to be more than nPeriods*(total num required per period)
    
    //for each engagment 
    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    for (int i=0; i<engagementNames.size(); i++) {
        prob.setEngagementReasonableReward(engagementNames[i]);
    }
#else
    
a980 1
#endif
@


1.77
log
@handling multiple aversions using separated spans of values, and multiplying
them together
@
text
@d109 1
a109 1
      priority = priority+*currentAversionMax;
d133 1
a133 1
  *currentAversionMax = *currentAversionMax+thisFieldAversionMax;
d149 1
a149 1
    int currentAversionMax=0;
@


1.76
log
@miscell. cleanups
@
text
@a9 2
//#include "matchFile04Feb.h"
//#include "matchFile.h"
a12 4
//#include "resourceFile.h"
//#include "resourceFileSimple.h"
//#include "resourceFileSimpleSubs.h"
//#include "resourceFile04Feb.h"
a13 2
//#include "bomFileSimple.h"
//#include "bomFile04Feb.h"
d92 2
a93 1
                      std::vector<std::string> & fieldValues
d104 1
d108 2
d133 1
d149 1
d153 17
d178 1
a178 1
      readPrioritySubsFile(prob, rootFileName, fieldName, fieldValues);
d901 3
a903 3
       //DLG NOTE WE HAVE A LITTLE PROBLEM HERE
       //we need to not add the capability of acquiring new resources
       //for this type, since that's not really relevant. We should
d905 1
a905 1
       //whole structure
@


1.75
log
@working with priority substitutes; adding resource if not already existant
@
text
@d132 1
a132 1
    //DLG setting these to reasonable values
d886 5
d981 1
a981 32
     //DLG these need to be fixed up once the substitution file format is set
#if 0
  // this will change to "countrySubs" when fully defined
  //---------------------------------------------------------
  // Read locationSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string locationSubsFileName = idir + "/locationSubs.csv";
    RCPlocationSubsFile locationSubsFile(locationSubsFileName);
    readSubsFile(
      prob,
      locationSubsFile,
      "Location" );
  } //end of reading locationSubs file
  //---------------------------------------------------------

  // This may change when fully defined. We will also need a "globalResourceSubs"
  //---------------------------------------------------------
  // Read sourceSubs file
  //---------------------------------------------------------
  {
    // Read skill subs file and pass info to rcp problem
    std::string sourceSubsFileName = idir + "/sourceSubs.csv";
    RCPsourceSubsFile sourceSubsFile(sourceSubsFileName);
    readSubsFile(
      prob,
      sourceSubsFile,
      "Source" );
  } //end of reading sourceSubs file
  //---------------------------------------------------------
#endif
@


1.74
log
@adding support for priority substitution on bom arcs
@
text
@d853 1
a853 4
       for ( i=0; i<prob.getResourceIdentifierNames().size(); i++) {
         subVector.push_back(0);
       }

d863 4
a866 1
         if (attributeValue=="unspecified") subVector.assign(i,1);
d884 1
a884 1
          <<"   record will be ignored. "                                    <<std::endl
d886 8
a893 1
        continue;
d930 1
a930 1
       for (i=0; i<prob.getResourceIdentifierNames().size(); i++) {
@


1.73
log
@changed a comment
@
text
@d94 45
d141 1
a141 1
void readPrioritySubsFile(
d143 1
d148 2
a149 1
    RCPglobalAttrFile prioritySubsFile(substitutionFileName);
a154 2
    }
    for (int i = 0; i< nPriorityFields; i++) {
d157 1
d161 1
d163 1
a164 54
    #if 0
    std::string fileFormat = globalAttrFile.fieldAsString("fileFormat","attrValue");
    std::string theAlg = globalAttrFile.fieldAsString("algorithm","attrValue");
    std::string theProb = globalAttrFile.fieldAsString("problem","attrValue");
  int numAttributes = prob.getResourceIdentifierNames().size();
  RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,readFixedCost);
  RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
  
  // loop once for each record in resource file
  
  
  std::vector<std::string> resourceAttributeValues;
  //std::vector<std::string> *resourceAttributeValues=new std::vector<std::string>;
  for ( ; resourceFileIter()!=NULL; ) {
    resourceAttributeValues.clear();
    for (int j=0; j<numAttributes; j++) {
      std::string attributeName = prob.getResourceIdentifierNames()[j];
      std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
      resourceAttributeValues.push_back(attributeValue);
    }
    int period = resourceFileIter.periodAsInt();
    float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
    if (readFixedCost)
      fixedCost = resourceFileIter.fieldOnRecordAsFloat("fixedCost");
    
    // test to ensure period is within the planning horizon
    if ( period >= nPeriods ) {
      // Write warning message
      std::cout 
        <<"-------------------------------------------------------"         <<std::endl
        <<"Warning: period is beyond planning horizion"                     <<std::endl
        <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
        <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl            
        <<"   period: " <<period                                            <<std::endl
        <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
        <<"   record will be ignored. "                                     <<std::endl
        <<"-------------------------------------------------------"         <<std::endl;
      continue;
    }
    
    
    if ( !prob.resourceExists(resourceAttributeValues) )
      prob.addResource(resourceAttributeValues);
    prob.setResourceSupplyQuantity(resourceAttributeValues,period,supplyQuantity);
    if (period == 0){
      prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,supplyQuantity);
    }
    prob.setResourceFixedCost(resourceAttributeValues,period,fixedCost);
    if ( setAcquireCost )
      prob.setResourceAcquireCost(resourceAttributeValues,acquireCost);
    
    
  }
  #endif
d805 1
a805 2
    std::string prioritySubsFileName = idir + "/prioritySubs.csv";
    readPrioritySubsFile(prob,prioritySubsFileName);
d861 1
a861 1
      //"undefined" be found only in the "allowed" fields.
d866 1
a866 1
         if (attributeValue=="undefined") subVector.assign(i,1);
d1042 2
@


1.72
log
@adding a "prioritySubstitution" flag to the global attribute file for
the feb04 format. To be used later.
@
text
@d94 2
a95 1
//read the priority order for substitution of resource type
@


1.71
log
@trivial changes from int to unsigned int to make the compiler happier
@
text
@d4 1
d94 78
d248 15
d264 1
a264 1
      populate04Feb(prob, idir, odir, nPeriods);
d775 2
a776 1
              int   nPeriods) 
d806 9
d865 4
@


1.70
log
@Implemented the functionality of setEngagementReasonableReward using RCPproblem public methods in populate.
@
text
@d702 1
a702 1
    for (int i=0; i<prob.getResourceIdentifierNames().size(); i++) {
d754 1
a754 1
       int i;
d844 1
a844 1
    int e;
d850 1
a850 1
      int r;
d854 1
a854 1
        int t;
@


1.69
log
@removed setResourceIdentifierNames
and added addResourceIdentifierName
@
text
@d826 2
d837 27
@


1.68
log
@Removed methods:
addSkillSubs
setSkillSubsCost
setSkillSubsLeadTime
skillSubsExists
getSkillSubsNames
getSkillSubsCost
@
text
@a163 1
      std::vector<std::string> attrVector;
d167 1
a167 1
        attrVector.push_back(attr);
a169 1
      prob.setResourceIdentifierNames(attrVector);
d189 5
a193 7
    RCPvectorString resIdNames;
    resIdNames.push_back("jobRole");
    resIdNames.push_back("skillSet");
    resIdNames.push_back("LOB");
    resIdNames.push_back("source");
    resIdNames.push_back("resourceLocName");
    prob.setResourceIdentifierNames(resIdNames);
d697 1
a697 1
    RCPgnrlMatchFile matchFile(matchFileName,prob.getNumberResourceIdentifiers());
d702 1
a702 1
    for (int i=0; i<prob.getNumberResourceIdentifiers(); i++) {
d755 1
a755 1
       for ( i=0; i<prob.getNumberResourceIdentifiers(); i++) {
d818 1
a818 1
      for (i=0; i<prob.getNumberResourceIdentifiers(); i++) {
d821 1
a821 1
       for (i=0; i<prob.getNumberResourceIdentifiers(); i++) {
@


1.67
log
@Removed from populate references to
  addSkillSubs
  setSkillSubsCost
  setSkillSubsLeadTime
  addLocationSubs
  setLocationSubsCost
  setLocationSubsLeadTime
  etc
I believe populate is now just using the general methods
@
text
@d896 1
a896 1
    if ( prob.skillSubsExists(fromSkill,toSkill) ) {
@


1.66
log
@cleaned up unitTest, and which .h files need to be included in unitTest and populate.
@
text
@d615 2
a616 4
      "JobRole",
      &RCPproblem::addJobRoleSubs,
      &RCPproblem::setJobRoleSubsCost,
      &RCPproblem::setJobRoleSubsLeadTime );
d630 2
a631 4
      "Skill",
      &RCPproblem::addSkillSubs,
      &RCPproblem::setSkillSubsCost,
      &RCPproblem::setSkillSubsLeadTime );
d645 2
a646 4
      "Location",
      &RCPproblem::addLocationSubs,
      &RCPproblem::setLocationSubsCost,
      &RCPproblem::setLocationSubsLeadTime );
d660 2
a661 4
      "Lob",
      &RCPproblem::addLobSubs,
      &RCPproblem::setLobSubsCost,
      &RCPproblem::setLobSubsLeadTime );
d675 2
a676 4
      "Source",
      &RCPproblem::addSourceSubs,
      &RCPproblem::setSourceSubsCost,
      &RCPproblem::setSourceSubsLeadTime );
d855 1
a855 4
      "Location",
      &RCPproblem::addLocationSubs,
      &RCPproblem::setLocationSubsCost,
      &RCPproblem::setLocationSubsLeadTime );
d870 1
a870 4
      "Source",
      &RCPproblem::addSourceSubs,
      &RCPproblem::setSourceSubsCost,
      &RCPproblem::setSourceSubsLeadTime );
d882 3
a884 5
                  const SCOcsvFormatFile & file,   
                  const std::string & subsName,
                  void (RCPproblem::*addSubsFunc)(const std::string &, const std::string &),         
                  void (RCPproblem::*setSubsCostFunc)(const std::string &, const std::string &, float),         
                  void (RCPproblem::*setSubsLeadTimeFunc)(const std::string &, const std::string &, float) )
d912 3
a914 3
    (prob.*addSubsFunc)(fromSkill,toSkill);
    (prob.*setSubsCostFunc)(fromSkill,toSkill,cost);
    (prob.*setSubsLeadTimeFunc)(fromSkill,toSkill,leadTime);
@


1.65
log
@added function readResourceFile which is used be all populate functions.
@
text
@d10 1
a10 1
#include "matchFile.h"
@


1.64
log
@remove an unused header file
@
text
@d30 64
d196 1
a196 1
    resIdNames.push_back("locName");
d251 1
a251 60
    RCPgnrlResourceFile resourceFile(resourceFileName,5,true);
    RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
    
    // loop once for each record in resource file
    for ( ; resourceFileIter()!=NULL; ) {
      std::string jobRole = resourceFileIter.fieldOnRecord("jobRole");
      std::string skillSet = resourceFileIter.fieldOnRecord("skillSet");
      std::string LOB = resourceFileIter.fieldOnRecord("LOB");
      std::string source = resourceFileIter.fieldOnRecord("source");
      std::string resourceLocName = resourceFileIter.fieldOnRecord("resourceLocName");
      int period = resourceFileIter.periodAsInt();
      float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
      float fixedCost = resourceFileIter.fieldOnRecordAsFloat("fixedCost");
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

      RCPvectorString resourceIdValues;
      resourceIdValues.push_back(jobRole);
      resourceIdValues.push_back(skillSet);
      resourceIdValues.push_back(LOB);
      resourceIdValues.push_back(source);
      resourceIdValues.push_back(resourceLocName);
      
      if ( !prob.resourceExists(resourceIdValues) )
         prob.addResource(resourceIdValues);

      prob.setResourceSupplyQuantity(resourceIdValues,period,supplyQuantity);
      if (period == 0){
	      prob.setBenchResourceSupplyQuantity(resourceIdValues,0,supplyQuantity);
      }
      prob.setResourceFixedCost(resourceIdValues,period,fixedCost);
      
#if 0
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLocName) )
         prob.addResource(jobRole,skillSet,LOB,source,resourceLocName);

      prob.setResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
      if (period == 0){
	    prob.setBenchResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
      }
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLocName,period,fixedCost);
#endif



    }
d594 1
a594 1
      prob.setBomMatch(engagementName,resourceIdValues,period,"locName",locationMatch);
d599 1
a599 1
      prob.setBomSub(engagementName,resourceIdValues,period,"locName",locationSub);
a726 1
  int numAttributes;
d730 1
a730 46
    numAttributes = prob.getNumberResourceIdentifiers();
    RCPgnrlResourceFile resourceFile(resourceFileName,numAttributes,false);
    RCPgnrlResourceFileIterator resourceFileIter(resourceFile);
    
    // loop once for each record in resource file
    
 
    std::vector<std::string> resourceAttributeValues;
    //std::vector<std::string> *resourceAttributeValues=new std::vector<std::string>;
    for ( ; resourceFileIter()!=NULL; ) {
      resourceAttributeValues.clear();
      for (int j=0; j<numAttributes; j++) {
         std::string attributeName = prob.getResourceIdentifierNames()[j];
         std::string attributeValue = resourceFileIter.fieldOnRecord(attributeName);
         resourceAttributeValues.push_back(attributeValue);
      }
      int period = resourceFileIter.periodAsInt();
      float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl                <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }


      if ( !prob.resourceExists(resourceAttributeValues) )
         prob.addResource(resourceAttributeValues);
      prob.setResourceSupplyQuantity(resourceAttributeValues,period,supplyQuantity);
      if (period == 0){
	    prob.setBenchResourceSupplyQuantity(resourceAttributeValues,0,supplyQuantity);
      }
      prob.setResourceFixedCost(resourceAttributeValues,period,1);
      prob.setResourceAcquireCost(resourceAttributeValues,1.5);


    }
d742 1
@


1.63
log
@removing some extraneous formats and fixing some writing of output files
@
text
@d19 1
a19 1
#include "bomFileSimple.h"
@


1.62
log
@modified a poplute function for new format.
with this change
  rcpOpt(example_simplesubs)
will run without crashing
@
text
@d82 1
a82 1
    if ( fileFormat!="03Dec" && fileFormat!="04Jan" && fileFormat!="04JanSubs" && fileFormat!="04Feb") {
d89 1
a89 1
        <<"   allowed values: 03Dec 04Jan 04JanSubs 04Feb"               <<std::endl
a95 4
    else if (fileFormat=="04Jan")
      populate04Jan(prob, idir, odir,nPeriods);
    else if (fileFormat=="04JanSubs")
      populate04JanSubs(prob, idir, odir, nPeriods);
a975 184
void populate04Jan(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              int nPeriods) 
{


 
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");
  
 //---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------
  int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, locationMatch;
  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPmatchFile matchFile(matchFileName);
    RCPmatchFileIterator matchFileIter(matchFile);
    matchFileIter();
    
    jobRoleMatch = matchFileIter.jobRoleMatchAsInt();
    skillSetMatch = matchFileIter.skillSetMatchAsInt();
    lobMatch = matchFileIter.LOBMatchAsInt();
    sourceMatch = matchFileIter.sourceMatchAsInt();
    locationMatch = matchFileIter.locationMatchAsInt();
      
  }
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileSimpleName = idir + "/resource.csv";
    RCPgnrlResourceFile resourceFileSimple(resourceFileSimpleName,5,false);
    RCPgnrlResourceFileIterator resourceFileSimpleIter(resourceFileSimple);
    
    // loop once for each record in resource file
    for ( ; resourceFileSimpleIter()!=NULL; ) {
      std::string jobRole = resourceFileSimpleIter.fieldOnRecord("jobRole");
      std::string skillSet = resourceFileSimpleIter.fieldOnRecord("skillSet");
      std::string LOB = resourceFileSimpleIter.fieldOnRecord("LOB");
      std::string source = resourceFileSimpleIter.fieldOnRecord("source");
      std::string resourceLocName = resourceFileSimpleIter.fieldOnRecord("resourceLocName");
      int period = resourceFileSimpleIter.periodAsInt();
      float supplyQuantity =  resourceFileSimpleIter.supplyQuantityAsFloat();
      
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFileSimple.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileSimpleIter.recNum()      <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      //overwrite fields we are not interested in with a standard value
      if (jobRoleMatch==0) jobRole = "dummy";
      if (skillSetMatch==0) skillSet = "dummy";
      if (lobMatch==0) LOB = "dummy";
      if (sourceMatch==0) source = "dummy";
      if (locationMatch==0) resourceLocName= "dummy";

      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLocName) ){
         prob.addResource(jobRole,skillSet,LOB,source,resourceLocName);
      }

      //since we may have already put some supply for this resource (given the dummy fields)
      //we need to extract the current quantity and add to it.
      std::vector<float> currentQuantity = prob.getResourceSupplyQuantity(jobRole, skillSet, LOB, source, resourceLocName);
      supplyQuantity = currentQuantity[period] + supplyQuantity;
      prob.setResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
      if (period == 0){
	    prob.setBenchResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
      }
      //all resource implicitly have the same cost, so overwriting the value here is ok.
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLocName,period,1);


    }
    //  loop through the resources that have been defined to set the release cost of 
    //  the benchResource to a reasonable value
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    prob.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
  
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) 
      prob.setResourceReasonableReleaseCost(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
  }

  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string bomFileName = idir + "/bom.csv";
    RCPbomFileSimple bomFile(bomFileName);
    RCPbomFileSimpleIterator bomFileSimpleIter(bomFile);
    
    // loop once for each record in bom file
    for ( ; bomFileSimpleIter()!=NULL; ) {
      std::string jobRole = bomFileSimpleIter.jobRole();
      std::string skillSet = bomFileSimpleIter.skillSet();
      std::string LOB = bomFileSimpleIter.LOB();
      std::string source = bomFileSimpleIter.source();
      std::string resourceLoc = bomFileSimpleIter.resourceLocName();
      int period = bomFileSimpleIter.periodAsInt();
      float usageQuantity =  bomFileSimpleIter.usageQuantityAsFloat();

      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileSimpleIter.recNum()                <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      //set names of unmatched fields to dummy
      if (jobRoleMatch==0) 
         jobRole="dummy";
      if (skillSetMatch==0)
         skillSet="dummy";
      if (lobMatch==0)
         LOB = "dummy";
      if (sourceMatch==0)
         source = "dummy";
      if (locationMatch==0) 
         resourceLoc = "dummy";
      
      //need to create an engagement name based on the match flags and the given data.
      std::string engagementName= createEngagementName();
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         prob.setEngagementRevenue(engagementName,100000.);
         prob.setEngagementStartPeriod(engagementName,0);
         prob.setEngagementDuration(engagementName,nPeriods);
         prob.setEngagementLateAllowance(engagementName,0);
         prob.setEngagementLocation(engagementName,"dummy");
      }
                                    
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,resourceLoc) ) {
         prob.addBom(engagementName,jobRole,skillSet,LOB,source,resourceLoc);
      }
      std::vector<float> currentQuantity = prob.getBomUsageQuantity(engagementName, jobRole, skillSet, LOB, source, resourceLoc);
      usageQuantity = currentQuantity[period] + usageQuantity;
      prob.setBomUsageQuantity(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,usageQuantity);

      //now that we have substituted with "dummy" the fields we don't care about, we want to set all
      //match flags to 1 and all substitute flags to 0
      prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,1);
      prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,1);
      prob.setBomLocationMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,1);
      prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,1);
      prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,1);
      prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomLocationSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);

 
    }
  }
 
a976 24
   
  
  
  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
#if 0
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resourceaction.csv";
    RCPresourceActionFile resourceActionFile(resourceFileName);
    RCPresourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      std::string jobRole = resourceActionFileIter.jobRole();
      std::string skillSet = resourceActionFileIter.skillSet();
      std::string LOB = resourceActionFileIter.LOB();
      std::string source = resourceActionFileIter.source();
      std::string resourceLoc = resourceActionFileIter.resourceLocName();
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat();
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();
a977 284
      // test to ensure that resource exists
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLoc) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"                  <<std::endl
          <<"Warning: Resource does not exist"                                         <<std::endl
          <<"   resource action filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   resource action file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"   resource: " <<jobRole.c_str()                                     <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                             <<std::endl
          <<"   record will be ignored. "                                              <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
        continue;
      }

      prob.setResourceAcquireTime(jobRole,skillSet,LOB,source,resourceLoc,acquireTime);
      prob.setResourceAcquireCost(jobRole,skillSet,LOB,source,resourceLoc,acquireCost);
      prob.setResourceReleaseTime(jobRole,skillSet,LOB,source,resourceLoc,releaseTime);
      prob.setResourceReleaseCost(jobRole,skillSet,LOB,source,resourceLoc,releaseCost);

    }
  }
#endif
    
    
 
}
void populate04JanSubs(
              RCPproblem & prob, 
              const std::string & idir, 
              const std::string & odir,
              int nPeriods) 
{


 
  prob.setNPeriods(nPeriods);  
  prob.setOslMesgFileName(odir+"/oslMesgFile.txt");

  {
    RCPvectorString resIdNames;
    resIdNames.push_back("jobRole");
    resIdNames.push_back("skillSet");
    resIdNames.push_back("LOB");
    resIdNames.push_back("source");
    resIdNames.push_back("locName");
    prob.setResourceIdentifierNames(resIdNames);
  }
  
 //---------------------------------------------------------
  // Read match file
  //---------------------------------------------------------
  int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, locationMatch;
  {
    // Read match File 
    std::string matchFileName = idir + "/match.csv";
    RCPmatchFile matchFile(matchFileName);
    RCPmatchFileIterator matchFileIter(matchFile);
    matchFileIter();
    
    jobRoleMatch = matchFileIter.jobRoleMatchAsInt();
    skillSetMatch = matchFileIter.skillSetMatchAsInt();
    lobMatch = matchFileIter.LOBMatchAsInt();
    sourceMatch = matchFileIter.sourceMatchAsInt();
    locationMatch = matchFileIter.locationMatchAsInt();
      
  }
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileSimpleName = idir + "/resource.csv";
    RCPgnrlResourceFile resourceFileSimple(resourceFileSimpleName,5,true);
    RCPgnrlResourceFileIterator resourceFileSimpleIter(resourceFileSimple);
    
    // loop once for each record in resource file
    for ( ; resourceFileSimpleIter()!=NULL; ) {
      std::string jobRole = resourceFileSimpleIter.fieldOnRecord("jobRole");
      std::string skillSet = resourceFileSimpleIter.fieldOnRecord("skillSet");
      std::string LOB = resourceFileSimpleIter.fieldOnRecord("LOB");
      std::string source = resourceFileSimpleIter.fieldOnRecord("source");
      std::string resourceLocName = resourceFileSimpleIter.fieldOnRecord("resourceLocName");
      int period = resourceFileSimpleIter.periodAsInt();
      float supplyQuantity =  resourceFileSimpleIter.supplyQuantityAsFloat();
      float fixedCost = resourceFileSimpleIter.fieldOnRecordAsFloat("fixedCost");
      
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFileSimple.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileSimpleIter.recNum()      <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      RCPvectorString resourceIdValues;
      resourceIdValues.push_back(jobRole);
      resourceIdValues.push_back(skillSet);
      resourceIdValues.push_back(LOB);
      resourceIdValues.push_back(source);
      resourceIdValues.push_back(resourceLocName);
      
      if ( !prob.resourceExists(resourceIdValues) )
         prob.addResource(resourceIdValues);

      prob.setResourceSupplyQuantity(resourceIdValues,period,supplyQuantity);
      if (period == 0){
	      prob.setBenchResourceSupplyQuantity(resourceIdValues,0,supplyQuantity);
      }
      prob.setResourceFixedCost(resourceIdValues,period,fixedCost);
      
#if 0
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLocName) )
         prob.addResource(jobRole,skillSet,LOB,source,resourceLocName);


      prob.setResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
      if (period == 0){
	    prob.setBenchResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
      }
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLocName,period,fixedCost);
#endif
    }

    
    //  loop through the resources that have been defined to set the release cost of 
    //  the benchResource to a reasonable value
    std::vector<RCPvectorString> resNames;
    prob.getResourceNames( resNames );
    int r;
    for ( r=0; r<resNames.size(); ++r ) 
      prob.setResourceReasonableReleaseCost(resNames[r]);
#if 0
    //  loop through the resources that have been defined to set the release cost of 
    //  the benchResource to a reasonable value
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    prob.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
  
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) 
      prob.setResourceReasonableReleaseCost(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
#endif

  }

  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string bomFileName = idir + "/bom.csv";
    RCPbomFileSimple bomFile(bomFileName);
    RCPbomFileSimpleIterator bomFileSimpleIter(bomFile);
    
    // loop once for each record in bom file
    for ( ; bomFileSimpleIter()!=NULL; ) {
      std::string jobRole = bomFileSimpleIter.jobRole();
      std::string skillSet = bomFileSimpleIter.skillSet();
      std::string LOB = bomFileSimpleIter.LOB();
      std::string source = bomFileSimpleIter.source();
      std::string resourceLoc = bomFileSimpleIter.resourceLocName();
      int period = bomFileSimpleIter.periodAsInt();
      float usageQuantity =  bomFileSimpleIter.usageQuantityAsFloat();

      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileSimpleIter.recNum()                <<std::endl
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }
      
      //need to create an engagement name based on the match flags and the given data.
      std::string engagementName= createEngagementName();
      if (!prob.engagementExists(engagementName)) {
         prob.addEngagement(engagementName);
         prob.setEngagementRevenue(engagementName,100000.);
         prob.setEngagementStartPeriod(engagementName,0);
         prob.setEngagementDuration(engagementName,nPeriods);
         prob.setEngagementLateAllowance(engagementName,0);
         prob.setEngagementLocation(engagementName,"dummy");
      }
             
      
      RCPvectorString resourceIdValues;
      resourceIdValues.push_back(jobRole);
      resourceIdValues.push_back(skillSet);
      resourceIdValues.push_back(LOB);
      resourceIdValues.push_back(source);
      resourceIdValues.push_back(resourceLoc);

      if ( !prob.bomExists(engagementName,resourceIdValues) ) {
         prob.addBom(engagementName,resourceIdValues);
      }
      prob.setBomUsageQuantity(engagementName,resourceIdValues,period,usageQuantity);

      prob.setBomMatch(engagementName,resourceIdValues,period,"jobRole",jobRoleMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"skillSet",skillSetMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"locName",locationMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"LOB",lobMatch);
      prob.setBomMatch(engagementName,resourceIdValues,period,"source",sourceMatch);
      prob.setBomSub(engagementName,resourceIdValues,period,"jobRole",0);
      prob.setBomSub(engagementName,resourceIdValues,period,"skillSet",0);
      prob.setBomSub(engagementName,resourceIdValues,period,"locName",0);
      prob.setBomSub(engagementName,resourceIdValues,period,"LOB",0);
      prob.setBomSub(engagementName,resourceIdValues,period,"source",0);

 
    }
  }
 

   
  
  
  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
#if 0
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resourceaction.csv";
    RCPresourceActionFile resourceActionFile(resourceFileName);
    RCPresourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      std::string jobRole = resourceActionFileIter.jobRole();
      std::string skillSet = resourceActionFileIter.skillSet();
      std::string LOB = resourceActionFileIter.LOB();
      std::string source = resourceActionFileIter.source();
      std::string resourceLoc = resourceActionFileIter.resourceLocName();
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat();
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();

      // test to ensure that resource exists
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLoc) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"                  <<std::endl
          <<"Warning: Resource does not exist"                                         <<std::endl
          <<"   resource action filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   resource action file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"   resource: " <<jobRole.c_str()                                     <<std::endl
          <<"   resource location: " <<resourceLoc.c_str()                             <<std::endl
          <<"   record will be ignored. "                                              <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
        continue;
      }

      prob.setResourceAcquireTime(jobRole,skillSet,LOB,source,resourceLoc,acquireTime);
      prob.setResourceAcquireCost(jobRole,skillSet,LOB,source,resourceLoc,acquireCost);
      prob.setResourceReleaseTime(jobRole,skillSet,LOB,source,resourceLoc,releaseTime);
      prob.setResourceReleaseCost(jobRole,skillSet,LOB,source,resourceLoc,releaseCost);

    }
  }
#endif
    
    
 
}
@


1.61
log
@Lots of changes to use new way of identifying resources
@
text
@d1228 10
d1294 9
d1304 7
d1320 1
d1322 10
d1341 1
d1392 24
a1415 16
                                    
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,resourceLoc) ) {
         prob.addBom(engagementName,jobRole,skillSet,LOB,source,resourceLoc);
      }
      prob.setBomUsageQuantity(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,usageQuantity);

      prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,jobRoleMatch);
      prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,skillSetMatch);
      prob.setBomLocationMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,locationMatch);
      prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,lobMatch);
      prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,sourceMatch);
      prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomLocationSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
      prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,0);
@


1.60
log
@fixed some errors in writing out the mrpO file
@
text
@d128 11
a138 1
   
d221 17
d246 1
d273 8
d283 1
a283 1
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLoc) ) {
d297 4
a300 4
      prob.setResourceAcquireTime(jobRole,skillSet,LOB,source,resourceLoc,acquireTime);
      prob.setResourceAcquireCost(jobRole,skillSet,LOB,source,resourceLoc,acquireCost);
      prob.setResourceReleaseTime(jobRole,skillSet,LOB,source,resourceLoc,releaseTime);
      prob.setResourceReleaseCost(jobRole,skillSet,LOB,source,resourceLoc,releaseCost);
d336 8
d362 1
a362 1
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLoc) ) {
d587 2
a588 2
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,resourceLoc) )
         prob.addBom(engagementName,jobRole,skillSet,LOB,source,resourceLoc);
d590 11
a600 11
      prob.setBomUsageQuantity(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,usageQuantity);
      prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,jobRoleMatch);
      prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,skillSetMatch);
      prob.setBomLocationMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,locationMatch);
      prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,lobMatch);
      prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,sourceMatch);
      prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,jobRoleSub);
      prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,skillSetSub);
      prob.setBomLocationSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,locationSub);
      prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,lobSub);
      prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,sourceSub);
d703 2
a704 2
  int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, regionMatch, countryMatch, cityMatch;
  int bandMatch, reportingUnitMatch,globalMatch, competencyMatch, industryMatch;
@


1.59
log
@implemented several resource methods to work with resourceAttributeValues as parameter.
updated RCPproblem test to use these new methods.
@
text
@d20 1
a20 1
#include "bomFile04Feb.h"
@


1.58
log
@more updates for handling vector substitution and matching
@
text
@d104 1
a104 1
      std::vector<std::string> *attrVector = new std::vector<std::string>;
d108 1
a108 1
        attrVector->push_back(attr);
d111 1
a111 1
      prob.setResourceIdentifiers(attrVector);
d672 1
a672 1
       std::string attributeMatchName = prob.getResourceIdentifier(i)+"Match";
d698 1
a698 1
         std::string attributeName = prob.getResourceIdentifier(j);
d768 2
a769 1
       for (int i=0; i<prob.getNumberResourceIdentifiers(); i++) {
d776 1
a776 1
         std::string attributeName = prob.getResourceIdentifier(j);
d832 2
a833 2
      for (int i=0; i<prob.getNumberResourceIdentifiers(); i++) {
         prob.setBomMatch(engagementName, resourceAttributeValues, period, matchValues.at(i), prob.getResourceIdentifier(i));
d835 3
a837 3
       for (int i=0; i<prob.getNumberResourceIdentifiers(); i++) {
         std::string resourceName = prob.getResourceIdentifier(i);
         prob.setBomSub(engagementName,resourceAttributeValues,period,subVector.at(i),resourceName);
@


1.57
log
@more work on the substitute stuff for vectors
@
text
@d662 1
a662 1
  
d670 1
a670 1
    std::vector<int> matchValues;
d830 1
a830 15
      //DLG do matches
      //prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,jobRoleMatch);
      //prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,skillSetMatch);
      //prob.setBomRegionMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,regionMatch);
      //prob.setBomCountryMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,countryMatch);
      //prob.setBomCityMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,cityMatch);
      //prob.setBomReportingUnitMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,reportingUnitMatch);
      //prob.setBomBandMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,bandMatch);
      //prob.setBomGlobalMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,globalMatch);
      //prob.setBomCompetencyMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,competencyMatch);
      //prob.setBomIndustryMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,industryMatch);
      //prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,lobMatch);
      //prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,sourceMatch);

      //DLG do subs
d832 3
d838 1
a838 12
      //prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,skillSetSub);
      //prob.setBomRegionSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,regionSub);
      //prob.setBomCountrySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,countrySub);
      //prob.setBomCitySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,citySub);
      //prob.setBomReportingUnitSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,reportingUnitSub);
      //prob.setBomBandSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,bandSub);
      //prob.setBomGlobalSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,globalSub);
      //prob.setBomCompetencySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,competencySub);
      //prob.setBomIndustrySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,industrySub);
      //prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,lobSub);
      //prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,sourceSub);
    }
@


1.56
log
@Added bench, working, acquire and release quantities to the app data of the bench and working resources.  Also cleaned up the merge conflicts.
@
text
@a701 12
      //std::string jobRole = resourceFileIter.fieldOnRecord("jobRole");
      //std::string skillSet = resourceFileIter.fieldOnRecord("skillSet");
      //std::string LOB = resourceFileIter.fieldOnRecord("LOB");
      //std::string source = resourceFileIter.fieldOnRecord("source");
      //std::string region = resourceFileIter.fieldOnRecord("region");
      //std::string country = resourceFileIter.fieldOnRecord("country");
      //std::string city = resourceFileIter.fieldOnRecord("city");
      //std::string reportingUnit = resourceFileIter.fieldOnRecord("reportingUnit");
      //std::string band = resourceFileIter.fieldOnRecord("band");
      //std::string global = resourceFileIter.fieldOnRecord("global");
      //std::string competency = resourceFileIter.fieldOnRecord("competency");
      //std::string industry = resourceFileIter.fieldOnRecord("industry");
d712 1
a712 2
          <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl
          //<<"   jobRole: " <<jobRole.c_str()                        <<std::endl
d747 16
a762 16
    int jobRoleSub, skillSetSub, lobSub, sourceSub, regionSub, countrySub, citySub;
    int bandSub, globalSub, competencySub, reportingUnitSub, industrySub;
    //we will only be looking for substitution on source, country, and globalresource
    //these haven't all been defined yet
    jobRoleSub=0;
    skillSetSub=0;
    lobSub=0;
    sourceSub=0;
    regionSub=0;
    countrySub=0;
    citySub=0;
    reportingUnitSub=0;
    bandSub=0;
    globalSub=0;
    competencySub=0;
    industrySub=0;
d765 7
d777 1
a779 1
      //DLG deal with unspecified
d794 1
a794 3
          //<<"   resource: " <<jobRole.c_str()                           <<std::endl
          //<<"   resource location: " <<region.c_str()                   <<std::endl
          <<"   period: " <<period                                           <<std::endl
a807 2
          //<<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          //<<"   resource location: " <<region.c_str()                    <<std::endl
d845 4
a848 1
      //prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,jobRoleSub);
@


1.55
log
@more handling of matches in a general way
@
text
@d214 1
a214 1
      prob.setExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
d733 1
a733 2
      //if ( !prob.resourceExists(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry) )
         //prob.addResource(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);
d736 1
a736 1
      prob.setExogenousResourceSupplyQuantity(resourceAttributeValues,period,supplyQuantity);
d1043 1
a1043 1
      std::vector<float> currentQuantity = prob.getExogenousResourceSupplyQuantity(jobRole, skillSet, LOB, source, resourceLocName);
d1045 1
a1045 1
      prob.setExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
d1273 1
a1273 1
      prob.setExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
@


1.54
log
@updated match.csv files for consistency in naming. Also added some
selftests for the new gnrl format files
@
text
@d9 1
a9 1
#include "matchFile04Feb.h"
d13 1
d666 11
a676 17
    RCPmatchFile04Feb matchFile(matchFileName);
    RCPmatchFile04FebIterator matchFileIter(matchFile);
    matchFileIter(); //DLG come back to this
    
    jobRoleMatch = matchFileIter.jobRoleMatchAsInt();
    skillSetMatch = matchFileIter.skillSetMatchAsInt();
    lobMatch = matchFileIter.LOBMatchAsInt();
    sourceMatch = matchFileIter.sourceMatchAsInt();
    regionMatch = matchFileIter.regionMatchAsInt();
    countryMatch = matchFileIter.countryMatchAsInt();
    cityMatch = matchFileIter.cityMatchAsInt();
    bandMatch = matchFileIter.bandMatchAsInt();
    reportingUnitMatch = matchFileIter.reportingUnitMatchAsInt();
    globalMatch = matchFileIter.globalMatchAsInt();
    competencyMatch = matchFileIter.competencyMatchAsInt();
    industryMatch = matchFileIter.industryMatchAsInt();
      
@


1.53
log
@add gnrlBomFile.h, and a few other changes
@
text
@d995 1
a995 1
    lobMatch = matchFileIter.lobMatchAsInt();
d1232 1
a1232 1
    lobMatch = matchFileIter.lobMatchAsInt();
@


1.52
log
@massive commit to handle vector resource descriptions.
substitution for the "long" format is NOT yet implemented.
tests need to be updated
@
text
@d697 1
a697 1
    //DLG need to free this 
@


1.51
log
@more vector support
@
text
@d12 1
d687 1
d691 1
a691 1
    int numAttributes = prob.getNumberResourceIdentifiers();
d696 4
d701 18
a718 12
      std::string jobRole = resourceFileIter.fieldOnRecord("jobRole");
      std::string skillSet = resourceFileIter.fieldOnRecord("skillSet");
      std::string LOB = resourceFileIter.fieldOnRecord("LOB");
      std::string source = resourceFileIter.fieldOnRecord("source");
      std::string region = resourceFileIter.fieldOnRecord("region");
      std::string country = resourceFileIter.fieldOnRecord("country");
      std::string city = resourceFileIter.fieldOnRecord("city");
      std::string reportingUnit = resourceFileIter.fieldOnRecord("reportingUnit");
      std::string band = resourceFileIter.fieldOnRecord("band");
      std::string global = resourceFileIter.fieldOnRecord("global");
      std::string competency = resourceFileIter.fieldOnRecord("competency");
      std::string industry = resourceFileIter.fieldOnRecord("industry");
d730 1
a730 1
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
d738 5
a742 4
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry) )
         prob.addResource(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);

      prob.setExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry,period,supplyQuantity);
d744 1
a744 1
	    prob.setBenchResourceSupplyQuantity(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry,0,supplyQuantity);
d746 2
a747 2
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry,period,1);
      prob.setResourceAcquireCost(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,1.5);
d762 2
a763 2
    RCPbomFile04Feb bomFile(bomFileName);
    RCPbomFile04FebIterator bomFileIter(bomFile);
d784 8
a791 25
      
      std::string jobRole = bomFileIter.jobRole();
      //if (jobRole=="unspecified") jobRoleSub=1; //not allowed
      std::string skillSet = bomFileIter.skillSet();
      //if (skillSet=="unspecified") skillSetSub=1; //not allowed
      std::string LOB = bomFileIter.LOB();
      //if (LOB=="unspecified") lobSub=1; // not allowed
      std::string source = bomFileIter.source();
      if (source=="unspecified") sourceSub=1;
      std::string region = bomFileIter.region();
      //if (region=="unspecified") regionSub=1; // not allowed
      std::string country = bomFileIter.country();
      if (country=="unspecified") countrySub=1;
      std::string city = bomFileIter.city();
      if (city=="unspecified") citySub=1;
      std::string reportingUnit = bomFileIter.reportingUnit();
      //if (reportingUnit=="unspecified") reportingUnitSub=1; //not allowed
      std::string band = bomFileIter.band();
      //how to not specify band"
      std::string global = bomFileIter.global();
      if (global=="unspecified") globalSub=1;
      std::string competency = bomFileIter.competency();
      //if (competency=="unspecified") competencySub=1; //not allowed
      std::string industry = bomFileIter.industry();
      //if (industry=="unspecified") industrySub=1;//not allowed
d799 1
a799 1
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry) ) {
d806 2
a807 2
          <<"   resource: " <<jobRole.c_str()                           <<std::endl
          <<"   resource location: " <<region.c_str()                   <<std::endl
d822 2
a823 2
          <<"   jobRole: " <<jobRole.c_str()                        <<std::endl
          <<"   resource location: " <<region.c_str()                    <<std::endl
d842 2
a843 2
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry) )
         prob.addBom(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
d845 28
a872 26
      prob.setBomUsageQuantity(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,usageQuantity);
      prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,jobRoleMatch);
      prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,skillSetMatch);
      prob.setBomRegionMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,regionMatch);
      prob.setBomCountryMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,countryMatch);
      prob.setBomCityMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,cityMatch);
      prob.setBomReportingUnitMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,reportingUnitMatch);
      prob.setBomBandMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,bandMatch);
      prob.setBomGlobalMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,globalMatch);
      prob.setBomCompetencyMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,competencyMatch);
      prob.setBomIndustryMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,industryMatch);
      prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,lobMatch);
      prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,sourceMatch);

      prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,jobRoleSub);
      prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,skillSetSub);
      prob.setBomRegionSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,regionSub);
      prob.setBomCountrySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,countrySub);
      prob.setBomCitySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,citySub);
      prob.setBomReportingUnitSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,reportingUnitSub);
      prob.setBomBandSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,bandSub);
      prob.setBomGlobalSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,globalSub);
      prob.setBomCompetencySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,competencySub);
      prob.setBomIndustrySub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,industrySub);
      prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,lobSub);
      prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,period,sourceSub);
@


1.50
log
@vector handling updaes
@
text
@d666 1
a666 1
    matchFileIter();
d689 2
a690 1
    RCPgnrlResourceFile resourceFile(resourceFileName,12,false);
@


1.49
log
@incremental changes in support of vector handling of resources
@
text
@d98 12
a109 1
    else
d111 1
@


1.48
log
@starting to add exception handling
@
text
@d658 1
a658 1
    lobMatch = matchFileIter.lobMatchAsInt();
@


1.47
log
@New file gnrlResourceFile.h with classes
  RCPgnrlResourceFile
  RCPgnrlResourceFileIterator
These classes generalize the reading of the various resource files
and replaces the use of files:
  resourceFile04Feb.h
  resourceFileSimple.h
  resourceFileSimpleSubs.h
  resourceFile.h
These replaced files are still in cvs but are ifdef'ed out.

RCPgnrlResourceFile's constructor is:
  RCPgnrlResourceFile(fileName,numResourceIdFields,x)
where x is true if the file contains fixedCost field.
@
text
@d35 58
a92 57
  // Get number of periods
  std::string globalAttrFileName = idir + "/globalAttr.csv";
  RCPglobalAttrFile globalAttrFile(globalAttrFileName);
  int nPeriods=globalAttrFile.fieldAsInt("nPeriods","attrValue");
  std::string fileFormat = globalAttrFile.fieldAsString("fileFormat","attrValue");
  std::string theAlg = globalAttrFile.fieldAsString("algorithm","attrValue");
  std::string theProb = globalAttrFile.fieldAsString("problem","attrValue");
  
  prob.setAlgorithmName(theAlg);
  prob.setProblemName(theProb);
  prob.setFormatName(fileFormat);
  
  // Check the name of the problem
  if ( theProb!="resourceAction" && theProb!="gapGlut" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown problem specified."                          <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   problem specified: " <<theProb                             <<std::endl
      <<"   allowed values: resourceAction gapGlut"                    <<std::endl
      <<"   resourceAction performed "                                 <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    theProb="resourceAction";
  }

  // Check the name of the algorithm to be used

  if ( theAlg!="optimalPlan" && theAlg!="priorityPlan" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown algorithm specified."                        <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   algorithm specified: " <<theAlg                            <<std::endl
      <<"   allowed values: optimalPlan priorityPlan"                  <<std::endl
      <<"   resourceAction will be performed "                         <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    theAlg="optimalPlan";
  }

  prob.setAlgorithmName(theAlg);
  prob.setProblemName(theProb);

 if ( fileFormat!="03Dec" && fileFormat!="04Jan" && fileFormat!="04JanSubs" && fileFormat!="04Feb") {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown fileFormat specified."                       <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   fileFormat specified: " <<fileFormat                       <<std::endl
      <<"   allowed values: 03Dec 04Jan 04JanSubs 04Feb"               <<std::endl
      <<"   03Dec will be performed "                                  <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    fileFormat="03Dec";
  }  
  if (fileFormat=="03Dec") 
d94 1
a94 1
  else if (fileFormat=="04Jan")
d96 1
a96 1
  else if (fileFormat=="04JanSubs")
d98 1
a98 1
  else
d100 4
@


1.46
log
@changed the engagement reward to be data-driven
@
text
@d11 5
a15 4
#include "resourceFile.h"
#include "resourceFileSimple.h"
#include "resourceFileSimpleSubs.h"
#include "resourceFile04Feb.h"
d162 2
a163 2
    RCPresourceFile resourceFile(resourceFileName);
    RCPresourceFileIterator resourceFileIter(resourceFile);
d167 5
a171 5
      std::string jobRole = resourceFileIter.jobRole();
      std::string skillSet = resourceFileIter.skillSet();
      std::string LOB = resourceFileIter.LOB();
      std::string source = resourceFileIter.source();
      std::string resourceLocName = resourceFileIter.resourceLocName();
d174 1
a174 1
      float fixedCost = resourceFileIter.fixedCostAsFloat();
d672 2
a673 2
    RCPresourceFile04Feb resourceFile(resourceFileName);
    RCPresourceFile04FebIterator resourceFileIter(resourceFile);
d677 12
a688 12
      std::string jobRole = resourceFileIter.jobRole();
      std::string skillSet = resourceFileIter.skillSet();
      std::string LOB = resourceFileIter.LOB();
      std::string source = resourceFileIter.source();
      std::string region = resourceFileIter.region();
      std::string country = resourceFileIter.country();
      std::string city = resourceFileIter.city();
      std::string reportingUnit = resourceFileIter.reportingUnit();
      std::string band = resourceFileIter.band();
      std::string global = resourceFileIter.global();
      std::string competency = resourceFileIter.competency();
      std::string industry = resourceFileIter.industry();
d990 2
a991 2
    RCPresourceFileSimple resourceFileSimple(resourceFileSimpleName);
    RCPresourceFileSimpleIterator resourceFileSimpleIter(resourceFileSimple);
d995 5
a999 5
      std::string jobRole = resourceFileSimpleIter.jobRole();
      std::string skillSet = resourceFileSimpleIter.skillSet();
      std::string LOB = resourceFileSimpleIter.LOB();
      std::string source = resourceFileSimpleIter.source();
      std::string resourceLocName = resourceFileSimpleIter.resourceLocName();
d1227 2
a1228 2
    RCPresourceFileSimpleSubs resourceFileSimple(resourceFileSimpleName);
    RCPresourceFileSimpleSubsIterator resourceFileSimpleIter(resourceFileSimple);
d1232 5
a1236 5
      std::string jobRole = resourceFileSimpleIter.jobRole();
      std::string skillSet = resourceFileSimpleIter.skillSet();
      std::string LOB = resourceFileSimpleIter.LOB();
      std::string source = resourceFileSimpleIter.source();
      std::string resourceLocName = resourceFileSimpleIter.resourceLocName();
d1239 1
a1239 1
      float fixedCost = resourceFileSimpleIter.fixedCostAsFloat();
@


1.45
log
@need to set an acquire cost so that resources already available are used first
@
text
@d715 1
a715 1
      prob.setResourceAcquireCost(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,1.0);
a819 1
         prob.setEngagementRevenue(engagementName,100000.);
d857 10
@


1.44
log
@change to "getEngagementName"
@
text
@d715 1
a715 1

@


1.43
log
@more tests for new (expanded) format. Also fixed memory leak in appdata,
and moved the setting of global variables regarding format, algorithm, and
problem to populate (out of rcp.cpp)
@
text
@d816 2
a817 2
      //need to create an engagement name based on the given data.
      std::string engagementName= createEngagementName(jobRole, skillSet, LOB, source, region,country,city,reportingUnit,band,global,competency,industry);
d1094 1
a1094 1
      std::string engagementName= createEngagementName(jobRole, skillSet, LOB, source, resourceLoc);
d1309 1
a1309 1
      std::string engagementName= createEngagementName(jobRole, skillSet, LOB, source, resourceLoc);
d1392 1
a1392 1
std::string createEngagementName(std::string jobRole, std::string skillSet, std::string LOB, std::string source, std::string resourceLoc){
a1394 6
   return returnval;
}
std::string createEngagementName(std::string jobRole, std::string skillSet, std::string LOB, std::string source, std::string region, std::string country, std::string city, std::string reportingUnit, std::string band, std::string global, std::string competency, std::string industry){

   std::string returnval = "engagement";
                           
@


1.42
log
@fixed a number of problems with the new format
@
text
@d42 4
a45 1

@


1.41
log
@error in addresource
@
text
@d822 1
d896 1
a896 1
}
d1391 1
a1391 1
   std::string returnval = "j: "+ jobRole + " sk: "+skillSet+" lob: "+LOB+" sr: "+ source+" lc: "+resourceLoc;
d1396 2
a1397 12
   std::string returnval = "j:    "+ jobRole + 
                           " sk:  "+skillSet + 
                           " lob: "+LOB + 
                           " sr:  "+ source +
                           " region: "+region +
                           " country: "+ country + 
                           " city:    "+  city + 
                           " report:  " + reportingUnit + 
                           " band:    " + band + 
                           " global: "  + global + 
                           " comp:   " + competency + 
                           " ind: " + industry;
@


1.40
log
@The rcp program now reads the algorithm and problem and branches internally to the appropriate code for gapGlut or resourceAction (problem) and priorityPlan or optimalPlan (algorithm).
@
text
@d9 1
d633 5
d640 22
d731 2
a732 3
    int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, regionMatch, countryMatch, cityMatch, reportingUnitMatch, bandMatch, globalMatch, competencyMatch, industryMatch;
    int jobRoleSub, skillSetSub, lobSub, sourceSub, regionSub, countrySub, citySub, reportingUnitSub, bandSub, globalSub, competencySub, industrySub;
    
d738 1
a738 1
    sourceSub=1;
d740 1
a740 1
    countrySub=1;
d744 1
a744 1
    globalSub=1;
a748 12
      jobRoleMatch=1;
      skillSetMatch=1;
      lobMatch=1;
      sourceMatch=1;
      regionMatch=1;
      countryMatch=1;
      cityMatch=1;
      reportingUnitMatch=1;
      bandMatch=1;
      globalMatch=1;
      competencyMatch=1;
      industryMatch=1;
d751 1
a751 1
      if (jobRole=="unspecified") jobRoleMatch=0;
d753 1
a753 1
      if (skillSet=="unspecified") skillSetMatch=0;
d755 1
a755 1
      if (LOB=="unspecified") lobMatch=0;
d757 1
a757 1
      if (source=="unspecified") sourceMatch=0;
d759 1
a759 1
      if (region=="unspecified") regionMatch=0;
d761 1
a761 1
      if (country=="unspecified") countryMatch=0;
d763 1
a763 1
      if (city=="unspecified") cityMatch=0;
d765 1
a765 1
      if (reportingUnit=="unspecified") reportingUnitMatch=0;
d769 1
a769 1
      if (global=="unspecified") globalMatch=0;
d771 1
a771 1
      if (competency=="unspecified") competencyMatch=0;
d773 1
a773 1
      if (industry=="unspecified") industryMatch=0;
@


1.39
log
@more updates for extra fields. Not done yet though.
@
text
@d38 36
@


1.38
log
@more updates for the additional fields
@
text
@d805 1
d1343 1
a1343 1
   //this needs to be defined!
@


1.37
log
@couple fixes
@
text
@d617 1
a617 1
      int band = resourceFileIter.bandAsInt();
d715 1
a715 1
      int band = bomFileIter.bandAsInt();
d1341 1
a1341 1
std::string createEngagementName(std::string jobRole, std::string skillSet, std::string LOB, std::string source, std::string region, std::string country, std::string city, std::string reportingUnit, int band, std::string global, std::string competency, std::string industry){
a1342 2
   char bandstr[100];
   sprintf(bandstr,"%d", band);
d1351 1
a1351 1
                           " band:    " + bandstr + 
@


1.36
log
@new fields
@
text
@d1344 1
a1344 1
   printf(bandstr,"%s", band);
@


1.35
log
@more preparation for more complex input files
@
text
@d667 2
a668 2
    int jobRoleMatch, skillSetMatch, lobMatch, sourceMatch, resourceLocMatch;
    int jobRoleSub, skillSetSub, lobSub, sourceSub, resourceLocSub;
d676 8
a683 1
    resourceLocSub=0;
d690 8
a697 1
      resourceLocMatch=1;
d707 16
a722 2
      std::string resourceLoc = bomFileIter.resourceLocName();
      if (resourceLoc=="unspecified") resourceLocMatch=0;
d730 1
a730 1
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLoc) ) {
d738 1
a738 1
          <<"   resource location: " <<resourceLoc.c_str()                   <<std::endl
d754 1
a754 1
          <<"   resource location: " <<resourceLoc.c_str()                    <<std::endl
d763 1
a763 1
      std::string engagementName= createEngagementName(jobRole, skillSet, LOB, source, resourceLoc);
d773 2
a774 2
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,resourceLoc) )
         prob.addBom(engagementName,jobRole,skillSet,LOB,source,resourceLoc);
d776 26
a801 11
      prob.setBomUsageQuantity(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,usageQuantity);
      prob.setBomJobRoleMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,jobRoleMatch);
      prob.setBomSkillSetMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,skillSetMatch);
      prob.setBomLocationMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,resourceLocMatch);
      prob.setBomLobMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,lobMatch);
      prob.setBomSourceMatch(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,sourceMatch);
      prob.setBomJobRoleSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,jobRoleSub);
      prob.setBomSkillSetSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,skillSetSub);
      prob.setBomLocationSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,resourceLocSub);
      prob.setBomLobSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,lobSub);
      prob.setBomSourceSub(engagementName,jobRole,skillSet,LOB,source,resourceLoc,period,sourceSub);
d805 1
d841 1
a841 1

d1339 18
@


1.34
log
@preparation for new "complete" format (with more fields)
@
text
@d613 8
a620 1
      std::string resourceLocName = resourceFileIter.resourceLocName();
d640 2
a641 2
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLocName) )
         prob.addResource(jobRole,skillSet,LOB,source,resourceLocName);
d643 1
a643 1
      prob.setExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
d645 1
a645 1
	    prob.setBenchResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
d647 1
a647 1
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLocName,period,1);
@


1.33
log
@added unittests for various of the new file iterators.
@
text
@d13 1
d16 1
d38 1
a38 1
 if ( fileFormat!="03Dec" && fileFormat!="04Jan" && fileFormat!="04JanSubs") {
d45 1
a45 1
      <<"   allowed values: 03Dec 04Jan 04JanSubs"                     <<std::endl
d54 2
d57 1
a57 1
      populate04JanSubs(prob, idir, odir, nPeriods);
d586 150
d737 56
@


1.32
log
@Added setResourceReasonableReleaseCost method that sets the release cost of the bench resource to 2*nPeriods*maximum_period_cost.  This method is invoked for the 04Jan formats, because we don't have data for the release cost.  The default wit scrapping cost is 0 and this isn't good for our rcp model.
@
text
@d912 1
a912 1
      float supplyCost = resourceFileSimpleIter.supplyCostAsFloat();
d940 1
a940 1
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLocName,period,supplyCost);
@


1.31
log
@added another format to populate, where resources have costs, and
explicit substitution matching is performed
@
text
@d700 1
a700 1
      if ( !prob.resourceExists(jobRole,skillSet,LOB,source,resourceLocName) )
d702 1
a702 1

d717 9
d941 10
a951 2

    }
@


1.30
log
@trivial  change to create one engagement per bom entry description (instead of
one total engagment)
@
text
@d12 1
d36 1
a36 1
 if ( fileFormat!="03Dec" && fileFormat!="04Jan" ) {
d43 1
a43 1
      <<"   allowed values: 03Dec 04Jan"                               <<std::endl
d50 1
a50 1
  else 
d52 2
d792 203
@


1.29
log
@trivial change
@
text
@d775 1
a775 1
      if ( !prob.bomExists(engagementName,jobRole,skillSet,LOB,source,resourceLoc) )
d777 1
a777 1

d781 1
a781 1
      
d794 2
d855 1
a855 1
   return "foo";
@


1.28
log
@added more tests for gap/glut for the "simple" case
added incrementing of the current quantity of bom's and resources
@
text
@d704 1
a704 1
      supplyQuantity = currentQuantity[period]+supplyQuantity;
@


1.27
log
@new version of populate, which calls specific versions of the populate routine
depending on which file format is specified in the global attribute file
@
text
@a33 1
  std::string algorithm = globalAttrFile.fieldAsString("algorithm","attrValue");
d35 12
a46 1
  
d654 1
a654 1
//---------------------------------------------------------
d689 2
d701 4
d709 1
d778 2
d781 3
@


1.26
log
@Removed the MRP branch of the model and put the exogenous supply in the bench resource's appData.
@
text
@d9 1
d11 1
d13 1
d34 15
a48 2

  //populate the RCPproblem using the given directories and number of periods
d51 1
a51 1
  
a136 1

d144 1
d614 220
@


1.25
log
@fixed some bugs in the simple file handling
@
text
@d124 1
a124 1
	    prob.setAcquireResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
@


1.24
log
@moved the fixedCost from the resourceaction file to the resource file.
examle data files needed to be modified accordingly.
@
text
@d72 7
a78 6
      prob.addEngagement(engagementName);
      prob.setEngagementRevenue(engagementName,revenue);
      prob.setEngagementStartPeriod(engagementName,startPeriod);
      prob.setEngagementDuration(engagementName,duration);
      prob.setEngagementLateAllowance(engagementName,lateAllowance);
      prob.setEngagementLocation(engagementName,engLocName);
@


1.23
log
@Changed the interpretation of the resource supply to be "Ron's supply" and updated the code for that.  Also, compute gap/glut and print the result in the mrpO.csv file.
@
text
@d99 1
d120 1
d123 1
a123 1
	prob.setAcquireResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,0,supplyQuantity);
d125 3
a150 1
      float fixedCost =  resourceActionFileIter.fixedCostAsFloat();
a170 1
      prob.setResourceFixedCost(jobRole,skillSet,LOB,source,resourceLoc,fixedCost);
@


1.22
log
@Added code to read and add substitute arcs for location, lob, and source
@
text
@d119 4
a122 1
      prob.setResourceSupplyQuantity(jobRole,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
@


1.21
log
@added match flags
@
text
@d13 4
d492 51
@


1.20
log
@Modified code to get to compile on Linux.
@
text
@d185 5
d248 95
a342 1
      // test to ensure jobRolSub has a valid value
d437 2
d443 5
@


1.19
log
@ jobRoleSubs:
-Added file class for reading.
-Created new datafiles.
-in rcpProblem added add/set/get methods
-populateRCP added stanza to read file and invoke add & set methods.
Have not yet added code for adding substitute arcs to wit model.
@
text
@d361 3
a363 3
      &(RCPproblem::addJobRoleSubs),
      &(RCPproblem::setJobRoleSubsCost),
      &(RCPproblem::setJobRoleSubsLeadTime) );
d378 3
a380 3
      &(RCPproblem::addSkillSubs),
      &(RCPproblem::setSkillSubsCost),
      &(RCPproblem::setSkillSubsLeadTime) );
@


1.18
log
@Added fields to bomAppData:
   jobRoleSub, skillSetSub, locationSub, lobSub, sourceSub
Added set/gets for these fields in rcpProblem.
Added reading of these fields in populateRCP.cpp and the calls to set their values in rcpProblem.
@
text
@d6 1
a6 1
#include "rcpProblem.h"
d12 1
a12 1
#include "skillSubsFile.h"
d351 17
d374 7
a380 30
    RCPskillSubsFileIterator skillSubsFileIter(skillSubsFile);
    
    // loop once for each record in bom file
    for ( ; skillSubsFileIter()!=NULL; ) {
      std::string fromSkill = skillSubsFileIter.fromSkill();
      std::string toSkill = skillSubsFileIter.toSkill();
      float cost = skillSubsFileIter.costAsFloat();
      float leadTime = skillSubsFileIter.leadTimeAsFloat();

      // test to ensure that subSkill does not exist
      if ( prob.skillSubsExists(fromSkill,toSkill) ) {
        // skillSubs does exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: skillSubs already exists"                              <<std::endl
          <<"   skillSubs filename: " <<skillSubsFile.filename().c_str()         <<std::endl
          <<"   skillSubs file line number: " <<skillSubsFileIter.recNum()           <<std::endl
          <<"   fromSkill: " <<fromSkill.c_str()                             <<std::endl
          <<"   toSkill: " <<toSkill.c_str()                                 <<std::endl
          <<"   cost: " <<cost                                               <<std::endl
          <<"   leadTime: " <<leadTime                                       <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }

	    prob.addSkillSubs(fromSkill,toSkill);
	    prob.setSkillSubsCost(fromSkill,toSkill,cost);
	    prob.setSkillSubsLeadTime(fromSkill,toSkill,leadTime);
    }
d386 44
@


1.17
log
@Changed globally "resourceName" to "jobRole"
@
text
@d185 5
d242 95
d342 5
@


1.16
log
@Added "source" field to the resource description and all the related code to use "source"
@
text
@d88 1
a88 1
      std::string resourceName = resourceFileIter.resourceName();
d104 1
a104 1
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
d112 2
a113 2
      if ( !prob.resourceExists(resourceName,skillSet,LOB,source,resourceLocName) )
         prob.addResource(resourceName,skillSet,LOB,source,resourceLocName);
d115 1
a115 1
      prob.setResourceSupplyQuantity(resourceName,skillSet,LOB,source,resourceLocName,period,supplyQuantity);
d130 1
a130 1
      std::string resourceName = resourceActionFileIter.resourceName();
d142 1
a142 1
      if ( !prob.resourceExists(resourceName,skillSet,LOB,source,resourceLoc) ) {
d149 1
a149 1
          <<"   resource: " <<resourceName.c_str()                                     <<std::endl
d156 5
a160 5
      prob.setResourceAcquireTime(resourceName,skillSet,LOB,source,resourceLoc,acquireTime);
      prob.setResourceAcquireCost(resourceName,skillSet,LOB,source,resourceLoc,acquireCost);
      prob.setResourceReleaseTime(resourceName,skillSet,LOB,source,resourceLoc,releaseTime);
      prob.setResourceReleaseCost(resourceName,skillSet,LOB,source,resourceLoc,releaseCost);
      prob.setResourceFixedCost(resourceName,skillSet,LOB,source,resourceLoc,fixedCost);
d177 1
a177 1
      std::string resourceName = bomFileIter.resourceName();
d195 1
a195 1
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
d204 1
a204 1
      if ( !prob.resourceExists(resourceName,skillSet,LOB,source,resourceLoc) ) {
d212 1
a212 1
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
d229 1
a229 1
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
d238 2
a239 2
      if ( !prob.bomExists(engagementName,resourceName,skillSet,LOB,source,resourceLoc) )
         prob.addBom(engagementName,resourceName,skillSet,LOB,source,resourceLoc);
d241 1
a241 1
      prob.setBomUsageQuantity(engagementName,resourceName,skillSet,LOB,source,resourceLoc,period,usageQuantity);
@


1.15
log
@Added rcpProblem methods associated with skillSubs.
Code to add WIT subs arcs still needs to be added.
@
text
@d91 1
d112 2
a113 2
      if ( !prob.resourceExists(resourceName,skillSet,LOB,resourceLocName) )
         prob.addResource(resourceName,skillSet,LOB,resourceLocName);
d115 1
a115 1
      prob.setResourceSupplyQuantity(resourceName,skillSet,LOB,resourceLocName,period,supplyQuantity);
d133 1
d142 1
a142 1
      if ( !prob.resourceExists(resourceName,skillSet,LOB,resourceLoc) ) {
d156 5
a160 5
      prob.setResourceAcquireTime(resourceName,skillSet,LOB,resourceLoc, acquireTime);
      prob.setResourceAcquireCost(resourceName,skillSet,LOB,resourceLoc, acquireCost);
      prob.setResourceReleaseTime(resourceName,skillSet,LOB,resourceLoc, releaseTime);
      prob.setResourceReleaseCost(resourceName,skillSet,LOB,resourceLoc, releaseCost);
      prob.setResourceFixedCost(resourceName,skillSet,LOB,resourceLoc, fixedCost);
d180 1
d204 1
a204 1
      if ( !prob.resourceExists(resourceName,skillSet,LOB,resourceLoc) ) {
d238 2
a239 2
      if ( !prob.bomExists(engagementName,resourceName,skillSet,LOB,resourceLoc) )
         prob.addBom(engagementName,resourceName,skillSet,LOB,resourceLoc);
d241 1
a241 1
      prob.setBomUsageQuantity(engagementName,resourceName,skillSet,LOB,resourceLoc,period,usageQuantity);
@


1.14
log
@Added skillSet to rcp code;  added skillSubs* to appl.mk
@
text
@d258 21
a278 4
	  //rcpProblem.addSkillSubs(fromSkill,toSkill);
	  //rcpProblem.setSkillSubsCost(fromSkill,toSkill,cost);
	  //rcpProblem.setSkillSubsLeadTime(fromSkill,toSkill,leadTime);
	}
@


1.13
log
@Added reading skillSubs file to populateRCP. Code to pass skillSubs to RCP Problem has not yet been implemented.
@
text
@d90 1
d111 2
a112 2
      if ( !prob.resourceExists(resourceName,skillSet,resourceLocName) )
         prob.addResource(resourceName,skillSet,resourceLocName);
d114 1
a114 1
      prob.setResourceSupplyQuantity(resourceName,skillSet,resourceLocName,period,supplyQuantity);
d131 1
d140 1
a140 1
      if ( !prob.resourceExists(resourceName,skillSet,resourceLoc) ) {
d154 5
a158 5
      prob.setResourceAcquireTime(resourceName,skillSet,resourceLoc, acquireTime);
      prob.setResourceAcquireCost(resourceName,skillSet,resourceLoc, acquireCost);
      prob.setResourceReleaseTime(resourceName,skillSet,resourceLoc, releaseTime);
      prob.setResourceReleaseCost(resourceName,skillSet,resourceLoc, releaseCost);
      prob.setResourceFixedCost(resourceName,skillSet,resourceLoc, fixedCost);
d177 1
d201 1
a201 1
      if ( !prob.resourceExists(resourceName,skillSet,resourceLoc) ) {
d235 2
a236 2
      if ( !prob.bomExists(engagementName,resourceName,skillSet,resourceLoc) )
         prob.addBom(engagementName,resourceName,skillSet,resourceLoc);
d238 1
a238 1
      prob.setBomUsageQuantity(engagementName,resourceName,skillSet,resourceLoc,period,usageQuantity);
@


1.12
log
@Added "skillSet" field to input files and updated the code to use this field.
@
text
@d12 1
d238 22
a259 1
  
@


1.11
log
@Added globalAttr file containing algorithm and nPeriods
@
text
@d31 1
d88 1
d109 2
a110 2
      if ( !prob.resourceExists(resourceName,resourceLocName) )
         prob.addResource(resourceName,resourceLocName);
d112 1
a112 1
      prob.setResourceSupplyQuantity(resourceName,resourceLocName,period,supplyQuantity);
d128 1
d137 1
a137 1
      if ( !prob.resourceExists(resourceName,resourceLoc) ) {
d151 5
a155 5
      prob.setResourceAcquireTime(resourceName,resourceLoc, acquireTime);
      prob.setResourceAcquireCost(resourceName,resourceLoc, acquireCost);
      prob.setResourceReleaseTime(resourceName,resourceLoc, releaseTime);
      prob.setResourceReleaseCost(resourceName,resourceLoc, releaseCost);
      prob.setResourceFixedCost(resourceName,resourceLoc, fixedCost);
d173 1
d197 1
a197 1
      if ( !prob.resourceExists(resourceName,resourceLoc) ) {
d231 2
a232 2
      if ( !prob.bomExists(engagementName,resourceName,resourceLoc) )
         prob.addBom(engagementName,resourceName,resourceLoc);
d234 1
a234 1
      prob.setBomUsageQuantity(engagementName,resourceName,resourceLoc,period,usageQuantity);
@


1.10
log
@Code modifed so that an engagment is only uniquely identified by enagementName.
Engagement location is now an attribute of an engagement stored in appData.
@
text
@d8 1
d18 2
a19 2
              const std::string & odir, 
              int nPeriods) {
d21 5
@


1.9
log
@changed some variable names
@
text
@d60 6
a65 5
      prob.addEngagement(engagementName,engLocName);
      prob.setEngagementRevenue(engagementName,engLocName,revenue);
      prob.setEngagementStartPeriod(engagementName,engLocName,startPeriod);
      prob.setEngagementDuration(engagementName,engLocName,duration);
      prob.setEngagementLateAllowance(engagementName,engLocName,lateAllowance);
a165 1
      std::string engLocationName = bomFileIter.engLocationName();
d170 1
a170 1
      if ( !prob.engagementExists(engagementName,engLocationName) ) {
a177 1
          <<"   engLocation: " <<engLocationName.c_str()                     <<std::endl
a194 1
          <<"   endlocation: " <<engLocationName.c_str()                     <<std::endl
a211 1
          <<"   engLocation: " <<engLocationName.c_str()                      <<std::endl
d221 2
a222 2
      if ( !prob.bomExists(engagementName,engLocationName,resourceName,resourceLoc) )
         prob.addBom(engagementName,engLocationName,resourceName,resourceLoc);
d224 1
a224 1
      prob.setBomUsageQuantity(engagementName,engLocationName,resourceName,resourceLoc,period,usageQuantity);
@


1.8
log
@Added resource location to resourceActionFile and removed hardcoded resource location from populateRCP.cpp.
@
text
@d37 1
a37 1
      std::string resourceLocName = engagementFileIter.engLocationName();
d60 5
a64 5
      prob.addEngagement(engagementName,resourceLocName);
      prob.setEngagementRevenue(engagementName,resourceLocName,revenue);
      prob.setEngagementStartPeriod(engagementName,resourceLocName,startPeriod);
      prob.setEngagementDuration(engagementName,resourceLocName,duration);
      prob.setEngagementLateAllowance(engagementName,resourceLocName,lateAllowance);
@


1.7
log
@Added engagement location to the model.
@
text
@a19 2
  // For now just hardcode resource location
  std::string resourceLoc = "l1";
d119 1
d135 1
d163 1
d180 1
d198 1
d216 1
@


1.6
log
@Updated to read resourceLocatoin from resource file
@
text
@d39 1
d62 5
a66 5
      prob.addEngagement(engagementName);
      prob.setEngagementRevenue(engagementName,revenue);
      prob.setEngagementStartPeriod(engagementName,startPeriod);
      prob.setEngagementDuration(engagementName,duration);
      prob.setEngagementLateAllowance(engagementName,lateAllowance);
d82 1
a82 1
      std::string locationName = resourceFileIter.locationName();
d102 2
a103 2
      if ( !prob.resourceExists(resourceName,locationName) )
         prob.addResource(resourceName,locationName);
d105 1
a105 1
      prob.setResourceSupplyQuantity(resourceName,locationName,period,supplyQuantity);
d164 1
d169 1
a169 1
      if ( !prob.engagementExists(engagementName) ) {
d177 1
d194 1
d211 1
d220 2
a221 2
      if ( !prob.bomExists(engagementName,resourceName,resourceLoc) )
         prob.addBom(engagementName,resourceName,resourceLoc);
d223 1
a223 1
      prob.setBomUsageQuantity(engagementName,resourceName,resourceLoc,period,usageQuantity);
@


1.5
log
@Added resourceLocation to rcpProblem methods.
Hardcode resourceLocation as l1 in function populateRCP
@
text
@d81 1
d101 2
a102 2
      if ( !prob.resourceExists(resourceName,resourceLoc) )
         prob.addResource(resourceName,resourceLoc);
d104 1
a104 1
      prob.setResourceSupplyQuantity(resourceName,resourceLoc,period,supplyQuantity);
@


1.4
log
@Added pragma's to avoid MS C++ V6 warning messages
@
text
@d20 3
d100 2
a101 2
      if ( !prob.resourceExists(resourceName) )
         prob.addResource(resourceName);
d103 1
a103 1
      prob.setResourceSupplyQuantity(resourceName,period,supplyQuantity);
d126 1
a126 1
      if ( !prob.resourceExists(resourceName) ) {
d139 5
a143 5
      prob.setResourceAcquireTime(resourceName, acquireTime);
      prob.setResourceAcquireCost(resourceName, acquireCost);
      prob.setResourceReleaseTime(resourceName, releaseTime);
      prob.setResourceReleaseCost(resourceName, releaseCost);
      prob.setResourceFixedCost(resourceName, fixedCost);
d182 1
a182 1
      if ( !prob.resourceExists(resourceName) ) {
d214 2
a215 2
      if ( !prob.bomExists(engagementName,resourceName) )
         prob.addBom(engagementName,resourceName);
d217 1
a217 1
      prob.setBomUsageQuantity(engagementName,resourceName,period,usageQuantity);
@


1.3
log
@Added the concept of lateAllowance to allow us to set the ShipReward for a fixed number of periods following the due date.  The lateAllowance value is stored in the engagementAppData.  The engagementFile was modified to add the new field.  I added a CR/LF to the end of populateRCP.h to avoid the warning message from the Linux compiler.
@
text
@d1 5
@


1.2
log
@changed signature on populateRCP function so rcpProblem is passed by reference.
@
text
@d34 1
d57 1
@


1.1
log
@moved populate function to a separate file (not part of rcpProblem)
@
text
@d9 5
a13 1
void populate(RCPproblem prob, std::string idir, std::string odir, int nPeriods) {
@


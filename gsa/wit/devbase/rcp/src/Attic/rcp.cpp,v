head	1.49;
access;
symbols
	start:1.1.1.1 IBM:1.1.1;
locks; strict;
comment	@// @;


1.49
date	2004.03.30.23.42.47;	author fasano;	state dead;
branches;
next	1.48;

1.48
date	2004.03.17.18.21.24;	author dpc;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.16.20.48.21;	author dpc;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.10.19.13.31;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.10.17.08.43;	author dpc;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.09.14.23.56;	author gresh;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.01.22.54.03;	author dpc;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.12.21.24.30;	author gresh;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.12.17.56.03;	author gresh;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.12.17.26.59;	author gresh;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.11.19.39.09;	author gresh;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.29.15.36.01;	author gresh;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.27.20.48.35;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.26.17.35.02;	author gresh;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.26.14.29.38;	author gresh;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.23.13.54.38;	author dpc;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.21.20.40.03;	author dpc;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.21.14.43.07;	author dpc;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.16.19.44.12;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.09.21.39.50;	author dpc;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.08.20.00.04;	author dpc;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.07.22.18.34;	author dpc;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.07.14.01.52;	author dpc;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.06.17.10.02;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.13.04.56.56;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.13.04.52.48;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.12.17.04.18;	author dpc;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.09.14.17.45;	author dpc;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.03.22.09.53;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.01.17.44.13;	author gresh;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.01.16.00.31;	author gresh;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.01.14.19.06;	author gresh;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.26.03.25.20;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.25.19.09.02;	author gresh;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.25.18.58.54;	author gresh;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.25.14.57.48;	author gresh;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.24.18.16.56;	author gresh;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.24.18.06.26;	author gresh;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.23.11.51.54;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.21.22.34.57;	author dpc;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.21.16.58.55;	author dpc;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.20.02.12.59;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.19.19.34.24;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.19.15.23.56;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.18.21.35.12;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.18.19.32.19;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.14.21.38.03;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.14.20.23.15;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.13.14.23.40;	author fasano;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.13.14.23.40;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Cleaning up last vestiges of old style code. Removed dead files and if defed out sections.
@
text
@#if 0

#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#endif


#include "wit.h"

#include <map>
#include <vector>

#include <assert.h>
#include <iostream>
#include <float.h>
#include <math.h>


#include "rcpProblem.h"
#include "populateRCP.h"
#include "globalAttrFile.h"


int
main (int argc, char * argv[])
{
  
  std::cout <<"rcp2 Build date: " <<__DATE__ <<std::endl;
  
  // Put Parms into a vector
  std::vector<std::string> args;
  for (int i=0; i<argc; i++) 
    args.push_back(argv[i]);
  
  {
    // Check parm passed to program
    bool parmError = false;
    
    if ( args.size()> 1 ) {
      if (args[1]=="?" ) {
        parmError = true; // set flag to provide usage info
      }
    }
    
    if ( ! parmError ) {
      if ( args.size()!=2 ) {
        // Wrong number of parms. Write message
        std::cerr 
          <<"-------------------------------------------------------"  <<std::endl
          <<"Wrong number of parmeters specified"                      <<std::endl
          <<"  Number parameters specified: " <<args.size()-1          <<std::endl
          <<"  Expected number of parameters: 1"                       <<std::endl
          <<"-------------------------------------------------------"  <<std::endl;
        parmError = true;
      }
    }
    
    
    
    if ( parmError ) {
      // Write correct usage
      std::cerr 
        <<"-------------------------------------------------------"  <<std::endl
        <<argv[0] <<" dataDirectory "                                <<std::endl
        <<"  where:"                                                 <<std::endl
        <<"    dataDirectory:"                                       <<std::endl
        <<"      Directory where input files are located and"        <<std::endl
        <<"      output files are written."                          <<std::endl
        <<"  example usage:"                                         <<std::endl
        <<"    " <<argv[0] <<" example_tucson"                       <<std::endl
        <<"-------------------------------------------------------"  <<std::endl;
      return 1;
    }
  }
  
  std::string outputDirectory=args[1];
  std::string inputDirectory=args[1];
  
  RCPproblem rcpProb;
  populate(rcpProb, inputDirectory, outputDirectory);

  // Get the name of the problem to be solved and the algorithm method
  std::string globalAttrFileName = inputDirectory + "/globalAttr.csv";
  RCPglobalAttrFile globalAttrFile(globalAttrFileName);
  std::string format = globalAttrFile.fieldAsString("fileFormat","attrValue");
  std::string prob = globalAttrFile.fieldAsString("problem","attrValue");
  std::string alg = globalAttrFile.fieldAsString("algorithm","attrValue");

  // Check the name of the problem
  if ( prob!="resourceAction" && prob!="gapGlut" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown problem specified."                          <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   problem specified: " <<prob                                <<std::endl
      <<"   allowed values: resourceAction gapGlut"                    <<std::endl
      <<"   resourceAction performed "                                 <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    prob="resourceAction";
  }


  // Check the name of the algorithm to be used

  if ( alg!="optimalPlan" && alg!="priorityPlan" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown algorithm specified."                        <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   algorithm specified: " <<alg                               <<std::endl
      <<"   allowed values: optimalPlan priorityPlan"                  <<std::endl
      <<"   resourceAction will be performed "                         <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    alg="optimalPlan";
  }



  if (format=="04Feb") {
       // Is GapGlut Solve to be done?
       if ( prob=="gapGlut" )
         rcpProb.gapGlut04Feb();
       if ( prob=="resourceAction" )
         rcpProb.resourceAction04Feb(); 
  }
  else {
       // Is GapGlut Solve to be done?
       if ( prob=="gapGlut" )
         rcpProb.gapGlut();
       if ( prob=="resourceAction" )
         rcpProb.resourceAction();   
  }
  
  
  // Write Results
 
  if (format=="04Feb") {
  // Write resource plan
  if ( prob=="resourceAction" )
  {
    // Open file
    std::string resourcePlanFileName = outputDirectory+"/resourceO.csv";
    FILE * resourcePlanFilePtr = fopen(resourcePlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"jobRole\",\"skillSet\","
      "\"LOB\",\"source\","
      "\"region\",\"period\","
      "\"region\",\"country\","
      "\"city\",\"reportingUnit\","
      "\"band\",\"global\","
      "\"competency\",\"industry\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\""
      "\"releaseQuantity\""; 
    fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all resources
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries);

  
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> benchQty = rcpProb.getOptimalBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getOptimalWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      
      for ( int t=0; t<supQty.size(); t++ ) {
        fprintf(resourcePlanFilePtr,
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f,\n",
          jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),regions[r].c_str(),
          countries[r].c_str(),cities[r].c_str(),reportingUnits[r].c_str(),bands[r].c_str(),globals[r].c_str(),competencies[r].c_str(),industries[r].c_str(),
          t,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
      } // finished t loop
      
    } // end of r loop
    
    fclose(resourcePlanFilePtr);
  } // end of write resource plan block


  // Write engagment plan
  if ( prob=="resourceAction" )
  {
    // Open file
    std::string engagementPlanFileName = outputDirectory+"/engagementO.csv";
    FILE * engagementPlanFilePtr = fopen(engagementPlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
    fprintf(engagementPlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    
    rcpProb.getEngagementNames(engagementNames);
    
    // loop once for each engagement
    int e;
    bool engagementExecuted;
    int reqStartPeriod;
    int actStartPeriod;
    for ( e=0; e<engagementNames.size(); ++e ) {
      engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      std::string engLoc = rcpProb.getEngagementLocation(engagementNames[e]);
      fprintf(engagementPlanFilePtr,
        "\"%s\",\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engLoc.c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
      
    } // end of e loop
    
    fclose(engagementPlanFilePtr);
  } // end of write engagement plan block  
  
  
  if ( prob=="gapGlut" )
  {
    // Open file
    std::string mrpPlanFileName = outputDirectory+"/mrpO.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
    
    //    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
    //"\"supplyQuantity\",\"benchQuantity\","
    //"\"workingQuantity\",\"acquireQuantity\""
    //"\"releaseQuantity\""; 
    
    
    
    
    // this will work for all formats; one will only find the "dummy" fields in 
    // format 04Jan
    
    // Get list of all resources
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries);
    // Write header record
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\""; 
    //fprintf(mrpPlanFilePtr,"%s\n",heading.c_str());
    fprintf(mrpPlanFilePtr,"\"jobRole\",");
    fprintf(mrpPlanFilePtr,"\"skillSet\",");
    fprintf(mrpPlanFilePtr,"\"LOB\",");
    fprintf(mrpPlanFilePtr,"\"source\",");
    fprintf(mrpPlanFilePtr,"\"region\",");
    fprintf(mrpPlanFilePtr,"\"country\",");
    fprintf(mrpPlanFilePtr,"\"city\",");
    fprintf(mrpPlanFilePtr,"\"reportingUnit\",");
    fprintf(mrpPlanFilePtr,"\"band\",");
    fprintf(mrpPlanFilePtr,"\"global\",");
    fprintf(mrpPlanFilePtr,"\"competency\",");
    fprintf(mrpPlanFilePtr,"\"industry\",");
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      for ( int t=0; t<grossQty.size(); t++ ) {
        //fprintf(mrpPlanFilePtr,
          //"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          //jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          //t, 
          //exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
        fprintf(mrpPlanFilePtr,"\"%s\",",jobRoles[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",skillSets[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",LOBs[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",sources[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",regions[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",countries[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",cities[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",reportingUnits[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",bands[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",globals[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",competencies[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",industries[r].c_str());
        fprintf(mrpPlanFilePtr,
          "%d,%f,%f,%f,%f\n",
          t, 
          exogSup[t],grossQty[t],gapQty[t],glutQty[t]);

      } // finished t loop
      
    } // end of r loop
    
    fclose(mrpPlanFilePtr);
  } // end of write mrp plan block
  
  }
  else { // original format 
  // Write resource plan
  if ( prob=="resourceAction" )
  {
    // Open file
    std::string resourcePlanFileName = outputDirectory+"/resourceO.csv";
    FILE * resourcePlanFilePtr = fopen(resourcePlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\""
      "\"releaseQuantity\""; 
    fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all resources
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);

  
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getOptimalBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getOptimalWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      
      for ( int t=0; t<supQty.size(); t++ ) {
        fprintf(resourcePlanFilePtr,
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          t,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
      } // finished t loop
      
    } // end of r loop
    
    fclose(resourcePlanFilePtr);
  } // end of write resource plan block


  // Write engagment plan
  if ( prob=="resourceAction" )
  {
    // Open file
    std::string engagementPlanFileName = outputDirectory+"/engagementO.csv";
    FILE * engagementPlanFilePtr = fopen(engagementPlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
    fprintf(engagementPlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    
    rcpProb.getEngagementNames(engagementNames);
    
    // loop once for each engagement
    int e;
    bool engagementExecuted;
    int reqStartPeriod;
    int actStartPeriod;
    for ( e=0; e<engagementNames.size(); ++e ) {
      engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      std::string engLoc = rcpProb.getEngagementLocation(engagementNames[e]);
      fprintf(engagementPlanFilePtr,
        "\"%s\",\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engLoc.c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
      
    } // end of e loop
    
    fclose(engagementPlanFilePtr);
  } // end of write engagement plan block  
  
  
  if ( prob=="gapGlut" )
  {
    // Open file
    std::string mrpPlanFileName = outputDirectory+"/mrpO.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
    
    //    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
    //"\"supplyQuantity\",\"benchQuantity\","
    //"\"workingQuantity\",\"acquireQuantity\""
    //"\"releaseQuantity\""; 
    
    
    
    
    // this will work for all formats; one will only find the "dummy" fields in 
    // format 04Jan
    
    // Get list of all resources
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
    // Write header record
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\""; 
    //fprintf(mrpPlanFilePtr,"%s\n",heading.c_str());
    if (strcmp(jobRoles[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"jobRole\",");
    if (strcmp(skillSets[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"skillSet\",");
    if (strcmp(LOBs[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"LOB\",");
    if (strcmp(sources[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"source\",");
    if (strcmp(resourceLocs[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"locationName\",");
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\""; 
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      for ( int t=0; t<grossQty.size(); t++ ) {
        //fprintf(mrpPlanFilePtr,
          //"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          //jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          //t, 
          //exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
        if (strcmp(jobRoles[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",jobRoles[r].c_str());
        if (strcmp(skillSets[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",skillSets[r].c_str());
        if (strcmp(LOBs[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",LOBs[r].c_str());
        if (strcmp(sources[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",sources[r].c_str());
        if (strcmp(resourceLocs[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",resourceLocs[r].c_str());
        fprintf(mrpPlanFilePtr,
          "%d,%f,%f,%f,%f\n",
          t, 
          exogSup[t],grossQty[t],gapQty[t],glutQty[t]);

      } // finished t loop
      
    } // end of r loop
    
    fclose(mrpPlanFilePtr);
  } // end of write mrp plan block
  }  
  
  
  std::cout <<"rcp application is finished." <<std::endl;
  return 0;
}

#endif
@


1.48
log
@Changed [sg]et[Gap,Glut]Quantity to [sg]etResource[Gap,Glut]ResourceQuantity
@
text
@@


1.47
log
@Added bench, working, acquire and release quantities to the app data of the bench and working resources.  Also cleaned up the merge conflicts.
@
text
@d267 3
a269 3
      std::vector<float> grossQty = rcpProb.getMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> gapQty = rcpProb.getGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> glutQty = rcpProb.getGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d421 3
a423 3
      std::vector<float> grossQty = rcpProb.getMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.46
log
@- rcp.cpp renamed to rcpOptMain.cpp. This is the rcp standalone executable. (rcp.cpp remains for now in repository but is unused).
- removed main program rcpInvoke.cpp, because rcpOptMain will be used.(rcpInvoke.cpp remains for now in repository but is unused).
- invokeRcp.cpp was renamed rcpOpt.cpp (invokeRcp.cpp remains for now in the repository but is unused)
- rcpAlone.h was renamed rcpOpt.h (rcpAlone.h remains for now in repository but is unused).

- mds project rcp was replaced with project rcpOptMain.
- new mds project named rcpOptDll was created.  This project exposes the public members of RCPproblem and function rcpOpt(String directory);
@
text
@d171 2
a172 2
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d270 1
a270 1
      std::vector<float> exogSup = rcpProb.getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d327 2
a328 2
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d424 1
a424 1
      std::vector<float> exogSup = rcpProb.getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.45
log
@Fixed some reporting issues with gaps and gluts.
@
text
@d1 2
d458 2
@


1.44
log
@more tests for new (expanded) format. Also fixed memory leak in appdata,
and moved the setting of global variables regarding format, algorithm, and
problem to populate (out of rcp.cpp)
@
text
@d247 1
a247 1
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
d261 1
a261 1
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\",\"workingQty\"\n");
d266 2
a267 2
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
a268 2
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      
d288 1
a288 1
          "%d,%f,%f,%f,%f,%f\n",
d290 1
a290 1
          exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
d402 1
a402 1
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
d414 2
a415 2
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\",\"workingQty\"\n");
d420 2
a421 2
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
a422 2
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      
d428 1
a428 1
          //exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
d440 1
a440 1
          "%d,%f,%f,%f,%f,%f\n",
d442 1
a442 1
          exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
@


1.43
log
@The rcp program now reads the algorithm and problem and branches internally to the appropriate code for gapGlut or resourceAction (problem) and priorityPlan or optimalPlan (algorithm).
@
text
@d118 1
a118 3
  rcpProb.setAlgorithmName(alg);
  rcpProb.setProblemName(prob);
  rcpProb.setFormatName(format);
@


1.42
log
@yet more refinements for the new model.
@
text
@d81 1
a81 1
  // Get the name of the algorithm to be used
d84 2
a86 1
  std::string format = globalAttrFile.fieldAsString("fileFormat","attrValue");
d88 18
a105 1
  if ( alg!="optimalPlan" && alg!="gapGlut" ) {
d112 2
a113 2
      <<"   allowed values: optimalPlan gapGlut"                       <<std::endl
      <<"   gapGlut will be performed "                                <<std::endl
d115 1
a115 1
    alg="gapGlut";
d118 3
a120 1

d124 1
a124 1
       if ( alg=="gapGlut" )
d126 2
a127 2
       if ( alg=="optimalPlan" )
         rcpProb.optimalPlan04Feb(); 
d131 1
a131 1
       if ( alg=="gapGlut" )
d133 2
a134 2
       if ( alg=="optimalPlan" )
         rcpProb.optimalPlan();   
d142 1
a142 1
  if ( alg=="optimalPlan" )
d192 1
a192 1
  if ( alg=="optimalPlan" )
d228 1
a228 1
  if ( alg=="gapGlut" )
d267 1
a267 1
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d306 1
a306 1
  if ( alg=="optimalPlan" )
d349 1
a349 1
  if ( alg=="optimalPlan" )
d385 1
a385 1
  if ( alg=="gapGlut" )
d423 1
a423 1
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.41
log
@more updates for extra fields. Not done yet though.
@
text
@d119 156
a274 1
  //DLG the writing needs to be fixed if it is 04Feb format
d276 9
d436 1
a436 5
  


  
  
@


1.40
log
@more updates for the additional fields
@
text
@d119 1
@


1.39
log
@more preparation for more complex input files
@
text
@d85 1
a100 3
  // Is GapGlut Solve to be done?
  if ( alg=="gapGlut" )
    rcpProb.gapGlut();
d102 14
a115 3
  
  if ( alg=="optimalPlan" )
    rcpProb.optimalPlan(); 
@


1.38
log
@added a comment to clarify what's being written in mrpO.csv
@
text
@d134 1
a134 1
      std::vector<float> supQty = rcpProb.setBenchResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.37
log
@Modified help text to better match code being given to Ron
@
text
@d205 2
@


1.36
log
@minor change; remove a space in writing a header record in mrpO.csv
@
text
@d69 1
a69 1
        <<"    " <<argv[0] <<" ../data/example1"                     <<std::endl
@


1.35
log
@Modified writing of mrpO.csv to not write out dummy fields (for the
case of simple format, with all match flags equal at the global level)
@
text
@d223 1
a223 1
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\"\n");
@


1.34
log
@Removed delclaration of theGap, theGlut, and delta, which aren't being used now.
@
text
@a203 3
    // Write header record
    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
    fprintf(mrpPlanFilePtr,"%s\n",heading.c_str());
d209 15
a223 1
    
d234 15
d250 1
a250 2
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
d253 1
@


1.33
log
@Removed the MRP branch of the model and put the exogenous supply in the bench resource's appData.
@
text
@a214 1
    float theGap, theGlut, delta;
@


1.32
log
@Changed the interpretation of the resource supply to be "Ron's supply" and updated the code for that.  Also, compute gap/glut and print the result in the mrpO.csv file.
@
text
@d134 1
a134 1
      std::vector<float> supQty = rcpProb.getAcquireResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
a223 7
      //theGap = 0.0f;
      //theGlut = 0.0f;
      //delta = exogSup[t] - workingQty[t];
      //if (delta > 0)
        //theGlut = delta;
      //else
        //theGap = fabs(delta);
@


1.31
log
@algorithm in globalAttr is now gapGlut or optimalPlan
The rcpProblem::solve method was removed.
Added methods rcpProblem::gapGlut and rcpProblem::optimalPlan
@
text
@d134 1
a134 1
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d152 2
a153 1
  
a190 1
  // Write MRPe plan
d205 1
a205 1
    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"grossQuantity\",\"gapQuantity\",\"mrpExcessQuantity\",\"mrpResidualQuantity\""; 
d215 1
d220 2
a221 1
      std::vector<float> residualQty = rcpProb.getResourceResidualQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d224 7
d232 1
a232 1
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f\n",
d234 2
a235 2
          t,
          grossQty[t],gapQty[t],glutQty[t],residualQty[t]);
d243 2
@


1.30
log
@Changed globally "resourceName" to "jobRole"
@
text
@d20 1
d80 24
a103 1
  rcpProb.solve();
d105 2
d110 1
a110 1
  
d112 1
d154 1
d191 1
@


1.29
log
@Added "source" field to the resource description and all the related code to use "source"
@
text
@d92 1
a92 1
    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
d100 2
a101 2
    std::vector<std::string> resourceNames,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,LOBs,sources,resourceLocs);
d106 6
a111 6
    for ( r=0; r<resourceNames.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d116 1
a116 1
          resourceNames[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
d168 1
a168 1
    //    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
d176 1
a176 1
    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"grossQuantity\",\"gapQuantity\",\"mrpExcessQuantity\",\"mrpResidualQuantity\""; 
d181 2
a182 2
    std::vector<std::string> resourceNames,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,LOBs,sources,resourceLocs);
d186 5
a190 5
    for ( r=0; r<resourceNames.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> residualQty = rcpProb.getResourceResidualQuantity(resourceNames[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d195 1
a195 1
          resourceNames[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
@


1.28
log
@Added skillSet to rcp code;  added skillSubs* to appl.mk
@
text
@d92 1
a92 1
    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"locationName\",\"period\","
d100 4
a103 3
    std::vector<std::string> resourceNames,skillSets,LOBs,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,LOBs,resourceLocs);
    
d107 5
a111 5
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
d115 2
a116 2
          "\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),resourceLocs[r].c_str(),
d168 1
a168 1
    //    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"locationName\",\"period\","
d176 1
a176 1
    std::string heading="\"resourceName\",\"skillSet\",\"LOB\",\"locationName\",\"period\",\"grossQuantity\",\"gapQuantity\",\"mrpExcessQuantity\",\"mrpResidualQuantity\""; 
d181 2
a182 2
    std::vector<std::string> resourceNames,skillSets,LOBs,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,LOBs,resourceLocs);
d187 4
a190 4
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
      std::vector<float> residualQty = rcpProb.getResourceResidualQuantity(resourceNames[r],skillSets[r],LOBs[r],resourceLocs[r]);
d194 2
a195 2
          "\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),resourceLocs[r].c_str(),
@


1.27
log
@Added "skillSet" field to input files and updated the code to use this field.
@
text
@d92 1
a92 1
    std::string heading="\"resourceName\",\"skillSet\",\"locationName\",\"period\","
d100 2
a101 2
    std::vector<std::string> resourceNames,skillSets,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,resourceLocs);
d106 5
a110 5
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
d114 2
a115 2
          "\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),skillSets[r].c_str(),resourceLocs[r].c_str(),
d167 1
a167 1
    //    std::string heading="\"resourceName\",\"skillSet\",\"locationName\",\"period\","
d175 1
a175 1
    std::string heading="\"resourceName\",\"skillSet\",\"locationName\",\"period\",\"grossQuantity\",\"gapQuantity\",\"mrpExcessQuantity\",\"mrpResidualQuantity\""; 
d180 2
a181 2
    std::vector<std::string> resourceNames,skillSets,resourceLocs;
    rcpProb.getResourceNames(resourceNames,skillSets,resourceLocs);
d186 4
a189 4
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
      std::vector<float> residualQty = rcpProb.getResourceResidualQuantity(resourceNames[r],skillSets[r],resourceLocs[r]);
d193 2
a194 2
          "\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),skillSets[r].c_str(),resourceLocs[r].c_str(),
@


1.26
log
@Added globalAttr file containing algorithm and nPeriods
@
text
@d92 1
a92 1
    std::string heading="\"resourceName\",\"locationName\",\"period\","
d100 2
a101 2
    std::vector<std::string> resourceNames,resourceLocs;
    rcpProb.getResourceNames(resourceNames,resourceLocs);
d106 5
a110 5
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceNames[r],resourceLocs[r]);
d114 2
a115 2
          "\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),resourceLocs[r].c_str(),
d167 1
a167 1
    //    std::string heading="\"resourceName\",\"locationName\",\"period\","
d175 1
a175 1
    std::string heading="\"resourceName\",\"locationName\",\"period\",\"grossQuantity\",\"gapQuantity\",\"glutQuantity\""; 
d180 2
a181 2
    std::vector<std::string> resourceNames,resourceLocs;
    rcpProb.getResourceNames(resourceNames,resourceLocs);
d186 4
a189 4
      std::vector<float> grossQty = rcpProb.getResourceGrossQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceNames[r],resourceLocs[r]);
      std::vector<float> residualQty = rcpProb.getResourceResidualQuantity(resourceNames[r],resourceLocs[r]);
d193 2
a194 2
          "\"%s\",\"%s\",%d,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),resourceLocs[r].c_str(),
@


1.25
log
@Changed formating removing tabs
@
text
@d78 1
a78 1
  populate(rcpProb, inputDirectory, outputDirectory, 16);
@


1.24
log
@Code modifed so that an engagment is only uniquely identified by enagementName.
Engagement location is now an attribute of an engagement stored in appData.
@
text
@d90 1
a90 1

d97 2
a98 2

       
d102 1
a102 1

d111 1
a111 1

d119 1
a119 1

d121 1
a121 1

d130 1
a130 1

d134 2
a135 2

       
d138 1
a138 1

d140 1
a140 1

d143 3
a145 3
	bool engagementExecuted;
	int reqStartPeriod;
	int actStartPeriod;
d147 1
a147 1
	  engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
d149 2
a150 2
	  actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
    std::string engLoc = rcpProb.getEngagementLocation(engagementNames[e]);
d152 3
a154 3
          "\"%s\",\"%s\",%d,%d, %d\n",
          engagementNames[e].c_str(),engLoc.c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);

d156 1
a156 1

d159 2
a160 2


d166 1
a166 1

d171 3
a173 3



d177 2
a178 2

       
d182 1
a182 1

d190 1
a190 1

d198 1
a198 1

d200 1
a200 1

d203 5
a207 5




      
@


1.23
log
@Added MRP stuff and fixed duration/offset calculations
@
text
@a137 1
    std::vector<std::string> engLocationNames;
d139 1
a139 1
    rcpProb.getEngagementNames(engagementNames,engLocationNames);
d147 4
a150 3
	  engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e],engLocationNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e],engLocationNames[e]);
	  actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e],engLocationNames[e]);
d153 1
a153 1
          engagementNames[e].c_str(),engLocationNames[e].c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
@


1.22
log
@Added engagement location to the model.
@
text
@d161 46
@


1.21
log
@Updated to use resource location
@
text
@d132 1
a132 1
    std::string heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
d138 3
a140 1
    rcpProb.getEngagementNames(engagementNames);
d148 3
a150 3
	  engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
	  actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
d152 2
a153 2
          "\"%s\",%d,%d, %d\n",
          engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
@


1.20
log
@moved populate function to a separate file (not part of rcpProblem)
@
text
@d84 1
a84 1
     
d92 1
a92 1
    std::string heading="\"resourceName\",\"period\","
d100 2
a101 2
    std::vector<std::string> resourceNames;
    rcpProb.getResourceNames(resourceNames);
d106 5
a110 5
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceNames[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceNames[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceNames[r]);
	  std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r]);
	  std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceNames[r]);
d114 3
a116 2
          "\"%s\",%d,%f,%f,%f,%f,%f\n",
          resourceNames[r].c_str(),t,
@


1.19
log
@better examples for the unit test
to test various scenarios (acquire; delay; decline)
@
text
@d19 1
d78 1
a78 1
  rcpProb.populate(inputDirectory, outputDirectory, 16);
@


1.18
log
@cleaning up the testing procedures
@
text
@d146 1
a146 4
      if (engagementExecuted)
		  actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
	  else
		  actStartPeriod = 0;
@


1.17
log
@-added methods:
   getResourceBenchQuantity
   getResourceReleaseQuantity
-renamed getResourceConsumptionQuantity to getResourceWorkingQuantity
-Global wit attribute execEmptyBom is now being set to true
@
text
@d19 1
a19 4
#include "engagementFile.h"
#include "resourceFile.h"
#include "bomFile.h"
#include "resourceActionFile.h"
d77 1
a77 197
  int nPeriods=16;
  rcpProb.setNPeriods(nPeriods);  
  rcpProb.setOslMesgFileName(outputDirectory+"/oslMesgFile.txt");
  
  //---------------------------------------------------------
  // Read engagement file
  //---------------------------------------------------------
  {
    // Read engagement File and set up structures for using data
    std::string engagementFileName = inputDirectory + "/engagement.csv";
    RCPengagementFile engagementFile(engagementFileName);
    RCPengagementFileIterator engagementFileIter(engagementFile);
    
    // loop once for each record in engagement file
    for ( ; engagementFileIter()!=NULL; ) {
      std::string engagementName = engagementFileIter.engagementName();
      float revenue = engagementFileIter.revenueAsFloat();
      int startPeriod =  engagementFileIter.startPeriodAsInt();
      int duration =  engagementFileIter.durationAsInt();

      // test to ensure startPeriod is within the planning horizon
      if ( startPeriod >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: startPeriod is beyond planning horizion"                <<std::endl
          <<"   engagement filename: " <<engagementFile.filename().c_str()    <<std::endl
          <<"   engagement file line number: " <<engagementFileIter.recNum()  <<std::endl
          <<"   engagementName: " <<engagementName.c_str()                    <<std::endl
          <<"   startPeriod: " <<startPeriod                                  <<std::endl
          <<"   allowed range: 0<=startPeriod<" <<nPeriods                    <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }


      rcpProb.addEngagement(engagementName);
      rcpProb.setEngagementRevenue(engagementName,revenue);
      rcpProb.setEngagementStartPeriod(engagementName,startPeriod);
      rcpProb.setEngagementDuration(engagementName,duration);
    }
  }
  
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = inputDirectory + "/resource.csv";
    RCPresourceFile resourceFile(resourceFileName);
    RCPresourceFileIterator resourceFileIter(resourceFile);
    
    // loop once for each record in resource file
    for ( ; resourceFileIter()!=NULL; ) {
      std::string resourceName = resourceFileIter.resourceName();
      int period = resourceFileIter.periodAsInt();
      float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

      if ( !rcpProb.resourceExists(resourceName) )
         rcpProb.addResource(resourceName);

      rcpProb.setResourceSupplyQuantity(resourceName,period,supplyQuantity);
    }
  }

  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = inputDirectory + "/resourceaction.csv";
    RCPresourceActionFile resourceActionFile(resourceFileName);
    RCPresourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      std::string resourceName = resourceActionFileIter.resourceName();
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat();
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();
      float fixedCost =  resourceActionFileIter.fixedCostAsFloat();

      // test to ensure that resource exists
      if ( !rcpProb.resourceExists(resourceName) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"                  <<std::endl
          <<"Warning: Resource does not exist"                                         <<std::endl
          <<"   resource action filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   resource action file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"   resource: " <<resourceName.c_str()                                     <<std::endl
          <<"   record will be ignored. "                                              <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
        continue;
      }

      rcpProb.setResourceAcquireTime(resourceName, acquireTime);
      rcpProb.setResourceAcquireCost(resourceName, acquireCost);
      rcpProb.setResourceReleaseTime(resourceName, releaseTime);
      rcpProb.setResourceReleaseCost(resourceName, releaseCost);
      rcpProb.setResourceFixedCost(resourceName, fixedCost);

    }
  }

    
  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string bomFileName = inputDirectory + "/bom.csv";
    RCPbomFile bomFile(bomFileName);
    RCPbomFileIterator bomFileIter(bomFile);
    
    // loop once for each record in bom file
    for ( ; bomFileIter()!=NULL; ) {
      std::string resourceName = bomFileIter.resourceName();
      std::string engagementName = bomFileIter.engagementName();
      int period = bomFileIter.periodAsInt();
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();

      // test to ensure that engagement exist
      if ( !rcpProb.engagementExists(engagementName) ) {
        // Engagement does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Engagement does not exist"                             <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // test to ensure that resource exist
      if ( !rcpProb.resourceExists(resourceName) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Resource does not exist"                               <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

      if ( !rcpProb.bomExists(engagementName,resourceName) )
         rcpProb.addBom(engagementName,resourceName);

      rcpProb.setBomUsageQuantity(engagementName,resourceName,period,usageQuantity);
    }
  }
  
  //---------------------------------------------------------
@


1.16
log
@modified examples slightly again
@
text
@d290 4
a293 1
    std::string heading="\"resourceName\",\"period\",\"supplyQuantity\",\"consumptionQuantity\",\"acquireQuantity\""; 
d305 2
a306 1
      std::vector<float> consQty = rcpProb.getResourceConsumptionQuantity(resourceNames[r]);
d308 1
d312 3
a314 2
          "\"%s\",%d,%f,%f,%f\n",
          resourceNames[r].c_str(),t,supQty[t],consQty[t],acquireQty[t]);
@


1.15
log
@added new examples (very simple) in example3. Also changed various routines
related to "getEngagementStart" to "getRequestedEngagementStart" so that
we could have a routine to supply the actual start time.
@
text
@d323 1
a323 1
    std::string heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPerod\""; 
@


1.14
log
@added resourceActionO file
@
text
@d290 1
a290 1
    std::string heading="\"resourceName\",\"period\",\"supplyQuantity\",\"consumptionQuantity\""; 
d303 1
d307 2
a308 2
          "\"%s\",%d,%f,%f\n",
          resourceNames[r].c_str(),t,supQty[t],consQty[t]);
d323 1
a323 1
    std::string heading="\"engagementName\",\"engagementExecuted\",\"startPeriod\""; 
a332 1
	int startPeriod;
d334 2
d338 5
a342 2
      startPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);

d344 2
a345 2
          "\"%s\",%d,%d\n",
          engagementNames[e].c_str(),engagementExecuted, startPeriod);
d353 1
a353 29
  // Write resourceAction plan
  {
    // Open file
    std::string resourceActionPlanFileName = outputDirectory+"/resourceActionO.csv";
    FILE * resourceActionPlanFilePtr = fopen(resourceActionPlanFileName.c_str(),"w");

    // Write header record
    std::string heading="\"resourceName\",\"acquirePeriod\",\"acquireQuantity\""; 
    fprintf(resourceActionPlanFilePtr,"%s\n",heading.c_str());

       
    // Get list of all resources
    std::vector<std::string> resourceNames;
    rcpProb.getResourceNames(resourceNames);

    // loop once for each resource
    int r;
	int startPeriod;
    for ( r=0; r<resourceNames.size(); ++r ) {
	  std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceNames[r]);
      for ( int t=0; t<acquireQty.size(); t++ ) {
        fprintf(resourceActionPlanFilePtr,
          "\"%s\",%d,%f\n",
          resourceNames[r].c_str(),t,acquireQty[t]);
      } // finished t loop
    } // end of r loop

    fclose(resourceActionPlanFilePtr);
  } // end of write engagement plan block  
@


1.13
log
@changed int to bool
@
text
@d345 32
a376 1
  } // end of write resource plan block  
@


1.12
log
@added output for engagment information
@
text
@d333 1
a333 1
	int engagementExecuted;
@


1.11
log
@Added code to test that period read from csv files is within planning horizon
@
text
@d315 31
a345 1
  
@


1.10
log
@Added methods to get/set resource Action costs and times and then added the calls in rcp.cpp to set action costs.  Also added witWriteData to rcpProblem.cpp to help debug the model.
@
text
@a17 1

d100 17
d138 16
d251 17
a267 1
      // test to ensure that resource and engagement exist
@


1.9
log
@Created resourceActionFile.h and all the unitTest stuff for it.
@
text
@d81 1
a81 1
  int nPeriods=6;
d127 41
@


1.8
log
@added code to write an output file
@
text
@d23 1
a23 1

@


1.7
log
@added code methods to addBom and set/get attributes.
added code to read bom file and addBoms and attributes.
@
text
@d193 32
@


1.6
log
@modifed to set resource supplyQuanity
@
text
@d22 1
a22 2


d127 57
@


1.5
log
@Modified to use witPartAppData for setting/getting rcp engagement revenue, startPeriod, and duration
@
text
@d121 2
a122 2
      float period = resourceFileIter.periodAsInt();
      int supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
d126 2
@


1.4
log
@fixed problem where resources of the same name were being created
@
text
@d103 3
a105 1
      rcpProb.setEngagementParms(engagementName,revenue,startPeriod,duration);
@


1.3
log
@Added code to read resource file and add resources
@
text
@d116 1
a116 1
    // loop once for each record in engagement file
d122 2
a123 1
      rcpProb.addResource(resourceName);
@


1.2
log
@modified setEngagementRevenue to have 2 additional parms (startPeriod and duration).
@
text
@d21 1
d90 1
a90 1
    // Read mtm interplant File and set up structures for using data
d108 17
d126 1
@


1.1
log
@Initial revision
@
text
@d71 1
a71 1
        <<"    " <<argv[0] <<" ../example1"                          <<std::endl
d102 1
a102 1
      rcpProb.setEngagementRevenue(engagementName,revenue);
@


1.1.1.1
log
@initial import
@
text
@@

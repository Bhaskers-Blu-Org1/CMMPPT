head	1.56;
access;
symbols;
locks; strict;
comment	@// @;


1.56
date	2006.02.06.17.58.45;	author gresh;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.31.16.26.47;	author gresh;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.31.15.45.39;	author gresh;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.30.15.46.57;	author gresh;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.23.12.42.43;	author gresh;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.22.17.09.03;	author gresh;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.21.17.45.57;	author gresh;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.08.14.57.48;	author gresh;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.19.19.15.24;	author gresh;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.18.13.58.25;	author gresh;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.05.14.52.38;	author gresh;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.18.16.25.42;	author gresh;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.11.18.16.42;	author gresh;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.10.14.31.39;	author gresh;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.03.15.32.00;	author dpc;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.28.14.11.17;	author dpc;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.28.14.02.36;	author dpc;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.26.15.51.01;	author gresh;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.23.18.56.59;	author dpc;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.23.18.39.09;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.23.12.37.21;	author dpc;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.21.17.42.03;	author gresh;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.07.18.42.30;	author dpc;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.17.17.02.03;	author gresh;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.17.16.49.26;	author gresh;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.17.15.41.29;	author gresh;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.14.19.09.16;	author gresh;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.14.17.41.38;	author gresh;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.14.13.34.19;	author dpc;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.12.14.04.26;	author dpc;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.17.56.51;	author gresh;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.23.18.13.39;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.15.14.59.18;	author gresh;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.15.13.29.14;	author gresh;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.14.17.05.53;	author gresh;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.14.14.52.40;	author gresh;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.13.17.11.39;	author gresh;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.09.23.43.43;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.05.12.40.43;	author dpc;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.02.20.27.21;	author dpc;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.24.19.20.33;	author gresh;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.24.17.41.51;	author gresh;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.22.15.51.17;	author gresh;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.22.13.40.16;	author gresh;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.18.22.13.00;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.18.18.23.39;	author gresh;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.18.14.18.39;	author gresh;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.17.22.34.40;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.17.18.21.24;	author dpc;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.17.17.44.08;	author gresh;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.17.14.33.18;	author dpc;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.17.03.08.16;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.16.20.48.21;	author dpc;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.16.17.23.33;	author gresh;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.10.20.50.20;	author dpc;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.10.19.13.31;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.56
log
@look for "panic"
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#pragma warning(disable:4290)
#endif


#include "wit.h"

#include <map>
#include <vector>

#include <assert.h>
#include <iostream>
#include <float.h>
#include <math.h>


#include "rcpProblem.h"
#include "rcpOptCal.h"
#include "populateRCP.h"
#include "globalAttrFile.h"
#include "rcpOpt.h"
#include "rcpOptException.h"
#include "rcpOptIntException.h"

bool witOK = true;

#if 0
int RCP_DECLSPEC rcpOpt(char const *  directoryName)
{
  int retVal = 0;
  if (!witOK){
    RcpOptException rcpEx("RCP Optimizer is not available due to previous error.  Contact developers");
    throw rcpEx;
  }
  try {
    rcpOptExp(directoryName);
  }
  catch ( RcpOptException e ) {
    std::cerr <<e.what() <<std::endl;
    retVal = 1;
  }
  return retVal;
}
#endif
void writeNascoImplosion(std::string outputDirectory, RCPproblem & rcpProb, RcpOptCalendar rcpCal) 
{
  // Write engagement plan
    // Open file
    std::string engagementPlanFileName = outputDirectory+"/engagementTiming.csv";
    FILE * engagementPlanFilePtr = fopen(engagementPlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"engagementName\",\"engagementExecuted\",\"InfeasibleExecution\",\"reqStartPeriod\",\"actStartPeriod\",\"quantity\""; 
    fprintf(engagementPlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    
    rcpProb.getEngagementNames(engagementNames);
    
    // loop once for each engagement
    unsigned int e;
    bool engagementExecuted, infeasibleExecution;
    int reqStartPeriod;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::vector<float> quantity = rcpProb.getEngagementExecutionQuantity(engagementNames[e]);
      engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      infeasibleExecution = rcpProb.getInfeasibleExecution(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
      int thePeriod;
      int np = rcpProb.getNPeriods();
      //      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      if (engagementExecuted) {
        for(thePeriod=0; thePeriod<np; thePeriod ++)
                if (quantity[thePeriod] > 0)
                fprintf(engagementPlanFilePtr,
                        "\"%s\",%d, %d, %d, %d, %f\n",
                        engagementNames[e].c_str(),engagementExecuted, infeasibleExecution, reqStartPeriod, thePeriod, 
                        quantity[thePeriod]);
      }
      else {
            fprintf(engagementPlanFilePtr,
                    "\"%s\",%d,%d,%d, %d, %f\n",
                    engagementNames[e].c_str(),engagementExecuted, infeasibleExecution, reqStartPeriod, -1, 
                    0);
      
      }
    } // end of e loop
    
    fclose(engagementPlanFilePtr);
    // end of write engagement plan
    
}
void writeNascoGapGlut(std::string outputDirectory, RCPproblem & rcpProb, RcpOptCalendar  rcpCal) 
  {
    // Open file
    std::string mrpPlanFileName = outputDirectory+"/gapGlut.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
        
        
    //get the table of values
    std::vector<RCPvectorString> names;
    std::vector<std::vector<std::vector<std::string> > > skillGroupNames;
    
    //get the vector of resource ID names
    rcpProb.getResourceNames(names);
    rcpProb.getSkillGroupNames(skillGroupNames);

    for (int i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
      std::string heading;
      heading = heading+"\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
      fprintf(mrpPlanFilePtr,"%s",heading.c_str());
    }
    
    
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
        fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    else
        fprintf(mrpPlanFilePtr,"\"month\",\"year\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    unsigned int r;
    for ( r=0; r<names.size(); ++r ) {
      const RCPvectorString & resourceIdValues = names[r];
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(resourceIdValues);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceIdValues);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(resourceIdValues);
      int m, y;
      for (unsigned int t=0; t<grossQty.size(); t++ ) {
        for (unsigned int i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
           
           fprintf(mrpPlanFilePtr,"\"%s\",", names[r].at(i).c_str());
        }
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            fprintf(mrpPlanFilePtr,
             "%d,%f,%f,%f,%f\n",
             t, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
        else {
            y = rcpCal.computeYearFromPeriod(t);
            m = rcpCal.computeMonthFromPeriod(t);
            fprintf(mrpPlanFilePtr,
             "%d,%d, %f,%f,%f,%f\n",
             m, y, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);

        }

      } // finished t loop
      
    } // end of r loop
    fclose(mrpPlanFilePtr);
    mrpPlanFileName = outputDirectory+"/multipleSkillsGlut.csv";
    mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
        fprintf(mrpPlanFilePtr,"\"skills\",\"period\",\"glut\"\n");
    else
        fprintf(mrpPlanFilePtr,"\"skills\",\"month\",\"year\",\"glut\"\n");


     for ( r=0; r<skillGroupNames.size(); ++r ) {
      const std::vector<std::vector<std::string> >  skillGroup = skillGroupNames[r];
      std::vector<float> glutQty = rcpProb.getSkillGroupGlutQuantity(skillGroup);
      int m, y;
      std::string skillGroupName = rcpProb.createSkillGroupName(skillGroup);
      for (unsigned int t=0; t<glutQty.size(); t++ ) {
        fprintf(mrpPlanFilePtr,"%s,",skillGroupName.c_str());
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            fprintf(mrpPlanFilePtr,
             "%d,%f\n",
             t, 
             glutQty[t]);
        else {
            y = rcpCal.computeYearFromPeriod(t);
            m = rcpCal.computeMonthFromPeriod(t);
            fprintf(mrpPlanFilePtr,
             "%d,%d, %f\n",
             m, y, 
             glutQty[t]);

        }

      } // finished t loop
      
    } // end of r loop
       
    fclose(mrpPlanFilePtr);
  } // end of write mrp plan block


int RCP_DECLSPEC rcpOpt(char const *  directoryName)
{
  if (!witOK){
    RcpOptException rcpEx("RCP Optimizer is not available due to previous error.  Contact developers");
    throw rcpEx;
  }
    
  try {
  std::cout <<"rcp2 Build date: " <<__DATE__ <<std::endl;
  
  std::string outputDirectory=directoryName;
  std::string inputDirectory=directoryName;
  
  RCPproblem rcpProb;
  RcpOptCalendar rcpCal;
  populate(rcpProb, inputDirectory, outputDirectory, rcpCal);
  


   //check the timing
  rcpProb.getTimer().printElapsedTime("done with populate");

  // Get the name of the problem to be solved and the algorithm method
  std::string globalAttrFileName = inputDirectory + "/globalAttr.csv";
  RCPglobalAttrFile globalAttrFile(globalAttrFileName);
  std::string format = globalAttrFile.fieldAsString("fileFormat","attrValue");
  std::string prob = globalAttrFile.fieldAsString("problem","attrValue");
  std::string alg = globalAttrFile.fieldAsString("algorithm","attrValue");
  
  if (format=="NASCO") {
     rcpProb.priorityNASCO();
     writeNascoGapGlut(outputDirectory,rcpProb,rcpCal);
     writeNascoImplosion(outputDirectory,rcpProb,rcpCal);
  }
  else {  
  int i;

  // Check the name of the problem
  if ( prob!="resourceAction" && prob!="gapGlut" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown problem specified."                          <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   problem specified: " <<prob                                <<std::endl
      <<"   allowed values: resourceAction gapGlut"                    <<std::endl
      <<"   resourceAction performed "                                 <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    prob="resourceAction";
  }


  // Check the name of the algorithm to be used

  if ( alg!="optimalPlan" && alg!="priorityPlan" ) {
    // Write warning message
    std::cout 
      <<"-------------------------------------------------------"      <<std::endl
      <<"Warning: unknown algorithm specified."                        <<std::endl
      <<"   globalAttr filename: " <<globalAttrFile.filename()         <<std::endl
      <<"   algorithm specified: " <<alg                               <<std::endl
      <<"   allowed values: optimalPlan priorityPlan"                  <<std::endl
      <<"   resourceAction will be performed "                         <<std::endl
      <<"-------------------------------------------------------"      <<std::endl;
    alg="optimalPlan";
  }

  rcpProb.setAlgorithmName(alg);
  rcpProb.setProblemName(prob);
  rcpProb.setFormatName(format);

  // Solve the problem

  rcpProb.getTimer().printElapsedTime("done with setup");

  if ( prob=="gapGlut" ) 
    rcpProb.gapGlut();
  else   // assume the problem is resourceAction;  change this if more problems are defined
    rcpProb.resourceAction(); 
    
   //check the timing
   rcpProb.getTimer().printElapsedTime("after gapGlut");
   
// Write Results
 
  if (format=="04Feb"){ 
    if ( prob=="resourceAction" ) {
      // Write resource plan
      // Open file
    std::string resourcePlanFileName = outputDirectory+"/resourceO.csv";
    FILE * resourcePlanFilePtr = fopen(resourcePlanFileName.c_str(),"w");
    
    // Write header record
     int numAttributes = rcpProb.getResourceIdentifierNames().size();
    for (i=0; i<numAttributes; i++) {
      fprintf(resourcePlanFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
       fprintf(resourcePlanFilePtr,"\"period\",\"supply\",\"bench\",\"working\",\"gap\",\"glut\"\n",rcpProb.getResourceIdentifierNames()[numAttributes-1].c_str());
    else
       fprintf(resourcePlanFilePtr,"\"month\",\"year\",\"supply\",\"bench\",\"working\",\"acquire\",\"release\"\n",rcpProb.getResourceIdentifierNames()[numAttributes-1].c_str());
    
    // Get list of all resources
    std::vector<RCPvectorString> names;
    rcpProb.getResourceNames(names);

  
    // loop once for each resource
    unsigned int r;
    for ( r=0; r<names.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(names[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(names[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(names[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(names[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(names[r]);
      int m, y;      

      for (unsigned int t=0; t<supQty.size(); t++ ) {
        for (int j=0; j<numAttributes; j++) {
           fprintf(resourcePlanFilePtr,"\"%s\",",names[r].at(j).c_str());
        }
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
           fprintf(resourcePlanFilePtr,
             "%d,%f,%f,%f,%f,%f,\n",
             t,
              supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
        else {
           m = rcpCal.computeMonthFromPeriod(t);
           y = rcpCal.computeYearFromPeriod(t);
           fprintf(resourcePlanFilePtr,
             "%d,%d, %f,%f,%f,%f,%f,\n",
             m, y,
             supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
        }       

      } // finished t loop
      
    } // end of r loop
    
    fclose(resourcePlanFilePtr);
  // end of write resource plan

  // Write engagment plan
    // Open file
    std::string engagementPlanFileName = outputDirectory+"/engagementO.csv";
    FILE * engagementPlanFilePtr = fopen(engagementPlanFileName.c_str(),"w");
    
    // Write header record
    std::string heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\",\"quantity\""; 
    fprintf(engagementPlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    
    rcpProb.getEngagementNames(engagementNames);
    
    // loop once for each engagement
    unsigned int e;
    bool engagementExecuted;
    int reqStartPeriod;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::vector<float> quantity = rcpProb.getEngagementExecutionQuantity(engagementNames[e]);
      engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
      int thePeriod;
      int np = rcpProb.getNPeriods();
      //      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      if (engagementExecuted) {
        for(thePeriod=0; thePeriod<np; thePeriod ++)
                if (quantity[thePeriod] > 0)
                fprintf(engagementPlanFilePtr,
                        "\"%s\",%d,%d, %d, %f\n",
                        engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, thePeriod, 
                        quantity[thePeriod]);
      }
      else {
            fprintf(engagementPlanFilePtr,
                    "\"%s\",%d,%d, %d, %f\n",
                    engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, -1, 
                    0);
      
      }
    } // end of e loop
    
    fclose(engagementPlanFilePtr);
    // end of write engagement plan
    // end of resourceAction case
    }
  
  
  if ( prob=="gapGlut" )
  {

    // Open file
    std::string mrpPlanFileName = outputDirectory+"/gapGlut.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
        
        
    //get the table of values
    std::vector<RCPvectorString> names;
    
    //get the vector of resource ID names
    rcpProb.getResourceNames(names);

    for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
      std::string heading;
      heading = heading+"\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
      fprintf(mrpPlanFilePtr,"%s",heading.c_str());
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
        fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    else
        fprintf(mrpPlanFilePtr,"\"month\",\"year\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    unsigned int r;
    for ( r=0; r<names.size(); ++r ) {
      const RCPvectorString & resourceIdValues = names[r];
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(resourceIdValues);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceIdValues);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(resourceIdValues);
      int m, y;
      for (unsigned int t=0; t<grossQty.size(); t++ ) {
        for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
           
           fprintf(mrpPlanFilePtr,"\"%s\",", names[r].at(i).c_str());
        }
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            fprintf(mrpPlanFilePtr,
             "%d,%f,%f,%f,%f\n",
             t, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
        else {
            y = rcpCal.computeYearFromPeriod(t);
            m = rcpCal.computeMonthFromPeriod(t);
            fprintf(mrpPlanFilePtr,
             "%d,%d, %f,%f,%f,%f\n",
             m, y, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);

        }

      } // finished t loop
      
    } // end of r loop
    
    fclose(mrpPlanFilePtr);
  
  } // end of write mrp plan block
  
  }
  else if (format=="DemandEngagement" ) {
    // Open file
    std::string mrpPlanFileName = outputDirectory+"/gapGlut.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
        
    //get the table of values
    std::vector<RCPvectorString> names; 
    //get the vector of resource ID names
    rcpProb.getResourceNames(names);

    for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
      std::string heading;
      heading = heading+"\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
      fprintf(mrpPlanFilePtr,"%s",heading.c_str());
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
        fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    else
        fprintf(mrpPlanFilePtr,"\"month\",\"year\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    unsigned int r;
    for ( r=0; r<names.size(); ++r ) {
      const RCPvectorString & resourceIdValues = names[r];
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(resourceIdValues);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceIdValues);
 

      float * exogSup = rcpProb.getSimpleResourceSupplyQuantity(resourceIdValues);
      int m, y;
      for (unsigned int t=0; t<grossQty.size(); t++ ) {
        for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
           
           fprintf(mrpPlanFilePtr,"\"%s\",", names[r].at(i).c_str());
        }
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            fprintf(mrpPlanFilePtr,
             "%d,%f,%f,%f,%f\n",
             t, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
        else {
            y = rcpCal.computeYearFromPeriod(t);
            m = rcpCal.computeMonthFromPeriod(t);
            fprintf(mrpPlanFilePtr,
             "%d,%d, %f,%f,%f,%f\n",
             m, y, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
        }
      } // finished t loop
      delete [] exogSup;

    } // end of r loop
    fclose(mrpPlanFilePtr);  
  }
  else if (format=="03Dec") { //original format 
  // Write resource plan
  if ( prob=="resourceAction" ) {
    // Open file
    std::string resourcePlanFileName = outputDirectory+"/resourceO.csv";
    FILE * resourcePlanFilePtr = fopen(resourcePlanFileName.c_str(),"w");
    
    //get the table of values
    std::vector<RCPvectorString> names;
    
    //get the vector of resource ID names
    rcpProb.getResourceNames(names);

    // Print heading
    std::string heading;
    for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
      heading = heading + "\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
      heading= heading + "\"period\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\","
      "\"releaseQuantity\""; 
    else
       heading= heading + "\"month\",\"year\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\","
      "\"releaseQuantity\""; 
   
    
      fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
    
    //get resource names
    std::vector<RCPvectorString> resNames;
    rcpProb.getResourceNames(resNames);

    // loop once for each resource
    unsigned int r;
    for ( r=0; r<resNames.size(); ++r ) {
      const RCPvectorString & resourceIdValues = names[r];
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(resourceIdValues);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(resourceIdValues);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceIdValues);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(resourceIdValues);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(resourceIdValues);
      
      unsigned int t;
      int m, y;
      for ( t=0; t< supQty.size(); ++t ) {
        // Write resource id values
        for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
          fprintf(resourcePlanFilePtr,"\"%s\",", names[r][i].c_str());
        }
        
        // write resource attribute values
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
          fprintf(resourcePlanFilePtr,
          "%d,%f,%f,%f,%f,%f\n",
          t,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
        else {
          y = rcpCal.computeYearFromPeriod(t);
          m = rcpCal.computeMonthFromPeriod(t);
          fprintf(resourcePlanFilePtr,
          "%d,%d, %f,%f,%f,%f,%f\n",
          m, y,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
        }

      } // end of t loop
    }  // end of r loop

    
    fclose(resourcePlanFilePtr);
 


  // Write engagment plan
  
    // Open file
    std::string engagementPlanFileName = outputDirectory+"/engagementO.csv";
    FILE * engagementPlanFilePtr = fopen(engagementPlanFileName.c_str(),"w");
    
    // Write header record
    heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\",\"quantity\""; 
    fprintf(engagementPlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    
    rcpProb.getEngagementNames(engagementNames);
    
    // loop once for each engagement
    unsigned int e;
    bool engagementExecuted;
    int reqStartPeriod;
    int thePeriod;
    int np = rcpProb.getNPeriods();

    //DLG this will need to be fixed up to handle month/year
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::vector<float> quantity = rcpProb.getEngagementExecutionQuantity(engagementNames[e]);
      engagementExecuted = rcpProb.getEngagementExecuted(engagementNames[e]);
      reqStartPeriod = rcpProb.getEngagementRequestedStartPeriod(engagementNames[e]);
      //      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      if (engagementExecuted) {
        for(thePeriod=0; thePeriod<np; thePeriod++)
            if (quantity[thePeriod]>0)
            fprintf(engagementPlanFilePtr,
                    "\"%s\",%d,%d, %d, %f\n",
                    engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, thePeriod,
                    quantity[thePeriod]);
      }
      else {
            fprintf(engagementPlanFilePtr,
                    "\"%s\",%d,%d, %d, %f\n",
                    engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, -1, 
                    0);
      }
    } // end of e loop
    
    fclose(engagementPlanFilePtr);
  } // end of write engagement plan block  
  
  
  if ( prob=="gapGlut" ) {
   
    // Open file
    std::string mrpPlanFileName = outputDirectory+"/gapGlut.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
    
    // Get list of all resources
    std::vector<RCPvectorString> names;
    rcpProb.getResourceNames(names);
    int numResourceAttributes = (rcpProb.getResourceIdentifierNames()).size();

    for (i=0; i<numResourceAttributes; i++) {
      fprintf(mrpPlanFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
      fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    else
      fprintf(mrpPlanFilePtr,"\"month\",\"year\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    unsigned int r;

    for ( r=0; r<names.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(names[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(names[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(names[r]);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(names[r]);
      int m,y;
      for (unsigned int t=0; t<grossQty.size(); t++ ) {
         for (int j=0; j<numResourceAttributes; j++) {
           fprintf(mrpPlanFilePtr,"\"%s\",",names[r].at(j).c_str());
         }
         if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
             fprintf(mrpPlanFilePtr,
             "%d,%f,%f,%f,%f\n",
             t, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
         else {
             y = rcpCal.computeYearFromPeriod(t);
             m = rcpCal.computeMonthFromPeriod(t);
             fprintf(mrpPlanFilePtr,
             "%d,%d,%f,%f,%f,%f\n",
             m,y, 
             exogSup[t],grossQty[t],gapQty[t],glutQty[t]);

         }

      } // finished t loop
      
    } // end of r loop
    
    fclose(mrpPlanFilePtr);

    // Open file for pegging reports
    std::string pegFromSupplyFileName = outputDirectory+"/pegFromSupply.csv";
    std::string pegFromAcquisitionFileName = outputDirectory+"/pegFromGap.csv";
    std::string pegFromSubstitutionFileName = outputDirectory+"/pegFromSubstitution.csv";

    FILE * pegFromSupplyFilePtr = fopen(pegFromSupplyFileName.c_str(),"w");
    FILE * pegFromAcquisitionFilePtr = fopen(pegFromAcquisitionFileName.c_str(),"w");
    FILE * pegFromSubstitutionFilePtr = fopen(pegFromSubstitutionFileName.c_str(),"w");

    fprintf(pegFromSupplyFilePtr,"\"engagement\",");
    fprintf(pegFromAcquisitionFilePtr,"\"engagement\",");
    fprintf(pegFromSubstitutionFilePtr,"\"engagement\",");
    

    for (i=0; i<numResourceAttributes; i++) {
      fprintf(pegFromSupplyFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
      fprintf(pegFromAcquisitionFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());   
      fprintf(pegFromSubstitutionFilePtr,"\"REQ%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
    }

    for (i=0; i<numResourceAttributes; i++)
      fprintf(pegFromSubstitutionFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
  
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD){
      fprintf(pegFromSupplyFilePtr,"\"period\",\"supplyQty\"\n");
      fprintf(pegFromAcquisitionFilePtr,"\"period\",\"gapQty\"\n");
      fprintf(pegFromSubstitutionFilePtr,"\"period\",\"substitutionQty\"\n");
    }
    else {
      fprintf(pegFromSupplyFilePtr,"\"month\",\"year\",\"supplyQty\"\n");
      fprintf(pegFromAcquisitionFilePtr,"\"month\",\"year\",\"gapQty\"\n");
      fprintf(pegFromSubstitutionFilePtr,"\"month\",\"year\",\"substitutionQty\"\n");
    }
    
    // Get list of all engagements
    std::vector<std::string> engagementNames;
    rcpProb.getEngagementNames(engagementNames);
    
    int np = rcpProb.getNPeriods();
        
    // loop once for each engagement
    unsigned int e;
    for (e=0; e<engagementNames.size(); ++e) {
      int t;
      for (t=0; t<np; t++){
        std::vector<RCPvectorString> resources;
        std::vector<RCPvectorString> subResources;
        std::vector<float> quantitiesSup;
        std::vector<float> quantitiesAcq;
        std::vector<float> quantitiesSub;

        unsigned int r;

        rcpProb.getEngagementPeggedQuantitiesFromSupply(engagementNames[e], 
                                                        t,
                                                        resources,
                                                        quantitiesSup);
        for (r=0; r<resources.size(); r++){
          if(quantitiesSup[r] > 0){
            fprintf(pegFromSupplyFilePtr,"\"%s\",",engagementNames[e].c_str());
            int j;
            for (j=0; j<numResourceAttributes; j++) 
              fprintf(pegFromSupplyFilePtr,"\"%s\",",resources[r].at(j).c_str());
            if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
              fprintf(pegFromSupplyFilePtr,"%d,%f\n",t,quantitiesSup[r]);
            else {
              int y,m;
              y = rcpCal.computeYearFromPeriod(t);
              m = rcpCal.computeMonthFromPeriod(t);
              fprintf(pegFromSupplyFilePtr,"%d,%d,%f\n",m,y,quantitiesSup[r]);
            }
          }
        }

        rcpProb.getEngagementPeggedQuantitiesFromAcquisition(engagementNames[e], 
                                                        t,
                                                        resources,
                                                        quantitiesAcq);
        for (r=0; r<resources.size(); r++){
          if(quantitiesAcq[r] > 0){
            fprintf(pegFromAcquisitionFilePtr,"\"%s\",",engagementNames[e].c_str());
            int j;
            for (j=0; j<numResourceAttributes; j++) 
              fprintf(pegFromAcquisitionFilePtr,"\"%s\",",resources[r].at(j).c_str());
            if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
              fprintf(pegFromAcquisitionFilePtr,"%d,%f\n",t,quantitiesAcq[r]);
            else {
              int y,m;
              y = rcpCal.computeYearFromPeriod(t);
              m = rcpCal.computeMonthFromPeriod(t);
              fprintf(pegFromAcquisitionFilePtr,"%d,%d,%f\n",m,y,quantitiesAcq[r]);
            }
          }
        }



        rcpProb.getEngagementPeggedQuantitiesFromSubstitution(engagementNames[e], 
                                                              t,
                                                              resources,
                                                              quantitiesSub,
                                                              subResources);
        for (r=0; r<resources.size(); r++){
          if(quantitiesSub[r] > 0){
            fprintf(pegFromSubstitutionFilePtr,"\"%s\",",engagementNames[e].c_str());
            int j;
            for (j=0; j<numResourceAttributes; j++) 
              fprintf(pegFromSubstitutionFilePtr,"\"%s\",",resources[r].at(j).c_str());
            for (j=0; j<numResourceAttributes; j++) 
              fprintf(pegFromSubstitutionFilePtr,"\"%s\",",subResources[r].at(j).c_str());
            if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
              fprintf(pegFromSubstitutionFilePtr,"%d,%f\n",t,quantitiesSub[r]);
            else {
              int y,m;
              y = rcpCal.computeYearFromPeriod(t);
              m = rcpCal.computeMonthFromPeriod(t);
              fprintf(pegFromSubstitutionFilePtr,"%d,%d,%f\n",m,y,quantitiesSub[r]);
            }
          }
        }
      }
    }
    fclose(pegFromSupplyFilePtr);
    fclose(pegFromAcquisitionFilePtr);
    fclose(pegFromSubstitutionFilePtr);
  } // end of write gapGlut plan block


 
  
  }   
  else if ((format=="FlexMix")) {
    {
    // Open file

    std::string mrpPlanFileName = outputDirectory+"/gapGlut.csv";
    FILE * mrpPlanFilePtr = fopen(mrpPlanFileName.c_str(),"w");
        
        
    //get the table of values
    std::vector<RCPvectorString> names;
    
    //get the vector of resource ID names
    rcpProb.getResourceNames(names);

    for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
      std::string heading;
      heading = heading+"\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
      fprintf(mrpPlanFilePtr,"%s",heading.c_str());
    }
    if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
        fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    else
        fprintf(mrpPlanFilePtr,"\"month\",\"year\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
    // loop once for each resource
    unsigned int r;
    for ( r=0; r<names.size(); ++r ) {
      const RCPvectorString & resourceIdValues = names[r];
      //std::vector<float> grossQty = rcpProb.getFlexibleResourceMrpQuantity(resourceIdValues); //DLG NEED THIS
      std::vector<float> gapQty = rcpProb.getFlexibleResourceGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getFlexibleResourceGlutQuantity(resourceIdValues);
      float * exogSup = rcpProb.getFlexibleResourceSupplyQuantity(resourceIdValues);
      int m, y;
      
      int skillSetPosition = rcpProb.getSkillSetPosition();
      std::string skillName = names[r].at(skillSetPosition);

      if(skillName.find("s0:")==-1) {
      for (unsigned int t=0; t<gapQty.size(); t++ ) {
        for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
           
           fprintf(mrpPlanFilePtr,"\"%s\",", names[r].at(i).c_str());
        }
        if (rcpCal.getCalendarType()==RcpOptCalendar::PERIOD)
            fprintf(mrpPlanFilePtr,
             "%d,%f,%f,%f,%f\n",
             t, 
             //exogSup[t],grossQty[t],gapQty[t],glutQty[t]); //DLG
             exogSup[t],0.0,gapQty[t],glutQty[t]);
        else {
            y = rcpCal.computeYearFromPeriod(t);
            m = rcpCal.computeMonthFromPeriod(t);
            fprintf(mrpPlanFilePtr,
             "%d,%d, %f,%f,%f,%f\n",
             m, y, 
            // exogSup[t],grossQty[t],gapQty[t],glutQty[t]); //DLG
            exogSup[t],0.0,gapQty[t],glutQty[t]);

        }
        }

      } // finished t loop
      free(exogSup);
      
    } // end of r loop
    
    fclose(mrpPlanFilePtr);
    
  } // end of write mrp plan block
  

  }
  rcpProb.getTimer().printElapsedTime("done writing");
  std::cout << "Total Time: " <<   rcpProb.getTimer().getCurrentTime() << std::endl;

  }
  }
  catch ( SCOexception e ) {
    RcpOptException rcpEx(e.what());
    throw rcpEx;
  }
  catch ( RCPOptIntException e ) {
    RcpOptException rcpEx(e.what());
    throw rcpEx;
  }
  catch ( RcpOptException e) {
    throw e;
  }
  std::cout <<"rcp application is finished." <<std::endl;
  return 0;

}
@


1.55
log
@compiler issue
@
text
@d55 1
a55 1
    std::string heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\",\"quantity\""; 
d66 1
a66 1
    bool engagementExecuted;
d71 1
d80 2
a81 2
                        "\"%s\",%d,%d, %d, %f\n",
                        engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, thePeriod, 
d86 2
a87 2
                    "\"%s\",%d,%d, %d, %f\n",
                    engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, -1, 
@


1.54
log
@new files for handling nasco input
@
text
@d116 2
d132 1
a132 1
        for (i=0; i<(int)rcpProb.getResourceIdentifierNames().size(); i++) {
@


1.53
log
@changes for nasco multiple skills
@
text
@d51 1
a51 1
    std::string engagementPlanFileName = outputDirectory+"/engagementO.csv";
@


1.52
log
@checked in some NASCO specific code
@
text
@d47 143
d207 2
d220 6
d384 1
d439 1
d443 1
a443 1
  else if (format=="DemandEngagement"|| format=="NASCO" ) {
d624 1
a624 1

d687 1
d809 1
d872 1
d881 1
d895 1
@


1.51
log
@fixed the reporting of required supply in the output gapGlut file.
@
text
@d290 1
a290 1
  else if (format=="DemandEngagement") {
d316 2
@


1.50
log
@changes for deal hub example (demandengagement format)
@
text
@d125 1
a125 1
  if ((format=="04Feb")||(format=="DemandEngagement")){ 
d290 52
@


1.49
log
@getting the flex mix stuff working. Seems to be pretty close to correct
@
text
@d125 1
a125 1
  if (format=="04Feb") { 
d598 1
a598 1
  else if (format=="FlexMix") {
@


1.48
log
@many changes to support the "simple" flexmix model. Doesn't work yet.
@
text
@d155 2
a156 2
      
      int m,y;
d165 1
a165 1
             supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
d173 2
a174 1
        }        
d624 1
a624 1
      //std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(resourceIdValues); //DLG NEED THIS
d629 5
d655 1
a655 1
        free(exogSup);
d658 1
@


1.47
log
@attach acquire as a substitute for each demanded resource
@
text
@d125 1
a125 1
  if (format=="04Feb" || format=="FlexMix") {  //DLG check for other format??? FlexMix
d289 1
a289 1
  else { // original format 
d597 63
@


1.46
log
@more additions for flexible mix
@
text
@a115 2


d125 1
a125 1
  if (format=="04Feb") {
@


1.45
log
@write out something in the engagement file even when nothing was executed. Also fixed a few casts.
@
text
@d426 1
a426 1
    int numResourceAttributes = names[0].size();
@


1.44
log
@add "REQ" to the column headers for requested resources in the output file pegFromSubstititon.csv
@
text
@a201 1
    int actStartPeriod;
d209 15
a223 6
      for(thePeriod=0; thePeriod<np; thePeriod ++)
        if (quantity[thePeriod] > 0)
          fprintf(engagementPlanFilePtr,
                  "\"%s\",%d,%d, %d, %f\n",
                  engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, thePeriod, 
                  quantity[thePeriod]);
d245 1
a245 1
    for (i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d264 1
a264 1
        for (i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d306 1
a306 1
    for (i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d341 1
a341 1
        for (i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
a387 1
    int actStartPeriod;
d397 14
a410 6
      for(thePeriod=0; thePeriod<np; thePeriod++)
        if (quantity[thePeriod]>0)
          fprintf(engagementPlanFilePtr,
                  "\"%s\",%d,%d, %d, %f\n",
                  engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, thePeriod,
                  quantity[thePeriod]);
@


1.43
log
@changed many warnings to exceptions.
@
text
@d470 1
a470 1
      fprintf(pegFromSubstitutionFilePtr,"\"%s\",",rcpProb.getResourceIdentifierNames()[i].c_str());
@


1.42
log
@Added quantity to the engagement file.  The BOM or demand file is now more like a description of the offering.  Updated the reporting in engagementO.csv.
@
text
@d593 5
a597 2
  RcpOptException rcpEx(e.what());
  throw rcpEx;
@


1.41
log
@Changed the scope of the looping variable int i.
@
text
@d189 1
a189 1
    std::string heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
d204 1
d207 9
a215 5
      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      fprintf(engagementPlanFilePtr,
        "\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
      
d304 1
a304 1
      "\"workingQuantity\",\"acquireQuantity\""
d309 1
a309 1
      "\"workingQuantity\",\"acquireQuantity\""
d367 1
a367 1
    heading="\"engagementName\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
d381 3
d386 1
d389 7
a395 5
      actStartPeriod = rcpProb.getEngagementStartPeriod(engagementNames[e]);
      fprintf(engagementPlanFilePtr,
        "\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
      
@


1.40
log
@Changed a looping variable scope.
@
text
@d75 1
a75 1
  
d136 1
a136 1
    for (int i=0; i<numAttributes; i++) {
d232 1
a232 1
    for (int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d251 1
a251 1
        for (unsigned int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d293 1
a293 1
    for (unsigned int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d328 1
a328 1
        for (unsigned int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d402 1
a402 1
    for (int i=0; i<numResourceAttributes; i++) {
d456 1
a456 1
    for (int i=0; i<numResourceAttributes; i++) {
d462 1
a462 1
    for (int i=0; i<numResourceAttributes; i++)
@


1.39
log
@minor cleanups
@
text
@d232 1
a232 2
    unsigned int i;
    for ( i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
@


1.38
log
@Changed the name of output file and field from Acquisition to Gap.  Also, reset the obj1ShipReward of the engagements to zero after performing gapGlut.
@
text
@d484 1
a484 1
    int e;
d494 1
a494 1
        int r;
@


1.37
log
@Modifications to compile with MS Visual C++ V6 compiler
@
text
@d446 1
a446 1
    std::string pegFromAcquisitionFileName = outputDirectory+"/pegFromAcquisition.csv";
d457 1
a457 1
    for (i=0; i<numResourceAttributes; i++) {
d463 1
a463 1
    for ( i=0; i<numResourceAttributes; i++)
d468 1
a468 1
      fprintf(pegFromAcquisitionFilePtr,"\"period\",\"acquireQty\"\n");
d473 1
a473 1
      fprintf(pegFromAcquisitionFilePtr,"\"month\",\"year\",\"acquireQty\"\n");
@


1.36
log
@Added pegging reports and methods for getting results out of the engagementAppData.
@
text
@d232 2
a233 2

    for (unsigned int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d457 1
a457 1
    for (int i=0; i<numResourceAttributes; i++) {
d463 1
a463 1
    for (int i=0; i<numResourceAttributes; i++)
@


1.35
log
@remove "duration" from engagement files, along with "engagement location". Also, implement month/year format for engagement start times.
@
text
@d443 126
a568 1
  } // end of write mrp plan block
@


1.34
log
@Implemented the reasource action leadtime notification model and updated some unitTest cases to reflect this change.  In earlier versions, although we read in the leadtime parameter, the optimization model didn't implement the leadtime and set it to zero.
@
text
@d189 1
a189 1
    std::string heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
a206 1
      std::string engLoc = rcpProb.getEngagementLocation(engagementNames[e]);
d208 2
a209 2
        "\"%s\",\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engLoc.c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
d363 1
a363 1
    heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
a381 1
      std::string engLoc = rcpProb.getEngagementLocation(engagementNames[e]);
d383 2
a384 2
        "\"%s\",\"%s\",%d,%d, %d\n",
        engagementNames[e].c_str(),engLoc.c_str(),engagementExecuted, reqStartPeriod, actStartPeriod);
@


1.33
log
@put initialization of timer in rcpProblem constructor.
@
text
@d452 1
@


1.32
log
@removed some extraneous things
@
text
@a62 1
  rcpProb.getTimer().initializeTimer();
@


1.31
log
@fixed timing issues
@
text
@a62 2
  RcpOptTimer rcpTimer;
  rcpProb.setTimer(rcpTimer);
@


1.30
log
@finer resolution in time
@
text
@d63 3
d69 1
a69 1
  rcpProb.getTimer().printElapsedTime("after populate");
d116 1
a116 1
  rcpProb.getTimer().printElapsedTime("about to solve");
d126 1
a126 1
   rcpProb.getTimer().printElapsedTime("after solve");
@


1.29
log
@adding timing capability
@
text
@a447 1
  rcpProb.getTimer().printElapsedTime("done writing");
d451 2
@


1.28
log
@More checks were added to catch potential WIT severe or fatal issues.  You must update WIT for these changes to work.
@
text
@d65 3
d113 3
a115 1
  if ( prob=="gapGlut" )
d121 5
a125 2
  
  // Write Results
d448 2
a449 1
  
@


1.27
log
@Added a wrapper around all WIT calls:  checkWitRC(witReturnCode wrc)
@
text
@d27 1
d33 4
d50 5
@


1.26
log
@nothing significant
@
text
@d25 2
d437 4
@


1.25
log
@Updated api to only have method rcpOpt which throws an exception
@
text
@d99 2
@


1.24
log
@fixed header in writing out files.
In populate, need to reinitialize match vector *each* time a bom record is read
@
text
@d24 1
d26 1
d39 1
d41 1
a41 1
int RCP_DECLSPEC rcpOptExp (char const *  directoryName)
@


1.23
log
@warn if a column name doesn't exist when reading priority.csv
@
text
@a109 2
    //DLG I don't think this header is correct. Where is "period" "supplyQuantity" etc.?
    //these will need to be modified to handle month/year or period choice
d111 1
a111 1
    for (int i=0; i<numAttributes-1; i++) {
d114 4
a117 3
    fprintf(resourcePlanFilePtr,"\"%s\"\n",rcpProb.getResourceIdentifierNames()[numAttributes-1].c_str());
   
    
d133 1
d138 13
a150 4
        fprintf(resourcePlanFilePtr,
          "%d,%f,%f,%f,%f,%f,\n",
          t,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
@


1.22
log
@more calendar handling
@
text
@d191 1
a191 7
    
    //    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
    //"\"supplyQuantity\",\"benchQuantity\","
    //"\"workingQuantity\",\"acquireQuantity\""
    //"\"releaseQuantity\""; 
    
    
d220 1
@


1.21
log
@preparation for handling calendar style period information.
@
text
@d57 1
d110 3
a112 1
    int numAttributes = rcpProb.getResourceIdentifierNames().size();
d198 1
a198 5
    
    
    // this will work for all formats; one will only find the "dummy" fields in 
    // format 04Jan
    
d211 4
a214 2
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");

d223 1
a223 1

a224 1
        //DLG do we want to prune, and not write out lines with supplies and gaps of both = 0?
d228 14
a241 4
        fprintf(mrpPlanFilePtr,
          "%d,%f,%f,%f,%f\n",
          t, 
          exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
d269 2
a270 1
    heading= heading + "\"period\","
d274 8
a281 1
    fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
d298 1
d306 2
a307 1
        fprintf(resourcePlanFilePtr,
d311 9
d349 1
d379 4
a382 1
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\"\n");
d391 1
a391 1
      
d396 14
a409 4
        fprintf(mrpPlanFilePtr,
          "%d,%f,%f,%f,%f\n",
          t, 
          exogSup[t],grossQty[t],gapQty[t],glutQty[t]);
@


1.20
log
@changed "mrpO.csv" to "gapGlut.csv"
@
text
@d20 1
d47 2
a48 1
  populate(rcpProb, inputDirectory, outputDirectory);
d56 1
@


1.19
log
@Added new api rcpOptExp.
This is the same as rcpOpt except this one throws an exception
@
text
@d183 1
a183 1
    std::string mrpPlanFileName = outputDirectory+"/mrpO.csv";
d335 1
a335 1
    std::string mrpPlanFileName = outputDirectory+"/mrpO.csv";
@


1.18
log
@All references to gapGlut04Feb and resourceAction04Feb have been renamed to gapGlut and resourceAction.
@
text
@d24 12
d37 1
a37 1
int RCP_DECLSPEC rcpOpt (char const *  directoryName)
d39 1
a39 1
  
d375 6
a380 1
  }    
@


1.17
log
@Added priorityGapGlut1() which computes gap/gluts according to a priority scheme.  It's not called by anything but you can look for $$$$ in the code and change priorityGapGlut() to priorityGapGlut1() to call it.

Also I cleaned up some stuff in rcpOpt.cpp.
@
text
@d80 1
a80 1
    rcpProb.gapGlut04Feb();
d82 1
a82 1
    rcpProb.resourceAction04Feb(); 
@


1.16
log
@handling multiple aversions using separated spans of values, and multiplying
them together
@
text
@d77 6
a82 15
  if (format=="04Feb") {
       // Is GapGlut Solve to be done?
       if ( prob=="gapGlut" )
         rcpProb.gapGlut04Feb();
       if ( prob=="resourceAction" )
         rcpProb.resourceAction04Feb(); 
  }
  else {
       // Is GapGlut Solve to be done?
       if ( prob=="gapGlut" )
         rcpProb.gapGlut(); 
       if ( prob=="resourceAction" )
         rcpProb.resourceAction();   
  }
  
d87 3
a89 3
  // Write resource plan
  if ( prob=="resourceAction" ) {
    // Open file
d129 1
a129 2
  } // end of write resource plan block

a131 2
  if ( prob=="resourceAction" )
  {
d163 3
a165 1
  } // end of write engagement plan block  
@


1.15
log
@miscell. cleanups
@
text
@d207 1
a207 1
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\",\"workingQty\"\n");
d219 1
a219 5
        //fprintf(mrpPlanFilePtr,
          //"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          //jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          //t, 
          //exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
a222 12
        //fprintf(mrpPlanFilePtr,"\"%s\",",jobRoles[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",skillSets[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",LOBs[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",sources[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",regions[r].c_str());
        ///fprintf(mrpPlanFilePtr,"\"%s\",",countries[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",cities[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",reportingUnits[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",bands[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",globals[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",competencies[r].c_str());
        //fprintf(mrpPlanFilePtr,"\"%s\",",industries[r].c_str());
d301 1
a301 1
   heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
@


1.14
log
@adding a "prioritySubstitution" flag to the global attribute file for
the feb04 format. To be used later.
@
text
@d97 1
a97 2
  if ( prob=="resourceAction" )
  {
d254 1
a254 2
  if ( prob=="resourceAction" )
  {
a304 33
#if 0    
    // Write header record
    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\""
      "\"releaseQuantity\""; 
    fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
    
    
    // Get list of all resources
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);

  
    // loop once for each resource
    int r;
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      
      for ( int t=0; t<supQty.size(); t++ ) {
        fprintf(resourcePlanFilePtr,
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          t,
          supQty[t],benchQty[t],workingQty[t],acquireQty[t],releaseQty[t]);
      } // finished t loop
      
    } // end of r loop
#endif
d307 1
a307 1
  } // end of write resource plan block
d311 1
a311 2
  if ( prob=="resourceAction" )
  {
d317 1
a317 1
    std::string heading="\"engagementName\",\"engLocation\",\"engagementExecuted\",\"reqStartPeriod\",\"actStartPeriod\""; 
d346 1
a346 2
  if ( prob=="gapGlut" )
  {
d385 4
@


1.13
log
@trivial changes from int to unsigned int to make the compiler happier
@
text
@d4 1
@


1.12
log
@removed setResourceIdentifierNames
and added addResourceIdentifierName
@
text
@d117 1
a117 1
    int r;
d125 1
a125 1
      for ( int t=0; t<supQty.size(); t++ ) {
d159 1
a159 1
    int e;
d202 1
a202 1
    for (int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d210 1
a210 1
    int r;
d218 1
a218 1
      for ( int t=0; t<grossQty.size(); t++ ) {
d224 1
a224 1
        for (int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d268 1
a268 1
    for (int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d282 1
a282 1
    int r;
d291 1
a291 1
      int t;
d294 1
a294 1
        for (int i=0; i<rcpProb.getResourceIdentifierNames().size(); i++) {
d362 1
a362 1
    int e;
d398 1
a398 1
    int r;
d406 1
a406 1
      for ( int t=0; t<grossQty.size(); t++ ) {
@


1.11
log
@remove lots of old code calling old-style functions
@
text
@d103 1
a103 1
    int numAttributes = rcpProb.getNumberResourceIdentifiers();
d105 1
a105 1
      fprintf(resourcePlanFilePtr,"\"%s\",",rcpProb.getResourceIdentifierName(i).c_str());
d107 1
a107 1
    fprintf(resourcePlanFilePtr,"\"%s\"\n",rcpProb.getResourceIdentifierName(numAttributes-1).c_str());
d202 1
a202 1
    for (int i=0; i<rcpProb.getNumberResourceIdentifiers(); i++) {
d204 1
a204 1
      heading = heading+"\"" + rcpProb.getResourceIdentifierName(i)+"\""+",";
d224 1
a224 1
        for (int i=0; i<rcpProb.getNumberResourceIdentifiers(); i++) {
d268 2
a269 2
    for (int i=0; i<rcpProb.getNumberResourceIdentifiers(); i++) {
      heading = heading + "\"" + rcpProb.getResourceIdentifierName(i)+"\""+",";
d294 1
a294 1
        for (int i=0; i<rcpProb.getNumberResourceIdentifiers(); i++) {
d394 1
a394 1
      fprintf(mrpPlanFilePtr,"\"%s\",",rcpProb.getResourceIdentifierName(i).c_str());
@


1.10
log
@removing some extraneous formats and fixing some writing of output files
@
text
@d86 1
a86 1
         rcpProb.gapGlut();
@


1.9
log
@Lots of changes to use new way of identifying resources
@
text
@d103 6
a108 11
    std::string heading="\"jobRole\",\"skillSet\","
      "\"LOB\",\"source\","
      "\"region\",\"period\","
      "\"region\",\"country\","
      "\"city\",\"reportingUnit\","
      "\"band\",\"global\","
      "\"competency\",\"industry\","
      "\"supplyQuantity\",\"benchQuantity\","
      "\"workingQuantity\",\"acquireQuantity\""
      "\"releaseQuantity\""; 
    fprintf(resourcePlanFilePtr,"%s\n",heading.c_str());
d112 2
a113 2
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries);
d118 6
a123 6
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> supQty = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d126 3
d130 1
a130 3
          "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f,\n",
          jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),regions[r].c_str(),
          countries[r].c_str(),cities[r].c_str(),reportingUnits[r].c_str(),bands[r].c_str(),globals[r].c_str(),competencies[r].c_str(),industries[r].c_str(),
d383 1
a387 11
    //    std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\","
    //"\"supplyQuantity\",\"benchQuantity\","
    //"\"workingQuantity\",\"acquireQuantity\""
    //"\"releaseQuantity\""; 
    
    
    
    
    // this will work for all formats; one will only find the "dummy" fields in 
    // format 04Jan
    
d389 7
a395 16
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
    // Write header record
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
    //fprintf(mrpPlanFilePtr,"%s\n",heading.c_str());
    if (strcmp(jobRoles[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"jobRole\",");
    if (strcmp(skillSets[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"skillSet\",");
    if (strcmp(LOBs[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"LOB\",");
    if (strcmp(sources[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"source\",");
    if (strcmp(resourceLocs[0].c_str(),"dummy"))
       fprintf(mrpPlanFilePtr,"\"locationName\",");
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
d399 6
a404 5
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getResourceMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> exogSup = rcpProb.getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d407 3
a409 15
        //fprintf(mrpPlanFilePtr,
          //"\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,%f,%f\n",
          //jobRoles[r].c_str(),skillSets[r].c_str(),LOBs[r].c_str(),sources[r].c_str(),resourceLocs[r].c_str(),
          //t, 
          //exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
        if (strcmp(jobRoles[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",jobRoles[r].c_str());
        if (strcmp(skillSets[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",skillSets[r].c_str());
        if (strcmp(LOBs[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",LOBs[r].c_str());
        if (strcmp(sources[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",sources[r].c_str());
        if (strcmp(resourceLocs[r].c_str(),"dummy"))
          fprintf(mrpPlanFilePtr,"\"%s\",",resourceLocs[r].c_str());
d421 1
a421 3
  }  
  
  
@


1.8
log
@Changed [sg]et[Gap,Glut]Quantity to [sg]etResource[Gap,Glut]ResourceQuantity
@
text
@d264 47
d342 1
@


1.7
log
@fixed some errors in writing out the mrpO file
@
text
@d217 3
a219 3
      std::vector<float> grossQty = rcpProb.getMrpQuantity(resourceIdValues);
      std::vector<float> gapQty = rcpProb.getGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getGlutQuantity(resourceIdValues);
d375 3
a377 3
      std::vector<float> grossQty = rcpProb.getMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> gapQty = rcpProb.getGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.6
log
@Changed [sg]et{Attribute}Quantity to [sg]etResource{Attribute}Quantity
Saved the Optimal Resource Action plans to the appData
Fixed a method that was for Acquire;  it had been setting another attribute
@
text
@d205 2
a206 1
    for (int i=0; i<names[0].size(); i++) {
d208 1
a208 1
      heading = heading+"\"" + rcpProb.getResourceIdentifierNames()[i]+"\""+",";
d215 1
a215 1
    for ( r=0; r<names[0].size(); ++r ) {
d228 1
a228 1
        for (int i=0; i<names[0].size(); i++) {
@


1.5
log
@implemented several resource methods to work with resourceAttributeValues as parameter.
updated RCPproblem test to use these new methods.
@
text
@d125 4
a128 4
      std::vector<float> benchQty = rcpProb.getBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> acquireQty =rcpProb.getAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> releaseQty =rcpProb.getReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d208 1
a208 1
      fprintf(mrpPlanFilePtr,"%s",heading.c_str);
d280 4
a283 4
      std::vector<float> benchQty = rcpProb.getBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
@


1.4
log
@Added bench, working, acquire and release quantities to the app data of the bench and working resources.  Also cleaned up the merge conflicts.
@
text
@d207 2
a208 3
      heading.clear();
      heading = heading+"\"" + rcpProb.getResourceIdentifier(i)+"\""+",";
      fprintf(mrpPlanFilePtr,"%s",heading.c_str());
@


1.3
log
@massive commit to handle vector resource descriptions.
substitution for the "long" format is NOT yet implemented.
tests need to be updated
@
text
@d125 4
a128 4
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
a198 4
    // Get list of all resources
    //std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
    //rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries);
    
a200 1

a203 2
    

d209 1
a209 1
      fprintf(mrpPlanFilePtr,"%s",heading.c_str);
d218 4
a221 5
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(resourceIdValues);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(resourceIdValues);
      std::vector<float> exogSup = rcpProb.getExogenousResourceSupplyQuantity(resourceIdValues);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(resourceIdValues);
      
d229 1
a229 1
           fprintf(mrpPlanFilePtr,"\"%s\",", names[r].at(i).c_str);
d244 1
a244 1
          "%d,%f,%f,%f,%f,%f\n",
d246 1
a246 1
          exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
d281 4
a284 4
      std::vector<float> benchQty = rcpProb.getResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> acquireQty =rcpProb.getResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> releaseQty =rcpProb.getResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d371 1
a371 1
    fprintf(mrpPlanFilePtr,"\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\",\"workingQty\"\n");
d376 3
a378 4
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> exogSup = rcpProb.getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],resourceLocs[r]);
d397 1
a397 1
          "%d,%f,%f,%f,%f,%f\n",
d399 1
a399 1
          exogSup[t],grossQty[t],gapQty[t],glutQty[t],workingQty[t]);
@


1.2
log
@Updated appl.mk for building rcpOptMain.  Changed the argument of rcpOpt to char const *.
@
text
@d200 18
a217 17
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
    rcpProb.getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,reportingUnits,bands,globals,competencies,industries);
    // Write header record
    //std::string heading="\"jobRole\",\"skillSet\",\"LOB\",\"source\",\"locationName\",\"period\",\"supplyQty\",\"grossReq\",\"gap\",\"glut\", \"workingQty\""; 
    //fprintf(mrpPlanFilePtr,"%s\n",heading.c_str());
    fprintf(mrpPlanFilePtr,"\"jobRole\",");
    fprintf(mrpPlanFilePtr,"\"skillSet\",");
    fprintf(mrpPlanFilePtr,"\"LOB\",");
    fprintf(mrpPlanFilePtr,"\"source\",");
    fprintf(mrpPlanFilePtr,"\"region\",");
    fprintf(mrpPlanFilePtr,"\"country\",");
    fprintf(mrpPlanFilePtr,"\"city\",");
    fprintf(mrpPlanFilePtr,"\"reportingUnit\",");
    fprintf(mrpPlanFilePtr,"\"band\",");
    fprintf(mrpPlanFilePtr,"\"global\",");
    fprintf(mrpPlanFilePtr,"\"competency\",");
    fprintf(mrpPlanFilePtr,"\"industry\",");
d219 1
d222 7
a228 6
    for ( r=0; r<jobRoles.size(); ++r ) {
      std::vector<float> grossQty = rcpProb.getMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> gapQty = rcpProb.getResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> glutQty = rcpProb.getResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> exogSup = rcpProb.getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      std::vector<float> workingQty = rcpProb.getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d236 15
a250 12
        fprintf(mrpPlanFilePtr,"\"%s\",",jobRoles[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",skillSets[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",LOBs[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",sources[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",regions[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",countries[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",cities[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",reportingUnits[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",bands[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",globals[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",competencies[r].c_str());
        fprintf(mrpPlanFilePtr,"\"%s\",",industries[r].c_str());
@


1.1
log
@- rcp.cpp renamed to rcpOptMain.cpp. This is the rcp standalone executable. (rcp.cpp remains for now in repository but is unused).
- removed main program rcpInvoke.cpp, because rcpOptMain will be used.(rcpInvoke.cpp remains for now in repository but is unused).
- invokeRcp.cpp was renamed rcpOpt.cpp (invokeRcp.cpp remains for now in the repository but is unused)
- rcpAlone.h was renamed rcpOpt.h (rcpAlone.h remains for now in repository but is unused).

- mds project rcp was replaced with project rcpOptMain.
- new mds project named rcpOptDll was created.  This project exposes the public members of RCPproblem and function rcpOpt(String directory);
@
text
@d24 1
a24 1
int RCP_DECLSPEC rcpOpt (const char const *  directoryName)
@


head	1.305;
access;
symbols
	start:1.1.1.1 IBM:1.1.1;
locks; strict;
comment	@// @;


1.305
date	2007.05.01.14.47.35;	author aradovan;	state Exp;
branches;
next	1.304;

1.304
date	2007.03.21.14.24.28;	author fasano;	state Exp;
branches;
next	1.303;

1.303
date	2007.03.21.13.09.15;	author fasano;	state Exp;
branches;
next	1.302;

1.302
date	2006.05.15.14.07.57;	author gresh;	state Exp;
branches;
next	1.301;

1.301
date	2006.02.28.15.59.02;	author gresh;	state Exp;
branches;
next	1.300;

1.300
date	2006.02.06.17.58.45;	author gresh;	state Exp;
branches;
next	1.299;

1.299
date	2006.01.31.15.45.39;	author gresh;	state Exp;
branches;
next	1.298;

1.298
date	2006.01.30.15.46.57;	author gresh;	state Exp;
branches;
next	1.297;

1.297
date	2006.01.23.12.42.43;	author gresh;	state Exp;
branches;
next	1.296;

1.296
date	2005.12.22.17.09.03;	author gresh;	state Exp;
branches;
next	1.295;

1.295
date	2005.12.21.17.45.57;	author gresh;	state Exp;
branches;
next	1.294;

1.294
date	2005.11.02.16.59.29;	author gresh;	state Exp;
branches;
next	1.293;

1.293
date	2005.09.21.16.05.41;	author fasano;	state Exp;
branches;
next	1.292;

1.292
date	2005.09.21.15.06.57;	author gresh;	state Exp;
branches;
next	1.291;

1.291
date	2005.09.13.17.53.29;	author gresh;	state Exp;
branches;
next	1.290;

1.290
date	2005.09.08.14.57.49;	author gresh;	state Exp;
branches;
next	1.289;

1.289
date	2005.08.19.19.15.24;	author gresh;	state Exp;
branches;
next	1.288;

1.288
date	2005.08.18.13.58.25;	author gresh;	state Exp;
branches;
next	1.287;

1.287
date	2005.08.16.18.18.51;	author gresh;	state Exp;
branches;
next	1.286;

1.286
date	2005.08.16.16.21.19;	author gresh;	state Exp;
branches;
next	1.285;

1.285
date	2005.08.15.17.32.41;	author gresh;	state Exp;
branches;
next	1.284;

1.284
date	2005.08.04.18.33.06;	author gresh;	state Exp;
branches;
next	1.283;

1.283
date	2004.10.18.16.25.42;	author gresh;	state Exp;
branches;
next	1.282;

1.282
date	2004.10.16.12.54.42;	author gresh;	state Exp;
branches;
next	1.281;

1.281
date	2004.08.12.12.19.48;	author dpc;	state Exp;
branches;
next	1.280;

1.280
date	2004.08.10.16.44.10;	author gresh;	state Exp;
branches;
next	1.279;

1.279
date	2004.08.10.14.31.39;	author gresh;	state Exp;
branches;
next	1.278;

1.278
date	2004.08.03.15.32.00;	author dpc;	state Exp;
branches;
next	1.277;

1.277
date	2004.07.30.18.31.08;	author dpc;	state Exp;
branches;
next	1.276;

1.276
date	2004.07.28.13.39.34;	author dpc;	state Exp;
branches;
next	1.275;

1.275
date	2004.07.27.13.45.18;	author gresh;	state Exp;
branches;
next	1.274;

1.274
date	2004.07.27.13.15.05;	author gresh;	state Exp;
branches;
next	1.273;

1.273
date	2004.07.26.20.11.17;	author gresh;	state Exp;
branches;
next	1.272;

1.272
date	2004.07.26.19.11.26;	author dpc;	state Exp;
branches;
next	1.271;

1.271
date	2004.07.26.18.22.18;	author gresh;	state Exp;
branches;
next	1.270;

1.270
date	2004.07.26.18.06.22;	author dpc;	state Exp;
branches;
next	1.269;

1.269
date	2004.07.26.17.54.12;	author gresh;	state Exp;
branches;
next	1.268;

1.268
date	2004.07.26.15.51.01;	author gresh;	state Exp;
branches;
next	1.267;

1.267
date	2004.07.23.18.56.59;	author dpc;	state Exp;
branches;
next	1.266;

1.266
date	2004.07.23.18.46.50;	author fasano;	state Exp;
branches;
next	1.265;

1.265
date	2004.07.23.18.35.20;	author fasano;	state Exp;
branches;
next	1.264;

1.264
date	2004.07.23.17.07.17;	author gresh;	state Exp;
branches;
next	1.263;

1.263
date	2004.07.23.15.57.06;	author dpc;	state Exp;
branches;
next	1.262;

1.262
date	2004.07.23.13.47.52;	author fasano;	state Exp;
branches;
next	1.261;

1.261
date	2004.07.23.12.37.21;	author dpc;	state Exp;
branches;
next	1.260;

1.260
date	2004.07.22.15.06.23;	author gresh;	state Exp;
branches;
next	1.259;

1.259
date	2004.07.22.13.59.36;	author dpc;	state Exp;
branches;
next	1.258;

1.258
date	2004.07.21.20.00.15;	author dpc;	state Exp;
branches;
next	1.257;

1.257
date	2004.07.21.17.42.03;	author gresh;	state Exp;
branches;
next	1.256;

1.256
date	2004.07.21.14.47.29;	author gresh;	state Exp;
branches;
next	1.255;

1.255
date	2004.07.19.14.10.12;	author dpc;	state Exp;
branches;
next	1.254;

1.254
date	2004.07.19.13.38.03;	author dpc;	state Exp;
branches;
next	1.253;

1.253
date	2004.07.16.15.15.29;	author gresh;	state Exp;
branches;
next	1.252;

1.252
date	2004.07.16.15.10.56;	author gresh;	state Exp;
branches;
next	1.251;

1.251
date	2004.07.16.14.28.23;	author gresh;	state Exp;
branches;
next	1.250;

1.250
date	2004.07.15.17.12.46;	author gresh;	state Exp;
branches;
next	1.249;

1.249
date	2004.07.15.16.50.58;	author gresh;	state Exp;
branches;
next	1.248;

1.248
date	2004.07.15.15.31.45;	author dpc;	state Exp;
branches;
next	1.247;

1.247
date	2004.07.14.17.43.51;	author gresh;	state Exp;
branches;
next	1.246;

1.246
date	2004.06.24.21.36.10;	author dpc;	state Exp;
branches;
next	1.245;

1.245
date	2004.06.24.19.19.58;	author fasano;	state Exp;
branches;
next	1.244;

1.244
date	2004.06.22.19.15.32;	author gresh;	state Exp;
branches;
next	1.243;

1.243
date	2004.06.21.14.32.09;	author gresh;	state Exp;
branches;
next	1.242;

1.242
date	2004.06.18.17.31.25;	author gresh;	state Exp;
branches;
next	1.241;

1.241
date	2004.06.17.14.50.43;	author gresh;	state Exp;
branches;
next	1.240;

1.240
date	2004.06.07.18.42.30;	author dpc;	state Exp;
branches;
next	1.239;

1.239
date	2004.06.04.17.07.37;	author gresh;	state Exp;
branches;
next	1.238;

1.238
date	2004.06.02.13.46.43;	author gresh;	state Exp;
branches;
next	1.237;

1.237
date	2004.05.17.17.04.19;	author gresh;	state Exp;
branches;
next	1.236;

1.236
date	2004.05.17.17.02.04;	author gresh;	state Exp;
branches;
next	1.235;

1.235
date	2004.05.17.16.49.26;	author gresh;	state Exp;
branches;
next	1.234;

1.234
date	2004.05.17.15.41.29;	author gresh;	state Exp;
branches;
next	1.233;

1.233
date	2004.05.14.19.09.16;	author gresh;	state Exp;
branches;
next	1.232;

1.232
date	2004.05.14.17.41.38;	author gresh;	state Exp;
branches;
next	1.231;

1.231
date	2004.05.14.13.34.19;	author dpc;	state Exp;
branches;
next	1.230;

1.230
date	2004.05.12.14.04.26;	author dpc;	state Exp;
branches;
next	1.229;

1.229
date	2004.05.10.13.05.10;	author gresh;	state Exp;
branches;
next	1.228;

1.228
date	2004.05.07.18.00.24;	author dpc;	state Exp;
branches;
next	1.227;

1.227
date	2004.05.06.21.32.36;	author gresh;	state Exp;
branches;
next	1.226;

1.226
date	2004.05.06.19.39.46;	author fasano;	state Exp;
branches;
next	1.225;

1.225
date	2004.05.04.02.11.54;	author fasano;	state Exp;
branches;
next	1.224;

1.224
date	2004.05.03.23.08.36;	author dpc;	state Exp;
branches;
next	1.223;

1.223
date	2004.05.03.17.08.38;	author gresh;	state Exp;
branches;
next	1.222;

1.222
date	2004.05.03.14.49.37;	author gresh;	state Exp;
branches;
next	1.221;

1.221
date	2004.05.03.13.29.27;	author fasano;	state Exp;
branches;
next	1.220;

1.220
date	2004.05.03.13.20.59;	author fasano;	state Exp;
branches;
next	1.219;

1.219
date	2004.04.26.17.56.51;	author gresh;	state Exp;
branches;
next	1.218;

1.218
date	2004.04.21.19.17.01;	author gresh;	state Exp;
branches;
next	1.217;

1.217
date	2004.04.21.19.01.50;	author gresh;	state Exp;
branches;
next	1.216;

1.216
date	2004.04.21.17.02.27;	author dpc;	state Exp;
branches;
next	1.215;

1.215
date	2004.04.21.16.29.21;	author fasano;	state Exp;
branches;
next	1.214;

1.214
date	2004.04.21.15.32.14;	author fasano;	state Exp;
branches;
next	1.213;

1.213
date	2004.04.21.15.24.28;	author fasano;	state Exp;
branches;
next	1.212;

1.212
date	2004.04.21.12.43.56;	author fasano;	state Exp;
branches;
next	1.211;

1.211
date	2004.04.21.12.38.21;	author fasano;	state Exp;
branches;
next	1.210;

1.210
date	2004.04.19.16.22.11;	author dpc;	state Exp;
branches;
next	1.209;

1.209
date	2004.04.16.16.53.22;	author fasano;	state Exp;
branches;
next	1.208;

1.208
date	2004.04.16.16.01.59;	author gresh;	state Exp;
branches;
next	1.207;

1.207
date	2004.04.16.14.28.44;	author gresh;	state Exp;
branches;
next	1.206;

1.206
date	2004.04.16.14.24.08;	author dpc;	state Exp;
branches;
next	1.205;

1.205
date	2004.04.16.13.39.16;	author gresh;	state Exp;
branches;
next	1.204;

1.204
date	2004.04.15.19.39.30;	author gresh;	state Exp;
branches;
next	1.203;

1.203
date	2004.04.15.16.54.23;	author gresh;	state Exp;
branches;
next	1.202;

1.202
date	2004.04.15.16.21.24;	author dpc;	state Exp;
branches;
next	1.201;

1.201
date	2004.04.15.15.49.28;	author gresh;	state Exp;
branches;
next	1.200;

1.200
date	2004.04.15.15.29.51;	author gresh;	state Exp;
branches;
next	1.199;

1.199
date	2004.04.15.15.28.00;	author gresh;	state Exp;
branches;
next	1.198;

1.198
date	2004.04.14.18.55.32;	author dpc;	state Exp;
branches;
next	1.197;

1.197
date	2004.04.14.14.52.40;	author gresh;	state Exp;
branches;
next	1.196;

1.196
date	2004.04.14.12.51.18;	author gresh;	state Exp;
branches;
next	1.195;

1.195
date	2004.04.13.20.59.29;	author fasano;	state Exp;
branches;
next	1.194;

1.194
date	2004.04.13.20.16.50;	author fasano;	state Exp;
branches;
next	1.193;

1.193
date	2004.04.13.19.20.01;	author gresh;	state Exp;
branches;
next	1.192;

1.192
date	2004.04.13.15.51.16;	author gresh;	state Exp;
branches;
next	1.191;

1.191
date	2004.04.12.15.59.14;	author dpc;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.09.15.18.52;	author gresh;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.06.11.47.59;	author gresh;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.06.02.05.42;	author fasano;	state Exp;
branches;
next	1.187;

1.187
date	2004.04.05.21.37.12;	author dpc;	state Exp;
branches;
next	1.186;

1.186
date	2004.04.05.12.40.43;	author dpc;	state Exp;
branches;
next	1.185;

1.185
date	2004.04.05.00.36.00;	author fasano;	state Exp;
branches;
next	1.184;

1.184
date	2004.04.03.02.08.17;	author fasano;	state Exp;
branches;
next	1.183;

1.183
date	2004.04.02.20.38.43;	author gresh;	state Exp;
branches;
next	1.182;

1.182
date	2004.04.02.20.27.22;	author dpc;	state Exp;
branches;
next	1.181;

1.181
date	2004.04.02.18.28.35;	author gresh;	state Exp;
branches;
next	1.180;

1.180
date	2004.04.02.16.48.53;	author gresh;	state Exp;
branches;
next	1.179;

1.179
date	2004.04.02.15.12.16;	author gresh;	state Exp;
branches;
next	1.178;

1.178
date	2004.03.31.17.32.02;	author gresh;	state Exp;
branches;
next	1.177;

1.177
date	2004.03.31.16.05.43;	author gresh;	state Exp;
branches;
next	1.176;

1.176
date	2004.03.30.23.42.48;	author fasano;	state Exp;
branches;
next	1.175;

1.175
date	2004.03.24.19.20.33;	author gresh;	state Exp;
branches;
next	1.174;

1.174
date	2004.03.24.17.41.51;	author gresh;	state Exp;
branches;
next	1.173;

1.173
date	2004.03.24.16.25.52;	author gresh;	state Exp;
branches;
next	1.172;

1.172
date	2004.03.24.16.19.43;	author gresh;	state Exp;
branches;
next	1.171;

1.171
date	2004.03.24.15.16.41;	author gresh;	state Exp;
branches;
next	1.170;

1.170
date	2004.03.24.14.36.01;	author gresh;	state Exp;
branches;
next	1.169;

1.169
date	2004.03.23.22.47.21;	author gresh;	state Exp;
branches;
next	1.168;

1.168
date	2004.03.23.19.55.50;	author gresh;	state Exp;
branches;
next	1.167;

1.167
date	2004.03.23.14.27.49;	author gresh;	state Exp;
branches;
next	1.166;

1.166
date	2004.03.22.20.40.31;	author gresh;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.22.17.57.24;	author dpc;	state Exp;
branches;
next	1.164;

1.164
date	2004.03.22.15.51.17;	author gresh;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.22.13.40.16;	author gresh;	state Exp;
branches;
next	1.162;

1.162
date	2004.03.20.02.35.03;	author fasano;	state Exp;
branches;
next	1.161;

1.161
date	2004.03.19.19.27.52;	author fasano;	state Exp;
branches;
next	1.160;

1.160
date	2004.03.19.16.40.23;	author fasano;	state Exp;
branches;
next	1.159;

1.159
date	2004.03.19.02.49.45;	author fasano;	state Exp;
branches;
next	1.158;

1.158
date	2004.03.19.02.35.11;	author fasano;	state Exp;
branches;
next	1.157;

1.157
date	2004.03.18.23.14.03;	author dpc;	state Exp;
branches;
next	1.156;

1.156
date	2004.03.18.22.13.00;	author fasano;	state Exp;
branches;
next	1.155;

1.155
date	2004.03.18.21.18.49;	author fasano;	state Exp;
branches;
next	1.154;

1.154
date	2004.03.18.21.09.38;	author fasano;	state Exp;
branches;
next	1.153;

1.153
date	2004.03.18.20.45.45;	author fasano;	state Exp;
branches;
next	1.152;

1.152
date	2004.03.18.19.15.31;	author gresh;	state Exp;
branches;
next	1.151;

1.151
date	2004.03.18.18.23.39;	author gresh;	state Exp;
branches;
next	1.150;

1.150
date	2004.03.18.16.54.58;	author fasano;	state Exp;
branches;
next	1.149;

1.149
date	2004.03.18.16.51.51;	author fasano;	state Exp;
branches;
next	1.148;

1.148
date	2004.03.18.16.44.49;	author fasano;	state Exp;
branches;
next	1.147;

1.147
date	2004.03.18.16.38.39;	author fasano;	state Exp;
branches;
next	1.146;

1.146
date	2004.03.18.16.31.30;	author fasano;	state Exp;
branches;
next	1.145;

1.145
date	2004.03.18.16.25.37;	author fasano;	state Exp;
branches;
next	1.144;

1.144
date	2004.03.18.16.20.01;	author fasano;	state Exp;
branches;
next	1.143;

1.143
date	2004.03.18.14.18.39;	author gresh;	state Exp;
branches;
next	1.142;

1.142
date	2004.03.18.02.35.48;	author fasano;	state Exp;
branches;
next	1.141;

1.141
date	2004.03.17.22.34.40;	author fasano;	state Exp;
branches;
next	1.140;

1.140
date	2004.03.17.19.02.51;	author gresh;	state Exp;
branches;
next	1.139;

1.139
date	2004.03.17.18.21.24;	author dpc;	state Exp;
branches;
next	1.138;

1.138
date	2004.03.17.18.11.47;	author gresh;	state Exp;
branches;
next	1.137;

1.137
date	2004.03.17.17.44.08;	author gresh;	state Exp;
branches;
next	1.136;

1.136
date	2004.03.17.15.56.39;	author gresh;	state Exp;
branches;
next	1.135;

1.135
date	2004.03.17.15.11.26;	author gresh;	state Exp;
branches;
next	1.134;

1.134
date	2004.03.17.14.33.18;	author dpc;	state Exp;
branches;
next	1.133;

1.133
date	2004.03.17.03.08.16;	author fasano;	state Exp;
branches;
next	1.132;

1.132
date	2004.03.16.21.23.58;	author gresh;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.16.20.48.21;	author dpc;	state Exp;
branches;
next	1.130;

1.130
date	2004.03.16.18.58.21;	author gresh;	state Exp;
branches;
next	1.129;

1.129
date	2004.03.16.18.49.51;	author gresh;	state Exp;
branches;
next	1.128;

1.128
date	2004.03.16.18.41.05;	author gresh;	state Exp;
branches;
next	1.127;

1.127
date	2004.03.16.17.23.33;	author gresh;	state Exp;
branches;
next	1.126;

1.126
date	2004.03.15.21.12.25;	author gresh;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.15.20.56.44;	author gresh;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.15.20.38.31;	author gresh;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.15.19.02.09;	author fasano;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.15.18.08.34;	author fasano;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.15.17.01.38;	author fasano;	state Exp;
branches;
next	1.120;

1.120
date	2004.03.14.10.18.11;	author fasano;	state Exp;
branches;
next	1.119;

1.119
date	2004.03.14.10.11.26;	author fasano;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.13.19.15.29;	author fasano;	state Exp;
branches;
next	1.117;

1.117
date	2004.03.13.17.19.50;	author fasano;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.13.17.06.26;	author fasano;	state Exp;
branches;
next	1.115;

1.115
date	2004.03.13.14.55.23;	author fasano;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.13.05.50.41;	author fasano;	state Exp;
branches;
next	1.113;

1.113
date	2004.03.11.16.52.13;	author dpc;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.10.20.52.12;	author gresh;	state Exp;
branches;
next	1.111;

1.111
date	2004.03.10.20.50.20;	author dpc;	state Exp;
branches;
next	1.110;

1.110
date	2004.03.10.19.24.04;	author gresh;	state Exp;
branches;
next	1.109;

1.109
date	2004.03.10.19.16.59;	author gresh;	state Exp;
branches;
next	1.108;

1.108
date	2004.03.10.19.05.06;	author dpc;	state Exp;
branches;
next	1.107;

1.107
date	2004.03.10.17.08.43;	author dpc;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.09.14.23.56;	author gresh;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.08.21.01.48;	author gresh;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.08.14.34.25;	author gresh;	state Exp;
branches;
next	1.103;

1.103
date	2004.03.01.22.54.03;	author dpc;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.26.14.22.30;	author gresh;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.12.21.24.31;	author gresh;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.12.17.56.03;	author gresh;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.12.17.26.59;	author gresh;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.12.16.06.21;	author gresh;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.12.15.24.09;	author gresh;	state Exp;
branches;
next	1.96;

1.96
date	2004.02.11.19.39.09;	author gresh;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.10.19.43.33;	author gresh;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.30.19.57.30;	author dpc;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.30.15.16.09;	author gresh;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.30.14.58.41;	author dpc;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.30.13.28.08;	author dpc;	state Exp;
branches;
next	1.90;

1.90
date	2004.01.24.21.52.48;	author fasano;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.23.03.29.12;	author fasano;	state Exp;
branches;
next	1.88;

1.88
date	2004.01.22.22.30.09;	author dpc;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.22.16.50.00;	author gresh;	state Exp;
branches;
next	1.86;

1.86
date	2004.01.22.15.23.05;	author gresh;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.22.14.51.28;	author gresh;	state Exp;
branches;
next	1.84;

1.84
date	2004.01.21.20.40.03;	author dpc;	state Exp;
branches;
next	1.83;

1.83
date	2004.01.21.19.07.29;	author gresh;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.21.18.33.25;	author gresh;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.21.18.29.45;	author gresh;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.21.17.51.37;	author gresh;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.21.15.47.32;	author gresh;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.21.14.43.07;	author dpc;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.21.03.17.22;	author fasano;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.21.02.08.47;	author fasano;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.20.13.36.50;	author fasano;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.19.14.50.40;	author fasano;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.16.22.19.00;	author fasano;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.16.22.07.40;	author fasano;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.16.19.50.47;	author gresh;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.16.19.44.12;	author fasano;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.16.18.44.35;	author gresh;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.16.14.58.02;	author gresh;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.16.14.29.09;	author gresh;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.14.19.36.50;	author gresh;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.13.18.30.37;	author gresh;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.13.15.10.13;	author dpc;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.13.14.53.54;	author fasano;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.13.14.31.33;	author fasano;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.13.00.14.33;	author fasano;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.12.19.55.25;	author fasano;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.12.18.21.57;	author gresh;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.12.18.00.43;	author gresh;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.12.17.39.32;	author gresh;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.12.14.51.38;	author dpc;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.11.17.40.44;	author fasano;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.10.14.03.14;	author fasano;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.10.13.02.58;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.10.03.16.42;	author fasano;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.09.22.23.25;	author fasano;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.09.21.39.50;	author dpc;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.09.17.14.59;	author dpc;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.09.15.48.41;	author gresh;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.09.14.22.27;	author dpc;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.08.21.55.30;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.08.21.04.09;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.08.20.00.04;	author dpc;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.07.23.18.32;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.07.22.18.34;	author dpc;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.07.18.45.56;	author gresh;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.07.14.01.52;	author dpc;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.06.17.10.02;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.13.05.08.12;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.13.04.52.49;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.13.01.15.22;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.12.17.04.18;	author dpc;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.12.16.22.29;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.12.15.58.21;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.09.19.52.28;	author gresh;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.09.14.17.45;	author dpc;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.03.21.33.16;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.03.19.30.04;	author dpc;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.01.21.59.59;	author dpc;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.01.21.24.10;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.01.21.20.32;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.01.20.19.38;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.01.17.44.13;	author gresh;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.01.16.00.31;	author gresh;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.01.14.19.06;	author gresh;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.26.14.45.30;	author gresh;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.26.03.25.20;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.25.18.58.54;	author gresh;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.25.14.57.48;	author gresh;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.23.11.30.03;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.23.11.10.48;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.23.00.25.07;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.21.22.34.57;	author dpc;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.21.04.22.25;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.20.21.20.57;	author dpc;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.20.20.50.18;	author dpc;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.20.02.12.59;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.19.19.34.24;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.19.15.07.03;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.18.21.35.11;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.18.19.32.19;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.14.21.38.03;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.14.20.23.15;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.13.19.22.46;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.13.14.44.14;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.13.14.23.40;	author fasano;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.13.14.23.40;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.305
log
@Changed the case of one of the example file directories to match the case required on linux after a cvs checkout.  It was probably working on windows because I think the OS is not sensitive to the case in a directory name. (JP).
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4996)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#pragma warning(disable:4290)
#endif

#include <numeric>
#include <set>
#include <algorithm>

#include <cassert>
#include <iostream>
#include <cfloat>
#include <cstdio>
#include <climits>

#include "CoinFinite.h"
#include "CoinFloatEqual.h"
#include "rcpProblem.h"
#include "rcpOptException.h"
#include "engagementAppData.h"
#include "bomAppData.h"
#include "resourceAppData.h"
#include "populateRCP.h"
#include "rcpOptCal.h"
#include "rcpOptTimer.h"
#include "checkWitRC.h"
#include "rcpOptIntException.h"

extern bool witOK;



RcpOptTimer & RCPproblem::getTimer() {
  return timer_;
}

//----------------------
// Methods for engagements.
//----------------------
void RCPproblem::addDemandForEngagement(const std::string &engName, const std::string &demandName, int period, float quantity) 
{
  std::string theEngagement = engagementName(engName);
  float *demandVol;
  if (!witGetDemandExists(theEngagement, demandName)) {
     checkWitRC(witAddDemand(witRun(),theEngagement.c_str(),demandName.c_str()));
     demandVol = floatToFloatStar(0.0);
     demandVol[period]=quantity;
     checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
  
  
     //force the demand to be met in the demanded period by setting the cum demand vol.
     //in the period
     checkWitRC(witSetDemandCumShipBounds(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol,demandVol,NULL));
     //checkWitRC(witSetDemandShipVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
     delete [] demandVol;

  }
  else {
     witGetDemandDemandVol(witRun(),theEngagement.c_str(), demandName.c_str(), &demandVol);
	 demandVol[period]=quantity;
	 checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
	  
	  
	 //force the demand to be met in the demanded period by setting the cum demand vol.
	 //in the period
	 checkWitRC(witSetDemandCumShipBounds(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol,demandVol,NULL));
	 //checkWitRC(witSetDemandShipVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
	 witFree(demandVol);
  }


}
void RCPproblem::computeCumDemands() {

   //have to go through all the engagement parts, and all the demands for the parts
   std::vector<std::string> names;
   getEngagementNames(names);
   int numDemands;
   char **demandList;
   for (unsigned int i=0; i<names.size(); i++) {
      std::string theEngagement = engagementName(names[i]);
      witGetPartDemands(witRun(),theEngagement.c_str(),&numDemands,&demandList);
      for (int j=0; j<numDemands;j++) {
        float * hardlower;
        float * softlower;
        float * hardupper;
        float accumhard, accumsoft;
        accumhard=0.0;
        accumsoft=0.0;
        witGetDemandCumShipBounds(witRun(),theEngagement.c_str(),demandList[j], &hardlower, &softlower, &hardupper);
        for (int i=0; i<getNPeriods(); i++) {
            accumhard+=hardlower[i];
            accumsoft+=softlower[i];
            hardlower[i]=accumhard;
            softlower[i]=accumsoft;
        }
        witSetDemandCumShipBounds(witRun(),theEngagement.c_str(),demandList[j],hardlower,softlower,hardupper);
                 
        delete [] hardlower;
        delete [] softlower;
        delete [] hardupper;
         
         
      }
      delete [] demandList;
      
   
   }
   
   
}
void RCPproblem::addEngagementFamily(const std::string & engFamilyName) 
{
	std::string theEngagementFamily = engagementFamilyName(engFamilyName);
    engagementFamilyNames_.insert(theEngagementFamily);
	//we'll need a part for it
	checkWitRC(witAddPart(witRun(),theEngagementFamily.c_str(),WitMATERIAL));
	//give it a supply of zero
    float * supplyVol = floatToFloatStar(0.0f);
	supplyVol[0] = 1;
	checkWitRC(witSetPartSupplyVol(witRun(),theEngagementFamily.c_str(),supplyVol));
	delete [] supplyVol;
}
void RCPproblem::setEngagementFamily(const std::string & engName, const std::string & engFamilyName) {
	std::string theEngagement = engagementName(engName);
	std::string theEngagementFamily = engagementFamilyName(engFamilyName);

	//add a bom from the "family" part to the engagement
	checkWitRC(witAddBomEntry(witRun(),theEngagement.c_str(), theEngagementFamily.c_str()));
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(0);
	checkWitRC(witSetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),0,appData));
 }
void RCPproblem::addEngagement(const std::string & engName)
{
  std::string theEngagement = engagementName(engName);
  checkWitRC(witAddPart(witRun(),theEngagement.c_str(),WitCAPACITY));
  checkWitRC(witAddDemand(witRun(),theEngagement.c_str(),theEngagement.c_str()));
  checkWitRC(witAddOperation(witRun(),theEngagement.c_str()));
  checkWitRC(witAddBopEntry(witRun(),theEngagement.c_str(),theEngagement.c_str()));
 

  //Set the scrap cost for the engagement to a trivial quantity to prevent extra quantity from being built
  float * scrapCost = floatToFloatStar(1.0f);
  checkWitRC(witSetPartObj1ScrapCost(witRun(),theEngagement.c_str(),scrapCost));
  delete [] scrapCost;


  float * vecOne = floatToFloatStar(1.0);
  checkWitRC(witSetOperationIncLotSize(witRun(),theEngagement.c_str(),vecOne));
  //checkWitRC(witSetOperationIncLotSize(witRun(),"JUNK",vecOne));  ///DPC
  delete [] vecOne;
  
  RCPengagementAppData * appData = new RCPengagementAppData;
  checkWitRC(witSetPartAppData(witRun(),theEngagement.c_str(),appData));
  
  engagementNames_.insert(theEngagement);
}
void RCPproblem::addEngagementNoDemand(const std::string & engName)
{
  std::string theEngagement = engagementName(engName);
  checkWitRC(witAddPart(witRun(),theEngagement.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),theEngagement.c_str()));
  checkWitRC(witAddBopEntry(witRun(),theEngagement.c_str(),theEngagement.c_str()));
 

  //Set the scrap cost for the engagement to a trivial quantity to prevent extra quantity from being built
  float * scrapCost = floatToFloatStar(1.0f);
  checkWitRC(witSetPartObj1ScrapCost(witRun(),theEngagement.c_str(),scrapCost));
  delete [] scrapCost;


  float * vecOne = floatToFloatStar(1.0);
  checkWitRC(witSetOperationIncLotSize(witRun(),theEngagement.c_str(),vecOne));
  //checkWitRC(witSetOperationIncLotSize(witRun(),"JUNK",vecOne));  ///DPC
  delete [] vecOne;
  
  RCPengagementAppData * appData = new RCPengagementAppData;
  checkWitRC(witSetPartAppData(witRun(),theEngagement.c_str(),appData));
  
  engagementNames_.insert(theEngagement);
}
//AddAlternateResource should add a part (including the "transform" or "enable"
//operation) representing the skillList group (which
//is a vector of strings like {C++,java,DB2}. It should then connect the operation to
//each "working" part in the list of skills. For the skill group with only one item
//it should *not* add the part, but rather just adjust the supply of the already
//existing part.
  void RCPproblem::addAlternateResource(std::vector<std::string> skillList, int skillSetPosition,  RCPvectorString originalResource,  float * supplyAlternate) {
  //The first step is to construct a new part name

  //check whether there is just one skill
  if (skillList.size()==1) {
     //it should be the original skill
     std::string origSkill = originalResource.at(skillSetPosition);
     std::string skill = skillList.at(0);
     

     if (skill != origSkill) {
        //DLG what do we want to do here?
     }
     else {
        //modify the supply DLG IS THIS CORRECT? ON THE BENCH NOW?
        setFlexibleResourceSupplyQuantity(originalResource,supplyAlternate);
     }
  }
  else { 
     //here we need to make up a new name for the "skillSet", and add it as
     //a part, then set its supply, and connect it to all the appropriate places
     std::string skillname = makeFlexSkillName(skillList);
     RCPvectorString newResource = replaceSkillSet(originalResource, skillSetPosition, skillname);
     addFlexibleResource(newResource,false); 
     setFlexibleResourceSupplyQuantity(newResource,supplyAlternate);


     std::string primaryskill = originalResource.at(skillSetPosition);
     for (unsigned int i=0; i<skillList.size(); i++) {
        std::string sk = skillList.at(i);
        RCPvectorString targetResource = replaceSkillSet(originalResource, skillSetPosition, sk);
        std::string workingResource = workingResourceName(targetResource);
        std::string benchResource = benchResourceName(newResource);
        //only if the targetResource exists and only if this is different than the "vanilla" resource
        if (witPartExists(workingResource)) {
             std::string enableOp = enableFlexResourceOperationName(newResource,targetResource);  
             witAddOperation(witRun(),enableOp.c_str());
             float * execPenalty = floatToFloatStar(0.01f);
             checkWitRC(witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),execPenalty));
             witAddBomEntry(witRun(),enableOp.c_str(), benchResource.c_str());
             checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),workingResource.c_str()));
             delete [] execPenalty;

        }
     }
     
  }
  
  }
  
std::string  RCPproblem::makeFlexSkillName(std::vector<std::string> skillGroup) {
  //This routine makes a replacement name for "skillset" using the skills in the group
  std::string returnvalue="";
  char spacer[100];
  for (unsigned int i=0; i<skillGroup.size(); i++) {
     sprintf(spacer," s%d: ",i);
     returnvalue = returnvalue+spacer+skillGroup.at(i);
  }
  return returnvalue;
}

RCPvectorString replaceSkillSet(RCPvectorString attributes,int skillSetPosition,std::string alternateSkillSet) {
  
   //This routine replaces one skill set with another skill set. 
   RCPvectorString newResourceName;
   for (unsigned int i=0; i<attributes.size(); i++) {
      newResourceName.push_back(attributes[i]);
   }
   newResourceName[skillSetPosition]=alternateSkillSet;
   return newResourceName;

}


 bool RCPproblem::engagementExists    (const std::string & engName)const
 {
   return witPartExists(engagementName(engName).c_str());
 }
 bool RCPproblem::engagementFamilyExists (const std::string &engFamilyName)const
 {
	 bool exists;
	 std::string theEngagementFamily = engagementFamilyName(engFamilyName);

	 if (engagementFamilyNames_.find(theEngagementFamily)!= engagementFamilyNames_.end()) 
		 return true;
	 else
		 return false;
 }
void RCPproblem::setEngagementRevenue(const std::string & engName, 
                                      float revenue)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setRevenue(revenue);
}
void RCPproblem::setEngagementMustDo(const std::string & engName, 
                                      int mustDo)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setMustDo(mustDo);
}
void RCPproblem::setEngagementPriority(const std::string & engName, 
                                       int prior)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setPriority(prior);
}

void RCPproblem::setEngagementQuantity(const std::string & engName, 
                                       float quantity)
{
  RCPengagementAppData * appData;
  std::string theEngagement = engagementName(engName);
  checkWitRC(witGetPartAppData(witRun(),theEngagement.c_str(),(void**)&appData));
  appData->setQuantity(quantity);
}


void RCPproblem::setEngagementStartPeriod(const std::string & engName, 
                                          int startPeriod)
{
  assert(startPeriod<getNPeriods());
  std::string theEngagement = engagementName(engName);
  // Save start period in appData
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),theEngagement.c_str(),(void**)&appData));
  appData->setRequestedStartPeriod(startPeriod);
  
  // Set wit's demandVol from startPeriod
  //  float * demandVol = floatToFloatStar(0.0f);
  //demandVol[startPeriod]=1.0f;
  //checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol));
  //delete [] demandVol;
}

void RCPproblem::setEngagementLateAllowance(const std::string & engName, 
                                            int lateAllowance)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setLateAllowance(lateAllowance);
}
int RCPproblem::getEngagementMustDo(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getMustDo();
}

float RCPproblem::getEngagementRevenue(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getRevenue();
}
int RCPproblem::getEngagementPriority(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getPriority();
}

float RCPproblem::getEngagementQuantity(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getQuantity();
}

int RCPproblem::getEngagementRequestedStartPeriod(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getRequestedStartPeriod();
}
int RCPproblem::getEngagementStartPeriod(const std::string & engName)const
{
  bool executed = getEngagementExecuted(engName);
  //int duration = getEngagementDuration(engName);
  int retVal = -1;
  if (!executed) return retVal;
  else {
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,engagementName(engName));
    for (unsigned int t=0; t<execVol.size(); ++t ) {
      if( execVol[t]>0.0 ) {
        retVal=t;
        break;
      }
    }
    return retVal;
  }
}

//int RCPproblem::getEngagementDuration(const std::string & engName)const
//{
 // RCPengagementAppData * appData;
 // checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
 // return appData->getDuration();
//}

int RCPproblem::getEngagementLateAllowance(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getLateAllowance();
}


void RCPproblem::getEngagementNames( std::vector<std::string> & engagementNames ) const
{
  engagementNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=engagementNames_.begin(); it!=engagementNames_.end(); ++it ) {
    engagementNames.push_back( engagementFromEngagementName(*it) );
  }
}
bool RCPproblem::getInfeasibleExecution(const std::string &engName)const
{
  //check first whether the "panic" part was used at all
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,"MAKE PANIC");
  int usedPanic=0;
  for (unsigned int t=0; t<execVol.size(); ++t) {
    if (execVol[t]>0)
       usedPanic=1;
  }
  if (usedPanic==0)
     return false;
     
  std::string thisEngagementName = engagementName(engName);
  
  //we used the panic part. Now we have to determine whether this engagement used
  //it.
  
  int nSubsBom,bomEntryIndex,subsBomEntryIndex;
  char *opName;
  float * consRate;
  int usedPanicThisEngagement = 0;
  checkWitRC(witGetPartNConsumingSubsBomEntries(mutableWitRun(),"PANIC", &nSubsBom));
  for (int i=0; i<nSubsBom; i++) {
     checkWitRC(witGetPartConsumingSubsBomEntry(mutableWitRun(),"PANIC",i,&opName,&bomEntryIndex,&subsBomEntryIndex));
     if (!strcmp(opName,thisEngagementName.c_str())) {
        //check to see if the usage was 0 or not
        checkWitRC(witGetSubsBomEntryConsRate(mutableWitRun(),opName,bomEntryIndex,subsBomEntryIndex,&consRate));
        for (int j=0; j<getNPeriods(); j++) {
           if (consRate[j]>0) usedPanicThisEngagement=1;
        }
        free(consRate);
     }
     free(opName);
  }
  if (usedPanicThisEngagement)
     return true;
  else
     return false;
  
}
bool RCPproblem::getEngagementExecuted(const std::string & engName)const
{
  bool retVal=false;
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,
    engagementName(engName));
  for (unsigned int t=0; t<execVol.size(); ++t ) {
    if( execVol[t]>0.0 ) {
      retVal=true;
      break;
    }
  }
  return retVal;
}

std::vector<float> RCPproblem::getEngagementExecutionQuantity(const std::string & engName)const
{
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,
                                                   engagementName(engName));
  return execVol;
}

void RCPproblem::getEngagementPeggedQuantitiesFromSupply(const std::string &engName, 
                                                         int period,
                                                         std::vector<RCPvectorString> & resources,
                                                         std::vector<float> &quantities) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->getPeggedQuantitiesFromSupply(period,resources,quantities);
}

void RCPproblem::getEngagementPeggedQuantitiesFromAcquisition(const std::string &engName, 
                                                              int period,
                                                              std::vector<RCPvectorString> & resources,
                                                              std::vector<float> &quantities) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->getPeggedQuantitiesFromAcquisition(period,resources,quantities);
}
void RCPproblem::getEngagementPeggedQuantitiesFromSubstitution(const std::string &engName, 
                                                               int period,
                                                               std::vector<RCPvectorString> & resources,
                                                               std::vector<float> &quantities,
                                                               std::vector<RCPvectorString> & subResources) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->getPeggedQuantitiesFromSubstitution(period,resources,quantities,subResources);
}
float RCPproblem::getEngagementPeggedQuantityFromSupply(const std::string &engName, 
                                                         int period,
                                                         RCPvectorString & resource) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getPeggedQuantityFromSupply(period,resource);
}

float RCPproblem::getEngagementPeggedQuantityFromAcquisition(const std::string &engName, 
                                                              int period,
                                                              RCPvectorString & resource) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getPeggedQuantityFromAcquisition(period,resource);
}
void RCPproblem::getEngagementPeggedQuantitiesFromSubstitution(const std::string &engName, 
                                                               int period,
                                                               RCPvectorString & resource,
                                                               std::vector<float> &quantities,
                                                               std::vector<RCPvectorString> & subResources) const {
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->getPeggedQuantitiesFromSubstitution(period,resource,quantities,subResources);
}


//----------------------
// Methods for resources.
//----------------------
void RCPproblem::addMultipleSkillGroups(std::vector<std::vector<std::string> > skillGroup) {
    //this takes as input a vector of resource descriptions.
    //it checks whether or not we already have this set. If not, we add it, and
    //connect it to all the appropriate working resources. If it does exist,
    //we simply increase the supply of it.
    
    //first, if there's only one skill, we won't add it as a group.
    
    int size = skillGroup.size();
    int nPeriods = getNPeriods();
    if (size!=1) {
        //first we need to construct an appropriate name for the skill group
        std::string skillGroupName = createSkillGroupName(skillGroup);
        witBoolean exists;
        checkWitRC(witGetPartExists(witRun(), skillGroupName.c_str(), &exists));
        if (!exists) {
            //add it and hook it up
            addSkillGroupResource(skillGroup);
            multipleSkillResourceNames_.push_back(skillGroup);
            RCPresourceAppData * workingAppData = new RCPresourceAppData(nPeriods);
            checkWitRC(witSetPartAppData(witRun(),skillGroupName.c_str(),workingAppData));

        }
    }

}
void RCPproblem::setMultipleSkillResourceSupplyQuantity(std::vector<std::vector<std::string> > skillGroup, float supply, int period) {
    //simply increment the supply of it
    float * supplyVec;
    if (skillGroup.size()==1) {
        std::vector<std::string> resourceAttributeVector = skillGroup[0];
        std::string workingRes = workingResourceName(resourceAttributeVector);
        checkWitRC(witGetPartSupplyVol(witRun(),workingRes.c_str(),&supplyVec));
        supplyVec[period]=supply;   
        checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),supplyVec));
        checkWitRC(witFree(supplyVec));
    }
    else {
        std::string skillGroupName = createSkillGroupName(skillGroup);
        checkWitRC(witGetPartSupplyVol(mutableWitRun(),skillGroupName.c_str(),&supplyVec));
        supplyVec[period]=supply;   
        checkWitRC(witSetPartSupplyVol(witRun(),skillGroupName.c_str(),supplyVec));
        checkWitRC(witFree(supplyVec));
    }
}
float * RCPproblem::getMultipleSkillResourceSupplyQuantity(std::vector<std::vector<std::string> > skillGroup) {
    float * supplyVec;
    std::string skillGroupName = createSkillGroupName(skillGroup);
    checkWitRC(witGetPartSupplyVol(mutableWitRun(),skillGroupName.c_str(),&supplyVec));
    return supplyVec;
}
void RCPproblem::addFlexibleResource(const std::vector<std::string> &resourceAttributeVector, bool isActualResource)
{
  //this is for the flex mix model. It adds a "working" part, an "enable" operation,
  //and a "bench" part. There is no aquire operation. That will be added for
  //demanded resources as a "last" substitute. It only adds the aquire if this is a demanded
  //resoruce.

  std::string benchRes = benchResourceName(resourceAttributeVector);
  std::string enableOp = enableResourceOperationName(resourceAttributeVector);
  std::string workingRes = workingResourceName(resourceAttributeVector);
    
  int np = getNPeriods();
  
  // Add parts and operations
  checkWitRC(witAddPart(witRun(),benchRes.c_str(),WitCAPACITY));
 
  //only do this for "real" resources (not  mix ones)
  if (isActualResource) {
    checkWitRC(witAddOperation(witRun(),enableOp.c_str()));
    checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
    RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
    checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));

    // connect parts and operations.
    checkWitRC(witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
    checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str()));
    
    //add an epsilon enable cost
    float * execPenalty = floatToFloatStar(0.01f);
    checkWitRC(witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),execPenalty));
    delete [] execPenalty;

  }
   
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),benchRes.c_str(),benchAppData));
  
  
  

  std::string baseName = baseResourceName(resourceAttributeVector);
  resourceNames_.insert(baseName);
  for (unsigned int i=0; i<resourceAttributeVector.size(); i++) {
    const std::string & resourceID = getResourceIdentifierNames()[i];
    const std::string & resourceValue = resourceAttributeVector.at(i);
    resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
  }
  



}
void RCPproblem::addSimpleResource(const std::vector<std::string> &resourceAttributeVector)
{
  // It adds a "working" part and an aquire operation. 

  std::string workingRes = workingResourceName(resourceAttributeVector);
  std::string acquireOp = acquireResourceOperationName(resourceAttributeVector);
 
  
  int np = getNPeriods();
  // Add parts and operations
  checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
  
  checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),workingRes.c_str()));
  //  checkWitRC(witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),0,WitTRUE));
  // dpc --- test for MRP
  //checkWitRC(witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE));

  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));


  std::string baseName = baseResourceName(resourceAttributeVector);
  resourceNames_.insert(baseName);
  for (unsigned int i=0; i<resourceAttributeVector.size(); i++) {
    const std::string & resourceID = getResourceIdentifierNames()[i];
    const std::string & resourceValue = resourceAttributeVector.at(i);
    resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
  }
 }
 void RCPproblem::setSimpleResourceAcquireAppData(const std::vector<std::string> &resourceAttributeVector, float acquireTime)
{
      RCPresourceAppData * appData;
      std::string workingRes = workingResourceName(resourceAttributeVector);
      checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
      appData->setResourceAcquireAppData(acquireTime);
}

 void RCPproblem::setSimpleResourceAcquireAversion(std::vector<std::string> resourceAttributeVector, float aversion) {
  std::string workingRes = workingResourceName(resourceAttributeVector);
  std::string acquireOp = acquireResourceOperationName(resourceAttributeVector);
  //the bop entry has to be 0
  int bopEntryIndex=0;
  checkWitRC(witSetBopEntryExpAversion(witRun(),acquireOp.c_str(),bopEntryIndex,aversion));
  
 
 }

void RCPproblem::addSkillGroupResource(const std::vector<std::vector<std::string> > &skillGroup)
{
  // It adds a skill group part. It also creates the appropriate
  // operations to turn it into the appropriate "working" part
  
 
  
  int np = getNPeriods();
  // Add parts and operations
  std::string skillGroupName = createSkillGroupName(skillGroup);

  checkWitRC(witAddPart(witRun(),skillGroupName.c_str(),WitCAPACITY));
  
  int numSkills = skillGroup.size();
  for (int i=0; i<numSkills; i++) {
     //extract the individual skill group
     std::vector<std::string> resourceAttributeVector = skillGroup[i];
     std::string workingRes = workingResourceName(resourceAttributeVector);
     
     //make sure we actually have this working part
     witBoolean exists;
     checkWitRC(witGetPartExists(witRun(), workingRes.c_str(), &exists));
     
     //add it. Nothing requires it though.
     if (!exists)
      checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
     
     //make a name for the "translation" operation
     std::string opName = skillGroupToWorkingOperationName(skillGroup,resourceAttributeVector);
     checkWitRC(witAddOperation(witRun(),opName.c_str()));
     checkWitRC(witAddBopEntry(witRun(),opName.c_str(),workingRes.c_str()));
     checkWitRC(witAddBomEntry(witRun(),opName.c_str(),skillGroupName.c_str()));
  }
}
std::string RCPproblem::skillGroupToWorkingOperationName(std::vector<std::vector<std::string> > skillGroup, std::vector<std::string> resourceAttributeVector) {
  std::string skillGroupName = createSkillGroupName(skillGroup);
  std::string workingRes = workingResourceName(resourceAttributeVector);
  std::string retval = skillGroupName+ ":to:" + workingRes;
  return retval;

}
std::string RCPproblem::createSkillGroupName(std::vector<std::vector<std::string> > skillGroup) {
  int skillGroupSize = skillGroup.size();
  std::string retVal="";
  for (int i=0; i<skillGroupSize; i++) {
     std::vector<std::string> individual = skillGroup[i];
     std::string baseName = baseResourceName(individual);
     retVal=retVal+"["+baseName+"]";
  }
  return retVal;
}

void RCPproblem::addResourceAcquire(const std::vector<std::string> &resourceAttributeVector, std::string eName)
{
    std::string acquireWorkingRes = acquireWorkingResourceName(resourceAttributeVector);
    std::string acquireOp  = acquireWorkingResourceName(resourceAttributeVector);
    std::string workingRes = workingResourceName(resourceAttributeVector);
      
    if (!witPartExists(acquireWorkingRes)) {
        // Add parts and operations  
        checkWitRC(witAddPart(witRun(),acquireWorkingRes.c_str(),WitCAPACITY));
        checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
        float * execPenalty = floatToFloatStar(0.05f);
        checkWitRC(witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),execPenalty));
        delete [] execPenalty;
        // connect parts and operations.
        checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),acquireWorkingRes.c_str()));
          
     
    }
    //Add it as a substitute to the appropriate bom on the engagement
    std::string theEngagement = engagementName(eName);
    int bomIndex;
    int nBoms;
    //figure out which bomIndex this working resource is attached with to the engagement
    checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBoms));
  
    int bei;
    for ( bei=0; bei<nBoms; bei++ ) {
      char * consPartFromWit;
      checkWitRC(witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),bei,&consPartFromWit));
      if(workingRes==consPartFromWit) {
          bomIndex=bei;
      }
      checkWitRC(witFree(consPartFromWit));
    }
    checkWitRC(witAddSubsBomEntry(witRun(), theEngagement.c_str(), bomIndex, acquireWorkingRes.c_str())); 
    float * subsCost = floatToFloatStar(1.0f);
    checkWitRC(witSetSubsBomEntryObj1SubCost(witRun(),theEngagement.c_str(),bomIndex,0,subsCost));
    checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),bomIndex,0,100000000.0f));
    //checkWitRC(witFree(subsCost));
    delete [] subsCost;

}

void RCPproblem::addResource(const std::vector<std::string> &resourceAttributeVector)
{
  std::string acquireOp = acquireResourceOperationName(resourceAttributeVector);
  std::string benchRes = benchResourceName(resourceAttributeVector);
  std::string enableOp = enableResourceOperationName(resourceAttributeVector);
  std::string workingRes = workingResourceName(resourceAttributeVector);
  std::string scrapRes = scrapResourceName(resourceAttributeVector);
  std::string enableScrapOp = enableScrapResourceName(resourceAttributeVector);
  
  int np = getNPeriods();
  
  // Add parts and operations
  checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
  checkWitRC(witAddPart(witRun(),benchRes.c_str(),WitMATERIAL));
  checkWitRC(witAddOperation(witRun(),enableOp.c_str()));
  checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),scrapRes.c_str()));
  checkWitRC(witAddPart(witRun(),scrapRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),enableScrapOp.c_str()));
  
  // Add appData for working resource
  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));
  
  //Set the scrap cost for the working part to a large quantity
  {
    float * scrapCost = floatToFloatStar(1000000.0f);
    checkWitRC(witSetPartObj1ScrapCost(witRun(),workingRes.c_str(),scrapCost));
    delete [] scrapCost;
  }

  //Set the scrap cost for the bench part to a large quantity
  {
    float * scrapCost = floatToFloatStar(1000000.0f);
    checkWitRC(witSetPartObj1ScrapCost(witRun(),benchRes.c_str(),scrapCost));
    delete [] scrapCost;
  }

  
  // connect parts and operations.
  checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str()));
  //  checkWitRC(witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),0,WitTRUE));
  
  // dpc --- test for MRP
  checkWitRC(witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE));
  
  checkWitRC(witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
  checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str()));
  //  checkWitRC(witSetBopEntrySelForDel(witRun(),enableOp.c_str(),0,WitTRUE));
  // For MRP calculation and priorityPlan, set expAllowed to false;  doesn't impact optimalPlan
  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE));  
  
  if (np>1){
    checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
    
    float * offsetVec = floatToFloatStar(-1.f);
    checkWitRC(witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec));
    delete [] offsetVec;
    checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE));
    checkWitRC(witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2));
  }
  
  // connect up the release side of the model
  checkWitRC(witAddBomEntry(witRun(),scrapRes.c_str(),benchRes.c_str()));
  checkWitRC(witAddBomEntry(witRun(),enableScrapOp.c_str(),scrapRes.c_str()));
  checkWitRC(witAddBopEntry(witRun(),enableScrapOp.c_str(),workingRes.c_str()));
  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableScrapOp.c_str(),0,WitFALSE));

  std::string baseName = baseResourceName(resourceAttributeVector);
  resourceNames_.insert(baseName);
  //jobToResourceNames_[jobRole].insert(baseName);
  //skillToResourceNames_[skillSet].insert(baseName);
  //lobToResourceNames_[LOB].insert(baseName);
  //sourceToResourceNames_[source].insert(baseName);
  //locToResourceNames_[locName].insert(baseName);
  for (unsigned int i=0; i<resourceAttributeVector.size(); i++) {
    const std::string & resourceID = getResourceIdentifierNames()[i];
    const std::string & resourceValue = resourceAttributeVector.at(i);
    resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
  }
  //resourceIdToResourceNames_["jobRole"][jobRole].insert(baseName);
  //resourceIdToResourceNames_["skillSet"][skillSet].insert(baseName);
  //resourceIdToResourceNames_["LOB"][LOB].insert(baseName);
  //resourceIdToResourceNames_["source"][source].insert(baseName);
  //resourceIdToResourceNames_["locName"][locName].insert(baseName);
}
void RCPproblem::addFlexibleDemand(const std::vector<std::string> &resourceIdentifierValues, std::string engName, int period, float quantity) {

  std::string theEngagement = engagementName(engName);
  
  
  
  
  //if we haven't already done this....
  if (!witPartExists(theEngagement.c_str())) {
    checkWitRC(witAddPart(witRun(),theEngagement.c_str(),WitCAPACITY));
    checkWitRC(witAddDemand(witRun(),theEngagement.c_str(),theEngagement.c_str()));
    checkWitRC(witAddOperation(witRun(),theEngagement.c_str()));
    checkWitRC(witAddBopEntry(witRun(),theEngagement.c_str(),theEngagement.c_str()));
 
    //now attach the demand to the "working" part
    std::string workingResource = workingResourceName(resourceIdentifierValues);
    checkWitRC(witAddBomEntry(witRun(),theEngagement.c_str(),workingResource.c_str()));
    
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(0);
    int bomIndex;
    checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&bomIndex));
    checkWitRC(witSetBomEntryAppData(witRun(),theEngagement.c_str(),bomIndex-1,appData)); 
  
    //now attach the "acquire working" as a substitute
    addResourceAcquire(resourceIdentifierValues,engName); 
   
    engagementNames_.insert(theEngagement);
    
    std::string bn = bomName(engName,resourceIdentifierValues);
    bomNames_.insert(bn);
    mapEngagementToConsumedResources_[theEngagement].push_back(resourceIdentifierValues);

  }
  //now set the quantity and period for the demand
  float * demandVol;
  checkWitRC(witGetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),&demandVol));
  demandVol[period] = demandVol[period]+quantity;
  checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol));
  float * reward = floatToFloatStar(10.f);
  checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),reward));
  //checkWitRC(witFree(reward));
  delete [] reward;

  //force the demand to be met in the demanded period by setting the execvol equal to the demand
  //in the period

  checkWitRC(witSetOperationExecBounds(witRun(),theEngagement.c_str(),demandVol,demandVol,NULL));
  checkWitRC(witFree(demandVol)); 
 
  
 
  
 
}

bool RCPproblem::resourceExists(const std::vector<std::string> &resourceAttributeVector)const 
{
  std::string witName = benchResourceName(resourceAttributeVector);
  return witPartExists(witName);
}
bool RCPproblem::workingResourceExists(const std::vector<std::string> &resourceAttributeVector)const 
{
  std::string witName = workingResourceName(resourceAttributeVector);
  return witPartExists(witName);
}

// Return list of names.
// returned value names[i][j]
//   where i=[0,numberOfResourceIdentifiers]
//         j=[0,numberOfResources]
void RCPproblem::getResourceNames( std::vector<RCPvectorString> & names )const
{
  names.clear();
  
  // loop once for each resource
  std::set<std::string>::const_iterator r;
  for ( r=resourceNames_.begin(); r!=resourceNames_.end(); ++r) {
    
    const std::string & baseName = *r;
    RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
    
    names.push_back( resourceIdValues );
  }
}

void RCPproblem::getSkillGroupNames( std::vector<std::vector<std::vector<std::string> > > & names )const
{
   names= multipleSkillResourceNames_;
}

const std::vector<std::string> & RCPproblem::getResourceIdentifierNames() const
{
  return resourceIdentifierNames_;
}

void RCPproblem::addResourceIdentifierName(const std::string & resourceIdentifierName )
{
  int nResIdentNames = resourceNames_.size();
  
  // resource identifier names must be specified before adding resources.
  // make sure this is the case.
  assert( nResIdentNames == 0 );
  
  resourceIdentifierNames_.push_back(resourceIdentifierName);
  mapResourceIdentifierNameToSubsPriority_[resourceIdentifierName]=0;  //setting priority default value to zero
  
}

bool RCPproblem::resourceIdentifierNameExists( const std::string & name ) const
{
  return mapResourceIdentifierNameToSubsPriority_.find(name)!=mapResourceIdentifierNameToSubsPriority_.end();
}


void RCPproblem::setResourceIdentifierPriority(const std::string & identifierName, int priority )
{
  assert( resourceIdentifierNameExists(identifierName) );
  mapResourceIdentifierNameToSubsPriority_[identifierName]=priority;
}
int RCPproblem::getResourceIdentifierPriority(const std::string & identifierName ) const
{
  assert( resourceIdentifierNameExists(identifierName) );
  int retVal = mapResourceIdentifierNameToSubsPriority_.find(identifierName)->second;
  return retVal;
}


std::vector<std::string> RCPproblem::getResourceIdentifiersSortedByPriority() const
{
  std::vector<std::string> retVal;

  RCPsortStringIntPairSet sortedSet;
  std::vector<std::string> idNames = getResourceIdentifierNames();

  // Loop through each resourceIdName and create a sorted set
  unsigned int i;
  for ( i=0; i<idNames.size(); ++i ) {
    std::string idName = idNames[i];
    int priority = getResourceIdentifierPriority(idName);
    RCPstringIntPair pair(idName,priority);
    sortedSet.insert(pair);
  }

  // Loop through sorted set and creat return vector
  RCPsortStringIntPairSetConstIter it;
  for ( it=sortedSet.begin(); it!=sortedSet.end(); ++it ) {
    std::string idName = it->first;
    retVal.push_back(idName);
  }

  return retVal;
}



RCPvectorString RCPproblem::resourceIdentifierValuesFromResourceName(const std::string &baseResourceName ) const
{
  RCPvectorString retVal;
  for (unsigned int i=0; i<getResourceIdentifierNames().size(); ++i ) {
    std::string value = resourceIdentifierValueFromResourceName(baseResourceName, i);
    retVal.push_back(value);
  }
  return retVal;
}

std::string RCPproblem::resourceIdentifierValueFromResourceName(const std::string &resourcename, int which)const
{
  int last = getResourceIdentifierNames().size()-1;
  std::string retVal;
  if (which!=last) {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    std::string nextone = getResourceIdentifierNames()[which+1];
    nextone = " " +nextone + ": ";
    retVal = textBetween(resourcename, thisone, nextone);
  }
  else {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    retVal = textAfter(resourcename, thisone);
  }
  return retVal;
}


void RCPproblem::setResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float supplyQuantity)
{
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
    appData->setSupplyAppData(period, supplyQuantity);
}
void RCPproblem::setFlexibleResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues,  float *supplyQuantity)
{
    //we don't use appdata
    std::string benchRes = benchResourceName(resourceIdentifierValues);
    checkWitRC(witSetPartSupplyVol(witRun(),benchRes.c_str(),supplyQuantity));
}

void RCPproblem::setSimpleResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues,  float *supplyQuantity)
{
    //we don't use appdata
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),supplyQuantity));
}



void RCPproblem::setResourceMrpQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float mrpGrossQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setMrpAppData(period, mrpGrossQuantity);
}



void RCPproblem::setResourceGapQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float gapQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setGapAppData(period, gapQuantity);

}




void RCPproblem::setResourceGlutQuantity(
                                         const std::vector<std::string> &resourceIdentifierValues,
                                         int period,
                                         float glutQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setGlutAppData(period, glutQuantity);
}

void RCPproblem::setFlexibleResourceGapQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float gapQuantity)
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData));
  appData->setGapAppData(period, gapQuantity);
}




void RCPproblem::setFlexibleResourceGlutQuantity(
                                         const std::vector<std::string> &resourceIdentifierValues,
                                         int period,
                                         float glutQuantity)
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData));
  
  //need to accumulate gaps, since we are aggregating flex mix resources back to
  //their primary
  std::vector<float> priorGlut=appData->getGlutAppData();
  float newGlut = priorGlut.at(period)+glutQuantity;
  appData->setGlutAppData(period, newGlut);
}
void RCPproblem::setSkillGroupGlutQuantity(
                                         const std::vector<std::vector<std::string> > &skillGroup,
                                         int period,
                                         float glutQuantity)
{
  std::string skillGroupName = createSkillGroupName(skillGroup);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),skillGroupName.c_str(),(void**)&appData));
  appData->setGlutAppData(period, glutQuantity);
}

  std::vector<float> RCPproblem::getSkillGroupGlutQuantity(std::vector<std::vector<std::string> > skillGroup)
{
  std::string skillGroupName = createSkillGroupName(skillGroup);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),skillGroupName.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> RCPproblem::getResourceGlutQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> RCPproblem::getResourceGapQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  
  return(appData->getGapAppData());
  
}

std::vector<float> RCPproblem::getFlexibleResourceGlutQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> RCPproblem::getFlexibleResourceGapQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData));
  return(appData->getGapAppData());
  
}
#if 0

std::vector<float> RCPproblem::getResourceGlutQuantity(
                                                       const std::string & jobRole,
                                                       const std::string & skillSet,
                                                       const std::string & LOB,
                                                       const std::string & source,
                                                       const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> RCPproblem::getResourceGlutQuantity(
                                                       const std::string & jobRole,
                                                       const std::string & skillSet,
                                                       const std::string & LOB,
                                                       const std::string & source,
                                                       const std::string & region,
                                                       const std::string & country,
                                                       const std::string & city,
                                                       const std::string & reportingUnit,
                                                       const std::string & band,
                                                       const std::string & global,
                                                       const std::string & competency,
                                                       const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}
#endif


void RCPproblem::setResourceWorkingQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float workingQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setWorkingAppData(period, workingQuantity);
}



void RCPproblem::setResourceAcquireQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float acquireQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setAcquireAppData(period, acquireQuantity);
}


void RCPproblem::setResourceReleaseQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float releaseQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setReleaseAppData(period, releaseQuantity);
}


void RCPproblem::setResourceBenchQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float benchQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setBenchAppData(period, benchQuantity);
}







void RCPproblem::setBenchResourceSupplyQuantity(
                                                const std::vector<std::string> &resourceAttributeVector,
                                                int period,
                                                float supplyQuantity)
{
  std::string benchRes = benchResourceName(resourceAttributeVector);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    benchRes,
    period, supplyQuantity );
}




std::vector<float> RCPproblem::getResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getSupplyAppData());
}
float * RCPproblem::getFlexibleResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
 
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  int n = getNPeriods();
  float * supply;
  checkWitRC(witGetPartSupplyVol(mutableWitRun(),benchRes.c_str(),&supply));
  
  return supply;
}
float * RCPproblem::getSimpleResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
 
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  int n = getNPeriods();
  float * supply;
  checkWitRC(witGetPartSupplyVol(mutableWitRun(),workingRes.c_str(),&supply));
  
  return supply;
}

std::vector<float> RCPproblem::getResourceReleaseQuantity(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getReleaseAppData());
}


std::vector<float> RCPproblem::getResourceMrpQuantity(
                                                      const std::vector<std::string> &resourceAttributeVector)const
{
  std::string workingRes = workingResourceName(resourceAttributeVector);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getMrpAppData());
  
}

std::vector<float> RCPproblem::getResourceBenchQuantity(
                                                        const std::vector<std::string> &resourceAttributeVector)const
{
  std::string workingRes = workingResourceName(resourceAttributeVector);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getBenchAppData());
}



std::vector<float> RCPproblem::getResourceAcquireQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getAcquireAppData());
}


std::vector<float> RCPproblem::getResourceWorkingQuantity(
                                                          const std::vector<std::string> &resourceIdentifierValues )const 
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getWorkingAppData());
}
std::vector<float> RCPproblem::getOptimalWorkingQuantity(
                                                         const std::vector<std::string> &resourceIdentifierValues )const 
{
  std::string opName = enableResourceOperationName(resourceIdentifierValues);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}

std::vector<float> RCPproblem::getOptimalBenchQuantity(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}


void RCPproblem::setResourceAcquireCost(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        float acquireCost)
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * acv = floatToFloatStar(acquireCost);
  checkWitRC(witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv));
  delete [] acv;
}


void RCPproblem::setResourceAcquireTime(const std::vector<std::string> &resourceIdentifierValues, float acquireTime)
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float invacquireTime = -acquireTime; //offset should be negative so that
  //the resource is available after it's acquired
  float * atv = floatToFloatStar(invacquireTime);
  checkWitRC(witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv));
  delete [] atv;
}


void RCPproblem::setResourceReleaseTime(const std::vector<std::string>&resourceIdentifierValues, float releaseTime)
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rtv = floatToFloatStar(releaseTime);
  checkWitRC(witSetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,rtv));
  delete [] rtv;
}


void RCPproblem::setResourceReleaseCost(const std::vector<std::string> &resourceIdentifierValues, float releaseCost)
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues); 
  float * rcv = floatToFloatStar(releaseCost);
  checkWitRC(witSetOperationObj1ExecCost(witRun(),scrapRes.c_str(),rcv));
  delete [] rcv;
}




std::vector<float> RCPproblem::getResourceFixedCost(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartObj1StockCost,benchRes);
}



void RCPproblem::setResourceFixedCost(
                                      const std::vector<std::string> &resourceIdentifierValues,
                                      int   period,
                                      float fixedCost)
{
  std::string benchOp = benchResourceName(resourceIdentifierValues);
  std::string enableOp = enableResourceOperationName(resourceIdentifierValues);
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);  
  std::string enableScrapOp = enableScrapResourceName(resourceIdentifierValues);
  float * stockcost;
  checkWitRC(witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost));
  stockcost[period] = fixedCost;
  checkWitRC(witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost));
  checkWitRC(witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost));
  checkWitRC(witSetPartObj1ScrapCost(witRun(),scrapRes.c_str(),stockcost));
  checkWitRC(witSetOperationObj1ExecCost(witRun(),enableScrapOp.c_str(),stockcost));

  checkWitRC(witFree(stockcost));
}



float RCPproblem::getResourceAcquireCost(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * acv;
  checkWitRC(witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv));
  float returnVal = acv[0];
  checkWitRC(witFree(acv));
  return returnVal;
}


int RCPproblem::getIndexOfAttribute(std::string resourceAttribute) const
{
  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  int which=-1;
  for (unsigned int i=0; i<resourceIdentifierNames.size(); i++) {
    if (resourceIdentifierNames.at(i)==resourceAttribute) {
        which = i;
        break;
    }
  }
  return which;


}
float RCPproblem::getResourceAcquireTime(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * atv;
  checkWitRC(witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv));
  float returnVal = atv[0];
  checkWitRC(witFree(atv));
  return returnVal;
}


float RCPproblem::getResourceReleaseCost(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rcv;
  checkWitRC(witGetOperationObj1ExecCost(mutableWitRun(),scrapRes.c_str(),&rcv));
  float returnVal = rcv[0];
  checkWitRC(witFree(rcv));
  return returnVal;
}



float RCPproblem::getResourceReleaseTime(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rtv;
  checkWitRC(witGetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,&rtv));
  float returnVal = rtv[0];
  checkWitRC(witFree(rtv));
  return returnVal;
} 

std::vector<float> RCPproblem::getDemandShipReward(const std::string & engName)const
{
  std::string witDemandName = engagementName(engName);
  return witGetDemandAttribute(witGetDemandObj1ShipReward,witDemandName,witDemandName);
}


std::vector<float> RCPproblem::getResourceMRPGrossQuantity(
                                                           const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  //return witGetNameAttribute(witGetPartReqVol,workingRes);
  float *retVal;
  checkWitRC(witGetPartMrpConsVol(mutableWitRun(),workingRes.c_str(),&retVal));
  std::vector<float> retVec;
  for (int i=0; i<getNPeriods(); i++) {
    retVec.push_back(retVal[i]);
  }
  witFree(retVal);
  return retVec;
}

void RCPproblem::addReleaseLeadtimeStructure(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  int releaseTime = (int) getResourceReleaseTime(resourceIdentifierValues);  
  float * rtVec = floatToFloatStar((float)releaseTime);
  checkWitRC(witSetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,rtVec));
  delete [] rtVec;
  
  int i;
  int np = getNPeriods();
  if (releaseTime > np)
    releaseTime = np;
  for (i=1; i<=releaseTime; i++){
    checkWitRC(witAddBopEntry(mutableWitRun(),scrapRes.c_str(),scrapRes.c_str()));
    float * offsetVec = floatToFloatStar((float)i);
    checkWitRC(witSetBopEntryOffset(mutableWitRun(),scrapRes.c_str(),i-1,offsetVec));
    delete [] offsetVec;
  }
}
//----------------------
// Methods for boms.
//----------------------


void RCPproblem::addBom(const std::string & engagementName, 
                        const std::vector<std::string> &resourceIdentifierValues)
{ 
  assert( !bomExists(engagementName,resourceIdentifierValues) );
  std::string bn = bomName(engagementName,resourceIdentifierValues);
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  
  // nothing to do here. 
  // wit bomEntries are added when the usage period is known
  
  bomNames_.insert(bn);
  mapEngagementToConsumedResources_[engagementName].push_back(resourceIdentifierValues);
}

//----------------------
// Methods for boms.
//----------------------


void RCPproblem::updateEngagementBom(const std::string & engName, 
                        const std::vector<std::string> &resourceIdentifierValues,int period,float quantity,int mustDo)
{ 
  std::string theEngagement = engagementName(engName);
  std::string workingRes = workingResourceName(resourceIdentifierValues);

  //set the offset and quantity
  //Each (relative) period gets its own bom arc. The bom arc has
  //the offset set to -period for all periods in the time horizon. 
  //It also has the consrate = quantity for all periods in the time 
  //horizon.
  //mustDo indicates whether or not we need to attach to the "panic" object
  
  int bomEntries;
  checkWitRC(witAddBomEntry(witRun(),theEngagement.c_str(), workingRes.c_str()));
  checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(), &bomEntries));

  float *consrate = floatToFloatStar(quantity);  
  float * offset = floatToFloatStar(-period);
  checkWitRC(witSetBomEntryOffset(witRun(),theEngagement.c_str(),bomEntries-1,offset));
  witSetBomEntryConsRate(witRun(),theEngagement.c_str(),bomEntries-1,consrate);
  mapEngagementToConsumedResources_[engName].push_back(resourceIdentifierValues);
  delete [] consrate;
  delete [] offset;
  
  if (mustDo) {
     //create the panic part if necessary
     witBoolean exists;
     checkWitRC(witGetPartExists(witRun(),"PANIC",&exists));
     if (!exists) {
        checkWitRC(witAddPart(witRun(),"PANIC",WitCAPACITY));
        checkWitRC(witAddOperation(witRun(),"MAKE PANIC"));
        checkWitRC(witAddBopEntry(witRun(),"MAKE PANIC","PANIC"));
     }
     checkWitRC(witAddSubsBomEntry(witRun(),theEngagement.c_str(),bomEntries-1,"PANIC"));
  
  }
}





void RCPproblem::setBomUsageQuantity(
                                     const std::string & engName, 
                                     const std::vector<std::string> &resourceIdentifierValues,
                                     int period, 
                                     float usageQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string engagement = engagementName(engName);
  
  // Get the index for the bom connecting the operation to the part for this period
  int bomIndex = getBomEntryIndex(engagement,workingRes,period);
  
  // if the bomEntry was not found then add it.
  if ( bomIndex==-1 ) {
    // The RCP BOM must have already been added.
    assert( bomExists(engName,resourceIdentifierValues) );
    
    checkWitRC(witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex));
    checkWitRC(witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str()));
    
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(period);
    checkWitRC(witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData));
  }
  
  // set the RCP's usageQuantity to consRate
  witSetArcAttribute(witSetBomEntryConsRate,engagement,bomIndex,usageQuantity);
  
  
  // The BOM entries offset is set just before wit*Implode.
  // The offset will be set to engagementDuration-period
  
}


bool RCPproblem::bomExists(
                           const std::string & engagementName, 
                           const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string bn = bomName(engagementName,resourceIdentifierValues);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}




std::vector<RCPvectorString> RCPproblem::getEngagementConsumedResources(const std::string & engagementName) const
{
  std::vector<RCPvectorString> retVal;
  std::map<std::string,RCPvectorVectorString>::const_iterator it;
  it=mapEngagementToConsumedResources_.find(engagementName);
  if ( it != mapEngagementToConsumedResources_.end() )
    retVal = it->second;
  return retVal;
}

void RCPproblem::getBomNames(std::vector<std::string> &engagements, std::vector<RCPvectorString> & resourceNames )const
{
  resourceNames.clear();
  engagements.clear();
  
  // loop once for each bom
  std::set<std::string>::const_iterator r;
  for ( r=bomNames_.begin(); r!=bomNames_.end(); ++r) {
    const std::string & baseName = *r;
    
    // do the engagements 
    const std::string engagementName = engagementFromBomName(baseName);
    engagements.push_back(engagementName);
    
    RCPvectorString bomIdValues = resourceIdentifierValuesFromResourceName(baseName);
    
    resourceNames.push_back( bomIdValues );
  }
}


std::vector<float> RCPproblem::getBomUsageQuantity(const std::string & engName,  
                                                   const std::vector<std::string> &resourceIdentifierValues)const
{
  std::vector<float> retVal;
  
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string theEngagement = engagementName(engName);
  
  int np = getNPeriods();
  
  int t;
  for (t=0; t<np; ++t) {
    //int bomIndex = getBomEntryIndex(theEngagement,workingRes,t);
    retVal.push_back( getBomUsageQuantity(engName,resourceIdentifierValues,t) );
  }
  
  return retVal;
}

float RCPproblem::getBomUsageQuantity(const std::string & engName,  
                                      const std::vector<std::string> &resourceIdentifierValues,int period)const
{
  float retVal;
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string theEngagement = engagementName(engName);
  
  int bomIndex = getBomEntryIndex(theEngagement,workingRes,period);
  if ( bomIndex==-1 ) {
    // A bomEntry does not exist for this period
    retVal = 0.0f;
  }
  else {
    std::vector<float> consVol = 
      witGetArcAttribute(witGetBomEntryConsRate,theEngagement,bomIndex);
    retVal = consVol[0];    
  }
  
  return retVal;
}


//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
void RCPproblem::setBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int sub)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  appData->setSub(resourceIdName,sub);
}
//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData



// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  return appData->getSub(resourceIdName);
}


//-----------------------------------------------------------------------------

//-------------------------------------------------------------------------------------

void RCPproblem::setBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int match)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  appData->setMatch(resourceIdName,match);
}
// Method for setting bomAppData match attributes.


// Method for setting bomAppData matchstitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  return appData->getMatch(resourceIdName);
}



//----------------------
// Methods for handling resource substitution in a common way
//----------------------
void RCPproblem::addSubs(const std::string & resourceIdName, const std::string & from, const std::string & to )
{
  RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
  assert( !subsExists(resourceIdName,from,to) );
  RCPbaseSubs subs(from,to);
  subCollection[from][to]=subs;
}
void RCPproblem::setSubsCost(const std::string & resourceIdName, const std::string & from, const std::string & to, float cost )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setCost(cost);
}
void RCPproblem::setSubsLeadTime(const std::string & resourceIdName, const std::string & from, const std::string & to, float leadTime )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setLeadTime(leadTime);
} 
void RCPproblem::setSubsAversion(const std::string & resourceIdName, const std::string & from, const std::string & to, int aversion )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setAversion(aversion);
}
bool RCPproblem::subsExists(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  bool retVal=false;
  
  // if resourceIdName does not exist in resourceIdToSubs_ collection, then return that substitute does not exist
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  if( subCollIt == resourceIdToSubs_.end() )
    return retVal;
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  // does the fromSkill exist
  RCPmapMapStringToSubs::const_iterator itFrom = subCollection.find(from);
  if ( itFrom!=subCollection.end() ) {
    
    // the fromSkill exists, now see if this fromSkill has the toSkill
    RCPmapStringToSubs::const_iterator itTo = itFrom->second.find(to);
    if ( itTo!=itFrom->second.end() ) 
      retVal=true;
  }
  return retVal;
}

void RCPproblem::getSubsNames(const std::string & resourceIdName, std::vector<std::string> & froms, std::vector<std::string> & tos)const
{
  froms.clear();
  tos.clear();
  
  // if resourceIdName does not exist in resourceIdToSubs_ collection, then return empty vectors
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  if( subCollIt == resourceIdToSubs_.end() )
    return;
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  // loop once for each fromSkill
  RCPmapMapStringToSubs::const_iterator itFrom;
  for (itFrom=subCollection.begin(); itFrom!=subCollection.end(); ++itFrom) {
    
    // loop once for each toSkill
    RCPmapStringToSubs::const_iterator itTo;
    for (itTo=itFrom->second.begin(); itTo!=itFrom->second.end(); ++itTo ) {
      
      // get skillSubs and append from and to skills to returned vectors
      const RCPbaseSubs & subs  = (*itTo).second;
      froms.push_back(subs.getFromName() );
      tos.push_back(subs.getToName() );
      
    }
  }
}
float RCPproblem::getSubsCost(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  return subs.getCost();
}
float RCPproblem::getSubsLeadTime(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  return subs.getLeadTime();
}

// Get baseSubs from collection class
RCPbaseSubs & RCPproblem::getSubs(const std::string & resourceIdName, const std::string & from, const std::string & to ) 
{
  RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
  assert( subsExists(resourceIdName,from,to) );
  RCPmapStringToSubs & tos = subCollection.find(from)->second;
  RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}
const RCPbaseSubs & RCPproblem::getSubs(const std::string & resourceIdName, const std::string & from, const std::string & to ) const
{
  assert( subsExists(resourceIdName,from,to) );
  
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  assert( subCollIt != resourceIdToSubs_.end() );
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  const RCPmapStringToSubs & tos = subCollection.find(from)->second;
  const RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}

// given 2 sets return their union
void RCPproblem::unionCollectionOfStrings(
                                          const RCPcollectionOfStrings & set1,
                                          const RCPcollectionOfStrings & set2,
                                          RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_union(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}
// given 2 sets return their intersection
void RCPproblem::intersectionCollectionOfStrings(
                                                 const RCPcollectionOfStrings & set1,
                                                 const RCPcollectionOfStrings & set2,
                                                 RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_intersection(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}

void RCPproblem::removeIneligibleResources(
                                           RCPcollectionOfStrings & currentToResources,
                                           int subAllowed,
                                           const std::string & resourceIdName,
                                           const std::string & fromResourceAttribute )
{  
  
  
  //find the set of possible values in the given resourceIdName field
  const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames = resourceIdToResourceNames_[resourceIdName];
  
  
  RCPcollectionOfStrings unionSet1;
  
  //if substitution is allowed on this field...
  if ( subAllowed ) {
    //find the set of all {from/to} substitutes specified for the given resourceIdName
    const RCPmapMapStringToSubs & attributeSubs = resourceIdToSubs_[resourceIdName];

    //there were no substitutes specified for this field
    

    if (attributeSubs.find(fromResourceAttribute)==attributeSubs.end()) {
      #if 0
      std::cerr <<"WARNING: Substitute requested but no substitutes for given resource value provided. " <<std::endl
        <<"   resource ID name   : " << resourceIdName <<std::endl
        <<"   resource Value: " << fromResourceAttribute <<std::endl ;
      #endif
        
       //it is AS IF we require an exact match. So do it.
       
       // Are there any resources with the attribute value? If no, then just return
       if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 
    
       // Get all resources whose attribute value matches
       const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
       // Intersect resource whose attribute matches with set passed into this method
       RCPcollectionOfStrings intersection;
       intersectionCollectionOfStrings(currentToResources,resWithMatch,intersection);
    
       // update set passed into this method with insection just computed
       currentToResources = intersection;        
        
       return;
    }

    
    // This will be the set we build up
    RCPcollectionOfStrings unionSet;
    
    // this bom entry had a particular "from" specifed. Look for the legal substitutes
    // get toResources that can substitute for fromResources
    const RCPmapStringToSubs & toResources = attributeSubs.find(fromResourceAttribute)->second;
    
    // loop over each toResource creating a collection of all resources that have the toResource.
    RCPmapStringToSubs::const_iterator toResourcesIt;
    
    // Get all resources whose attribute value matches exactly the specified (from) value
    const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
    for ( toResourcesIt=toResources.begin(); toResourcesIt!=toResources.end(); ++toResourcesIt ) {
      
      //What is the "to" resource attribute?
      std::string toResourceAttribute = toResourcesIt->first;
      
      // If there aren't any actual resources with to attribute then there is nothing to do
      if ( attributeToResourceNames.find(toResourceAttribute)==attributeToResourceNames.end() ) continue;
      
      // Get set of all resources that have toAttribute
      const RCPcollectionOfStrings & resWithToAttributes = attributeToResourceNames.find(toResourceAttribute)->second;
      
      
      //take the union of the current union with the substitute possibilities
      unionCollectionOfStrings(unionSet,resWithToAttributes,unionSet1);
      unionSet=unionSet1;
      
    } // end of for toResourcesIt loop
    
    //take the union of the current union with the direct matches
    unionCollectionOfStrings(unionSet,resWithMatch,unionSet1);
    
    
    // Take the intersection of unionSet1 and currentToResources storing result in intersectionSet
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,unionSet1,intersection);
    currentToResources=intersection;
  }
  else { // substitution is not specified for this resource Id name; just look at matches
    // Are there any resources with the attribute value? If no, then just return
    if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 
    
    // Get all resources whose attribute value matches
    const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
    // Intersect resource whose attribute matches with set passed into this method
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,resWithMatch,intersection);
    
    // update set passed into this method with insection just computed
    currentToResources = intersection;
  }
}
//--------------------------------------------------------------------------
// Add wit substitute arcs 
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
// Add wit substitute arcs 
//--------------------------------------------------------------------------
void RCPproblem::addSubsArcsToWitModel04Feb(RCPoperationBomSubBomIndices & subBomsAdded )
{
  int np = getNPeriods();
  
  // Get rcp boms
  std::vector<RCPvectorString> resourceNames;
  std::vector<std::string> engagementNames;
  getBomNames(engagementNames, resourceNames);
  // loop once for each rcp bom
  
  int numIdentifiers = getResourceIdentifierNames().size();
  unsigned int b;
  for ( b=0; b<resourceNames.size(); ++b ) {
    const RCPvectorString & fromResourceVector = resourceNames[b];
    
    
    // Name of wit part connected to bomEntry
    std::string workingRes = workingResourceName(fromResourceVector);
    
    // Name of wit operation connected to bomEntry
    std::string witEngagement = engagementName(engagementNames[b]);
    
    int opExists;
    checkWitRC(witGetOperationExists(mutableWitRun(),witEngagement.c_str(),&opExists));


    // Get the indices for the boms connecting the operation to the part
    std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
    
    
    // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
    // be added.  Need loop over bomEntries, because data files allow substitution rules to be different
    // by period.
    unsigned int be;
    for( be=0; be<bomIndices.size(); ++be ) {
    int bomIndex = bomIndices[be];  
        
    // get the period associated with this bomEntry
    RCPbomAppData * appData;
    checkWitRC(witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),bomIndex,(void**)&appData));
    int period = appData->getPeriod();
        
    // Collection that will be manipulated to contain all allowed substitute resources
    RCPcollectionOfStrings subsResources = resourceNames_;;
        
        
    // Does this bom allow jobRole substitution? 
        
    // Check each attribute to see if substitution is allowed
    for (unsigned int i=0; i<getResourceIdentifierNames().size(); i++) {
        std::string resourceIdName = getResourceIdentifierNames()[i];
        std::string resourceValue = fromResourceVector.at(i);
        int subAllowed = getBomSub(engagementNames[b], fromResourceVector, period, resourceIdName);
        int matching = getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
        if (matching)
        removeIneligibleResources(subsResources,subAllowed,resourceIdName,resourceValue);
    }
        
    // Remove resource connected to BOM from the set of substitute resources
    subsResources.erase(baseNameFromWorkingResourceName(workingRes));
        
    // loop once for each substitute resource
    RCPcollectionOfStrings::const_iterator subsResIt;
    for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::vector<std::string> toResourceVector(numIdentifiers);
        std::string subsResource = *subsResIt;
        unsigned int i;
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
        toResourceVector[i]=resourceIdentifierValueFromResourceName(subsResource, i);
        }
            
        // make sure substitute resource exists
        assert( resourceExists(toResourceVector ));
        
        // compute the substitute arcs cost and leadTime
        // subsCost is the sum of the substitute cost for each substituted attribute
        // subsLeadTime is the maximum of the lead time for each substituted attribute
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        int subsAversion = 0;
        
        
        //look over all the resource attributes and get substitute lead times and costs
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
        std::string fromValue = fromResourceVector.at(i);
        std::string toValue = toResourceVector.at(i);
        std::string resourceIdName = getResourceIdentifierNames()[i];
        int matching =  getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
        if (fromValue != toValue && matching==1) {
            //this particular resource attribute was substituted
            subsLeadTime = max( subsLeadTime, resourceIdToSubs_[resourceIdName][fromValue][toValue].getLeadTime());
            subsCost     = subsCost       +   resourceIdToSubs_[resourceIdName][fromValue][toValue].getCost();
            //DLG this is where we need to do something clever
            //to figure out the appropriate aversion from the COMBINATION
            //of aversions for each of the relevant Id fields.
            subsAversion = subsAversion + resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
        }
        }
        
        
        // Assert that the subs resource exists
        assert( resourceExists(toResourceVector) );
        
        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(toResourceVector);
        
        //std::cout <<"  resource: " <<workingRes <<std::endl;
        //std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
        
        
        // get some attributes of bomEntry that will have substitute added
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,witEngagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,witEngagement,bomIndex);
        
        // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
        // no shifting by lead time is needed
        
        
#ifndef NDEBUG
        {
        int t;
        for( t=1; t<np; ++t )
            assert(bomConsRate[0]==bomConsRate[t]);
        }
#endif
        
        // get index of substitute to be added
        int subIndex;
        checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex));
        
        // add substitute
        checkWitRC(witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() ));
        
        subBomsAdded[witEngagement][bomIndex].push_back(subIndex);
        
        // set substitute consRate
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,witEngagement,bomIndex,subIndex,bomConsRate);
        
        // compute substitute offset
        // JP, Donna, Dan: need to verify that offset is being set correctly.
        std::vector<float> subsOffset(np);
        int t;
        for (t=0; t<np; ++t) {
        subsOffset[t]=offset[t]-subsLeadTime;
        }
        
        // set substitutes offset
        witSetSubArcAttribute(witSetSubsBomEntryOffset,witEngagement,bomIndex,subIndex,subsOffset);
        
        // set cost of using substitute
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,witEngagement,bomIndex,subIndex,subsCost);
        
        // set aversion of using substitute
        checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),witEngagement.c_str(),bomIndex,subIndex,(float)subsAversion));      
    }  // end for subsResIt loop         
    }  // end of for be loop 

  } // end for b loop
}

void RCPproblem::addSubsArcsToWitModelFlexMix(RCPoperationBomSubBomIndices & subBomsAdded )
{
  int np = getNPeriods();
  
  // Get rcp boms
  std::vector<RCPvectorString> resourceNames;
  std::vector<std::string> engagementNames;
  getBomNames(engagementNames, resourceNames);
  // loop once for each rcp bom
  
  int numIdentifiers = getResourceIdentifierNames().size();
  unsigned int b;
  for ( b=0; b<resourceNames.size(); ++b ) {
    const RCPvectorString & fromResourceVector = resourceNames[b];
    
    
    // Name of wit part connected to bomEntry
    std::string workingRes = workingResourceName(fromResourceVector);
    
    // Name of wit operation connected to bomEntry
    std::string witEngagement = engagementName(engagementNames[b]);
    


    // Get the indices for the boms connecting the operation to the part
    std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
    
    
    // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
    // be added.  Need loop over bomEntries, because data files allow substitution rules to be different
    // by period.
    unsigned int be;
    for( be=0; be<bomIndices.size(); ++be ) {
    int bomIndex = bomIndices[be];  
        
    //for this model, there is essentially only one period
    int period = 0;
        
    // Collection that will be manipulated to contain all allowed substitute resources
    RCPcollectionOfStrings subsResources = resourceNames_;;
        
        
    // Does this bom allow jobRole substitution? 
        
    // Check each attribute to see if substitution is allowed
    for (unsigned int i=0; i<getResourceIdentifierNames().size(); i++) {
        std::string resourceIdName = getResourceIdentifierNames()[i];
        std::string resourceValue = fromResourceVector.at(i);
        int subAllowed = getBomSub(engagementNames[b], fromResourceVector, period, resourceIdName);
        int matching = getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
        if (matching)
        removeIneligibleResources(subsResources,subAllowed,resourceIdName,resourceValue);
    }
        
    // Remove resource connected to BOM from the set of substitute resources
    subsResources.erase(baseNameFromWorkingResourceName(workingRes));
        
    // loop once for each substitute resource
    RCPcollectionOfStrings::const_iterator subsResIt;
    for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::vector<std::string> toResourceVector(numIdentifiers);
        std::string subsResource = *subsResIt;
        unsigned int i;
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
        toResourceVector[i]=resourceIdentifierValueFromResourceName(subsResource, i);
        }
            
        // make sure substitute resource exists
        assert( resourceExists(toResourceVector ));
        
        // compute the substitute arcs cost and leadTime
        // subsCost is the sum of the substitute cost for each substituted attribute
        // subsLeadTime is the maximum of the lead time for each substituted attribute
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        int subsAversion = 0;
        
        
        //look over all the resource attributes and get substitute lead times and costs
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
        std::string fromValue = fromResourceVector.at(i);
        std::string toValue = toResourceVector.at(i);
        std::string resourceIdName = getResourceIdentifierNames()[i];
        int matching =  getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
        if (fromValue != toValue && matching==1) {
            //this particular resource attribute was substituted
            subsLeadTime = max( subsLeadTime, resourceIdToSubs_[resourceIdName][fromValue][toValue].getLeadTime());
            subsCost     = subsCost       +   resourceIdToSubs_[resourceIdName][fromValue][toValue].getCost();
            //DLG this is where we need to do something clever
            //to figure out the appropriate aversion from the COMBINATION
            //of aversions for each of the relevant Id fields.
            subsAversion = subsAversion + resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
        }
        }
        
        
        // Assert that the subs resource exists
        assert( resourceExists(toResourceVector) );
        
        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(toResourceVector);
        
        //std::cout <<"  resource: " <<workingRes <<std::endl;
        //std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
        
        
        // get some attributes of bomEntry that will have substitute added
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,witEngagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,witEngagement,bomIndex);
        
        // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
        // no shifting by lead time is needed
        
        

        
        // get index of substitute to be added
        int subIndex;
        checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex));
        
        // add substitute
        checkWitRC(witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() ));
        
        subBomsAdded[witEngagement][bomIndex].push_back(subIndex);
        
        // set substitute consRate
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,witEngagement,bomIndex,subIndex,bomConsRate);
        
        // compute substitute offset
        // JP, Donna, Dan: need to verify that offset is being set correctly.
        std::vector<float> subsOffset(np);
        int t;
        for (t=0; t<np; ++t) {
        subsOffset[t]=offset[t]-subsLeadTime;
        }
        
        // set substitutes offset
        witSetSubArcAttribute(witSetSubsBomEntryOffset,witEngagement,bomIndex,subIndex,subsOffset);
        
        // set cost of using substitute
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,witEngagement,bomIndex,subIndex,subsCost);
        
        // set aversion of using substitute
        checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),witEngagement.c_str(),bomIndex,subIndex,(float)subsAversion));      
    }  // end for subsResIt loop         
    }  // end of for be loop 

  } // end for b loop
}


// For a specified BOM return all of the resources that can substitute for it
void RCPproblem::getSubsResources( 
                                  const std::string & engName, 
                                  const RCPvectorString &resourceIdentifierValues,
                                  RCPcollectionOfStrings & retVal) const
{
  // There are 3 steps.
  // 1. add substitutes to wit model
  // 2. retrieve subs from wit model and populate returned data structures
  // 3. remove substitutes from wit model.
  //
  // this could be coded more efficiently.
  // Right now this method is just used for testing, so it is probably OK that it is 
  // inefficent.
  
  // 1. Add Substitutes to wit model
  RCPoperationBomSubBomIndices subBomsAdded;
  ((RCPproblem *)this)->addSubsArcsToWitModel04Feb(subBomsAdded);
  
  // 2. Get subs from wit model and populate returned data structures
  retVal.clear();
  
  // Name of wit part connected to bomEntry
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  
  // Name of wit operation connected to bomEntry
  std::string witEngagement = engagementName(engName);
  
  // Get the indices of the boms connecting the operation to the part
  std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
  //int nBomIndices =bomIndices.size();
  unsigned int b;
  for( b=0; b<bomIndices.size(); ++b ) {
    int bomIndex = bomIndices[b]; 
    
    // Get the number of substitutes
    int nSubs;
    checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&nSubs));
    
    // loop once for each subs
    int s;
    for ( s=0; s<nSubs; ++s ) {
      char * subResName;
      checkWitRC(witGetSubsBomEntryConsumedPart(mutableWitRun(),witEngagement.c_str(),bomIndex,s,&subResName));
      std::string baseName = baseNameFromWorkingResourceName(subResName);
      retVal.insert(baseName);
      checkWitRC(witFree(subResName));
    }
  }
  
  // 3. Remove Substitutes to wit model
  ((RCPproblem *)this)->removeSubsArcsFromWitModel04Feb(subBomsAdded);
  
}


void RCPproblem::presolveForPriorityAllocation()
{
  int np=getNPeriods();
  float scalingFactor = 0.001f;
  checkWitRC(witSetSelSplit(witRun(), WitTRUE));
  checkWitRC(witSetExpCutoff(witRun(), 0.0001f));
  // Scale the prodRate of each engagement operation 
  // Then scale the consRate of each BOM and subBOM arc going into that engagement operation
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      //      std::cout << "theEngagement:" << theEngagement << std::endl;
      float * prodRate = new float[np];
      int t;
      for (t=0; t<np; t++){
        prodRate[t] = scalingFactor;
        //std::cout << "Period(prodRate):" << t << ":" << prodRate[t] <<std::endl;
      }       
      checkWitRC(witSetBopEntryProductRate(witRun(),theEngagement.c_str(),0,prodRate));
      delete [] prodRate;
      
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      float * consRate = new float[np];
      for (i=0; i<nBomArcs; i++){
        checkWitRC(witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate));
        for (t=0;t<np;t++){
          consRate[t] = consRate[t]*scalingFactor;
          //std::cout << "Period(consRate): " << t << ":" << consRate[t] << std::endl; 
        }
        checkWitRC(witSetBomEntryConsRate(witRun(),theEngagement.c_str(),i,consRate));
        
        // Get the number of subBOM arcs hanging off this BOM arc and scale each of them
        int nSubBomArcs;
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        int j;
        for (j=0;j<nSubBomArcs;j++){
          checkWitRC(witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate));
          for (t=0;t<np;t++){
            consRate[t] = consRate[t]*scalingFactor;
            //std::cout << "Period(subBomArc): " << t << ":" << consRate[t] << std::endl;
          }
          checkWitRC(witSetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,consRate));
        }
      } 
      delete [] consRate;
    }
  }
}



void RCPproblem::presolveForOptimalGapGlut()
{
  int np=getNPeriods();
  
  // set witOperationExecBounds for RCP engagement
  // Set softLB to be 1 in the requested startPeriod
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float * softLB = new float[np];
      int t;
      for (t=0; t<np; t++)
        softLB[t] = 0.0f;
      softLB[startPeriod] = 1.0f;
      checkWitRC(witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL));
      delete [] softLB;
    }
  }
}

void RCPproblem::postsolveForOptimalGapGlut()
{  
  // reset witOperationExecBounds for RCP engagement
  // reset softLB to be 0 for all periods
  // Loop over all engagements
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  float * softLB = floatToFloatStar(0.0f);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) {
    std::string theEngagement = engagementName(engagementNames[e]);
    //int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
    checkWitRC(witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL));
  } 
  delete [] softLB;
}



void RCPproblem::presolve(RCPoperationBomSubBomIndices & subBomsAdded)
{
  int np=getNPeriods();
  
  // set wit obj1ShipReward from RCP engagement revenue, startTime, duration.
  // Loop over all engagements
  {
    float * obj1ShipReward = new float[np];
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      //int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
      
      //   int lastPeriod = startPeriod+duration-1;
      //if (lastPeriod>np) lastPeriod=np;
      int t;
      for ( t=0; t<startPeriod; t++ ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 ){
        for ( t=startPeriod; t<np; t++ ) obj1ShipReward[t]=revenue;
      }
      else {
        int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
        for ( t=startPeriod; t<endPoint; t++) obj1ShipReward[t]=revenue;
        for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
      }
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward));
    }
    delete [] obj1ShipReward;   
  }
  
  // set wit bomEntryOffset for each RCP bom.
  // The offset = (engagement duration) - (wit's bomEntry period)
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      
      // Get engagements duration
      //int duration = getEngagementDuration(engagementNames[e]);
      std::string theEngagement = engagementName(engagementNames[e]);
      
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        // get the period associated with this bomEntry
        RCPbomAppData * appData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData));
        int period = appData->getPeriod();
        
        // compute offset for bomEntry
        float offset = -(float)period;
        
        // Set bomEntry offest
        witSetArcAttribute(witSetBomEntryOffset,theEngagement,b,offset);
        
      } // end of b loop
    } // end of e loop
  } // finished setting wit bomEntryOffset for each RCP BOM
  
  // Add substitute arcs.  
  getTimer().printElapsedTime("done most of presolve");
  addSubsArcsToWitModel04Feb(subBomsAdded);
  getTimer().printElapsedTime("done addSubsArcsToWitMOdel");
}
void RCPproblem::presolve04Feb(RCPoperationBomSubBomIndices & subsAddedByPresolve)
{
  int np=getNPeriods();
  
  // set wit obj1ShipReward from RCP engagement revenue, startTime, duration.
  // Loop over all engagements
  {
    float * obj1ShipReward = new float[np];
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float quantity = getEngagementQuantity(engagementNames[e]);

      // set the demand quantity 
      float * demandQty = floatToFloatStar(0.f);
      demandQty[startPeriod] = quantity;
      checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandQty));
      delete [] demandQty;

      //int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
      
      //   int lastPeriod = startPeriod+duration-1;
      //if (lastPeriod>np) lastPeriod=np;
      int t;
      for ( t=0; t<startPeriod; t++ ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 ){
        for ( t=startPeriod; t<np; t++ ) obj1ShipReward[t]=revenue;
      }
      else {
        int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
        for ( t=startPeriod; t<endPoint; t++) obj1ShipReward[t]=revenue;
        for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
      }
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward));
    }
    delete [] obj1ShipReward;   
  }
  
  // set wit bomEntryOffset for each RCP bom.
  // The offset = (engagement duration) - (wit's bomEntry period)
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      
      // Get engagements duration
      //int duration = getEngagementDuration(engagementNames[e]);
      std::string theEngagement = engagementName(engagementNames[e]);
      
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        // get the period associated with this bomEntry
        RCPbomAppData * appData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData));
        int period = appData->getPeriod();
        
        // compute offset for bomEntry
        float offset = -(float)period;
        
        // Set bomEntry offest
        witSetArcAttribute(witSetBomEntryOffset,theEngagement,b,offset);
        
      } // end of b loop
    } // end of e loop
  } // finished setting wit bomEntryOffset for each RCP BOM
  
  // Add substitute arcs.
  getTimer().printElapsedTime("done most of presolve");
  addSubsArcsToWitModel04Feb(subsAddedByPresolve);
  getTimer().printElapsedTime("done addSubsArcsToWitMOdel");

}
void RCPproblem::presolveFlexMix()
{
  int np=getNPeriods();
  
  RCPoperationBomSubBomIndices subBomsAdded;
  
    
  // Add substitute arcs.
  addSubsArcsToWitModelFlexMix(subBomsAdded);
  getTimer().printElapsedTime("done addSubsArcsToWitMOdel");

}
void RCPproblem::postsolve(RCPoperationBomSubBomIndices & subsAddedByPresolve)
{
  removeSubsArcsFromWitModel04Feb(subsAddedByPresolve);
}
// remove subs boms which were added by presolve
void RCPproblem::removeSubsArcsFromWitModel04Feb(RCPoperationBomSubBomIndices & subsToBeRemoved)
{
  // Loop once for each operation
  RCPoperationBomSubBomIndicesConstIter opIt;
  for ( opIt=subsToBeRemoved.begin(); opIt!=subsToBeRemoved.end(); ++opIt ){
    const std::string & witOpName = opIt->first;
    const RCPbomSubBomIndices & bomSubIndices = opIt->second;
    
    // Loop once for bomEntry
    RCPbomSubBomIndicesConstIter bomIt;
    for ( bomIt=bomSubIndices.begin(); bomIt!=bomSubIndices.end(); ++bomIt ) {
      int bomEntryIndex = bomIt->first;
      const RCPsubBomIndices & subsEntryIndices = bomIt->second;
      
      // loop once for each subBomEntry
      unsigned int s;
      for ( s=0; s<subsEntryIndices.size(); ++s ) {
        checkWitRC(witSetSubsBomEntrySelForDel(witRun(),witOpName.c_str(),bomEntryIndex,subsEntryIndices[s],WitTRUE));
      } // end of loop once for each subBomEntry
      
    } // end of Loop once for bomEntry
    
  } // end of for operation loop.
  
  checkWitRC(witPurgeData(witRun()));  
  
}

void RCPproblem::priorityGapGlut()
{
  // (1)Set the wit supply volume for every working part to the exogenous supply
  // volume for that part
  // (2)set mrpNetAllowed to true on all the subBOM arcs
  // (3)perform witMRP
  // (4)gap is reqVol and glut is mrpExcessVol of the working part
  // (5)Reset the wit supply volume for every working part to zero
  
  // Get list of all resources
  // Need to branch on format type;  right now it's hardcoded for the old format 
  std::vector<RCPvectorString> names;
  
  int numResources, np;
  
  np = getNPeriods();
  getResourceNames(names);
  numResources = names.size();
  
  // (1) loop once for each resource and set supply of the working part to the exogenous supply
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    exogSup = getResourceSupplyQuantity(names[r]);
    
    int t;
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,
      workingRes,t,exogSup[t]);
  }
  // (2) Now loop through all the subs and set mrpNetAllowed to true
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      //      std::cout << "theEngagement:" << theEngagement << std::endl;
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      for (i=0; i<nBomArcs; i++){
        // Get the number of subBOM arcs hanging off this BOM arc and scale each of them
        int nSubBomArcs;
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        int j;
        for (j=0;j<nSubBomArcs;j++){
          checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),theEngagement.c_str(),i,j,WitTRUE));
        } 
      }
    }
  }
 
  // (3) perform the wit MRP
  checkWitRC(witMrp(witRun()));
  
  // (4) pick off the results
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetPartReqVol,workingRes);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartMrpExcessVol,workingRes);
    for (int t=0; t<np; t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (5) Reset the supply of the working part to zero
  // loop once for each resource
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    
    int t;
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,0.0f);
  }
  
}

void RCPproblem::priorityGapGlut1()
{
  // Assume that the offset of the acquireOp is zero for gapGlut computation
  // (0) Check to see that there is only one engagement,its requested start 
  // time is period zero and get its name.
  // (1) Set the base engagement demand to zero
  // (2) Create additional demand structures, one for the demand that must be met exactly and one for the demand
  // that can be met with substitution; mark these SelForDel
  // (3)Set the wit supply volume for every working part to the exogenous supply
  // volume for that part; Set the productRate of the acquireOp to vecZero. 
  // (4) Loop through all the BOMs in the base model add "copies" of the 'must be met exactly' BOMs to the 'must
  // be met exactly' demand and copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)
  // (5) perform witHeurImplode
  // (6) gap is acquire execVol of the resource and glut is scrapVol of the working part
  // (7) Set the base engagement demand back to one
  // (8) Set the wit supply volume for every working part to zeroVec
  // (9) witPurgeData
  // (10) Set the productRate of the acquireOp to vecOne
  
  int nPeriods = getNPeriods();
  int t;
  
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int engSize = engagementNames.size();
  
  // (2)
  int nSpecialDemands = getResourceIdentifierNames().size();
  int maxPriority = 1;
  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  
  for (int i=0; i<nSpecialDemands; i++){
    int pr = getResourceIdentifierPriority(resourceIdentifierNames[i]);
    if (pr > maxPriority)
      maxPriority = pr;
  }
  
  

  // (3) 
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  // loop once for each resource; connect the acquire resource operation to the working resource part; set the 
  // external supply for the working part; set the productRate of the acquireOp to zeroVec
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::string acquireRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    checkWitRC(witAddBopEntry(witRun(),acquireRes.c_str(),workingRes.c_str()));
    checkWitRC(witSetBopEntrySelForDel(witRun(),acquireRes.c_str(),1,WitTRUE));
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<(int)exogSup.size(); t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[t]);
    
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
  }

  // Need to assign priorities to the demands
  // (4) Loop over all the engagements and assign a priority to the demand
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int engCount;
    
    for(engCount=0; engCount<engSize; engCount++){
      std::string theEngagement = engagementName(engagementNames[engCount]);
      
      
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      
      //      for (i=0; i<nBomArcs; i++){  //Still assuming that there is a "single" bom arc, so don't need to loop through other arcs  DPC
      if (nBomArcs > 0){
        i=0;
        // Get the number of subBOM arcs hanging off this BOM arc 
        int nSubBomArcs;
        char * consumedPartName;
        std::string priorityDemand;
        
        checkWitRC(witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName));
        
        std::string baseName, workingPartName(consumedPartName);
        baseName = baseNameFromWorkingResourceName(workingPartName);
        RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
        
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        
        // Now go through the working resource and see how many "UNSPECIFIED" or "PRIORITY" values it has;
        // if it is just one, than add it to the appropriate Special Demand 
        
        int index, tempIndex, count = 0;
        std::string idName;
        //assert (resourceIdValues.size() == nSpecialDemands);
        for (index=0; index<nSpecialDemands; index++){
          if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   
            // Still need to check on the match flag DPC;  Donna may have fixed this on the input side by changing the data for non-matched stuff
            count ++;
            tempIndex = index;
            idName = resourceIdentifierNames[index];
          }
        }
        
        int * priorityVec;
        int priority;
        checkWitRC(witGetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),&priorityVec));

        switch (count)
          {
            // set the demand priority based on the following rules
          case 0:
            for (t=0; t<nPeriods; t++)
              priorityVec[t] = 1;
            break;
          case 1:
            priority = getResourceIdentifierPriority(idName);
            if (priority <= 0)
              priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
            else
              if (priority < INT_MAX)
                priority ++;
            for(t=0; t<nPeriods; t++)
              priorityVec[t] = priority;  
            break;
          default:
            for(t=0; t<nPeriods; t++)
              priorityVec[t] = maxPriority+2;
          }

        checkWitRC(witSetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),priorityVec));
        checkWitRC(witFree(priorityVec));
        checkWitRC(witFree(consumedPartName));
      } 
    }
  }
  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));
  //  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  checkWitRC(witHeurImplode(witRun()));
  //  generatePriorityGapGlut1PeggingResults();
  //  checkWitRC(witClearPegging(witRun()));
  //  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (8) 
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero));
    delete [] vecZero;
  }
  
  // (10)
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
  }
  
}
void RCPproblem::priorityGapGlutDemandEngagement()
{
  // a few differences from priorityGapGlut1 due to the different position of the
  // acquire in the model (off of working, not bench)
  
  
  // Assume that the offset of the acquireOp is zero for gapGlut computation
  // (0) Check to see that there is only one engagement,its requested start 
  // time is period zero and get its name.
  // (1) Set the base engagement demand to zero
  // (2) Create additional demand structures, one for the demand that must be met exactly and one for the demand
  // that can be met with substitution; mark these SelForDel
  // (3)Set the wit supply volume for every working part to the exogenous supply
  // volume for that part; Set the productRate of the acquireOp to vecZero. 
  // (4) Loop through all the BOMs in the base model add "copies" of the 'must be met exactly' BOMs to the 'must
  // be met exactly' demand and copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)
  // (5) perform witHeurImplode
  // (6) gap is acquire execVol of the resource and glut is scrapVol of the working part
  // (7) Set the base engagement demand back to one
  // (8) Set the wit supply volume for every working part to zeroVec
  // (9) witPurgeData
  // (10) Set the productRate of the acquireOp to vecOne
  
  int nPeriods = getNPeriods();
  int t;
  
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int engSize = engagementNames.size();
  
 

  // (3) 
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));
  //  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  checkWitRC(witHeurImplode(witRun()));
  //  generatePriorityGapGlut1PeggingResults();
  //  checkWitRC(witClearPegging(witRun()));
  //  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  for (int r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    int opExists;
    checkWitRC(witGetOperationExists(witRun(),acquireOp.c_str(),&opExists)) ;
    
    std::vector<float> gapQty;
    if (opExists) 
         gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    
    if (opExists) {
        for (unsigned int t=0; t<glutQty.size(); t++ ) {
            setResourceGapQuantity(names[r],t,gapQty[t]);
            setResourceGlutQuantity(names[r],t,glutQty[t]);
        }
    }
    else {
       for (unsigned int t=0; t<glutQty.size(); t++ ) {
            setResourceGapQuantity(names[r],t,0.0);
            setResourceGlutQuantity(names[r],t,glutQty[t]);
        }

    }
  }
  
 

  
}
void RCPproblem::GapGlutFlexMix()
{
  int nPeriods = getNPeriods();

  
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int engSize = engagementNames.size();
  
  
  

  // (3) 
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  

  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));
  //  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  
  
  
  //checkWitRC(witHeurImplode(witRun()));
  checkWitRC(witOptImplode(witRun()));
 
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  int r;
  for ( r=0; r<numResources; ++r ) { //DLG LOOP THROUGH ENGAGEMENTS AND FIGURE OUT THE ACQUIRE OP WILL BE
    

    std::string benchRes, acquireOp;
    benchRes = benchResourceName(names[r]);
    acquireOp = acquireWorkingResourceName(names[r]); 
    std::vector<float> gapQty;
    if (witOperationExists(acquireOp))
       gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    else {
       for (int n =0; n<nPeriods; n++)
          gapQty.push_back(0.0f);
    }
       
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,benchRes);
    //DLG here we want to assign the glut to the primary part
    std::vector<std::string> primarynames = getPrimaryNameFromFlexibleName(names[r]);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setFlexibleResourceGapQuantity(names[r],t,gapQty[t]);
      setFlexibleResourceGlutQuantity(primarynames,t,glutQty[t]);
    }
  
  }
  
  
  
    
}

std::vector<std::string> RCPproblem::getPrimaryNameFromFlexibleName(std::vector<std::string> names) {
   std::vector<std::string> returnedNames;
   for (unsigned int i=0; i<names.size(); i++) 
      returnedNames.push_back(names.at(i));
      
      
   std::string skillSet = names[skillSetPosition_];
   int begPos = skillSet.find(" s0: ");
   if (begPos==-1)
      return returnedNames; //it's not a flexmix resource
      
   
   std::string primarySkillSet = textAfter(skillSet, " s0: ");
   int nextMark = primarySkillSet.find(" s1:");
   std::string finalSkillSet = primarySkillSet.substr(0,nextMark);
   
 
   returnedNames[skillSetPosition_] = finalSkillSet;

   
   return returnedNames;
}
void RCPproblem::priorityNASCO() 
{
  //set the engagement demands
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int numEngagements = engagementNames.size();
  int engCount;

  for(engCount=0; engCount<numEngagements; engCount++){
    std::string engName = engagementNames[engCount];
 
    float * demandQty = floatToFloatStar(0.f);
    int reqStartPer = getEngagementRequestedStartPeriod(engName);

    demandQty[reqStartPer] = getEngagementQuantity(engName);
    checkWitRC(witSetDemandDemandVol(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),demandQty));
    delete [] demandQty;
    
    int priority = getEngagementPriority(engName);
    int * vecPriority = intToIntStar(priority);
    checkWitRC(witSetDemandPriority(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),vecPriority));
    delete [] vecPriority;
   }
   
  checkWitRC(witWriteData(witRun(),"witBeforeMRP.dat")); 
  
  checkWitRC(witMrp(witRun()));
  saveMrpResults();
  
  checkWitRC(witSetSelSplit(witRun(),WitTRUE));
  
  //Do a witHeurImplode
  checkWitRC(witWriteData(witRun(),"witBeforeHeurImplode.dat")); 
  checkWitRC(witHeurImplode(witRun()));
  
  std::vector<RCPvectorString> names;
  std::vector<std::vector<std::vector<std::string> > > multipleSkillNames;
  
  int numResources, numMultipleSkillResources;
  getResourceNames(names);
  getSkillGroupNames(multipleSkillNames);
  numResources = names.size();
  numMultipleSkillResources = multipleSkillNames.size();
 
 
  //collect the gaps and gluts
  for (int r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
   }
  //collect the gluts on the multiple skill names
  for (int r=0; r<numMultipleSkillResources; ++r ) {
    std::vector<std::vector<std::string> > skillGroup = multipleSkillNames[r];
    std::string skillGroupName = createSkillGroupName(skillGroup);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,skillGroupName);
    for (unsigned int t=0; t<glutQty.size(); t++ ) {
      setSkillGroupGlutQuantity(skillGroup,t,glutQty[t]);
    }
   }   
   //now we need to make the acquire time infeasible, to determine which
   //projects can be done
   for (int r=0; r<numResources; ++r) {
      RCPresourceAppData * appData;
      std::string workingRes = workingResourceName(names[r]);
      checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
      float acquireTime = appData->getResourceAcquireAppData();
      setResourceAcquireTime(names[r],acquireTime);
   }
   
   //we also need to set the late allowance now (work doesn't necessarily have
   //to be done on time)
    for(engCount=0; engCount<numEngagements; engCount++){
        std::string engName = engagementNames[engCount];
     
        int lateAllowance = getEngagementLateAllowance(engName);
        int *lateAllowanceVec = intToIntStar(lateAllowance);
        checkWitRC(witSetDemandShipLateUB(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),lateAllowanceVec));
        delete [] lateAllowanceVec;
        

    }
   
   //run the implosion again
   checkWitRC(witWriteData(witRun(),"witBeforeSecondHeurImplode.dat")); 
   checkWitRC(witHeurImplode(witRun()));
  

}
void RCPproblem::priorityGapGlut2()
{
  // (1) Set the wit supply volume for every working part to the exogenous supply
  // volume for that part; add arc from acquire to working; set the productRate of the acquireOp to vecZero. 
  // (1.1) Create a global dummy part, which is needed to make the heuristic work right
  // A subarc will be added to this dummy part for those BOMs that have no existing subarcs
  // (2) Loop through each engagement.  Get its name and report if the engagement's requested start 
  // time is not in period zero.  Set the engagement's demand priority and demand volume.
  // (3) Create the sorting layer. (Mark selForDel)
  // (4) For the engagement, loop through each BOM coming off the engagement.  Add "copies" of the 
  // 'must be met exactly' BOMs to the 'must be met exactly' sort layer operation and 
  // copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)
  // (5) perform witHeurImplode
  // (6) gap is acquire execVol of the resource and glut is scrapVol of the working part
  // (7) For each BOM in each engagement, set earliestPeriod to zero
  // (8) Set the wit supply volume for every working part to zeroVec
  // (9) witPurgeData
  // (10) Set the productRate of the acquireOp to vecOne
  
  int nPeriods = getNPeriods();
  int t;

  // (1) Get list of all resources and set the supply volume for the working part to the exogenous supply
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  // loop once for each resource; connect the acquire resource operation to the working resource part; set the 
  // external supply for the working part; set the productRate of the acquireOp to zeroVec
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::string acquireRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    checkWitRC(witAddBopEntry(witRun(),acquireRes.c_str(),workingRes.c_str()));
    checkWitRC(witSetBopEntrySelForDel(witRun(),acquireRes.c_str(),1,WitTRUE));
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<(int)exogSup.size(); t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[t]);
    
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
  }

  //(1.1)
  std::string globalSubPart = "global_sub";
  witBoolean exists = WitTRUE;
  while (exists) {
    globalSubPart = "__" + globalSubPart + "__";
    checkWitRC(witGetPartExists(witRun(), globalSubPart.c_str(), &exists));
  }
  checkWitRC(witAddPart(witRun(),globalSubPart.c_str(),WitCAPACITY));
  checkWitRC(witSetPartSelForDel(witRun(),globalSubPart.c_str(),WitTRUE));
  
  // (2) Loop through each engagement.  Get its name and check to see that the engagement's requested start 
  // time is period zero.  (Still assuming all engagements are starting at period 0).  Set the the engagement's priority
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int numEngagements = engagementNames.size();
  int engCount;

  for(engCount=0; engCount<numEngagements; engCount++){
    std::string engName = engagementNames[engCount];
    int reqStartPer = getEngagementRequestedStartPeriod(engName);
    if (reqStartPer != 0){
      std::cout << "This version of RCP loops over shipment time when sorting the demands." << std::endl;
      std::cout << "The start period for engagement " << engName << " is not zero."  << std::endl;
    }
  
    int priority = getEngagementPriority(engName);
    int * vecPriority = intToIntStar(priority);
    checkWitRC(witSetDemandPriority(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),vecPriority));
    delete [] vecPriority;
    
    float * demandQty = floatToFloatStar(0.f);
    demandQty[reqStartPer] = getEngagementQuantity(engName);
    checkWitRC(witSetDemandDemandVol(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),demandQty));
    delete [] demandQty;


    // (3) Create the sorting layer. (Mark selForDel)
    const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifiersSortedByPriority();
    const std::vector<std::string> & unsortedResourceIdentifierNames = getResourceIdentifierNames();
    int nResIDs = resourceIdentifierNames.size();
    std::string sortName1, sortName2, sortEngagementName1, sortEngagementName2;
    int i;
    
    for (i=0; i<=nResIDs+1; i++){
      if (i==0) 
        sortName1 = "__exact__";
      else if (i==nResIDs+1)
        sortName1 = "__last__";
      else
        sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
      
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      
      checkWitRC(witAddPart(witRun(),sortEngagementName1.c_str(),WitCAPACITY));
      checkWitRC(witSetPartSelForDel(witRun(),sortEngagementName1.c_str(),WitTRUE));
      checkWitRC(witAddOperation(witRun(),sortEngagementName1.c_str()));
      checkWitRC(witSetOperationSelForDel(witRun(),sortEngagementName1.c_str(),WitTRUE));
      checkWitRC(witAddBopEntry(witRun(),sortEngagementName1.c_str(),sortEngagementName1.c_str()));
      checkWitRC(witAddBomEntry(witRun(),engagementName(engName).c_str(),sortEngagementName1.c_str())); 
    }
  
    if (nResIDs == 0){
      sortName1 = "__exact__";
      sortName2 = "__last__";
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
      checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));
    }
    else for (i=0; i<=nResIDs; i++){
      if (i==0){
        sortName1 = "__exact__";
        sortName2 = "__" + resourceIdentifierNames[0] + "__";
      }
      else if (i == nResIDs ) {
        sortName1 = "__" + resourceIdentifierNames[nResIDs-1] + "__";
        sortName2 = "__last__";
      }
      else {
        sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
        sortName2 = "__" + resourceIdentifierNames[i] + "__";
      }
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
      checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));
    }

    // tie the "last" part in the sort layer to the globalSubPart
    sortEngagementName1 = sortLayerEngagementName(engName, "__last__");
    checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), globalSubPart.c_str()));
    checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));    


  // (4) For the engagement, loop through each BOM coming off the engagement.  Add "copies" of the 
  // 'must be met exactly' BOMs to the 'must be met exactly' sort layer operation and 
  // copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)


    {
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),engagementName(engName).c_str(),&nBomArcs));
      int i;
      int nBomsAddedToExactLayer = 0, nBomsAddedToLastLayer = 0, nBomsAddedToSortLayer;
      
      std::vector<int> nBomsAddedToSpecialSortLayer (nResIDs);
      {
        int k;
        for (k=0; k<nResIDs; k++)
          nBomsAddedToSpecialSortLayer[k] = 0;
      }
      
      for (i=0; i<nBomArcs; i++){
        // Get the number of subBOM arcs hanging off this BOM arc 
        int nSubBomArcs;
        char * consumedPartName;
        float * consRate, * offset, aversion;
        std::string sortLayerOp;

        

        checkWitRC(witGetBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,&consumedPartName));
        // Copy over those bom arcs that aren't related to the sortLayer
        if (!beginsWith(consumedPartName, "sortLayer:")) {

          // Shut off BOM arc by setting earliestPeriod to nPeriods
          checkWitRC(witSetBomEntryEarliestPeriod(witRun(),engagementName(engName).c_str(),i,nPeriods));
                  
          std::string baseName, workingPartName(consumedPartName);
          baseName = baseNameFromWorkingResourceName(workingPartName);
          RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
          
          checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),engagementName(engName).c_str(),i,&nSubBomArcs));

          // Work with Donna to get the right criteria for the linking up of the resource to the right sort layer
          // This is a temporary approach.
        
          int index, tempIndex, count = 0;
          assert (resourceIdValues.size() == nResIDs);
          for (index=0; index<nResIDs; index++){
            if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   // Still need to check on the match flag DPC
              count ++;
              tempIndex = index;
            }
          }
          switch (count)
            {
            case 0:
              sortLayerOp = sortLayerEngagementName(engName, "__exact__");
              nBomsAddedToSortLayer = nBomsAddedToExactLayer;
              break;
            case 1:
              // NOTE:  We went through the resourceIdValues in the order of definition,
              // so we use the unsorted list of resourceIDs to get the proper column.
              sortLayerOp = sortLayerEngagementName(engName, "__"+ unsortedResourceIdentifierNames[tempIndex] + "__");
              nBomsAddedToSortLayer = nBomsAddedToSpecialSortLayer[tempIndex];
              break;
            default:
              sortLayerOp = sortLayerEngagementName(engName, "__last__");
              nBomsAddedToSortLayer = nBomsAddedToLastLayer;
            }
          
          checkWitRC(witAddBomEntry(witRun(),sortLayerOp.c_str(),consumedPartName));        
          checkWitRC(witSetBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,WitTRUE));
          // Add a subBomArc to the global_sub_part for those bom arcs that have no subBomArcs
          if (nSubBomArcs == 0)
            checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,globalSubPart.c_str()));

          // copy over the attributes of this BOM arc from the base model to the LastLayerDemand
          // and then bring over all of the subBOMs and their attributes
          checkWitRC(witGetBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,&consRate));
          checkWitRC(witGetBomEntryOffset(witRun(),engagementName(engName).c_str(),i,&offset));
          checkWitRC(witSetBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,consRate));
          checkWitRC(witSetBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,offset));
          // Now copy over the subBOM arcs
          
          int j;
          for (j=0; j<nSubBomArcs; j++)
            {
              char * subConsumedPartName;
              float *subConsRate, *subOffset;
              checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,j,&subConsumedPartName));
              checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,subConsumedPartName));
              checkWitRC(witSetSubsBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
              checkWitRC(witGetSubsBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,j,&subConsRate));
              checkWitRC(witSetSubsBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subConsRate));
              checkWitRC(witGetSubsBomEntryOffset(witRun(),engagementName(engName).c_str(),i,j,&subOffset));
              checkWitRC(witSetSubsBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subOffset));
              checkWitRC(witGetSubsBomEntryExpNetAversion(witRun(),engagementName(engName).c_str(),i,j,&aversion));
              checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,aversion));
              checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
              checkWitRC(witFree(subOffset));
              checkWitRC(witFree(subConsRate));
              checkWitRC(witFree(subConsumedPartName));
            }
          switch (count)
            {
            case 0: 
              nBomsAddedToExactLayer ++;
              break;
            case 1:
              nBomsAddedToSpecialSortLayer[tempIndex] ++;
              break;
            default:
              nBomsAddedToLastLayer ++;
            }
          checkWitRC(witFree(consumedPartName));
          checkWitRC(witFree(consRate));
          checkWitRC(witFree(offset));
        } 
      }
    }
  }


  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));

  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  checkWitRC(witHeurImplode(witRun()));
  generatePriorityGapGlut2PeggingResults();
  checkWitRC(witClearPegging(witRun()));
  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (7) Reset the priority of the engagements back to zero.   For each BOM in each engagement, set earliestPeriod back to zero

  for(engCount=0; engCount<numEngagements; engCount++){
    std::string engName = engagementNames[engCount];
    int * vecPriority = intToIntStar(0);
    
    checkWitRC(witSetDemandPriority(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),vecPriority));
    delete [] vecPriority;
            
    
    int nBomArcs;
    checkWitRC(witGetOperationNBomEntries(witRun(),engagementName(engName).c_str(),&nBomArcs));
    int i;
    
    for (i=0; i<nBomArcs; i++)
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),engagementName(engName).c_str(),i,0));
  }
  
  // (8) Set the wit supply volume for every working part to zeroVec
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero));
    delete [] vecZero;
  }
  
  // (9) purge the model of the temporary modeling elements
  checkWitRC(witPurgeData(witRun()));

  // (10) Set the productRate of the acquireOp to vecOne
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
  }
}


void RCPproblem::generatePriorityGapGlut1PeggingResults()
{
  // (1) Loop through each demand

  //const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  //int nSpecialDemands = getResourceIdentifierNames().size();
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) 
    computePegging(engagementName(engagementNames[e].c_str()));
}

void RCPproblem::generatePriorityGapGlut2PeggingResults()
{
  // (1) Loop through each demand

  //const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  //int nSpecialDemands = getResourceIdentifierNames().size();
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) 
    computePegging3(engagementName(engagementNames[e].c_str()));
}


void RCPproblem::computePegging(std::string demandName) 
{
  int np = getNPeriods();
  // (2) For each demand, loop through all the BOMs for that demand
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desired quantity)
  // (4) Call the pegging function, for all the periods, to get the amount of "gap" or acquisition and net this from the consRate vector
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.

  int bomIndex, nBomArcs;
  checkWitRC(witGetOperationNBomEntries(witRun(),demandName.c_str(),&nBomArcs));
  for (bomIndex = 0; bomIndex < nBomArcs; bomIndex++)
    {
      char * consumedPartName;
      float * consRate;
      float * offset;
      std::vector<float> cumTotal(np);
      std::vector<float> localConsRate(np);
      int theOffset;

      int i;
      for(i=0; i<np; i++){
        cumTotal[i] = 0.f;
        localConsRate[i] = 0.f;
      }

      checkWitRC(witGetBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,&consumedPartName));
      checkWitRC(witGetBomEntryConsRate(witRun(),demandName.c_str(),bomIndex,&consRate));
      checkWitRC(witGetBomEntryOffset(witRun(),demandName.c_str(),bomIndex,&offset));
      std::string acquireOpName = getAcquireOperationFromWorkingName(consumedPartName);

      theOffset = - (int) offset[0];
      localConsRate[theOffset] = consRate[0];

      int lenLists;
      char ** operationNameList;
      int * execPeriodList;
      float * peggedExecVolList;
      int theIdx;
      
      checkWitRC(witGetDemandExecVolPegging ( witRun(),
                                   demandName.c_str(),
                                   demandName.c_str(),
                                   0,
                                   & lenLists,
                                   & operationNameList,
                                   & execPeriodList,
                                   & peggedExecVolList));

      //look for the acquireOperation in the returned operationNameList
      for (theIdx = 0; theIdx < lenLists; theIdx++)
        {
          if(acquireOpName == operationNameList[theIdx])
            { //found it
              if (execPeriodList[theIdx] == theOffset){
                cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
                //                std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
                //                  " GAP: " << peggedExecVolList[theIdx] << std::endl;
              }
            }
        }

      for (theIdx = 0; theIdx < lenLists; theIdx++)
        checkWitRC(witFree(operationNameList[theIdx]));
      
      checkWitRC(witFree (operationNameList));
      checkWitRC(witFree (execPeriodList));
      checkWitRC(witFree (peggedExecVolList));
      
      // Now take care of the subVols
      int nSubBomArcs, subBomIndex;
      checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),demandName.c_str(),bomIndex,&nSubBomArcs));
      for(subBomIndex = 0; subBomIndex<nSubBomArcs; subBomIndex++)
        {
          char * subPartConsumed;
          float * subVol;
          checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed));
          checkWitRC(witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol));
          if (subVol[theOffset]>0)
                {
                  float subQtyUsed = subVol[theOffset] * localConsRate[theOffset];
                  cumTotal[theOffset] += subQtyUsed;
                  //                                  std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
                  //                                            << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
                }
          checkWitRC(witFree (subVol));
          checkWitRC(witFree (subPartConsumed));
        }

      for (i=0; i<np; i++)
        {
          float supplyQtyUsed = localConsRate[i] - cumTotal[i];
          //          if (supplyQtyUsed > 0)
            //                    std::cout << "  Demand:" << demandName << "  Period:" << i << " Supply Used:" 
            //                                    << supplyQtyUsed << std::endl;
        }
      
      checkWitRC(witFree (consRate));
      checkWitRC(witFree (consumedPartName));
      checkWitRC(witFree (offset));
    }
}


void RCPproblem::computePegging3(std::string demandName) 
{
  int np = getNPeriods();
  // (1) Call pegging on the demand 
  // (2) For the demand, loop through all the BOMs for that demand.  These will be "sort-layer" parts.
  // (2.5) For each "sort-layer" operation, loop through all the BOMs of that sort-layer operation, skipping the index 0 BOM entry, which is there for modeling tricks.
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desired quantity) (Note:  There could be demand in different periods for the same resource)
  // (4) The execVol of the acquireOperation for a resource is the gap associated to the BOM arc that is in effect at offset t (or -t)
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.

  // (1) Call Wit's pegging function for this demand;  and get the appData for the engagement

  int lenLists;
  char ** operationNameList;
  int * execPeriodList;
  float * peggedExecVolList;
  int theIdx;

  int reqStartPer = getEngagementRequestedStartPeriod(textAfter(demandName,"engagement: "));  

  checkWitRC(witGetDemandExecVolPegging ( witRun(),
                                          demandName.c_str(),
                                          demandName.c_str(),
                                          reqStartPer,
                                          & lenLists,
                                          & operationNameList,
                                          & execPeriodList,
                                          & peggedExecVolList));

  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),demandName.c_str(),(void**)&appData));
  appData->clearPegging();

  int sortLayerBomIndex, nSortLayerBomArcs;
  checkWitRC(witGetOperationNBomEntries(witRun(),demandName.c_str(),&nSortLayerBomArcs));
  for (sortLayerBomIndex = 0; sortLayerBomIndex < nSortLayerBomArcs; sortLayerBomIndex++)
    {
      char * sortLayerConsumedPartName;

      checkWitRC(witGetBomEntryConsumedPart(witRun(),demandName.c_str(),sortLayerBomIndex,&sortLayerConsumedPartName));

      // make sure the consumed part is a sort layer part;  otherwise skip it


      if (beginsWith(sortLayerConsumedPartName, "sortLayer:")) {

        
        int nBomArcs, bomIndex;
        checkWitRC(witGetOperationNBomEntries(witRun(),sortLayerConsumedPartName,&nBomArcs));
        //(2.5)
        //can skip BomIndex:0 because it's just there as a modeling trick
        for (bomIndex = 1; bomIndex < nBomArcs; bomIndex ++){

          float localConsRate;  //This holds the BOM usage quantity
          float cumTotal = 0.f;  //
          char * consumedPartName;
          float * consRate;
          float * offset;
          int theOffset;
          
          // (3)
          checkWitRC(witGetBomEntryConsumedPart(witRun(),sortLayerConsumedPartName,bomIndex,&consumedPartName));
          checkWitRC(witGetBomEntryConsRate(witRun(),sortLayerConsumedPartName,bomIndex,&consRate));
          checkWitRC(witGetBomEntryOffset(witRun(),sortLayerConsumedPartName,bomIndex,&offset));
          
          std::string acquireOpName = getAcquireOperationFromWorkingName(consumedPartName);

          theOffset = - (int) offset[0];
          localConsRate = consRate[0];
          
          checkWitRC(witFree(offset));
          checkWitRC(witFree(consRate));

          // (4)  Now go find the pegged acquireOp's execution volume in period 'theOffset' from Wit's pegging computation.

          //look for the acquireOperation in the returned operationNameList
          for (theIdx = 0; theIdx < lenLists; theIdx++)
            {
              if(acquireOpName == operationNameList[theIdx])
                { //found it -- now see if it is in the right time period
                  if (execPeriodList[theIdx] == theOffset+reqStartPer){
                    cumTotal = peggedExecVolList[theIdx];
                    //                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << cumTotal << std::endl;
                                  appData->addPeggedQuantityFromAcquisition(theOffset+reqStartPer,
       resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),cumTotal);
                  }
                }
            }

          // (5) Now take care of the subVols  
          
          int nSubBomArcs, subBomIndex;
          checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),sortLayerConsumedPartName,bomIndex,&nSubBomArcs));
          for(subBomIndex = 0; subBomIndex<nSubBomArcs; subBomIndex++)
            {
              char * subPartConsumed;
              float * subVol;
              float * subOffset;
              int theSubOffset;

              checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subPartConsumed));
              checkWitRC(witGetSubsBomEntrySubVol(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subVol));    
              checkWitRC(witGetSubsBomEntryOffset(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subOffset));
              theSubOffset = - (int) subOffset[0];
              if (theSubOffset == theOffset + reqStartPer){
                
                if (subVol[reqStartPer]>0)
                  {
                    float subQtyUsed = subVol[reqStartPer] * localConsRate;
                    cumTotal += subQtyUsed;
                    //                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset + reqStartPer 
                    //                              << " RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUB RESOURCE:" 
                                   //                              << baseNameFromWorkingResourceName(subPartConsumed) << " QUANTITY SUBBED: " << subQtyUsed << std::endl;
                    appData->addPeggedQuantityFromSubstitution(theOffset+reqStartPer,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),subQtyUsed,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(subPartConsumed)));
                  }
              }
              checkWitRC(witFree (subOffset));
              checkWitRC(witFree (subVol));
              checkWitRC(witFree (subPartConsumed));
            }

          float supplyQtyUsed = localConsRate - cumTotal;
          if (supplyQtyUsed > 0){
            //            std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  Period:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUPPLY USED: " 
            //                          << supplyQtyUsed << std::endl;
            appData->addPeggedQuantityFromSupply(theOffset+reqStartPer,
                                                 resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)), supplyQtyUsed);
          }
          checkWitRC(witFree (consumedPartName));
        }
      }
      checkWitRC(witFree (sortLayerConsumedPartName));
    }

  for (theIdx = 0; theIdx < lenLists; theIdx++)
    checkWitRC(witFree(operationNameList[theIdx]));
    
  checkWitRC(witFree (operationNameList));
  checkWitRC(witFree (execPeriodList));
  checkWitRC(witFree (peggedExecVolList));

}

void RCPproblem::optimalGapGlut(){
  
  // (1) Run witOptImplode
  // (2) gap = negative part of (exogQty - workingQty); glut = positive part of (exogQty - workingQty)
  checkWitRC(witWriteData(witRun(),"witOGG.dat"));
  checkWitRC(witOptImplode(witRun()));
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::vector<float> gapQty;    
    std::vector<float> glutQty;    
    std::string workingRes;
    std::vector<float> exogSup;
    std::vector<float> workingQty;
    workingRes = workingResourceName(names[r]);
    exogSup = getResourceSupplyQuantity(names[r]);
    //    workingQty = getResourceWorkingQuantity(names[r]);
    // NOTE:  The workingAppData isn't being used here for the workingQty.  The workingQty is being set to the execVol of the working resource.  
    workingQty = getOptimalWorkingQuantity(names[r]);
    
    unsigned int t;
    for (t=0; t<exogSup.size(); t++){
      float delta = exogSup[t] - workingQty[t];
      //      printf("%d %f %f %f\n", t, delta, exogSup[t], workingQty[t]);
      if (delta>=0) {
        gapQty.push_back(0.0f);
        glutQty.push_back(delta);
      }
      else {
        gapQty.push_back(-delta);
        glutQty.push_back(0.0f);
      }
      setResourceGapQuantity(names[r],t,gapQty[t]);      
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
}

// witSetOptWithLotSize has been removed.
// This code is a replacement for witSetOptWithLotSizes.
void RCPproblem::setOptWithLotSizes()
{
    /*      
Hello, Folks.

Whoa; looks like RCP hasn't been built with a current version of WIT in a while. :) CVS indicates that I committed WIT with the optWithLotSizes attribute removed on 8/17/06. (As I recall, I checked with everybody first to see that it wasn't needed. We don't actually remove attributes very often.)

Anyway, the relevant new capability is called "MIP Mode": see the WIT Guide, chapter 1. The new attributes for it are:

problem.mipMode
operation.intExecVols
subEntry.intSubVols
demand.intShipVols

If you have any further questions, please let me know.

Bob Wittrock
*/

  checkWitRC(witSetMipMode(witRun(),WitTRUE));

  // Loop once for each operation
  int nOps;
  char **ops;
  checkWitRC(witGetOperations(mutableWitRun(),&nOps,&ops));
  for( int o=0; o<nOps; ++o ) {
      checkWitRC(witSetOperationIntExecVols(witRun(),ops[o],WitTRUE));

      // Loop once for each operation Bom
      int nBoms;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),ops[o],&nBoms));
      for ( int b=0; b<nBoms; ++b ) {
          
          // Loop once for each sub
          int nSubs;
          checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),ops[o],b,&nSubs));
          for ( int s=0; s<nSubs; ++s ) {
              checkWitRC(witSetSubsBomEntryIntSubVols(witRun(),ops[o],b,s,WitTRUE));
          }
      }

      witFree(ops[o]);
  }
  witFree(ops);
  
  // Loop once for each part
  int nParts;
  char **parts;
  checkWitRC(witGetParts(mutableWitRun(),&nParts,&parts));
  for ( int p=0; p<nParts; ++p ) {

      // Loop once for each demand
      int nDems;
      char **dems;
      checkWitRC(witGetPartDemands(mutableWitRun(),parts[p],&nDems,&dems));
      for ( int d=0; d<nDems; ++d ) {
          checkWitRC(witSetDemandIntShipVols(witRun(),parts[p],dems[d],WitTRUE));
          witFree(dems[d]);
      }
      witFree(dems);
      witFree(parts[p]);
  }
  witFree(parts);
}

void RCPproblem::optimalResourceAction()
{
  // witSetOptWithLotSizes no longer exists.  See Bob's comments below
  //checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
    setOptWithLotSizes();


  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit3opt.dat"));
  checkWitRC(witOptImplode(witRun()));
  saveOptimalResourceActionResults();
}


void RCPproblem::priorityResourceAction()
{
  // (1) Get the offset (leadtime) from the acquire BOP; set the productRate of this operation to zero
  // (2) Create a bunch of BOPs from the acquire operation up to the working
  // part, one for each period, setting the offset and the lastestPeriod on each; mark SelForDel
  // (3) Set the supply for period zero on the working part to the exogenous supply at period zero
  // (4) Delete the enable operation and the bench part.  ***** don't need this now
  // (5) Run witHeurImplode
  // (6) Do some post processing and pick off the answers
  // (7) reset productRate of acquire operation to 1; set the supply for period zero of the working part to zero; 
  // do a WitPurge to remove the BOPs added in (2)
  
  int np=getNPeriods();
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp,workingRes;
    
    acquireOp = acquireResourceOperationName(names[r]);
    workingRes = workingResourceName(names[r]);
    
    float * aov;
    checkWitRC(witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&aov));
    int acqOffset = (int) floor(aov[0]);
    checkWitRC(witFree(aov));
    
    int t;
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
    
    // (2) Add the new BOPs from the acquire operation directly to the working resource part
    // and set the offset and latestPeriod  NOTE: acqOffset is non-positive 
    int i;
    for (i=0; i<np+acqOffset; i++)
    {
      checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),workingRes.c_str()));
      float * vecOffset = floatToFloatStar((float) -i+acqOffset);
      checkWitRC(witSetBopEntryOffset(witRun(),acquireOp.c_str(),i+1,vecOffset));
      checkWitRC(witSetBopEntryLatestPeriod(witRun(),acquireOp.c_str(),i+1,np-i-1+acqOffset));
      checkWitRC(witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),i+1,WitTRUE));
      delete [] vecOffset;
    }
    
    // (3) Set the supply for period zero on the working part to the exogenous supply at period zero
    std::vector<float> exogSup;
    
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[0]);
  }
  
  // (4) Delete the enable operation and the bench part. ***DPC  mark the parts for purging
  //  checkWitRC(witPurgeData(witRun()));
  
  // (5) Run witHeurImplode
  checkWitRC(witHeurImplode(witRun()));
  
  // (6) Do some post processing 
  // Loop through each working resource and
  // (a) compute the minToGo(i) = min over { i <= t <= np} of residualVol(t)
  // (b) releaseQty(t) = minToGo(t) - minToGo(t-1)
  // (c) cumulativeReleaseQty(t) = cumulativeReleaseQty(t-1) + releaseQty(t)
  // (d) benchQty(t) = residualVol(t) - cumulativeReleaseQty(t)
  // (e) workingQty = consVol
  // Store the releaseQty, benchQty and workingQty in the appData
  
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireRes;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    std::vector<float> minToGo(np), residualQty, releaseQty(np), cumulativeReleaseQty(np), benchQty(np), workingQty(np), acquireQty;
    workingQty = witGetNameAttribute(witGetPartConsVol, workingRes);
    residualQty = witGetNameAttribute(witGetPartResidualVol, workingRes);
    acquireQty = witGetNameAttribute(witGetOperationExecVol, acquireRes);
    minToGo[np-1] = residualQty[np-1];
    int i;
    for (i=np-2; i>=0; i--){
      if (residualQty[i] <= minToGo[i+1])
        minToGo[i] = residualQty[i];
      else
        minToGo[i] = minToGo[i+1];
    }
    releaseQty[0] = minToGo[0];
    for (i=1; i<np; i++)
      releaseQty[i] = minToGo[i] - minToGo[i-1];
    cumulativeReleaseQty[0] = releaseQty[0];
    for (i=1; i<np; i++)
      cumulativeReleaseQty[i] = releaseQty[i] + cumulativeReleaseQty[i-1];
    for (i=0; i<np; i++)
      benchQty[i] = residualQty[i] - cumulativeReleaseQty[i];
    //write the answer into appData
    for (i=0; i<np; i++){
      setResourceWorkingQuantity(names[r],i,workingQty[i]);
      setResourceReleaseQuantity(names[r],i,releaseQty[i]);
      setResourceAcquireQuantity(names[r],i,acquireQty[i]);
      setResourceBenchQuantity(names[r],i,benchQty[i]);
    }
  }
  
  // (7) Reset productRate of acquireOp to one;  reset supplyVol of working resource in period zero to zero; purge
  // the wit model of the added BOP arcs
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp,workingRes;
    
    acquireOp = acquireResourceOperationName(names[r]);
    workingRes = workingResourceName(names[r]);
    
    int t;
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
    
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,0.0f);
  }
  checkWitRC(witPurgeData(witRun()));
}

void RCPproblem::saveMrpResults()
{
  // Save the MRP gross requirements away in the app data for the working resource
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  getResourceNames(names);
  int numResources = names.size();
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::vector<float> grossQty;
    grossQty = getResourceMRPGrossQuantity(names[r]);
    
    for (unsigned int t=0; t<grossQty.size(); t++ ){
             setResourceMrpQuantity(names[r],t,grossQty[t]);
    }
  }
}


void RCPproblem::saveOptimalResourceActionResults()
{
  // Save the working, release, acquire and bench results from the Optimal Resource Action plan in the app data for the working resource
  // Get list of all resources
  std::vector<RCPvectorString> resNames;
  int numResources;
  
  getResourceNames(resNames);
  numResources = resNames.size();
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) 
  {
    std::string enableOpName, benchResName, acquireOpName, scrapResName, enableScrapResName;
    std::vector<float> workingQty, releaseQty, acquireQty, benchQty, workingScrapQty, benchScrapQty;
    
    enableOpName=enableResourceOperationName(resNames[r]);
    benchResName=benchResourceName(resNames[r]);
    acquireOpName=acquireResourceOperationName(resNames[r]);
    scrapResName=scrapResourceName(resNames[r]);
    enableScrapResName=enableScrapResourceName(resNames[r]);

    workingQty = witGetNameAttribute(witGetOperationExecVol,enableOpName);
    workingScrapQty = witGetNameAttribute(witGetOperationExecVol,enableScrapResName);

    releaseQty = witGetNameAttribute(witGetOperationExecVol,scrapResName);  

    acquireQty = witGetNameAttribute(witGetOperationExecVol,acquireOpName);

    benchQty = witGetNameAttribute(witGetPartStockVol,benchResName);
    benchScrapQty = witGetNameAttribute(witGetPartScrapVol, scrapResName);
    
    //    int relLT = (int) getResourceReleaseTime(resNames[r]);
    for (unsigned int t=0; t<workingQty.size(); t++ ){
      setResourceWorkingQuantity(resNames[r],t,workingQty[t]+workingScrapQty[t]);
      //      if (t < relLT)
      //      setResourceReleaseQuantity(resNames[r],t,0.f);
      // else
      //setResourceReleaseQuantity(resNames[r],t,releaseQty[t-relLT]);
      setResourceReleaseQuantity(resNames[r],t,releaseQty[t]);
      setResourceAcquireQuantity(resNames[r],t,acquireQty[t]);
      setResourceBenchQuantity(resNames[r],t,benchQty[t]+benchScrapQty[t]);
    }
  }
}


void RCPproblem::gapGlut()
{
  //getTimer().printElapsedTime("in gapGlut");
  RCPoperationBomSubBomIndices subBomsAdded;

  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit0.dat"));


  if (getFormatName() != "FlexMix") {
     if ((getFormatName() != "DemandEngagement"))
        presolve04Feb(subBomsAdded);
        
     getTimer().printElapsedTime("after presolve in gapGlut");

     //  presolveForGapGlut();
     checkWitRC(witMrp(witRun()));
     getTimer().printElapsedTime("after witMrp");
     checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
     checkWitRC(witWriteData(witRun(),"wit1.dat"));
     getTimer().printElapsedTime("after witWriteData in gapGlut");


     saveMrpResults();
  }
  
  
  getTimer().printElapsedTime("after saveMrpResults in gapGlut");
  if (getFormatName()=="FlexMix") {
    presolveFlexMix();
    GapGlutFlexMix();
  }
 
  else {
  if (getAlgorithmName() == "priorityPlan"){  
    if (getFormatName() == "04Feb") 
      priorityGapGlut1(); 
    else if (getFormatName() == "DemandEngagement")
      priorityGapGlutDemandEngagement();
    else if (getFormatName() == "03Dec")
      priorityGapGlut2();
    else
      priorityGapGlut();
  }
  else
    {
      // assume this is the optimalGapGlut
      presolveForOptimalGapGlut();


      // witsetOptWithLotSizes no longer exists. See Bob's comments below
      //checkWitRC(witSetOptWithLotSizes(witRun(),WitFALSE));
      setOptWithLotSizes();      
      
      optimalGapGlut();
      postsolveForOptimalGapGlut();
    }
  }
  postsolve(subBomsAdded);

    // Reset the revenue and demand for each engagement back to zero
    if (getFormatName()!="DemandEngagement") {
        std::vector<std::string> engagementNames;
        getEngagementNames(engagementNames);
        unsigned int e;
        float * zeroQty = floatToFloatStar(0.0f);
        for( e=0; e<engagementNames.size(); ++e ) {
        std::string theEngagement = engagementName(engagementNames[e]);
        checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
        checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
        }
        
        delete[] zeroQty;
    }

    checkWitRC(witWriteData(witRun(),"wit2.dat"));
    getTimer().printElapsedTime("done solving in gapGlut");

}

void RCPproblem::resourceAction()
{
  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  
  RCPoperationBomSubBomIndices subBomsAdded;
  presolve04Feb(subBomsAdded);
  
  checkWitRC(witMrp(witRun()));
  saveMrpResults();
  //  checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
  if (getAlgorithmName() == "priorityPlan")
  {
    //checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
    priorityResourceAction();
  }
  else
  {
    //    checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
    optimalResourceAction();
  }
  checkWitRC(witWriteData(witRun(),"wit4.dat"));
  
  postsolve(subBomsAdded);
}


//-------------------------------------------------------------------------
// algorithm and problem Methods
//-------------------------------------------------------------------------
void RCPproblem::setAlgorithmName(const std::string & algName){
  algorithmName_ = algName;
}

void RCPproblem::setProblemName(const std::string & probName){
  problemName_=probName;
}

void RCPproblem::setFormatName(const std::string & forName){
  formatName_=forName;
}

std::string RCPproblem::getAlgorithmName(){
  return algorithmName_;
}

std::string RCPproblem::getProblemName(){
  return problemName_;
}

std::string RCPproblem::getFormatName(){
  return formatName_;
}

bool RCPproblem::isLongFormat(){
  if (resourceIdentifierNames_.size()!=0) return true;
  if (getFormatName() == "04Feb")
    return true;
  else
    return false;
}

//-------------------------------------------------------------------------
// Engagement Name Methods
//-------------------------------------------------------------------------
std::string RCPproblem::engagementName(const std::string & engagementName )
{
  return "engagement: "+engagementName;
}
std::string RCPproblem::engagementFamilyName(const std::string & engagementFamilyName )
{
  return "engagementFamily: "+engagementFamilyName;
}


std::string RCPproblem::engagementFromEngagementName(const std::string & engName)
{
  return textAfter(engName,"engagement: ");
}

std::string RCPproblem::demandTypeFromEngagementName(const std::string & engName)
{
  std::string demandType;
  demandType = textBetween(engName,"*","*");
  
  return demandType;
}

std::string RCPproblem::sortLayerEngagementName(const std::string & engagementName, const std::string & orderName)
{
  return "sortLayer: " + engagementName + " order: " + orderName;
}


//-------------------------------------------------------------------------
// Resource Name Methods
//-------------------------------------------------------------------------
std::string RCPproblem::acquireResourceOperationName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "acquire: "+baseResourceName(resourceAttributeVector);
}
std::string RCPproblem::acquireWorkingResourceName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "acquire working: "+baseResourceName(resourceAttributeVector);
}

std::string RCPproblem::benchResourceName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "bench: " + baseResourceName(resourceAttributeVector);
}

std::string RCPproblem::getBenchFromWorkingName(const std::string &workingName){
  return "bench: " + textAfter(workingName,"working: ");
}

std::string RCPproblem::getScrapFromWorkingName(const std::string &workingName){
  return "scrap: " + textAfter(workingName,"working: ");
}

std::string RCPproblem::getEnableScrapFromWorkingName(const std::string &workingName){
  return "enableScrap: " + textAfter(workingName,"working: ");
}

std::string RCPproblem::getAcquireOperationFromWorkingName(const std::string &workingName){
  return "acquire: " + textAfter(workingName,"working: ");
}


std::string RCPproblem::enableResourceOperationName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "enable: "+baseResourceName(resourceAttributeVector);
}
std::string RCPproblem::enableFlexResourceOperationName(const std::vector<std::string> &resourceAttributeVector, const std::vector<std::string> &targetAttributeVector )const
{
  return "enable: "+baseResourceName(resourceAttributeVector)+" TO " + baseResourceName(targetAttributeVector);
}

std::string RCPproblem::workingResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "working: "+baseResourceName(resourceIdentifierValues);
}

std::string RCPproblem::scrapResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "scrap: "+baseResourceName(resourceIdentifierValues);
}

std::string RCPproblem::enableScrapResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "enableScrap: "+baseResourceName(resourceIdentifierValues);
}

std::string RCPproblem::baseResourceName(const std::vector<std::string> &resourceAttributeVector )const
{ 
  std::string retVal;
  int numAttributes = resourceAttributeVector.size();
  //int x = getResourceIdentifierNames().size();
  //assert( getResourceIdentifierNames().size() ==  numAttributes );
  for (int i=0; i<numAttributes-1; i++) {
    std::string attributeName = getResourceIdentifierNames()[i];
    std::string attributeValue = resourceAttributeVector.at(i);
    retVal = retVal + attributeName + ": " + attributeValue + " ";
  }
  std::string attributeName = getResourceIdentifierNames()[numAttributes-1];
  std::string attributeValue = resourceAttributeVector.at(numAttributes-1);
  retVal = retVal + attributeName + ": " + attributeValue;
  return retVal;
}


std::string RCPproblem::baseNameFromWorkingResourceName(const std::string & workingName)
{
  return textAfter(workingName,"working: ");
}


//-------------------------------------------------------------------------
// Bom Name Methods
//------------------------------------------------------------------------- 
std::string RCPproblem::bomName(const std::string & engagementName, const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string retVal="bom op: "+engagementName + " ";
  for (unsigned int i=0; i<resourceIdentifierValues.size()-1; i++) {
    retVal = retVal+getResourceIdentifierNames()[i] + ": " + resourceIdentifierValues.at(i) + " ";
  }
  retVal = retVal + getResourceIdentifierNames()[resourceIdentifierValues.size()-1] + ": " + resourceIdentifierValues.at(resourceIdentifierValues.size()-1);
  return retVal;
}


std::string RCPproblem::engagementFromBomName(const std::string & bomName)const
{
  std::string nextToken = " "+getResourceIdentifierNames()[0];
  return textBetween(bomName,"bom op: ",nextToken);
}





//--------------------------------------------------------
// Get Bom Entry Index
// Return the bom entry index that matches input parms
// -1 returned if bomEntryIndex does not exist
int RCPproblem::getBomEntryIndex( 
                                 const std::string & opName, 
                                 const std::string & partName,
                                 int period
                                 ) const
{
  int retVal = -1;
  
  //int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  int nBoms;
  checkWitRC(witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms));
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    checkWitRC(witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit));
    if(partName==consPartFromWit) {
      // Operation and Part match, now see if bomEntry has correct period    
      RCPbomAppData * appData;
      checkWitRC(witGetBomEntryAppData(mutableWitRun(),opName.c_str(),bei,(void**)&appData));
      int bomEntryPeriod = appData->getPeriod();
      if ( bomEntryPeriod == period ) {      
        retVal=bei;
      }
      if(retVal!=-1) {        
        checkWitRC(witFree(consPartFromWit));
        break;
      }
    } 
    checkWitRC(witFree(consPartFromWit));
  }
  
  return retVal;
}

//--------------------------------------------------------
// Get Bom Entry Indices
// Return the bom entry indices that matches input parms
std::vector<int> RCPproblem::getBomEntryIndex( 
                                              const std::string & opName, 
                                              const std::string & partName
                                              ) const
{
  std::vector<int> retVal;
  
  //int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  assert(witOperationExists(opName) );
  int nBoms;
  checkWitRC(witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms));
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    checkWitRC(witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit));
    if(partName==consPartFromWit) {
      // Operation and Part match     
      retVal.push_back(bei);
    }
    checkWitRC(witFree(consPartFromWit));
  }
  return retVal;
}
//--------------------------------------------------------

// default constructor
RCPproblem::RCPproblem()
:
SCOproblemBase(),
resourceIdentifierNames_(),
mapResourceIdentifierNameToSubsPriority_(),
engagementNames_(),
resourceNames_(),
bomNames_(),
resourceIdToSubs_(),
resourceIdToResourceNames_(),
algorithmName_(),
problemName_(),
formatName_()
{
  checkWitRC(witSetExecEmptyBom(witRun(),WitTRUE));
}

// destructor
RCPproblem::~RCPproblem()
{
  if (witOK)
    gutsOfDestructor();
}

// copy constructor
RCPproblem::RCPproblem( const RCPproblem& source ):
SCOproblemBase(source),
resourceIdentifierNames_(),
mapResourceIdentifierNameToSubsPriority_(),
engagementNames_(),
resourceNames_(),
bomNames_(),
resourceIdToSubs_(),
resourceIdToResourceNames_(),
algorithmName_(),
problemName_(),
formatName_()
{
  gutsOfCopy(source);
}

// assignment operator
RCPproblem&
RCPproblem::operator=(const RCPproblem& rhs)
{  
  if (this != &rhs) { 
    SCOproblemBase::operator=(rhs);
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object
void RCPproblem::gutsOfCopy( const RCPproblem& source )
{
  resourceIdentifierNames_ = source.resourceIdentifierNames_;
  mapResourceIdentifierNameToSubsPriority_ = source.mapResourceIdentifierNameToSubsPriority_;
  engagementNames_ = source.engagementNames_;
  engagementFamilyNames_ = source.engagementFamilyNames_;
  resourceNames_ = source.resourceNames_;
  bomNames_ = source.bomNames_;
  resourceIdToSubs_ = source.resourceIdToSubs_;
  resourceIdToResourceNames_ = source.resourceIdToResourceNames_;
  algorithmName_  = source.algorithmName_;
  problemName_  = source.problemName_;
  formatName_  = source.formatName_;
  
  // copy engagement appData
  unsigned int e;
  std::vector<std::string> engagementNames;
  std::vector<std::string> engagementLocs;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;    
    RCPengagementAppData * sinkAppData;
    checkWitRC(witGetPartAppData(source.mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData));
    sinkAppData = new RCPengagementAppData(*srcAppData);    
    checkWitRC(witSetPartAppData(witRun(),theEngagement.c_str(),sinkAppData));
  }
  
  // copy rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPbomAppData * srcAppData;    
        RCPbomAppData * sinkAppData;
        checkWitRC(witGetBomEntryAppData(source.mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData));
        sinkAppData = new RCPbomAppData(*srcAppData);    
        checkWitRC(witSetBomEntryAppData(witRun(),theEngagement.c_str(),b,sinkAppData));
        
      } // end of b loop
    } // end of e loop
  } // finished copying rcp bom appData
  
  // copy resource appData
  {
    unsigned int r;
    //std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    std::vector<RCPvectorString> names;
    getResourceNames(names);
    for ( r=0; r<names.size(); ++r ) { 
      std::string resourceName = workingResourceName(names[r]);
      RCPresourceAppData * srcAppData;  
      RCPresourceAppData * sinkAppData;  
      checkWitRC(witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData));
      sinkAppData = new RCPresourceAppData(*srcAppData);   
      checkWitRC(witSetPartAppData(witRun(),resourceName.c_str(),sinkAppData)); 
    }
  }
  
  
}

// destructor
void RCPproblem::gutsOfDestructor()
{
  // delete engagement appData
  unsigned int e;
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;  
    checkWitRC(witGetPartAppData(mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData));
    delete srcAppData;
  }
  
  // delete rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPengagementAppData * srcAppData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData));
        delete srcAppData;
        
      } // end of b loop
    } // end of e loop
  } // finished deleting rcp bom appData
  
  // delete resource appData  //DLG THIS HAS A PROBLEM FOR FLEX MIX. DELETING IT IN THE WRONG PLACE
  {
    int r;
    
    std::vector<RCPvectorString> names;
    getResourceNames(names);
    int numResources = names.size();
    
    if (getFormatName()=="FlexMix") {
        for ( r=0; r<numResources; ++r ) { 
        RCPresourceAppData * srcAppData;
        std::string benchResWitName = benchResourceName(names[r]);
        checkWitRC(witGetPartAppData(mutableWitRun(),benchResWitName.c_str(),(void**)&srcAppData));
        delete srcAppData;
        }

    }
    else {
        for ( r=0; r<numResources; ++r ) { 
        RCPresourceAppData * srcAppData;
        std::string workingResWitName = workingResourceName(names[r]);
        checkWitRC(witGetPartAppData(mutableWitRun(),workingResWitName.c_str(),(void**)&srcAppData));
        delete srcAppData;
        }
    }
  }
  
}



#ifdef NDEBUG
#undef NDEBUG
#endif
//------------------------------------------------------------------------------
// Test function
//------------------------------------------------------------------------------
void
RCPproblem::test()
{
  CoinRelFltEq eq;
  
  {
    RCPproblem prob;
    
    prob.setNPeriods(12);
    assert( prob.getNPeriods() == 12 );
    
    prob.setTitle("wittitle");
    assert( prob.getTitle() == "wittitle");
    
    assert( prob.implosionCount()==0 );  
    
    
  }
  
  
#if 0  
  // Test engagements for throwing internal exception
  {
    
    RCPproblem prob;
    
    prob.setNPeriods(2);
    
    prob.addEngagement("engagement1");  
    prob.addEngagement("engagement2");
    
    assert(  prob.engagementExists("engagement1") );
    assert(  prob.engagementExists("engagement2") );
    assert( !prob.engagementExists("e3") );
    
    assert( prob.getEngagementRevenue("engagement1") == 0.0f );
    prob.setEngagementRevenue("engagement1",1.234f);
    assert( prob.getEngagementRevenue("engagement1") == 1.234f );
    {
      bool except = false;
      try {
        float revenue;
        // The following line should throw an RCPOptIntException
        revenue = prob.getEngagementRevenue("e4");
        // shouldn't go to the next line
        assert( revenue == -1234.0);
      }
      catch ( RCPOptIntException e ) {
        except = true;
      }
      assert( except );
    }
  }
#endif

  {
    RCPproblem prob;
    
    prob.setNPeriods(2);
    
    prob.addEngagement("engagement1");  
    prob.addEngagement("engagement2");
    
    assert(  prob.engagementExists("engagement1") );
    assert(  prob.engagementExists("engagement2") );
    assert( !prob.engagementExists("e3") );
    
    assert( prob.getEngagementRevenue("engagement1") == 0.0f );
    prob.setEngagementRevenue("engagement1",1.234f);
    assert( prob.getEngagementRevenue("engagement1") == 1.234f );
    
    prob.setEngagementStartPeriod("engagement1",1);
    assert( prob.getEngagementRequestedStartPeriod("engagement1") == 1 );
    
    //prob.setEngagementDuration("engagement1",3);
    //assert( prob.getEngagementDuration("engagement1") == 3 );
        
    std::vector<std::string> engagementNames;
    prob.getEngagementNames(engagementNames);
    assert( engagementNames.size()==2 );
    assert( engagementNames[0]=="engagement1" || engagementNames[1]=="engagement1" );
    assert( engagementNames[0]=="engagement2" || engagementNames[1]=="engagement2" );
    
    assert( !prob.getEngagementExecuted("engagement1") );
    
  }
  
  // Test resources
  {
    RCPproblem prob;
    prob.setNPeriods(4);
    
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    prob.addResourceIdentifierName("LOB");
    prob.addResourceIdentifierName("source");
    prob.addResourceIdentifierName("locName");
    
    assert( prob.resourceIdentifierNameExists("jobRole") );
    assert( !prob.resourceIdentifierNameExists("jobRoleXX") );
    
    assert( prob.getResourceIdentifierPriority("jobRole") == 0 );
    prob.setResourceIdentifierPriority("jobRole",123);
    assert( prob.getResourceIdentifierPriority("jobRole") == 123 );

    prob.setResourceIdentifierPriority("skillSet",456);
    assert( prob.getResourceIdentifierPriority("skillSet") == 456 );

    // test getResourceIdentifiersSortedByPriority is returning sorted list
    {
      std::vector<std::string> resIdsSortByPriority = prob.getResourceIdentifiersSortedByPriority();
      std::vector<std::string> resIds = prob.getResourceIdentifierNames();
      int sortedSize = resIdsSortByPriority.size();
      int unsortedSize = resIds.size();
      assert( sortedSize == unsortedSize );
      assert (resIdsSortByPriority[0] == "jobRole");
      assert (resIdsSortByPriority[1] == "skillSet");
      assert (resIdsSortByPriority[2] == "LOB");
      assert (resIdsSortByPriority[3] == "locName");
      assert (resIdsSortByPriority[4] == "source");

      //      int r;
      //      for ( r=1; r<resIdsSortByPriority.size(); ++r ) {
      //        int p0 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r-1]);
      //        int p1 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r  ]);
      //        assert( p0 <= p1 );
      //}
    }

    
    RCPvectorString res1;
    res1.push_back("appDeveloper");
    res1.push_back("java");
    res1.push_back("AMS");
    res1.push_back("IBM");
    res1.push_back("New York");
    prob.addResource(res1);
    //prob.addResource("appDeveloper","java", "AMS","IBM","New York");  
    
    RCPvectorString res2;
    res2.push_back("architect");
    res2.push_back("c++");
    res2.push_back("eBHS");
    res2.push_back("SUBCON");
    res2.push_back("l2");
    prob.addResource(res2);
    //rob.addResource("architect","c++","eBHS","SUBCON","l2");
    
    float time = prob.getResourceAcquireTime(res1);
    //float time = prob.getResourceAcquireTime("appDeveloper","java","AMS","IBM","New York");
    assert( time == 0.f);
    prob.setResourceAcquireTime(res1, 2.f);
    assert ( prob.getResourceAcquireTime(res1) == -2.f ); //note that we negate the
    //acquire time inside setResourceAcquireTime
    //so that logically it can be positive
    
    assert( prob.getResourceAcquireCost(res1) == 0 );
    prob.setResourceAcquireCost(res1, 100.f);
    assert ( prob.getResourceAcquireCost(res1) == 100.f );
    
    std::vector<RCPvectorString> resNames;
    prob.getResourceNames(resNames);
    assert(resNames.size()==2);
    assert( resNames[0][0]=="appDeveloper" || resNames[1][0]=="appDeveloper" );
    assert( resNames[0][0]=="architect" || resNames[1][0]=="architect" );
    
    assert( resNames[0][1]=="java" || resNames[1][1]=="java" );
    assert( resNames[0][1]=="c++" || resNames[1][1]=="c++" );
    
    assert( resNames[0][2]=="AMS" || resNames[1][2]=="AMS" );
    assert( resNames[0][2]=="eBHS" || resNames[1][2]=="eBHS" );
    
    assert( resNames[0][3]=="IBM" || resNames[1][3]=="IBM" );
    assert( resNames[0][3]=="SUBCON" || resNames[1][3]=="SUBCON" );
    
    assert( resNames[0][4]=="New York" || resNames[1][4]=="New York" );
    assert( resNames[0][4]=="l2" || resNames[1][4]=="l2" );
    
    // Test to ensure SupplyQuantity defaults to 0
    std::vector<float> sq = prob.getResourceSupplyQuantity(res2);
    assert( sq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==0.0f );
    
    std::vector<float> sqOrig = sq;
    
    // Test SupplyQuantity Set/Get
    sqOrig[2]=5.0f;
    prob.setResourceSupplyQuantity(res2,2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity(res2);
    
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    sqOrig[0]=2.0f;
    prob.setResourceSupplyQuantity(res2,0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity(res2);
    
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    prob.setResourceFixedCost(res1, 0, 1.0f);
    prob.setResourceFixedCost(res1, 1, 2.0f);
    prob.setResourceFixedCost(res1, 2, 3.0f);
    prob.setResourceFixedCost(res1, 3, 2.0f);
    
    std::vector<float> resourceCost = prob.getResourceFixedCost(res1);
    assert( resourceCost.size() == 4);
    assert( resourceCost[0]==1.0f );
    assert( resourceCost[1]==2.0f );
    assert( resourceCost[2]==3.0f );
    assert( resourceCost[3]==2.0f );
    

  }
  
  
  // Test bom
  {
    RCPproblem prob;
    prob.setNPeriods(4);
    
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    prob.addResourceIdentifierName("LOB");
    prob.addResourceIdentifierName("source");
    prob.addResourceIdentifierName("locName");
    
    RCPvectorString res1;
    res1.push_back("appDeveloper");
    res1.push_back("java");
    res1.push_back("AMS");
    res1.push_back("IBM");
    res1.push_back("New York");
    prob.addResource(res1);  
    
    RCPvectorString res2;
    res2.push_back("architect");
    res2.push_back("c++");
    res2.push_back("eBHS");
    res2.push_back("SUBCON");
    res2.push_back("New York");
    prob.addResource(res2);
    
    prob.addEngagement("engagement1");
    
    std::vector<std::string> engagementNames;
    std::vector<RCPvectorString> resNames;
    prob.getBomNames(engagementNames,resNames);
    assert( resNames.size()==0 );
    assert( engagementNames.size()==0);
    
    // test add bom
    assert( !prob.bomExists("engagement1",res1) );
    assert( prob.getEngagementConsumedResources("engagement1").size() == 0 );
    prob.addBom("engagement1",res1);
    assert( prob.bomExists("engagement1",res1) );
    assert( prob.getEngagementConsumedResources("engagement1").size() == 1 );
    assert( prob.getEngagementConsumedResources("engagement1")[0][0]=="appDeveloper" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][1]=="java" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][2]=="AMS" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][3]=="IBM" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][4]=="New York" );
    
    // test add another bom
    assert( !prob.bomExists("engagement1",res2) );
    prob.addBom("engagement1",res2);
    assert( prob.bomExists("engagement1",res2) );
    assert( prob.getEngagementConsumedResources("engagement1").size() == 2 );
    assert( prob.getEngagementConsumedResources("engagement1")[0][0]=="appDeveloper" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][1]=="java" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][2]=="AMS" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][3]=="IBM" );
    assert( prob.getEngagementConsumedResources("engagement1")[0][4]=="New York" );
    assert( prob.getEngagementConsumedResources("engagement1")[1][0]=="architect" );
    assert( prob.getEngagementConsumedResources("engagement1")[1][1]=="c++" );
    assert( prob.getEngagementConsumedResources("engagement1")[1][2]=="eBHS" );
    assert( prob.getEngagementConsumedResources("engagement1")[1][3]=="SUBCON" );
    assert( prob.getEngagementConsumedResources("engagement1")[1][4]=="New York" );
    
    
    prob.getBomNames(engagementNames,resNames);
    assert( engagementNames.size()==2);
    assert( engagementNames[0]=="engagement1");
    assert( engagementNames[1]=="engagement1");
    
    assert( resNames[0][0]=="appDeveloper" || resNames[1][0]=="appDeveloper" );
    assert( resNames[0][0]=="architect" || resNames[1][0]=="architect" );
    
    assert( resNames[0][1]=="java" || resNames[1][1]=="java" );
    assert( resNames[0][1]=="c++" || resNames[1][1]=="c++" );
    
    assert( resNames[0][2]=="AMS" || resNames[1][2]=="AMS" );
    assert( resNames[0][2]=="eBHS" || resNames[1][2]=="eBHS" );
    
    assert( resNames[0][3]=="IBM" || resNames[1][3]=="IBM" );
    assert( resNames[0][3]=="SUBCON" || resNames[1][3]=="SUBCON" );
    
    assert( resNames[0][4]=="New York");
    std::string x = resNames[1][4];
    assert( resNames[1][4]=="New York");
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocNames;
    
    
    // Test to ensure usageQuantity defaults to 1
    std::vector<float> uq = prob.getBomUsageQuantity("engagement1",res2);
    assert( uq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==0.0f );
    
    std::vector<float> uqOrig = uq;
    
    // Test SupplyQuantity Set/Get
    uqOrig[2]=5.0f;
    prob.setBomUsageQuantity("engagement1",res2,2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("engagement1",res2,2) == 5.0f );
    uq = prob.getBomUsageQuantity("engagement1",res2);
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    uqOrig[0]=2.0f;
    prob.setBomUsageQuantity("engagement1",res2,0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("engagement1",res2,0) == 2.0f );
    uq = prob.getBomUsageQuantity("engagement1",res2);
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
    
    // test set/getting match usage
    assert( prob.getBomMatch("engagement1",res2,0,"jobRole")==0 );
    assert( prob.getBomMatch("engagement1",res2,0,"skillSet")==0 );
    assert( prob.getBomMatch("engagement1",res2,0,"locName")==0 );
    assert( prob.getBomMatch("engagement1",res2,0,"LOB")==0 );
    assert( prob.getBomMatch("engagement1",res2,0,"source")==0 );
    
    prob.setBomMatch("engagement1",res2,0,"jobRole",1);
    prob.setBomMatch("engagement1",res2,0,"skillSet",1);
    prob.setBomMatch("engagement1",res2,0,"locName",1);
    prob.setBomMatch("engagement1",res2,0,"LOB",1);
    prob.setBomMatch("engagement1",res2,0,"source",1);
    
    assert( prob.getBomMatch("engagement1",res2,0,"jobRole")==1 );
    assert( prob.getBomMatch("engagement1",res2,0,"skillSet")==1 );
    assert( prob.getBomMatch("engagement1",res2,0,"locName")==1 );
    assert( prob.getBomMatch("engagement1",res2,0,"LOB")==1 );
    assert( prob.getBomMatch("engagement1",res2,0,"source")==1 );
    
    // test set/getting subs usage
    assert( prob.getBomSub("engagement1",res2,0,"jobRole")==0 );
    assert( prob.getBomSub("engagement1",res2,0,"skillSet")==0 );
    assert( prob.getBomSub("engagement1",res2,0,"locName")==0 );
    assert( prob.getBomSub("engagement1",res2,0,"LOB")==0 );
    assert( prob.getBomSub("engagement1",res2,0,"source")==0 );
    
    prob.setBomSub("engagement1",res2,0,"jobRole",1);
    prob.setBomSub("engagement1",res2,0,"skillSet",1);
    prob.setBomSub("engagement1",res2,0,"locName",1);
    prob.setBomSub("engagement1",res2,0,"LOB",1);
    prob.setBomSub("engagement1",res2,0,"source",1);
    
    assert( prob.getBomSub("engagement1",res2,0,"jobRole")==1 );
    assert( prob.getBomSub("engagement1",res2,0,"skillSet")==1 );
    assert( prob.getBomSub("engagement1",res2,0,"locName")==1 );
    assert( prob.getBomSub("engagement1",res2,0,"LOB")==1 );
    assert( prob.getBomSub("engagement1",res2,0,"source")==1 );
  }
  // Test skillSubs
  {
    RCPproblem prob;
    std::vector<std::string> fromSkills, toSkills;
    prob.getSubsNames("skillSet",fromSkills,toSkills);
    assert(fromSkills.size()==0);
    assert(toSkills.size()==0);
    const std::string resIdName = "skillSet";
    
    
    assert( !prob.subsExists(resIdName,"java","c++") );
    prob.addSubs(resIdName,"java","c++");
    assert( prob.subsExists(resIdName,"java","c++") );
    prob.getSubsNames(resIdName,fromSkills,toSkills);
    assert(fromSkills.size()==1);
    assert(toSkills.size()==1);
    assert(fromSkills[0]=="java");
    assert(toSkills[0]=="c++");
    
    prob.setSubsCost(resIdName,"java","c++",2.0f);
    assert( eq(prob.getSubsCost(resIdName,"java","c++"),2.0f) );
    
    prob.setSubsLeadTime(resIdName,"java","c++",3.0f);
    assert( eq(prob.getSubsLeadTime(resIdName,"java","c++"),3.0f) );
    
    prob.addSubs(resIdName,"sA","sB");
    prob.getSubsNames(resIdName,fromSkills,toSkills);
    assert(fromSkills.size()==2);
    assert(toSkills.size()==2);
    assert(fromSkills[1]=="sA");
    assert(toSkills[1]=="sB");
    
    assert(  prob.subsExists(resIdName,"sA","sB") );
    assert( !prob.subsExists(resIdName,"sB","sA") );
    
  } // end test skillSubs
  
  // Test assignment operator
  {
    RCPproblem prob0;
    {
      RCPproblem prob1;
      prob1.setNPeriods(2);
      
      prob1.addEngagement("engagement1");
      
      prob1.setEngagementRevenue("engagement1",1.0f);
      prob1.setEngagementStartPeriod("engagement1",1);
      //prob1.setEngagementDuration("engagement1",3);
      
      assert(prob1.getEngagementRevenue("engagement1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("engagement1")==1);
      //assert(prob1.getEngagementDuration("engagement1")==3);
      
      prob0=prob1;
    }
    
    assert(prob0.getEngagementRevenue("engagement1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("engagement1")==1);
    //assert(prob0.getEngagementDuration("engagement1")==3);    
  }
  
  RcpOptCalendar rcpcal;

  // Test gapGlut priorityPlan
  {
    RCPproblem prob_subs;
    std::string inputDirectory, outputDirectory;
    std::cout << "example_prioritysubstitute" << std::endl;
    inputDirectory = outputDirectory = "../data/example_prioritysubstitute";
    //this problem must use priority substitute skills to satisfy demand
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "gapGlut");
    assert(prob_subs.getAlgorithmName() == "priorityPlan");
    
    
    // do solve in loop to make sure resolving works
    int r;
    for (r=0; r<2; ++r ) {
      prob_subs.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("java");r1.push_back("IBM");r1.push_back("global");
      r2.push_back("j1");r2.push_back("c++");r2.push_back("Cont");r2.push_back("non-global");
      r3.push_back("j2");r3.push_back("java");r3.push_back("IBM");r3.push_back("non-global");
      r4.push_back("j2");r4.push_back("c++");r4.push_back("PRIORITY");r4.push_back("global");

      //the following are the supplied resources (not demanded). These are used for gap glut checks
       r5.push_back("j2");r5.push_back("c++");r5.push_back("Cont");r5.push_back("global");
       r6.push_back("j2");r6.push_back("c++");r6.push_back("Supp");r6.push_back("global");
       r7.push_back("j2");r7.push_back("c++");r7.push_back("IBM");r7.push_back("global");

      
      //check that appropriate substitute arcs are there
      {
        std::string r1str   = prob_subs.baseResourceName(r1);
        std::string r2str   = prob_subs.baseResourceName(r2);
        std::string r3str   = prob_subs.baseResourceName(r3);
        std::string r4str   = prob_subs.baseResourceName(r4);
        std::string r5str   = prob_subs.baseResourceName(r5);
        std::string r6str   = prob_subs.baseResourceName(r6);
        std::string r7str   = prob_subs.baseResourceName(r7);
        
        
        // Get resources that are substituting for r1
        RCPcollectionOfStrings subsRes;
        
        prob_subs.getSubsResources(
          createEngagementName(r1),
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(
          createEngagementName(r2),
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(
          createEngagementName(r3),
          r3,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );

        prob_subs.getSubsResources(
          createEngagementName(r4),
          r4,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   != subsRes.end() );  
        assert( subsRes.find( r6str )   != subsRes.end() ); 
        assert( subsRes.find( r7str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );

       }
    
      //check that the gaps and gluts are correct
      //because of the priority aversion, the IBM and Cont substitutes for
      //prioritySubstitutes should get used first. The Supp substititute won't be
      //needed, so there will be a glut of that
      {
        std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r2);
        glutQty = prob_subs.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r3);
        glutQty = prob_subs.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r4);
        glutQty = prob_subs.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r5);
        glutQty = prob_subs.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r6);
        glutQty = prob_subs.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r7);
        glutQty = prob_subs.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
      }
    } // end of for r loop
  }
  
  // gapGlut priority
  {
    RCPproblem prob_subs;
    //a more complex example with levels of priority of substitution
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_ron";
    //this problem must use priority substitute skills to satisfy demand
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "gapGlut");
    assert(prob_subs.getAlgorithmName() == "priorityPlan");
    
    // solve in loop to ensure resolving is working
    int r;
    for ( r=0; r<2; ++r ) {
      
      prob_subs.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15;
      
      r1.push_back("j1");r1.push_back("java");r1.push_back("IBM");r1.push_back("global");r1.push_back("chicago");r1.push_back("US");
      r2.push_back("j2");r2.push_back("c++");r2.push_back("IBM");r2.push_back("global");r2.push_back("chicago");r2.push_back("US");
      r3.push_back("j2");r3.push_back("c++");r3.push_back("IBM");r3.push_back("global");r3.push_back("akron");r3.push_back("US");
      r4.push_back("j1");r4.push_back("java");r4.push_back("Cont");r4.push_back("non-global");r4.push_back("akron");r4.push_back("US");
      r5.push_back("j1");r5.push_back("java");r5.push_back("Supp");r5.push_back("non-global");r5.push_back("akron");r5.push_back("US");
      r6.push_back("j1");r6.push_back("java");r6.push_back("WOS");r6.push_back("non-global");r6.push_back("akron");r6.push_back("US");
      r7.push_back("j3");r7.push_back("s3");r7.push_back("IBM");r7.push_back("non-global");r7.push_back("london");r7.push_back("GB");
      r8.push_back("j3");r8.push_back("s3");r8.push_back("IBM");r8.push_back("non-global");r8.push_back("akron");r8.push_back("US");
      r9.push_back("j3");r9.push_back("s3");r9.push_back("Cont");r9.push_back("global");r9.push_back("newyork");r9.push_back("US");
      r10.push_back("j3");r10.push_back("s3");r10.push_back("Cont");r10.push_back("non-global");r10.push_back("newyork");r10.push_back("US");
      r11.push_back("j2");r11.push_back("c++");r11.push_back("IBM");r11.push_back("global");r11.push_back("UNSPECIFIED");r11.push_back("US");
      r12.push_back("j1");r12.push_back("java");r12.push_back("PRIORITY");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
      r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("UNSPECIFIED");r13.push_back("PRIORITY");
      r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("PRIORITY");r14.push_back("newyork");r14.push_back("US");
      r15.push_back("j3");r15.push_back("UNSPECIFIED");r15.push_back("Cont");r15.push_back("non-global");r15.push_back("newyork");r15.push_back("US");   
      
      //check that the gaps and gluts are correct
      {       
        std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r2);
        glutQty = prob_subs.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r3);
        glutQty = prob_subs.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r4);
        glutQty = prob_subs.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r5);
        glutQty = prob_subs.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r6);
        glutQty = prob_subs.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r7);
        glutQty = prob_subs.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r8);
        glutQty = prob_subs.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r9);
        glutQty = prob_subs.getResourceGlutQuantity(r9);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r10);
        glutQty = prob_subs.getResourceGlutQuantity(r10);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r11);
        glutQty = prob_subs.getResourceGlutQuantity(r11);
        assert(gapQty[0]==1.0 ); //uncomment this line when priority subtitution is implemented
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r12);
        glutQty = prob_subs.getResourceGlutQuantity(r12);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r13);
        glutQty = prob_subs.getResourceGlutQuantity(r13);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r14);
        glutQty = prob_subs.getResourceGlutQuantity(r14);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r15);
        glutQty = prob_subs.getResourceGlutQuantity(r15);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
      }
    } // end of for r loop (resolve loop)   
  }
  
  // ResourceAction OptimalPlan
  {
    RCPproblem prob_subs;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example4";
    //this problem must use substitute skills to satisfy engagements
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "resourceAction");
    assert(prob_subs.getAlgorithmName() == "optimalPlan");
    
    prob_subs.resourceAction(); 
    double expectedObjValue = 4778.0;
    double obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
    // Resolve
    // Does not work because resolving is does not yet work
    prob_subs.resourceAction(); 
    obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
    //check that appropriate substitute arcs are there
    {
      // Create base name for each resource
      RCPvectorString r1s1ResVal,r1s2ResVal,r2s1ResVal,r2s2ResVal,r1as1ResVal,r1as2ResVal,r1s1aResVal,r2s1aResVal,r1as1aResVal;
      
      r1s1ResVal.push_back("appDeveloper");r1s1ResVal.push_back("java");r1s1ResVal.push_back("AMS");r1s1ResVal.push_back("IBM");r1s1ResVal.push_back("New York");
      r1s2ResVal.push_back("appDeveloper");r1s2ResVal.push_back("c++");r1s2ResVal.push_back("AMS");r1s2ResVal.push_back("IBM");r1s2ResVal.push_back("New York");
      r2s1ResVal.push_back("architect");r2s1ResVal.push_back("java");r2s1ResVal.push_back("AMS");r2s1ResVal.push_back("IBM");r2s1ResVal.push_back("New York");
      r2s2ResVal.push_back("architect");r2s2ResVal.push_back("c++");r2s2ResVal.push_back("AMS");r2s2ResVal.push_back("IBM");r2s2ResVal.push_back("New York");
      
      r1as1ResVal.push_back("appDevelopera");r1as1ResVal.push_back("java"); r1as1ResVal.push_back("AMS");r1as1ResVal.push_back("IBM");r1as1ResVal.push_back("New York");
      r1as2ResVal.push_back("appDevelopera");r1as2ResVal.push_back("c++"); r1as2ResVal.push_back("AMS");r1as2ResVal.push_back("IBM");r1as2ResVal.push_back("New York");
      r1s1aResVal.push_back("appDeveloper"); r1s1aResVal.push_back("javaa");r1s1aResVal.push_back("AMS");r1s1aResVal.push_back("IBM");r1s1aResVal.push_back("New York");
      r2s1aResVal.push_back("architect"); r2s1aResVal.push_back("javaa");r2s1aResVal.push_back("AMS");r2s1aResVal.push_back("IBM");r2s1aResVal.push_back("New York");
      
      r1as1aResVal.push_back("appDevelopera");r1as1aResVal.push_back("javaa");r1as1aResVal.push_back("AMS");r1as1aResVal.push_back("IBM");r1as1aResVal.push_back("New York");
      
      std::string r1s1   = prob_subs.baseResourceName(r1s1ResVal);
      std::string r1s2   = prob_subs.baseResourceName(r1s2ResVal);
      std::string r2s1   = prob_subs.baseResourceName(r2s1ResVal);
      std::string r2s2   = prob_subs.baseResourceName(r2s2ResVal);
      std::string r1as1  = prob_subs.baseResourceName(r1as1ResVal);
      std::string r1as2  = prob_subs.baseResourceName(r1as2ResVal);
      std::string r1s1a  = prob_subs.baseResourceName(r1s1aResVal);
      std::string r2s1a  = prob_subs.baseResourceName(r2s1aResVal);
      std::string r1as1a = prob_subs.baseResourceName(r1as1aResVal);
      
      // Get resources that are substituting for engagement: e1
      // and resource: "appDeveloper","java","New York","AMS","IBM"
      RCPcollectionOfStrings subsRes;
      
      prob_subs.getSubsResources(
        "engagement1",r1s1ResVal,subsRes);
      
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  != subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  != subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) != subsRes.end() ); 
      assert( subsRes.size() == 3 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "architect","java","New York","AMS","IBM"
      prob_subs.getSubsResources(
        "engagement1",r2s1ResVal,
        //"architect","java","New York","AMS","IBM",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  != subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );        
      assert( subsRes.size() == 1 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "appDeveloper","c++","New York","AMS","IBM"
      prob_subs.getSubsResources(
        "engagement1",r1s2ResVal,
        //"appDeveloper","c++","New York","AMS","IBM",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  != subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() ); 
      assert( subsRes.size() == 1 );  
      
      
      // Get resources that are substituting for engagement: e1
      // and resource: "architect","c++","New York","AMS","IBM"
      prob_subs.getSubsResources(
        "engagement1",r2s2ResVal,
        //"architect","c++","New York","AMS","IBM",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );   
      assert( subsRes.size() == 0 );
      
    }
    
    // resolve again
    prob_subs.resourceAction(); 
    obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
  }
  {
    RCPproblem prob_subs;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example4";
    //this problem must use substitute skills to satisfy engagements
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "resourceAction");
    assert(prob_subs.getAlgorithmName() == "optimalPlan");
    
    
    prob_subs.resourceAction(); 
  }
  
  
  //now do some meaningful tests with various test directories.
  {
    RCPproblem prob_baseline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_baseline";
    populate(prob_baseline, inputDirectory, outputDirectory, rcpcal);
    
    // solve a few times making sure resolve works
    int r;
    for ( r=0; r<3; ++r ) {
      prob_baseline.gapGlut(); 
      
      RCPvectorString DetailA;
      DetailA.push_back("DetailA");DetailA.push_back("java");DetailA.push_back("AMS");DetailA.push_back("IBM");DetailA.push_back("New York");
      std::vector<float> gapQty = prob_baseline.getResourceGapQuantity(DetailA);
      std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 );
      
      RCPvectorString DetailB;
      DetailB.push_back("DetailB");DetailB.push_back("java");DetailB.push_back("AMS");DetailB.push_back("IBM");DetailB.push_back("New York");
      gapQty = prob_baseline.getResourceGapQuantity(DetailB);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 );
      
      RCPvectorString DetailC;
      DetailC.push_back("DetailC");DetailC.push_back("java");DetailC.push_back("AMS");DetailC.push_back("IBM");DetailC.push_back("New York");
      gapQty = prob_baseline.getResourceGapQuantity(DetailC);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==10.0 ); //or -10?
      
      DetailA.clear();
      DetailA.push_back("DetailA");DetailA.push_back("java");DetailA.push_back("AMS");DetailA.push_back("IBM");DetailA.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailA);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==30.0 ); //or -30?
      
      DetailB.clear();
      DetailB.push_back("DetailB");DetailB.push_back("java");DetailB.push_back("AMS");DetailB.push_back("IBM");DetailB.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailB);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==10.0 ); //or -10?
      
      DetailC.clear();
      DetailC.push_back("DetailC");DetailC.push_back("java");DetailC.push_back("AMS");DetailC.push_back("IBM");DetailC.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailC);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 ); 
    }    
  }
 
  {
    RCPproblem prob_nasco_january;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/nasco_january";  
    populate(prob_nasco_january, inputDirectory, outputDirectory, rcpcal);
    
 
    prob_nasco_january.priorityNASCO(); 
      
    RCPvectorString resource;
    resource.push_back("Back End");resource.push_back("5");
    std::vector<float> gapQty = prob_nasco_january.getResourceGapQuantity(resource);
    std::vector<float> glutQty = prob_nasco_january.getResourceGlutQuantity(resource);
    assert(glutQty[0]==62.0 );
    assert(glutQty[1]==112.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[1]==0.0 );
    
    

    resource.clear();
    resource.push_back("Front End");resource.push_back("5");
    gapQty = prob_nasco_january.getResourceGapQuantity(resource);
    glutQty = prob_nasco_january.getResourceGlutQuantity(resource);
    assert(glutQty[1]==24.0 );
    assert(glutQty[2]==0.0 );
    assert(gapQty[1]==0.0 );
    float foo=gapQty[2];
    assert(gapQty[2]==76.0 );
       
  
  }
 {  //tests skill mix
    RCPproblem prob_nasco;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_NASCO_test";  
    populate(prob_nasco, inputDirectory, outputDirectory, rcpcal);
    
    int nPeriods = prob_nasco.getNPeriods();
    prob_nasco.priorityNASCO(); 
      
    RCPvectorString resource;
    resource.push_back("Back End");resource.push_back("3");
    std::vector<float> gapQty = prob_nasco.getResourceGapQuantity(resource);
    std::vector<float> glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==0.0 );
    assert(glutQty[1]==0.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[1]==98.0 );
    
    

    resource.clear();
    resource.push_back("Front End");resource.push_back("5");
    gapQty = prob_nasco.getResourceGapQuantity(resource);
    glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==32.0 );
    assert(glutQty[1]==12.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[0]==0.0 );
       
    resource.clear();
    resource.push_back("Online");resource.push_back("2");
    gapQty = prob_nasco.getResourceGapQuantity(resource);
    glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==0.0 );
    assert(glutQty[1]==0.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[1]==40.0 );
    
    //now check the implosion results, with suggested timings
    int engagementExecuted = prob_nasco.getEngagementExecuted("New Work A");
    int reqStartPeriod = prob_nasco.getEngagementRequestedStartPeriod("New Work A");
    assert(engagementExecuted==1);
    std::vector<float> quantity = prob_nasco.getEngagementExecutionQuantity("New Work A");
    for(int thePeriod=0; thePeriod<nPeriods; thePeriod ++) {
       if (thePeriod != 2)
           assert(quantity[thePeriod]==0);
       else
           assert(quantity[thePeriod]==1);
    }
    
    //now check the impossible one
    engagementExecuted = prob_nasco.getEngagementExecuted("Impossible Work");
    assert(engagementExecuted==0);
    
    
         
  }
{  //tests not using skill mix
    RCPproblem prob_nasco;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_NASCO_test_primary";  
    populate(prob_nasco, inputDirectory, outputDirectory, rcpcal);
    
 
    prob_nasco.priorityNASCO(); 
      
    RCPvectorString resource;
    resource.push_back("Back End");resource.push_back("3");
    std::vector<float> gapQty = prob_nasco.getResourceGapQuantity(resource);
    std::vector<float> glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==0.0 );
    assert(glutQty[1]==0.0 );
    assert(gapQty[0]==120.0 );
    assert(gapQty[1]==260.0 );
    
    

    resource.clear();
    resource.push_back("Front End");resource.push_back("5");
    gapQty = prob_nasco.getResourceGapQuantity(resource);
    glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==32.0 );
    assert(glutQty[1]==12.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[0]==0.0 );
 
    resource.clear();
    resource.push_back("Online");resource.push_back("2");
    gapQty = prob_nasco.getResourceGapQuantity(resource);
    glutQty = prob_nasco.getResourceGlutQuantity(resource);
    assert(glutQty[0]==162.0 );
    assert(glutQty[1]==112.0 );
    assert(gapQty[0]==0.0 );
    assert(gapQty[0]==0.0 );      
  
  }
  {
    RCPproblem prob_flexmix;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/testflexmix";
    populate(prob_flexmix, inputDirectory, outputDirectory, rcpcal);
    
    prob_flexmix.gapGlut(); 
      
    RCPvectorString DetailA,DetailB,DetailC,DetailD;
    DetailA.push_back("developer");DetailA.push_back("c++");DetailA.push_back("global");DetailA.push_back("SO");DetailA.push_back("IBM");DetailA.push_back("unmatched");
    std::vector<float> gapQty = prob_flexmix.getFlexibleResourceGapQuantity(DetailA);
    std::vector<float> glutQty = prob_flexmix.getFlexibleResourceGlutQuantity(DetailA);
    double objValue = prob_flexmix.getObjValue();
    assert(gapQty[0]== 0.0 );
    assert(glutQty[0]==2.0 );
    assert(gapQty[1]== 0.0 );
    assert(glutQty[1]==1.0 );
    DetailB.push_back("developer");DetailB.push_back("java");DetailB.push_back("global");DetailB.push_back("SO");DetailB.push_back("IBM");DetailB.push_back("unmatched");
    gapQty = prob_flexmix.getFlexibleResourceGapQuantity(DetailB);
    glutQty = prob_flexmix.getFlexibleResourceGlutQuantity(DetailB);
    assert(gapQty[0]== 2.0 );
    assert(glutQty[0]==0.0 );      
    assert(gapQty[1]== 0.0 );
    assert(glutQty[1]==0.0 );      
    DetailC.push_back("developer");DetailC.push_back("java");DetailC.push_back("global");DetailC.push_back("SO");DetailC.push_back("CONT");DetailC.push_back("unmatched");
    gapQty = prob_flexmix.getFlexibleResourceGapQuantity(DetailC);
    glutQty = prob_flexmix.getFlexibleResourceGlutQuantity(DetailC);
    assert(gapQty[0]== 0.0 );
    assert(glutQty[0]==0.0 );      
    assert(gapQty[1]== 0.0 );
    assert(glutQty[1]==0.0 );   
    DetailD.push_back("developer");DetailD.push_back("java");DetailD.push_back("global");DetailD.push_back("SO");DetailD.push_back("PRIORITY");DetailD.push_back("unmatched");
    gapQty = prob_flexmix.getFlexibleResourceGapQuantity(DetailD);
    glutQty = prob_flexmix.getFlexibleResourceGlutQuantity(DetailD);
    assert(gapQty[0]== 0.0 );
    assert(glutQty[0]==0.0 );      
    assert(gapQty[1]== 2.0 );
    assert(glutQty[1]==0.0 );       
  }
 
  {
    RCPproblem prob_acquire;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_acquire";
    //this problem has a short time horizon, and revenue is set so that
    //acquiring new resources is worthwhile
    populate(prob_acquire, inputDirectory, outputDirectory, rcpcal);
    prob_acquire.resourceAction(); 
    double obj = prob_acquire.getObjValue();
    assert( eq(obj,4925.0) );
    
    //test that resources got acquired; 2 of appDevelper and 3 of r2, both in period 1
    //std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("appDeveloper","java","AMS","IBM","New York");
    
    RCPvectorString r1;
    r1.push_back("appDeveloper");r1.push_back("java");r1.push_back("AMS");r1.push_back("IBM");r1.push_back("New York");
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity(r1);
    float aq=acquireQty[1];
    assert(acquireQty[1]==2);
    
    //acquireQty =prob_acquire.getResourceAcquireQuantity("architect","c++","eBHS","SUBCON","New York");
    RCPvectorString r2;
    r2.push_back("architect");r2.push_back("c++");r2.push_back("eBHS");r2.push_back("SUBCON");r2.push_back("New York");
    acquireQty =prob_acquire.getResourceAcquireQuantity(r2);
    aq=acquireQty[1];
    assert(acquireQty[1]==3);
    
    //test that one engagement gets executed starting in period 1 (it has to wait one period to acquire the resources)
    assert(prob_acquire.getEngagementExecuted("engagement1"));
    assert(prob_acquire.getEngagementExecuted("engagement2"));
    assert(prob_acquire.getEngagementStartPeriod("engagement1")==0);
    assert(prob_acquire.getEngagementStartPeriod("engagement2")==2);
  }
  
  {
    RCPproblem prob_delay;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_delay";
    //this problem has a longer time horizon, and revenue is set so that
    //delaying the execution of jobs is worthwhile
    populate(prob_delay, inputDirectory, outputDirectory, rcpcal);
    prob_delay.resourceAction(); 
    double obj = prob_delay.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,4935.0) );
    //test that no resources were acquired, and that a job was done late
    assert(
      prob_delay.getEngagementStartPeriod("engagement2")==0 && prob_delay.getEngagementStartPeriod("engagement1")==3
      ||
      prob_delay.getEngagementStartPeriod("engagement2")==3 && prob_delay.getEngagementStartPeriod("engagement1")==0
      );
    
    RCPvectorString r1;
    r1.push_back("appDeveloper");r1.push_back("java");r1.push_back("AMS");r1.push_back("IBM");r1.push_back("New York");
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity(r1);
    //std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("appDeveloper","java","AMS","IBM","New York");
    
    unsigned int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
    RCPvectorString r2;
    r2.push_back("architect");r2.push_back("c++");r2.push_back("eBHS");r2.push_back("SUBCON");r2.push_back("New York");
    acquireQty =prob_delay.getResourceAcquireQuantity(r2);
    //acquireQty =prob_delay.getResourceAcquireQuantity("architect","c++","eBHS","SUBCON","New York");
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
  }

  {
    RCPproblem prob_decline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_decline";
    //this problem has a short time horizon, but revenue and acquire costs are such that
    //it is better to decline an engagement
    populate(prob_decline, inputDirectory, outputDirectory, rcpcal);
    prob_decline.resourceAction(); 
    double obj = prob_decline.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,265.0) );
    //test that resources were not acquired and that a job was declined
    assert(prob_decline.getEngagementExecuted("engagement1")==false);
    
    RCPvectorString r1;
    r1.push_back("appDeveloper");r1.push_back("java");r1.push_back("AMS");r1.push_back("IBM");r1.push_back("New York");
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity(r1);
    //std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("appDeveloper","java","AMS","IBM","New York");
    unsigned int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
    RCPvectorString r2;
    r2.push_back("architect");r2.push_back("c++");r2.push_back("eBHS");r2.push_back("SUBCON");r2.push_back("New York");
    acquireQty =prob_decline.getResourceAcquireQuantity(r2);;
    //acquireQty =prob_decline.getResourceAcquireQuantity("architect","c++","eBHS","SUBCON","New York");
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
  }

  {
    RCPproblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory, rcpcal);
    
    prob_IGS.resourceAction(); 
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39775.0f) );
    //test that the shipReward is set in periods 6 and 7
    std::vector<float> shipRewardQty = prob_IGS.getDemandShipReward("engagement1");
    int i;
    for(i=0; i<6; i++)
      assert(eq(shipRewardQty[i],0.0f));
    assert(eq(shipRewardQty[6],40000.0f));
    assert(eq(shipRewardQty[7],40000.0f));
    for(i=8; i<16; i++)
      assert(eq(shipRewardQty[i],0.0f));
    
    //int ed = prob_IGS.getEngagementDuration("engagement1");
    //assert(ed==2);
    int ela = prob_IGS.getEngagementLateAllowance("engagement1");
    assert( ela == 1 );
    int ersp = prob_IGS.getEngagementRequestedStartPeriod("engagement1");
    assert( ersp == 6 );
    int esp = prob_IGS.getEngagementStartPeriod("engagement1");
    assert( esp == 6 || esp == 7 );
  }
  
  {
    RCPproblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory, rcpcal);
    
    // don't let the engagement be done a period late
    prob_IGS.setEngagementLateAllowance("engagement1",0);
    
    prob_IGS.resourceAction(); 
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39775.0f) );
    int esp = prob_IGS.getEngagementStartPeriod("engagement1");
    assert( esp == 6 );
  }
  
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test2" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test2";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
    // do solve in loop to make sure resolving works


    prob.gapGlut();
      
    // Create base name for each resource
    RCPvectorString r1, r2;
      
    //the following are the demanded resources. These are the only ones which
    //we should look for substitute arcs on.
    r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
    //the following are the supplied resources (not demanded). These are used for gap glut checks
    r2.push_back("j1");r2.push_back("IBM");r2.push_back("G");
      
    //check that appropriate substitute arcs are there
    {
        std::string r2str   = prob.baseResourceName(r2);
        
        // Get resources that are substituting for r1
        RCPcollectionOfStrings subsRes;
        
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r2str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
        
     }
    
     //check that the gaps and gluts are correct
     {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
     }
  }
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test1" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test1";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
    // do solve in loop to make sure resolving works
    prob.gapGlut();
      
    // Create base name for each resource
    RCPvectorString r1, r2, r3, r4, r5, r6;
    RCPvectorString r7, r8, r9, r10;
      
    //the following are the demanded resources. These are the only ones which
    //we should look for substitute arcs on.
    r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
    r2.push_back("j1");r2.push_back("PRIORITY");r2.push_back("G");
    r3.push_back("j1");r3.push_back("CONT");r3.push_back("PRIORITY");
    r4.push_back("j1");r4.push_back("CONT");r4.push_back("N");
    r5.push_back("j2");r5.push_back("CONT");r5.push_back("PRIORITY");
    r6.push_back("j2");r6.push_back("CONT");r6.push_back("N");

    //the following are the supplied resources (not demanded). These are used for gap glut checks
    r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
    r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
    r9.push_back("j1");r9.push_back("CONT");r9.push_back("N");
    r10.push_back("j2");r10.push_back("CONT");r10.push_back("N");
      
    //check that appropriate substitute arcs are there
    {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        std::string r9str   = prob.baseResourceName(r9);
        std::string r10str   = prob.baseResourceName(r10);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
   
       // Get resources that are substituting for r3:firm
       prob.getSubsResources(
          "firm",
          r3,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.find( r8str )   != subsRes.end() );
       assert( subsRes.find( r9str )   != subsRes.end() );  
       assert( subsRes.size() == 2 );
       
       // Get resources that are substituting for r4:opportunity
       prob.getSubsResources(
          "opportunity",
          r4,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.size() == 0 );
       
       // Get resources that are substituting for r5:opportunity
       prob.getSubsResources(
          "opportunity",
          r5,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.find( r10str )   != subsRes.end() );  
       assert( subsRes.size() == 1 );
       
       // Get resources that are substituting for r6:forecast
       prob.getSubsResources(
          "forecast",
          r5,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.size() == 0 );       
     }  
       
     //check that the gaps and gluts are correct
     {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
    }
  }  
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test3" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test3";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r7, r8;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
      r2.push_back("j2");r2.push_back("CONT");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );
      
       
      prob.gapGlut();
      

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
       }
    } // end of for r loop
  }    
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test4" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test4";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r7, r8;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
      r2.push_back("j2");r2.push_back("CONT");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
     }
       

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
       }
  }    
 // Test ER5 format (gap glut/format 03Dec) examples
  {
      RCPproblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test5" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test5";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2, r3, r4, r5, r6, r6a, r6b;
      RCPvectorString r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j2");r2.push_back("PRIORITY");r2.push_back("G");
      r3.push_back("j2");r3.push_back("PRIORITY");r3.push_back("N");
      r4.push_back("j1");r4.push_back("CONT");r4.push_back("G");
      r5.push_back("j1");r5.push_back("IBM");r5.push_back("G");
      r6.push_back("j1");r6.push_back("CONT");r6.push_back("N");
      r6a.push_back("j3");r6a.push_back("IBM");r6a.push_back("G");
      r6b.push_back("j2");r6b.push_back("PRIORITY");r6b.push_back("PRIORITY");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      r9.push_back("j1");r9.push_back("CONT");r9.push_back("N");
      r10.push_back("j2");r10.push_back("IBM");r10.push_back("G");
      r11.push_back("j2");r11.push_back("CONT");r11.push_back("G");
      r12.push_back("j2");r12.push_back("CONT");r12.push_back("N");
      r13.push_back("j3");r13.push_back("IBM");r13.push_back("G");
      r14.push_back("j3");r14.push_back("CONT");r14.push_back("G");
      r15.push_back("j3");r15.push_back("CONT");r15.push_back("N");
      r16.push_back("j4");r16.push_back("CONT");r16.push_back("N");
      r17.push_back("j4");r17.push_back("IBM");r17.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        std::string r9str   = prob.baseResourceName(r9);
        std::string r10str   = prob.baseResourceName(r10);
        std::string r11str   = prob.baseResourceName(r11);
        std::string r12str   = prob.baseResourceName(r12);
        std::string r13str   = prob.baseResourceName(r13);
        std::string r14str   = prob.baseResourceName(r14);
        std::string r15str   = prob.baseResourceName(r15);
        std::string r16str   = prob.baseResourceName(r16);
        std::string r17str   = prob.baseResourceName(r17);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() ); 
        assert( subsRes.find( r13str )   != subsRes.end() ); 
        assert( subsRes.find( r17str )   != subsRes.end() ); 
        assert( subsRes.size() == 3 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
        
        // Get resources that are substituting for r3:firm
        prob.getSubsResources(
          "firm",
          r3,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
        
        // Get resources that are substituting for r4:opportunity
        prob.getSubsResources(
          "opportunity",
          r4,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r14str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
        
        // Get resources that are substituting for r5:opportunity
        prob.getSubsResources(
          "opportunity",
          r5,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.find( r13str )   != subsRes.end() );  
        assert( subsRes.find( r17str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );
        
        // Get resources that are substituting for r6:forecast
        prob.getSubsResources(
          "forecast",
          r6,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.find( r15str )   != subsRes.end() );
        assert( subsRes.find( r16str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );
        
        // Get resources that are substituting for r6a:forecast
        prob.getSubsResources(
          "forecast",
          r6a,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );
        
        // Get resources that are substituting for r6b:firm
        prob.getSubsResources(
          "firm",
          r6b,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.size() == 5 ); //this includes two "supplies" added with 0 quantity from the demand
        
        
        
     }
       

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6a);
        glutQty = prob.getResourceGlutQuantity(r6a);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6b);
        glutQty = prob.getResourceGlutQuantity(r6b);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r9);
        glutQty = prob.getResourceGlutQuantity(r9);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r10);
        glutQty = prob.getResourceGlutQuantity(r10);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r11);
        glutQty = prob.getResourceGlutQuantity(r11);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r12);
        glutQty = prob.getResourceGlutQuantity(r12);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r13);
        glutQty = prob.getResourceGlutQuantity(r13);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r14);
        glutQty = prob.getResourceGlutQuantity(r14);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob.getResourceGapQuantity(r15);
        glutQty = prob.getResourceGlutQuantity(r15);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r16);
        glutQty = prob.getResourceGlutQuantity(r16);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob.getResourceGapQuantity(r17);
        glutQty = prob.getResourceGlutQuantity(r17);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
      }
 
      //now check that the pegging is correct
      {
      float qSup,qAq;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //r1 should be satisfied by r7(supply) and r10(sub)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r1);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r1);
      assert(qAq==0);
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r1,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r10);
      //r2 should be satisfied by r11(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r2,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r11);
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r2);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r2);
      assert(qAq==0);
      // r3 should be satisfied by r12(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r3,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r12);
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r3);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r3);
      assert(qAq==0);
      //r4 should be satisfied by r8(supply)
      prob.getEngagementPeggedQuantitiesFromSubstitution("opportunity",0,r4,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("opportunity",0,r4);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("opportunity",0,r4);
      assert(qAq==0);
      //r5 should be satsified by r13(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("opportunity",0,r5,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r13);
      qSup = prob.getEngagementPeggedQuantityFromSupply("opportunity",0,r5);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("opportunity",0,r5);
      assert(qAq==0);
      //r6 should be satisfied by r9(supply) and r15(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r15);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("forecast",0,r6);
      assert(qAq==0);
      //r6a should be a gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6a,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6a);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("forecast",0,r6a);
      assert(qAq==1);
      //r6b should be a gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6b,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6b);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r6b);
      assert(qAq==1);
      }
  } 
 // Test ER5 format (gap glut/format 03Dec) examples
  {
      RCPproblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test6" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test6";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r3, r4, r5, r6, r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j1");r2.push_back("PRIORITY");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r3.push_back("j1");r3.push_back("IBM");r3.push_back("G");
      r4.push_back("j1");r4.push_back("CONT");r4.push_back("G");
      r5.push_back("j1");r5.push_back("WOS");r5.push_back("G");
      r6.push_back("j2");r6.push_back("CONT");r6.push_back("G");
      r7.push_back("j1");r7.push_back("JV");r7.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r3str   = prob.baseResourceName(r3);
        std::string r4str   = prob.baseResourceName(r4);
        std::string r5str   = prob.baseResourceName(r5);
        std::string r6str   = prob.baseResourceName(r6);
        std::string r7str   = prob.baseResourceName(r7);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r3str )   != subsRes.end() );  
        assert( subsRes.find( r4str )   != subsRes.end() );  
        assert( subsRes.find( r5str )   != subsRes.end() );  
        assert( subsRes.find( r6str )   != subsRes.end() );  
        assert( subsRes.size() == 4 );
        
      }
       

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
      }
 
      //now check that the pegging is correct
      {
      float qSup,qAq;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //r1 should be satisfied by r3(supply)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r1);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r1);
      assert(qAq==0);
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r1,qSub,subsResources);
      assert(qSub.size()==0);
      //r2 should be satisfied by r4(sub), r5(sub), r6(sub) and 1 gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r2,qSub,subsResources);
      assert(qSub.size()==3);
      assert((subsResources[0]==r4)||(subsResources[0]==r5)||(subsResources[0]==r6));
      assert((subsResources[1]==r4)||(subsResources[1]==r5)||(subsResources[1]==r6));
      assert((subsResources[2]==r4)||(subsResources[2]==r5)||(subsResources[2]==r6));
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r2);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r2);
      assert(qAq==1);
      // r3 should be satisfied by r12(sub)
      }
  } 
// Test ER5 format (gap glut/format 03Dec) examples
  {
      RCPproblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test7" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test7";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString d1, d3, d4, d5, d6, d7;
      RCPvectorString r1, r2, r3, r4, r5, r6, r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      d1.push_back("j1");d1.push_back("IBM");d1.push_back("G");
      d3.push_back("j1");d3.push_back("WOS");d3.push_back("N");
      d4.push_back("j1");d4.push_back("CONT");d4.push_back("N");
      d5.push_back("j2");d5.push_back("IBM");d5.push_back("PRIORITY");
      d6.push_back("j2");d6.push_back("PRIORITY");d6.push_back("PRIORITY");
      d7.push_back("j1");d7.push_back("IBM");d7.push_back("PRIORITY");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r1.push_back("j2");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j1");r2.push_back("IBM");r2.push_back("G");
      r3.push_back("j1");r3.push_back("CONT");r3.push_back("G");
      r4.push_back("j1");r4.push_back("IBM");r4.push_back("N");
      r5.push_back("j2");r5.push_back("CONT");r5.push_back("N");
      r6.push_back("j2");r6.push_back("IBM");r6.push_back("G");
      r7.push_back("j2");r7.push_back("CONT");r7.push_back("N");
      

      //check that the gaps and gluts are correct (just checking a couple)
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(d3);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(d3);
        assert(gapQty[2]==1.0 );
        assert(glutQty[2]==0.0 );
        gapQty = prob.getResourceGapQuantity(d1);
        glutQty = prob.getResourceGlutQuantity(d1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        
        //DLG the following seems to depend on platform
        glutQty = prob.getResourceGlutQuantity(r3);
        // assert((prob.getResourceGlutQuantity(r3)[1]==0.0 && prob.getResourceGlutQuantity(r7)[1]==1.0)||
        //(prob.getResourceGlutQuantity(r3)[1]==1.0 && prob.getResourceGlutQuantity(r7)[1]==0.0));
 
        // One of these will stay
        assert(prob.getResourceGlutQuantity(r3)[1]==0.0 && prob.getResourceGlutQuantity(r7)[1]==1.0);
        //assert(prob.getResourceGlutQuantity(r3)[1]==1.0 && prob.getResourceGlutQuantity(r7)[1]==0.0);

        
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[2]==0.0 );
        assert(glutQty[2]==1.0 );
        }
 
      //now check that the pegging is correct (just a couple)
      {
      float qSup;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //d1 (period 0) should be satisfied by r1(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,d1,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r1));
      //d1 (period 1) should be satisfied by r2(supply)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",1,d1);
      assert(qSup==1);
      // d4 should be satisfied by r5(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",2,d4,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r5));
      // d6 should be satisfied by r6(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",2,d6,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r6));
      }
  } 

  //tests using new "vector" format, testing matching (no substitution yet)
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match1";
    //this one matches everything, and has 2 gaps and 2 gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
    
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[2]);
    glutQty = prob.getResourceGlutQuantity(names[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    gapQty = prob.getResourceGapQuantity(names[3]);
    glutQty = prob.getResourceGlutQuantity(names[3]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match2";
    //this one matches on jobrole, but not skillset, and has 2 gaps and 2 gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
    
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==2);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==2);
    
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match3";
    //this one matches on skillset but not jobrole, and has no gaps or gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
    
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
  }
  //"expanded" 04Feb style 
  {
    RCPproblem prob_04Feb;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example04Feb";
    populate(prob_04Feb, inputDirectory, outputDirectory, rcpcal);
    prob_04Feb.gapGlut();
    
    
    std::vector<RCPvectorString> names;
    prob_04Feb.getResourceNames(names);
    
    std::vector<float> gapQty = prob_04Feb.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob_04Feb.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==2);
    gapQty = prob_04Feb.getResourceGapQuantity(names[9]);
    glutQty = prob_04Feb.getResourceGlutQuantity(names[9]);
    assert(gapQty[0]==2);
    assert(glutQty[0]==0);
    
    
    
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("j1");names.push_back("java");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j1");names.push_back("c++");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("java");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("c++");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("j2");names.push_back("c++");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("c++");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("j2");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); //this should be uncommented when column priority is working
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("java");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1); //this should be uncommented when column priority is working
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson1";
    //this one differs from example_tucson in that jobRoleMatch=0. This allows a gap
    //and glut to satisfy one another
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); //uncomment when priority columns are implemented
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); //uncomment when priority columns are implemented
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("unmatched");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); //this should be uncommented when column priority is working
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "tucson2" << std::endl;
    inputDirectory = outputDirectory = "../data/example_tucson2";
    //this one tests that more than one "indeterminate" will get done LAST
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("java");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("java");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("java");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("UNSPECIFIED");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("c++");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("java");names.push_back("Cont");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("java");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0); 
    assert(glutQty[0]==0);
    
    
  }
    {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson3";
    //this one is exactly the same as tucson1, except that there are two identical periods.
    //this is just to test that more than one period works as expected
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    assert(gapQty[1]==1);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("c++");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    assert(gapQty[1]==0);
    assert(glutQty[1]==1);
    
    names.clear();
    names.push_back("unmatched");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); 
    assert(glutQty[0]==0);
    assert(gapQty[1]==1); 
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("java");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
  }
 {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_startperiod";
    std::cout << "startperiod" << std::endl;
    //this one is just like tucson3, except there are 12 periods in the horizon,
    //but only 11 and 12 given.
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("java");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("java");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("java");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[10]==0);
    assert(glutQty[10]==0); 
    assert(gapQty[11]==0);
    assert(glutQty[11]==0); 
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("UNSPECIFIED");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[10]==1);
    assert(glutQty[10]==0); 
    assert(gapQty[11]==1);
    assert(glutQty[11]==0); 
    
    names.clear();
    names.push_back("c++");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("java");names.push_back("Cont");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==1);
    assert(gapQty[11]==0);
    assert(glutQty[11]==1);
    
    names.clear();
    names.push_back("java");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0); 
    assert(glutQty[0]==0);
    assert(gapQty[10]==0); 
    assert(glutQty[10]==0);
    assert(gapQty[11]==0); 
    assert(glutQty[11]==0);
    
    
  }

  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "startperiod1" << std::endl;
    inputDirectory = outputDirectory = "../data/example_startperiod1";
    //just make sure this doesn't crash.
    bool exceptionCaught=false;
    try {
        populate(prob, inputDirectory, outputDirectory, rcpcal);    }
    catch ( RcpOptException e ) {
        exceptionCaught = true;
    }
    assert (exceptionCaught);
  }
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "interleave_crash" << std::endl;
    inputDirectory = outputDirectory = "../data/interleave_crash";
    //just make sure this doesn't crash.
    bool exceptionCaught=false;
    try {
        populate(prob, inputDirectory, outputDirectory, rcpcal);
    }
    catch ( RcpOptException e ) {
        exceptionCaught = true;
    }
    assert (exceptionCaught);
  }

   {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    //just a simple to test to see if it runs
    inputDirectory = outputDirectory = "../data/example_finalformat";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();  
  }  
  
}
void RCPproblem::setSkillSetPosition(int skillSetPosition) {
   skillSetPosition_ = skillSetPosition;
}
int RCPproblem::getSkillSetPosition() {
   return skillSetPosition_;
}
@


1.304
log
@Added RcpProblem::setOptWithLotsSizes method to replace witSetOptWithLotSizes
(WIT no longer has the function witSetOptWithLotSizes).
Added some pragma's to reduce the warnings issued by the MS V8 compiler
@
text
@d5640 1
a5640 1
    inputDirectory = outputDirectory = "../data/NASCO_january";  
d7305 1
a7305 1
}@


1.303
log
@Modified to compile, by commenting out two calls to witSetOptWithLotSizes.
UnitTest does not now run.  Added comments from Bob on how to now implement witSetOptWithLotSizes.
@
text
@d2 1
d3929 3
a3931 1
void RCPproblem::optimalResourceAction()
d3933 1
a3933 3
  // witSetOptWithLotSizes no longer exists.  See Bob's comments below
  //checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
/*      
d3949 54
d4259 1
a4259 18

/*      
Hello, Folks.

Whoa; looks like RCP hasn't been built with a current version of WIT in a while. :) CVS indicates that I committed WIT with the optWithLotSizes attribute removed on 8/17/06. (As I recall, I checked with everybody first to see that it wasn't needed. We don't actually remove attributes very often.)

Anyway, the relevant new capability is called "MIP Mode": see the WIT Guide, chapter 1. The new attributes for it are:

problem.mipMode
operation.intExecVols
subEntry.intSubVols
demand.intShipVols

If you have any further questions, please let me know.

Bob Wittrock
*/
      
@


1.302
log
@added engagement families for the "portfolio" option.
@
text
@d3930 18
a3947 1
  checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
d4200 23
a4222 1
      checkWitRC(witSetOptWithLotSizes(witRun(),WitFALSE));
@


1.301
log
@changed a delete to a witFree
@
text
@d113 22
d268 10
d4278 5
d4540 1
@


1.300
log
@look for "panic"
@
text
@d48 10
d61 9
a70 9
  demandVol[period]=quantity;
  checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
  
  
  //force the demand to be met in the demanded period by setting the cum demand vol.
  //in the period
  checkWitRC(witSetDemandCumShipBounds(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol,demandVol,NULL));
  //checkWitRC(witSetDemandShipVol(witRun(),theEngagement.c_str(),demandName.c_str(),demandVol));
  delete [] demandVol;
@


1.299
log
@new files for handling nasco input
@
text
@d367 40
a406 1

@


1.298
log
@changes for nasco multiple skills
@
text
@d5511 1
a5511 1
 
d5542 18
@


1.297
log
@checked in some NASCO specific code
@
text
@d71 1
a71 1
   for (int i=0; i<names.size(); i++) {
d243 7
d267 1
d292 6
a297 1

d444 51
d576 15
d592 2
d595 10
d606 28
d636 10
d862 4
d1053 10
d1064 8
a1071 1

d1490 1
a1490 1
                        const std::vector<std::string> &resourceIdentifierValues,int period,float quantity)
d1500 1
d1513 13
a3055 1
    int foo=glutQty[0];
d3109 5
d3120 3
a3122 1

d3128 1
d3130 1
a3130 1
  int numResources;
d3132 1
d3134 2
a3135 1
  
a3136 3
  getResourceNames(names);
  numResources = names.size();
  
d3149 35
d4064 1
a4064 1
     if ((getFormatName() != "DemandEngagement") && (getFormatName() != "NASCO"))
d4076 2
a4077 2
     if (getFormatName()!="NASCO")
        saveMrpResults();
a4094 2
    else if (getFormatName() == "NASCO")
      priorityNASCO();
d5472 111
@


1.296
log
@fixed the reporting of required supply in the output gapGlut file.
@
text
@d54 2
a57 1

d874 1
d937 1
d1285 9
a1293 1
  return witGetNameAttribute(witGetPartReqVol,workingRes);
d2929 53
d3859 1
a3859 1
     if (getFormatName() != "DemandEngagement") 
d3861 1
d3871 2
a3872 1
     saveMrpResults();
d3890 2
d3904 1
a3904 1
    postsolve(subBomsAdded);
@


1.295
log
@changes for deal hub example (demandengagement format)
@
text
@d2827 1
a2827 9
  // (8) 
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero));
    delete [] vecZero;
  }
  
@


1.294
log
@giving some attribute values nice names (such as appDeveloper instead of r1)
@
text
@d41 61
d127 24
d198 2
d450 3
d460 2
d482 34
d521 1
d523 13
a535 15
      
    // Add parts and operations  
    checkWitRC(witAddPart(witRun(),acquireWorkingRes.c_str(),WitCAPACITY));
    checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
    float * execPenalty = floatToFloatStar(0.05f);
    checkWitRC(witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),execPenalty));

      
      
    // connect parts and operations.
    checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),acquireWorkingRes.c_str()));
      
 
      
    //Add it as a substitute
d537 15
a551 1
    checkWitRC(witAddSubsBomEntry(witRun(), theEngagement.c_str(), 0, acquireWorkingRes.c_str())); 
d553 2
a554 2
    checkWitRC(witSetSubsBomEntryObj1SubCost(witRun(),theEngagement.c_str(),0,0,subsCost));
    checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),0,0,100000000.0f));
d556 2
d688 2
a689 1
  
d707 5
d842 6
d1069 10
a1078 1

d1323 30
d2747 1
a2747 1
void RCPproblem::GapGlutFlexMix()
d2749 29
d2779 10
d2790 51
d2903 1
d3803 2
a3804 1
     presolve04Feb(subBomsAdded);
d3816 2
d3823 1
d3828 2
d3847 12
a3858 8
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    float * zeroQty = floatToFloatStar(0.0f);
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
      checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
a3859 2
    
    delete[] zeroQty;
@


1.293
log
@Modified to add a line for debugging
@
text
@d4066 2
a4067 2
    prob.addEngagement("e1");  
    prob.addEngagement("e2");
d4069 2
a4070 2
    assert(  prob.engagementExists("e1") );
    assert(  prob.engagementExists("e2") );
d4073 3
a4075 3
    assert( prob.getEngagementRevenue("e1") == 0.0f );
    prob.setEngagementRevenue("e1",1.234f);
    assert( prob.getEngagementRevenue("e1") == 1.234f );
d4098 2
a4099 2
    prob.addEngagement("e1");  
    prob.addEngagement("e2");
d4101 2
a4102 2
    assert(  prob.engagementExists("e1") );
    assert(  prob.engagementExists("e2") );
d4105 3
a4107 3
    assert( prob.getEngagementRevenue("e1") == 0.0f );
    prob.setEngagementRevenue("e1",1.234f);
    assert( prob.getEngagementRevenue("e1") == 1.234f );
d4109 2
a4110 2
    prob.setEngagementStartPeriod("e1",1);
    assert( prob.getEngagementRequestedStartPeriod("e1") == 1 );
d4112 2
a4113 2
    //prob.setEngagementDuration("e1",3);
    //assert( prob.getEngagementDuration("e1") == 3 );
d4118 2
a4119 2
    assert( engagementNames[0]=="e1" || engagementNames[1]=="e1" );
    assert( engagementNames[0]=="e2" || engagementNames[1]=="e2" );
d4121 1
a4121 1
    assert( !prob.getEngagementExecuted("e1") );
d4169 5
a4173 5
    res1.push_back("r1");
    res1.push_back("s1");
    res1.push_back("LOB1");
    res1.push_back("src1");
    res1.push_back("l1");
d4175 1
a4175 1
    //prob.addResource("r1","s1", "LOB1","src1","l1");  
d4178 4
a4181 4
    res2.push_back("r2");
    res2.push_back("s2");
    res2.push_back("LOB2");
    res2.push_back("src2");
d4184 1
a4184 1
    //rob.addResource("r2","s2","LOB2","src2","l2");
d4187 1
a4187 1
    //float time = prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1");
d4201 2
a4202 2
    assert( resNames[0][0]=="r1" || resNames[1][0]=="r1" );
    assert( resNames[0][0]=="r2" || resNames[1][0]=="r2" );
d4204 2
a4205 2
    assert( resNames[0][1]=="s1" || resNames[1][1]=="s1" );
    assert( resNames[0][1]=="s2" || resNames[1][1]=="s2" );
d4207 2
a4208 2
    assert( resNames[0][2]=="LOB1" || resNames[1][2]=="LOB1" );
    assert( resNames[0][2]=="LOB2" || resNames[1][2]=="LOB2" );
d4210 2
a4211 2
    assert( resNames[0][3]=="src1" || resNames[1][3]=="src1" );
    assert( resNames[0][3]=="src2" || resNames[1][3]=="src2" );
d4213 1
a4213 1
    assert( resNames[0][4]=="l1" || resNames[1][4]=="l1" );
d4269 5
a4273 5
    res1.push_back("r1");
    res1.push_back("s1");
    res1.push_back("LOB1");
    res1.push_back("src1");
    res1.push_back("l1");
d4277 5
a4281 5
    res2.push_back("r2");
    res2.push_back("s2");
    res2.push_back("LOB2");
    res2.push_back("src2");
    res2.push_back("l1");
d4284 1
a4284 1
    prob.addEngagement("e1");
d4293 10
a4302 10
    assert( !prob.bomExists("e1",res1) );
    assert( prob.getEngagementConsumedResources("e1").size() == 0 );
    prob.addBom("e1",res1);
    assert( prob.bomExists("e1",res1) );
    assert( prob.getEngagementConsumedResources("e1").size() == 1 );
    assert( prob.getEngagementConsumedResources("e1")[0][0]=="r1" );
    assert( prob.getEngagementConsumedResources("e1")[0][1]=="s1" );
    assert( prob.getEngagementConsumedResources("e1")[0][2]=="LOB1" );
    assert( prob.getEngagementConsumedResources("e1")[0][3]=="src1" );
    assert( prob.getEngagementConsumedResources("e1")[0][4]=="l1" );
d4305 14
a4318 14
    assert( !prob.bomExists("e1",res2) );
    prob.addBom("e1",res2);
    assert( prob.bomExists("e1",res2) );
    assert( prob.getEngagementConsumedResources("e1").size() == 2 );
    assert( prob.getEngagementConsumedResources("e1")[0][0]=="r1" );
    assert( prob.getEngagementConsumedResources("e1")[0][1]=="s1" );
    assert( prob.getEngagementConsumedResources("e1")[0][2]=="LOB1" );
    assert( prob.getEngagementConsumedResources("e1")[0][3]=="src1" );
    assert( prob.getEngagementConsumedResources("e1")[0][4]=="l1" );
    assert( prob.getEngagementConsumedResources("e1")[1][0]=="r2" );
    assert( prob.getEngagementConsumedResources("e1")[1][1]=="s2" );
    assert( prob.getEngagementConsumedResources("e1")[1][2]=="LOB2" );
    assert( prob.getEngagementConsumedResources("e1")[1][3]=="src2" );
    assert( prob.getEngagementConsumedResources("e1")[1][4]=="l1" );
d4323 2
a4324 2
    assert( engagementNames[0]=="e1");
    assert( engagementNames[1]=="e1");
d4326 2
a4327 2
    assert( resNames[0][0]=="r1" || resNames[1][0]=="r1" );
    assert( resNames[0][0]=="r2" || resNames[1][0]=="r2" );
d4329 2
a4330 2
    assert( resNames[0][1]=="s1" || resNames[1][1]=="s1" );
    assert( resNames[0][1]=="s2" || resNames[1][1]=="s2" );
d4332 2
a4333 2
    assert( resNames[0][2]=="LOB1" || resNames[1][2]=="LOB1" );
    assert( resNames[0][2]=="LOB2" || resNames[1][2]=="LOB2" );
d4335 2
a4336 2
    assert( resNames[0][3]=="src1" || resNames[1][3]=="src1" );
    assert( resNames[0][3]=="src2" || resNames[1][3]=="src2" );
d4338 1
a4338 1
    assert( resNames[0][4]=="l1");
d4340 1
a4340 1
    assert( resNames[1][4]=="l1");
d4345 1
a4345 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1",res2);
d4355 3
a4357 3
    prob.setBomUsageQuantity("e1",res2,2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1",res2,2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1",res2);
d4363 3
a4365 3
    prob.setBomUsageQuantity("e1",res2,0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1",res2,0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1",res2);
d4370 17
a4386 17
    assert( prob.getBomMatch("e1",res2,0,"jobRole")==0 );
    assert( prob.getBomMatch("e1",res2,0,"skillSet")==0 );
    assert( prob.getBomMatch("e1",res2,0,"locName")==0 );
    assert( prob.getBomMatch("e1",res2,0,"LOB")==0 );
    assert( prob.getBomMatch("e1",res2,0,"source")==0 );
    
    prob.setBomMatch("e1",res2,0,"jobRole",1);
    prob.setBomMatch("e1",res2,0,"skillSet",1);
    prob.setBomMatch("e1",res2,0,"locName",1);
    prob.setBomMatch("e1",res2,0,"LOB",1);
    prob.setBomMatch("e1",res2,0,"source",1);
    
    assert( prob.getBomMatch("e1",res2,0,"jobRole")==1 );
    assert( prob.getBomMatch("e1",res2,0,"skillSet")==1 );
    assert( prob.getBomMatch("e1",res2,0,"locName")==1 );
    assert( prob.getBomMatch("e1",res2,0,"LOB")==1 );
    assert( prob.getBomMatch("e1",res2,0,"source")==1 );
d4389 17
a4405 17
    assert( prob.getBomSub("e1",res2,0,"jobRole")==0 );
    assert( prob.getBomSub("e1",res2,0,"skillSet")==0 );
    assert( prob.getBomSub("e1",res2,0,"locName")==0 );
    assert( prob.getBomSub("e1",res2,0,"LOB")==0 );
    assert( prob.getBomSub("e1",res2,0,"source")==0 );
    
    prob.setBomSub("e1",res2,0,"jobRole",1);
    prob.setBomSub("e1",res2,0,"skillSet",1);
    prob.setBomSub("e1",res2,0,"locName",1);
    prob.setBomSub("e1",res2,0,"LOB",1);
    prob.setBomSub("e1",res2,0,"source",1);
    
    assert( prob.getBomSub("e1",res2,0,"jobRole")==1 );
    assert( prob.getBomSub("e1",res2,0,"skillSet")==1 );
    assert( prob.getBomSub("e1",res2,0,"locName")==1 );
    assert( prob.getBomSub("e1",res2,0,"LOB")==1 );
    assert( prob.getBomSub("e1",res2,0,"source")==1 );
d4417 3
a4419 3
    assert( !prob.subsExists(resIdName,"s1","s2") );
    prob.addSubs(resIdName,"s1","s2");
    assert( prob.subsExists(resIdName,"s1","s2") );
d4423 2
a4424 2
    assert(fromSkills[0]=="s1");
    assert(toSkills[0]=="s2");
d4426 2
a4427 2
    prob.setSubsCost(resIdName,"s1","s2",2.0f);
    assert( eq(prob.getSubsCost(resIdName,"s1","s2"),2.0f) );
d4429 2
a4430 2
    prob.setSubsLeadTime(resIdName,"s1","s2",3.0f);
    assert( eq(prob.getSubsLeadTime(resIdName,"s1","s2"),3.0f) );
d4451 1
a4451 1
      prob1.addEngagement("e1");
d4453 7
a4459 7
      prob1.setEngagementRevenue("e1",1.0f);
      prob1.setEngagementStartPeriod("e1",1);
      //prob1.setEngagementDuration("e1",3);
      
      assert(prob1.getEngagementRevenue("e1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("e1")==1);
      //assert(prob1.getEngagementDuration("e1")==3);
d4464 3
a4466 3
    assert(prob0.getEngagementRevenue("e1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("e1")==1);
    //assert(prob0.getEngagementDuration("e1")==3);    
d4494 4
a4497 4
      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");
      r2.push_back("j1");r2.push_back("s2");r2.push_back("Cont");r2.push_back("non-global");
      r3.push_back("j2");r3.push_back("s1");r3.push_back("IBM");r3.push_back("non-global");
      r4.push_back("j2");r4.push_back("s2");r4.push_back("PRIORITY");r4.push_back("global");
d4500 3
a4502 3
       r5.push_back("j2");r5.push_back("s2");r5.push_back("Cont");r5.push_back("global");
       r6.push_back("j2");r6.push_back("s2");r6.push_back("Supp");r6.push_back("global");
       r7.push_back("j2");r7.push_back("s2");r7.push_back("IBM");r7.push_back("global");
d4631 6
a4636 6
      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");r1.push_back("chicago");r1.push_back("US");
      r2.push_back("j2");r2.push_back("s2");r2.push_back("IBM");r2.push_back("global");r2.push_back("chicago");r2.push_back("US");
      r3.push_back("j2");r3.push_back("s2");r3.push_back("IBM");r3.push_back("global");r3.push_back("akron");r3.push_back("US");
      r4.push_back("j1");r4.push_back("s1");r4.push_back("Cont");r4.push_back("non-global");r4.push_back("akron");r4.push_back("US");
      r5.push_back("j1");r5.push_back("s1");r5.push_back("Supp");r5.push_back("non-global");r5.push_back("akron");r5.push_back("US");
      r6.push_back("j1");r6.push_back("s1");r6.push_back("WOS");r6.push_back("non-global");r6.push_back("akron");r6.push_back("US");
d4641 2
a4642 2
      r11.push_back("j2");r11.push_back("s2");r11.push_back("IBM");r11.push_back("global");r11.push_back("UNSPECIFIED");r11.push_back("US");
      r12.push_back("j1");r12.push_back("s1");r12.push_back("PRIORITY");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
d4740 9
a4748 9
      r1s1ResVal.push_back("r1");r1s1ResVal.push_back("s1");r1s1ResVal.push_back("LOB1");r1s1ResVal.push_back("src1");r1s1ResVal.push_back("l1");
      r1s2ResVal.push_back("r1");r1s2ResVal.push_back("s2");r1s2ResVal.push_back("LOB1");r1s2ResVal.push_back("src1");r1s2ResVal.push_back("l1");
      r2s1ResVal.push_back("r2");r2s1ResVal.push_back("s1");r2s1ResVal.push_back("LOB1");r2s1ResVal.push_back("src1");r2s1ResVal.push_back("l1");
      r2s2ResVal.push_back("r2");r2s2ResVal.push_back("s2");r2s2ResVal.push_back("LOB1");r2s2ResVal.push_back("src1");r2s2ResVal.push_back("l1");
      
      r1as1ResVal.push_back("r1a");r1as1ResVal.push_back("s1"); r1as1ResVal.push_back("LOB1");r1as1ResVal.push_back("src1");r1as1ResVal.push_back("l1");
      r1as2ResVal.push_back("r1a");r1as2ResVal.push_back("s2"); r1as2ResVal.push_back("LOB1");r1as2ResVal.push_back("src1");r1as2ResVal.push_back("l1");
      r1s1aResVal.push_back("r1"); r1s1aResVal.push_back("s1a");r1s1aResVal.push_back("LOB1");r1s1aResVal.push_back("src1");r1s1aResVal.push_back("l1");
      r2s1aResVal.push_back("r2"); r2s1aResVal.push_back("s1a");r2s1aResVal.push_back("LOB1");r2s1aResVal.push_back("src1");r2s1aResVal.push_back("l1");
d4750 1
a4750 1
      r1as1aResVal.push_back("r1a");r1as1aResVal.push_back("s1a");r1as1aResVal.push_back("LOB1");r1as1aResVal.push_back("src1");r1as1aResVal.push_back("l1");
d4763 1
a4763 1
      // and resource: "r1","s1","l1","LOB1","src1"
d4767 1
a4767 1
        "e1",r1s1ResVal,subsRes);
d4783 1
a4783 1
      // and resource: "r2","s1","l1","LOB1","src1"
d4785 2
a4786 2
        "e1",r2s1ResVal,
        //"r2","s1","l1","LOB1","src1",
d4802 1
a4802 1
      // and resource: "r1","s2","l1","LOB1","src1"
d4804 2
a4805 2
        "e1",r1s2ResVal,
        //"r1","s2","l1","LOB1","src1",
d4822 1
a4822 1
      // and resource: "r2","s2","l1","LOB1","src1"
d4824 2
a4825 2
        "e1",r2s2ResVal,
        //"r2","s2","l1","LOB1","src1",
d4876 1
a4876 1
      DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l1");
d4883 1
a4883 1
      DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l1");
d4890 1
a4890 1
      DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l1");
d4897 1
a4897 1
      DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l2");
d4904 1
a4904 1
      DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l2");
d4911 1
a4911 1
      DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l2");
d4969 2
a4970 2
    //test that resources got acquired; 2 of r1 and 3 of r2, both in period 1
    //std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
d4973 1
a4973 1
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
d4978 1
a4978 1
    //acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d4980 1
a4980 1
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
d4986 4
a4989 4
    assert(prob_acquire.getEngagementExecuted("e1"));
    assert(prob_acquire.getEngagementExecuted("e2"));
    assert(prob_acquire.getEngagementStartPeriod("e1")==0);
    assert(prob_acquire.getEngagementStartPeriod("e2")==2);
d5005 1
a5005 1
      prob_delay.getEngagementStartPeriod("e2")==0 && prob_delay.getEngagementStartPeriod("e1")==3
d5007 1
a5007 1
      prob_delay.getEngagementStartPeriod("e2")==3 && prob_delay.getEngagementStartPeriod("e1")==0
d5011 1
a5011 1
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
d5013 1
a5013 1
    //std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
d5019 1
a5019 1
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
d5021 1
a5021 1
    //acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d5038 1
a5038 1
    assert(prob_decline.getEngagementExecuted("e1")==false);
d5041 1
a5041 1
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
d5043 1
a5043 1
    //std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
d5048 1
a5048 1
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
d5050 1
a5050 1
    //acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d5067 1
a5067 1
    std::vector<float> shipRewardQty = prob_IGS.getDemandShipReward("e1");
d5076 1
a5076 1
    //int ed = prob_IGS.getEngagementDuration("e1");
d5078 1
a5078 1
    int ela = prob_IGS.getEngagementLateAllowance("e1");
d5080 1
a5080 1
    int ersp = prob_IGS.getEngagementRequestedStartPeriod("e1");
d5082 1
a5082 1
    int esp = prob_IGS.getEngagementStartPeriod("e1");
d5094 1
a5094 1
    prob_IGS.setEngagementLateAllowance("e1",0);
d5100 1
a5100 1
    int esp = prob_IGS.getEngagementStartPeriod("e1");
d6020 1
a6020 1
    names.push_back("j1");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6027 1
a6027 1
    names.push_back("j1");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
d6034 1
a6034 1
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
d6041 1
a6041 1
    names.push_back("j2");names.push_back("s2");names.push_back("Cont");names.push_back("global");
d6048 1
a6048 1
    names.push_back("j2");names.push_back("s2");names.push_back("IBM");names.push_back("global");
d6055 1
a6055 1
    names.push_back("j2");names.push_back("s2");names.push_back("Supp");names.push_back("global");
d6069 1
a6069 1
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6087 1
a6087 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6094 1
a6094 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
d6101 1
a6101 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
d6108 1
a6108 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6115 1
a6115 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("global");
d6122 1
a6122 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("IBM");names.push_back("global");
d6129 1
a6129 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Supp");names.push_back("global");
d6143 1
a6143 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6161 1
a6161 1
    names.push_back("s1");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d6168 1
a6168 1
    names.push_back("s1");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
d6175 1
a6175 1
    names.push_back("s1");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
d6196 1
a6196 1
    names.push_back("s2");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d6203 1
a6203 1
    names.push_back("s1");names.push_back("Cont");names.push_back("global");names.push_back("lob");
d6210 1
a6210 1
    names.push_back("s1");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
d6230 1
a6230 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6239 1
a6239 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
d6248 1
a6248 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
d6257 1
a6257 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6266 1
a6266 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("global");
d6275 1
a6275 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("IBM");names.push_back("global");
d6284 1
a6284 1
    names.push_back("unmatched");names.push_back("s2");names.push_back("Supp");names.push_back("global");
d6302 1
a6302 1
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d6323 1
a6323 1
    names.push_back("s1");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d6334 1
a6334 1
    names.push_back("s1");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
d6345 1
a6345 1
    names.push_back("s1");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
d6378 1
a6378 1
    names.push_back("s2");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d6389 1
a6389 1
    names.push_back("s1");names.push_back("Cont");names.push_back("global");names.push_back("lob");
d6400 1
a6400 1
    names.push_back("s1");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
@


1.292
log
@need to add some epsilon penalties for the flex mix stuff so that operations
didn't happen unless they needed to. It was creating unnecessary parts which were then scrapped, so the gluts were being found incorrectly (since we look for gluts at the "bottom" of the tree)
@
text
@d4930 1
@


1.291
log
@more support of flex mix. Now actually reading the skills file.
@
text
@d109 2
d368 2
a369 1
    checkWitRC(witSetOperationExecPenalty(witRun(),enableOp.c_str(),0.01f));
d400 3
d2607 1
a2607 1
    
@


1.290
log
@getting the flex mix stuff working. Seems to be pretty close to correct
@
text
@d410 1
a410 1
    checkWitRC(witFree(subsCost));
d540 1
a540 1
  checkWitRC(witFree(reward));
d4912 39
a4950 1
  
@


1.289
log
@many changes to support the "simple" flexmix model. Doesn't work yet.
@
text
@d74 1
a74 3
  
  
       float foo;
d95 1
a95 1
     addFlexibleResource(newResource,false,false,""); 
d341 1
a341 1
void RCPproblem::addFlexibleResource(const std::vector<std::string> &resourceAttributeVector, bool isActualResource, bool isDemandedResource, std::string engagementName)
d355 3
a357 6
  checkWitRC(witAddPart(witRun(),benchRes.c_str(),WitMATERIAL));
  // Add appData for bench resource
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),benchRes.c_str(),benchAppData));
  
  //only do this for "real" resources (not flexible mix ones)
d364 3
d369 3
a371 2
  // For MRP calculation and priorityPlan, set expAllowed to false;  doesn't impact optimalPlan
  //checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE));  
a372 9
  //DLG DO WE NEED THIS?
 //if (np>1){
  //  checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
  //  float * offsetVec = floatToFloatStar(-1.f);
  //  checkWitRC(witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec));
  //  delete [] offsetVec;
  //  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE));
  //  checkWitRC(witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2));
 // }
d383 7
a389 2
  
  if (isDemandedResource) {
d391 1
a391 1
    std::string acquireOp  = acquireResourceOperationName(resourceAttributeVector);
d405 6
a410 5
    checkWitRC(witAddSubsBomEntry(witRun(), engagementName.c_str(), 0, acquireWorkingRes.c_str())); 
    checkWitRC(witSetSubsBomEntryExecPenalty(witRun(),engagementName.c_str(),0,0,1.f));
    checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),engagementName.c_str(),0,0,100000000.0f));
  }

a412 1

d499 1
d501 52
a704 2


d752 6
a757 1
  appData->setGlutAppData(period, glutQuantity);
d1156 3
a1193 1

d1619 4
d1632 15
a1646 15
      int bomIndex = bomIndices[be];  
      
      // get the period associated with this bomEntry
      RCPbomAppData * appData;
      checkWitRC(witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),bomIndex,(void**)&appData));
      int period = appData->getPeriod();
      
      // Collection that will be manipulated to contain all allowed substitute resources
      RCPcollectionOfStrings subsResources = resourceNames_;;
      
      
      // Does this bom allow jobRole substitution? 
      
      // Check each attribute to see if substitution is allowed
      for (unsigned int i=0; i<getResourceIdentifierNames().size(); i++) {
d1652 9
a1660 9
          removeIneligibleResources(subsResources,subAllowed,resourceIdName,resourceValue);
      }
      
      // Remove resource connected to BOM from the set of substitute resources
      subsResources.erase(baseNameFromWorkingResourceName(workingRes));
      
      // loop once for each substitute resource
      RCPcollectionOfStrings::const_iterator subsResIt;
      for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
d1665 1
a1665 1
          toResourceVector[i]=resourceIdentifierValueFromResourceName(subsResource, i);
d1667 1
a1667 1
         
d1681 5
a1685 5
          std::string fromValue = fromResourceVector.at(i);
          std::string toValue = toResourceVector.at(i);
          std::string resourceIdName = getResourceIdentifierNames()[i];
          int matching =  getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
          if (fromValue != toValue && matching==1) {
d1693 1
a1693 1
          }
d1717 2
a1718 2
          int t;
          for( t=1; t<np; ++t )
d1740 1
a1740 1
          subsOffset[t]=offset[t]-subsLeadTime;
d1751 1
a1751 1
      }  // end for subsResIt loop         
d1753 19
d1773 131
d1907 1
d2223 10
d2234 1
d2324 1
a2324 1
  
d2554 1
a2554 1
  int t;
d2576 5
a2580 1
  checkWitRC(witHeurImplode(witRun()));
d2601 3
d2606 1
a2606 1
      setFlexibleResourceGlutQuantity(names[r],t,glutQty[t]);
d2608 1
a2610 10
  // (8) restoring model to initial state //DLG DO WE NEED THIS?
  #if 0
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string benchRes;
    benchRes = benchResourceName(names[r]); //DLG these should be bench
    checkWitRC(witSetPartSupplyVol(witRun(),benchRes.c_str(),vecZero));
    delete [] vecZero;
  }
  #endif
a2611 9
  // (10)
 // for ( r=0; r<numResources; ++r ) {
  //  std::string acquireOp;
  //  acquireOp = acquireResourceOperationName(names[r]);
    
  //  float * oneVec = floatToFloatStar(1.0f);
  //  checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
  //  delete [] oneVec;
  //}
d2613 1
d2615 18
d2634 3
a3511 6
  presolve04Feb(subBomsAdded);
  getTimer().printElapsedTime("after presolve in gapGlut");

  //  presolveForGapGlut();
  checkWitRC(witMrp(witRun()));
  getTimer().printElapsedTime("after witMrp");
d3513 10
a3522 3
  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit1.dat"));
  getTimer().printElapsedTime("after witWriteData in gapGlut");
a3523 1
  if (getFormatName() != "FlexMix") 
d3525 1
d3527 2
a3528 1
  if (getFormatName()=="FlexMix")
d3530 1
d6408 6
@


1.288
log
@attach acquire as a substitute for each demanded resource
@
text
@d72 1
a72 1
  void RCPproblem::addAlternateResource(std::vector<std::string> skillList, int skillSetPosition,  RCPvectorString originalResource,  std::vector<float> supplyAlternate) {
d88 2
a89 6
        //modify the supply
        for (int j=0; j<getNPeriods(); j++) {
           setResourceSupplyQuantity(originalResource,j,supplyAlternate.at(j));
        }
        setBenchResourceSupplyQuantity(originalResource,0,supplyAlternate.at(0));   
        foo = supplyAlternate.at(0);
d97 3
a99 6
     addFlexibleResource(newResource); 
     for (int j=0; j<getNPeriods(); j++) {
        setResourceSupplyQuantity(newResource,j,supplyAlternate.at(j));
     }
     setBenchResourceSupplyQuantity(newResource,0,supplyAlternate.at(0));   
     foo = supplyAlternate.at(0);
a106 3
        std::string enableOp = enableFlexResourceOperationName(newResource,targetResource);  //DLG different ones for each target
        witAddOperation(witRun(),enableOp.c_str());
        witAddBomEntry(witRun(),enableOp.c_str(), benchResource.c_str());
d108 4
a111 1
        if (witPartExists(workingResource))
d113 1
d343 1
a343 1
void RCPproblem::addFlexibleResource(const std::vector<std::string> &resourceAttributeVector)
d347 2
a348 1
  //demanded resources as a "last" substitute.
d358 13
a370 12
  checkWitRC(witAddOperation(witRun(),enableOp.c_str()));
  checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
  
  // Add appData for working resource
  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));
  
 
  
  // connect parts and operations.
  checkWitRC(witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
  checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str()));
d372 1
a372 1
  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE));  
d375 8
a382 8
  if (np>1){
    checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
    float * offsetVec = floatToFloatStar(-1.f);
    checkWitRC(witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec));
    delete [] offsetVec;
    checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE));
    checkWitRC(witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2));
  }
a391 11
}

void RCPproblem::addFlexibleResourceAcquisition(const std::vector<std::string> &resourceAttributeVector)
{
  //this is for the flex mix model. It adds a "acquire working" part, and an "acquire" operation
  //This acquire working part will be added for
  //demanded resources as a "last" substitute.

  std::string acquireWorkingRes = acquireWorkingResourceName(resourceAttributeVector);
  std::string acquireOp  = acquireResourceOperationName(resourceAttributeVector);
  std::string enableOp = enableResourceOperationName(resourceAttributeVector); // for where to attach the subs arc
a392 9
  int np = getNPeriods();
  
  // Add parts and operations  
  checkWitRC(witAddPart(witRun(),acquireWorkingRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
  
  // Add appData for working resource //DLG DO WE NEED THIS ??
  //RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  //checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));
d394 13
d408 6
a413 18
 
  // connect parts and operations.
  checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),acquireWorkingRes.c_str()));
  
  //DLG DO WE NEED ANY OF THIS?
  // For MRP calculation and priorityPlan, set expAllowed to false;  doesn't impact optimalPlan
  //checkWitRC(witSetBopEntryExpAllowed(witRun(),acquireWorkingOp.c_str(),0,WitFALSE));  //DLG ???
  
 // if (np>1){
 //   checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
    
 //   float * offsetVec = floatToFloatStar(-1.f);
 //   checkWitRC(witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec));
 //   delete [] offsetVec;
 //   checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE));
 //   checkWitRC(witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2));
 // }
  
a414 12
  std::string baseName = baseResourceName(resourceAttributeVector);
  resourceNames_.insert(baseName);
  for (unsigned int i=0; i<resourceAttributeVector.size(); i++) {
    const std::string & resourceID = getResourceIdentifierNames()[i];
    const std::string & resourceValue = resourceAttributeVector.at(i);
    resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
  }
  
  //Add it as a substitute
  checkWitRC(witAddSubsBomEntry(witRun(), enableOp.c_str(), 0, acquireWorkingRes.c_str()));
  checkWitRC(witSetSubsBomEntryExecPenalty(witRun(),enableOp.c_str(),0,0,100000000.0f));
  checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),enableOp.c_str(),0,0,100000000.0f));
d416 2
d634 6
d684 25
d729 17
d849 10
a858 1

a1014 1
  //DLG check for -1
a1104 2

//DLG this is probably where the usage quantity is messed up for the new arcs
d2330 76
d3293 2
a3294 1
  saveMrpResults();
d3296 6
a3301 4

  if (getAlgorithmName() == "priorityPlan"){  //DLG we may want to allow optimalPlan and FlexMix
    if (getFormatName() == "04Feb" || getFormatName() == "FlexMix") //DLG ??
      priorityGapGlut1(); //$$$$$ 
d3315 1
d3762 1
a3762 1
  // delete resource appData
d3770 16
a3785 5
    for ( r=0; r<numResources; ++r ) { 
      RCPresourceAppData * srcAppData;
      std::string workingResWitName = workingResourceName(names[r]);
      checkWitRC(witGetPartAppData(mutableWitRun(),workingResWitName.c_str(),(void**)&srcAppData));
      delete srcAppData;
@


1.287
log
@fixed up some errors for the flex mix; adding separate engagements for each
flex group
@
text
@a72 1
  //DLG THIS NEEDS CODE
d101 1
a101 1
     addResource(newResource); //DLG this may need to be a different method
d349 102
a450 4
//void RCPproblem::addFlexibleResource(const std::vector<std::string> &resourceAttributeVector)
//{
   //NEEDS CODE
//}
d3199 2
a3200 2
  if (getAlgorithmName() == "priorityPlan"){
    if (getFormatName() == "04Feb")
d3330 4
a3333 1

@


1.286
log
@supporting flex mix
@
text
@d91 1
a91 3
          setResourceSupplyQuantity(originalResource, j, supplyAlternate.at(j)); 
          foo = supplyAlternate.at(j);

d93 2
a102 1

d104 1
a104 2
       setResourceSupplyQuantity(newResource, j, supplyAlternate.at(j)); 
       foo = supplyAlternate.at(j);
d106 3
d114 4
a117 2
        std::string benchResource = benchResourceName(targetResource);
        std::string enableOp = enableResourceOperationName(newResource);
d119 1
a119 1
        if ((primaryskill!=sk) && witPartExists(workingResource))
d986 1
d3261 4
@


1.285
log
@flexible mix groups. Beginning changes
@
text
@d74 47
d124 10
d135 9
d145 1
@


1.284
log
@skeleton for flexible mix changes
@
text
@d66 7
a72 6
//AddAlternateResource should figure out the name for the "skill by..." part
//it should also create the operation to turn skill1 into skill2 for this part
//it should connect up the arcs from the new part to the operation, and from
//the new operation to the working as skill2 part, with some aversion.
//it should also connect the real part to this operation (skill2)
  void RCPproblem::addAlternateResource(RCPvectorString alternateResource, RCPvectorString originalResource,  std::vector<float> supplyAlternate) {
d76 1
a76 9
  std::string RCPproblem::createAltName(RCPvectorString resourceWithAlternate, RCPvectorString originalResource, int skillSetPosition) const
  {
  //DLG THIS NEEDS CODE TO CREATE THE "skill2 by skill1" name
  return "foobar";
  }
  void RCPproblem::AttachCrossTerm(RCPvectorString originalResource, RCPvectorString resourceWithAlternate, int skillSetPosition, float fraction)
  {
  //THIS NEEDS CODE
  }
a79 4
bool RCPproblem::engagementExists    (const std::string & engName)const
{
  return witPartExists(engagementName(engName).c_str());
}
d81 4
d280 4
a283 4
void RCPproblem::addFlexibleResource(const std::vector<std::string> &resourceAttributeVector)
{
  //DLG NEEDS TO HAVE CODE
}
@


1.283
log
@write out something in the engagement file even when nothing was executed. Also fixed a few casts.
@
text
@d66 20
d287 4
d821 13
d835 1
@


1.282
log
@replacing with dan's working copies
@
text
@a4022 1
        float foo = gapQty[0];
a4552 1
        float foo = gapQty[0];
a4689 5
    // do solve in loop to make sure resolving works
    int r;
    for (r=0; r<2; ++r ) {
      prob.gapGlut();
      
d4725 1
a4725 1
      }
d4727 2
@


1.281
log
@Wrappered more wit calls with checkWitRC
Touch rcpOpt.cpp before making all
@
text
@d2533 2
a2534 2
                std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
                  " GAP: " << peggedExecVolList[theIdx] << std::endl;
d2559 2
a2560 2
                                  std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
                                            << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
d2569 3
a2571 3
          if (supplyQtyUsed > 0)
                    std::cout << "  Demand:" << demandName << "  Period:" << i << " Supply Used:" 
                                    << supplyQtyUsed << std::endl;
d2665 1
a2665 1
                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << cumTotal << std::endl;
d2693 3
a2695 3
                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset + reqStartPer 
                              << " RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUB RESOURCE:" 
                              << baseNameFromWorkingResourceName(subPartConsumed) << " QUANTITY SUBBED: " << subQtyUsed << std::endl;
d2706 2
a2707 2
            std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  Period:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUPPLY USED: " 
                          << supplyQtyUsed << std::endl;
d3053 1
a3053 1
    checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
@


1.280
log
@fix case of filename
@
text
@d781 1
a781 1
  witFree(stockcost);
d792 1
a792 1
  witFree(acv);
d804 1
a804 1
  witFree(atv);
d815 1
a815 1
  witFree(rcv);
d827 1
a827 1
  witFree(rtv);
d1526 1
a1526 1
      witFree(subResName);
d1825 1
a1825 1
  witPurgeData(witRun());  
d1887 1
a1887 1
  witMrp(witRun());
d2062 2
a2063 2
        witFree(priorityVec);
        witFree(consumedPartName);
d2069 1
a2069 1
  witWriteData(witRun(),"wit3.dat");
d2359 3
a2361 3
              witFree(subOffset);
              witFree(subConsRate);
              witFree(subConsumedPartName);
d2374 3
a2376 3
          witFree(consumedPartName);
          witFree(consRate);
          witFree(offset);
d2385 1
a2385 1
  witWriteData(witRun(),"wit3.dat");
d2435 1
a2435 1
  witPurgeData(witRun());
d2540 1
a2540 1
        witFree(operationNameList[theIdx]);
d2542 3
a2544 3
      witFree (operationNameList);
      witFree (execPeriodList);
      witFree (peggedExecVolList);
d2562 2
a2563 2
          witFree (subVol);
          witFree (subPartConsumed);
d2574 3
a2576 3
      witFree (consRate);
      witFree (consumedPartName);
      witFree (offset);
d2653 2
a2654 2
          witFree(offset);
          witFree(consRate);
d2699 3
a2701 3
              witFree (subOffset);
              witFree (subVol);
              witFree (subPartConsumed);
d2711 1
a2711 1
          witFree (consumedPartName);
d2714 1
a2714 1
      witFree (sortLayerConsumedPartName);
d2718 1
a2718 1
    witFree(operationNameList[theIdx]);
d2720 3
a2722 3
  witFree (operationNameList);
  witFree (execPeriodList);
  witFree (peggedExecVolList);
d2730 2
a2731 2
  witWriteData(witRun(),"witOGG.dat");
  witOptImplode(witRun());
d2775 2
a2776 2
  witWriteData(witRun(),"wit3opt.dat");
  witOptImplode(witRun());
d2811 1
a2811 1
    witFree(aov);
d2842 1
a2842 1
  //  witPurgeData(witRun());
d2845 1
a2845 1
  witHeurImplode(witRun());
d2905 1
a2905 1
  witPurgeData(witRun());
d2984 1
a2984 1
  witWriteData(witRun(),"wit0.dat");
d2990 1
a2990 1
  witMrp(witRun());
d2994 1
a2994 1
  witWriteData(witRun(),"wit1.dat");
d3031 1
a3031 1
    witWriteData(witRun(),"wit2.dat");
d3043 1
a3043 1
  witMrp(witRun());
d3056 1
a3056 1
  witWriteData(witRun(),"wit4.dat");
d3254 1
a3254 1
        witFree(consPartFromWit);
d3258 1
a3258 1
    witFree(consPartFromWit);
d3289 1
a3289 1
    witFree(consPartFromWit);
@


1.279
log
@changed many warnings to exceptions.
@
text
@d20 1
a20 1
#include "RcpOptException.h"
@


1.278
log
@Added quantity to the engagement file.  The BOM or demand file is now more like a description of the offering.  Updated the reporting in engagementO.csv.
@
text
@d20 1
d5828 7
a5834 2
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
d5842 8
a5849 2
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
@


1.277
log
@Removed MULTIPLEENGAGEMENT ifdef's
Changed the start period of an engagement to it's real start period.
@
text
@d86 9
d106 4
a109 4
  float * demandVol = floatToFloatStar(0.0f);
  demandVol[startPeriod]=1.0f;
  checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol));
  delete [] demandVol;
d134 7
d204 7
d1726 8
d2117 1
a2117 1
  // time is not in period zero.  Set the engagement's demand priority.
d2194 5
d2773 2
d3017 1
a3017 1
    // Reset the revenue for each engagement back to zero
d3025 1
@


1.276
log
@Fixed assert of gap/glut in er5_test7 now that WIT has been updated to generate a consistent sorting.

In appl.mk, added a vpath to get make depend to work on Linux.
@
text
@a6 2
#define MULTIPLEENGAGEMENTS

a1920 97
#ifndef MULTIPLEENGAGEMENTS
  //{
  // temporary code to check the names of the resourceIdentifiers
  //int i;
  //for (i=0; i<nSpecialDemands; i++)
  //      std::cout << "ID: " << i << ":  " << resourceIdentifierNames[i] << std::endl;
  // }
  
  {
    //  add the SpecialDemands, one for each resource identifier
    int i;
    for (i=0; i<nSpecialDemands; i++)
    {
      std::string specialDemand = "XXX_SpecialDemand_";
      specialDemand += resourceIdentifierNames[i];
      checkWitRC(witAddPart(witRun(),specialDemand.c_str(),WitCAPACITY));
      checkWitRC(witAddOperation(witRun(),specialDemand.c_str()));
      checkWitRC(witAddDemand(witRun(),specialDemand.c_str(),specialDemand.c_str()));
      checkWitRC(witAddBopEntry(witRun(),specialDemand.c_str(),specialDemand.c_str()));
      
      checkWitRC(witSetDemandSelForDel(witRun(),specialDemand.c_str(),specialDemand.c_str(),WitTRUE));
      checkWitRC(witSetPartSelForDel(witRun(),specialDemand.c_str(),WitTRUE));
      checkWitRC(witSetOperationSelForDel(witRun(),specialDemand.c_str(), WitTRUE));
      demandVol[0] = 1.0f;
      checkWitRC(witSetDemandDemandVol(witRun(),specialDemand.c_str(),specialDemand.c_str(),demandVol));
#if 0
      int * priorityVec;
      checkWitRC(witGetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),&priorityVec));
      priority = getResourceIdentifierPriority(resourceIdentifierNames[i]);
      if (priority <= 0)
        priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
      else
        if (priority < INT_MAX)
          priority ++;
        //      if (priority >= 0 && priority < INT_MAX) // The highest priority is one, so shift what the user has specified up by one 
        //        priority ++;          // to make sure the exact demand is the only one with a WIT priority of one.  
        for(t=0; t<nPeriods; t++)
          priorityVec[t] = priority;  
        checkWitRC(witSetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),priorityVec));
        witFree(priorityVec);
#else
      int priority = getResourceIdentifierPriority(resourceIdentifierNames[i]);
      if (priority <= 0)
        priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
      else
        if (priority < INT_MAX) priority ++;
      checkWitRC(witSetDemandAttribute(witSetDemandPriority,specialDemand,specialDemand,priority));
#endif
    }
  }
  
  std::string priorityExactDemand = "PriorityExactDemand"; 
  if (!engagementExists(priorityExactDemand)) {
    checkWitRC(witAddPart(witRun(),priorityExactDemand.c_str(),WitCAPACITY));
    checkWitRC(witAddOperation(witRun(),priorityExactDemand.c_str()));
    checkWitRC(witAddDemand(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str()));
    checkWitRC(witAddBopEntry(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str()));
    
    checkWitRC(witSetDemandSelForDel(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),WitTRUE));
    checkWitRC(witSetPartSelForDel(witRun(),priorityExactDemand.c_str(),WitTRUE));
    checkWitRC(witSetOperationSelForDel(witRun(),priorityExactDemand.c_str(), WitTRUE));
    demandVol[0] = 1.0f;
    checkWitRC(witSetDemandDemandVol(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),demandVol));
#if 0
    int * priorityVec;
    checkWitRC(witGetDemandPriority(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),&priorityVec));
    for(t=0; t<nPeriods; t++)
      priorityVec[t] = 1;
    checkWitRC(witSetDemandPriority(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),priorityVec));
    witFree(priorityVec);
#else
    checkWitRC(witSetDemandAttribute(witSetDemandPriority,priorityExactDemand,priorityExactDemand,1));
#endif
  }
  
  std::string priorityLastDemand = "PriorityLastDemand"; 
  if (!engagementExists(priorityLastDemand)) {
    checkWitRC(witAddPart(witRun(),priorityLastDemand.c_str(),WitCAPACITY));
    checkWitRC(witAddOperation(witRun(),priorityLastDemand.c_str()));
    checkWitRC(witAddDemand(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str()));
    checkWitRC(witAddBopEntry(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str()));
    checkWitRC(witSetDemandSelForDel(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),WitTRUE));
    checkWitRC(witSetPartSelForDel(witRun(),priorityLastDemand.c_str(),WitTRUE));
    checkWitRC(witSetOperationSelForDel(witRun(),priorityLastDemand.c_str(), WitTRUE));
    checkWitRC(witSetDemandDemandVol(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),demandVol));
#if 0
    int * priorityVec;
    checkWitRC(witGetDemandPriority(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),&priorityVec));
    for(t=0; t<nPeriods; t++)
      priorityVec[t] = maxPriority+2;  // zero is the lowest priority
    checkWitRC(witSetDemandPriority(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),priorityVec));
    witFree(priorityVec);
#else
    checkWitRC(witSetDemandAttribute(witSetDemandPriority,priorityLastDemand,priorityLastDemand,maxPriority+2));
#endif
  } 
#endif
a1955 122
#ifndef MULTIPLEENGAGEMENTS  
  // (4) copy over the BOM and subBOM arcs to the appropriate demand structure for every resource
  {
    // Get the number of BOM arcs going into the engagement operation
    int nBomArcs;
    checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
    int i;
    int nBomsAddedToPriorityExact = 0, nBomsAddedToPriorityLast = 0, nBomsAddedToPriorityDemand;
    
    std::vector<int> nBomsAddedToSpecialDemand (nSpecialDemands);
    {
      int k;
      for (k=0; k<nSpecialDemands; k++)
        nBomsAddedToSpecialDemand[k] = 0;
    }
    
    for (i=0; i<nBomArcs; i++){
      // Get the number of subBOM arcs hanging off this BOM arc 
      int nSubBomArcs;
      char * consumedPartName;
      float * consRate, * offset, aversion;
      std::string priorityDemand;
      
      checkWitRC(witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName));
      
      std::string baseName, workingPartName(consumedPartName);
      baseName = baseNameFromWorkingResourceName(workingPartName);
      //      std::cout << "WorkingPartName: " << workingPartName << std::endl;
      //      std::cout << "BaseName: " << baseName << std::endl;
      RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
      // {
      //        unsigned int kk;
      //for (kk = 0; kk<resourceIdValues.size(); kk++)
      //    std::cout << resourceIdValues[kk] << " " ;
      //std::cout << std::endl;
      //}
      
      
      //  The next few lines are being replaced by a more general test   DPC
      checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
      //if (nSubBomArcs == 0) // this is a completely specified resource --- connect it to PriorityExactDemand
      //        {
      //  priorityDemand = priorityExactDemand;
      //  nBomsAddedToPriorityDemand = nBomsAddedToPriorityExact;
      //}
      
      // Now go through the working resource and see how many "UNSPECIFIED" or "PRIORITY" values it has;
      // if it is just one, than add it to the appropriate Special Demand 
      
      int index, tempIndex, count = 0;
      std::string idName;
      assert (resourceIdValues.size() == nSpecialDemands);
      for (index=0; index<nSpecialDemands; index++){
        if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   // Still need to check on the match flag DPC
          count ++;
          tempIndex = index;
          idName = resourceIdentifierNames[index];
        }
      }
      switch (count)
      {
      case 0:
        priorityDemand = priorityExactDemand;
        nBomsAddedToPriorityDemand = nBomsAddedToPriorityExact;
        break;
      case 1:
        priorityDemand = "XXX_SpecialDemand_"+ resourceIdentifierNames[tempIndex];
        nBomsAddedToPriorityDemand = nBomsAddedToSpecialDemand[tempIndex];
        break;
      default:
        priorityDemand = priorityLastDemand;
        nBomsAddedToPriorityDemand = nBomsAddedToPriorityLast;
      }
      
      checkWitRC(witAddBomEntry(witRun(),priorityDemand.c_str(),consumedPartName));         
      checkWitRC(witSetBomEntrySelForDel(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,WitTRUE));
      // copy over the attributes of this BOM arc from the base model to the PriorityLastDemand
      // and then bring over all of the subBOMs and their attributes
      checkWitRC(witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate));
      checkWitRC(witGetBomEntryOffset(witRun(),theEngagement.c_str(),i,&offset));
      checkWitRC(witSetBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,consRate));
      checkWitRC(witSetBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,offset));
      // Now copy over the subBOM arcs
      int j;
      for (j=0; j<nSubBomArcs; j++)
      {
        char * subConsumedPartName;
        float *subConsRate, *subOffset;
        checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,j,&subConsumedPartName));
        checkWitRC(witAddSubsBomEntry(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,subConsumedPartName));
        checkWitRC(witSetSubsBomEntrySelForDel(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE));
        checkWitRC(witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&subConsRate));
        checkWitRC(witSetSubsBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,subConsRate));
        checkWitRC(witGetSubsBomEntryOffset(witRun(),theEngagement.c_str(),i,j,&subOffset));
        checkWitRC(witSetSubsBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,subOffset));
        checkWitRC(witGetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),i,j,&aversion));
        checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,aversion));
        checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE));
        witFree(subOffset);
        witFree(subConsRate);
        witFree(subConsumedPartName);
      }
      
      switch (count)
      {
      case 0: 
        nBomsAddedToPriorityExact ++;
        break;
      case 1:
        nBomsAddedToSpecialDemand[tempIndex] ++;
        break;
      default:
        nBomsAddedToPriorityLast ++;
      }
      witFree(consumedPartName);
      witFree(consRate);
      witFree(offset);
    } 
  }
#endif

#ifdef MULTIPLEENGAGEMENTS
a2034 1
#endif
a2057 7
#ifndef MULTIPLEENGAGEMENTS
  // (7) set the base engagement demand back to one
  demandVol[0] = 1.0f;
  checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol));
  delete [] demandVol;
#endif
  
a2066 5
#ifndef MULTIPLEENGAGEMENTS
  // (9)
  witPurgeData(witRun());
#endif

d2085 2
a2086 3
  // (2) Loop through each engagement.  Get its name and check to see that the engagement's requested start 
  // time is period zero.  (Still assuming all engagements are starting at period 0)
  // Set the engagements demand
d2155 2
a2156 3
      std::cout << "This version of RCP assumes engagements start at period 0. " << std::endl;
      std::cout << "The start period for engagement " << engName << " will be set to zero."  << std::endl;
      setEngagementStartPeriod(engName, 0);
a2410 156
#ifndef MULTIPLEENGAGEMENTS
void RCPproblem::generatePriorityGapGlut1PeggingResults()
{
  // (1) Loop through each special demand and the 'exact' and 'last' demand
  // (2) For each demand, loop through all the BOMs for that demand
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desird quantity)
  // (4) Call the pegging function, for all the periods, to get the amount of "gap" or acquisition and net this from the consRate vector
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.
  //  prtExecVolPegging("PriorityExactDemand","PriorityExactDemand",0);
  //  prtSubExecVolPegging("PriorityExactDemand","PriorityExactDemand",0);
  //  prtExecVolPegging("PriorityLastDemand","PriorityLastDemand",0);
  //  prtSubExecVolPegging("PriorityLastDemand","PriorityLastDemand",0);
  computePegging("PriorityExactDemand");
  computePegging("PriorityLastDemand");

  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  int nSpecialDemands = getResourceIdentifierNames().size();

  int i;
  for (i=0; i<nSpecialDemands; i++)
    {
      std::string specialDemand = "XXX_SpecialDemand_";
      specialDemand += resourceIdentifierNames[i];
      //      prtExecVolPegging(specialDemand.c_str(),specialDemand.c_str(),0);
      //      prtSubExecVolPegging(specialDemand.c_str(),specialDemand.c_str(),0);
      computePegging(specialDemand);
    }
}

void RCPproblem::computePegging(std::string demandName) 
{
  int np = getNPeriods();
  // (2) For each demand, loop through all the BOMs for that demand
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desird quantity)
  // (4) Call the pegging function, for all the periods, to get the amount of "gap" or acquisition and net this from the consRate vector
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.

  int bomIndex, nBomArcs;
  checkWitRC(witGetOperationNBomEntries(witRun(),demandName.c_str(),&nBomArcs));
  for (bomIndex = 0; bomIndex < nBomArcs; bomIndex++)
    {
      char * consumedPartName;
      float * consRate;
      std::vector<float> cumTotal(np);

      int i;
      for(i=0; i<np; i++)
        cumTotal[i] = 0.f;

      checkWitRC(witGetBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,&consumedPartName));
      checkWitRC(witGetBomEntryConsRate(witRun(),demandName.c_str(),bomIndex,&consRate));
      std::string acquireOpName = getAcquireOperationFromWorkingName(consumedPartName);

      int lenLists;
      char ** operationNameList;
      int * execPeriodList;
      float * peggedExecVolList;
      int theIdx;
      
      checkWitRC(witGetDemandExecVolPegging ( witRun(),
                                   demandName.c_str(),
                                   demandName.c_str(),
                                   0,
                                   & lenLists,
                                   & operationNameList,
                                   & execPeriodList,
                                   & peggedExecVolList));

      //look for the acquireOperation in the returned operationNameList
      for (theIdx = 0; theIdx < lenLists; theIdx++)
        {
          if(acquireOpName == operationNameList[theIdx])
            { //found it
              cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
              std::cout << "  Operation:" << consumedPartName << "  Period:" << execPeriodList[theIdx] << 
                " GAP: " << peggedExecVolList[theIdx] << std::endl;
            }
        }

      for (theIdx = 0; theIdx < lenLists; theIdx++)
        witFree(operationNameList[theIdx]);
      
      witFree (operationNameList);
      witFree (execPeriodList);
      witFree (peggedExecVolList);
      
      // Now take care of the subVols
      int nSubBomArcs, subBomIndex;
      checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),demandName.c_str(),bomIndex,&nSubBomArcs));
      for(subBomIndex = 0; subBomIndex<nSubBomArcs; subBomIndex++)
        {
          char * subPartConsumed;
          float * subVol;
          checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed));
          checkWitRC(witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol));
          for (i=0; i<np; i++)
            {
              if (subVol[i]>0)
                {
                  float subQtyUsed = subVol[i] * consRate[i];
                  cumTotal[i] += subQtyUsed;
                  std::cout << "  Operation:" << consumedPartName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
                            << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
                }
            }
          witFree (subVol);
          witFree (subPartConsumed);
        }

      for (i=0; i<np; i++)
        {
          float supplyQtyUsed = consRate[i] - cumTotal[i];
          if (supplyQtyUsed > 0)
            std::cout << "  Operation:" << consumedPartName << "  Period:" << i << " Supply Used:" 
                            << supplyQtyUsed << std::endl;
        }
      
      witFree (consRate);
      witFree (consumedPartName);
    }
}

        //****************************

void RCPproblem::prtExecVolPegging(
                                   const char* partName,
                                   const char* demandName,
                                   int shipPer)
{
  int lenLists;
  char ** operationNameList;
  int * execPeriodList;
  float * peggedExecVolList;
  int theIdx;
  
  checkWitRC(witGetDemandExecVolPegging (
                              witRun(),
                              partName,
                              demandName,
                              shipPer,
                              & lenLists,
                              & operationNameList,
                              & execPeriodList,
                              & peggedExecVolList));
  
  std::cout << "Pegging for demand " << partName << std::endl;
  for (theIdx = 0; theIdx < lenLists; theIdx ++)
    std::cout << "  Operation:" << operationNameList[theIdx] << "  Period:" << execPeriodList[theIdx] << " ExecVol: " <<
      peggedExecVolList[theIdx] << std::endl;

  for (theIdx = 0; theIdx < lenLists; theIdx++)
    witFree(operationNameList[theIdx]);
a2411 47
  witFree (operationNameList);
  witFree (execPeriodList);
  witFree (peggedExecVolList);
}

void RCPproblem::prtSubExecVolPegging(
                                   const char* partName,
                                   const char* demandName,
                                   int shipPer)
{
  int lenLists;
  char ** operationNameList;
  int * bomEntryIndexList;
  int * subsBomEntryIndexList;
  int * execPeriodList;
  float * peggedSubVolList;
  int theIdx;
  
  checkWitRC(witGetDemandSubVolPegging (
                              witRun(),
                              partName,
                              demandName,
                              shipPer,
                              & lenLists,
                              & operationNameList,
                              & bomEntryIndexList,
                              & subsBomEntryIndexList,
                              & execPeriodList,
                              & peggedSubVolList));
  
  std::cout << "Sub Pegging for demand " << partName << std::endl;
  for (theIdx = 0; theIdx < lenLists; theIdx ++)
    std::cout << "  Operation:" << operationNameList[theIdx] << "  bomIndex: " << bomEntryIndexList[theIdx] << "  subBomIndex: " << subsBomEntryIndexList[theIdx] << "  Period:" << execPeriodList[theIdx] << " ExecVol: " <<
      peggedSubVolList[theIdx] << std::endl;

  for (theIdx = 0; theIdx < lenLists; theIdx++)
    witFree(operationNameList[theIdx]);

  witFree (bomEntryIndexList);
  witFree (subsBomEntryIndexList);
  witFree (operationNameList);
  witFree (execPeriodList);
  witFree (peggedSubVolList);
}
#endif //#ifndef MULTIPLEENGAGEMENTS

#ifdef MULTIPLEENGAGEMENTS
d2547 1
a2547 1
  // (1) Call pegging on the demand (Still assuming the demand is shipped in period 0.)
d2563 3
a2565 1
  
d2569 1
a2569 1
                                          0,
d2626 1
a2626 1
                  if (execPeriodList[theIdx] == theOffset){
d2628 2
a2629 2
                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << cumTotal << std::endl;
                                  appData->addPeggedQuantityFromAcquisition(theOffset,
d2650 1
a2650 1
              if (theSubOffset == theOffset){
d2652 1
a2652 1
                if (subVol[0]>0)
d2654 1
a2654 1
                    float subQtyUsed = subVol[0] * localConsRate;
d2656 1
a2656 1
                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset 
d2659 1
a2659 1
                    appData->addPeggedQuantityFromSubstitution(theOffset,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),subQtyUsed,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(subPartConsumed)));
d2669 1
a2669 1
            std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  Period:" << theOffset <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUPPLY USED: " 
d2671 1
a2671 1
            appData->addPeggedQuantityFromSupply(theOffset,
a2687 4

#endif //#ifdef MULTIPLEENGAGEMENTS


@


1.275
log
@added an "or" for a particular test that depends on platform
@
text
@d5688 6
a5693 2
        assert((prob.getResourceGlutQuantity(r3)[1]==0.0 && prob.getResourceGlutQuantity(r7)[1]==1.0)||
        (prob.getResourceGlutQuantity(r3)[1]==1.0 && prob.getResourceGlutQuantity(r7)[1]==0.0));
@


1.274
log
@a modified check for gap-glut
@
text
@d5685 2
a5686 1
        gapQty = prob.getResourceGapQuantity(r3);
d5688 3
a5690 8
        assert(gapQty[1]==0.0 );
        assert(glutQty[1]==1.0 );
        
        //for DPC
        //gapQty = prob.getResourceGapQuantity(r7);
        //glutQty = prob.getResourceGlutQuantity(r7);
        //assert(gapQty[1]==0.0 );
        //assert(glutQty[1]==1.0 );
@


1.273
log
@added in a few more tests for pegging on example er5_test7
@
text
@d5668 1
d5688 8
a5695 1
        //DPC Need to check this one        assert(glutQty[1]==1.0 );
@


1.272
log
@Fixed calculation of subVol usage for Pegging.
@
text
@a5695 1
      #if 0 //DLG
a5714 1
      #endif //DLG
@


1.271
log
@a few fixes to clean things up and put back the check on period being within the horizon
@
text
@d3080 3
d3084 16
a3099 10
              checkWitRC(witGetSubsBomEntrySubVol(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subVol));
              if (subVol[theOffset]>0)
                {
                  float subQtyUsed = subVol[theOffset] * localConsRate;
                  cumTotal += subQtyUsed;
                  std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset 
                            << " RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUB RESOURCE:" 
                            << baseNameFromWorkingResourceName(subPartConsumed) << " QUANTITY SUBBED: " << subQtyUsed << std::endl;
                  appData->addPeggedQuantityFromSubstitution(theOffset,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),subQtyUsed,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(subPartConsumed)));
                }
d5687 1
a5687 1
        assert(glutQty[1]==1.0 );
@


1.270
log
@Changed witFree to delete
@
text
@d1214 1
d1218 1
d3414 1
a3414 1
    int e;
d3420 2
a3421 1
    delete [] zeroQty;
d5625 86
@


1.269
log
@undid some changes
@
text
@d3418 1
a3418 1
    witFree(zeroQty);
@


1.268
log
@minor cleanups
@
text
@a1213 1
      #if 0
a1216 1
      #endif
d3412 1
a3412 1
    unsigned int e;
@


1.267
log
@Changed the name of output file and field from Acquisition to Gap.  Also, reset the obj1ShipReward of the engagements to zero after performing gapGlut.
@
text
@d1214 1
d1218 1
d3414 1
a3414 1
    int e;
@


1.266
log
@Added code to clear out the stored pegging info so subsequent calls to solve can be made.
@
text
@d3408 12
@


1.265
log
@Modifications to compile with MS Visual C++ V6 compiler
@
text
@d3012 1
@


1.264
log
@added some methods for extracting pegging information to rcpProblem; also added more tests to unitTest to check pegging
@
text
@d238 1
a238 1
  return appData->getPeggedQuantitiesFromSubstitution(period,resource,quantities,subResources);
@


1.263
log
@Added {} around a block of code to suppress storing 0's to the engagementAppData
@
text
@d216 24
d5136 1
a5136 1
    std::cout << "er5_test3" << std::endl;
d5419 2
a5420 2
       }
  }  
d5423 77
a5499 9
      #if 0
      r1 should be satisfied by r7(supply) and r10(sub)
      r2 should be satisfied by r11(sub)
      r3 should be satisfied by r12(sub)
      r4 should be satisfied by r8(supply)
      r5 should be satsified by r13(sub)
      r6 should be satisfied by r9(supply) and r15(sub)
      r6a should be a gap
      r6b should be a gap
a5500 1
      #endif
d5502 46
d5549 1
d5551 58
@


1.262
log
@Modifications to compile with MS Visual C++ V6 compiler
@
text
@d3069 1
a3069 1
          if (supplyQtyUsed > 0)
d3072 3
a3074 3
           appData->addPeggedQuantityFromSupply(theOffset,
  resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)), supplyQtyUsed);
          
@


1.261
log
@Added pegging reports and methods for getting results out of the engagementAppData.
@
text
@d196 1
a196 1
  return appData->getPeggedQuantitiesFromSupply(period,resources,quantities);
d205 1
a205 1
  return appData->getPeggedQuantitiesFromAcquisition(period,resources,quantities);
d214 1
a214 1
  return appData->getPeggedQuantitiesFromSubstitution(period,resources,quantities,subResources);
@


1.260
log
@more tests
@
text
@d190 27
d1931 2
a1932 2
        //	if (priority >= 0 && priority < INT_MAX) // The highest priority is one, so shift what the user has specified up by one 
        //	  priority ++;          // to make sure the exact demand is the only one with a WIT priority of one.  
d2060 1
a2060 1
      //	unsigned int kk;
d2070 1
a2070 1
      //	{
d2103 1
a2103 1
      checkWitRC(witAddBomEntry(witRun(),priorityDemand.c_str(),consumedPartName));	    
d2169 58
a2226 58
	i=0;
	// Get the number of subBOM arcs hanging off this BOM arc 
	int nSubBomArcs;
	char * consumedPartName;
	std::string priorityDemand;
	
	checkWitRC(witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName));
	
	std::string baseName, workingPartName(consumedPartName);
	baseName = baseNameFromWorkingResourceName(workingPartName);
	RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
	
	checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
	
	// Now go through the working resource and see how many "UNSPECIFIED" or "PRIORITY" values it has;
	// if it is just one, than add it to the appropriate Special Demand 
	
	int index, tempIndex, count = 0;
	std::string idName;
	//assert (resourceIdValues.size() == nSpecialDemands);
	for (index=0; index<nSpecialDemands; index++){
	  if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   
	    // Still need to check on the match flag DPC;  Donna may have fixed this on the input side by changing the data for non-matched stuff
	    count ++;
	    tempIndex = index;
	    idName = resourceIdentifierNames[index];
	  }
	}
	
	int * priorityVec;
	int priority;
	checkWitRC(witGetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),&priorityVec));

	switch (count)
	  {
	    // set the demand priority based on the following rules
	  case 0:
	    for (t=0; t<nPeriods; t++)
	      priorityVec[t] = 1;
	    break;
	  case 1:
	    priority = getResourceIdentifierPriority(idName);
	    if (priority <= 0)
	      priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
	    else
	      if (priority < INT_MAX)
		priority ++;
	    for(t=0; t<nPeriods; t++)
	      priorityVec[t] = priority;  
	    break;
	  default:
	    for(t=0; t<nPeriods; t++)
	      priorityVec[t] = maxPriority+2;
	  }

	checkWitRC(witSetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),priorityVec));
	witFree(priorityVec);
	witFree(consumedPartName);
d2384 1
a2384 1
	sortName1 = "__exact__";
d2386 1
a2386 1
	sortName1 = "__last__";
d2388 1
a2388 1
	sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
d2410 2
a2411 2
	sortName1 = "__exact__";
	sortName2 = "__" + resourceIdentifierNames[0] + "__";
d2414 2
a2415 2
	sortName1 = "__" + resourceIdentifierNames[nResIDs-1] + "__";
	sortName2 = "__last__";
d2418 2
a2419 2
	sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
	sortName2 = "__" + resourceIdentifierNames[i] + "__";
d2448 3
a2450 3
	int k;
	for (k=0; k<nResIDs; k++)
	  nBomsAddedToSpecialSortLayer[k] = 0;
d2454 97
a2550 97
	// Get the number of subBOM arcs hanging off this BOM arc 
	int nSubBomArcs;
	char * consumedPartName;
	float * consRate, * offset, aversion;
	std::string sortLayerOp;

	

	checkWitRC(witGetBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,&consumedPartName));
	// Copy over those bom arcs that aren't related to the sortLayer
	if (!beginsWith(consumedPartName, "sortLayer:")) {

	  // Shut off BOM arc by setting earliestPeriod to nPeriods
	  checkWitRC(witSetBomEntryEarliestPeriod(witRun(),engagementName(engName).c_str(),i,nPeriods));
	  	  
	  std::string baseName, workingPartName(consumedPartName);
	  baseName = baseNameFromWorkingResourceName(workingPartName);
	  RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
	  
	  checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),engagementName(engName).c_str(),i,&nSubBomArcs));

	  // Work with Donna to get the right criteria for the linking up of the resource to the right sort layer
	  // This is a temporary approach.
	
	  int index, tempIndex, count = 0;
	  assert (resourceIdValues.size() == nResIDs);
	  for (index=0; index<nResIDs; index++){
	    if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   // Still need to check on the match flag DPC
	      count ++;
	      tempIndex = index;
	    }
	  }
	  switch (count)
	    {
	    case 0:
	      sortLayerOp = sortLayerEngagementName(engName, "__exact__");
	      nBomsAddedToSortLayer = nBomsAddedToExactLayer;
	      break;
	    case 1:
	      // NOTE:  We went through the resourceIdValues in the order of definition,
	      // so we use the unsorted list of resourceIDs to get the proper column.
	      sortLayerOp = sortLayerEngagementName(engName, "__"+ unsortedResourceIdentifierNames[tempIndex] + "__");
	      nBomsAddedToSortLayer = nBomsAddedToSpecialSortLayer[tempIndex];
	      break;
	    default:
	      sortLayerOp = sortLayerEngagementName(engName, "__last__");
	      nBomsAddedToSortLayer = nBomsAddedToLastLayer;
	    }
	  
	  checkWitRC(witAddBomEntry(witRun(),sortLayerOp.c_str(),consumedPartName));	    
	  checkWitRC(witSetBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,WitTRUE));
	  // Add a subBomArc to the global_sub_part for those bom arcs that have no subBomArcs
	  if (nSubBomArcs == 0)
	    checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,globalSubPart.c_str()));

	  // copy over the attributes of this BOM arc from the base model to the LastLayerDemand
	  // and then bring over all of the subBOMs and their attributes
	  checkWitRC(witGetBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,&consRate));
	  checkWitRC(witGetBomEntryOffset(witRun(),engagementName(engName).c_str(),i,&offset));
	  checkWitRC(witSetBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,consRate));
	  checkWitRC(witSetBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,offset));
	  // Now copy over the subBOM arcs
	  
	  int j;
	  for (j=0; j<nSubBomArcs; j++)
	    {
	      char * subConsumedPartName;
	      float *subConsRate, *subOffset;
	      checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,j,&subConsumedPartName));
	      checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,subConsumedPartName));
	      checkWitRC(witSetSubsBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
	      checkWitRC(witGetSubsBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,j,&subConsRate));
	      checkWitRC(witSetSubsBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subConsRate));
	      checkWitRC(witGetSubsBomEntryOffset(witRun(),engagementName(engName).c_str(),i,j,&subOffset));
	      checkWitRC(witSetSubsBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subOffset));
	      checkWitRC(witGetSubsBomEntryExpNetAversion(witRun(),engagementName(engName).c_str(),i,j,&aversion));
	      checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,aversion));
	      checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
	      witFree(subOffset);
	      witFree(subConsRate);
	      witFree(subConsumedPartName);
	    }
	  switch (count)
	    {
	    case 0: 
	      nBomsAddedToExactLayer ++;
	      break;
	    case 1:
	      nBomsAddedToSpecialSortLayer[tempIndex] ++;
	      break;
	    default:
	      nBomsAddedToLastLayer ++;
	    }
	  witFree(consumedPartName);
	  witFree(consRate);
	  witFree(offset);
	} 
d2588 1
a2588 1
	    
d2672 1
a2672 1
	cumTotal[i] = 0.f;
d2685 7
a2691 7
				   demandName.c_str(),
				   demandName.c_str(),
				   0,
				   & lenLists,
				   & operationNameList,
				   & execPeriodList,
				   & peggedExecVolList));
d2695 8
a2702 8
	{
	  if(acquireOpName == operationNameList[theIdx])
	    { //found it
	      cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
	      std::cout << "  Operation:" << consumedPartName << "  Period:" << execPeriodList[theIdx] << 
		" GAP: " << peggedExecVolList[theIdx] << std::endl;
	    }
	}
d2705 1
a2705 1
	witFree(operationNameList[theIdx]);
d2715 18
a2732 18
	{
	  char * subPartConsumed;
	  float * subVol;
	  checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed));
	  checkWitRC(witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol));
	  for (i=0; i<np; i++)
	    {
	      if (subVol[i]>0)
		{
		  float subQtyUsed = subVol[i] * consRate[i];
		  cumTotal[i] += subQtyUsed;
		  std::cout << "  Operation:" << consumedPartName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
			    << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
		}
	    }
	  witFree (subVol);
	  witFree (subPartConsumed);
	}
d2735 6
a2740 6
	{
	  float supplyQtyUsed = consRate[i] - cumTotal[i];
	  if (supplyQtyUsed > 0)
	    std::cout << "  Operation:" << consumedPartName << "  Period:" << i << " Supply Used:" 
			    << supplyQtyUsed << std::endl;
	}
d2747 1
a2747 1
	//****************************
d2750 3
a2752 3
				   const char* partName,
				   const char* demandName,
				   int shipPer)
d2761 8
a2768 8
			      witRun(),
			      partName,
			      demandName,
			      shipPer,
			      & lenLists,
			      & operationNameList,
			      & execPeriodList,
			      & peggedExecVolList));
d2784 3
a2786 3
				   const char* partName,
				   const char* demandName,
				   int shipPer)
d2797 10
a2806 10
			      witRun(),
			      partName,
			      demandName,
			      shipPer,
			      & lenLists,
			      & operationNameList,
			      & bomEntryIndexList,
			      & subsBomEntryIndexList,
			      & execPeriodList,
			      & peggedSubVolList));
d2875 2
a2876 2
	cumTotal[i] = 0.f;
	localConsRate[i] = 0.f;
d2894 7
a2900 7
				   demandName.c_str(),
				   demandName.c_str(),
				   0,
				   & lenLists,
				   & operationNameList,
				   & execPeriodList,
				   & peggedExecVolList));
d2904 10
a2913 10
	{
	  if(acquireOpName == operationNameList[theIdx])
	    { //found it
	      if (execPeriodList[theIdx] == theOffset){
		cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
		std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
		  " GAP: " << peggedExecVolList[theIdx] << std::endl;
	      }
	    }
	}
d2916 1
a2916 1
	witFree(operationNameList[theIdx]);
d2926 15
a2940 15
	{
	  char * subPartConsumed;
	  float * subVol;
	  checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed));
	  checkWitRC(witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol));
	  if (subVol[theOffset]>0)
		{
		  float subQtyUsed = subVol[theOffset] * localConsRate[theOffset];
		  cumTotal[theOffset] += subQtyUsed;
		  		  std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
		  			    << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
		}
	  witFree (subVol);
	  witFree (subPartConsumed);
	}
d2943 6
a2948 6
	{
	  float supplyQtyUsed = localConsRate[i] - cumTotal[i];
	  if (supplyQtyUsed > 0)
	    	    std::cout << "  Demand:" << demandName << "  Period:" << i << " Supply Used:" 
	    			    << supplyQtyUsed << std::endl;
	}
d2969 1
a2969 1
  // (1) Call Wit's pegging function for this demand
d2978 7
a2984 7
					  demandName.c_str(),
					  demandName.c_str(),
					  0,
					  & lenLists,
					  & operationNameList,
					  & execPeriodList,
					  & peggedExecVolList));
d2986 2
d3003 1
a3003 1
	int nBomArcs, bomIndex;
d3009 2
a3010 2
	  float localConsRate;  //This holds the BOM usage quantity
	  float cumTotal = 0.f;  //
d3015 2
a3016 2
	  
	  // (3)
d3025 19
a3043 17
	  
	  witFree(offset);
	  witFree(consRate);

	  // (4)  Now go find the pegged acquireOp's execution volume in period 'theOffset' from Wit's pegging computation.

	  //look for the acquireOperation in the returned operationNameList
	  for (theIdx = 0; theIdx < lenLists; theIdx++)
	    {
	      if(acquireOpName == operationNameList[theIdx])
		{ //found it -- now see if it is in the right time period
		  if (execPeriodList[theIdx] == theOffset){
		    cumTotal = peggedExecVolList[theIdx];
		    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << cumTotal << std::endl;
		  }
		}
	    }
d3046 1
a3046 1
	  
d3055 9
a3063 8
	      if (subVol[theOffset]>0)
		{
		  float subQtyUsed = subVol[theOffset] * localConsRate;
		  cumTotal += subQtyUsed;
		  std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset 
			    << " RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUB RESOURCE:" 
			    << baseNameFromWorkingResourceName(subPartConsumed) << " QUANTITY SUBBED: " << subQtyUsed << std::endl;
		}
d3068 3
a3070 4

	  float supplyQtyUsed = localConsRate - cumTotal;
	  if (supplyQtyUsed > 0)
	    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  Period:" << theOffset <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUPPLY USED: " 
d3072 2
d3290 1
a3290 1
	     setResourceMrpQuantity(names[r],t,grossQty[t]);
d3874 5
a3878 5
	float revenue;
	// The following line should throw an RCPOptIntException
	revenue = prob.getEngagementRevenue("e4");
	// shouldn't go to the next line
	assert( revenue == -1234.0);
@


1.259
log
@Fixed pegging function to handle mulitple demands.
@
text
@d353 1
a353 1
  int i;
d776 1
a776 1
  float * rtVec = floatToFloatStar(releaseTime);
d786 1
a786 1
    float * offsetVec = floatToFloatStar(i);
d4015 1
a4015 4
#if 0
    prob.setResourceReasonableReleaseCost(res1);
    assert( prob.getResourceReleaseCost(res1) == 24.0f);
#endif
d5148 232
a5379 1
  
@


1.258
log
@Pegging is implemented for GapGlut2 (03Dec) model.
@
text
@d2933 2
a2934 1
  // (2) For each demand, loop through all the BOMs for that demand.  These will be "sort-layer" parts.
d2942 18
a2959 1
  // (2)
d2995 1
a2995 1
          localConsRate = consRate[0];  //This stores the BOM usage rate 
d3000 14
a3013 10
	  // (4)
	  
	  float * acquireOpExecVol;
	  checkWitRC(witGetOperationExecVol(witRun(),acquireOpName.c_str(),&acquireOpExecVol));
		     
	  cumTotal = acquireOpExecVol[theOffset];
	  if (acquireOpExecVol[theOffset] > 0)
	    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << acquireOpExecVol[theOffset] << std::endl;
	  witFree(acquireOpExecVol);
	  
d3047 8
@


1.257
log
@remove "duration" from engagement files, along with "engagement location". Also, implement month/year format for engagement start times.
@
text
@d104 1
a104 7
//void RCPproblem::setEngagementDuration(const std::string & engName, 
 //                                      int duration)
//{
  //RCPengagementAppData * appData;
  //checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  //appData->setDuration(duration);
//}
d2533 1
a2533 1
  //  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
d2535 3
a2537 3
  //  generatePriorityGapGlut1PeggingResults();
  //  checkWitRC(witClearPegging(witRun()));
  //  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
d2811 14
d2925 1
d2928 99
d4805 1
a4805 1
    std::cout << "er5_test1" << std::endl;
@


1.256
log
@change a 0 to a "no" in input files for consistency
@
text
@a65 1
  //  engagementLocationNames_.insert(engagementLocationName);
d87 1
a87 7
void RCPproblem::setEngagementLocation(const std::string & engName, 
                                       const std::string & location)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setLocation(location);
}
d104 7
a110 7
void RCPproblem::setEngagementDuration(const std::string & engName, 
                                       int duration)
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData));
  appData->setDuration(duration);
}
d132 1
a132 6
std::string RCPproblem::getEngagementLocation(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getLocation();
}
d157 6
a162 6
int RCPproblem::getEngagementDuration(const std::string & engName)const
{
  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData));
  return appData->getDuration();
}
d1019 1
a1019 1
// Methods for handling jobRole, skill, location, lob, and source substitution in a common way
d3736 3
a3738 7
    prob.setEngagementDuration("e1",3);
    assert( prob.getEngagementDuration("e1") == 3 );
    
    assert(prob.getEngagementLocation("e1")=="");
    prob.setEngagementLocation("e1","Loc1");
    assert(prob.getEngagementLocation("e1")=="Loc1");
    
d4082 1
a4082 1
      prob1.setEngagementDuration("e1",3);
d4086 1
a4086 1
      assert(prob1.getEngagementDuration("e1")==3);
d4093 1
a4093 1
    assert(prob0.getEngagementDuration("e1")==3);    
d4665 2
a4666 2
    int ed = prob_IGS.getEngagementDuration("e1");
    assert(ed==2);
@


1.255
log
@Fixed a subBOM link to the global sub.
@
text
@a4754 1
	//  #if 0 //DLG
a4760 1
	//  #endif
a4852 1
    //     #if 0 //DLG
d4879 1
a4879 2
      }
     //      #endif
d4934 1
a4934 1
      //      #if 0 //DLG
a4953 1
      //       #endif
d5008 1
a5008 1
      //      #if 0 //DLG
a5027 2
      //       #endif

@


1.254
log
@Fixed a bug in the subBOM SORT model.
@
text
@d2498 1
a2498 1
	    checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,globalSubPart.c_str()));
@


1.253
log
@trivial changes
@
text
@d2418 6
d2495 1
a2495 1
	  checkWitRC(witSetBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,WitTRUE));
d2504 2
a2505 2
	  checkWitRC(witSetBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,consRate));
	  checkWitRC(witSetBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,offset));
d2514 2
a2515 2
	      checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,subConsumedPartName));
	      checkWitRC(witSetSubsBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,j,WitTRUE));
d2517 1
a2517 1
	      checkWitRC(witSetSubsBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,j,subConsRate));
d2519 1
a2519 1
	      checkWitRC(witSetSubsBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,j,subOffset));
d2521 2
a2522 2
	      checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,j,aversion));
	      checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer,j,WitTRUE));
d3190 3
d4755 1
a4755 1
  #if 0 //DLG
d4762 1
a4762 1
  #endif
d4855 1
a4855 1
     #if 0 //DLG
d4883 1
a4883 1
      #endif
d4938 1
a4938 1
      #if 0 //DLG
d4958 1
a4958 1
       #endif
d5013 1
a5013 1
      #if 0 //DLG
d5033 1
a5033 1
       #endif
@


1.252
log
@more tests
@
text
@d4712 1
a4712 1
    int r;
d4963 1
a4963 2
    // do solve in loop to make sure resolving works
    int r;
@


1.251
log
@added some tests
@
text
@d4713 2
a4714 2
    for (r=0; r<2; ++r ) {
      prob.gapGlut();
d4716 2
a4717 2
      // Create base name for each resource
      RCPvectorString r1, r2;
d4719 5
a4723 5
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r2.push_back("j1");r2.push_back("IBM");r2.push_back("G");
d4725 2
a4726 2
      //check that appropriate substitute arcs are there
      {
d4739 1
a4739 1
       }
d4741 2
a4742 2
      //check that the gaps and gluts are correct
      {
d4754 1
a4754 2
      }
    } // end of for r loop
d4768 1
a4768 3
    int r;
    for (r=0; r<2; ++r ) {
      prob.gapGlut();
d4770 3
a4772 3
      // Create base name for each resource
      RCPvectorString r1, r2, r3, r4, r5, r6;
      RCPvectorString r7, r8, r9, r10;
d4774 8
a4781 8
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j1");r2.push_back("PRIORITY");r2.push_back("G");
      r3.push_back("j1");r3.push_back("CONT");r3.push_back("PRIORITY");
      r4.push_back("j1");r4.push_back("CONT");r4.push_back("N");
      r5.push_back("j2");r5.push_back("CONT");r5.push_back("PRIORITY");
      r6.push_back("j2");r6.push_back("CONT");r6.push_back("N");
d4783 5
a4787 5
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      r9.push_back("j1");r9.push_back("CONT");r9.push_back("N");
      r10.push_back("j2");r10.push_back("CONT");r10.push_back("N");
d4789 2
a4790 2
      //check that appropriate substitute arcs are there
      {
d4844 1
a4844 1
       }  
d4846 3
a4848 3
      #if 0 //DLG
      //check that the gaps and gluts are correct
      {
d4873 75
d4951 75
a5025 2
    }  
  
d5027 1
@


1.250
log
@comment change
@
text
@d4700 1
a4700 2
#if 0
  //"new" style simple input
d4702 1
a4702 1
    RCPproblem prob_simple;
d4704 3
a4706 1
    inputDirectory = outputDirectory = "../data/example_simple";
d4708 32
a4739 3
    populate(prob_simple, inputDirectory, outputDirectory);
    prob_simple.gapGlut();
    prob_simple.resourceAction();
d4741 23
a4763 2
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    prob_simple.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
d4765 115
a4879 22
    std::vector<float> gapQty = prob_simple.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    std::vector<float> glutQty = prob_simple.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==20);
    assert(glutQty[1]==0);
    
    gapQty = prob_simple.getResourceGapQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    assert(gapQty[0]==10);
    assert(glutQty[0]==0);
    assert(gapQty[1]==30);
    assert(glutQty[1]==0);
    gapQty = prob_simple.getResourceGapQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==30);
    assert(gapQty[1]==0);
    assert(glutQty[1]==10);
    
  }
#endif
d4881 1
@


1.249
log
@found a bug in the substitution arcs when substitution was requested but no
substitution arcs given
@
text
@d1185 1
a1185 1
       //it is as if we require an exact match. So do it.
@


1.248
log
@gapGlut for 03Dec
@
text
@d1179 1
d1184 17
a1200 1
      return;
d1202 1
@


1.247
log
@removed unused methods
@
text
@a49 49
  // Add the sort layer 
  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifiersSortedByPriority();
  int nSpecialDemands = resourceIdentifierNames.size();
  std::string sortName1, sortName2, sortEngagementName1, sortEngagementName2;
  int np = getNPeriods();
  int i;

  for (i=0; i<=nSpecialDemands+1; i++){
    if (i==0) 
      sortName1 = "__exact__";
    else if (i==nSpecialDemands+1)
      sortName1 = "__last__";
    else
      sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
   
    sortEngagementName1 = sortLayerEngagementName(engName, sortName1);

    checkWitRC(witAddPart(witRun(),sortEngagementName1.c_str(),WitCAPACITY));
    checkWitRC(witAddOperation(witRun(),sortEngagementName1.c_str()));
    checkWitRC(witAddBopEntry(witRun(),sortEngagementName1.c_str(),sortEngagementName1.c_str()));
    //checkWitRC(witAddBomEntry(witRun(),theEngagement.c_str(),sortEngagementName1.c_str()));
  }
  
  if (nSpecialDemands == 0){
    sortName1 = "__exact__";
    sortName2 = "__last__";
    sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
    sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
    checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
    checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,np));
  }
  else for (i=0; i<=nSpecialDemands; i++){
    if (i==0){
      sortName1 = "__exact__";
      sortName2 = "__" + resourceIdentifierNames[0] + "__";
    }
    else if (i == nSpecialDemands ) {
      sortName1 = "__" + resourceIdentifierNames[nSpecialDemands-1] + "__";
      sortName2 = "__last__";
    }
    else {
      sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
      sortName2 = "__" + resourceIdentifierNames[i] + "__";
    }
    sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
    sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
    checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
    checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,np));
  }
d1759 1
a1759 1
  int numRows, np;
d1763 1
a1763 1
  numRows = names.size();
d1767 1
a1767 1
  for ( r=0; r<numRows; ++r ) {
d1807 1
a1807 1
  for ( r=0; r<numRows; ++r ) {
d1820 1
a1820 1
  for ( r=0; r<numRows; ++r ) {
a1856 26
#ifndef MULTIPLEENGAGEMENTS
  if (engSize == 0)
  {
    std::cout << "Can't execute priority gap/glut algorithm." << std::endl;
    std::cout << "The mrp based gap/glut will be executed" << std::endl;
    priorityGapGlut();
    return;
  }
  
  if (engSize != 1 || 
    getEngagementRequestedStartPeriod(engagementNames[0]) != 0)
  {
    // There still could be some problems here if there is just one demand
    // and it was not the default demand that was created for 04Feb.  DPC
    std::cout << "Can't execute priority gap/glut algorithm." << std::endl;
    std::cout << "The mrp based gap/glut will be executed" << std::endl;
    priorityGapGlut();
    return;
  }

  std::string theEngagement = engagementName(engagementNames[0]);
  
  // (1) set the demand of the base engagement to zero
  float * demandVol = floatToFloatStar(0.0f);
  checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol));
#endif
d1972 1
a1972 1
  int numRows;
d1974 1
a1974 1
  numRows = names.size();
d1980 1
a1980 1
  for ( r=0; r<numRows; ++r ) {
d2215 1
a2215 1
  for ( r=0; r<numRows; ++r ) {
d2235 1
a2235 1
  for ( r=0; r<numRows; ++r ) {
d2249 1
a2249 1
  for ( r=0; r<numRows; ++r ) {
d2260 328
d2919 1
a2919 1
  int numRows;
d2921 1
a2921 1
  numRows = names.size();
d2926 1
a2926 1
  for ( r=0; r<numRows; ++r ) {
d2979 1
a2979 1
  int numRows;
d2981 1
a2981 1
  numRows = names.size();
d2985 1
a2985 1
  for ( r=0; r<numRows; ++r ) {
d3039 1
a3039 1
  for ( r=0; r<numRows; ++r ) {
d3074 1
a3074 1
  for ( r=0; r<numRows; ++r ) {
d3098 1
a3098 1
  int numRows = names.size();
d3102 1
a3102 1
  for ( r=0; r<numRows; ++r ) {
d3118 1
a3118 1
  int numRows;
d3121 1
a3121 1
  numRows = resNames.size();
d3125 1
a3125 1
  for ( r=0; r<numRows; ++r ) 
d3180 1
a3180 1
  if (getAlgorithmName() == "priorityPlan")
d3183 2
d3187 1
d3222 1
a3222 1
  witWriteData(witRun(),"wity.dat");
d3286 1
a3286 1
  return "sortLayer: " + engagementName + "order: " + orderName;
d3627 1
a3627 1
    int numRows = names.size();
d3629 1
a3629 1
    for ( r=0; r<numRows; ++r ) { 
@


1.246
log
@populate.cpp:  added newline at the end of the file

rcpProblem.cpp:  Added some new structure to handle the sorting layer;
modified the sorting test case

rcpProblem.h:  modified the comparison operator for the sorting of the id
priorities to handle ids that default to zero.
@
text
@d438 1
a438 9
void RCPproblem::setDemandTypePriority(const std::string & demandType, int priority )
{
  mapDemandTypeToPriority_[demandType]=priority;
}
int RCPproblem::getDemandTypePriority(const std::string & demandType ) const
{
  int retVal = mapDemandTypeToPriority_.find(demandType)->second;
  return retVal;
}
@


1.245
log
@Added method to get list of ResourceIdentifiers sorted by priority.
std::vector<std::string> getResourceIdentifiersSortedByPriority() const;
@
text
@d49 51
a99 1
  
a3022 1

d3027 1
d3036 4
a3039 1

d3508 3
d3518 12
a3529 6
      int r;
      for ( r=1; r<resIdsSortByPriority.size(); ++r ) {
        int p0 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r-1]);
        int p1 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r  ]);
        assert( p0 <= p1 );
      }
d4355 1
a4355 1
  
d4384 1
@


1.244
log
@folding together original "engagement" oriented files with new ER5 files
@
text
@d361 27
d3454 16
@


1.243
log
@more changes to support demandType
@
text
@d80 7
d131 6
@


1.242
log
@support for handling demandType and demandTypePriority
@
text
@d2938 7
a2944 1

@


1.241
log
@some changes to support ER5; adding columns for demand type, flags for substituion
@
text
@d348 9
@


1.240
log
@Implemented the reasource action leadtime notification model and updated some unitTest cases to reflect this change.  In earlier versions, although we read in the leadtime parameter, the optimization model didn't implement the leadtime and set it to zero.
@
text
@d644 1
a644 1
  witFree(rtv);
@


1.239
log
@commented out assorted asserts and did things to make the eclipse compiler happy. Also for cleanliness, added "acquireTime" to readResourceFile.
@
text
@d50 6
d58 1
a58 1
  //checkWitRC(witSetOperationIncLotSize(witRun(),"JUNK",vecOne)); ////DPC
d204 2
d214 3
a217 4
  // Add appData for benchRes
  //  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  //  checkWitRC(witSetPartAppData(witRun(),benchRes.c_str(),benchAppData));

d222 14
a249 1
  
d260 6
a265 1
  
d641 4
a644 6
  //remember to negate this
  
  //std::string acquireOp = acquireResourceOperationName(jobRole);  Still need to model this
  //  float * rtv = floatToFloatStar(releaseTime);
  //  checkWitRC(witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,rtv));   Still need to model this
  //delete [] rtv;
d650 1
a650 1
  std::string benchOp = benchResourceName(resourceIdentifierValues); 
d652 1
a652 1
  checkWitRC(witSetPartObj1ScrapCost(witRun(),benchOp.c_str(),rcv));
d674 2
d681 3
d714 1
a714 1
  std::string benchRes = benchResourceName(resourceIdentifierValues);
d716 1
a716 1
  checkWitRC(witGetPartObj1ScrapCost(mutableWitRun(),benchRes.c_str(),&rcv));
d726 5
a730 8
  //  std::string benchRes = benchResourceName(jobRole);
  //float * rtv;
  //checkWitRC(witGetBopEntryOffset(mutableWitRun(),benchRes.c_str(),0,&rtv));
  //float returnVal = rtv[0];
  float returnVal = 0.0;  //Still need to model this
  assert(0==1);
  //witFree(rtv);
  
d732 1
a732 2
}

d748 19
a766 1

d2783 2
a2784 2
    std::string enableOpName, benchResName, acquireOpName;
    std::vector<float> workingQty, releaseQty, acquireQty, benchQty;
d2789 3
a2791 1
    
d2793 4
a2796 1
    releaseQty = witGetNameAttribute(witGetPartScrapVol,benchResName);
d2798 1
d2800 1
d2802 1
d2804 5
a2808 1
      setResourceWorkingQuantity(resNames[r],t,workingQty[t]);
d2811 1
a2811 1
      setResourceBenchQuantity(resNames[r],t,benchQty[t]);
d2952 8
d2975 10
d3815 1
a3815 1
        int foo = gapQty[0];
d3961 1
a3961 1
    double expectedObjValue = 4886.0;
d4261 1
a4261 1
    assert( eq(obj,39835.0f) );
d4295 1
a4295 1
    assert( eq(obj,39835.0f) );
@


1.238
log
@minor change in hopes of being more efficient with vectors
@
text
@d134 1
a134 1
  int duration = getEngagementDuration(engName);
d840 1
a840 1
    int bomIndex = getBomEntryIndex(theEngagement,workingRes,t);
d1351 1
a1351 1
  int nBomIndices =bomIndices.size();
d1471 1
a1471 1
    int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
d1494 1
a1494 1
      int duration = getEngagementDuration(engagementNames[e]);
d1524 1
a1524 1
      int duration = getEngagementDuration(engagementNames[e]);
d1568 1
a1568 1
      int duration = getEngagementDuration(engagementNames[e]);
d1598 1
a1598 1
      int duration = getEngagementDuration(engagementNames[e]);
d2103 1
a2103 1
	assert (resourceIdValues.size() == nSpecialDemands);
d2410 2
a2411 2
  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  int nSpecialDemands = getResourceIdentifierNames().size();
d2917 2
a2918 2
  int x = getResourceIdentifierNames().size();
  assert( getResourceIdentifierNames().size() ==  numAttributes );
d2973 1
a2973 1
  int nP = getNPeriods();
d3012 1
a3012 1
  int nP = getNPeriods();
d3743 1
@


1.237
log
@moved initialization back to the constructor of the timer
@
text
@a1080 2
  //find the set of all {from/to} substitutes specified for the given resourceIdName
  const RCPmapMapStringToSubs & attributeSubs = resourceIdToSubs_[resourceIdName];
d1090 3
d1175 1
d1225 1
a1225 2
        std::vector<std::string> toResourceVector;
        toResourceVector.clear();
d1229 1
a1229 1
          toResourceVector.push_back(resourceIdentifierValueFromResourceName(subsResource, i));
d1231 1
a1231 13
        //std::string toJobRole = jobRoleFromResourceName(subsResource);
        //std::string toSkill   = skillSetFromResourceName(subsResource);
        //std::string toRegion = regionFromResourceName(subsResource);
        //std::string toCountry = countryFromResourceName(subsResource);
        //std::string toCity = cityFromResourceName(subsResource);
        //std::string toReportingUnit = reportingUnitFromResourceName(subsResource);
        //std::string toBand = bandFromResourceName(subsResource);
        //std::string toGlobal = globalFromResourceName(subsResource);
        //std::string toCompetency = competencyFromResourceName(subsResource);
        //std::string toIndustry = industryFromResourceName(subsResource);
        //std::string toLOB = LOBFromResourceName(subsResource);
        //std::string toSource = sourceFromResourceName(subsResource);
        
@


1.236
log
@put initialization of timer in rcpProblem constructor.
@
text
@a3058 1
  getTimer().initializeTimer();
@


1.235
log
@removed some extraneous things
@
text
@d3059 1
@


1.234
log
@fixed timing issues
@
text
@a37 3
void RCPproblem::setTimer(RcpOptTimer &t) {
  timer_ = t;
}
d1560 1
d1562 1
d1634 1
d1636 2
@


1.233
log
@finer resolution in time
@
text
@d34 3
a36 3
void RCPproblem::setTimer(RcpOptTimer timer) 
{
  timer_ = timer;
d38 2
a39 2
RcpOptTimer RCPproblem::getTimer() {
  return timer_;
d41 1
d2774 1
a2774 1
  getTimer().printElapsedTime("in gapGlut");
a3055 1

a3056 1

d3642 1
a3642 1
  RcpOptTimer rcptimer;
@


1.232
log
@adding timing capability
@
text
@d3055 1
d3057 1
a3057 1
  RcpOptTimer timer_;
@


1.231
log
@More checks were added to catch potential WIT severe or fatal issues.  You must update WIT for these changes to work.
@
text
@d27 1
d33 8
d2773 1
d2775 1
d2777 2
d2781 2
d2785 2
d2788 2
a2789 1
  
d2805 2
d3056 1
d3642 1
@


1.230
log
@Added a wrapper around all WIT calls:  checkWitRC(witReturnCode wrc)
@
text
@d30 2
d45 1
a108 1
  //  checkWitRC(checkWitRC(witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData)));
d2149 1
a2149 1
  witHeurImplode(witRun());
d2151 1
a2151 1
  //  witClearPegging(witRun());
d2422 1
a2422 1
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desird quantity)
d2436 2
d2440 1
a2440 1
      for(i=0; i<np; i++)
d2442 2
d2450 3
d2473 5
a2477 3
	      cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
	      	      std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
	      		" GAP: " << peggedExecVolList[theIdx] << std::endl;
d2497 1
a2497 3
	  for (i=0; i<np; i++)
	    {
	      if (subVol[i]>0)
d2499 2
a2500 2
		  float subQtyUsed = subVol[i] * consRate[i];
		  cumTotal[i] += subQtyUsed;
a2503 1
	    }
d2510 2
a2511 2
	  float supplyQtyUsed = consRate[i] - cumTotal[i];
	  //if (supplyQtyUsed > 0)
d3042 2
a3043 1
  gutsOfDestructor();
d3227 1
a3227 1
  
d3260 2
a3262 1
    
@


1.229
log
@added the "bad crash" to our test suite
@
text
@d27 2
a28 2


d36 4
a39 4
  witAddPart(witRun(),theEngagement.c_str(),WitCAPACITY);
  witAddDemand(witRun(),theEngagement.c_str(),theEngagement.c_str());
  witAddOperation(witRun(),theEngagement.c_str());
  witAddBopEntry(witRun(),theEngagement.c_str(),theEngagement.c_str());
d42 1
a42 1
  witSetOperationIncLotSize(witRun(),theEngagement.c_str(),vecOne);
d46 1
a46 1
  witSetPartAppData(witRun(),theEngagement.c_str(),appData);
d61 1
a61 1
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
d68 1
a68 1
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
d78 1
a78 1
  witGetPartAppData(witRun(),theEngagement.c_str(),(void**)&appData);
d84 1
a84 1
  witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol);
d91 1
a91 1
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
d98 1
a98 1
  witGetPartAppData(witRun(),engagementName(engName).c_str(),(void**)&appData);
d106 2
a107 1
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
d113 1
a113 1
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
d119 1
a119 1
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
d143 1
a143 1
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
d150 1
a150 1
  witGetPartAppData(mutableWitRun(),engagementName(engName).c_str(),(void**)&appData);
d193 4
a196 4
  witAddOperation(witRun(),acquireOp.c_str());
  witAddPart(witRun(),benchRes.c_str(),WitMATERIAL);
  witAddOperation(witRun(),enableOp.c_str());
  witAddPart(witRun(),workingRes.c_str(),WitCAPACITY);
d200 1
a200 1
  //  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);
d204 1
a204 1
  witSetPartAppData(witRun(),workingRes.c_str(),workingAppData);
d208 2
a209 2
  witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str());
  //  witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),0,WitTRUE);
d212 1
a212 1
  witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE);
d214 3
a216 3
  witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str());
  witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str());
  //  witSetBopEntrySelForDel(witRun(),enableOp.c_str(),0,WitTRUE);
d218 1
a218 1
  witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE);  
d222 1
a222 1
    witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str());
d225 1
a225 1
    witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec);
d227 2
a228 2
    witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE);
    witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2);
d349 1
a349 1
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d363 1
a363 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d378 1
a378 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d392 1
a392 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d402 1
a402 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d411 1
a411 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d427 1
a427 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d448 1
a448 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d459 1
a459 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d469 1
a469 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d478 1
a478 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d487 1
a487 1
  witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
d516 1
a516 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d526 1
a526 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d536 1
a536 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d546 1
a546 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d556 1
a556 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d566 1
a566 1
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
d589 1
a589 1
  witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv);
d600 1
a600 1
  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv);
d611 1
a611 1
  //  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,rtv);   Still need to model this
d620 1
a620 1
  witSetPartObj1ScrapCost(witRun(),benchOp.c_str(),rcv);
d643 1
a643 1
  witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost);
d645 2
a646 2
  witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost);
  witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost);
d656 1
a656 1
  witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv);
d668 1
a668 1
  witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv);
d679 1
a679 1
  witGetPartObj1ScrapCost(mutableWitRun(),benchRes.c_str(),&rcv);
d691 1
a691 1
  //witGetBopEntryOffset(mutableWitRun(),benchRes.c_str(),0,&rtv);
d754 2
a755 2
    witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex);
    witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str());
d759 1
a759 1
    witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData);
d873 1
a873 1
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
d894 1
a894 1
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
d913 1
a913 1
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
d931 1
a931 1
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
d1189 1
a1189 1
      witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),bomIndex,(void**)&appData);
d1291 1
a1291 1
        witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex);
d1294 1
a1294 1
        witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() );
d1316 1
a1316 1
        witSetSubsBomEntryExpNetAversion(witRun(),witEngagement.c_str(),bomIndex,subIndex,(float)subsAversion);      
d1360 1
a1360 1
    witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&nSubs);
d1366 1
a1366 1
      witGetSubsBomEntryConsumedPart(mutableWitRun(),witEngagement.c_str(),bomIndex,s,&subResName);
d1383 2
a1384 2
  witSetSelSplit(witRun(), WitTRUE);
  witSetExpCutoff(witRun(), 0.0001f);
d1401 1
a1401 1
      witSetBopEntryProductRate(witRun(),theEngagement.c_str(),0,prodRate);
d1406 1
a1406 1
      witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs);
d1410 1
a1410 1
        witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate);
d1415 1
a1415 1
        witSetBomEntryConsRate(witRun(),theEngagement.c_str(),i,consRate);
d1419 1
a1419 1
        witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
d1422 1
a1422 1
          witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate);
d1427 1
a1427 1
          witSetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,consRate);
d1456 1
a1456 1
      witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL);
d1474 1
a1474 1
    witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL);
d1511 1
a1511 1
      witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward);
d1531 1
a1531 1
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
d1537 1
a1537 1
        witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData);
d1583 1
a1583 1
      witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward);
d1603 1
a1603 1
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
d1609 1
a1609 1
        witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData);
d1648 1
a1648 1
        witSetSubsBomEntrySelForDel(witRun(),witOpName.c_str(),bomEntryIndex,subsEntryIndices[s],WitTRUE);
d1702 1
a1702 1
      witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs);
d1707 1
a1707 1
        witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
d1710 1
a1710 1
          witSetSubsBomEntryMrpNetAllowed(witRun(),theEngagement.c_str(),i,j,WitTRUE);
d1794 1
a1794 1
  witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol);
d1824 8
a1831 8
      witAddPart(witRun(),specialDemand.c_str(),WitCAPACITY);
      witAddOperation(witRun(),specialDemand.c_str());
      witAddDemand(witRun(),specialDemand.c_str(),specialDemand.c_str());
      witAddBopEntry(witRun(),specialDemand.c_str(),specialDemand.c_str());
      
      witSetDemandSelForDel(witRun(),specialDemand.c_str(),specialDemand.c_str(),WitTRUE);
      witSetPartSelForDel(witRun(),specialDemand.c_str(),WitTRUE);
      witSetOperationSelForDel(witRun(),specialDemand.c_str(), WitTRUE);
d1833 1
a1833 1
      witSetDemandDemandVol(witRun(),specialDemand.c_str(),specialDemand.c_str(),demandVol);
d1836 1
a1836 1
      witGetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),&priorityVec);
d1847 1
a1847 1
        witSetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),priorityVec);
d1855 1
a1855 1
      witSetDemandAttribute(witSetDemandPriority,specialDemand,specialDemand,priority);
d1862 8
a1869 8
    witAddPart(witRun(),priorityExactDemand.c_str(),WitCAPACITY);
    witAddOperation(witRun(),priorityExactDemand.c_str());
    witAddDemand(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str());
    witAddBopEntry(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str());
    
    witSetDemandSelForDel(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),WitTRUE);
    witSetPartSelForDel(witRun(),priorityExactDemand.c_str(),WitTRUE);
    witSetOperationSelForDel(witRun(),priorityExactDemand.c_str(), WitTRUE);
d1871 1
a1871 1
    witSetDemandDemandVol(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),demandVol);
d1874 1
a1874 1
    witGetDemandPriority(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),&priorityVec);
d1877 1
a1877 1
    witSetDemandPriority(witRun(),priorityExactDemand.c_str(),priorityExactDemand.c_str(),priorityVec);
d1880 1
a1880 1
    witSetDemandAttribute(witSetDemandPriority,priorityExactDemand,priorityExactDemand,1);
d1886 8
a1893 8
    witAddPart(witRun(),priorityLastDemand.c_str(),WitCAPACITY);
    witAddOperation(witRun(),priorityLastDemand.c_str());
    witAddDemand(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str());
    witAddBopEntry(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str());
    witSetDemandSelForDel(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),WitTRUE);
    witSetPartSelForDel(witRun(),priorityLastDemand.c_str(),WitTRUE);
    witSetOperationSelForDel(witRun(),priorityLastDemand.c_str(), WitTRUE);
    witSetDemandDemandVol(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),demandVol);
d1896 1
a1896 1
    witGetDemandPriority(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),&priorityVec);
d1899 1
a1899 1
    witSetDemandPriority(witRun(),priorityLastDemand.c_str(),priorityLastDemand.c_str(),priorityVec);
d1902 1
a1902 1
    witSetDemandAttribute(witSetDemandPriority,priorityLastDemand,priorityLastDemand,maxPriority+2);
d1925 2
a1926 2
    witAddBopEntry(witRun(),acquireRes.c_str(),workingRes.c_str());
    witSetBopEntrySelForDel(witRun(),acquireRes.c_str(),1,WitTRUE);
d1936 1
a1936 1
    witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec);
d1946 1
a1946 1
    witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs);
d1964 1
a1964 1
      witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName);
d1980 1
a1980 1
      witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
d2015 2
a2016 2
      witAddBomEntry(witRun(),priorityDemand.c_str(),consumedPartName);	    
      witSetBomEntrySelForDel(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,WitTRUE);
d2019 4
a2022 4
      witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate);
      witGetBomEntryOffset(witRun(),theEngagement.c_str(),i,&offset);
      witSetBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,consRate);
      witSetBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,offset);
d2029 10
a2038 10
        witGetSubsBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,j,&subConsumedPartName);
        witAddSubsBomEntry(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,subConsumedPartName);
        witSetSubsBomEntrySelForDel(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE);
        witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&subConsRate);
        witSetSubsBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,subConsRate);
        witGetSubsBomEntryOffset(witRun(),theEngagement.c_str(),i,j,&subOffset);
        witSetSubsBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,subOffset);
        witGetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),i,j,&aversion);
        witSetSubsBomEntryExpNetAversion(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,aversion);
        witSetSubsBomEntryMrpNetAllowed(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE);
d2076 1
a2076 1
      witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs);
d2087 1
a2087 1
	witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName);
d2093 1
a2093 1
	witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
d2112 1
a2112 1
	witGetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),&priorityVec);
d2136 1
a2136 1
	witSetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),priorityVec);
d2146 1
a2146 1
  witSetPerfPegging(witRun(), WitTRUE);
d2148 3
a2150 3
  generatePriorityGapGlut1PeggingResults();
  witClearPegging(witRun());
  witSetPerfPegging(witRun(), WitFALSE);
d2169 1
a2169 1
  witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandVol);
d2178 1
a2178 1
    witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero);
d2193 1
a2193 1
    witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec);
d2241 1
a2241 1
  witGetOperationNBomEntries(witRun(),demandName.c_str(),&nBomArcs);
d2252 2
a2253 2
      witGetBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,&consumedPartName);
      witGetBomEntryConsRate(witRun(),demandName.c_str(),bomIndex,&consRate);
d2262 1
a2262 1
      witGetDemandExecVolPegging ( witRun(),
d2269 1
a2269 1
				   & peggedExecVolList);
d2291 1
a2291 1
      witGetBomEntryNSubsBomEntries(witRun(),demandName.c_str(),bomIndex,&nSubBomArcs);
d2296 2
a2297 2
	  witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed);
	  witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol);
d2338 1
a2338 1
  witGetDemandExecVolPegging (
d2346 1
a2346 1
			      & peggedExecVolList);
d2374 1
a2374 1
  witGetDemandSubVolPegging (
d2384 1
a2384 1
			      & peggedSubVolList);
d2427 1
a2427 1
  witGetOperationNBomEntries(witRun(),demandName.c_str(),&nBomArcs);
d2439 3
a2441 3
      witGetBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,&consumedPartName);
      witGetBomEntryConsRate(witRun(),demandName.c_str(),bomIndex,&consRate);
      witGetBomEntryOffset(witRun(),demandName.c_str(),bomIndex,&offset);
d2450 1
a2450 1
      witGetDemandExecVolPegging ( witRun(),
d2457 1
a2457 1
				   & peggedExecVolList);
d2465 2
a2466 2
	      //	      std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
	      //		" GAP: " << peggedExecVolList[theIdx] << std::endl;
d2479 1
a2479 1
      witGetBomEntryNSubsBomEntries(witRun(),demandName.c_str(),bomIndex,&nSubBomArcs);
d2484 2
a2485 2
	  witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed);
	  witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol);
d2492 2
a2493 2
		  //		  std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
		  //			    << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
d2504 2
a2505 2
	    //	    std::cout << "  Demand:" << demandName << "  Period:" << i << " Supply Used:" 
	    //			    << supplyQtyUsed << std::endl;
d2563 1
a2563 1
  witSetOptWithLotSizes(witRun(),WitTRUE); 
d2597 1
a2597 1
    witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&aov);
d2603 1
a2603 1
    witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec);
d2612 1
a2612 1
      witAddBopEntry(witRun(),acquireOp.c_str(),workingRes.c_str());
d2614 3
a2616 3
      witSetBopEntryOffset(witRun(),acquireOp.c_str(),i+1,vecOffset);
      witSetBopEntryLatestPeriod(witRun(),acquireOp.c_str(),i+1,np-i-1+acqOffset);
      witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),i+1,WitTRUE);
d2687 1
a2687 1
    witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec);
d2760 1
a2760 1
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
d2773 1
a2773 1
      witSetOptWithLotSizes(witRun(),WitFALSE);
d2783 1
a2783 1
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
d2790 1
a2790 1
  //  witSetOptWithLotSizes(witRun(),WitTRUE); 
d2793 1
a2793 1
    //witSetOptWithLotSizes(witRun(),WitTRUE); 
d2798 1
a2798 1
    witSetOptWithLotSizes(witRun(),WitTRUE); 
d2957 1
a2957 1
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms);
d2962 1
a2962 1
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit);
d2966 1
a2966 1
      witGetBomEntryAppData(mutableWitRun(),opName.c_str(),bei,(void**)&appData);
d2997 1
a2997 1
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms);
d3002 1
a3002 1
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit);
d3028 1
a3028 1
  witSetExecEmptyBom(witRun(),WitTRUE);
d3088 1
a3088 1
    witGetPartAppData(source.mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData);
d3090 1
a3090 1
    witSetPartAppData(witRun(),theEngagement.c_str(),sinkAppData);
d3103 1
a3103 1
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
d3109 1
a3109 1
        witGetBomEntryAppData(source.mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData);
d3111 1
a3111 1
        witSetBomEntryAppData(witRun(),theEngagement.c_str(),b,sinkAppData);
d3127 1
a3127 1
      witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
d3129 1
a3129 1
      witSetPartAppData(witRun(),resourceName.c_str(),sinkAppData); 
d3146 1
a3146 1
    witGetPartAppData(mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData);
d3160 1
a3160 1
      witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries);
d3165 1
a3165 1
        witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData);
d3183 1
a3183 1
      witGetPartAppData(mutableWitRun(),workingResWitName.c_str(),(void**)&srcAppData);
d3219 32
a3250 1
  // Test engagements
@


1.228
log
@Fixed BomIndex problem that caused the example from Tucson to crash
@
text
@d4716 9
@


1.227
log
@changed unspecified and priority to UNSPECIFIED and PRIORITY
@
text
@d1188 1
a1188 1
      witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),be,(void**)&appData);
d2145 1
a2145 1
  //  witSetPerfPegging(witRun(), WitTRUE);
d2147 3
a2149 3
  //  generatePriorityGapGlut1PeggingResults();
  //  witClearPegging(witRun());
  //  witSetPerfPegging(witRun(), WitFALSE);
d2198 1
a2198 2

//#if 0
d2399 113
a2513 1
//#endif		       
d3583 1
@


1.226
log
@updated to use witSetDemandAttribute in more places
@
text
@d1986 1
a1986 1
      // Now go through the working resource and see how many "unspecified" or "priority" values it has;
d1993 1
a1993 1
        if (resourceIdValues[index] == "unspecified" || resourceIdValues[index] == "priority"){   // Still need to check on the match flag DPC
d2094 1
a2094 1
	// Now go through the working resource and see how many "unspecified" or "priority" values it has;
d2101 1
a2101 1
	  if (resourceIdValues[index] == "unspecified" || resourceIdValues[index] == "priority"){   
d3493 1
a3493 1
      r4.push_back("j2");r4.push_back("s2");r4.push_back("priority");r4.push_back("global");
d3637 5
a3641 5
      r11.push_back("j2");r11.push_back("s2");r11.push_back("IBM");r11.push_back("global");r11.push_back("unspecified");r11.push_back("US");
      r12.push_back("j1");r12.push_back("s1");r12.push_back("priority");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
      r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("unspecified");r13.push_back("priority");
      r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("priority");r14.push_back("newyork");r14.push_back("US");
      r15.push_back("j3");r15.push_back("unspecified");r15.push_back("Cont");r15.push_back("non-global");r15.push_back("newyork");r15.push_back("US");   
d4244 1
a4244 1
    names.push_back("j2");names.push_back("unspecified");names.push_back("IBM");names.push_back("non-global");
d4318 1
a4318 1
    names.push_back("unmatched");names.push_back("unspecified");names.push_back("IBM");names.push_back("non-global");
d4350 1
a4350 1
    names.push_back("s1");names.push_back("priority");names.push_back("global");names.push_back("lob");
d4357 1
a4357 1
    names.push_back("s1");names.push_back("IBM");names.push_back("priority");names.push_back("lob");
d4364 1
a4364 1
    names.push_back("unspecified");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d4371 1
a4371 1
    names.push_back("unspecified");names.push_back("IBM");names.push_back("global");names.push_back("unspecified");
d4475 1
a4475 1
    names.push_back("unmatched");names.push_back("unspecified");names.push_back("IBM");names.push_back("non-global");
d4516 1
a4516 1
    names.push_back("s1");names.push_back("priority");names.push_back("global");names.push_back("lob");
d4527 1
a4527 1
    names.push_back("s1");names.push_back("IBM");names.push_back("priority");names.push_back("lob");
d4538 1
a4538 1
    names.push_back("unspecified");names.push_back("IBM");names.push_back("global");names.push_back("lob");
d4549 1
a4549 1
    names.push_back("unspecified");names.push_back("IBM");names.push_back("global");names.push_back("unspecified");
@


1.225
log
@Modifed to use witSetDemandAttribute
@
text
@d1854 1
a1854 1
      witSetDemandAttribute(witSetDemandPriority,specialDemand.c_str(),specialDemand.c_str(),priority);
d1871 1
d1878 3
d1893 1
d1900 3
@


1.224
log
@priorityGapGlut1 now works off the multiple demands that get created, one for each resource, in populate.  Turn off the definition of MULTIPLEENGAGEMENTS at the top of rcpProblem.cpp and populate.cpp to get back to the old approach of one engagement.
@
text
@a1820 1
      int priority;
d1833 1
d1848 8
a2213 1
      int priority;
a2282 2
      char * subPartConsumed;
      float * subVol;
@


1.223
log
@reorder tests, and fix comment about tests
@
text
@d7 2
d1745 1
d1749 1
a1749 1
  // (2) Create two additional demand structures, one for the demand that must be met exactly and one for the demand
d1768 3
a1770 1
  if (engagementNames.size() == 0)
d1778 1
a1778 1
  if (engagementNames.size() != 1 || 
d1788 1
a1788 1
  
d1794 1
d1808 1
a1808 1
  
d1884 1
a1884 1
      priorityVec[t] = INT_MAX;  // zero is the lowest priority
d1888 2
a1889 2
  
  
d1923 2
a1924 1
  
d2043 83
d2129 1
d2131 3
d2149 1
d2154 1
d2165 1
d2168 2
a2169 1
  
d2183 208
d2395 1
a2395 1
  
d2753 4
d4321 1
d4483 1
d4585 1
@


1.222
log
@fix up unit test for checking for subs. arcs
@
text
@d4076 93
a4168 1
   {
d4172 1
a4172 1
    //this one is just like tucson2, except there are 12 periods in the horizon,
d4269 1
d4279 1
a4279 93
  {
    RCPproblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson3";
    //this one is exactly the same as tucson1, except that there are two identical periods.
    //this is just to test that more than one period works as expected
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    assert(gapQty[1]==1);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    assert(gapQty[1]==0);
    assert(glutQty[1]==1);
    
    names.clear();
    names.push_back("unmatched");names.push_back("unspecified");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); 
    assert(glutQty[0]==0);
    assert(gapQty[1]==1); 
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
  }
  {
@


1.221
log
@Added some more debug testing code
@
text
@d3163 1
a3163 1
      RCPvectorString r1,r2,r3,r4,r5,r6,rdummy;
d3165 2
d3170 4
a3173 3
#if 1
       r4.push_back("j2");r4.push_back("s2");r4.push_back("Cont");r4.push_back("global");
       r5.push_back("j2");r5.push_back("s2");r5.push_back("IBM");r5.push_back("global");
d3175 2
a3176 6
#else
       r4.push_back("j2");r4.push_back("s2");r4.push_back("priority");r4.push_back("global");
       r5.push_back("j2");r5.push_back("s2");r5.push_back("Supp");r5.push_back("global");
       r6.push_back("j2");r6.push_back("s2");r6.push_back("IBM");r6.push_back("global");
#endif
       rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("priority");rdummy.push_back("global");
d3186 1
a3186 1
        std::string rdstr   = prob_subs.baseResourceName(rdummy);
d3202 1
a3202 1
        assert( subsRes.find( rdstr )   == subsRes.end() );  
d3215 1
a3215 1
        assert( subsRes.find( rdstr )   == subsRes.end() );  
d3228 1
a3228 1
        assert( subsRes.find( rdstr )   == subsRes.end() );  
a3230 1
#if 1
a3238 40
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( rdstr )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
#endif
        
        prob_subs.getSubsResources(
          createEngagementName(r5),
          r5,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( rdstr )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(
          createEngagementName(r6),
          r6,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( rdstr )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(          
          createEngagementName(rdummy),
          rdummy,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   != subsRes.end() );  
d3241 1
a3241 1
        assert( subsRes.find( rdstr )   == subsRes.end() );  
d3243 3
a3245 2
      }
      
d3275 2
a3276 2
        gapQty = prob_subs.getResourceGapQuantity(rdummy);
        glutQty = prob_subs.getResourceGlutQuantity(rdummy);
@


1.220
log
@Modified implementation of MULTIPLEENGAGEMENTS so that the difference is now contained in the engagementName method, rather than the code that calls engagementName.
@
text
@d2560 1
@


1.219
log
@nothing significant
@
text
@d3167 10
a3176 4
      r4.push_back("j2");r4.push_back("s2");r4.push_back("Cont");r4.push_back("global");
      r5.push_back("j2");r5.push_back("s2");r5.push_back("IBM");r5.push_back("global");
      r6.push_back("j2");r6.push_back("s2");r6.push_back("Supp");r6.push_back("global");
      rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("priority");rdummy.push_back("global");
d3193 2
a3194 1
          "engagement",r1,subsRes);
d3206 2
a3207 1
          "engagement",r2,subsRes);
d3219 2
a3220 1
          "engagement",r3,subsRes);
d3230 2
a3231 1
        
d3233 2
a3234 1
          "engagement",r4,subsRes);
d3244 1
d3247 2
a3248 1
          "engagement",r5,subsRes);
d3260 2
a3261 1
          "engagement",r6,subsRes);
d3272 3
a3274 2
        prob_subs.getSubsResources(
          "engagement",rdummy,subsRes);
@


1.218
log
@some more tests of the calendar handling
@
text
@d2338 1
a2338 1
    else
@


1.217
log
@need to check the planning horizon before setting some attributes on the resource
@
text
@d4101 110
@


1.216
log
@Moved all the resource app data to the working resource and removed the app data that was on the bench resource.
@
text
@d1878 1
a1878 1
      priorityVec[t] = 0;  // zero is the lowest priority
@


1.215
log
@fix memory leak in RCPproblem::priorityGapGlut1
@
text
@d196 3
a198 3
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);
  
d344 4
a347 4
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData);
  appData->setSupplyAppData(period, supplyQuantity);
d511 1
a511 1
  std::string benchRes = benchResourceName(resourceIdentifierValues);
d513 1
a513 1
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
d2745 1
a2745 5
      std::string benchResWitName = benchResourceName(names[r]);
      RCPresourceAppData * srcAppData;  
      witGetPartAppData(mutableWitRun(),benchResWitName.c_str(),(void**)&srcAppData);
      delete srcAppData;

@


1.214
log
@fix memory leak with resourceAppData
@
text
@d2004 1
d2008 4
a2011 4
        witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate);
        witSetSubsBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,consRate);
        witGetSubsBomEntryOffset(witRun(),theEngagement.c_str(),i,j,&offset);
        witSetSubsBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,offset);
d2015 2
@


1.213
log
@fix memory leak in RCPproblem::getBomEntryIndex
@
text
@a195 1
  // JPF Fix Leak
d2711 1
a2711 1
  // delte rcp bom appData
a2735 1
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames,regions,countries,cities,bands,reportingUnits,globals,competencies,industries;
d2738 2
a2739 17
    
    int numRows;
    if (resourceIdentifierNames_.size()!=0) {
      // resource id names have been specified, so assume using general format
      getResourceNames(names);
      numRows = names.size();
    }
    else {
      //if (!isLongFormat()) {
      //getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
      // numRows = jobRoles.size();
      //}
      //else {
      getResourceNames(names);
      numRows = names.size();
      //}
    }
d2742 1
a2742 7
      std::string resourceName;
      //if (resourceIdentifierNames_.size()!=0) 
      //  resourceName = workingResourceName(names[r]);
      //else if (!isLongFormat())
      // resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      //else
      resourceName = workingResourceName(names[r]);
d2744 5
a2748 1
      witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
@


1.212
log
@Modified code so new/delete was removed from inner loop.
@
text
@d196 1
d2534 6
a2539 4
      witFree(consPartFromWit);
      if(retVal!=-1) break;
    }
    
d2541 1
@


1.211
log
@Cosmetic changes.
Fixed indenting and tabs.
@
text
@d1460 1
a1460 3
{
  int np=getNPeriods();
  
d1464 10
a1473 15
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float * softLB = new float[np];
      int t;
      for (t=0; t<np; t++)
        softLB[t] = 0.0f;
      witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL);
      delete [] softLB;
    }
  }
@


1.210
log
@Changed the default priority for a resource ID to zero, rather than INT_MAX, and I now compute the maximum of the defined ID priorities and assign the priorities for the undefined values to this maximum + 1 + 1.
@
text
@d38 1
a38 1

d45 1
a45 1

d63 1
a63 1
                                      const std::string & location)
d70 1
a70 1
                                      int startPeriod)
d78 1
a78 1
   
d86 1
a86 1
                                      int duration)
d93 1
a93 1
                                      int lateAllowance)
d129 2
a130 2
	retVal=t;
	break;
d132 1
a132 1
	}
d134 1
a134 1
 }
d155 1
a155 1

d166 1
a166 1
						   engagementName(engName));
d186 1
a186 1

d188 1
a188 1

d194 1
a194 1

d198 1
a198 1

d202 2
a203 2


d207 1
a207 1

d210 1
a210 1

d216 2
a217 2


d220 1
a220 1

d227 2
a228 2


d237 3
a239 3
      const std::string & resourceID = getResourceIdentifierNames()[i];
      const std::string & resourceValue = resourceAttributeVector.at(i);
      resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
d262 1
a262 1

d269 1
a269 1

d283 1
a283 1

d287 1
a287 1

d290 1
a290 1

d327 5
a331 5
     std::string thisone = getResourceIdentifierNames()[which];
     thisone = thisone + ": ";
     std::string nextone = getResourceIdentifierNames()[which+1];
     nextone = " " +nextone + ": ";
     retVal = textBetween(resourcename, thisone, nextone);
d334 3
a336 3
     std::string thisone = getResourceIdentifierNames()[which];
     thisone = thisone + ": ";
     retVal = textAfter(resourcename, thisone);
d344 4
a347 4
    std::string benchRes = benchResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData);
    appData->setSupplyAppData(period, supplyQuantity);
d354 8
a361 8
                                           const std::vector<std::string> &resourceIdentifierValues,
                                           int period,
                                           float mrpGrossQuantity)
{
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setMrpAppData(period, mrpGrossQuantity);
d383 8
a390 8
                                           const std::vector<std::string> &resourceIdentifierValues,
                                           int period,
                                           float glutQuantity)
{
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGlutAppData(period, glutQuantity);
d401 1
a401 1

d410 1
a410 1

d416 5
a420 5
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
d426 1
a426 1

d430 12
a441 12
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
d447 1
a447 1

d454 4
a457 4
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setWorkingAppData(period, workingQuantity);
d464 4
a467 4
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setAcquireAppData(period, acquireQuantity);
d473 4
a476 4
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setReleaseAppData(period, releaseQuantity);
d482 4
a485 4
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setBenchAppData(period, benchQuantity);
d495 3
a497 3
                                           const std::vector<std::string> &resourceAttributeVector,
                                           int period,
                                           float supplyQuantity)
d529 1
a529 1
                                           const std::vector<std::string> &resourceAttributeVector)const
d535 1
a535 1

d539 1
a539 1
							const std::vector<std::string> &resourceAttributeVector)const
d559 1
a559 1
                                           const std::vector<std::string> &resourceIdentifierValues )const 
d567 1
a567 1
                                          const std::vector<std::string> &resourceIdentifierValues )const 
d595 1
a595 1
                                       //the resource is available after it's acquired
d604 3
a606 3
   //remember to negate this
	
	//std::string acquireOp = acquireResourceOperationName(jobRole);  Still need to model this
d706 1
a706 1
                                           const std::vector<std::string> &resourceIdentifierValues)const
d724 1
a724 1

d727 1
a727 1

d742 1
a742 1

d745 1
a745 1

d750 1
a750 1

d753 1
a753 1
  
d758 1
a758 1

d762 1
a762 1

d765 1
a765 1

d799 1
a799 1

d804 1
a804 1

d810 1
a810 1

d817 1
a817 1
                                         const std::vector<std::string> &resourceIdentifierValues)const
d820 1
a820 1

d823 1
a823 1

d825 1
a825 1

d831 1
a831 1

d834 1
a834 1
  
d836 1
a836 1
                            const std::vector<std::string> &resourceIdentifierValues,int period)const
d841 1
a841 1

d852 1
a852 1

d864 1
a864 1

d868 1
a868 1

d885 1
a885 1

d889 1
a889 1

d904 1
a904 1

d922 1
a922 1

d926 1
a926 1

d932 1
a932 1
  
d962 1
a962 1

d968 1
a968 1

d985 1
a985 1

d991 1
a991 1

d1031 1
a1031 1

d1035 1
a1035 1

d1043 3
a1045 3
                                            const RCPcollectionOfStrings & set1,
                                            const RCPcollectionOfStrings & set2,
                                            RCPcollectionOfStrings & retVal)
d1053 3
a1055 3
                                            const RCPcollectionOfStrings & set1,
                                            const RCPcollectionOfStrings & set2,
                                            RCPcollectionOfStrings & retVal)
d1071 1
a1071 1
 
d1081 1
a1081 1
 
d1083 4
a1086 4
          std::cerr <<"WARNING: Substitute requested but no substitutes for given resource value provided. " <<std::endl
          <<"   resource ID name   : " << resourceIdName <<std::endl
          <<"   resource Value: " << fromResourceAttribute <<std::endl ;
        return;
d1088 1
a1088 1

d1091 1
a1091 1
 
d1101 1
a1101 1

d1112 2
a1113 2


d1161 1
a1161 1
 
d1165 2
a1166 2

        
d1192 1
a1192 1

d1197 6
a1202 6
         std::string resourceIdName = getResourceIdentifierNames()[i];
         std::string resourceValue = fromResourceVector.at(i);
         int subAllowed = getBomSub(engagementNames[b], fromResourceVector, period, resourceIdName);
         int matching = getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
         if (matching)
           removeIneligibleResources(subsResources,subAllowed,resourceIdName,resourceValue);
d1204 1
a1204 1

d1207 1
a1207 1
           
d1216 1
a1216 1
            toResourceVector.push_back(resourceIdentifierValueFromResourceName(subsResource, i));
d1230 1
a1230 1

d1240 2
a1241 2


d1244 13
a1256 13
           std::string fromValue = fromResourceVector.at(i);
           std::string toValue = toResourceVector.at(i);
           std::string resourceIdName = getResourceIdentifierNames()[i];
           int matching =  getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
           if (fromValue != toValue && matching==1) {
             //this particular resource attribute was substituted
             subsLeadTime = max( subsLeadTime, resourceIdToSubs_[resourceIdName][fromValue][toValue].getLeadTime());
             subsCost     = subsCost       +   resourceIdToSubs_[resourceIdName][fromValue][toValue].getCost();
             //DLG this is where we need to do something clever
             //to figure out the appropriate aversion from the COMBINATION
             //of aversions for each of the relevant Id fields.
             subsAversion = subsAversion + resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
           }
d1259 1
a1259 1

d1262 1
a1262 1

d1277 1
a1277 1
 
d1285 1
a1285 1
           
d1292 1
a1292 1

d1311 1
a1311 1
   
d1322 3
a1324 3
                      const std::string & engName, 
                      const RCPvectorString &resourceIdentifierValues,
                      RCPcollectionOfStrings & retVal) const
d1334 1
a1334 1

d1338 1
a1338 1

d1341 1
a1341 1

d1395 1
a1395 1
	prodRate[t] = scalingFactor;
d1407 19
a1425 19
	witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate);
	for (t=0;t<np;t++){
	  consRate[t] = consRate[t]*scalingFactor;
	  //std::cout << "Period(consRate): " << t << ":" << consRate[t] << std::endl; 
	}
	witSetBomEntryConsRate(witRun(),theEngagement.c_str(),i,consRate);
	
	// Get the number of subBOM arcs hanging off this BOM arc and scale each of them
	int nSubBomArcs;
	witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
	int j;
	for (j=0;j<nSubBomArcs;j++){
	  witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate);
	  for (t=0;t<np;t++){
	    consRate[t] = consRate[t]*scalingFactor;
	    //std::cout << "Period(subBomArc): " << t << ":" << consRate[t] << std::endl;
	  }
	  witSetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,consRate);
	}
d1437 1
a1437 1

d1451 1
a1451 1
	softLB[t] = 0.0f;
d1462 1
a1462 1

d1476 1
a1476 1
	softLB[t] = 0.0f;
d1488 1
a1488 1

d1511 1
a1511 1
	int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
d1513 1
a1513 1
	for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
d1519 1
a1519 1

d1528 1
a1528 1

d1543 1
a1543 1

d1546 1
a1546 1

d1560 1
a1560 1

d1583 1
a1583 1
	int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
d1585 1
a1585 1
	for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
d1591 1
a1591 1

d1600 1
a1600 1

d1615 1
a1615 1

d1618 1
a1618 1

d1642 1
a1642 1

d1648 1
a1648 1

d1654 1
a1654 1

d1656 1
a1656 1

d1658 1
a1658 1

d1660 1
a1660 1

d1677 1
a1677 1

d1689 1
a1689 1
   
d1719 1
a1719 1

d1722 1
a1722 1

d1734 1
a1734 1

d1740 1
a1740 1
       
d1769 1
a1769 1

d1773 6
a1778 6
    {
      std::cout << "Can't execute priority gap/glut algorithm." << std::endl;
      std::cout << "The mrp based gap/glut will be executed" << std::endl;
      priorityGapGlut();
      return;
    }
d1781 10
a1790 10
      getEngagementRequestedStartPeriod(engagementNames[0]) != 0)
    {
      // There still could be some problems here if there is just one demand
      // and it was not the default demand that was created for 04Feb.  DPC
      std::cout << "Can't execute priority gap/glut algorithm." << std::endl;
      std::cout << "The mrp based gap/glut will be executed" << std::endl;
      priorityGapGlut();
      return;
    }

d1792 1
a1792 1

d1796 1
a1796 1

d1801 1
a1801 1

d1807 3
a1809 3
      


d1811 4
a1814 4
    // temporary code to check the names of the resourceIdentifiers
    //int i;
    //for (i=0; i<nSpecialDemands; i++)
      //      std::cout << "ID: " << i << ":  " << resourceIdentifierNames[i] << std::endl;
d1816 1
a1816 1

d1821 29
a1849 29
      {
	int priority;
	std::string specialDemand = "XXX_SpecialDemand_";
	specialDemand += resourceIdentifierNames[i];
	witAddPart(witRun(),specialDemand.c_str(),WitCAPACITY);
	witAddOperation(witRun(),specialDemand.c_str());
	witAddDemand(witRun(),specialDemand.c_str(),specialDemand.c_str());
	witAddBopEntry(witRun(),specialDemand.c_str(),specialDemand.c_str());

	witSetDemandSelForDel(witRun(),specialDemand.c_str(),specialDemand.c_str(),WitTRUE);
	witSetPartSelForDel(witRun(),specialDemand.c_str(),WitTRUE);
	witSetOperationSelForDel(witRun(),specialDemand.c_str(), WitTRUE);
	demandVol[0] = 1.0f;
	witSetDemandDemandVol(witRun(),specialDemand.c_str(),specialDemand.c_str(),demandVol);
	int * priorityVec;
	witGetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),&priorityVec);
	priority = getResourceIdentifierPriority(resourceIdentifierNames[i]);
	if (priority <= 0)
	  priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
	else
	  if (priority < INT_MAX)
	    priority ++;
	//	if (priority >= 0 && priority < INT_MAX) // The highest priority is one, so shift what the user has specified up by one 
	//	  priority ++;          // to make sure the exact demand is the only one with a WIT priority of one.  
	for(t=0; t<nPeriods; t++)
	  priorityVec[t] = priority;  
	witSetDemandPriority(witRun(),specialDemand.c_str(),specialDemand.c_str(),priorityVec);
	witFree(priorityVec);
      }
d1851 1
a1851 1

d1858 1
a1858 1

d1871 1
a1871 1

d1889 1
a1889 1

d1898 2
a1899 2


d1912 1
a1912 1
   
d1915 1
a1915 1
  
d1918 1
a1918 1

d1922 1
a1922 1

d1924 1
a1924 1

d1932 1
a1932 1

d1937 1
a1937 1
	nBomsAddedToSpecialDemand[k] = 0;
d1939 1
a1939 1

d1946 1
a1946 1

d1948 1
a1948 1

d1961 1
a1961 1

d1972 1
a1972 1

d1977 5
a1981 5
	if (resourceIdValues[index] == "unspecified" || resourceIdValues[index] == "priority"){   // Still need to check on the match flag DPC
	  count ++;
	  tempIndex = index;
	  idName = resourceIdentifierNames[index];
	}
d1984 13
a1996 13
	{
	case 0:
	  priorityDemand = priorityExactDemand;
	  nBomsAddedToPriorityDemand = nBomsAddedToPriorityExact;
	  break;
	case 1:
	  priorityDemand = "XXX_SpecialDemand_"+ resourceIdentifierNames[tempIndex];
	  nBomsAddedToPriorityDemand = nBomsAddedToSpecialDemand[tempIndex];
	  break;
	default:
	  priorityDemand = priorityLastDemand;
	  nBomsAddedToPriorityDemand = nBomsAddedToPriorityLast;
	}
d2009 15
a2023 15
	{
	  char * subConsumedPartName;
	  witGetSubsBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,j,&subConsumedPartName);
	  witAddSubsBomEntry(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,subConsumedPartName);
	  witSetSubsBomEntrySelForDel(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE);
	  witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate);
	  witSetSubsBomEntryConsRate(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,consRate);
	  witGetSubsBomEntryOffset(witRun(),theEngagement.c_str(),i,j,&offset);
	  witSetSubsBomEntryOffset(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,offset);
	  witGetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),i,j,&aversion);
	  witSetSubsBomEntryExpNetAversion(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,aversion);
	  witSetSubsBomEntryMrpNetAllowed(witRun(),priorityDemand.c_str(),nBomsAddedToPriorityDemand,j,WitTRUE);
	  witFree(subConsumedPartName);
	}
	
d2025 10
a2034 10
	{
	case 0: 
	  nBomsAddedToPriorityExact ++;
	  break;
	case 1:
	  nBomsAddedToSpecialDemand[tempIndex] ++;
	  break;
	default:
	  nBomsAddedToPriorityLast ++;
	}
d2044 1
a2044 1

d2058 1
a2058 1

d2063 1
a2063 1

d2075 1
a2075 1

d2080 1
a2080 1

d2085 1
a2085 1

d2100 1
a2100 1

d2115 1
a2115 1
  
d2153 1
a2153 1

d2160 1
a2160 1

d2168 1
a2168 1
      
d2173 1
a2173 1

d2178 1
a2178 1

d2184 8
a2191 8
      {
	witAddBopEntry(witRun(),acquireOp.c_str(),workingRes.c_str());
	float * vecOffset = floatToFloatStar((float) -i+acqOffset);
	witSetBopEntryOffset(witRun(),acquireOp.c_str(),i+1,vecOffset);
	witSetBopEntryLatestPeriod(witRun(),acquireOp.c_str(),i+1,np-i-1+acqOffset);
	witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),i+1,WitTRUE);
	delete [] vecOffset;
      }
d2201 1
a2201 1

d2229 1
a2229 1
	minToGo[i] = residualQty[i];
d2231 1
a2231 1
	minToGo[i] = minToGo[i+1];
d2257 1
a2257 1

d2262 1
a2262 1

d2277 1
a2277 1

d2283 1
a2283 1
      
d2336 1
a2336 1

d2342 1
a2342 1
  else
d2350 2
a2351 2
  postsolve(subBomsAdded);
  witWriteData(witRun(),"wit2.dat");
d2357 1
a2357 1

d2360 1
a2360 1

d2365 4
a2368 4
    {
      //witSetOptWithLotSizes(witRun(),WitTRUE); 
      priorityResourceAction();
    }
d2370 4
a2373 4
    {
      witSetOptWithLotSizes(witRun(),WitTRUE); 
      optimalResourceAction();
    }
d2375 1
a2375 1

d2469 3
a2471 3
       std::string attributeName = getResourceIdentifierNames()[i];
       std::string attributeValue = resourceAttributeVector.at(i);
       retVal = retVal + attributeName + ": " + attributeValue + " ";
d2493 1
a2493 1
       retVal = retVal+getResourceIdentifierNames()[i] + ": " + resourceIdentifierValues.at(i) + " ";
d2507 1
a2507 1
  
d2515 4
a2518 4
                                const std::string & opName, 
                                const std::string & partName,
                                int period
                                ) const
d2552 3
a2554 3
                                const std::string & opName, 
                                const std::string & partName
                                ) const
d2593 1
a2593 1
 witSetExecEmptyBom(witRun(),WitTRUE);
d2643 1
a2643 1

d2657 1
a2657 1

d2697 2
a2698 2


d2714 1
a2714 1

d2736 1
a2736 1

d2743 1
a2743 1

d2752 2
a2753 2
        //getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
       // numRows = jobRoles.size();
d2756 2
a2757 2
        getResourceNames(names);
        numRows = names.size();
d2766 1
a2766 1
       // resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
d2768 1
a2768 1
        resourceName = workingResourceName(names[r]);
d2774 1
a2774 1

d2792 1
a2792 1
          
d2798 1
a2798 1

d2800 2
a2801 2


d2803 3
a2805 3


         
d2810 1
a2810 1

d2812 1
a2812 1

d2815 1
a2815 1

d2819 1
a2819 1

d2823 1
a2823 1

d2826 1
a2826 1

d2829 1
a2829 1

d2833 1
a2833 1

d2839 1
a2839 1

d2841 1
a2841 1

d2843 1
a2843 1
           
d2854 1
a2854 1

d2857 1
a2857 1

d2861 1
a2861 1

d2879 1
a2879 1

d2885 3
a2887 3
	                                                      //acquire time inside setResourceAcquireTime
	                                                      //so that logically it can be positive

d2906 1
a2906 1

d2909 1
a2909 1

d2916 1
a2916 1

d2918 1
a2918 1

d2923 1
a2923 1

d2931 1
a2931 1

d2939 1
a2939 1

d2946 1
a2946 1

d2952 2
a2953 2

             
d2958 1
a2958 1

d2964 1
a2964 1

d2980 1
a2980 1

d2982 1
a2982 1

d2988 1
a2988 1

d3000 1
a3000 1

d3016 2
a3017 2


d3028 1
a3028 1

d3031 1
a3031 1

d3039 1
a3039 1

d3047 1
a3047 1

d3049 1
a3049 1

d3065 1
a3065 1
      
d3078 1
a3078 1

d3084 1
a3084 1

d3097 1
a3097 1

d3104 1
a3104 1
   // Test skillSubs
d3112 1
a3112 1

d3122 1
a3122 1

d3125 1
a3125 1

d3135 1
a3135 1

d3138 1
a3138 1

d3140 1
a3140 1

d3149 1
a3149 1

d3153 1
a3153 1

d3157 1
a3157 1

d3160 1
a3160 1

d3165 1
a3165 1

d3330 1
a3330 1

d3444 1
a3444 1

d3449 1
a3449 1
     
d3455 1
a3455 1
     
d3465 1
a3465 1
     
d3472 1
a3472 1
     
d3482 1
a3482 1
             
d3590 1
a3590 1

d3639 1
a3639 1

d3650 1
a3650 1

d3653 1
a3653 1

d3659 1
a3659 1

d3666 1
a3666 1

d3696 1
a3696 1

d3742 1
a3742 1

d3756 1
a3756 1

d3773 1
a3773 1

d3776 1
a3776 1

d3798 1
a3798 1

d3805 1
a3805 1

d3818 1
a3818 1

d3821 1
a3821 1

d3834 1
a3834 1

d3862 1
a3862 1

d3873 1
a3873 1
    {
d3883 1
a3883 1

d3901 1
a3901 1

d3913 3
a3915 3

   

d3924 1
a3924 1

d3939 1
a3939 1

d3946 1
a3946 1
        
d3960 1
a3960 1

d3967 1
a3967 1

d3981 2
a3982 2
    }
 {
d3991 1
a3991 1

d4006 1
a4006 1

d4027 1
a4027 1

d4034 1
a4034 1

d4041 1
a4041 1

d4055 2
a4056 2
    }
 {
d4064 1
a4064 1

d4079 1
a4079 1

d4107 1
a4107 1

d4114 1
a4114 1

d4123 2
a4124 2
    }
 {
d4133 1
a4133 1

d4152 1
a4152 1

d4179 1
a4179 1

d4188 1
a4188 1

d4197 1
a4197 1

d4215 2
a4216 2
    }
    {
d4223 2
a4224 2
    }  

@


1.209
log
@Removed some cout's
@
text
@d289 1
a289 1
  mapResourceIdentifierNameToSubsPriority_[resourceIdentifierName]=INT_MAX;
d1799 1
d1802 8
d1838 7
a1844 2
	if (priority >= 0 && priority < INT_MAX) // The highest priority is one, so shift what the user has specified up by one 
	  priority ++;          // to make sure the exact demand is the only one with a WIT priority of one.  
d2858 1
a2858 1
    assert( prob.getResourceIdentifierPriority("jobRole") == INT_MAX );
d4098 1
a4098 1
    //assert(gapQty[0]==1); this should work
d4112 2
a4113 2
    //assert(gapQty[0]==1); //this should work
    assert(glutQty[0]==0);
@


1.208
log
@more test cases
@
text
@d2778 1
a2778 3
    
    std::cout <<"Test A: " <<std::endl;
      
a2796 1
    std::cout <<"Test B:engagements " <<std::endl;
a2832 1
    std::cout <<"Test C:resources " <<std::endl;
a2942 1
    std::cout <<"Test D:bom " <<std::endl;
a3131 1
      std::cout <<"Test E:assignment " <<std::endl;
@


1.207
log
@removed some warnings
@
text
@d4048 160
@


1.206
log
@Commented out some std::cout's and commented out the witSetMesg that was turning on the printing of the
purge results (in problemBase.cpp).
@
text
@d1266 2
a1267 2
        std::cout <<"  resource: " <<workingRes <<std::endl;
        std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
@


1.205
log
@added example_finalformat to rcpProblem::test
@
text
@d1801 1
a1801 1
  {
d1803 4
a1806 4
    int i;
    for (i=0; i<nSpecialDemands; i++)
      std::cout << "ID: " << i << ":  " << resourceIdentifierNames[i] << std::endl;
  }
d1937 2
a1938 2
      std::cout << "WorkingPartName: " << workingPartName << std::endl;
      std::cout << "BaseName: " << baseName << std::endl;
d1940 6
a1945 6
      {
	unsigned int kk;
	for (kk = 0; kk<resourceIdValues.size(); kk++)
	    std::cout << resourceIdValues[kk] << " " ;
	std::cout << std::endl;
      }
@


1.204
log
@cleaner handling of match=0; just set that field to "unmatched"
@
text
@d4048 8
@


1.203
log
@trivial changes
@
text
@d3857 1
a3857 1
    assert(gapQty[0]==1);
a3860 4
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[2]);
    glutQty = prob.getResourceGlutQuantity(names[2]);
d3862 2
a3863 5
    assert(glutQty[0]==1);
    gapQty = prob.getResourceGapQuantity(names[3]);
    glutQty = prob.getResourceGlutQuantity(names[3]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
a3883 8
    gapQty = prob.getResourceGapQuantity(names[2]);
    glutQty = prob.getResourceGlutQuantity(names[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[3]);
    glutQty = prob.getResourceGlutQuantity(names[3]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
d3986 1
a3986 1
    names.push_back("j1");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d3993 1
a3993 1
    names.push_back("j1");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
d4000 1
a4000 1
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
d4007 1
a4007 1
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("global");
d4014 1
a4014 1
    names.push_back("j2");names.push_back("s2");names.push_back("Cont");names.push_back("global");
d4021 1
a4021 1
    names.push_back("j2");names.push_back("s2");names.push_back("IBM");names.push_back("global");
d4028 1
a4028 1
    names.push_back("j2");names.push_back("s2");names.push_back("Supp");names.push_back("global");
d4035 1
a4035 1
    names.push_back("j2");names.push_back("unspecified");names.push_back("IBM");names.push_back("non-global");
d4042 1
a4042 1
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("global");
@


1.202
log
@priorityGapGlut1() is now being called.
uncommented some asserts now that this algorithm is working.
Still need to work on checking the match flag.
@
text
@d1941 1
a1941 1
	int kk;
@


1.201
log
@fixed asserts in unitTest for tucson examples
@
text
@d1813 1
d1828 3
d1832 1
a1832 1
	  priorityVec[t] = 1;  //This will need to be set to the real priority of the resource identifier
d1838 10
a1847 10
  std::string priority1Demand = "Priority1Demand"; 
  if (!engagementExists(priority1Demand)) {
    witAddPart(witRun(),priority1Demand.c_str(),WitCAPACITY);
    witAddOperation(witRun(),priority1Demand.c_str());
    witAddDemand(witRun(),priority1Demand.c_str(),priority1Demand.c_str());
    witAddBopEntry(witRun(),priority1Demand.c_str(),priority1Demand.c_str());

    witSetDemandSelForDel(witRun(),priority1Demand.c_str(),priority1Demand.c_str(),WitTRUE);
    witSetPartSelForDel(witRun(),priority1Demand.c_str(),WitTRUE);
    witSetOperationSelForDel(witRun(),priority1Demand.c_str(), WitTRUE);
d1849 1
a1849 1
    witSetDemandDemandVol(witRun(),priority1Demand.c_str(),priority1Demand.c_str(),demandVol);
d1851 1
a1851 1
    witGetDemandPriority(witRun(),priority1Demand.c_str(),priority1Demand.c_str(),&priorityVec);
d1854 1
a1854 1
    witSetDemandPriority(witRun(),priority1Demand.c_str(),priority1Demand.c_str(),priorityVec);
d1858 10
a1867 10
  std::string priority2Demand = "Priority2Demand"; 
  if (!engagementExists(priority2Demand)) {
    witAddPart(witRun(),priority2Demand.c_str(),WitCAPACITY);
    witAddOperation(witRun(),priority2Demand.c_str());
    witAddDemand(witRun(),priority2Demand.c_str(),priority2Demand.c_str());
    witAddBopEntry(witRun(),priority2Demand.c_str(),priority2Demand.c_str());
    witSetDemandSelForDel(witRun(),priority2Demand.c_str(),priority2Demand.c_str(),WitTRUE);
    witSetPartSelForDel(witRun(),priority2Demand.c_str(),WitTRUE);
    witSetOperationSelForDel(witRun(),priority2Demand.c_str(), WitTRUE);
    witSetDemandDemandVol(witRun(),priority2Demand.c_str(),priority2Demand.c_str(),demandVol);
d1869 1
a1869 1
    witGetDemandPriority(witRun(),priority2Demand.c_str(),priority2Demand.c_str(),&priorityVec);
d1871 2
a1872 2
      priorityVec[t] = 2;
    witSetDemandPriority(witRun(),priority2Demand.c_str(),priority2Demand.c_str(),priorityVec);
d1911 1
a1911 1
  // (4) copy over the BOM and subBOM arcs
d1917 1
a1917 1
    int nBomsAddedToPriority1 = 0, nBomsAddedToPriority2 = 0, nBomsAddedToPriorityDemand;
d1932 1
d1934 15
d1950 17
a1966 4
      if (nSubBomArcs == 0) // this is a completely specified resource --- connect it to Priority1Demand
	{
	  priorityDemand = priority1Demand;
	  nBomsAddedToPriorityDemand = nBomsAddedToPriority1;
d1968 2
a1969 1
      else  // connect it to Priority2Demand
d1971 11
a1981 2
	  priorityDemand = priority2Demand;
	  nBomsAddedToPriorityDemand = nBomsAddedToPriority2;
d1986 1
a1986 1
      // copy over the attributes of this BOM arc from the base model to the Priority2Demand
d2009 12
a2020 5

      if (nSubBomArcs == 0) // this is a completely specified resource --- connect it to Priority1Demand
	nBomsAddedToPriority1 ++;
      else
	nBomsAddedToPriority2 ++;
d2324 4
a2327 4
    //    if (getFormatName() == "04Feb")
    //priorityGapGlut1(); //$$$$$ Here is where you can change this to call priorityGapGlut1()
    //else
    priorityGapGlut();
d3368 1
a3368 1
        //assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
d3404 1
a3404 1
        //assert(gapQty[0]==1.0 ); //uncomment this line when priority subtitution is implemented
d3650 1
a3650 1
    //assert(acquireQty[1]==2);
d3979 1
a3979 1
    //assert(gapQty[0]==1); //this should be uncommented when column priority is working
d3987 1
a3987 1
    //assert(glutQty[0]==1); //this should be uncommented when column priority is working
d4004 1
a4004 1
    //assert(gapQty[0]==0);
d4026 1
a4026 1
    //assert(glutQty[0]==0); //uncomment when priority columns are implemented
d4033 1
a4033 1
    //assert(glutQty[0]==0); //uncomment when priority columns are implemented
d4053 1
a4053 1
    //assert(gapQty[0]==1); //this should be uncommented when column priority is working
@


1.200
log
@comment some asserts
@
text
@d3903 1
a3903 8
    
    names.clear();
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    //assert(glutQty[0]==1); //uncomment when priority columns are implemented
    
d3954 1
a3954 1
    assert(gapQty[0]==0);
d3976 1
a3976 1
    //assert(glutQty[0]==1); //uncomment when priority columns are implemented
d4011 1
a4011 1
    //assert(glutQty[0]==1); //this should be uncommented when column priority is working
@


1.199
log
@fixed something that the linux compiler was unhappy about
@
text
@d3983 1
a3983 1
    assert(glutQty[0]==1); //uncomment when priority columns are implemented
d3990 1
a3990 1
    assert(glutQty[0]==0); //uncomment when priority columns are implemented
d4010 1
a4010 1
    assert(gapQty[0]==1); //this should be uncommented when column priority is working
d4018 1
a4018 1
    assert(glutQty[0]==1); //this should be uncommented when column priority is working
@


1.198
log
@New file:  resourceIdPriorityFile.h  defines a new input file format for resource identifier priorities
and added code to read in this file in populate

Changed the spelling of ...Identifer... to ...Identifier...

Modified priorityGapGlut1(), but this is not invoked yet.
@
text
@d3916 2
a3917 2
    //assert(glutQty[0]==0); //uncomment when priority columns are implemented

d3983 1
a3983 1
    //assert(glutQty[0]==1); //uncomment when priority columns are implemented
d3990 1
a3990 1
    //assert(glutQty[0]==0); //uncomment when priority columns are implemented
d4010 1
a4010 1
    //assert(gapQty[0]==1); //this should be uncommented when column priority is working
d4018 1
a4018 1
    //assert(glutQty[0]==1); //this should be uncommented when column priority is working
@


1.197
log
@preparation for handling calendar style period information.
@
text
@d257 1
a257 1
//   where i=[0,numberOfResourceIdentifers]
d289 1
a289 1
  mapResourceIdentiferNameToSubsPriority_[resourceIdentifierName]=INT_MAX;
d293 1
a293 1
bool RCPproblem::resourceIdentiferNameExists( const std::string & name ) const
d295 1
a295 1
  return mapResourceIdentiferNameToSubsPriority_.find(name)!=mapResourceIdentiferNameToSubsPriority_.end();
d299 1
a299 1
void RCPproblem::setResourceIdentifierSubstitutePriority(const std::string & identifierName, int priority )
d301 2
a302 2
  assert( resourceIdentiferNameExists(identifierName) );
  mapResourceIdentiferNameToSubsPriority_[identifierName]=priority;
d304 1
a304 1
int RCPproblem::getResourceIdentifierSubstitutePriority(const std::string & identifierName ) const
d306 2
a307 2
  assert( resourceIdentiferNameExists(identifierName) );
  int retVal = mapResourceIdentiferNameToSubsPriority_.find(identifierName)->second;
d863 1
a863 1
  assert( resourceIdentiferNameExists(resourceIdName) );
d884 1
a884 1
  assert( resourceIdentiferNameExists(resourceIdName) );
d903 1
a903 1
  assert( resourceIdentiferNameExists(resourceIdName) );
d921 1
a921 1
  assert( resourceIdentiferNameExists(resourceIdName) );
d1751 1
a1751 1
  // time is period zeo and get it's name.
d1798 36
d1839 2
d1859 1
d1867 1
a1867 1
      priorityVec[t] = 1;
d1892 1
d1913 9
a1921 1
    int nBomsAddedToPriority1 = 0, nBomsAddedToPriority2 = 0;
d1923 1
a1923 1
        // Get the number of subBOM arcs hanging off this BOM arc 
d1927 1
d1932 7
a1938 7
	  witAddBomEntry(witRun(),priority1Demand.c_str(),consumedPartName);
	  witSetBomEntrySelForDel(witRun(),priority1Demand.c_str(),nBomsAddedToPriority1,WitTRUE);
	  witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate);
	  witGetBomEntryOffset(witRun(),theEngagement.c_str(),i,&offset);
	  witSetBomEntryConsRate(witRun(),priority1Demand.c_str(),nBomsAddedToPriority1,consRate);
	  witSetBomEntryOffset(witRun(),priority1Demand.c_str(),nBomsAddedToPriority1,offset);
	  nBomsAddedToPriority1 ++;
d1940 12
a1951 1
      else
a1952 10
	  witAddBomEntry(witRun(),priority2Demand.c_str(),consumedPartName);	    
	  witSetBomEntrySelForDel(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,WitTRUE);
	  // copy over the attributes of this BOM arc from the base model to the Priority2Demand
	  // and then bring over all of the subBOMs and their attributes
	  witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate);
	  witGetBomEntryOffset(witRun(),theEngagement.c_str(),i,&offset);
	  witSetBomEntryConsRate(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,consRate);
	  witSetBomEntryOffset(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,offset);
	  // Now copy over the subBOM arcs
	  int j;
d1954 10
a1963 14
	  for (j=0; j<nSubBomArcs; j++)
	    {
	      witGetSubsBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,j,&subConsumedPartName);
	      witAddSubsBomEntry(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,subConsumedPartName);
	      witSetSubsBomEntrySelForDel(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,j,WitTRUE);
	      witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate);
	      witSetSubsBomEntryConsRate(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,j,consRate);
	      witGetSubsBomEntryOffset(witRun(),theEngagement.c_str(),i,j,&offset);
	      witSetSubsBomEntryOffset(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,j,offset);
	      witGetSubsBomEntryExpNetAversion(witRun(),theEngagement.c_str(),i,j,&aversion);
	      witSetSubsBomEntryExpNetAversion(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,j,aversion);
	      witSetSubsBomEntryMrpNetAllowed(witRun(),priority2Demand.c_str(),nBomsAddedToPriority2,j,WitTRUE);
	    }
	  nBomsAddedToPriority2 ++;
d1966 8
a1973 3
    witFree(consumedPartName);
    witFree(consRate);
    witFree(offset);
d1976 1
a1976 1

d1978 1
d2286 1
a2287 1
  postsolve(subBomsAdded);
d2519 1
a2519 1
mapResourceIdentiferNameToSubsPriority_(),
d2542 1
a2542 1
mapResourceIdentiferNameToSubsPriority_(),
d2570 1
a2570 1
  mapResourceIdentiferNameToSubsPriority_ = source.mapResourceIdentiferNameToSubsPriority_;
d2795 2
a2796 2
    assert( prob.resourceIdentiferNameExists("jobRole") );
    assert( !prob.resourceIdentiferNameExists("jobRoleXX") );
d2798 3
a2800 3
    assert( prob.getResourceIdentifierSubstitutePriority("jobRole") == INT_MAX );
    prob.setResourceIdentifierSubstitutePriority("jobRole",123);
    assert( prob.getResourceIdentifierSubstitutePriority("jobRole") == 123 );
@


1.196
log
@more tests
@
text
@d3056 1
a3056 1
  
d3063 1
a3063 1
    populate(prob_subs, inputDirectory, outputDirectory);
d3228 1
a3228 1
    populate(prob_subs, inputDirectory, outputDirectory);
d3330 1
a3330 1
    populate(prob_subs, inputDirectory, outputDirectory);
d3464 1
a3464 1
    populate(prob_subs, inputDirectory, outputDirectory);
d3479 1
a3479 1
    populate(prob_baseline, inputDirectory, outputDirectory);
d3536 1
a3536 1
    populate(prob_acquire, inputDirectory, outputDirectory);
d3570 1
a3570 1
    populate(prob_delay, inputDirectory, outputDirectory);
d3604 1
a3604 1
    populate(prob_decline, inputDirectory, outputDirectory);
d3631 1
a3631 1
    populate(prob_IGS, inputDirectory, outputDirectory);
d3662 1
a3662 1
    populate(prob_IGS, inputDirectory, outputDirectory);
d3719 1
a3719 1
    populate(prob, inputDirectory, outputDirectory);
d3747 1
a3747 1
    populate(prob, inputDirectory, outputDirectory);
d3775 1
a3775 1
    populate(prob, inputDirectory, outputDirectory);
d3803 1
a3803 2
    
    populate(prob_04Feb, inputDirectory, outputDirectory);
d3826 1
a3826 2
    
    populate(prob, inputDirectory, outputDirectory);
d3900 1
a3900 2
    
    populate(prob, inputDirectory, outputDirectory);
@


1.195
log
@added methods
void setResourceIdentifierSubstitutePriority(const std::string & identifierName, int priority );
int getResourceIdentifierSubstitutePriority(const std::string & identifierName )const;
@
text
@a22 4
//#include "engagementFile.h"
//#include "resourceFile.h"
//#include "bomFile.h"
//#include "resourceActionFile.h"
d3838 75
@


1.194
log
@added method
bool resourceIdentiferNameExists( const std::string & name ) const
@
text
@d293 1
a293 1
  mapResourceIdentiferNameToIndex_[resourceIdentifierName]=nResIdentNames;
d299 14
a312 1
  return mapResourceIdentiferNameToIndex_.find(name)!=mapResourceIdentiferNameToIndex_.end();
d867 1
a867 1
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );
d888 1
a888 1
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );
d907 1
a907 1
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );
d925 1
a925 1
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );
d2471 1
a2471 1
mapResourceIdentiferNameToIndex_(),
d2494 1
a2494 1
mapResourceIdentiferNameToIndex_(),
d2522 1
a2522 1
  mapResourceIdentiferNameToIndex_ = source.mapResourceIdentiferNameToIndex_;
d2749 4
@


1.193
log
@removed some unused files
@
text
@d297 5
d2733 3
@


1.192
log
@updated unit test to check column priority
@
text
@d23 4
a26 4
#include "engagementFile.h"
#include "resourceFile.h"
#include "bomFile.h"
#include "resourceActionFile.h"
@


1.191
log
@appl.mk :  added rcpOptCal and rcpOptException to the list of files that get compiles
rcpOptCal.cpp and .h : new files that implement rcpOptCalendar
populateRCP.cpp : added tests to see if period is negative
rcpProblem.cpp : In priorityGapGlut1(), I now check to see that there is just one engagement and it
has a startPeriod of 0
unitTest.cpp : Call added to test rcpOptCalendar
@
text
@d3834 7
d3845 1
a3845 1
    assert(glutQty[0]==0);
d3865 1
a3865 1
    assert(gapQty[0]==1);
d3867 7
@


1.190
log
@changed "prioritySubstitute" to "priority"
@
text
@d28 1
a28 1

d1736 2
d1756 24
a1779 1
  // (1) The base engagement name is hardcoded to "engagement: engagement".  This should be changed to be more flexible.
d1781 1
a1781 1
  witSetDemandDemandVol(witRun(),"engagement: engagement","engagement: engagement",demandVol);
a1854 1
    std::string theEngagement = "engagement: engagement";
d1929 1
a1929 1
  // (7) The base engagement name is hardcoded to "engagement: engagement".  This should be changed to be more flexible.
d1931 1
a1931 1
  witSetDemandDemandVol(witRun(),"engagement: engagement","engagement: engagement",demandVol);
d2208 1
a2208 1
    //  if (getFormatName() == "04Feb")
@


1.189
log
@just a few unsigned int things to make the compiler quiet
@
text
@d3038 1
a3038 1
      rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("prioritySubstitute");rdummy.push_back("global");
d3208 3
a3210 3
      r12.push_back("j1");r12.push_back("s1");r12.push_back("prioritySubstitute");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
      r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("unspecified");r13.push_back("prioritySubstitute");
      r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("prioritySubstitute");r14.push_back("newyork");r14.push_back("US");
@


1.188
log
@Change some of resolve code in test methods.
Added more resolve tests.
@
text
@d1636 1
a1636 1
      int s;
d1676 1
a1676 1
    unsigned int t;
d1715 1
a1715 1
    for (unsigned int t=0; t<np; t++ ) {
d1727 1
a1727 1
    unsigned int t;
d1816 1
a1816 1
    for (t=0; t<exogSup.size(); t++)
d2020 1
a2020 1
    unsigned int t;
@


1.187
log
@Made changes to gapGlut and resourceAction to make the RCP code more re-entrant.
@
text
@a3022 2

    prob_subs.gapGlut();
d3024 4
a3027 20
    // Create base name for each resource
    RCPvectorString r1,r2,r3,r4,r5,r6,rdummy;
    
    r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");
    r2.push_back("j1");r2.push_back("s2");r2.push_back("Cont");r2.push_back("non-global");
    r3.push_back("j2");r3.push_back("s1");r3.push_back("IBM");r3.push_back("non-global");
    r4.push_back("j2");r4.push_back("s2");r4.push_back("Cont");r4.push_back("global");
    r5.push_back("j2");r5.push_back("s2");r5.push_back("IBM");r5.push_back("global");
    r6.push_back("j2");r6.push_back("s2");r6.push_back("Supp");r6.push_back("global");
    rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("prioritySubstitute");rdummy.push_back("global");
    
    //check that appropriate substitute arcs are there
    {
      std::string r1str   = prob_subs.baseResourceName(r1);
      std::string r2str   = prob_subs.baseResourceName(r2);
      std::string r3str   = prob_subs.baseResourceName(r3);
      std::string r4str   = prob_subs.baseResourceName(r4);
      std::string r5str   = prob_subs.baseResourceName(r5);
      std::string r6str   = prob_subs.baseResourceName(r6);
      std::string rdstr   = prob_subs.baseResourceName(rdummy);
d3029 2
d3032 142
a3173 156
      // Get resources that are substituting for r1
      RCPcollectionOfStrings subsRes;
      
      prob_subs.getSubsResources(
        "engagement",r1,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",r2,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",r3,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",r4,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",r5,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",r6,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   == subsRes.end() );  
      assert( subsRes.find( r5str )   == subsRes.end() );  
      assert( subsRes.find( r6str )   == subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 0 );
      
      prob_subs.getSubsResources(
        "engagement",rdummy,subsRes);
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1str )   == subsRes.end() );  
      assert( subsRes.find( r2str )   == subsRes.end() );  
      assert( subsRes.find( r3str )   == subsRes.end() );  
      assert( subsRes.find( r4str )   != subsRes.end() );  
      assert( subsRes.find( r5str )   != subsRes.end() );  
      assert( subsRes.find( r6str )   != subsRes.end() ); 
      assert( subsRes.find( rdstr )   == subsRes.end() );  
      assert( subsRes.size() == 3 );
      
    }
    
    //check that the gaps and gluts are correct
    //because of the priority aversion, the IBM and Cont substitutes for
    //prioritySubstitutes should get used first. The Supp substititute won't be
    //needed, so there will be a glut of that
    {
      std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
      std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r2);
      glutQty = prob_subs.getResourceGlutQuantity(r2);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r3);
      glutQty = prob_subs.getResourceGlutQuantity(r3);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(r4);
      glutQty = prob_subs.getResourceGlutQuantity(r4);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r5);
      glutQty = prob_subs.getResourceGlutQuantity(r5);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r6);
      glutQty = prob_subs.getResourceGlutQuantity(r6);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(rdummy);
      glutQty = prob_subs.getResourceGlutQuantity(rdummy);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
    }

    // Resolve and test that solution is still the same as before
    {    
      prob_subs.gapGlut();
      std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
      std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r2);
      glutQty = prob_subs.getResourceGlutQuantity(r2);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r3);
      glutQty = prob_subs.getResourceGlutQuantity(r3);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(r4);
      glutQty = prob_subs.getResourceGlutQuantity(r4);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r5);
      glutQty = prob_subs.getResourceGlutQuantity(r5);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r6);
      glutQty = prob_subs.getResourceGlutQuantity(r6);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(rdummy);
      glutQty = prob_subs.getResourceGlutQuantity(rdummy);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
    }
d3188 4
a3191 88
    
    prob_subs.gapGlut();
    
    // Create base name for each resource
    RCPvectorString r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15;
    
    r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");r1.push_back("chicago");r1.push_back("US");
    r2.push_back("j2");r2.push_back("s2");r2.push_back("IBM");r2.push_back("global");r2.push_back("chicago");r2.push_back("US");
    r3.push_back("j2");r3.push_back("s2");r3.push_back("IBM");r3.push_back("global");r3.push_back("akron");r3.push_back("US");
    r4.push_back("j1");r4.push_back("s1");r4.push_back("Cont");r4.push_back("non-global");r4.push_back("akron");r4.push_back("US");
    r5.push_back("j1");r5.push_back("s1");r5.push_back("Supp");r5.push_back("non-global");r5.push_back("akron");r5.push_back("US");
    r6.push_back("j1");r6.push_back("s1");r6.push_back("WOS");r6.push_back("non-global");r6.push_back("akron");r6.push_back("US");
    r7.push_back("j3");r7.push_back("s3");r7.push_back("IBM");r7.push_back("non-global");r7.push_back("london");r7.push_back("GB");
    r8.push_back("j3");r8.push_back("s3");r8.push_back("IBM");r8.push_back("non-global");r8.push_back("akron");r8.push_back("US");
    r9.push_back("j3");r9.push_back("s3");r9.push_back("Cont");r9.push_back("global");r9.push_back("newyork");r9.push_back("US");
    r10.push_back("j3");r10.push_back("s3");r10.push_back("Cont");r10.push_back("non-global");r10.push_back("newyork");r10.push_back("US");
    r11.push_back("j2");r11.push_back("s2");r11.push_back("IBM");r11.push_back("global");r11.push_back("unspecified");r11.push_back("US");
    r12.push_back("j1");r12.push_back("s1");r12.push_back("prioritySubstitute");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
    r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("unspecified");r13.push_back("prioritySubstitute");
    r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("prioritySubstitute");r14.push_back("newyork");r14.push_back("US");
    r15.push_back("j3");r15.push_back("unspecified");r15.push_back("Cont");r15.push_back("non-global");r15.push_back("newyork");r15.push_back("US");   
    
    //check that the gaps and gluts are correct
    {       
      std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
      std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r2);
      glutQty = prob_subs.getResourceGlutQuantity(r2);
      //assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r3);
      glutQty = prob_subs.getResourceGlutQuantity(r3);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r4);
      glutQty = prob_subs.getResourceGlutQuantity(r4);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r5);
      glutQty = prob_subs.getResourceGlutQuantity(r5);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r6);
      glutQty = prob_subs.getResourceGlutQuantity(r6);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(r7);
      glutQty = prob_subs.getResourceGlutQuantity(r7);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r8);
      glutQty = prob_subs.getResourceGlutQuantity(r8);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r9);
      glutQty = prob_subs.getResourceGlutQuantity(r9);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r10);
      glutQty = prob_subs.getResourceGlutQuantity(r10);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r11);
      glutQty = prob_subs.getResourceGlutQuantity(r11);
      //assert(gapQty[0]==1.0 ); //uncomment this line when priority subtitution is implemented
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r12);
      glutQty = prob_subs.getResourceGlutQuantity(r12);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r13);
      glutQty = prob_subs.getResourceGlutQuantity(r13);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r14);
      glutQty = prob_subs.getResourceGlutQuantity(r14);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r15);
      glutQty = prob_subs.getResourceGlutQuantity(r15);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
    }
        
    // resolve and check that the gaps and gluts the same
    {       
d3193 84
a3276 61
      std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
      std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r2);
      glutQty = prob_subs.getResourceGlutQuantity(r2);
      //assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r3);
      glutQty = prob_subs.getResourceGlutQuantity(r3);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r4);
      glutQty = prob_subs.getResourceGlutQuantity(r4);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r5);
      glutQty = prob_subs.getResourceGlutQuantity(r5);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r6);
      glutQty = prob_subs.getResourceGlutQuantity(r6);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==1.0 );
      gapQty = prob_subs.getResourceGapQuantity(r7);
      glutQty = prob_subs.getResourceGlutQuantity(r7);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r8);
      glutQty = prob_subs.getResourceGlutQuantity(r8);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r9);
      glutQty = prob_subs.getResourceGlutQuantity(r9);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r10);
      glutQty = prob_subs.getResourceGlutQuantity(r10);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r11);
      glutQty = prob_subs.getResourceGlutQuantity(r11);
      //assert(gapQty[0]==1.0 ); //uncomment this line when priority subtitution is implemented
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r12);
      glutQty = prob_subs.getResourceGlutQuantity(r12);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r13);
      glutQty = prob_subs.getResourceGlutQuantity(r13);
      assert(gapQty[0]==1.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r14);
      glutQty = prob_subs.getResourceGlutQuantity(r14);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
      gapQty = prob_subs.getResourceGapQuantity(r15);
      glutQty = prob_subs.getResourceGlutQuantity(r15);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==0.0 );
    }
a3295 1
#if 0
a3299 1
#endif
a3327 1
      obj = prob_subs.getObjValue();
a3334 2
      obj = prob_subs.getObjValue();

a3405 1
      obj = prob_subs.getObjValue();
d3408 1
a3408 2
#if 0
    // Does not work because resolving is does not yet work
a3411 1
#endif
d3414 1
a3414 1
    {
d3424 1
a3424 1

d3426 3
a3428 2
    

a3434 44
    prob_baseline.gapGlut(); 
    
    RCPvectorString DetailA;
    DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l1");
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity(DetailA);
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 );

    RCPvectorString DetailB;
    DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l1");
    gapQty = prob_baseline.getResourceGapQuantity(DetailB);
    glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 );

    RCPvectorString DetailC;
    DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l1");
    gapQty = prob_baseline.getResourceGapQuantity(DetailC);
    glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==10.0 ); //or -10?
    
    DetailA.clear();
    DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l2");
    gapQty = prob_baseline.getResourceGapQuantity(DetailA);
    glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==30.0 ); //or -30?

    DetailB.clear();
    DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l2");
    gapQty = prob_baseline.getResourceGapQuantity(DetailB);
    glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
    assert(gapQty[0]==0.0 );
    assert(glutQty[0]==10.0 ); //or -10?

    DetailC.clear();
    DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l2");
    gapQty = prob_baseline.getResourceGapQuantity(DetailC);
    glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
    assert(gapQty[0]==10.0 );
    assert(glutQty[0]==0.0 ); 

d3436 47
a3837 1
  }
@


1.186
log
@All references to gapGlut04Feb and resourceAction04Feb have been renamed to gapGlut and resourceAction.
@
text
@d210 1
a210 1
  witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),0,WitTRUE);
d217 1
a217 1
  witSetBopEntrySelForDel(witRun(),enableOp.c_str(),0,WitTRUE);
d1420 1
a1420 1
void RCPproblem::presolveForGapGlut()
d1445 24
d1656 1
a1659 2
  std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
    reportingUnits,bands,globals,competencies,industries;
d1662 5
a1666 9
  int numRows;
  //if (!isLongFormat()) {
   // getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
   // numRows = jobRoles.size();
  //}
 // else {
    getResourceNames(names);
    numRows = names.size();
 // }
d1668 1
a1668 1
  // loop once for each resource
d1677 1
a1677 1
    for (t=0; t<exogSup.size(); t++)
d1681 1
a1681 1
  // Now loop through all the subs and set mrpNetAllowed to true
d1705 2
a1706 1
  // perform the wit MRP
d1708 2
a1709 1
  // pick off the results
d1715 1
a1715 1
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
d1720 12
d1738 1
a1738 1
  // that can be met with substitution
d1740 2
a1741 3
  // volume for that part
  // (4) Purge the model.  Loop through all the BOMs in the base model, connect the acquire operation, 
  // (5) add "copies" of the 'must be met exactly' BOMs to the 'must
d1743 7
a1749 3
  //  mrpNetAllowed to true on all the subBOM arcs
  // (6) perform witHeurImplode
  // (7) gap is acquire execVol of the resource and glut is scrapVol of the working part
d1752 1
a1756 1
  delete [] demandVol;
d1759 10
a1768 7
  std::string priority1EngagementName = "Priority1Demand"; 
  if (!engagementExists(priority1EngagementName)) {
    addEngagement(priority1EngagementName);
    setEngagementStartPeriod(priority1EngagementName,0);
    setEngagementDuration(priority1EngagementName,nPeriods);
    setEngagementLateAllowance(priority1EngagementName,0);
    setEngagementLocation(priority1EngagementName,"dummy");
d1770 4
a1773 5
    witGetDemandPriority(witRun(),"engagement: Priority1Demand","engagement: Priority1Demand",&priorityVec);
    int i;
    for(i=0; i<nPeriods; i++)
      priorityVec[i] = 1;
    witSetDemandPriority(witRun(),"engagement: Priority1Demand","engagement: Priority1Demand",priorityVec);
d1777 9
a1785 7
  std::string priority2EngagementName = "Priority2Demand"; 
  if (!engagementExists(priority2EngagementName)) {
    addEngagement(priority2EngagementName);
    setEngagementStartPeriod(priority2EngagementName,0);
    setEngagementDuration(priority2EngagementName,nPeriods);
    setEngagementLateAllowance(priority2EngagementName,0);
    setEngagementLocation(priority2EngagementName,"dummy");
d1787 4
a1790 5
    witGetDemandPriority(witRun(),"engagement: Priority2Demand","engagement: Priority2Demand",&priorityVec);
    int i;
    for(i=0; i<nPeriods; i++)
      priorityVec[i] = 2;
    witSetDemandPriority(witRun(),"engagement: Priority2Demand","engagement: Priority2Demand",priorityVec);
d1792 2
a1793 1
  }
a1802 2
  // purge the model
  witPurgeData(witRun());
d1805 1
a1805 1
  // external supply for the working part
a1815 1
    unsigned int t;
d1818 8
d1828 1
a1828 1
  // copy over the BOM and subBOM arcs
d1845 2
a1846 1
	  witAddBomEntry(witRun(),"engagement: Priority1Demand",consumedPartName);
d1849 2
a1850 2
	  witSetBomEntryConsRate(witRun(),"engagement: Priority1Demand",nBomsAddedToPriority1,consRate);
	  witSetBomEntryOffset(witRun(),"engagement: Priority1Demand",nBomsAddedToPriority1,offset);
d1855 2
a1856 1
	  witAddBomEntry(witRun(),"engagement: Priority2Demand",consumedPartName);	    
d1861 2
a1862 2
	  witSetBomEntryConsRate(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,consRate);
	  witSetBomEntryOffset(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,offset);
d1869 2
a1870 1
	      witAddSubsBomEntry(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,subConsumedPartName);
d1872 1
a1872 1
	      witSetSubsBomEntryConsRate(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,j,consRate);
d1874 1
a1874 1
	      witSetSubsBomEntryOffset(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,j,offset);
d1876 2
a1877 2
	      witSetSubsBomEntryExpNetAversion(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,j,aversion);
	      witSetSubsBomEntryMrpNetAllowed(witRun(),"engagement: Priority2Demand",nBomsAddedToPriority2,j,WitTRUE);
d1888 1
a1888 1
  // perform witHeurImplode
d1891 1
a1891 1
  // pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
d1905 27
a1942 3
  std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
    reportingUnits,bands,globals,competencies,industries;
  
d1990 1
a1990 1
  // (1) Get the offset (leadtime) from the acquire BOP
d1992 1
a1992 1
  // part, one for each period, setting the offset and the lastestPeriod on each
d1994 1
a1994 1
  // (4) Delete the enable operation and the bench part.
d1996 3
a1998 1
  // (6) Do some post processing 
d2019 6
d2035 1
d2044 2
a2045 5
    int n;
    // witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,0,exogSup[0]);
    for (n=0; n<np; n++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,
			  workingRes,n,exogSup[0]);
d2049 1
a2049 1
  witPurgeData(witRun());
d2095 18
a2118 4
  std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
       reportingUnits,bands,globals,competencies,industries;
  

d2121 2
a2122 2
 	getResourceNames(names);
 	int numRows = names.size();
d2177 1
a2177 1
  presolveForGapGlut();
d2184 4
a2187 1
    priorityGapGlut(); //$$$$$ Here is where you can change this to call priorityGapGlut1()
d2189 7
a2195 1
    optimalGapGlut();
d2209 1
a2209 1
  witSetOptWithLotSizes(witRun(),WitTRUE); 
d3203 1
a3203 1
    }   
@


1.185
log
@Modifed unitTest to try solving after initial solve
@
text
@a2082 23
  gapGlut04Feb();
  return;
  
  RCPoperationBomSubBomIndices subBomsAdded;
  presolve(subBomsAdded);
  presolveForGapGlut();
  witMrp(witRun());
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
  witWriteData(witRun(),"wit1.dat");
  saveMrpResults();

  if (getAlgorithmName() == "priorityPlan")
    priorityGapGlut();
  else
    optimalGapGlut();

  witWriteData(witRun(),"wit2.dat");

  postsolve(subBomsAdded);
}

void RCPproblem::gapGlut04Feb()
{
a2098 3
//--------------------------------------------


a2100 21
  resourceAction04Feb();
  return;
  //  let's see if we can just call resourceAction04Feb
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");

  RCPoperationBomSubBomIndices subBomsAdded;
  presolve(subBomsAdded);

  witMrp(witRun());
  saveMrpResults();
  if (getAlgorithmName() == "priorityPlan")
      priorityResourceAction();
  else  //assume algorithm is optimalPlan
      optimalResourceAction();
  witWriteData(witRun(),"wit.dat");
  
  postsolve(subBomsAdded);
}

void RCPproblem::resourceAction04Feb()
{
d2911 1
a2911 1
  // Test gapGlut04Feb priorityPlan
d2923 1
a2923 1
    prob_subs.gapGlut04Feb();
d3073 1
a3073 1
      prob_subs.gapGlut04Feb();
d3105 1
a3105 1
  // gapGlut04Feb priority
d3118 1
a3118 1
    prob_subs.gapGlut04Feb();
d3205 1
a3205 1
      prob_subs.gapGlut04Feb();
d3486 1
a3486 1
    prob_acquire.resourceAction04Feb(); 
d3669 1
a3669 1
    prob.gapGlut04Feb();
d3697 1
a3697 1
    prob.gapGlut04Feb();
d3725 1
a3725 1
    prob.gapGlut04Feb();
d3754 1
a3754 1
    prob_04Feb.gapGlut04Feb();
d3778 1
a3778 1
    prob.gapGlut04Feb();
@


1.184
log
@Added postsolve which removes substitute arcs added by presolve.
@
text
@d2166 1
a2166 1
  witWriteData(witRun(),"wit.dat");
d2958 1
d2972 11
d2984 1
a2984 12
    {      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,rdummy;

      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");
      r2.push_back("j1");r2.push_back("s2");r2.push_back("Cont");r2.push_back("non-global");
      r3.push_back("j2");r3.push_back("s1");r3.push_back("IBM");r3.push_back("non-global");
      r4.push_back("j2");r4.push_back("s2");r4.push_back("Cont");r4.push_back("global");
      r5.push_back("j2");r5.push_back("s2");r5.push_back("IBM");r5.push_back("global");
      r6.push_back("j2");r6.push_back("s2");r6.push_back("Supp");r6.push_back("global");
      rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("prioritySubstitute");rdummy.push_back("global");
     
d3081 7
a3087 4
      //check that the gaps and gluts are correct
      //because of the priority aversion, the IBM and Cont substitutes for
      //prioritySubstitutes should get used first. The Supp substititute won't be
      //needed, so there will be a glut of that
a3115 1
    
d3117 33
a3149 2
    
    
d3151 2
d3164 1
a3164 1

d3167 86
a3252 25
      //check that appropriate substitute arcs are there
    {
      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15;

      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");r1.push_back("chicago");r1.push_back("US");
      r2.push_back("j2");r2.push_back("s2");r2.push_back("IBM");r2.push_back("global");r2.push_back("chicago");r2.push_back("US");
      r3.push_back("j2");r3.push_back("s2");r3.push_back("IBM");r3.push_back("global");r3.push_back("akron");r3.push_back("US");
      r4.push_back("j1");r4.push_back("s1");r4.push_back("Cont");r4.push_back("non-global");r4.push_back("akron");r4.push_back("US");
      r5.push_back("j1");r5.push_back("s1");r5.push_back("Supp");r5.push_back("non-global");r5.push_back("akron");r5.push_back("US");
      r6.push_back("j1");r6.push_back("s1");r6.push_back("WOS");r6.push_back("non-global");r6.push_back("akron");r6.push_back("US");
      r7.push_back("j3");r7.push_back("s3");r7.push_back("IBM");r7.push_back("non-global");r7.push_back("london");r7.push_back("GB");
      r8.push_back("j3");r8.push_back("s3");r8.push_back("IBM");r8.push_back("non-global");r8.push_back("akron");r8.push_back("US");
      r9.push_back("j3");r9.push_back("s3");r9.push_back("Cont");r9.push_back("global");r9.push_back("newyork");r9.push_back("US");
      r10.push_back("j3");r10.push_back("s3");r10.push_back("Cont");r10.push_back("non-global");r10.push_back("newyork");r10.push_back("US");
      r11.push_back("j2");r11.push_back("s2");r11.push_back("IBM");r11.push_back("global");r11.push_back("unspecified");r11.push_back("US");
      r12.push_back("j1");r12.push_back("s1");r12.push_back("prioritySubstitute");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
      r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("unspecified");r13.push_back("prioritySubstitute");
      r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("prioritySubstitute");r14.push_back("newyork");r14.push_back("US");
      r15.push_back("j3");r15.push_back("unspecified");r15.push_back("Cont");r15.push_back("non-global");r15.push_back("newyork");r15.push_back("US");
          
      
       //check that the gaps and gluts are correct
      
d3305 1
a3305 1
       gapQty = prob_subs.getResourceGapQuantity(r14);
a3312 2


a3313 2
    
    
d3315 3
a3317 2

   {
a3325 1
    
d3328 12
a3339 1
    
a3341 1
      
d3344 1
a3344 1

a3355 1

d3366 2
a3367 2
           
      
d3374 2
d3447 2
d3451 6
a3456 4
    //Check optimal value
    double obj = prob_subs.getObjValue();
    assert( eq(obj,4886.0) );
    
@


1.183
log
@fix some frees to be witFrees
@
text
@d1138 1
a1138 1
void RCPproblem::addSubsArcsToWitModel04Feb()
d1278 2
d1312 14
d1327 1
a1327 1
  
d1356 3
d1447 1
a1447 1
void RCPproblem::presolve()
d1517 1
a1517 1
  addSubsArcsToWitModel04Feb();
d1519 1
a1519 1
void RCPproblem::presolve04Feb()
d1588 35
a1622 2
  // Add substitute arcs.  
  addSubsArcsToWitModel04Feb();
d2085 3
a2087 1
  presolve();
d2100 2
d2106 2
a2107 1
  presolve04Feb();
d2119 1
d2131 4
a2134 1
  presolve();
d2142 2
d2149 4
a2152 1
  presolve04Feb();
d2167 2
d2972 1
a2972 2
    {
      
@


1.182
log
@Added priorityGapGlut1() which computes gap/gluts according to a priority scheme.  It's not called by anything but you can look for $$$$ in the code and change priorityGapGlut() to priorityGapGlut1() to call it.

Also I cleaned up some stuff in rcpOpt.cpp.
@
text
@d1684 1
a1684 1
    delete [] priorityVec;
d1700 1
a1700 1
    delete [] priorityVec;
d1780 1
a1780 1
	  free (subConsumedPartName);
d1782 3
a1784 3
      free (consumedPartName);
      free (consRate);
      free (offset);
d3095 1
a3095 1
      //      assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
@


1.181
log
@tests for priority substitution
@
text
@d210 2
d1649 159
d2032 1
d2058 1
a2058 1
    priorityGapGlut();
d3095 1
a3095 1
      //assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
d3496 36
@


1.180
log
@another fix to the handling of substitutes when they are not provided as requested
@
text
@d2888 106
@


1.179
log
@check whether there are any substitutes before trying to iterate through them.
@
text
@d1065 5
a1069 3
    if (attributeSubs.size()==0) {
        std::cerr <<"WARNING: Substitute requested but no substitutes provided. " <<std::endl
          <<"   resource ID name   : " << resourceIdName <<std::endl;
d1072 1
@


1.178
log
@added another test case to test matching and priority substitution
@
text
@d1053 1
d1055 2
d1058 2
d1061 2
d1064 6
d1073 1
a1073 1

d1080 1
a1080 1
    // Get all resources whose attribute value matches
d1088 1
a1088 1
      // If there aren't any resources with toSkill then there is nothing to do
a1090 1
      
d1099 2
a1100 1
    } // end of for toSkillIt loop
d1105 1
a1105 1
    // Take the intersection of unionOrig and currentToResources storing result in intersectionSet
d1110 1
a1110 1
  else { 
d1117 1
a1117 1
    // Intersect resourcse whose attribute matches with set passed into this method
@


1.177
log
@changes to the format of the priority substitution files; cleaner and neater
@
text
@d3000 14
a3013 1
 
a3211 13
#if 0
  //"new" style simple input
  {
    RCPproblem prob_simple;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_simple";
    
    populate(prob_simple, inputDirectory, outputDirectory);
    prob_simple.gapGlut();
    prob_simple.resourceAction();
    
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocs;
    prob_simple.getResourceNames(jobRoles,skillSets,LOBs,sources,resourceLocs);
a3212 23
    std::vector<float> gapQty = prob_simple.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    std::vector<float> glutQty = prob_simple.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==20);
    assert(glutQty[1]==0);

    gapQty = prob_simple.getResourceGapQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    assert(gapQty[0]==10);
    assert(glutQty[0]==0);
    assert(gapQty[1]==30);
    assert(glutQty[1]==0);

    gapQty = prob_simple.getResourceGapQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==30);
    assert(gapQty[1]==0);
    assert(glutQty[1]==10);

  }
#endif
d3322 61
@


1.176
log
@Cleaning up last vestiges of old style code. Removed dead files and if defed out sections.
@
text
@d1207 1
a1207 1
        int subsAversion = 1;
d1223 1
a1223 4
             //I've set it up so that the highest priority fields get the lowest numbers, the
             //next priority field starts from the next larger number etc. Thus multiplying the
             //aversions will order them the way we want
             subsAversion = subsAversion * resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
d2737 1
a2737 1
      rdummy.push_back("j2");rdummy.push_back("s2");rdummy.push_back("unspecified");rdummy.push_back("global");
d2837 1
a2837 1
      //unspecified should get used first. The Supp substititute won't be
@


1.175
log
@handling multiple aversions using separated spans of values, and multiplying
them together
@
text
@a270 9
#if 0
    // loop once for each resourceId and add resourceIdValues to oneResouce
    int i;
    for ( i=0; i< getNumberResourceIdentifiers(); ++i ) {
      const std::string & longName = *r;
      std::string idValue = resourceIdentifierValueFromResourceName( longName, i );
      resourceIdValues.push_back( idValue );
    }
#endif
d275 1
a275 13
#if 0
int RCPproblem::getNumberResourceIdentifiers() const
{
  return resourceIdentifierNames_.size();
}
#endif
#if 0
std::string RCPproblem::getResourceIdentifierName(int which)const {
  assert( which<resourceIdentifierNames_.size() );
  assert( which>=0 );
  return resourceIdentifierNames_[which];
}
#endif
a293 6
#if 0
void RCPproblem::setResourceIdentifierNames(const std::vector<std::string> & resourceIdentifierNames )
{
  // resource identifier names must be specified before adding resources.
  // make sure this is the case.
  assert( resourceNames_.size() == 0 );
a294 7
  resourceIdentifierNames_ = resourceIdentifierNames;
  int i;
  for ( i=0; i<resourceIdentifierNames.size(); i++ ) {
     mapResourceIdentiferNameToIndex_[resourceIdentifierNames[i]]=i;
  }
}
#endif
a324 65
#if 0
void RCPproblem::getResourceNames( 
           std::vector<std::string> & jobRoles, std::vector<std::string> & skillSets, 
	   std::vector<std::string> & LOBs, std::vector<std::string> & sources,
           std::vector<std::string> & locNames ) const
{
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  locNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=resourceNames_.begin(); it!=resourceNames_.end(); ++it ) {
    jobRoles.push_back( jobRoleFromResourceName(*it) );
    skillSets.push_back( skillSetFromResourceName(*it) );
    LOBs.push_back( LOBFromResourceName(*it) );
    sources.push_back( sourceFromResourceName(*it) );
    locNames.push_back( locationFromResourceName(*it) );
  }
}
void RCPproblem::getResourceNames( 
           std::vector<std::string> & jobRoles, 
           std::vector<std::string> & skillSets, 
	       std::vector<std::string> & LOBs, 
	       std::vector<std::string> & sources,
           std::vector<std::string> & regions,
           std::vector<std::string> & countries,
           std::vector<std::string> & cities,
           std::vector<std::string> & reportingUnits,
           std::vector<std::string> & bands,
           std::vector<std::string> & globals,
           std::vector<std::string> & competencies,
           std::vector<std::string> & industries ) const
{
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  regions.clear();
  countries.clear();
  cities.clear();
  reportingUnits.clear();
  bands.clear();
  globals.clear();
  competencies.clear();
  industries.clear();

  std::set<std::string>::const_iterator it;
  for ( it=resourceNames_.begin(); it!=resourceNames_.end(); ++it ) {
    jobRoles.push_back( jobRoleFromResourceName(*it) );
    skillSets.push_back( skillSetFromResourceName(*it) );
    LOBs.push_back( LOBFromResourceName(*it) );
    sources.push_back( sourceFromResourceName(*it) );
    regions.push_back( regionFromResourceName(*it) );
    countries.push_back( countryFromResourceName(*it) );
    cities.push_back( cityFromResourceName(*it) );
    reportingUnits.push_back( reportingUnitFromResourceName(*it) );
    bands.push_back( bandFromResourceName(*it) );
    globals.push_back( globalFromResourceName(*it) );
    competencies.push_back( competencyFromResourceName(*it) );
    industries.push_back( industryFromResourceName(*it) );
  }
}
#endif
a362 36
#if 0
std::vector<float> RCPproblem::getResourceGapQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getGapAppData());

}

std::vector<float> RCPproblem::getResourceGapQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getGapAppData());

}
#endif
a501 79
#if 0
std::vector<float> RCPproblem::getResourceSupplyQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getSupplyAppData());
}
std::vector<float> RCPproblem::getResourceSupplyQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getSupplyAppData());
}

std::vector<float> RCPproblem::getResourceMrpQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getMrpAppData());

}

std::vector<float> RCPproblem::getResourceMrpQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getMrpAppData());
}

std::vector<float> RCPproblem::getResourceWorkingQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getWorkingAppData());
}
a502 20
std::vector<float> RCPproblem::getResourceWorkingQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getWorkingAppData());
}
#endif
a510 13
#if 0
std::vector<float> RCPproblem::getResourceReleaseQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getReleaseAppData());
}
a511 20
std::vector<float> RCPproblem::getResourceReleaseQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getReleaseAppData());
}
#endif
a530 14
#if 0
std::vector<float> RCPproblem::getResourceBenchQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getBenchAppData());
}

a531 20
std::vector<float> RCPproblem::getResourceBenchQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getBenchAppData());
}
#endif
a540 13
#if 0
std::vector<float> RCPproblem::getResourceAcquireQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getAcquireAppData());
}
a541 20
std::vector<float> RCPproblem::getResourceAcquireQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData);
  return(appData->getAcquireAppData());
}
#endif
d556 2
a557 7
#if 0
std::vector<float> RCPproblem::getOptimalWorkingQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName )const
d559 2
a560 39
  std::string opName = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}
std::vector<float> RCPproblem::getOptimalWorkingQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry )const
{
  std::string opName = enableResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}
#endif


std::vector<float> RCPproblem::getOptimalBenchQuantity(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}

#if 0
std::vector<float> RCPproblem::getOptimalBenchQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
a562 18
std::vector<float> RCPproblem::getOptimalBenchQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry )const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}
#endif
a604 26
#if 0
void RCPproblem::setEngagementReasonableReward(const std::string & name) {
      std::string theEngagement = engagementName(name);
      //get all the resources required
      int numBOMentries;
      char * partName;
      float totalSum = 0;
      witGetOperationNBomEntries(witRun(), theEngagement.c_str(), &numBOMentries);
      for (int i=0; i<numBOMentries; i++) {
         witGetBomEntryConsumedPart(witRun(), theEngagement.c_str(), i, &partName);
         std::string benchName = getBenchFromWorkingName(partName);
         witFree(partName);
         std::vector<float> qty = witGetArcAttribute(witGetBomEntryConsRate,theEngagement.c_str(),i);
         std::vector<float> cost = witGetNameAttribute(witGetPartObj1StockCost,benchName.c_str());

         //loop over and add it up
         float sum = 0;
         for (int j=0; j<qty.size(); j++) {
            sum = sum + qty[j]*cost[j];
         }
         totalSum=totalSum+sum;
      }
      //multiply by 4 for good measure
      totalSum = totalSum*4.0;
      setEngagementRevenue(name,totalSum);

a605 15
}

void RCPproblem::setResourceReasonableReleaseCost(const std::vector<std::string> &resourceIdentifierValues)
{
      std::vector<float> fixedCost = getResourceFixedCost(resourceIdentifierValues);
      float maximum = 0.0f;
      int t;
      for (t=0; t< fixedCost.size(); t++)
  	  if (fixedCost[t] > maximum) 
	    maximum = fixedCost[t];
      float reasonableReleaseCost = 2*getNPeriods()*maximum;
      setResourceReleaseCost(resourceIdentifierValues,reasonableReleaseCost);
    
}
#endif
a613 11
#if 0
std::vector<float> RCPproblem::getResourceFixedCost(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartObj1StockCost,benchRes);
}
a614 18
std::vector<float> RCPproblem::getResourceFixedCost(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetPartObj1StockCost,benchRes);
}
#endif
d643 1
a643 37
#if 0
float RCPproblem::getResourceAcquireCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & locName) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * acv;
  witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv);
  float returnVal = acv[0];
  witFree(acv);
  return returnVal;
}
float RCPproblem::getResourceAcquireCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & region,
                                         const std::string & country,
                                         const std::string & city,
                                         const std::string & reportingUnit,
                                         const std::string & band,
                                         const std::string & global,
                                         const std::string & competency,
                                         const std::string & industry) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  float * acv;
  witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv);
  float returnVal = acv[0];
  witFree(acv);
  return returnVal;
}
#endif
a654 37
#if 0
float RCPproblem::getResourceAcquireTime(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & locName) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * atv;
  witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv);
  float returnVal = atv[0];
  witFree(atv);
  return returnVal;
}
float RCPproblem::getResourceAcquireTime(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & region,
                                         const std::string & country,
                                         const std::string & city,
                                         const std::string & reportingUnit,
                                         const std::string & band,
                                         const std::string & global,
                                         const std::string & competency,
                                         const std::string & industry) const 
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,region, country,city,reportingUnit,band,global,competency,industry);
  float * atv;
  witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv);
  float returnVal = atv[0];
  witFree(atv);
  return returnVal;
}
#endif
d666 1
a666 37
#if 0
float RCPproblem::getResourceReleaseCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & region,
                                         const std::string & country,
                                         const std::string & city,
                                         const std::string & reportingUnit,
                                         const std::string & band,
                                         const std::string & global,
                                         const std::string & competency,
                                         const std::string & industry) const 
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region, country,city,reportingUnit,band,global,competency,industry);
  float * rcv;
  witGetPartObj1ScrapCost(mutableWitRun(),benchRes.c_str(),&rcv);
  float returnVal = rcv[0];
  witFree(rcv);
  return returnVal;
}
float RCPproblem::getResourceReleaseCost(
                                         const std::string & jobRole,
                                         const std::string & skillSet,
                                         const std::string & LOB,
                                         const std::string & source,
                                         const std::string & location) const 
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,location);
  float * rcv;
  witGetPartObj1ScrapCost(mutableWitRun(),benchRes.c_str(),&rcv);
  float returnVal = rcv[0];
  witFree(rcv);
  return returnVal;
}
#endif
a680 44
#if 0
float RCPproblem::getResourceReleaseTime(
					 const std::string & jobRole,
					 const std::string & skillSet,
					 const std::string & LOB,
					 const std::string & source,
                                         const std::string & locName) const 
{
  //  std::string benchRes = benchResourceName(jobRole);
  //float * rtv;
  //witGetBopEntryOffset(mutableWitRun(),benchRes.c_str(),0,&rtv);
  //float returnVal = rtv[0];
  float returnVal = 0.0;  //Still need to model this
  assert(0==1);
  //witFree(rtv);
  
  return returnVal;
}
float RCPproblem::getResourceReleaseTime(
					 const std::string & jobRole,
					 const std::string & skillSet,
					 const std::string & LOB,
					 const std::string & source,
                     const std::string & region,
                     const std::string & country,
                     const std::string & city,
                     const std::string & reportingUnit,
                     const std::string & band,
                     const std::string & global,
                     const std::string & competency,
                     const std::string & industry) const 
{
  //  std::string benchRes = benchResourceName(jobRole);
  //float * rtv;
  //witGetBopEntryOffset(mutableWitRun(),benchRes.c_str(),0,&rtv);
  //float returnVal = rtv[0];
  float returnVal = 0.0;  //Still need to model this
  assert(0==1);
  //witFree(rtv);
  
  return returnVal;
}

#endif
a695 29
#if 0
std::vector<float> RCPproblem::getResourceMRPGrossQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartReqVol,workingRes);
}
std::vector<float> RCPproblem::getResourceMRPGrossQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region, country,city,reportingUnit,band,global,competency, industry);
  return (witGetNameAttribute(witGetPartReqVol,workingRes));

}
a696 28
std::vector<float> RCPproblem::getResourceStockQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}
std::vector<float> RCPproblem::getResourceStockQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}
#endif
a700 13
#if 0
void RCPproblem::addBom(const std::string & engagementName, 
                        const std::string & jobRole,
                        const std::string & skillSet,
                        const std::string & LOB,
                        const std::string & source,
                        const std::string & resourceLocName)
{ 
  std::string bn = bomName(engagementName,jobRole,skillSet,LOB,source,resourceLocName);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);

  // nothing to do here. 
  // wit bomEntries are added when the usage period is known
a701 3
  bomNames_.insert(bn);
}
#endif
a715 20
#if 0
void RCPproblem::addBom(const std::string & engagementName, 
                        const std::string & jobRole,
                        const std::string & skillSet,
                        const std::string & LOB,
                        const std::string & source,
                        const std::string & region,
                        const std::string & country,
                        const std::string & city,
                        const std::string & reportingUnit,
                        const std::string & band,
                        const std::string & global,
                        const std::string & competency,
                        const std::string & industry)
{ 
  std::string bn = bomNameLong(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);

  // nothing to do here. 
  // wit bomEntries are added when the usage period is known
a716 2
  bomNames_.insert(bn);
}
d720 1
a720 5
                                     const std::string & jobRole,
                                     const std::string & skillSet, 
                                     const std::string & LOB, 
                                     const std::string & source, 
                                     const std::string & resourceLocName,
d724 1
a724 1
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
d733 1
a733 1
    assert( bomExists(engName,jobRole,skillSet,LOB,source,resourceLocName) );
a751 1
#endif
d754 3
a756 5
void RCPproblem::setBomUsageQuantity(
                                     const std::string & engName, 
                                     const std::vector<std::string> &resourceIdentifierValues,
                                     int period, 
                                     float usageQuantity)
d758 8
a765 2
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string engagement = engagementName(engName);
a766 126
  // Get the index for the bom connecting the operation to the part for this period
  int bomIndex = getBomEntryIndex(engagement,workingRes,period);

  // if the bomEntry was not found then add it.
  if ( bomIndex==-1 ) {
    // The RCP BOM must have already been added.
    assert( bomExists(engName,resourceIdentifierValues) );

    witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex);
    witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str());
  
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(period);
    witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData);
  }

  // set the RCP's usageQuantity to consRate
  witSetArcAttribute(witSetBomEntryConsRate,engagement,bomIndex,usageQuantity);
  

  // The BOM entries offset is set just before wit*Implode.
  // The offset will be set to engagementDuration-period

}

#if 0
void RCPproblem::setBomUsageQuantity(
                                     const std::string & engName, 
                                     const std::string & jobRole,
                                     const std::string & skillSet, 
                                     const std::string & LOB, 
                                     const std::string & source, 
                                     const std::string & region,
                                     const std::string & country,
                                     const std::string & city,
                                     const std::string & reportingUnit,
                                     const std::string & band,
                                     const std::string & global,
                                     const std::string & competency,
                                     const std::string &industry,
                                     int period, 
                                     float usageQuantity)
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string engagement = engagementName(engName);

  // Get the index for the bom connecting the operation to the part for this period
  int bomIndex = getBomEntryIndex(engagement,workingRes,period);

  // if the bomEntry was not found then add it.
  if ( bomIndex==-1 ) {
    // The RCP BOM must have already been added.
    assert( bomExists(engName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry) );

    witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex);
    witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str());
  
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(period);
    witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData);
  }

  // set the RCP's usageQuantity to consRate
  witSetArcAttribute(witSetBomEntryConsRate,engagement,bomIndex,usageQuantity);
  

  // The BOM entries offset is set just before wit*Implode.
  // The offset will be set to engagementDuration-period

}
  
bool RCPproblem::bomExists(
                           const std::string & engagementName, 
                           const std::string & jobRole,
                           const std::string & skillSet,
                           const std::string & LOB,
                           const std::string & source,
                           const std::string & resourceLocName)const
{
  std::string bn = bomName(engagementName,jobRole,skillSet,LOB,source,resourceLocName);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}
#endif


bool RCPproblem::bomExists(
                           const std::string & engagementName, 
                           const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string bn = bomName(engagementName,resourceIdentifierValues);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}


#if 0
bool RCPproblem::bomExists(
                           const std::string & engagementName, 
                           const std::string & jobRole,
                           const std::string & skillSet,
                           const std::string & LOB,
                           const std::string & source,
                           const std::string & region,
                           const std::string & country,
                           const std::string & city,
                           const std::string & reportingUnit,
                           const std::string & band,
                           const std::string & global,
                           const std::string & competency,
                           const std::string & industry)const
{
  std::string bn = bomNameLong(engagementName,jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}
#endif
d799 1
a799 75
#if 0
void RCPproblem::getBomNames( 
                             std::vector<std::string> & engagementNames, 
                             std::vector<std::string> & jobRoles, 
                             std::vector<std::string> & skillSets,
                             std::vector<std::string> & LOBs,
                             std::vector<std::string> & sources,
                             std::vector<std::string> & resourceLocNames )const
{
  engagementNames.clear();
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  resourceLocNames.clear();

  std::set<std::string>::const_iterator it;
  for ( it=bomNames_.begin(); it!=bomNames_.end(); ++it ) {
    engagementNames.push_back( engagementFromBomName(*it) );
    jobRoles.push_back( resourceFromBomName(*it) );
    skillSets.push_back( skillSetFromBomName(*it) );
    LOBs.push_back( LOBFromBomName(*it) );
    sources.push_back( sourceFromBomName(*it) );
    resourceLocNames.push_back( resourceLocFromBomName(*it) );
  }
}

void RCPproblem::getBomNames( 
                             std::vector<std::string> & engagementNames, 
                             std::vector<std::string> & jobRoles, 
                             std::vector<std::string> & skillSets,
                             std::vector<std::string> & LOBs,
                             std::vector<std::string> & sources,
                             std::vector<std::string> & regions,
                             std::vector<std::string> & countries,
                             std::vector<std::string> & cities,
                             std::vector<std::string> & reportingUnits,
                             std::vector<std::string> & bands,
                             std::vector<std::string> & globals,
                             std::vector<std::string> & competencies,
                             std::vector<std::string> & industries)const
{
  engagementNames.clear();
  jobRoles.clear();
  skillSets.clear();
  LOBs.clear();
  sources.clear();
  regions.clear();
  countries.clear();
  cities.clear();
  reportingUnits.clear();
  bands.clear();
  globals.clear();
  competencies.clear();
  industries.clear();


  std::set<std::string>::const_iterator it;
  for ( it=bomNames_.begin(); it!=bomNames_.end(); ++it ) {
    engagementNames.push_back( engagementFromLongBomName(*it) );
    jobRoles.push_back( resourceFromLongBomName(*it) );
    skillSets.push_back( skillSetFromLongBomName(*it) );
    LOBs.push_back( LOBFromLongBomName(*it) );
    sources.push_back( sourceFromLongBomName(*it) );
    regions.push_back( regionFromLongBomName(*it) );
    countries.push_back( countryFromLongBomName(*it) );
    cities.push_back( cityFromLongBomName(*it) );
    reportingUnits.push_back( reportingUnitFromLongBomName(*it) );
    bands.push_back( bandFromLongBomName(*it) );
    globals.push_back( globalFromLongBomName(*it) );
    competencies.push_back( competencyFromLongBomName(*it) );
    industries.push_back( industryFromLongBomName(*it) );
  }
}
#endif
a817 25
#if 0
std::vector<float> RCPproblem::getBomUsageQuantity(
                                                   const std::string & engName,
                                                   const std::string & jobRole, 
                                                   const std::string & skillSet,
                                                   const std::string & LOB,
                                                   const std::string & source,
                                                   const std::string & resourceLocName)const
{
  std::vector<float> retVal;

  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string theEngagement = engagementName(engName);

  int np = getNPeriods();

  int t;
  for (t=0; t<np; ++t) {
    int bomIndex = getBomEntryIndex(theEngagement,workingRes,t);
    retVal.push_back( getBomUsageQuantity(engName,jobRole,skillSet,LOB,source,resourceLocName,t) );
  }

  return retVal;
}
#endif
d839 6
a844 519

#if 0
float RCPproblem::getBomUsageQuantity(
                                      const std::string & engName, 
                                      const std::string & jobRole, 
                                      const std::string & skillSet,
                                      const std::string & LOB,
                                      const std::string & source,
                                      const std::string & resourceLocName,
                                      int period)const
{
  float retVal;
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string theEngagement = engagementName(engName);

  int bomIndex = getBomEntryIndex(theEngagement,workingRes,period);
  if ( bomIndex==-1 ) {
    // A bomEntry does not exist for this period
    retVal = 0.0f;
  }
  else {
    std::vector<float> consVol = 
      witGetArcAttribute(witGetBomEntryConsRate,theEngagement,bomIndex);
    retVal = consVol[0];    
  }

  return retVal;
}
#endif
//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
void RCPproblem::setBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int sub)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );

  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setSub(resourceIdName,sub);
}
//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData

#if 0
void  RCPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int sub,
    const std::string & resourceIdName )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setSub(resourceIdName,sub);
}
#endif


// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );

  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return appData->getSub(resourceIdName);
}

#if 0
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData


int  RCPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    const std::string & resourceIdName ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return appData->getSub(resourceIdName);
}
void  RCPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string &band, const std::string &global, const std::string & competency, const std::string & industry, int period,
    int sub,
    const std::string & resourceIdName )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setSub(resourceIdName,sub);
}

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string &band, const std::string &global, const std::string &competency, const std::string &industry, int period,
    const std::string & resourceIdName ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
   return appData->getSub(resourceIdName);
}
#endif
//-----------------------------------------------------------------------------

//-------------------------------------------------------------------------------------

void RCPproblem::setBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int match)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );

  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setMatch(resourceIdName,match);
}
// Method for setting bomAppData match attributes.

#if 0
void  RCPproblem::setBomMatch(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int match,
    const std::string & resourceIdName )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setMatch(resourceIdName,match);
}
#endif
// Method for setting bomAppData matchstitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( mapResourceIdentiferNameToIndex_.find(resourceIdName) != mapResourceIdentiferNameToIndex_.end() );

  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return appData->getMatch(resourceIdName);
}

#if 0
int  RCPproblem::getBomMatch(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    const std::string & resourceIdName ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return appData->getMatch(resourceIdName);
}

void  RCPproblem::setBomMatch(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string &band, const std::string &global, const std::string & competency, const std::string & industry, int period,
    int match,
    const std::string & resourceIdName )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  appData->setMatch(resourceIdName,match);
}

// Method for setting bomAppData matchstitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomMatch(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string &band, const std::string &global, const std::string &competency, const std::string &industry, int period,
    const std::string & resourceIdName ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
   return appData->getMatch(resourceIdName);
}
//-----------------------------------------------------------------------------
#endif
#if 0

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
void  RCPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int sub,
    void (RCPbomAppData::*setSubFunc)(int) )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  (appData->*setSubFunc)(sub);
}

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int (RCPbomAppData::*getSubFunc)() const ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,resourceLocName);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return (appData->*getSubFunc)();
}
void  RCPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string &band, const std::string &global, const std::string & competency, const std::string & industry, int period,
    int sub,
    void (RCPbomAppData::*setSubFunc)(int) )
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  (appData->*setSubFunc)(sub);
}

// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  RCPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string &band, const std::string &global, const std::string &competency, const std::string &industry, int period,
    int (RCPbomAppData::*getSubFunc)() const ) const
{
  std::string witPartName = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);

  RCPbomAppData * appData;
  witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData);
  return (appData->*getSubFunc)();
}
#endif

#if 0
void  RCPproblem::setBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int match)
{  
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"jobRole");
}
void  RCPproblem::setBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"skillSet");
}
void  RCPproblem::setBomLocationMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"location");
}
void  RCPproblem::setBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"lob");
}
void  RCPproblem::setBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"source");
}

int RCPproblem::getBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"jobRole");
}
int RCPproblem::getBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"skillSet");
}
int RCPproblem::getBomLocationMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"location");
}
int RCPproblem::getBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"lob");
}
int RCPproblem::getBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"source");
}

void  RCPproblem::setBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period,
    int sub)
{  
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,"jobRole");
}
void  RCPproblem::setBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,"skillSet");
}
void  RCPproblem::setBomLocationSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,"location");
}
void  RCPproblem::setBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,"lob");
}
void  RCPproblem::setBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,"source");
}

int RCPproblem::getBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"jobRole");
}
int RCPproblem::getBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"skillSet");
}
int RCPproblem::getBomLocationSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"location");
}
int RCPproblem::getBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"lob");
}
int RCPproblem::getBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"source");
}
#endif



#if 0
//newer methods
void  RCPproblem::setBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period,
    int match)
{  
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"jobRole");
}
void  RCPproblem::setBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"skillSet");
}
void  RCPproblem::setBomRegionMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"region");
}
void  RCPproblem::setBomCountryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"country");
}
void  RCPproblem::setBomCityMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"city");
}
void  RCPproblem::setBomReportingUnitMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"reportingUnit");
}
void  RCPproblem::setBomBandMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"bandMatch");
}
void  RCPproblem::setBomGlobalMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"global");
}
void  RCPproblem::setBomCompetencyMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"competency");
}
void  RCPproblem::setBomIndustryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"industry");
}
void  RCPproblem::setBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"lob");
}
void  RCPproblem::setBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int match)
{
  setBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"source");
}

int RCPproblem::getBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"jobRole");
}
int RCPproblem::getBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"skillSet");
}
int RCPproblem::getBomRegionMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"region");
}
int RCPproblem::getBomCountryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"country");
}
int RCPproblem::getBomCityMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"city");
}
int RCPproblem::getBomReportingUnitMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"reportingUnit");
}
int RCPproblem::getBomBandMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"band");
}
int RCPproblem::getBomGlobalMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"global");
}
int RCPproblem::getBomCompetencyMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"competency");
}
int RCPproblem::getBomIndustryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"industry");
}
int RCPproblem::getBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"lob");
}
int RCPproblem::getBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomMatch(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"source");
}

void  RCPproblem::setBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period,
    int sub)
{  
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"jobRole");
}
void  RCPproblem::setBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"skillSet");
}
void  RCPproblem::setBomRegionSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"region");
}
void  RCPproblem::setBomCountrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"country");
}
void  RCPproblem::setBomCitySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"city");
}
void  RCPproblem::setBomReportingUnitSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"reportingUnit");
}
void  RCPproblem::setBomBandSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"band");
}
void  RCPproblem::setBomGlobalSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
d846 10
a855 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"global");
d857 9
a865 2
void  RCPproblem::setBomCompetencySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
d867 10
a876 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"competency");
d878 7
a884 2
void  RCPproblem::setBomIndustrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
d886 10
a895 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"industry");
d897 6
a902 2
void  RCPproblem::setBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
d904 10
a913 6
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"lob");
}
void  RCPproblem::setBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
    int sub)
{
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,"source");
a915 49
int RCPproblem::getBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"jobRole");
}
int RCPproblem::getBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"skillSet");
}
int RCPproblem::getBomRegionSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"region");
}
int RCPproblem::getBomCountrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"country");
}
int RCPproblem::getBomCitySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"city");
}
int RCPproblem::getBomReportingUnitSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"reportingUnit");
}
int RCPproblem::getBomBandSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"band");
}
int RCPproblem::getBomGlobalSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"global");
}
int RCPproblem::getBomCompetencySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"competency");
}
int RCPproblem::getBomIndustrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"industry");
}
int RCPproblem::getBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"lob");
}
int RCPproblem::getBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string &competency, const std::string & industry, int period)
{  
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"source");
}
#endif
a1326 38
#if 0
void RCPproblem::getSubsResources( 
                    const std::string & engName, 
                    const std::string & jobRole,
                    const std::string & skillSet,
                    const std::string & location,
                    const std::string & lob,
                    const std::string & source,
                    RCPcollectionOfStrings & retVal)const
{
  retVal.clear();
  
  // Name of wit part connected to bomEntry
  std::string workingRes = workingResourceName(jobRole,skillSet,lob,source,location);
    
  // Name of wit operation connected to bomEntry
  std::string witEngagement = engagementName(engName);
    
  // Get the indices of the boms connecting the operation to the part
  std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
  int b;
  for( b=0; b<bomIndices.size(); ++b ) {
    int bomIndex = bomIndices[b]; 

    // Get the number of substitutes
    int nSubs;
    witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&nSubs);

    // loop once for each subs
    int s;
    for ( s=0; s<nSubs; ++s ) {
      char * subResName;
      witGetSubsBomEntryConsumedPart(mutableWitRun(),witEngagement.c_str(),bomIndex,s,&subResName);
      std::string baseName = baseNameFromWorkingResourceName(subResName);
      retVal.insert(baseName);
      witFree(subResName);
    }
  }
a1327 2
}
#endif
d1990 1
a1990 10
#if 0
std::string RCPproblem::acquireResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "acquire: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string RCPproblem::acquireResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string & band, const std::string &global, const std::string &competency, const std::string &industry )
{
  return "acquire: "+baseResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
}
#endif
d1995 1
a1995 7
#if 0
std::string RCPproblem::benchResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName ) const
{
  if (resourceIdentifierNames_.size()!=0) return "bench: " + baseResourceName(getResourceIdentifierNames());
  else return "bench: " + baseResourceName(jobRole,skillSet,LOB,source,locName);
}
#endif
d2000 1
a2000 6
#if 0
std::string RCPproblem::benchResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string & band, const std::string &global, const std::string &competency, const std::string &industry )
{
  return "bench: " + baseResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
}
#endif
d2005 1
a2005 10
#if 0
std::string RCPproblem::enableResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "enable: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string RCPproblem::enableResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string & reportingUnit, const std::string & band, const std::string &global, const std::string &competency, const std::string &industry )
{
  return "enable: "+baseResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
}
#endif
d2010 1
a2010 10
#if 0
std::string RCPproblem::workingResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName  )
{
  return "working: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
std::string RCPproblem::workingResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string &global, const std::string &competency, const std::string &industry )
{
  return "working: "+baseResourceName(jobRole,skillSet,LOB,source,region, country,city,reportingUnit, band, global, competency,industry);
}
#endif
a2026 11
#if 0
std::string RCPproblem::baseResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +locName;
}
std::string RCPproblem::baseResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string & competency, const std::string & industry )
{

  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +region + " in: " + country + " city: " + city + " repUnit: " + reportingUnit + " band: " + band + " global: "+ global + " comp: " + competency + " indus: " + industry;
}
#endif
a2028 54
#if 0
std::string RCPproblem::jobRoleFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName,"resource: "," skillSet: ");
}
std::string RCPproblem::skillSetFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," skillSet: "," LOB: ");
}
std::string RCPproblem::LOBFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," LOB: "," source: ");
}
std::string RCPproblem::sourceFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," source: "," at: ");
}
std::string RCPproblem::locationFromResourceName(const std::string & baseResourceName)
{
  return textAfter(baseResourceName," at: ");
}
std::string RCPproblem::regionFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," at: ", " in: ");
}
std::string RCPproblem::countryFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," in: ", " city: ");
}
std::string RCPproblem::cityFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," city: "," repUnit: ");
}
std::string RCPproblem::reportingUnitFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," repUnit: "," band: ");
}
std::string RCPproblem::bandFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," band: "," global: ");
}
std::string RCPproblem::globalFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," global: "," comp: ");
}
std::string RCPproblem::competencyFromResourceName(const std::string & baseResourceName)
{
  return textBetween(baseResourceName," comp: "," indus: ");
}
std::string RCPproblem::industryFromResourceName(const std::string & baseResourceName)
{
  return textAfter(baseResourceName," indus: ");
}
#endif
d2048 1
a2048 6
#if 0
std::string RCPproblem::bomName(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName)
{
  return "bom op: " + engagementName + " resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source +" at: "+ resourceLocName;
}
#endif
a2054 85
#if 0
std::string RCPproblem::resourceFromBomName(const std::string & bomName)
{
  return textBetween(bomName," resource: "," skillSet: ");
}
std::string RCPproblem::skillSetFromBomName(const std::string & bomName)
{
  return textBetween(bomName," skillSet: "," LOB: ");
}
std::string RCPproblem::LOBFromBomName(const std::string & bomName)
{
  return textBetween(bomName," LOB: "," source: ");
}
std::string RCPproblem::sourceFromBomName(const std::string & bomName)
{
  return textBetween(bomName," source: "," at: ");
}
std::string RCPproblem::resourceLocFromBomName(const std::string & bomName)
{
  return textAfter(bomName," at: ");
}

//newer methods
std::string RCPproblem::bomNameLong(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string & band, const std::string & global, const std::string & competency, const std::string & industry)
{
 
  return "bom op: " + engagementName + " resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source +" region: "+ region + " country: " + country + " city: " + city + " rep: " + reportingUnit + " band: " + band + " global: " + global + " comp: " + competency + " ind: " + industry;
}
std::string RCPproblem::engagementFromLongBomName(const std::string & bomName)const
{
  assert(  getResourceIdentifierNames().size() != 0 );
  std::string firstResourceID = getResourceIdentifierNames()[0];
  std::string firstResourceIDString = " "+firstResourceID;
  return textBetween(bomName,"bom op: ",firstResourceIDString);
}
std::string RCPproblem::resourceFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," resource: "," skillSet: ");
}
std::string RCPproblem::skillSetFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," skillSet: "," LOB: ");
}
std::string RCPproblem::LOBFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," LOB: "," source: ");
}
std::string RCPproblem::sourceFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," source: "," region: ");
}
std::string RCPproblem::regionFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," region: "," country: ");
}
std::string RCPproblem::countryFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," country: "," city: ");
}
std::string RCPproblem::cityFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," city: "," rep: ");
}
std::string RCPproblem::reportingUnitFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," rep: "," band: ");
}
std::string RCPproblem::bandFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," band: "," global: ");
}
std::string RCPproblem::globalFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," global: "," comp: ");
}
std::string RCPproblem::competencyFromLongBomName(const std::string & bomName)
{
  return textBetween(bomName," comp: "," ind: ");
}
std::string RCPproblem::industryFromLongBomName(const std::string & bomName)
{
  return textAfter(bomName," ind: ");
}

#endif
a2057 11
#if 0
//-------------------------------------------------------------------------
// skillSubs Name Methods
//------------------------------------------------------------------------- 
std::string RCPproblem::skillSubsName(const std::string & fromSkill,const std::string & toSkill)
{
  return "fromSkill: " + fromSkill + " toSkill: " + toSkill;
}
#endif


a2135 5
//jobRoleSubs_(),
//skillSubs_(),
//locationSubs_(),
//lobSubs_(),
//sourceSubs_(),
a2136 5
//jobToResourceNames_(),
//skillToResourceNames_(),
//lobToResourceNames_(),
//sourceToResourceNames_(),
//locToResourceNames_(),
a2141 1
  // witSetOptWithLotSizes(witRun(),WitTRUE); 
a2158 5
//jobRoleSubs_(),
//skillSubs_(),
//locationSubs_(),
//lobSubs_(),
//sourceSubs_(),
a2159 5
//jobToResourceNames_(),
//skillToResourceNames_(),
//lobToResourceNames_(),
//sourceToResourceNames_(),
//locToResourceNames_(),
a2186 5
  //jobRoleSubs_ = source.jobRoleSubs_;
  //skillSubs_ = source.skillSubs_;
  //locationSubs_ = source.locationSubs_;
  //lobSubs_ = source.lobSubs_;
  //sourceSubs_ = source.sourceSubs_;
a2187 5
  //jobToResourceNames_ = source.jobToResourceNames_;
  //skillToResourceNames_ = source.skillToResourceNames_;
  //lobToResourceNames_ = source.lobToResourceNames_;
  //sourceToResourceNames_ = source.sourceToResourceNames_;
  //locToResourceNames_ = source.locToResourceNames_;
d2916 1
a2916 13
     
#if 0
      std::string r1s1   = RCPproblem::baseResourceName("r1", "s1", "LOB1","src1","l1");
      std::string r1s2   = RCPproblem::baseResourceName("r1", "s2", "LOB1","src1","l1");
      std::string r2s1   = RCPproblem::baseResourceName("r2", "s1", "LOB1","src1","l1");
      std::string r2s2   = RCPproblem::baseResourceName("r2", "s2", "LOB1","src1","l1");
      std::string r1as1  = RCPproblem::baseResourceName("r1a","s1", "LOB1","src1","l1");
      std::string r1as2  = RCPproblem::baseResourceName("r1a","s2", "LOB1","src1","l1");
      std::string r1s1a  = RCPproblem::baseResourceName("r1", "s1a","LOB1","src1","l1");
      std::string r2s1a  = RCPproblem::baseResourceName("r2", "s1a","LOB1","src1","l1");
      std::string r1as1a = RCPproblem::baseResourceName("r1a","s1a","LOB1","src1","l1");
#endif
      
a2924 6
#if 0
      prob_subs.getSubsResources(
        "e1",
        "r1","s1","l1","LOB1","src1",
        subsRes);
#endif
@


1.174
log
@miscell. cleanups
@
text
@d2675 5
a2679 5
             //of aversions for each of the relevant Id fields. For example
             //if we have an aversion from source of 4 and from global of 2 then
             //perhaps it should be 8. Right now it's just getting overwriten each time
             //and the last one wins
             subsAversion = resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
@


1.173
log
@additonal tests of priority substitution for unitTest
@
text
@d1628 1
a1628 1
    // do the engagements //DLG this was using engagementFromLongBomName
@


1.172
log
@*** empty log message ***
@
text
@d4566 33
@


1.171
log
@remove unused function addSubsArcsToWitModel
@
text
@d4446 127
d4716 1
a4716 1
  
@


1.170
log
@bug in figuring out the appropriate set of substitution arcs. Only shows up
when there are more than one possible substitution for a given field.
@
text
@a2568 158
//DLG we should probably get rid of this since it's just calling the other one
void RCPproblem::addSubsArcsToWitModel()
{
  addSubsArcsToWitModel04Feb();
  return;

  int np = getNPeriods();
  
  // Get rcp boms
  std::vector<RCPvectorString> resourceNames;
  std::vector<std::string> engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames;
  //if (resourceIdentifierNames_.size()!=0) {
    // resource id names have been specified, so assume using general format
    getBomNames(engagementNames,resourceNames);
  //}
  //else {
   // getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames );
  //}
  
  // loop once for each rcp bom
  unsigned int b;
  for ( b=0; b<engagementNames.size(); ++b ) {
    
    std::string workingRes;
    RCPvectorString resourceIdValues;
    //if (resourceIdentifierNames_.size()!=0) {
      resourceIdValues=resourceNames[b];
      workingRes = workingResourceName(resourceIdValues);
    //}
   // else {
            
    //  resourceIdValues.push_back(jobRoles[b]);
    //  resourceIdValues.push_back(skillSets[b]);
    //  resourceIdValues.push_back(LOBs[b]);
    //  resourceIdValues.push_back(sources[b]);
    //  resourceIdValues.push_back(resourceLocNames[b]);
      
      // Does fromSkill appear in list of substitutes? If no, then just iterate
      //if ( resourceIdToSubs_["skillSet"].find(fromSkill)==resourceIdToSubs_["skillSet"].end() ) continue; 
      
      // Name of wit part connected to bomEntry
      //workingRes = workingResourceName(jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);
   // }
    
    // Name of wit operation connected to bomEntry
    std::string witEngagement = engagementName(engagementNames[b]);
    
    // Get the indices for the boms connecting the operation to the part
    std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
    
    
    // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
    // be added.  Need loop over bomEntries, because data files allow substitution rules to be different
    // by period.
    unsigned int be;
    for( be=0; be<bomIndices.size(); ++be ) {
      int bomIndex = bomIndices[be];  
      
      // get the period associated with this bomEntry
      RCPbomAppData * appData;
      witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),be,(void**)&appData);
      int period = appData->getPeriod();
      
      // Collection that will be manipulated to contain all allowed substitute resources
      RCPcollectionOfStrings subsResources = resourceNames_;;

      //loop once for each resource id name
      unsigned int i;
      for( i=0; i<getResourceIdentifierNames().size(); ++i ) {

        const std::string & resIdName  = getResourceIdentifierNames()[i];
        const std::string & resIdValue = resourceIdValues[i];

        // Does this bom allow substitution on i'th resource id 
        int subAllowed =      getBomSub(engagementNames[b],resourceIdValues,period,resIdName);
        int matching = getBomMatch(engagementNames[b],resourceIdValues,period,resIdName);
        if (matching) {
          removeIneligibleResources(subsResources,subAllowed,resIdName,resIdValue);
        }
      }
      
#if 0
      // Does this bom allow jobRole substitution? 
      int subAllowed =      getBomSub(engagementNames[b],resourceIdValues,period,"jobRole");
      int jobRoleMatching = getBomMatch(engagementNames[b],resourceIdValues,period,"jobRole");
      if (jobRoleMatching) {
        removeIneligibleResources(subsResources,subAllowed,"jobRole",fromJobRole);
      }
      
      // Does this bom allow skill substitution? 
      subAllowed = getBomSkillSetSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int skillSetMatching = getBomSkillSetMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (skillSetMatching) {
        //removeIneligibleResources(subsResources,subAllowed,skillSubs_,skillToResourceNames_,fromSkillSet);
        removeIneligibleResources(subsResources,subAllowed,"skillSet",fromSkillSet);
      }
      
      // Does this bom allow location substitution? 
      subAllowed = getBomLocationSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int locationMatching = getBomLocationMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (locationMatching) {
        removeIneligibleResources(subsResources,subAllowed,"locName",fromLocation);
      }
      
      // Does this bom allow lob substitution? 
      subAllowed = getBomLobSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int lobMatching = getBomLobMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (lobMatching) {
        removeIneligibleResources(subsResources,subAllowed,"LOB",fromLob);
      }
      
      // Does this bom allow source substitution? 
      subAllowed = getBomSourceSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int sourceMatching = getBomSourceMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (sourceMatching) {
        removeIneligibleResources(subsResources,subAllowed,"source",fromSource);
      }
#endif

      // Remove resource connected to BOM from the set of substitute resources
      subsResources.erase(baseNameFromWorkingResourceName(workingRes));
           
      // loop once for each substitute resource
      RCPcollectionOfStrings::const_iterator subsResIt;
      for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::string subsResource = *subsResIt;
        RCPvectorString toResIdValues = resourceIdentifierValuesFromResourceName(subsResource);
        
        // make sure substitute resource exists
        assert( resourceExists(toResIdValues) );
        
        //loop once for each resource id name
        unsigned int i;
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        for( i=0; i<getResourceIdentifierNames().size(); ++i ) {
          
          const std::string & resIdName  = getResourceIdentifierNames()[i];
          const std::string & fromResIdValue = resourceIdValues[i];
          const std::string & toResIdValue = toResIdValues[i];
          
          // compute the substitute arcs cost and leadTime
          // subsCost is the sum of the substitute cost for each substituted attribute
          // subsLeadTime is the maximum of the lead time for each substituted attribute
          int matching = getBomMatch(engagementNames[b],resourceIdValues,period,resIdName);
          if ( fromResIdValue != toResIdValue && matching==1 ) {
            //resIdName was substituted
            subsLeadTime = max( subsLeadTime , resourceIdToSubs_[resIdName][fromResIdValue][toResIdValue].getLeadTime() );
            subsCost     = subsCost          + resourceIdToSubs_[resIdName][fromResIdValue][toResIdValue].getCost();
          }
        }

#if 0
        std::string toJobRole = jobRoleFromResourceName(subsResource);
        std::string toSkill   = skillSetFromResourceName(subsResource);
        std::string toLocation = locationFromResourceName(subsResource);
        std::string toLOB = LOBFromResourceName(subsResource);
        std::string toSource = sourceFromResourceName(subsResource);
a2569 88
        // make sure substitute resource exists
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
        
        // compute the substitute arcs cost and leadTime
        // subsCost is the sum of the substitute cost for each substituted attribute
        // subsLeadTime is the maximum of the lead time for each substituted attribute
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        if ( fromJobRole != toJobRole && jobRoleMatching==1 ) {
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["jobRole"][fromJobRole][toJobRole].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["jobRole"][fromJobRole][toJobRole].getCost();
        }
        if ( fromSkillSet != toSkill && skillSetMatching==1 ) {
          //skill was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["skillSet"][fromSkillSet][toSkill].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["skillSet"][fromSkillSet][toSkill].getCost();
        }
        if ( fromLocation != toLocation && locationMatching==1 ) {
          //location was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["locName"][fromLocation][toLocation].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["locName"][fromLocation][toLocation].getCost();
        }
        if ( fromLob != toLOB && lobMatching==1 ) {
          //lob was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["LOB"][fromLob][toLOB].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["LOB"][fromLob][toLOB].getCost();
        }
        if ( fromSource != toSource && sourceMatching==1 ) {
          //source was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["source"][fromSource][toSource].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["source"][fromSource][toSource].getCost();
        }
#endif
        
        // Assert that the subs resource exists
        assert( resourceExists(toResIdValues) );
        
        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(toResIdValues);
        
        std::cout <<"  resource: " <<workingRes <<std::endl;
        std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
        
        
        // get some attributes of bomEntry that will have substitute added
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,witEngagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,witEngagement,bomIndex);
        
        // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
        // no shifting by lead time is needed
#ifndef NDEBUG
        {
          int t;
          for( t=1; t<np; ++t )
            assert(bomConsRate[0]==bomConsRate[t]);
        }
#endif
        
        // get index of substitute to be added
        int subIndex;
        witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex);
        
        // add substitute
        witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() );
        
        // set substitute consRate
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,witEngagement,bomIndex,subIndex,bomConsRate);
        
        // compute substitute offset
        // JP, Donna, Dan: need to verify that offset is being set correctly.
        std::vector<float> subsOffset(np);
        int t;
        for (t=0; t<np; ++t) {
          subsOffset[t]=offset[t]-subsLeadTime;
        }
        
        // set substitutes offset
        witSetSubArcAttribute(witSetSubsBomEntryOffset,witEngagement,bomIndex,subIndex,subsOffset);
        
        // set cost of using substitute
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,witEngagement,bomIndex,subIndex,subsCost);
        
      }  // end for subsResIt loop
      
    }  // end of for be loop 
    
  } // end for b loop
}
d2976 1
a2976 1
  addSubsArcsToWitModel();
@


1.169
log
@working with priority substitutes; adding resource if not already existant
@
text
@d2508 1
a2508 1

a2511 6
    std::set <std::string>::const_iterator siter;
    siter = currentToResources.begin( );
    for (int i=0; i<currentToResources.size(); i++) {
        std::string foo = *siter;
        siter++;
    }
d2519 4
a2523 2
      // Get all resources whose attribute value matches
      const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
d2534 5
a2538 3
      
      //take the union of these
      unionCollectionOfStrings(resWithToAttributes,resWithMatch,unionSet);
d2541 2
a2543 5
    siter = unionSet.begin( );
    for (int i=0; i<unionSet.size(); i++) {
        std::string foo = *siter;
        siter++;
    }
d2547 1
a2547 1
    intersectionCollectionOfStrings(currentToResources,unionSet,intersection);
@


1.168
log
@fix a call to wit for adding aversion
@
text
@a2509 1
    
d2512 7
d2543 6
@


1.167
log
@misc. compiler warning fixes
@
text
@d2974 1
a2974 5
        float faversion = (const float)subsAversion;
        
        //DLG this doesn't compile; don't know why
        //witSetSubArcAttribute(witSetSubsBomEntryExpNetAversion,witEngagement,bomIndex,subIndex,faversion);
      
@


1.166
log
@adding support for priority substitution on bom arcs
@
text
@a2972 1
        // DLG I don't know the right wit routine here
d2974 4
a2977 1
        //witSetSubArcAttribute(witSetSubsBomEntryObj1SubAversion,witEngagement,bomIndex,subIndex,subsAversion);
@


1.165
log
@Added priorityResourceAction capability.  Fixed a problem in resourceAppData where I was writing the wrong value to workingQuantity.
@
text
@d2391 5
a2395 1

d2899 1
d2912 7
d2973 4
@


1.164
log
@adding a "prioritySubstitution" flag to the global attribute file for
the feb04 format. To be used later.
@
text
@d215 1
d879 8
a889 1

d3378 3
a3380 1
    workingQty = getResourceWorkingQuantity(names[r]);
d3385 1
a3385 1
      printf("%d %f %f %f\n", t, delta, exogSup[t], workingQty[t]);
d3420 1
a3420 3
  std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
       reportingUnits,bands,globals,competencies,industries;
       
d3422 2
a3423 8
  //if(!isLongFormat()) {
   // getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
   // numRows = jobRoles.size();
  //}
 // else {
    getResourceNames(names);
    numRows = names.size();
 // }
d3425 1
d3429 4
a3432 11
    //if(!isLongFormat())
    //  {
	//acquireOp = acquireResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	//workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    //  }
    //else
      {
	acquireOp = acquireResourceOperationName(names[r]);
	workingRes = workingResourceName(names[r]);
      }

d3444 1
a3444 1
	float * vecOffset = floatToFloatStar((float) -i);
d3449 1
a3449 1

d3452 3
a3454 6

    //if(!isLongFormat())
    //  exogSup = getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    //else
      exogSup = getResourceSupplyQuantity(names[r]);

d3456 1
a3456 2
    witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,
			  workingRes,0,exogSup[0]);
d3459 1
a3459 1
			  workingRes,n,0.0f);
d3464 1
a3464 1

d3467 1
a3467 1

d3469 40
a3508 1

d3636 1
a3636 1
      witHeurImplode(witRun());
@


1.163
log
@trivial changes from int to unsigned int to make the compiler happier
@
text
@d4 1
@


1.162
log
@ifdef'ed implemtation and prototype of setEngagementReasonableReward.
ifdef'ed out all references to setResourceReasonableReleaseCost.
It was only used in unitTest, not in populate.
@
text
@d130 1
a130 1
    for ( int t=0; t<execVol.size(); ++t ) {
d170 1
a170 1
  for ( int t=0; t<execVol.size(); ++t ) {
d236 1
a236 1
  for (int i=0; i<resourceAttributeVector.size(); i++) {
d331 1
a331 2
  int i;
  for ( i=0; i<getResourceIdentifierNames().size(); ++i ) {
d2569 1
a2569 1
  int b;
d2603 1
a2603 1
    int be;
d2616 1
a2616 1
      int i;
d2681 1
a2681 1
        int i;
d2809 1
a2809 1
  int b;
d2827 1
a2827 1
    int be;
d2843 1
a2843 1
      for (int i=0; i<getResourceIdentifierNames().size(); i++) {
d2861 1
a2861 1
        int i;
d2975 1
a2975 1
  int b;
d3049 1
a3049 1
    int e;
d3105 1
a3105 1
    int e;
d3132 1
a3132 1
    int e;
d3163 1
a3163 1
    int e;
d3182 1
a3182 1
        float offset = -period;
d3204 1
a3204 1
    int e;
d3235 1
a3235 1
    int e;
d3254 1
a3254 1
        float offset = -period;
d3299 1
a3299 1
    int t;
d3309 1
a3309 1
    int e;
d3336 1
a3336 1
    for ( int t=0; t<gapQty.size(); t++ ) {
d3371 1
a3371 1
    int t;
d3498 1
a3498 1
    for ( int t=0; t<grossQty.size(); t++ ){
d3531 1
a3531 1
    for ( int t=0; t<workingQty.size(); t++ ){
d3830 1
a3830 1
  for (int i=0; i<resourceIdentifierValues.size()-1; i++) {
d4115 1
a4115 1
  int e;
d4133 1
a4133 1
    int e;
d4154 1
a4154 1
    int r;
d4175 1
a4175 1
  int e;
d4190 1
a4190 1
    int e;
d4893 1
a4893 1
    int i;
d4922 1
a4922 1
    int i;
@


1.161
log
@Implemented the functionality of setEngagementReasonableReward using RCPproblem public methods in populate.
@
text
@d991 1
d1032 1
d4415 1
d4418 1
@


1.160
log
@reorgainizing up rcpProblem header file
@
text
@d1385 1
d1393 1
d1598 10
d4456 1
d4459 6
d4470 12
@


1.159
log
@modifed some member data items to be handled in constructors.
@
text
@d296 1
a296 1
const RCPvectorString & RCPproblem::getResourceIdentifierNames() const
@


1.158
log
@changed parameter names
@
text
@d3606 1
a3606 1
  algorithmName = algName;
d3610 1
a3610 1
  problemName=probName;
d3614 1
a3614 1
  formatName=forName;
d3618 1
a3618 1
  return algorithmName;
d3622 1
a3622 1
  return problemName;
d3626 1
a3626 1
  return formatName;
d4024 4
a4027 1
resourceIdToResourceNames_()
d4058 4
a4061 1
resourceIdToResourceNames_()
d4097 3
@


1.157
log
@Fixed the gapGlut and resourceAction methods.  They both are still there and they call their 04Feb counterparts.
@
text
@d424 1
a424 1
void RCPproblem::setResourceSupplyQuantity(const std::vector<std::string> &resourceAttributeValues, int period, float supplyQuantity)
d426 1
a426 1
    std::string benchRes = benchResourceName(resourceAttributeValues);
d436 1
a436 1
                                           const std::vector<std::string> &resourceAttributeValues,
d440 1
a440 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d451 1
a451 1
                                        const std::vector<std::string> &resourceAttributeValues,
d455 1
a455 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d501 1
a501 1
                                           const std::vector<std::string> &resourceAttributeValues,
d505 1
a505 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d513 1
a513 1
std::vector<float> RCPproblem::getResourceGlutQuantity(const std::vector<std::string> &resourceAttributeValues)const
d515 1
a515 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d522 1
a522 1
std::vector<float> RCPproblem::getResourceGapQuantity(const std::vector<std::string> &resourceAttributeValues)const
d524 1
a524 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d570 1
a570 1
void RCPproblem::setResourceWorkingQuantity(const std::vector<std::string> &resourceAttributeValues, int period, float workingQuantity)
d572 1
a572 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d580 1
a580 1
void RCPproblem::setResourceAcquireQuantity(const std::vector<std::string> &resourceAttributeValues, int period, float acquireQuantity)
d582 1
a582 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d589 1
a589 1
void RCPproblem::setResourceReleaseQuantity(const std::vector<std::string> &resourceAttributeValues, int period, float releaseQuantity)
d591 1
a591 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d598 1
a598 1
void RCPproblem::setResourceBenchQuantity(const std::vector<std::string> &resourceAttributeValues, int period, float benchQuantity)
d600 1
a600 1
    std::string workingRes = workingResourceName(resourceAttributeValues);
d627 1
a627 1
std::vector<float> RCPproblem::getResourceSupplyQuantity(const std::vector<std::string> &resourceAttributeValues)const
d629 1
a629 1
  std::string benchRes = benchResourceName(resourceAttributeValues);
d736 1
a736 1
std::vector<float> RCPproblem::getResourceReleaseQuantity(const std::vector<std::string> &resourceAttributeValues) const
d738 1
a738 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d833 1
a833 1
std::vector<float> RCPproblem::getResourceAcquireQuantity(const std::vector<std::string> &resourceAttributeValues)const
d835 1
a835 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d876 1
a876 1
                                           const std::vector<std::string> &resourceAttributeValues )const 
d878 1
a878 1
  std::string opName = enableResourceOperationName(resourceAttributeValues);
d913 1
a913 1
std::vector<float> RCPproblem::getOptimalBenchQuantity(const std::vector<std::string> &resourceAttributeValues) const
d915 1
a915 1
  std::string benchRes = benchResourceName(resourceAttributeValues);
d951 1
a951 1
                                        const std::vector<std::string> &resourceAttributeValues,
d954 1
a954 1
  std::string acquireOp = acquireResourceOperationName(resourceAttributeValues);
d961 1
a961 1
void RCPproblem::setResourceAcquireTime(const std::vector<std::string> &resourceAttributeValues, float acquireTime)
d963 1
a963 1
  std::string acquireOp = acquireResourceOperationName(resourceAttributeValues);
d972 1
a972 1
void RCPproblem::setResourceReleaseTime(const std::vector<std::string>&resourceAttributeValues, float releaseTime)
d983 1
a983 1
void RCPproblem::setResourceReleaseCost(const std::vector<std::string> &resourceAttributeValues, float releaseCost)
d985 1
a985 1
  std::string benchOp = benchResourceName(resourceAttributeValues); 
d1019 1
a1019 1
void RCPproblem::setResourceReasonableReleaseCost(const std::vector<std::string> &resourceAttributeValues)
d1021 1
a1021 1
      std::vector<float> fixedCost = getResourceFixedCost(resourceAttributeValues);
d1028 1
a1028 1
      setResourceReleaseCost(resourceAttributeValues,reasonableReleaseCost);
d1033 1
a1033 1
std::vector<float> RCPproblem::getResourceFixedCost(const std::vector<std::string> &resourceAttributeValues) const
d1035 1
a1035 1
  std::string benchRes = benchResourceName(resourceAttributeValues);
d1071 1
a1071 1
                                      const std::vector<std::string> &resourceAttributeValues,
d1075 2
a1076 2
  std::string benchOp = benchResourceName(resourceAttributeValues);
  std::string enableOp = enableResourceOperationName(resourceAttributeValues);
d1087 1
a1087 1
float RCPproblem::getResourceAcquireCost(const std::vector<std::string> & resourceAttributeValues) const
d1089 1
a1089 1
  std::string acquireOp = acquireResourceOperationName(resourceAttributeValues);
d1135 1
a1135 1
float RCPproblem::getResourceAcquireTime(const std::vector<std::string> & resourceAttributeValues) const
d1137 1
a1137 1
  std::string acquireOp = acquireResourceOperationName(resourceAttributeValues);
d1183 1
a1183 1
float RCPproblem::getResourceReleaseCost(const std::vector<std::string> & resourceAttributeValues) const
d1185 1
a1185 1
  std::string benchRes = benchResourceName(resourceAttributeValues);
d1231 1
a1231 1
float RCPproblem::getResourceReleaseTime(const std::vector<std::string> & resourceAttributeValues) const
d1297 1
a1297 1
                                           const std::vector<std::string> &resourceAttributeValues)const
d1299 1
a1299 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d1383 1
a1383 1
                        const std::vector<std::string> &resourceAttributeValues)
d1385 2
a1386 2
  std::string bn = bomName(engagementName,resourceAttributeValues);
  std::string workingRes = workingResourceName(resourceAttributeValues);
d1461 1
a1461 1
                                     const std::vector<std::string> &resourceAttributeValues,
d1465 1
a1465 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d1474 1
a1474 1
    assert( bomExists(engName,resourceAttributeValues) );
d1559 1
a1559 1
                           const std::vector<std::string> &resourceAttributeValues)const
d1561 1
a1561 1
  std::string bn = bomName(engagementName,resourceAttributeValues);
d1692 1
a1692 1
                                         const std::vector<std::string> &resourceAttributeValues)const
d1696 1
a1696 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d1704 1
a1704 1
    retVal.push_back( getBomUsageQuantity(engName,resourceAttributeValues,t) );
d1736 1
a1736 1
                            const std::vector<std::string> &resourceAttributeValues,int period)const
d1739 1
a1739 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d1787 1
a1787 1
void RCPproblem::setBomSub(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period, const std::string & resourceIdName , int sub)
d1792 1
a1792 1
  std::string witPartName = workingResourceName(resourceAttributeValues);
d1822 1
a1822 1
int  RCPproblem::getBomSub(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period, const std::string & resourceIdName ) const
d1827 1
a1827 1
  std::string witPartName = workingResourceName(resourceAttributeValues);
d1883 1
a1883 1
void RCPproblem::setBomMatch(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period, const std::string & resourceIdName , int match)
d1888 1
a1888 1
  std::string witPartName = workingResourceName(resourceAttributeValues);
d1914 1
a1914 1
int  RCPproblem::getBomMatch(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period, const std::string & resourceIdName ) const
d1919 1
a1919 1
  std::string witPartName = workingResourceName(resourceAttributeValues);
d2948 1
a2948 1
                      const RCPvectorString &resourceAttributeValues,
d2954 1
a2954 1
  std::string workingRes = workingResourceName(resourceAttributeValues);
d3708 1
a3708 1
std::string RCPproblem::workingResourceName(const std::vector<std::string> &resourceAttributeValues )const
d3710 1
a3710 1
  return "working: "+baseResourceName(resourceAttributeValues);
d3814 1
a3814 1
std::string RCPproblem::bomName(const std::string & engagementName, const std::vector<std::string> &resourceAttributeValues)const
d3817 2
a3818 2
  for (int i=0; i<resourceAttributeValues.size()-1; i++) {
       retVal = retVal+getResourceIdentifierNames()[i] + ": " + resourceAttributeValues.at(i) + " ";
d3820 1
a3820 1
  retVal = retVal + getResourceIdentifierNames()[resourceAttributeValues.size()-1] + ": " + resourceAttributeValues.at(resourceAttributeValues.size()-1);
@


1.156
log
@removed setResourceIdentifierNames
and added addResourceIdentifierName
@
text
@d3530 1
d3567 3
d3590 2
a3591 2
      witSetOptWithLotSizes(witRun(),WitTRUE); 
      witOptImplode(witRun());
d3596 1
a3596 1
      witOptImplode(witRun());
d4800 1
a4800 1
    prob_acquire.resourceAction(); 
@


1.155
log
@Removed remaining methods:
add*Subs
set*SubsCost
set*SubsLeadTime
*SubsExists
get*SubsNames
get*SubsCost
@
text
@d282 1
d287 2
a288 1

d294 1
d301 13
a324 2


d326 1
d341 1
a341 1
  int last = getNumberResourceIdentifiers()-1;
d2830 2
a2831 2
      for (int i=0; i<getNumberResourceIdentifiers(); i++) {
         std::string resourceIdName = getResourceIdentifierName(i);
d2849 1
a2849 1
        for ( i=0; i<getNumberResourceIdentifiers(); i++) {
d2876 1
a2876 1
        for ( i=0; i<getNumberResourceIdentifiers(); i++) {
d2879 1
a2879 1
           std::string resourceIdName = getResourceIdentifierName(i);
d3828 1
a3828 1
  std::string nextToken = " "+getResourceIdentifierName(0);
d4297 5
a4301 8

    RCPvectorString resIdNames;
    resIdNames.push_back("jobRole");
    resIdNames.push_back("skillSet");
    resIdNames.push_back("LOB");
    resIdNames.push_back("source");
    resIdNames.push_back("locName");
    prob.setResourceIdentifierNames(resIdNames);
d4399 5
a4403 7
    RCPvectorString resIdNames;
    resIdNames.push_back("jobRole");
    resIdNames.push_back("skillSet");
    resIdNames.push_back("LOB");
    resIdNames.push_back("source");
    resIdNames.push_back("locName");
    prob.setResourceIdentifierNames(resIdNames);
@


1.154
log
@Removed methods:
addSkillSubs
setSkillSubsCost
setSkillSubsLeadTime
skillSubsExists
getSkillSubsNames
getSkillSubsCost
@
text
@a2333 110
  
//----------------------
// Methods for location substitution.
//----------------------
void RCPproblem::addLocationSubs(const std::string & fromLocation, const std::string & toLocation )
{
  addSubs("locName",fromLocation,toLocation);
}
void RCPproblem::setLocationSubsCost(const std::string & fromLocation, const std::string & toLocation, float cost )
{
  setSubsCost("locName",fromLocation,toLocation,cost);
}
void RCPproblem::setLocationSubsLeadTime(const std::string & fromLocation, const std::string & toLocation, float leadTime )
{
  setSubsLeadTime("locName",fromLocation,toLocation,leadTime);
}

bool RCPproblem::locationSubsExists(const std::string & fromLocation, const std::string & toLocation )const
{
  return subsExists("locName",fromLocation,toLocation);
}
void RCPproblem::getLocationSubsNames( std::vector<std::string> & fromLocations, std::vector<std::string> & toLocations)const
{
  getSubsNames("locName",fromLocations,toLocations);
}

float RCPproblem::getLocationSubsCost(const std::string & fromLocation, const std::string & toLocation )const
{
  return getSubsCost("locName",fromLocation,toLocation);
}

float RCPproblem::getLocationSubsLeadTime(const std::string & fromLocation, const std::string & toLocation )const
{
  return getSubsLeadTime("locName",fromLocation,toLocation);
}

  
//----------------------
// Methods for lob substitution.
//----------------------
void RCPproblem::addLobSubs(const std::string & fromLob, const std::string & toLob )
{
  addSubs("LOB",fromLob,toLob);
}
void RCPproblem::setLobSubsCost(const std::string & fromLob, const std::string & toLob, float cost )
{
  setSubsCost("LOB",fromLob,toLob,cost);
}
void RCPproblem::setLobSubsLeadTime(const std::string & fromLob, const std::string & toLob, float leadTime )
{
  setSubsLeadTime("LOB",fromLob,toLob,leadTime);
}

bool RCPproblem::lobSubsExists(const std::string & fromLob, const std::string & toLob )const
{
  return subsExists("LOB",fromLob,toLob);
}
void RCPproblem::getLobSubsNames( std::vector<std::string> & fromLobs, std::vector<std::string> & toLobs)const
{
  getSubsNames("LOB",fromLobs,toLobs);
}

float RCPproblem::getLobSubsCost(const std::string & fromLob, const std::string & toLob )const
{
  return getSubsCost("LOB",fromLob,toLob);
}

float RCPproblem::getLobSubsLeadTime(const std::string & fromLob, const std::string & toLob )const
{
  return getSubsLeadTime("LOB",fromLob,toLob);
}

  
//----------------------
// Methods for source substitution.
//----------------------
void RCPproblem::addSourceSubs(const std::string & fromSource, const std::string & toSource )
{
  addSubs("source",fromSource,toSource);
}
void RCPproblem::setSourceSubsCost(const std::string & fromSource, const std::string & toSource, float cost )
{
  setSubsCost("source",fromSource,toSource,cost);
}
void RCPproblem::setSourceSubsLeadTime(const std::string & fromSource, const std::string & toSource, float leadTime )
{
  setSubsLeadTime("source",fromSource,toSource,leadTime);
}

bool RCPproblem::sourceSubsExists(const std::string & fromSource, const std::string & toSource )const
{
  return subsExists("source",fromSource,toSource);
}
void RCPproblem::getSourceSubsNames( std::vector<std::string> & fromSources, std::vector<std::string> & toSources)const
{
  getSubsNames("source",fromSources,toSources);
}

float RCPproblem::getSourceSubsCost(const std::string & fromSource, const std::string & toSource )const
{
  return getSubsCost("source",fromSource,toSource);
}

float RCPproblem::getSourceSubsLeadTime(const std::string & fromSource, const std::string & toSource )const
{
  return getSubsLeadTime("source",fromSource,toSource);
}



@


1.153
log
@removed job role subs methods
@
text
@a2335 37
// Methods for skill substitution.
//----------------------
void RCPproblem::addSkillSubs(const std::string & fromSkill, const std::string & toSkill )
{
  //addSubs(skillSubs_,fromSkill,toSkill);
  addSubs("skillSet",fromSkill,toSkill);
}
void RCPproblem::setSkillSubsCost(const std::string & fromSkill, const std::string & toSkill, float cost )
{
  setSubsCost("skillSet",fromSkill,toSkill,cost);
}
void RCPproblem::setSkillSubsLeadTime(const std::string & fromSkill, const std::string & toSkill, float leadTime )
{
  setSubsLeadTime("skillSet",fromSkill,toSkill,leadTime);
}

bool RCPproblem::skillSubsExists(const std::string & fromSkill, const std::string & toSkill )const
{
  return subsExists("skillSet",fromSkill,toSkill);
}
void RCPproblem::getSkillSubsNames( std::vector<std::string> & fromSkills, std::vector<std::string> & toSkills)const
{
  getSubsNames("skillSet",fromSkills,toSkills);
}

float RCPproblem::getSkillSubsCost(const std::string & fromSkill, const std::string & toSkill )const
{
  return getSubsCost("skillSet",fromSkill,toSkill);
}

float RCPproblem::getSkillSubsLeadTime(const std::string & fromSkill, const std::string & toSkill )const
{
  return getSubsLeadTime("skillSet",fromSkill,toSkill);
}

  
//----------------------
d4629 1
a4629 1
    prob.getSkillSubsNames(fromSkills,toSkills);
d4632 1
d4635 4
a4638 4
    assert( !prob.skillSubsExists("s1","s2") );
    prob.addSkillSubs("s1","s2");
    assert( prob.skillSubsExists("s1","s2") );
    prob.getSkillSubsNames(fromSkills,toSkills);
d4644 2
a4645 2
    prob.setSkillSubsCost("s1","s2",2.0f);
    assert( eq(prob.getSkillSubsCost("s1","s2"),2.0f) );
d4647 2
a4648 2
    prob.setSkillSubsLeadTime("s1","s2",3.0f);
    assert( eq(prob.getSkillSubsLeadTime("s1","s2"),3.0f) );
d4650 2
a4651 2
    prob.addSkillSubs("sA","sB");
    prob.getSkillSubsNames(fromSkills,toSkills);
d4657 2
a4658 2
    assert(  prob.skillSubsExists("sA","sB") );
    assert( !prob.skillSubsExists("sB","sA") );
@


1.152
log
@just a couple comments
@
text
@a2332 41
//----------------------
// Methods for jobRole substitution.
//----------------------
void RCPproblem::addJobRoleSubs(const std::string & fromJobRole, const std::string & toJobRole )
{
  //addSubs(jobRoleSubs_,fromJobRole,toJobRole);
  addSubs("jobRole",fromJobRole,toJobRole);
}
void RCPproblem::setJobRoleSubsCost(const std::string & fromJobRole, const std::string & toJobRole, float cost )
{
  //setSubsCost(jobRoleSubs_,fromJobRole,toJobRole,cost);
  setSubsCost("jobRole",fromJobRole,toJobRole,cost);
}
void RCPproblem::setJobRoleSubsLeadTime(const std::string & fromJobRole, const std::string & toJobRole, float leadTime )
{
  //;setSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole,leadTime);
  setSubsLeadTime("jobRole",fromJobRole,toJobRole,leadTime);
}

bool RCPproblem::jobRoleSubsExists(const std::string & fromJobRole, const std::string & toJobRole )const
{
  //return subsExists(jobRoleSubs_,fromJobRole,toJobRole);
  return subsExists("jobRole",fromJobRole,toJobRole);
}
void RCPproblem::getJobRoleSubsNames( std::vector<std::string> & fromJobRoles, std::vector<std::string> & toJobRoles)const
{
  //getSubsNames(jobRoleSubs_,fromJobRoles,toJobRoles);
  getSubsNames("jobRole",fromJobRoles,toJobRoles);
}

float RCPproblem::getJobRoleSubsCost(const std::string & fromJobRole, const std::string & toJobRole )const
{
  //return getSubsCost(jobRoleSubs_,fromJobRole,toJobRole);
  return getSubsCost("jobRole",fromJobRole,toJobRole);
}

float RCPproblem::getJobRoleSubsLeadTime(const std::string & fromJobRole, const std::string & toJobRole )const
{
  //return getSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole);
  return getSubsLeadTime("jobRole",fromJobRole,toJobRole);
}
@


1.151
log
@remove lots of old code calling old-style functions
@
text
@d2708 2
@


1.150
log
@Removed old forms of:
  setResourceFixedCost
  resourceExists
@
text
@d343 1
d407 1
a407 1

d445 2
d481 1
a481 1

d516 1
d552 1
a552 1

d621 1
a621 1

d720 1
a720 1

d729 1
d762 1
a762 1

d782 1
d816 1
a816 1

d826 1
d859 1
a859 1

d867 1
d895 2
d904 1
d933 1
d1024 1
d1053 1
d1081 2
d1118 1
a1118 1

d1129 2
d1166 1
a1166 1

d1177 2
d1214 1
a1214 1

d1229 1
d1272 1
a1272 1

d1287 2
d1345 1
a1345 1

d1349 2
d1366 1
d1378 2
d1440 4
d1478 1
d1539 3
d1554 2
d1578 3
d1591 2
a1592 2
    // do the engagements
    const std::string engagementName = engagementFromLongBomName(baseName);
d1600 2
d1627 1
d1675 1
a1675 1

d1694 1
d1718 1
d1740 2
d1768 1
a1768 1

d1788 2
d1802 2
d1820 2
d1824 2
d1863 1
d1883 1
d1896 1
d1913 1
d1953 1
a1953 1

d2012 1
d2106 1
d2110 1
d2331 1
d2718 1
a2718 1
  if (resourceIdentifierNames_.size()!=0) {
d2721 4
a2724 4
  }
  else {
    getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames );
  }
d2732 1
a2732 1
    if (resourceIdentifierNames_.size()!=0) {
d2735 2
a2736 2
    }
    else {
d2738 5
a2742 5
      resourceIdValues.push_back(jobRoles[b]);
      resourceIdValues.push_back(skillSets[b]);
      resourceIdValues.push_back(LOBs[b]);
      resourceIdValues.push_back(sources[b]);
      resourceIdValues.push_back(resourceLocNames[b]);
d2748 2
a2749 2
      workingRes = workingResourceName(jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);
    }
d3153 2
d3194 1
a3194 1

d3252 1
d3440 5
a3444 5
  if (!isLongFormat()) {
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
    numRows = jobRoles.size();
  }
  else {
d3447 1
a3447 1
  }
d3571 5
a3575 5
  if(!isLongFormat()) {
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
    numRows = jobRoles.size();
  }
  else {
d3578 1
a3578 1
  }
d3583 6
a3588 6
    if(!isLongFormat())
      {
	acquireOp = acquireResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
      }
    else
d3614 3
a3616 3
    if(!isLongFormat())
      exogSup = getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    else
d3698 1
d3715 1
d3733 2
d3829 2
d3839 1
d3844 1
d3850 1
d3854 2
d3860 1
d3865 1
d3874 1
d3879 1
d3888 1
d3905 1
d3915 1
d3918 1
d3971 1
d3990 2
d3996 2
a3997 1
std::string RCPproblem::engagementFromBomName(const std::string & bomName)
d3999 2
a4000 1
  return textBetween(bomName,"bom op: "," resource: ");
d4002 2
d4087 1
a4087 1

d4300 5
a4304 4
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    for ( r=0; r<jobRoles.size(); ++r ) { 
      std::string resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
d4366 5
a4370 5
      if (!isLongFormat()) {
        getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
        numRows = jobRoles.size();
      }
      else {
d4373 1
a4373 1
      }
d4378 5
a4382 5
      if (resourceIdentifierNames_.size()!=0) 
        resourceName = workingResourceName(names[r]);
      else if (!isLongFormat())
        resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      else
d4775 1
a4775 1
    prob_subs.resourceAction();
d4971 1
a4971 1
    prob_acquire.resourceAction();
d5005 1
a5005 1
    prob_delay.resourceAction();
d5039 1
a5039 1
    prob_decline.resourceAction();
d5067 1
a5067 1
    prob_IGS.resourceAction();
d5101 1
a5101 1
    prob_IGS.resourceAction();
@


1.149
log
@Removed old forms of:
  setResourceReasonableReleaseCost
  setResourceAcquireCost
  setResourceReleaseTime
  setResourceReleaseCost
@
text
@a253 10
bool RCPproblem::resourceExists(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName)const
{
  std::string witName = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witPartExists(witName);
}
bool RCPproblem::resourceExists(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, const std::string &band, const std::string &global, const std::string &competency, const std::string &industry)const
{
  std::string witName = benchResourceName(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);
  return witPartExists(witName);
}
a1055 45
void RCPproblem::setResourceFixedCost(
                                      const std::string & jobRole,
                                      const std::string & skillSet,
                                      const std::string & LOB,
                                      const std::string & source,
                                      const std::string & locName,
                                      int   period,
                                      float fixedCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * stockcost;
  witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost);
  stockcost[period] = fixedCost;
  witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost);
  witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost);
  witFree(stockcost);
}

void RCPproblem::setResourceFixedCost(
                                      const std::string & jobRole,
                                      const std::string & skillSet,
                                      const std::string & LOB,
                                      const std::string & source,
                                      const std::string & region,
                                      const std::string & country,
                                      const std::string & city,
                                      const std::string & reportingUnit,
                                      const std::string & band,
                                      const std::string & global,
                                      const std::string & competency,
                                      const std::string & industry,
                                      int   period,
                                      float fixedCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);
  float * stockcost;
  witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost);
  stockcost[period] = fixedCost;
  witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost);
  witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost);
  witFree(stockcost);
  
}
@


1.148
log
@Removed old forms of:
  setResourceGlutQuantity
  setBenchResourceSupplyQuantity
  setResourceAcquireTime
@
text
@d942 1
a942 33
void RCPproblem::setResourceAcquireCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet, 
                                        const std::string & LOB, 
                                        const std::string & source, 
                                        const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                        float acquireCost)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  float * acv = floatToFloatStar(acquireCost);
  witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv);
  delete [] acv;
}
void RCPproblem::setResourceAcquireCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet, 
                                        const std::string & LOB, 
                                        const std::string & source, 
                                        const std::string & locName,
                                        float acquireCost)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  float * acv = floatToFloatStar(acquireCost);
  witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv);
  delete [] acv;
}
d964 1
a964 37
void RCPproblem::setResourceReleaseTime(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName,
                                        float releaseTime)
{
   //remember to negate this
	
	//std::string acquireOp = acquireResourceOperationName(jobRole);  Still need to model this
  //  float * rtv = floatToFloatStar(releaseTime);
  //  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,rtv);   Still need to model this
  //delete [] rtv;
}
void RCPproblem::setResourceReleaseTime(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                        float releaseTime)
{
   //remember to negate this
	
	//std::string acquireOp = acquireResourceOperationName(jobRole);  Still need to model this
  //  float * rtv = floatToFloatStar(releaseTime);
  //  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,rtv);   Still need to model this
  //delete [] rtv;
}
d973 1
a973 33
void RCPproblem::setResourceReleaseCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName,
                                        float releaseCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,locName); 
  float * rcv = floatToFloatStar(releaseCost);
  witSetPartObj1ScrapCost(witRun(),benchOp.c_str(),rcv);
  delete [] rcv;
}
void RCPproblem::setResourceReleaseCost(
                                        const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                        float releaseCost)
{
  std::string benchOp = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry); 
  float * rcv = floatToFloatStar(releaseCost);
  witSetPartObj1ScrapCost(witRun(),benchOp.c_str(),rcv);
  delete [] rcv;
}
a1013 29
void RCPproblem::setResourceReasonableReleaseCost(const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & locName){

      std::vector<float> fixedCost = getResourceFixedCost(jobRole,skillSet,LOB,source,locName);
      float maximum = 0.0f;
      int t;
      for (t=0; t< fixedCost.size(); t++)
  	  if (fixedCost[t] > maximum) 
	    maximum = fixedCost[t];
      float reasonableReleaseCost = 2*getNPeriods()*maximum;
      setResourceReleaseCost(jobRole,skillSet,LOB,source,locName,reasonableReleaseCost);
    

}
void RCPproblem::setResourceReasonableReleaseCost(const std::string & jobRole, 
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry){
a1014 11
      std::vector<float> fixedCost = getResourceFixedCost(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
      float maximum = 0.0f;
      int t;
      for (t=0; t< fixedCost.size(); t++)
  	  if (fixedCost[t] > maximum) 
	    maximum = fixedCost[t];
      float reasonableReleaseCost = 2*getNPeriods()*maximum;
      setResourceReleaseCost(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry,reasonableReleaseCost);
    

}
@


1.147
log
@Removed old forms of:
  setResourceGapQuantity
@
text
@d491 1
a491 14
void RCPproblem::setResourceGlutQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float glutQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGlutAppData(period, glutQuantity);
}
d503 1
a503 21
void RCPproblem::setResourceGlutQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float glutQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGlutAppData(period, glutQuantity);
}
a599 39
void RCPproblem::setBenchResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float supplyQuantity)
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    benchRes,
    period, supplyQuantity );
}

void RCPproblem::setBenchResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & location,
                                           int period,
                                           float supplyQuantity)
{
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,location);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    benchRes,
    period, supplyQuantity );
}

a614 41
#if 0
void RCPproblem::setWorkingResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float supplyQuantity)
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    workingRes,
    period, supplyQuantity );
}

void RCPproblem::setWorkingResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & location,
                                           int period,
                                           float supplyQuantity)
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,location);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    workingRes,
    period, supplyQuantity );
}

#endif
a978 37
  float invacquireTime = -acquireTime; //offset should be negative so that
                                       //the resource is available after it's acquired
  float * atv = floatToFloatStar(invacquireTime);
  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv);
  delete [] atv;
}
void RCPproblem::setResourceAcquireTime(
                                        const std::string & jobRole,
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & location,
                                        float acquireTime)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,location);
  float invacquireTime = -acquireTime; //offset should be negative so that
                                       //the resource is available after it's acquired
  float * atv = floatToFloatStar(invacquireTime);
  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv);
  delete [] atv;
}
void RCPproblem::setResourceAcquireTime(
                                        const std::string & jobRole,
                                        const std::string & skillSet,
                                        const std::string & LOB,
                                        const std::string & source,
                                        const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                        float acquireTime)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
@


1.146
log
@Removed old forms of:
  setResourceReleaseQuantity,
  setResourceAcquireQuantity,
  setResourceBenchQuantity
@
text
@d441 2
a442 24
void RCPproblem::setResourceGapQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float gapQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGapAppData(period, gapQuantity);
}
void RCPproblem::setResourceGapQuantity(
                                           const std::vector<std::string> &resourceAttributeValues,
                                           int period,
                                           float gapQuantity)
{
    std::string workingRes = workingResourceName(resourceAttributeValues);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGapAppData(period, gapQuantity);
}
d445 3
a447 14
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float gapQuantity)
d449 4
a452 4
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setGapAppData(period, gapQuantity);
a453 2


d3710 1
a3710 1

d3713 14
a3726 14
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
       reportingUnits,bands,globals,competencies,industries;
    std::vector<RCPvectorString> names;

    int numRows;
    if (!isLongFormat()) {
      getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
      numRows = jobRoles.size();
    }
    else {
      getResourceNames(names);
      numRows = names.size();
    }

d3732 3
a3734 8
    if (!isLongFormat()){
      workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
      exogSup = getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    }
    else
      {workingRes = workingResourceName(names[r]);
      exogSup = getResourceSupplyQuantity(names[r]);
      }
d3738 1
a3738 1
			  workingRes,t,exogSup[t]);
d3754 7
a3760 7
	  // Get the number of subBOM arcs hanging off this BOM arc and scale each of them
	  int nSubBomArcs;
	  witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs);
	  int j;
	  for (j=0;j<nSubBomArcs;j++){
	    witSetSubsBomEntryMrpNetAllowed(witRun(),theEngagement.c_str(),i,j,WitTRUE);
	  } 
d3769 1
a3769 4
    if (!isLongFormat()) 
      workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    else
      workingRes = workingResourceName(names[r]);
d3773 2
a3774 8
      if (!isLongFormat()){
      setResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,gapQty[t]);      
      setResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,glutQty[t]);
      }
      else
	{setResourceGapQuantity(names[r],t,gapQty[t]);
	setResourceGlutQuantity(names[r],t,glutQty[t]);
	}
d3780 1
a3780 1

d3783 1
a3783 1

d3788 2
a3789 2
       reportingUnits,bands,globals,competencies,industries;
       
d3791 2
a3792 8
  if(!isLongFormat() ) {
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
    numRows = jobRoles.size();
  }
  else {
    getResourceNames(names);
    numRows = names.size();
  }
d3794 1
d3803 4
a3806 12
    if(!isLongFormat())
      {
	workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	exogSup = getResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	workingQty = getOptimalWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
      }
    else
      {
	workingRes = workingResourceName(names[r]);
	exogSup = getResourceSupplyQuantity(names[r]);
	workingQty = getResourceWorkingQuantity(names[r]);
      }
d3812 2
a3813 2
	gapQty.push_back(0.0f);
	glutQty.push_back(delta);
d3816 2
a3817 2
	gapQty.push_back(-delta);
	glutQty.push_back(0.0f);
d3819 2
a3820 10
      if(!isLongFormat())
	{
	  setResourceGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,gapQty[t]);      
	  setResourceGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,glutQty[t]);
	}
      else
	{
	  setResourceGapQuantity(names[r],t,gapQty[t]);      
	  setResourceGlutQuantity(names[r],t,glutQty[t]);
	}
@


1.145
log
@Removed setResourceWorkingQuantity
@
text
@a646 36
void RCPproblem::setResourceAcquireQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float acquireQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setAcquireAppData(period, acquireQuantity);
}

void RCPproblem::setResourceAcquireQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float acquireQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setAcquireAppData(period, acquireQuantity);
}
a655 36
void RCPproblem::setResourceReleaseQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float releaseQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setReleaseAppData(period, releaseQuantity);
}

void RCPproblem::setResourceReleaseQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float releaseQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setReleaseAppData(period, releaseQuantity);
}
a663 14
void RCPproblem::setResourceBenchQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float benchQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setBenchAppData(period, benchQuantity);
}
a664 21
void RCPproblem::setResourceBenchQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float benchQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setBenchAppData(period, benchQuantity);
}
@


1.144
log
@Removed dead code.
@
text
@a636 36
void RCPproblem::setResourceWorkingQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float workingQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setWorkingAppData(period, workingQuantity);
}

void RCPproblem::setResourceWorkingQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float workingQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setWorkingAppData(period, workingQuantity);
}
a4121 2
  std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries,cities,
       reportingUnits,bands,globals,competencies,industries;
d4125 3
a4127 17
  if (resourceIdentifierNames_.size()!=0) {
    // resource id names have been specified, so assume using general format
    getResourceNames(resNames);
    numRows = resNames.size();
  }
  else {
    if(!isLongFormat()) {
      getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
      numRows = jobRoles.size();
    }
    else {
      getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
        reportingUnits,bands,globals,competencies,industries);
      numRows = jobRoles.size();
    }
  }

d4131 18
a4148 55
    {
      std::string enableOpName, benchResName, acquireOpName;
      std::vector<float> workingQty, releaseQty, acquireQty, benchQty;
      if (resourceIdentifierNames_.size()!=0) {
        enableOpName=enableResourceOperationName(resNames[r]);
        benchResName=benchResourceName(resNames[r]);
        acquireOpName=acquireResourceOperationName(resNames[r]);
      }
      else if(!isLongFormat())
	{
	  enableOpName = enableResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	  benchResName = benchResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	  acquireOpName = acquireResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	}
      else
	{
	  enableOpName = enableResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
	  benchResName = benchResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
	  acquireOpName = acquireResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
	}
      workingQty = witGetNameAttribute(witGetOperationExecVol,enableOpName);
      releaseQty = witGetNameAttribute(witGetPartScrapVol,benchResName);
      acquireQty = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
      benchQty = witGetNameAttribute(witGetPartStockVol,benchResName);
      for ( int t=0; t<workingQty.size(); t++ ){
        
      if (resourceIdentifierNames_.size()!=0) {
	      setResourceWorkingQuantity(resNames[r],t,workingQty[t]);
	      setResourceReleaseQuantity(resNames[r],t,releaseQty[t]);
	      setResourceAcquireQuantity(resNames[r],t,acquireQty[t]);
	      setResourceBenchQuantity(resNames[r],t,benchQty[t]);
      }
	else if(!isLongFormat())
	  {
	  setResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,workingQty[t]);
	  setResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,releaseQty[t]);
	  setResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,acquireQty[t]);
	  setResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,benchQty[t]);
	  }
	else
	  {
	    setResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			       cities[r],reportingUnits[r],bands[r],globals[r],
			       competencies[r],industries[r],t,workingQty[t]);
	    setResourceReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			       cities[r],reportingUnits[r],bands[r],globals[r],
			       competencies[r],industries[r],t,releaseQty[t]);
	    setResourceAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			       cities[r],reportingUnits[r],bands[r],globals[r],
			       competencies[r],industries[r],t,acquireQty[t]);
	    setResourceBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			     cities[r],reportingUnits[r],bands[r],globals[r],
			     competencies[r],industries[r],t,benchQty[t]);
	  }
      }
d4150 1
@


1.143
log
@removing some extraneous formats and fixing some writing of output files
@
text
@a246 84
void RCPproblem::addResource(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source,  const std::string & locName)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);

  int np = getNPeriods();

  // Add parts and operations
  witAddOperation(witRun(),acquireOp.c_str());
  //witSetOperationSelForDel(witRun(),acquireOp.c_str(),WitTRUE);
  witAddPart(witRun(),benchRes.c_str(),WitMATERIAL);
  //  witSetPartSelForDel(witRun(),benchRes.c_str(),WitTRUE);
  witAddOperation(witRun(),enableOp.c_str());
  witAddPart(witRun(),workingRes.c_str(),WitCAPACITY);

  // Add appData for benchRes
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);

  // Add appData for working resource
  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),workingRes.c_str(),workingAppData);


  // connect parts and operations.
  witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str());
  // dpc --- test for MRP
  witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE);

  witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str());
  witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str());
  // This bop entry will be deleted when solving the priority resourceAction plan.
  witSetBopEntrySelForDel(witRun(),enableOp.c_str(),0,WitTRUE);
  // For MRP calculation and priorityPlan, set expAllowed to false;  doesn't impact optimalPlan
  witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE);  


  if (np>1){
    witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str());

    float * offsetVec = floatToFloatStar(-1.f);
    witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec);
    delete [] offsetVec;
    witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE);
    witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2);
  }


  std::string baseName = baseResourceName(jobRole,skillSet,LOB,source,locName);
  resourceNames_.insert(baseName);
  //jobToResourceNames_[jobRole].insert(baseName);
  //skillToResourceNames_[skillSet].insert(baseName);
  //lobToResourceNames_[LOB].insert(baseName);
  //sourceToResourceNames_[source].insert(baseName);
  //locToResourceNames_[locName].insert(baseName);
  resourceIdToResourceNames_["jobRole"][jobRole].insert(baseName);
  resourceIdToResourceNames_["skillSet"][skillSet].insert(baseName);
  resourceIdToResourceNames_["LOB"][LOB].insert(baseName);
  resourceIdToResourceNames_["source"][source].insert(baseName);
  resourceIdToResourceNames_["locName"][locName].insert(baseName);
}
void RCPproblem::addResource(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source,  const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, const std::string &band, const std::string & global, const std::string & competency, const std::string & industry)
{
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);

 int np = getNPeriods();
 // Add parts and operations
  witAddOperation(witRun(),acquireOp.c_str());
  witAddPart(witRun(),benchRes.c_str(),WitMATERIAL);
  witAddOperation(witRun(),enableOp.c_str());
  witAddPart(witRun(),workingRes.c_str(),WitCAPACITY);
  
  // Add appData for benchRes
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);

  // Add appData for working resource
  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),workingRes.c_str(),workingAppData);
a247 20
  

  // connect parts and operations.
  witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str());
  // dpc --- test for MRP
  witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE);

  witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str());
  witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str());


  if (np>1){
    witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str());

    float * offsetVec = floatToFloatStar(-1.f);
    witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec);
    delete [] offsetVec;
    witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE);
    witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2);
  }
a248 27
  std::string baseName = baseResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  resourceNames_.insert(baseName);
  //jobToResourceNames_[jobRole].insert(baseName);
  //skillToResourceNames_[skillSet].insert(baseName);
  //lobToResourceNames_[LOB].insert(baseName);
  //sourceToResourceNames_[source].insert(baseName);
  //regionToResourceNames_[region].insert(baseName);
  //countryToResourceNames_[country].insert(baseName);
  //cityToResourceNames_[city].insert(baseName);
  //reportingUnitToResourceNames_[reportingUnit].insert(baseName);
  //bandToResourceNames_[band].insert(baseName);
  //globalToResourceNames_[global].insert(baseName);
  //competencyToResourceNames_[competency].insert(baseName);
  //industryToResourceNames_[industry].insert(baseName);
  resourceIdToResourceNames_["jobRole"][jobRole].insert(baseName);
  resourceIdToResourceNames_["skillSet"][skillSet].insert(baseName);
  resourceIdToResourceNames_["LOB"][LOB].insert(baseName);
  resourceIdToResourceNames_["source"][source].insert(baseName);
  resourceIdToResourceNames_["region"][region].insert(baseName);
  resourceIdToResourceNames_["country"][country].insert(baseName);
  resourceIdToResourceNames_["city"][city].insert(baseName);
  resourceIdToResourceNames_["reportingUnit"][reportingUnit].insert(baseName);
  resourceIdToResourceNames_["band"][band].insert(baseName);
  resourceIdToResourceNames_["global"][global].insert(baseName);
  resourceIdToResourceNames_["competency"][competency].insert(baseName);
  resourceIdToResourceNames_["industry"][industry].insert(baseName);
}
a427 36
void RCPproblem::setResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float supplyQuantity)
{
    std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData);
    appData->setSupplyAppData(period, supplyQuantity);
}

void RCPproblem::setResourceSupplyQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float supplyQuantity)
{
    std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),benchRes.c_str(),(void**)&appData);
    appData->setSupplyAppData(period, supplyQuantity);
}
a438 14
void RCPproblem::setResourceMrpQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & locName,
                                           int period,
                                           float mrpGrossQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setMrpAppData(period, mrpGrossQuantity);
}
a439 21
void RCPproblem::setResourceMrpQuantity(
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry,
                                           int period,
                                           float mrpGrossQuantity)
{
    std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
    RCPresourceAppData * appData;
    witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData);
    appData->setMrpAppData(period, mrpGrossQuantity);
}
d4145 1
a4145 8
    if (resourceIdentifierNames_.size()!=0) {
      grossQty = getResourceMRPGrossQuantity(names[r]);
    }
    else if(!isLongFormat()) {
      grossQty = getResourceMRPGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
    }
    else
      grossQty = getResourceMRPGrossQuantity(names[r]);
d4148 1
a4148 7
      if (resourceIdentifierNames_.size()!=0) {
        setResourceMrpQuantity(names[r],t,grossQty[t]);
      }
      else if(!isLongFormat())
        setResourceMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,grossQty[t]);
      else
	      setResourceMrpQuantity(names[r],t,grossQty[t]);
@


1.142
log
@fixed prob_acquire testcase which was debugged by Dan
@
text
@a3660 2

      //DLG work on these
@


1.141
log
@Lots of changes to use new way of identifying resources
@
text
@d3371 3
d4399 1
a4399 1
  for ( r=0; r<jobRoles.size(); ++r ) 
d4404 2
a4405 2
        enableOpName=benchResourceName(resNames[r]);
        benchResName=enableResourceOperationName(resNames[r]);
d4767 1
a5706 3
#if 0

    THIS IS NOT WORKING JPF
d5723 1
a5723 1
#endif
@


1.140
log
@fixed "key" stuff in new gnrlBom file
@
text
@d450 2
d830 1
d876 9
d922 8
a973 1

d1314 1
d1516 10
d3374 1
d3376 7
a3382 1
  getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, resourceLocNames );
a3386 5
    const std::string & fromJobRole = jobRoles[b];
    const std::string & fromSkillSet = skillSets[b];
    const std::string & fromLob = LOBs[b];
    const std::string & fromSource = sources[b];
    const std::string & fromLocation = resourceLocNames[b];
d3388 20
a3407 3
    
    // Name of wit part connected to bomEntry
    std::string workingRes = workingResourceName(fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation);
d3430 15
d3446 1
d3448 2
a3449 2
      int subAllowed =      getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int jobRoleMatching = getBomJobRoleMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
d3482 1
d3491 27
d3556 1
d3559 1
a3559 1
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
d3562 1
a3562 1
        std::string subsWorkingRes = workingResourceName(toJobRole,toSkill,toLOB,toSource,toLocation);
d3655 1
d3679 2
a3680 1
        for (int i=0; i<getNumberResourceIdentifiers(); i++) {
d3705 1
d3707 1
a3707 1
        for (int i=0; i<getNumberResourceIdentifiers(); i++) {
d3718 2
d3778 36
d4184 1
a4184 1
  if(!isLongFormat()) {
d4338 1
a4338 7

  int numRows;
  if(!isLongFormat()) {
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
    numRows = jobRoles.size();
  }
  else {
d4340 1
a4340 2
 	numRows = names.size();
  }
d4346 4
a4349 1
    if(!isLongFormat()) {
d4356 5
a4360 2
      if(!isLongFormat())
	setResourceMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,grossQty[t]);
d4362 1
a4362 1
	setResourceMrpQuantity(names[r],t,grossQty[t]);
d4374 19
a4392 5
  if(!isLongFormat())
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions);
  else
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     reportingUnits,bands,globals,competencies,industries);
d4400 6
a4405 1
      if(!isLongFormat())
d4422 8
a4429 1
	if(!isLongFormat())
d4550 1
d5510 26
d5545 1
d5551 5
d5560 1
d5577 2
a5578 2
        "e1",
        "r2","s1","l1","LOB1","src1",
d5596 2
a5597 2
        "e1",
        "r1","s2","l1","LOB1","src1",
d5616 2
a5617 2
        "e1",
        "r2","s2","l1","LOB1","src1",
d5648 4
a5651 2
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l1");
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l1");
d5654 5
a5658 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l1");
d5661 5
a5665 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l1");
d5669 4
a5672 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l2");
d5675 5
a5679 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l2");
d5682 5
a5686 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l2");
d5703 4
d5708 13
a5720 3
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    assert(acquireQty[1]==2);
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d5722 1
d5747 6
a5752 1
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
d5756 4
a5759 1
    acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d5777 5
a5781 1
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
d5785 4
a5788 1
    acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
d5841 1
d5877 1
@


1.139
log
@Changed [sg]et[Gap,Glut]Quantity to [sg]etResource[Gap,Glut]ResourceQuantity
@
text
@a5722 2
  //DLG this test needs to be rewritten
#if 0
a5730 14
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,regions,countries, cities,bands,globals, competencies, industries, reportingUnits;
    prob_04Feb.getResourceNames(
             jobRoles, 
             skillSets, 
	         LOBs, 
	         sources,
             regions,
             countries,
             cities,
             reportingUnits,
             bands,
             globals,
             competencies,
             industries );
d5732 5
a5736 2
    std::vector<float> gapQty = prob_04Feb.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
    std::vector<float> glutQty = prob_04Feb.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
d5739 2
a5740 3

    gapQty = prob_04Feb.getResourceGapQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
    glutQty = prob_04Feb.getResourceGlutQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
a5746 1
#endif
@


1.138
log
@new tests for matching
@
text
@d594 1
a594 1
void RCPproblem::setMrpQuantity(
d604 1
a604 1
void RCPproblem::setMrpQuantity(
d619 1
a619 1
void RCPproblem::setMrpQuantity(
d641 1
a641 1
void RCPproblem::setGapQuantity(
d655 1
a655 1
void RCPproblem::setGapQuantity(
d666 1
a666 1
void RCPproblem::setGapQuantity(
d689 1
a689 1
std::vector<float> RCPproblem::getGapQuantity(
d703 1
a703 1
std::vector<float> RCPproblem::getGapQuantity(
d726 1
a726 1
void RCPproblem::setGlutQuantity(
d740 1
a740 1
void RCPproblem::setGlutQuantity(
d751 1
a751 1
void RCPproblem::setGlutQuantity(
d773 1
a773 1
std::vector<float> RCPproblem::getGlutQuantity(const std::vector<std::string> &resourceAttributeValues)const
d782 1
a782 1
std::vector<float> RCPproblem::getGapQuantity(const std::vector<std::string> &resourceAttributeValues)const
d792 1
a792 1
std::vector<float> RCPproblem::getGlutQuantity(
d806 1
a806 1
std::vector<float> RCPproblem::getGlutQuantity(
d828 9
a836 1
void RCPproblem::setWorkingQuantity(
d851 1
a851 1
void RCPproblem::setWorkingQuantity(
d873 1
a873 1
void RCPproblem::setAcquireQuantity(
d888 1
a888 1
void RCPproblem::setAcquireQuantity(
d910 1
a910 1
void RCPproblem::setReleaseQuantity(
d925 1
a925 1
void RCPproblem::setReleaseQuantity(
d947 9
a955 1
void RCPproblem::setBenchQuantity(
d970 1
a970 1
void RCPproblem::setBenchQuantity(
d1134 1
a1134 1
std::vector<float> RCPproblem::getMrpQuantity(
d1148 1
a1148 1
std::vector<float> RCPproblem::getMrpQuantity(
d1201 8
d1242 1
a1242 1
std::vector<float> RCPproblem::getMrpQuantity(
d1253 9
d1295 8
d1370 7
d1385 1
a1385 2
  std::vector<float> stockVol = witGetNameAttribute(witGetPartStockVol,benchRes);
  return stockVol;
d1387 1
d1400 2
a1401 1
                                           const std::string & industry )const{
d1403 1
a1403 2
  std::vector<float> stockVol = witGetNameAttribute(witGetPartStockVol,benchRes);
  return stockVol;
a1405 2


d3561 4
d4026 2
a4027 2
      setGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,gapQty[t]);      
      setGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,glutQty[t]);
d4030 2
a4031 2
	{setGapQuantity(names[r],t,gapQty[t]);
	setGlutQuantity(names[r],t,glutQty[t]);
d4092 2
a4093 2
	  setGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,gapQty[t]);      
	  setGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,glutQty[t]);
d4097 2
a4098 2
	  setGapQuantity(names[r],t,gapQty[t]);      
	  setGlutQuantity(names[r],t,glutQty[t]);
a4155 1
#if 1
a4166 1
#endif
d4226 1
a4226 1
	setMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,grossQty[t]);
d4228 1
a4228 1
	setMrpQuantity(names[r],t,grossQty[t]);
d4271 4
a4274 4
	  setWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,workingQty[t]);
	  setReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,releaseQty[t]);
	  setAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,acquireQty[t]);
	  setBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],t,benchQty[t]);
d4278 1
a4278 1
	    setWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
d4281 1
a4281 1
	    setReleaseQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
d4284 1
a4284 1
	    setAcquireQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
d4287 1
a4287 1
	    setBenchQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
a4468 8
std::string RCPproblem::enableExogenousResourceOperationName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "enableSup: "+baseResourceName(resourceAttributeVector);
}
std::string RCPproblem::exogenousResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
{
  return "exogRes: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
}
a5103 3
    //prob.setExogenousResourceSupplyQuantity(res2,2,sqOrig[2]);
    //sq = prob.getExogenousResourceSupplyQuantity(res2);

a5111 4

    //prob.setExogenousResourceSupplyQuantity(res2,0,sqOrig[0]);
    //sq = prob.getExogenousResourceSupplyQuantity(res2);

d5454 2
a5455 2
    std::vector<float> gapQty = prob_baseline.getGapQuantity("DetailA","s1","LOB1","src1","l1");
    std::vector<float> glutQty = prob_baseline.getGlutQuantity("DetailA","s1","LOB1","src1","l1");
d5458 2
a5459 2
    gapQty = prob_baseline.getGapQuantity("DetailB","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getGlutQuantity("DetailB","s1","LOB1","src1","l1");
d5462 2
a5463 2
    gapQty = prob_baseline.getGapQuantity("DetailC","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getGlutQuantity("DetailC","s1","LOB1","src1","l1");
d5467 2
a5468 2
    gapQty = prob_baseline.getGapQuantity("DetailA","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getGlutQuantity("DetailA","s1","LOB1","src1","l2");
d5471 2
a5472 2
    gapQty = prob_baseline.getGapQuantity("DetailB","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getGlutQuantity("DetailB","s1","LOB1","src1","l2");
d5475 2
a5476 2
    gapQty = prob_baseline.getGapQuantity("DetailC","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getGlutQuantity("DetailC","s1","LOB1","src1","l2");
d5614 2
a5615 2
    std::vector<float> gapQty = prob_simple.getGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    std::vector<float> glutQty = prob_simple.getGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
d5621 2
a5622 2
    gapQty = prob_simple.getGapQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    glutQty = prob_simple.getGlutQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
d5628 2
a5629 2
    gapQty = prob_simple.getGapQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    glutQty = prob_simple.getGlutQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
d5649 2
a5650 2
    std::vector<float> gapQty = prob.getGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getGlutQuantity(names[0]);
d5653 2
a5654 2
    gapQty = prob.getGapQuantity(names[1]);
    glutQty = prob.getGlutQuantity(names[1]);
d5657 2
a5658 2
    gapQty = prob.getGapQuantity(names[2]);
    glutQty = prob.getGlutQuantity(names[2]);
d5661 2
a5662 2
    gapQty = prob.getGapQuantity(names[3]);
    glutQty = prob.getGlutQuantity(names[3]);
d5677 2
a5678 2
    std::vector<float> gapQty = prob.getGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getGlutQuantity(names[0]);
d5681 2
a5682 2
    gapQty = prob.getGapQuantity(names[1]);
    glutQty = prob.getGlutQuantity(names[1]);
d5685 2
a5686 2
    gapQty = prob.getGapQuantity(names[2]);
    glutQty = prob.getGlutQuantity(names[2]);
d5689 2
a5690 2
    gapQty = prob.getGapQuantity(names[3]);
    glutQty = prob.getGlutQuantity(names[3]);
d5705 2
a5706 2
    std::vector<float> gapQty = prob.getGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getGlutQuantity(names[0]);
d5709 2
a5710 2
    gapQty = prob.getGapQuantity(names[1]);
    glutQty = prob.getGlutQuantity(names[1]);
d5713 2
a5714 2
    gapQty = prob.getGapQuantity(names[2]);
    glutQty = prob.getGlutQuantity(names[2]);
d5717 2
a5718 2
    gapQty = prob.getGapQuantity(names[3]);
    glutQty = prob.getGlutQuantity(names[3]);
d5748 2
a5749 2
    std::vector<float> gapQty = prob_04Feb.getGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
    std::vector<float> glutQty = prob_04Feb.getGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
d5753 2
a5754 2
    gapQty = prob_04Feb.getGapQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
    glutQty = prob_04Feb.getGlutQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
@


1.137
log
@fixed some errors in writing out the mrpO file
@
text
@d5603 86
@


1.136
log
@changes to do substitution properly for the new vector format
@
text
@d3486 1
a3486 1
  for ( b=0; b<resourceNames[0].size(); ++b ) {
d3918 1
a3918 1
      numRows = names[0].size();
d3966 1
a3966 1
  for ( r=0; r<jobRoles.size(); ++r ) {
d4005 1
a4005 1
    numRows = names[0].size();
d4084 1
a4084 1
    numRows = names[0].size();
d4163 1
a4163 1
 	numRows = names[0].size();
d4900 1
a4900 1
        numRows = names[0].size();
@


1.135
log
@using new methods in witsetsubsArcs04feb
@
text
@a3309 2
    // Does fromSkill appear in list of substitutes? If no, then just iterate
    //if ( resourceIdToSubs_["skillSet"].find(fromSkill)==resourceIdToSubs_["skillSet"].end() ) continue; 
a3339 2
        //removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,jobToResourceNames_,fromJobRole);
        //removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,resourceIdToResourceNames_["jobRole"],fromJobRole);
a3354 1
        //removeIneligibleResources(subsResources,subAllowed,locationSubs_,locToResourceNames_,fromLocation);
a3361 1
        //removeIneligibleResources(subsResources,subAllowed,lobSubs_,lobToResourceNames_,fromLob);
a3368 1
        //removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["source"],sourceToResourceNames_,fromSource);
a3393 3
          //jobRole was substituted
          //subsLeadTime = max( subsLeadTime , jobRoleSubs_[fromJobRole][toJobRole].getLeadTime() );
          //subsCost     = subsCost          + jobRoleSubs_[fromJobRole][toJobRole].getCost();
d3487 1
a3487 1
    const RCPvectorString & fromResourceIdValues = resourceNames[b];
d3491 1
a3491 1
    std::string workingRes = workingResourceName(fromResourceIdValues);
d3518 3
a3520 3
         std::string resourceValue = fromResourceIdValues.at(i);
         int subAllowed = getBomSub(engagementNames[b], fromResourceIdValues, period, resourceIdName);
         int matching = getBomMatch(engagementNames[b], fromResourceIdValues, period, resourceIdName);
a3522 2
           subsResources.erase(baseNameFromWorkingResourceName(workingRes));
     
a3523 76
      //int subAllowed =      getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry, period);
      //int jobRoleMatching = getBomJobRoleMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (jobRoleMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"jobRole",fromJobRole);
      //}
      
      // Does this bom allow skill substitution? 
      //subAllowed = getBomSkillSetSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int skillSetMatching = getBomSkillSetMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (skillSetMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"skillSet",fromSkillSet);
      //}
      
      // Does this bom allow region substitution? 
      //subAllowed = getBomRegionSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int regionMatching = getBomRegionMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (regionMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"region",fromRegion);
      //}
  
      // Does this bom allow country substitution? 
      //subAllowed = getBomCountrySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int countryMatching = getBomCountryMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (countryMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"country",fromCountry);
      //}
       // Does this bom allow city substitution? 
      //subAllowed = getBomCitySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int cityMatching = getBomCityMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (cityMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"city",fromCity);
      //}
       // Does this bom allow reportingunit substitution? 
      //subAllowed = getBomReportingUnitSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int reportingUnitMatching = getBomReportingUnitMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (reportingUnitMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"reportingUnit",fromReportingUnit);
      //}
       // Does this bom allow band substitution? 
      //subAllowed = getBomBandSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int bandMatching = getBomBandMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
     // if (bandMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"band",fromBand);
      //}
       // Does this bom allow global substitution? 
      //subAllowed = getBomGlobalSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int globalMatching = getBomGlobalMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (globalMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"global",fromGlobal);
      //}
       // Does this bom allow competency substitution? 
      //subAllowed = getBomCompetencySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int competencyMatching = getBomCompetencyMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (competencyMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"competency",fromCompetency);
      //}
       // Does this bom allow industry substitution? 
      //subAllowed = getBomIndustrySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int industryMatching = getBomIndustryMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (industryMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"industry",fromIndustry);
      //}
 
       // Does this bom allow lob substitution? 
      //subAllowed = getBomLobSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int lobMatching = getBomLobMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (lobMatching) {
       // removeIneligibleResources(subsResources,subAllowed,"LOB",fromLob);
      //}
      
      // Does this bom allow source substitution? 
      //subAllowed = getBomSourceSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //int sourceMatching = getBomSourceMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      //if (sourceMatching) {
        //removeIneligibleResources(subsResources,subAllowed,"source",fromSource);
      //}
a3528 3
      
      //DLG need to fix this
#if 0
d3531 2
d3534 15
a3548 12
        std::string toJobRole = jobRoleFromResourceName(subsResource);
        std::string toSkill   = skillSetFromResourceName(subsResource);
        std::string toRegion = regionFromResourceName(subsResource);
        std::string toCountry = countryFromResourceName(subsResource);
        std::string toCity = cityFromResourceName(subsResource);
        std::string toReportingUnit = reportingUnitFromResourceName(subsResource);
        std::string toBand = bandFromResourceName(subsResource);
        std::string toGlobal = globalFromResourceName(subsResource);
        std::string toCompetency = competencyFromResourceName(subsResource);
        std::string toIndustry = industryFromResourceName(subsResource);
        std::string toLOB = LOBFromResourceName(subsResource);
        std::string toSource = sourceFromResourceName(subsResource);
d3551 1
a3551 1
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toRegion,toCountry,toCity,toReportingUnit,toBand,toGlobal,toCompetency,toIndustry) );
a3557 2
        
        //DLG need to work on these
d3559 11
a3569 33
        if ( fromJobRole != toJobRole && jobRoleMatching==1 ) {
          //jobRole was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["jobRole"][fromJobRole][toJobRole].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["jobRole"][fromJobRole][toJobRole].getCost();
        }
        if ( fromSkillSet != toSkill && skillSetMatching==1 ) {
          //skill was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["skillSet"][fromSkillSet][toSkill].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["skillSet"][fromSkillSet][toSkill].getCost();
        }
        
        if ( fromRegion != toRegion && regionMatching==1 ) {
          //region was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["region"][fromRegion][toRegion].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["region"][fromRegion][toRegion].getCost();
        }
        
        if ( fromCountry != toCountry && countryMatching==1 ) {
          //country was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["country"][fromCountry][toCountry].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["country"][fromCountry][toCountry].getCost();
        }
        
        if ( fromCity != toCity && cityMatching==1 ) {
          //city was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["city"][fromCity][toCity].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["city"][fromCity][toCity].getCost();
        }
        
        if ( fromReportingUnit != toReportingUnit && reportingUnitMatching==1 ) {
          //reporting unit was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["reportingUnit"][fromReportingUnit][toReportingUnit].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["reportingUnit"][fromReportingUnit][toReportingUnit].getCost();
a3570 36
        
        if ( fromBand != toBand && bandMatching==1 ) {
          //band was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["band"][fromBand][toBand].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["band"][fromBand][toBand].getCost();
        }
        
        if ( fromGlobal != toGlobal && globalMatching==1 ) {
          //global was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["global"][fromGlobal][toGlobal].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["global"][fromGlobal][toGlobal].getCost();
        }
        
        if ( fromCompetency != toCompetency && competencyMatching==1 ) {
          //competency was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["competency"][fromCompetency][toCompetency].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["competency"][fromCompetency][toCompetency].getCost();
        }
        
        if ( fromIndustry != toIndustry && industryMatching==1 ) {
          //industry was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["industry"][fromIndustry][toIndustry].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["industry"][fromIndustry][toIndustry].getCost();
        }
        
        if ( fromLob != toLOB && lobMatching==1 ) {
          //lob was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["LOB"][fromLob][toLOB].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["LOB"][fromLob][toLOB].getCost();
        }
        if ( fromSource != toSource && sourceMatching==1 ) {
          //source was substituted
          subsLeadTime = max( subsLeadTime , resourceIdToSubs_["source"][fromSource][toSource].getLeadTime() );
          subsCost     = subsCost          + resourceIdToSubs_["source"][fromSource][toSource].getCost();
        }
        
d3572 2
a3573 2
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toRegion,toCountry,toCity,toReportingUnit,toBand,toGlobal,toCompetency,toIndustry) );
        
d3575 1
a3575 1
        std::string subsWorkingRes = workingResourceName(toJobRole,toSkill,toLOB,toSource,toRegion,toCountry,toCity,toReportingUnit,toBand,toGlobal,toCompetency,toIndustry);
d3584 1
a3584 1
   
d3587 2
a3588 1

d3621 1
a3621 2
      }  // end for subsResIt loop
  #endif           
a3624 1
  //#endif
@


1.134
log
@Changed [sg]et{Attribute}Quantity to [sg]etResource{Attribute}Quantity
Saved the Optimal Resource Action plans to the appData
Fixed a method that was for Acquire;  it had been setting another attribute
@
text
@d1359 1
a3489 3
  //std::vector<std::string> engagementNames, jobRoles, skillSets, LOBs, sources, regions,countries,cities,reportingUnits,bands,globals,competencies,industries;

  //getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, regions,countries,cities,reportingUnits,bands,globals,competencies,industries );
d3499 1
a3499 16
    //const std::string & fromJobRole = jobRoles[b];
    //const std::string & fromSkillSet = skillSets[b];
    //const std::string & fromLob = LOBs[b];
    //const std::string & fromSource = sources[b];
    //const std::string & fromRegion = regions[b];
    //const std::string & fromCountry = countries[b];
    //const std::string & fromCity = cities[b];
    //const std::string & fromReportingUnit = reportingUnits[b];
    //const std::string & fromBand = bands[b];
    //const std::string & fromGlobal = globals[b];
    //const std::string & fromCompetency = competencies[b];
    //const std::string & fromIndustry = industries[b];
    
    // Does fromSkill appear in list of substitutes? If no, then just iterate
    //if ( resourceIdToSubs_["skillSet"].find(fromSkill)==resourceIdToSubs_["skillSet"].end() ) continue; 
    
d3525 11
a3535 3
      // Does this bom allow jobRole substitution? 
      
      //DLG work on these
@


1.133
log
@implemented several resource methods to work with resourceAttributeValues as parameter.
updated RCPproblem test to use these new methods.
@
text
@d1152 1
a1152 1
std::vector<float> RCPproblem::getWorkingQuantity(
d1165 1
a1165 1
std::vector<float> RCPproblem::getWorkingQuantity(
d1185 1
a1185 1
std::vector<float> RCPproblem::getReleaseQuantity(
d1198 1
a1198 1
std::vector<float> RCPproblem::getReleaseQuantity(
d1228 1
a1228 1
std::vector<float> RCPproblem::getBenchQuantity(
d1242 1
a1242 1
std::vector<float> RCPproblem::getBenchQuantity(
d1262 1
a1262 1
std::vector<float> RCPproblem::getAcquireQuantity(
d1275 1
a1275 1
std::vector<float> RCPproblem::getAcquireQuantity(
a1357 56
std::vector<float> RCPproblem::getResourceReleaseQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string partName = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartScrapVol,partName);
}
std::vector<float> RCPproblem::getResourceReleaseQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string partName = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetPartScrapVol,partName);
}


std::vector<float> RCPproblem::getResourceAcquireQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string acquireRes = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationExecVol,acquireRes);
}
std::vector<float> RCPproblem::getResourceAcquireQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::string acquireRes = acquireResourceOperationName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  return witGetNameAttribute(witGetOperationExecVol,acquireRes);
}
d1614 1
a1623 2
  

a1641 2
  

a1656 1
  
d1658 1
a1675 1
  
d1677 1
d4214 1
@


1.132
log
@more work on the substitute stuff for vectors
@
text
@d237 2
a238 2
      std::string resourceID = getResourceIdentifier(i);
      std::string resourceValue = resourceAttributeVector.at(i);
a395 1
#ifdef JPF
a406 2

    std::vector<std::string> resourceIdValues;
d408 3
d415 1
a415 1
      std::string idValue = getResourceValue( longName, i );
d418 1
d425 1
a425 1
  return resourceIdentifiers->size();
d427 10
a436 2
std::string RCPproblem::getResourceIdentifier(int which)const {
   return resourceIdentifiers->at(which);
d438 11
a448 2
void RCPproblem::setResourceIdentifiers(std::vector<std::string> *identifiers){
     resourceIdentifiers = identifiers;
d450 14
a463 1
std::string RCPproblem::getResourceValue(const std::string &resourcename, int which)const
d468 1
a468 1
     std::string thisone = getResourceIdentifier(which);
d470 1
a470 1
     std::string nextone = getResourceIdentifier(which+1);
d475 1
a475 1
     std::string thisone = getResourceIdentifier(which);
a480 1
#endif
d1071 1
d1074 2
d1085 1
d1386 1
d1414 1
d1458 9
d1543 7
d1610 13
d1665 5
a1669 1

d1764 10
d1810 10
d1856 10
d1902 14
d2255 1
a2256 1
    std::vector<std::string> bomIdValues;
d2258 1
a2258 1
    const std::string engagementName = engagementFromLongBomName(*r);
d2261 1
a2261 7
    // loop once for each resourceId and add resourceIdValues to oneResouce
    int i;
    for ( i=0; i< getNumberResourceIdentifiers(); ++i ) {
      const std::string & longName = *r;
      std::string idValue = getResourceValue( longName, i );
      bomIdValues.push_back( idValue );
    }
d2338 19
d2380 21
d2431 1
a2431 3
void  RCPproblem::setBomSub(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period,
    int sub,
    const std::string & resourceIdName )
d2433 3
d2444 3
d2462 15
a2487 1

d2517 2
a2518 4
// Method for setting bomAppData match attributes.
void  RCPproblem::setBomMatch(const std::string & engName, const std::vector<std::string> &resourceAttributeValues, int period,
    int match,
    const std::string & resourceIdName )
d2520 3
d2526 1
a2526 1

d2531 2
d2547 14
d4599 1
a4599 1
std::string RCPproblem::benchResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d4601 2
a4602 1
  return "bench: " + baseResourceName(jobRole,skillSet,LOB,source,locName);
d4647 2
d4650 1
a4650 1
       std::string attributeName = getResourceIdentifier(i);
d4654 1
a4654 1
  std::string attributeName = getResourceIdentifier(numAttributes-1);
d4735 1
a4735 1
       retVal = retVal+getResourceIdentifier(i) + ": " + resourceAttributeValues.at(i) + " ";
d4737 1
a4737 1
  retVal = retVal + getResourceIdentifier(resourceAttributeValues.size()-1) + ": " + resourceAttributeValues.at(resourceAttributeValues.size()-1);
d4777 1
a4777 1
  std::string firstResourceID = getResourceIdentifier(0);
d4918 2
d4949 2
d4984 2
a4985 1
  
d5102 4
a5105 3
    if (!isLongFormat()) {
      getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
      numRows = jobRoles.size();
d5108 8
a5115 2
      getResourceNames(names);
      numRows = names[0].size();
d5120 3
a5122 1
      if (!isLongFormat())
d5209 27
d5237 2
a5238 3
    prob.addResource("r1","s1", "LOB1","src1","l1");  
    prob.addResource("r2","s2","LOB2","src2","l2");
    float time = prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1");
d5240 2
a5241 2
    prob.setResourceAcquireTime("r1","s1","LOB1","src1","l1", 2.f);
    assert ( prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1") == -2.f ); //note that we negate the
d5245 12
a5256 3
    assert( prob.getResourceAcquireCost("r1","s1","LOB1","src1","l1") == 0 );
    prob.setResourceAcquireCost("r1","s1","LOB1","src1","l1", 100.f);
    assert ( prob.getResourceAcquireCost("r1","s1","LOB1","src1","l1") == 100.f );
d5258 8
a5265 21
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    prob.getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    assert( jobRoles.size()==2 );
    assert( jobRoles[0]=="r1" || jobRoles[1]=="r1" );
    assert( jobRoles[1]=="r2" || jobRoles[1]=="r2" );

    assert( skillSets.size()==2 );
    assert( skillSets[0]=="s1" || skillSets[1]=="s1" );
    assert( skillSets[0]=="s2" || skillSets[1]=="s2" );

    assert( LOBs.size()==2 );
    assert( LOBs[0]=="LOB1" || LOBs[1]=="LOB1" );
    assert( LOBs[0]=="LOB2" || LOBs[1]=="LOB2" );

    assert( sources.size()==2 );
    assert( sources[0]=="src1" || sources[1]=="src1" );
    assert( sources[0]=="src2" || sources[1]=="src2" );

    assert( locNames.size()==2 );
    assert( locNames[0]=="l1" || locNames[1]=="l1" );
    assert( locNames[0]=="l2" || locNames[1]=="l2" );
d5268 1
a5268 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d5278 6
a5283 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","src2","l2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d5289 7
a5295 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","src2","l2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d5299 4
a5302 4
    prob.setResourceFixedCost("r1","s1","LOB1","src1","l1", 0, 1.0f);
    prob.setResourceFixedCost("r1","s1","LOB1","src1","l1", 1, 2.0f);
    prob.setResourceFixedCost("r1","s1","LOB1","src1","l1", 2, 3.0f);
    prob.setResourceFixedCost("r1","s1","LOB1","src1","l1", 3, 2.0f);
d5304 1
a5304 1
    std::vector<float> resourceCost = prob.getResourceFixedCost("r1","s1","LOB1","src1","l1");
d5311 2
a5312 2
    prob.setResourceReasonableReleaseCost("r1","s1","LOB1","src1","l1");
    assert( prob.getResourceReleaseCost("r1","s1","LOB1","src1","l1") == 24.0f);
d5322 24
a5345 2
    prob.addResource("r1","s1","LOB1","src1","l1");  
    prob.addResource("r2","s2","LOB2","src2","l1");
d5348 4
a5351 3
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,jobRoles,skillSets,LOBs,sources,resourceLocNames);
    assert( jobRoles.size()==0);
d5355 3
a5357 3
    assert( !prob.bomExists("e1","r1","s1","LOB1","src1","l1") );
    prob.addBom("e1","r1","s1","LOB1","src1","l1");
    assert( prob.bomExists("e1","r1","s1","LOB1","src1","l1") );
d5360 3
a5362 3
    assert( !prob.bomExists("e1","r2","s2","LOB2","src2","l1") );
    prob.addBom("e1","r2","s2","LOB2","src2","l1");
    assert( prob.bomExists("e1","r2","s2","LOB2","src2","l1") );
d5364 1
a5364 1
    prob.getBomNames(engagementNames,jobRoles,skillSets,LOBs,sources,resourceLocNames);
d5368 6
a5373 15
    assert( jobRoles.size()==2 );
    assert( jobRoles[0]=="r1" || jobRoles[1]=="r1" );
    assert( jobRoles[0]=="r2" || jobRoles[1]=="r2" );
    assert( skillSets.size()==2 );
    assert( skillSets[0]=="s1" || skillSets[1]=="s1" );
    assert( skillSets[0]=="s2" || skillSets[1]=="s2" );
    assert( LOBs.size()==2 );
    assert( LOBs[0]=="LOB1" || LOBs[1]=="LOB1" );
    assert( LOBs[0]=="LOB2" || LOBs[1]=="LOB2" );
    assert( sources.size()==2 );
    assert( sources[0]=="src1" || sources[1]=="src1" );
    assert( sources[0]=="src2" || sources[1]=="src2" );
    assert( resourceLocNames.size()==2 );
    assert( resourceLocNames[0]=="l1");
    assert( resourceLocNames[1]=="l1");
d5375 12
d5388 1
a5388 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
d5398 3
a5400 3
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
d5406 3
a5408 3
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","src2","l1");
d5413 17
a5429 17
    assert( prob.getBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLobMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0)==0 );
    
    prob.setBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLobMatch("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0,1);

    assert( prob.getBomJobRoleMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSkillSetMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLocationMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLobMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSourceMatch("e1","r2","s2","LOB2","src2","l1",0)==1 );
d5432 17
a5448 17
    assert( prob.getBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLocationSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomLobSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    assert( prob.getBomSourceSub("e1","r2","s2","LOB2","src2","l1",0)==0 );
    
    prob.setBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLocationSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomLobSub("e1","r2","s2","LOB2","src2","l1",0,1);
    prob.setBomSourceSub("e1","r2","s2","LOB2","src2","l1",0,1);

    assert( prob.getBomJobRoleSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSkillSetSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLocationSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomLobSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
    assert( prob.getBomSourceSub("e1","r2","s2","LOB2","src2","l1",0)==1 );
@


1.131
log
@Added bench, working, acquire and release quantities to the app data of the bench and working resources.  Also cleaned up the merge conflicts.
@
text
@d2284 12
d2353 12
a2376 1

@


1.130
log
@minor changes
@
text
@d258 1
d260 1
d280 2
d515 3
a517 4
void RCPproblem::setExogenousResourceSupplyQuantity(
                                           const std::vector<std::string> &resourceAttributeVector,
                                           int period,
                                           float supplyQuantity)
d519 1
a519 1
    std::string benchRes = benchResourceName(resourceAttributeVector);
d522 1
a522 1
    appData->setExogenousSupplyAppData(period, supplyQuantity);
d524 4
a527 1
void RCPproblem::setExogenousResourceSupplyQuantity(
d539 1
a539 1
    appData->setExogenousSupplyAppData(period, supplyQuantity);
d541 2
a542 1
void RCPproblem::setExogenousResourceSupplyQuantity(
d561 1
a561 1
    appData->setExogenousSupplyAppData(period, supplyQuantity);
d743 19
d798 150
d970 1
d972 5
a976 1
                                           const std::vector<std::string> &resourceAttributeVector,
d980 1
a980 1
  std::string benchRes = benchResourceName(resourceAttributeVector);
d986 4
d991 1
a991 5
                                           const std::string & jobRole,
					                       const std::string & skillSet,
					                       const std::string & LOB,
					                       const std::string & source,
                                           const std::string & location,
d995 1
a995 1
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,location);
d1002 1
a1002 1

d1025 1
d1041 1
d1043 7
d1060 3
a1062 1
  return witGetNameAttribute(witGetPartSupplyVol,benchRes);
d1078 4
a1081 2
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region, country, city, reportingUnit, band, global, competency, industry);
  return witGetNameAttribute(witGetPartSupplyVol,benchRes);
d1084 6
a1089 2
std::vector<float> RCPproblem::getExogenousResourceSupplyQuantity(
                                           const std::vector<std::string> &resourceAttributeValues)const 
d1091 1
a1091 1
  std::string benchRes = benchResourceName(resourceAttributeValues);
d1093 2
a1094 2
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getExogenousSupplyAppData());
d1097 2
a1098 1
std::vector<float> RCPproblem::getExogenousResourceSupplyQuantity(
d1103 8
a1110 1
                                           const std::string & locName)const
d1112 1
a1112 1
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
d1114 3
a1116 2
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getExogenousSupplyAppData());
d1118 11
d1130 2
a1131 1
std::vector<float> RCPproblem::getExogenousResourceSupplyQuantity(
d1145 1
a1145 1
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
d1147 3
a1149 2
  witGetPartAppData(mutableWitRun(),benchRes.c_str(),(void**)&appData);
  return(appData->getExogenousSupplyAppData());
d1151 31
d1193 2
a1194 1
std::vector<float> RCPproblem::getMrpQuantity(
d1204 23
a1226 1
  return(appData->getMrpAppData());
d1228 11
d1241 1
a1241 1
std::vector<float> RCPproblem::getMrpQuantity(
d1258 1
a1258 2
  return(appData->getMrpAppData());

d1267 2
a1268 1
std::vector<float> RCPproblem::getResourceWorkingQuantity(
d1278 1
a1278 1
std::vector<float> RCPproblem::getResourceWorkingQuantity(
d1295 1
a1295 1
std::vector<float> RCPproblem::getResourceBenchQuantity(
d1306 1
a1306 1
std::vector<float> RCPproblem::getResourceBenchQuantity(
a1888 119



std::vector<float> RCPproblem::getResourceGapQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::vector<float> gapQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,locName);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,locName);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>=0) gapQty.push_back(0.0f);
    else
      gapQty.push_back(-delta);
  }
  return(gapQty);
}
std::vector<float> RCPproblem::getResourceGapQuantity(
                                           const std::vector<std::string> &resourceAttributeValues)const
{
  std::vector<float> gapQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(resourceAttributeValues);
  std::vector<float> workingQty = getResourceWorkingQuantity(resourceAttributeValues);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>=0) gapQty.push_back(0.0f);
    else
      gapQty.push_back(-delta);
  }
  return(gapQty);
}
std::vector<float> RCPproblem::getResourceGapQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::vector<float> gapQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>=0) gapQty.push_back(0.0f);
    else
      gapQty.push_back(-delta);
  }
  return(gapQty);
}

std::vector<float> RCPproblem::getResourceGlutQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::vector<float> glutQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,locName);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,locName);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>0) glutQty.push_back(delta);
    else
      glutQty.push_back(0.0f);
  }
  return(glutQty);
}
std::vector<float> RCPproblem::getResourceGlutQuantity(
                                           const std::vector<std::string> &resourceAttributeVector)const
{
  std::vector<float> glutQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(resourceAttributeVector);
  std::vector<float> workingQty = getResourceWorkingQuantity(resourceAttributeVector);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>0) glutQty.push_back(delta);
    else
      glutQty.push_back(0.0f);
  }
  return(glutQty);
}
std::vector<float> RCPproblem::getResourceGlutQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & region,
                                           const std::string & country,
                                           const std::string & city,
                                           const std::string & reportingUnit,
                                           const std::string & band,
                                           const std::string & global,
                                           const std::string & competency,
                                           const std::string & industry)const
{
  std::vector<float> glutQty;
  std::vector<float> exogSup = getExogenousResourceSupplyQuantity(jobRole,skillSet,LOB,source,region, country, city, reportingUnit,band,global, competency, industry);
  std::vector<float> workingQty = getResourceWorkingQuantity(jobRole,skillSet,LOB,source,region, country, city, reportingUnit,band,global, competency, industry);
  for (int t=0; t<exogSup.size(); t++){
    float delta = exogSup[t] - workingQty[t];
    if (delta>0) glutQty.push_back(delta);
    else
      glutQty.push_back(0.0f);
  }
  return(glutQty);
}

d2039 1
d3938 1
a3938 1
      exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
d3942 1
a3942 1
      exogSup = getExogenousResourceSupplyQuantity(names[r]);
a3998 1
  // Hard coded for short format
d4029 2
a4030 2
	exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
	workingQty = getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
d4035 1
a4035 1
	exogSup = getExogenousResourceSupplyQuantity(names[r]);
d4063 8
d4112 1
a4112 1
    float offset = aov[0];
d4115 1
a4115 1
#if 0
d4117 1
a4117 1
    // and set the offset and latestPeriod  *** DPC:still need to account for the acquisition leadtime ****
d4119 1
a4119 1
    for (i=0; i<np; i++)
d4122 1
a4122 1
	float * vecOffset = floatToFloatStar((float) i);
d4124 1
a4124 1
	witSetBopEntryLatestPeriod(witRun(),acquireOp.c_str(),i+1,np-i);
d4133 1
a4133 1
      exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
d4135 1
a4135 1
      exogSup = getExogenousResourceSupplyQuantity(names[r]);
d4194 62
a4295 1
    {
d4297 2
a4298 6
    }
  else
    {
      witSetOptWithLotSizes(witRun(),WitTRUE); 
      witOptImplode(witRun());
    }
d5034 2
a5035 2
    prob.setExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2",2,sqOrig[2]);
    sq = prob.getExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d5041 2
a5042 2
    prob.setExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2",0,sqOrig[0]);
    sq = prob.getExogenousResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d5356 2
a5357 2
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l1");
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l1");
d5360 2
a5361 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l1");
d5364 2
a5365 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l1");
d5369 2
a5370 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","src1","l2");
d5373 2
a5374 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","src1","l2");
d5377 2
a5378 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","src1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","src1","l2");
d5510 1
d5516 2
a5517 2
    std::vector<float> gapQty = prob_simple.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
    std::vector<float> glutQty = prob_simple.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],resourceLocs[0]);
d5523 2
a5524 2
    gapQty = prob_simple.getResourceGapQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[1],skillSets[1],LOBs[1],sources[1],resourceLocs[1]);
d5530 2
a5531 2
    gapQty = prob_simple.getResourceGapQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
    glutQty = prob_simple.getResourceGlutQuantity(jobRoles[2],skillSets[2],LOBs[2],sources[2],resourceLocs[2]);
d5564 2
a5565 2
    std::vector<float> gapQty = prob_04Feb.getResourceGapQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
    std::vector<float> glutQty = prob_04Feb.getResourceGlutQuantity(jobRoles[0],skillSets[0],LOBs[0],sources[0],regions[0],countries[0],cities[0],reportingUnits[0],bands[0],globals[0],competencies[0],industries[0]);
d5569 2
a5570 2
    gapQty = prob_04Feb.getResourceGapQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
    glutQty = prob_04Feb.getResourceGlutQuantity(jobRoles[9],skillSets[9],LOBs[9],sources[9],regions[9],countries[9],cities[9],reportingUnits[9],bands[9],globals[9],competencies[9],industries[9]);
@


1.129
log
@few more places where vector format was needed
@
text
@d1935 1
a1935 1
                           const std::vector<std::string> &resourceAttributeValues)
d4292 1
a4292 1
std::string RCPproblem::bomName(const std::string & engagementName, const std::vector<std::string> &resourceAttributeValues)
@


1.128
log
@add gnrlBomFile.h, and a few other changes
@
text
@d3752 1
d3754 2
a3755 1
    if (!isLongFormat())
d3757 6
a3762 3
    else
      getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     reportingUnits,bands,globals,competencies,industries);
d3766 1
a3766 1
  for ( r=0; r<jobRoles.size(); ++r ) {
d3774 2
a3775 5
      {workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
						    reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
      exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
								      cities[r],reportingUnits[r],bands[r],globals[r],
								      competencies[r],industries[r]);
d3814 1
a3814 2
      workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
						    reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d3823 2
a3824 4
	{setGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
						    reportingUnits[r],bands[r],globals[r],competencies[r],industries[r],t,gapQty[t]);
	setGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
						    reportingUnits[r],bands[r],globals[r],competencies[r],industries[r],t,glutQty[t]);
d3908 1
d3911 3
a3913 1
  if(!isLongFormat())
d3915 6
a3920 3
  else
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     reportingUnits,bands,globals,competencies,industries);
d3923 1
a3923 1
  for ( r=0; r<jobRoles.size(); ++r ) {
d3932 2
a3933 5
	acquireOp = acquireResourceOperationName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],
							     countries[r],cities[r],reportingUnits[r],bands[r],globals[r],
							     competencies[r],industries[r]);
	workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
		     reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d3957 1
d3961 1
a3961 2
      exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
						       reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
@


1.127
log
@massive commit to handle vector resource descriptions.
substitution for the "long" format is NOT yet implemented.
tests need to be updated
@
text
@d376 1
a376 1
bool RCPproblem::resourceExists(const std::vector<std::string> &resourceAttributeVector)const //DLG 
d558 10
d1570 6
a3985 2
  //DLG need to free this
  std::vector<RCPvectorString> *names = new std::vector<RCPvectorString>;
d3987 3
d3992 1
d3995 2
a3996 3
    //getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     //reportingUnits,bands,globals,competencies,industries);
	getResourceNames(*names);
d4001 1
a4001 1
  for ( r=0; r<jobRoles.size(); ++r ) {
d4004 1
a4004 2
      //grossQty = getResourceMRPGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
      //grossQty = getResourceMRPGrossQuantity(names);
d4007 2
a4008 3
      grossQty = getResourceMRPGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
					     cities[r],reportingUnits[r],bands[r],globals[r],
					     competencies[r],industries[r]);
d4013 1
a4013 3
	setMrpQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
		       cities[r],reportingUnits[r],bands[r],globals[r],
		       competencies[r],industries[r],t,grossQty[t]);
@


1.126
log
@more vector support
@
text
@d183 64
d376 5
a380 1

d436 1
a436 1
     nextone = nextone + ": ";
d512 10
d608 10
d693 10
d785 11
d881 9
d924 9
d967 6
a972 1

d1085 9
d1340 15
d1610 14
d1668 14
d1754 11
d1826 33
d1917 11
d1951 8
d1960 16
d3160 1
a3160 1
  std::vector<std::string> engagementNames, jobRoles, skillSets, LOBs, sources, regions,countries,cities,reportingUnits,bands,globals,competencies,industries;
d3162 4
a3165 2
  getBomNames( engagementNames, jobRoles, skillSets, LOBs, sources, regions,countries,cities,reportingUnits,bands,globals,competencies,industries );
  
d3169 15
a3183 13
  for ( b=0; b<engagementNames.size(); ++b ) {
    const std::string & fromJobRole = jobRoles[b];
    const std::string & fromSkillSet = skillSets[b];
    const std::string & fromLob = LOBs[b];
    const std::string & fromSource = sources[b];
    const std::string & fromRegion = regions[b];
    const std::string & fromCountry = countries[b];
    const std::string & fromCity = cities[b];
    const std::string & fromReportingUnit = reportingUnits[b];
    const std::string & fromBand = bands[b];
    const std::string & fromGlobal = globals[b];
    const std::string & fromCompetency = competencies[b];
    const std::string & fromIndustry = industries[b];
d3189 1
a3189 1
    std::string workingRes = workingResourceName(fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion, fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry);
d3214 7
a3220 7
      int subAllowed =      getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry, period);
      int jobRoleMatching = getBomJobRoleMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (jobRoleMatching) {
        //removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,jobToResourceNames_,fromJobRole);
        //removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,resourceIdToResourceNames_["jobRole"],fromJobRole);
        removeIneligibleResources(subsResources,subAllowed,"jobRole",fromJobRole);
      }
d3223 5
a3227 6
      subAllowed = getBomSkillSetSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int skillSetMatching = getBomSkillSetMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (skillSetMatching) {
        //removeIneligibleResources(subsResources,subAllowed,skillSubs_,skillToResourceNames_,fromSkillSet);
        removeIneligibleResources(subsResources,subAllowed,"skillSet",fromSkillSet);
      }
d3230 5
a3234 6
      subAllowed = getBomRegionSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int regionMatching = getBomRegionMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (regionMatching) {
        //removeIneligibleResources(subsResources,subAllowed,regionSubs_,regionToResourceNames_,fromRegion);
        removeIneligibleResources(subsResources,subAllowed,"region",fromRegion);
      }
d3237 5
a3241 6
      subAllowed = getBomCountrySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int countryMatching = getBomCountryMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (countryMatching) {
        //removeIneligibleResources(subsResources,subAllowed,countrySubs_,countryToResourceNames_,fromCountry);
        removeIneligibleResources(subsResources,subAllowed,"country",fromCountry);
      }
d3243 5
a3247 6
      subAllowed = getBomCitySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int cityMatching = getBomCityMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (cityMatching) {
        //removeIneligibleResources(subsResources,subAllowed,citySubs_,cityToResourceNames_,fromCity);
        removeIneligibleResources(subsResources,subAllowed,"city",fromCity);
      }
d3249 5
a3253 6
      subAllowed = getBomReportingUnitSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int reportingUnitMatching = getBomReportingUnitMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (reportingUnitMatching) {
        //removeIneligibleResources(subsResources,subAllowed,reportingUnitSubs_,reportingUnitToResourceNames_,fromReportingUnit);
        removeIneligibleResources(subsResources,subAllowed,"reportingUnit",fromReportingUnit);
      }
d3255 5
a3259 6
      subAllowed = getBomBandSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int bandMatching = getBomBandMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (bandMatching) {
        //removeIneligibleResources(subsResources,subAllowed,bandSubs_,bandToResourceNames_,fromBand);
        removeIneligibleResources(subsResources,subAllowed,"band",fromBand);
      }
d3261 5
a3265 6
      subAllowed = getBomGlobalSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int globalMatching = getBomGlobalMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (globalMatching) {
        //removeIneligibleResources(subsResources,subAllowed,globalSubs_,globalToResourceNames_,fromGlobal);
        removeIneligibleResources(subsResources,subAllowed,"global",fromGlobal);
      }
d3267 5
a3271 6
      subAllowed = getBomCompetencySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int competencyMatching = getBomCompetencyMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (competencyMatching) {
        //removeIneligibleResources(subsResources,subAllowed,competencySubs_,competencyToResourceNames_,fromCompetency);
        removeIneligibleResources(subsResources,subAllowed,"competency",fromCompetency);
      }
d3273 5
a3277 6
      subAllowed = getBomIndustrySub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int industryMatching = getBomIndustryMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (industryMatching) {
        //removeIneligibleResources(subsResources,subAllowed,industrySubs_,industryToResourceNames_,fromIndustry);
        removeIneligibleResources(subsResources,subAllowed,"industry",fromIndustry);
      }
d3280 5
a3284 6
      subAllowed = getBomLobSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int lobMatching = getBomLobMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (lobMatching) {
        //removeIneligibleResources(subsResources,subAllowed,lobSubs_,lobToResourceNames_,fromLob);
        removeIneligibleResources(subsResources,subAllowed,"LOB",fromLob);
      }
d3287 5
a3291 6
      subAllowed = getBomSourceSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      int sourceMatching = getBomSourceMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
      if (sourceMatching) {
        //removeIneligibleResources(subsResources,subAllowed,sourceSubs_,sourceToResourceNames_,fromSource);
        removeIneligibleResources(subsResources,subAllowed,"source",fromSource);
      }
d3297 3
d3324 3
a3328 2
          //subsLeadTime = max( subsLeadTime , jobRoleSubs_[fromJobRole][toJobRole].getLeadTime() );
          //subsCost     = subsCost          + jobRoleSubs_[fromJobRole][toJobRole].getCost();
d3410 1
a3410 1
        
d3421 1
a3421 1
        
d3445 1
a3445 1
        
d3447 1
a3447 1
      
d3822 2
a3823 1

d3826 3
a3828 1
  if(!isLongFormat())
d3830 6
a3835 3
  else
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     reportingUnits,bands,globals,competencies,industries);
d3839 1
a3839 1
  for ( r=0; r<jobRoles.size(); ++r ) {
d3853 3
a3855 8
	workingRes = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
					 reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
	exogSup = getExogenousResourceSupplyQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
						     cities[r],reportingUnits[r],bands[r],globals[r],
						     competencies[r],industries[r]);
	workingQty = getResourceWorkingQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
						     cities[r],reportingUnits[r],bands[r],globals[r],
						     competencies[r],industries[r]);
d3876 2
a3877 6
	  setGapQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			 cities[r],reportingUnits[r],bands[r],globals[r],
			 competencies[r],industries[r],t,gapQty[t]);      
	  setGlutQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],
			  cities[r],reportingUnits[r],bands[r],globals[r],
			  competencies[r],industries[r],t,glutQty[t]);
a3881 1

d3969 5
a3973 1
  if(!isLongFormat())
d3975 6
a3980 3
  else
    getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		     reportingUnits,bands,globals,competencies,industries);
d3986 4
a3989 2
    if(!isLongFormat())
      grossQty = getResourceMRPGrossQuantity(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r]);
d4132 4
d4144 4
d4159 4
d4171 5
a4175 1
std::string RCPproblem::workingResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d4183 1
a4183 1
std::string RCPproblem::enableExogenousResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d4185 1
a4185 1
  return "enableSup: "+baseResourceName(jobRole,skillSet,LOB,source,locName);
d4191 14
d4277 9
d4321 1
a4321 1
std::string RCPproblem::engagementFromLongBomName(const std::string & bomName)
d4323 3
a4325 1
  return textBetween(bomName,"bom op: "," resource: ");
d4639 5
a4643 1
    if (!isLongFormat())
d4645 8
a4652 4
    else
      getResourceNames(jobRoles,skillSets,LOBs,sources,regions,countries,cities,
		       reportingUnits,bands,globals,competencies,industries);
    for ( r=0; r<jobRoles.size(); ++r ) { 
d4657 1
a4657 2
        resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],regions[r],countries[r],cities[r],
					   reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
d5292 2
d5330 1
@


1.125
log
@vector handling updaes
@
text
@d352 1
a352 1
  return resourceNames_.size();
@


1.124
log
@support for vector handling
@
text
@d357 3
@


1.123
log
@added gnrl method for getting resourceNames
@
text
@d350 1
a350 1
int RCPproblem::getNumberResources() const
d353 21
@


1.122
log
@changes tom bomAppData to use resourceIdName for sub
@
text
@d324 31
@


1.121
log
@changes tom bomAppData to use resourceIdName for matching
@
text
@d1780 1
d1793 1
a1793 1
  appData->setMatch(resourceIdName,sub);
d1807 1
a1807 1
  return appData->getMatch(resourceIdName);
d1820 1
a1820 1
  appData->setMatch(resourceIdName,sub);
d1834 57
d1893 1
d1895 1
a1895 1
#if 1
d1956 1
a1956 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"jobRole");
d1961 1
a1961 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"skillSet");
d1966 1
a1966 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"location");
d1971 1
a1971 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"lob");
d1976 1
a1976 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,"source");
d1981 1
a1981 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"jobRole");
d1985 1
a1985 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"skillSet");
d1989 1
a1989 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"location");
d1993 1
a1993 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"lob");
d1997 1
a1997 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,"source");
d2003 1
a2003 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setJobRoleSub);
d2008 1
a2008 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setSkillSetSub);
d2013 1
a2013 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setLocationSub);
d2018 1
a2018 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setLobSub);
d2023 1
a2023 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,&RCPbomAppData::setSourceSub);
d2028 1
a2028 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getJobRoleSub);
d2032 1
a2032 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSkillSetSub);
d2036 1
a2036 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLocationSub);
d2040 1
a2040 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLobSub);
d2044 1
a2044 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSourceSub);
d2053 1
a2053 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"jobRole");
d2058 1
a2058 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"skillSet");
d2063 1
a2063 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"region");
d2068 1
a2068 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"country");
d2073 1
a2073 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"city");
d2078 1
a2078 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"reportingUnit");
d2083 1
a2083 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"bandMatch");
d2088 1
a2088 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"global");
d2093 1
a2093 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"competency");
d2098 1
a2098 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"industry");
d2103 1
a2103 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"lob");
d2108 1
a2108 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,"source");
d2113 1
a2113 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"jobRole");
d2117 1
a2117 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"skillSet");
d2121 1
a2121 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"region");
d2125 1
a2125 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"country");
d2129 1
a2129 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"city");
d2133 1
a2133 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"reportingUnit");
d2137 1
a2137 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"band");
d2141 1
a2141 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"global");
d2145 1
a2145 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"competency");
d2149 1
a2149 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"industry");
d2153 1
a2153 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"lob");
d2157 1
a2157 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,"source");
d2163 1
a2163 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setJobRoleSub);
d2168 1
a2168 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setSkillSetSub);
d2173 1
a2173 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setRegionSub);
d2178 1
a2178 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setCountrySub);
d2183 1
a2183 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setCitySub);
d2188 1
a2188 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setReportingUnitSub);
d2193 1
a2193 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setBandSub);
d2198 1
a2198 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setGlobalSub);
d2203 1
a2203 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setCompetencySub);
d2208 1
a2208 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setIndustrySub);
d2213 1
a2213 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setLobSub);
d2218 1
a2218 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,sub,&RCPbomAppData::setSourceSub);
d2223 1
a2223 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getJobRoleSub);
d2227 1
a2227 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getSkillSetSub);
d2231 1
a2231 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getRegionSub);
d2235 1
a2235 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCountrySub);
d2239 1
a2239 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCitySub);
d2243 1
a2243 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getReportingUnitSub);
d2247 1
a2247 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getBandSub);
d2251 1
a2251 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getGlobalSub);
d2255 1
a2255 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCompetencySub);
d2259 1
a2259 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getIndustrySub);
d2263 1
a2263 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getLobSub);
d2267 1
a2267 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getSourceSub);
@


1.120
log
@removed declared but unused variables.
plugged memory leak.
@
text
@d1784 58
d1892 1
d1897 1
a1897 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setJobRoleMatch);
d1902 1
a1902 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setSkillSetMatch);
d1907 1
a1907 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setLocationMatch);
d1912 1
a1912 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setLobMatch);
d1917 1
a1917 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,&RCPbomAppData::setSourceMatch);
d1922 1
a1922 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getJobRoleMatch);
d1926 1
a1926 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSkillSetMatch);
d1930 1
a1930 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLocationMatch);
d1934 1
a1934 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getLobMatch);
d1938 1
a1938 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,&RCPbomAppData::getSourceMatch);
d1994 1
a1994 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setJobRoleMatch);
d1999 1
a1999 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setSkillSetMatch);
d2004 1
a2004 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setRegionMatch);
d2009 1
a2009 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setCountryMatch);
d2014 1
a2014 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setCityMatch);
d2019 1
a2019 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setReportingUnitMatch);
d2024 1
a2024 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setBandMatch);
d2029 1
a2029 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setGlobalMatch);
d2034 1
a2034 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setCompetencyMatch);
d2039 1
a2039 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setIndustryMatch);
d2044 1
a2044 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setLobMatch);
d2049 1
a2049 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,match,&RCPbomAppData::setSourceMatch);
d2054 1
a2054 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getJobRoleMatch);
d2058 1
a2058 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getSkillSetMatch);
d2062 1
a2062 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getRegionMatch);
d2066 1
a2066 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCountryMatch);
d2070 1
a2070 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCityMatch);
d2074 1
a2074 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getReportingUnitMatch);
d2078 1
a2078 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getBandMatch);
d2082 1
a2082 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getGlobalMatch);
d2086 1
a2086 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getCompetencyMatch);
d2090 1
a2090 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getIndustryMatch);
d2094 1
a2094 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getLobMatch);
d2098 1
a2098 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,region,country,city, reportingUnit, band, global, competency,industry,period,&RCPbomAppData::getSourceMatch);
@


1.119
log
@modifed member data item that had been declared mutable so that this was no longer necessary.
The mutable modifier was removed.
@
text
@d1043 1
a1043 1
      int numBOMentries, numBOPentries, numBOMentries1;
d1050 1
@


1.118
log
@Modified private methods that were called with parameter  resourceIdToResourceNames_["string"],
to just pass "string" as the parameter.
@
text
@d2365 5
a2369 1
  const RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
d2388 5
a2392 1
  const RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
a2431 1
  const RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
d2433 5
@


1.117
log
@Modified private methods that were called with parameter  resourceIdToSubs_["string"],
to just pass "string" as the parameter.
@
text
@a2455 1
                                           const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames,
d2460 1
d2565 1
a2565 1
        removeIneligibleResources(subsResources,subAllowed,"jobRole",resourceIdToResourceNames_["jobRole"],fromJobRole);
d2573 1
a2573 1
        removeIneligibleResources(subsResources,subAllowed,"skillSet",resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2581 1
a2581 1
        removeIneligibleResources(subsResources,subAllowed,"locName",resourceIdToResourceNames_["locName"],fromLocation);
d2589 1
a2589 1
        removeIneligibleResources(subsResources,subAllowed,"LOB",resourceIdToResourceNames_["LOB"],fromLob);
d2597 1
a2597 1
        removeIneligibleResources(subsResources,subAllowed,"source",resourceIdToResourceNames_["source"],fromSource);
d2766 1
a2766 1
        removeIneligibleResources(subsResources,subAllowed,"jobRole",resourceIdToResourceNames_["jobRole"],fromJobRole);
d2774 1
a2774 1
        removeIneligibleResources(subsResources,subAllowed,"skillSet",resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2782 1
a2782 1
        removeIneligibleResources(subsResources,subAllowed,"region",resourceIdToResourceNames_["region"],fromRegion);
d2790 1
a2790 1
        removeIneligibleResources(subsResources,subAllowed,"country",resourceIdToResourceNames_["country"],fromCountry);
d2797 1
a2797 1
        removeIneligibleResources(subsResources,subAllowed,"city",resourceIdToResourceNames_["city"],fromCity);
d2804 1
a2804 1
        removeIneligibleResources(subsResources,subAllowed,"reportingUnit",resourceIdToResourceNames_["reportingUnit"],fromReportingUnit);
d2811 1
a2811 1
        removeIneligibleResources(subsResources,subAllowed,"band",resourceIdToResourceNames_["band"],fromBand);
d2818 1
a2818 1
        removeIneligibleResources(subsResources,subAllowed,"global",resourceIdToResourceNames_["global"],fromGlobal);
d2825 1
a2825 1
        removeIneligibleResources(subsResources,subAllowed,"competency",resourceIdToResourceNames_["competency"],fromCompetency);
d2832 1
a2832 1
        removeIneligibleResources(subsResources,subAllowed,"industry",resourceIdToResourceNames_["industry"],fromIndustry);
d2840 1
a2840 1
        removeIneligibleResources(subsResources,subAllowed,"LOB",resourceIdToResourceNames_["LOB"],fromLob);
d2848 1
a2848 1
        removeIneligibleResources(subsResources,subAllowed,"source",resourceIdToResourceNames_["source"],fromSource);
@


1.116
log
@Modified private methods that were called with parameter  resourceIdToSubs_["string"],
to just pass "string" as the parameter.
@
text
@d2178 1
a2178 1
  getSubsNames(resourceIdToSubs_["jobRole"],fromJobRoles,toJobRoles);
d2217 1
a2217 1
  getSubsNames(resourceIdToSubs_["skillSet"],fromSkills,toSkills);
d2253 1
a2253 1
  getSubsNames(resourceIdToSubs_["locName"],fromLocations,toLocations);
d2289 1
a2289 1
  getSubsNames(resourceIdToSubs_["LOB"],fromLobs,toLobs);
d2325 1
a2325 1
  getSubsNames(resourceIdToSubs_["source"],fromSources,toSources);
d2379 1
a2379 1
void RCPproblem::getSubsNames(const RCPmapMapStringToSubs & subCollection, std::vector<std::string> & froms, std::vector<std::string> & tos)const
d2383 3
a2385 1
  
d2455 1
a2455 1
                                           const RCPmapMapStringToSubs & attributeSubs,
d2460 2
d2565 1
a2565 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["jobRole"],resourceIdToResourceNames_["jobRole"],fromJobRole);
d2573 1
a2573 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["skillSet"],resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2581 1
a2581 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["locName"],resourceIdToResourceNames_["locName"],fromLocation);
d2589 1
a2589 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["LOB"],resourceIdToResourceNames_["LOB"],fromLob);
d2597 1
a2597 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["source"],resourceIdToResourceNames_["source"],fromSource);
d2766 1
a2766 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["jobRole"],resourceIdToResourceNames_["jobRole"],fromJobRole);
d2774 1
a2774 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["skillSet"],resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2782 1
a2782 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["region"],resourceIdToResourceNames_["region"],fromRegion);
d2790 1
a2790 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["country"],resourceIdToResourceNames_["country"],fromCountry);
d2797 1
a2797 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["city"],resourceIdToResourceNames_["city"],fromCity);
d2804 1
a2804 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["reportingUnit"],resourceIdToResourceNames_["reportingUnit"],fromReportingUnit);
d2811 1
a2811 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["band"],resourceIdToResourceNames_["band"],fromBand);
d2818 1
a2818 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["global"],resourceIdToResourceNames_["global"],fromGlobal);
d2825 1
a2825 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["competency"],resourceIdToResourceNames_["competency"],fromCompetency);
d2832 1
a2832 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["industry"],resourceIdToResourceNames_["industry"],fromIndustry);
d2840 1
a2840 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["LOB"],resourceIdToResourceNames_["LOB"],fromLob);
d2848 1
a2848 1
        removeIneligibleResources(subsResources,subAllowed,resourceIdToSubs_["source"],resourceIdToResourceNames_["source"],fromSource);
@


1.115
log
@RCPproblem member data:
  jobRoleSubs_
  skillSubs_
  locationSubs_
  regionSubs_
  countrySubs_
  citySubs_
  reportingUnitSubs_
  bandSubs_
  globalSubs_
  competencySubs_
  industrySubs_
  lobSubs_
  sourceSubs_
was replaced with
  resourceIdToSubs_

The current mapping to the prior structures from the one new is:
  resourceIdToSubs_["jobRoll"] is jobRoleSubs_
  resourceIdToSubs_["skillSet"] is skillSubs_
  resourceIdToSubs_["locName"] is locationSubs_
  resourceIdToSubs_["region"] is regionSubs_
  resourceIdToSubs_["country"] is countrySubs_
  resourceIdToSubs_["city"] is citySubs_
  resourceIdToSubs_["reportingUnit"] is reportingUnitSubs_
  resourceIdToSubs_["band"] is bandSubs_
  resourceIdToSubs_["global"] is globalSubs_
  resourceIdToSubs_["competency"] is competencySubs_
  resourceIdToSubs_["industry"] is industrySubs_
  resourceIdToSubs_["LOB"] is lobSubs_
  resourceIdToSubs_["source"] is sourceSubs_
@
text
@d2157 1
a2157 1
  addSubs(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole);
d2162 1
a2162 1
  setSubsCost(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole,cost);
d2167 1
a2167 1
  setSubsLeadTime(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole,leadTime);
d2173 1
a2173 1
  return subsExists(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole);
d2184 1
a2184 1
  return getSubsCost(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole);
d2190 1
a2190 1
  return getSubsLeadTime(resourceIdToSubs_["jobRole"],fromJobRole,toJobRole);
d2200 1
a2200 1
  addSubs(resourceIdToSubs_["skillSet"],fromSkill,toSkill);
d2204 1
a2204 1
  setSubsCost(resourceIdToSubs_["skillSet"],fromSkill,toSkill,cost);
d2208 1
a2208 1
  setSubsLeadTime(resourceIdToSubs_["skillSet"],fromSkill,toSkill,leadTime);
d2213 1
a2213 1
  return subsExists(resourceIdToSubs_["skillSet"],fromSkill,toSkill);
d2222 1
a2222 1
  return getSubsCost(resourceIdToSubs_["skillSet"],fromSkill,toSkill);
d2227 1
a2227 1
  return getSubsLeadTime(resourceIdToSubs_["skillSet"],fromSkill,toSkill);
d2236 1
a2236 1
  addSubs(resourceIdToSubs_["locName"],fromLocation,toLocation);
d2240 1
a2240 1
  setSubsCost(resourceIdToSubs_["locName"],fromLocation,toLocation,cost);
d2244 1
a2244 1
  setSubsLeadTime(resourceIdToSubs_["locName"],fromLocation,toLocation,leadTime);
d2249 1
a2249 1
  return subsExists(resourceIdToSubs_["locName"],fromLocation,toLocation);
d2258 1
a2258 1
  return getSubsCost(resourceIdToSubs_["locName"],fromLocation,toLocation);
d2263 1
a2263 1
  return getSubsLeadTime(resourceIdToSubs_["locName"],fromLocation,toLocation);
d2272 1
a2272 1
  addSubs(resourceIdToSubs_["LOB"],fromLob,toLob);
d2276 1
a2276 1
  setSubsCost(resourceIdToSubs_["LOB"],fromLob,toLob,cost);
d2280 1
a2280 1
  setSubsLeadTime(resourceIdToSubs_["LOB"],fromLob,toLob,leadTime);
d2285 1
a2285 1
  return subsExists(resourceIdToSubs_["LOB"],fromLob,toLob);
d2294 1
a2294 1
  return getSubsCost(resourceIdToSubs_["LOB"],fromLob,toLob);
d2299 1
a2299 1
  return getSubsLeadTime(resourceIdToSubs_["LOB"],fromLob,toLob);
d2308 1
a2308 1
  addSubs(resourceIdToSubs_["source"],fromSource,toSource);
d2312 1
a2312 1
  setSubsCost(resourceIdToSubs_["source"],fromSource,toSource,cost);
d2316 1
a2316 1
  setSubsLeadTime(resourceIdToSubs_["source"],fromSource,toSource,leadTime);
d2321 1
a2321 1
  return subsExists(resourceIdToSubs_["source"],fromSource,toSource);
d2330 1
a2330 1
  return getSubsCost(resourceIdToSubs_["source"],fromSource,toSource);
d2335 1
a2335 1
  return getSubsLeadTime(resourceIdToSubs_["source"],fromSource,toSource);
d2343 1
a2343 1
void RCPproblem::addSubs(RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to )
d2345 2
a2346 1
  assert( !subsExists(subCollection,from,to) );
d2350 1
a2350 1
void RCPproblem::setSubsCost(RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to, float cost )
d2352 1
a2352 1
  RCPbaseSubs & subs = getSubs(subCollection,from,to);
d2355 1
a2355 1
void RCPproblem::setSubsLeadTime(RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to, float leadTime )
d2357 1
a2357 1
  RCPbaseSubs & subs = getSubs(subCollection,from,to);
d2361 1
a2361 1
bool RCPproblem::subsExists(const RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to )const
d2364 3
a2366 1
  
d2400 1
a2400 1
float RCPproblem::getSubsCost(const RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to )const
d2402 1
a2402 1
  const RCPbaseSubs & subs = getSubs(subCollection,from,to);
d2405 1
a2405 1
float RCPproblem::getSubsLeadTime(const RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to )const
d2407 1
a2407 1
  const RCPbaseSubs & subs = getSubs(subCollection,from,to);
d2412 1
a2412 1
RCPbaseSubs & RCPproblem::getSubs(RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to ) 
d2414 2
a2415 1
  assert( subsExists(subCollection,from,to) );
d2420 1
a2420 1
const RCPbaseSubs & RCPproblem::getSubs(const RCPmapMapStringToSubs & subCollection, const std::string & from, const std::string & to ) const
d2422 2
a2423 1
  assert( subsExists(subCollection,from,to) );
@


1.114
log
@Replaced RCPproblem member data
  jobToResourceNames_
  skillToResourceNames_
  lobToResourceNames_
  sourceToResourceNames_
  locToResourceNames_
  regionToResourceNames_
  countryToResourceNames_
  cityToResourceNames_
  reportingUnitToResourceNames_
  globalToResourceNames_
  competencyToResourceNames_
  industryToResourceNames_
  bandToResourceNames_
with the single strucure
  resourceIdToResourceNames_

To access what was in jobToResourceNames_ one uses resourceIdToResourceNames_["jobRole"].
To access what was in skillToResourceNames_ one uses resourceIdToResourceNames_["skilSet"].
To access what was in lobToResourceNames_one uses resourceIdToResourceNames_["LOB"].
To access what was in sourceToResourceNames_ one uses resourceIdToResourceNames_["source"].
To access what was in locToResourceNames_ one uses resourceIdToResourceNames_["locName"].
To access what was in regionToResourceNames_ one uses resourceIdToResourceNames_["region"].
To access what was in countryToResourceNames_ one uses resourceIdToResourceNames_["country"].
To access what was in cityToResourceNames_ one uses resourceIdToResourceNames_["city"].
To access what was in reportingUnitToResourceNames_ one uses resourceIdToResourceNames_["reportingUnit"].
To access what was in globalToResourceNames_ one uses resourceIdToResourceNames_["global"].
To access what was in competencyToResourceNames_one uses resourceIdToResourceNames_["competency"].
To access what was in industryToResourceNames_one uses resourceIdToResourceNames_["industry"].
@
text
@d2156 2
a2157 1
  addSubs(jobRoleSubs_,fromJobRole,toJobRole);
d2161 2
a2162 1
  setSubsCost(jobRoleSubs_,fromJobRole,toJobRole,cost);
d2166 2
a2167 1
  setSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole,leadTime);
d2172 2
a2173 1
  return subsExists(jobRoleSubs_,fromJobRole,toJobRole);
d2177 2
a2178 1
  getSubsNames(jobRoleSubs_,fromJobRoles,toJobRoles);
d2183 2
a2184 1
  return getSubsCost(jobRoleSubs_,fromJobRole,toJobRole);
d2189 2
a2190 1
  return getSubsLeadTime(jobRoleSubs_,fromJobRole,toJobRole);
d2199 2
a2200 1
  addSubs(skillSubs_,fromSkill,toSkill);
d2204 1
a2204 1
  setSubsCost(skillSubs_,fromSkill,toSkill,cost);
d2208 1
a2208 1
  setSubsLeadTime(skillSubs_,fromSkill,toSkill,leadTime);
d2213 1
a2213 1
  return subsExists(skillSubs_,fromSkill,toSkill);
d2217 1
a2217 1
  getSubsNames(skillSubs_,fromSkills,toSkills);
d2222 1
a2222 1
  return getSubsCost(skillSubs_,fromSkill,toSkill);
d2227 1
a2227 1
  return getSubsLeadTime(skillSubs_,fromSkill,toSkill);
d2236 1
a2236 1
  addSubs(locationSubs_,fromLocation,toLocation);
d2240 1
a2240 1
  setSubsCost(locationSubs_,fromLocation,toLocation,cost);
d2244 1
a2244 1
  setSubsLeadTime(locationSubs_,fromLocation,toLocation,leadTime);
d2249 1
a2249 1
  return subsExists(locationSubs_,fromLocation,toLocation);
d2253 1
a2253 1
  getSubsNames(locationSubs_,fromLocations,toLocations);
d2258 1
a2258 1
  return getSubsCost(locationSubs_,fromLocation,toLocation);
d2263 1
a2263 1
  return getSubsLeadTime(locationSubs_,fromLocation,toLocation);
d2272 1
a2272 1
  addSubs(lobSubs_,fromLob,toLob);
d2276 1
a2276 1
  setSubsCost(lobSubs_,fromLob,toLob,cost);
d2280 1
a2280 1
  setSubsLeadTime(lobSubs_,fromLob,toLob,leadTime);
d2285 1
a2285 1
  return subsExists(lobSubs_,fromLob,toLob);
d2289 1
a2289 1
  getSubsNames(lobSubs_,fromLobs,toLobs);
d2294 1
a2294 1
  return getSubsCost(lobSubs_,fromLob,toLob);
d2299 1
a2299 1
  return getSubsLeadTime(lobSubs_,fromLob,toLob);
d2308 1
a2308 1
  addSubs(sourceSubs_,fromSource,toSource);
d2312 1
a2312 1
  setSubsCost(sourceSubs_,fromSource,toSource,cost);
d2316 1
a2316 1
  setSubsLeadTime(sourceSubs_,fromSource,toSource,leadTime);
d2321 1
a2321 1
  return subsExists(sourceSubs_,fromSource,toSource);
d2325 1
a2325 1
  getSubsNames(sourceSubs_,fromSources,toSources);
d2330 1
a2330 1
  return getSubsCost(sourceSubs_,fromSource,toSource);
d2335 1
a2335 1
  return getSubsLeadTime(sourceSubs_,fromSource,toSource);
d2343 1
a2343 1
void RCPproblem::addSubs(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )
d2349 1
a2349 1
void RCPproblem::setSubsCost(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to, float cost )
d2354 1
a2354 1
void RCPproblem::setSubsLeadTime(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to, float leadTime )
d2360 1
a2360 1
bool RCPproblem::subsExists(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
d2365 1
a2365 1
  std::map<std::string,RCPmapStringToSubs>::const_iterator itFrom = subCollection.find(from);
d2376 1
a2376 1
void RCPproblem::getSubsNames(const std::map<std::string,RCPmapStringToSubs> & subCollection, std::vector<std::string> & froms, std::vector<std::string> & tos)const
d2382 1
a2382 1
  std::map<std::string,RCPmapStringToSubs>::const_iterator itFrom;
d2397 1
a2397 1
float RCPproblem::getSubsCost(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
d2402 1
a2402 1
float RCPproblem::getSubsLeadTime(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to )const
d2409 1
a2409 1
RCPbaseSubs & RCPproblem::getSubs(std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to ) 
d2416 1
a2416 1
const RCPbaseSubs & RCPproblem::getSubs(const std::map<std::string,RCPmapStringToSubs> & subCollection, const std::string & from, const std::string & to ) const
d2448 1
a2448 1
                                           const std::map<std::string,RCPmapStringToSubs> & attributeSubs,
d2523 1
a2523 1
    //if ( skillSubs_.find(fromSkill)==skillSubs_.end() ) continue; 
d2555 2
a2556 1
        removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,resourceIdToResourceNames_["jobRole"],fromJobRole);
d2564 1
a2564 1
        removeIneligibleResources(subsResources,subAllowed,skillSubs_,resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2572 1
a2572 1
        removeIneligibleResources(subsResources,subAllowed,locationSubs_,resourceIdToResourceNames_["locName"],fromLocation);
d2580 1
a2580 1
        removeIneligibleResources(subsResources,subAllowed,lobSubs_,resourceIdToResourceNames_["LOB"],fromLob);
d2587 2
a2588 2
        //removeIneligibleResources(subsResources,subAllowed,sourceSubs_,sourceToResourceNames_,fromSource);
        removeIneligibleResources(subsResources,subAllowed,sourceSubs_,resourceIdToResourceNames_["source"],fromSource);
d2614 4
a2617 2
          subsLeadTime = max( subsLeadTime , jobRoleSubs_[fromJobRole][toJobRole].getLeadTime() );
          subsCost     = subsCost          + jobRoleSubs_[fromJobRole][toJobRole].getCost();
d2621 2
a2622 2
          subsLeadTime = max( subsLeadTime , skillSubs_[fromSkillSet][toSkill].getLeadTime() );
          subsCost     = subsCost          + skillSubs_[fromSkillSet][toSkill].getCost();
d2626 2
a2627 2
          subsLeadTime = max( subsLeadTime , locationSubs_[fromLocation][toLocation].getLeadTime() );
          subsCost     = subsCost          + locationSubs_[fromLocation][toLocation].getCost();
d2631 2
a2632 2
          subsLeadTime = max( subsLeadTime , lobSubs_[fromLob][toLOB].getLeadTime() );
          subsCost     = subsCost          + lobSubs_[fromLob][toLOB].getCost();
d2636 2
a2637 2
          subsLeadTime = max( subsLeadTime , sourceSubs_[fromSource][toSource].getLeadTime() );
          subsCost     = subsCost          + sourceSubs_[fromSource][toSource].getCost();
d2724 1
a2724 1
    //if ( skillSubs_.find(fromSkill)==skillSubs_.end() ) continue; 
d2756 2
a2757 1
        removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,resourceIdToResourceNames_["jobRole"],fromJobRole);
d2765 1
a2765 1
        removeIneligibleResources(subsResources,subAllowed,skillSubs_,resourceIdToResourceNames_["skillSet"],fromSkillSet);
d2773 1
a2773 1
        removeIneligibleResources(subsResources,subAllowed,regionSubs_,resourceIdToResourceNames_["region"],fromRegion);
d2781 1
a2781 1
        removeIneligibleResources(subsResources,subAllowed,countrySubs_,resourceIdToResourceNames_["country"],fromCountry);
d2788 1
a2788 1
        removeIneligibleResources(subsResources,subAllowed,citySubs_,resourceIdToResourceNames_["city"],fromCity);
d2795 1
a2795 1
        removeIneligibleResources(subsResources,subAllowed,reportingUnitSubs_,resourceIdToResourceNames_["reportingUnit"],fromReportingUnit);
d2802 1
a2802 1
        removeIneligibleResources(subsResources,subAllowed,bandSubs_,resourceIdToResourceNames_["band"],fromBand);
d2809 1
a2809 1
        removeIneligibleResources(subsResources,subAllowed,globalSubs_,resourceIdToResourceNames_["global"],fromGlobal);
d2816 1
a2816 1
        removeIneligibleResources(subsResources,subAllowed,competencySubs_,resourceIdToResourceNames_["competency"],fromCompetency);
d2823 1
a2823 1
        removeIneligibleResources(subsResources,subAllowed,industrySubs_,resourceIdToResourceNames_["industry"],fromIndustry);
d2831 1
a2831 1
        removeIneligibleResources(subsResources,subAllowed,lobSubs_,resourceIdToResourceNames_["LOB"],fromLob);
d2839 1
a2839 1
        removeIneligibleResources(subsResources,subAllowed,sourceSubs_,resourceIdToResourceNames_["source"],fromSource);
d2872 4
a2875 2
          subsLeadTime = max( subsLeadTime , jobRoleSubs_[fromJobRole][toJobRole].getLeadTime() );
          subsCost     = subsCost          + jobRoleSubs_[fromJobRole][toJobRole].getCost();
d2879 2
a2880 2
          subsLeadTime = max( subsLeadTime , skillSubs_[fromSkillSet][toSkill].getLeadTime() );
          subsCost     = subsCost          + skillSubs_[fromSkillSet][toSkill].getCost();
d2885 2
a2886 2
          subsLeadTime = max( subsLeadTime , regionSubs_[fromRegion][toRegion].getLeadTime() );
          subsCost     = subsCost          + regionSubs_[fromRegion][toRegion].getCost();
d2891 2
a2892 2
          subsLeadTime = max( subsLeadTime , countrySubs_[fromCountry][toCountry].getLeadTime() );
          subsCost     = subsCost          + countrySubs_[fromCountry][toCountry].getCost();
d2897 2
a2898 2
          subsLeadTime = max( subsLeadTime , citySubs_[fromCity][toCity].getLeadTime() );
          subsCost     = subsCost          + citySubs_[fromCity][toCity].getCost();
d2903 2
a2904 2
          subsLeadTime = max( subsLeadTime , reportingUnitSubs_[fromReportingUnit][toReportingUnit].getLeadTime() );
          subsCost     = subsCost          + reportingUnitSubs_[fromReportingUnit][toReportingUnit].getCost();
d2909 2
a2910 2
          subsLeadTime = max( subsLeadTime , bandSubs_[fromBand][toBand].getLeadTime() );
          subsCost     = subsCost          + bandSubs_[fromBand][toBand].getCost();
d2915 2
a2916 2
          subsLeadTime = max( subsLeadTime , globalSubs_[fromGlobal][toGlobal].getLeadTime() );
          subsCost     = subsCost          + globalSubs_[fromGlobal][toGlobal].getCost();
d2921 2
a2922 2
          subsLeadTime = max( subsLeadTime , competencySubs_[fromCompetency][toCompetency].getLeadTime() );
          subsCost     = subsCost          + competencySubs_[fromCompetency][toCompetency].getCost();
d2927 2
a2928 2
          subsLeadTime = max( subsLeadTime , industrySubs_[fromIndustry][toIndustry].getLeadTime() );
          subsCost     = subsCost          + industrySubs_[fromIndustry][toIndustry].getCost();
d2933 2
a2934 2
          subsLeadTime = max( subsLeadTime , lobSubs_[fromLob][toLOB].getLeadTime() );
          subsCost     = subsCost          + lobSubs_[fromLob][toLOB].getCost();
d2938 2
a2939 2
          subsLeadTime = max( subsLeadTime , sourceSubs_[fromSource][toSource].getLeadTime() );
          subsCost     = subsCost          + sourceSubs_[fromSource][toSource].getCost();
d3966 6
a3971 5
jobRoleSubs_(),
skillSubs_(),
locationSubs_(),
lobSubs_(),
sourceSubs_(),
d3995 6
a4000 5
jobRoleSubs_(),
skillSubs_(),
locationSubs_(),
lobSubs_(),
sourceSubs_(),
d4029 6
a4034 5
  jobRoleSubs_ = source.jobRoleSubs_;
  skillSubs_ = source.skillSubs_;
  locationSubs_ = source.locationSubs_;
  lobSubs_ = source.lobSubs_;
  sourceSubs_ = source.sourceSubs_;
@


1.113
log
@Commented out some test code for priority resourceAction that was breaking.  Need to adjust the latest period.  Step (2) of algorithm.
@
text
@d231 10
a240 5
  jobToResourceNames_[jobRole].insert(baseName);
  skillToResourceNames_[skillSet].insert(baseName);
  lobToResourceNames_[LOB].insert(baseName);
  sourceToResourceNames_[source].insert(baseName);
  locToResourceNames_[locName].insert(baseName);
d287 24
a310 12
  jobToResourceNames_[jobRole].insert(baseName);
  skillToResourceNames_[skillSet].insert(baseName);
  lobToResourceNames_[LOB].insert(baseName);
  sourceToResourceNames_[source].insert(baseName);
  regionToResourceNames_[region].insert(baseName);
  countryToResourceNames_[country].insert(baseName);
  cityToResourceNames_[city].insert(baseName);
  reportingUnitToResourceNames_[reportingUnit].insert(baseName);
  bandToResourceNames_[band].insert(baseName);
  globalToResourceNames_[global].insert(baseName);
  competencyToResourceNames_[competency].insert(baseName);
  industryToResourceNames_[industry].insert(baseName);
d2546 2
a2547 1
        removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,jobToResourceNames_,fromJobRole);
d2554 2
a2555 1
        removeIneligibleResources(subsResources,subAllowed,skillSubs_,skillToResourceNames_,fromSkillSet);
d2562 2
a2563 1
        removeIneligibleResources(subsResources,subAllowed,locationSubs_,locToResourceNames_,fromLocation);
d2570 2
a2571 1
        removeIneligibleResources(subsResources,subAllowed,lobSubs_,lobToResourceNames_,fromLob);
d2578 2
a2579 1
        removeIneligibleResources(subsResources,subAllowed,sourceSubs_,sourceToResourceNames_,fromSource);
d2744 2
a2745 1
        removeIneligibleResources(subsResources,subAllowed,jobRoleSubs_,jobToResourceNames_,fromJobRole);
d2752 2
a2753 1
        removeIneligibleResources(subsResources,subAllowed,skillSubs_,skillToResourceNames_,fromSkillSet);
d2760 2
a2761 1
        removeIneligibleResources(subsResources,subAllowed,regionSubs_,regionToResourceNames_,fromRegion);
d2768 2
a2769 1
        removeIneligibleResources(subsResources,subAllowed,countrySubs_,countryToResourceNames_,fromCountry);
d2775 2
a2776 1
        removeIneligibleResources(subsResources,subAllowed,citySubs_,cityToResourceNames_,fromCity);
d2782 2
a2783 1
        removeIneligibleResources(subsResources,subAllowed,reportingUnitSubs_,reportingUnitToResourceNames_,fromReportingUnit);
d2789 2
a2790 1
        removeIneligibleResources(subsResources,subAllowed,bandSubs_,bandToResourceNames_,fromBand);
d2796 2
a2797 1
        removeIneligibleResources(subsResources,subAllowed,globalSubs_,globalToResourceNames_,fromGlobal);
d2803 2
a2804 1
        removeIneligibleResources(subsResources,subAllowed,competencySubs_,competencyToResourceNames_,fromCompetency);
d2810 2
a2811 1
        removeIneligibleResources(subsResources,subAllowed,industrySubs_,industryToResourceNames_,fromIndustry);
d2818 2
a2819 1
        removeIneligibleResources(subsResources,subAllowed,lobSubs_,lobToResourceNames_,fromLob);
d2826 2
a2827 1
        removeIneligibleResources(subsResources,subAllowed,sourceSubs_,sourceToResourceNames_,fromSource);
d3957 6
a3962 6
jobToResourceNames_(),
skillToResourceNames_(),
lobToResourceNames_(),
sourceToResourceNames_(),
locToResourceNames_()

d3985 6
a3990 6
jobToResourceNames_(),
skillToResourceNames_(),
lobToResourceNames_(),
sourceToResourceNames_(),
locToResourceNames_()

d4018 6
a4023 5
  jobToResourceNames_ = source.jobToResourceNames_;
  skillToResourceNames_ = source.skillToResourceNames_;
  lobToResourceNames_ = source.lobToResourceNames_;
  sourceToResourceNames_ = source.sourceToResourceNames_;
  locToResourceNames_ = source.locToResourceNames_;
@


1.112
log
@improve "reasonableEngagementRevenue" computation to include bench costs rather than assuming them equal to 1.
@
text
@d3424 1
d3436 1
@


1.111
log
@Updated appl.mk for building rcpOptMain.  Changed the argument of rcpOpt to char const *.
@
text
@d1026 2
a1027 2
      int numBOMentries;
      char *partName;
d1031 2
d1034 1
d1039 1
a1039 1
            sum = sum + qty[j];
d3633 3
@


1.110
log
@changed the setting of the reward for engagements to be data-driven
@
text
@d1034 1
a1034 1
         int sum = 0;
@


1.109
log
@changed the engagement reward to be data-driven
@
text
@d4750 1
a4750 1
    //    assert(glutQty[0]==2);
d4754 1
a4754 1
    //    assert(gapQty[0]==2);
@


1.108
log
@Commented out some asserts.  We need to figure out what is the right value of the gap and glut.
@
text
@d1023 9
d1033 13
@


1.107
log
@Fixed some reporting issues with gaps and gluts.
@
text
@d4728 1
a4728 1
    assert(glutQty[0]==2);
d4732 1
a4732 1
    assert(gapQty[0]==2);
@


1.106
log
@more tests for new (expanded) format. Also fixed memory leak in appdata,
and moved the setting of global variables regarding format, algorithm, and
problem to populate (out of rcp.cpp)
@
text
@d244 1
a244 1
  int np = getNPeriods();
d357 12
a368 12
    jobRoles.push_back( jobRoleFromLongResourceName(*it) );
    skillSets.push_back( skillSetFromLongResourceName(*it) );
    LOBs.push_back( LOBFromLongResourceName(*it) );
    sources.push_back( sourceFromLongResourceName(*it) );
    regions.push_back( regionFromLongResourceName(*it) );
    countries.push_back( countryFromLongResourceName(*it) );
    cities.push_back( cityFromLongResourceName(*it) );
    reportingUnits.push_back( reportingUnitFromLongResourceName(*it) );
    bands.push_back( bandFromLongResourceName(*it) );
    globals.push_back( globalFromLongResourceName(*it) );
    competencies.push_back( competencyFromLongResourceName(*it) );
    industries.push_back( industryFromLongResourceName(*it) );
d1330 2
a1331 1
  return witGetNameAttribute(witGetPartReqVol,workingRes);
a2651 1
  
d2778 12
a2789 12
        std::string toJobRole = jobRoleFromLongResourceName(subsResource);
        std::string toSkill   = skillSetFromLongResourceName(subsResource);
        std::string toRegion = regionFromLongResourceName(subsResource);
        std::string toCountry = countryFromLongResourceName(subsResource);
        std::string toCity = cityFromLongResourceName(subsResource);
        std::string toReportingUnit = reportingUnitFromLongResourceName(subsResource);
        std::string toBand = bandFromLongResourceName(subsResource);
        std::string toGlobal = globalFromLongResourceName(subsResource);
        std::string toCompetency = competencyFromLongResourceName(subsResource);
        std::string toIndustry = industryFromLongResourceName(subsResource);
        std::string toLOB = LOBFromLongResourceName(subsResource);
        std::string toSource = sourceFromLongResourceName(subsResource);
d3331 1
d3358 79
d3459 1
a3459 1
    for ( int t=0; t<grossQty.size(); t++ )
d3464 1
a3464 1
					     cities[r],reportingUnits[r],bands[r],globals[r],
d3466 1
d3475 2
d3484 1
a3484 2
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
  witWriteData(witRun(),"wit.dat");
d3491 2
d3499 2
a3501 4
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");

  witWriteData(witRun(),"wit.dat");
}
d3505 1
a3505 1

a3506 2
  witSetOptWithLotSizes(witRun(),WitTRUE); 
  //  witSetMesgTimesPrint(witRun(), WitTRUE, WitINFORMATIONAL_MESSAGES,UCHAR_MAX);
d3509 9
a3517 1
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");
a3518 1
  witOptImplode(witRun());
d3520 1
d3523 1
a3523 1

a3524 1
  witSetOptWithLotSizes(witRun(),WitTRUE); 
d3527 11
a3537 2
  witSetMesgFileAccessMode(witRun(),WitTRUE,"w");

a3538 1
  witOptImplode(witRun());
d3644 1
a3644 1
  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " region: " +region + " country: " + country + " city: " + city + " rep: " + reportingUnit + " band: " + band + " global: "+ global + " comp: " + competency + " ind: " + industry;
a3795 48
std::string RCPproblem::jobRoleFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName,"resource: "," skillSet: ");
}
std::string RCPproblem::skillSetFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," skillSet: "," LOB: ");
}
std::string RCPproblem::LOBFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," LOB: "," source: ");
}
std::string RCPproblem::sourceFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," source: "," region: ");
}
std::string RCPproblem::regionFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," region: "," country: ");
}
std::string RCPproblem::countryFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," country: "," city: ");
}
std::string RCPproblem::cityFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," city: "," rep: ");
}
std::string RCPproblem::reportingUnitFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," rep: "," band: ");
}
std::string RCPproblem::bandFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," band: "," global: ");
}
std::string RCPproblem::globalFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," global: "," comp: ");
}
std::string RCPproblem::competencyFromLongResourceName(const std::string & bomName)
{
  return textBetween(bomName," comp: "," ind: ");
}
std::string RCPproblem::industryFromLongResourceName(const std::string & bomName)
{
  return textAfter(bomName," ind: ");
}
a4053 1
    //DLG need to figure out whether we've got the "long" or the "short" names here
d4060 1
a4060 1
		     reportingUnits,bands,globals,competencies,industries);
d4067 1
a4067 1
		     reportingUnits[r],bands[r],globals[r],competencies[r],industries[r]);
@


1.105
log
@fixed a number of problems with the new format
@
text
@d4008 18
a4025 9
    //int r;
    //std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    //getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    //for ( r=0; r<jobRoles.size(); ++r ) { 
      //std::string resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      //RCPresourceAppData * srcAppData;  
      //witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
      //delete srcAppData;
    //}
d4655 23
d4679 13
@


1.104
log
@error in addresource
@
text
@d357 12
a368 12
    jobRoles.push_back( jobRoleFromResourceName(*it) );
    skillSets.push_back( skillSetFromResourceName(*it) );
    LOBs.push_back( LOBFromResourceName(*it) );
    sources.push_back( sourceFromResourceName(*it) );
    regions.push_back( regionFromResourceName(*it) );
    countries.push_back( countryFromResourceName(*it) );
    cities.push_back( cityFromResourceName(*it) );
    reportingUnits.push_back( reportingUnitFromResourceName(*it) );
    bands.push_back( bandFromResourceName(*it) );
    globals.push_back( globalFromResourceName(*it) );
    competencies.push_back( competencyFromResourceName(*it) );
    industries.push_back( industryFromResourceName(*it) );
d2651 1
d2778 12
a2789 12
        std::string toJobRole = jobRoleFromResourceName(subsResource);
        std::string toSkill   = skillSetFromResourceName(subsResource);
        std::string toRegion = regionFromResourceName(subsResource);
        std::string toCountry = countryFromResourceName(subsResource);
        std::string toCity = cityFromResourceName(subsResource);
        std::string toReportingUnit = reportingUnitFromResourceName(subsResource);
        std::string toBand = bandFromResourceName(subsResource);
        std::string toGlobal = globalFromResourceName(subsResource);
        std::string toCompetency = competencyFromResourceName(subsResource);
        std::string toIndustry = industryFromResourceName(subsResource);
        std::string toLOB = LOBFromResourceName(subsResource);
        std::string toSource = sourceFromResourceName(subsResource);
d3549 1
a3549 1
  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +region + " in: " + country + " city: " + city + " repUnit: " + reportingUnit + " band: " + band + " global: "+ global + " comp: " + competency + " indus: " + industry;
d3701 48
d4007 10
a4016 9
    int r;
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    getResourceNames(jobRoles,skillSets,LOBs,sources,locNames);
    for ( r=0; r<jobRoles.size(); ++r ) { 
      std::string resourceName = workingResourceName(jobRoles[r],skillSets[r],LOBs[r],sources[r],locNames[r]);
      RCPresourceAppData * srcAppData;  
      witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
@


1.103
log
@The rcp program now reads the algorithm and problem and branches internally to the appropriate code for gapGlut or resourceAction (problem) and priorityPlan or optimalPlan (algorithm).
@
text
@d245 6
a250 1

d259 1
a259 5
  // Add parts and operations
  witAddOperation(witRun(),acquireOp.c_str());
  witAddPart(witRun(),benchRes.c_str(),WitMATERIAL);
  witAddOperation(witRun(),enableOp.c_str());
  witAddPart(witRun(),workingRes.c_str(),WitCAPACITY);
@


1.102
log
@fix to parsing of names, also made bom match resource file
@
text
@d190 2
d198 9
d214 3
a217 1
  int np = getNPeriods();
a227 3
  // Add appData for benchRes
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);
d244 10
d268 1
a268 1
  int np = getNPeriods();
a278 4
  // Add appData for benchRes
  RCPresourceAppData * benchAppData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),benchRes.c_str(),benchAppData);

d382 1
a382 1
    appData->setExogenousSupply(period, supplyQuantity);
d403 53
a455 1
    appData->setExogenousSupply(period, supplyQuantity);
d458 133
d612 2
a613 1
}void RCPproblem::setBenchResourceSupplyQuantity(
d629 41
d708 1
a708 1
  return(appData->getExogenousSupply());
d728 1
a728 1
  return(appData->getExogenousSupply());
d732 36
d1303 2
a1304 1
std::vector<float> RCPproblem::getResourceGrossQuantity(
d1311 2
a1312 2
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetOperationMrpExecVol,enableOp);
d1314 1
a1314 1
std::vector<float> RCPproblem::getResourceGrossQuantity(
d1328 2
a1329 2
  std::string enableOp = enableResourceOperationName(jobRole,skillSet,LOB,source,region, country,city,reportingUnit,band,global,competency, industry);
  return witGetNameAttribute(witGetOperationMrpExecVol,enableOp);
d1332 3
d2965 55
d3193 194
d3391 8
a3400 2
  witMrp(witRun());
  witOptImplode(witRun());
d3406 8
a3416 2
  witMrp(witRun());
  witOptImplode(witRun());
d3419 1
a3419 1
void RCPproblem::optimalPlan()
d3424 3
a3428 1
  witMrp(witRun());
d3431 1
a3431 1
void RCPproblem::optimalPlan04Feb()
d3436 2
a3440 1
  witMrp(witRun());
d3445 33
d4298 6
a4303 1
    prob_subs.optimalPlan();
d4450 1
a4450 1
    prob_acquire.optimalPlan();
d4472 1
a4472 1
    prob_delay.optimalPlan();
d4498 1
a4498 1
    prob_decline.optimalPlan();
d4519 1
a4519 1
    prob_IGS.optimalPlan();
d4553 1
a4553 1
    prob_IGS.optimalPlan();
d4568 1
a4568 1
    prob_simple.optimalPlan();
@


1.101
log
@yet more refinements for the new model.
@
text
@d2869 1
d2891 1
d3085 1
a3085 1
  return textBetween(bomName," source: "," at: ");
d3089 1
a3089 1
  return textBetween(bomName," at: "," country: ");
@


1.100
log
@more updates for extra fields. Not done yet though.
@
text
@d311 26
d338 16
d527 17
d555 17
d583 37
d639 23
a661 1
                                        const std::string & locName,
d664 1
a664 1
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
d687 22
d723 20
d761 24
d800 17
d818 1
d2364 1
a2364 2
  //DLG: when this is fixed up remove teh #if 0
#if 0
d2428 1
a2428 1
      //DLG need a bunch more: country, city, reportingunit,band,global,competency,industry
d2442 1
a2442 1
      subAllowed = getBomRegionSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,fromCountry, fromCity, fromReportingUnit, fromBand, fromGlobal, fromCompetency, fromIndustry,period);
d2463 1
a2463 1
        removeIneligibleResources(subsResources,subAllowed,competencySubs_,comptetencyToResourceNames_,fromCompetency);
d2526 45
a2570 3
          //location was substituted
          subsLeadTime = max( subsLeadTime , locationSubs_[fromRegion][toRegion].getLeadTime() );
          subsCost     = subsCost          + locationSubs_[fromRegion][toRegion].getCost();
d2572 1
a2572 1
        //DLG need more here: country,city,reportingunit,band,global,competency,industry
d2588 1
a2588 1
        std::string subsWorkingRes = workingResourceName(toJobRole,toSkill,toLOB,toSource,toRegion,toCountry,toCity,toReportingUnit,toBand,toGlobal,toCompetency,toIndusry);
d2601 1
a2601 1
//#ifndef NDEBUG
d2607 1
a2607 1
//#endif
d2638 1
a2638 1
  #endif
d2988 32
@


1.99
log
@more updates for the additional fields
@
text
@d2145 1
a2145 1
  //DLG: this all needs to be updated with new fields
d2154 7
d2166 1
a2166 1
    std::string workingRes = workingResourceName(fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion);
d2191 2
a2192 2
      int subAllowed =      getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,period);
      int jobRoleMatching = getBomJobRoleMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,period);
d2198 2
a2199 2
      subAllowed = getBomSkillSetSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,period);
      int skillSetMatching = getBomSkillSetMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromRegion,period);
d2204 5
a2208 5
      // Does this bom allow location substitution? 
      subAllowed = getBomLocationSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int locationMatching = getBomLocationMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      if (locationMatching) {
        removeIneligibleResources(subsResources,subAllowed,locationSubs_,locToResourceNames_,fromLocation);
d2210 47
a2256 4
      
      // Does this bom allow lob substitution? 
      subAllowed = getBomLobSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int lobMatching = getBomLobMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
d2262 2
a2263 2
      subAllowed = getBomSourceSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
      int sourceMatching = getBomSourceMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
d2277 8
a2284 1
        std::string toLocation = locationFromResourceName(subsResource);
d2289 1
a2289 1
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
d2306 2
a2307 1
        if ( fromLocation != toLocation && locationMatching==1 ) {
d2309 2
a2310 2
          subsLeadTime = max( subsLeadTime , locationSubs_[fromLocation][toLocation].getLeadTime() );
          subsCost     = subsCost          + locationSubs_[fromLocation][toLocation].getCost();
d2312 1
d2325 1
a2325 1
        assert( resourceExists(toJobRole,toSkill,toLOB,toSource,toLocation) );
d2328 1
a2328 1
        std::string subsWorkingRes = workingResourceName(toJobRole,toSkill,toLOB,toSource,toLocation);
d2340 1
a2340 1
//#endif
d2347 1
a2347 1

@


1.98
log
@couple fixes
@
text
@d227 1
a227 1
void RCPproblem::addResource(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source,  const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string & competency, const std::string & industry)
d284 1
a284 1
bool RCPproblem::resourceExists(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry)const
d335 1
a335 1
                                           int band,
d357 1
a357 1
                                           int band,
d404 1
a404 1
                                           int band,
d435 1
a435 1
                                           int band,
d466 1
a466 1
                                           int band,
d629 1
a629 1
                                      int band,
d670 1
a670 1
                                         int band,
d706 1
a706 1
                                         int band,
d728 1
a728 1
                                         int band,
d781 1
a781 1
                     int band,
d824 1
a824 1
                                           int band,
d860 1
a860 1
                                           int band,
d904 1
a904 1
                                           int band,
d940 1
a940 1
                                           int band,
d976 1
a976 1
                        int band,
d1037 1
a1037 1
                                     int band,
d1098 1
a1098 1
                           int band,
d1136 47
d1261 1
a1261 1
void  RCPproblem::setBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, int band, const std::string &global, const std::string & competency, const std::string & industry, int period,
d1276 1
a1276 1
int  RCPproblem::getBomSub(const std::string & engName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry, int period,
d1385 1
a1385 1
void  RCPproblem::setBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period,
d1390 1
a1390 1
void  RCPproblem::setBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1395 1
a1395 1
void  RCPproblem::setBomRegionMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1400 1
a1400 1
void  RCPproblem::setBomCountryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1405 1
a1405 1
void  RCPproblem::setBomCityMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1410 1
a1410 1
void  RCPproblem::setBomReportingUnitMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1415 1
a1415 1
void  RCPproblem::setBomBandMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1420 1
a1420 1
void  RCPproblem::setBomGlobalMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1425 1
a1425 1
void  RCPproblem::setBomCompetencyMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1430 1
a1430 1
void  RCPproblem::setBomIndustryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1435 1
a1435 1
void  RCPproblem::setBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1440 1
a1440 1
void  RCPproblem::setBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1446 1
a1446 1
int RCPproblem::getBomJobRoleMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1450 1
a1450 1
int RCPproblem::getBomSkillSetMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1454 1
a1454 1
int RCPproblem::getBomRegionMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1458 1
a1458 1
int RCPproblem::getBomCountryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1462 1
a1462 1
int RCPproblem::getBomCityMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1466 1
a1466 1
int RCPproblem::getBomReportingUnitMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1470 1
a1470 1
int RCPproblem::getBomBandMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1474 1
a1474 1
int RCPproblem::getBomGlobalMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1478 1
a1478 1
int RCPproblem::getBomCompetencyMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1482 1
a1482 1
int RCPproblem::getBomIndustryMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1486 1
a1486 1
int RCPproblem::getBomLobMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1490 1
a1490 1
int RCPproblem::getBomSourceMatch(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1495 1
a1495 1
void  RCPproblem::setBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period,
d1500 1
a1500 1
void  RCPproblem::setBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1505 1
a1505 1
void  RCPproblem::setBomRegionSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1510 1
a1510 1
void  RCPproblem::setBomCountrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1515 1
a1515 1
void  RCPproblem::setBomCitySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1520 1
a1520 1
void  RCPproblem::setBomReportingUnitSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1525 1
a1525 1
void  RCPproblem::setBomBandSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1530 1
a1530 1
void  RCPproblem::setBomGlobalSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1535 1
a1535 1
void  RCPproblem::setBomCompetencySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1540 1
a1540 1
void  RCPproblem::setBomIndustrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1545 1
a1545 1
void  RCPproblem::setBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1550 1
a1550 1
void  RCPproblem::setBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period, 
d1556 1
a1556 1
int RCPproblem::getBomJobRoleSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1560 1
a1560 1
int RCPproblem::getBomSkillSetSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1564 1
a1564 1
int RCPproblem::getBomRegionSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1568 1
a1568 1
int RCPproblem::getBomCountrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1572 1
a1572 1
int RCPproblem::getBomCitySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1576 1
a1576 1
int RCPproblem::getBomReportingUnitSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1580 1
a1580 1
int RCPproblem::getBomBandSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1584 1
a1584 1
int RCPproblem::getBomGlobalSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1588 1
a1588 1
int RCPproblem::getBomCompetencySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1592 1
a1592 1
int RCPproblem::getBomIndustrySub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1596 1
a1596 1
int RCPproblem::getBomLobSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d1600 1
a1600 1
int RCPproblem::getBomSourceSub(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string &competency, const std::string & industry, int period)
d2132 189
d2464 72
d2545 9
d2565 10
d2603 1
a2603 1
std::string RCPproblem::acquireResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry )
d2611 1
a2611 1
std::string RCPproblem::benchResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string &reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry )
d2619 1
a2619 1
std::string RCPproblem::enableResourceOperationName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string &country, const std::string &city, const std::string & reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry )
d2627 1
a2627 1
std::string RCPproblem::workingResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, int band, const std::string &global, const std::string &competency, const std::string &industry )
d2643 1
a2643 1
std::string RCPproblem::baseResourceName(const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string & competency, const std::string & industry )
d2645 2
a2646 3
  char bandstr[100];
  sprintf(bandstr,"%d", band);
  return "resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +region + " in: " + country + " city: " + city + " repUnit: " + reportingUnit + " band: " + bandstr + " global: "+ global + " comp: " + competency + " indus: " + industry;
d2709 1
a2709 1
std::string RCPproblem::bomNameLong(const std::string & engagementName, const std::string & jobRole, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & region, const std::string & country, const std::string & city, const std::string & reportingUnit, int band, const std::string & global, const std::string & competency, const std::string & industry)
d2711 2
a2712 3
  char bandstr[100];
  sprintf (bandstr,"%s", band);
  return "bom op: " + engagementName + " resource: " + jobRole + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source +" region: "+ region + " country: " + country + " city: " + city + " rep: " + reportingUnit + " band: " + bandstr + " global: " + global + " comp: " + competency + " ind: " + industry;
@


1.97
log
@new fields
@
text
@d2319 1
a2319 1
  printf(bandstr,"%d", band);
d2386 1
a2386 1
  printf (bandstr,"%s", band);
@


1.96
log
@more preparation for more complex input files
@
text
@d967 22
d1027 44
d1088 22
d1214 26
d1334 223
d2381 62
@


1.95
log
@preparation for new "complete" format (with more fields)
@
text
@d227 51
d284 5
d314 3
a316 3
					   const std::string & skillSet,
					   const std::string & LOB,
					   const std::string & source,
d326 21
d350 25
a374 4
					   const std::string & skillSet,
					   const std::string & LOB,
					   const std::string & source,
                                           const std::string & locName,
d378 1
a378 1
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
d385 1
a385 1
std::vector<float> RCPproblem::setBenchResourceSupplyQuantity(
d395 17
d426 20
d457 17
d620 26
d661 21
d697 21
d724 22
a745 1
                                         const std::string & locName) const 
d747 1
a747 1
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
d772 24
d815 17
d851 25
d895 25
d931 17
d1939 4
d1947 4
d1955 4
d1963 4
d1979 6
d2425 1
a2425 1
    std::vector<float> sq = prob.setBenchResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
@


1.94
log
@Added test cases for setting and getting the fixed cost and tested the setting of the reasonableReleaseCost.
@
text
@d1442 1
@


1.93
log
@added unittests for various of the new file iterators.
@
text
@a218 4
  
  RCPresourceAppData * appData = new RCPresourceAppData(np);
  witSetPartAppData(witRun(),workingRes.c_str(),appData);

a264 6
  //  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  //  witSetNameAttribute(
  //    witGetPartSupplyVol,witSetPartSupplyVol,
  //    exogRes,
  //    period, supplyQuantity );

a304 2
  //  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  //  return witGetNameAttribute(witGetPartSupplyVol,exogRes);
a464 2
  //  witSetOperationObj1ExecCost(witRun(),enableExogOp.c_str(),stockcost);
  //  witSetPartObj1ScrapCost(witRun(),exogRes.c_str(),stockcost);
d2075 11
a2085 1
    
d2087 2
@


1.92
log
@Fixed a problem with delete.  It needed to be a witFree.
@
text
@d437 2
a438 2
	if (fixedCost[t] > maximum) 
	  maximum = fixedCost[t];
@


1.91
log
@Added setResourceReasonableReleaseCost method that sets the release cost of the bench resource to 2*nPeriods*maximum_period_cost.  This method is invoked for the 04Jan formats, because we don't have data for the release cost.  The default wit scrapping cost is 0 and this isn't good for our rcp model.
@
text
@d479 1
a479 1
  delete [] stockcost;
@


1.90
log
@Changed the way the resource connected to the BOM is skipped over when adding substitutes.
It is now removed from the set of substitutes using stl set method erase.
@
text
@d427 15
d443 1
d454 1
a454 1
  return witGetNameAttribute(witGetOperationObj1ExecCost,benchRes);
d479 1
a479 1

d520 1
a520 1
  std::string acquireOp = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
d522 1
a522 1
  witGetPartObj1ScrapCost(mutableWitRun(),acquireOp.c_str(),&rcv);
d535 1
a535 1
  //  std::string acquireOp = acquireResourceOperationName(jobRole);
d537 1
a537 1
  //witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&rtv);
@


1.89
log
@more changes to substitute arc code to try to simplify and make more readable
@
text
@d1295 3
a1311 7
        //if this is actually just the original "from" request, we don't want to add a substitute arc
        if (!(fromJobRole.compare(toJobRole))&&
            !(fromSkillSet.compare(toSkill))&&
            !(fromLocation.compare(toLocation))&&
            !(fromLob.compare(toLOB))&&
            !(fromSource.compare(toSource))) continue;
        
d2289 2
a2290 1
      assert( subsRes.find( r1as1a ) != subsRes.end() );  
d2308 2
a2309 1
      assert( subsRes.find( r1as1a ) == subsRes.end() );   
d2327 2
a2328 1
      assert( subsRes.find( r1as1a ) == subsRes.end() );   
d2348 1
@


1.88
log
@Added presolveForGapGlut() to rcpProblem.  This sets the soft lower bounds for the gap/glut calculations.  I moved the witSetOptWithLotSizes() from the constructor of rcpProblem to the optimalPlan() method.
@
text
@d1155 7
a1161 15
//--------------------------------------------------------------------------
// This method performs a repetitive part of addSubsArcsToWitModel.
// It takes a setOfReources (the first parameter) and adds to it
// all resources that can substitute for a specific attribute (the 4th parameter). 
// It also must include the original "from" resource for that attribute.
// currentToResources: unionOfSubstitutableResources
// attributeSubs: jobRoleSubs_, skillSubs_, locationSubs_, lobSubs_, sourcesSubs_
// attributeToResourceNames: jobToResourceNames_, skillToResourceNames_, locToResourceNames_, lobToResourceNames, sourceToResourceNames_
// fromResourceAttribure: engagementNames[b],jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]
//--------------------------------------------------------------------------
void RCPproblem::unionOfToResources(
                                   RCPcollectionOfStrings & currentToResources,
                                   const std::map<std::string,RCPmapStringToSubs> & attributeSubs,
                                   const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames,
                                   const std::string & fromResourceAttribute )
d1164 38
a1201 13
  // This will be the set we build up
  RCPcollectionOfStrings unionSet;
  
  // I don't do this because we still want to handle the "from" resources.
  // Does fromAttribute appear in list of substitutes? If no, then just return
  //if ( attributeSubs.find(fromResourceAttribute)==attributeSubs.end() ) return; 
  
  // get toResources that can substitute for fromResources
  const RCPmapStringToSubs & toResources = attributeSubs.find(fromResourceAttribute)->second;
  
  // loop over each toResource creating a collection of all resources that have the toResource.
  RCPmapStringToSubs::const_iterator toResourcesIt;
  for ( toResourcesIt=toResources.begin(); toResourcesIt!=toResources.end(); ++toResourcesIt ) {
a1203 10
   
    //What is the "to" resource attribute?
    std::string toResourceAttribute = toResourcesIt->first;

    // If there aren't any resources with toSkill then there is nothing to do
    if ( attributeToResourceNames.find(toResourceAttribute)==attributeToResourceNames.end() ) continue;
    
     
    // Get set of all resources that have toAttribute
    const RCPcollectionOfStrings & resWithToAttributes = attributeToResourceNames.find(toResourceAttribute)->second;
d1205 7
a1211 9
    //take the union of these
    unionCollectionOfStrings(resWithToAttributes,resWithMatch,unionSet);

  } // end of for toSkillIt loop
  
  // Take the intersection of unionOrig and currentToResources storing result in intersectionSet
  RCPcollectionOfStrings intersectionSet;
  intersectionCollectionOfStrings(currentToResources,unionSet,intersectionSet);
  currentToResources=intersectionSet;
a1212 28

//--------------------------------------------------------------------------
// This method performs a repetitive part of addSubsArcsToWitModel.
// It takes a setOfReources (the first parameter) and intersects with it
// all resources whose attribute has a specified value.. 
// currentToResources: intesectionOfSubstitutableResources
// attributeToResourceNames: jobToResourceNames_, skillToResourceNames_, locToResourceNames_, lobToResourceNames, sourceToResourceNames_
// fromResourceAttribure: jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]
//------------------------------------------------------------------
void RCPproblem::intersectionOfToResources(
                                   RCPcollectionOfStrings & setOfResources,
                                   const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames,
                                   const std::string & fromResourceAttribute )
{  
  // Are there any resources with the attribute value? If no, then just return
  if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 

  // Get all resources whose attribute value matches
  const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
  
  // Intersect resourcse whose attribute matches with set passed into this method
  RCPcollectionOfStrings intersection;
  intersectionCollectionOfStrings(setOfResources,resWithMatch,intersection);
      
  // update set passed into this method with insection just computed
  setOfResources = intersection;
}

a1263 2
      
      //only do something if we care about this field
d1265 1
a1265 4
        if ( subAllowed != 0) 
           unionOfToResources(subsResources,jobRoleSubs_,jobToResourceNames_,fromJobRole);
        else 
          intersectionOfToResources(subsResources,jobToResourceNames_,fromJobRole);
d1272 1
a1272 4
         if ( subAllowed != 0 ) 
            unionOfToResources(subsResources,skillSubs_,skillToResourceNames_,fromSkillSet);
         else 
            intersectionOfToResources(subsResources,skillToResourceNames_,fromSkillSet);
d1279 1
a1279 4
         if ( subAllowed != 0 ) 
           unionOfToResources(subsResources,locationSubs_,locToResourceNames_,fromLocation);
         else 
           intersectionOfToResources(subsResources,locToResourceNames_,fromLocation);
d1286 1
a1286 4
         if ( subAllowed != 0 ) 
           unionOfToResources(subsResources,lobSubs_,lobToResourceNames_,fromLob);
         else 
           intersectionOfToResources(subsResources,lobToResourceNames_,fromLob);
d1293 1
a1293 4
         if ( subAllowed != 0 ) 
           unionOfToResources(subsResources,sourceSubs_,sourceToResourceNames_,fromSource);
         else
           intersectionOfToResources(subsResources,sourceToResourceNames_,fromSource);
@


1.87
log
@added more tests for gap/glut for the "simple" case
added incrementing of the current quantity of bom's and resources
@
text
@d1484 27
d1586 1
d1597 1
d1816 1
a1816 1
 witSetOptWithLotSizes(witRun(),WitTRUE); 
@


1.86
log
@remove populateSimple.h
@
text
@d323 1
d2533 24
@


1.85
log
@new version of populate, which calls specific versions of the populate routine
depending on which file format is specified in the global attribute file
@
text
@d27 1
a27 1
#include "populateRCPSimple.h"
@


1.84
log
@Removed the MRP branch of the model and put the exogenous supply in the bench resource's appData.
@
text
@d2529 1
a2529 1
    populateSimple(prob_simple, inputDirectory, outputDirectory);
@


1.83
log
@fixed some bugs in the simple file handling
@
text
@a188 2
  std::string enableExogOp = enableExogenousResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
a194 2
  witAddPart(witRun(),exogRes.c_str(),WitCAPACITY);
  witAddOperation(witRun(),enableExogOp.c_str());
a203 5
  witAddBomEntry(witRun(),enableExogOp.c_str(),exogRes.c_str());
  // Break this link for now
  //  witAddBopEntry(witRun(),enableExogOp.c_str(),workingRes.c_str());
  //  witSetBopEntryExpAversion(witRun(),enableExogOp.c_str(),0,-1);

d215 4
d269 10
a278 5
  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    exogRes,
    period, supplyQuantity );
d281 1
a281 1
void RCPproblem::setAcquireResourceSupplyQuantity(
d297 1
a297 2

std::vector<float> RCPproblem::getAcquireResourceSupplyQuantity(
d315 7
a321 2
  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartSupplyVol,exogRes);
a454 2
  std::string enableExogOp = enableExogenousResourceOperationName(jobRole,skillSet,LOB,source,locName);
  std::string exogRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
a585 10
std::vector<float> RCPproblem::getResourceResidualQuantity(
                                           const std::string & jobRole,
                                           const std::string & skillSet,
                                           const std::string & LOB,
                                           const std::string & source,
                                           const std::string & locName)const
{
  std::string supplyRes = exogenousResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartMrpResidualVol,supplyRes);
}
d2065 1
a2065 1
    std::vector<float> sq = prob.getAcquireResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
@


1.82
log
@comment populateSimple
@
text
@d2537 2
a2538 1
    //populateSimple(prob_simple, inputDirectory, outputDirectory);
d2540 1
a2540 1
    }
@


1.81
log
@initialize the match file iterator
@
text
@d2537 1
a2537 1
    populateSimple(prob_simple, inputDirectory, outputDirectory);
@


1.80
log
@preparing for handling "simple" format files. Not yet exercised in unitTest.
@
text
@d2537 1
a2537 1
    //populateSimple(prob_simple, inputDirectory, outputDirectory);
@


1.79
log
@moved the fixedCost from the resourceaction file to the resource file.
examle data files needed to be modified accordingly.
@
text
@d27 1
d1706 1
d1792 1
d1820 1
d2208 1
a2208 2

  // Test skillSubs
d2530 10
@


1.78
log
@Changed the interpretation of the resource supply to be "Ron's supply" and updated the code for that.  Also, compute gap/glut and print the result in the mrpO.csv file.
@
text
@d421 18
d445 1
d452 9
a460 6
  float * fcv = floatToFloatStar(fixedCost);
  witSetPartObj1StockCost(witRun(),benchOp.c_str(),fcv);
  witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),fcv);
  //  witSetOperationObj1ExecCost(witRun(),enableExogOp.c_str(),fcv);
  //  witSetPartObj1ScrapCost(witRun(),exogRes.c_str(),fcv);
  delete [] fcv;
d526 1
a526 14
float RCPproblem::getResourceFixedCost(
				       const std::string & jobRole,
				       const std::string & skillSet,
				       const std::string & LOB,
				       const std::string & source,
                                       const std::string & locName) const 
{
  std::string acquireOp = benchResourceName(jobRole,skillSet,LOB,source,locName);
  float * fcv;
  witGetPartObj1StockCost(mutableWitRun(),acquireOp.c_str(),&fcv);
  float returnVal = fcv[0];
  witFree(fcv);
  return returnVal;
}
@


1.77
log
@Some more work on simplifying substitution code
@
text
@d188 2
d196 2
d207 5
d264 17
a280 1
void RCPproblem::setResourceSupplyQuantity(
d296 2
a297 1
std::vector<float> RCPproblem::getResourceSupplyQuantity(
d308 10
d431 2
d436 2
d532 2
a533 2
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartMrpConsVol,benchRes);
d543 10
a552 5
  //  std::string acquireRes = acquireResourceOperationName(jobRole,skillSet,LOB,source,locName);
  //return witGetNameAttribute(witGetOperationMrpExecVol,acquireRes);
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartReqVol,benchRes);

d562 10
a571 2
  std::string benchRes = benchResourceName(jobRole,skillSet,LOB,source,locName);
  return witGetNameAttribute(witGetPartMrpExcessVol,benchRes);
d581 10
d592 1
a592 1
  return witGetNameAttribute(witGetPartMrpResidualVol,benchRes);
d1197 1
a1555 1
  
d1559 1
d1568 1
d1611 8
d2060 1
a2060 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d2070 2
a2071 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","src2","l2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
d2077 2
a2078 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","src2","l2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","src2","l2");
@


1.76
log
@Added resource appData
@
text
@d1215 1
a1215 2
      RCPcollectionOfStrings unionOfSubstitutableResources=resourceNames_;  //Done once per substitution possibility
      RCPcollectionOfStrings intersectionOfNonSubstitutableResources = resourceNames_;
a1217 2
      // If yes, then add resources with toJobRoles to unionOfSubstitutableResources
      // If no, then intesect with intersectionOfNonSubstitutableResources;
d1224 1
a1224 1
           unionOfToResources(unionOfSubstitutableResources,jobRoleSubs_,jobToResourceNames_,fromJobRole);
d1226 1
a1226 1
          intersectionOfToResources(intersectionOfNonSubstitutableResources,jobToResourceNames_,fromJobRole);
a1229 2
      // If yes, then add resources with toSkills to unionOfSubstitutableResources
      // If no, then intesect with intersectionOfNonSubstitutableResources;
d1234 1
a1234 1
            unionOfToResources(unionOfSubstitutableResources,skillSubs_,skillToResourceNames_,fromSkillSet);
d1236 1
a1236 1
            intersectionOfToResources(intersectionOfNonSubstitutableResources,skillToResourceNames_,fromSkillSet);
a1239 2
      // If yes, then add resources with toLocation to unionOfSubstitutableResources
      // If no, then intesect with intersectionOfNonSubstitutableResources;
d1244 1
a1244 1
           unionOfToResources(unionOfSubstitutableResources,locationSubs_,locToResourceNames_,fromLocation);
d1246 1
a1246 1
           intersectionOfToResources(intersectionOfNonSubstitutableResources,locToResourceNames_,fromLocation);
a1249 2
      // If yes, then add resources with toLob to unionOfSubstitutableResources
      // If no, then intesect with intersectionOfNonSubstitutableResources;
d1254 1
a1254 1
           unionOfToResources(unionOfSubstitutableResources,lobSubs_,lobToResourceNames_,fromLob);
d1256 1
a1256 1
           intersectionOfToResources(intersectionOfNonSubstitutableResources,lobToResourceNames_,fromLob);
a1259 2
      // If yes, then add resources with toSource to unionOfSubstitutableResources
      // If no, then intesect with intersectionOfNonSubstitutableResources;
d1264 1
a1264 1
           unionOfToResources(unionOfSubstitutableResources,sourceSubs_,sourceToResourceNames_,fromSource);
d1266 1
a1266 1
           intersectionOfToResources(intersectionOfNonSubstitutableResources,sourceToResourceNames_,fromSource);
a1267 5
      
      // Now take intesection of unionOfSubstitutableResources and intersectionOfNonSubstitutableResources 
      // to determine resources that can be substituted
      RCPcollectionOfStrings subsResources; 
      intersectionCollectionOfStrings(unionOfSubstitutableResources,intersectionOfNonSubstitutableResources,subsResources);
@


1.75
log
@Added static member functions to perform union and intersections. The hope is that this will allow the code to be more readable as compared to using the STL functions directly.
@
text
@d21 1
d214 4
d1821 15
d1875 13
@


1.74
log
@Updated example4 test to look at every bom and possible substitute
@
text
@d1064 20
d1128 1
a1128 2
    std::insert_iterator<RCPcollectionOfStrings> insert(unionSet, unionSet.begin());
    std::set_union(resWithToAttributes.begin(),resWithToAttributes.end(), resWithMatch.begin(), resWithMatch.end(), insert);
d1133 1
a1133 3
    
  std::insert_iterator<RCPcollectionOfStrings>  insert2(intersectionSet, intersectionSet.begin());
  std::set_intersection(currentToResources.begin(),currentToResources.end(), unionSet.begin(),unionSet.end(), insert2);
d1158 1
a1158 2
  std::insert_iterator<RCPcollectionOfStrings>  insert(intersection, intersection.begin());
  std::set_intersection(setOfResources.begin(),setOfResources.end(), resWithMatch.begin(),resWithMatch.end(), insert);
a1159 1

d1277 2
a1278 6
      RCPcollectionOfStrings subsResources;      
      std::insert_iterator<RCPcollectionOfStrings>  subsResourcesInsert(subsResources, subsResources.begin());
      std::set_intersection(
        unionOfSubstitutableResources.begin(),unionOfSubstitutableResources.end(), 
        intersectionOfNonSubstitutableResources.begin(),intersectionOfNonSubstitutableResources.end(), 
        subsResourcesInsert);
@


1.73
log
@Fixed problem with way name wit name of substutitue resource was computed
@
text
@d2164 1
d2167 88
d2256 1
a2256 3
    
    //I've changed the problem
    prob_subs.optimalPlan();
a2258 20

    // Get resources that are substituting for engagement: e1
    // and resource: "r1","s1","l1","LOB1","src1"
    RCPcollectionOfStrings subsRes;
    prob_subs.getSubsResources(
      "e1",
      "r1","s1","l1","LOB1","src1",
      subsRes);

    // Make sure resource is not substituting for self
    std::string r1s1 = RCPproblem::baseResourceName("r1","s1","LOB1","src1","l1");
    assert( subsRes.find( r1s1 ) == subsRes.end() );  

    // Assert that "r1","s2","LOB1","src1","l1" is not substituting
    std::string r1s2 = RCPproblem::baseResourceName("r1","s2","LOB1","src1","l1");
    assert( subsRes.find( r1s2 ) == subsRes.end() );   

    // Assert that "r1a","s1","LOB1","src1","l1" is not substituting
    std::string r1as1 = RCPproblem::baseResourceName("r1a","s1","LOB1","src1","l1");
    assert( subsRes.find( r1as1 ) != subsRes.end() );  
a2259 3
    // Assert that ("r1a","s1a","LOB1","src1","l1") is substituting
    std::string r1aS1a = RCPproblem::baseResourceName("r1a","s1a","LOB1","src1","l1");
    assert( subsRes.find( r1aS1a ) != subsRes.end() );
a2260 7
    // Assert that ("r2","s1a","LOB1","src1","l1") is not substituting
    std::string r2S1a = RCPproblem::baseResourceName("r2","s1a","LOB1","src1","l1");
    assert( subsRes.find( r2S1a ) == subsRes.end() );




@


1.72
log
@Added some code to facilitate testing of substitutes.
@
text
@d1320 2
a1321 2
        // Assert that the primary resource exists
        assert( resourceExists(fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation) );
d1324 1
a1324 1
        std::string subsWorkingRes = workingResourceName(fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation);
a2180 5
    // Assert that ("r1a","s1a","LOB1","src1","l1") does not substitute
    std::string r1aS1a = RCPproblem::baseResourceName("r1a","s1a","LOB1","src1","l1");
    assert( subsRes.find( r1aS1a ) == subsRes.end() );

    
d2183 1
a2183 1
    //assert( subsRes.find( r1s1 ) == subsRes.end() );  //COMMENTED BECAUSE ASSERT FAILS
d2185 1
a2185 1
    // Assert that "r1","s2","LOB1","src1","l1" is substituting
d2187 13
a2199 1
    //assert( subsRes.find( r1s2 ) != subsRes.end() );  //COMMENTED BECAUSE ASSERT FAILS
@


1.71
log
@removed unnecessary union in substitute code
@
text
@d600 1
d1375 42
d1572 4
d2172 25
a2196 1
 
@


1.70
log
@algorithm in globalAttr is now gapGlut or optimalPlan
The rcpProblem::solve method was removed.
Added methods rcpProblem::gapGlut and rcpProblem::optimalPlan
@
text
@a1078 3
  // The first thing we need to do is to populate the union with all those containing the
  // original "from" field
  const RCPcollectionOfStrings& origResources = attributeToResourceNames.find(fromResourceAttribute)->second;
a1110 5
  //do a union with the original set
  RCPcollectionOfStrings unionOrig;
  std::insert_iterator<RCPcollectionOfStrings> insert1(unionOrig, unionOrig.begin());
  std::set_union(unionSet.begin(), unionSet.end(), origResources.begin(), origResources.end(), insert1);
  //unionOrig=insert1;
d1115 1
a1115 1
  std::set_intersection(currentToResources.begin(),currentToResources.end(), unionOrig.begin(),unionOrig.end(), insert2);
d2117 3
@


1.69
log
@removed extraneous lines in substitute code, and added a test for example4
@
text
@d1382 1
a1382 2
//--------------------------------------------
void RCPproblem::solve()
d1453 12
d1466 1
a1468 1
  witMrp(witRun());
d2127 1
a2127 1
    prob_subs.solve();
d2139 1
a2139 1
    prob_baseline.solve(); 
d2177 1
a2177 1
    prob_acquire.solve();
d2199 1
a2199 1
    prob_delay.solve();
d2225 1
a2225 1
    prob_decline.solve();
d2246 1
a2246 1
    prob_IGS.solve();
d2280 1
a2280 1
    prob_IGS.solve();
@


1.68
log
@handle matching correctly
@
text
@a1266 6
      // Have not yet implemented substitution data for location, lob, & source.
      // So for now just do intersectionOfToResources.
      intersectionOfToResources(intersectionOfNonSubstitutableResources,locToResourceNames_,fromLocation);
      intersectionOfToResources(intersectionOfNonSubstitutableResources,lobToResourceNames_,fromLob);
      intersectionOfToResources(intersectionOfNonSubstitutableResources,sourceToResourceNames_,fromSource);
      
d2116 4
a2119 16
    //prob_subs.solve();
    //double obj = prob_subs.getObjValue();
    //assert( eq(obj,4750.0) );
    //assert(prob_subs.getEngagementExecuted("e1"));
    //assert(prob_subs.getEngagementExecuted("e2"));
    //std::vector<float> wq = prob_subs.getResourceWorkingQuantity("r1","s1","LOB1","src1","l1");
    //int t=0;
    //for (t=0; t<16; ++t)
     // assert(wq[t]==0.0f);
    //wq = prob_subs.getResourceWorkingQuantity("r1","s2","LOB1","src1","l1");
    //assert( wq[3]==0.f );
    //assert( wq[4]==10.f );
    //assert( wq[5]==11.f );
    //assert( wq[6]==10.f );
    //assert( wq[7]==0.f );

@


1.67
log
@changed the substitution logic
@
text
@d1210 4
a1213 1
      if ( subAllowed != 0) {
d1215 2
d1218 1
a1218 4
      else 
        if ( jobRoleMatching = 1 )
          intersectionOfToResources(intersectionOfNonSubstitutableResources,jobToResourceNames_,fromJobRole);

d1224 5
a1228 2
      if ( subAllowed != 0 ) {
        unionOfToResources(unionOfSubstitutableResources,skillSubs_,skillToResourceNames_,fromSkillSet);
d1230 1
a1230 4
      else 
        if ( skillSetMatching = 1 )
          intersectionOfToResources(intersectionOfNonSubstitutableResources,skillToResourceNames_,fromSkillSet);

d1236 5
a1240 2
      if ( subAllowed != 0 ) {
        unionOfToResources(unionOfSubstitutableResources,locationSubs_,locToResourceNames_,fromLocation);
d1242 1
a1242 4
      else 
        if ( locationMatching = 1 )
          intersectionOfToResources(intersectionOfNonSubstitutableResources,locToResourceNames_,fromLocation);

d1248 7
a1254 7
      if ( subAllowed != 0 ) {
        unionOfToResources(unionOfSubstitutableResources,lobSubs_,lobToResourceNames_,fromLob);
       }   
      else 
        if ( lobMatching = 1 )
          intersectionOfToResources(intersectionOfNonSubstitutableResources,lobToResourceNames_,fromLob);

d1260 5
a1264 2
      if ( subAllowed != 0 ) {
        unionOfToResources(unionOfSubstitutableResources,sourceSubs_,sourceToResourceNames_,fromSource);
d1266 1
a1266 4
      else
        if ( sourceMatching = 1 )
           intersectionOfToResources(intersectionOfNonSubstitutableResources,sourceToResourceNames_,fromSource);
 
@


1.66
log
@comment out asserts for example4 (since it's changed) and get
rid of extraneous data in resourceaction.csv
@
text
@d1067 1
d1079 8
d1088 1
a1088 1
  if ( attributeSubs.find(fromResourceAttribute)==attributeSubs.end() ) return; 
d1090 1
a1090 1
  // get toSkills that can substitute for fromSkills
d1093 1
a1093 1
  // loop over each toSkill creating a collection of all resources that have the toSkills.
d1096 4
d1101 1
a1101 1
    
d1105 1
d1109 12
a1120 4
    // Take the union of sets resWithToAttributes and retVal storing result in unionSet
    RCPcollectionOfStrings unionSet;
    std::insert_iterator<RCPcollectionOfStrings>  insert(unionSet, unionSet.begin());
    std::set_union(resWithToAttributes.begin(),resWithToAttributes.end(), currentToResources.begin(),currentToResources.end(), insert);
d1122 3
a1124 3
    // assign union set to retVal
    currentToResources = unionSet;
  } // end of for toSkillIt loop
d1150 1
d1202 1
a1202 1
      RCPcollectionOfStrings unionOfSubstitutableResources;
d1210 3
a1212 2
      if ( subAllowed != 0) 
        unionOfToResources(unionOfSubstitutableResources,jobRoleSubs_,jobToResourceNames_,fromJobRole);
d1216 1
a1216 2
      
      
d1222 1
a1222 1
      if ( subAllowed != 0 ) 
d1224 1
d1228 1
a1228 1
      
d1234 1
a1234 1
      if ( subAllowed != 0 ) 
d1236 1
d1240 1
a1240 1
      
d1246 1
a1246 1
      if ( subAllowed != 0 ) 
d1248 1
d1252 1
a1252 1
      
d1258 1
a1258 1
      if ( subAllowed != 0 ) 
d1260 1
d1264 1
a1264 1

d1293 7
d1332 1
a1332 1
        assert( resourceExists(fromJobRole,toSkill,fromLob,fromSource,fromLocation) );
d1335 1
a1335 1
        std::string subsWorkingRes = workingResourceName(fromJobRole,toSkill,fromLob,fromSource,fromLocation);
@


1.65
log
@updated example4 to test out substitutions.
Also fixed a couple copy/paste errors in rcpProblem.cpp
@
text
@d2084 4
a2087 2
    prob_subs.solve();
    double obj = prob_subs.getObjValue();
d2089 12
a2100 12
    assert(prob_subs.getEngagementExecuted("e1"));
    assert(prob_subs.getEngagementExecuted("e2"));
    std::vector<float> wq = prob_subs.getResourceWorkingQuantity("r1","s1","LOB1","src1","l1");
    int t=0;
    for (t=0; t<16; ++t)
      assert(wq[t]==0.0f);
    wq = prob_subs.getResourceWorkingQuantity("r1","s2","LOB1","src1","l1");
    assert( wq[3]==0.f );
    assert( wq[4]==10.f );
    assert( wq[5]==11.f );
    assert( wq[6]==10.f );
    assert( wq[7]==0.f );
@


1.64
log
@Added & to some function parameters to get Linux to recognize the right signature.
@
text
@d1187 1
a1187 1
      if ( subAllowed != 0 ) 
d1220 1
a1220 1
      int lobMatching = getBomLocationMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
d1231 1
a1231 1
      int sourceMatching = getBomLocationMatch(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
@


1.63
log
@Added code to use the Match flag when adding substitute arcs.
@
text
@d707 1
a707 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,RCPbomAppData::setJobRoleMatch);
d712 1
a712 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,RCPbomAppData::setSkillSetMatch);
d717 1
a717 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,RCPbomAppData::setLocationMatch);
d722 1
a722 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,RCPbomAppData::setLobMatch);
d727 1
a727 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,match,RCPbomAppData::setSourceMatch);
d732 1
a732 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getJobRoleMatch);
d736 1
a736 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getSkillSetMatch);
d740 1
a740 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getLocationMatch);
d744 1
a744 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getLobMatch);
d748 1
a748 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getSourceMatch);
@


1.62
log
@Changed some variable names and fixed some errors in addSubArc method
@
text
@d1185 2
a1186 1
      int subAllowed = getBomJobRoleSub(engagementNames[b],fromJobRole,fromSkillSet,fromLob,fromSource,fromLocation,period);
d1190 2
a1191 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,jobToResourceNames_,fromJobRole);
d1198 1
d1202 2
a1203 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,skillToResourceNames_,fromSkillSet);
d1209 1
d1213 2
a1214 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,locToResourceNames_,fromLocation);
d1220 1
d1224 2
a1225 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,lobToResourceNames_,fromLob);
d1231 1
d1234 3
a1236 2
      else 
        intersectionOfToResources(intersectionOfNonSubstitutableResources,sourceToResourceNames_,fromSource);
d1271 1
a1271 1
        if ( fromJobRole != toJobRole ) {
d1276 1
a1276 1
        if ( fromSkillSet != toSkill ) {
d1281 1
a1281 1
        if ( fromLocation != toLocation ) {
d1286 1
a1286 1
        if ( fromLob != toLOB ) {
d1291 1
a1291 1
        if ( fromSource != toSource ) {
@


1.61
log
@Added code to read and add substitute arcs for location, lob, and source
@
text
@d1111 1
a1111 1
// fromResourceAttribure: engagementNames[b],jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]
d1148 4
a1151 1
    //const std::string & fromSkill = skillSets[b];
d1157 1
a1157 1
    std::string workingRes = workingResourceName(jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);
d1185 1
a1185 1
      int subAllowed = getBomJobRoleSub(engagementNames[b],jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b],period);
d1187 1
a1187 1
        unionOfToResources(unionOfSubstitutableResources,jobRoleSubs_,jobToResourceNames_,jobRoles[b]);
d1189 1
a1189 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,jobToResourceNames_,jobRoles[b]);
d1195 1
a1195 1
      subAllowed = getBomSkillSetSub(engagementNames[b],jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b],period);
d1197 1
a1197 1
        unionOfToResources(unionOfSubstitutableResources,skillSubs_,skillToResourceNames_,skillSets[b]);
d1199 28
a1226 1
        intersectionOfToResources(intersectionOfNonSubstitutableResources,skillToResourceNames_,skillSets[b]);
d1230 3
a1232 3
      intersectionOfToResources(intersectionOfNonSubstitutableResources,locToResourceNames_,resourceLocNames[b]);
      intersectionOfToResources(intersectionOfNonSubstitutableResources,lobToResourceNames_,LOBs[b]);
      intersectionOfToResources(intersectionOfNonSubstitutableResources,sourceToResourceNames_,sources[b]);
d1261 1
a1261 1
        if ( jobRoles[b] != toJobRole ) {
d1263 2
a1264 2
          subsLeadTime = max( subsLeadTime , jobRoleSubs_[jobRoles[b]][toJobRole].getLeadTime() );
          subsCost     = subsCost          + jobRoleSubs_[jobRoles[b]][toJobRole].getCost();
d1266 1
a1266 1
        if ( skillSets[b] != toSkill ) {
d1268 2
a1269 2
          subsLeadTime = max( subsLeadTime , skillSubs_[skillSets[b]][toSkill].getLeadTime() );
          subsCost     = subsCost          + skillSubs_[skillSets[b]][toSkill].getCost();
d1271 1
a1271 1
        if ( resourceLocNames[b] != toLocation ) {
d1273 2
a1274 2
          subsLeadTime = max( subsLeadTime , locationSubs_[resourceLocNames[b]][toLocation].getLeadTime() );
          subsCost     = subsCost          + locationSubs_[resourceLocNames[b]][toLocation].getCost();
d1276 1
a1276 1
        if ( LOBs[b] != toLOB ) {
d1278 2
a1279 2
          subsLeadTime = max( subsLeadTime , lobSubs_[LOBs[b]][toLOB].getLeadTime() );
          subsCost     = subsCost          + lobSubs_[LOBs[b]][toLOB].getCost();
d1281 1
a1281 1
        if ( sources[b] != toSource ) {
d1283 2
a1284 2
          subsLeadTime = max( subsLeadTime , sourceSubs_[sources[b]][toSource].getLeadTime() );
          subsCost     = subsCost          + sourceSubs_[sources[b]][toSource].getCost();
d1288 1
a1288 1
        assert( resourceExists(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );
d1291 1
a1291 1
        std::string subsWorkingRes = workingResourceName(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]);
@


1.60
log
@in rcpProblem changed name of addSkillSubsArcs method to be addSubsArcsToWitModel.
This renamed method now adds substitutes for jobRoles and skillSets.
@
text
@d869 108
@


1.59
log
@fixed a few typos in the data files, and uncommented the population of one
of the tests
@
text
@d16 1
d214 1
a214 1
  jobRoles_.insert(baseName);
d241 2
a242 2
  for ( it=jobRoles_.begin(); it!=jobRoles_.end(); ++it ) {
    jobRoles.push_back( resourceFromResourceName(*it) );
d955 41
d998 29
a1026 1
// Add wit sub arcs for skills
d1028 1
a1028 1
void RCPproblem::addSkillSubsArcs()
d1039 2
a1040 1
    const std::string & fromSkill = skillSets[b];
d1043 1
a1043 1
    if ( skillSubs_.find(fromSkill)==skillSubs_.end() ) continue; 
d1068 2
a1069 30
      RCPcollectionOfStrings resWithToSkills;
      
      // Does this bom allow skill substitution? 
      // If yes, then add resources with toSkills to resWithToSkills
      int subAllowed = getBomSkillSetSub(engagementNames[b],jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b],period);
      if ( subAllowed != 0 ) {
        
        // get toSkills that can substitute for fromSkills
        const RCPmapStringToSubs & toSkills = skillSubs_.find(fromSkill)->second;
        
        // loop over each toSkill creating a collection of all resources that have the toSkills.
        RCPmapStringToSubs::const_iterator toSkillsIt;
        for ( toSkillsIt=toSkills.begin(); toSkillsIt!=toSkills.end(); ++toSkillsIt ) {
          std::string toSkill = toSkillsIt->first;
          
          // If there aren't any resources with toSkill then there is nothing to do
          if ( skillToResourceNames_.find(toSkill)==skillToResourceNames_.end() ) continue;
          
          // Get set of all resources that have toSkill
          const RCPcollectionOfStrings & resWithToSkill = skillToResourceNames_.find(toSkill)->second;
          
          // Take the union of sets resWithToSkill and resWithToSkills storing result in unionSet
          RCPcollectionOfStrings unionSet;
          std::insert_iterator<RCPcollectionOfStrings>  insert(unionSet, unionSet.begin());
          std::set_union(resWithToSkill.begin(),resWithToSkill.end(), resWithToSkills.begin(),resWithToSkills.end(), insert);
          
          // assign union set to resWithToSkills
          resWithToSkills = unionSet;
        } // end of for toSkillIt loop
      }
d1071 8
a1078 6
      // Are there any resources that have jobRoles[b], LOBs[b], sources[b], and resourceLocNames[b]?
      // If no, then iterate
      if ( jobToResourceNames_.find(jobRoles[b])==jobToResourceNames_.end() ) continue;
      if ( lobToResourceNames_.find(LOBs[b])==lobToResourceNames_.end() ) continue;
      if ( sourceToResourceNames_.find(sources[b])==sourceToResourceNames_.end() ) continue;
      if ( locToResourceNames_.find(resourceLocNames[b])==locToResourceNames_.end() ) continue;
a1079 5
      // Get collections of resources that individually match jobRoles[b], toSkill, LOBs[b], resourceLocNames[b]
      const RCPcollectionOfStrings & resWithJob = jobToResourceNames_.find(jobRoles[b])->second;
      const RCPcollectionOfStrings & resWithLob = lobToResourceNames_.find(LOBs[b])->second;
      const RCPcollectionOfStrings & resWithSource = sourceToResourceNames_.find(sources[b])->second;
      const RCPcollectionOfStrings & resWithLoc = locToResourceNames_.find(resourceLocNames[b])->second;
d1081 14
a1094 31
#if 0
      RCPcollectionOfStrings::const_iterator it;
      for ( it=resWithJob.begin(); it!=resWithJob.end(); ++it ) {
        std::cout <<"resWithJob " <<*it <<std::endl;
      }
      for ( it=resWithToSkills.begin(); it!=resWithToSkills.end(); ++it ) {
        std::cout <<"resWithToSkill " <<*it <<std::endl;
      }
      for ( it=resWithLob.begin(); it!=resWithLob.end(); ++it ) {
        std::cout <<"resWithLob " <<*it <<std::endl;
      }
      for ( it=resWithLoc.begin(); it!=resWithLoc.end(); ++it ) {
        std::cout <<"resWithLoc " <<*it <<std::endl;
      }
#endif
      
      // Now get all resources that match all (jobRoles[b],toSkill,LOBs[b],resourceLocNames[b])
      RCPcollectionOfStrings intersection1, intersection2, intersection3, subsResources;
      std::insert_iterator<RCPcollectionOfStrings>  insert1(intersection1, intersection1.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insert2(intersection2, intersection2.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insert3(intersection3, intersection3.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insertSubResource(subsResources, subsResources.begin());
      
      std::set_intersection(resWithJob.begin(),resWithJob.end(), resWithToSkills.begin(),resWithToSkills.end(), insert1);
      std::set_intersection(intersection1.begin(),intersection1.end(), resWithLob.begin(),resWithLob.end(), insert2);
      std::set_intersection(intersection2.begin(),intersection2.end(), resWithSource.begin(),resWithSource.end(), insert3);
      std::set_intersection(intersection3.begin(),intersection3.end(), resWithLoc.begin(),resWithLoc.end(), insertSubResource);
      
      // subsResource contains list of resources which are to be substituted for resource b
      std::cout 
        <<"fromSkill: "  <<fromSkill <<std::endl;
d1096 9
d1109 8
a1116 1
        std::string toSkill = skillSetFromResourceName(subsResource);
d1118 30
a1147 5
        assert( resourceExists(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );
        
        // Get leadTime and cost of substitutine fromSkill to toSkill
        float subsLeadTime = skillSubs_[fromSkill][toSkill].getLeadTime();
        float subsCost = skillSubs_[fromSkill][toSkill].getCost();
d1149 1
d1275 1
a1275 1
  addSkillSubsArcs();
d1328 1
a1328 1
std::string RCPproblem::resourceFromResourceName(const std::string & baseResourceName)
d1468 1
a1468 1
jobRoles_(),
d1495 1
a1495 1
jobRoles_(),
d1527 1
a1527 1
  jobRoles_ = source.jobRoles_;
@


1.58
log
@additional unit tests for the new match flags
@
text
@d1870 1
a1870 1
    //populate(prob_subs, inputDirectory, outputDirectory);
@


1.57
log
@added match flags
@
text
@d1762 19
@


1.56
log
@Modified code to get to compile on Linux.
@
text
@d703 46
d1851 1
a1851 1
    populate(prob_subs, inputDirectory, outputDirectory);
@


1.55
log
@ jobRoleSubs:
-Added file class for reading.
-Created new datafiles.
-in rcpProblem added add/set/get methods
-populateRCP added stanza to read file and invoke add & set methods.
Have not yet added code for adding substitute arcs to wit model.
@
text
@d707 1
a707 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,RCPbomAppData::setJobRoleSub);
d712 1
a712 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,RCPbomAppData::setSkillSetSub);
d717 1
a717 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,RCPbomAppData::setLocationSub);
d722 1
a722 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,RCPbomAppData::setLobSub);
d727 1
a727 1
  setBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,sub,RCPbomAppData::setSourceSub);
d732 1
a732 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getJobRoleSub);
d736 1
a736 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getSkillSetSub);
d740 1
a740 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getLocationSub);
d744 1
a744 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getLobSub);
d748 1
a748 1
  return getBomSub(engagementName,jobRole,skillSet,LOB,source,resourceLocName,period,RCPbomAppData::getSourceSub);
@


1.54
log
@Modifed to addSubArcs method to set up for using to substitute on more than just skills
@
text
@d752 36
d792 1
a792 3
  assert( !skillSubsExists(fromSkill,toSkill) );
  RCPskillSubs subs(fromSkill,toSkill);
  skillSubs_[fromSkill][toSkill]=subs;
d796 1
a796 2
  RCPskillSubs & subs = getSkillSubs(fromSkill,toSkill);
  subs.setCost(cost);
d800 1
a800 2
  RCPskillSubs & subs = getSkillSubs(fromSkill,toSkill);
  subs.setLeadTime(leadTime);
d805 41
d847 1
a847 1

d849 3
a851 3
  std::map<std::string,RCPmapStringToSkillSubs>::const_iterator itFrom = skillSubs_.find(fromSkill);
  if ( itFrom!=skillSubs_.end() ) {

d853 1
a853 1
    RCPmapStringToSkillSubs::const_iterator itTo = itFrom->second.find(toSkill);
d859 2
a860 1
void RCPproblem::getSkillSubsNames( std::vector<std::string> & fromSkills, std::vector<std::string> & toSkills)const
d862 3
a864 3
  fromSkills.clear();
  toSkills.clear();

d866 3
a868 3
  std::map<std::string,RCPmapStringToSkillSubs>::const_iterator itFrom;
  for (itFrom=skillSubs_.begin(); itFrom!=skillSubs_.end(); ++itFrom) {

d870 1
a870 1
    RCPmapStringToSkillSubs::const_iterator itTo;
d872 1
a872 1

d874 4
a877 4
       const RCPskillSubs & subs  = (*itTo).second;
       fromSkills.push_back(subs.getFromSkill() );
       toSkills.push_back(subs.getToSkill() );

d881 1
a881 2

float RCPproblem::getSkillSubsCost(const std::string & fromSkill, const std::string & toSkill )const
d883 1
a883 1
  const RCPskillSubs & subs = getSkillSubs(fromSkill,toSkill);
d886 1
a886 2

float RCPproblem::getSkillSubsLeadTime(const std::string & fromSkill, const std::string & toSkill )const
d888 1
a888 1
  const RCPskillSubs & subs = getSkillSubs(fromSkill,toSkill);
d892 2
a893 2
// Get skillSub from collection class
RCPskillSubs & RCPproblem::getSkillSubs(const std::string & fromSkill, const std::string & toSkill ) 
d895 3
a897 3
  assert( skillSubsExists(fromSkill,toSkill) );
  RCPmapStringToSkillSubs & toSkills = skillSubs_.find(fromSkill)->second;
  RCPskillSubs & subs = toSkills.find(toSkill)->second;
d900 1
a900 1
const RCPskillSubs & RCPproblem::getSkillSubs(const std::string & fromSkill, const std::string & toSkill ) const
d902 3
a904 3
  assert( skillSubsExists(fromSkill,toSkill) );
  const RCPmapStringToSkillSubs & toSkills = skillSubs_.find(fromSkill)->second;
  const RCPskillSubs & subs = toSkills.find(toSkill)->second;
d908 1
d959 1
a959 1
        const RCPmapStringToSkillSubs & toSkills = skillSubs_.find(fromSkill)->second;
d962 1
a962 1
        RCPmapStringToSkillSubs::const_iterator toSkillsIt;
d1359 1
d1361 3
d1386 1
d1388 3
d1418 1
d1420 3
@


1.53
log
@Coded modifed to conditionally add substitute arcs based of value of skillSetSub field in bom.csv
@
text
@d877 3
d881 1
a881 1
      // If no, then iterate
d883 1
a883 1
      if ( subAllowed == 0 ) continue;
a886 17
      
      // loop over each toSkill creating a collection of all resources that have the toSkills.
      RCPcollectionOfStrings resWithToSkills;
      RCPmapStringToSkillSubs::const_iterator toSkillsIt;
      for ( toSkillsIt=toSkills.begin(); toSkillsIt!=toSkills.end(); ++toSkillsIt ) {
        std::string toSkill = toSkillsIt->first;
        
        // If there aren't any resources with toSkill then there is nothing to do
        if ( skillToResourceNames_.find(toSkill)==skillToResourceNames_.end() ) continue;
        
        // Get set of all resources that have toSkill
        const RCPcollectionOfStrings & resWithToSkill = skillToResourceNames_.find(toSkill)->second;
        
        // Take the union of sets resWithToSkill and resWithToSkills storing result in unionSet
        RCPcollectionOfStrings unionSet;
        std::insert_iterator<RCPcollectionOfStrings>  insert(unionSet, unionSet.begin());
        std::set_union(resWithToSkill.begin(),resWithToSkill.end(), resWithToSkills.begin(),resWithToSkills.end(), insert);
d888 20
a907 3
        // assign union set to resWithToSkills
        resWithToSkills = unionSet;
      } // end of for toSkillIt loop
@


1.52
log
@Added fields to bomAppData:
   jobRoleSub, skillSetSub, locationSub, lobSub, sourceSub
Added set/gets for these fields in rcpProblem.
Added reading of these fields in populateRCP.cpp and the calls to set their values in rcpProblem.
@
text
@d853 1
a853 1
    if ( skillSubs_.find(fromSkill)==skillSubs_.end() ) continue;
d855 2
a856 2
    // get toSkills that can substitute for fromSkills
    const RCPmapStringToSkillSubs & toSkills = skillSubs_.find(fromSkill)->second;
d858 2
a859 33
    // loop over each toSkill creating a collection of all resources that have the toSkills.
    RCPcollectionOfStrings resWithToSkills;
    RCPmapStringToSkillSubs::const_iterator toSkillsIt;
    for ( toSkillsIt=toSkills.begin(); toSkillsIt!=toSkills.end(); ++toSkillsIt ) {
      std::string toSkill = toSkillsIt->first;
      
      // If there aren't any resources with toSkill then there is nothing to do
      if ( skillToResourceNames_.find(toSkill)==skillToResourceNames_.end() ) continue;
      
      // Get set of all resources that have toSkill
      const RCPcollectionOfStrings & resWithToSkill = skillToResourceNames_.find(toSkill)->second;
      
      // Take the union of sets resWithToSkill and resWithToSkills storing result in unionSet
      RCPcollectionOfStrings unionSet;
      std::insert_iterator<RCPcollectionOfStrings>  insert(unionSet, unionSet.begin());
      std::set_union(resWithToSkill.begin(),resWithToSkill.end(), resWithToSkills.begin(),resWithToSkills.end(), insert);
      
      // assign union set to resWithToSkills
      resWithToSkills = unionSet;
    } // end of for toSkillIt loop
    
    // Are there any resources that have jobRoles[b], LOBs[b], sources[b], and resourceLocNames[b]?
    // If no, then iterate
    if ( jobToResourceNames_.find(jobRoles[b])==jobToResourceNames_.end() ) continue;
    if ( lobToResourceNames_.find(LOBs[b])==lobToResourceNames_.end() ) continue;
    if ( sourceToResourceNames_.find(sources[b])==sourceToResourceNames_.end() ) continue;
    if ( locToResourceNames_.find(resourceLocNames[b])==locToResourceNames_.end() ) continue;
    
    // Get collections of resources that individually match jobRoles[b], toSkill, LOBs[b], resourceLocNames[b]
    const RCPcollectionOfStrings & resWithJob = jobToResourceNames_.find(jobRoles[b])->second;
    const RCPcollectionOfStrings & resWithLob = lobToResourceNames_.find(LOBs[b])->second;
    const RCPcollectionOfStrings & resWithSource = sourceToResourceNames_.find(sources[b])->second;
    const RCPcollectionOfStrings & resWithLoc = locToResourceNames_.find(resourceLocNames[b])->second;
d861 58
d920 13
a932 13
    RCPcollectionOfStrings::const_iterator it;
    for ( it=resWithJob.begin(); it!=resWithJob.end(); ++it ) {
      std::cout <<"resWithJob " <<*it <<std::endl;
    }
    for ( it=resWithToSkills.begin(); it!=resWithToSkills.end(); ++it ) {
      std::cout <<"resWithToSkill " <<*it <<std::endl;
    }
    for ( it=resWithLob.begin(); it!=resWithLob.end(); ++it ) {
      std::cout <<"resWithLob " <<*it <<std::endl;
    }
    for ( it=resWithLoc.begin(); it!=resWithLoc.end(); ++it ) {
      std::cout <<"resWithLoc " <<*it <<std::endl;
    }
d934 37
a970 51
    
    // Now get all resources that match all (jobRoles[b],toSkill,LOBs[b],resourceLocNames[b])
    RCPcollectionOfStrings intersection1, intersection2, intersection3, subsResources;
    std::insert_iterator<RCPcollectionOfStrings>  insert1(intersection1, intersection1.begin());
    std::insert_iterator<RCPcollectionOfStrings>  insert2(intersection2, intersection2.begin());
    std::insert_iterator<RCPcollectionOfStrings>  insert3(intersection3, intersection3.begin());
    std::insert_iterator<RCPcollectionOfStrings>  insertSubResource(subsResources, subsResources.begin());
    
    std::set_intersection(resWithJob.begin(),resWithJob.end(), resWithToSkills.begin(),resWithToSkills.end(), insert1);
    std::set_intersection(intersection1.begin(),intersection1.end(), resWithLob.begin(),resWithLob.end(), insert2);
    std::set_intersection(intersection2.begin(),intersection2.end(), resWithSource.begin(),resWithSource.end(), insert3);
    std::set_intersection(intersection3.begin(),intersection3.end(), resWithLoc.begin(),resWithLoc.end(), insertSubResource);
    
    // subsResource contains list of resources which are to be substituted for resource b
    std::cout 
      <<"fromSkill: "  <<fromSkill <<std::endl;
    
    // loop once for each substitute resource
    RCPcollectionOfStrings::const_iterator subsResIt;
    for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
      std::string subsResource = *subsResIt;
      std::string toSkill = skillSetFromResourceName(subsResource);
      
      assert( resourceExists(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );
      
      // Get leadTime and cost of substitutine fromSkill to toSkill
      float subsLeadTime = skillSubs_[fromSkill][toSkill].getLeadTime();
      float subsCost = skillSubs_[fromSkill][toSkill].getCost();
      
      assert( resourceExists(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );
      
      // Name of wit part connected to bomEntry
      std::string workingRes = workingResourceName(jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);
      
      // Name of wit operation connected to bomEntry
      std::string engagement = engagementName(engagementNames[b]);
      
      // Name of witPart to be connected to subsBomEntry
      std::string subsWorkingRes = workingResourceName(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]);
      
      // Get the indices for the boms connecting the operation to the part
      std::vector<int> bomIndices = getBomEntryIndex(engagement,workingRes);
      
      std::cout <<"  resource: " <<workingRes <<std::endl;
      std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
      
      // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
      // be added.
      int be;
      for( be=0; be<bomIndices.size(); ++be ) {
        int bomIndex = bomIndices[be];
d973 2
a974 2
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,engagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,engagement,bomIndex);
d988 1
a988 1
        witGetBomEntryNSubsBomEntries(mutableWitRun(),engagement.c_str(),bomIndex,&subIndex);
d991 1
a991 1
        witAddSubsBomEntry(witRun(),engagement.c_str(),bomIndex,subsWorkingRes.c_str() );
d994 1
a994 1
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,engagement,bomIndex,subIndex,bomConsRate);
d1005 1
a1005 1
        witSetSubArcAttribute(witSetSubsBomEntryOffset,engagement,bomIndex,subIndex,subsOffset);
d1008 1
a1008 1
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,engagement,bomIndex,subIndex,subsCost);
d1010 1
a1010 1
      }
d1012 1
a1012 1
    }  // end for subsResIt loop 
d1087 1
a1087 1
  // Add substitute arcs.  This needs to be conditionally done. But for now just always do it.
@


1.51
log
@Modifed method addSkillSubsArcs.
It now creates a set of all resources that have the toSkills by taking union of all sets that have the toSkill.
This was a change that was suggested at today's code review.
@
text
@d674 77
d1615 19
d1715 5
a1720 12
#if 0
    //test that resources got acquired; 2 of r1 and 3 of r2, both in period 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    assert(acquireQty[0]==2);
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","l1");
    assert(acquireQty[0]==3);
    //test that one engagement gets executed starting in period 1 (it has to wait one period to acquire the resources)
    assert(prob_acquire.getEngagementExecuted("e1"));
    assert(prob_acquire.getEngagementExecuted("e2"));
    assert(prob_acquire.getEngagementStartPeriod("e1")==1);
    assert(prob_acquire.getEngagementStartPeriod("e2")==0);
#endif
@


1.50
log
@Changed globally "resourceName" to "jobRole"
@
text
@d214 1
a214 1
  resourceToResourceNames_[jobRole].insert(baseName);
d765 1
a765 1

d769 1
a769 1

d774 1
a774 1

d777 1
a777 1

d780 3
a782 2

    // loop once for each toSkill that can substitute
d786 2
a787 7
      const RCPskillSubs & skillSubstitute = toSkillsIt->second;
      float subsLeadTime = skillSubstitute.getLeadTime();
      float subsCost  = skillSubstitute.getCost();

      // Are there any resources that have jobRoles[b], toSkill, LOBs[b], sources[b], and resourceLocNames[b]?
      // If no, then iterate
      if ( resourceToResourceNames_.find(jobRoles[b])==resourceToResourceNames_.end() ) continue;
d789 2
a790 6
      if ( lobToResourceNames_.find(LOBs[b])==lobToResourceNames_.end() ) continue;
      if ( sourceToResourceNames_.find(sources[b])==sourceToResourceNames_.end() ) continue;
      if ( locToResourceNames_.find(resourceLocNames[b])==locToResourceNames_.end() ) continue;

      // Get collections of resources that individually match jobRoles[b], toSkill, LOBs[b], resourceLocNames[b]
      const RCPcollectionOfStrings & resWithResourceName = resourceToResourceNames_.find(jobRoles[b])->second;
d792 23
a814 4
      const RCPcollectionOfStrings & resWithLob = lobToResourceNames_.find(LOBs[b])->second;
      const RCPcollectionOfStrings & resWithSource = sourceToResourceNames_.find(sources[b])->second;
      const RCPcollectionOfStrings & resWithLoc = locToResourceNames_.find(resourceLocNames[b])->second;

d816 13
a828 13
      RCPcollectionOfStrings::const_iterator it;
      for ( it=resWithResourceName.begin(); it!=resWithResourceName.end(); ++it ) {
        std::cout <<"resWithResourceName " <<*it <<std::endl;
      }
      for ( it=resWithToSkill.begin(); it!=resWithToSkill.end(); ++it ) {
        std::cout <<"resWithToSkill " <<*it <<std::endl;
      }
      for ( it=resWithLob.begin(); it!=resWithLob.end(); ++it ) {
        std::cout <<"resWithLob " <<*it <<std::endl;
      }
      for ( it=resWithLoc.begin(); it!=resWithLoc.end(); ++it ) {
        std::cout <<"resWithLoc " <<*it <<std::endl;
      }
d830 45
a874 1

d876 12
a887 51
      // Now get all resources that match all (jobRoles[b],toSkill,LOBs[b],resourceLocNames[b])
      RCPcollectionOfStrings intersection1, intersection2, intersection3, subsResources;
      std::insert_iterator<RCPcollectionOfStrings>  insert1(intersection1, intersection1.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insert2(intersection2, intersection2.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insert3(intersection3, intersection3.begin());
      std::insert_iterator<RCPcollectionOfStrings>  insertSubResource(subsResources, subsResources.begin());

      std::set_intersection(resWithResourceName.begin(),resWithResourceName.end(), resWithToSkill.begin(),resWithToSkill.end(), insert1);
      std::set_intersection(intersection1.begin(),intersection1.end(), resWithLob.begin(),resWithLob.end(), insert2);
      std::set_intersection(intersection2.begin(),intersection2.end(), resWithSource.begin(),resWithSource.end(), insert3);
      std::set_intersection(intersection3.begin(),intersection3.end(), resWithLoc.begin(),resWithLoc.end(), insertSubResource);

      // subsResource contains list of resources which are to be substituted for resource b
      std::cout 
        <<"fromSkill: "  <<fromSkill <<std::endl
        <<"  toSkill: "   <<toSkill   <<std::endl;

      // loop once for each substitute resource
      RCPcollectionOfStrings::const_iterator subsResIt;
      for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::string subsResource = *subsResIt;

        assert( resourceExists(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );

        // Name of wit part connected to bomEntry
        std::string workingRes = workingResourceName(jobRoles[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);

        // Name of wit operation connected to bomEntry
        std::string engagement = engagementName(engagementNames[b]);

        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(jobRoles[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]);

        // Get the indices for the boms connecting the operation to the part
        std::vector<int> bomIndices = getBomEntryIndex(engagement,workingRes);

        std::cout <<"  resource: " <<workingRes <<std::endl;
        std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;

        // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
        // be added.
        int be;
        for( be=0; be<bomIndices.size(); ++be ) {
          int bomIndex = bomIndices[be];

          // get some attributes of bomEntry that will have substitute added
          std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,engagement,bomIndex);
          std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,engagement,bomIndex);

          // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
          // no shifting by lead time is needed
d889 5
a893 5
          {
            int t;
            for( t=1; t<np; ++t )
              assert(bomConsRate[0]==bomConsRate[t]);
          }
d895 17
a911 25

          // get index of substitute to be added
          int subIndex;
          witGetBomEntryNSubsBomEntries(mutableWitRun(),engagement.c_str(),bomIndex,&subIndex);

          // add substitute
          witAddSubsBomEntry(witRun(),engagement.c_str(),bomIndex,subsWorkingRes.c_str() );
          
          // set substitute consRate
          witSetSubArcAttribute(witSetSubsBomEntryConsRate,engagement,bomIndex,subIndex,bomConsRate);

          // compute substitute offset
          // JP, Donna, Dan: need to verify that offset is being set correctly.
          std::vector<float> subsOffset(np);
          int t;
          for (t=0; t<np; ++t) {
            subsOffset[t]=offset[t]-subsLeadTime;
          }

          // set substitutes offset
          witSetSubArcAttribute(witSetSubsBomEntryOffset,engagement,bomIndex,subIndex,subsOffset);
          
          // set cost of using substitute
          witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,engagement,bomIndex,subIndex,subsCost);
          
d913 11
a923 5

      }  // end for subsResIt loop    

    } // end for toSkillsIt loop

d1194 1
a1194 1
resourceToResourceNames_(),
d1217 1
a1217 1
resourceToResourceNames_(),
d1245 1
a1245 1
  resourceToResourceNames_ = source.resourceToResourceNames_;
@


1.49
log
@Set the latestPeriod for the feedback loop on "enable" to nPeriods-2;  updated some asserts for example_acquire.
@
text
@d180 1
a180 1
void RCPproblem::addResource(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source,  const std::string & locName)
d182 4
a185 4
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,LOB,source,locName);
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,source,locName);
d212 3
a214 3
  std::string baseName = baseResourceName(resourceName,skillSet,LOB,source,locName);
  resourceNames_.insert(baseName);
  resourceToResourceNames_[resourceName].insert(baseName);
d221 1
a221 1
bool RCPproblem::resourceExists(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName)const
d223 1
a223 1
  std::string witName = benchResourceName(resourceName,skillSet,LOB,source,locName);
d229 1
a229 1
           std::vector<std::string> & resourceNames, std::vector<std::string> & skillSets, 
d233 1
a233 1
  resourceNames.clear();
d240 2
a241 2
  for ( it=resourceNames_.begin(); it!=resourceNames_.end(); ++it ) {
    resourceNames.push_back( resourceFromResourceName(*it) );
d250 1
a250 1
                                           const std::string & resourceName,
d258 1
a258 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d266 1
a266 1
                                           const std::string & resourceName,
d272 1
a272 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d277 1
a277 1
                                           const std::string & resourceName,
d283 1
a283 1
  std::string opName = enableResourceOperationName(resourceName,skillSet,LOB,source,locName);
d287 1
a287 1
                                           const std::string & resourceName,
d293 1
a293 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d299 1
a299 1
                                           const std::string & resourceName,
d305 1
a305 1
  std::string partName = benchResourceName(resourceName,skillSet,LOB,source,locName);
d310 1
a310 1
                                           const std::string & resourceName,
d316 1
a316 1
  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d320 1
a320 1
                                        const std::string & resourceName, 
d327 1
a327 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d334 1
a334 1
                                        const std::string & resourceName,
d341 1
a341 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d350 1
a350 1
                                        const std::string & resourceName, 
d359 1
a359 1
	//std::string acquireOp = acquireResourceOperationName(resourceName);  Still need to model this
d366 1
a366 1
                                        const std::string & resourceName, 
d373 1
a373 1
  std::string benchOp = benchResourceName(resourceName,skillSet,LOB,source,locName); 
d380 1
a380 1
                                      const std::string & resourceName,
d387 2
a388 2
  std::string benchOp = benchResourceName(resourceName,skillSet,LOB,source,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,LOB,source,locName);
d396 1
a396 1
                                         const std::string & resourceName,
d402 1
a402 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d411 1
a411 1
                                         const std::string & resourceName,
d417 1
a417 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d426 1
a426 1
                                         const std::string & resourceName,
d432 1
a432 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d441 1
a441 1
					 const std::string & resourceName,
d447 1
a447 1
  //  std::string acquireOp = acquireResourceOperationName(resourceName);
d459 1
a459 1
				       const std::string & resourceName,
d465 1
a465 1
  std::string acquireOp = benchResourceName(resourceName,skillSet,LOB,source,locName);
d480 1
a480 1
                                           const std::string & resourceName,
d486 1
a486 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d491 1
a491 1
                                           const std::string & resourceName,
d497 1
a497 1
  //  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,LOB,source,locName);
d499 1
a499 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d505 1
a505 1
                                           const std::string & resourceName,
d511 1
a511 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d516 1
a516 1
                                           const std::string & resourceName,
d522 1
a522 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,source,locName);
d530 1
a530 1
                        const std::string & resourceName,
d536 2
a537 2
  std::string bn = bomName(engagementName,resourceName,skillSet,LOB,source,resourceLocName);
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,source,resourceLocName);
d547 1
a547 1
                                     const std::string & resourceName,
d555 1
a555 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,source,resourceLocName);
d564 1
a564 1
    assert( bomExists(engName,resourceName,skillSet,LOB,source,resourceLocName) );
d585 1
a585 1
                           const std::string & resourceName,
d591 1
a591 1
  std::string bn = bomName(engagementName,resourceName,skillSet,LOB,source,resourceLocName);
d601 1
a601 1
                             std::vector<std::string> & resourceNames, 
d608 1
a608 1
  resourceNames.clear();
d617 1
a617 1
    resourceNames.push_back( resourceFromBomName(*it) );
d626 1
a626 1
                                                   const std::string & resourceName, 
d634 1
a634 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,source,resourceLocName);
d642 1
a642 1
    retVal.push_back( getBomUsageQuantity(engName,resourceName,skillSet,LOB,source,resourceLocName,t) );
d649 1
a649 1
                                      const std::string & resourceName, 
d657 1
a657 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,source,resourceLocName);
d767 2
a768 2
  std::vector<std::string> engagementNames, resourceNames, skillSets, LOBs, sources, resourceLocNames;
  getBomNames( engagementNames, resourceNames, skillSets, LOBs, sources, resourceLocNames );
d789 1
a789 1
      // Are there any resources that have resourceNames[b], toSkill, LOBs[b], sources[b], and resourceLocNames[b]?
d791 1
a791 1
      if ( resourceToResourceNames_.find(resourceNames[b])==resourceToResourceNames_.end() ) continue;
d797 2
a798 2
      // Get collections of resources that individually match resourceNames[b], toSkill, LOBs[b], resourceLocNames[b]
      const RCPcollectionOfStrings & resWithResourceName = resourceToResourceNames_.find(resourceNames[b])->second;
d821 1
a821 1
      // Now get all resources that match all (resourceNames[b],toSkill,LOBs[b],resourceLocNames[b])
d843 1
a843 1
        assert( resourceExists(resourceNames[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]) );
d846 1
a846 1
        std::string workingRes = workingResourceName(resourceNames[b],skillSets[b],LOBs[b],sources[b],resourceLocNames[b]);
d852 1
a852 1
        std::string subsWorkingRes = workingResourceName(resourceNames[b],toSkill,LOBs[b],sources[b],resourceLocNames[b]);
d1015 1
a1015 1
std::string RCPproblem::acquireResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d1017 1
a1017 1
  return "acquire: "+baseResourceName(resourceName,skillSet,LOB,source,locName);
d1019 1
a1019 1
std::string RCPproblem::benchResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d1021 1
a1021 1
  return "bench: " + baseResourceName(resourceName,skillSet,LOB,source,locName);
d1023 1
a1023 1
std::string RCPproblem::enableResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d1025 1
a1025 1
  return "enable: "+baseResourceName(resourceName,skillSet,LOB,source,locName);
d1027 1
a1027 1
std::string RCPproblem::workingResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d1029 1
a1029 1
  return "working: "+baseResourceName(resourceName,skillSet,LOB,source,locName);
d1031 1
a1031 1
std::string RCPproblem::baseResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & locName )
d1033 1
a1033 1
  return "resource: " + resourceName + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source + " at: " +locName;
d1062 1
a1062 1
std::string RCPproblem::bomName(const std::string & engagementName, const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & source, const std::string & resourceLocName)
d1064 1
a1064 1
  return "bom op: " + engagementName + " resource: " + resourceName + " skillSet: " + skillSet + " LOB: " + LOB + " source: " + source +" at: "+ resourceLocName;
d1177 1
a1177 1
resourceNames_(),
d1200 1
a1200 1
resourceNames_(),
d1228 1
a1228 1
  resourceNames_ = source.resourceNames_;
d1405 5
a1409 5
    std::vector<std::string> resourceNames,skillSets,LOBs,sources,locNames;
    prob.getResourceNames(resourceNames,skillSets,LOBs,sources,locNames);
    assert( resourceNames.size()==2 );
    assert( resourceNames[0]=="r1" || resourceNames[1]=="r1" );
    assert( resourceNames[1]=="r2" || resourceNames[1]=="r2" );
d1465 3
a1467 3
    std::vector<std::string> resourceNames,skillSets,LOBs,sources,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,resourceNames,skillSets,LOBs,sources,resourceLocNames);
    assert( resourceNames.size()==0);
d1480 1
a1480 1
    prob.getBomNames(engagementNames,resourceNames,skillSets,LOBs,sources,resourceLocNames);
d1484 3
a1486 3
    assert( resourceNames.size()==2 );
    assert( resourceNames[0]=="r1" || resourceNames[1]=="r1" );
    assert( resourceNames[0]=="r2" || resourceNames[1]=="r2" );
@


1.48
log
@uncommented asserts on the baseline problem
@
text
@d201 2
a202 1
  if (getNPeriods()>1){
d209 1
d1666 1
a1666 1
    assert( eq(obj,4920.0) );
d1669 1
a1669 1
    assert(acquireQty[0]==2);
d1671 1
a1671 1
    assert(acquireQty[0]==3);
d1675 2
a1676 2
    assert(prob_acquire.getEngagementStartPeriod("e1")==1);
    assert(prob_acquire.getEngagementStartPeriod("e2")==0);
@


1.47
log
@If (nPeriods == 1) we can't add the feedback loop from the enable operation to the bench supply because then that will prevent the enable operation from firing.  So there is a test now to only add that feedback loop if nPeriods>1.
@
text
@d1628 2
a1629 2
    //assert(gapQty[0]==10.0 );
    //assert(glutQty[0]==0.0 );
d1632 2
a1633 2
    //assert(gapQty[0]==10.0 );
    //assert(glutQty[0]==0.0 );
d1636 2
a1637 2
    //assert(gapQty[0]==0.0 );
    //assert(glutQty[0]==10.0 ); //or -10?
d1641 2
a1642 2
    //assert(gapQty[0]==0.0 );
    //assert(glutQty[0]==30.0 ); //or -30?
d1645 2
a1646 2
    //assert(gapQty[0]==0.0 );
    //assert(glutQty[0]==10.0 ); //or -10?
d1649 2
a1650 2
    //assert(gapQty[0]==10.0 );
    //assert(glutQty[0]==0.0 ); 
@


1.46
log
@added initialization code for private member data to constructors
@
text
@a199 1
  witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str());
d201 2
a202 3
  float * offsetVec = floatToFloatStar(-1.f);
  witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec);
  delete [] offsetVec;
d204 5
a208 1
  witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE);
@


1.45
log
@added code that calls witAddSubsBomEntry for substitute skills
@
text
@d755 3
d762 1
a762 1
  // Get boms
d766 1
a766 1
  // loop once for each bom
d785 1
a785 1
      // Are there any resources that have resourceNames[b], toSkill, LOBs[b] and resourceLocNames[b]?
d790 1
d797 1
d818 1
a818 1
      RCPcollectionOfStrings intersection1, intersection2, subsResources;
d821 1
d826 2
a827 1
      std::set_intersection(intersection2.begin(),intersection2.end(), resWithLoc.begin(),resWithLoc.end(), insertSubResource);
d850 1
a850 1
        // Get the indices for the bom connecting the operation to the part
d1175 6
a1180 1
skillSubs_()
d1198 6
a1203 1
skillSubs_()
d1227 5
@


1.44
log
@Added "source" field to the resource description and all the related code to use "source"
@
text
@d8 1
d208 7
a214 1
  resourceNames_.insert(baseResourceName(resourceName,skillSet,LOB,source,locName));
d677 1
a677 2
  std::string name = skillSubsName(fromSkill,toSkill);
  skillSubs_[name]=subs;
d692 12
a703 3
  std::string name = skillSubsName(fromSkill,toSkill);
  std::map<std::string,RCPskillSubs>::const_iterator it = skillSubs_.find(name);
  return it!=skillSubs_.end();
d709 15
a723 5
  std::map<std::string,RCPskillSubs>::const_iterator it;
  for (it=skillSubs_.begin(); it!=skillSubs_.end(); ++it) {
    const RCPskillSubs & subs  = (*it).second;
    fromSkills.push_back(subs.getFromSkill() );
    toSkills.push_back(subs.getToSkill() );
d743 2
a744 2
  std::string name = skillSubsName(fromSkill,toSkill);
  RCPskillSubs & subs = skillSubs_[name];
d750 2
a751 3
  std::string name = skillSubsName(fromSkill,toSkill);
  std::map<std::string,RCPskillSubs>::const_iterator it = skillSubs_.find(name);
  const RCPskillSubs & subs = (*it).second;
d755 146
d971 4
d1082 1
d1090 1
d1130 29
d1562 31
@


1.43
log
@Added rcpProblem methods associated with skillSubs.
Code to add WIT subs arcs still needs to be added.
@
text
@d179 1
a179 1
void RCPproblem::addResource(const std::string & resourceName, const std::string & skillSet, const std::string & LOB,  const std::string & locName)
d181 4
a184 4
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,LOB,locName);
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,locName);
d207 1
a207 1
  resourceNames_.insert(baseResourceName(resourceName,skillSet,LOB,locName));
d210 1
a210 1
bool RCPproblem::resourceExists(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName)const
d212 1
a212 1
  std::string witName = benchResourceName(resourceName,skillSet,LOB,locName);
d219 1
a219 1
	   std::vector<std::string> & LOBs, 
d225 1
d233 1
d242 1
d247 1
a247 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d258 1
d261 1
a261 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d269 1
d272 1
a272 1
  std::string opName = enableResourceOperationName(resourceName,skillSet,LOB,locName);
d279 1
d282 1
a282 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d291 1
d294 1
a294 1
  std::string partName = benchResourceName(resourceName,skillSet,LOB,locName);
d302 1
d305 1
a305 1
  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d312 1
d316 1
a316 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d326 1
d330 1
a330 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d342 1
d358 1
d362 1
a362 1
  std::string benchOp = benchResourceName(resourceName,skillSet,LOB,locName); 
d372 1
d376 2
a377 2
  std::string benchOp = benchResourceName(resourceName,skillSet,LOB,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,LOB,locName);
d388 1
d391 1
a391 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d403 1
d406 1
a406 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d418 1
d421 1
a421 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d433 1
d451 1
d454 1
a454 1
  std::string acquireOp = benchResourceName(resourceName,skillSet,LOB,locName);
d472 1
d475 1
a475 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d483 1
d486 1
a486 1
  //  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,LOB,locName);
d488 1
a488 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d497 1
d500 1
a500 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d508 1
d511 1
a511 1
  std::string benchRes = benchResourceName(resourceName,skillSet,LOB,locName);
d522 1
d525 2
a526 2
  std::string bn = bomName(engagementName,resourceName,skillSet,LOB,resourceLocName);
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,resourceLocName);
d539 1
d544 1
a544 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,resourceLocName);
d553 1
a553 1
    assert( bomExists(engName,resourceName,skillSet,LOB,resourceLocName) );
d577 1
d580 1
a580 1
  std::string bn = bomName(engagementName,resourceName,skillSet,LOB,resourceLocName);
d593 1
d600 1
d609 1
d618 1
d623 1
a623 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,resourceLocName);
d631 1
a631 1
    retVal.push_back( getBomUsageQuantity(engName,resourceName,skillSet,LOB,resourceLocName,t) );
d641 1
d646 1
a646 1
  std::string workingRes = workingResourceName(resourceName,skillSet,LOB,resourceLocName);
d830 1
a830 1
std::string RCPproblem::acquireResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName )
d832 1
a832 1
  return "acquire: "+baseResourceName(resourceName,skillSet,LOB,locName);
d834 1
a834 1
std::string RCPproblem::benchResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName )
d836 1
a836 1
  return "bench: " + baseResourceName(resourceName,skillSet,LOB,locName);
d838 1
a838 1
std::string RCPproblem::enableResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName )
d840 1
a840 1
  return "enable: "+baseResourceName(resourceName,skillSet,LOB,locName);
d842 1
a842 1
std::string RCPproblem::workingResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName )
d844 1
a844 1
  return "working: "+baseResourceName(resourceName,skillSet,LOB,locName);
d846 1
a846 1
std::string RCPproblem::baseResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & locName )
d848 1
a848 1
  return "resource: " + resourceName + " skillSet: " + skillSet + " LOB: " + LOB + " at: " +locName;
d858 1
a858 1
  return textBetween(baseResourceName,"skillSet: "," LOB: ");
d862 5
a866 1
  return textBetween(baseResourceName,"LOB: "," at: ");
d877 1
a877 1
std::string RCPproblem::bomName(const std::string & engagementName, const std::string & resourceName, const std::string & skillSet, const std::string & LOB, const std::string & resourceLocName)
d879 1
a879 1
  return "bom op: " + engagementName + " resource: " + resourceName + " skillSet: " + skillSet + " LOB: " + LOB + " at: "+ resourceLocName;
d895 5
a899 1
  return textBetween(bomName," LOB: "," at: ");
d1161 3
a1163 3
    prob.addResource("r1","s1", "LOB1","l1");  
    prob.addResource("r2","s2","LOB2","l2");
    float time = prob.getResourceAcquireTime("r1","s1","LOB1","l1");
d1165 2
a1166 2
    prob.setResourceAcquireTime("r1","s1","LOB1","l1", 2.f);
    assert ( prob.getResourceAcquireTime("r1","s1","LOB1","l1") == -2.f ); //note that we negate the
d1170 3
a1172 3
    assert( prob.getResourceAcquireCost("r1","s1","LOB1","l1") == 0 );
    prob.setResourceAcquireCost("r1","s1","LOB1","l1", 100.f);
    assert ( prob.getResourceAcquireCost("r1","s1","LOB1","l1") == 100.f );
d1174 2
a1175 2
    std::vector<std::string> resourceNames,skillSets,LOBs,locNames;
    prob.getResourceNames(resourceNames,skillSets,LOBs,locNames);
d1188 4
d1197 1
a1197 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","l2");
d1207 2
a1208 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","l2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","l2");
d1214 2
a1215 2
    prob.setResourceSupplyQuantity("r2","s2","LOB2","l2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2","s2","LOB2","l2");
d1230 2
a1231 2
    prob.addResource("r1","s1","LOB1","l1");  
    prob.addResource("r2","s2","LOB2","l1");
d1234 2
a1235 2
    std::vector<std::string> resourceNames,skillSets,LOBs,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,resourceNames,skillSets,LOBs,resourceLocNames);
d1240 3
a1242 3
    assert( !prob.bomExists("e1","r1","s1","LOB1","l1") );
    prob.addBom("e1","r1","s1","LOB1","l1");
    assert( prob.bomExists("e1","r1","s1","LOB1","l1") );
d1245 3
a1247 3
    assert( !prob.bomExists("e1","r2","s2","LOB2","l1") );
    prob.addBom("e1","r2","s2","LOB2","l1");
    assert( prob.bomExists("e1","r2","s2","LOB2","l1") );
d1249 1
a1249 1
    prob.getBomNames(engagementNames,resourceNames,skillSets,LOBs,resourceLocNames);
d1262 3
d1270 1
a1270 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","l1");
d1280 3
a1282 3
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","l1");
d1288 3
a1290 3
    prob.setBomUsageQuantity("e1","r2","s2","LOB2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","LOB2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","LOB2","l1");
d1366 2
a1367 2
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","l1");
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","l1");
d1370 2
a1371 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","l1");
d1374 2
a1375 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","l1");
d1379 2
a1380 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","LOB1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","LOB1","l2");
d1383 2
a1384 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","LOB1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","LOB1","l2");
d1387 2
a1388 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","LOB1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","LOB1","l2");
d1406 1
a1406 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","l1");
d1408 1
a1408 1
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","l1");
d1434 1
a1434 1
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","LOB1","l1");
d1438 1
a1438 1
    acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","LOB2","l1");
d1456 1
a1456 1
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","LOB1","l1");
d1460 1
a1460 1
    acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","LOB2","l1");
@


1.42
log
@Added skillSet to rcp code;  added skillSubs* to appl.mk
@
text
@d633 50
d684 16
d868 10
d924 2
a925 1
bomNames_()
d942 2
a943 1
bomNames_()
d966 1
d1058 1
d1250 36
a1358 1
    CoinRelFltEq eq;
@


1.41
log
@new tests
@
text
@d179 1
a179 1
void RCPproblem::addResource(const std::string & resourceName, const std::string & skillSet,  const std::string & locName)
d181 4
a184 4
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,locName);
  std::string workingRes = workingResourceName(resourceName,skillSet,locName);
d207 1
a207 1
  resourceNames_.insert(baseResourceName(resourceName,skillSet, locName));
d210 1
a210 1
bool RCPproblem::resourceExists(const std::string & resourceName, const std::string & skillSet, const std::string & locName)const
d212 1
a212 1
  std::string witName = benchResourceName(resourceName,skillSet,locName);
d219 1
d224 1
d231 1
d239 1
d244 1
a244 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d254 1
d257 1
a257 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d264 1
d267 1
a267 1
  std::string opName = enableResourceOperationName(resourceName,skillSet,locName);
d273 1
d276 1
a276 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d284 1
d287 1
a287 1
  std::string partName = benchResourceName(resourceName,skillSet,locName);
d294 1
d297 1
a297 1
  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,locName);
d303 1
d307 1
a307 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
d316 1
d320 1
a320 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
d331 1
d346 1
d350 1
a350 1
  std::string benchOp = benchResourceName(resourceName,skillSet,locName); 
d359 1
d363 2
a364 2
  std::string benchOp = benchResourceName(resourceName,skillSet,locName);
  std::string enableOp = enableResourceOperationName(resourceName,skillSet,locName);
d374 1
d377 1
a377 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
d388 1
d391 1
a391 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
d402 1
d405 1
a405 1
  std::string acquireOp = acquireResourceOperationName(resourceName,skillSet,locName);
d416 1
d433 1
d436 1
a436 1
  std::string acquireOp = benchResourceName(resourceName,skillSet,locName);
d453 1
d456 1
a456 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d463 1
d466 1
a466 1
  //  std::string acquireRes = acquireResourceOperationName(resourceName,skillSet,locName);
d468 1
a468 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d476 1
d479 1
a479 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d486 1
d489 1
a489 1
  std::string benchRes = benchResourceName(resourceName,skillSet,locName);
d499 1
d502 2
a503 2
  std::string bn = bomName(engagementName,resourceName,skillSet,resourceLocName);
  std::string workingRes = workingResourceName(resourceName,skillSet,resourceLocName);
d515 1
d520 1
a520 1
  std::string workingRes = workingResourceName(resourceName,skillSet,resourceLocName);
d529 1
a529 1
    assert( bomExists(engName,resourceName,skillSet,resourceLocName) );
d552 1
d555 1
a555 1
  std::string bn = bomName(engagementName,resourceName,skillSet,resourceLocName);
d567 1
d573 1
d581 1
d589 1
d594 1
a594 1
  std::string workingRes = workingResourceName(resourceName,skillSet,resourceLocName);
d602 1
a602 1
    retVal.push_back( getBomUsageQuantity(engName,resourceName,skillSet,resourceLocName,t) );
d611 1
d616 1
a616 1
  std::string workingRes = workingResourceName(resourceName,skillSet,resourceLocName);
d734 1
a734 1
std::string RCPproblem::acquireResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & locName )
d736 1
a736 1
  return "acquire: "+baseResourceName(resourceName,skillSet,locName);
d738 1
a738 1
std::string RCPproblem::benchResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & locName )
d740 1
a740 1
  return "bench: " + baseResourceName(resourceName,skillSet,locName);
d742 1
a742 1
std::string RCPproblem::enableResourceOperationName(const std::string & resourceName, const std::string & skillSet, const std::string & locName )
d744 1
a744 1
  return "enable: "+baseResourceName(resourceName,skillSet,locName);
d746 1
a746 1
std::string RCPproblem::workingResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & locName )
d748 1
a748 1
  return "working: "+baseResourceName(resourceName,skillSet,locName);
d750 1
a750 1
std::string RCPproblem::baseResourceName(const std::string & resourceName, const std::string & skillSet, const std::string & locName )
d752 1
a752 1
  return "resource: " + resourceName + " skillSet: " + skillSet + " at: " +locName;
d762 5
a766 1
  return textBetween(baseResourceName,"skillSet: "," at: ");
d777 1
a777 1
std::string RCPproblem::bomName(const std::string & engagementName, const std::string & resourceName, const std::string & skillSet, const std::string & resourceLocName)
d779 1
a779 1
  return "bom op: " + engagementName + " resource: " + resourceName + " skillSet: " + skillSet + " at: "+ resourceLocName;
d791 5
a795 1
  return textBetween(bomName," skillSet: "," at: ");
d1043 3
a1045 3
    prob.addResource("r1","s1","l1");  
    prob.addResource("r2","s2","l2");
    float time = prob.getResourceAcquireTime("r1","s1","l1");
d1047 2
a1048 2
    prob.setResourceAcquireTime("r1","s1","l1", 2.f);
    assert ( prob.getResourceAcquireTime("r1","s1","l1") == -2.f ); //note that we negate the
d1052 3
a1054 3
    assert( prob.getResourceAcquireCost("r1","s1","l1") == 0 );
    prob.setResourceAcquireCost("r1","s1","l1", 100.f);
    assert ( prob.getResourceAcquireCost("r1","s1","l1") == 100.f );
d1056 2
a1057 2
    std::vector<std::string> resourceNames,skillSets,locNames;
    prob.getResourceNames(resourceNames,skillSets,locNames);
d1060 1
a1060 1
    assert( resourceNames[0]=="r2" || resourceNames[1]=="r2" );
d1064 5
a1068 1
    assert( skillSets[0]=="s21" || skillSets[1]=="s2" );
d1075 1
a1075 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2","s2","l2");
d1085 2
a1086 2
    prob.setResourceSupplyQuantity("r2","s2","l2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2","s2","l2");
d1092 2
a1093 2
    prob.setResourceSupplyQuantity("r2","s2","l2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2","s2","l2");
d1108 2
a1109 2
    prob.addResource("r1","s1","l1");  
    prob.addResource("r2","s2","l1");
d1112 2
a1113 2
    std::vector<std::string> resourceNames,skillSets,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,resourceNames,skillSets,resourceLocNames);
d1118 3
a1120 3
    assert( !prob.bomExists("e1","r1","s1","l1") );
    prob.addBom("e1","r1","s1","l1");
    assert( prob.bomExists("e1","r1","s1","l1") );
d1123 3
a1125 3
    assert( !prob.bomExists("e1","r2","s2","l1") );
    prob.addBom("e1","r2","s2","l1");
    assert( prob.bomExists("e1","r2","s2","l1") );
d1127 1
a1127 1
    prob.getBomNames(engagementNames,resourceNames,skillSets,resourceLocNames);
d1137 3
d1145 1
a1145 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","s2","l1");
d1155 3
a1157 3
    prob.setBomUsageQuantity("e1","r2","s2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","l1");
d1163 3
a1165 3
    prob.setBomUsageQuantity("e1","r2","s2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","s2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","s2","l1");
d1205 2
a1206 2
    std::vector<float> gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","l1");
    std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","l1");
d1209 2
a1210 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","l1");
d1213 2
a1214 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","l1");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","l1");
d1218 2
a1219 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailA","s1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailA","s1","l2");
d1222 2
a1223 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailB","s1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailB","s1","l2");
d1226 2
a1227 2
    gapQty = prob_baseline.getResourceGapQuantity("DetailC","s1","l2");
    glutQty = prob_baseline.getResourceGlutQuantity("DetailC","s1","l2");
d1246 1
a1246 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","l1");
d1248 1
a1248 1
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","l1");
d1274 1
a1274 1
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","l1");
d1278 1
a1278 1
    acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","l1");
d1296 1
a1296 1
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","l1");
d1300 1
a1300 1
    acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","l1");
@


1.40
log
@Added "skillSet" field to input files and updated the code to use this field.
@
text
@d1153 36
@


1.39
log
@Added globalAttr file containing algorithm and nPeriods
@
text
@d179 1
a179 1
void RCPproblem::addResource(const std::string & resourceName, const std::string & locName)
d181 4
a184 4
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
  std::string benchRes = benchResourceName(resourceName,locName);
  std::string enableOp = enableResourceOperationName(resourceName,locName);
  std::string workingRes = workingResourceName(resourceName,locName);
d207 1
a207 1
  resourceNames_.insert(baseResourceName(resourceName,locName));
d210 1
a210 1
bool RCPproblem::resourceExists(const std::string & resourceName, const std::string & locName)const
d212 1
a212 1
  std::string witName = benchResourceName(resourceName,locName);
d218 1
a218 1
           std::vector<std::string> & resourceNames,
d222 1
d228 1
d235 1
d240 1
a240 1
  std::string benchRes = benchResourceName(resourceName,locName);
d249 1
d252 1
a252 1
  std::string benchRes = benchResourceName(resourceName,locName);
d258 1
d261 1
a261 1
  std::string opName = enableResourceOperationName(resourceName,locName);
d266 1
d269 1
a269 1
  std::string benchRes = benchResourceName(resourceName,locName);
d276 1
d279 1
a279 1
  std::string partName = benchResourceName(resourceName,locName);
d285 1
d288 1
a288 1
  std::string acquireRes = acquireResourceOperationName(resourceName,locName);
d293 1
d297 1
a297 1
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
d305 1
d309 1
a309 1
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
d319 1
d333 1
d337 1
a337 1
  std::string benchOp = benchResourceName(resourceName,locName); 
d345 1
d349 2
a350 2
  std::string benchOp = benchResourceName(resourceName,locName);
  std::string enableOp = enableResourceOperationName(resourceName,locName);
d359 1
d362 1
a362 1
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
d372 1
d375 1
a375 1
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
d385 1
d388 1
a388 1
  std::string acquireOp = acquireResourceOperationName(resourceName,locName);
d396 3
a398 1
float RCPproblem::getResourceReleaseTime(const std::string & resourceName,
d412 3
a414 1
float RCPproblem::getResourceFixedCost(const std::string & resourceName,
d417 1
a417 1
  std::string acquireOp = benchResourceName(resourceName,locName);
d433 1
d436 1
a436 1
  std::string benchRes = benchResourceName(resourceName,locName);
d442 1
d445 1
a445 1
  //  std::string acquireRes = acquireResourceOperationName(resourceName,locName);
d447 1
a447 1
  std::string benchRes = benchResourceName(resourceName,locName);
d454 1
d457 1
a457 1
  std::string benchRes = benchResourceName(resourceName,locName);
d463 1
d466 1
a466 1
  std::string benchRes = benchResourceName(resourceName,locName);
d475 1
d478 2
a479 2
  std::string bn = bomName(engagementName,resourceName,resourceLocName);
  std::string workingRes = workingResourceName(resourceName,resourceLocName);
d489 2
a490 1
                                     const std::string & resourceName, 
d495 1
a495 1
  std::string workingRes = workingResourceName(resourceName,resourceLocName);
d504 1
a504 1
    assert( bomExists(engName,resourceName,resourceLocName) );
d526 1
d529 1
a529 1
  std::string bn = bomName(engagementName,resourceName,resourceLocName);
d540 1
d545 1
d552 1
d559 1
d564 1
a564 1
  std::string workingRes = workingResourceName(resourceName,resourceLocName);
d572 1
a572 1
    retVal.push_back( getBomUsageQuantity(engName,resourceName,resourceLocName,t) );
d580 1
d585 1
a585 1
  std::string workingRes = workingResourceName(resourceName,resourceLocName);
d703 1
a703 1
std::string RCPproblem::acquireResourceOperationName(const std::string & resourceName,const std::string & locName )
d705 1
a705 1
  return "acquire: "+baseResourceName(resourceName,locName);
d707 1
a707 1
std::string RCPproblem::benchResourceName(const std::string & resourceName,const std::string & locName )
d709 1
a709 1
  return "bench: "+baseResourceName(resourceName,locName);
d711 1
a711 1
std::string RCPproblem::enableResourceOperationName(const std::string & resourceName,const std::string & locName )
d713 1
a713 1
  return "enable: "+baseResourceName(resourceName,locName);
d715 1
a715 1
std::string RCPproblem::workingResourceName(const std::string & resourceName,const std::string & locName )
d717 1
a717 1
  return "working: "+baseResourceName(resourceName,locName);
d719 1
a719 1
std::string RCPproblem::baseResourceName(const std::string & resourceName,const std::string & locName )
d721 1
a721 1
  return "resource: "+resourceName+" at: "+locName;
d727 5
a731 1
  return textBetween(baseResourceName,"resource: "," at: ");
d742 1
a742 1
std::string RCPproblem::bomName(const std::string & engagementName,const std::string & resourceName,const std::string & resourceLocName)
d744 1
a744 1
  return "bom op: " + engagementName + " resource: " + resourceName +" at: "+ resourceLocName;
d752 5
a756 1
  return textBetween(bomName," resource: "," at: ");
d1004 3
a1006 3
    prob.addResource("r1","l1");  
    prob.addResource("r2","l2");
    float time = prob.getResourceAcquireTime("r1","l1");
d1008 2
a1009 2
    prob.setResourceAcquireTime("r1","l1", 2.f);
    assert ( prob.getResourceAcquireTime("r1","l1") == -2.f ); //note that we negate the
d1013 3
a1015 3
    assert( prob.getResourceAcquireCost("r1","l1") == 0 );
    prob.setResourceAcquireCost("r1","l1", 100.f);
    assert ( prob.getResourceAcquireCost("r1","l1") == 100.f );
d1017 2
a1018 2
    std::vector<std::string> resourceNames,locNames;
    prob.getResourceNames(resourceNames,locNames);
d1023 4
d1032 1
a1032 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2","l2");
d1042 2
a1043 2
    prob.setResourceSupplyQuantity("r2","l2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2","l2");
d1049 2
a1050 2
    prob.setResourceSupplyQuantity("r2","l2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2","l2");
d1065 2
a1066 2
    prob.addResource("r1","l1");  
    prob.addResource("r2","l1");
d1069 2
a1070 2
    std::vector<std::string> resourceNames,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,resourceNames,resourceLocNames);
d1075 3
a1077 3
    assert( !prob.bomExists("e1","r1","l1") );
    prob.addBom("e1","r1","l1");
    assert( prob.bomExists("e1","r1","l1") );
d1080 3
a1082 3
    assert( !prob.bomExists("e1","r2","l1") );
    prob.addBom("e1","r2","l1");
    assert( prob.bomExists("e1","r2","l1") );
d1084 1
a1084 1
    prob.getBomNames(engagementNames,resourceNames,resourceLocNames);
d1091 3
d1099 1
a1099 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","l1");
d1109 3
a1111 3
    prob.setBomUsageQuantity("e1","r2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","l1");
d1117 3
a1119 3
    prob.setBomUsageQuantity("e1","r2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","l1");
d1164 1
a1164 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","l1");
d1166 1
a1166 1
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2","l1");
d1192 1
a1192 1
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","l1");
d1196 1
a1196 1
    acquireQty =prob_delay.getResourceAcquireQuantity("r2","l1");
d1214 1
a1214 1
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","l1");
d1218 1
a1218 1
    acquireQty =prob_decline.getResourceAcquireQuantity("r2","l1");
@


1.38
log
@modified some method names
@
text
@d1111 1
a1111 1
    populate(prob_acquire, inputDirectory, outputDirectory, 5);
d1134 1
a1134 1
    populate(prob_delay, inputDirectory, outputDirectory, 15);
d1160 1
a1160 1
    populate(prob_decline, inputDirectory, outputDirectory, 5);
d1180 1
a1180 1
    populate(prob_IGS, inputDirectory, outputDirectory, 16);
d1211 1
a1211 1
    populate(prob_IGS, inputDirectory, outputDirectory, 16);
@


1.37
log
@Code modifed so that an engagment is only uniquely identified by enagementName.
Engagement location is now an attribute of an engagement stored in appData.
@
text
@d30 1
a30 1
void RCPproblem::addEngagement(const std::string & engagementName)
d32 1
a32 1
  std::string theEngagement = baseEngagementName(engagementName);
d49 1
a49 1
bool RCPproblem::engagementExists    (const std::string & engagementName)const
d51 1
a51 1
  return witPartExists(baseEngagementName(engagementName).c_str());
d54 1
a54 1
void RCPproblem::setEngagementRevenue(const std::string & engagementName, 
d58 1
a58 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d61 1
a61 1
void RCPproblem::setEngagementLocation(const std::string & engagementName, 
d65 1
a65 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d68 1
a68 1
void RCPproblem::setEngagementStartPeriod(const std::string & engagementName, 
d72 1
a72 1
  std::string theEngagement = baseEngagementName(engagementName);
d84 1
a84 1
void RCPproblem::setEngagementDuration(const std::string & engagementName, 
d88 1
a88 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d91 1
a91 1
void RCPproblem::setEngagementLateAllowance(const std::string & engagementName, 
d95 1
a95 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d100 1
a100 1
float RCPproblem::getEngagementRevenue(const std::string & engagementName)const
d103 1
a103 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d106 1
a106 1
std::string RCPproblem::getEngagementLocation(const std::string & engagementName)const
d109 1
a109 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d112 1
a112 1
int RCPproblem::getEngagementRequestedStartPeriod(const std::string & engagementName)const
d115 1
a115 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d118 1
a118 1
int RCPproblem::getEngagementStartPeriod(const std::string & engagementName)const
d120 2
a121 2
  bool executed = getEngagementExecuted(engagementName);
  int duration = getEngagementDuration(engagementName);
d125 1
a125 1
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,baseEngagementName(engagementName));
d136 1
a136 1
int RCPproblem::getEngagementDuration(const std::string & engagementName)const
d139 1
a139 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d143 1
a143 1
int RCPproblem::getEngagementLateAllowance(const std::string & engagementName)const
d146 1
a146 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName).c_str(),(void**)&appData);
d157 1
a157 1
    engagementNames.push_back( engagementFromBaseEngagementName(*it) );
d161 1
a161 1
bool RCPproblem::getEngagementExecuted(const std::string & engagementName)const
d165 1
a165 1
						   baseEngagementName(engagementName));
d405 1
a405 1
std::vector<float> RCPproblem::getDemandShipReward(const std::string & engagementName)const
d407 1
a407 1
  std::string witDemandName = baseEngagementName(engagementName);
d463 1
a463 1
                                     const std::string & engagementName, 
d470 1
a470 1
  std::string engagement = baseEngagementName(engagementName);
d478 1
a478 1
    assert( bomExists(engagementName,resourceName,resourceLocName) );
d527 1
a527 1
                                                   const std::string & engagementName,
d534 1
a534 1
  std::string theEngagement = baseEngagementName(engagementName);
d541 1
a541 1
    retVal.push_back( getBomUsageQuantity(engagementName,resourceName,resourceLocName,t) );
d547 1
a547 1
                                      const std::string & engagementName, 
d554 1
a554 1
  std::string theEngagement = baseEngagementName(engagementName);
d586 1
a586 1
      std::string theEngagement = baseEngagementName(engagementNames[e]);
d620 1
a620 1
      std::string theEngagement = baseEngagementName(engagementNames[e]);
d653 1
a653 1
std::string RCPproblem::baseEngagementName(const std::string & engagementName )
d659 1
a659 1
std::string RCPproblem::engagementFromBaseEngagementName(const std::string & baseEngagementName)
d661 1
a661 1
  return textAfter(baseEngagementName,"engagement: ");
d816 1
a816 1
    std::string theEngagement = baseEngagementName(engagementNames[e]);
d831 1
a831 1
      std::string theEngagement = baseEngagementName(engagementNames[e]);
d859 1
a859 1
    std::string theEngagement = baseEngagementName(engagementNames[e]);
d872 1
a872 1
      std::string theEngagement = baseEngagementName(engagementNames[e]);
@


1.36
log
@change getEngagementShipReward to be named getDemandShipReward and made method private rather than public.
@
text
@d30 1
a30 1
void RCPproblem::addEngagement(const std::string & engagementName, const std::string & engagementLocationName)
d32 1
a32 1
  std::string theEngagement = baseEngagementName(engagementName, engagementLocationName);
d49 1
a49 1
bool RCPproblem::engagementExists    (const std::string & engagementName, const std::string & engagementLocationName)const
d51 1
a51 1
  return witPartExists(baseEngagementName(engagementName,engagementLocationName).c_str());
d54 1
a54 1
void RCPproblem::setEngagementRevenue(const std::string & engagementName, const std::string & engagementLocationName,
d58 1
a58 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d61 8
a68 1
void RCPproblem::setEngagementStartPeriod(const std::string & engagementName, const std::string & engagementLocationName,
d72 1
a72 1
  std::string theEngagement = baseEngagementName(engagementName, engagementLocationName);
d84 1
a84 1
void RCPproblem::setEngagementDuration(const std::string & engagementName, const std::string & engagementLocationName,
d88 1
a88 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d91 1
a91 1
void RCPproblem::setEngagementLateAllowance(const std::string & engagementName, const std::string & engagementLocationName,
d95 1
a95 1
  witGetPartAppData(witRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d100 1
a100 1
float RCPproblem::getEngagementRevenue(const std::string & engagementName, const std::string & engagementLocationName)const
d103 1
a103 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d106 7
a112 1
int RCPproblem::getEngagementRequestedStartPeriod(const std::string & engagementName, const std::string & engagementLocationName)const
d115 1
a115 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d118 1
a118 1
int RCPproblem::getEngagementStartPeriod(const std::string & engagementName, const std::string & engagementLocationName)const
d120 2
a121 2
  bool executed = getEngagementExecuted(engagementName, engagementLocationName);
  int duration = getEngagementDuration(engagementName, engagementLocationName);
d125 1
a125 1
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,baseEngagementName(engagementName, engagementLocationName));
d136 1
a136 1
int RCPproblem::getEngagementDuration(const std::string & engagementName, const std::string & engagementLocationName)const
d139 1
a139 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d143 1
a143 1
int RCPproblem::getEngagementLateAllowance(const std::string & engagementName, const std::string & engagementLocationName)const
d146 1
a146 1
  witGetPartAppData(mutableWitRun(),baseEngagementName(engagementName, engagementLocationName).c_str(),(void**)&appData);
d151 1
a151 2
void RCPproblem::getEngagementNames( std::vector<std::string> & engagementNames, 
				     std::vector<std::string> & engagementLocationNames ) const
a153 1
  engagementLocationNames.clear();
a157 1
    engagementLocationNames.push_back( engagementLocationFromBaseEngagementName(*it) );
d161 1
a161 1
bool RCPproblem::getEngagementExecuted(const std::string & engagementName, const std::string & engagementLocationName)const
d165 1
a165 1
						   baseEngagementName(engagementName, engagementLocationName));
d405 1
a405 1
std::vector<float> RCPproblem::getDemandShipReward(const std::string & engagementName, const std::string & engagementLocationName)const
d407 2
a408 1
  return witGetDemandAttribute(witGetDemandObj1ShipReward,baseEngagementName(engagementName,engagementLocationName),baseEngagementName(engagementName,engagementLocationName));
a449 1
			const std::string & engagementLocationName,
d453 1
a453 1
  std::string bn = bomName(engagementName,engagementLocationName,resourceName,resourceLocName);
a463 1
                                     const std::string & engagementLocationName, 
d470 1
d473 1
a473 1
  int bomIndex = getBomEntryIndex(baseEngagementName(engagementName,engagementLocationName),workingRes,period);
d478 1
a478 1
    assert( bomExists(engagementName,engagementLocationName,resourceName,resourceLocName) );
d480 2
a481 2
    witGetOperationNBomEntries(witRun(),baseEngagementName(engagementName,engagementLocationName).c_str(),&bomIndex);
    witAddBomEntry(witRun(),baseEngagementName(engagementName,engagementLocationName).c_str(),workingRes.c_str());
d485 1
a485 1
    witSetBomEntryAppData(witRun(),baseEngagementName(engagementName,engagementLocationName).c_str(),bomIndex,appData);
d489 1
a489 1
  witSetArcAttribute(witSetBomEntryConsRate,baseEngagementName(engagementName,engagementLocationName),bomIndex,usageQuantity);
a498 1
                           const std::string & engagementLocationName, 
d502 1
a502 1
  std::string bn = bomName(engagementName,engagementLocationName,resourceName,resourceLocName);
a511 1
                             std::vector<std::string> & engagementLocationNames, 
a515 1
  engagementLocationNames.clear();
a521 1
    engagementLocationNames.push_back( engagementLocationFromBomName(*it) );
d527 1
a527 2
                                                   const std::string & engagementName, 
						   const std::string & engagementLocationName, 
d534 1
a534 1
  std::string theEngagement = baseEngagementName(engagementName,engagementLocationName);
d541 1
a541 1
    retVal.push_back( getBomUsageQuantity(engagementName,engagementLocationName,resourceName,resourceLocName,t) );
a547 1
                                      const std::string & engagementLocationName, 
d554 1
a554 1
  std::string theEngagement = baseEngagementName(engagementName, engagementLocationName);
d583 1
a583 2
    std::vector<std::string> engagementLocs;
    getEngagementNames(engagementNames,engagementLocs);
d586 5
a590 5
      std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
      float revenue = getEngagementRevenue(engagementNames[e],engagementLocs[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e],engagementLocs[e]);
      int duration = getEngagementDuration(engagementNames[e],engagementLocs[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e],engagementLocs[e]);
d614 1
a614 2
    std::vector<std::string> engagementLocs;
    getEngagementNames(engagementNames,engagementLocs);
d619 2
a620 2
      int duration = getEngagementDuration(engagementNames[e],engagementLocs[e]);
      std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
d653 1
a653 1
std::string RCPproblem::baseEngagementName(const std::string & engagementName,const std::string & engagementLocationName )
d655 1
a655 1
  return "engagement: "+engagementName+" at: "+engagementLocationName;
d661 1
a661 5
  return textBetween(baseEngagementName,"engagement: "," at: ");
}
std::string RCPproblem::engagementLocationFromBaseEngagementName(const std::string & baseEngagementName)
{
  return textAfter(baseEngagementName," at: ");
d706 1
a706 5
std::string RCPproblem::bomName(const std::string & engagementName,const std::string & engagementLocationName,const std::string & resourceName,const std::string & resourceLocName)
{
  return "bom op: " + engagementName + " engLoc: " + engagementLocationName + " resource: " + resourceName +" at: "+ resourceLocName;
}
std::string RCPproblem::engagementLocationFromBomName(const std::string & bomName)
d708 1
a708 1
  return textBetween(bomName,"engLoc: "," resource: ");
d712 1
a712 1
  return textBetween(bomName,"bom op: "," engLoc: ");
a806 1
  engagementLocationNames_ = source.engagementLocationNames_;
d814 1
a814 1
  getEngagementNames(engagementNames,engagementLocs);
d816 1
a816 1
    std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
d828 1
a828 2
    std::vector<std::string> engagementLocs;
    getEngagementNames(engagementNames,engagementLocs);
d831 1
a831 1
      std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
d857 1
a857 2
  std::vector<std::string> engagementLocs;
  getEngagementNames(engagementNames,engagementLocs);
d859 1
a859 1
    std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
d869 1
a869 2
    std::vector<std::string> engagementLocs;
    getEngagementNames(engagementNames,engagementLocs);
d872 1
a872 1
      std::string theEngagement = baseEngagementName(engagementNames[e], engagementLocs[e]);
d927 2
a928 2
    prob.addEngagement("e1","Loc1");  
    prob.addEngagement("e2", "Loc1");
d930 17
a946 11
    assert(  prob.engagementExists("e1", "Loc1") );
    assert(  prob.engagementExists("e2", "Loc1") );
    assert( !prob.engagementExists("e3", "Loc1") );

    assert( prob.getEngagementRevenue("e1", "Loc1") == 0.0f );
    prob.setEngagementRevenue("e1","Loc1",1.234f);
    assert( prob.getEngagementRevenue("e1","Loc1") == 1.234f );
    prob.setEngagementStartPeriod("e1","Loc1",1);
    assert( prob.getEngagementRequestedStartPeriod("e1","Loc1") == 1 );
    prob.setEngagementDuration("e1","Loc1",3);
    assert( prob.getEngagementDuration("e1","Loc1") == 3 );
d949 1
a949 2
    std::vector<std::string> engagementLocs;
    prob.getEngagementNames(engagementNames,engagementLocs);
d954 1
a954 5
    assert( engagementLocs.size()==2 );
    assert( engagementLocs[0]=="Loc1" || engagementLocs[1]=="Loc1" );
    assert( engagementLocs[0]=="Loc1" || engagementLocs[1]=="Loc1" );

    assert( !prob.getEngagementExecuted("e1", "Loc1") );
d1023 1
a1023 1
    prob.addEngagement("e1","Loc1");
d1025 2
a1026 2
    std::vector<std::string> resourceNames,engagementNames,engagementLocs,resourceLocNames;
    prob.getBomNames(engagementNames,engagementLocs,resourceNames,resourceLocNames);
a1028 1
    assert( engagementLocs.size()==0);
d1031 3
a1033 3
    assert( !prob.bomExists("e1","Loc1","r1","l1") );
    prob.addBom("e1","Loc1","r1","l1");
    assert( prob.bomExists("e1","Loc1","r1","l1") );
d1036 3
a1038 3
    assert( !prob.bomExists("e1","Loc1","r2","l1") );
    prob.addBom("e1","Loc1","r2","l1");
    assert( prob.bomExists("e1","Loc1","r2","l1") );
d1040 1
a1040 1
    prob.getBomNames(engagementNames,engagementLocs,resourceNames,resourceLocNames);
a1043 3
    assert( engagementLocs.size()==2);
    assert( engagementLocs[0]=="Loc1");
    assert( engagementLocs[1]=="Loc1");
d1052 1
a1052 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","Loc1","r2","l1");
d1062 3
a1064 3
    prob.setBomUsageQuantity("e1","Loc1","r2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","Loc1","r2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","Loc1","r2","l1");
d1070 3
a1072 3
    prob.setBomUsageQuantity("e1","Loc1","r2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","Loc1","r2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","Loc1","r2","l1");
d1085 1
a1085 1
      prob1.addEngagement("e1","Loc1");
d1087 7
a1093 7
      prob1.setEngagementRevenue("e1","Loc1",1.0f);
      prob1.setEngagementStartPeriod("e1","Loc1",1);
      prob1.setEngagementDuration("e1","Loc1",3);

      assert(prob1.getEngagementRevenue("e1","Loc1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("e1","Loc1")==1);
      assert(prob1.getEngagementDuration("e1","Loc1")==3);
d1098 3
a1100 3
    assert(prob0.getEngagementRevenue("e1","Loc1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("e1","Loc1")==1);
    assert(prob0.getEngagementDuration("e1","Loc1")==3);    
d1122 4
a1125 4
    assert(prob_acquire.getEngagementExecuted("e1","Loc1"));
    assert(prob_acquire.getEngagementExecuted("e2","Loc1"));
    assert(prob_acquire.getEngagementStartPeriod("e1","Loc1")==1);
    assert(prob_acquire.getEngagementStartPeriod("e2","Loc1")==0);
d1141 1
a1141 1
      prob_delay.getEngagementStartPeriod("e2","Loc1")==0 && prob_delay.getEngagementStartPeriod("e1","Loc1")==3
d1143 1
a1143 1
      prob_delay.getEngagementStartPeriod("e2","Loc1")==3 && prob_delay.getEngagementStartPeriod("e1","Loc1")==0
d1166 1
a1166 1
    assert(prob_decline.getEngagementExecuted("e1","Loc1")==false);
d1187 1
a1187 1
    std::vector<float> shipRewardQty = prob_IGS.getDemandShipReward("e1","Loc1");
d1196 1
a1196 1
    int ed = prob_IGS.getEngagementDuration("e1","Loc1");
d1198 1
a1198 1
    int ela = prob_IGS.getEngagementLateAllowance("e1","Loc1");
d1200 1
a1200 1
    int ersp = prob_IGS.getEngagementRequestedStartPeriod("e1","Loc1");
d1202 1
a1202 1
    int esp = prob_IGS.getEngagementStartPeriod("e1","Loc1");
d1214 1
a1214 1
    prob_IGS.setEngagementLateAllowance("e1","Loc1",0);
d1220 1
a1220 1
    int esp = prob_IGS.getEngagementStartPeriod("e1","Loc1");
@


1.35
log
@Added MRP stuff and fixed duration/offset calculations
@
text
@d395 1
a395 1
std::vector<float> RCPproblem::getEngagementShipReward(const std::string & engagementName, const std::string & engagementLocationName)const
d1200 1
a1200 1
    std::vector<float> shipRewardQty = prob_IGS.getEngagementShipReward("e1","Loc1");
@


1.34
log
@Added test case to make sure that the startPeriod is correct after solve.
@
text
@d115 1
a115 1
	retVal=t-duration+1;
d184 3
d400 26
d427 7
d589 2
a590 2
      int lastPeriod = startPeriod+duration-1;
      if (lastPeriod>np) lastPeriod=np;
d592 3
a594 3
      for ( t=0; t<lastPeriod; ++t ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 || lastPeriod + lateAllowance >= np){
        for ( t=lastPeriod; t<np; ++t ) obj1ShipReward[t]=revenue;
d597 3
a599 2
        for ( t=lastPeriod; t<=lastPeriod + lateAllowance; ++t) obj1ShipReward[t]=revenue;
        for ( t=lastPeriod + lateAllowance +1; t<np; ++t) obj1ShipReward[t]=0.0f;
a600 8

#if 0
      // encourage wit to things on-time
      for (t=1; t<np; t++ ) {
        obj1ShipReward[t]=obj1ShipReward[t-1]*(.99);
      }
#endif

d632 1
a632 1
        float offset = duration - period - 1;
d642 1
d1199 1
a1199 1
    //test that the shipReward is set in periods 7 and 8
d1202 1
a1202 1
    for(i=0; i<7; i++)
d1204 1
d1206 1
a1206 2
    assert(eq(shipRewardQty[8],40000.0f));
    for(i=9; i<16; i++)
@


1.33
log
@Attempted to fix durations
@
text
@d564 8
d1164 1
d1178 27
@


1.32
log
@changed a comment to match what was actually occurring
@
text
@d115 1
a115 1
	retVal=t-duration;
d558 1
a558 1
	for ( t=lastPeriod; t<np; ++t ) obj1ShipReward[t]=revenue;
d561 2
a562 2
	for ( t=lastPeriod; t<=lastPeriod + lateAllowance; ++t) obj1ShipReward[t]=revenue;
	for ( t=lastPeriod + lateAllowance +1; t<np; ++t) obj1ShipReward[t]=0.0f;
d595 1
a595 1
        float offset = duration - period;
@


1.31
log
@Added engagement location to the model.
@
text
@d1096 1
a1096 1
    //test that both engagements get executed starting in period 1 (they have to wait one period to acquire the resources)
@


1.30
log
@Added resourceLocation to rcpProblem methods.
Hardcode resourceLocation as l1 in function populateRCP
@
text
@d30 1
a30 1
void RCPproblem::addEngagement(const std::string & engagementName)
d32 5
a36 4
  witAddPart(witRun(),engagementName.c_str(),WitCAPACITY);
  witAddDemand(witRun(),engagementName.c_str(),engagementName.c_str());
  witAddOperation(witRun(),engagementName.c_str());
  witAddBopEntry(witRun(),engagementName.c_str(),engagementName.c_str());
d39 1
a39 1
  witSetOperationIncLotSize(witRun(),engagementName.c_str(),vecOne);
d43 1
a43 1
  witSetPartAppData(witRun(),engagementName.c_str(),appData);
d45 2
a46 1
  engagementNames_.insert(engagementName);
d49 1
a49 1
bool RCPproblem::engagementExists    (const std::string & engagementName)const
d51 1
a51 1
  return witPartExists(engagementName);
d54 1
a54 1
void RCPproblem::setEngagementRevenue(const std::string & engagementName, 
d58 1
a58 1
  witGetPartAppData(witRun(),engagementName.c_str(),(void**)&appData);
d61 1
a61 1
void RCPproblem::setEngagementStartPeriod(const std::string & engagementName, 
d65 1
a65 1

d68 1
a68 1
  witGetPartAppData(witRun(),engagementName.c_str(),(void**)&appData);
d74 1
a74 1
  witSetDemandDemandVol(witRun(),engagementName.c_str(),engagementName.c_str(),demandVol);
d77 1
a77 1
void RCPproblem::setEngagementDuration(const std::string & engagementName, 
d81 1
a81 1
  witGetPartAppData(witRun(),engagementName.c_str(),(void**)&appData);
d84 1
a84 1
void RCPproblem::setEngagementLateAllowance(const std::string & engagementName, 
d88 1
a88 1
  witGetPartAppData(witRun(),engagementName.c_str(),(void**)&appData);
d93 1
a93 1
float RCPproblem::getEngagementRevenue(const std::string & engagementName)const
d96 1
a96 1
  witGetPartAppData(mutableWitRun(),engagementName.c_str(),(void**)&appData);
d99 1
a99 1
int RCPproblem::getEngagementRequestedStartPeriod(const std::string & engagementName)const
d102 1
a102 1
  witGetPartAppData(mutableWitRun(),engagementName.c_str(),(void**)&appData);
d105 1
a105 1
int RCPproblem::getEngagementStartPeriod(const std::string & engagementName)const
d107 6
a112 6
 bool executed = getEngagementExecuted(engagementName);
 int duration = getEngagementDuration(engagementName);
 int retVal = -1;
 if (!executed) return retVal;
 else {
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,engagementName);
d115 2
a116 2
         retVal=t-duration;
         break;
d123 1
a123 1
int RCPproblem::getEngagementDuration(const std::string & engagementName)const
d126 1
a126 1
  witGetPartAppData(mutableWitRun(),engagementName.c_str(),(void**)&appData);
d130 1
a130 1
int RCPproblem::getEngagementLateAllowance(const std::string & engagementName)const
d133 1
a133 1
  witGetPartAppData(mutableWitRun(),engagementName.c_str(),(void**)&appData);
d138 2
a139 2

void RCPproblem::getEngagementNames( std::vector<std::string> & engagementNames ) const
d142 1
d146 2
a147 1
    engagementNames.push_back( *it );
d151 1
a151 1
bool RCPproblem::getEngagementExecuted(const std::string & engagementName)const
d154 2
a155 1
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,engagementName);
d392 1
a392 1
std::vector<float> RCPproblem::getEngagementShipReward(const std::string & engagementName)const
d394 1
a394 1
  return witGetDemandAttribute(witGetDemandObj1ShipReward,engagementName,engagementName);
d403 1
d407 1
a407 1
  std::string bn = bomName(engagementName,resourceName,resourceLocName);
d418 1
d427 1
a427 1
  int bomIndex = getBomEntryIndex(engagementName,workingRes,period);
d432 1
a432 1
    assert( bomExists(engagementName,resourceName,resourceLocName) );
d434 2
a435 2
    witGetOperationNBomEntries(witRun(),engagementName.c_str(),&bomIndex);
    witAddBomEntry(witRun(),engagementName.c_str(),workingRes.c_str());
d439 1
a439 1
    witSetBomEntryAppData(witRun(),engagementName.c_str(),bomIndex,appData);
d443 1
a443 1
  witSetArcAttribute(witSetBomEntryConsRate,engagementName,bomIndex,usageQuantity);
d453 1
d457 1
a457 1
  std::string bn = bomName(engagementName,resourceName,resourceLocName);
d467 1
d472 1
d479 1
d486 1
d491 1
d493 1
d499 2
a500 2
    int bomIndex = getBomEntryIndex(engagementName,workingRes,t);
    retVal.push_back( getBomUsageQuantity(engagementName,resourceName,resourceLocName,t) );
d507 1
d514 1
d516 1
a516 1
  int bomIndex = getBomEntryIndex(engagementName,workingRes,period);
d523 1
a523 1
      witGetArcAttribute(witGetBomEntryConsRate,engagementName,bomIndex);
d543 2
a544 1
    getEngagementNames(engagementNames);
d547 5
a551 4
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
d564 1
a564 1
      witSetDemandObj1ShipReward(witRun(),engagementNames[e].c_str(),engagementNames[e].c_str(),obj1ShipReward);
d574 2
a575 1
    getEngagementNames(engagementNames);
d580 2
a581 1
      int duration = getEngagementDuration(engagementNames[e]);
d585 1
a585 1
      witGetOperationNBomEntries(mutableWitRun(),engagementNames[e].c_str(),&nBomEntries);
d591 1
a591 1
        witGetBomEntryAppData(mutableWitRun(),engagementNames[e].c_str(),b,(void**)&appData);
d598 1
a598 1
        witSetArcAttribute(witSetBomEntryOffset,engagementNames[e],b,offset);
d609 23
d670 5
a674 1
std::string RCPproblem::bomName(const std::string & engagementName,const std::string & resourceName,const std::string & resourceLocName)
d676 1
a676 1
  return "bom op: " + engagementName + " resource: " + resourceName +" at: "+ resourceLocName;
d680 1
a680 1
  return textBetween(bomName,"bom op: "," resource: ");
d775 1
d782 2
a783 1
  getEngagementNames(engagementNames);
d785 1
d788 1
a788 1
    witGetPartAppData(source.mutableWitRun(),engagementNames[e].c_str(),(void**)&srcAppData);
d790 1
a790 1
    witSetPartAppData(witRun(),engagementNames[e].c_str(),sinkAppData);
d797 2
a798 1
    getEngagementNames(engagementNames);
d801 1
a801 1
      
d804 1
a804 1
      witGetOperationNBomEntries(mutableWitRun(),engagementNames[e].c_str(),&nBomEntries);
d810 1
a810 1
        witGetBomEntryAppData(source.mutableWitRun(),engagementNames[e].c_str(),b,(void**)&srcAppData);
d812 1
a812 1
        witSetBomEntryAppData(witRun(),engagementNames[e].c_str(),b,sinkAppData);
d827 2
a828 1
  getEngagementNames(engagementNames);
d830 1
d832 1
a832 1
    witGetPartAppData(mutableWitRun(),engagementNames[e].c_str(),(void**)&srcAppData);
d840 2
a841 1
    getEngagementNames(engagementNames);
d844 1
a844 1
      
d847 1
a847 1
      witGetOperationNBomEntries(mutableWitRun(),engagementNames[e].c_str(),&nBomEntries);
d852 1
a852 1
        witGetBomEntryAppData(mutableWitRun(),engagementNames[e].c_str(),b,(void**)&srcAppData);
d876 2
d893 1
d895 2
d899 2
a900 2
    prob.addEngagement("e1");  
    prob.addEngagement("e2");
d902 11
a912 11
    assert(  prob.engagementExists("e1") );
    assert(  prob.engagementExists("e2") );
    assert( !prob.engagementExists("e3") );

    assert( prob.getEngagementRevenue("e1") == 0.0f );
    prob.setEngagementRevenue("e1",1.234f);
    assert( prob.getEngagementRevenue("e1") == 1.234f );
    prob.setEngagementStartPeriod("e1",1);
    assert( prob.getEngagementRequestedStartPeriod("e1") == 1 );
    prob.setEngagementDuration("e1",3);
    assert( prob.getEngagementDuration("e1") == 3 );
d915 2
a916 1
    prob.getEngagementNames(engagementNames);
d921 5
a925 1
    assert( !prob.getEngagementExecuted("e1") );
d932 1
d989 1
d994 1
a994 1
    prob.addEngagement("e1");
d996 2
a997 2
    std::vector<std::string> resourceNames,engagementNames,resourceLocNames;
    prob.getBomNames(engagementNames,resourceNames,resourceLocNames);
d1000 1
d1003 3
a1005 3
    assert( !prob.bomExists("e1","r1","l1") );
    prob.addBom("e1","r1","l1");
    assert( prob.bomExists("e1","r1","l1") );
d1008 3
a1010 3
    assert( !prob.bomExists("e1","r2","l1") );
    prob.addBom("e1","r2","l1");
    assert( prob.bomExists("e1","r2","l1") );
d1012 1
a1012 1
    prob.getBomNames(engagementNames,resourceNames,resourceLocNames);
d1016 3
d1027 1
a1027 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2","l1");
d1037 3
a1039 3
    prob.setBomUsageQuantity("e1","r2","l1",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2","l1",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2","l1");
d1045 3
a1047 3
    prob.setBomUsageQuantity("e1","r2","l1",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2","l1",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2","l1");
d1057 1
d1060 1
a1060 1
      prob1.addEngagement("e1");
d1062 7
a1068 7
      prob1.setEngagementRevenue("e1",1.0f);
      prob1.setEngagementStartPeriod("e1",1);
      prob1.setEngagementDuration("e1",3);

      assert(prob1.getEngagementRevenue("e1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("e1")==1);
      assert(prob1.getEngagementDuration("e1")==3);
d1073 3
a1075 3
    assert(prob0.getEngagementRevenue("e1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("e1")==1);
    assert(prob0.getEngagementDuration("e1")==3);    
d1097 4
a1100 4
    assert(prob_acquire.getEngagementExecuted("e1"));
    assert(prob_acquire.getEngagementExecuted("e2"));
    assert(prob_acquire.getEngagementStartPeriod("e1")==1);
    assert(prob_acquire.getEngagementStartPeriod("e2")==0);
d1116 1
a1116 1
      prob_delay.getEngagementStartPeriod("e2")==0 && prob_delay.getEngagementStartPeriod("e1")==3
d1118 1
a1118 1
      prob_delay.getEngagementStartPeriod("e2")==3 && prob_delay.getEngagementStartPeriod("e1")==0
d1141 1
a1141 1
    assert(prob_decline.getEngagementExecuted("e1")==false);
d1161 1
a1161 1
    std::vector<float> shipRewardQty = prob_IGS.getEngagementShipReward("e1");
@


1.29
log
@Added the concept of lateAllowance to allow us to set the ShipReward for a fixed number of periods following the due date.  The lateAllowance value is stored in the engagementAppData.  The engagementFile was modified to add the new field.  I added a CR/LF to the end of populateRCP.h to avoid the warning message from the Linux compiler.
@
text
@d164 1
a164 1
void RCPproblem::addResource(const std::string & resourceName)
d166 4
a169 4
  std::string acquireOp = acquireResourceOperationName(resourceName);
  std::string benchRes = benchResourceName(resourceName);
  std::string enableOp = enableResourceOperationName(resourceName);
  std::string workingRes = workingResourceName(resourceName);
d189 1
a189 1
  resourceNames_.insert(resourceName);
d192 1
a192 1
bool RCPproblem::resourceExists    (const std::string & resourceName)const
d194 1
a194 1
  std::string witName = benchResourceName(resourceName);
d199 3
a201 1
void RCPproblem::getResourceNames( std::vector<std::string> & resourceNames ) const
d204 1
d208 2
a209 1
    resourceNames.push_back( *it );
d214 2
a215 1
                                           const std::string & resourceName, 
d219 1
a219 1
  std::string benchRes = benchResourceName(resourceName);
d226 3
a228 1
std::vector<float> RCPproblem::getResourceSupplyQuantity(const std::string & resourceName)const
d230 1
a230 1
  std::string benchRes = benchResourceName(resourceName);
d234 3
a236 1
std::vector<float> RCPproblem::getResourceWorkingQuantity(const std::string & resourceName)const
d238 1
a238 1
  std::string opName = enableResourceOperationName(resourceName);
d241 3
a243 1
std::vector<float> RCPproblem::getResourceBenchQuantity(const std::string & resourceName)const
d245 1
a245 1
  std::string benchRes = benchResourceName(resourceName);
a246 7
#if 0
  std::vector<float> supplyVol = getResourceSupplyQuantity(resourceName);
  std::vector<float> retVal;
  int t;
  for ( t=0; t<stockVol.size(); ++t )  retVal.push_back(stockVol[t]+supplyVol[t]);
  return retVal;
#endif
d250 3
a252 1
std::vector<float> RCPproblem::getResourceReleaseQuantity(const std::string & resourceName)const
d254 1
a254 1
  std::string partName = benchResourceName(resourceName);
d258 3
a260 1
std::vector<float> RCPproblem::getResourceAcquireQuantity(const std::string & resourceName)const
d262 1
a262 1
  std::string acquireRes = acquireResourceOperationName(resourceName);
d265 6
a270 2
void RCPproblem::setResourceAcquireCost(const std::string & resourceName, float acquireCost){
  std::string acquireOp = acquireResourceOperationName(resourceName);
d276 6
a281 2
void RCPproblem::setResourceAcquireTime(const std::string & resourceName, float acquireTime){
  std::string acquireOp = acquireResourceOperationName(resourceName);
d289 5
a293 1
void RCPproblem::setResourceReleaseTime(const std::string & resourceName, float releaseTime){
d302 6
a307 2
void RCPproblem::setResourceReleaseCost(const std::string & resourceName, float releaseCost){
  std::string benchOp = benchResourceName(resourceName); 
d313 7
a319 3
void RCPproblem::setResourceFixedCost(const std::string & resourceName, float fixedCost){
  std::string benchOp = benchResourceName(resourceName);
  std::string enableOp = enableResourceOperationName(resourceName);
d326 5
a330 2
float RCPproblem::getResourceAcquireCost(const std::string & resourceName) const {
  std::string acquireOp = acquireResourceOperationName(resourceName);
d338 5
a342 2
float RCPproblem::getResourceAcquireTime(const std::string & resourceName) const {
  std::string acquireOp = acquireResourceOperationName(resourceName);
d350 5
a354 2
float RCPproblem::getResourceReleaseCost(const std::string & resourceName) const {
  std::string acquireOp = acquireResourceOperationName(resourceName);
d362 3
a364 1
float RCPproblem::getResourceReleaseTime(const std::string & resourceName) const {
d370 1
d376 4
a379 2
float RCPproblem::getResourceFixedCost(const std::string & resourceName) const {
  std::string acquireOp = benchResourceName(resourceName);
d397 3
a399 1
void RCPproblem::addBom(const std::string & engagementName, const std::string & resourceName)
d401 2
a402 2
  std::string bn = bomName(engagementName,resourceName);
  std::string workingRes = workingResourceName(resourceName);
d410 6
a415 1
void RCPproblem::setBomUsageQuantity(const std::string & engagementName, const std::string & resourceName, int period, float usageQuantity)
d417 1
a417 1
  std::string workingRes = workingResourceName(resourceName);
d425 1
a425 1
    assert( bomExists(engagementName,resourceName) );
d444 4
a447 1
bool RCPproblem::bomExists(const std::string & engagementName, const std::string & resourceName)const
d449 1
a449 1
  std::string bn = bomName(engagementName,resourceName);
d457 4
a460 1
void RCPproblem::getBomNames( std::vector<std::string> & engagementNames, std::vector<std::string> & resourceNames )const
d464 1
d470 1
d473 4
a476 1
std::vector<float> RCPproblem::getBomUsageQuantity(const std::string & engagementName, const std::string & resourceName)const
d479 1
a479 1
  std::string workingRes = workingResourceName(resourceName);
d486 1
a486 1
    retVal.push_back( getBomUsageQuantity(engagementName,resourceName,t) );
d491 5
a495 1
float RCPproblem::getBomUsageQuantity(const std::string & engagementName, const std::string & resourceName,int period)const
d498 1
a498 1
  std::string workingRes = workingResourceName(resourceName);
d592 5
a596 1
std::string RCPproblem::acquireResourceOperationName(const std::string & name )
d598 1
a598 1
  return "acquire: "+name;
d600 1
a600 1
std::string RCPproblem::benchResourceName(const std::string & name )
d602 1
a602 1
  return "bench: "+name;
d604 1
a604 1
std::string RCPproblem::enableResourceOperationName(const std::string & name )
d606 1
a606 1
  return "enable: "+name;
d608 1
a608 1
std::string RCPproblem::workingResourceName(const std::string & name )
d610 1
a610 1
  return "working: "+name;
d613 11
d627 1
a627 1
std::string RCPproblem::bomName(const std::string & engagementName,const std::string & resourceName)
d629 1
a629 1
  return "bom op: " + engagementName + " resource: " + resourceName;
d637 5
a641 1
  return textAfter(bomName," resource: ");
d870 3
a872 3
    prob.addResource("r1");  
    prob.addResource("r2");
    float time = prob.getResourceAcquireTime("r1");
d874 2
a875 2
    prob.setResourceAcquireTime("r1", 2.f);
    assert ( prob.getResourceAcquireTime("r1") == -2.f ); //note that we negate the
d879 3
a881 3
    assert( prob.getResourceAcquireCost("r1") == 0 );
    prob.setResourceAcquireCost("r1", 100.f);
    assert ( prob.getResourceAcquireCost("r1") == 100.f );
d883 2
a884 2
    std::vector<std::string> resourceNames;
    prob.getResourceNames(resourceNames);
d889 4
d894 1
a894 1
    std::vector<float> sq = prob.getResourceSupplyQuantity("r2");
d904 2
a905 2
    prob.setResourceSupplyQuantity("r2",2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity("r2");
d911 2
a912 2
    prob.setResourceSupplyQuantity("r2",0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity("r2");
d926 2
a927 2
    prob.addResource("r1");  
    prob.addResource("r2");
d930 2
a931 2
    std::vector<std::string> resourceNames,engagementNames;
    prob.getBomNames(engagementNames,resourceNames);
d936 3
a938 3
    assert( !prob.bomExists("e1","r1") );
    prob.addBom("e1","r1");
    assert( prob.bomExists("e1","r1") );
d941 3
a943 3
    assert( !prob.bomExists("e1","r2") );
    prob.addBom("e1","r2");
    assert( prob.bomExists("e1","r2") );
d945 1
a945 1
    prob.getBomNames(engagementNames,resourceNames);
d952 3
d957 1
a957 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1","r2");
d967 3
a969 3
    prob.setBomUsageQuantity("e1","r2",2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1","r2",2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1","r2");
d975 3
a977 3
    prob.setBomUsageQuantity("e1","r2",0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1","r2",0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1","r2");
d1021 1
a1021 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1");
d1023 1
a1023 1
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2");
d1049 1
a1049 1
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1");
d1053 1
a1053 1
    acquireQty =prob_delay.getResourceAcquireQuantity("r2");
d1071 1
a1071 1
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1");
d1075 1
a1075 1
    acquireQty =prob_decline.getResourceAcquireQuantity("r2");
@


1.28
log
@The assertions for example_delay were failing in the test for equality with 0 on Linux/Intel.  I modified the test and use the eq(value1, value2) approximate test.
@
text
@d82 8
d128 7
d345 5
d469 1
d475 7
a481 1
      for ( t=lastPeriod; t<np; ++t ) obj1ShipReward[t]=revenue;
d519 1
a519 1
  
d989 21
@


1.27
log
@Modifed assertions to accomodate multiple solutions with same obj value
@
text
@d957 1
a957 1
      assert(acquireQty[i]==0);
d960 1
a960 1
      assert(acquireQty[i]==0);
@


1.26
log
@Modifed assertions to accomodate multiple solutions with same obj value
@
text
@d923 3
d949 3
@


1.25
log
@Moved tests that read data from directories from unitTest.cpp to rcpProblem.cpp
@
text
@d15 1
d900 3
d924 5
a928 2
    assert(prob_delay.getEngagementStartPeriod("e2")==0);
    assert(prob_delay.getEngagementStartPeriod("e1")==3);
@


1.24
log
@moved populate function to a separate file (not part of rcpProblem)
@
text
@d22 1
d887 61
@


1.23
log
@better examples for the unit test
to test various scenarios (acquire; delay; decline)
@
text
@a23 202
void RCPproblem::populate(std::string idir, std::string odir, int nPeriods) {

  //populate the RCPproblem using the given directories and number of periods
  setNPeriods(nPeriods);  
  setOslMesgFileName(odir+"/oslMesgFile.txt");
  
  //---------------------------------------------------------
  // Read engagement file
  //---------------------------------------------------------
  {
    // Read engagement File and set up structures for using data
    std::string engagementFileName = idir + "/engagement.csv";
    RCPengagementFile engagementFile(engagementFileName);
    RCPengagementFileIterator engagementFileIter(engagementFile);
    
    // loop once for each record in engagement file
    for ( ; engagementFileIter()!=NULL; ) {
      std::string engagementName = engagementFileIter.engagementName();
      float revenue = engagementFileIter.revenueAsFloat();
      int startPeriod =  engagementFileIter.startPeriodAsInt();
      int duration =  engagementFileIter.durationAsInt();

      // test to ensure startPeriod is within the planning horizon
      if ( startPeriod >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: startPeriod is beyond planning horizion"                <<std::endl
          <<"   engagement filename: " <<engagementFile.filename().c_str()    <<std::endl
          <<"   engagement file line number: " <<engagementFileIter.recNum()  <<std::endl
          <<"   engagementName: " <<engagementName.c_str()                    <<std::endl
          <<"   startPeriod: " <<startPeriod                                  <<std::endl
          <<"   allowed range: 0<=startPeriod<" <<nPeriods                    <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }


      addEngagement(engagementName);
      setEngagementRevenue(engagementName,revenue);
      setEngagementStartPeriod(engagementName,startPeriod);
      setEngagementDuration(engagementName,duration);
    }
  }
  
  //---------------------------------------------------------
  // Read resource file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resource.csv";
    RCPresourceFile resourceFile(resourceFileName);
    RCPresourceFileIterator resourceFileIter(resourceFile);
    
    // loop once for each record in resource file
    for ( ; resourceFileIter()!=NULL; ) {
      std::string resourceName = resourceFileIter.resourceName();
      int period = resourceFileIter.periodAsInt();
      float supplyQuantity =  resourceFileIter.supplyQuantityAsFloat();
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   resource filename: " <<resourceFile.filename().c_str()        <<std::endl
          <<"   resource file line number: " <<resourceFileIter.recNum()      <<std::endl
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

      if ( !resourceExists(resourceName) )
         addResource(resourceName);

      setResourceSupplyQuantity(resourceName,period,supplyQuantity);
    }
  }

  //---------------------------------------------------------
  // Read resource action file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string resourceFileName = idir + "/resourceaction.csv";
    RCPresourceActionFile resourceActionFile(resourceFileName);
    RCPresourceActionFileIterator resourceActionFileIter(resourceActionFile);
    
    // loop once for each record in resource file
    for ( ; resourceActionFileIter()!=NULL; ) {
      std::string resourceName = resourceActionFileIter.resourceName();
      float acquireCost =  resourceActionFileIter.acquireCostAsFloat();
      float acquireTime =  resourceActionFileIter.acquireTimeAsFloat();
      float releaseCost =  resourceActionFileIter.releaseCostAsFloat();
      float releaseTime =  resourceActionFileIter.releaseTimeAsFloat();
      float fixedCost =  resourceActionFileIter.fixedCostAsFloat();

      // test to ensure that resource exists
      if ( !resourceExists(resourceName) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"                  <<std::endl
          <<"Warning: Resource does not exist"                                         <<std::endl
          <<"   resource action filename: " <<resourceActionFile.filename().c_str()    <<std::endl
          <<"   resource action file line number: " <<resourceActionFileIter.recNum()  <<std::endl
          <<"   resource: " <<resourceName.c_str()                                     <<std::endl
          <<"   record will be ignored. "                                              <<std::endl
          <<"-------------------------------------------------------"                  <<std::endl;
        continue;
      }

      setResourceAcquireTime(resourceName, acquireTime);
      setResourceAcquireCost(resourceName, acquireCost);
      setResourceReleaseTime(resourceName, releaseTime);
      setResourceReleaseCost(resourceName, releaseCost);
      setResourceFixedCost(resourceName, fixedCost);

    }
  }

    
  //---------------------------------------------------------
  // Read bom file
  //---------------------------------------------------------
  {
    // Read resource File and set up structures for using data
    std::string bomFileName = idir + "/bom.csv";
    RCPbomFile bomFile(bomFileName);
    RCPbomFileIterator bomFileIter(bomFile);
    
    // loop once for each record in bom file
    for ( ; bomFileIter()!=NULL; ) {
      std::string resourceName = bomFileIter.resourceName();
      std::string engagementName = bomFileIter.engagementName();
      int period = bomFileIter.periodAsInt();
      float usageQuantity =  bomFileIter.usageQuantityAsFloat();

      // test to ensure that engagement exist
      if ( !engagementExists(engagementName) ) {
        // Engagement does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Engagement does not exist"                             <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // test to ensure that resource exist
      if ( !resourceExists(resourceName) ) {
        // Resource does not exist. Write warning message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: Resource does not exist"                               <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                 <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()               <<std::endl
          <<"   engagement: " <<engagementName.c_str()                       <<std::endl
          <<"   resource: " <<resourceName.c_str()                           <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // test to ensure period is within the planning horizon
      if ( period >= nPeriods ) {
        // Write warning message
        std::cout 
          <<"-------------------------------------------------------"         <<std::endl
          <<"Warning: period is beyond planning horizion"                     <<std::endl
          <<"   bom filename: " <<bomFile.filename().c_str()                  <<std::endl
          <<"   bom file line number: " <<bomFileIter.recNum()                <<std::endl
          <<"   engagement: " <<engagementName.c_str()                        <<std::endl
          <<"   resourceName: " <<resourceName.c_str()                        <<std::endl
          <<"   period: " <<period                                            <<std::endl
          <<"   allowed range: 0<=period<" <<nPeriods                         <<std::endl
          <<"   record will be ignored. "                                     <<std::endl
          <<"-------------------------------------------------------"         <<std::endl;
        continue;
      }

      if ( !bomExists(engagementName,resourceName) )
         addBom(engagementName,resourceName);

      setBomUsageQuantity(engagementName,resourceName,period,usageQuantity);
    }
  }
  
  //---------------------------------------------------------

}

a717 50
	//now do some meaningful tests with various test directories
	RCPproblem prob_acquire;
	std::string inputDirectory, outputDirectory;
	inputDirectory = outputDirectory = "../data/example_acquire";
	//this problem has a short time horizon, and revenue is set so that
	//acquiring new resources is worthwhile
    prob_acquire.populate(inputDirectory, outputDirectory, 5);
    prob_acquire.solve();
	//test that resources got acquired; 2 of r1 and 3 of r2, both in period 1
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1");
	assert(acquireQty[0]==2);
    acquireQty =prob_acquire.getResourceAcquireQuantity("r2");
    assert(acquireQty[0]==3);
	//test that both engagements get executed starting in period 1 (they have to wait one period to acquire the resources)
	assert(prob_acquire.getEngagementExecuted("e1"));
	assert(prob_acquire.getEngagementExecuted("e2"));
	assert(prob_acquire.getEngagementStartPeriod("e1")==1);
	assert(prob_acquire.getEngagementStartPeriod("e2")==0);


	RCPproblem prob_delay;
	inputDirectory = outputDirectory = "../data/example_delay";
	//this problem has a longer time horizon, and revenue is set so that
	//delaying the execution of jobs is worthwhile
    prob_delay.populate(inputDirectory, outputDirectory, 15);
    prob_delay.solve();
	//test that no resources were acquired, and that a job was done late
	assert(prob_delay.getEngagementStartPeriod("e2")==0);
	assert(prob_delay.getEngagementStartPeriod("e1")==3);
    acquireQty =prob_delay.getResourceAcquireQuantity("r1");
	for (int i=0; i<acquireQty.size(); i++)
        assert(acquireQty[i]==0);
    acquireQty =prob_delay.getResourceAcquireQuantity("r2");
	for (int i=0; i<acquireQty.size(); i++)
        assert(acquireQty[i]==0);

	RCPproblem prob_decline;
	inputDirectory = outputDirectory = "../data/example_decline";
	//this problem has a short time horizon, but revenue and acquire costs are such that
	//it is better to decline an engagement
    prob_decline.populate(inputDirectory, outputDirectory, 5);
    prob_decline.solve();
	//test that resources were not acquired and that a job was declined
	assert(prob_decline.getEngagementExecuted("e1")==false);
    acquireQty =prob_decline.getResourceAcquireQuantity("r1");
	for (int i=0; i<acquireQty.size(); i++)
        assert(acquireQty[i]==0);
    acquireQty =prob_decline.getResourceAcquireQuantity("r2");
	for (int i=0; i<acquireQty.size(); i++)
        assert(acquireQty[i]==0);
@


1.22
log
@cleaning up the testing procedures
@
text
@d299 1
a299 1
 int retVal = 0;
d459 3
a461 1
  //std::string acquireOp = acquireResourceOperationName(resourceName);  Still need to model this
d919 51
@


1.21
log
@invert sign of delay for acquiring resources. Subtract duration of engagement
from the time at which execVol>0, so that engagementStartTime is correct.
@
text
@d18 207
d962 3
a964 1
    assert ( prob.getResourceAcquireTime("r1") == 2.f );
a1086 2


@


1.20
log
@-added methods:
   getResourceBenchQuantity
   getResourceReleaseQuantity
-renamed getResourceConsumptionQuantity to getResourceWorkingQuantity
-Global wit attribute execEmptyBom is now being set to true
@
text
@d91 1
d98 1
a98 1
         retVal=t;
d244 3
a246 1
  float * atv = floatToFloatStar(acquireTime);
@


1.19
log
@added new examples (very simple) in example3. Also changed various routines
related to "getEngagementStart" to "getRequestedEngagementStart" so that
we could have a routine to supply the actual start time.
@
text
@d204 6
a209 1
std::vector<float> RCPproblem::getResourceConsumptionQuantity(const std::string & resourceName)const
d212 9
a220 1
  return witGetNameAttribute(witGetPartConsVol,benchRes);
d222 7
d571 1
@


1.18
log
@added resourceActionO file
@
text
@d60 1
a60 1
  appData->setStartPeriod(startPeriod);
d82 1
a82 1
int RCPproblem::getEngagementStartPeriod(const std::string & engagementName)const
d86 17
a102 1
  return appData->getStartPeriod();
d104 1
d415 1
a415 1
      int startPeriod = getEngagementStartPeriod(engagementNames[e]);
d707 1
a707 1
    assert( prob.getEngagementStartPeriod("e1") == 1 );
d843 1
a843 1
      assert(prob1.getEngagementStartPeriod("e1")==1);
d850 1
a850 1
    assert(prob0.getEngagementStartPeriod("e1")==1);
@


1.17
log
@moved the setting of wit's demandVol for setEngagementStartPeriod.
fixed bug in unitTest where it was setting startPeriod beyond the last period
@
text
@d192 5
a196 1

@


1.16
log
@changed name of method floatToConstFloatStar to floatToFloatStar because it makes more sense
@
text
@d55 3
d61 6
a402 2

      witSetDemandAttribute(witGetDemandDemandVol,witSetDemandDemandVol,engagementNames[e],engagementNames[e],startPeriod,1.0f);
d685 2
a686 2
    prob.setEngagementStartPeriod("e1",2);
    assert( prob.getEngagementStartPeriod("e1") == 2 );
d818 1
a818 1
      prob1.setEngagementStartPeriod("e1",2);
d822 1
a822 1
      assert(prob1.getEngagementStartPeriod("e1")==2);
d829 1
a829 1
    assert(prob0.getEngagementStartPeriod("e1")==2);
@


1.15
log
@Modified so DemandVol is now being set (it is an easy problem if there is no demand)
@
text
@d30 1
a30 1
  float * vecOne = floatToConstFloatStar(1.0);
d134 1
a134 1
  float * offsetVec = floatToConstFloatStar(-1.f);
d186 1
a186 1
  float * acv = floatToConstFloatStar(acquireCost);
d193 1
a193 1
  float * atv = floatToConstFloatStar(acquireTime);
d200 1
a200 1
  //  float * rtv = floatToConstFloatStar(releaseTime);
d207 1
a207 1
  float * rcv = floatToConstFloatStar(releaseCost);
d215 1
a215 1
  float * fcv = floatToConstFloatStar(fixedCost);
d394 1
@


1.14
log
@Added methods to get/set resource Action costs and times and then added the calls in rcp.cpp to set action costs.  Also added witWriteData to rcpProblem.cpp to help debug the model.
@
text
@a85 27
#if 0
void RCPproblem::setEngagementParms(const std::string & engagementName, 
                                    float revenue,
                                    int startPeriod,
                                    int duration)
{
  // Set Obj1ShipReward to revenue for all periods

  // Here are two ways to do the same thing.
#if 1
  // This method exposes all calls to WIT API
  int nP;
  witGetNPeriods(mutableWitRun(),&nP);
  int lastPeriod = startPeriod+duration-1;
  if (lastPeriod>nP) lastPeriod=nP;
  float * revenueVec = new float[nP];
  int t;
  for ( t=0; t<lastPeriod; ++t ) revenueVec[t]=0.0f;
  for ( t=lastPeriod; t<nP; ++t ) revenueVec[t]=revenue;
  witSetDemandObj1ShipReward(witRun(),engagementName.c_str(),engagementName.c_str(),revenueVec);
  delete [] revenueVec;
#else
  // This method uses method in the base class
  witSetDemandAttribute(witSetDemandObj1ShipReward,engagementName,engagementName,revenue);
#endif
}
#endif
a86 8
#if 0
float RCPproblem::getEngagementRevenue(const std::string & engagementName)const
{
  std::vector<float> shipReward = witGetDemandAttribute(witGetDemandObj1ShipReward,engagementName,engagementName);
  float retVal = shipReward[shipReward.size()-1];
  return retVal;
}
#endif
a99 15
#if 0
  float * execVol;
  witGetOperationExecVol(mutableWitRun(),enagementName.c_str(),&execVol);
  int np;
  witGetNPeriods(mutableWitRun(),&np);
  bool retVal=false;
  for ( int t=0; t<np; ++t ) {
    if( execVol[t]>0.0 ) {
      retVal=true;
      break;
    }
  }
  witFree(execVol);
  return retVal;
#else
a108 1
#endif
a279 3
#if 0
  witAddBomEntry(witRun(),engagementName.c_str(),workingRes.c_str());
#endif
d293 3
d381 1
d394 1
@


1.13
log
@Modified so an RCP bom maps to many WIT bomEntries. One for each consumption period.
@
text
@d242 1
a242 1
  void RCPproblem::setResourceAcquireTime(const std::string & resourceName, float acquireTime){
d244 26
a269 4
  float * offv = floatToConstFloatStar(acquireTime);
  witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,offv);
  delete [] offv;
  
d283 33
a315 4
  float * acv;
  witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&acv);
  float returnVal = acv[0];
  witFree(acv);
d480 2
a481 2


@


1.12
log
@Added Set/Get acquireTime/Cost for resources
@
text
@d17 1
d278 3
a281 8

#if 0
  // set consumption rate to be 0.0
  int nBoms;
  witGetOperationNBomEntries(mutableWitRun(),engagementName.c_str(),&nBoms);
  float * zeroVec = floatToConstFloatStar(0.0f);
  witSetBomEntryConsRate(witRun(),engagementName.c_str(),nBoms-1,zeroVec);
  delete [] zeroVec;
d291 2
a292 1
  int bomIndex = getBomEntryIndex(engagementName,workingRes);
d294 16
a309 12
  float * uqv = floatToConstFloatStar(usageQuantity);
  witSetBomEntryConsRate(witRun(),
    engagementName.c_str(),bomIndex,
    uqv);
  delete [] uqv;

  int duration = getEngagementDuration(engagementName);
  float * ofv = floatToConstFloatStar(duration-period);
  witSetBomEntryOffset(witRun(),
    engagementName.c_str(),bomIndex,
    ofv);
  delete [] ofv;
d336 16
d354 10
a363 1
  int bomIndex = getBomEntryIndex(engagementName,workingRes);
d365 1
a365 4
  return
    witGetArcAttribute(
    witGetBomEntryConsRate,
    engagementName,bomIndex);
d397 8
d406 23
d472 39
d569 25
d608 23
d750 1
a750 1
    prob.getBomNames(resourceNames,engagementNames);
d777 1
a777 1
      assert( uq[t]==1.0f );
a780 1
#if 0
d784 1
d792 1
a795 1
#endif
@


1.11
log
@Added incLotSize, Offset, ConsRate
@
text
@d234 35
d556 8
a563 1

d593 2
a594 1

d631 1
a631 1
    // Test to ensure usageQuantity defaults to 0
d636 1
a636 1
      assert( uq[t]==0.0f );
d640 1
d654 1
@


1.10
log
@added code to write an output file
@
text
@d29 3
d244 1
d251 1
d262 13
a274 4
  witSetArcAttribute(
    witGetBomEntryConsRate,witSetBomEntryConsRate,
    engagementName,bomIndex,
    period,usageQuantity);
d391 1
a391 1
 // nothing to do
@


1.9
log
@added code methods to addBom and set/get attributes.
added code to read bom file and addBoms and attributes.
@
text
@d225 6
@


1.8
log
@Added set/get methods for Resource SupplyQuantity
@
text
@d225 66
d346 17
d368 2
a369 1
resourceNames_()
d384 2
a385 1
resourceNames_()
d407 1
d533 57
@


1.7
log
@Modified to use witPartAppData for setting/getting rcp engagement revenue, startPeriod, and duration
@
text
@d207 20
d422 24
@


1.6
log
@fixed problem where resources of the same name were being created
@
text
@d16 1
d29 4
d41 21
d63 20
d108 1
d110 1
d117 1
d210 26
d279 2
a280 2
engagementNames_(source.engagementNames_),
resourceNames_(source.resourceNames_)
d290 1
a290 1
    RCPproblem::operator=(rhs);
d299 15
d320 9
a328 1

d371 1
a371 1
    prob.setEngagementParms("e1",1.234f,1,1);
d373 4
d403 25
@


1.5
log
@Added code to read resource file and add resources
@
text
@d33 1
a33 5
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),engagementName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
d139 6
@


1.4
log
@modified setEngagementRevenue to have 2 additional parms (startPeriod and duration).
@
text
@d113 43
d161 21
a181 1
//--------------------------------------------
d187 2
a188 1
engagementNames_()
d202 2
a203 1
engagementNames_(source.engagementNames_)
d281 17
@


1.3
log
@implemented getEngagementRevenue and getEngagements
@
text
@d23 1
a23 1
  witAddPart(witRun(),engagementName.c_str(),WitMATERIAL);
d41 4
a44 1
void RCPproblem::setEngagementRevenue(const std::string & engagementName, float revenue)
d49 1
a49 1
#if 0
d53 2
d56 3
a58 1
  for ( int t=0; t<nP; ++t ) revenueVec[t]=revenue;
d70 1
a70 1
  float retVal = shipReward[0];
d84 28
d206 1
a206 1
    prob.setEngagementRevenue("e1",1.234f);
d214 2
@


1.2
log
@get building on powerVac
@
text
@d40 1
d60 8
a67 1
void RCPproblem::getEngagements( std::vector<std::string> & engagementNames ) const
d69 6
a74 2
  // must implement
  assert(0==1);
a75 1
//float RCPproblem::getEngagementRevenue(const std::string & engagementName)const;
d166 13
@


1.1
log
@Initial revision
@
text
@d59 7
a65 2
void RCPproblem::getEngagements( std::vector<std::string> & engagementNames ) const;
float RCPproblem::getEngagementRevenue(const std::string & engagementName)const;
@


1.1.1.1
log
@initial import
@
text
@@

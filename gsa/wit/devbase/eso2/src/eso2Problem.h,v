head	1.82;
access;
symbols
	abandoningEtnParts:1.53
	beforeEtnParts:1.52
	eso2InitialFileFormats:1.18;
locks; strict;
comment	@ * @;


1.82
date	2008.02.15.01.13.58;	author fasano;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.20.11.06.49;	author fasano;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.19.13.21.02;	author fasano;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.31.09.28.50;	author fasano;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.31.02.30.59;	author fasano;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.10.21.22.54;	author fasano;	state Exp;
branches;
next	1.76;

1.76
date	2006.12.29.19.12.18;	author fasano;	state Exp;
branches;
next	1.75;

1.75
date	2006.10.27.02.19.05;	author fasano;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.09.20.16.33;	author fasano;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.05.17.29.10;	author fasano;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.27.12.23.22;	author fasano;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.09.16.09.01;	author fasano;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.23.15.31.35;	author fasano;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.23.12.22.37;	author fasano;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.23.02.28.42;	author fasano;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.22.22.11.18;	author fasano;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.22.13.49.29;	author fasano;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.14.17.04.14;	author fasano;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.14.16.56.26;	author fasano;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.12.19.44.15;	author fasano;	state Exp;
branches;
next	1.62;

1.62
date	2006.04.12.18.44.39;	author fasano;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.12.13.11.06;	author fasano;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.07.16.57.15;	author fasano;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.03.13.50.26;	author fasano;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.29.02.16.44;	author fasano;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.02.14.31.06;	author fasano;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.29.18.27.37;	author fasano;	state Exp;
branches;
next	1.55;

1.55
date	2004.09.21.17.23.50;	author fasano;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.21.14.21.11;	author fasano;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.18.17.36.29;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.08.02.45.45;	author fasano;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.29.19.16.01;	author fasano;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.24.22.35.20;	author fasano;	state Exp;
branches;
next	1.49;

1.49
date	2003.10.24.22.29.45;	author fasano;	state Exp;
branches;
next	1.48;

1.48
date	2003.10.24.17.22.59;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.16.16.32.32;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.16.15.11.08;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.08.19.00.04;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.08.15.36.46;	author fasano;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.04.12.19.00;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.29.13.20.50;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.14.18.49.52;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.12.13.24.48;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.12.03.02.56;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.27.20.42.36;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.27.20.05.41;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.24.20.11.23;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.21.19.35.21;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.09.15.57.33;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.08.14.09.38;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.01.22.02.19;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.30.01.32.07;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.21.13.54.25;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.17.13.06.13;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.17.01.26.48;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.11.01.19.45;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.04.22.06.13;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.01.15.36.40;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.30.19.04.24;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.20.23.44.31;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.17.01.28.21;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.09.19.43.30;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.28.01.25.08;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.18.10.40;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.12.13.21.29;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.11.13.18.38;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.10.01.51.00;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.10.00.25.49;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.21.36.02;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.09.14.16.01;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.09.02.42.59;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.09.01.24.31;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.09.01.10.37;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.08.23.39.57;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.08.22.54.59;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.08.03.33.44;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.08.02.12.24;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.08.00.47.50;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.07.23.28.02;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.07.20.39.07;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.07.19.12.20;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.07.17.04.19;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Changes to add code to remove cycles. Also removes some pruning messages.
@
text
@#ifndef ESO2problem_h
#define ESO2problem_h

//#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <cassert>

#include <wit.h>

#include "partInterplant.h"

typedef std::pair<std::string,int> ESO2stringIntPair;

extern "C" {typedef witReturnCode (STDCALL * witSetNameFloatStar) (
   WitRun * const theWitRun,
   const char * const name,
   const float * const floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameFloatStarStar) (
   WitRun * const theWitRun,
   const char * const name,
   float ** floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witSetName3FloatStar) (
   WitRun * const theWitRun,
   const char * const operationName,
   const float * const hardLower,
   const float * const softLower,
   const float * const hardUpper);}

extern "C" {typedef witReturnCode (STDCALL * witGetName3FloatStar) (
   WitRun * const theWitRun,
   const char * const operationName,
   float ** hardLower,
   float ** softLower,
   float ** hardUpper);}

extern "C" {typedef witReturnCode (STDCALL * witSetNameIndexFloatStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,
   const float * const floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witSetNameIndexIndexFloatStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,   
   const int subEntryIndex,
   const float * const floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameIndexFloatStarStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,
   float ** floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameIndexIntStarStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,
   int ** intVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameIndexIndexFloatStarStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,   
   const int subEntryIndex,
   float ** floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameIndexIndexIntStarStar) (
   WitRun * const theWitRun,
   const char * const name,   
   const int bopEntryIndex,   
   const int subEntryIndex,
   int ** intVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetNameIndexIndexIntStar) (
   WitRun * const theWitRun,
   const char * const consumingOperationName,
   const int bomEntryIndex,
   const int subsBomEntryIndex,
   int * earliestPeriod);}

extern "C" {typedef witReturnCode (STDCALL * witSetDblNameFloatStar) (
   WitRun * const theWitRun,
   const char * const partName,  
   const char * const demandName, 
   const float * const floatVec);}

extern "C" {typedef witReturnCode (STDCALL * witGetDblNameFloatStarStar) (
   WitRun * const theWitRun,
   const char * const partName,
   const char * const demandName,
   float ** floatVec);}

class ESO2problem  {
public:

  //----------------------------------
  // Methods for global attributes.
  //----------------------------------
  // Set/Get String Describing Problem
  void setTitle(const std::string & title);
  std::string getTitle() const;

  // Set/Get Number of Periods in Problem
  void setNPeriods(int nP);
  inline int getNPeriods() const
  {
    int retVal = nPeriods_;
#ifndef NDEBUG
    //std::cout <<"called getNPeriods()" <<std::endl;
    int nP;
    witGetNPeriods(mutableWitRun(),&nP);
    assert(nP==retVal);
#endif
    return retVal;
  }

  // Set/Get Wholesale Fair Market Value Scale Factor
  void setWfmvScaleFactor(float wfmvScaleFactor, float wfmv2ScaleFactor);
  float getWfmvScaleFactor() const;
  float getWfmv2ScaleFactor() const;
  float getWfmvScaleFactor(int demandFileNumber) const;

  // Set/Get flag to indicate if wfmvScale factor is to be applied for supply from plantLoc when satisfying demand from demandFileNumber
  void setApplyLocWfmvScaleFactor(const std::string & plantLoc,int demandFileNumber);
  bool getApplyLocWfmvScaleFactor(const std::string & plantLoc,int demandFileNumber) const;
  void setUseApplyScaleFactorLoc(bool val);
  bool getUseApplyScaleFactorLoc() const;

  // Set/Get priorities of mtm, features, and looseParts.
  // Priorities are:
  // 1 - high. Select this category of supply first.
  // 2 - medium. 
  // 3 - low. Select this category of supply last.
  // 4 - never. Never consume this category of supply to meet demand.
  void setMtmPriority( int p );
  int getMtmPriority() const;
  void setFeaturePriority( int p );
  int getFeaturePriority() const;
  void setLoosePartPriority( int p );
  int getLoosePartPriority() const;
  void setMtm2Priority( int p );
  int getMtm2Priority() const;
  void setFeature2Priority( int p );
  int getFeature2Priority() const;
  void setLoosePart2Priority( int p );
  int getLoosePart2Priority() const;

  // Set period when supply in period 1 perishes.
  // A value of 0 indicates that any supply not consumed in period 1,
  // is not available for consumption in period 2.
  // A value of 1 indicates that any supply not consumed in period 1,
  // is available for consumption in period 1.
  // A value of 2 indicates that any supply available in period 1 that
  // is not consumed in period 1 or 2, is available for consumption in period 2.
  // This parameter affects the supply of mtm's, features, and loose parts.
  void setPeriod1SupplyPerishPeriod(int period);
  inline int getPeriod1SupplyPerishPeriod() const
  {
    return period1SupplyPerishPeriod_;
  }

  // Set flag which indicates that inventory may be held at demand location
  void setAllowInventoryHoldingAtDemandLocation(bool allow);
  inline bool getAllowInventoryHoldingAtDemandLocation() const
  {
    return allowInventoryHoldingAtDemandLocation_;
  }
  
  // Set flag which indicates that inventory may be held at demand location
  void setRemoveCycles(bool remove);
  inline bool getRemoveCycles() const
  {
    return removeCycles_;
  }

  // There is a scale factor for each demand file
  void setWacScaleFactors( float wsf1, float wsf2 );
  const std::vector<float> & getWacScaleFactors() const;


  // Set OSL Logfile name
  void setSolverLogFileName(const std::string & name);
  
  //----------------------
  // Methods for mtms.
  //----------------------
  void addMtm         (const std::string & mtmName, const std::string & mtmLoc,float demanCost,float demanTime );
  bool mtmExists      (const std::string & mtmName, const std::string & mtmLoc )const;
  void setMtmSupply   (const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
  void setMtmWfmv     (const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
  void setMtmDemanCost(const std::string & mtmName, const std::string & mtmLoc, int period, float cost );
  void setMtmDemanCost(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, const std::vector<float> & cost );
  void setMtmDemanCost(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, int period, float cost );
  void setMtmDemanTime(const std::string & mtmName, const std::string & mtmLoc, int period, float time );
  void setMtmDemanTime(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, const std::vector<float> &  time );
  void setMtmDemanTime(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, int period, float time );
 
  // Get list of all mtms added
  void getMtms( std::vector<std::string> & mtmName, std::vector<std::string> &mtmLocs ) const;
  std::vector<float> getMtmAcquireQty(const std::string & mtmName, const std::string & mtmLoc )const;
  std::vector<float> getMtmAcquireQty(const std::string & mtmName, const std::string & srcLoc, const std::string & destLoc )const;

  std::vector<float> getMtmAcquireQtyWithOffset(const std::string & mtmName, const std::string & mtmLoc )const;
  std::vector<float> getMtmAcquireQtyWithOffset(const std::string & mtmName, const std::string & srcLoc, const std::string & destLoc )const;

  std::vector<float> getMtmSupply(const std::string & mtmName, const std::string & mtmLoc )const;
  std::vector<float> getMtmWfmv(const std::string & mtmName, const std::string & mtmLoc ) const;
  std::vector<float> getMtmDemanCost(const std::string & mtmName, const std::string & mtmLoc ) const;
  std::vector<float> getMtmDemanTime(const std::string & mtmName, const std::string & mtmLoc ) const;
  std::vector<float> getMtmDemanTime(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc ) const;
  
  //----------------------
  // Methods for features.
  //----------------------
  void addFeature      (const std::string & featureName, const std::string & featureLoc );
  bool featureExists   (const std::string & featureName, const std::string & featureLoc )const;
  void setFeatureSupply(const std::string & featureName, const std::string & featureLoc, int period, float supply );
  void setFeatureWfmv  (const std::string & featureName, const std::string & featureLoc, int period, float wholeSaleMarketValue );
   
  // Get list of all features added
  void getFeatures( std::vector<std::string> & featureName, std::vector<std::string> &featureLocs ) const;
  std::vector<float> getFeatureAcquireQty(const std::string & featureName, const std::string & featureLoc )const;
  std::vector<float> getFeatureSupply(const std::string & featureName, const std::string & featureLoc )const;
  std::vector<float> getFeatureWfmv(const std::string & featureName, const std::string & featureLoc )const;

  //----------------------
  // Methods for looseParts.
  //----------------------
  void addLoosePart      (const std::string & loosePartName, const std::string & loosePartLoc );
  bool loosePartExists   (const std::string & loosePartName, const std::string & loosePartLoc )const;
  void setLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc, int period, float supply );
  void setLoosePartWfmv  (const std::string & loosePartName, const std::string & loosePartLoc, int period, float wholeSaleMarketValue );
   
  // Get list of all looseParts added
  void getLooseParts( std::vector<std::string> & loosePartName, std::vector<std::string> &loosePartLocs ) const;
  std::vector<float> getLoosePartAcquireQty(const std::string & loosePartName, const std::string & loosePartLoc )const;
  std::vector<float> getLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc )const;
  std::vector<float> getLoosePartWfmv(const std::string & loosePartName, const std::string & loosePartLoc )const;

  //----------------------
  // Methods for Deman (demanufactuing boms).
  //----------------------
  bool demanBomExists     (const std::string & mtm, const std::string & part, const std::string & loc )const;
  void addDemanBom        (const std::string & mtm, const std::string & part, const std::string & loc );
  void setDemanBomAttachRate(const std::string & mtm, const std::string & part, const std::string & loc, int period, float prodRate );
  std::vector<float> getDemanBomAttachRate( const std::string & mtm, const std::string & part, const std::string & loc ) const;

  std::vector<std::string> getDemanBoms(const std::string & mtm, const std::string & mtmSrcLoc, const std::string & demanLoc)const;

  //----------------------
  // Methods for feature cross referencing
  //----------------------
  bool featureXrefExists      (const std::string & part, const std::string & feature, const std::string & loc )const;
  void addFeatureXref         (const std::string & part, const std::string & feature, const std::string & loc );
  void setFeatureXrefProdRate (const std::string & part, const std::string & feature, const std::string & loc, int period, float prodRate );
  void setFeatureXrefCost     (const std::string & part, const std::string & feature, const std::string & loc, int period, float cost );
  void setFeatureXrefUsageTime(const std::string & part, const std::string & feature, const std::string & loc, int period, float usageTime );
  void setFeatureXrefCost     (const std::string & part, const std::string & feature, const std::string & loc, float cost );
  void setFeatureXrefUsageTime(const std::string & part, const std::string & feature, const std::string & loc, float usageTime );

  void getFeatureXrefs( std::vector<std::string> & parts, std::vector<std::string> & features, std::vector<std::string> &locs ) const;
  std::vector<float> getFeatureXrefVol(const std::string & part,const std::string & feature, const std::string & loc )const;
  std::vector<float> getFeatureXrefCost(const std::string & part,const std::string & feature, const std::string & loc )const;
  std::vector<float> getFeatureXrefProdRate(const std::string & part,const std::string & feature, const std::string & loc )const;

  //----------------------
  // Methods for alt parts
  //----------------------
  bool altExists      (const std::string & partOrFeature, const std::string & altPart, const std::string & loc )const;
  void addAlt         (const std::string & partOrFeature, const std::string & altPart, const std::string & loc, float altCost, float altTime );
  //void setAlternatePartProdRate (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
  //void setAlternatePartCost     (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float cost );
  //void setAlternatePartUsageTime(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float usageTime );
   
  // Get list of all features added
  void getAlts( std::vector<std::string> & partOrFeatures, std::vector<std::string> & altParts, std::vector<std::string> &locs ) const;
  std::set<std::string> getAltPartOrFeature(const std::string & altPart,const std::string & loc) const;
  std::vector<float> getAltVolWithOffset(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
  std::vector<float> getAltVol          (const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
  std::vector<float> getAltConvCost(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
  std::vector<float> getAltConvTime(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
 
  // Given a part name return all locations where the part exists
  std::vector<std::string> getPartLocs(const std::string & partName ) const;

  //----------------------
  // Methods for mtmInterplant
  //----------------------  
  bool mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc )const;
  bool mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc )const;
  void addMtmInterplant        (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime  );
  void setMtmInterplantMoveCost(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost );
  void setMtmInterplantMoveTime(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime );
   
  // Get list of all mtmInterplants added
  void getMtmDemanLocs(
    std::vector<std::string> & mtms,
    std::vector<std::string> & srcLocs,
    std::vector<std::string> & destLocs ) const;
  std::vector<float> getMtmInterplantMoveCost(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getMtmInterplantMoveTime(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getMtmInterplantMoveVol(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  
  //----------------------
  // Methods for partInterplant
  //----------------------
  bool partInterplantExists     (const std::string & part, const std::string & srcLoc, const std::string & destLoc )const;
  void addPartInterplant        (const std::string & part, const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime );
  void setPartInterplantMoveCost(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost );
  void setPartInterplantMoveTime(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime );
   
  // Get list of all partInterplants added
  void getPartInterplants( std::vector<std::string> & parts, std::vector<std::string> & srcLocs, std::vector<std::string> &destLocs ) const;
  std::set<std::string> getPartInterplantSrcLocs( const std::string & part, const std::string & destLoc ) const;
  std::vector<float> getPartInterplantMoveVol(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getPartInterplantMoveVolWithOffset(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getPartInterplantMoveCost(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getPartInterplantMoveTime(const std::string & part, const std::string & srcLoc, const std::string & destLoc ) const;
 
  // 
  void addPartsInterplant(const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime );
  //----------------------
  // Methods for partDemand
  //----------------------
  bool partDemandExists      (const std::string & part, const std::string & custLoc, const std::string & plantLoc )const;
  void addPartDemand         (const std::string & part, const std::string & custLoc, const std::string & plantLoc );
  void setPartDemandDemandVol(const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period, float demandVol );
  void setPartDemandWac      (const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period, float wac );
  void setPartDemandPriority (const std::string & part, const std::string & custLoc, const std::string & plantLoc, int priority );
   
  // Get list of all partDemands added
  void getPartDemands( std::vector<std::string> & parts, std::vector<std::string> & custLocs, std::vector<std::string> &plantLocs ) const;
  std::vector<float> getPartDemandShipVol  (const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  std::vector<float> getPartDemandDemandVol(const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  std::vector<float> getPartDemandWac(const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  std::vector<float> getPartDemandScaledWac(const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  int getPartDemandPriority (const std::string & part, const std::string & custLoc, const std::string & plantLoc ) const;

  // Report on details on avail supply for a part demand.
  void reportPartDemand(const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period )const;

  // Pegging information
  std::set<std::string> getPartDemandPeggedAttributeNames(
    const std::string & part, const std::string & custLoc, const std::string & plantLoc, int shipPeriod )const;
  void getPartDemandPegging(
    const std::string & peggedAttributeName,
    const std::string & part, const std::string & custLoc, const std::string & plantLoc, int shipPeriod,

    std::vector<std::string> & items, 
    std::vector<std::string> & locs, 
    std::vector<int> & periods, 
    std::vector<int> & depths, 
    std::vector<float> & quantity ) const;

#if 0
  void getPartDemandPegging(
    const std::string & part, const std::string & custLoc, const std::string & plantLoc, int shipPeriod,

    std::vector<std::string> & acquiredMtms, 
    std::vector<std::string> & acquiredMtmSrcLocs, 
    std::vector<std::string> & acquiredMtmAcquireLocs, 
    std::vector<int> & acquiredMtmAcquirePeriods, 
    std::vector<float> & acquiredMtmAcquireQuantity,

    std::vector<std::string> & demanMtms,
    std::vector<std::string> & demanLocs,
    std::vector<int> & demanPeriods,
    std::vector<float> & demanQuantities,

    std::vector<std::string> & features, 
    std::vector<std::string> & featurePlantLocs, 
    std::vector<int> & featureAcquirePeriods, 
    std::vector<float> & featureAcquireQuantity,

    std::vector<std::string> & looseParts, 
    std::vector<std::string> & loosePartPlantLocs, 
    std::vector<int> & loosePartAcquirePeriods, 
    std::vector<float> & loosePartAcquireQuantity )
    const;
#endif

  //----------------------
  // Methods for part.
  //----------------------
  bool partExists(const std::string & part, const std::string & partLoc )const;


  //----------------------
  // Remove inactive objects from (wit) model.
  // This is in an effort to improve performance.
  //----------------------
  void pruneWitModel();

  
  //----------------------
  // Attempt to remove cycles from BOM
  //----------------------
  void removeCycles();


  //----------------------
  // Label depth of Wit Objects to determine order that they are performed.
  // This is important when they are done in the same period.
  // This info is needed for the pegged reports
  //----------------------
  void labelObjectDepth(    
    std::map<std::string,int> & operationDepths,
    std::map<std::string,int> & partDepths);

  //----------------------
  // Methods for partShipReportO
  //----------------------
  

  //--------------------
  // Solve Methods. 
  //--------------------
  void solve();
  void solveWithPegging();

  
  //--------------------
  // Key Performance Indicators
  //--------------------
  double getObjValue() const;
  void mtmMetrics(
    double & totalWfmvWithScale,
    double & sumAcquireCost,
    double & sumMoveCost,
    double & sumDemanCost,
    int & numUnique,
    int & numUniqueAcquired,
    double & supplyQuantity,
    double & acquiredQuantity)
    const;
  void featureMetrics(
    double & totalWfmvWithScale,
    double & sumAcquireCost,
    double & sumXrefCost,
    int & numUnique,
    int & numUniqueAcquired,
    double & supplyQuantity,
    double & acquiredQuantity)
    const;
  void loosePartMetrics(
    double & totalWfmvWithScale,
    double & sumAcquireCost,
    double & sumAltCost,
    int & numUnique,
    int & numUniqueAcquired,
    double & supplyQuantity,
    double & acquiredQuantity)
    const;
  void partDemandMetrics(
    double & sumDemandWac,
    double & sumShippedWac,
    std::map<std::string,double> & sumShippedWacComponents,
    int & numUnique,
    int & numUniqueShipped,
    double & sumDemandVol,
    double & sumShipVol)
    const;
  double sumOfWac(std::map<std::string,double> & wacComponents) const;
  double sumOfFeatureWfmvWithScaleFactor() const;
  double sumOfLoosePartWfmvWithScaleFactor() const;
  double sumOfMtmWfmvWithScaleFactor() const;
  double sumOfMtmWfmvWithScaleFactorAndMoveCost() const;
  double sumOfDemanCost() const;
  double sumOfPartMoveCost() const;
  double sumOfMtmMoveCost() const;
  double sumOfFeatureXrefCost() const;
  double sumOfAltCost() const;


  //----------------------------------------------------------------------

  void writeWitData( std::string filename ) const;

  //----------------------------------------------------------------------

  static float bigM() { return 1000000.0f; };

  //----------------------------------------------------------------------

  // default constructor
  ESO2problem();
  
  // copy constructor
  ESO2problem( const ESO2problem& source );
  
  // assignment operator
  ESO2problem&
  operator=(const ESO2problem& rhs);
  
  // destructor
  ~ESO2problem();
  

  // Self-test
  static void test();

private:

  
  //----------------------
  // Methods for part.
  //----------------------
  void addPart(const std::string & part, const std::string & partLoc );
  void addPartWithOutApplyingInterplants(const std::string & part, const std::string & partLoc );
  void reportPart(
    const std::string & witPartName, 
    int period,int recursionDepth,
    float volume,
    float value  ) const;

  // add capacity. ensure scrap cost is high so anything acquired is consumed.
  // this is a wrapper for witAddPart(wr,name,WitCAPACITY);
  void addNonScrapableCapacity(const std::string & name );
  
  // Set prodRates from attach rates
  void setDemanBomAndFeatureXrefProdRates();
  
  // Set wit bounds and ensure that hlb<=slb<=hub
  // This condition is not being met.
  void setExecBounds(
    const std::string opName,
    std::vector<float> hlb,
    std::vector<float> slb,
    std::vector<float> hub );
  
  // Compute multilevel impact period given vector of impactPeriods
  typedef std::vector<int> StdVecInt;
  static std::vector<int> multiLevelImpactPeriod( const std::vector<StdVecInt> & impPersVecs );
  
  // uses kevin's logic to determine if supply being consumed
  // will be from period 0 (usePerishableSupply) or period>0 (don't usePerishableSupply)
   bool useMtmPerishableSupply(
     const std::string & mtm,
     const std::string & srcLoc,
     const std::string & destLoc,
     int period );
   bool useFeaturePerishableSupply(
     const std::string & feature,
     const std::string & featureLoc,
     int period );
   bool useLoosePartPerishableSupply(
     const std::string & part,
     const std::string & partLoc,
     int period );
   bool usePerishableSupply(
     const std::string & witAcquireOpName,
     const std::string & witAcquiredPartName,
     int period );
   
  // Set element of Part/Operation float* attribute, given period and fltValue
  void witSetNameAttribute(
    witGetNameFloatStarStar witGetFunc,
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    int period, 
    float supply ); 
  
  // Set Part/Operation float* attribute, given std::vector<float>
  void witSetNameAttribute(
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    const std::vector<float> & value );

  // Set Part/Operation float* attribute, given float
  void witSetNameAttribute(
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    float value );
  
  // Set Part/Operation bound attribute, given three std::vector<float> vectors
  void witSetNameBoundAttribute(
    witSetName3FloatStar     witSetFunc,
    const std::string & name,
    const std::vector<float> & hlb,
    const std::vector<float> & slb,
    const std::vector<float> & hub );

  // Set element on bom/bop float* attribute, given period and fltValue
  void witSetArcAttribute(
    witGetNameIndexFloatStarStar witGetFunc,
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    int period, 
    float flt );

  // Set element on bom/bop float* attribute, given std::vector<float>
  void witSetArcAttribute(
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    const std::vector<float> & value );

  // Set element on bom/bop float* attribute, given float
  void witSetArcAttribute(
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    float value );    

  // Set element on demand float* attribute, given period and fltValue
  void witSetDemandAttribute(
    witGetDblNameFloatStarStar      witGetFunc,
    witSetDblNameFloatStar          witSetFunc,
    const std::string & partName,
    const std::string & demandName,
    int period, 
    float flt );    

  // Set element on demand float* attribute, given std::vector<float>
  void witSetDemandAttribute(
    witSetDblNameFloatStar          witSetFunc,
    const std::string & partName,
    const std::string & demandName,
    const std::vector<float> & fltVec );
  
  // Get vector of wit part/Operation float* attribute
  std::vector<float> witGetNameAttribute(
    witGetNameFloatStarStar witGetFunc,
    const std::string & name )const;

  // Get vector of bom/bop float* attribute
  std::vector<float> witGetArcAttribute(
    witGetNameIndexFloatStarStar     witGetFunc,
    const std::string & opName,
    int index )const;
  // Get vector of bom/bop int* attribute
  std::vector<int> witGetArcAttribute(
    witGetNameIndexIntStarStar     witGetFunc,
    const std::string & opName,
    int index )const;

  
  // Get vector of sub float* attribute
  std::vector<float> witGetSubArcAttribute(
    witGetNameIndexIndexFloatStarStar     witGetFunc,
    const std::string & opName,
    int index, int subIndex )const;
  // Get vector of sub int* attribute
  std::vector<int> witGetSubArcAttribute(
    witGetNameIndexIndexIntStarStar     witGetFunc,
    const std::string & opName,
    int index, int subIndex )const;
  // Get vector of sub int attribute
  int witGetSubArcAttribute(
    witGetNameIndexIndexIntStar     witGetFunc,
    const std::string & opName,
    int index, int subIndex )const;
  
  // Set sub float* attribute, given period and fltValue
  void witSetSubArcAttribute(
    witGetNameIndexIndexFloatStarStar witGetFunc,
    witSetNameIndexIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index, int subIndex,
    int period, 
    float flt );

  // Get vector of wit demand float* attribute
  std::vector<float> witGetDemandAttribute(
    witGetDblNameFloatStarStar witGetFunc,
    const std::string & partName,
    const std::string & demandName )const;

  
  // Get Part/Operation bound attributes, given three std::vector<float> vectors
  void witGetNameBoundAttribute(
    witGetName3FloatStar     witGetFunc,
    const std::string & name,
    std::vector<float> & hlb,
    std::vector<float> & slb,
    std::vector<float> & hub )const;

  std::vector<std::string> witGetOperProducts(const std::string & opName) const;

  // MTM Name Methods
  static std::string igfMtmName(const std::string & mtm,const std::string & mtmLoc );
  static std::string acquireMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc );
  static std::string serverMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc  );
  static std::string demanMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc  );
  static std::string baseMtmName(const std::string & mtm,const std::string & mtmDestLoc );
  static std::string mtmFromMtmName(const std::string & mtmName);
  static std::string mtmDestLocFromMtmName(const std::string & mtmName);
  static std::string mtmSrcLocFromMtmName(const std::string & mtmName);
  static bool isMtmDemanName( const std::string & witName );
  static bool isAcquireMtmName( const std::string & witName );

  static bool isAcquireName( const std::string & witName );

  // Feature Name Methods
  static std::string igfFeatureName(const std::string & feature,const std::string & loc );
  static std::string acquireFeatureName(const std::string & feature,const std::string & loc );
  static std::string baseFeatureName(const std::string & feature,const std::string & loc );
  static std::string featureFromFeatureName(const std::string & featureName);
  static std::string locFromFeatureName(const std::string & featureName);
  static bool isAcquireFeatureName( const std::string & witName );

  // Loose Part Name Methods
  static std::string igfLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string acquireLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string baseLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string loosePartFromLoosePartName(const std::string & loosePartName);
  static std::string locFromLoosePartName(const std::string & loosePartName);
  static bool isAcquireLoosePartName( const std::string & witName );

  // feature cross reference name methods
  static std::string featureXrefName(const std::string & part, const std::string & feature, const std::string & loc);
  static std::string partFromFeatureXrefName(const std::string & featXrefName );
  static std::string featureFromFeatureXrefName(const std::string & featXrefName);
  static std::string locFromFeatureXrefName(const std::string & featXrefName);
  static bool isFeatureXrefName( const std::string & witName );

  // alternate name methods
  static std::string altName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc);
  static std::string partFromAltName(const std::string & etnCspName);
  static std::string altPartFromAltName(const std::string & etnCspName);
  static std::string locFromAltName(const std::string & etnCspName);
  static bool isAltName( const std::string & witName );

  // partInterplant name methods
  static std::string partInterplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc);
  static std::string partFromPartInterplantName(const std::string & partInterplantName);
  static std::string srcLocFromPartInterplantName(const std::string & partInterplantName);
  static std::string destLocFromPartInterplantName(const std::string & partInterplantName);
  static bool isPartInterplantName( const std::string & witName );

  // partDemand name methods
  static std::string partDemandName(const std::string & part, const std::string & custLoc, const std::string & plantLoc);
  static std::string partDemandRegulatorName(const std::string & part, const std::string & custLoc, const std::string & plantLoc);
  static std::string partDemandInventoryName(const std::string & part, const std::string & custLoc, const std::string & plantLoc);
  static std::string partFromPartDemandName(const std::string & partDemandName);
  static std::string custLocFromPartDemandName(const std::string & partDemandName);
  static std::string plantLocFromPartDemandName(const std::string & partDemandName);

  // Part Name Methods  
  static std::string partName(const std::string & part,const std::string & loc );
  static std::string moveablePartName(const std::string & part,const std::string & loc );
  static std::string partFromPartName( const std::string & partName );
  static std::string locFromPartName( const std::string & partName );

  // Cycle Breaking Name Methods
  static std::string cycleBreakingPartName(const std::vector<std::string> & partNames);
  static std::string cycleBreakingOperationName(const std::string & ecOpNameInCycle, const std::vector<std::string> & partNamesInCycle);

  // String Utilities
  static std::string textBetween(const std::string & src, const std::string & before,const std::string & after);
  static std::string textAfter(const std::string & src, const std::string & before);
  static bool beginsWith(const std::string & src, const std::string & begString);
  static bool contains(const std::string & haystack, const std::string & needle);

  // get index of bop entry  
  int getBopEntryIndex( 
    const std::string & mtm, 
    const std::string & part, 
    const std::string & loc ) const;
  int getBopEntryIndex( 
    const std::string & opName, 
    const std::string & partName ) const;

  void addSubsForPeriod1SupplyPerishPeriod(
       const std::string & acquireOperation, 
       const std::string & acquiredPart,
       float moveTime);
    
  public:
  inline std::vector<float> witFloatStarToStlVec(const float * inputVec ) const
  {
    std::vector<float>  retVal;
    int np = getNPeriods();
    int i;
    for ( i=0; i<np; ++i ) retVal.push_back(inputVec[i]);
    return retVal;
  };

  inline std::vector<int> witIntStarToStlVec(const int * inputVec ) const
  {
    std::vector<int>  retVal;
    int np = getNPeriods();
    int i;
    for ( i=0; i<np; ++i ) retVal.push_back(inputVec[i]);
    return retVal;
  };

  inline float * stlVecToFloatStar(const std::vector<float> & inputVector ) const
  {
    size_t len = inputVector.size();
    float * retVal = NULL;
    if ( len > 0 ) {
      //retVal = (float *) malloc(len*sizeof(float));
      retVal = new float[len];
      size_t i;
      for ( i=0; i<len; ++i ) retVal[i] = inputVector[i];
    }
    return retVal;
  };
  
  inline float * floatToConstFloatStar(float input ) const
  {
    int len = getNPeriods();
    //float * retVal = (float *) malloc(len*sizeof(float));
    float * retVal = new float[len];
    int i;
    for ( i=0; i<len; ++i ) retVal[i] = input;
    return retVal;
  };
  
  inline std::vector<float> floatToStlVec(float input ) const
  {
    int len = getNPeriods();
    std::vector<float> retVal;
    int i;
    for ( i=0; i<len; ++i ) retVal.push_back(input);
    return retVal;
  };
#if 0
  inline std::vector<int> intToStlVec(int input ) const
  {
    int len = getNPeriods();
    std::vector<int> retVal;
    int i;
    for ( i=0; i<len; ++i ) retVal.push_back(input);
    return retVal;
  };
#endif

  private:

  int getMtmPriority(int demandPriority) const;
  int getFeaturePriority(int demandPriority) const;
  int getLoosePartPriority(int demandPriority) const;

  void setDemanBomAndFeatureXrefProdRatesAreSet(bool v) {
    demanBomAndFeatureXrefProdRatesAreSet_=v;
  };
  bool getDemanBomProdRatesAreSet() const {
    return demanBomAndFeatureXrefProdRatesAreSet_;
  };

  // Get an operations execVol shifted by Bom offset (requires that operation only has 1 bom).
  // An example use is a move operation.  The execVol provides the arrival period of the move.  The shifted
  // execVol returned by this method returns the execVol when the move starts.
  std::vector<float> getOffsetExecVol(const std::string & witOpName ) const;

  //------------------------
  bool witGetDemandExists(const std::string & demandedPartName,const std::string & demandName) const;
  bool witGetSubsBomEntryExists(
                                           const std::string & operationName,
                                           int bomEntry,
                                           int subEntry) const;
  static void compareWitSolutionsTimeVec(
                                const std::string & id,
                                const std::vector<float> & execTv1,
                                const std::vector<float> & execTv2, 
                                const std::vector<float> & costTv1,
                                const std::vector<float> & costTv2 );
  static void compareWitSolutions( const ESO2problem & p1,  const ESO2problem & p2 );
  //------------------------
  
  // Internal method used by pruning function
  void updateActivePartList(const std::string & partName,std::set<std::string> &activeParts) const;

  // Perform wit pegging and save results in eso2Problem data structures
  void doPegging();

private:
  // if the typedef is not used, then ms compiler will not compile program
  typedef std::set<std::string> ESOstringSet;
  typedef std::set<std::string>::iterator ESOstringSetIterator;
  typedef std::set<std::string>::const_iterator ESOstringSetConstIterator;
  typedef std::map<std::string,ESOstringSet> ESOmapStringToStringSet;
  typedef std::map<std::string,ESOstringSet>::iterator ESOmapStringToStringSetIterator;
  typedef std::map<std::string,ESOstringSet>::const_iterator ESOmapStringToStringSetConstIterator;

  typedef std::vector<ESO2partInterplant> ESO2partInterplantVec;
  typedef std::map<std::string,ESO2partInterplantVec> ESO2mapStringToPartInterplantVec;

  void addMtmAcquireLoc(const std::string & mtmSrcLoc, const std::string & mtmAcquireLoc ); 
  bool mtmAcquireLocExists(const std::string & mtmName, const std::string & mtmAcquireLoc ) const;
  bool mtmAcquireExists(const std::string & mtmName ) const;
  const ESOstringSet & getMtmAcquireLocs(const std::string & mtmSrcLoc)const;

  void addPartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc );
  void removePartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc );

  WitRun * mutableWitRun() const;
  WitRun * witRun();

  // return number of calls to witImplode
  int implosionCount() const;

  void gutsOfCopy( const ESO2problem& source );
  void gutsOfDestructor();

  mutable WitRun * wr_;
  int implosionCount_;

  int nPeriods_; // cached for performance

  std::set<std::string> mtmNames_; 
  std::set<std::string> featureNames_; 
  std::set<std::string> loosePartNames_; 
  std::set<std::string> xrefFeatures_; 
  std::set<std::string> alts_; 
  std::set<std::string> partInterplants_;  
  std::set<std::string> partDemands_; 

  bool demanBomAndFeatureXrefProdRatesAreSet_;

  ESOmapStringToStringSet mtmAcquireLocs_;
  ESOmapStringToStringSet partOrFeatureLocs_;  // given a part, what locations can it be found at.
  ESO2mapStringToPartInterplantVec defaultPartInterplants_;  

  ESOstringSet perishableSupplyWarningMsgTested_;

  int mtmPriority_;
  int featurePriority_;
  int loosePartPriority_;
  int mtm2Priority_;
  int feature2Priority_;
  int loosePart2Priority_;

  std::vector<float> wacScaleFactors_;
  std::set<std::pair<std::string,int> > wfmvLocScaleFactorSfDemandFilePair_;
  bool allowInventoryHoldingAtDemandLocation_;
  bool removeCycles_;
  bool useApplyScaleFactorLoc_;
  int period1SupplyPerishPeriod_;

};


#endif
@


1.81
log
@Restructured to get ready to implement solve that tolerates cycles.
Added a new method call sovleWithCycles.
At momement it just invokes solve followed by doPegging.
@
text
@d174 7
d400 6
d750 5
d936 1
@


1.80
log
@Modified pruning function to not use witGetPartBelowList.
@
text
@d412 1
d855 3
@


1.79
log
@no message
@
text
@d850 3
@


1.78
log
@added useApplyScaleFactorLocData to globalAttrData and code to support this attribute
@
text
@d132 2
a133 1
  bool getApplyLocWfmvScaleFactor() const;
d911 1
@


1.77
log
@Added code to compute source of supply that makes up totalWac
@
text
@d132 1
@


1.76
log
@Updated eso2Problem to optionally allow inventory to be held at demand location
@
text
@d340 1
a340 1
  std::vector<std::string> getPartDemandPeggedAttributeNames(
d447 1
d453 1
a453 1
  double sumOfWac() const;
@


1.75
log
@Updated to implement applyScaleFactorLoc
@
text
@d166 7
d724 1
d907 1
@


1.74
log
@Updated to have depth of pegging activity.
@
text
@d127 5
d898 1
@


1.73
log
@Changed code so that *O.csv files no longer has offset periods.
Attempted to remove in pegged file a move where the from/to locations are the same
@
text
@d337 1
d379 10
@


1.72
log
@Fixup partShipReportO
@
text
@d187 4
d263 2
a264 1
  std::vector<float> getAltVol(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
d301 1
a380 2
  std::vector<float> getAltVolForPartShipReportO(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
  std::vector<float> getPartInterplantMoveVolForPartShipReportO(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
@


1.71
log
@Modified to use new wit API names that doesn't reference OSL
@
text
@d372 7
@


1.70
log
@Added pegging of FeatureXref and AltPart operations
@
text
@d167 1
a167 1
  void setOslMesgFileName(const std::string & name);
@


1.69
log
@modified function which offsets execVol to impact period.  some other clean up.
@
text
@d671 1
d678 1
@


1.68
log
@implemented pegging of harvested and moved parts
@
text
@d791 4
a794 2
  // Use this method to get the quantity at the start of an operation rather than the end.
  std::vector<float> shiftAttributeByOffset(const std::vector<float> & attrValue, const std::vector<float> & offset) const;
@


1.67
log
@Modified eso2 & eso2Problem to use generalized storing of pegged attributes in partDemandAppData
@
text
@d683 1
@


1.66
log
@Added pegging of deman info
@
text
@d322 12
d358 1
@


1.65
log
@modified to compile on aix
@
text
@d325 10
a334 5
    std::vector<std::string> & mtms, 
    std::vector<std::string> & mtmSrcLocs, 
    std::vector<std::string> & mtmAcquireLocs, 
    std::vector<int> & mtmAcquirePeriods, 
    std::vector<float> & mtmAcquireQuantity,
@


1.64
log
@added wac scale factors (one for each demand file)
@
text
@d162 1
a162 1
  void ESO2problem::setWacScaleFactors( float wsf1, float wsf2 );
@


1.63
log
@modified to compile on aix
@
text
@d161 4
d315 1
d550 8
a557 1
    float flt );
d847 1
@


1.62
log
@Updated to all setting of mtm, feature, and loosePart priority when satisfying priority 2 demand.
@
text
@d532 1
a532 1
  void ESO2problem::witSetArcAttribute(
@


1.61
log
@Updated to add wfmv2ScaleFactor
@
text
@d140 6
d749 4
d831 3
@


1.60
log
@Modified the setting of feature conversion cost and time by adding a new block that loops over the records in the featureConversionOverride data file.
@
text
@d124 1
a124 1
  void setWfmvScaleFactor(float sf);
d126 1
d251 1
@


1.59
log
@Added a more general method for dealing with the ETN flags
@
text
@d228 2
d523 7
@


1.58
log
@updated to add low priority demand file
@
text
@d283 1
d695 1
a695 1
      int i;
d739 3
@


1.57
log
@Modified to try to write a report with info kevin is asking for
@
text
@d175 1
d180 1
a268 1
  std::vector<float> getMtmAcquireQty(const std::string & mtmName, const std::string & srcLoc, const std::string & destLoc )const;
d293 1
d300 1
d689 1
a689 1
    int len = inputVector.size();
@


1.56
log
@changed code to use std::string rather than BCP_string
@
text
@d243 1
d279 1
@


1.55
log
@Changes to add loc to altData file.
Changes to start implementing PIP (pegging).
@
text
@a13 1
#include "BCP_string.h"
d106 2
a107 2
  void setTitle(const BCP_string & title);
  BCP_string getTitle() const;
d156 1
a156 1
  void setOslMesgFileName(const BCP_string & name);
d161 10
a170 10
  void addMtm         (const BCP_string & mtmName, const BCP_string & mtmLoc,float demanCost,float demanTime );
  bool mtmExists      (const BCP_string & mtmName, const BCP_string & mtmLoc )const;
  void setMtmSupply   (const BCP_string & mtmName, const BCP_string & mtmLoc, int period, float supply );
  void setMtmWfmv     (const BCP_string & mtmName, const BCP_string & mtmLoc, int period, float supply );
  void setMtmDemanCost(const BCP_string & mtmName, const BCP_string & mtmLoc, int period, float cost );
  void setMtmDemanCost(const BCP_string & mtmName, const BCP_string & supplyLoc, const BCP_string & demanLoc, const std::vector<float> & cost );
  void setMtmDemanCost(const BCP_string & mtmName, const BCP_string & supplyLoc, const BCP_string & demanLoc, int period, float cost );
  void setMtmDemanTime(const BCP_string & mtmName, const BCP_string & mtmLoc, int period, float time );
  void setMtmDemanTime(const BCP_string & mtmName, const BCP_string & supplyLoc, const BCP_string & demanLoc, const std::vector<float> &  time );
  void setMtmDemanTime(const BCP_string & mtmName, const BCP_string & supplyLoc, const BCP_string & demanLoc, int period, float time );
d173 6
a178 6
  void getMtms( std::vector<BCP_string> & mtmName, std::vector<BCP_string> &mtmLocs ) const;
  std::vector<float> getMtmAcquireQty(const BCP_string & mtmName, const BCP_string & mtmLoc )const;
  std::vector<float> getMtmSupply(const BCP_string & mtmName, const BCP_string & mtmLoc )const;
  std::vector<float> getMtmWfmv(const BCP_string & mtmName, const BCP_string & mtmLoc ) const;
  std::vector<float> getMtmDemanCost(const BCP_string & mtmName, const BCP_string & mtmLoc ) const;
  std::vector<float> getMtmDemanTime(const BCP_string & mtmName, const BCP_string & mtmLoc ) const;
d183 4
a186 4
  void addFeature      (const BCP_string & featureName, const BCP_string & featureLoc );
  bool featureExists   (const BCP_string & featureName, const BCP_string & featureLoc )const;
  void setFeatureSupply(const BCP_string & featureName, const BCP_string & featureLoc, int period, float supply );
  void setFeatureWfmv  (const BCP_string & featureName, const BCP_string & featureLoc, int period, float wholeSaleMarketValue );
d189 4
a192 4
  void getFeatures( std::vector<BCP_string> & featureName, std::vector<BCP_string> &featureLocs ) const;
  std::vector<float> getFeatureAcquireQty(const BCP_string & featureName, const BCP_string & featureLoc )const;
  std::vector<float> getFeatureSupply(const BCP_string & featureName, const BCP_string & featureLoc )const;
  std::vector<float> getFeatureWfmv(const BCP_string & featureName, const BCP_string & featureLoc )const;
d197 4
a200 4
  void addLoosePart      (const BCP_string & loosePartName, const BCP_string & loosePartLoc );
  bool loosePartExists   (const BCP_string & loosePartName, const BCP_string & loosePartLoc )const;
  void setLoosePartSupply(const BCP_string & loosePartName, const BCP_string & loosePartLoc, int period, float supply );
  void setLoosePartWfmv  (const BCP_string & loosePartName, const BCP_string & loosePartLoc, int period, float wholeSaleMarketValue );
d203 4
a206 4
  void getLooseParts( std::vector<BCP_string> & loosePartName, std::vector<BCP_string> &loosePartLocs ) const;
  std::vector<float> getLoosePartAcquireQty(const BCP_string & loosePartName, const BCP_string & loosePartLoc )const;
  std::vector<float> getLoosePartSupply(const BCP_string & loosePartName, const BCP_string & loosePartLoc )const;
  std::vector<float> getLoosePartWfmv(const BCP_string & loosePartName, const BCP_string & loosePartLoc )const;
d211 4
a214 4
  bool demanBomExists     (const BCP_string & mtm, const BCP_string & part, const BCP_string & loc )const;
  void addDemanBom        (const BCP_string & mtm, const BCP_string & part, const BCP_string & loc );
  void setDemanBomAttachRate(const BCP_string & mtm, const BCP_string & part, const BCP_string & loc, int period, float prodRate );
  std::vector<float> getDemanBomAttachRate( const BCP_string & mtm, const BCP_string & part, const BCP_string & loc ) const;
d216 1
a216 1
  std::vector<BCP_string> getDemanBoms(const BCP_string & mtm, const BCP_string & mtmSrcLoc, const BCP_string & demanLoc)const;
d221 10
a230 10
  bool featureXrefExists      (const BCP_string & part, const BCP_string & feature, const BCP_string & loc )const;
  void addFeatureXref         (const BCP_string & part, const BCP_string & feature, const BCP_string & loc );
  void setFeatureXrefProdRate (const BCP_string & part, const BCP_string & feature, const BCP_string & loc, int period, float prodRate );
  void setFeatureXrefCost     (const BCP_string & part, const BCP_string & feature, const BCP_string & loc, int period, float cost );
  void setFeatureXrefUsageTime(const BCP_string & part, const BCP_string & feature, const BCP_string & loc, int period, float usageTime );

  void getFeatureXrefs( std::vector<BCP_string> & parts, std::vector<BCP_string> & features, std::vector<BCP_string> &locs ) const;
  std::vector<float> getFeatureXrefVol(const BCP_string & part,const BCP_string & feature, const BCP_string & loc )const;
  std::vector<float> getFeatureXrefCost(const BCP_string & part,const BCP_string & feature, const BCP_string & loc )const;
  std::vector<float> getFeatureXrefProdRate(const BCP_string & part,const BCP_string & feature, const BCP_string & loc )const;
d235 5
a239 5
  bool altExists      (const BCP_string & partOrFeature, const BCP_string & altPart, const BCP_string & loc )const;
  void addAlt         (const BCP_string & partOrFeature, const BCP_string & altPart, const BCP_string & loc, float altCost, float altTime );
  //void setAlternatePartProdRate (const BCP_string & upLevelPart, const BCP_string & downLevelPart, const BCP_string & loc, int period, float prodRate );
  //void setAlternatePartCost     (const BCP_string & upLevelPart, const BCP_string & downLevelPart, const BCP_string & loc, int period, float cost );
  //void setAlternatePartUsageTime(const BCP_string & upLevelPart, const BCP_string & downLevelPart, const BCP_string & loc, int period, float usageTime );
d242 3
a244 3
  void getAlts( std::vector<BCP_string> & partOrFeatures, std::vector<BCP_string> & altParts, std::vector<BCP_string> &locs ) const;
  std::vector<float> getAltVol(const BCP_string & partOrFeature,const BCP_string & altPart, const BCP_string & loc )const;
  std::vector<float> getAltConvCost(const BCP_string & partOrFeature,const BCP_string & altPart, const BCP_string & loc )const;
d247 1
a247 1
  std::vector<BCP_string> getPartLocs(const BCP_string & partName ) const;
d252 5
a256 5
  bool mtmInterplantExists     (const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc )const;
  bool mtmInterplantExists     (const BCP_string & mtm, const BCP_string & srcLoc )const;
  void addMtmInterplant        (const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc, float defaultMoveCost, float defaultMoveTime  );
  void setMtmInterplantMoveCost(const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveCost );
  void setMtmInterplantMoveTime(const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveTime );
d260 7
a266 7
    std::vector<BCP_string> & mtms,
    std::vector<BCP_string> & srcLocs,
    std::vector<BCP_string> & destLocs ) const;
  std::vector<float> getMtmInterplantMoveCost(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const;
  std::vector<float> getMtmInterplantMoveTime(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const;
  std::vector<float> getMtmInterplantMoveVol(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const;
  std::vector<float> getMtmAcquireQty(const BCP_string & mtmName, const BCP_string & srcLoc, const BCP_string & destLoc )const;
d271 4
a274 4
  bool partInterplantExists     (const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc )const;
  void addPartInterplant        (const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc, float defaultMoveCost, float defaultMoveTime );
  void setPartInterplantMoveCost(const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveCost );
  void setPartInterplantMoveTime(const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveTime );
d277 3
a279 3
  void getPartInterplants( std::vector<BCP_string> & parts, std::vector<BCP_string> & srcLocs, std::vector<BCP_string> &destLocs ) const;
  std::vector<float> getPartInterplantMoveVol(const BCP_string & part,const BCP_string & srcLoc, const BCP_string & destLoc )const;
  std::vector<float> getPartInterplantMoveCost(const BCP_string & part,const BCP_string & srcLoc, const BCP_string & destLoc )const;
d282 1
a282 1
  void addPartsInterplant(const BCP_string & srcLoc, const BCP_string & destLoc, float defaultMoveCost, float defaultMoveTime );
d286 4
a289 4
  bool partDemandExists      (const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc )const;
  void addPartDemand         (const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc );
  void setPartDemandDemandVol(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc, int period, float demandVol );
  void setPartDemandWac      (const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc, int period, float wac );
d292 4
a295 4
  void getPartDemands( std::vector<BCP_string> & parts, std::vector<BCP_string> & custLocs, std::vector<BCP_string> &plantLocs ) const;
  std::vector<float> getPartDemandShipVol  (const BCP_string & part,const BCP_string & custLoc, const BCP_string & plantLoc )const;
  std::vector<float> getPartDemandDemandVol(const BCP_string & part,const BCP_string & custLoc, const BCP_string & plantLoc )const;
  std::vector<float> getPartDemandWac(const BCP_string & part,const BCP_string & custLoc, const BCP_string & plantLoc )const;
d298 1
a298 1
  void reportPartDemand(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc, int period )const;
d302 1
a302 1
    const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc, int shipPeriod,
d304 3
a306 3
    std::vector<BCP_string> & mtms, 
    std::vector<BCP_string> & mtmSrcLocs, 
    std::vector<BCP_string> & mtmAcquireLocs, 
d310 2
a311 2
    std::vector<BCP_string> & features, 
    std::vector<BCP_string> & featurePlantLocs, 
d315 2
a316 2
    std::vector<BCP_string> & looseParts, 
    std::vector<BCP_string> & loosePartPlantLocs, 
d324 1
a324 1
  bool partExists(const BCP_string & part, const BCP_string & partLoc )const;
d393 1
a393 1
  void writeWitData( BCP_string filename ) const;
d424 2
a425 2
  void addPart(const BCP_string & part, const BCP_string & partLoc );
  void addPartWithOutApplyingInterplants(const BCP_string & part, const BCP_string & partLoc );
d427 1
a427 1
    const BCP_string & witPartName, 
d434 1
a434 1
  void addNonScrapableCapacity(const BCP_string & name );
d442 1
a442 1
    const BCP_string opName,
d454 3
a456 3
     const BCP_string & mtm,
     const BCP_string & srcLoc,
     const BCP_string & destLoc,
d459 2
a460 2
     const BCP_string & feature,
     const BCP_string & featureLoc,
d463 2
a464 2
     const BCP_string & part,
     const BCP_string & partLoc,
d467 2
a468 2
     const BCP_string & witAcquireOpName,
     const BCP_string & witAcquiredPartName,
d475 1
a475 1
    const BCP_string & name,
d482 1
a482 1
    const BCP_string & name,
d488 1
a488 1
    const BCP_string & name,
d494 1
a494 1
    const BCP_string & name,
d503 1
a503 1
    const BCP_string & opName,
d511 1
a511 1
    const BCP_string & opName,
d519 2
a520 2
    const BCP_string & partName,
    const BCP_string & demandName,
d527 1
a527 1
    const BCP_string & name )const;
d532 1
a532 1
    const BCP_string & opName,
d537 1
a537 1
    const BCP_string & opName,
d544 1
a544 1
    const BCP_string & opName,
d549 1
a549 1
    const BCP_string & opName,
d554 1
a554 1
    const BCP_string & opName,
d561 1
a561 1
    const BCP_string & opName,
d569 2
a570 2
    const BCP_string & partName,
    const BCP_string & demandName )const;
d576 1
a576 1
    const BCP_string & name,
d584 10
a593 10
  static BCP_string igfMtmName(const BCP_string & mtm,const BCP_string & mtmLoc );
  static BCP_string acquireMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc );
  static BCP_string serverMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc  );
  static BCP_string demanMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc  );
  static BCP_string baseMtmName(const BCP_string & mtm,const BCP_string & mtmDestLoc );
  static BCP_string mtmFromMtmName(const BCP_string & mtmName);
  static BCP_string mtmDestLocFromMtmName(const BCP_string & mtmName);
  static BCP_string mtmSrcLocFromMtmName(const BCP_string & mtmName);
  static bool isMtmDemanName( const BCP_string & witName );
  static bool isAcquireMtmName( const BCP_string & witName );
d595 1
a595 1
  static bool isAcquireName( const BCP_string & witName );
d598 6
a603 6
  static BCP_string igfFeatureName(const BCP_string & feature,const BCP_string & loc );
  static BCP_string acquireFeatureName(const BCP_string & feature,const BCP_string & loc );
  static BCP_string baseFeatureName(const BCP_string & feature,const BCP_string & loc );
  static BCP_string featureFromFeatureName(const BCP_string & featureName);
  static BCP_string locFromFeatureName(const BCP_string & featureName);
  static bool isAcquireFeatureName( const BCP_string & witName );
d606 6
a611 6
  static BCP_string igfLoosePartName(const BCP_string & loosePart,const BCP_string & loc );
  static BCP_string acquireLoosePartName(const BCP_string & loosePart,const BCP_string & loc );
  static BCP_string baseLoosePartName(const BCP_string & loosePart,const BCP_string & loc );
  static BCP_string loosePartFromLoosePartName(const BCP_string & loosePartName);
  static BCP_string locFromLoosePartName(const BCP_string & loosePartName);
  static bool isAcquireLoosePartName( const BCP_string & witName );
d614 4
a617 4
  static BCP_string featureXrefName(const BCP_string & part, const BCP_string & feature, const BCP_string & loc);
  static BCP_string partFromFeatureXrefName(const BCP_string & featXrefName );
  static BCP_string featureFromFeatureXrefName(const BCP_string & featXrefName);
  static BCP_string locFromFeatureXrefName(const BCP_string & featXrefName);
d620 4
a623 4
  static BCP_string altName(const BCP_string & upLevelPart, const BCP_string & downLevelPart, const BCP_string & loc);
  static BCP_string partFromAltName(const BCP_string & etnCspName);
  static BCP_string altPartFromAltName(const BCP_string & etnCspName);
  static BCP_string locFromAltName(const BCP_string & etnCspName);
d626 4
a629 4
  static BCP_string partInterplantName(const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc);
  static BCP_string partFromPartInterplantName(const BCP_string & partInterplantName);
  static BCP_string srcLocFromPartInterplantName(const BCP_string & partInterplantName);
  static BCP_string destLocFromPartInterplantName(const BCP_string & partInterplantName);
d632 5
a636 5
  static BCP_string partDemandName(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc);
  static BCP_string partDemandRegulatorName(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc);
  static BCP_string partFromPartDemandName(const BCP_string & partDemandName);
  static BCP_string custLocFromPartDemandName(const BCP_string & partDemandName);
  static BCP_string plantLocFromPartDemandName(const BCP_string & partDemandName);
d639 3
a641 3
  static BCP_string partName(const BCP_string & part,const BCP_string & loc );
  static BCP_string moveablePartName(const BCP_string & part,const BCP_string & loc );
  static BCP_string partFromPartName( const BCP_string & partName );
d644 4
a647 4
  static BCP_string textBetween(const BCP_string & src, const BCP_string & before,const BCP_string & after);
  static BCP_string textAfter(const BCP_string & src, const BCP_string & before);
  static bool beginsWith(const BCP_string & src, const BCP_string & begString);
  static bool contains(const BCP_string & haystack, const BCP_string & needle);
d651 3
a653 3
    const BCP_string & mtm, 
    const BCP_string & part, 
    const BCP_string & loc ) const;
d655 2
a656 2
    const BCP_string & opName, 
    const BCP_string & partName ) const;
d659 2
a660 2
       const BCP_string & acquireOperation, 
       const BCP_string & acquiredPart,
d734 1
a734 1
  bool witGetDemandExists(const BCP_string & demandedPartName,const BCP_string & demandName) const;
d736 1
a736 1
                                           const BCP_string & operationName,
d740 1
a740 1
                                const BCP_string & id,
d750 6
a755 6
  typedef std::set<BCP_string> ESOstringSet;
  typedef std::set<BCP_string>::iterator ESOstringSetIterator;
  typedef std::set<BCP_string>::const_iterator ESOstringSetConstIterator;
  typedef std::map<BCP_string,ESOstringSet> ESOmapStringToStringSet;
  typedef std::map<BCP_string,ESOstringSet>::iterator ESOmapStringToStringSetIterator;
  typedef std::map<BCP_string,ESOstringSet>::const_iterator ESOmapStringToStringSetConstIterator;
d758 1
a758 1
  typedef std::map<BCP_string,ESO2partInterplantVec> ESO2mapStringToPartInterplantVec;
d760 4
a763 4
  void addMtmAcquireLoc(const BCP_string & mtmSrcLoc, const BCP_string & mtmAcquireLoc ); 
  bool mtmAcquireLocExists(const BCP_string & mtmName, const BCP_string & mtmAcquireLoc ) const;
  bool mtmAcquireExists(const BCP_string & mtmName ) const;
  const ESOstringSet & getMtmAcquireLocs(const BCP_string & mtmSrcLoc)const;
d765 2
a766 2
  void addPartOrFeatureLoc(const BCP_string & partOrFeatureName, const BCP_string & loc );
  void removePartOrFeatureLoc(const BCP_string & partOrFeatureName, const BCP_string & loc );
d782 7
a788 7
  std::set<BCP_string> mtmNames_; 
  std::set<BCP_string> featureNames_; 
  std::set<BCP_string> loosePartNames_; 
  std::set<BCP_string> xrefFeatures_; 
  std::set<BCP_string> alts_; 
  std::set<BCP_string> partInterplants_;  
  std::set<BCP_string> partDemands_; 
@


1.54
log
@Code restored to state before etnParts were added
@
text
@d16 1
d301 21
d582 2
d586 4
a589 4
  static BCP_string acquireMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc );
  static BCP_string serverMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc  );
  static BCP_string demanMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc  );
  static BCP_string baseMtmName(const BCP_string & mtm,const BCP_string & mtmLoc );
d591 6
a596 1
  static BCP_string mtmLocFromMtmName(const BCP_string & mtmName);
d604 1
d612 1
d648 1
@


1.53
log
@Modified code to add etn flag to mtm, feature, and loose part
@
text
@d610 2
a611 6
  static BCP_string partWEtnName(const BCP_string & part,const BCP_string & loc );
  static BCP_string moveablePartWEtnName(const BCP_string & part,const BCP_string & loc );
  static BCP_string partFromPartWEtnName( const BCP_string & partName );
  static BCP_string partWOEtnName(const BCP_string & part,const BCP_string & loc );
  static BCP_string moveablePartWOEtnName(const BCP_string & part,const BCP_string & loc );
  static BCP_string partFromPartWOEtnName( const BCP_string & partName );
@


1.52
log
@modified to reduce the number of times wit does preprocessing
@
text
@d610 6
a615 2
  static BCP_string moveablePartName(const BCP_string & part,const BCP_string & loc );
  static BCP_string partFromPartName( const BCP_string & partName );
@


1.51
log
@Replaced std::string with BCP_string to work around VAC compiler problem
@
text
@d230 1
d344 1
d367 1
d416 1
a416 1
  void setDemanBomProdRates();
d695 2
a696 2
  void setDemanBomProdRatesAreSet(bool v) {
    demanBomProdRatesAreSet_=v;
d699 1
a699 1
    return demanBomProdRatesAreSet_;
d759 1
a759 1
  bool demanBomProdRatesAreSet_;
@


1.50
log
@desparate change to try to fix things
@
text
@d14 1
d106 2
a107 2
  void setTitle(const std::string & title);
  std::string getTitle() const;
d156 1
a156 1
  void setOslMesgFileName(const std::string & name);
d161 10
a170 10
  void addMtm         (const std::string & mtmName, const std::string & mtmLoc,float demanCost,float demanTime );
  bool mtmExists      (const std::string & mtmName, const std::string & mtmLoc )const;
  void setMtmSupply   (const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
  void setMtmWfmv     (const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
  void setMtmDemanCost(const std::string & mtmName, const std::string & mtmLoc, int period, float cost );
  void setMtmDemanCost(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, const std::vector<float> & cost );
  void setMtmDemanCost(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, int period, float cost );
  void setMtmDemanTime(const std::string & mtmName, const std::string & mtmLoc, int period, float time );
  void setMtmDemanTime(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, const std::vector<float> &  time );
  void setMtmDemanTime(const std::string & mtmName, const std::string & supplyLoc, const std::string & demanLoc, int period, float time );
d173 6
a178 6
  void getMtms( std::vector<std::string> & mtmName, std::vector<std::string> &mtmLocs ) const;
  std::vector<float> getMtmAcquireQty(const std::string & mtmName, const std::string & mtmLoc )const;
  std::vector<float> getMtmSupply(const std::string & mtmName, const std::string & mtmLoc )const;
  std::vector<float> getMtmWfmv(const std::string & mtmName, const std::string & mtmLoc ) const;
  std::vector<float> getMtmDemanCost(const std::string & mtmName, const std::string & mtmLoc ) const;
  std::vector<float> getMtmDemanTime(const std::string & mtmName, const std::string & mtmLoc ) const;
d183 4
a186 4
  void addFeature      (const std::string & featureName, const std::string & featureLoc );
  bool featureExists   (const std::string & featureName, const std::string & featureLoc )const;
  void setFeatureSupply(const std::string & featureName, const std::string & featureLoc, int period, float supply );
  void setFeatureWfmv  (const std::string & featureName, const std::string & featureLoc, int period, float wholeSaleMarketValue );
d189 4
a192 4
  void getFeatures( std::vector<std::string> & featureName, std::vector<std::string> &featureLocs ) const;
  std::vector<float> getFeatureAcquireQty(const std::string & featureName, const std::string & featureLoc )const;
  std::vector<float> getFeatureSupply(const std::string & featureName, const std::string & featureLoc )const;
  std::vector<float> getFeatureWfmv(const std::string & featureName, const std::string & featureLoc )const;
d197 4
a200 4
  void addLoosePart      (const std::string & loosePartName, const std::string & loosePartLoc );
  bool loosePartExists   (const std::string & loosePartName, const std::string & loosePartLoc )const;
  void setLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc, int period, float supply );
  void setLoosePartWfmv  (const std::string & loosePartName, const std::string & loosePartLoc, int period, float wholeSaleMarketValue );
d203 4
a206 4
  void getLooseParts( std::vector<std::string> & loosePartName, std::vector<std::string> &loosePartLocs ) const;
  std::vector<float> getLoosePartAcquireQty(const std::string & loosePartName, const std::string & loosePartLoc )const;
  std::vector<float> getLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc )const;
  std::vector<float> getLoosePartWfmv(const std::string & loosePartName, const std::string & loosePartLoc )const;
d211 4
a214 4
  bool demanBomExists     (const std::string & mtm, const std::string & part, const std::string & loc )const;
  void addDemanBom        (const std::string & mtm, const std::string & part, const std::string & loc );
  void setDemanBomAttachRate(const std::string & mtm, const std::string & part, const std::string & loc, int period, float prodRate );
  std::vector<float> getDemanBomAttachRate( const std::string & mtm, const std::string & part, const std::string & loc ) const;
d216 1
a216 1
  std::vector<std::string> getDemanBoms(const std::string & mtm, const std::string & mtmSrcLoc, const std::string & demanLoc)const;
d221 9
a229 9
  bool featureXrefExists      (const std::string & part, const std::string & feature, const std::string & loc )const;
  void addFeatureXref         (const std::string & part, const std::string & feature, const std::string & loc );
  void setFeatureXrefProdRate (const std::string & part, const std::string & feature, const std::string & loc, int period, float prodRate );
  void setFeatureXrefCost     (const std::string & part, const std::string & feature, const std::string & loc, int period, float cost );
  void setFeatureXrefUsageTime(const std::string & part, const std::string & feature, const std::string & loc, int period, float usageTime );

  void getFeatureXrefs( std::vector<std::string> & parts, std::vector<std::string> & features, std::vector<std::string> &locs ) const;
  std::vector<float> getFeatureXrefVol(const std::string & part,const std::string & feature, const std::string & loc )const;
  std::vector<float> getFeatureXrefCost(const std::string & part,const std::string & feature, const std::string & loc )const;
d234 5
a238 5
  bool altExists      (const std::string & partOrFeature, const std::string & altPart, const std::string & loc )const;
  void addAlt         (const std::string & partOrFeature, const std::string & altPart, const std::string & loc, float altCost, float altTime );
  //void setAlternatePartProdRate (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
  //void setAlternatePartCost     (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float cost );
  //void setAlternatePartUsageTime(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float usageTime );
d241 3
a243 3
  void getAlts( std::vector<std::string> & partOrFeatures, std::vector<std::string> & altParts, std::vector<std::string> &locs ) const;
  std::vector<float> getAltVol(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
  std::vector<float> getAltConvCost(const std::string & partOrFeature,const std::string & altPart, const std::string & loc )const;
d246 1
a246 1
  std::vector<std::string> getPartLocs(const std::string & partName ) const;
d251 5
a255 5
  bool mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc )const;
  bool mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc )const;
  void addMtmInterplant        (const std::string & mtm, const std::string & srcLoc, std::string destLoc, float defaultMoveCost, float defaultMoveTime  );
  void setMtmInterplantMoveCost(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost );
  void setMtmInterplantMoveTime(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime );
d259 7
a265 7
    std::vector<std::string> & mtms,
    std::vector<std::string> & srcLocs,
    std::vector<std::string> & destLocs ) const;
  std::vector<float> getMtmInterplantMoveCost(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getMtmInterplantMoveTime(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getMtmInterplantMoveVol(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getMtmAcquireQty(const std::string & mtmName, const std::string & srcLoc, const std::string & destLoc )const;
d270 4
a273 4
  bool partInterplantExists     (const std::string & part, const std::string & srcLoc, const std::string & destLoc )const;
  void addPartInterplant        (const std::string & part, const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime );
  void setPartInterplantMoveCost(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost );
  void setPartInterplantMoveTime(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime );
d276 3
a278 3
  void getPartInterplants( std::vector<std::string> & parts, std::vector<std::string> & srcLocs, std::vector<std::string> &destLocs ) const;
  std::vector<float> getPartInterplantMoveVol(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
  std::vector<float> getPartInterplantMoveCost(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
d281 1
a281 1
  void addPartsInterplant(const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime );
d285 4
a288 4
  bool partDemandExists      (const std::string & part, const std::string & custLoc, const std::string & plantLoc )const;
  void addPartDemand         (const std::string & part, const std::string & custLoc, const std::string & plantLoc );
  void setPartDemandDemandVol(const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period, float demandVol );
  void setPartDemandWac      (const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period, float wac );
d291 4
a294 4
  void getPartDemands( std::vector<std::string> & parts, std::vector<std::string> & custLocs, std::vector<std::string> &plantLocs ) const;
  std::vector<float> getPartDemandShipVol  (const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  std::vector<float> getPartDemandDemandVol(const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
  std::vector<float> getPartDemandWac(const std::string & part,const std::string & custLoc, const std::string & plantLoc )const;
d297 1
a297 1
  void reportPartDemand(const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period )const;
d302 1
a302 1
  bool partExists(const std::string & part, const std::string & partLoc )const;
d369 1
a369 1
  void writeWitData( std::string filename ) const;
d400 2
a401 2
  void addPart(const std::string & part, const std::string & partLoc );
  void addPartWithOutApplyingInterplants(const std::string & part, const std::string & partLoc );
d403 1
a403 1
    const std::string & witPartName, 
d410 1
a410 1
  void addNonScrapableCapacity(const std::string & name );
d418 1
a418 1
    const std::string opName,
d430 3
a432 3
     const std::string & mtm,
     const std::string & srcLoc,
     const std::string & destLoc,
d435 2
a436 2
     const std::string & feature,
     const std::string & featureLoc,
d439 2
a440 2
     const std::string & part,
     const std::string & partLoc,
d443 2
a444 2
     const std::string & witAcquireOpName,
     const std::string & witAcquiredPartName,
d451 1
a451 1
    const std::string & name,
d458 1
a458 1
    const std::string & name,
d464 1
a464 1
    const std::string & name,
d470 1
a470 1
    const std::string & name,
d479 1
a479 1
    const std::string & opName,
d487 1
a487 1
    const std::string & opName,
d495 2
a496 2
    const std::string & partName,
    const std::string & demandName,
d503 1
a503 1
    const std::string & name )const;
d508 1
a508 1
    const std::string & opName,
d513 1
a513 1
    const std::string & opName,
d520 1
a520 1
    const std::string & opName,
d525 1
a525 1
    const std::string & opName,
d530 1
a530 1
    const std::string & opName,
d537 1
a537 1
    const std::string & opName,
d545 2
a546 2
    const std::string & partName,
    const std::string & demandName )const;
d552 1
a552 1
    const std::string & name,
d558 7
a564 7
  static std::string igfMtmName(const std::string & mtm,const std::string & mtmLoc );
  static std::string acquireMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc );
  static std::string serverMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc  );
  static std::string demanMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc  );
  static std::string baseMtmName(const std::string & mtm,const std::string & mtmLoc );
  static std::string mtmFromMtmName(const std::string & mtmName);
  static std::string mtmLocFromMtmName(const std::string & mtmName);
d567 5
a571 5
  static std::string igfFeatureName(const std::string & feature,const std::string & loc );
  static std::string acquireFeatureName(const std::string & feature,const std::string & loc );
  static std::string baseFeatureName(const std::string & feature,const std::string & loc );
  static std::string featureFromFeatureName(const std::string & featureName);
  static std::string locFromFeatureName(const std::string & featureName);
d574 5
a578 5
  static std::string igfLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string acquireLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string baseLoosePartName(const std::string & loosePart,const std::string & loc );
  static std::string loosePartFromLoosePartName(const std::string & loosePartName);
  static std::string locFromLoosePartName(const std::string & loosePartName);
d581 4
a584 4
  static std::string featureXrefName(const std::string & part, const std::string & feature, const std::string & loc);
  static std::string partFromFeatureXrefName(const std::string & featXrefName );
  static std::string featureFromFeatureXrefName(const std::string & featXrefName);
  static std::string locFromFeatureXrefName(const std::string & featXrefName);
d587 4
a590 4
  static std::string altName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc);
  static std::string partFromAltName(const std::string & etnCspName);
  static std::string altPartFromAltName(const std::string & etnCspName);
  static std::string locFromAltName(const std::string & etnCspName);
d593 4
a596 4
  static std::string partInterplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc);
  static std::string partFromPartInterplantName(const std::string & partInterplantName);
  static std::string srcLocFromPartInterplantName(const std::string & partInterplantName);
  static std::string destLocFromPartInterplantName(const std::string & partInterplantName);
d599 5
a603 5
  static std::string partDemandName(const std::string & part, const std::string & custLoc, const std::string & plantLoc);
  static std::string partDemandRegulatorName(const std::string & part, const std::string & custLoc, const std::string & plantLoc);
  static std::string partFromPartDemandName(const std::string & partDemandName);
  static std::string custLocFromPartDemandName(const std::string & partDemandName);
  static std::string plantLocFromPartDemandName(const std::string & partDemandName);
d606 3
a608 3
  static std::string partName(const std::string & part,const std::string & loc );
  static std::string moveablePartName(const std::string & part,const std::string & loc );
  static std::string partFromPartName( const std::string & partName );
d611 3
a613 3
  static std::string textBetween(const std::string & src, const std::string & before,const std::string & after);
  static std::string textAfter(const std::string & src, const std::string & before);
  static bool beginsWith(const std::string & src, const std::string & begString);
d617 3
a619 3
    const std::string & mtm, 
    const std::string & part, 
    const std::string & loc ) const;
d621 2
a622 2
    const std::string & opName, 
    const std::string & partName ) const;
d625 2
a626 2
       const std::string & acquireOperation, 
       const std::string & acquiredPart,
d700 1
a700 1
  bool witGetDemandExists(const std::string & demandedPartName,const std::string & demandName) const;
d702 1
a702 1
                                           const std::string & operationName,
d706 1
a706 1
                                const std::string & id,
d716 6
a721 6
  typedef std::set<std::string> ESOstringSet;
  typedef std::set<std::string>::iterator ESOstringSetIterator;
  typedef std::set<std::string>::const_iterator ESOstringSetConstIterator;
  typedef std::map<std::string,ESOstringSet> ESOmapStringToStringSet;
  typedef std::map<std::string,ESOstringSet>::iterator ESOmapStringToStringSetIterator;
  typedef std::map<std::string,ESOstringSet>::const_iterator ESOmapStringToStringSetConstIterator;
d724 1
a724 1
  typedef std::map<std::string,ESO2partInterplantVec> ESO2mapStringToPartInterplantVec;
d726 4
a729 4
  void addMtmAcquireLoc(const std::string & mtmSrcLoc, std::string mtmAcquireLoc ); 
  bool mtmAcquireLocExists(const std::string & mtmName, const std::string & mtmAcquireLoc ) const;
  bool mtmAcquireExists(const std::string & mtmName ) const;
  const ESOstringSet & getMtmAcquireLocs(const std::string & mtmSrcLoc)const;
d731 2
a732 2
  void addPartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc );
  void removePartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc );
d748 7
a754 7
  std::set<std::string> mtmNames_; 
  std::set<std::string> featureNames_; 
  std::set<std::string> loosePartNames_; 
  std::set<std::string> xrefFeatures_; 
  std::set<std::string> alts_; 
  std::set<std::string> partInterplants_;  
  std::set<std::string> partDemands_; 
@


1.49
log
@desparate change to try to fix things
@
text
@d252 1
a252 1
  void addMtmInterplant        (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, float defaultMoveCost, float defaultMoveTime  );
@


1.48
log
@Added code to covert from old file format to new
@
text
@d725 1
a725 1
  void addMtmAcquireLoc(const std::string & mtmSrcLoc, const std::string & mtmAcquireLoc ); 
@


1.47
log
@Added code to write alt output file
@
text
@d612 1
a612 1

@


1.46
log
@Added code for setting alts
@
text
@d241 2
a242 2
  //std::vector<float> getAlternatePartEcVol(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
  //std::vector<float> getAlternatePartCost(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
@


1.45
log
@Modified so there there is a scrap cost on all parts (except for parts created from demanufacturing).
This is an attempt to ensure all acquired parts are consumed.
@
text
@d231 1
a231 1
  // Methods for alternate parts
d233 2
a234 2
  //bool alternatePartExists      (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc )const;
  //void addAlternatePart         (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc );
d240 1
a240 1
  //void getAlternateParts( std::vector<std::string> & upLevelParts, std::vector<std::string> & downLevelParts, std::vector<std::string> &locs ) const;
d244 3
d586 4
a589 4
  //static std::string alternatePartName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc);
  //static std::string upLevelPartFromAlternatePartName(const std::string & etnCspName);
  //static std::string downLevelPartFromAlternatePartName(const std::string & etnCspName);
  //static std::string locFromAlternatePartName(const std::string & etnCspName);
d716 2
d730 3
d751 1
a751 1
  //std::set<std::string> alternateParts_; 
d758 1
@


1.44
log
@Added bigM method to eso2Problem and updated code to use this constant
@
text
@d33 7
d215 2
d403 4
d456 6
d544 9
d604 1
d694 15
@


1.43
log
@Added code to write wit data files before each implode call
@
text
@d9 1
d357 4
@


1.42
log
@changes to have demanCost and demanTime be from deman location, rather supply loc and time
@
text
@d679 3
d686 1
@


1.41
log
@Modified to implement featureXref
@
text
@d157 2
d160 2
d591 1
d641 12
@


1.40
log
@Modified kpi's to be computed in double precision
\
@
text
@d202 14
d219 5
a223 5
  bool alternatePartExists      (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc )const;
  void addAlternatePart         (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc );
  void setAlternatePartProdRate (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
  void setAlternatePartCost     (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float cost );
  void setAlternatePartUsageTime(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float usageTime );
d226 3
a228 3
  void getAlternateParts( std::vector<std::string> & upLevelParts, std::vector<std::string> & downLevelParts, std::vector<std::string> &locs ) const;
  std::vector<float> getAlternatePartEcVol(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
  std::vector<float> getAlternatePartCost(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
d346 1
a346 1
  double sumOfAlternatePartCost() const;
d539 6
d546 4
a549 4
  static std::string alternatePartName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc);
  static std::string upLevelPartFromAlternatePartName(const std::string & etnCspName);
  static std::string downLevelPartFromAlternatePartName(const std::string & etnCspName);
  static std::string locFromAlternatePartName(const std::string & etnCspName);
d672 2
a673 1
  std::set<std::string> alternateParts_; 
@


1.39
log
@Added writing of kpi's
@
text
@d288 1
a288 1
  float getObjValue() const;
d290 4
a293 4
    float & totalWfmvWithScale,
    float & sumAcquireCost,
    float & sumMoveCost,
    float & sumDemanCost,
d296 2
a297 2
    float & supplyQuantity,
    float & acquiredQuantity)
d300 3
a302 3
    float & totalWfmvWithScale,
    float & sumAcquireCost,
    float & sumXrefCost,
d305 2
a306 2
    float & supplyQuantity,
    float & acquiredQuantity)
d309 2
a310 2
    float & totalWfmvWithScale,
    float & sumAcquireCost,
d313 2
a314 2
    float & supplyQuantity,
    float & acquiredQuantity)
d317 2
a318 2
    float & sumDemandWac,
    float & sumShippedWac,
d321 2
a322 2
    float & sumDemandVol,
    float & sumShipVol)
d324 9
a332 9
  float sumOfWac() const;
  float sumOfFeatureWfmvWithScaleFactor() const;
  float sumOfLoosePartWfmvWithScaleFactor() const;
  float sumOfMtmWfmvWithScaleFactor() const;
  float sumOfMtmWfmvWithScaleFactorAndMoveCost() const;
  float sumOfDemanCost() const;
  float sumOfPartMoveCost() const;
  float sumOfMtmMoveCost() const;
  float sumOfAlternatePartCost() const;
@


1.38
log
@added code to ensure slb is less than hub
@
text
@a144 2
  // Get WIT objective value;
  float getObjValue() const;
d283 51
@


1.37
log
@changes to improve performance
@
text
@d322 1
a322 1

d325 9
a333 1

d335 5
a339 5
   typedef std::vector<int> StdVecInt;
   static std::vector<int> multiLevelImpactPeriod( const std::vector<StdVecInt> & impPersVecs );
   
   // uses kevin's logic to determine if supply being consumed
   // will be from period 0 (usePerishableSupply) or period>0 (don't usePerishableSupply)
@


1.36
log
@fix to have wfmv be source of perishable supply when non-perishable supply has supplyVol=0
@
text
@d4 1
d102 11
a112 1
  int getNPeriods() const;
d140 4
a143 1
  int getPeriod1SupplyPerishPeriod() const;
d590 2
d604 1
a604 1
  ESOstringSet perishableSupplyWarningMsgIssued_;
@


1.35
log
@Changed default demanTime to be nPeriods+1.
Fixed so demanTime is properly considered after interPlant moves.
Updated to set deman prodRate to attach rate associated with period of supply being deman'ed
@
text
@d140 1
a140 1
  void addMtm         (const std::string & mtmName, const std::string & mtmLoc );
d314 21
a334 2
  static std::vector<int> multiLevelImpactPeriod( const std::vector<StdVecInt> & impPersVecs );

d587 2
@


1.34
log
@fixed code to handle move time on substitute mtms
@
text
@d128 1
a128 1
  void setPeriod1SupplyPerishPeriod(int periods);
d189 1
a189 1
 
d309 7
d526 8
d563 2
@


1.33
log
@More diagnositic info
@
text
@d37 7
d303 5
a307 1
  void reportPart(const std::string & witPartName, int period,int recursionDepth ) const;
d389 9
d467 2
a468 1
       const std::string & acquiredPart );
@


1.32
log
@added code to traverse tree for one demand
@
text
@d63 7
d371 5
@


1.31
log
@updated to put osl log file input/output directory
@
text
@d43 20
d237 4
a240 1
  
d289 1
d349 17
d440 9
@


1.30
log
@modified to not write zero's to output file
@
text
@d99 3
@


1.29
log
@changed name of globalAttribute period1PerishabilityLimit to period1SupplyPerishPeriod
@
text
@d262 1
a262 1
  void addPartWithApplyingInterplants(const std::string & part, const std::string & partLoc );
@


1.28
log
@Changes to implement period1SupplyPerishabilityLimit
@
text
@d94 2
a95 2
  void setPeriod1PerishabilityLimit(int periods);
  int getPeriod1PerishabilityLimit() const;
d389 1
a389 1
  void addSubsForPeriod1PerishabilityLimit(
d470 1
a470 1
  int period1PerishabilityLimit_;
@


1.27
log
@changes for building on aix
@
text
@d86 11
d388 4
d469 2
@


1.26
log
@updated unitTest to do something useful.
fixed problems with prunning. Now works for all testCases.
@
text
@d166 1
a166 1
  void ESO2problem::getMtmDemanLocs(
@


1.25
log
@Changed so partInterplants are applied to parts obtained from an mtm that has had an interplant move.
@
text
@d210 5
d251 1
d362 1
d441 6
a446 6
  std::vector<std::string> mtmNames_; 
  std::vector<std::string> featureNames_; 
  std::vector<std::string> loosePartNames_; 
  std::vector<std::string> alternateParts_; 
  std::vector<std::string> partInterplants_;  
  std::vector<std::string> partDemands_; 
@


1.24
log
@File changes to allow all parts and mtms defined at a srcLoc to have interplant move operations added.
@
text
@d11 2
d85 3
d188 2
d418 3
d442 1
@


1.23
log
@Added partInterplantMoveDefault input data file
@
text
@d156 1
a156 1
  void addMtmInterplant        (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc );
@


1.22
log
@Modifications to add mtmPriority, featurePriority, and loosePartPriority
@
text
@d98 3
a100 1
  std::vector<float> getMtmWfmv(      const std::string & mtmName, const std::string & mtmLoc ) const;
d149 1
d174 1
a174 1
  void addPartInterplant        (const std::string & part, const std::string & srcLoc, const std::string & destLoc );
d181 1
d193 3
a195 2
  std::vector<float> getPartDemandShipVol  (const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
  std::vector<float> getPartDemandDemandVol(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
@


1.21
log
@Updated to set aquireCost of features and looseParts using scale factors
@
text
@d22 7
d70 13
d249 8
d371 7
a377 3
    float * retVal = (float *) malloc(len*sizeof(float));
    int i;
    for ( i=0; i<len; ++i ) retVal[i] = inputVector[i];
d384 2
a385 1
    float * retVal = (float *) malloc(len*sizeof(float));
d427 5
@


1.20
log
@Added loosePart data file
@
text
@d92 1
d106 1
@


1.19
log
@modifications to accomodate 2/18 file format changes
@
text
@d94 13
d286 7
d386 1
@


1.18
log
@Added writing for mtm and feature supplyVol to output files
@
text
@d7 1
d79 1
d98 1
a98 1
  void setDemanBomProdRate(const std::string & mtm, const std::string & part, const std::string & loc, int period, float prodRate );
d101 1
a101 1
  // Methods for etnCsp boms
d103 5
a107 5
  bool etnCspBomExists      (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc )const;
  void addEtnCspBom         (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc );
  void setEtnCspBomProdRate (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
  void setEtnCspBomCost     (const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float cost );
  void setEtnCspBomUsageTime(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float usageTime );
d110 2
a111 2
  void getEtnCspBoms( std::vector<std::string> & upLevelParts, std::vector<std::string> & downLevelParts, std::vector<std::string> &locs ) const;
  std::vector<float> getEtnCspBomEcVol(const std::string & upLevelPart,const std::string & downLevelPart, const std::string & loc )const;
d114 25
a138 6
  // Methods for interplant
  //----------------------
  bool interplantExists     (const std::string & part, const std::string & srcLoc, const std::string & destLoc )const;
  void addInterplant        (const std::string & part, const std::string & srcLoc, const std::string & destLoc );
  void setInterplantMoveCost(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost );
  void setInterplantMoveTime(const std::string & part, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime );
d140 3
a142 3
  // Get list of all interplants added
  void getInterplants( std::vector<std::string> & parts, std::vector<std::string> & srcLocs, std::vector<std::string> &destLocs ) const;
  std::vector<float> getInterplantMoveVol(const std::string & part,const std::string & srcLoc, const std::string & destLoc )const;
d224 7
d244 7
a250 1
  
d258 5
a262 5
  static std::string igfMtmName(const std::string & mtm,const std::string & loc );
  static std::string acquireMtmName(const std::string & mtm,const std::string & loc );
  static std::string serverMtmName(const std::string & mtm,const std::string & loc );
  static std::string demanMtmName(const std::string & mtm,const std::string & loc );
  static std::string baseMtmName(const std::string & mtm,const std::string & loc );
d264 1
a264 1
  static std::string locFromMtmName(const std::string & mtmName);
d273 11
a283 11
  // etnCsp name methods
  static std::string etnCspName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc);
  static std::string upLevelPartFromEtnCspName(const std::string & etnCspName);
  static std::string downLevelPartFromEtnCspName(const std::string & etnCspName);
  static std::string locFromEtnCspName(const std::string & etnCspName);

  // interplant name methods
  static std::string interplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc);
  static std::string partFromInterplantName(const std::string & interplantName);
  static std::string srcLocFromInterplantName(const std::string & interplantName);
  static std::string destLocFromInterplantName(const std::string & interplantName);
a298 25
#if 0
  // Methods for handling resource names
  static std::string ibmBenchResourceName(const std::string & role,int band);
  static std::string contrBenchResourceName(const std::string & role,int band);
  static std::string resourceName(const std::string & role,int band);
  static std::string roleFromResourceName(const std::string & resName );
  static int         bandFromResourceName(const std::string & resName );

  // Methods for handling project resource link names
  static std::string ibmProjectResourceLinkName(const std::string & proj,const std::string & role,int band);
  static std::string contrProjectResourceLinkName(const std::string & proj,const std::string & role,int band);
  static std::string projectResourceLinkName(const std::string & proj,const std::string & role,int band);
  static std::string roleFromProjectResourceLinkName(const std::string & projResrcLinkName );
  static int         bandFromProjectResourceLinkName(const std::string & projResrcLinkName );
  static std::string projectFromProjectResourceLinkName(const std::string & projResrcLinkName );
#endif

#if 0
  // Return the range of bomEntry indices connecting the operation and part
  void getOperationBomEntryIndices(
                                 const std::string & opName,
                                 const std::string & consPartName,
                                 int & bomEntryIndexFirst,
                                 int & bomEntryIndexLast );
#endif 
d335 9
d345 10
a354 2
  
 
d366 2
a367 2
  std::vector<std::string> etnCspBoms_; 
  std::vector<std::string> interplants_;  
d369 2
@


1.17
log
@Added regulator capacity to enforce demand perishability
@
text
@d76 1
d89 1
@


1.16
log
@Mtm's wfmv costs are now scaled.
@
text
@d251 1
@


1.15
log
@Added mtm acquire operation appData and storing wfmv here.
@
text
@d184 7
a190 1
    float supply );
@


1.14
log
@added methods for set/getting wfmvScaleFactor
@
text
@d76 1
a76 1

a138 88
#if 0
  //----------------------
  // Methods for projects.
  //----------------------
  void addProject(const std::string & project );

  // Get list of all projects
  void getProjects(
    std::vector<std::string> & projects ) const;

  void setProjectCloseProb(const std::string & project, float closingProbability);
  float getProjectCloseProb(const std::string & project) const;

  void setProjectRateScale(const std::string & project, float rateScale);
  float getProjectRateScale(const std::string & project) const;

  void setProjectStartPeriod(const std::string & project, int startPeriod);
  int getProjectStartPeriod(const std::string & project ) const;

  void setProjectRevenue(const std::string & project, float revenue);
  float getProjectRevenue(const std::string & project ) const;

  // Get the execution volume of the project.
  // This will be 0 if the project will not be performed (executed).
  // It will be 1 if the project will be done.
  // It can be between 0 and 1 if the solution includes a portion of the project being done.
  // retVal[g] is the execVol for projects
  // with probability >= getProbGrid()[g].
  std::vector<float> getProjectExecVol(const std::string & project ) const;

  //----------------------
  // Methods for resources
  //----------------------
  void addResource(const std::string & role, int band );

  // Get list of all resources
  void getResources(
    std::vector<std::string> & roles,
    std::vector<int> & bands ) const;
  void setResourceIbmCost(
    const std::string & role, int band, 
    float ibmCost);
  void setResourceContrCost(
    const std::string & role, int band, 
    float ibmCost);
  float getResourceIbmCost(
    const std::string & role, int band);
  float getResourceContrCost(
    const std::string & role, int band);

  void setResourceIbmSupplyVol(
    const std::string & role, int band, 
    std::vector<float> supplyVol );
  std::vector<float> getResourceIbmSupplyVol(
    const std::string & role, int band );
  void setResourceContrSupplyVol(
    const std::string & role, int band, 
    std::vector<float> supplyVol );
  std::vector<float> getResourceContrSupplyVol(
    const std::string & role, int band );
  
  // Get the consVol of resource.
  // retVal[g,t] is the consVol in period t for projects
  // with probability >= getProbGrid()[g].
  std::vector< std::vector<float> > getResourceIbmConsVol(
    const std::string & role, int band );
  std::vector< std::vector<float> > getResourceContrConsVol(
    const std::string & role, int band );

  
  // If all projects can not be executed, then
  // get a list of gating resources
  void getResourceShortages(     
    std::vector<std::string> & resourceDescriptions,
    std::vector<int> & periods,
    std::vector<float> & shortageVols ) const;
  
  //----------------------
  // Methods for project-resource links. 
  //----------------------
  void addProjectResourceLink(
    const std::string & project,
    const std::string & role, int band);

  // Get list of project resource links
  void getProjectResourceLinks(
    std::vector<std::string> & projects,
    std::vector<std::string> & roles, std::vector<int> & bands) const;
a139 8
  void setProjectResourceLinkConsRate(
    const std::string & project,
    const std::string & role, int band,
    const std::vector<float> & consRate);
  std::vector<float> getProjectResourceLinkConsRate(
    const std::string & project,
    const std::string & role, int band);
#endif
@


1.13
log
@updated to write shipVol results
@
text
@d58 4
d116 4
@


1.12
log
@code to write etnCsp output file has been added
@
text
@d48 3
a50 1
  //------------------------------------
d62 4
a65 4
  void addMtm(const std::string & mtmName, const std::string & mtmLoc );
  bool mtmExists(const std::string & mtmName, const std::string & mtmLoc )const;
  void setMtmSupply(const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
  void setMtmWfmv(const std::string & mtmName, const std::string & mtmLoc, int period, float supply );
d76 2
a77 2
  void addFeature(const std::string & featureName, const std::string & featureLoc );
  bool featureExists(const std::string & featureName, const std::string & featureLoc )const;
d79 1
a79 1
  void setFeatureWfmv(const std::string & featureName, const std::string & featureLoc, int period, float wholeSaleMarketValue );
d88 2
a89 2
  bool demanBomExists(const std::string & mtm, const std::string & part, const std::string & loc )const;
  void addDemanBom(const std::string & mtm, const std::string & part, const std::string & loc );
d95 4
a98 4
  bool etnCspBomExists(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc )const;
  void addEtnCspBom(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc );
  void setEtnCspBomProdRate(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
  void setEtnCspBomCost(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float cost );
d108 2
a109 2
  bool interplantExists(const std::string & part, const std::string & srcLoc, const std::string & destLoc )const;
  void addInterplant(const std::string & part, const std::string & srcLoc, const std::string & destLoc );
d116 2
a117 2
  bool partDemandExists(const std::string & part, const std::string & custLoc, const std::string & plantLoc )const;
  void addPartDemand(const std::string & part, const std::string & custLoc, const std::string & plantLoc );
d119 6
a124 1
  void setPartDemandWac(const std::string & part, const std::string & custLoc, const std::string & plantLoc, int period, float wac );
d296 6
d327 3
d333 3
d420 2
@


1.11
log
@Renamed some methods that had overloaded names to unique names for better readability
@
text
@d68 1
a68 1
  void getMtms( std::vector<std::string> & mtmName, std::vector<std::string> &mtmLoc ) const;
d78 5
a82 1
  
d98 4
d303 2
d308 3
d400 1
@


1.10
log
@added code to write mtmAcquirePlan file
@
text
@d252 1
a252 1
  void witSet(
d260 1
a260 1
  void witSet(
@


1.9
log
@Added solve
@
text
@d66 5
a70 1
  
d276 5
d288 2
d307 4
@


1.8
log
@updated to read interplant and partDemand files
@
text
@a209 1
#if 0
d211 1
a211 2
  // Solve Methods
  // Example probGrid: 1., 0.75, 0.5, 0.25, 0.0
a212 3
  void setProbabilityGrid(const std::vector<float> & probGrid);
  std::vector<float> getProbabilityGrid();

a213 1
#endif
@


1.7
log
@setting etnCsp usageTime attribute
@
text
@d33 12
d90 17
a106 1

d253 1
a253 1
  // Set element of Part/Operation float* attribute, given period and float
d261 2
a262 1
  void ESO2problem::witSet(
d270 9
d293 6
@


1.6
log
@setting more etnCsp attributes. More still to do.
@
text
@d21 1
a21 1
extern "C" {typedef witReturnCode (STDCALL * witSetNameBopIndexFloatStar) (
d27 1
a27 1
extern "C" {typedef witReturnCode (STDCALL * witGetNameBopIndexFloatStarStar) (
d76 2
a77 1
  void setEtnCspBomCost(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc, int period, float prodRate );
d233 3
a235 3
  void ESO2problem::witSetBop(
    witGetNameBopIndexFloatStarStar witGetFunc,
    witSetNameBopIndexFloatStar     witSetFunc,
d237 1
a237 1
    const std::string & partName,
@


1.5
log
@adding etnCsp structures, not yet setting attributes
@
text
@d21 12
d75 3
a77 1
 
d232 8
d289 3
@


1.4
log
@Changes to read demanBom file
@
text
@d57 12
a68 1
  
a207 1
  bool partExists(const std::string & part, const std::string & partLoc )const;
d229 3
@


1.3
log
@added code to process feature file
@
text
@d49 9
a57 2
  void setFeatureWfmv(const std::string & featureName, const std::string & featureLoc, int period, float supply );

d192 7
d216 6
a221 4
  static std::string igfFeatureName(const std::string & mtm,const std::string & loc );
  static std::string acquireFeatureName(const std::string & mtm,const std::string & loc );
  static std::string serverFeatureName(const std::string & mtm,const std::string & loc );
  static std::string baseFeatureName(const std::string & mtm,const std::string & loc );
d249 6
@


1.2
log
@added setting of demanCost
@
text
@d13 2
a14 2
   const char * const operationName,
   const float * const obj1ExecCost);}
d18 2
a19 2
   const char * const operationName,
   float ** obj1ExecCost);}
d39 1
d41 9
d200 6
@


1.1
log
@updated to add eso2Problem class and eso2 main program
@
text
@d8 1
d10 10
a19 1
class WitRun;
d39 1
d175 10
@


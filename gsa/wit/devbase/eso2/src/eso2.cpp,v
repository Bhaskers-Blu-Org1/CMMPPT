head	1.81;
access;
symbols
	abandoningEtnParts:1.60
	beforeEtnParts:1.60
	eso2InitialFileFormats:1.17;
locks; strict;
comment	@// @;


1.81
date	2008.01.20.11.06.47;	author fasano;	state Exp;
branches;
next	1.80;

1.80
date	2007.01.10.21.22.54;	author fasano;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.04.19.51.22;	author fasano;	state Exp;
branches;
next	1.78;

1.78
date	2007.01.02.15.04.39;	author fasano;	state Exp;
branches;
next	1.77;

1.77
date	2006.08.09.20.16.32;	author fasano;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.05.17.29.09;	author fasano;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.27.12.23.21;	author fasano;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.22.16.54.22;	author fasano;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.09.16.09.01;	author fasano;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.23.15.48.25;	author fasano;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.22.22.11.18;	author fasano;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.22.13.49.28;	author fasano;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.19.21.10.27;	author fasano;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.13.14.41.35;	author fasano;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.12.13.11.06;	author fasano;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.29.02.16.43;	author fasano;	state Exp;
branches;
next	1.65;

1.65
date	2005.02.13.18.53.25;	author fasano;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.02.20.58.31;	author fasano;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.02.14.31.06;	author fasano;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.29.18.27.37;	author fasano;	state Exp;
branches;
next	1.61;

1.61
date	2004.09.21.17.23.50;	author fasano;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.08.15.35.00;	author fasano;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.15.20.31.11;	author fasano;	state Exp;
branches;
next	1.58;

1.58
date	2003.11.08.02.45.45;	author fasano;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.29.19.21.36;	author fasano;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.24.17.22.58;	author fasano;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.16.16.32.32;	author fasano;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.08.19.00.04;	author fasano;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.08.15.36.45;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.29.13.23.41;	author fasano;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.14.18.49.52;	author fasano;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.13.23.59.21;	author fasano;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.13.19.46.25;	author fasano;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.12.20.06.12;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.12.20.05.05;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.12.13.24.48;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.12.13.20.44;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.12.03.05.05;	author fasano;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.12.03.02.56;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.24.20.11.23;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.21.19.35.21;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.08.14.09.38;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.08.13.29.29;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.02.21.01.45;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.01.22.02.19;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.30.01.32.07;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.21.20.12.31;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.21.13.54.26;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.20.15.14.26;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.20.13.16.10;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.17.01.26.47;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.12.01.25.41;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.12.01.21.18;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.11.00.22.33;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.04.22.06.12;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.01.15.36.40;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.30.19.04.23;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.20.23.44.30;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.17.01.28.21;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.09.19.43.29;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.28.16.59.34;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.28.01.25.07;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.18.57.38;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.20.18.10.40;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.12.13.21.29;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.11.13.18.37;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.09.21.36.02;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.14.16.01;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.09.02.42.59;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.09.01.10.37;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.08.23.39.57;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.08.22.54.59;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.08.13.00.09;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.08.03.33.44;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.08.02.12.24;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.08.00.47.51;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.07.23.28.02;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.07.20.59.35;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.07.20.39.07;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.07.19.12.20;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.07.17.04.19;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Restructured to get ready to implement solve that tolerates cycles.
Added a new method call sovleWithCycles.
At momement it just invokes solve followed by doPegging.
@
text
@
#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#endif


#include "wit.h"

#include <map>
#include <vector>

#include <assert.h>
#include <iostream>
#include <float.h>
#include <math.h>



#include "CoinFloatEqual.h"
#include "eso2.h"
#include "globalAttrData.h"
#include "mtmData.h"
#include "featureData.h"
#include "loosePartData.h"
#include "mtmDemanBomData.h"
#include "alternatePartData.h"
#include "partInterplantData.h"
#include "partInterplantOverrideData.h"
#include "mtmInterplantData.h"
#include "mtmInterplantOverrideData.h"
#include "partDemandData.h"
#include "eso2Problem.h"


typedef std::vector<std::string> StdStringVec;

// Function to round acquire quantities
float acqQtyRnd(float x)
{
  //return ceil(x);
  return x;
}

float applyScaleToWfmv(float scale, float wfmv)
{
  //return scale*wfmv;
  return wfmv;
}


/*
------------
 
// Write partDemand in WAC*ShipVol order
void partDemandInWacTimesShipVolOrder(
                  const ESO2problem & eso2Prob,
                  bool writeHeader,
                  FILE * partDemandInWacTimesShipVolOrderFilePtr,
                  
                  bool writeZeros )
{
  if ( !writeHeader ) return;
  float wfmvScaleFactor = eso2Prob.getWfmvScaleFactor();
  float wfmv2ScaleFactor = eso2Prob.getWfmv2ScaleFactor();
  int nPeriods = eso2Prob.getNPeriods();
  {
    std::string heading;
    heading = "\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"wac\",\"etnFlag\"";
    if (writeHeader) fprintf(partShipReportFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    eso2Prob.getPartDemands(parts,custLocs,plantLocs);

    std::map<float,int> demOrdList;
    
    // loop once for each shipped part
    size_t p;
    for ( p=0; p<parts.size(); p++ ) {
            
      std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
      std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
      std::vector<float> wac = eso2Prob.getPartDemandWac(parts[p],custLocs[p],plantLocs[p]);




      
      
    } // finished p loop
  } // finished writing partShip file
} // end partDemandInWacTimesShipVol Order


-----------
*/
  
// Attempt to write report requested by Kevin
void writeShipReportForKevin(
                  const ESO2problem & eso2Prob,
                  bool writeHeader,
                  FILE * partShipReportFilePtr,
                  
                  bool writeZeros )
{
  
  float wfmvScaleFactor = eso2Prob.getWfmvScaleFactor();
  float wfmv2ScaleFactor = eso2Prob.getWfmv2ScaleFactor();
  int nPeriods = eso2Prob.getNPeriods();
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\",\"altVol\",\"upstreamPart\",\"interPlantSrcLoc\",\"interPlantMoveVol\""; 
    if (writeHeader) fprintf(partShipReportFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    eso2Prob.getPartDemands(parts,custLocs,plantLocs);
    
    // loop once for each shipped part
    size_t p;
    for ( p=0; p<parts.size(); p++ ) {
      
      //**int t;
      //**for ( t=0; t<eso2Prob.getNPeriods(); t++ ) {
      
      std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
      assert( demandVol.size() == nPeriods );
      std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
      assert( shipVol.size() == nPeriods );
      std::vector<float> wac = eso2Prob.getPartDemandWac(parts[p],custLocs[p],plantLocs[p]);
      
      std::set<std::string> srcLocs = eso2Prob.getPartInterplantSrcLocs(parts[p],plantLocs[p]);
      std::set<std::string>::const_iterator it;
      for ( it=srcLocs.begin(); it!=srcLocs.end(); ++it ) {
        std::string srcLoc = *it;
        std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(parts[p],srcLoc,plantLocs[p]);
        
        for ( size_t t=0; t<shipVol.size(); t++ ) {
          if ( moveVol[t]==0.0 && !writeZeros ) continue;
          if (moveVol[t]==0.0) continue;
          
          fprintf(partShipReportFilePtr,
            "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,0.0,\" \",\"%s\",%f\n",
            wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
            srcLoc.c_str(),moveVol[t]);
        } // finished t loop
      } // finished srcLoc it loop
      
      
      // determine if shipped part has an alternate
      std::set<std::string> partsUsedAsAlt = eso2Prob.getAltPartOrFeature(parts[p],plantLocs[p]);
      for ( it=partsUsedAsAlt.begin(); it!=partsUsedAsAlt.end(); ++it ) {
        std::string partUsedAsAlt = *it;
        std::vector<float> altVol = eso2Prob.getAltVol(partUsedAsAlt,parts[p],plantLocs[p]);
        
        std::set<std::string> srcLocs = eso2Prob.getPartInterplantSrcLocs(partUsedAsAlt,plantLocs[p]);
        std::set<std::string>::const_iterator it1;
        for ( it1=srcLocs.begin(); it1!=srcLocs.end(); ++it1 ) {
          std::string srcLoc = *it1;
          std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(partUsedAsAlt,srcLoc,plantLocs[p]);
          
          for ( size_t t=0; t<shipVol.size(); t++ ) {
            if ( moveVol[t]==0.0 && !writeZeros && altVol[t]==0.0 ) continue;
            if (moveVol[t]==0.0) continue;
            
            fprintf(partShipReportFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,\"%s\",\"%s\",%f\n",
              wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
              altVol[t],partUsedAsAlt.c_str(),
              srcLoc.c_str(),moveVol[t]);
          } // finished t loop
        } // finished srcLocs it1 loop
      } // finished partsUsedAsAlt it loop
      
      //** } // finished t loop
      
    } // finished p loop
  } // finished writing partShip file
} // Kevin's partShipReport



void writeResults(
      const ESO2problem & eso2Prob,
      bool writeHeader,
      FILE * mtmAcquirePlanFilePtr,
      FILE * featureAcquirePlanFilePtr,
      FILE * loosePartAcquirePlanFilePtr,
      FILE * partShipFilePtr,
      FILE * featureXrefFilePtr,
      FILE * altFilePtr,
      FILE * partInterplantFilePtr,

      FILE * peggedDemandPlanFilePtr,

      FILE * kpiFilePtr,
      
      double mtmTotalWfmvAtScale1,
      int    mtmNumUnique,
      double mtmSupplyQuantity,
      
      double featureTotalWfmvAtScale1,
      int    featureNumUnique,
      double featureSupplyQuantity,
      
      double loosePartTotalWfmvAtScale1,
      int    loosePartNumUnique,
      double loosePartSupplyQuantity,
      
      double  partDemandSumDemandWac,
      int     partDemandNumUnique,
      double  partDemandSumDemandVol,
      
      bool writeZeros )
{
  float wfmvScaleFactor = eso2Prob.getWfmvScaleFactor();
  float wfmv2ScaleFactor = eso2Prob.getWfmv2ScaleFactor();
  int nPeriods = eso2Prob.getNPeriods();

#if 0
  float mtmAcquireCost = 0.0f;
  float mtmDemanCost = 0.0f;
  float mtmInterplantCost = 0.0f;
  float featureAcquireCost = 0.0f;
  float loosePartAcquireCost = 0.0f;
  float partAcquireAvoidanceValue = 0.0f;
  float alternatePartCost = 0.0f;
  float partInterplantCost = 0.0f;
#endif
  
  // Open mtmAcquirePlan file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"period\",\"supply\",\"acquireQty\""; 
    if (writeHeader) fprintf(mtmAcquirePlanFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    eso2Prob.getMtmDemanLocs(mtms,srcLocs,destLocs);
    
    // loop once for each mtm
    size_t m;
    for ( m=0; m<mtms.size(); m++ ) {
      
      std::vector<float> acquireQty = eso2Prob.getMtmAcquireQty(mtms[m],srcLocs[m],destLocs[m]);
      std::vector<float> supply = eso2Prob.getMtmSupply(mtms[m],srcLocs[m]);
      //std::vector<float> wfmv = eso2Prob.getMtmWfmv(mtms[m],srcLocs[m]);
      //std::vector<float> demanCost = eso2Prob.getMtmDemanCost(mtms[m],srcLocs[m]);
      //std::vector<float> moveCost = eso2Prob.getMtmInterplantMoveCost(mtms[m],srcLocs[m],destLocs[m]);
      assert( acquireQty.size() == nPeriods );
      for ( size_t t=0; t<acquireQty.size(); t++ ) {
        if ( acquireQty[t]==0.0 && !writeZeros ) continue;
        fprintf(mtmAcquirePlanFilePtr,
          "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,mtms[m].c_str(),srcLocs[m].c_str(),destLocs[m].c_str(),t+1,supply[t],acquireQty[t]);
        //mtmAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
        //mtmDemanCost += acqQtyRnd(acquireQty[t])*demanCost[t];
        //mtmInterplantCost += acqQtyRnd(acquireQty[t])*moveCost[t];
      } // finished t loop
    } // finished m loop
  } // finished writing mtmAcquirePlan file
  
  // Open featureAcquirePlan file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"feature\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
    if (writeHeader) fprintf(featureAcquirePlanFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> features;
    std::vector<std::string> plantLocs;
    eso2Prob.getFeatures(features,plantLocs);
    
    // loop once for each feature
    size_t f;
    for ( f=0; f<features.size(); f++ ) {
      
      std::vector<float> acquireQty = eso2Prob.getFeatureAcquireQty(features[f],plantLocs[f]);
      std::vector<float> supply = eso2Prob.getFeatureSupply(features[f],plantLocs[f]);
      std::vector<float> wfmv = eso2Prob.getFeatureWfmv(features[f],plantLocs[f]);
      assert( acquireQty.size() == nPeriods );
      for ( size_t t=0; t<acquireQty.size(); t++ ) {
        if ( acquireQty[t]==0.0 && !writeZeros ) continue;
        fprintf(featureAcquirePlanFilePtr,
          "%f,%f,\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,features[f].c_str(),plantLocs[f].c_str(),t+1,supply[t],acquireQty[t]);
        //featureAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
      } // finished t loop
    } // finished f loop
  } // finished writing featureAcquirePlan file

    
  // Open loosePartAcquirePlan file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
    if (writeHeader) fprintf(loosePartAcquirePlanFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> looseParts;
    std::vector<std::string> plantLocs;
    eso2Prob.getLooseParts(looseParts,plantLocs);
    
    // loop once for each loosePart
    size_t f;
    for ( f=0; f<looseParts.size(); f++ ) {
      
      std::vector<float> acquireQty = eso2Prob.getLoosePartAcquireQty(looseParts[f],plantLocs[f]);
      std::vector<float> supply = eso2Prob.getLoosePartSupply(looseParts[f],plantLocs[f]);
      std::vector<float> wfmv = eso2Prob.getLoosePartWfmv(looseParts[f],plantLocs[f]);
      assert( acquireQty.size() == nPeriods );
      for ( size_t t=0; t<acquireQty.size(); t++ ) {
        if ( acquireQty[t]==0.0 && !writeZeros ) continue;
        fprintf(loosePartAcquirePlanFilePtr,
          "%f,%f,\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,looseParts[f].c_str(),plantLocs[f].c_str(),t+1,supply[t],acquireQty[t]);
          //loosePartAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
      } // finished t loop
    } // finished f loop
  } // finished writing loosePartAcquirePlan file
  
  // Open partShip file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\""; 
    if (writeHeader) fprintf(partShipFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    eso2Prob.getPartDemands(parts,custLocs,plantLocs);
    
    // loop once for each shipped part
    size_t p;
    for ( p=0; p<parts.size(); p++ ) {
      
      std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
      assert( demandVol.size() == nPeriods );
      std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
      assert( shipVol.size() == nPeriods );
      std::vector<float> wac = eso2Prob.getPartDemandWac(parts[p],custLocs[p],plantLocs[p]);
      
      for ( size_t t=0; t<shipVol.size(); t++ ) {
        if ( shipVol[t]==0.0 && !writeZeros ) continue;
        fprintf(partShipFilePtr,
          "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t]);
        //partAcquireAvoidanceValue += shipVol[t]*wac[t];
      } // finished t loop
    } // finished p loop
  } // finished writing partShip file
  
  
  
  
  // Open featureXref file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"feature\",\"plantLoc\",\"period\",\"xrefVol\""; 
    if (writeHeader) fprintf(featureXrefFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> plantLocs;
    eso2Prob.getFeatureXrefs(parts,features,plantLocs);
    
    // loop once for each part
    size_t e;
    for ( e=0; e<parts.size(); e++ ) {
      
      std::vector<float> xrefVol = eso2Prob.getFeatureXrefVol(parts[e],features[e],plantLocs[e]);
      assert( xrefVol.size() == nPeriods );
      //std::vector<float> xrefCost = eso2Prob.getFeatureXrefCost(parts[e],features[e],plantLocs[e]);
      for ( size_t t=0; t<xrefVol.size(); t++ ) {
        if ( xrefVol[t]==0.0 && !writeZeros ) continue;
        fprintf(featureXrefFilePtr,
          "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,parts[e].c_str(),features[e].c_str(),plantLocs[e].c_str(),t+1,xrefVol[t]);
        //alternatePartCost += ecVol[t]*ecCost[t];
      } // finished t loop
    } // finished e loop
  } // finished writing alternatePart file

  // Open alternatePart file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"altPart\",\"loc\",\"period\",\"altVol\""; 
    if (writeHeader) fprintf(altFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> partOrFeatures;
    std::vector<std::string> altParts;
    std::vector<std::string> locs;
    eso2Prob.getAlts(partOrFeatures,altParts,locs);
    
    // loop once for each altPart
    size_t e;
    for ( e=0; e<partOrFeatures.size(); e++ ) {    
      std::vector<float> altVol = eso2Prob.getAltVol(partOrFeatures[e],altParts[e],locs[e]);
      assert( altVol.size() == nPeriods );
      std::vector<float> altConvCost = eso2Prob.getAltConvCost(partOrFeatures[e],altParts[e],locs[e]);
      for ( size_t t=0; t<altVol.size(); t++ ) {
        if ( altVol[t]==0.0 && !writeZeros ) continue;
        fprintf(altFilePtr,
          "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,partOrFeatures[e].c_str(),altParts[e].c_str(),locs[e].c_str(),t+1,altVol[t]);
          //altCost += altVol[t]*altConvCost[t];
      } // finished t loop
    } // finished e loop
  } // finished writing alt file
  
  // Open partInterplant output file and write header.
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"part\",\"srcLoc\",\"destLoc\",\"period\",\"moveVol\""; 
    if (writeHeader) fprintf(partInterplantFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    eso2Prob.getPartInterplants(parts,srcLocs,destLocs);
    
    // loop once for each partInterplant part
    size_t i;
    for ( i=0; i<parts.size(); i++ ) {
      
      std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(parts[i],srcLocs[i],destLocs[i]);
      std::vector<float> moveCost = eso2Prob.getPartInterplantMoveCost(parts[i],srcLocs[i],destLocs[i]);
      assert( moveVol.size() == nPeriods );
      for ( size_t t=0; t<moveVol.size(); t++ ) {
        if ( moveVol[t]==0.0 && !writeZeros ) continue;
        fprintf(partInterplantFilePtr,
          "%f,%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,wfmv2ScaleFactor,parts[i].c_str(),srcLocs[i].c_str(),destLocs[i].c_str(),t+1,moveVol[t]);
        //partInterplantCost += moveVol[t]*moveCost[t];
      } // finished t loop
    } // finished i loop
  } // finished writing partInterplant file

    
  // Open pegged*AcquirePlan files and write header.
  {
    if (writeHeader) {
      std::string heading;
      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"activity\",\"item\",\"loc\",\"activityPeriod\",\"activitySortAid\",\"qty\""; 
      fprintf(peggedDemandPlanFilePtr,"%s\n",heading.c_str());
    }
     
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    eso2Prob.getPartDemands(parts,custLocs,plantLocs);
    
    // loop once for each shipped part
    size_t p;
    for ( p=0; p<parts.size(); p++ ) {
      
      std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
      std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);

      // loop for each period
      int t;
      for (t=0; t<nPeriods; ++t ) {

        // if shipVol is not 0, then get pegging information
        if ( shipVol[t] != 0.0 ) {
          const std::set<std::string> & peggedAttributes = eso2Prob.getPartDemandPeggedAttributeNames(parts[p],custLocs[p],plantLocs[p],t);

          // loop once for each attribute pegged to demand
          std::set<std::string>::const_iterator it;
          for ( it=peggedAttributes.begin(); it!=peggedAttributes.end(); ++ it ) {

            std::vector<std::string> items,locs;
            std::vector<int> periods;
            std::vector<int> depths;
            std::vector<float> quantities;    
            eso2Prob.getPartDemandPegging(
              /*peggedAttributes[a],*/ *it,
              parts[p],custLocs[p],plantLocs[p],t,
              items, locs, periods, depths, quantities );

            // loop once for each item with attribute a pegged to demand p.
            for ( size_t i=0; i<items.size(); ++i ) {
              fprintf(peggedDemandPlanFilePtr,
                "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%f\n",
                wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
                (*it).c_str(),items[i].c_str(),locs[i].c_str(),
                periods[i]+1,depths[i],quantities[i]);
            } // end of i loop
          } // End of a loop on each pegged attribute

        }
      } // end of t loop for each time period
    } // finished p loop for each shipped part
  } // finished writing pegged*AcquirePlan files
  
  // Write key performance indicator file.
  {
    std::string heading;
    heading =
      std::string("\"wfmvScaleFactor\",") +
      std::string("\"wfmv2ScaleFactor\",") +
      std::string("\"netValue\",") +

      std::string("\"sumWfmvAllMtms\",") +
      std::string("\"sumWfvmAcquiredMtms\",") +
      std::string("\"numUniqueMtms\",") +
      std::string("\"numUniqueAcquiredMtms\",") +
      std::string("\"supplyQtyAllMtms\",") +
      std::string("\"acquiredQtyMtms\",") +

      std::string("\"moveCostMtm\",") +
      std::string("\"demanCostMtm\",") +
      

      std::string("\"sumWfmvAllFeatures\",") +
      std::string("\"sumWfvmAcquiredFeatures\",") +
      std::string("\"numUniqueFeatures\",") +
      std::string("\"numUniqueAcquiredFeatures\",") +
      std::string("\"supplyQtyAllFeatures\",") +
      std::string("\"acquiredQtyFeatures\",") +

      std::string("\"conversionCostFeatures\",") +


      std::string("\"sumWfmvAllLooseParts\",") +
      std::string("\"sumWfvmAcquiredLooseParts\",") +
      std::string("\"numUniqueLooseParts\",") +
      std::string("\"numUniqueAcquiredLooseParts\",") +
      std::string("\"supplyQtyAllLooseParts\",") +
      std::string("\"acquiredQtyLooseParts\",") +
      
      std::string("\"sumWacAllPartDemands\",") +
      std::string("\"sumWacMetPartDemands\",") +
      std::string("\"numUniquePartDemandTriples\",") +
      std::string("\"numUniqueMetPartDemandTriples\",") +
      std::string("\"demandQtyAllPartDemandTriples\",") +
      std::string("\"metQtyAllPartDemandTriples\",") +

      std::string("\"moveCostParts\"");
    if (writeHeader) fprintf(kpiFilePtr,"%s\n",heading.c_str());

    double witObjVal = eso2Prob.getObjValue();
    double partMoveCost = eso2Prob.sumOfPartMoveCost();

    
    // Get metrics
    double mtmTotalWfmvWithScaleFactorTEMP;
    double mtmSumAcquireCost;
    double mtmSumMoveCost;
    double mtmSumDemanCost;
    int mtmNumUniqueTEMP;
    int mtmNumUniqueAcquired;
    double mtmSupplyQuantityTEMP;
    double mtmAcquiredQuantity;
    
    eso2Prob.mtmMetrics(
      mtmTotalWfmvWithScaleFactorTEMP,
      mtmSumAcquireCost,
      mtmSumMoveCost,
      mtmSumDemanCost,
      mtmNumUniqueTEMP,
      mtmNumUniqueAcquired,
      mtmSupplyQuantityTEMP,
      mtmAcquiredQuantity);

    //std::cout <<"mtmNumUniqueAcquired=" <<mtmNumUniqueAcquired <<" mtmAcquiredQuantity=" <<mtmAcquiredQuantity <<std::endl;
    
    double featureTotalWfmvWithScaleFactorTEMP;
    double featureSumAcquireCost;
    double featureSumXrefCost;
    int featureNumUniqueTEMP;
    int featureNumUniqueAcquired;
    double featureSupplyQuantityTEMP;
    double featureAcquiredQuantity;
    
    eso2Prob.featureMetrics(
      featureTotalWfmvWithScaleFactorTEMP,
      featureSumAcquireCost,
      featureSumXrefCost,
      featureNumUniqueTEMP,
      featureNumUniqueAcquired,
      featureSupplyQuantityTEMP,
      featureAcquiredQuantity);

    double loosePartTotalWfmvWithScaleFactorTEMP;
    double loosePartSumAcquireCost;
    double loosePartSumAltCost;
    int loosePartNumUniqueTEMP;
    int loosePartNumUniqueAcquired;
    double loosePartSupplyQuantityTEMP;
    double loosePartAcquiredQuantity;
    
    eso2Prob.loosePartMetrics(
      loosePartTotalWfmvWithScaleFactorTEMP,
      loosePartSumAcquireCost,
      loosePartSumAltCost,
      loosePartNumUniqueTEMP,
      loosePartNumUniqueAcquired,
      loosePartSupplyQuantityTEMP,
      loosePartAcquiredQuantity);
    
    double partDemandSumDemandWacTEMP;
    double partDemandSumShippedWac;
    int partDemandNumUniqueTEMP;
    int partDemandNumUniqueShipped;
    double partDemandSumDemandVolTEMP;
    double partDemandSumShipVol;
    std::map<std::string,double> sumShippedWacComponents;
    
    eso2Prob.partDemandMetrics(
      partDemandSumDemandWacTEMP,
      partDemandSumShippedWac,
      sumShippedWacComponents,
      partDemandNumUniqueTEMP,
      partDemandNumUniqueShipped,
      partDemandSumDemandVolTEMP,
      partDemandSumShipVol); 
        
    CoinRelFltEq eq(1.e-5);
    double calcObj=
      partDemandSumShippedWac -
      (mtmSumAcquireCost + featureSumAcquireCost + 
      loosePartSumAcquireCost + loosePartSumAltCost +
      mtmSumDemanCost +
      mtmSumMoveCost + partMoveCost +
      featureSumXrefCost);
    std::cout <<"calcObj=" <<calcObj <<" witObj=" <<witObjVal <<std::endl;
    //assert(eq(calcObj,witObjVal));
    std::cout <<"totalWac=" <<partDemandSumShippedWac <<std::endl;
    std::cout <<"  Sources of totalWac:" <<std::endl;
    std::map<std::string,double>::const_iterator it;
    for ( it=sumShippedWacComponents.begin(); it!=sumShippedWacComponents.end(); ++it ) {
      std::cout <<"  " <<it->first <<"=" <<it->second <<std::endl;
    }

    fprintf(kpiFilePtr,
      "%f,%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%d,%d,%f,%f,%f\n",
      
      wfmvScaleFactor,
      wfmv2ScaleFactor,
      witObjVal,

      mtmTotalWfmvAtScale1*wfmvScaleFactor,
      mtmSumAcquireCost,
      mtmNumUnique,
      mtmNumUniqueAcquired,
      mtmSupplyQuantity,
      mtmAcquiredQuantity,
      mtmSumMoveCost,
      mtmSumDemanCost,

      featureTotalWfmvAtScale1*wfmvScaleFactor,
      featureSumAcquireCost,
      featureNumUnique,
      featureNumUniqueAcquired,
      featureSupplyQuantity,
      featureAcquiredQuantity,
      featureSumXrefCost,

      loosePartTotalWfmvAtScale1*wfmvScaleFactor,
      loosePartSumAcquireCost,
      loosePartNumUnique,
      loosePartNumUniqueAcquired,
      loosePartSupplyQuantity,
      loosePartAcquiredQuantity,
      
      partDemandSumDemandWac,
      partDemandSumShippedWac,
      partDemandNumUnique,
      partDemandNumUniqueShipped,
      partDemandSumDemandVol,
      partDemandSumShipVol,

      partMoveCost
      );
  }
  

} // end function to  writing results



int
main (int argc, char * argv[])
{

  std::cout <<"eso2 Build date: " <<__DATE__ <<std::endl;
  {
    
    // Put Parms into a vector
    std::vector<std::string> args;
    for (int i=0; i<argc; i++) 
      args.push_back(argv[i]);
    
    {
      // Check parm passed to program
      bool parmError = false;
      
      if ( args.size()> 1 ) {
        if (args[1]=="?" ) {
          parmError = true; // set flag to provide usage info
        }
      }
      
      if ( ! parmError ) {
        if ( args.size()!=2 ) {
          // Wrong number of parms. Write message
          std::cerr 
            <<"-------------------------------------------------------"  <<std::endl
            <<"Wrong number of parmeters specified"                      <<std::endl
            <<"  Number parameters specified: " <<(int)args.size()-1     <<std::endl
            <<"  Expected number of parameters: 1"                       <<std::endl
            <<"-------------------------------------------------------"  <<std::endl;
          parmError = true;
        }
      }
      
      
      
      if ( parmError ) {
        // Write correct usage
        std::cerr 
          <<"-------------------------------------------------------"  <<std::endl
          <<argv[0] <<" dataDirectory "                                <<std::endl
          <<"  where:"                                                 <<std::endl
          <<"    dataDirectory:"                                       <<std::endl
          <<"      Directory where input files are located and"        <<std::endl
          <<"      output files are written."                          <<std::endl
          <<"  example usage:"                                         <<std::endl
          <<"    " <<argv[0] <<" ../example1"                          <<std::endl
          <<"-------------------------------------------------------"  <<std::endl;
        return 1;
      }
    }
    
    std::string outputDirectory=args[1];
    std::string inputDirectory=args[1];
    ESO2problem eso2Prob;
    int nPeriods;
    
    int nWfmvScaleFactors;
    bool writeZeros=true;
    {
      // Get number of solves to be done (ie number of scale factors)
      std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
      ESO2globalAttrData globalAttrFile(globalAttrFileName);
      nWfmvScaleFactors=globalAttrFile.fieldAsInt("nWfmvScaleFactors","attrValue");

      // determine if results with value of zero are to be written to output file;
      if ( globalAttrFile.keyExists("writeZeroResults") ) {
        std::string wzr = globalAttrFile.fieldAsString("writeZeroResults","attrValue");
        if ( wzr!="yes" && wzr!="no" ) {
          std::cout 
            <<"-------------------------------------------------------"       <<std::endl
            <<"Warning: Incorrect value for writeZeroResults specified."      <<std::endl
            <<"   globalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
            <<"   value specified: " <<wzr.c_str()                            <<std::endl
            <<"   expected values: yes no"                                    <<std::endl
            <<"   will assume writeZeroResults is yes "                          <<std::endl
            <<"-------------------------------------------------------"       <<std::endl;
        }
        else {
          if ( wzr=="no" )
            writeZeros=false;
        }
      }
      else {
        std::cout 
          <<"-------------------------------------------------------"       <<std::endl
          <<"Warning: Attribute writeZeroResults not specified."            <<std::endl
          <<"   globalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
          <<"   expected values: yes no"                                    <<std::endl
          <<"   will assume writeZeroResults is yes "                       <<std::endl
          <<"-------------------------------------------------------"       <<std::endl;
      }
    }
    
    eso2Prob.setSolverLogFileName(outputDirectory+"/clpMesgFile.txt");
    bool useGlobalAttrFileSettings = true;
    createModel(eso2Prob, inputDirectory, useGlobalAttrFileSettings);
    nPeriods = eso2Prob.getNPeriods();

    
    //---------------------------------------------------------
    
    std::string mtmAcquirePlanFileName = outputDirectory+"/mtmAcquirePlanO.csv";
    FILE * mtmAcquirePlanFilePtr = fopen(mtmAcquirePlanFileName.c_str(),"w");
    
    std::string featureAcquirePlanFileName = outputDirectory+"/featureAcquirePlanO.csv";
    FILE * featureAcquirePlanFilePtr = fopen(featureAcquirePlanFileName.c_str(),"w");
    
    std::string loosePartAcquirePlanFileName = outputDirectory+"/loosePartAcquirePlanO.csv";
    FILE * loosePartAcquirePlanFilePtr = fopen(loosePartAcquirePlanFileName.c_str(),"w");
    
    std::string partShipFileName = outputDirectory+"/partShipO.csv";
    FILE * partShipFilePtr = fopen(partShipFileName.c_str(),"w");

    std::string partShipReportFileName = outputDirectory+"/partShipReportO.csv";
    FILE * partShipReportFilePtr = fopen(partShipReportFileName.c_str(),"w");
    
    std::string featureXrefFileName = outputDirectory+"/featureXrefO.csv";
    FILE * featureXrefFilePtr = fopen(featureXrefFileName.c_str(),"w");
    
    std::string altFileName = outputDirectory+"/altO.csv";
    FILE * altFilePtr = fopen(altFileName.c_str(),"w");
    
    std::string partInterplantFileName = outputDirectory+"/partInterplantO.csv";
    FILE * partInterplantFilePtr = fopen(partInterplantFileName.c_str(),"w");

    std::string peggedDemandPlanFileName = outputDirectory+"/peggedDemandPlanO.csv";
    FILE * peggedDemandPlanFilePtr = fopen(peggedDemandPlanFileName.c_str(),"w");
    
    std::string kpiFileName = outputDirectory+"/keyPerformanceIndicatorsO.csv";
    FILE * kpiFilePtr = fopen(kpiFileName.c_str(),"w");
    
    //---------------------------------------------------------
    
    // Get some metrics before prunning
    double mtmTotalWfmvAtScale1;
    double mtmSumAcquireCostTemp;
    double mtmSumMoveCostTemp;
    double mtmSumDemanCostTemp;
    int mtmNumUnique;
    int mtmNumUniqueAcquiredTemp;
    double mtmSupplyQuantity;
    double mtmAcquiredQuantityTemp;
    
    eso2Prob.mtmMetrics(
      mtmTotalWfmvAtScale1,
      mtmSumAcquireCostTemp,
      mtmSumMoveCostTemp,
      mtmSumDemanCostTemp,
      mtmNumUnique,
      mtmNumUniqueAcquiredTemp,
      mtmSupplyQuantity,
      mtmAcquiredQuantityTemp);
    
    double featureTotalWfmvAtScale1;
    double featureSumAcquireCostTemp;
    double featureSumXrefCostTemp;
    int featureNumUnique;
    int featureNumUniqueAcquiredTemp;
    double featureSupplyQuantity;
    double featureAcquiredQuantityTemp;
    
    eso2Prob.featureMetrics(
      featureTotalWfmvAtScale1,
      featureSumAcquireCostTemp,
      featureSumXrefCostTemp,
      featureNumUnique,
      featureNumUniqueAcquiredTemp,
      featureSupplyQuantity,
      featureAcquiredQuantityTemp);

    double loosePartTotalWfmvAtScale1;
    double loosePartSumAcquireCostTemp;
    double loosePartSumAltCost;
    int loosePartNumUnique;
    int loosePartNumUniqueAcquiredTemp;
    double loosePartSupplyQuantity;
    double loosePartAcquiredQuantityTemp;
    
    eso2Prob.loosePartMetrics(
      loosePartTotalWfmvAtScale1,
      loosePartSumAcquireCostTemp,
      loosePartSumAltCost,
      loosePartNumUnique,
      loosePartNumUniqueAcquiredTemp,
      loosePartSupplyQuantity,
      loosePartAcquiredQuantityTemp);
    
    double partDemandSumDemandWac;
    double partDemandSumShippedWacTemp;
    int partDemandNumUnique;
    int partDemandNumUniqueShippedTemp;
    double partDemandSumDemandVol;
    double partDemandSumShipVolTemp;
    std::map<std::string,double> sumShippedWacComponents;
    
    eso2Prob.partDemandMetrics(
      partDemandSumDemandWac,
      partDemandSumShippedWacTemp,
      sumShippedWacComponents,
      partDemandNumUnique,
      partDemandNumUniqueShippedTemp,
      partDemandSumDemandVol,
      partDemandSumShipVolTemp);
           

    //eso2Prob.writeWitData(outputDirectory + "/eso2.wit");
    eso2Prob.pruneWitModel();
    //eso2Prob.writeWitData(outputDirectory + "/example3.wit");


    std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
    ESO2globalAttrData globalAttrFile(globalAttrFileName);

    // Loop once for each scale factor
    int s;
    for ( s=1; s<=nWfmvScaleFactors;  ++s ) {
      
      // get scale factor for this solve
      char sAsChar[100];
      sprintf(sAsChar,"%d",s);
      std::string attrName = std::string("wfmvScaleFactor")+std::string(sAsChar);
      float wfmvScaleFactor = globalAttrFile.fieldAsFloat(attrName,"attrValue");
      std::string attr2Name = std::string("wfmv2ScaleFactor")+std::string(sAsChar);
      float wfmv2ScaleFactor = globalAttrFile.fieldAsFloat(attr2Name,"attrValue");
      eso2Prob.setWfmvScaleFactor(wfmvScaleFactor,wfmv2ScaleFactor);

      // Solve
      std::cout 
        <<"Solving with wfmvScaleFactor="<<wfmvScaleFactor
        <<" and wfmv2ScaleFactor="<<wfmv2ScaleFactor
        <<". solve " <<s <<" of " <<nWfmvScaleFactors <<"."
        <<std::endl;
      eso2Prob.solveWithPegging();
      
      
      
      // Write Results
      std::cout <<"Writing results." <<std::endl;
      bool writeHeader = false;
      if ( s==1 ) writeHeader = true;
      writeResults(
        eso2Prob,
        writeHeader,
        mtmAcquirePlanFilePtr,
        featureAcquirePlanFilePtr,
        loosePartAcquirePlanFilePtr,
        partShipFilePtr,
        featureXrefFilePtr,
        altFilePtr,
        partInterplantFilePtr,
        peggedDemandPlanFilePtr,
        kpiFilePtr,
        
        mtmTotalWfmvAtScale1,
        mtmNumUnique,
        mtmSupplyQuantity,
        
        featureTotalWfmvAtScale1,
        featureNumUnique,
        featureSupplyQuantity,
        
        loosePartTotalWfmvAtScale1,
        loosePartNumUnique,
        loosePartSupplyQuantity,
        
        partDemandSumDemandWac,
        partDemandNumUnique,
        partDemandSumDemandVol,
        
        writeZeros );
      
      writeShipReportForKevin(eso2Prob,writeHeader,partShipReportFilePtr,writeZeros );

      
    } // end of s loop

    //eso2Prob.reportPartDemand("0000000P1690","93B","93B",24-1);
    //eso2Prob.reportPartDemand("p1","cust","sim",3-1);
    //eso2Prob.reportPartDemand("pn1","980","980",1-1);
    //eso2Prob.reportPartDemand("0000053P6023","980","980",12-1);
    //eso2Prob.reportPartDemand("u3","kgn","wat",4-1);
    //eso2Prob.reportPartDemand("u3","kgn","wat",1-1);
    //eso2Prob.reportPartDemand("u3","kgn","wat",2-1);


    
    //--------------------------------------
    fclose(mtmAcquirePlanFilePtr);
    fclose(featureAcquirePlanFilePtr);
    fclose(partShipFilePtr);
    fclose(partShipReportFilePtr);
    fclose(featureXrefFilePtr);
    fclose(partInterplantFilePtr);
    fclose(peggedDemandPlanFilePtr);
    fclose(kpiFilePtr);
    //--------------------------------------


#if 0
      // Get list of shortages and print 
      if ( shortages )
      {          
        std::vector<std::string> resourceDescriptions;
        std::vector<int> periods;
        std::vector<float> shortageVols;
        eso2Prob.getResourceShortages(resourceDescriptions,periods,shortageVols );
        if ( periods.size()>0 )
          printf("Resource Shortages:");
        int s;
        for ( s=0; s<periods.size(); s++ ) {
          printf("%d, %f, %s\n",periods[s],shortageVols[s],resourceDescriptions[s].c_str());
        }
      }
#endif
      
  }

  std::cout <<"eso2 application is finished." <<std::endl;
  return 0;
}
@


1.80
log
@Added code to compute source of supply that makes up totalWac
@
text
@d919 1
a919 1
      eso2Prob.solve();
@


1.79
log
@TotalWac
@
text
@d468 1
a468 1
          const std::vector<std::string> & peggedAttributes = eso2Prob.getPartDemandPeggedAttributeNames(parts[p],custLocs[p],plantLocs[p],t);
d471 2
a472 1
          for ( size_t a=0; a<peggedAttributes.size(); ++a ) {
d479 1
a479 1
              peggedAttributes[a],
d488 1
a488 1
                peggedAttributes[a].c_str(),items[i].c_str(),locs[i].c_str(),
d610 1
d615 1
d629 1
a629 1
    std::cout <<"calcObj=" <<calcObj <<" witObj=" <<witObjVal <<" totalWac=" <<partDemandSumShippedWac <<std::endl;
d631 6
d880 1
d885 1
@


1.78
log
@Updated so allowInventoryHoldingAtDemandLocation can be put into the globalAttrData file
@
text
@d626 1
a626 1
    std::cout <<"calcObj=" <<calcObj <<" witObj=" <<witObjVal <<std::endl;
@


1.77
log
@Updated to have depth of pegging activity.
@
text
@d772 2
a773 2
    bool setPeriod1SupplyPerishabilityLimit = true;
    createModel(eso2Prob, inputDirectory, setPeriod1SupplyPerishabilityLimit);
@


1.76
log
@Changed code so that *O.csv files no longer has offset periods.
Attempted to remove in pegged file a move where the from/to locations are the same
@
text
@d446 1
a446 1
      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"activity\",\"item\",\"loc\",\"period\",\"qty\""; 
d475 1
d480 1
a480 1
              items, locs, periods, quantities );
d485 1
a485 1
                "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
d488 1
a488 1
                periods[i]+1,quantities[i]);
d885 1
@


1.75
log
@Fixup partShipReportO
@
text
@d139 1
a139 1
        std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVolForPartShipReportO(parts[p],srcLoc,plantLocs[p]);
d157 1
a157 1
        std::vector<float> altVol = eso2Prob.getAltVolForPartShipReportO(partUsedAsAlt,parts[p],plantLocs[p]);
d163 1
a163 1
          std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVolForPartShipReportO(partUsedAsAlt,srcLoc,plantLocs[p]);
@


1.74
log
@fix bug
@
text
@d139 1
a139 1
        std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(parts[p],srcLoc,plantLocs[p]);
d157 1
a157 1
        std::vector<float> altVol = eso2Prob.getAltVol(partUsedAsAlt,parts[p],plantLocs[p]);
d163 1
a163 1
          std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(partUsedAsAlt,srcLoc,plantLocs[p]);
@


1.73
log
@Modified to use new wit API names that doesn't reference OSL
@
text
@d170 2
a171 2
              "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,\"%s\",\"%s\",%f\n",
              wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
@


1.72
log
@Modified name of peg output file to be peggedDemandPlanO
@
text
@d51 48
d770 1
a770 1
    eso2Prob.setOslMesgFileName(outputDirectory+"/oslMesgFile.txt");
@


1.71
log
@Modified eso2 & eso2Problem to use generalized storing of pegged attributes in partDemandAppData
@
text
@d149 1
a149 3
      FILE * peggedMtmAcquirePlanFilePtr,
      FILE * peggedFeatureAcquirePlanFilePtr,
      FILE * peggedLoosePartAcquirePlanFilePtr,
a397 10
#if 0
      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"acquirePeriod\",\"acquireQty\""; 
      fprintf(peggedMtmAcquirePlanFilePtr,"%s\n",heading.c_str());

      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"feature\",\"acquireLoc\",\"acquirePeriod\",\"acquireQty\""; 
      fprintf(peggedFeatureAcquirePlanFilePtr,"%s\n",heading.c_str());

      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"part\",\"acquireLoc\",\"acquirePeriod\",\"acquireQty\""; 
      fprintf(peggedLoosePartAcquirePlanFilePtr,"%s\n",heading.c_str());
#endif
d399 1
a399 1
      fprintf(peggedMtmAcquirePlanFilePtr,"%s\n",heading.c_str());
d435 1
a435 1
              fprintf(peggedMtmAcquirePlanFilePtr,
a441 38
#if 0
          std::vector<std::string> acquiredMtms, mtmSrcLocs, mtmAcquireLocs;
          std::vector<int> mtmAcquirePeriods;
          std::vector<float> mtmAcquireQuantities;  
          std::vector<std::string> demanMtms, demanLocs;
          std::vector<int> demanPeriods;
          std::vector<float> demanQuantities;    
          std::vector<std::string> features,featurePlantLocs;
          std::vector<int> featureAcquirePeriods;
          std::vector<float> featureAcquireQuantities;    
          std::vector<std::string> looseParts,loosePartPlantLocs;
          std::vector<int> loosePartAcquirePeriods;
          std::vector<float> loosePartAcquireQuantities;
          eso2Prob.getPartDemandPegging(
            parts[p],custLocs[p],plantLocs[p],t,
            acquiredMtms, mtmSrcLocs, mtmAcquireLocs, mtmAcquirePeriods, mtmAcquireQuantities,
            demanMtms,demanLocs,demanPeriods,demanQuantities,
            features,featurePlantLocs,featureAcquirePeriods,featureAcquireQuantities,
            looseParts,loosePartPlantLocs,loosePartAcquirePeriods,loosePartAcquireQuantities );
          
          //Loop once for each mtm acquired
          size_t m;
          for (m=0; m<acquiredMtms.size(); ++m ){
            std::string activity="AcquireMtm";
            fprintf(peggedMtmAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
              activity.c_str(),acquiredMtms[m].c_str(),mtmSrcLocs[m].c_str(),
              mtmAcquirePeriods[m]+1,mtmAcquireQuantities[m]);
            if (mtmSrcLocs[m]!=mtmAcquireLocs[m] ) {
              std::string activity="MtmMoveFrom";
              fprintf(peggedMtmAcquirePlanFilePtr,
                "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
                activity.c_str(),acquiredMtms[m].c_str(),mtmSrcLocs[m].c_str(),
                mtmAcquirePeriods[m]+1,mtmAcquireQuantities[m]);

            }
a442 34
          } // end of for m loop
          
          //Loop once for each deman operation
          size_t f;
          for (f=0; f<demanMtms.size(); ++f ){
            std::string activity="DisassembleMtm";
            fprintf(peggedMtmAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
              activity.c_str(),demanMtms[f].c_str(),demanLocs[f].c_str(),
              demanPeriods[f]+1,demanQuantities[f]);
          } // end deman operation loop

          //Loop once for each feature acquired
          for (f=0; f<features.size(); ++f ){
            std::string activity="AcquireFeature";
            fprintf(peggedMtmAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
              activity.c_str(),features[f].c_str(),featurePlantLocs[f].c_str(),
              featureAcquirePeriods[f]+1,featureAcquireQuantities[f]);
          } // end of for f loop
          
          //Loop once for each loosePart acquired
          size_t l;
          for (l=0; l<looseParts.size(); ++l ){
            std::string activity="AcquireLoosePart";
            fprintf(peggedMtmAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,wfmv2ScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
              activity.c_str(),looseParts[l].c_str(),loosePartPlantLocs[l].c_str(),
              loosePartAcquirePeriods[l]+1,loosePartAcquireQuantities[l]);
          } // end of for l loop
#endif
d754 2
a755 8
    std::string peggedMtmAcquirePlanFileName = outputDirectory+"/peggedMtmAcquirePlanO.csv";
    FILE * peggedMtmAcquirePlanFilePtr = fopen(peggedMtmAcquirePlanFileName.c_str(),"w");

    std::string peggedFeatureAcquirePlanFileName = outputDirectory+"/peggedFeatureAcquirePlanO.csv";
    FILE * peggedFeatureAcquirePlanFilePtr = fopen(peggedFeatureAcquirePlanFileName.c_str(),"w");

    std::string peggedLoosePartAcquirePlanFileName = outputDirectory+"/peggedLoosePartAcquirePlanO.csv";
    FILE * peggedLoosePartAcquirePlanFilePtr = fopen(peggedLoosePartAcquirePlanFileName.c_str(),"w");
d876 1
a876 3
        peggedMtmAcquirePlanFilePtr,
        peggedFeatureAcquirePlanFilePtr,
        peggedLoosePartAcquirePlanFilePtr,
d919 1
a919 3
    fclose(peggedMtmAcquirePlanFilePtr);
    fclose(peggedFeatureAcquirePlanFilePtr);
    fclose(peggedLoosePartAcquirePlanFilePtr);
@


1.70
log
@Added pegging of deman info
@
text
@d432 23
d526 1
a526 1

@


1.69
log
@modifications to implement group pegging
@
text
@d1 1
d75 1
a75 1
    int p;
d93 1
a93 1
        for ( int t=0; t<shipVol.size(); t++ ) {
d117 1
a117 1
          for ( int t=0; t<shipVol.size(); t++ ) {
d200 1
a200 1
    int m;
d209 1
a209 1
      for ( int t=0; t<acquireQty.size(); t++ ) {
d232 1
a232 1
    int f;
d239 1
a239 1
      for ( int t=0; t<acquireQty.size(); t++ ) {
d261 1
a261 1
    int f;
d268 1
a268 1
      for ( int t=0; t<acquireQty.size(); t++ ) {
d290 1
a290 1
    int p;
d299 1
a299 1
      for ( int t=0; t<shipVol.size(); t++ ) {
d324 1
a324 1
    int e;
d330 1
a330 1
      for ( int t=0; t<xrefVol.size(); t++ ) {
d352 1
a352 1
    int e;
d357 1
a357 1
      for ( int t=0; t<altVol.size(); t++ ) {
d379 1
a379 1
    int i;
d385 1
a385 1
      for ( int t=0; t<moveVol.size(); t++ ) {
d400 1
d404 1
a404 1
      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"feature\",\"plantLoc\",\"acquirePeriod\",\"acquireQty\""; 
d407 1
a407 1
      heading="\"wfmvScaleFactor\",\"wfmv2ScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"part\",\"plantLoc\",\"acquirePeriod\",\"acquireQty\""; 
d409 3
d420 1
a420 1
    int p;
d432 1
a432 1
          std::vector<std::string> mtms, mtmSrcLocs, mtmAcquireLocs;
d434 4
a437 1
          std::vector<float> mtmAcquireQuantities;          
d446 2
a447 1
            mtms, mtmSrcLocs, mtmAcquireLocs, mtmAcquirePeriods, mtmAcquireQuantities,
d452 3
a454 2
          int m;
          for (m=0; m<mtms.size(); ++m ){
d458 1
a458 1
              mtms[m].c_str(),mtmSrcLocs[m].c_str(),mtmAcquireLocs[m].c_str(),
d460 10
d472 11
a483 1
          int f;
d485 3
a487 2
            fprintf(peggedFeatureAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",%d,%f\n",
d489 1
a489 1
              features[f].c_str(),featurePlantLocs[f].c_str(),
d494 1
a494 1
          int l;
d496 3
a498 2
            fprintf(peggedLoosePartAcquirePlanFilePtr,
              "%f,%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",%d,%f\n",
d500 1
a500 1
              looseParts[l].c_str(),loosePartPlantLocs[l].c_str(),
d716 1
a716 1
            <<"  Number parameters specified: " <<args.size()-1          <<std::endl
@


1.68
log
@added writing wfmv2ScaleFactor to Output files.
@
text
@d449 1
a449 1
              mtmAcquirePeriods[m],mtmAcquireQuantities[m]);
d459 1
a459 1
              featureAcquirePeriods[f],featureAcquireQuantities[f]);
d469 1
a469 1
              loosePartAcquirePeriods[l],loosePartAcquireQuantities[l]);
@


1.67
log
@Updated to add wfmv2ScaleFactor
@
text
@d61 1
d65 1
a65 1
    heading="\"wfmvScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\",\"altVol\",\"upstreamPart\",\"interPlantSrcLoc\",\"interPlantMoveVol\""; 
d97 2
a98 2
            "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,0.0,\" \",\"%s\",%f\n",
            wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
d173 1
d190 1
a190 1
    heading="\"wfmvScaleFactor\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"period\",\"supply\",\"acquireQty\""; 
d211 2
a212 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,mtms[m].c_str(),srcLocs[m].c_str(),destLocs[m].c_str(),t+1,supply[t],acquireQty[t]);
d223 1
a223 1
    heading="\"wfmvScaleFactor\",\"feature\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
d241 2
a242 2
          "%f,\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,features[f].c_str(),plantLocs[f].c_str(),t+1,supply[t],acquireQty[t]);
d252 1
a252 1
    heading="\"wfmvScaleFactor\",\"part\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
d270 2
a271 2
          "%f,\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,looseParts[f].c_str(),plantLocs[f].c_str(),t+1,supply[t],acquireQty[t]);
d280 1
a280 1
    heading="\"wfmvScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\""; 
d301 2
a302 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
          wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t]);
d314 1
a314 1
    heading="\"wfmvScaleFactor\",\"part\",\"feature\",\"plantLoc\",\"period\",\"xrefVol\""; 
d332 2
a333 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,parts[e].c_str(),features[e].c_str(),plantLocs[e].c_str(),t+1,xrefVol[t]);
d342 1
a342 1
    heading="\"wfmvScaleFactor\",\"part\",\"altPart\",\"loc\",\"period\",\"altVol\""; 
d359 2
a360 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,partOrFeatures[e].c_str(),altParts[e].c_str(),locs[e].c_str(),t+1,altVol[t]);
d369 1
a369 1
    heading="\"wfmvScaleFactor\",\"part\",\"srcLoc\",\"destLoc\",\"period\",\"moveVol\""; 
d387 2
a388 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,parts[i].c_str(),srcLocs[i].c_str(),destLocs[i].c_str(),t+1,moveVol[t]);
d399 1
a399 1
      heading="\"wfmvScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"acquirePeriod\",\"acquireQty\""; 
d402 1
a402 1
      heading="\"wfmvScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"feature\",\"plantLoc\",\"acquirePeriod\",\"acquireQty\""; 
d405 1
a405 1
      heading="\"wfmvScaleFactor\",\"demandedPart\",\"custLoc\",\"plantLoc\",\"demandShipPeriod\",\"part\",\"plantLoc\",\"acquirePeriod\",\"acquireQty\""; 
d446 2
a447 2
              "%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
d456 2
a457 2
              "%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
d466 2
a467 2
              "%f,\"%s\",\"%s\",\"%s\",%d,\"%s\",\"%s\",%d,%f\n",
              wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,
d482 1
d610 1
a610 1
      "%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%f,%d,%d,%f,%f,%f,%f,%d,%d,%f,%f,%f\n",
d613 1
@


1.66
log
@updated to add low priority demand file
@
text
@d879 3
a881 1
      eso2Prob.setWfmvScaleFactor(wfmvScaleFactor);
d886 1
@


1.65
log
@some clean-up on writeShipReport
@
text
@d865 1
@


1.64
log
@partShipReportO formating changes
@
text
@d50 83
a132 1

a142 1
      FILE * partShipReportFilePtr,
d306 1
a306 73
  // Attempt to write report requested by Kevin
  {
    std::string heading;
    heading="\"wfmvScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\",\"altVol\",\"upstreamPart\",\"interPlantSrcLoc\",\"interPlantMoveVol\""; 
    if (writeHeader) fprintf(partShipReportFilePtr,"%s\n",heading.c_str());
    
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    eso2Prob.getPartDemands(parts,custLocs,plantLocs);
    
    // loop once for each shipped part
    int p;
    for ( p=0; p<parts.size(); p++ ) {
      
      int t;
      for ( t=0; t<eso2Prob.getNPeriods(); t++ ) {

      std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
      assert( demandVol.size() == nPeriods );
      std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
      assert( shipVol.size() == nPeriods );
      std::vector<float> wac = eso2Prob.getPartDemandWac(parts[p],custLocs[p],plantLocs[p]);

      std::set<std::string> srcLocs = eso2Prob.getPartInterplantSrcLocs(parts[p],plantLocs[p]);
      std::set<std::string>::const_iterator it;
      for ( it=srcLocs.begin(); it!=srcLocs.end(); ++it ) {
        std::string srcLoc = *it;
        std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(parts[p],srcLoc,plantLocs[p]);
        
        // *JP for ( int t=0; t<shipVol.size(); t++ ) {
          if ( moveVol[t]==0.0 && !writeZeros ) continue;
          if (moveVol[t]==0.0) continue;
          
          fprintf(partShipReportFilePtr,
            "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,0.0,\" \",\"%s\",%f\n",
            wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
            srcLoc.c_str(),moveVol[t]);
        // *JP } // finished t loop
      } // finished srcLoc it loop


      // determine if shipped part has an alternate
      std::set<std::string> partsUsedAsAlt = eso2Prob.getAltPartOrFeature(parts[p],plantLocs[p]);
      for ( it=partsUsedAsAlt.begin(); it!=partsUsedAsAlt.end(); ++it ) {
        std::string partUsedAsAlt = *it;
        std::vector<float> altVol = eso2Prob.getAltVol(partUsedAsAlt,parts[p],plantLocs[p]);

        std::set<std::string> srcLocs = eso2Prob.getPartInterplantSrcLocs(partUsedAsAlt,plantLocs[p]);
        std::set<std::string>::const_iterator it1;
        for ( it1=srcLocs.begin(); it1!=srcLocs.end(); ++it1 ) {
          std::string srcLoc = *it1;
          std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(partUsedAsAlt,srcLoc,plantLocs[p]);
        
          // *JP for ( int t=0; t<shipVol.size(); t++ ) {
            if ( moveVol[t]==0.0 && !writeZeros && altVol[t]==0.0 ) continue;
            if (moveVol[t]==0.0) continue;
          
            fprintf(partShipReportFilePtr,
            "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,%f,\"%s\",\"%s\",%f\n",
              wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t+1,demandVol[t],shipVol[t],
              altVol[t],partUsedAsAlt.c_str(),
              srcLoc.c_str(),moveVol[t]);
          // *JP } // finished t loop
        } // finished srcLocs it1 loop
      } // finished partsUsedAsAlt it loop

      } // finished t loop

    } // finished p loop
  } // finished writing partShip file

 
d646 1
a899 1
        partShipReportFilePtr,
d926 3
@


1.63
log
@Modified to try to write a report with info kevin is asking for
@
text
@d228 1
a228 1
    heading="\"wfmvScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\",\"interPlantSrcLoc\",\"interPlantMoveVol\",\"upstreamPart\",\"altVol\""; 
d257 1
d260 1
a260 1
            "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,\"%s\",%f,\" \",0.0\n",
d281 1
d284 1
a284 1
            "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f,\"%s\",%f,\"%s\",%f\n",
d286 2
a287 2
              srcLoc.c_str(),moveVol[t],
              partUsedAsAlt.c_str(),altVol[t]);
@


1.62
log
@changed code to use std::string rather than BCP_string
@
text
@d61 1
d225 72
d754 3
d888 1
d931 1
@


1.61
log
@Changes to add loc to altData file.
Changes to start implementing PIP (pegging).
@
text
@a32 1
#include "BCP_string.h"
d35 1
a35 1
typedef std::vector<BCP_string> StdStringVec;
d105 1
a105 1
    BCP_string heading;
d109 3
a111 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d138 1
a138 1
    BCP_string heading;
d142 2
a143 2
    std::vector<BCP_string> features;
    std::vector<BCP_string> plantLocs;
d167 1
a167 1
    BCP_string heading;
d171 2
a172 2
    std::vector<BCP_string> looseParts;
    std::vector<BCP_string> plantLocs;
d195 1
a195 1
    BCP_string heading;
d199 3
a201 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> custLocs;
    std::vector<BCP_string> plantLocs;
d227 1
a227 1
    BCP_string heading;
d231 3
a233 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> features;
    std::vector<BCP_string> plantLocs;
d255 1
a255 1
    BCP_string heading;
d259 3
a261 3
    std::vector<BCP_string> partOrFeatures;
    std::vector<BCP_string> altParts;
    std::vector<BCP_string> locs;
d282 1
a282 1
    BCP_string heading;
d286 3
a288 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d312 1
a312 1
      BCP_string heading;
d323 3
a325 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> custLocs;
    std::vector<BCP_string> plantLocs;
d341 1
a341 1
          std::vector<BCP_string> mtms, mtmSrcLocs, mtmAcquireLocs;
d344 1
a344 1
          std::vector<BCP_string> features,featurePlantLocs;
d347 1
a347 1
          std::vector<BCP_string> looseParts,loosePartPlantLocs;
d393 1
a393 1
    BCP_string heading;
d395 2
a396 2
      BCP_string("\"wfmvScaleFactor\",") +
      BCP_string("\"netValue\",") +
d398 34
a431 34
      BCP_string("\"sumWfmvAllMtms\",") +
      BCP_string("\"sumWfvmAcquiredMtms\",") +
      BCP_string("\"numUniqueMtms\",") +
      BCP_string("\"numUniqueAcquiredMtms\",") +
      BCP_string("\"supplyQtyAllMtms\",") +
      BCP_string("\"acquiredQtyMtms\",") +

      BCP_string("\"moveCostMtm\",") +
      BCP_string("\"demanCostMtm\",") +
      

      BCP_string("\"sumWfmvAllFeatures\",") +
      BCP_string("\"sumWfvmAcquiredFeatures\",") +
      BCP_string("\"numUniqueFeatures\",") +
      BCP_string("\"numUniqueAcquiredFeatures\",") +
      BCP_string("\"supplyQtyAllFeatures\",") +
      BCP_string("\"acquiredQtyFeatures\",") +

      BCP_string("\"conversionCostFeatures\",") +


      BCP_string("\"sumWfmvAllLooseParts\",") +
      BCP_string("\"sumWfvmAcquiredLooseParts\",") +
      BCP_string("\"numUniqueLooseParts\",") +
      BCP_string("\"numUniqueAcquiredLooseParts\",") +
      BCP_string("\"supplyQtyAllLooseParts\",") +
      BCP_string("\"acquiredQtyLooseParts\",") +
      
      BCP_string("\"sumWacAllPartDemands\",") +
      BCP_string("\"sumWacMetPartDemands\",") +
      BCP_string("\"numUniquePartDemandTriples\",") +
      BCP_string("\"numUniqueMetPartDemandTriples\",") +
      BCP_string("\"demandQtyAllPartDemandTriples\",") +
      BCP_string("\"metQtyAllPartDemandTriples\",") +
d433 1
a433 1
      BCP_string("\"moveCostParts\"");
d575 1
a575 1
    std::vector<BCP_string> args;
d620 2
a621 2
    BCP_string outputDirectory=args[1];
    BCP_string inputDirectory=args[1];
d629 1
a629 1
      BCP_string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d635 1
a635 1
        BCP_string wzr = globalAttrFile.fieldAsString("writeZeroResults","attrValue");
d670 1
a670 1
    BCP_string mtmAcquirePlanFileName = outputDirectory+"/mtmAcquirePlanO.csv";
d673 1
a673 1
    BCP_string featureAcquirePlanFileName = outputDirectory+"/featureAcquirePlanO.csv";
d676 1
a676 1
    BCP_string loosePartAcquirePlanFileName = outputDirectory+"/loosePartAcquirePlanO.csv";
d679 1
a679 1
    BCP_string partShipFileName = outputDirectory+"/partShipO.csv";
d682 1
a682 1
    BCP_string featureXrefFileName = outputDirectory+"/featureXrefO.csv";
d685 1
a685 1
    BCP_string altFileName = outputDirectory+"/altO.csv";
d688 1
a688 1
    BCP_string partInterplantFileName = outputDirectory+"/partInterplantO.csv";
d691 1
a691 1
    BCP_string peggedMtmAcquirePlanFileName = outputDirectory+"/peggedMtmAcquirePlanO.csv";
d694 1
a694 1
    BCP_string peggedFeatureAcquirePlanFileName = outputDirectory+"/peggedFeatureAcquirePlanO.csv";
d697 1
a697 1
    BCP_string peggedLoosePartAcquirePlanFileName = outputDirectory+"/peggedLoosePartAcquirePlanO.csv";
d700 1
a700 1
    BCP_string kpiFileName = outputDirectory+"/keyPerformanceIndicatorsO.csv";
d778 1
a778 1
    BCP_string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d788 1
a788 1
      BCP_string attrName = BCP_string("wfmvScaleFactor")+BCP_string(sAsChar);
d867 1
a867 1
        std::vector<BCP_string> resourceDescriptions;
@


1.60
log
@Removed some debugging code
@
text
@d65 5
d308 83
a390 1
  
d691 9
d816 3
d857 3
@


1.59
log
@Changed output file field from partOrFeature to part
@
text
@d742 1
@


1.58
log
@modified to reduce the number of times wit does preprocessing
@
text
@d252 1
a252 1
    heading="\"wfmvScaleFactor\",\"partOrFeature\",\"altPart\",\"loc\",\"period\",\"altVol\""; 
@


1.57
log
@Replaced std::string with BCP_string to work around VAC compiler problem
@
text
@d395 1
d404 1
d424 1
a424 2
    
    
d428 2
a429 1
      (mtmSumAcquireCost + featureSumAcquireCost + loosePartSumAcquireCost +
d649 1
d658 1
d742 1
a742 1
    //eso2Prob.reportPartDemand("0000000P1690","980","980",9-1);
@


1.56
log
@Added code to covert from old file format to new
@
text
@d33 1
d36 1
a36 1
typedef std::vector<std::string> StdStringVec;
d101 1
a101 1
    std::string heading;
d105 3
a107 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d134 1
a134 1
    std::string heading;
d138 2
a139 2
    std::vector<std::string> features;
    std::vector<std::string> plantLocs;
d163 1
a163 1
    std::string heading;
d167 2
a168 2
    std::vector<std::string> looseParts;
    std::vector<std::string> plantLocs;
d191 1
a191 1
    std::string heading;
d195 3
a197 3
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
d223 1
a223 1
    std::string heading;
d227 3
a229 3
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> plantLocs;
d251 1
a251 1
    std::string heading;
d255 3
a257 3
    std::vector<std::string> partOrFeatures;
    std::vector<std::string> altParts;
    std::vector<std::string> locs;
d278 1
a278 1
    std::string heading;
d282 3
a284 3
    std::vector<std::string> parts;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d307 1
a307 1
    std::string heading;
d309 2
a310 2
      std::string("\"wfmvScaleFactor\",") +
      std::string("\"netValue\",") +
d312 34
a345 34
      std::string("\"sumWfmvAllMtms\",") +
      std::string("\"sumWfvmAcquiredMtms\",") +
      std::string("\"numUniqueMtms\",") +
      std::string("\"numUniqueAcquiredMtms\",") +
      std::string("\"supplyQtyAllMtms\",") +
      std::string("\"acquiredQtyMtms\",") +

      std::string("\"moveCostMtm\",") +
      std::string("\"demanCostMtm\",") +
      

      std::string("\"sumWfmvAllFeatures\",") +
      std::string("\"sumWfvmAcquiredFeatures\",") +
      std::string("\"numUniqueFeatures\",") +
      std::string("\"numUniqueAcquiredFeatures\",") +
      std::string("\"supplyQtyAllFeatures\",") +
      std::string("\"acquiredQtyFeatures\",") +

      std::string("\"conversionCostFeatures\",") +


      std::string("\"sumWfmvAllLooseParts\",") +
      std::string("\"sumWfvmAcquiredLooseParts\",") +
      std::string("\"numUniqueLooseParts\",") +
      std::string("\"numUniqueAcquiredLooseParts\",") +
      std::string("\"supplyQtyAllLooseParts\",") +
      std::string("\"acquiredQtyLooseParts\",") +
      
      std::string("\"sumWacAllPartDemands\",") +
      std::string("\"sumWacMetPartDemands\",") +
      std::string("\"numUniquePartDemandTriples\",") +
      std::string("\"numUniqueMetPartDemandTriples\",") +
      std::string("\"demandQtyAllPartDemandTriples\",") +
      std::string("\"metQtyAllPartDemandTriples\",") +
d347 1
a347 1
      std::string("\"moveCostParts\"");
d487 1
a487 1
    std::vector<std::string> args;
d532 2
a533 2
    std::string outputDirectory=args[1];
    std::string inputDirectory=args[1];
d541 1
a541 1
      std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d547 1
a547 1
        std::string wzr = globalAttrFile.fieldAsString("writeZeroResults","attrValue");
d582 1
a582 1
    std::string mtmAcquirePlanFileName = outputDirectory+"/mtmAcquirePlanO.csv";
d585 1
a585 1
    std::string featureAcquirePlanFileName = outputDirectory+"/featureAcquirePlanO.csv";
d588 1
a588 1
    std::string loosePartAcquirePlanFileName = outputDirectory+"/loosePartAcquirePlanO.csv";
d591 1
a591 1
    std::string partShipFileName = outputDirectory+"/partShipO.csv";
d594 1
a594 1
    std::string featureXrefFileName = outputDirectory+"/featureXrefO.csv";
d597 1
a597 1
    std::string altFileName = outputDirectory+"/altO.csv";
d600 1
a600 1
    std::string partInterplantFileName = outputDirectory+"/partInterplantO.csv";
d603 1
a603 1
    std::string kpiFileName = outputDirectory+"/keyPerformanceIndicatorsO.csv";
d679 1
a679 1
    std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d689 1
a689 1
      std::string attrName = std::string("wfmvScaleFactor")+std::string(sAsChar);
d761 1
a761 1
        std::vector<std::string> resourceDescriptions;
@


1.55
log
@Added code to write alt output file
@
text
@a5 14
/*
1. ensure allacquired looseParts, features, mtms are used to satisfy demand.

2. add outputs with excess and consVol

3. implement alternates..

altFile
  partOrFeature,altPart,altConvCost,altConvTime
altOverrideFile
  partOrFeature,altPart,loc,altConvCost,altConvTime
altExcludeLocFile
  partOrFeature,altPart,excludeLoc
*/
@


1.54
log
@Modified so there there is a scrap cost on all parts (except for parts created from demanufacturing).
This is an attempt to ensure all acquired parts are consumed.
@
text
@d76 1
a261 1
#if 0
d265 2
a266 2
    heading="\"wfmvScaleFactor\",\"upLevelPart\",\"downLevelPart\",\"plantLoc\",\"period\",\"ecVol\""; 
    if (writeHeader) fprintf(alternatePartFilePtr,"%s\n",heading.c_str());
d268 4
a271 4
    std::vector<std::string> upLevelParts;
    std::vector<std::string> downLevelParts;
    std::vector<std::string> plantLocs;
    eso2Prob.getAlternateParts(upLevelParts,downLevelParts,plantLocs);
d273 1
a273 1
    // loop once for each alternatePart
d275 7
a281 8
    for ( e=0; e<upLevelParts.size(); e++ ) {
      
      std::vector<float> ecVol = eso2Prob.getAlternatePartEcVol(upLevelParts[e],downLevelParts[e],plantLocs[e]);
      assert( ecVol.size() == nPeriods );
      std::vector<float> ecCost = eso2Prob.getAlternatePartCost(upLevelParts[e],downLevelParts[e],plantLocs[e]);
      for ( int t=0; t<ecVol.size(); t++ ) {
        if ( ecVol[t]==0.0 && !writeZeros ) continue;
        fprintf(alternatePartFilePtr,
d283 2
a284 2
          wfmvScaleFactor,upLevelParts[e].c_str(),downLevelParts[e].c_str(),plantLocs[e].c_str(),t+1,ecVol[t]);
        //alternatePartCost += ecVol[t]*ecCost[t];
d287 1
a287 2
  } // finished writing alternatePart file
#endif
d610 3
d727 1
@


1.53
log
@Added bigM method to eso2Problem and updated code to use this constant
@
text
@d14 1
a14 1
  partOrFeature,altPart,altCost,altTime
d16 1
a16 1
  partOrFeature,altPart,loc,altCost,altTime
d18 1
a18 1
  partOrFeature,altPart,excludeLOc
@


1.52
log
@changes to have demanCost and demanTime be from deman location, rather supply loc and time
@
text
@d6 15
@


1.51
log
@Modified to implement featureXref
@
text
@a5 2
// todo: deman time and cost is from location of deman, not location of supply

@


1.50
log
@removed cout
@
text
@d6 1
d62 1
a62 1
      FILE * alternatePartFilePtr,
d219 30
d276 1
d596 2
a597 2
    std::string alternatePartFileName = outputDirectory+"/alternatePartO.csv";
    FILE * alternatePartFilePtr = fopen(alternatePartFileName.c_str(),"w");
d712 1
a712 1
        alternatePartFilePtr,
d749 1
a749 1
    fclose(alternatePartFilePtr);
@


1.49
log
@Added some diagnostics
@
text
@d344 1
a344 1
    std::cout <<"mtmNumUniqueAcquired=" <<mtmNumUniqueAcquired <<" mtmAcquiredQuantity=" <<mtmAcquiredQuantity <<std::endl;
@


1.48
log
@removed assert
@
text
@d114 3
a116 3
      std::vector<float> wfmv = eso2Prob.getMtmWfmv(mtms[m],srcLocs[m]);
      std::vector<float> demanCost = eso2Prob.getMtmDemanCost(mtms[m],srcLocs[m]);
      std::vector<float> moveCost = eso2Prob.getMtmInterplantMoveCost(mtms[m],srcLocs[m],destLocs[m]);
d343 2
@


1.47
log
@fixed spelling error in kpi header record
@
text
@d400 1
a400 1
    assert(eq(calcObj,witObjVal));
@


1.46
log
@Modified kpi's to be computed in double precision
\
@
text
@d300 1
a300 1
      std::string("\"conversionCostFeature\",") +
@


1.45
log
@add some diagnostic messages
@
text
@d65 15
a79 15
      float mtmTotalWfmvAtScale1,
      int   mtmNumUnique,
      float mtmSupplyQuantity,
      
      float featureTotalWfmvAtScale1,
      int   featureNumUnique,
      float featureSupplyQuantity,
      
      float loosePartTotalWfmvAtScale1,
      int   loosePartNumUnique,
      float loosePartSupplyQuantity,
      
      float  partDemandSumDemandWac,
      int    partDemandNumUnique,
      float  partDemandSumDemandVol,
d320 2
a321 2
    float witObjVal = eso2Prob.getObjValue();
    float partMoveCost = eso2Prob.sumOfPartMoveCost();
d325 4
a328 4
    float mtmTotalWfmvWithScaleFactorTEMP;
    float mtmSumAcquireCost;
    float mtmSumMoveCost;
    float mtmSumDemanCost;
d331 2
a332 2
    float mtmSupplyQuantityTEMP;
    float mtmAcquiredQuantity;
d344 3
a346 3
    float featureTotalWfmvWithScaleFactorTEMP;
    float featureSumAcquireCost;
    float featureSumXrefCost;
d349 2
a350 2
    float featureSupplyQuantityTEMP;
    float featureAcquiredQuantity;
d361 2
a362 2
    float loosePartTotalWfmvWithScaleFactorTEMP;
    float loosePartSumAcquireCost;
d365 2
a366 2
    float loosePartSupplyQuantityTEMP;
    float loosePartAcquiredQuantity;
d376 2
a377 2
    float partDemandSumDemandWacTEMP;
    float partDemandSumShippedWac;
d380 2
a381 2
    float partDemandSumDemandVolTEMP;
    float partDemandSumShipVol;
d393 1
a393 1
    float calcObj=
d574 4
a577 4
    float mtmTotalWfmvAtScale1;
    float mtmSumAcquireCostTemp;
    float mtmSumMoveCostTemp;
    float mtmSumDemanCostTemp;
d580 2
a581 2
    float mtmSupplyQuantity;
    float mtmAcquiredQuantityTemp;
d593 3
a595 3
    float featureTotalWfmvAtScale1;
    float featureSumAcquireCostTemp;
    float featureSumXrefCostTemp;
d598 2
a599 2
    float featureSupplyQuantity;
    float featureAcquiredQuantityTemp;
d610 2
a611 2
    float loosePartTotalWfmvAtScale1;
    float loosePartSumAcquireCostTemp;
d614 2
a615 2
    float loosePartSupplyQuantity;
    float loosePartAcquiredQuantityTemp;
d625 2
a626 2
    float partDemandSumDemandWac;
    float partDemandSumShippedWacTemp;
d629 2
a630 2
    float partDemandSumDemandVol;
    float partDemandSumShipVolTemp;
@


1.44
log
@updated tolerances for eps
@
text
@d392 1
a392 1
    CoinRelFltEq eq(1.e-6);
d399 1
@


1.43
log
@Added writing of kpi's
@
text
@d701 1
@


1.42
log
@fix to have wfmv be source of perishable supply when non-perishable supply has supplyVol=0
@
text
@d19 1
d64 17
d86 1
d95 1
d123 3
a125 3
        mtmAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
        mtmDemanCost += acqQtyRnd(acquireQty[t])*demanCost[t];
        mtmInterplantCost += acqQtyRnd(acquireQty[t])*moveCost[t];
d153 1
a153 1
        featureAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
d182 1
a182 1
          loosePartAcquireCost += acqQtyRnd(acquireQty[t])*applyScaleToWfmv(wfmvScaleFactor,wfmv[t]);
d213 1
a213 1
        partAcquireAvoidanceValue += shipVol[t]*wac[t];
d241 1
a241 1
        alternatePartCost += ecVol[t]*ecCost[t];
d269 1
a269 1
        partInterplantCost += moveVol[t]*moveCost[t];
a279 1
      std::string("\"witObjVal\",") +
d281 37
a317 8
      std::string("\"featureAcquireCost\",") +
      std::string("\"loosePartAcquireCost\",") +
      std::string("\"mtmAcquireCost\",") +
      std::string("\"mtmDemanCost\",") +
      std::string("\"mtmInterplantCost\",") +
      std::string("\"alternatePartCost\",") +
      std::string("\"partInterplantCost\",") +
      std::string("\"partAcquireAvoidanceValue\"");
d321 1
a322 9
    float netValue = 
      partAcquireAvoidanceValue -
      (featureAcquireCost +
       loosePartAcquireCost +
       mtmAcquireCost +
       mtmDemanCost +
       mtmInterplantCost +
       alternatePartCost +
       partInterplantCost );
d324 77
d402 2
a403 1
      "%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f\n",
d406 34
a439 9
      netValue,
      featureAcquireCost,
      loosePartAcquireCost,
      mtmAcquireCost,
      mtmDemanCost,
      mtmInterplantCost,
      alternatePartCost,
      partInterplantCost,
      partAcquireAvoidanceValue);
d572 68
d680 17
@


1.41
log
@Changed default demanTime to be nPeriods+1.
Fixed so demanTime is properly considered after interPlant moves.
Updated to set deman prodRate to attach rate associated with period of supply being deman'ed
@
text
@d473 1
a473 1
    //eso2Prob.reportPartDemand("0000041L5225","980","980",12-1);
d475 1
a475 1
    eso2Prob.reportPartDemand("u3","kgn","wat",4-1);
@


1.40
log
@More diagnositic info
@
text
@d429 1
a430 1
    //eso2Prob.writeWitData(outputDirectory + "/eso2.wit");
@


1.39
log
@removed purge executable from appl.mk
@
text
@d473 1
a473 1
    eso2Prob.reportPartDemand("0000041L5225","980","980",12-1);
d475 1
a475 1
    //eso2Prob.reportPartDemand("u3","kgn","wat",4-1);
@


1.38
log
@added writeZeroResults global attribute
@
text
@d473 1
@


1.37
log
@added code to traverse tree for one demand
@
text
@d62 2
a63 1
      FILE * kpiFilePtr )
d99 1
a99 1
        if ( acquireQty[t]==0.0 ) continue;
d129 1
a129 1
        if ( acquireQty[t]==0.0 ) continue;
d158 1
a158 1
        if ( acquireQty[t]==0.0 ) continue;
d189 1
a189 1
        if ( shipVol[t]==0.0 ) continue;
d217 1
a217 1
        if ( ecVol[t]==0.0 ) continue;
d245 1
a245 1
        if ( moveVol[t]==0.0 ) continue;
d361 37
a430 1
    
a431 1
    // Get number of solves to be done (ie number of scale factors)
a433 1
    int nWfmvScaleFactors=globalAttrFile.fieldAsInt("nWfmvScaleFactors","attrValue");
d468 2
a469 1
        kpiFilePtr );
d473 1
a473 1
    eso2Prob.reportPartDemand("0000053P6023","980","980",12-1);
@


1.36
log
@updated to put osl log file input/output directory
@
text
@d437 5
@


1.35
log
@Modified kpi output file
@
text
@d360 1
d392 1
a392 1
    eso2Prob.writeWitData(outputDirectory + "/eso2.wit");
@


1.34
log
@modified to not write zero's to output file
@
text
@d45 2
a46 2
  return scale*wfmv;
  //return wfmv;
@


1.33
log
@Fixed problem with displaying header record in output files
@
text
@d98 1
d128 1
d157 1
d188 1
d216 1
d244 1
@


1.32
log
@Some modification of messages displayed and fixing up end period for last supply period perishability.
@
text
@d416 1
a416 1
      if ( s== 0 ) writeHeader = true;
@


1.31
log
@Changes to implement period1SupplyPerishabilityLimit
@
text
@d407 1
a407 1
        <<". solve " <<s+1 <<" of " <<nWfmvScaleFactors <<"."
@


1.30
log
@Updated to change 1 to be the first period.
@
text
@d354 2
a355 1
    createModel(eso2Prob, inputDirectory);
@


1.29
log
@Updated to change 1 to be the first period.
Added additional test to see if objValue has changed
@
text
@d100 1
a100 1
          wfmvScaleFactor,mtms[m].c_str(),srcLocs[m].c_str(),destLocs[m].c_str(),t,supply[t],acquireQty[t]);
d129 1
a129 1
          wfmvScaleFactor,features[f].c_str(),plantLocs[f].c_str(),t,supply[t],acquireQty[t]);
d157 1
a157 1
          wfmvScaleFactor,looseParts[f].c_str(),plantLocs[f].c_str(),t,supply[t],acquireQty[t]);
d187 1
a187 1
          wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t,demandVol[t],shipVol[t]);
d214 1
a214 1
          wfmvScaleFactor,upLevelParts[e].c_str(),downLevelParts[e].c_str(),plantLocs[e].c_str(),t,ecVol[t]);
d241 1
a241 1
          wfmvScaleFactor,parts[i].c_str(),srcLocs[i].c_str(),destLocs[i].c_str(),t,moveVol[t]);
a299 34
  {
    int n=16;
    int ix[16];
    ix[0]=0;
    ix[1]=0;
    ix[2]=2;
    ix[3]=3;
    ix[4]=4;
    ix[5]=4;
    ix[6]=4;
    ix[7]=4;
    ix[8]=4;
    ix[9]=4;
    ix[10]=5;
    ix[11]=6;
    ix[12]=6;
    ix[13]=6;
    ix[14]=6;
    ix[15]=7;
    for ( int mt=0; mt<n-1; mt=mt+1 ) {
      if ( ix[mt]==ix[mt+1] ) break;
    }
    for ( int mf=mt+1; mf<n; mf=mf+1 ) {
      if ( ix[mt]!=ix[mf] ) {
        mt=mt+1;
        //if (mt!=mf) 
          ix[mt]=ix[mf];
        //else
        //  std::cout <<"mt==mf" <<std::endl;
      }
    }
    std::cout <<" ";

  }
d394 1
a394 1
    for ( s=0; s<nWfmvScaleFactors;  ++s ) {
@


1.28
log
@Some changes getting ready for AIX build
@
text
@d377 1
a377 1
          <<"    " <<argv[0] <<" example1"                             <<std::endl
@


1.27
log
@updated unitTest to do something useful.
fixed problems with prunning. Now works for all testCases.
@
text
@d417 2
a418 1
    //eso2Prob.writeWitData(outputDirectory + "/eso2.wit");
a419 1
    eso2Prob.pruneWitModel();
@


1.26
log
@Changed so partInterplants are applied to parts obtained from an mtm that has had an interplant move.
@
text
@d6 3
d13 1
a13 1
#include <iostream.h>
d17 3
a49 237
#if 0
// Add all interplant moves from the specified part & srcLoc
// This is a recursive function because a new part at destLoc may be created,
// which will then have to be moved to all of its destination locations.
void addAllPartInterplants(
                    ESO2problem & eso2Prob,
                    std::map<std::string,StdStringVec>> & srcToDestLocs,
                    const ESO2partInterplantData & partInterplantFile,
                    const std::string & part,
                    const std::string & srcLoc)
{
  StdStringVec destLocs = srcToDestLocs[srcLoc];

  // Loop once for each destination location
  int l=0;
  for ( l=0; l<destLocs.size(); l++ ) {
    const std::string & destLoc = destLocs[l];
    // does part at dest loc exist
    bool partExist = eso2Prob.partExists(part,destLoc);
    
    // If link between srcLoc and destLoc for part does not exist, then add it to model
    if ( !eso2Prob.partInterplantExists(part,srcLoc,destLoc ) ) {
      
      // Get default move cost and time between srcLoc and destLoc
      float defaultMoveCost = 1000000.f;
      float defaultMoveTime = 0.0f;
      if ( partInterplantFile.keyExists(srcLoc,destLoc) ) {
        defaultMoveCost = partInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
        defaultMoveTime = partInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
      }
      else {
        // Default part interplant move time and cost does not exist
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: default part interplant move time and cost does not exist in partInterplantData file" <<endl
          <<"   partInterplantData filename: " <<partInterplantFile.filename().c_str()   <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
          <<"   destLoc: " <<destLoc.c_str()                                 <<endl
          <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<endl
          <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<endl
          <<"-------------------------------------------------------"        <<endl;
      }
      eso2Prob.addPartInterplant(part,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
    } // end adding interplant.

    // If part destination part did not exist, now it does after adding interplant.
    // Add all interplant moves for this new part
    if ( !partExist ) {
      addAllPartInterplants( eso2Prob, srcToDestLocs, partInterplantFile, part, destLoc);
    }
  }  // end for l 
}

#endif


// Add all interplant moves from the specified mtm & srcLoc
// This is not a recursive function because an mtm is only moved once.
void addAllMtmInterplants(
                    ESO2problem & eso2Prob,
                    std::map<std::string,StdStringVec>> & srcToDestLocs,
                    const ESO2mtmInterplantData & mtmInterplantFile,
                    const std::string & mtm,
                    const std::string & srcLoc)
{
  StdStringVec destLocs = srcToDestLocs[srcLoc];

  // Loop once for each destination location
  int l=0;
  for ( l=0; l<destLocs.size(); l++ ) {
    const std::string & destLoc = destLocs[l];
    // does mtm at dest loc exist
    bool mtmExist = eso2Prob.mtmExists(mtm,destLoc);
    
    // If link between srcLoc and destLoc for part does not exist, then add it to model
    if ( !eso2Prob.mtmInterplantExists(mtm,srcLoc,destLoc ) ) {
      
      // Get default move cost and time between srcLoc and destLoc
      float defaultMoveCost = 1000000.f;
      float defaultMoveTime = 0.0f;
      if ( mtmInterplantFile.keyExists(srcLoc,destLoc) ) {
        defaultMoveCost = mtmInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
        defaultMoveTime = mtmInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
      }
      else {
        // Default mtm interplant move time and cost does not exist
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: default mtm interplant move time and cost does not exist in mtmInterplantData file" <<endl
          <<"   partInterplantData filename: " <<mtmInterplantFile.filename().c_str()   <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
          <<"   destLoc: " <<destLoc.c_str()                                 <<endl
          <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<endl
          <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<endl
          <<"-------------------------------------------------------"        <<endl;
      }
      eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
    } // end adding interplant.

    //if ( !mtmExist ) {
    //  addAllMtmInterplants( eso2Prob, srcToDestLocs, mtmInterplantFile, mtm, destLoc);
    //}
  }  // end for l 
}

void createModel(ESO2problem & eso2Prob, const std::string & inputDirectory )
{
  cout <<"Reading input files" <<endl;
  
  int nPeriods;      

  // Set up interplant moves info
  typedef std::vector<std::string> StdStringVec;
  //std::map<std::string,StdStringVec> partSrcToDests;
  std::map<std::string,StdStringVec> mtmSrcToDests;
  
  // Read Global Attributes
  std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
  ESO2globalAttrData globalAttrFile(globalAttrFileName);
  {      
    std::string title=globalAttrFile.fieldAsString("title","attrValue");
    eso2Prob.setTitle(title);
    
    nPeriods=globalAttrFile.fieldAsInt("nPeriods","attrValue");
    eso2Prob.setNPeriods(nPeriods);

    std::vector<std::string> priorities;
    priorities.push_back("mtmPriority");
    priorities.push_back("featurePriority");
    priorities.push_back("loosePartPriority");
    int p;
    for ( p=0; p<3; ++p ) {
      bool attrExists = globalAttrFile.keyExists(priorities[p]);
      if ( !attrExists ) {
        // Priority attribute does not exist
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Error: " <<priorities[p].c_str() <<" not specified."            <<endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<endl
          <<"   valid range: 1<=" <<priorities[p].c_str() <<"<=4"            <<endl
          <<"-------------------------------------------------------"        <<endl;
        exit(1);
      }
      int priority = globalAttrFile.fieldAsInt(priorities[p],"attrValue");
      if ( priority<1 || priority>4 ) {
        // Priority is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Error: " <<priorities[p].c_str() <<" is out of allowed range"   <<endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<endl
          <<"   " <<priorities[p].c_str() <<": " <<globalAttrFile.fieldAsString(priorities[p],"attrValue").c_str() <<endl
          <<"   valid range: 1<=" <<priorities[p].c_str() <<"<=4"            <<endl
          <<"-------------------------------------------------------"        <<endl;
        exit(1);
      }
      if ( p==0 ) eso2Prob.setMtmPriority(priority);
      else if ( p==1 )  eso2Prob.setFeaturePriority(priority);
      else if ( p==2 )  eso2Prob.setLoosePartPriority(priority);
    }
  }

  // Read part interplant File and set up structures for using data
  std::string partInterplantFileName = inputDirectory + "/partInterplantData.csv";
  ESO2partInterplantData partInterplantFile(partInterplantFileName);
  {
    ESO2partInterplantDataIterator partInterplantFileIter(partInterplantFile);
    
    // loop once for each record in partInterplant file
    for ( ; partInterplantFileIter()!=NULL; ) {
      std::string srcLoc = partInterplantFileIter.srcLoc();
      std::string destLoc = partInterplantFileIter.destLoc();
      float defaultMoveCost = partInterplantFileIter.defaultMoveCostAsFloat();
      float defaultMoveTime = partInterplantFileIter.defaultMoveTimeAsFloat();
      eso2Prob.addPartsInterplant(srcLoc,destLoc,defaultMoveCost,defaultMoveTime);      
    }
  }

  // Read mtm interplant File and set up structures for using data
  std::string mtmInterplantFileName = inputDirectory + "/mtmInterplantData.csv";
  ESO2mtmInterplantData mtmInterplantFile(mtmInterplantFileName);
  {
    ESO2mtmInterplantDataIterator mtmInterplantFileIter(mtmInterplantFile);
    
    // loop once for each record in partInterplant file
    for ( ; mtmInterplantFileIter()!=NULL; ) {
      std::string srcLoc = mtmInterplantFileIter.srcLoc();
      std::string destLoc = mtmInterplantFileIter.destLoc();
      mtmSrcToDests[srcLoc].push_back(destLoc);     
    }
  }
  
  
  // Read MTM File
  {
    std::string mtmFileName = inputDirectory + "/mtmData.csv";
    ESO2mtmData mtmFile(mtmFileName);
    ESO2mtmDataIterator mtmFileIter(mtmFile);
    
    // loop once for each record in mtm file
    for ( ; mtmFileIter()!=NULL; ) {
      std::string mtm = mtmFileIter.mtm();
      std::string plantLoc = mtmFileIter.plantLoc();
      int period = mtmFileIter.periodAsInt();
      float supply = mtmFileIter.supplyAsFloat();
      float wfmv = mtmFileIter.wfmvAsFloat();
      float demanCost = mtmFileIter.demanCostAsFloat();
      float demanTime = mtmFileIter.demanTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   mtm filename: " <<mtmFile.filename().c_str()                 <<endl
          <<"   mtm file line number: " <<mtmFileIter.recNum()               <<endl
          <<"   mtm: " <<mtm.c_str()                                         <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
        eso2Prob.addMtm(mtm,plantLoc);
        addAllMtmInterplants(eso2Prob, mtmSrcToDests, mtmInterplantFile, mtm,plantLoc);
      }
      
      eso2Prob.setMtmSupply(mtm,plantLoc,period,supply);
      eso2Prob.setMtmWfmv(mtm,plantLoc,period,wfmv);
      eso2Prob.setMtmDemanCost(mtm,plantLoc,period,demanCost);
      eso2Prob.setMtmDemanTime(mtm,plantLoc,period,demanTime);
      
    } // end loop reading mtm file record
  } // end of block reading mtm file
a50 496
  // Read mtmInterplantOverride File
  {
    std::string mtmInterplantOverrideFileName = inputDirectory + "/mtmInterplantOverrideData.csv";
    ESO2mtmInterplantOverrideData mtmInterplantOverrideFile(mtmInterplantOverrideFileName);
    ESO2mtmInterplantOverrideDataIterator mtmInterplantOverrideFileIter(mtmInterplantOverrideFile);
    
    // loop once for each record in mtmInterplant file
    for ( ; mtmInterplantOverrideFileIter()!=NULL; ) {
      std::string mtm = mtmInterplantOverrideFileIter.mtm();
      std::string srcLoc = mtmInterplantOverrideFileIter.srcLoc();
      std::string destLoc = mtmInterplantOverrideFileIter.destLoc();
      int period = mtmInterplantOverrideFileIter.periodAsInt();
      float moveCost = mtmInterplantOverrideFileIter.moveCostAsFloat();
      float moveTime = mtmInterplantOverrideFileIter.moveTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                               <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl           
          <<"   destLoc: " <<destLoc.c_str()                                 <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
             
      // Test to make sure mtm exists
      if ( !eso2Prob.mtmExists(mtm,srcLoc) ) {
        // mtm does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"      <<endl
          <<"Warning: mtm at srcLoc does not exist"                        <<endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                             <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                 <<endl          
          <<"   destLoc: " <<destLoc.c_str()                               <<endl
          <<"   period: " <<period                                         <<endl
          <<"   record will be ignored. "                                  <<endl
          <<"-------------------------------------------------------"      <<endl;
        continue;
      }  
      
      // Test to make sure not interplanting to self
      if ( srcLoc==destLoc ) {
        // can not interplant to self
        cout 
          <<"-------------------------------------------------------"      <<endl
          <<"Warning: srcLoc and destLoc are same location"                <<endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                             <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                 <<endl          
          <<"   destLoc: " <<destLoc.c_str()                               <<endl
          <<"   period: " <<period                                         <<endl
          <<"   record will be ignored. "                                  <<endl
          <<"-------------------------------------------------------"      <<endl;
        continue;
      }

      // if mtmInterplant connection does not exist, then add it
      if ( !eso2Prob.mtmInterplantExists(mtm,srcLoc,destLoc) ) {
        // add mtmInterplant connection
        
        // Get default move cost and time between srcLoc and destLoc
        float defaultMoveCost = 1000000.f;
        float defaultMoveTime = 0.0f;
        if ( mtmInterplantFile.keyExists(srcLoc,destLoc) ) {
          defaultMoveCost = mtmInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
          defaultMoveTime = mtmInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
        }
        else {
          // Default part interplant move time and cost does not exist
          cout 
            <<"-------------------------------------------------------"        <<endl
            <<"Warning: default mtm interplant move time and cost does not exist in mtmInterplantData file" <<endl
            <<"   mtmInterplantData filename: " <<mtmInterplantFile.filename().c_str()   <<endl
            <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
            <<"   destLoc: " <<destLoc.c_str()                                 <<endl
            <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<endl
            <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<endl
            <<"-------------------------------------------------------"        <<endl;
        }
        eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
      }
      
      eso2Prob.setMtmInterplantMoveCost(mtm,srcLoc,destLoc,period,moveCost);
      eso2Prob.setMtmInterplantMoveTime(mtm,srcLoc,destLoc,period,moveTime);
      
    } // end loop reading mtmInterplant file record
  } // end of block reading mtmInterplant file





  
  // Read Feature File
  {
    std::string featureFileName = inputDirectory + "/featureData.csv";
    ESO2featureData featureFile(featureFileName);
    ESO2featureDataIterator featureFileIter(featureFile);
    
    // loop once for each record in feature file
    for ( ; featureFileIter()!=NULL; ) {
      std::string feature = featureFileIter.feature();
      std::string plantLoc = featureFileIter.plantLoc();
      int period = featureFileIter.periodAsInt();
      float supply = featureFileIter.supplyAsFloat();
      float wfmv = featureFileIter.wfmvAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   feature filename: " <<featureFile.filename().c_str()         <<endl
          <<"   feature file line number: " <<featureFileIter.recNum()       <<endl
          <<"   feature: " <<feature.c_str()                                 <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      if ( !eso2Prob.featureExists(feature,plantLoc) ) {
        eso2Prob.addFeature(feature,plantLoc);
      }
      
      eso2Prob.setFeatureSupply(feature,plantLoc,period,supply);
      eso2Prob.setFeatureWfmv(feature,plantLoc,period,wfmv);
      
    } // end loop reading feature file record
  } // end of block reading feature file
  

  

  
  // Read LoosePart File
  {
    std::string loosePartFileName = inputDirectory + "/loosePartData.csv";
    ESO2loosePartData loosePartFile(loosePartFileName);
    ESO2loosePartDataIterator loosePartFileIter(loosePartFile);
    
    // loop once for each record in loosePart file
    for ( ; loosePartFileIter()!=NULL; ) {
      std::string loosePart = loosePartFileIter.part();
      std::string plantLoc = loosePartFileIter.plantLoc();
      int period = loosePartFileIter.periodAsInt();
      float supply = loosePartFileIter.supplyAsFloat();
      float wfmv = loosePartFileIter.wfmvAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   loosePart filename: " <<loosePartFile.filename().c_str()         <<endl
          <<"   loosePart file line number: " <<loosePartFileIter.recNum()       <<endl
          <<"   part: " <<loosePart.c_str()                                 <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      if ( !eso2Prob.loosePartExists(loosePart,plantLoc) ) {
        eso2Prob.addLoosePart(loosePart,plantLoc);
#if 0
        // add move to all destLocs
        addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, loosePart,plantLoc);
#endif
      }
      
      eso2Prob.setLoosePartSupply(loosePart,plantLoc,period,supply);
      eso2Prob.setLoosePartWfmv(loosePart,plantLoc,period,wfmv);
      
    } // end loop reading loosePart file record
  } // end of block reading loosePart file
  
  // Read Mtm Demanufacturing Bom File
  {
    std::string mtmDemanBomFileName = inputDirectory + "/mtmDemanBomData.csv";
    ESO2mtmDemanBomData mtmDemanBomFile(mtmDemanBomFileName);
    ESO2mtmDemanBomDataIterator mtmDemanBomFileIter(mtmDemanBomFile);

    int etnFlagFilter = globalAttrFile.fieldAsInt("etnFlagFilter","attrValue");
    
    // loop once for each record in mtmDemanBom file
    for ( ; mtmDemanBomFileIter()!=NULL; ) {
      std::string mtm = mtmDemanBomFileIter.mtm();
      std::string part = mtmDemanBomFileIter.part();
      std::string srcLoc = mtmDemanBomFileIter.srcLoc();
      int period = mtmDemanBomFileIter.periodAsInt();
      float attachRate = mtmDemanBomFileIter.attachRateAsFloat();
      int etnFlag = mtmDemanBomFileIter.etnFlagAsInt();

      // check to see if this record is to be filtered
      if ( etnFlagFilter==0 && etnFlag!=0 ) continue;
      if ( etnFlagFilter==1 && etnFlag!=1 ) continue;
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str() <<endl
          <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<endl
          <<"   mtm: " <<mtm.c_str()                                         <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // Test to make sure mtm exists
      if ( !eso2Prob.mtmExists(mtm,srcLoc) ) {
        // mtm does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"          <<endl
          <<"Warning: mtm at srcLoc does not exist"                            <<endl
          <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str()   <<endl
          <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<endl
          <<"   mtm: " <<mtm.c_str()                                           <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                     <<endl
          <<"   record will be ignored. "                                      <<endl
          <<"-------------------------------------------------------"          <<endl;
        continue;
      }
      
      // If bom entry does not exist, then add it to model
      if ( !eso2Prob.demanBomExists(mtm,part,srcLoc ) ) {
        //bool partExists = eso2Prob.partExists(part,srcLoc);
        eso2Prob.addDemanBom(mtm,part,srcLoc);
        
        //// if part is a new part, then add all of its interplant moves
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,srcLoc);
      }
      
      eso2Prob.setDemanBomAttachRate(mtm,part,srcLoc,period,attachRate);
      
    } // end loop reading mtmDemanBom file record
  } // end of block reading mtmDemanBom file
  
  
  // Read alternatePart File
  {
    std::string alternatePartFileName = inputDirectory + "/alternatePartData.csv";
    ESO2alternatePartData alternatePartFile(alternatePartFileName);
    ESO2alternatePartDataIterator alternatePartFileIter(alternatePartFile);
    
    // loop once for each record in alternatePart file
    for ( ; alternatePartFileIter()!=NULL; ) {
      std::string upLevelPart = alternatePartFileIter.upLevelPart();
      std::string downLevelPart = alternatePartFileIter.downLevelPart();
      std::string plantLoc = alternatePartFileIter.plantLoc();
      int period = alternatePartFileIter.periodAsInt();
      float prodRate = alternatePartFileIter.prodRateAsFloat();
      float cost = alternatePartFileIter.costAsFloat();
      float usageTime = alternatePartFileIter.usageTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()           <<endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()         <<endl
          <<"   upLevelPart: " <<upLevelPart.c_str()                         <<endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // Test to make sure downLevel part exists
      if ( !eso2Prob.partExists(downLevelPart,plantLoc) ) {
        // part does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: downLevelPart at plantLoc does not exist"              <<endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()           <<endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()         <<endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }

      // Test to make sure downLevel and upLevel part are not same part
      if ( downLevelPart==upLevelPart ) {
        // part does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: downLevelPart and upLevelPart are the same part."      <<endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()     <<endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()   <<endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<endl
          <<"   upLevelPart: " <<upLevelPart.c_str()                         <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // If bom between downLevel and upLevel part does not exist, then add it to model
      if ( !eso2Prob.alternatePartExists(upLevelPart,downLevelPart,plantLoc ) ) {
        //bool partExists = eso2Prob.partExists(upLevelPart,plantLoc);
        eso2Prob.addAlternatePart(upLevelPart,downLevelPart,plantLoc);
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, upLevelPart,plantLoc);
      }
      
      eso2Prob.setAlternatePartProdRate(upLevelPart,downLevelPart,plantLoc,period,prodRate);
      eso2Prob.setAlternatePartCost(upLevelPart,downLevelPart,plantLoc,period,cost);
      eso2Prob.setAlternatePartUsageTime(upLevelPart,downLevelPart,plantLoc,period,usageTime);
      
    } // end loop reading alternatePart file record
  } // end of block reading alternatePart file


   
  // Read part interplant override File
  {
    std::string partInterplantOverrideDataFileName = inputDirectory + "/partInterplantOverrideData.csv";
    ESO2partInterplantOverrideData partInterplantOverrideDataFile(partInterplantOverrideDataFileName);
    ESO2partInterplantOverrideDataIterator partInterplantOverrideFileIter(partInterplantOverrideDataFile);
    
    // loop once for each record in partInterplant file
    for ( ; partInterplantOverrideFileIter()!=NULL; ) {
      std::string part = partInterplantOverrideFileIter.part();
      std::string srcLoc = partInterplantOverrideFileIter.srcLoc();
      std::string destLoc = partInterplantOverrideFileIter.destLoc();
      int period = partInterplantOverrideFileIter.periodAsInt();
      float moveCost = partInterplantOverrideFileIter.moveCostAsFloat();
      float moveTime = partInterplantOverrideFileIter.moveTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   partInterplantOverride filename: " <<partInterplantOverrideDataFile.filename().c_str()   <<endl
          <<"   partInterplantOverride file line number: " <<partInterplantOverrideFileIter.recNum() <<endl
          <<"   part: " <<part.c_str()                                       <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
          <<"   destLoc: " <<destLoc.c_str()                                 <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // Test to make sure part exists
      if ( !eso2Prob.partExists(part,srcLoc) ) {
        // part does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: part at srcLoc does not exist"                         <<endl
          <<"   partInterplantOverride filename: " <<partInterplantOverrideDataFile.filename().c_str()   <<endl
          <<"   partInterplantOverride file line number: " <<partInterplantOverrideFileIter.recNum() <<endl
          <<"   part: " <<part.c_str()                                       <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      
      // If link between srcLoc and destLoc for part does not exist, then add it to model
      if ( !eso2Prob.partInterplantExists(part,srcLoc,destLoc ) ) {
        // Get default move cost and time between srcLoc and destLoc
        float defaultMoveCost = 1000000.f;
        float defaultMoveTime = 0.0f;
        if ( partInterplantFile.keyExists(srcLoc,destLoc) ) {
          defaultMoveCost = partInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
          defaultMoveTime = partInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
        }
        else {
          // Default part interplant move time and cost does not exist
          cout 
            <<"-------------------------------------------------------"        <<endl
            <<"Warning: default part interplant move time and cost does not exist in partInterplantMoveDefaults file" <<endl
            <<"   partInterplant filename: " <<partInterplantFile.filename().c_str()   <<endl
            <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
            <<"   destLoc: " <<destLoc.c_str()                                 <<endl
            <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<endl
            <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<endl
            <<"-------------------------------------------------------"        <<endl;
        }
        eso2Prob.addPartInterplant(part,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
        
        
        //bool partExists = eso2Prob.partExists(part,destLoc);
        
        //std::map<std::string,StdStringVec>> singleSrcToDest;
        //singleSrcToDest[srcLoc].push_back(destLoc);
        //eso2Prob.addPartInterplant(part,srcLoc,destLoc,100000.0,0.0);
        
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,destLoc);
      }
     
      eso2Prob.setPartInterplantMoveCost(part,srcLoc,destLoc,period,moveCost);
      eso2Prob.setPartInterplantMoveTime(part,srcLoc,destLoc,period,moveTime);

    } // end loop reading partInterplant file record
  } // end of block reading partInterplant file
   
  // Read partDemand File
  {
    std::string partDemandFileName = inputDirectory + "/partDemandData.csv";
    ESO2partDemandData partDemandFile(partDemandFileName);
    ESO2partDemandDataIterator partDemandFileIter(partDemandFile);
    
    // loop once for each record in partDemand file
    for ( ; partDemandFileIter()!=NULL; ) {

      std::string part = partDemandFileIter.part();
      std::string custLoc = partDemandFileIter.custLoc();
      std::string plantLoc = partDemandFileIter.plantLoc();
      int period = partDemandFileIter.periodAsInt();
      float demandVol = partDemandFileIter.demandVolAsFloat();
      float wac = partDemandFileIter.wacAsFloat();
      
      // Test to make sure period is in range
      if ( period<0 || period>=nPeriods ) {
        // Period is out of range. Write message
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: period out of allowed range"                           <<endl
          <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<endl
          <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<endl
          <<"   part: " <<part.c_str()                                       <<endl
          <<"   custLoc: " <<custLoc.c_str()                                 <<endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
          <<"   period: " <<period                                           <<endl
          <<"   valid range: 0<=period<" <<nPeriods                          <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // Test to make sure mtm exists
      if ( !eso2Prob.partExists(part,plantLoc) ) {
        // part does not exist so record is invalid
        cout 
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: part at plantLoc does not exist"                       <<endl
          <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<endl
          <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<endl
          <<"   part: " <<part.c_str()                                       <<endl
          <<"   srcLoc: " <<plantLoc.c_str()                                 <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
        continue;
      }
      
      // If bom between downLevel and upLevel part does not exist, then add it to model
      if ( !eso2Prob.partDemandExists(part,custLoc,plantLoc ) ) {
        eso2Prob.addPartDemand(part,custLoc,plantLoc);
      }
     
      eso2Prob.setPartDemandDemandVol(part,custLoc,plantLoc,period,demandVol);
      eso2Prob.setPartDemandWac(part,custLoc,plantLoc,period,wac);

    } // end loop reading partDemand file record
  } // end of block reading partDemand file

} // end function createModel
a82 3
    //std::vector<std::string> plantLocs;
    //eso2Prob.getMtms(mtms,plantLocs);
    
d328 1
a328 1
        //  cout <<"mt==mf" <<endl;
d331 1
a331 1
    cout <<" ";
d334 1
a334 1
  cout <<"eso2 Build date: " <<__DATE__ <<endl;
d355 6
a360 6
          cerr 
            <<"-------------------------------------------------------"  <<endl
            <<"Wrong number of parmeters specified"                      <<endl
            <<"  Number parameters specified: " <<args.size()-1          <<endl
            <<"  Expected number of parameters: 1"                       <<endl
            <<"-------------------------------------------------------"  <<endl;
d369 10
a378 10
        cerr 
          <<"-------------------------------------------------------"  <<endl
          <<argv[0] <<" dataDirectory "                                <<endl
          <<"  where:"                                                 <<endl
          <<"    dataDirectory:"                                       <<endl
          <<"      Directory where input files are located and"        <<endl
          <<"      output files are written."                          <<endl
          <<"  example usage:"                                         <<endl
          <<"    " <<argv[0] <<" example1"                             <<endl
          <<"-------------------------------------------------------"  <<endl;
d417 3
d438 1
a438 1
      cout 
d441 1
a441 1
        <<endl;
d447 1
a447 1
      cout <<"Writing results." <<endl;
d471 1
d494 1
a494 1
  cout <<"eso2 application is finished." <<endl;
@


1.25
log
@File changes to allow all parts and mtms defined at a srcLoc to have interplant move operations added.
@
text
@d37 5
d43 2
d97 2
d157 1
a157 1
  std::map<std::string,StdStringVec> partSrcToDests;
d215 3
a217 3
      
      partSrcToDests[srcLoc].push_back(destLoc);     
      
d464 1
a464 1
        
d467 1
d531 1
a531 1
        bool partExists = eso2Prob.partExists(part,srcLoc);
d534 3
a536 3
        // if part is a new part, then add all of its interplant moves
        if ( !partExists )
          addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,srcLoc);
d613 1
a613 1
        bool partExists = eso2Prob.partExists(upLevelPart,plantLoc);
d615 2
a616 2
        if ( !partExists )
          addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, upLevelPart,plantLoc);
d679 30
a708 9

        bool partExists = eso2Prob.partExists(part,destLoc);
       
        std::map<std::string,StdStringVec>> singleSrcToDest;
        singleSrcToDest[srcLoc].push_back(destLoc);
        addAllPartInterplants(eso2Prob,singleSrcToDest,partInterplantFile,part,srcLoc);

        if ( !partExists )
          addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,destLoc);
d831 1
a831 1
        mtmAcquireCost += acqQtyRnd(acquireQty[t])*wfmv[t];
d860 1
a860 1
        featureAcquireCost += acqQtyRnd(acquireQty[t])*wfmv[t];
d888 1
a888 1
          loosePartAcquireCost += acqQtyRnd(acquireQty[t])*wfmv[t];
d983 1
d995 2
d1008 1
a1008 1
      "%f,%f,%f,%f,%f,%f,%f,%f,%f,%f\n",
d1010 1
@


1.24
log
@Added partInterplantMoveDefault input data file
@
text
@d6 3
d21 1
a21 1
#include "partInterplantMoveDefaultsData.h"
d23 1
d27 113
d145 5
d195 31
d262 1
d273 1
a273 1
  // Read mtmInterplant File
d275 3
a277 3
    std::string mtmInterplantFileName = inputDirectory + "/mtmInterplantData.csv";
    ESO2mtmInterplantData mtmInterplantFile(mtmInterplantFileName);
    ESO2mtmInterplantDataIterator mtmInterplantFileIter(mtmInterplantFile);
d280 7
a286 7
    for ( ; mtmInterplantFileIter()!=NULL; ) {
      std::string mtm = mtmInterplantFileIter.mtm();
      std::string srcLoc = mtmInterplantFileIter.srcLoc();
      std::string destLoc = mtmInterplantFileIter.destLoc();
      int period = mtmInterplantFileIter.periodAsInt();
      float moveCost = mtmInterplantFileIter.moveCostAsFloat();
      float moveTime = mtmInterplantFileIter.moveTimeAsFloat();
d294 2
a295 2
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum() <<endl
d312 2
a313 2
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum() <<endl
d329 2
a330 2
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()   <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum() <<endl
d343 21
a363 1
        eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc);
d455 3
d521 1
d523 4
d603 1
d605 2
d618 1
a618 1
  // Read part interplant File
d620 3
a622 6
    std::string partInterplantFileName = inputDirectory + "/partInterplantData.csv";
    ESO2partInterplantData partInterplantFile(partInterplantFileName);
    ESO2partInterplantDataIterator partInterplantFileIter(partInterplantFile);

    std::string partInterplantMoveDefaultsFileName = inputDirectory + "/partInterplantMoveDefaultsData.csv";
    ESO2partInterplantMoveDefaultsData partInterplantMoveDefaultsFile(partInterplantMoveDefaultsFileName);
d625 7
a631 7
    for ( ; partInterplantFileIter()!=NULL; ) {
      std::string part = partInterplantFileIter.part();
      std::string srcLoc = partInterplantFileIter.srcLoc();
      std::string destLoc = partInterplantFileIter.destLoc();
      int period = partInterplantFileIter.periodAsInt();
      float moveCost = partInterplantFileIter.moveCostAsFloat();
      float moveTime = partInterplantFileIter.moveTimeAsFloat();
d639 2
a640 2
          <<"   partInterplant filename: " <<partInterplantFile.filename().c_str()   <<endl
          <<"   partInterplant file line number: " <<partInterplantFileIter.recNum() <<endl
d651 1
a651 1
      // Test to make sure mtm exists
d657 2
a658 2
          <<"   partInterplant filename: " <<partInterplantFile.filename().c_str()   <<endl
          <<"   partInterplant file line number: " <<partInterplantFileIter.recNum() <<endl
d666 2
a667 1
      // If bom between downLevel and upLevel part does not exist, then add it to model
d670 8
a677 20
        // Get default move cost and time between srcLoc and destLoc
        float defaultMoveCost = 1000000.f;
        float defaultMoveTime = 0.0f;
        if ( partInterplantMoveDefaultsFile.keyExists(srcLoc,destLoc) ) {
          defaultMoveCost = partInterplantMoveDefaultsFile.defaultMoveCostAsFloat(srcLoc,destLoc);
          defaultMoveTime = partInterplantMoveDefaultsFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
        }
        else {
          // Default part interplant move time and cost does not exist
          cout 
            <<"-------------------------------------------------------"        <<endl
            <<"Warning: default part interplant move time and cost does not exist in partInterplantMoveDefaults file" <<endl
            <<"   partInterplantMoveDefaults filename: " <<partInterplantMoveDefaultsFile.filename().c_str()   <<endl
            <<"   srcLoc: " <<srcLoc.c_str()                                   <<endl
            <<"   destLoc: " <<destLoc.c_str()                                 <<endl
            <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<endl
            <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<endl
            <<"-------------------------------------------------------"        <<endl;
        }
        eso2Prob.addPartInterplant(part,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
d800 3
a802 6
        mtmAcquireCost += ceil(acquireQty[t])*wfmv[t];
        mtmDemanCost += ceil(acquireQty[t])*demanCost[t];
        mtmInterplantCost += ceil(acquireQty[t])*moveCost[t];
        //mtmAcquireCost += acquireQty[t]*wfmv[t];
        //mtmDemanCost += acquireQty[t]*demanCost[t];
        //mtmInterplantCost += acquireQty[t]*moveCost[t];
d829 1
a829 1
        featureAcquireCost += ceil(acquireQty[t])*wfmv[t];
d857 1
a857 1
        loosePartAcquireCost += ceil(acquireQty[t])*wfmv[t];
d994 35
a1072 2
          <<"    " <<argv[0] <<" 03Feb19jonBuckley"                    <<endl
          <<"    " <<argv[0] <<" totalCostOfSupplyA"                   <<endl
@


1.23
log
@Modifications to add mtmPriority, featurePriority, and loosePartPriority
@
text
@d9 1
d18 1
d438 3
d486 21
a506 1
        eso2Prob.addPartInterplant(part,srcLoc,destLoc);
d586 2
a587 1
      FILE * partInterplantFilePtr )
d591 9
d604 1
a604 1
    heading="\"wfmvScaleFactor\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"period\",\"acquireQty\""; 
d620 4
a623 1
      //std::vector<float> supply = eso2Prob.getMtmSupply(mtms[m],plantLocs[m]);
d627 8
a634 2
          "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
          wfmvScaleFactor,mtms[m].c_str(),srcLocs[m].c_str(),destLocs[m].c_str(),t,acquireQty[t]);
d655 1
d661 1
d683 1
d689 1
a710 1
      
d713 1
d719 1
d741 1
d746 1
d767 1
d773 1
d778 41
d906 3
d949 2
a950 1
        partInterplantFilePtr );
@


1.22
log
@Updated to set aquireCost of features and looseParts using scale factors
@
text
@d36 34
@


1.21
log
@fixed up output file heading
@
text
@d351 1
a351 1
      // Test to make sure mtm exists
d365 17
d742 2
a743 2
          <<"    " <<argv[0] <<" example2"                             <<endl
          <<"    " <<argv[0] <<" 02Sep25"                              <<endl
@


1.20
log
@Added loosePart data file
@
text
@d573 1
a573 1
    heading="\"wfmvScaleFactor\",\"loosePart\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
@


1.19
log
@Added loop to do multiple solves each with different wfmvScaleFactor
@
text
@d13 1
d104 5
a108 5
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()                 <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum()               <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                                         <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                               <<endl                      <<endl
          <<"   destLoc: " <<destLoc.c_str()                               <<endl
d120 1
a120 1
          <<"-------------------------------------------------------"        <<endl
d122 4
a125 4
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()                 <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum()               <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                                         <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                               <<endl                      <<endl
d127 3
a129 3
          <<"   period: " <<period                                           <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
d137 6
a142 6
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: srcLoc and destLoc are same location"                        <<endl
          <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()                 <<endl
          <<"   mtmInterplant file line number: " <<mtmInterplantFileIter.recNum()               <<endl
          <<"   mtmInterplant: " <<mtm.c_str()                                         <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                               <<endl                      <<endl
d144 3
a146 3
          <<"   period: " <<period                                           <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
d208 44
d283 1
a283 1
          <<"   srcLoc: " <<srcLoc.c_str()                               <<endl
d295 3
a297 3
          <<"-------------------------------------------------------"        <<endl
          <<"Warning: mtm at srcLoc does not exist"                        <<endl
          <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str() <<endl
d299 4
a302 4
          <<"   mtm: " <<mtm.c_str()                                         <<endl
          <<"   srcLoc: " <<srcLoc.c_str()                               <<endl
          <<"   record will be ignored. "                                    <<endl
          <<"-------------------------------------------------------"        <<endl;
d507 1
d568 26
d749 3
d798 1
@


1.18
log
@modifications to accomodate 2/18 file format changes
@
text
@d456 150
d668 25
d694 10
a703 1
    //---------------------------------------------------------
d705 5
a709 5
    eso2Prob.setWfmvScaleFactor(1.0f);
    float wfmvScaleFactor = eso2Prob.getWfmvScaleFactor();
    // Solve
    {
      cout <<"Solving." <<endl;
d711 4
a714 6
    }
    
    //---------------------------------------------------------
    // Write Results
    //---------------------------------------------------------
    {
d716 10
d727 1
a727 149
      // Open mtmAcquirePlan file and write header.
      {
        std::string mtmAcquirePlanFileName = outputDirectory+"/mtmAcquirePlanO.csv";
        FILE * mtmAcquirePlanFilePtr = fopen(mtmAcquirePlanFileName.c_str(),"w");
        std::string heading;
        heading="\"wfmvScaleFactor\",\"mtm\",\"srcLoc\",\"acquireLoc\",\"period\",\"acquireQty\""; 
        fprintf(mtmAcquirePlanFilePtr,"%s\n",heading.c_str());
        
        std::vector<std::string> mtms;
        //std::vector<std::string> plantLocs;
        //eso2Prob.getMtms(mtms,plantLocs);

        std::vector<std::string> srcLocs;
        std::vector<std::string> destLocs;
        eso2Prob.getMtmDemanLocs(mtms,srcLocs,destLocs);
        
        // loop once for each mtm
        int m;
        for ( m=0; m<mtms.size(); m++ ) {
          
          std::vector<float> acquireQty = eso2Prob.getMtmAcquireQty(mtms[m],srcLocs[m],destLocs[m]);
          //std::vector<float> supply = eso2Prob.getMtmSupply(mtms[m],plantLocs[m]);
          assert( acquireQty.size() == nPeriods );
          for ( int t=0; t<acquireQty.size(); t++ ) {
            fprintf(mtmAcquirePlanFilePtr,
                "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,mtms[m].c_str(),srcLocs[m].c_str(),destLocs[m].c_str(),t,acquireQty[t]);
          } // finished t loop
        } // finished m loop
        fclose(mtmAcquirePlanFilePtr);
      } // finished writing mtmAcquirePlan file
            
      // Open featureAcquirePlan file and write header.
      {
        std::string featureAcquirePlanFileName = outputDirectory+"/featureAcquirePlanO.csv";
        FILE * featureAcquirePlanFilePtr = fopen(featureAcquirePlanFileName.c_str(),"w");
        std::string heading;
        heading="\"wfmvScaleFactor\",\"feature\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
        fprintf(featureAcquirePlanFilePtr,"%s\n",heading.c_str());
        
        std::vector<std::string> features;
        std::vector<std::string> plantLocs;
        eso2Prob.getFeatures(features,plantLocs);
        
        // loop once for each feature
        int f;
        for ( f=0; f<features.size(); f++ ) {
          
          std::vector<float> acquireQty = eso2Prob.getFeatureAcquireQty(features[f],plantLocs[f]);
          std::vector<float> supply = eso2Prob.getFeatureSupply(features[f],plantLocs[f]);
          assert( acquireQty.size() == nPeriods );
          for ( int t=0; t<acquireQty.size(); t++ ) {
            fprintf(featureAcquirePlanFilePtr,
                "%f,\"%s\",\"%s\",%d,%f,%f\n",
                wfmvScaleFactor,features[f].c_str(),plantLocs[f].c_str(),t,supply[t],acquireQty[t]);
          } // finished t loop
        } // finished f loop
        fclose(featureAcquirePlanFilePtr);
      } // finished writing featureAcquirePlan file

      // Open partShip file and write header.
      {
        std::string partShipFileName = outputDirectory+"/partShipO.csv";
        FILE * partShipFilePtr = fopen(partShipFileName.c_str(),"w");
        std::string heading;
        heading="\"wfmvScaleFactor\",\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\""; 
        fprintf(partShipFilePtr,"%s\n",heading.c_str());
        
        std::vector<std::string> parts;
        std::vector<std::string> custLocs;
        std::vector<std::string> plantLocs;
        eso2Prob.getPartDemands(parts,custLocs,plantLocs);
        
        // loop once for each shipped part
        int p;
        for ( p=0; p<parts.size(); p++ ) {
          
          std::vector<float> demandVol = eso2Prob.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
          assert( demandVol.size() == nPeriods );
          
          std::vector<float> shipVol = eso2Prob.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
          assert( shipVol.size() == nPeriods );
          
          for ( int t=0; t<shipVol.size(); t++ ) {
            fprintf(partShipFilePtr,
                "%f,\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
                wfmvScaleFactor,parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t,demandVol[t],shipVol[t]);
          } // finished t loop
        } // finished p loop
        fclose(partShipFilePtr);
      } // finished writing partShip file
                  
      // Open alternatePart file and write header.
      {
        std::string alternatePartFileName = outputDirectory+"/alternatePartO.csv";
        FILE * alternatePartFilePtr = fopen(alternatePartFileName.c_str(),"w");
        std::string heading;
        heading="\"wfmvScaleFactor\",\"upLevelPart\",\"downLevelPart\",\"plantLoc\",\"period\",\"ecVol\""; 
        fprintf(alternatePartFilePtr,"%s\n",heading.c_str());
        
        std::vector<std::string> upLevelParts;
        std::vector<std::string> downLevelParts;
        std::vector<std::string> plantLocs;
        eso2Prob.getAlternateParts(upLevelParts,downLevelParts,plantLocs);
        
        // loop once for each alternatePart
        int e;
        for ( e=0; e<upLevelParts.size(); e++ ) {
          
          std::vector<float> ecVol = eso2Prob.getAlternatePartEcVol(upLevelParts[e],downLevelParts[e],plantLocs[e]);
          assert( ecVol.size() == nPeriods );
          for ( int t=0; t<ecVol.size(); t++ ) {
            fprintf(alternatePartFilePtr,
                "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,upLevelParts[e].c_str(),downLevelParts[e].c_str(),plantLocs[e].c_str(),t,ecVol[t]);
          } // finished t loop
        } // finished e loop
        fclose(alternatePartFilePtr);
      } // finished writing alternatePart file
                 
      // Open partInterplant output file and write header.
      {
        std::string partInterplantFileName = outputDirectory+"/partInterplantO.csv";
        FILE * partInterplantFilePtr = fopen(partInterplantFileName.c_str(),"w");
        std::string heading;
        heading="\"wfmvScaleFactor\",\"part\",\"srcLoc\",\"destLoc\",\"period\",\"moveVol\""; 
        fprintf(partInterplantFilePtr,"%s\n",heading.c_str());
        
        std::vector<std::string> parts;
        std::vector<std::string> srcLocs;
        std::vector<std::string> destLocs;
        eso2Prob.getPartInterplants(parts,srcLocs,destLocs);
        
        // loop once for each partInterplant part
        int i;
        for ( i=0; i<parts.size(); i++ ) {
          
          std::vector<float> moveVol = eso2Prob.getPartInterplantMoveVol(parts[i],srcLocs[i],destLocs[i]);
          assert( moveVol.size() == nPeriods );
          for ( int t=0; t<moveVol.size(); t++ ) {
            fprintf(partInterplantFilePtr,
                "%f,\"%s\",\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,parts[i].c_str(),srcLocs[i].c_str(),destLocs[i].c_str(),t,moveVol[t]);
          } // finished t loop
        } // finished i loop
        fclose(partInterplantFilePtr);
      } // finished writing partInterplant file

    } // finished writing results
d730 8
@


1.17
log
@Added writing for mtm and feature supplyVol to output files
@
text
@d14 3
a16 2
#include "etnCspData.h"
#include "interplantData.h"
d81 84
d213 2
d220 1
a220 1
      std::string plantLoc = mtmDemanBomFileIter.plantLoc();
d222 6
a227 1
      float prodRate = mtmDemanBomFileIter.prodRateAsFloat();
d238 1
a238 1
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
d247 1
a247 1
      if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
d251 1
a251 1
          <<"Warning: mtm at plantLoc does not exist"                        <<endl
d255 1
a255 1
          <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
d262 2
a263 2
      if ( !eso2Prob.demanBomExists(mtm,part,plantLoc ) ) {
        eso2Prob.addDemanBom(mtm,part,plantLoc);
d266 1
a266 1
      eso2Prob.setDemanBomProdRate(mtm,part,plantLoc,period,prodRate);
d272 1
a272 1
  // Read etn csp File
d274 13
a286 13
    std::string etnCspFileName = inputDirectory + "/etnCspData.csv";
    ESO2etnCspData etnCspFile(etnCspFileName);
    ESO2etnCspDataIterator etnCspFileIter(etnCspFile);
    
    // loop once for each record in etnCsp file
    for ( ; etnCspFileIter()!=NULL; ) {
      std::string upLevelPart = etnCspFileIter.upLevelPart();
      std::string downLevelPart = etnCspFileIter.downLevelPart();
      std::string plantLoc = etnCspFileIter.plantLoc();
      int period = etnCspFileIter.periodAsInt();
      float prodRate = etnCspFileIter.prodRateAsFloat();
      float cost = etnCspFileIter.costAsFloat();
      float usageTime = etnCspFileIter.usageTimeAsFloat();
d294 2
a295 2
          <<"   etnCsp filename: " <<etnCspFile.filename().c_str()           <<endl
          <<"   etnCsp file line number: " <<etnCspFileIter.recNum()         <<endl
d312 2
a313 2
          <<"   etnCsp filename: " <<etnCspFile.filename().c_str()           <<endl
          <<"   etnCsp file line number: " <<etnCspFileIter.recNum()         <<endl
d322 2
a323 2
      if ( !eso2Prob.etnCspBomExists(upLevelPart,downLevelPart,plantLoc ) ) {
        eso2Prob.addEtnCspBom(upLevelPart,downLevelPart,plantLoc);
d326 3
a328 3
      eso2Prob.setEtnCspBomProdRate(upLevelPart,downLevelPart,plantLoc,period,prodRate);
      eso2Prob.setEtnCspBomCost(upLevelPart,downLevelPart,plantLoc,period,cost);
      eso2Prob.setEtnCspBomUsageTime(upLevelPart,downLevelPart,plantLoc,period,usageTime);
d330 2
a331 2
    } // end loop reading etnCsp file record
  } // end of block reading etnCsp file
d335 1
a335 1
  // Read interplant File
d337 12
a348 12
    std::string interplantFileName = inputDirectory + "/interplantData.csv";
    ESO2interplantData interplantFile(interplantFileName);
    ESO2interplantDataIterator interplantFileIter(interplantFile);
    
    // loop once for each record in interplant file
    for ( ; interplantFileIter()!=NULL; ) {
      std::string part = interplantFileIter.part();
      std::string srcLoc = interplantFileIter.srcLoc();
      std::string destLoc = interplantFileIter.destLoc();
      int period = interplantFileIter.periodAsInt();
      float moveCost = interplantFileIter.moveCostAsFloat();
      float moveTime = interplantFileIter.moveTimeAsFloat();
d356 2
a357 2
          <<"   interplant filename: " <<interplantFile.filename().c_str()   <<endl
          <<"   interplant file line number: " <<interplantFileIter.recNum() <<endl
d374 2
a375 2
          <<"   interplant filename: " <<interplantFile.filename().c_str()   <<endl
          <<"   interplant file line number: " <<interplantFileIter.recNum() <<endl
d384 2
a385 2
      if ( !eso2Prob.interplantExists(part,srcLoc,destLoc ) ) {
        eso2Prob.addInterplant(part,srcLoc,destLoc);
d388 2
a389 2
      eso2Prob.setInterplantMoveCost(part,srcLoc,destLoc,period,moveCost);
      eso2Prob.setInterplantMoveTime(part,srcLoc,destLoc,period,moveTime);
d391 2
a392 2
    } // end loop reading interplant file record
  } // end of block reading interplant file
d540 1
a540 1
        heading="\"wfmvScaleFactor\",\"mtm\",\"plantLoc\",\"period\",\"supply\",\"acquireQty\""; 
d544 6
a549 2
        std::vector<std::string> plantLocs;
        eso2Prob.getMtms(mtms,plantLocs);
d555 2
a556 2
          std::vector<float> acquireQty = eso2Prob.getMtmAcquireQty(mtms[m],plantLocs[m]);
          std::vector<float> supply = eso2Prob.getMtmSupply(mtms[m],plantLocs[m]);
d560 2
a561 2
                "%f,\"%s\",\"%s\",%d,%f,%f\n",
                wfmvScaleFactor,mtms[m].c_str(),plantLocs[m].c_str(),t,supply[t],acquireQty[t]);
d627 1
a627 1
      // Open etnCsp file and write header.
d629 2
a630 2
        std::string etnCspFileName = outputDirectory+"/etnCspO.csv";
        FILE * etnCspFilePtr = fopen(etnCspFileName.c_str(),"w");
d633 1
a633 1
        fprintf(etnCspFilePtr,"%s\n",heading.c_str());
d638 1
a638 1
        eso2Prob.getEtnCspBoms(upLevelParts,downLevelParts,plantLocs);
d640 1
a640 1
        // loop once for each etnCsp
d644 1
a644 1
          std::vector<float> ecVol = eso2Prob.getEtnCspBomEcVol(upLevelParts[e],downLevelParts[e],plantLocs[e]);
d647 1
a647 1
            fprintf(etnCspFilePtr,
d652 2
a653 2
        fclose(etnCspFilePtr);
      } // finished writing etnCsp file
d655 1
a655 1
      // Open interplant output file and write header.
d657 2
a658 2
        std::string interplantFileName = outputDirectory+"/interplantO.csv";
        FILE * interplantFilePtr = fopen(interplantFileName.c_str(),"w");
d661 1
a661 1
        fprintf(interplantFilePtr,"%s\n",heading.c_str());
d666 1
a666 1
        eso2Prob.getInterplants(parts,srcLocs,destLocs);
d668 1
a668 1
        // loop once for each interplant part
d672 1
a672 1
          std::vector<float> moveVol = eso2Prob.getInterplantMoveVol(parts[i],srcLocs[i],destLocs[i]);
d675 1
a675 1
            fprintf(interplantFilePtr,
d680 2
a681 2
        fclose(interplantFilePtr);
      } // finished writing interplant file
@


1.16
log
@Added regulator capacity to enforce demand perishability
@
text
@d448 1
a448 1
        heading="\"wfmvScaleFactor\",\"mtm\",\"plantLoc\",\"period\",\"acquireQty\""; 
d460 1
d464 2
a465 2
                "%f,\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,mtms[m].c_str(),plantLocs[m].c_str(),t,acquireQty[t]);
d476 1
a476 1
        heading="\"wfmvScaleFactor\",\"feature\",\"plantLoc\",\"period\",\"acquireQty\""; 
d488 1
d492 2
a493 2
                "%f,\"%s\",\"%s\",%d,%f\n",
                wfmvScaleFactor,features[f].c_str(),plantLocs[f].c_str(),t,acquireQty[t]);
@


1.15
log
@added methods for set/getting wfmvScaleFactor
@
text
@d429 1
a429 1
    eso2Prob.setWfmvScaleFactor(0.8f);
@


1.14
log
@updated to write shipVol results
@
text
@d429 2
a430 1
    float wfmvScaleFactor = 1.0f;
d556 28
a583 1

a587 42
#if 0
    //---------------------------------------------------------
    // Write Results
    //---------------------------------------------------------
    {
      cout <<"Writing results." <<endl;

      // Open resrcConsVol file and write header.
      std::string resrcConsVolFileName = outputDirectory+"/resrcConsVolO.csv";
      FILE * resrcConsVolFilePtr = fopen(resrcConsVolFileName.c_str(),"w");
      std::string heading;
      heading="\"role\",\"band\",\"prob\",\"period\",\"ibmConsVol\",\"contrConsVol\""; 
      fprintf(resrcConsVolFilePtr,"%s\n",heading.c_str());
      
      // Open projExecVol file and write header.
      std::string projExecVolFileName = outputDirectory+"/projExecVolO.csv";
      FILE * projExecVolFilePtr = fopen(projExecVolFileName.c_str(),"w");
      heading="\"proj\",\"prob\",\"execVol\""; 
      fprintf(projExecVolFilePtr,"%s\n",heading.c_str());  
      
      std::vector<float> probGrid = eso2Prob.getProbabilityGrid();

      // Write projExecVol file
      bool shortages=false;
      {
        std::vector<std::string> projects;
        eso2Prob.getProjects(projects);
        
        // loop once for each point on probability grid
        int g;
        for ( g=0; g<probGrid.size(); g++ ) {
          int p;
          for (p=0;p<projects.size();p++) {
            std::vector<float> execVol = eso2Prob.getProjectExecVol(projects[p]);
            fprintf(projExecVolFilePtr,
              "\"%s\",%f,%f\n",
              projects[p].c_str(),probGrid[g],execVol[g]);
            if ( execVol[g] < 1.0 && (g+1)==probGrid.size() ) shortages=true;
          } // finished p loop
        } // finished g loop
        fclose(projExecVolFilePtr);
      } // finished writing projExecVol file
a588 24
      
      // Write resrcConsVol file
      {
        std::vector<std::string> roles;
        std::vector<int> bands;
        eso2Prob.getResources(roles,bands);
        
        // loop once for each point on probability grid
        int g;
        for ( g=0; g<probGrid.size(); g++ ) {
          int r;
          for (r=0;r<roles.size();r++) {
            std::vector< std::vector<float> >ibmConsVol = eso2Prob.getResourceIbmConsVol(roles[r],bands[r]);
            std::vector< std::vector<float> >contrConsVol = eso2Prob.getResourceContrConsVol(roles[r],bands[r]);
            int t;
            for (t=0;t<nPeriods;t++) {
              fprintf(resrcConsVolFilePtr,
                "\"%s\",%d,%f,%d,%f,%f\n",
                roles[r].c_str(),bands[r],probGrid[g],t,ibmConsVol[g][t],contrConsVol[g][t]);
            } // finished t loop
          } // finished r loop
        } // finished g loop
        fclose(resrcConsVolFilePtr);
      } // finished writing resrcConsVol file
a606 2
    }  // Finished writing results
#endif
@


1.13
log
@code to write etnCsp output file has been added
@
text
@d496 31
a526 1
      // TO DO: Write partDemand ship vol file
@


1.12
log
@added code to write mtmAcquirePlan file
@
text
@d468 59
@


1.11
log
@Added solve
@
text
@d429 1
d435 35
@


1.10
log
@updated to read interplant and partDemand files
@
text
@a428 1
#if 0
a431 5
      std::vector<float> probGrid(3);
      probGrid[0]=1.0f;
      probGrid[1]=0.5f;
      probGrid[2]=0.0f;
      eso2Prob.setProbabilityGrid(probGrid);
a433 1
#endif
@


1.9
log
@modified to have new function createModel where file reading, add*, and set* actions are done
@
text
@d15 2
d240 122
@


1.8
log
@setting etnCsp usageTime attribute
@
text
@d17 222
d299 2
a300 214
    // Read input files
    {
      cout <<"Reading input files" <<endl;
      
      

      // Read Global Attributes
      std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
      ESO2globalAttrData globalAttrFile(globalAttrFileName);
      {      
        std::string title=globalAttrFile.fieldAsString("title","attrValue");
        eso2Prob.setTitle(title);
        
        nPeriods=globalAttrFile.fieldAsInt("nPeriods","attrValue");
        eso2Prob.setNPeriods(nPeriods);
      }

      // Read MTM File
      {
        std::string mtmFileName = inputDirectory + "/mtmData.csv";
        ESO2mtmData mtmFile(mtmFileName);
        ESO2mtmDataIterator mtmFileIter(mtmFile);
        
        // loop once for each record in mtm file
        for ( ; mtmFileIter()!=NULL; ) {
          std::string mtm = mtmFileIter.mtm();
          std::string plantLoc = mtmFileIter.plantLoc();
          int period = mtmFileIter.periodAsInt();
          float supply = mtmFileIter.supplyAsFloat();
          float wfmv = mtmFileIter.wfmvAsFloat();
          float demanCost = mtmFileIter.demanCostAsFloat();
          float demanTime = mtmFileIter.demanTimeAsFloat();

          // Test to make sure period is in range
          if ( period<0 || period>=nPeriods ) {
            // Period is out of range. Write message
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: period out of allowed range"                           <<endl
                <<"   mtm filename: " <<mtmFile.filename().c_str()                 <<endl
                <<"   mtm file line number: " <<mtmFileIter.recNum()               <<endl
                <<"   mtm: " <<mtm.c_str()                                         <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   period: " <<period                                           <<endl
                <<"   valid range: 0<=period<" <<nPeriods                          <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
            eso2Prob.addMtm(mtm,plantLoc);
          }

          eso2Prob.setMtmSupply(mtm,plantLoc,period,supply);
          eso2Prob.setMtmWfmv(mtm,plantLoc,period,wfmv);
          eso2Prob.setMtmDemanCost(mtm,plantLoc,period,demanCost);
          eso2Prob.setMtmDemanTime(mtm,plantLoc,period,demanTime);
          
        } // end loop reading mtm file record
      } // end of block reading mtm file
        
      // Read Feature File
      {
        std::string featureFileName = inputDirectory + "/featureData.csv";
        ESO2featureData featureFile(featureFileName);
        ESO2featureDataIterator featureFileIter(featureFile);
        
        // loop once for each record in feature file
        for ( ; featureFileIter()!=NULL; ) {
          std::string feature = featureFileIter.feature();
          std::string plantLoc = featureFileIter.plantLoc();
          int period = featureFileIter.periodAsInt();
          float supply = featureFileIter.supplyAsFloat();
          float wfmv = featureFileIter.wfmvAsFloat();

          // Test to make sure period is in range
          if ( period<0 || period>=nPeriods ) {
            // Period is out of range. Write message
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: period out of allowed range"                           <<endl
                <<"   feature filename: " <<featureFile.filename().c_str()         <<endl
                <<"   feature file line number: " <<featureFileIter.recNum()       <<endl
                <<"   feature: " <<feature.c_str()                                 <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   period: " <<period                                           <<endl
                <<"   valid range: 0<=period<" <<nPeriods                          <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          if ( !eso2Prob.featureExists(feature,plantLoc) ) {
            eso2Prob.addFeature(feature,plantLoc);
          }

          eso2Prob.setFeatureSupply(feature,plantLoc,period,supply);
          eso2Prob.setFeatureWfmv(feature,plantLoc,period,wfmv);
          
        } // end loop reading feature file record
      } // end of block reading feature file

              
      // Read Mtm Demanufacturing Bom File
      {
        std::string mtmDemanBomFileName = inputDirectory + "/mtmDemanBomData.csv";
        ESO2mtmDemanBomData mtmDemanBomFile(mtmDemanBomFileName);
        ESO2mtmDemanBomDataIterator mtmDemanBomFileIter(mtmDemanBomFile);
        
        // loop once for each record in mtmDemanBom file
        for ( ; mtmDemanBomFileIter()!=NULL; ) {
          std::string mtm = mtmDemanBomFileIter.mtm();
          std::string part = mtmDemanBomFileIter.part();
          std::string plantLoc = mtmDemanBomFileIter.plantLoc();
          int period = mtmDemanBomFileIter.periodAsInt();
          float prodRate = mtmDemanBomFileIter.prodRateAsFloat();

          // Test to make sure period is in range
          if ( period<0 || period>=nPeriods ) {
            // Period is out of range. Write message
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: period out of allowed range"                           <<endl
                <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str() <<endl
                <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<endl
                <<"   mtm: " <<mtm.c_str()                                         <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   period: " <<period                                           <<endl
                <<"   valid range: 0<=period<" <<nPeriods                          <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          // Test to make sure mtm exists
          if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
            // mtm does not exist so record is invalid
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: mtm at plantLoc does not exist"                        <<endl
                <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str() <<endl
                <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<endl
                <<"   mtm: " <<mtm.c_str()                                         <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          // If bom entry does not exist, then add it to model
          if ( !eso2Prob.demanBomExists(mtm,part,plantLoc ) ) {
            eso2Prob.addDemanBom(mtm,part,plantLoc);
          }

          eso2Prob.setDemanBomProdRate(mtm,part,plantLoc,period,prodRate);
          
        } // end loop reading mtmDemanBom file record
      } // end of block reading mtmDemanBom file

              
      // Read etn csp File
      {
        std::string etnCspFileName = inputDirectory + "/etnCspData.csv";
        ESO2etnCspData etnCspFile(etnCspFileName);
        ESO2etnCspDataIterator etnCspFileIter(etnCspFile);
        
        // loop once for each record in etnCsp file
        for ( ; etnCspFileIter()!=NULL; ) {
          std::string upLevelPart = etnCspFileIter.upLevelPart();
          std::string downLevelPart = etnCspFileIter.downLevelPart();
          std::string plantLoc = etnCspFileIter.plantLoc();
          int period = etnCspFileIter.periodAsInt();
          float prodRate = etnCspFileIter.prodRateAsFloat();
          float cost = etnCspFileIter.costAsFloat();
          float usageTime = etnCspFileIter.usageTimeAsFloat();

          // Test to make sure period is in range
          if ( period<0 || period>=nPeriods ) {
            // Period is out of range. Write message
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: period out of allowed range"                           <<endl
                <<"   etnCsp filename: " <<etnCspFile.filename().c_str()           <<endl
                <<"   etnCsp file line number: " <<etnCspFileIter.recNum()         <<endl
                <<"   upLevelPart: " <<upLevelPart.c_str()                         <<endl
                <<"   downLevelPart: " <<downLevelPart.c_str()                     <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   period: " <<period                                           <<endl
                <<"   valid range: 0<=period<" <<nPeriods                          <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          // Test to make sure mtm exists
          if ( !eso2Prob.partExists(downLevelPart,plantLoc) ) {
            // part does not exist so record is invalid
            cout 
                <<"-------------------------------------------------------"        <<endl
                <<"Warning: downLevelPart at plantLoc does not exist"              <<endl
                <<"   etnCsp filename: " <<etnCspFile.filename().c_str()           <<endl
                <<"   etnCsp file line number: " <<etnCspFileIter.recNum()         <<endl
                <<"   downLevelPart: " <<downLevelPart.c_str()                     <<endl
                <<"   plantLoc: " <<plantLoc.c_str()                               <<endl
                <<"   record will be ignored. "                                    <<endl
                <<"-------------------------------------------------------"        <<endl;
            continue;
          }

          // If bom between downLevel and upLevel part does not exist, then add it to model
          if ( !eso2Prob.etnCspBomExists(upLevelPart,downLevelPart,plantLoc ) ) {
            eso2Prob.addEtnCspBom(upLevelPart,downLevelPart,plantLoc);
          }
a301 8
          eso2Prob.setEtnCspBomProdRate(upLevelPart,downLevelPart,plantLoc,period,prodRate);
          eso2Prob.setEtnCspBomCost(upLevelPart,downLevelPart,plantLoc,period,cost);
          eso2Prob.setEtnCspBomUsageTime(upLevelPart,downLevelPart,plantLoc,period,usageTime);
          
        } // end loop reading etnCsp file record
      } // end of block reading etnCsp file
 
    } // Finished Reading Files
@


1.7
log
@setting more etnCsp attributes. More still to do.
@
text
@d294 1
a294 3
#if 0
          eso2Prob.setEtnCspBomUsageTime(mtm,part,plantLoc,period,usageTime);
#endif
d298 1
a298 113

      
#if 0
      // Read resrc, resrcAttr, and contrSubs Files
      {
        std::string resrcFileName = inputDirectory + "/resrc.csv";
        ILSresrcFile resrcFile(resrcFileName);
        ILSresrcFileIterator resrcFileIter(resrcFile);
        
        std::string resrcAttrFileName = inputDirectory + "/resrcAttr.csv";
        ILSresrcAttrFile resrcAttrFile(resrcAttrFileName);
        
        std::string contrSubsFileName = inputDirectory + "/contrSubs.csv";
        ILScontrSubsFile contrSubsFile(contrSubsFileName);
        
        // loop once for each record
        for ( resrcFileIter(); resrcFileIter()!=NULL; ) {
          std::string role = resrcFileIter.role();
          int band = resrcFileIter.bandAsInt();
          float  ibmCost  = resrcFileIter.ibmCostAsFloat();
          float contrCost = resrcFileIter.contrCostAsFloat();
          
          // Add resource to Model
          eso2Prob.addResource(role,band);
          
          eso2Prob.setResourceIbmCost(role,band,ibmCost);
          eso2Prob.setResourceContrCost(role,band,contrCost);
          
          // Set the supply of ibm resource
          std::vector<float> svVec;
          int t;
          for (t=0; t<nPeriods; t++ ) {
            std::string key = ILSresrcAttrFile::key(role,band,t);
            if ( resrcAttrFile.keyExists(key) ) {
              float svForPeriodT = resrcAttrFile.supplyAsFloat(key);
              svVec.push_back(svForPeriodT);
            }
            else {
              svVec.push_back(0.0f);
            }
          }
          assert(svVec.size()==nPeriods);
          eso2Prob.setResourceIbmSupplyVol(role,band,svVec);

          // set supply of contractor resource
          float contrSubPercent = contrSubsFile.subsPerAsFloat(resrcFileIter.band());
          for (t=0; t<nPeriods; t++ ) {
            svVec[t]=svVec[t]*contrSubPercent;
          }
          eso2Prob.setResourceContrSupplyVol(role,band,svVec);

        }  
      } // Finished reading resrc, resrcAttr, contrSubs files
      
      // Read Project File
      std::string projFileName = inputDirectory + "/proj.csv";
      ILSprojFile projFile(projFileName);
      {
        ILSprojFileIterator projFileIter(projFile);
        
        // loop once for each record
        for ( projFileIter(); projFileIter()!=NULL; ) {
          std::string proj = projFileIter.proj();
          float rateScale = projFileIter.rateScaleAsFloat();
          float revenue = projFileIter.revenueAsFloat();
          float closeProb = projFileIter.closeProbAsFloat();
          
          // Add project to Model
          eso2Prob.addProject(proj);
          
          eso2Prob.setProjectRateScale(proj,rateScale);
          eso2Prob.setProjectRevenue(proj,revenue);
          eso2Prob.setProjectCloseProb(proj,closeProb);
        }  
      }  // Finished with projFileIter  
      
      // Read projResrcLink, projResrcLinkAttr
      {
        std::string projResrcLinkFileName = inputDirectory + "/projResrcLink.csv";
        ILSprojResrcLinkFile projResrcLinkFile(projResrcLinkFileName);
        ILSprojResrcLinkFileIterator projResrcLinkFileIter(projResrcLinkFile);
        
        std::string projResrcLinkAttrFileName = inputDirectory + "/projResrcLinkAttr.csv";
        ILSprojResrcLinkAttrFile projResrcLinkAttrFile(projResrcLinkAttrFileName);
        
        // loop once for each record
        for ( projResrcLinkFileIter(); projResrcLinkFileIter()!=NULL; ) {
          std::string proj = projResrcLinkFileIter.proj();
          std::string role = projResrcLinkFileIter.role();
          int band = projResrcLinkFileIter.bandAsInt();

          // Add link connecting project to consumed resource
          eso2Prob.addProjectResourceLink(proj,role,band);

          // Set the amount of the resource consumed in each period
          int t;
          std::vector<float> consRateVec;
          for (t=0; t<nPeriods; t++ ) consRateVec.push_back(0.0f);
          int projStartPeriod=projFile.startPeriodAsInt(proj);
          for (t=0; t<nPeriods; t++ ) {
            
            // Was the consRate specified in attribute file?
            std::string key = ILSprojResrcLinkAttrFile::key(proj,role,band,t);
            if ( projResrcLinkAttrFile.keyExists(key) ) {
              assert( t+projStartPeriod <nPeriods );
              consRateVec[t+projStartPeriod]=projResrcLinkAttrFile.consRateAsFloat(key);
            }
          }
          eso2Prob.setProjectResourceLinkConsRate(proj,role,band,consRateVec);
        }
      }  // finished reading projResrcLink, projResrcLinkAttr
#endif
      
@


1.6
log
@adding etnCsp structures, not yet setting attributes
@
text
@d292 2
a294 2
          eso2Prob.setEtnCspBomProdRate(mtm,part,plantLoc,period,prodRate);
          eso2Prob.setEtnCspBomCost(mtm,part,plantLoc,period,cost);
@


1.5
log
@Changes to read demanBom file
@
text
@d14 1
a17 2


d236 64
@


1.4
log
@added code to set feature supply and wfmv
@
text
@d13 1
a13 8
#if 0
#include "projFile.h"
#include "resrcFile.h"
#include "resrcAttrFile.h"
#include "projResrcLinkFile.h"
#include "projResrcLinkAttrFile.h"
#include "contrSubsFile.h"
#endif
d181 57
a237 1
      
@


1.3
log
@added code to process feature file
@
text
@d140 1
a140 1
          eso2Prob.setMtmWfmv(mtm,plantLoc,period,supply);
d181 1
a181 1
#if 0
d183 1
a183 2
          eso2Prob.setFeatureWfmv(feature,plantLoc,period,demanCost);
#endif
@


1.2
log
@added setting of demanCost
@
text
@d12 1
d140 1
d142 1
d144 8
a151 2
        } // end loop reading mtm file
      }
d153 35
@


1.1
log
@updated to add eso2Problem class and eso2 main program
@
text
@a118 1
            int recNum = mtmFileIter.recNum();
d139 1
@


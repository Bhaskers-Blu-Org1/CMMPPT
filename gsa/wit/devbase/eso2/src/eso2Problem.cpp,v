head	1.118;
access;
symbols
	abandoningEtnParts:1.74
	beforeEtnParts:1.73
	eso2InitialFileFormats:1.21;
locks; strict;
comment	@// @;


1.118
date	2008.02.21.01.25.49;	author fasano;	state Exp;
branches;
next	1.117;

1.117
date	2008.02.15.01.13.58;	author fasano;	state Exp;
branches;
next	1.116;

1.116
date	2008.01.20.11.06.48;	author fasano;	state Exp;
branches;
next	1.115;

1.115
date	2008.01.19.13.21.02;	author fasano;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.16.14.49.22;	author fasano;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.10.13.46.26;	author fasano;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.31.09.28.49;	author fasano;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.31.02.30.59;	author fasano;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.01.18.13.40;	author fasano;	state Exp;
branches;
next	1.109;

1.109
date	2007.01.10.21.22.54;	author fasano;	state Exp;
branches;
next	1.108;

1.108
date	2007.01.02.15.04.39;	author fasano;	state Exp;
branches;
next	1.107;

1.107
date	2006.12.29.19.12.18;	author fasano;	state Exp;
branches;
next	1.106;

1.106
date	2006.11.04.13.24.05;	author fasano;	state Exp;
branches;
next	1.105;

1.105
date	2006.10.27.02.19.05;	author fasano;	state Exp;
branches;
next	1.104;

1.104
date	2006.08.11.22.58.50;	author fasano;	state Exp;
branches;
next	1.103;

1.103
date	2006.08.09.20.16.33;	author fasano;	state Exp;
branches;
next	1.102;

1.102
date	2006.07.28.21.22.40;	author fasano;	state Exp;
branches;
next	1.101;

1.101
date	2006.06.05.17.29.09;	author fasano;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.27.12.23.21;	author fasano;	state Exp;
branches;
next	1.99;

1.99
date	2006.05.22.16.54.22;	author fasano;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.09.16.09.01;	author fasano;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.23.17.12.59;	author fasano;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.23.15.31.35;	author fasano;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.23.14.19.43;	author fasano;	state Exp;
branches;
next	1.94;

1.94
date	2006.04.23.12.22.36;	author fasano;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.23.02.28.42;	author fasano;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.22.22.11.18;	author fasano;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.22.16.26.41;	author fasano;	state Exp;
branches;
next	1.90;

1.90
date	2006.04.22.13.49.29;	author fasano;	state Exp;
branches;
next	1.89;

1.89
date	2006.04.19.21.10.27;	author fasano;	state Exp;
branches;
next	1.88;

1.88
date	2006.04.14.19.46.56;	author fasano;	state Exp;
branches;
next	1.87;

1.87
date	2006.04.14.19.15.04;	author fasano;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.14.16.56.26;	author fasano;	state Exp;
branches;
next	1.85;

1.85
date	2006.04.12.18.44.39;	author fasano;	state Exp;
branches;
next	1.84;

1.84
date	2006.04.12.13.11.06;	author fasano;	state Exp;
branches;
next	1.83;

1.83
date	2006.04.07.16.57.14;	author fasano;	state Exp;
branches;
next	1.82;

1.82
date	2006.04.07.03.27.54;	author fasano;	state Exp;
branches;
next	1.81;

1.81
date	2006.04.03.13.50.26;	author fasano;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.29.02.16.43;	author fasano;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.17.15.10.03;	author fasano;	state Exp;
branches;
next	1.78;

1.78
date	2005.02.02.14.31.06;	author fasano;	state Exp;
branches;
next	1.77;

1.77
date	2005.01.29.18.27.37;	author fasano;	state Exp;
branches;
next	1.76;

1.76
date	2004.09.21.17.23.50;	author fasano;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.21.14.21.11;	author fasano;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.18.17.36.29;	author fasano;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.08.13.38.45;	author fasano;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.08.02.45.45;	author fasano;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.29.19.16.01;	author fasano;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.24.22.35.20;	author fasano;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.24.22.29.45;	author fasano;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.24.17.22.58;	author fasano;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.16.16.32.32;	author fasano;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.16.15.11.08;	author fasano;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.08.19.00.04;	author fasano;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.08.15.36.45;	author fasano;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.04.12.19.00;	author fasano;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.29.13.23.41;	author fasano;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.29.13.20.50;	author fasano;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.14.18.49.52;	author fasano;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.13.19.46.25;	author fasano;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.12.20.01.35;	author fasano;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.12.13.24.48;	author fasano;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.12.03.05.05;	author fasano;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.12.03.02.56;	author fasano;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.28.09.58.53;	author fasano;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.27.20.42.36;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.27.20.05.41;	author fasano;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.24.20.14.15;	author fasano;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.24.20.11.24;	author fasano;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.22.16.22.30;	author fasano;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.21.20.29.45;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.21.19.35.21;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.09.17.48.38;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.09.15.57.33;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.08.14.09.38;	author fasano;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.08.13.29.30;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.01.22.02.19;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.30.01.32.07;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.21.13.54.25;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.20.15.14.27;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.20.13.16.10;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.18.14.33.47;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.17.14.08.47;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.17.13.06.13;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.17.01.26.47;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.12.01.21.18;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.11.01.19.45;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.11.00.22.33;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.04.22.06.13;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.01.15.36.40;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.30.19.04.23;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.20.23.44.31;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.17.01.28.21;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.09.19.43.30;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.28.01.25.07;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.20.18.57.38;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.20.18.10.40;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.12.13.21.29;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.11.13.18.37;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.10.01.51.00;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.10.00.25.49;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.09.21.36.02;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.09.14.16.01;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.09.02.42.59;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.01.24.31;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.09.01.10.37;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.08.23.39.57;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.08.22.54.59;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.08.03.33.44;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.08.02.12.24;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.08.00.58.34;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.08.00.47.50;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.07.23.41.13;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.07.23.28.02;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.07.20.59.35;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.07.20.39.07;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.07.19.12.20;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.07.17.04.19;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.118
log
@Added testing of allowInventoryAtDemandLocation and removeCycles
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4018)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#pragma warning(disable:4996)
#endif

#include <numeric>
#include <set>

#include <cassert>
#include <iostream>
#include <cfloat>
#include <cstdio>
#include <climits>

#include <wit.h>

#include "CoinFloatEqual.h"
#include "probAppData.h"
#include "partDemandAppData.h"
#include "mtmAppData.h"
#include "mtmDemanBomAppData.h"
#include "featureXrefAppData.h"
#include "featureAppData.h"
#include "loosePartAppData.h"
#include "eso2Problem.h"
#include "eso2.h"
#include "unitTestResultsData.h"
#include "pipSequenceTriple.h"
//#include "eso2WitPrune.h"
#include "stringStringIntFloatTuple.h"


#define CONSUME_ACQUIRED
#define REDUCE_PREPROCESSING_TIME


//--------------------------------------------
//--------------------------------------------
//class ESO2pipSequenceItem
//--------------------------------------------
//--------------------------------------------
// Return true if subsBomEntry exists
bool ESO2problem::witGetSubsBomEntryExists(
                                           const std::string & operationName,
                                           int bomEntry,
                                           int subEntry) const
{
  int opExists;
  witGetOperationExists(mutableWitRun(),operationName.c_str(),&opExists);
  if ( !opExists ) return false;

  int nBomEntries;
  witGetOperationNBomEntries(mutableWitRun(),operationName.c_str(),&nBomEntries);

  int nSubBomEntries;
  witGetBomEntryNSubsBomEntries(mutableWitRun(),operationName.c_str(),bomEntry,&nSubBomEntries);
  if ( subEntry >= nSubBomEntries ) return false;
  return true;
}
// Return true if demand exist
bool ESO2problem::witGetDemandExists(const std::string & pn, const std::string & dn ) const
{
  bool retVal = false;
  
  witBoolean partExists;
  witGetPartExists( mutableWitRun(), pn.c_str(), &partExists );
  if ( !partExists ) return retVal;   
  
  int nPartDemands;
  char ** demandList;
  witGetPartDemands( mutableWitRun(), pn.c_str(), &nPartDemands, &demandList);
  for ( int d=0; d<nPartDemands; ++d ) {
    if ( demandList[d] == dn ) {
      retVal = true;
    }    
    witFree(demandList[d]);
  }
  witFree(demandList);
  return retVal;
}

void ESO2problem::compareWitSolutionsTimeVec(
                                const std::string & id,
                                const std::vector<float> & execTv1,
                                const std::vector<float> & execTv2, 
                                const std::vector<float> & costTv1,
                                const std::vector<float> & costTv2 ) 
{
  int t;
  assert( execTv1.size()==execTv2.size() );
  for ( t=0; t<execTv1.size(); ++t ) {
    CoinRelFltEq eq;
    if ( !eq(execTv1[t],execTv2[t]) ) {
      std::cout <<id.c_str() <<" period: " <<t <<" vol: " <<execTv1[t] <<" " <<execTv2[t] <<" cost: " <<costTv1[t] <<" " <<costTv2[t] <<std::endl;
    }
  }
}

void ESO2problem::compareWitSolutions( const ESO2problem & p1,  const ESO2problem & p2 ) 
{
  // Iterate over demands in p1
  {  
    witAttr objItrState;
    witGetObjItrState(p1.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p1.mutableWitRun());
      witGetObjItrState(p1.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_DEMAND ) {
        char * demandedPartName;
        char * demandName;
        witGetObjItrDemand(p1.mutableWitRun(),&demandedPartName,&demandName);
        std::vector<float> shipVol1 = p1.witGetDemandAttribute(witGetDemandShipVol,demandedPartName,demandName);
        std::vector<float> shipRew1 = p1.witGetDemandAttribute(witGetDemandObj1ShipReward,demandedPartName,demandName);
        
        std::vector<float> shipVol2 = p2.floatToStlVec(0.0);
        std::vector<float> shipRew2 = p2.floatToStlVec(-FLT_MAX);
        bool exists = p2.witGetDemandExists(demandedPartName,demandName);
        if ( exists ) {
          shipVol2 = p2.witGetDemandAttribute(witGetDemandShipVol,demandedPartName,demandName);
          shipRew2 = p2.witGetDemandAttribute(witGetDemandObj1ShipReward,demandedPartName,demandName);
        }

        std::string id = std::string(demandName) + "/" + demandedPartName;
        compareWitSolutionsTimeVec(id,shipVol1,shipVol2,shipRew1,shipRew2);        
        
        witFree(demandedPartName);
        witFree(demandName);
      } 
      
    } // end while( true )
  }
  
  // Iterate over demands in p2
  {  
    witAttr objItrState;
    witGetObjItrState(p2.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p2.mutableWitRun());
      witGetObjItrState(p2.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_DEMAND ) {
        char * demandedPartName;
        char * demandName;
        witGetObjItrDemand(p2.mutableWitRun(),&demandedPartName,&demandName);
        std::vector<float> shipVol2 = p2.witGetDemandAttribute(witGetDemandShipVol,demandedPartName,demandName);
        std::vector<float> shipRew2 = p2.witGetDemandAttribute(witGetDemandObj1ShipReward,demandedPartName,demandName);
        
        std::vector<float> shipVol1 = p1.floatToStlVec(0.0);
        std::vector<float> shipRew1 = p1.floatToStlVec(-FLT_MAX);
        bool exists = p1.witGetDemandExists(demandedPartName,demandName);
        if ( exists ) continue;

        std::string id = std::string(demandName) + "/" + demandedPartName;
        compareWitSolutionsTimeVec(id,shipVol1,shipVol2,shipRew1,shipRew2);        
        
        witFree(demandedPartName);
        witFree(demandName);
      } 
      
    } // end while( true )
  }

  
  // Iterate over operations in p1
  {  
    witAttr objItrState;
    witGetObjItrState(p1.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p1.mutableWitRun());
      witGetObjItrState(p1.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_OPERATION ) {
        char * operationName;
        witGetObjItrOperation(p1.mutableWitRun(),&operationName);
        std::vector<float> execVol1 = p1.witGetNameAttribute(witGetOperationExecVol,operationName);
        std::vector<float> execCost1 = p1.witGetNameAttribute(witGetOperationObj1ExecCost,operationName);
        
        std::vector<float> execVol2 = p2.floatToStlVec(0.0);
        std::vector<float> execCost2 = p2.floatToStlVec(-FLT_MAX);
        int exists;
        witGetOperationExists(p2.mutableWitRun(),operationName, &exists);
        if ( exists ) {
          execVol2 = p2.witGetNameAttribute(witGetOperationExecVol,operationName);
          execCost2 = p2.witGetNameAttribute(witGetOperationObj1ExecCost,operationName);
        }

        std::string id = std::string("Operation:: ") + operationName;
        compareWitSolutionsTimeVec(id,execVol1,execVol2,execCost1,execCost2);        
        
        witFree(operationName);
      } 
      
    } // end while( true )
  }
  
  // Iterate over operations in p2
  {  
    witAttr objItrState;
    witGetObjItrState(p2.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p2.mutableWitRun());
      witGetObjItrState(p2.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_OPERATION ) {
        char * operationName;
        witGetObjItrOperation(p2.mutableWitRun(),&operationName);
        std::vector<float> execVol2 = p2.witGetNameAttribute(witGetOperationExecVol,operationName);
        std::vector<float> execCost2 = p2.witGetNameAttribute(witGetOperationObj1ExecCost,operationName);
        
        std::vector<float> execVol1 = p1.floatToStlVec(0.0);
        std::vector<float> execCost1 = p1.floatToStlVec(-FLT_MAX);
        int exists;
        witGetOperationExists(p1.mutableWitRun(),operationName, &exists);
        if ( exists ) continue; 

        std::string id = std::string("Operation:: ") + operationName;
        compareWitSolutionsTimeVec(id,execVol1,execVol2,execCost1,execCost2);        
        
        witFree(operationName);
      } 
      
    } // end while( true )
  }

   
  // Iterate over substitutes in p1
  {  
    witAttr objItrState;
    witGetObjItrState(p1.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p1.mutableWitRun());
      witGetObjItrState(p1.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_SUB_ENTRY ) {
        char * operationName;
        int bomEntry;
        int subEntry;
        witGetObjItrSubsBomEntry(p1.mutableWitRun(),&operationName, &bomEntry, &subEntry);
        std::vector<float> subVol1 = p1.witGetSubArcAttribute(witGetSubsBomEntrySubVol,operationName,bomEntry,subEntry);
        std::vector<float> subCost1 = p1.witGetSubArcAttribute(witGetSubsBomEntryObj1SubCost,operationName,bomEntry,subEntry);
        
        std::vector<float> subVol2 = p2.floatToStlVec(0.0);
        std::vector<float> subCost2 = p2.floatToStlVec(-FLT_MAX);
        bool exists = p2.witGetSubsBomEntryExists(operationName,bomEntry,subEntry);
        if ( exists ) {
          subVol2 = p2.witGetSubArcAttribute(witGetSubsBomEntrySubVol,operationName,bomEntry,subEntry);
          subCost2 = p2.witGetSubArcAttribute(witGetSubsBomEntryObj1SubCost,operationName,bomEntry,subEntry);
        }


        char bomEntryAsChar[100];
        char subEntryAsChar[100];
        sprintf(bomEntryAsChar,"%d",bomEntry);
        sprintf(subEntryAsChar,"%d",subEntry);        
        std::string id = std::string("Subs:: ") + operationName + " bomEntry: " + bomEntryAsChar + " subEntry: " + subEntryAsChar;
        compareWitSolutionsTimeVec(id,subVol1,subVol2,subCost1,subCost2);        
        
        witFree(operationName);
      } 
      
    } // end while( true )
  }
    
  // Iterate over substitutes in p2
  {  
    witAttr objItrState;
    witGetObjItrState(p2.mutableWitRun(), &objItrState);
    while( true )   {
      witAdvanceObjItr(p2.mutableWitRun());
      witGetObjItrState(p2.mutableWitRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_SUB_ENTRY ) {
        char * operationName;
        int bomEntry;
        int subEntry;
        witGetObjItrSubsBomEntry(p2.mutableWitRun(),&operationName, &bomEntry, &subEntry);
        std::vector<float> subVol2 = p2.witGetSubArcAttribute(witGetSubsBomEntrySubVol,operationName,bomEntry,subEntry);
        std::vector<float> subCost2 = p2.witGetSubArcAttribute(witGetSubsBomEntryObj1SubCost,operationName,bomEntry,subEntry);
        
        std::vector<float> subVol1 = p1.floatToStlVec(0.0);
        std::vector<float> subCost1 = p1.floatToStlVec(-FLT_MAX);
        bool exists = p1.witGetSubsBomEntryExists(operationName,bomEntry,subEntry);
        if ( exists ) continue; 

        char bomEntryAsChar[100];
        char subEntryAsChar[100];
        sprintf(bomEntryAsChar,"%d",bomEntry);
        sprintf(subEntryAsChar,"%d",subEntry);        
        std::string id = std::string("Subs:: ") + operationName + "bomEntry: " + bomEntryAsChar + "subEntry: " + subEntryAsChar;
        compareWitSolutionsTimeVec(id,subVol1,subVol2,subCost1,subCost2);        
        
        witFree(operationName);
      } 
      
    } // end while( true )
  }
}
//--------------------------------------------
//--------------------------------------------

void ESO2problem::addSubsForPeriod1SupplyPerishPeriod(
       const std::string & acquireOperation, 
       const std::string & acquiredPart,
       float moveTime)
{  
  int perishLimit = getPeriod1SupplyPerishPeriod();
  assert( perishLimit>=0 );
  int np = getNPeriods();

  witAddSubsBomEntry(witRun(),acquireOperation.c_str(),0,acquiredPart.c_str());
  if ( perishLimit==0 ) {
    // Substitute arc is not needed so turn it off by setting earliest period to be nPeriods
    witSetSubsBomEntryEarliestPeriod(witRun(),acquireOperation.c_str(),0,0,np);
  }
  else {
    // determine earliest period that substitute could be used
    int earliest = (int)(moveTime /*+ 1*/);
    
    // if moveTime longer than time horizon just turn off arc
    if ( earliest>=np ) {
      earliest=np;
    }
    else {
      // Need to set offsets
      float * offset = floatToConstFloatStar(0.0f);
      int t;
      int latest = -1;
      for ( t=earliest; t<=(int)(moveTime+perishLimit); ++t ) {
        if ( t >= np ) break;
        latest = t;
        offset[t] =(float) t;
      }
      assert( latest != -1 );
      witSetSubsBomEntryOffset(witRun(),acquireOperation.c_str(),0,0,offset);
      witSetSubsBomEntryLatestPeriod(witRun(),acquireOperation.c_str(),0,0,latest);
      delete [] offset;
    }
    witSetSubsBomEntryEarliestPeriod(witRun(),acquireOperation.c_str(),0,0,earliest);
  }


#if 0
  if ( perishLimit>np ) perishLimit = np;

  float * offset = floatToConstFloatStar(0.0f);
  int l;
  for ( l=0; l<perishLimit; ++l ) {
    offset[l] = l;
  }

  witAddSubsBomEntry(witRun(),acquireOperation.c_str(),0,acquiredPart.c_str());
  witSetSubsBomEntryOffset(witRun(),acquireOperation.c_str(),0,0,offset);
  witSetSubsBomEntryLatestPeriod(witRun(),acquireOperation.c_str(),0,0,perishLimit);

  // The model is not wrong if this is not done, but it is slightly more efficient.
  if ( np>0 )
    witSetSubsBomEntryEarliestPeriod(witRun(),acquireOperation.c_str(),0,0,1);

  delete [] offset;
#endif
}

std::vector<int> ESO2problem::multiLevelImpactPeriod( 
       const std::vector<StdVecInt> & impPersVecs )
{
  std::vector<int> retVal;
  
  int p;
  int l; 

  size_t nLevels = impPersVecs.size();
  assert( nLevels > 0 );

  size_t np = impPersVecs[0].size();
  
  // initialize retVal
  for (p=0; p<np; ++p) retVal.push_back(p);

  // loop once for each level
  for (l=0; l<nLevels; ++l ) {

    // loop once for each time period
    for (p=0; p<np; ++p) {

      int x=retVal[p];
      if ( retVal[p] == -1 ) continue;

      int y=impPersVecs[l][ retVal[p] ];
      retVal[p] = impPersVecs[l][ retVal[p] ];

    } // end for p
  } // end for l


#if 0
  for (l=0; l<nLevels; ++l ) {
    for (p=0; p<np; ++p) {
      std::cout <<impPersVecs[l][p] <<" ";
    }
    std::cout <<std::endl;
  }
  for (p=0; p<np; ++p) {
      std::cout <<retVal[p] <<" ";
  }
  std::cout <<std::endl <<std::endl;
#endif

  return retVal;
}

// Set prodRates from mtm attach rates and featureXref ApplProdRates
void ESO2problem::setDemanBomAndFeatureXrefProdRates()
{
  if ( getDemanBomProdRatesAreSet() ) return;
  int np=getNPeriods();

  setDemanBomAndFeatureXrefProdRatesAreSet(true);

  // Make copy of temporary eso2Problem to be used with witGet functions.
  // This is to avoid causing wit to have to do preprocess in a loop and
  // vastly improves performance.
  const ESO2problem * getProb = new ESO2problem(*this);
  //const ESO2problem * getProb = this;

  {
  
  std::cout <<"Setting attachRates using period of mtm supply" <<std::endl;
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms, srcLocs, destLocs );
    int m;
    for (m=0; m<mtms.size(); ++m ) {

      if ( (m % 10)==0 ) 
        std::cout <<"  Setting attachRate for mtm-srcLoc-destLoc triple number:" 
        <<m 
        <<" out of "
        <<(unsigned int)mtms.size()
        <<std::endl;
      
      
      std::string baseDemanOpName = demanMtmName(mtms[m],srcLocs[m],srcLocs[m] );
      int nBops;
      witGetOperationNBopEntries(mutableWitRun(),baseDemanOpName.c_str(),&nBops);
      // loop once for each bop
      int b;
      for (b=0; b<nBops; ++b ) {
        ESO2mtmDemanBomAppData * bopAppData; 
        witGetBopEntryAppData(getProb->mutableWitRun(),baseDemanOpName.c_str(),b,(void**)&bopAppData);
        std::vector<float> attachRate = bopAppData->getAttachRate();

        // must map attachRates to prodRates via impactPeriods.
        // AttachRate[t] is for supply from period t
        // WIT needs prodRate[t] were t is the period of deman operation

        // Get names of wit objects
        std::string demanOpName = demanMtmName(mtms[m],srcLocs[m],destLocs[m] );
        std::string moveAndAcquireOpName = acquireMtmName(mtms[m],srcLocs[m],destLocs[m] );
        
        // Get all impact periods that are in affect from deman operation
        // to source of supply
        std::vector<StdVecInt> impPersVecs(3);
        impPersVecs[0]=( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,demanOpName,0) );
        impPersVecs[1]=( getProb->witGetArcAttribute(witGetBopEntryImpactPeriod,moveAndAcquireOpName,0) );
        impPersVecs[2]=( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,moveAndAcquireOpName,0) );

        std::vector<int> impPers = multiLevelImpactPeriod(impPersVecs);
		//for ( int t=0; t<impPers.size(); ++t ) 
		//	std::cout <<"impPers[" <<t <<"]=" <<impPers[t] <<std::endl;




        // map attach rate to prodRate
        std::vector<float> prodRate(np);
        int p;
        for ( p=0; p<np; ++p ) {
          prodRate[p] = 0.0f;
          if ( impPers[p] != -1 ) {
            
            if ( useMtmPerishableSupply(mtms[m],srcLocs[m],destLocs[m],p ) ){
              prodRate[p] = attachRate[0];
            }
            else {
              prodRate[p] = attachRate[impPers[p]];
            }
          }
          //std::cout <<p <<" " <<impPers[p] <<" " <<attachRate[p] <<" " <<prodRate[p] <<std::endl;
        }

        witSetArcAttribute(witSetBopEntryProductRate,demanOpName,b,prodRate); 

      } // end of b loop
      
    } // end of m loop
    
    std::cout <<"Finished setting attachRates using period of mtm supply" <<std::endl;
  }

#ifdef REDUCE_PREPROCESSING_TIME
  //----------------------------------------------
  {
  
    std::cout <<"Setting featureXref prodRates using period of feature supply" <<std::endl;
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatureXrefs( parts, features, locs );
 
    int x;
    for (x=0; x<parts.size(); ++x ) {

      if ( (x % 10)==0 ) 
        std::cout <<"  Setting prodRate for part-feature-loc triple number: " 
        <<x 
        <<" out of "
        <<(unsigned int)parts.size()
        <<std::endl;
  
     // must map featureXref applProdRate to  wit prodRate via impactPeriods.
     // The applProdRate's period is the period of supply.
     // Wit's prodRate is the period of the crossReference operation.
     // Wit's prodRate must be computed from applProdRate and impact periods.
  
     // Get names of wit objects
     std::string xrefOpName = featureXrefName(parts[x],features[x],locs[x] );
     std::string acquireFeatureOpName = acquireFeatureName(features[x],locs[x] );
  
     // Get all impact periods that are in affect from xref operation
     // to source of supply
     std::vector<StdVecInt> impPersVecs(3);
     
     impPersVecs[0]=( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,xrefOpName,0) );
     impPersVecs[1]=( getProb->witGetArcAttribute(witGetBopEntryImpactPeriod,acquireFeatureOpName,0) );
     impPersVecs[2]=( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,acquireFeatureOpName,0) );
  
     std::vector<int> impPers = multiLevelImpactPeriod(impPersVecs);
  
     // Get current application prodRates
     std::vector<float> applProdRate = getProb->getFeatureXrefProdRate(parts[x],features[x],locs[x]);
  
     
        
     // map applProdRate to witProdRate.
     // There are two cases to consider, since period zero supply may not perish
        std::vector<float> prodRate(np);
        int p;
        for ( p=0; p<np; ++p ) {
          prodRate[p] = 0.0f;
          if ( impPers[p] != -1 ) {
            
            if ( useFeaturePerishableSupply(features[x],locs[x],p )  ){
              prodRate[p] = applProdRate[0];
            }
            else {
              prodRate[p] = applProdRate[impPers[p]];
            }
          }
        }
        
        //for ( p=0; p<np; ++p )
        //  std::cout <<p <<" " <<impPers[p] <<" " <<applProdRate[p] <<" " <<prodRate[p] <<std::endl;


     witSetArcAttribute(witSetBopEntryProductRate,xrefOpName,0,prodRate); 
    } // end of x loop
    
    std::cout <<"Finished featureXref prodRates using period of feature supply" <<std::endl;
  }
#endif
  //--------------------------------------------------
  delete getProb;
    
    
}

//----------------------
// Return true if perishable supply will be consumed
//----------------------
bool ESO2problem::useLoosePartPerishableSupply(
                         const std::string & part,
                         const std::string & partLoc,
                         int period ) 
{
  // get name of acquire op and acquired part
  std::string acquireOpName = acquireLoosePartName(part,partLoc);  
  std::string acquiredPartName = igfLoosePartName(part,partLoc);
  return usePerishableSupply(acquireOpName,acquiredPartName,period);
}
bool ESO2problem::useFeaturePerishableSupply(
                         const std::string & feature,
                         const std::string & featureLoc,
                         int period ) 
{
  // get name of acquire op and acquired part
  std::string acquireOpName = acquireFeatureName(feature,featureLoc);  
  std::string acquiredPartName = igfFeatureName(feature,featureLoc);
  return usePerishableSupply(acquireOpName,acquiredPartName,period);
}
bool ESO2problem::useMtmPerishableSupply(
                         const std::string & mtm,
                         const std::string & srcLoc,
                         const std::string & destLoc,
                         int period
                         )  
{
  // get name of acquire op and acquired part
  std::string moveAndAcquireOpName = acquireMtmName(mtm,srcLoc,destLoc);  
  std::string acquiredPartName = igfMtmName(mtm,srcLoc);
  return usePerishableSupply(moveAndAcquireOpName,acquiredPartName,period);
}

bool ESO2problem::usePerishableSupply(
                         const std::string & witAcquireOpName,
                         const std::string & witAcquiredPartName,
                         int period
                         )  
{
  // Get periods that substitute arc is active
  int subEarliestPer = witGetSubArcAttribute(witGetSubsBomEntryEarliestPeriod,witAcquireOpName,0,0);
  int subLatestPer = witGetSubArcAttribute(witGetSubsBomEntryLatestPeriod,witAcquireOpName,0,0);

  // get supply
  std::vector<float> supply = witGetNameAttribute(witGetPartSupplyVol,witAcquiredPartName);
  
  // Test Kevin's claims about perishable supply
  // Only need to test once per wit operation
  if ( perishableSupplyWarningMsgTested_.find(witAcquireOpName)==perishableSupplyWarningMsgTested_.end() ) {
    perishableSupplyWarningMsgTested_.insert(witAcquireOpName);
    bool ok=true;
    int badPer;
    int p;
    if ( supply[0]!= 0.0f ) {
      for ( p=1; p<supply.size(); ++p ) {
        if ( supply[p] != 0.0f ) {
          ok=false;
          badPer=p;
          break;
        }
      }
    }
    if ( !ok ) {
      // only issue warning if hasn't already been done for this operation
      std::cout 
        <<"-------------------------------------------------------"            <<std::endl
        <<"Warning: supply in first period and another period is non-zero."<<std::endl
        <<"   name: " <<witAcquireOpName.c_str()                                    <<std::endl
        <<"   supply in period 1 is " <<supply[0]    <<std::endl
        <<"   supply in period "<<badPer+1 <<" is " <<supply[badPer]    <<std::endl
        <<"-------------------------------------------------------"            <<std::endl;
      
    }
  }
  
  // determine if deman in period is consuming supply from period 0
  // via substitute bom
  bool useSubs = true;
  if ( subEarliestPer == getNPeriods() ) useSubs=false;
  if ( period<subEarliestPer ) useSubs=false;
  if ( period>subLatestPer ) useSubs=false;
  if ( supply[0]==0.0f ) useSubs=false;
  return useSubs;
}
//-------------------------------------------

void ESO2problem::addNonScrapableCapacity(const std::string & name )
{
  witAddPart(witRun(), name.c_str(), WitCAPACITY);
#ifdef CONSUME_ACQUIRED
  witSetNameAttribute(witSetPartObj1ScrapCost,name.c_str(),bigM());
#endif
}
//-------------------------------------------
// 
//----------------------
// Mtm Methods
//----------------------
void ESO2problem::addMtm(const std::string & mtmName, const std::string & mtmLoc,
                         float demanCostS, float demanTimeS)
{
  std::string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
  std::string acquireMtmWitName = acquireMtmName(mtmName, mtmLoc, mtmLoc );
  std::string serverMtmWitName = serverMtmName(mtmName, mtmLoc, mtmLoc );
  std::string demanMtmWitName = demanMtmName(mtmName, mtmLoc, mtmLoc );

  int np = getNPeriods();

  // Add igf owned mtm, acquire operation, and connect them
  witAddPart(witRun(), igfMtmWitName.c_str(), WitCAPACITY);
  witAddOperation(witRun(), acquireMtmWitName.c_str() );
  witAddBomEntry(witRun(), acquireMtmWitName.c_str(), igfMtmWitName.c_str() );

  // Add substitute boms to allow period 0 supply to be consumed in latter periods.
  addSubsForPeriod1SupplyPerishPeriod(acquireMtmWitName,igfMtmWitName,0.0f);

  // Add server owned mtm, and connect to acquire operation
  addNonScrapableCapacity(serverMtmWitName.c_str());
  witAddBopEntry(witRun(), acquireMtmWitName.c_str(), serverMtmWitName.c_str() );

  // Add demanufacturing operation and connect to server owned mtm
  witAddOperation(witRun(), demanMtmWitName.c_str() );
  witAddBomEntry(witRun(), demanMtmWitName.c_str(), serverMtmWitName.c_str() );

  // Set default demanCost
  float * demanCost = floatToConstFloatStar( (float) demanCostS );
  witSetOperationObj1ExecCost(witRun(), demanMtmWitName.c_str(), demanCost );
  delete [] demanCost;

  // Set default demanTime
  float * demanTime = floatToConstFloatStar( (float) demanTimeS );
  witSetBomEntryOffset(witRun(), demanMtmWitName.c_str(), 0, demanTime );
  delete [] demanTime;

  // Set default app data to hold wfmv
  ESO2mtmAppData * appData = new ESO2mtmAppData(np);
  std::vector<float> moveCost = floatToStlVec(0.0f);
  appData->setMoveCost(moveCost);
  witSetOperationAppData (mutableWitRun(), acquireMtmWitName.c_str(), appData);
  
  std::string baseName = baseMtmName(mtmName, mtmLoc );
  mtmNames_.insert(baseName);
  //addMtmAcquireLoc(baseName,mtmLoc);
}

bool ESO2problem::mtmExists(const std::string & mtmName, const std::string & mtmLoc )const
{
  std::string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),igfMtmWitName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
}


void ESO2problem::setMtmSupply(
    const std::string & mtmName, 
    const std::string & mtmLoc, 
    int period, 
    float supply )
{ 
  std::string name = igfMtmName(mtmName, mtmLoc );
  witSetNameAttribute(&witGetPartSupplyVol,witSetPartSupplyVol,name,period,supply);
}
void ESO2problem::setMtmWfmv(
    const std::string & mtmName, 
    const std::string & mtmLoc, 
    int period, 
    float wholeSaleFairMarketValue )
{
  std::string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
  ESO2mtmAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  appData->setWfmv(period,wholeSaleFairMarketValue);
}
std::vector<float> ESO2problem::getMtmWfmv(
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
{
  std::string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
  ESO2mtmAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  return appData->getWfmv();
}
void ESO2problem::setMtmDemanCost(
                     const std::string & mtmName, 
                     const std::string & supplyLoc, 
                     const std::string & demanLoc, 
                     int period, 
                     float cost )
{ 
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,cost);
}
void ESO2problem::setMtmDemanCost(
    const std::string & mtmName, 
    const std::string & mtmLoc, 
    int period, 
    float demanCost )
{ 
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,demanCost);
}
void ESO2problem::setMtmDemanCost(
    const std::string & mtmName, 
    const std::string & supplyLoc, 
    const std::string & demanLoc,
    const std::vector<float> & demanCost )
{ 
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
  witSetNameAttribute(witSetOperationObj1ExecCost,name,demanCost);
}
std::vector<float> ESO2problem::getMtmDemanCost(
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
{
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
  return witGetNameAttribute(witGetOperationObj1ExecCost,name);
}
void ESO2problem::setMtmDemanTime(
    const std::string & mtmName, 
    const std::string & mtmLoc, 
    int period, 
    float time )
{ 
  std::string name = demanMtmName(mtmName, mtmLoc,mtmLoc );
  witSetArcAttribute(witGetBomEntryOffset,witSetBomEntryOffset,
    name,0,period,time);
}
void ESO2problem::setMtmDemanTime(
                     const std::string & mtmName, 
                     const std::string & supplyLoc, 
                     const std::string & demanLoc, 
                     int period, 
                     float time )
{ 
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
  witSetArcAttribute(witGetBomEntryOffset,witSetBomEntryOffset,
    name,0,period,time);
}
void ESO2problem::setMtmDemanTime(
    const std::string & mtmName, 
    const std::string & supplyLoc,  
    const std::string & demanLoc, 
    const std::vector<float> & time )
{ 
  std::string name = demanMtmName(mtmName, supplyLoc,demanLoc );
  witSetArcAttribute(witSetBomEntryOffset,name,0,time);
}
std::vector<float> ESO2problem::getMtmDemanTime(
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
{
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
  return witGetArcAttribute(witGetBomEntryOffset,name,0);
}
std::vector<float> ESO2problem::getMtmDemanTime(
    const std::string & mtmName, 
    const std::string & supplyLoc,
	const std::string & demanLoc) const
{
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
  return witGetArcAttribute(witGetBomEntryOffset,name,0);
}


void ESO2problem::getMtms(
    std::vector<std::string> & mtms,
    std::vector<std::string> & mtmLoc ) const
{
  mtms.clear();
  mtmLoc.clear();
#if 0
  int nMtms = mtmNames_.size();
  int m;
  for ( m=0; m<nMtms; m++ ) {
    mtms.push_back( mtmFromMtmName(mtmNames_[m]) );
    mtmLoc.push_back( mtmDestLocFromMtmName(mtmNames_[m]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=mtmNames_.begin(); it!=mtmNames_.end(); ++it ) {
    mtms.push_back( mtmFromMtmName(*it) );
    mtmLoc.push_back( mtmDestLocFromMtmName(*it) );
  }
#endif
}


void ESO2problem::getMtmDemanLocs(
    std::vector<std::string> & mtms,
    std::vector<std::string> & srcLocs,
    std::vector<std::string> & destLocs ) const
{
  mtms.clear();
  srcLocs.clear();
  destLocs.clear();
#if 0
  int nMtms = mtmNames_.size();
  int m;
  for ( m=0; m<nMtms; m++ ) {
    
    const std::string & mtm = mtmFromMtmName(mtmNames_[m]);
    const std::string & srcLoc = mtmDestLocFromMtmName(mtmNames_[m]);
#else
  std::set<std::string>::const_iterator it;
  for ( it=mtmNames_.begin(); it!=mtmNames_.end(); ++it ) {
    const std::string & mtm = mtmFromMtmName(*it);
    const std::string & srcLoc = mtmDestLocFromMtmName(*it);
#endif
    mtms.push_back( mtm );
    srcLocs.push_back( srcLoc );
    destLocs.push_back( srcLoc );
    
    // are there any interplant moves to deman mtm at another location
    std::string mtmBName = baseMtmName(mtm,srcLoc);
    if ( mtmAcquireExists(mtmBName) ) {
      
      // mtm has interplant moves so get all destLocs
      
      // Get all locations that this mtm can be moved to
      const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
      
      // Loop once for each location this mtm can be moved to for deman
      std::set<std::string>::const_iterator locIt;
      for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
        const std::string & destLoc = *locIt;
        
        mtms.push_back( mtm );
        srcLocs.push_back( srcLoc );
        destLocs.push_back( destLoc );
        
      } // end of locIt loop
    } // end of if (mtmAcquireExists(baseMtmName)) 
  } // end of m loop
}

std::vector<float> ESO2problem::getMtmAcquireQty(
                                                 const std::string & mtmName, 
                                                 const std::string & mtmLoc )const
{
  return getMtmAcquireQty(mtmName,mtmLoc,mtmLoc);
}

std::vector<float> ESO2problem::getMtmAcquireQtyWithOffset(
                                                 const std::string & mtmName, 
                                                 const std::string & mtmLoc )const
{
  return getMtmAcquireQtyWithOffset(mtmName,mtmLoc,mtmLoc);
}

std::vector<float> ESO2problem::getMtmAcquireQty(
                                                 const std::string & mtmName, 
                                                 const std::string & srcLoc , 
                                                 const std::string & destLoc )const
{
  // Wit ExecVol includes the time to demanufacture.
  // To get acquireQty, execVol needs to be shifted by bom offset
  std::string opName = acquireMtmName(mtmName,srcLoc,destLoc);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}

std::vector<float> ESO2problem::getMtmAcquireQtyWithOffset(
                                                 const std::string & mtmName, 
                                                 const std::string & srcLoc , 
                                                 const std::string & destLoc )const
{
  // Wit ExecVol includes the time to demanufacture.
  // To get acquireQty, execVol needs to be shifted by bom offset
  std::string opName = acquireMtmName(mtmName,srcLoc,destLoc);
  return getOffsetExecVol(opName);
}

std::vector<float> ESO2problem::getMtmSupply(
                                                 const std::string & mtmName, 
                                                 const std::string & mtmLoc )const
{
  std::vector<float> retVal;
  std::string name = igfMtmName(mtmName,mtmLoc);
  retVal = witGetNameAttribute(witGetPartSupplyVol,name);
  return retVal;
}


//----------------------
// mtm interplant methods
//----------------------
bool ESO2problem::mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc )const
{
  std::string mtmBName = baseMtmName(mtm,srcLoc);
  return mtmAcquireLocExists(mtmBName,destLoc);
}
bool ESO2problem::mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc )const
{
  std::string mtmBName = baseMtmName(mtm,srcLoc);
  return mtmAcquireExists(mtmBName);
}
void ESO2problem::addMtmInterplant(
                                   const std::string & mtm, 
                                   const std::string & srcLoc, 
                                   const std::string & destLoc,
                                   float defaultMoveCost, 
                                   float defaultMoveTime  )
{
  assert(mtmExists(mtm,srcLoc));
  
  std::string mtmBName = baseMtmName(mtm,srcLoc);
  std::string igfMtmWitName = igfMtmName(mtm, srcLoc );
  std::string acquireMtmWitName = acquireMtmName(mtm, srcLoc, destLoc );
  std::string serverMtmWitName = serverMtmName(mtm, srcLoc, destLoc );
  std::string demanMtmWitName = demanMtmName(mtm, srcLoc, destLoc );

  // Add acquire operation, and connect to IGF owned part
  //witAddPart(witRun(), igfMtmWitName.c_str(), WitCAPACITY);
  witAddOperation(witRun(), acquireMtmWitName.c_str() );
  witAddBomEntry(witRun(), acquireMtmWitName.c_str(), igfMtmWitName.c_str() );

  // Add substitute boms to allow period 0 supply to be consumed in latter periods.
  addSubsForPeriod1SupplyPerishPeriod(acquireMtmWitName,igfMtmWitName,defaultMoveTime);

  // Set default moveTime
  std::vector<float> defaultMoveTimeVec = floatToStlVec(defaultMoveTime);
  witSetArcAttribute(witSetBomEntryOffset,acquireMtmWitName,0,defaultMoveTimeVec);

  // Add server owned mtm, and connect to acquire operation
  addNonScrapableCapacity(serverMtmWitName.c_str());
  witAddBopEntry(witRun(), acquireMtmWitName.c_str(), serverMtmWitName.c_str() );

  // Add demanufacturing operation and connect to server owned mtm
  witAddOperation(witRun(), demanMtmWitName.c_str() );
  witAddBomEntry(witRun(), demanMtmWitName.c_str(), serverMtmWitName.c_str() );

  // Set default app data
  int np = getNPeriods();
  ESO2mtmAppData * appData = new ESO2mtmAppData(np);
  std::vector<float> defaultMoveCostVec = floatToStlVec(defaultMoveCost);
  appData->setMoveCost(defaultMoveCostVec);
  witSetOperationAppData (mutableWitRun(), acquireMtmWitName.c_str(), appData);

  std::vector<float> demanCost=floatToStlVec(ESO2problem::bigM());
  witSetNameAttribute(witSetOperationObj1ExecCost,demanMtmWitName,demanCost);

  std::vector<float> demanTime=floatToStlVec((float)(np+1));
  witSetArcAttribute(witSetBomEntryOffset,demanMtmWitName,0,demanTime);

  addMtmAcquireLoc(mtmBName,destLoc);

}
void ESO2problem::setMtmInterplantMoveCost(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost )
{
  std::string name = acquireMtmName(mtm, srcLoc, destLoc );
  ESO2mtmAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  appData->setMoveCost(period,moveCost);
}
void ESO2problem::setMtmInterplantMoveTime(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime )
{  
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc); 
  witSetArcAttribute(
    witGetBomEntryOffset,
    witSetBomEntryOffset,
    opName, 0,
    period, moveTime );

  // check to see if offset on substitute arc with move time needs to be updated.
  int perishLimit = getPeriod1SupplyPerishPeriod();
  int np = getNPeriods();
  if ( period>=moveTime+1 && period<=moveTime+perishLimit && moveTime+1<np ) {
    float offsetOfT = moveTime+1;
    witSetSubArcAttribute(
      witGetSubsBomEntryOffset,
      witSetSubsBomEntryOffset,
      opName,0,0,
      period,offsetOfT);
  }
  else {
    // substitute can not be used to consume from first period,
    // so set substitute offset to be same as bom's offset which
    // has the effect of making the substitute redundant
    witSetSubArcAttribute(
      witGetSubsBomEntryOffset,
      witSetSubsBomEntryOffset,
      opName,0,0,
      period,0.0f);
  }

}
std::vector<float> ESO2problem::getMtmInterplantMoveCost(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
{
  std::string name = acquireMtmName(mtm, srcLoc, destLoc );
  ESO2mtmAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  return appData->getMoveCost();
}  
std::vector<float> ESO2problem::getMtmInterplantMoveTime(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
{
  std::vector<float> retVal;
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc);
  retVal = witGetArcAttribute(witGetBomEntryOffset,opName,0);
  return retVal;
} 
std::vector<float> ESO2problem::getMtmInterplantMoveVol(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
{
  std::vector<float> retVal;
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
}

// This is an internal method called when a new part is created.
// The location of the part is added to a map from part to location.
// This allows one to quickly find all locations given a partname.
void ESO2problem::addPartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc )
{
  // is the first location for partOrFeature?
  ESOmapStringToStringSetIterator it;
  it = partOrFeatureLocs_.find(partOrFeatureName);
  if ( it == partOrFeatureLocs_.end() ) {
    // this is first location for partOrFeature
    ESOstringSet locs;
    locs.insert(loc);
    partOrFeatureLocs_[partOrFeatureName] = locs;
  }
  else {
    // partOrFeature already has loc, so get vector of locs
    ESOstringSet & locs = it->second;
    // add new loc.  
    locs.insert(loc);
  }
}
void ESO2problem::removePartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc )
{
  ESOmapStringToStringSetIterator it;
  it = partOrFeatureLocs_.find(partOrFeatureName);

  // part does not exist in map, then just return.
  if( it != partOrFeatureLocs_.end() ) return;

  // get vector of locs for this part
  ESOstringSet & locs = it->second;
  // remove loc. 
  locs.erase(loc);

  // if there are no more locs for this part, then remove part from map
  if ( locs.size()==0 ) {
    partOrFeatureLocs_.erase(partOrFeatureName);
  }
}

// Get all locations were a part exists
std::vector<std::string> ESO2problem::getPartLocs(const std::string & partName ) const
{
  std::vector<std::string> retVal;

  ESOmapStringToStringSetConstIterator it;
  it = partOrFeatureLocs_.find(partName);

  // part does not exist in map, then just return.
  if( it == partOrFeatureLocs_.end() ) return retVal;

  // get vector of locs for this part
  const ESOstringSet & locs = it->second;

  // iterate over set makeing a vector
  ESOstringSetConstIterator locIt;
  for ( locIt = locs.begin(); locIt!=locs.end(); ++locIt ) {
    retVal.push_back(*locIt);
  }
  return retVal;
}
  
void ESO2problem::addMtmAcquireLoc(const std::string & mtmName, const std::string & mtmAcquireLoc )
{
#if 0
  // is the first location for mtm?
  ESOmapStringToStringSetIterator it;
  it = mtmAcquireLocs_.find(mtmName);
  if ( it == mtmAcquireLocs_.end() ) {
    // this is first location for mtm
    ESOstringSet locs;
    locs.insert(mtmAcquireLoc);
    mtmAcquireLocs_[mtmName] = locs;
    //mtmAcquireLocs_[mtmName].insert(mtmAcquireLoc);
  }
  else {
    // mtm already has acquire loc, so get vector of acquire locs
    ESOstringSet & locs = it->second;
    // make sure loc does not already exist
    assert( !mtmAcquireLocExists(mtmName,mtmAcquireLoc) );
    // add new loc.  
    locs.insert(mtmAcquireLoc);
  }
#else
  mtmAcquireLocs_[mtmName].insert(mtmAcquireLoc);
#endif
}

bool ESO2problem::mtmAcquireLocExists(const std::string & mtmName, const std::string & mtmAcquireLoc ) const
{
  bool retVal = false;
  ESOmapStringToStringSetConstIterator it;
  it = mtmAcquireLocs_.find(mtmName);
  if ( it != mtmAcquireLocs_.end() ) {
    const ESOstringSet & locs = it->second;
    if ( locs.find(mtmAcquireLoc) != locs.end() )
      retVal = true;
  }
  return retVal;
}

bool ESO2problem::mtmAcquireExists(const std::string & mtmName ) const
{
  bool retVal = false;
  ESOmapStringToStringSetConstIterator it;
  it = mtmAcquireLocs_.find(mtmName);
  if ( it != mtmAcquireLocs_.end() ) {
    retVal = true;
  }
  return retVal;
}

const std::set<std::string> & ESO2problem::getMtmAcquireLocs(const std::string & mtmName)const
{
  ESOmapStringToStringSetConstIterator it;
  it = mtmAcquireLocs_.find(mtmName);
  assert( it != mtmAcquireLocs_.end() );
  const ESOstringSet & retVal = it->second;
  return retVal;
}





//----------------------
// Feature Methods
//----------------------
void ESO2problem::addFeature(const std::string & featureName, const std::string & featureLoc )
{
  std::string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
  std::string acquireFeatureWitName = acquireFeatureName(featureName, featureLoc );
  std::string serverFeatureWitName = partName(featureName, featureLoc );

  // Add igf owned feature, acquire operation, and connect them
  witAddPart(witRun(), igfFeatureWitName.c_str(), WitCAPACITY);
  witAddOperation(witRun(), acquireFeatureWitName.c_str() );
  witAddBomEntry(witRun(), acquireFeatureWitName.c_str(), igfFeatureWitName.c_str() );  

  // Add substitute boms to allow period 0 supply to be consumed in latter periods.
  addSubsForPeriod1SupplyPerishPeriod(acquireFeatureWitName,igfFeatureWitName,0.0f);

  // Add server owned feature, and connect to acquire operation
  addPartWithOutApplyingInterplants(featureName,featureLoc);
#if 0
  std::string serverOwnedFeatureName = partName(featureName, featureLoc );
  std::string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
  witAddPart(witRun(), serverOwnedFeatureName.c_str(), WitCAPACITY);
  witAddPart(witRun(), moveableServerOwnedFeatureName.c_str(), WitCAPACITY);
  witAddOperation(witRun(),serverOwnedFeatureName.c_str());
  witAddBomEntry(witRun(),serverOwnedFeatureName.c_str(),moveableServerOwnedFeatureName.c_str());
  witAddBopEntry(witRun(),serverOwnedFeatureName.c_str(),serverOwnedFeatureName.c_str());
#endif
  
  std::string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
  witAddBopEntry(witRun(), acquireFeatureWitName.c_str(), moveableServerOwnedFeatureName.c_str() );


#if 0
  // Set default acquistion cost
  float * acquireCost = floatToConstFloatStar(bigM());
  witSetOperationObj1ExecCost(witRun(),acquireFeatureWitName.c_str(),acquireCost);
  free(acquireCost);
#endif
  
  // Set default app data to hold wfmv (ie acquistion cost)
  int np = getNPeriods();
  ESO2featureAppData * appData = new ESO2featureAppData(np);
  witSetOperationAppData (mutableWitRun(), acquireFeatureWitName.c_str(), appData);
  
  std::string baseName = baseFeatureName(featureName, featureLoc );
  featureNames_.insert(baseName);
}
bool ESO2problem::featureExists(const std::string & featureName, const std::string & featureLoc )const
{
  std::string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),igfFeatureWitName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
}
void ESO2problem::setFeatureSupply(const std::string & featureName, const std::string & featureLoc, int period, float supply )
{
  std::string name = igfFeatureName(featureName, featureLoc );
  witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,name,period,supply);
}
void ESO2problem::setFeatureWfmv(const std::string & featureName, const std::string & featureLoc, int period, float wholeSaleFairMarketValue )
{ 
  std::string name = acquireFeatureName(featureName, featureLoc );
  
  ESO2featureAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  appData->setWfmv(period,wholeSaleFairMarketValue);
}

void ESO2problem::getFeatures(
    std::vector<std::string> & features,
    std::vector<std::string> & featureLocs ) const
{
  features.clear();
  featureLocs.clear();
#if 0
  int nFeatures = featureNames_.size();
  int f;
  for ( f=0; f<nFeatures; f++ ) {
    features.push_back( featureFromFeatureName(featureNames_[f]) );
    featureLocs.push_back( locFromFeatureName(featureNames_[f]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=featureNames_.begin(); it!=featureNames_.end(); ++it ) {
    features.push_back( featureFromFeatureName(*it) );
    featureLocs.push_back( locFromFeatureName(*it) );
  }
#endif
}

std::vector<float> ESO2problem::getFeatureAcquireQty(
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
{
  std::vector<float> retVal;
  std::string opName = acquireFeatureName(featureName,featureLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
}
std::vector<float> ESO2problem::getFeatureSupply(
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
{
  std::vector<float> retVal;
  std::string name = igfFeatureName(featureName,featureLoc);
  retVal = witGetNameAttribute(witGetPartSupplyVol,name);
  return retVal;
}

std::vector<float> ESO2problem::getFeatureWfmv(
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
{
  std::string name = acquireFeatureName(featureName,featureLoc);
  ESO2featureAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  return appData->getWfmv();
}








//----------------------
// LoosePart Methods
//----------------------
void ESO2problem::addLoosePart(const std::string & loosePartName, const std::string & loosePartLoc )
{
  std::string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
  std::string acquireLoosePartWitName = acquireLoosePartName(loosePartName, loosePartLoc );
  std::string serverLoosePartWitName = moveablePartName(loosePartName, loosePartLoc );

  // Add igf owned loosePart, acquire operation, and connect them
  witAddPart(witRun(), igfLoosePartWitName.c_str(), WitCAPACITY);
  witAddOperation(witRun(), acquireLoosePartWitName.c_str() );
  witAddBomEntry(witRun(), acquireLoosePartWitName.c_str(), igfLoosePartWitName.c_str() );

  // Add substitute boms to allow period 0 supply to be consumed in latter periods.
  addSubsForPeriod1SupplyPerishPeriod(acquireLoosePartWitName,igfLoosePartWitName,0.0f);
  
  // if server owned part does not exist, then add it to model
  if ( !partExists(loosePartName,loosePartLoc) ) {
    addPart(loosePartName,loosePartLoc);
  }
  // connect server owned loose part to acquire operation
  witAddBopEntry(witRun(), acquireLoosePartWitName.c_str(), serverLoosePartWitName.c_str() );

#if 0
  // Set default acquistion cost
  float * acquireCost = floatToConstFloatStar(bigM());
  witSetOperationObj1ExecCost(witRun(),acquireLoosePartWitName.c_str(),acquireCost);
  free(acquireCost);
#endif
  
  // Set default app data to hold wfmv (ie acquistion cost)
  int np = getNPeriods();
  ESO2loosePartAppData * appData = new ESO2loosePartAppData(np);
  witSetOperationAppData (mutableWitRun(), acquireLoosePartWitName.c_str(), appData);
  
  std::string baseName = baseLoosePartName(loosePartName, loosePartLoc );
  loosePartNames_.insert(baseName);
}
bool ESO2problem::loosePartExists(const std::string & loosePartName, const std::string & loosePartLoc )const
{
  std::string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),igfLoosePartWitName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
}
void ESO2problem::setLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc, int period, float supply )
{
  std::string name = igfLoosePartName(loosePartName, loosePartLoc );
  witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,name,period,supply);
}
void ESO2problem::setLoosePartWfmv(const std::string & loosePartName, const std::string & loosePartLoc, int period, float wholeSaleFairMarketValue )
{ 
  std::string name = acquireLoosePartName(loosePartName, loosePartLoc );
  
  ESO2loosePartAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  appData->setWfmv(period,wholeSaleFairMarketValue);  
}

void ESO2problem::getLooseParts(
    std::vector<std::string> & looseParts,
    std::vector<std::string> & loosePartLocs ) const
{
  looseParts.clear();
  loosePartLocs.clear();
#if 0
  int nLooseParts = loosePartNames_.size();
  int f;
  for ( f=0; f<nLooseParts; f++ ) {
    looseParts.push_back( loosePartFromLoosePartName(loosePartNames_[f]) );
    loosePartLocs.push_back( locFromLoosePartName(loosePartNames_[f]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=loosePartNames_.begin(); it!=loosePartNames_.end(); ++it ) {
    looseParts.push_back( loosePartFromLoosePartName(*it) );
    loosePartLocs.push_back( locFromLoosePartName(*it) );
  }
#endif
}

std::vector<float> ESO2problem::getLoosePartAcquireQty(
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
{
  std::vector<float> retVal;
  std::string opName = acquireLoosePartName(loosePartName,loosePartLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
}
std::vector<float> ESO2problem::getLoosePartSupply(
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
{
  std::vector<float> retVal;
  std::string name = igfLoosePartName(loosePartName,loosePartLoc);
  retVal = witGetNameAttribute(witGetPartSupplyVol,name);
  return retVal;
}
std::vector<float> ESO2problem::getLoosePartWfmv(
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
{ 
  std::string name = acquireLoosePartName(loosePartName,loosePartLoc);
  ESO2featureAppData * appData;
  witGetOperationAppData(mutableWitRun(), name.c_str(), (void**)&appData);
  return appData->getWfmv();
}
//----------------------
// Part Methods
//----------------------
void ESO2problem::addPartWithOutApplyingInterplants(const std::string & part, const std::string & partLoc )
{
  std::string witName = partName(part, partLoc );
  std::string moveAbleWitName = moveablePartName(part, partLoc );
  assert( !partExists(part,partLoc) );
  addNonScrapableCapacity( witName.c_str());
  addNonScrapableCapacity(moveAbleWitName.c_str());
  witAddOperation(witRun(),witName.c_str());
  witAddBomEntry(witRun(),witName.c_str(),moveAbleWitName.c_str());
  witAddBopEntry(witRun(),witName.c_str(),witName.c_str());

  // Add partLoc to map of parts to locations.
  addPartOrFeatureLoc(part,partLoc);
}
void ESO2problem::addPart(const std::string & part, const std::string & partLoc )
{
  std::string witName = partName(part, partLoc );
  std::string moveAbleWitName = moveablePartName(part, partLoc );
  addPartWithOutApplyingInterplants(part,partLoc);

  // Now add all interplant moves for this part.
  // First get vector of part interplant moves from partLoc
  ESO2partInterplantVec & interPlantVec = defaultPartInterplants_[partLoc];

  // Loop once for each destination location
  int l=0;
  for ( l=0; l<interPlantVec.size(); l++ ) {
    const std::string & destLoc = interPlantVec[l].getDestLoc();
    // does part at dest loc exist
    //bool partExist = partExists(part,destLoc);
    
    // If link between srcLoc and destLoc for part does not exist, then add it to model
    if ( !partInterplantExists(part,partLoc,destLoc ) ) {
      
      // Get default move cost and time between srcLoc and destLoc
      float defaultMoveCost = interPlantVec[l].getDefaultMoveCost();
      float defaultMoveTime = interPlantVec[l].getDefaultMoveTime();
      addPartInterplant(part,partLoc,destLoc,defaultMoveCost,defaultMoveTime);
    } // end adding interplant.

    // If  destination part did not exist, now it does after adding interplant.
    // Add all interplant moves for this new part
    //if ( !partExist ) {
    //  addAllPartInterplants( eso2Prob, srcToDestLocs, partInterplantFile, part, destLoc);
    //}
  }  // end for l 
}
bool ESO2problem::partExists(const std::string & name, const std::string & loc )const
{
  std::string witName = partName(name, loc );
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),witName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
}

//----------------------
// Methods for Deman (demanufactuing boms).
//----------------------
bool ESO2problem::demanBomExists(const std::string & mtm, const std::string & part, const std::string & loc )const
{
  bool retVal = false;
  // the demanBom exists if there is a wit bop entry.
  // get index of bop entry. if doesn't exist then -1 is returned.
  int bei = getBopEntryIndex(mtm,part,loc);
  if ( bei!=-1 ) retVal = true;
  return retVal;
}
void ESO2problem::addDemanBom(const std::string & mtm, const std::string & part, const std::string & loc )
{
  assert( !demanBomExists(mtm,part,loc) );
  int np = getNPeriods();

  // if produced part does not exist, then add it to model
  if ( !partExists(part,loc) ) {
    addPart(part,loc);
  }
  
#ifdef CONSUME_ACQUIRED
  // make sure scrap cost of produced parts is zero
  witSetNameAttribute(witSetPartObj1ScrapCost,partName(part, loc ),0.0f);
  witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartName(part, loc ),0.0f);
#endif

  // link mtm demanufacturing operation at src location of consumed part with produced part
  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );
  witAddBopEntry(witRun(),demanOp.c_str(),producedPart.c_str() );

  // set prodRate to default value
  int nBops;
  witGetOperationNBopEntries(mutableWitRun(),demanOp.c_str(),&nBops);
  std::vector<float> prodRate = floatToStlVec(0.f);
  witSetArcAttribute(witSetBopEntryProductRate,demanOp,nBops-1,prodRate);

  // add appData to hold attachRate
  ESO2mtmDemanBomAppData * appData = new ESO2mtmDemanBomAppData(np);
  std::vector<float> attachRate = floatToStlVec(0.0f);
  appData->setAttachRate(attachRate);
  witSetBopEntryAppData (mutableWitRun(), demanOp.c_str(),nBops-1, appData);

  // Are there any interplant moves for this mtm
  std::string mtmBName = baseMtmName(mtm,loc);
  if ( mtmAcquireExists(mtmBName) ) {
    
    // MTM has move operations so add bopEntry for each move to location
    
    // Get all locations that this mtm can be moved to
    const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
    
    // Loop once for each location this mtm can be moved to
    std::set<std::string>::const_iterator locIt;
    for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
      const std::string & destLoc = *locIt;
      
      // if produced part at destLoc does not exist, then add it to model
      if ( !partExists(part,destLoc) ) {
        addPart(part,destLoc);
      }
        
#ifdef CONSUME_ACQUIRED
      // make sure scrap cost of produced parts is zero
      witSetNameAttribute(witSetPartObj1ScrapCost,partName(part, destLoc ),0.0f);
      witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartName(part, destLoc ),0.0f);
#endif
      
      // Add bop entry
      demanOp = demanMtmName(mtm,loc,destLoc);
      std::string producedPart = moveablePartName(part, destLoc );
      witAddBopEntry(witRun(),demanOp.c_str(),producedPart.c_str() );

#if 0
      // Test that nBops has not changed
      {  
        int nDestBops;
        witGetOperationNBopEntries(mutableWitRun(),demanOp.c_str(),&nDestBops);
        assert( nDestBops == nBops );
      }
#endif

      // set prodRate to default
      witSetArcAttribute(witSetBopEntryProductRate,demanOp,nBops-1,prodRate);
      
    } // end of locIt loop
    
  } // end of if (mtmAcquireExists(baseMtmName)) 
}

std::vector<std::string> ESO2problem::getDemanBoms(const std::string & mtm, const std::string & mtmSrcLoc, const std::string & demanLoc)const
{
  std::vector<std::string> retVal;

  std::string demanOp = demanMtmName(mtm, mtmSrcLoc, demanLoc );

#if 0
  int nBopEntries;
  witGetOperationNBopEntries(mutableWitRun(),demanOp.c_str(),&nBopEntries);

  int b;
  for ( b=0; b<nBopEntries; b++ ) {
    char * prodPart;
    witGetBopEntryProducedPart(mutableWitRun(),demanOp.c_str(),b,&prodPart);
    retVal.push_back(partFromPartName(prodPart));    
  }
#else
  std::vector<std::string> witNames = witGetOperProducts(demanOp.c_str());
  int n;
  for (n=0; n<witNames.size(); ++n) {
    retVal.push_back(witNames[n].c_str());
  }
#endif

  return retVal;
}
std::vector<std::string> ESO2problem::witGetOperProducts(const std::string & op)const
{
  std::vector<std::string> retVal;

  int nBopEntries;
  witGetOperationNBopEntries(mutableWitRun(),op.c_str(),&nBopEntries);

  int b;
  for ( b=0; b<nBopEntries; b++ ) {
    char * prodPart;
    witGetBopEntryProducedPart(mutableWitRun(),op.c_str(),b,&prodPart);
    retVal.push_back(prodPart);    
    witFree(prodPart);
  }
  return retVal;
}

void ESO2problem::setDemanBomAttachRate(
          const std::string & mtm, 
          const std::string & part, 
          const std::string & loc, 
          int period, 
          float attachRate )
{
  setDemanBomAndFeatureXrefProdRatesAreSet(false);

  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );

  // Set ProdRate for part at its src location
  int index = getBopEntryIndex(demanOp,producedPart);

  ESO2mtmDemanBomAppData * appData;
  witGetBopEntryAppData(mutableWitRun(), demanOp.c_str(),index, (void**)&appData);
  appData->setAttachRate(period,attachRate);
#if 0
  witSetArcAttribute(witGetBopEntryProductRate,
    witSetBopEntryProductRate,
    demanOp, index,
    period,attachRate);

  // Are there any interplant moves for this mtm
  std::string mtmBName = baseMtmName(mtm,loc);
  if ( mtmAcquireExists(mtmBName) ) {
    
    // MTM has move operations so set prodRate for each move to location
    
    // Get all locations that this mtm can be moved to
    const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
    
    // Loop once for each location this mtm can be moved to
    std::set<std::string>::const_iterator locIt;
    for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
      const std::string & destLoc = *locIt;
      
      // set ProdRate
      demanOp = demanMtmName(mtm,loc,destLoc);
      witSetArcAttribute(witGetBopEntryProductRate,
          witSetBopEntryProductRate,
          demanOp, index,
          period,attachRate);
      
    } // end of locIt loop
    
  } // end of if (mtmAcquireExists(baseMtmName)) 
#endif
}


std::vector<float> ESO2problem::getDemanBomAttachRate(
          const std::string & mtm, 
          const std::string & part, 
          const std::string & loc ) const
{
  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );

  // Set ProdRate for part at its src location
  int index = getBopEntryIndex(demanOp,producedPart);

  ESO2mtmDemanBomAppData * appData;
  witGetBopEntryAppData(mutableWitRun(), demanOp.c_str(),index, (void**)&appData);
  return appData->getAttachRate();
}


// Get Bop Entry Index
int ESO2problem::getBopEntryIndex( 
                                const std::string & mtm, 
                                const std::string & part, 
                                const std::string & loc ) const
{
  // Get wit names
  std::string producedPart = moveablePartName(part, loc );
  std::string producingOp = demanMtmName(mtm, loc, loc );
  int retVal = getBopEntryIndex(producingOp,producedPart);

  return retVal;
}

// Get Bop Entry Index
int ESO2problem::getBopEntryIndex( 
                                const std::string & opName, 
                                const std::string & partName
                                ) const
{
  int retVal = -1;
  
  int nP = getNPeriods();

  // Get current number of bops connected to operation
  int nBops;
  witGetOperationNBopEntries(mutableWitRun(),opName.c_str(),&nBops);

  int bei;
  for ( bei=0; bei<nBops; bei++ ) {
    char * prodPartFromWit;
    witGetBopEntryProducedPart(mutableWitRun(),opName.c_str(),bei,&prodPartFromWit);
    if(partName==prodPartFromWit) retVal=bei;
    witFree(prodPartFromWit);
    if(retVal!=-1) break;
  }

  return retVal;
}


//----------------------
// feature cross reference methods
//----------------------
bool ESO2problem::featureXrefExists(
                                  const std::string & part, 
                                  const std::string & feature, 
                                  const std::string & loc )const
{
  std::string xrefName = featureXrefName(part,feature,loc);
  witBoolean exists;
  witGetOperationExists(mutableWitRun(),xrefName.c_str(),&exists);
  bool retVal = false;
  if( exists ) retVal = true;
  return retVal;
}
void ESO2problem::addFeatureXref(
                               const std::string & part, 
                               const std::string & feature, 
                               const std::string & loc )
{
  int np=getNPeriods();

  assert( !featureXrefExists(part,feature,loc) );
  //assert(  partExists(part,loc) );
  assert(  featureExists(feature,loc) );
  std::string xrefName = featureXrefName(part,feature,loc);  
  std::string refPartName = moveablePartName(part,loc); 
  std::string featureName = partName(feature,loc);

  // Create xref operation and connect to feature
  witAddOperation(witRun(),xrefName.c_str());
  witAddBomEntry(witRun(),xrefName.c_str(),featureName.c_str());

  // if referenced part doesn't exist, then add it to model.
  if ( !partExists(part,loc) ) {
    addPart(part,loc);
  }

  // Connect referenced part to xref operation  
  witAddBopEntry(witRun(),xrefName.c_str(),refPartName.c_str());

  // set default cost
  float * cost = floatToConstFloatStar(bigM());
  witSetOperationObj1ExecCost(witRun(),xrefName.c_str(),cost);
  delete [] cost;

  // set default prodRate
#if 0
  {
  float * prodRate = floatToConstFloatStar(0.f);
  witSetBopEntryProductRate(witRun(),xrefName.c_str(),0,prodRate);
  delete [] prodRate;
  }
#endif
  {
  // add appData to hold applProdRate
  ESO2featureXrefAppData * appData = new ESO2featureXrefAppData(np);
  std::vector<float> prodRate = floatToStlVec(0.0f);
  appData->setProdRate(prodRate);
  witSetOperationAppData (witRun(),xrefName.c_str(), appData);
  }


  // Set default usageTime
  float * usageTime = floatToConstFloatStar(bigM());
  witSetBomEntryOffset(witRun(),xrefName.c_str(),0,usageTime);
  delete [] usageTime;

  xrefFeatures_.insert(xrefName);
}
 
void ESO2problem::setFeatureXrefProdRate(
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
          int period, 
          float applProdRate )
{
  int np = getNPeriods();
  std::string xrefName = featureXrefName(part,feature,loc);

  // Set prod rate in appData.
  // It will latter be set in WIT data structures.
  // To do it now requires witPreprocessing, which can be time consuming.
  
  ESO2featureXrefAppData * appData;
  witGetOperationAppData(mutableWitRun(), xrefName.c_str(), (void**)&appData);
  appData->setProdRate(period,applProdRate);

#ifndef REDUCE_PREPROCESSING_TIME
  
  // must map featureXref applProdRate to  wit prodRate via impactPeriods.
  // The applProdRate's period is the period of supply.
  // Wit's prodRate is the period of the crossReference operation.
  // Wit's prodRate must be computed from applProdRate and impact periods.
  
  // Get names of wit objects
  std::string xrefOpName = featureXrefName(part,feature,loc );
  std::string acquireFeatureOpName = acquireFeatureName(feature,loc );
  
  // Get all impact periods that are in affect from xref operation
  // to source of supply
  std::vector<StdVecInt> impPersVecs;
  impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,xrefOpName,0) );
  impPersVecs.push_back( witGetArcAttribute(witGetBopEntryImpactPeriod,acquireFeatureOpName,0) );
  impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,acquireFeatureOpName,0) );
  
  std::vector<int> impPers = multiLevelImpactPeriod(impPersVecs);
  
  // Get current wit prodRates
  std::vector<float> witProdRate = witGetArcAttribute(witGetBopEntryProductRate,xrefOpName,0);
  
  // map applProdRate to witProdRate.
  // There are two cases to consider, since period zero supply may not perish
  
  if ( period==0 ) {
    // This is the perishable supply case
    int p;
    for ( p=0; p<np; ++p ) {
      if ( impPers[p] != -1 ) {
        if ( p==0 || useFeaturePerishableSupply(feature,loc,p ) ){
          witProdRate[p] = applProdRate;
        }
      }
    }
  }
  else {
    // This is the non-perishable supply case  
    int p;
    for ( p=0; p<np; ++p ) {
      if ( impPers[p] != period ) continue;
      witProdRate[p] = applProdRate;
    }
  }
  
  witSetArcAttribute(witSetBopEntryProductRate,xrefOpName,0,witProdRate); 
#endif
  
}  

void ESO2problem::setFeatureXrefCost(
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
          int period, 
          float cost )
{
  std::string xrefOpName = featureXrefName(part,feature,loc);
  witSetNameAttribute(
    witGetOperationObj1ExecCost,
    witSetOperationObj1ExecCost,
    xrefOpName,
    period, cost );
}
void ESO2problem::setFeatureXrefCost(
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc,  
          float cost )
{
  std::string xrefOpName = featureXrefName(part,feature,loc);
  witSetNameAttribute(
    witSetOperationObj1ExecCost,
    xrefOpName,
    cost );
}
void ESO2problem::setFeatureXrefUsageTime(
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
          int period, 
          float usageTime )
{
  std::string xrefOpName = featureXrefName(part,feature,loc);
  witSetArcAttribute(
    witGetBomEntryOffset,
    witSetBomEntryOffset,
    xrefOpName, 0,
    period, usageTime );
} 

void ESO2problem::setFeatureXrefUsageTime(
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
          float usageTime )
{
  std::string xrefOpName = featureXrefName(part,feature,loc);
  witSetArcAttribute(
    witSetBomEntryOffset,
    xrefOpName, 0,
    usageTime );
} 

void ESO2problem::getFeatureXrefs(
    std::vector<std::string> & parts,
    std::vector<std::string> & features,
    std::vector<std::string> & locs ) const
{
  parts.clear();
  features.clear();
  locs.clear();
#if 0
  int nItems = alternateParts_.size();
  int n;
  for ( n=0; n<nItems; n++ ) {
    upLevelParts.push_back( upLevelPartFromAlternatePartName(alternateParts_[n]) );
    downLevelParts.push_back( downLevelPartFromAlternatePartName(alternateParts_[n]) );
    locs.push_back( locFromAlternatePartName(alternateParts_[n]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=xrefFeatures_.begin(); it!=xrefFeatures_.end(); ++it ) {
    parts.push_back( partFromFeatureXrefName(*it) );
    features.push_back( featureFromFeatureXrefName(*it) );
    locs.push_back( locFromFeatureXrefName(*it) );
  }
#endif
}
std::vector<float> ESO2problem::getFeatureXrefVol(
                                                 const std::string & part,
                                                 const std::string & feature, 
                                                 const std::string & loc )const
{
  std::vector<float> retVal;
  std::string opName = featureXrefName(part,feature,loc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
}

std::vector<float> ESO2problem::getFeatureXrefCost(
                                                 const std::string & part,
                                                 const std::string & feature, 
                                                 const std::string & loc )const
{
  std::vector<float> retVal;
  std::string opName = featureXrefName(part,feature,loc);
  retVal = witGetNameAttribute(witGetOperationObj1ExecCost,opName);
  return retVal;
}


std::vector<float> ESO2problem::getFeatureXrefProdRate(
                                                 const std::string & part,
                                                 const std::string & feature, 
                                                 const std::string & loc )const
{
  std::vector<float> retVal;
  std::string opName = featureXrefName(part,feature,loc);

  ESO2featureXrefAppData * appData;
  witGetOperationAppData(mutableWitRun(), opName.c_str(), (void**)&appData);
  assert( appData != NULL );
  retVal = appData->getProdRate();
  
  return retVal;
}


//----------------------
// alternate part methods
//----------------------
bool ESO2problem::altExists(
                                  const std::string & partOrFeature, 
                                  const std::string & altPart, 
                                  const std::string & loc )const
{
  std::string ecOpName = altName(partOrFeature,altPart,loc);
  witBoolean exists;
  witGetOperationExists(mutableWitRun(),ecOpName.c_str(),&exists);
  bool retVal = false;
  if( exists ) retVal = true;
  return retVal;
}

void ESO2problem::addAlt(
                               const std::string & partOrFeature, 
                               const std::string & altPart, 
                               const std::string & loc,
                               float altCost,
                               float altTime )
{
  assert( !altExists(partOrFeature,altPart,loc) );
  assert(  partExists(partOrFeature,loc) );
  std::string ecOpName = altName(partOrFeature,altPart,loc);  
  std::string upLevelPartName = moveablePartName(altPart,loc); 
  std::string downLevelPartName = partName(partOrFeature,loc);

  // Create EC operation and connect to downlevel part
  witAddOperation(witRun(),ecOpName.c_str());
  witAddBomEntry(witRun(),ecOpName.c_str(),downLevelPartName.c_str());

  float * offset = floatToConstFloatStar(altTime);
  witSetBomEntryOffset(witRun(),ecOpName.c_str(),0,offset);
  delete [] offset;

  // if up level part doesn't exist, then add it to model.
  if ( !partExists(altPart,loc) ) {
    addPart(altPart,loc);
  }

  // Connect uplevel part to ec operation  
  witAddBopEntry(witRun(),ecOpName.c_str(),upLevelPartName.c_str());

  // set default values
  float * cost = floatToConstFloatStar(altCost);
  witSetOperationObj1ExecCost(witRun(),ecOpName.c_str(),cost);
  delete [] cost;

  float * prodRate = floatToConstFloatStar(1.f);
  witSetBopEntryProductRate(witRun(),ecOpName.c_str(),0,prodRate);
  delete [] prodRate;

  alts_.insert(ecOpName);
}

#if 0  
void ESO2problem::setAlternatePartProdRate(
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
          int period, 
          float prodRate )
{
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //std::string producedPart = partName(upLevelPart,loc);
  witSetArcAttribute(
    witGetBopEntryProductRate,
    witSetBopEntryProductRate,
    ecOpName, 0,
    period, prodRate );
}  

void ESO2problem::setAlternatePartCost(
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
          int period, 
          float cost )
{
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc);
  witSetNameAttribute(
    witGetOperationObj1ExecCost,
    witSetOperationObj1ExecCost,
    ecOpName,
    period, cost );
}
void ESO2problem::setAlternatePartUsageTime(
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
          int period, 
          float usageTime )
{
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //std::string producedPart = partName(upLevelPart,loc);
  witSetArcAttribute(
    witGetBomEntryOffset,
    witSetBomEntryOffset,
    ecOpName, 0,
    period, usageTime );
} 

#endif

void ESO2problem::getAlts(
    std::vector<std::string> & partOrFeatures,
    std::vector<std::string> & altParts,
    std::vector<std::string> & locs ) const
{
  partOrFeatures.clear();
  altParts.clear();
  locs.clear();
  std::set<std::string>::const_iterator it;
  for ( it=alts_.begin(); it!=alts_.end(); ++it ) {
    altParts.push_back( altPartFromAltName(*it) );
    partOrFeatures.push_back( partFromAltName(*it) );
    locs.push_back( locFromAltName(*it) );
  }
}
std::set<std::string> ESO2problem::getAltPartOrFeature(const std::string & altPart,const std::string & loc) const
{
  std::set<std::string> retVal;
  std::set<std::string>::const_iterator it;
  for ( it=alts_.begin(); it!=alts_.end(); ++it ) {
    if ( altPart==altPartFromAltName(*it) && loc==locFromAltName(*it) )
      retVal.insert(partFromAltName(*it));
  }
  return retVal;
}


std::vector<float> ESO2problem::getAltVolWithOffset(
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
{
  // Wit ExecVol includes the time to demanufacture.
  // To get acquireQty, execVol needs to be shifted by bom offset
  std::string opName = altName(partOrFeature,altPart,loc);
#if 0
  std::vector<float> altVol = witGetNameAttribute(witGetOperationExecVol,opName);
  std::vector<float> offset = getAltConvTime(partOrFeature,altPart,loc );
  return shiftAttributeByOffset(altVol,offset);
#endif
  return getOffsetExecVol(opName);
}

std::vector<float> ESO2problem::getAltVol(
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
{
  std::string opName = altName(partOrFeature,altPart,loc);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}

std::vector<float> ESO2problem::getAltConvCost(
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
{
  std::vector<float> retVal;
  std::string opName = altName(partOrFeature,altPart,loc);
  retVal = witGetNameAttribute(witGetOperationObj1ExecCost,opName);
  return retVal;
}
std::vector<float> ESO2problem::getAltConvTime(
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
{
  std::vector<float> retVal;
  std::string opName = altName(partOrFeature,altPart,loc); 
  
  int n;
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&n);
  assert(n==1 || n==0);

  if (n==0) {
    retVal = floatToStlVec(0.0f);
  } else {
    retVal = witGetArcAttribute(witGetBomEntryOffset,opName,0);
  }

  return retVal;
}

 
//----------------------
// partInterplant methods
//----------------------
bool ESO2problem::partInterplantExists(
                                  const std::string & part, 
                                  const std::string & srcLoc, 
                                  const std::string & destLoc )const
{
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  witBoolean exists;
  witGetOperationExists(mutableWitRun(),opName.c_str(),&exists);
  bool retVal = false;
  if( exists ) retVal = true;
  return retVal;
}

void ESO2problem::addPartsInterplant(
                                     const std::string & srcLoc, 
                                     const std::string & destLoc, 
                                     float defaultMoveCost, 
                                     float defaultMoveTime )
{
  ESO2partInterplant pi(srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
  defaultPartInterplants_[srcLoc].push_back(pi);
}

void ESO2problem::addPartInterplant(
                               const std::string & part, 
                               const std::string & srcLoc, 
                               const std::string & destLoc, 
                               float defaultMoveCost , 
                               float defaultMoveTime )
{
  assert( !partInterplantExists(part,srcLoc,destLoc) );
  std::string opName = partInterplantName(part,srcLoc,destLoc);  
  std::string srcPartName = moveablePartName(part,srcLoc); 
  std::string destPartName = partName(part,destLoc);

  // Create move operation and connect to src part
  witAddOperation(witRun(),opName.c_str());
  witAddBomEntry(witRun(),opName.c_str(),srcPartName.c_str());

  // if destination part doesn't exist, then add it to model.
  if ( !partExists(part,destLoc) ) {
    addPart(part,destLoc);
  }

  // Connect destination part to move operation  
  witAddBopEntry(witRun(),opName.c_str(),destPartName.c_str());

  // set default move cost
  float * moveCost = floatToConstFloatStar(defaultMoveCost);
  witSetOperationObj1ExecCost(witRun(),opName.c_str(),moveCost);
  delete [] moveCost;

  // set default move time
  float * moveTime = floatToConstFloatStar(defaultMoveTime);
  witSetBomEntryOffset(witRun(),opName.c_str(),0,moveTime );
  delete [] moveTime;

  partInterplants_.insert(opName);
}
void ESO2problem::setPartInterplantMoveCost(
          const std::string & part, 
          const std::string & srcLoc, 
          const std::string & destLoc, 
          int period, 
          float moveCost )
{
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  witSetNameAttribute(
    witGetOperationObj1ExecCost,
    witSetOperationObj1ExecCost,
    opName,
    period, moveCost );
}
void ESO2problem::setPartInterplantMoveTime(
          const std::string & part, 
          const std::string & srcLoc, 
          const std::string & destLoc, 
          int period, 
          float moveTime )
{
  std::string opName = partInterplantName(part,srcLoc,destLoc); 
  witSetArcAttribute(
    witGetBomEntryOffset,
    witSetBomEntryOffset,
    opName, 0,
    period, moveTime );
} 

void ESO2problem::getPartInterplants( 
                    std::vector<std::string> & parts, 
                    std::vector<std::string> & srcLocs, 
                    std::vector<std::string> &destLocs ) const
{
  parts.clear();
  srcLocs.clear();
  destLocs.clear();
#if 0
  int nItems = partInterplants_.size();
  int n;
  for ( n=0; n<nItems; n++ ) {
    parts.push_back( partFromPartInterplantName(partInterplants_[n]) );
    srcLocs.push_back( srcLocFromPartInterplantName(partInterplants_[n]) );
    destLocs.push_back( destLocFromPartInterplantName(partInterplants_[n]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=partInterplants_.begin(); it!=partInterplants_.end(); ++it ) {
    parts.push_back( partFromPartInterplantName(*it) );
    srcLocs.push_back( srcLocFromPartInterplantName(*it) );
    destLocs.push_back( destLocFromPartInterplantName(*it) );
  }
#endif
}

std::set<std::string> ESO2problem::getPartInterplantSrcLocs( const std::string & part, const std::string & destLoc ) const
{
  std::set<std::string> retVal;
  std::set<std::string>::const_iterator it;
  for ( it=partInterplants_.begin(); it!=partInterplants_.end(); ++it ) {
    if ( (partFromPartInterplantName(*it) == part ) && ( destLocFromPartInterplantName(*it) == destLoc ) )
      retVal.insert( srcLocFromPartInterplantName(*it) );
  }
  return retVal;
}

std::vector<float> ESO2problem::getPartInterplantMoveVolWithOffset(
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
{
#if 0
  std::vector<float> retVal;
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
#endif

  // Wit ExecVol includes the time to move.
  // To get volume at start of move, then execVol needs to be shifted by bom offset
  std::string opName = partInterplantName(part,srcLoc,destLoc);
#if 0
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,opName);
  std::vector<float> offset = getPartInterplantMoveTime(part, srcLoc,destLoc );
  return shiftAttributeByOffset(execVol,offset);
#endif
   return getOffsetExecVol(opName);
}

std::vector<float> ESO2problem::getPartInterplantMoveVol(
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
{
#if 1
  std::vector<float> retVal;
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
#else

  // Wit ExecVol includes the time to move.
  // To get volume at start of move, then execVol needs to be shifted by bom offset
  std::string opName = partInterplantName(part,srcLoc,destLoc);
#if 0
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,opName);
  std::vector<float> offset = getPartInterplantMoveTime(part, srcLoc,destLoc );
  return shiftAttributeByOffset(execVol,offset);
#endif
   return getOffsetExecVol(opName);
#endif
}

std::vector<float> ESO2problem::getOffsetExecVol(const std::string & witOpName) const
{
  std::vector<float> retVal;
  std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witOpName);

  int nBoms;
  witGetOperationNBomEntries(mutableWitRun(),witOpName.c_str(),&nBoms);

  if ( nBoms==0 ) {
    retVal = execVol;
  } else {
    assert(nBoms==1);
    std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,witOpName,0 );

    retVal=floatToStlVec(0.0f);
    for (int p=0;p<retVal.size(); ++p ){
      int ip = impPer[p];
      if ( ip == -1 ) continue;
      float ev = execVol[p];
      retVal[ ip ] = ev;
    }
  }
  return retVal;
}
std::vector<float> ESO2problem::getPartInterplantMoveCost(
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
{
  std::vector<float> retVal;
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  retVal = witGetNameAttribute(witGetOperationObj1ExecCost,opName);
  return retVal;
}

std::vector<float> ESO2problem::getPartInterplantMoveTime(
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
{
  std::vector<float> retVal;
  std::string opName = partInterplantName(part,srcLoc,destLoc);
  
  int n;
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&n);
  assert(n==1 || n==0);

  if (n==0) {
    retVal = floatToStlVec(0.0f);
  } else {
    retVal = witGetArcAttribute(witGetBomEntryOffset,opName,0);
  }

  return retVal;
}


//----------------------
// partDemand methods
//----------------------
bool ESO2problem::partDemandExists(
                                  const std::string & part, 
                                  const std::string & custLoc, 
                                  const std::string & plantLoc )const
{
#if 0
  bool retVal=false;
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
  int nDems;
  char ** dNames;
  witGetPartDemands(mutableWitRun(),dName.c_str(),&nDems,&dNames);
  for ( int d=0; d<nDems; d++ ) {
    if ( dName==dNames[d] ) retVal = true;
    witFree(dNames[d]);
  }
  witFree(dNames);
  return retVal;
#endif
  // Since every demand has its own part, just have to see if part exists
  std::string dName = partDemandName(part,custLoc,plantLoc);
  witBoolean partExists;
  witGetPartExists(mutableWitRun(),dName.c_str(),&partExists);
  bool retVal = false;
  if( partExists) retVal = true;
  return retVal;
}

// Pegging information
std::set<std::string> ESO2problem::getPartDemandPeggedAttributeNames(
  const std::string & part, const std::string & custLoc, const std::string & plantLoc, int shipPeriod )const
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  ESO2partDemandAppData * appDataPtr;
  witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&appDataPtr);
  return appDataPtr->getAttributeNames();
}
 
void ESO2problem::getPartDemandPegging(
                                       const std::string & peggedAttributeName,
                                       const std::string & part, const std::string & custLoc, const std::string & plantLoc, int shipPeriod,

                                       std::vector<std::string> & items, 
                                       std::vector<std::string> & locs, 
                                       std::vector<int> & periods, 
                                       std::vector<int> & depths, 
                                       std::vector<float> & quantities ) const
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  ESO2partDemandAppData * appDataPtr;
  witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&appDataPtr);
  
  appDataPtr->getPeggedItems(peggedAttributeName,shipPeriod,items,locs,periods,depths,quantities);
}

#if 0
void ESO2problem::getPartDemandPegging(
    const std::string & part, 
    const std::string & custLoc, 
    const std::string & plantLoc, 
    int shipPeriod,

    std::vector<std::string> & mtms, 
    std::vector<std::string> & mtmSrcLocs, 
    std::vector<std::string> & mtmAcquireLocs, 
    std::vector<int> & mtmAcquirePeriods, 
    std::vector<float> & mtmAcquireQuantity,
    
    std::vector<std::string> & demanMtms,
    std::vector<std::string> & demanLocs,
    std::vector<int> & demanPeriods,
    std::vector<float> & demanQuantities,

    std::vector<std::string> & features, 
    std::vector<std::string> & featurePlantLocs, 
    std::vector<int> & featureAcquirePeriods, 
    std::vector<float> & featureAcquireQuantity,

    std::vector<std::string> & looseParts, 
    std::vector<std::string> & loosePartPlantLocs, 
    std::vector<int> & loosePartAcquirePeriods, 
    std::vector<float> & loosePartAcquireQuantity )
    const
{
  
  std::string dName = partDemandName(part,custLoc,plantLoc);
  ESO2partDemandAppData * appDataPtr;
  witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&appDataPtr);

  // Get MTM pegging info
  {
    mtms.clear();
    mtmSrcLocs.clear();
    mtmAcquireLocs.clear();
    mtmAcquirePeriods.clear();
    mtmAcquireQuantity.clear();
    
    std::vector<std::string> witMtms;
    std::vector<int> periods;
    std::vector<float> quantities;
    appDataPtr->getPeggedItems("MtmAcquire",shipPeriod,witMtms,periods,quantities);
    
    int m;
    for( m=0; m<witMtms.size(); ++m ) {
      std::string t = mtmFromMtmName(witMtms[m].c_str());
      mtms.push_back(t);
      
      t=mtmSrcLocFromMtmName(witMtms[m].c_str());
      mtmSrcLocs.push_back(t);
      
      t=mtmDestLocFromMtmName(witMtms[m].c_str());
      mtmAcquireLocs.push_back(t);
      
      mtmAcquirePeriods.push_back(periods[m]);
      
      mtmAcquireQuantity.push_back(quantities[m]);
    }
  } // end get MTM pegging info

  
  // Get mtm deman info
  {
    demanMtms.clear();
    demanLocs.clear();
    demanPeriods.clear();
    demanQuantities.clear();
    
    std::vector<std::string> witDemanOps;
    std::vector<int> periods;
    std::vector<float> quantities;
    appDataPtr->getPeggedItems("MtmDisassemble",shipPeriod,witDemanOps,periods,quantities);
    
    int m;
    for( m=0; m<witDemanOps.size(); ++m ) {
      std::string t = mtmFromMtmName(witDemanOps[m].c_str());
      demanMtms.push_back(t);
      
      t=mtmDestLocFromMtmName(witDemanOps[m].c_str());
      demanLocs.push_back(t);
      
      demanPeriods.push_back(periods[m]);
      
      demanQuantities.push_back(quantities[m]);
    }
  } // end get mtm deman pegging info

    // Get feature pegging info
  {
    features.clear();
    featurePlantLocs.clear();
    featureAcquirePeriods.clear();
    featureAcquireQuantity.clear();
    
    std::vector<std::string> witFeatures;
    std::vector<int> periods;
    std::vector<float> quantities;
    appDataPtr->getPeggedItems("FeatureAcquire",shipPeriod,witFeatures,periods,quantities);
    
    int m;
    for( m=0; m<witFeatures.size(); ++m ) {
      std::string t = featureFromFeatureName(witFeatures[m].c_str());
      features.push_back(t);
      
      t=locFromFeatureName(witFeatures[m].c_str());
      featurePlantLocs.push_back(t);
      
      featureAcquirePeriods.push_back(periods[m]);
      
      featureAcquireQuantity.push_back(quantities[m]);
    }
  } // end get feature pegging info

  // Get loosePart pegging info
  {
    looseParts.clear();
    loosePartPlantLocs.clear();
    loosePartAcquirePeriods.clear();
    loosePartAcquireQuantity.clear();
    
    std::vector<std::string> witLooseParts;
    std::vector<int> periods;
    std::vector<float> quantities;
    appDataPtr->getPeggedItems("LoosePartAcquire",shipPeriod,witLooseParts,periods,quantities);
    
    int m;
    for( m=0; m<witLooseParts.size(); ++m ) {
      std::string t = loosePartFromLoosePartName(witLooseParts[m].c_str());
      looseParts.push_back(t);
      
      t=locFromLoosePartName(witLooseParts[m].c_str());
      loosePartPlantLocs.push_back(t);
      
      loosePartAcquirePeriods.push_back(periods[m]);
      
      loosePartAcquireQuantity.push_back(quantities[m]);
    }
  } // end get loosePart pegging info


}
#endif

void ESO2problem::reportPart(const std::string & witPartName, 
                             int period,
                             int recursionDepth,
                             float reqVol,
                             float reqVal ) const
{
  int np=getNPeriods();
  recursionDepth++;

  std::string indent="";
  int i;
  for (i=0; i<recursionDepth; i++ ) indent=indent+"   ";

  std::vector<float> consVol = witGetNameAttribute(witGetPartConsVol,witPartName);
  std::vector<float> excessVol = witGetNameAttribute(witGetPartExcessVol,witPartName);
  //std::vector<float> stockVol = witGetNameAttribute(witGetPartStockVol,witPartName);
  std::vector<float> supplyVol = witGetNameAttribute(witGetPartSupplyVol,witPartName);
  
  std::cout 
    <<indent.c_str() <<"----------------------------------" <<std::endl
    <<indent.c_str() <<"part name: "   <<witPartName.c_str() <<std::endl
    <<indent.c_str() <<"period: "   <<period <<std::endl
    <<indent.c_str() <<"requiredVol: "   <<reqVol <<std::endl
    <<indent.c_str() <<"value of satisfy requiredVol: "   <<reqVal <<std::endl
    <<indent.c_str() <<"consVol: "   <<consVol[period] <<std::endl
    <<indent.c_str() <<"excessVol: "     <<excessVol[period] <<std::endl
    //<<indent.c_str() <<"stockVol: "     <<excessVol[period] <<std::endl
    <<indent.c_str() <<"supplyVol: "     <<supplyVol[period] <<std::endl;

  int nProdBops;
  witGetPartNProducingBopEntries(mutableWitRun(),witPartName.c_str(),&nProdBops);

  int prodBop;
  for ( prodBop=0; prodBop<nProdBops; prodBop++ ) {
    int bopIndex;
    char * opName;
    witGetPartProducingBopEntry(mutableWitRun(),witPartName.c_str(),prodBop,&opName,&bopIndex);
    std::cout 
      <<indent.c_str() <<"producing op: "   <<opName <<std::endl;

    // Make sure bop offsets are zero
    std::vector<float> bopOffset = witGetArcAttribute(witGetBopEntryOffset,opName,bopIndex);
    assert(bopOffset.size()==np);
    for ( i=0; i<np; i++ ) 
      assert(bopOffset[i]==0);

    // get bop prod rate    
    std::vector<float> bopProdRate = witGetArcAttribute(witGetBopEntryProductRate,opName,bopIndex);

    // get operation attributes
    std::vector<float> obj1ExecCost = witGetNameAttribute(witGetOperationObj1ExecCost,opName);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,opName);

    std::vector<float> bomOffset = witGetArcAttribute(witGetBomEntryOffset,opName,0);
    std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,opName,0);
    std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,opName,0);
    std::vector<float> hlb,slb,hub;
    witGetNameBoundAttribute(witGetOperationExecBounds,opName,hlb,slb,hub);
    for ( i=0; i<np; i++ ) 
      assert(bomConsRate[i]==1.0);
    int newPer = impPer[period];

    std::cout 
      <<indent.c_str() <<"period: "   <<period <<std::endl
      <<indent.c_str() <<"bop prodRate: "   <<bopProdRate[period] <<std::endl      
      <<indent.c_str() <<"opName: "   <<opName <<std::endl
      <<indent.c_str() <<"operation obj1ExecCost: "   <<obj1ExecCost[period] <<std::endl
      <<indent.c_str() <<"operation execVol: "   <<execVol[period] <<std::endl
      <<indent.c_str() <<"operation exec hub: "   <<hub[period] <<std::endl
      <<indent.c_str() <<"bom offset: "   <<bomOffset[period] <<std::endl
      <<indent.c_str() <<"impact period: "   <<impPer[period] <<std::endl;

    // get consumed part
    char * consumedPart;
    witGetBomEntryConsumedPart(mutableWitRun(),opName,0,&consumedPart);

    // are there any subs
    int nSubBoms;
    witGetBomEntryNSubsBomEntries(mutableWitRun(),opName,0,&nSubBoms);
    assert( nSubBoms==0 || nSubBoms==1 );
    if ( nSubBoms==1 ) {
      std::vector<float> subOffset = witGetSubArcAttribute(witGetSubsBomEntryOffset,opName,0,0);
      std::vector<int> subImpPer = witGetSubArcAttribute(witGetSubsBomEntryImpactPeriod,opName,0,0);
      int earliestPeriod = witGetSubArcAttribute(witGetSubsBomEntryEarliestPeriod,opName,0,0);
      int latestPeriod = witGetSubArcAttribute(witGetSubsBomEntryLatestPeriod,opName,0,0);

      std::cout 
        <<indent.c_str() <<"subBom offset: "   <<subOffset[period] <<std::endl
        <<indent.c_str() <<"subImpact period: "   <<subImpPer[period] <<std::endl
        <<indent.c_str() <<"subEarliest period: "   <<earliestPeriod <<std::endl
        <<indent.c_str() <<"subLatest period: "   <<latestPeriod <<std::endl;
      
      if ( subImpPer[period]!=-1 ) {
        float newReqVol = reqVol/bopProdRate[period];
        float newReqVal = reqVal-obj1ExecCost[period]*newReqVol;
        reportPart(consumedPart,subImpPer[period],recursionDepth,newReqVol,newReqVal );
      }

    }

    if ( newPer == -1 ) {
      // can not consume part
      std::cout 
        <<indent.c_str() <<"part name: "   <<consumedPart <<std::endl;
    }
    else {
      // report on consumed part{
      float newReqVol = reqVol/bopProdRate[period];
      float newReqVal = reqVal-obj1ExecCost[period]*newReqVol;
      reportPart(consumedPart,newPer,recursionDepth, newReqVol, newReqVal );
    }

    witFree(consumedPart);
    witFree(opName);
  }  // for prodBop
}
void ESO2problem::reportPartDemand(const std::string & part, 
                      const std::string & custLoc, 
                      const std::string & plantLoc, 
                      int period ) const 
{ 
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);

  std::vector<float> shipVol = getPartDemandShipVol(part,custLoc,plantLoc);
  std::vector<float> demandVol = getPartDemandDemandVol(part,custLoc,plantLoc);
  std::vector<float> wac = getPartDemandWac(part,custLoc,plantLoc);

  std::cout 
    <<"----------------------------------" <<std::endl
    <<"demand name: " <<dName.c_str() <<std::endl
    <<"demanded part name: "   <<pName.c_str() <<std::endl
    <<"period: "   <<period <<std::endl
    <<"demandVol: "   <<demandVol[period] <<std::endl
    <<"shipVol: "     <<shipVol[period] <<std::endl
    <<"wac: "     <<wac[period] <<std::endl
    <<"wac*demandVol: "     <<wac[period]*demandVol[period] <<std::endl;
  if ( demandVol[period] == shipVol[period] ) {
    std::cout 
      <<"demand satisfied." <<std::endl ;
  }
  //else {
    reportPart(pName,period,0,demandVol[period],wac[period]*demandVol[period]);
  //}

  std::cout
      <<"----------------------------------" <<std::endl;

}

void ESO2problem::addPartDemand(
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc)
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);

  // Add part and attach demand to it.
  addNonScrapableCapacity(dName.c_str());
  witAddDemand(witRun(),dName.c_str(),dName.c_str());

  // Add operation and connect to demanded part
  witAddOperation(witRun(),dName.c_str());
  witAddBopEntry(witRun(),dName.c_str(),dName.c_str());

  //-------------------------------------------
  // Add part to model inventory holding at demand location

  std::string inventoryPartName = partDemandInventoryName(part,custLoc,plantLoc);
  if ( getAllowInventoryHoldingAtDemandLocation() ) {
    witAddPart(witRun(), inventoryPartName.c_str(), WitMATERIAL );
  } else {
    witAddPart(witRun(), inventoryPartName.c_str(), WitCAPACITY );
  }
  witAddBomEntry(witRun(),dName.c_str(),inventoryPartName.c_str());

  witAddOperation(witRun(),inventoryPartName.c_str());
  witAddBopEntry(witRun(),inventoryPartName.c_str(),inventoryPartName.c_str());
  //-------------------------------------------

  // Attach existing part in model to operation
  witAddBomEntry(witRun(),/*dName.c_str()*/ inventoryPartName.c_str() ,pName.c_str());

  // Add regulator capacity and attach to operation.
  // This capacity is used to control demand perishability
  witAddPart(witRun(), regulatorName.c_str(), WitCAPACITY);
  witAddBomEntry(witRun(),dName.c_str(),regulatorName.c_str());

  // Set default app data to hold pegging information
  ESO2partDemandAppData * appData = new ESO2partDemandAppData(getNPeriods());
  witSetDemandAppData (mutableWitRun(), dName.c_str(),dName.c_str(), appData);

  partDemands_.insert(dName);
}

void ESO2problem::setPartDemandDemandVol(
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc,
                               int period,
                               float demandVol)
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string rName = partDemandRegulatorName(part,custLoc,plantLoc);
  witSetDemandAttribute(witGetDemandDemandVol,witSetDemandDemandVol,
    dName, dName, period, demandVol);

  // Set supplyVol of regulator capacity to enforce perishability of demand
  witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,
    rName, period, demandVol);
}

void ESO2problem::setPartDemandWac(
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc,
                               int period,
                               float wac)
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
#if 0
  witSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,
    dName, dName, period, wac);
#endif
  ESO2partDemandAppData * appData;
  witGetDemandAppData(mutableWitRun(), dName.c_str(), dName.c_str(), (void**)&appData);
  appData->setWac(period,wac);
}

void ESO2problem::setPartDemandPriority(
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc,
                               int priority)
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
  ESO2partDemandAppData * appData;
  witGetDemandAppData(mutableWitRun(), dName.c_str(), dName.c_str(), (void**)&appData);
  appData->setPriority(priority);
}

int ESO2problem::getPartDemandPriority(
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc)const
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
  ESO2partDemandAppData * appData;
  witGetDemandAppData(mutableWitRun(), dName.c_str(), dName.c_str(), (void**)&appData);
  return appData->getPriority();
}

   
// Get list of all partDemands added
void ESO2problem::getPartDemands( 
                                 std::vector<std::string> & parts, 
                                 std::vector<std::string> & custLocs, 
                                 std::vector<std::string> &plantLocs ) const
{
  parts.clear();
  custLocs.clear();
  plantLocs.clear();
#if 0
  int nItems = partDemands_.size();
  int n;
  for ( n=0; n<nItems; n++ ) {
    parts.push_back( partFromPartDemandName(partDemands_[n]) );
    custLocs.push_back( custLocFromPartDemandName(partDemands_[n]) );
    plantLocs.push_back( plantLocFromPartDemandName(partDemands_[n]) );
  }
#else
  std::set<std::string>::const_iterator it;
  for ( it=partDemands_.begin(); it!=partDemands_.end(); ++it ) {
    parts.push_back( partFromPartDemandName(*it) );
    custLocs.push_back( custLocFromPartDemandName(*it) );
    plantLocs.push_back( plantLocFromPartDemandName(*it) );
  }
#endif
}
std::vector<float> ESO2problem::getPartDemandShipVol(
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
{
  std::vector<float> retVal;
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
  retVal = witGetDemandAttribute(witGetDemandShipVol,dName,dName);
  return retVal;
}
std::vector<float> ESO2problem::getPartDemandDemandVol(
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
{
  std::vector<float> retVal;
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
  retVal = witGetDemandAttribute(witGetDemandDemandVol,dName,dName);
  return retVal;
}
std::vector<float> ESO2problem::getPartDemandWac(
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
{
  std::vector<float> retVal;
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
#if 0
  retVal = witGetDemandAttribute(witGetDemandObj1ShipReward,dName,dName);
#endif  
  ESO2partDemandAppData * appData;
  witGetDemandAppData(mutableWitRun(), dName.c_str(), dName.c_str(), (void**)&appData);
  retVal = appData->getWac();

  return retVal;
}
std::vector<float> ESO2problem::getPartDemandScaledWac(
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
{
  std::vector<float> retVal = getPartDemandWac(part,custLoc,plantLoc);
  int demandPriority = getPartDemandPriority(part,custLoc,plantLoc);
  const std::vector<float> & wacScaleFactors = getWacScaleFactors();
  for (size_t t=0; t<retVal.size(); ++t ) 
    retVal[t]=retVal[t]*wacScaleFactors[demandPriority];
  return retVal;
}




// Label depth of Wit Objects to determine order that they are performed.
// This is important when they are done in the same period
void ESO2problem::labelObjectDepth(
    std::map<std::string,int> & operationDepths,
    std::map<std::string,int> & partDepths)
{
  operationDepths.clear();
  partDepths.clear();

  // Make sure wit is in preprocessed state
  witPreprocess(witRun());

  // Loop once for each WIT object and record its depth
  {
    witAttr objItrState;
    witGetObjItrState(witRun(), &objItrState);
    assert(objItrState==WitINACTIVE);
    for( int depth=0; depth=depth+10; )   {
      witAdvanceObjItr(witRun());
      witGetObjItrState(witRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_OPERATION ) {
        char * operationName;
        witGetObjItrOperation(witRun(),&operationName);
        operationDepths[operationName] = depth;  
        witFree(operationName);
      }
      if( objItrState == WitAT_PART ) {
        char * partName;
        witGetObjItrPart(witRun(),&partName);
        partDepths[partName] = depth; 
        witFree(partName);
      }
    }
  }



}

void ESO2problem::updateActivePartList(const std::string & partName,std::set<std::string> &activeParts) const
{
	// if partName is already in list, just return
	if( activeParts.find(partName)!=activeParts.end() ) return;

	activeParts.insert(partName);

	// get number bop entries that produce this part
	int nProdBops;
    witGetPartNProducingBopEntries(mutableWitRun(),partName.c_str(),&nProdBops);

	// loop once for each bop 
    for ( int prodBop=0; prodBop<nProdBops; prodBop++ ) {

      // get operation name
      int bopIndex;
      char * opName;
      witGetPartProducingBopEntry(mutableWitRun(),partName.c_str(),prodBop,&opName,&bopIndex);

	  // get number of boms connected to operation
	  int nBoms;
	  witGetOperationNBomEntries(mutableWitRun(),opName,&nBoms);

	  // Loop once for each bom entries
	  for ( int bom=0; bom<nBoms; bom++ ) {
		  char * consumedPartName;
		  witGetBomEntryConsumedPart(mutableWitRun(),opName,bom,&consumedPartName);

		  // recursively call
		  updateActivePartList(consumedPartName,activeParts);
		  witFree(consumedPartName);
	  }

	  witFree(opName);
	}	
}
//-------------------------------------------------
// Try to remove cycles
//-------------------------------------------------
void ESO2problem::removeCycles()
{
  if ( !getRemoveCycles() ) return;
/*
WIT0531S The following explodeable cycle was found in the complete BOM
         structure:

WIT0532S Part part: 0000003N6612 at 980 is produced by operation part:
         0000003N6612 at 980.
         Operation part: 0000003N6612 at 980 consumes part moveablepart:
         0000003N6612 at 980.
WIT0532S Part moveablepart: 0000003N6612 at 980 is produced by operation ec:
         0000080P6949 to 0000003N6612 at 980.
         Operation ec: 0000080P6949 to 0000003N6612 at 980 consumes part part:
         0000080P6949 at 980.
WIT0532S Part part: 0000080P6949 at 980 is produced by operation part:
         0000080P6949 at 980.
         Operation part: 0000080P6949 at 980 consumes part moveablepart:
         0000080P6949 at 980.

WIT0532S Part moveablepart: 0000080P6949 at 980 is produced by operation ec:
         0000010N9534 to 0000080P6949 at 980.
         Operation ec: 0000010N9534 to 0000080P6949 at 980 consumes part part:
         0000010N9534 at 980.
WIT0532S Part part: 0000010N9534 at 980 is produced by operation part:
         0000010N9534 at 980.
         Operation part: 0000010N9534 at 980 consumes part moveablepart:
         0000010N9534 at 980.
WIT0532S Part moveablepart: 0000010N9534 at 980 is produced by operation ec:
         0000003N6612 to 0000010N9534 at 980.
         Operation ec: 0000003N6612 to 0000010N9534 at 980 consumes part part:
         0000003N6612 at 980.

WIT0533S Explodeable cycles in the complete BOM structure are not allowed.


WIT0090S WIT has encountered an error condition and is now terminating
         execution of the program.
         The return code is 3.


Produced Part: "part: 0000003N6612 at 980"
Operation:     "part: 0000003N6612 at 980"
Consumed Part: "moveablepart: 0000003N6612 at 980"

Produced Part: "moveablepart: 0000003N6612 at 980"
Operation:     "ec: 0000080P6949 to 0000003N6612 at 980"
Consumes Part: "part: 0000080P6949 at 980"

Produced Part: "part: 0000080P6949 at 980"
Operation:     "part: 0000080P6949 at 980"
Consumes Part: "moveablepart: 0000080P6949 at 980"

Produced Part: "moveablepart: 0000080P6949 at 980"
Operation:     "ec: 0000010N9534 to 0000080P6949 at 980"
Consumes Part: "part: 0000010N9534 at 980"

Produced Part: "0000010N9534 at 980"
Operation:     "part: 0000010N9534 at 980"
Consumes Part: "moveablepart: 0000010N9534 at 980"

Produced Part: "moveablepart: 0000010N9534 at 980"
Operation:     "ec: 0000003N6612 to 0000010N9534 at 980"
Consumes Part: "0000003N6612 at 980"


'part: 0000003N6612 at 980'         'part: 0000003N6612 at 980'
'moveablepart: 0000003N6612 at 980' 'ec: 0000080P6949 to 0000003N6612 at 980'
'part: 0000080P6949 at 980'         'part: 0000080P6949 at 980'
'moveablepart: 0000080P6949 at 980' 'ec: 0000010N9534 to 0000080P6949 at 980'
'part: 0000010N9534 at 980'         'part: 0000010N9534 at 980'
'moveablepart: 0000010N9534 at 980' 'ec: 0000003N6612 to 0000010N9534 at 980'
*/
  // Loop once for each cycle
  for (;;) {
    char **partNameList;
    char **operationNameList;
    int lenLists;
    witGetExpCycle( mutableWitRun(),&lenLists,&partNameList,&operationNameList);

    // if no more cycles then exit
    if ( lenLists==0 ) break;

    std::vector<std::string> altParts;
    std::vector<std::string> ecOps;
    std::cout <<std::endl <<"Cycle found: " <<std::endl;
    // Make sure cycle is a recognizabile pattern
    {
      bool expectedPattern=true;
      std::vector<std::string> partPrefix(2), opPrefix(2);
      partPrefix[0]=std::string("part: ");
      partPrefix[1]="moveablepart: ";
      opPrefix[0]="part: ";
      opPrefix[1]="ec: ";
      int startType=1;
      if ( std::string(partNameList[0]).find(partPrefix[0])==0 ) startType=0;
      for ( int i=0; i<lenLists; ++i ) {  
        //std::cout <<"  Produced Part: '" <<partNameList[i] <<"' by operation: '" <<operationNameList[i] <<"'" <<std::endl;
        
        if( std::string(partNameList[i]).find(partPrefix[(i%2)+startType])!=0 )
          expectedPattern=false;
        if( std::string(operationNameList[i]).find(opPrefix[(i%2)+startType])!=0 )
          expectedPattern=false;
        // Had better be from same location 
        if ( locFromPartName(partNameList[0]) != locFromPartName(partNameList[i]) )
          expectedPattern=false;
        if ( locFromPartName(partNameList[0]) != locFromAltName(operationNameList[i]))
          expectedPattern=false;
        
        if( std::string(partNameList[i]).find(partPrefix[0])==0 ) {
          altParts.push_back(partNameList[i]);        
          std::cout <<"  Produced Part: '" <<partNameList[i] <<std::endl;
        }
        if( std::string(operationNameList[i]).find(opPrefix[1])==0 )
          ecOps.push_back(operationNameList[i]);
          
      }
      if ( !expectedPattern )
        std::cout <<"Cycle of unrecognizable type found" <<std::endl;
      
      if(altParts.size()!=ecOps.size())
        std::cout <<"Cycle of unrecognizable type found" <<std::endl;
      if(altParts.size()*2!=lenLists)
        std::cout <<"Cycle of unrecognizable type found" <<std::endl;

      assert(altParts.size()==ecOps.size());
      assert(altParts.size()*2==lenLists);
      assert( expectedPattern );
    }

    // Create cycle breaking part
    std::string cbpn=cycleBreakingPartName(altParts);
    witAddPart(witRun(),cbpn.c_str(),WitMATERIAL);

    // Loop once for each ec operation.
    // Remove existing Bop and EC operation.
    // Create new EC Opearation and connect to cycle breaking part
    for ( int i=0; i<ecOps.size(); ++i ) {

      // Make sure only 1 bop
      int nBops;
      witGetOperationNBopEntries(mutableWitRun(),ecOps[i].c_str(),&nBops);
      assert(nBops=1);

      // create new ec operation if cycle is >2 parts
      std::string cbon;
      bool newEcOp;
      int cycBopIndex;
      if ( altParts.size()>2 ) {
        cbon=cycleBreakingOperationName(ecOps[i],altParts);
        witAddOperation(witRun(),cbon.c_str());
        witCopyOperationData(witRun(),cbon.c_str(), mutableWitRun(),ecOps[i].c_str());
        newEcOp=true;
        cycBopIndex=0;
        alts_.insert(cbon);
        alts_.erase(ecOps[i]);
      } else {
        cbon=ecOps[i];
        newEcOp=false;
        cycBopIndex=1;
      }

      //Make sure EC operation has some cost, so that it will not be an alternate optimal to using the orig part.
      std::vector<float> execCost=witGetNameAttribute(witGetOperationExecCost,cbon);
      for ( int t=0; t<execCost.size(); ++t ) {
        if (execCost[t]==0.0f) 
          execCost[t]=0.02;
      }
      witSetNameAttribute(witSetOperationExecCost,cbon,execCost);


      // Get prod rate of existing bop
      //float * prodRate;
      //witGetBopEntryProductRate(mutableWitRun(),ecOps[i].c_str(),0,&prodRate);

      // Add new bop and set attributes
      witAddBopEntry(witRun(),cbon.c_str(),cbpn.c_str());
      witCopyBopEntryData(witRun(),cbon.c_str(),cycBopIndex, mutableWitRun(),ecOps[i].c_str(),0);
 
      //witSetBopEntryProductRate(witRun(),ecOps[i].c_str(),1,prodRate);
      //witFree(prodRate);

      // Remove Operation & Bop which is part of the troublesome loop
      if ( newEcOp )
        witSetOperationSelForDel(witRun(),ecOps[i].c_str(),WitTRUE);
      witSetBopEntrySelForDel(witRun(),ecOps[i].c_str(),0,WitTRUE);
      witSetBopEntryExpAllowed(witRun(),ecOps[i].c_str(),0,WitFALSE);
      
    }

    // Loop once for each alt part in cycle
    for ( int i=0; i<altParts.size(); ++i ) {

      // Loop once for each bom consuming altParts[i]
      int numConsIndies;
      witGetPartNConsumingBomEntries(mutableWitRun(),altParts[i].c_str(),&numConsIndies);
      //std::cout <<"  " <<altParts[i] <<" used by:" <<std::endl;
      for ( int consIndex=0; consIndex<numConsIndies; ++consIndex ) {
        char * consumingOperationName;
        int bomEntryIndex;
        witGetPartConsumingBomEntry(mutableWitRun(),altParts[i].c_str(),consIndex,&consumingOperationName,&bomEntryIndex);
        std::string consOpName(consumingOperationName);
        witFree(consumingOperationName);

        if ( isAltName(consOpName) ) continue;
        //std::cout <<"    " <<consOpName <<" " <<bomEntryIndex <<std::endl;

        // Add BOM to cycleBreakingPartName
        int dupBomEntry;
        witGetOperationNBomEntries(mutableWitRun(),consOpName.c_str(),&dupBomEntry);
        witAddBomEntry(witRun(),consOpName.c_str(),cbpn.c_str());
 
        // Copy attributes to new bom Entry
        witCopyBomEntryData(witRun(),consOpName.c_str(),dupBomEntry, mutableWitRun(),consOpName.c_str(),bomEntryIndex);
      
      } // for ( int consIndex=0; consIndex<numConsIndies; ++consIndex )
  
    } //for ( int i=0; i<altParts.size(); ++i )


    // Free WIT allocated memory
    for ( int i=0; i<lenLists; ++i ) {
      witFree(partNameList[i]);
      witFree(operationNameList[i]);
    }
    witFree(partNameList);
    witFree(operationNameList);
  } //for (;;) {

  witPurgeData(witRun());

}

//-------------------------------------------------
// Prune Wit Model by removing object that will
// not participate in the solution
//-------------------------------------------------
void ESO2problem::pruneWitModel()
{
  
  // Cycles need to be removed before setting prod rates.
  removeCycles();

  // ensure prodRates are set before prunning
  setDemanBomAndFeatureXrefProdRates();

  std::set<std::string> activeParts;

  // Loop once for each demand and create set of parts
  // that can be used to satisfy the demand.
  {
    witAttr objItrState;
    witGetObjItrState(witRun(), &objItrState);
    assert(objItrState==WitINACTIVE);
    while( true )   {
      witAdvanceObjItr(witRun());
      witGetObjItrState(witRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;
      if( objItrState == WitAT_DEMAND ) {
        char * demandedPartName;
        char * demandName;
        witGetObjItrDemand(witRun(),&demandedPartName,&demandName);
        
#if 0
        // Get list of all parts used by demand
        int lenList;
        char ** belowList;
        witGetPartBelowList(witRun(),demandedPartName,&lenList,&belowList);
        int b;
        for( b=0; b<lenList; b++ ) {
          // Add part to set of activeParts
          std::string activePart(belowList[b]);
          activeParts.insert(activePart);
          witFree(belowList[b]);
        }
        witFree(belowList);
#else
		// Update set of parts that can be used to meet this demand
		updateActivePartList(demandedPartName,activeParts);
#endif
        witFree(demandedPartName);
        witFree(demandName);
      }
    }
  }

  // Remove inactive partInterplants
  {
    std::vector<std::string> parts;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getPartInterplants( parts, srcLocs, destLocs);
    int p;
    for (p=0; p<parts.size(); ++p ) {
      std::string pName = partName(parts[p],destLocs[p]);
      std::string mpName = moveablePartName(parts[p],destLocs[p]);
      std::string opName = partInterplantName(parts[p],srcLocs[p],destLocs[p]);
      //std::string srcPName = partName(parts[p],destLocs[p]);
      // If part is not active, then delete
      if( activeParts.find(mpName)==activeParts.end() ) {
        //std::cout <<"Prunning: " <<opName.c_str() <<std::endl;

        witSetPartSelForDel(witRun(),pName.c_str(),WitTRUE);
        witSetPartSelForDel(witRun(),mpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),opName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
        partInterplants_.erase(opName);

        removePartOrFeatureLoc(parts[p],destLocs[p]);
      }
    }
  }
  
  // Remove inactive featureXrefs
  {
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatureXrefs( parts, features, locs);
    int p;
    for (p=0; p<parts.size(); ++p ) {
      std::string pName = partName(parts[p],locs[p]);
      std::string mpName = moveablePartName(parts[p],locs[p]);
      std::string opName = featureXrefName(parts[p],features[p],locs[p]);
      // If part is not active, then delete
      if( activeParts.find(mpName)==activeParts.end() ) {
        //std::cout <<"Prunning: " <<pName.c_str() <<std::endl;

        witSetPartSelForDel(witRun(),pName.c_str(),WitTRUE);
        witSetPartSelForDel(witRun(),mpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),opName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
        xrefFeatures_.erase(opName);

        removePartOrFeatureLoc(parts[p],locs[p]);
      }
    }
  }
  
  // Remove inactive looseParts
  {
    std::vector<std::string> parts;
    std::vector<std::string> locs;
    getLooseParts( parts, locs);
    int p;
    for (p=0; p<parts.size(); ++p ) {
      std::string pName = partName(parts[p],locs[p]);
      std::string mpName = moveablePartName(parts[p],locs[p]);
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
      std::string igfPName = igfLoosePartName(parts[p],locs[p]);
      std::string baseName = baseLoosePartName(parts[p],locs[p]);
      // If part is not active, then delete
      if( activeParts.find(mpName)==activeParts.end() ) {
        //std::cout <<"Prunning: " <<pName.c_str() <<std::endl;

        witSetPartSelForDel(witRun(),pName.c_str(),WitTRUE);
        witSetPartSelForDel(witRun(),mpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),opName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
        assert( activeParts.find(igfPName)==activeParts.end() );
        witSetPartSelForDel(witRun(),igfPName.c_str(),WitTRUE);
        loosePartNames_.erase(baseName);

        removePartOrFeatureLoc(parts[p],locs[p]);
      }
    }
  }
   
  // Remove inactive features
  {
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatures( features, locs);
    int p;
    for (p=0; p<features.size(); ++p ) {
      std::string pName = partName(features[p],locs[p]);
      std::string mpName = moveablePartName(features[p],locs[p]);
      std::string opName = acquireFeatureName(features[p],locs[p]);
      std::string igfFName = igfFeatureName(features[p],locs[p]);
      std::string baseName = baseFeatureName(features[p],locs[p]);
      // If part is not active, then delete
      if( activeParts.find(mpName)==activeParts.end() ) {
        //std::cout <<"Prunning: " <<pName.c_str() <<std::endl;

        witSetPartSelForDel(witRun(),pName.c_str(),WitTRUE);
        witSetPartSelForDel(witRun(),mpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),opName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
        assert( activeParts.find(igfFName)==activeParts.end() );
        witSetPartSelForDel(witRun(),igfFName.c_str(),WitTRUE);
        featureNames_.erase(baseName);

        removePartOrFeatureLoc(features[p],locs[p]);
      }
    }
  }

#if 1
     
  // Remove inactive alts
  {
    std::vector<std::string> partOrFeatures;
    std::vector<std::string> altParts;
    std::vector<std::string> locs;
    getAlts( partOrFeatures, altParts, locs);
    int p;
    for (p=0; p<partOrFeatures.size(); ++p ) {
      
      std::string ecOpName = altName(partOrFeatures[p],altParts[p],locs[p]);   
      std::string upLevelPartName = partName(altParts[p],locs[p]); 
      std::string moveableUpLevelPartName = moveablePartName(altParts[p],locs[p]); 
      std::string downLevelPartName = partName(partOrFeatures[p],locs[p]);

      // If part is not active, then delete
      if( activeParts.find(upLevelPartName)==activeParts.end() ) {

        // Due the the cycle removing code upLevelPartName may be a pseudo part that represents
        // more than one part and may not be in the wit model.
        witBoolean partExists;
        witGetPartExists(mutableWitRun(),upLevelPartName.c_str(),&partExists);
        if ( partExists ) {
          //std::cout <<"Prunning: " <<upLevelPartName.c_str() <<std::endl;

          witSetPartSelForDel(witRun(),upLevelPartName.c_str(),WitTRUE);
 
          witSetOperationSelForDel(witRun(),upLevelPartName.c_str(),WitTRUE);

          removePartOrFeatureLoc(altParts[p],locs[p]);
        }
      }
    }
  }
#endif
   
  // Remove inactive mtm interplants
  {
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms, srcLocs, destLocs );
    int p;
    for (p=0; p<mtms.size(); ++p ) {
      if (srcLocs[p] == destLocs[p] ) continue;
      std::string igfPName = igfMtmName(mtms[p],srcLocs[p] );
      std::string acquireOpName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string serverPName = serverMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string baseName = baseMtmName(mtms[p],srcLocs[p] );
      // If part is not active, then delete
      if( activeParts.find(serverPName)==activeParts.end() ) { 
        //std::cout <<"Prunning: " <<demanOpName.c_str() <<std::endl;

        witSetPartSelForDel(witRun(),serverPName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),acquireOpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),demanOpName.c_str(),WitTRUE);
        // Delete all parts birthed in demanufacturing
        int nBops;
        witGetOperationNBopEntries(witRun(),demanOpName.c_str(),&nBops);
        int b;
        for (b=0; b<nBops; ++b) {
          char * moveableProducedPart;
          witGetBopEntryProducedPart(witRun(),demanOpName.c_str(),b,&moveableProducedPart);

          //fprintf(pruneF,"witSetPartSelForDel\n%s\n",moveableProducedPart);
          witSetPartSelForDel(witRun(),moveableProducedPart,WitTRUE);

          char *op;
          int bei;
          witGetPartConsumingBomEntry(witRun(),moveableProducedPart,0,&op,&bei);
          assert(bei==0);

          //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",op);
          witSetOperationSelForDel(witRun(),op,WitTRUE);   
          
          char * producedPart;
          witGetBopEntryProducedPart(witRun(),op,0,&producedPart);   
          //std::cout <<"Prunning: " <<producedPart <<std::endl;  
          
          witSetPartSelForDel(witRun(),producedPart,WitTRUE);

          assert(strcmp(op,producedPart)==0);
          witFree(op);
          witFree(producedPart);
          witFree(moveableProducedPart);
        }
        //if (srcLocs[p] != destLocs[p] ) {
          assert(mtmAcquireExists(baseName));
          assert(mtmAcquireLocs_[baseName].find(destLocs[p]) != mtmAcquireLocs_[baseName].end() );
          mtmAcquireLocs_[baseName].erase(destLocs[p]);
          if ( mtmAcquireLocs_[baseName].size() ==  0 ) {
            mtmAcquireLocs_.erase(baseName);
          }
        //}
        //else {
        //  // Is igf mtm inactive?
        //  if ( activeParts.find(igfPName)==activeParts.end() ) {
        //    witSetPartSelForDel(witRun(),igfPName.c_str(),WitTRUE);
        //    mtmNames_.erase(baseName);
        //  }
        //}
      }
    }
  }
  
  //std::cout <<"Calling witPurgeData" <<std::endl;
  witPurgeData(witRun());  
  //std::cout <<"Returned from calling witPurgeData" <<std::endl;
  

#if 0
  // Loop for each part and delete any part that is inactive
  {
    witAttr objItrState;
    witGetObjItrState(witRun(), &objItrState);
    assert(objItrState==WitINACTIVE);
    while( true )   {
      witAdvanceObjItr(witRun());
      witGetObjItrState(witRun(), &objItrState);
      if (objItrState==WitINACTIVE) break;

      if( objItrState == WitAT_PART ) {
        char * partName;
        witGetObjItrPart(witRun(),&partName);
        
        // If part is not active, then delete
        if( activeParts.find(partName)==activeParts.end() ) {
          std::cout <<"Inactive part: " <<partName <<std::endl;
          //witSetPartSelForDel(witRun(),partName,WitTRUE);
        }
        witFree(partName);
      }
      
      if( objItrState == WitAT_OPERATION ) {
        char * opName;
        witGetObjItrOperation(witRun(),&opName);
        
        int nBops;
        witGetOperationNBopEntries(witRun(),opName,&nBops);
        
        int nBoms;
        witGetOperationNBomEntries(witRun(),opName,&nBoms);

        if( nBops==0 || nBoms==0 ) {
          std::cout <<"Inactive Op: " <<opName <<std::endl;
          //witSetOperationSelForDel(witRun(),opName,WitTRUE);
        }
        
        witFree(opName);
      }
    }
    //witPurgeData(witRun());
  }

  
  std::cout "Completed pruning unused objects from model" <<std::endl;

#endif
}

// Set wit bounds and ensure that hlb<=slb<=hub
// This condition is not being met.
void ESO2problem::setExecBounds(
                                const std::string opName,
                                std::vector<float> hlb,
                                std::vector<float> slb,
                                std::vector<float> hub )
{
  CoinRelFltEq eq(1.e-7);
  int np = getNPeriods();
  int p;
  for (p=0; p<np; ++p) {
    if( eq( hlb[p],slb[p] ) ) slb[p] = hlb[p];
    if( eq( slb[p],hub[p] ) ) hub[p] = slb[p];
  }
  witSetNameBoundAttribute(witSetOperationExecBounds,opName, hlb,slb,hub);
}
//-------------------------------------------------
// Optimization methods
//-------------------------------------------------
void ESO2problem::solve()
{

  //writeWitData("eso2.wit");

  std::vector<float> zeroTv = floatToStlVec(0.0f);
  std::vector<float> nullTv;
  std::vector<float> infinityTv = floatToStlVec(FLT_MAX);


  // set scrapCost on parts produced from demanufacturing to be zero
  // This is so that mtm can be demanufactured and the resulting parts scrapped 
  // without penalty
#if 0
  std::vector<std::string> mtms,srcLocs,demanLocs;
  getMtmDemanLocs(mtms,srcLocs,demanLocs);
  int msdTriple;
  for (msdTriple=0; msdTriple<mtms.size(); msdTriple++) {
    std::vector<std::string> prodParts = getDemanBoms(mtms[msdTriple],srcLocs[msdTriple],demanLocs[msdTriple]);
    int pp;
    for ( pp=0; pp<prodParts.size(); pp++ ) {
      std::string pName = partName(prodParts[pp], demanLocs[msdTriple] );
      std::string moveablePName = moveablePartName(prodParts[pp], demanLocs[msdTriple] );
      witSetNameAttribute(witSetPartObj1ScrapCost,pName.c_str(),0.0f);
      witSetNameAttribute(witSetPartObj1ScrapCost,moveablePName.c_str(),0.0f);
    }
  }
#endif

  // set demanProdRates from attachRates
  setDemanBomAndFeatureXrefProdRates();
  //pruneWitModel();

  // Turn off all demands and set obj1ShipReward to Wac*wacScaleFactor
  {
    std::vector<std::string> parts, custLocs, plantLocs;
    getPartDemands( parts, custLocs, plantLocs );
    
    // loop once for each demand and set associated operations upper Exec Bounds to zero
    int d;
    for (d=0; d<parts.size(); ++d ) {
      std::string dName = partDemandName(parts[d],custLocs[d],plantLocs[d]);
      std::string inventoryName = partDemandInventoryName(parts[d],custLocs[d],plantLocs[d]);
      witSetNameBoundAttribute(witSetOperationExecBounds,dName, zeroTv,zeroTv,zeroTv);
      std::vector<float> scaledWac = getPartDemandScaledWac(parts[d],custLocs[d],plantLocs[d]);
      witSetDemandAttribute(witSetDemandObj1ShipReward, dName, dName, scaledWac);
      if ( getAllowInventoryHoldingAtDemandLocation() ) {
        float * inventCost = new float [getNPeriods()];
        for ( int t=0; t<getNPeriods(); ++t )
          inventCost[t] = scaledWac[t] * 0.000001;
        witSetPartStockCost(witRun(),inventoryName.c_str(),inventCost);
        delete [] inventCost;
      }
    } // end of (d=0; d<parts.size(); ++d )
  } // end of Turn off all demands

  //xx--------------------------------------------
  //set operations execBounds Hard Upper Bound to zero.
  //set execVol to zero
  //xx--------------------------------------------
  {  
    
    // update wfmv and execBounds for mtms
    { 
      std::vector<std::string> mtms;
      std::vector<std::string> plantLocs;
      getMtms(mtms,plantLocs);
      
      // loop once for each mtm
      int m;
      for ( m=0; m<mtms.size(); m++ ) {
        std::vector<float> wfmvVec = getMtmWfmv(mtms[m],plantLocs[m]);          
        std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );         
        std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
        
        witSetNameAttribute(witSetOperationExecVol,acquireOpName, zeroTv); 
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv); 
        
        // are there any locations that this mtm is moved to?
        if ( mtmAcquireExists(mtmBName) ) {
          
          // Get all locations that this mtm can be moved to
          const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
          
          // Loop once for each location this mtm can be moved to
          std::set<std::string>::const_iterator locIt;
          for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
            const std::string & destLoc = *locIt;
            std::vector<float> moveCost = getMtmInterplantMoveCost(mtms[m],plantLocs[m],destLoc);
            
            std::string acquireMtmWitName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,acquireMtmWitName,0);
                       
            std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
            witSetNameAttribute(witSetOperationExecVol,acquireAndMoveOpName, zeroTv); 
            witSetNameBoundAttribute(witSetOperationExecBounds,acquireAndMoveOpName, zeroTv,zeroTv,zeroTv);
            
          } // end of locIt loop
          
        } // end of if (mtmAcquireExists(baseMtmName))
        
      } // end of loop m
      
    } // end of update for mtms
    
    // update execBounds for features
    {
      std::vector<std::string> features;
      std::vector<std::string> featureLocs;
      getFeatures(features,featureLocs);
      
      // loop once for each feature
      int f;
      for ( f=0; f<features.size(); f++ ) {
        std::vector<float> wfmvVec = getFeatureWfmv(features[f],featureLocs[f]);          
        std::string featureName = baseFeatureName(features[f],featureLocs[f] );         
        std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );
        
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv);       
        
      } // end of loop f
      
    } // end of update for features
    
    
    // update execBounds for looseParts
    {
      std::vector<std::string> looseParts;
      std::vector<std::string> loosePartLocs;
      getLooseParts(looseParts,loosePartLocs);
      
      // loop once for each loosePart
      int l;
      for ( l=0; l<looseParts.size(); l++ ) {
        std::vector<float> wfmvVec = getLoosePartWfmv(looseParts[l],loosePartLocs[l]);          
        std::string loosePartName = baseLoosePartName(looseParts[l],loosePartLocs[l] );         
        std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );
        
        witSetNameAttribute(witSetOperationExecVol,acquireOpName, zeroTv); 
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv);           
        
      } // end of loop l
      
    } // end of update for looseParts
  } // finished setting obj1ExecCost and execBounds
 
  
  //xx--------------------------------------------
  // finished setting operations execBounds Hard Upper Bound to zero.
  //xx--------------------------------------------
  
  // Loop once for each demand priority
  int dp;
  for ( dp=0; dp<2; ++dp ) {

  // Set obj1ExecCost of mtm, feature, and loosePart acquire operations 
  // to wfmv * wfmvScaleFactor.
  {    
    
    // update wfmv for mtms
    { 
      std::vector<std::string> mtms;
      std::vector<std::string> plantLocs;
      getMtms(mtms,plantLocs);
      
      // loop once for each mtm
      int m;
      for ( m=0; m<mtms.size(); m++ ) {
        std::vector<float> wfmvVec = getMtmWfmv(mtms[m],plantLocs[m]);          
        std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );         
        std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
        
        float scaleFactor = getWfmvScaleFactor(dp);
        // If applying scale factor by location and location is not specified then use zero
        if ( getUseApplyScaleFactorLoc() && !getApplyLocWfmvScaleFactor(plantLocs[m],dp) ) scaleFactor = 0.0;
        
        // Set wfmv for aquiring mtm at its src location (without moving it)
        std::vector<float> scaledWfmvVec = wfmvVec;
        int p;
        for ( p=0; p<wfmvVec.size(); ++p ) {
          if ( useMtmPerishableSupply(mtms[m],plantLocs[m],plantLocs[m],p) ) {
            scaledWfmvVec[p] = scaleFactor*wfmvVec[0];
          }
          else {
            scaledWfmvVec[p] = scaleFactor*wfmvVec[p];
          }
        }
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, scaledWfmvVec); 
        
        // are there any locations that this mtm is moved to?
        if ( mtmAcquireExists(mtmBName) ) {
          
          // Get all locations that this mtm can be moved to
          const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
          
          // Loop once for each location this mtm can be moved to
          std::set<std::string>::const_iterator locIt;
          for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
            const std::string & destLoc = *locIt;
            std::vector<float> moveCost = getMtmInterplantMoveCost(mtms[m],plantLocs[m],destLoc);
            
            std::string acquireMtmWitName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,acquireMtmWitName,0);
            
            // compute execCost. this is scaleFactor*wfmv + moveCost
            std::vector<float> scaledWfmvWithMoveCostVec = wfmvVec;
            for( p=0; p<moveCost.size(); ++p ) {
              if ( impPer[p]==-1 )
                scaledWfmvWithMoveCostVec[p] = ESO2problem::bigM();
              else
                if ( useMtmPerishableSupply(mtms[m],plantLocs[m],destLoc,p) ) {
                  scaledWfmvWithMoveCostVec[p] = scaleFactor*wfmvVec[0] + moveCost[p];
                }
                else {
                  scaledWfmvWithMoveCostVec[p] = scaleFactor*wfmvVec[impPer[p]] + moveCost[p];
                }
            }
            
            std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
            witSetNameAttribute(witSetOperationObj1ExecCost,acquireAndMoveOpName, scaledWfmvWithMoveCostVec);
            
          } // end of locIt loop
          
        } // end of if (mtmAcquireExists(baseMtmName))
        
      } // end of loop m
      
    } // end of update wfmv for mtms
    
    // update wfmv for features
    {
      std::vector<std::string> features;
      std::vector<std::string> featureLocs;
      getFeatures(features,featureLocs);
      
      // loop once for each feature
      int f;
      for ( f=0; f<features.size(); f++ ) {
        std::vector<float> wfmvVec = getFeatureWfmv(features[f],featureLocs[f]);          
        std::string featureName = baseFeatureName(features[f],featureLocs[f] );         
        std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );

        float scaleFactor = getWfmvScaleFactor(dp);
        // If applying scale factor by location and location is not specified then use zero
        if ( getUseApplyScaleFactorLoc() && !getApplyLocWfmvScaleFactor(featureLocs[f],dp) ) scaleFactor = 0.0;
               
        // Set wfmv for aquiring feature
        int p;
        for ( p=0; p<wfmvVec.size(); ++p ) {
          if ( useFeaturePerishableSupply(features[f],featureLocs[f],p) ) {
            wfmvVec[p] = scaleFactor*wfmvVec[0];
          }
          else {
            wfmvVec[p] = scaleFactor*wfmvVec[p];
          }
        }
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);       
        
      } // end of loop f
      
    } // end of update wfmv for features
    
    
    // update wfmv for looseParts
    {
      std::vector<std::string> looseParts;
      std::vector<std::string> loosePartLocs;
      getLooseParts(looseParts,loosePartLocs);
      
      // loop once for each loosePart
      int l;
      for ( l=0; l<looseParts.size(); l++ ) {
        std::vector<float> wfmvVec = getLoosePartWfmv(looseParts[l],loosePartLocs[l]);          
        std::string loosePartName = baseLoosePartName(looseParts[l],loosePartLocs[l] );         
        std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );
        
        float scaleFactor = getWfmvScaleFactor(dp);
        // If applying scale factor by location and location is not specified then use zero
        if ( getUseApplyScaleFactorLoc() && !getApplyLocWfmvScaleFactor(loosePartLocs[l],dp) ) scaleFactor = 0.0;
        
        
        // Set wfmv for aquiring loosePart
        int p;
        for ( p=0; p<wfmvVec.size(); ++p ) {
          if ( useLoosePartPerishableSupply(looseParts[l],loosePartLocs[l],p) ) {
            wfmvVec[p] = scaleFactor*wfmvVec[0];
          }
          else {
            wfmvVec[p] = scaleFactor*wfmvVec[p];
          }
        }
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);       
        
      } // end of loop l
      
    } // end of update wfmv for looseParts
  } // finished setting obj1ExecCost and execBounds



  
    
    // Turn on demands with demand priority equal to dp.
    // Set lower bound on all demands with demand priority <dp.
    {
      std::vector<std::string> parts, custLocs, plantLocs;
      getPartDemands( parts, custLocs, plantLocs );
      
      // loop once for each demand and set associated operations upper Exec Bounds to zero
      int d;
      for (d=0; d<parts.size(); ++d ) {
        std::string dName = partDemandName(parts[d],custLocs[d],plantLocs[d]);
        int demandPriority = getPartDemandPriority(parts[d],custLocs[d],plantLocs[d]);
        std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,dName);
        std::vector<float> execHub;
        if (demandPriority<=dp) execHub = infinityTv;
        else  execHub = execSlb;
        //witSetNameBoundAttribute(witSetOperationExecBounds,dName, zeroTv,execSlb,execHub);
        setExecBounds(dName,zeroTv,execSlb,execHub);
      } // end of (d=0; d<parts.size(); ++d )
    } // end of Turn on demand with priority eqaul to dp
    
    // Loop once for each supply priority
    int p;
    for ( p=1; p<4; ++p ) {
      
      // update execBounds for mtms
      { 
        std::vector<std::string> mtms;
        std::vector<std::string> plantLocs;
        getMtms(mtms,plantLocs);
        
        // loop once for each mtm
        int m;
        for ( m=0; m<mtms.size(); m++ ) {           
          std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );    
          std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
          // Get execVol and set to softLower bound
          std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
          std::vector<float> execHub;
          if (getMtmPriority(dp)<=p) execHub = infinityTv;
          else  execHub = execSlb;
          //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub);  
          setExecBounds(acquireOpName, zeroTv,execSlb,execHub);  
          
          // are there any locations that this mtm is moved to?
          if ( mtmAcquireExists(mtmBName) ) {
            // Get all locations that this mtm can be moved to
            const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
            // Loop once for each location this mtm can be moved to
            std::set<std::string>::const_iterator locIt;
            for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
              const std::string & destLoc = *locIt;
              std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );       
              // Get execVol and set to softLower bound
              std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireAndMoveOpName);
              std::vector<float> execHub;
              if (getMtmPriority(dp)<=p) execHub = infinityTv;
              else  execHub = execSlb;
              //witSetNameBoundAttribute(witSetOperationExecBounds,acquireAndMoveOpName, zeroTv,execSlb,execHub);
              setExecBounds(acquireAndMoveOpName, zeroTv,execSlb,execHub);            
            } // end of locIt loop
          } // end of if (mtmAcquireExists(baseMtmName))
        } // end of loop m      
      } // end of update execBounds for mtms
      
      // update execBounds for features
      {
        std::vector<std::string> features;
        std::vector<std::string> featureLocs;
        getFeatures(features,featureLocs);
        
        // loop once for each feature
        int f;
        for ( f=0; f<features.size(); f++ ) {      
          std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );        
          // Get execVol and set to softLower bound
          std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
          std::vector<float> execHub;
          if (getFeaturePriority(dp)<=p) execHub = infinityTv;
          else  execHub = execSlb;
          //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub); 
          setExecBounds(acquireOpName, zeroTv,execSlb,execHub);            
        } // end of loop f      
      } // end of update execBounds for features
      
      
      // update execBounds for looseParts
      {
        std::vector<std::string> looseParts;
        std::vector<std::string> loosePartLocs;
        getLooseParts(looseParts,loosePartLocs);
        
        // loop once for each loosePart
        int l;
        for ( l=0; l<looseParts.size(); l++ ) {            
          std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );  
          // Get execVol and set to softLower bound
          std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
          std::vector<float> execHub;
          if (getLoosePartPriority(dp)<=p) execHub = infinityTv;
          else  execHub = execSlb;
          //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub); 
          setExecBounds(acquireOpName, zeroTv,execSlb,execHub);                       
        } // end of loop l
      } // end of update execBounds for looseParts
      
#if 0
      // Write wit data file before invoking witOptImplode
      {
        char asChar[100];
        sprintf(asChar,"%d",implosionCount());
        std::string witDataFileName = std::string("implode")+std::string(asChar)+".wit";
        writeWitData(witDataFileName);
      }
#endif
      
      std::cout <<"Calling witOptImplode" <<std::endl;
      witOptImplode (witRun());
      implosionCount_++;
      std::cout <<"Returned from witOptImplode call" <<std::endl;
      //reportPartDemand("p2","pok","pok",0);
    } // end of p loop for each supply priority
  } // end of dp loop for each demand priority

  witBoolean postProcessed; 
  witGetPostprocessed(mutableWitRun(),&postProcessed);
  assert(postProcessed);

}

void ESO2problem::solveWithPegging() {
  std::cout <<"entered: ESO2problem::solveWithPegging()" <<std::endl;
  solve();
  doPegging();
}

//-------------------------------------------------
// Do pegging
//-------------------------------------------------
void ESO2problem::doPegging() {


#if 0
  // Is it only deman ops that have multiple bops?
  // Tests show that only demanOps have multiple bops
  {
    // Get all wit operations
    int nOps;
    char ** ops;
    witGetOperations(mutableWitRun(),&nOps,&ops);
    int o;
    for ( o=0; o<nOps; ++o ) {
      int nBops;
      witGetOperationNBopEntries(mutableWitRun(),ops[o],&nBops);
      if ( nBops> 1 ) 
        assert( isMtmDemanName(ops[o]) );
      witFree(ops[o]);
    }
    witFree(ops);
  }
#endif

  // Label depth of Wit Objects to determine order that they are performed.
  // This is important when they are done in the same period
  std::map<std::string,int> operationDepths;
  std::map<std::string,int> partDepths;
  labelObjectDepth(operationDepths,partDepths);


  // clear pegging info in partDemand appData which may be laying around from a prior call to solve
  {
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    getPartDemands( parts, custLocs, plantLocs);
    int p;
    for (p=0; p<parts.size(); ++p ) { 
      ESO2partDemandAppData * srcAppData;  
      std::string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
      witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&srcAppData);
      srcAppData->clearPegging();
    }
  }


  witBoolean postProcessed;
  witGetPostprocessed(mutableWitRun(),&postProcessed);
  assert(postProcessed);


  // Set the PIP sequence
  std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple> demandSet;
  {
    witClearPipSeq(witRun());

    // Loop once for each demanded part
    std::vector<std::string> demdParts, demdCustLocs, demdPlantLocs;
    getPartDemands( demdParts, demdCustLocs, demdPlantLocs );
    int d;
    for ( d=0; d<demdParts.size(); ++d ) {

      std::string dName = partDemandName(demdParts[d], demdCustLocs[d], demdPlantLocs[d] );
      std::vector<float> shipVol = witGetDemandAttribute(witGetDemandShipVol,dName,dName);
      std::vector<float> shipReward = witGetDemandAttribute(witGetDemandObj1ShipReward,dName,dName);

      // Loop once for each period
      int t;
      for ( t=0; t<shipVol.size(); ++t ) {
        if ( shipVol[t]>0.0 ) {
          // Determine value of this shipment
          float value = shipVol[t] * shipReward[t];

          // determine pip sequence by inserting demand in sorted list
          ESO2pipSequenceTriple seq(dName.c_str(),t,shipVol[t],value);
          demandSet.insert(seq);
        }
      } // end loop for each perid t
    } // end loop for each demanded part d


    // Loop through each pipSequenceTriple and add them to the pip sequence
    std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple>::const_iterator it;
    int nInserted = 0;
    for (it=demandSet.begin(); it!=demandSet.end(); ++it ) {
      std::string dn = it->getDemandName();
      int sp = it->getShipPeriod();
      float isv = it->getIncShipVol();
      float v = it->getValue();
      witAppendToPipSeq(witRun(),dn.c_str(),dn.c_str(),sp,isv);
      nInserted++;
    }
    assert( nInserted==demandSet.size() );
  } // end setting the PIP sequence

  // Have WIT compute pegging
  witBuildPip(witRun());

  // Extract pegging and store in member data 
  {     
    // Loop through each pipSequenceTriple 
    std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple>::const_iterator it;
    for (it=demandSet.begin(); it!=demandSet.end(); ++it ) {
      std::string dn = it->getDemandName();
      int sp = it->getShipPeriod();
      float isv = it->getIncShipVol();
      ESO2partDemandAppData * appDataPtr;
      witGetDemandAppData(mutableWitRun(),dn.c_str(),dn.c_str(),(void**)&appDataPtr);
      std::string plantLoc = plantLocFromPartDemandName(dn);

      // Since birthed parts can have multiple bops producing them, we need to 
      // ensure that these produced parts are only pegged once
      std::set< std::string > peggedDemanPart;

      // Get operations pegged to demand
      {
        int nOps;
        char ** ops;
        int * execPeriods;
        float * execVols;
        witGetDemandExecVolPip(mutableWitRun(),
          dn.c_str(),dn.c_str(),sp,
          &nOps,&ops,&execPeriods,&execVols);  

        // get produced parts pegged to demand
        std::map<std::string,std::vector<std::pair<int,float> > > peggedProdParts;
        {
          int nProdParts;
          char ** prodParts;
          int * prodPeriods;
          float * prodVols;
          /*witGetDemandExecVolPip*/witGetDemandProdVolPip(mutableWitRun(),
            dn.c_str(),dn.c_str(),sp,
            &nProdParts,&prodParts,&prodPeriods,&prodVols);
          for (int pp=0; pp<nProdParts; ++pp) {
            std::string prodPart(prodParts[pp]);
            std::pair<int,float> periodVolPair(prodPeriods[pp],prodVols[pp]);
            peggedProdParts[prodPart].push_back(periodVolPair);
            witFree(prodParts[pp]);
          }
          witFree(prodParts);
          witFree(prodPeriods);
          witFree(prodVols);
        }

        // loop once for each pegged operation
        int o;
        for ( o=0; o<nOps; ++o ) {
          if ( isAcquireMtmName(ops[o]) ) {  

            std::string mtm = mtmFromMtmName(ops[o]);
            std::string srcLoc = mtmSrcLocFromMtmName(ops[o]);
            std::string destLoc = mtmDestLocFromMtmName(ops[o]);
            // Need to shift period by acquire time.
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
            int shiftedPeriod = impPer[execPeriods[o]];
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("MtmAcquire",sp,mtm,srcLoc,shiftedPeriod,depth+0,execVols[o]); 
            appDataPtr->addPeggedItem("MtmMoveFrom",sp,mtm,srcLoc,shiftedPeriod,depth+1,execVols[o]); 
            appDataPtr->addPeggedItem("MtmMovedTo",sp,mtm,destLoc,execPeriods[o],depth+2,execVols[o]);         
          }
          else if ( isMtmDemanName(ops[o] ) ) {
            std::string mtm = mtmFromMtmName(ops[o]);
            std::string loc = mtmDestLocFromMtmName(ops[o]);
            // Need to shift period by deman time.
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
            int shiftedPeriod = impPer[execPeriods[o]];
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("MtmDisassemble",sp,mtm,loc,shiftedPeriod,depth,execVols[o]);

            // loop once for each Bop to find the pegged birthed part
            int nBops;
            witGetOperationNBopEntries(mutableWitRun(),ops[o],&nBops);
            for ( int b=0; b<nBops; ++b ) {
              // Get bops produced part
              char * witProdPart;
              witGetBopEntryProducedPart(mutableWitRun(),ops[o],b,&witProdPart);
              std::string prodPart = partFromPartName(witProdPart);
              std::string witProdPartAsStlString(witProdPart);
              witFree(witProdPart);

              // is current demand pegged to this produced part? If not, continue.
              if ( peggedProdParts.find(witProdPartAsStlString)==peggedProdParts.end() ) 
                continue;

              // has this produced part already been pegged to the current demand
              if ( peggedDemanPart.find(witProdPartAsStlString)!=peggedDemanPart.end() ) 
                continue;
              peggedDemanPart.insert(witProdPartAsStlString);

              // record produced part pegging in demand app data
              const std::vector<std::pair<int,float> > & vectorPeriodProdvolPairs =  peggedProdParts.find(witProdPartAsStlString)->second;
              for ( size_t ppp=0; ppp<vectorPeriodProdvolPairs.size(); ++ppp ) {
                int prodPeriod = vectorPeriodProdvolPairs[ppp].first;
                float prodVol = vectorPeriodProdvolPairs[ppp].second;
                appDataPtr->addPeggedItem("PartHarvestedFromMtm",sp,prodPart,loc,prodPeriod,depth+1,prodVol);
              }
            } // end of loop b for each bop
          }
          else if ( isAcquireFeatureName(ops[o]) ) {
            std::string feature = featureFromFeatureName(ops[o]);
            std::string loc = locFromFeatureName(ops[o]);              
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("FeatureAcquire",sp,feature,loc,execPeriods[o],depth,execVols[o]);
          }
          else if ( isFeatureXrefName(ops[o]) ) {
            std::string feature = featureFromFeatureXrefName(ops[o]);
            std::string loc = locFromFeatureXrefName(ops[o]);
            std::string part = partFromFeatureXrefName(ops[o]);
            // Need to shift period by xref time.
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
            int shiftedPeriod = impPer[execPeriods[o]];
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("FeatureXrefFrom",sp,feature,loc,shiftedPeriod,depth,execVols[o]);
            appDataPtr->addPeggedItem("PartXrefedTo",sp,part,loc,execPeriods[o],depth+1,execVols[o]);
          }
          else if ( isAcquireLoosePartName(ops[o]) ) {
            std::string lp = loosePartFromLoosePartName(ops[o]);
            std::string loc = locFromLoosePartName(ops[o]);
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("LoosePartAcquire",sp,lp,loc,execPeriods[o],depth,execVols[o]);
          }
          else if ( isAltName(ops[o]) ) {
            std::string fromPart = partFromAltName(ops[o]);
            std::string toPart = altPartFromAltName(ops[o]);
            std::string loc = locFromAltName(ops[o]);
            // Need to shift period by alt time.
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
            int shiftedPeriod = impPer[execPeriods[o]];
            int depth = operationDepths[ops[o]];
            appDataPtr->addPeggedItem("PartAltFrom",sp,fromPart,loc,shiftedPeriod,depth,execVols[o]);
            appDataPtr->addPeggedItem("PartAltTo",sp,toPart,loc,execPeriods[o],depth+1,execVols[o]);
          }
          else if ( isPartInterplantName(ops[o]) ) {
            std::string part = partFromPartInterplantName(ops[o]);
            std::string srcLoc = srcLocFromPartInterplantName(ops[o]);
            std::string destLoc = destLocFromPartInterplantName(ops[o]);
            // Need to shift period by acquire time.
            std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
            int shiftedPeriod = impPer[execPeriods[o]];
            bool skip=false;
            if ( 
              sp==shiftedPeriod &&
              sp==execPeriods[o] &&
              plantLoc == srcLoc &&
              plantLoc == destLoc ) 
              skip=true;
            if ( !skip ) {
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("PartMoveFrom",sp,part,srcLoc,shiftedPeriod,depth,execVols[o]); 
              appDataPtr->addPeggedItem("PartMovedTo",sp,part,destLoc,execPeriods[o],depth+1,execVols[o]);   
            }
          }
          witFree(ops[o]);
        }
        witFree(ops);
        witFree(execPeriods);
        witFree(execVols);
      } // end Get pegged operations
    } // end Loop through each pipSequenceTriple 
  }  // end Extract pegging and store in member data 

} // end Do pegging


//-------------------------------------------------------------------------
// mtm Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::igfMtmName(const std::string & mtm,const std::string & mtmSrcLoc )
{
  return "igf: "+baseMtmName(mtm,mtmSrcLoc);
}
std::string ESO2problem::acquireMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc )
{
  return "acquire: "+baseMtmName(mtm,destLoc)+" from: "+mtmSrcLoc;
}
std::string ESO2problem::serverMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc )
{
  return "server: "+baseMtmName(mtm,destLoc)+" from: "+mtmSrcLoc;
}
std::string ESO2problem::demanMtmName(const std::string & mtm,const std::string & mtmSrcLoc,const std::string & destLoc )
{
  return "deman: "+baseMtmName(mtm,destLoc)+" from: "+mtmSrcLoc;
}
std::string ESO2problem::baseMtmName(const std::string & mtm,const std::string & mtmDestLoc )
{
  return "mtm "+mtm+" at "+mtmDestLoc;
}
std::string ESO2problem::mtmFromMtmName(const std::string & mtmName)
{  
  return textBetween(mtmName,"mtm "," at ");
}
std::string ESO2problem::mtmDestLocFromMtmName(const std::string & mtmName)
{ 
  std::string retVal;
  if ( contains(mtmName," from: ") ) {
    retVal = textBetween(mtmName," at "," from: ");
  }
  else {
    retVal = textAfter(mtmName," at ");
  }
  return retVal;
}
std::string ESO2problem::mtmSrcLocFromMtmName(const std::string & mtmName)
{  
  return textAfter(mtmName," from: ");
}
bool ESO2problem::isMtmDemanName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"deman: ");
  bool hasFromText = contains(witName," from: ");
  bool retVal = false;
  if ( correctPrefix && hasFromText ) retVal = true;
  return retVal;
}
bool ESO2problem::isAcquireMtmName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"acquire: ");
  bool hasFromText = contains(witName," from: ");
  bool retVal = false;
  if ( correctPrefix && hasFromText ) retVal = true;
  return retVal;
}

//-------------------------------------------------------------------------
// feature Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::igfFeatureName(const std::string & feature,const std::string & loc )
{
  return "igf: "+baseFeatureName(feature,loc);
}
std::string ESO2problem::acquireFeatureName(const std::string & feature,const std::string & loc )
{
  return "acquire: "+baseFeatureName(feature,loc);
}
std::string ESO2problem::baseFeatureName(const std::string & feature,const std::string & loc )
{
  return "feature "+feature+" at "+loc;
}
std::string ESO2problem::featureFromFeatureName(const std::string & featureName)
{  
  return textBetween(featureName,"feature "," at ");
}
std::string ESO2problem::locFromFeatureName(const std::string & featureName)
{  
  return textAfter(featureName," at ");
}
bool ESO2problem::isAcquireFeatureName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"acquire: ");
  bool hasFeatureText = contains(witName,"feature ");
  bool hasAtText = contains(witName," at ");
  bool retVal = false;
  if ( correctPrefix && hasFeatureText && hasAtText ) retVal = true;
  return retVal;
}

//-------------------------------------------------------------------------
// loose part Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::igfLoosePartName(const std::string & loosePart,const std::string & loc )
{
  return "igf: "+baseLoosePartName(loosePart,loc);
}
std::string ESO2problem::acquireLoosePartName(const std::string & loosePart,const std::string & loc )
{
  return "acquire: "+baseLoosePartName(loosePart,loc);
}
std::string ESO2problem::baseLoosePartName(const std::string & loosePart,const std::string & loc )
{
  return "loosePart "+loosePart+" at "+loc;
}
std::string ESO2problem::loosePartFromLoosePartName(const std::string & loosePartName)
{  
  return textBetween(loosePartName,"loosePart "," at ");
}
std::string ESO2problem::locFromLoosePartName(const std::string & loosePartName)
{  
  return textAfter(loosePartName," at ");
}
bool ESO2problem::isAcquireLoosePartName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"acquire: ");
  bool hasLoosePartText = contains(witName,"loosePart ");
  bool hasAtText = contains(witName," at ");
  bool retVal = false;
  if ( correctPrefix && hasLoosePartText && hasAtText ) retVal = true;
  return retVal;
}


bool ESO2problem::isAcquireName( const std::string & witName )
{
  bool retVal = 
    isAcquireMtmName(witName) || 
    isAcquireFeatureName(witName) || 
    isAcquireLoosePartName(witName);
  return retVal;
}

//-------------------------------------------------------------------------
// Feature Cross Reference Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::featureXrefName(const std::string & part, const std::string & feature, const std::string & loc)
{
  return "xref: "+feature+" to "+part+" at "+loc;
}
std::string ESO2problem::partFromFeatureXrefName(const std::string & featXrefName)
{ 
  return textBetween(featXrefName," to "," at ");
}
std::string ESO2problem::featureFromFeatureXrefName(const std::string & featXrefName)
{   
  return textBetween(featXrefName,"xref: "," to ");
}
std::string ESO2problem::locFromFeatureXrefName(const std::string & featXrefName)
{  
  return textAfter(featXrefName," at ");
}
bool ESO2problem::isFeatureXrefName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"xref: ");
  bool hasToText = contains(witName," to ");
  bool hasAtText = contains(witName," at ");
  bool retVal = false;
  if ( correctPrefix && hasToText && hasAtText ) retVal = true;
  return retVal;
}

//-------------------------------------------------------------------------
// etnCsp Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::altName(const std::string & partOrFeature, const std::string & altPart, const std::string & loc)
{
  return "ec: "+partOrFeature+" to "+altPart+" at "+loc;
}
std::string ESO2problem::partFromAltName(const std::string & altName)
{  
  return textBetween(altName,"ec: "," to ");
}
std::string ESO2problem::altPartFromAltName(const std::string & altName)
{  
  return textBetween(altName," to "," at ");
}
std::string ESO2problem::locFromAltName(const std::string & altName)
{  
  return textAfter(altName," at ");
}
bool ESO2problem::isAltName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"ec: ");
  bool hasToText = contains(witName," to ");
  bool hasAtText = contains(witName," at ");
  bool retVal = false;
  if ( correctPrefix && hasToText && hasAtText ) retVal = true;
  return retVal;
}
//-------------------------------------------------------------------------
// partInterplant Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::partInterplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc)
{
  return "move: "+part+" from "+srcLoc+" to "+destLoc;
}
std::string ESO2problem::partFromPartInterplantName(const std::string & partInterplantName)
{  
  return textBetween(partInterplantName,"move: "," from ");
}
std::string ESO2problem::srcLocFromPartInterplantName(const std::string & partInterplantName)
{  
  return textBetween(partInterplantName," from "," to ");
}
std::string ESO2problem::destLocFromPartInterplantName(const std::string & partInterplantName)
{  
  return textAfter(partInterplantName," to ");
}
bool ESO2problem::isPartInterplantName( const std::string & witName )
{
  bool correctPrefix = beginsWith(witName,"move: ");
  bool hasFromText = contains(witName," from ");
  bool hasToText = contains(witName," to ");
  bool retVal = false;
  if ( correctPrefix && hasFromText && hasToText ) retVal = true;
  return retVal;
}
//-------------------------------------------------------------------------
// partDemand Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::partDemandName(const std::string & part, const std::string & custLoc, const std::string & plantLoc)
{
  return "part: "+part+" custLoc: "+custLoc+" plantLoc: "+plantLoc;;
}
std::string ESO2problem::partDemandRegulatorName(const std::string & part, const std::string & custLoc, const std::string & plantLoc)
{
  return "regulator for: "+partDemandName(part,custLoc,plantLoc);
}
std::string ESO2problem::partDemandInventoryName(const std::string & part, const std::string & custLoc, const std::string & plantLoc)
{
  return "Inventoryable Part for: "+partDemandName(part,custLoc,plantLoc);
}
std::string ESO2problem::partFromPartDemandName(const std::string & partDemandName)
{  
  return textBetween(partDemandName,"part: "," custLoc: ");
}
std::string ESO2problem::custLocFromPartDemandName(const std::string & partDemandName)
{  
  return textBetween(partDemandName," custLoc: "," plantLoc: ");
}
std::string ESO2problem::plantLocFromPartDemandName(const std::string & partDemandName)
{  
  return textAfter(partDemandName," plantLoc: ");
}


//-------------------------------------------------------------------------
// part Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::partName(const std::string & part,const std::string & loc )
{
  return "part: "+part+" at "+loc;
}

std::string ESO2problem::moveablePartName(const std::string & part,const std::string & loc )
{
  return "moveable"+partName(part,loc);
}

std::string ESO2problem::partFromPartName( const std::string & partName )
{
  return textBetween(partName, "part: ", " at " );
}
std::string ESO2problem::locFromPartName( const std::string & partName )
{
  return textAfter(partName," at " );
}



//-------------------------------------------------------------------------
// Cycle Breaking Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::cycleBreakingPartName(const std::vector<std::string> & partNames)
{
  std::string retVal="Cycle Breaking Part: ";
  retVal += "|"+partFromPartName(partNames[0])+"|";
  for ( int i=1; i<partNames.size(); ++i ) {
    retVal += " or ";
    retVal += "|"+partFromPartName(partNames[i])+"|";
  }
  retVal += " at " + locFromPartName(partNames[0]);
  return retVal;
}

std::string ESO2problem::cycleBreakingOperationName(const std::string & ecOpNameInCycle, const std::vector<std::string> & partNamesInCycle)
{
  std::string fromPart=partFromAltName(ecOpNameInCycle);
  std::string loc = locFromAltName(ecOpNameInCycle);

  // Find fromPart in list of parts in cycle
  int fp;
  for ( fp=0; fp<partNamesInCycle.size(); fp++ ) {
    if(fromPart==partFromPartName(partNamesInCycle[fp])) 
      break;
  }
  // assert that fromPart was found in list
  assert(fp<partNamesInCycle.size());

  std::string uplevelPartNames="";
  for ( int i=1; i<partNamesInCycle.size(); i++ ) {
    int npi=(fp+i)%partNamesInCycle.size();
    uplevelPartNames+=partFromPartName(partNamesInCycle[npi]);
    if ( i==(partNamesInCycle.size()-1)  ) break;
    uplevelPartNames+= " / ";
  }

  std::string retVal=altName(fromPart, uplevelPartNames, loc);

  return retVal;

}

//-------------------------------------------------------------------------
// text utilities Methods
//-------------------------------------------------------------------------
std::string ESO2problem::textBetween(
                        const std::string & src, 
                        const std::string & begMark,
                        const std::string & endMark)
{
  size_t begPos = src.find(begMark);
  assert( begPos != std::string::npos );
  begPos = begPos+begMark.size();

  size_t endPos = src.find(endMark);
  assert( endPos != std::string::npos );

  size_t len = endPos-begPos;
  std::string retVal = src.substr(begPos,len);
  return retVal;
}
std::string ESO2problem::textAfter(
                        const std::string & src, 
                        const std::string & begMark)
{
  size_t begPos = src.find(begMark);
  assert( begPos != std::string::npos );
  begPos = begPos+begMark.size();

  size_t endPos = src.size();

  size_t len = endPos-begPos;
  std::string retVal = src.substr(begPos,len);
  return retVal;
}
bool ESO2problem::beginsWith(
                        const std::string & src, 
                        const std::string & begString)
{
  size_t begPos = src.find(begString);
  if ( begPos==0 ) return true;
  else return false;
}
bool ESO2problem::contains(
                        const std::string & haystack, 
                        const std::string & needle)
{
  size_t pos = haystack.find(needle);
  if ( pos!=std::string::npos ) return true;
  else return false;
}



//-------------------------------------------------------------------------
// Utilities for invoking Wit Methods
//-------------------------------------------------------------------------
// Set element of Part/Operation float* attribute, given period and float
void ESO2problem::witSetNameAttribute(
    witGetNameFloatStarStar witGetFunc,
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    int period, 
    float flt )    
{ 
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetFunc(mutableWitRun(),name.c_str(),&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),name.c_str(),floatStar);
  witFree(floatStar);
}

// Set Part/Operation float* attribute, given std::vector<float>
void ESO2problem::witSetNameAttribute(
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    const std::vector<float> & value )
{
  float * fltStar = stlVecToFloatStar(value);
  witSetFunc(witRun(),name.c_str(),fltStar);
  delete [] fltStar;
}

// Set Part/Operation float* attribute, given float
void ESO2problem::witSetNameAttribute(
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    float value )
{
  float * fltStar = floatToConstFloatStar(value);
  witSetFunc(witRun(),name.c_str(),fltStar);
  delete [] fltStar;
}

// Set Part/Operation bound attribute, given three std::vector<float> vectors
void ESO2problem::witSetNameBoundAttribute(
    witSetName3FloatStar     witSetFunc,
    const std::string & name,
    const std::vector<float> & hlb,
    const std::vector<float> & slb,
    const std::vector<float> & hub )
{
  float * hlbFltStar = stlVecToFloatStar(hlb);
  float * slbFltStar = stlVecToFloatStar(slb);
  float * hubFltStar = stlVecToFloatStar(hub);
  witSetFunc(witRun(),name.c_str(),hlbFltStar, slbFltStar, hubFltStar);
  delete [] hlbFltStar;
  delete [] slbFltStar;
  delete [] hubFltStar;
}
// Get Part/Operation bound attributes, given three std::vector<float> vectors
void ESO2problem::witGetNameBoundAttribute(
    witGetName3FloatStar     witGetFunc,
    const std::string & name,
    std::vector<float> & hlb,
    std::vector<float> & slb,
    std::vector<float> & hub )const
{
  float * hlbFltStar;
  float * slbFltStar;
  float * hubFltStar;
  witGetFunc(mutableWitRun(),name.c_str(),&hlbFltStar, &slbFltStar, &hubFltStar);
  hlb=witFloatStarToStlVec(hlbFltStar);
  slb=witFloatStarToStlVec(slbFltStar);
  hub=witFloatStarToStlVec(hubFltStar);
  witFree(hlbFltStar);
  witFree(slbFltStar);
  witFree(hubFltStar);
}



// Set element of Bop/Bop Entry float* attribute, given period and float
void ESO2problem::witSetArcAttribute(
    witGetNameIndexFloatStarStar witGetFunc,
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    int period, 
    float flt )    
{ 
  assert( period>= 0 );
  assert( period<getNPeriods() );
  //int bei = getBopEntryIndex(opName,partName);
  //assert( bei!=-1 );
  float * floatStar;
  witGetFunc(mutableWitRun(),opName.c_str(),index,&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),opName.c_str(),index,floatStar);
  witFree(floatStar);
}

// Set element of Bop/Bop Entry float* attribute, given std::vector<float>
void ESO2problem::witSetArcAttribute(
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    const std::vector<float> & value )    
{ 
  float * fltStar = stlVecToFloatStar(value);
  witSetFunc(witRun(),opName.c_str(),index,fltStar);
  delete []  fltStar;
}

// Set element of Bop/Bop Entry float* attribute, given float
void ESO2problem::witSetArcAttribute(
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    float value )    
{ 
  float * fltStar = floatToConstFloatStar(value);
  witSetFunc(witRun(),opName.c_str(),index,fltStar);
  delete []  fltStar;
}



// Set element on demand float* attribute, given period and fltValue
void ESO2problem::witSetDemandAttribute(
    witGetDblNameFloatStarStar      witGetFunc,
    witSetDblNameFloatStar          witSetFunc,
    const std::string & partName,
    const std::string & demandName,
    int period, 
    float flt )
{
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetFunc(mutableWitRun(),partName.c_str(),demandName.c_str(),&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),partName.c_str(),demandName.c_str(),floatStar);
  witFree(floatStar);
}

// Set element on demand float* attribute, given stl::vector<float>
void ESO2problem::witSetDemandAttribute(
    witSetDblNameFloatStar          witSetFunc,
    const std::string & partName,
    const std::string & demandName,
    const std::vector<float> & fltVec )
{
  float * floatStar = stlVecToFloatStar(fltVec);
  witSetFunc(witRun(),partName.c_str(),demandName.c_str(),floatStar);
  delete [] floatStar;
}

// Get vector of wit part/Operation float* attribute
std::vector<float> ESO2problem::witGetNameAttribute(
    witGetNameFloatStarStar witGetFunc,
    const std::string & name ) const
{
  float * attr;
  witGetFunc(mutableWitRun(),name.c_str(),&attr);
  std::vector<float> retVal = witFloatStarToStlVec(attr);
  witFree(attr);
  return retVal;
}

// Get vector of bom/bop float* attribute
std::vector<float> ESO2problem::witGetArcAttribute(
                                     witGetNameIndexFloatStarStar     witGetFunc,
                                     const std::string & opName,
                                     int index )const
{
  float * attr;
  witGetFunc(mutableWitRun(),opName.c_str(),index,&attr);
  std::vector<float> retVal = witFloatStarToStlVec(attr);
  witFree(attr);
  return retVal;
}

// Get vector of bom/bop int* attribute
std::vector<int> ESO2problem::witGetArcAttribute(
                                     witGetNameIndexIntStarStar     witGetFunc,
                                     const std::string & opName,
                                     int index )const
{
  int * attr;
  witGetFunc(mutableWitRun(),opName.c_str(),index,&attr);
  std::vector<int> retVal = witIntStarToStlVec(attr);
  witFree(attr);
  return retVal;
}



// Get vector of sub float* attribute
std::vector<float> ESO2problem::witGetSubArcAttribute(
                                     witGetNameIndexIndexFloatStarStar     witGetFunc,
                                     const std::string & opName,
                                     int index, int subIndex )const
{
  float * attr;
  witGetFunc(mutableWitRun(),opName.c_str(),index,subIndex,&attr);
  std::vector<float> retVal = witFloatStarToStlVec(attr);
  witFree(attr);
  return retVal;
}

// Get vector of sub int* attribute
std::vector<int> ESO2problem::witGetSubArcAttribute(
                                     witGetNameIndexIndexIntStarStar     witGetFunc,
                                     const std::string & opName,
                                     int index, int subIndex )const
{
  int * attr;
  witGetFunc(mutableWitRun(),opName.c_str(),index,subIndex,&attr);
  std::vector<int> retVal = witIntStarToStlVec(attr);
  witFree(attr);
  return retVal;
}

// Get vector of sub int attribute
int ESO2problem::witGetSubArcAttribute(
                                     witGetNameIndexIndexIntStar     witGetFunc,
                                     const std::string & opName,
                                     int index, int subIndex )const
{
  int retVal;
  witGetFunc(mutableWitRun(),opName.c_str(),index,subIndex,&retVal);
  return retVal;
}

// Set sub float* attribute, given period and fltValue
void ESO2problem::witSetSubArcAttribute(
    witGetNameIndexIndexFloatStarStar witGetFunc,
    witSetNameIndexIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index, int subIndex,
    int period, 
    float flt )    
{ 
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetFunc(mutableWitRun(),opName.c_str(),index,subIndex,&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),opName.c_str(),index,subIndex,floatStar);
  witFree(floatStar);
}





// Get vector of wit demand float* attribute
std::vector<float> ESO2problem::witGetDemandAttribute(
    witGetDblNameFloatStarStar witGetFunc,
    const std::string & partName,
    const std::string & demandName )const
{
  float * attr;
  witGetFunc(mutableWitRun(),partName.c_str(),demandName.c_str(),&attr);
  std::vector<float> retVal = witFloatStarToStlVec(attr);
  witFree(attr);
  return retVal;
}




#if 0
//---------------------------------------------
// Get resource shortage list
//---------------------------------------------

void ESO2problem::getResourceShortages(     
    std::vector<std::string> & resourceDescriptions,
    std::vector<int> & periods,
    std::vector<float> & shortageVols ) const
{
  resourceDescriptions.clear();
  periods.clear();
  shortageVols.clear();

  std::vector<std::string> projects;
  getProjects(projects);
  int np = getNPeriods();
  
  // Set Focus
  for ( int p=0; p<projects.size(); p++ ) {
    float *dv;
    witGetDemandDemandVol(mutableWitRun(),projects[p].c_str(),projects[p].c_str(),&dv);
    witSetDemandFssShipVol(mutableWitRun(),projects[p].c_str(),projects[p].c_str(),dv);
    witFree(dv);
  }

  int lenList;
  char **partList;
  float ** shortageVolList;  
  //OsiRelFltEq eq;
  witGetFocusShortageVol ( mutableWitRun(), &lenList, &partList, &shortageVolList );
  for ( int i=0; i<lenList; i++ ) {
    for ( int t=0; t<np; t++ ) {
      if ( shortageVolList[i][t]==0.0 ) continue;
      resourceDescriptions.push_back(partList[i]);
      periods.push_back(t);
      shortageVols.push_back(shortageVolList[i][t]);
    }
    witFree(partList[i]);
    witFree(shortageVolList[i]);
  }
  witFree(partList);
  witFree(shortageVolList);
}
#endif

//--------------------------------------------------------

void ESO2problem::setTitle( const std::string & title)
{
  witSetTitle(witRun(),title.c_str());
}

std::string ESO2problem::getTitle() const
{
  char * t;
  witGetTitle(mutableWitRun(),&t);
  std::string retVal(t);
  witFree(t);
  return retVal;
}

void ESO2problem::setNPeriods( int nP )
{
  witSetNPeriods(witRun(),nP);
  nPeriods_ = nP;
}


double ESO2problem::getObjValue() const
{
  double retVal;
  float objVal;
  float boundsVal;
  witGetObjValues (mutableWitRun(),&objVal,&boundsVal);
  retVal = objVal;
  return retVal;
}

double ESO2problem::sumOfFeatureXrefCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatureXrefs(parts,features,locs);
  int i;
  for ( i=0; i<parts.size(); ++i ) {
    std::string witOpName = featureXrefName(parts[i],features[i],locs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witOpName);
    
    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}
double ESO2problem::sumOfPartMoveCost() const
{
  double retVal=0.0;
  int np=getNPeriods();  
  std::vector<std::string> parts;
  std::vector<std::string> srcLocs;
  std::vector<std::string> destLocs;
  getPartInterplants(parts,srcLocs,destLocs);
  int i;
  for ( i=0; i<parts.size(); ++i ) {
    std::string witMoveOpName = partInterplantName(parts[i],srcLocs[i],destLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witMoveOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witMoveOpName);
    
    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}
double ESO2problem::sumOfWac(std::map<std::string,double> & wacComponents) const
{
  CoinRelFltEq eq;

  double retVal=0.0;
  wacComponents.clear();

  int np=getNPeriods();
  std::vector<std::string> parts;
  std::vector<std::string> custLocs;
  std::vector<std::string> plantLocs;
  getPartDemands(parts,custLocs,plantLocs);
  int i;
  for ( i=0; i<parts.size(); ++i ) {
    std::string witDemandName = partDemandName(parts[i],custLocs[i],plantLocs[i]);
    std::vector<float> witShipVols = witGetDemandAttribute(witGetDemandShipVol,witDemandName,witDemandName);
    std::vector<float> witShipReward = witGetDemandAttribute(witGetDemandObj1ShipReward,witDemandName,witDemandName);
 
    std::vector<float> shipVols = getPartDemandShipVol(parts[i],custLocs[i],plantLocs[i]);
    std::vector<float> scaledWacs = getPartDemandScaledWac(parts[i],custLocs[i],plantLocs[i]);
    int t;

    for ( t=0; t<np; ++t ) {
      assert( eq(witShipVols[t],shipVols[t]) );
      //assert( eq(witShipReward[t],scaledWacs[t]) );
      double incrementalWac = witShipVols[t]*witShipReward[t];
      if ( incrementalWac==0.0 ) continue;
      retVal += incrementalWac;

      std::vector<std::string> mtmItems,featureItems,loosePartItems,locs;
      std::vector<int> periods;
      std::vector<int> depths;
      std::vector<float> quantities;    
      getPartDemandPegging("MtmAcquire",      parts[i],custLocs[i],plantLocs[i],t, mtmItems,       locs, periods, depths, quantities );
      getPartDemandPegging("FeatureAcquire",  parts[i],custLocs[i],plantLocs[i],t, featureItems,   locs, periods, depths, quantities );
      getPartDemandPegging("LoosePartAcquire",parts[i],custLocs[i],plantLocs[i],t, loosePartItems, locs, periods, depths, quantities );

      std::string compName;
      if ( mtmItems.size()>0 )       compName+="-MtmAcquire-";
      if ( featureItems.size()>0 )   compName+="-FeatureAcquire-";
      if ( loosePartItems.size()>0 ) compName+="-LoosePartAcquire-";
      if ( compName=="" ) compName="-other-";
      // assert( compName!="-other-");
   
      if ( wacComponents.find(compName)==wacComponents.end() ) wacComponents[compName]=0.0;
      wacComponents[compName]+=incrementalWac;
    }
  }
  return retVal;
}
double ESO2problem::sumOfFeatureWfmvWithScaleFactor() const
{
  double retVal=0.0;
  int np=getNPeriods();
  std::vector<std::string> features;
  std::vector<std::string> plantLocs;
  getFeatures(features,plantLocs);
  int i;
  for ( i=0; i<features.size(); ++i ) {
    
    std::string witAcquireOpName = acquireFeatureName(features[i],plantLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAcquireOpName);

    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}
double ESO2problem::sumOfLoosePartWfmvWithScaleFactor() const
{
  double retVal=0.0;
  int np=getNPeriods();
  std::vector<std::string> looseParts;
  std::vector<std::string> plantLocs;
  getLooseParts(looseParts,plantLocs);
  int i;
  for ( i=0; i<looseParts.size(); ++i ) {
    
    std::string witAcquireOpName = acquireLoosePartName(looseParts[i],plantLocs[i]);
    //std::string witPartName = igfLoosePartName(looseParts[i],plantLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAcquireOpName);

    //std::vector<float> acquireQty = getLoosePartAcquireQty(looseParts[i],plantLocs[i]);
    //std::vector<float> wfmv = getLoosePartWfmv(looseParts[i],plantLocs[i]);
    //float scaleFactor = getWfmvScaleFactor();
    int t;
    for ( t=0; t<np; ++t ) {
      
      //assert( execVol[t]==acquireQty[t] );
      //assert( execCost[t]==wfmv[t]*scaleFactor );

      retVal += execVol[t]*execCost[t];
    }
  }
  
  return retVal;
}

double ESO2problem::sumOfAltCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
  
    std::vector<std::string> partOrFeatures;
    std::vector<std::string> altParts;
    std::vector<std::string> locs;
    getAlts(partOrFeatures,altParts,locs);
    
    // loop once for each altPart
    int i;
    for ( i=0; i<partOrFeatures.size(); i++ ) {
    
    std::string witAltOpName = altName(partOrFeatures[i],altParts[i],locs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAltOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAltOpName);

    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  
  return retVal;
}

double ESO2problem::sumOfMtmWfmvWithScaleFactorAndMoveCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms,srcLocs,destLocs);
  int i;
  for ( i=0; i<mtms.size(); ++i ) {
    
    std::string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAcquireOpName);

    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}

double ESO2problem::sumOfMtmWfmvWithScaleFactor() const
{
  double retVal=sumOfMtmWfmvWithScaleFactorAndMoveCost()-sumOfMtmMoveCost();
  return retVal;
}

double ESO2problem::sumOfMtmMoveCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms,srcLocs,destLocs);
  int i;
  for ( i=0; i<mtms.size(); ++i ) {
    
    std::string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    std::vector<float> moveCost = getMtmInterplantMoveCost(mtms[i],srcLocs[i],destLocs[i]);

    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*moveCost[t];
    }
  }
  return retVal;
}
double ESO2problem::sumOfDemanCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
  std::vector<std::string> mtms;
  std::vector<std::string> srcLocs;
  std::vector<std::string> destLocs;
  getMtmDemanLocs(mtms,srcLocs,destLocs);
  int i;
  for ( i=0; i<mtms.size(); ++i ) {
    
    std::string witAcquireOpName = demanMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAcquireOpName);

    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}
void ESO2problem::mtmMetrics(
                              double & totalWfmvWithScale,
                              double & sumAcquireCost,
                              double & sumMoveCost,
                              double & sumDemanCost,
                              int & numUnique,
                              int & numUniqueAcquired,
                              double & supplyQuantity,
                              double & acquiredQuantity)
                              const
{
  sumAcquireCost = sumOfMtmWfmvWithScaleFactor();
  sumMoveCost = sumOfMtmMoveCost();
  sumDemanCost = sumOfDemanCost();
  
  int np=getNPeriods();
  float scaleFactor = getWfmvScaleFactor();
  {
    std::vector<std::string> mtms;
    std::vector<std::string> locs;
    getMtms(mtms,locs);
    
    totalWfmvWithScale = 0.0;
    numUnique = (int)mtms.size();
    supplyQuantity =0;
    
    int i;
    for ( i=0; i<mtms.size(); ++i ) {
      
      std::vector<float> wfmv = getMtmWfmv(mtms[i],locs[i]);
      std::vector<float> supplyQty = getMtmSupply(mtms[i],locs[i]);
      
      int t;
      for ( t=0; t<np; ++t ) {
        totalWfmvWithScale += supplyQty[t]*wfmv[t]*scaleFactor;
        supplyQuantity += supplyQty[t];
      }
    }
  }
  {
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms,srcLocs,destLocs);
    
    numUniqueAcquired =0;
    acquiredQuantity = 0;
    
    int i;
    for ( i=0; i<mtms.size(); ++i ) {
      
      //std::vector<float> wfmv = getMtmWfmv(mtms[i],srcLocs[i]);
      //std::vector<float> supplyQty = getMtmSupply(mtms[i],srcLocs[i]);
      std::vector<float> acquireQty = getMtmAcquireQty(mtms[i],srcLocs[i],destLocs[i]);
      
      int t;
      bool nonZero = false;
      for ( t=0; t<np; ++t ) {
        //totalWfmvWithScale += supplyQty[t]*wfmv[t]*scaleFactor;
        //supplyQuantity += supplyQty[t];
        acquiredQuantity += acquireQty[t];
        if( acquireQty[t] > 0.0 ) 
          nonZero=true;
      }
      if (nonZero) numUniqueAcquired++;
    }
  }
}

void ESO2problem::featureMetrics(
                              double & totalWfmvWithScale,
                              double & sumAcquireCost,
                              double & sumXrefCost,
                              int & numUnique,
                              int & numUniqueAcquired,
                              double & supplyQuantity,
                              double & acquiredQuantity)
                              const
{
  sumAcquireCost = sumOfFeatureWfmvWithScaleFactor();
  sumXrefCost = sumOfFeatureXrefCost();
  
  int np=getNPeriods();
  float scaleFactor = getWfmvScaleFactor();

  std::vector<std::string> features;
  std::vector<std::string> plantLocs;
  getFeatures(features,plantLocs);
  
  totalWfmvWithScale = 0.0;
  numUnique = (int)features.size();
  numUniqueAcquired =0;
  supplyQuantity =0;
  acquiredQuantity = 0;

  int i;
  for ( i=0; i<features.size(); ++i ) {
    
    std::vector<float> wfmv = getFeatureWfmv(features[i],plantLocs[i]);
    std::vector<float> supplyQty = getFeatureSupply(features[i],plantLocs[i]);
    std::vector<float> acquireQty = getFeatureAcquireQty(features[i],plantLocs[i]);

    int t;
    bool nonZero = false;
    for ( t=0; t<np; ++t ) {
      totalWfmvWithScale += supplyQty[t]*wfmv[t]*scaleFactor;
      supplyQuantity += supplyQty[t];
      acquiredQuantity += acquireQty[t];
      if( acquireQty[t] > 0.0 ) nonZero=true;
    }
    if (nonZero) numUniqueAcquired++;
  }
}

void ESO2problem::loosePartMetrics(
                              double & totalWfmvWithScale,
                              double & sumAcquireCost,
                              double & sumAltCost,
                              int & numUnique,
                              int & numUniqueAcquired,
                              double & supplyQuantity,
                              double & acquiredQuantity)
                              const
{
  sumAcquireCost = sumOfLoosePartWfmvWithScaleFactor();
  sumAltCost = sumOfAltCost();
  
  int np=getNPeriods();
  float scaleFactor = getWfmvScaleFactor();
  
  std::vector<std::string> looseParts;
  std::vector<std::string> plantLocs;
  getLooseParts(looseParts,plantLocs);
  
  totalWfmvWithScale = 0.0;
  numUnique = (int)looseParts.size();
  numUniqueAcquired =0;
  supplyQuantity =0;
  acquiredQuantity = 0;

  int i;
  for ( i=0; i<looseParts.size(); ++i ) {
    
    std::vector<float> wfmv = getLoosePartWfmv(looseParts[i],plantLocs[i]);
    std::vector<float> supplyQty = getLoosePartSupply(looseParts[i],plantLocs[i]);
    std::vector<float> acquireQty = getLoosePartAcquireQty(looseParts[i],plantLocs[i]);

    int t;
    bool nonZero = false;
    for ( t=0; t<np; ++t ) {
      totalWfmvWithScale += supplyQty[t]*wfmv[t]*scaleFactor;
      supplyQuantity += supplyQty[t];
      acquiredQuantity += acquireQty[t];
      if( acquireQty[t] > 0.0 ) nonZero=true;
    }
    if (nonZero) numUniqueAcquired++;
  }
}


void ESO2problem::partDemandMetrics(
                              double & sumDemandWac,
                              double & sumShippedWac,
                              std::map<std::string,double> & sumShippedWacComponents,
                              int & numUnique,
                              int & numUniqueShipped,
                              double & sumDemandVol,
                              double & sumShipVol)
                              const
{
  sumShippedWac = sumOfWac(sumShippedWacComponents);
  
  int np=getNPeriods();
  
  std::vector<std::string> parts;
  std::vector<std::string> custLocs;
  std::vector<std::string> plantLocs;
  getPartDemands(parts,custLocs,plantLocs);
  
  sumDemandWac = 0.0;
  numUnique = (int)parts.size();
  numUniqueShipped =0;
  sumDemandVol=0;
  sumShipVol = 0;

  int i;
  for ( i=0; i<numUnique; ++i ) {
    
    std::vector<float> scaledWac = getPartDemandScaledWac(parts[i],custLocs[i],plantLocs[i]);
    std::vector<float> shipVol = getPartDemandShipVol(parts[i],custLocs[i],plantLocs[i]);
    std::vector<float> demandVol = getPartDemandDemandVol(parts[i],custLocs[i],plantLocs[i]);

    int t;
    bool nonZero = false;
    for ( t=0; t<np; ++t ) {
      sumDemandWac += demandVol[t]*scaledWac[t];
      sumDemandVol += demandVol[t];
      sumShipVol += shipVol[t];
      if( shipVol[t] > 0.0 ) nonZero=true;
    }
    if (nonZero) numUniqueShipped++;
  }
}

// Set OSL Logfile name
void ESO2problem::setSolverLogFileName(const std::string & name)
{
  witSetSolverLogFileName(witRun(),name.c_str());
}

// Set/Get Wholesale Fair Market Value Scale Factor
void ESO2problem::setWfmvScaleFactor(float wfmvScaleFactor, float wfmv2ScaleFactor)
{
  ESO2probAppData * appData;
  witGetAppData(witRun(),(void**)&appData);
  appData->setWfmvScaleFactor(wfmvScaleFactor);
  appData->setWfmv2ScaleFactor(wfmv2ScaleFactor);
}
float ESO2problem::getWfmvScaleFactor() const
{
  ESO2probAppData * appData;
  witGetAppData(mutableWitRun(),(void**)&appData);
  return appData->getWfmvScaleFactor();
}

float ESO2problem::getWfmv2ScaleFactor() const
{
  ESO2probAppData * appData;
  witGetAppData(mutableWitRun(),(void**)&appData);
  return appData->getWfmv2ScaleFactor();
}
float ESO2problem::getWfmvScaleFactor(int demandFileNumber) const
{
  assert(demandFileNumber==0 || demandFileNumber==1 );
  float retVal=-FLT_MAX;
  if (demandFileNumber==0) retVal = getWfmvScaleFactor();
  if (demandFileNumber==1) retVal = getWfmv2ScaleFactor();
  return retVal;
}
void ESO2problem::setApplyLocWfmvScaleFactor(const std::string & plantLoc,int demandFileNumber)
{
  std::pair<std::string,int> pair(plantLoc,demandFileNumber);
  wfmvLocScaleFactorSfDemandFilePair_.insert(pair);
}
bool ESO2problem::getApplyLocWfmvScaleFactor(const std::string & plantLoc,int demandFileNumber) const
{
  bool retVal;
  std::pair<std::string,int> pair(plantLoc,demandFileNumber);
  retVal = wfmvLocScaleFactorSfDemandFilePair_.find(pair)!=wfmvLocScaleFactorSfDemandFilePair_.end();
  return retVal;
}

void ESO2problem::setUseApplyScaleFactorLoc(bool val)
{
  useApplyScaleFactorLoc_ = val;
}
bool ESO2problem::getUseApplyScaleFactorLoc() const
{
  // Return true if using wfmvLocScaleFactorSfDemandFilePair_ (ie applyScaleFactorLocFile)
  bool retVal = useApplyScaleFactorLoc_;
  return retVal;
}



// Set/Get priorities of mtm, features, and looseParts.
// Priorities are:
// 1 - high. Select this category of supply first.
// 2 - medium. 
// 3 - low. Select this category of supply last.
// 4 - never. Never consume this category of supply to meet demand.
void ESO2problem::setMtmPriority( int p )
{
  assert(p>=1 && p<=4);
  mtmPriority_=p;
}
int ESO2problem::getMtmPriority() const
{
  return mtmPriority_;
}
void ESO2problem::setFeaturePriority( int p )
{
  assert(p>=1 && p<=4);
  featurePriority_=p;
}
int ESO2problem::getFeaturePriority() const
{
  return featurePriority_;
}
void ESO2problem::setLoosePartPriority( int p )
{
  assert(p>=1 && p<=4);
  loosePartPriority_=p;
}
int ESO2problem::getLoosePartPriority() const
{
  return loosePartPriority_;
}

void ESO2problem::setMtm2Priority( int p )
{
  assert(p>=1 && p<=4);
  mtm2Priority_=p;
}
int ESO2problem::getMtm2Priority() const
{
  return mtm2Priority_;
}
void ESO2problem::setFeature2Priority( int p )
{
  assert(p>=1 && p<=4);
  feature2Priority_=p;
}
int ESO2problem::getFeature2Priority() const
{
  return feature2Priority_;
}
void ESO2problem::setLoosePart2Priority( int p )
{
  assert(p>=1 && p<=4);
  loosePart2Priority_=p;
}
int ESO2problem::getLoosePart2Priority() const
{
  return loosePart2Priority_;
}

int ESO2problem::getMtmPriority(int demandPriority) const
{
  assert(demandPriority>=0 && demandPriority<=1);
  int retVal;
  if (demandPriority==0) 
    retVal=getMtmPriority();
  else
    retVal=getMtm2Priority();
  return retVal;
}
int ESO2problem::getFeaturePriority(int demandPriority) const
{
  assert(demandPriority>=0 && demandPriority<=1);
  int retVal;
  if (demandPriority==0) 
    retVal=getFeaturePriority();
  else
    retVal=getFeature2Priority();
  return retVal;
}
int ESO2problem::getLoosePartPriority(int demandPriority) const
{
  assert(demandPriority>=0 && demandPriority<=1);
  int retVal;
  if (demandPriority==0) 
    retVal=getLoosePartPriority();
  else
    retVal=getLoosePart2Priority();
  return retVal;
}

void ESO2problem::setPeriod1SupplyPerishPeriod( int periods )
{
  assert(periods>=0);
  period1SupplyPerishPeriod_=periods;
}

void ESO2problem::setAllowInventoryHoldingAtDemandLocation( bool allow )
{
  allowInventoryHoldingAtDemandLocation_=allow;
}

void ESO2problem::setRemoveCycles( bool remove )
{
  removeCycles_=remove;
}
void ESO2problem::setWacScaleFactors( float wsf1, float wsf2 )
{
  wacScaleFactors_.clear();
  wacScaleFactors_.push_back(wsf1);
  wacScaleFactors_.push_back(wsf2);
}
const std::vector<float> & ESO2problem::getWacScaleFactors()const
{
  return wacScaleFactors_;
}

void ESO2problem::writeWitData( std::string filename ) const
{
  witSetMesgFileAccessMode(mutableWitRun(),WitFALSE,"w");
  witWriteData(mutableWitRun(), filename.c_str() );
}











WitRun * ESO2problem::mutableWitRun() const { return wr_; }
WitRun * ESO2problem::witRun() { return wr_; }

int ESO2problem::implosionCount() const { return implosionCount_; }

// default constructor
ESO2problem::ESO2problem()
:
wr_(NULL),
implosionCount_(0),
nPeriods_(26),
mtmNames_(),
featureNames_(),
loosePartNames_(),
//alternateParts_(),
partInterplants_(),
partDemands_(),
demanBomAndFeatureXrefProdRatesAreSet_(false),
mtmAcquireLocs_(),
partOrFeatureLocs_(),
defaultPartInterplants_(),
perishableSupplyWarningMsgTested_(),
mtmPriority_(1),
featurePriority_(1),
loosePartPriority_(1),
mtm2Priority_(1),
feature2Priority_(1),
loosePart2Priority_(1),
wacScaleFactors_(),
wfmvLocScaleFactorSfDemandFilePair_(),
allowInventoryHoldingAtDemandLocation_(false),
removeCycles_(false),
useApplyScaleFactorLoc_(true),
period1SupplyPerishPeriod_(0)
{
  witNewRun( &wr_ );
  witInitialize( witRun() );
  //witSetOslMesgFileName(witRun(),WitSTDOUT);
  
  // Turn off WIT informational messages
  witSetMesgTimesPrint( witRun(), WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
  // Turn off warning msg about long names.
  witSetMesgTimesPrint( witRun(), WitTRUE, 338, 0);

  // Turn on some interesting informational messages
  witSetMesgTimesPrint( witRun(), WitTRUE, 729, UCHAR_MAX);
  witSetMesgTimesPrint( witRun(), WitTRUE, 730, UCHAR_MAX);

  //WIT0729I Deleting selected objects.
  //         Number of objects selected by the user:  158900
  //         Number of objects selected by WIT:       160629
  //         Number of objects selected total:        319529

  //WIT0730I Object purge complete.
  //         Number of objects before purge:  332170
  //         Number of objects deleted:       319529
  //         Number of objects after purge:    12641

  /* Turn off warning msg:
  WIT0749W One or more BOP entries have been rejected for possible explosion,
         because they had positive effective production rates (= yieldRate *
         productRate) that were below the value of expCutoff. The largest
         effective production rate that was rejected and the corresponding BOP
         entry and execution period are given below:

            expCutoff:             0.01
            Largest Rejected Rate: 0.008
            Operation:             "disassemble_26353AU"
            BOP Entry Index:       4
            Exec. Period:          0
  */
  //witSetMesgTimesPrint( witRun(), WitTRUE, 749, 0);
  
  
  //witSetTitle( witRun(), "DaimlerChrysler" );
  //witSetNPeriods( witRun(), 1 );
  witSetObjChoice( witRun(), 1 );
  witSetUseFocusHorizons( witRun(), WitFALSE );

  witSetExecEmptyBom( witRun(), WitFALSE );
  witSetMultiRoute( witRun(), WitTRUE );
  witSetIndependentOffsets( witRun(), WitTRUE );

  witSetAccAfterOptImp(witRun(),WitTRUE );
  witSetAccAfterSoftLB(witRun(),WitTRUE );

  //witSetPostSolveRecovery(witRun(),WitTRUE);

  //witSetGroupPipMode(witRun(),WitTRUE);

  ESO2probAppData * problemAppData = new ESO2probAppData;
  witSetAppData(witRun(),problemAppData);

  // Set default wacScaleFactor for both demand files to 1
  wacScaleFactors_.push_back(1.0f);
  wacScaleFactors_.push_back(1.0f);
 
}

// destructor
ESO2problem::~ESO2problem()
{
  gutsOfDestructor();
}

// copy constructor
ESO2problem::ESO2problem( const ESO2problem& source ):
wr_(NULL),
implosionCount_(source.nPeriods_),
nPeriods_(source.nPeriods_),
mtmNames_(),
featureNames_(),
loosePartNames_(),
xrefFeatures_(),
alts_(),
partInterplants_(),
partDemands_(),
demanBomAndFeatureXrefProdRatesAreSet_(false),
mtmAcquireLocs_(),
partOrFeatureLocs_(),
defaultPartInterplants_(),
perishableSupplyWarningMsgTested_(),
mtmPriority_(1),
featurePriority_(1),
loosePartPriority_(1),
mtm2Priority_(1),
feature2Priority_(1),
loosePart2Priority_(1),
wacScaleFactors_(),
wfmvLocScaleFactorSfDemandFilePair_(),
allowInventoryHoldingAtDemandLocation_(false),
removeCycles_(false),
useApplyScaleFactorLoc_(true),
period1SupplyPerishPeriod_(0)
{
  gutsOfCopy(source);
}

// assignment operator
ESO2problem&
ESO2problem::operator=(const ESO2problem& rhs)
{  
  if (this != &rhs) { 
    if ( wr_ != NULL ) gutsOfDestructor();
    wr_ = NULL;
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object
void ESO2problem::gutsOfCopy( const ESO2problem& source )
{
  // Copy Wit Run
  assert(wr_==NULL);
  witNewRun( &wr_ );

  // Turn off WIT informational messages
  witSetMesgTimesPrint( wr_, WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
  // Turn off warning msg about long names.
  witSetMesgTimesPrint( wr_, WitTRUE, 338, 0);

  witCopyData(wr_,source.wr_);
  implosionCount_ = source.implosionCount_;
  nPeriods_ = source.nPeriods_;
  mtmNames_ = source.mtmNames_;
  featureNames_  = source.featureNames_;
  loosePartNames_  = source.loosePartNames_;
  xrefFeatures_  = source.xrefFeatures_;
  alts_  = source.alts_;
  partInterplants_  = source.partInterplants_;
  partDemands_  = source.partDemands_;
  demanBomAndFeatureXrefProdRatesAreSet_  = source.demanBomAndFeatureXrefProdRatesAreSet_;
  mtmAcquireLocs_  = source.mtmAcquireLocs_;
  partOrFeatureLocs_  = source.partOrFeatureLocs_;
  defaultPartInterplants_ = source.defaultPartInterplants_;
  perishableSupplyWarningMsgTested_ = source.perishableSupplyWarningMsgTested_;
  mtmPriority_  = source.mtmPriority_;
  featurePriority_  = source.featurePriority_;
  loosePartPriority_  = source.loosePartPriority_;
  mtm2Priority_  = source.mtm2Priority_;
  feature2Priority_  = source.feature2Priority_;
  loosePart2Priority_  = source.loosePart2Priority_;
  wacScaleFactors_  = source.wacScaleFactors_;
  wfmvLocScaleFactorSfDemandFilePair_ = source.wfmvLocScaleFactorSfDemandFilePair_;
  allowInventoryHoldingAtDemandLocation_ = source.allowInventoryHoldingAtDemandLocation_;
  removeCycles_ = source.removeCycles_;
  useApplyScaleFactorLoc_ = source.useApplyScaleFactorLoc_;
  period1SupplyPerishPeriod_  = source.period1SupplyPerishPeriod_;

  // Copy global app data
  {      
    ESO2probAppData * srcAppData;  
    ESO2probAppData * sinkAppData;
    witGetAppData(source.mutableWitRun(), (void**)&srcAppData);
    sinkAppData = new ESO2probAppData(*srcAppData);    
    witSetAppData(witRun(), sinkAppData);
  }
    
  // copy partDemand appData
  {
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    getPartDemands( parts, custLocs, plantLocs);
    int p;
    for (p=0; p<parts.size(); ++p ) { 
      ESO2partDemandAppData * srcAppData;  
      ESO2partDemandAppData * sinkAppData;
      std::string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
      witGetDemandAppData(source.mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&srcAppData);
      sinkAppData = new ESO2partDemandAppData(*srcAppData);    
      witSetDemandAppData(witRun(),dName.c_str(),dName.c_str(),sinkAppData);
    }
  }
  // copy looseParts appData
  {
    std::vector<std::string> parts;
    std::vector<std::string> locs;
    getLooseParts( parts, locs);
    int p;
    for (p=0; p<parts.size(); ++p ) { 
      ESO2loosePartAppData * srcAppData;  
      ESO2loosePartAppData * sinkAppData;
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
      witGetOperationAppData(source.mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      sinkAppData = new ESO2loosePartAppData(*srcAppData);    
      witSetOperationAppData(witRun(),opName.c_str(),sinkAppData);
    }
  }
   
  // copy features appData
  {
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatures( features, locs);
    int p;
    for (p=0; p<features.size(); ++p ) {
      ESO2featureAppData * srcAppData;  
      ESO2featureAppData * sinkAppData;
      std::string opName = acquireFeatureName(features[p],locs[p]);
      witGetOperationAppData(source.mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      sinkAppData = new ESO2featureAppData(*srcAppData);    
      witSetOperationAppData(witRun(),opName.c_str(),sinkAppData);
    }
  }
  
  // copy featureXrefs appData
  {
    std::vector<std::string> features;
    std::vector<std::string> parts;
    std::vector<std::string> locs;
    getFeatureXrefs( features, parts, locs);
    int p;
    for (p=0; p<features.size(); ++p ) {
      ESO2featureXrefAppData * srcAppData;  
      ESO2featureXrefAppData * sinkAppData;
      std::string opName = featureXrefName(features[p],parts[p],locs[p]);
      witGetOperationAppData(source.mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      sinkAppData = new ESO2featureXrefAppData(*srcAppData);    
      witSetOperationAppData(witRun(),opName.c_str(),sinkAppData);
    }
  }
   
  // Copy Mtm App Data and demanufacturing bops
  {
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms, srcLocs, destLocs );
    int p;
    for (p=0; p<mtms.size(); ++p ) {
      ESO2mtmAppData * srcAppData;  
      ESO2mtmAppData * sinkAppData;
      std::string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
      witGetOperationAppData(source.mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      sinkAppData = new ESO2mtmAppData(*srcAppData);    
      witSetOperationAppData(witRun(),opName.c_str(),sinkAppData);

      // copy appData for each deman bop
      if ( srcLocs[p]==destLocs[p] ) {
        std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
        int nBops;
        witGetOperationNBopEntries(source.mutableWitRun(),demanOpName.c_str(),&nBops);
        // loop once for each bop
        int b;
        for (b=0; b<nBops; ++b ) {
          ESO2mtmDemanBomAppData * srcAppData;  
          ESO2mtmDemanBomAppData * sinkAppData;
          witGetBopEntryAppData(source.mutableWitRun(),demanOpName.c_str(),b,(void**)&srcAppData);
          sinkAppData = new ESO2mtmDemanBomAppData(*srcAppData);    
          witSetBopEntryAppData(witRun(),demanOpName.c_str(),b,sinkAppData);
        }
      }

    } //end of p loop
  }

}

// destructor
void ESO2problem::gutsOfDestructor()
{

  // Delete global app data
  {  
    ESO2probAppData * probAppData;  
    witGetAppData(mutableWitRun(),  (void**)&probAppData);
    delete probAppData;
  }
  
  // delete partDemand appData
  {
    std::vector<std::string> parts;
    std::vector<std::string> custLocs;
    std::vector<std::string> plantLocs;
    getPartDemands( parts, custLocs, plantLocs);
    int p;
    for (p=0; p<parts.size(); ++p ) { 
      ESO2partDemandAppData * srcAppData;  
      std::string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
      witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
    
    
  // delete looseParts appData
  {
    std::vector<std::string> parts;
    std::vector<std::string> locs;
    getLooseParts( parts, locs);
    int p;
    for (p=0; p<parts.size(); ++p ) { 
      ESO2loosePartAppData * srcAppData;  
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
      witGetOperationAppData(mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
   
  // delete features appData
  {
    std::vector<std::string> features;
    std::vector<std::string> locs;
    getFeatures( features, locs);
    int p;
    for (p=0; p<features.size(); ++p ) {
      ESO2featureAppData * srcAppData;  
      std::string opName = acquireFeatureName(features[p],locs[p]);
      witGetOperationAppData(mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
  
  // copy featureXrefs appData
  {
    std::vector<std::string> features;
    std::vector<std::string> parts;
    std::vector<std::string> locs;
    getFeatureXrefs( features, parts, locs);
    int p;
    for (p=0; p<features.size(); ++p ) {
      ESO2featureXrefAppData * srcAppData;  
      std::string opName = featureXrefName(features[p],parts[p],locs[p]);
      witGetOperationAppData(mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      delete srcAppData;
    }
  }
   
   
  // delete Mtm App Data and deman bop app data
  {
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
    getMtmDemanLocs(mtms, srcLocs, destLocs );
    int p;
    for (p=0; p<mtms.size(); ++p ) {
      ESO2mtmAppData * srcAppData;  
      std::string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
      witGetOperationAppData(mutableWitRun(),opName.c_str(),(void**)&srcAppData);
      delete srcAppData;
      
      if ( srcLocs[p]==destLocs[p] ) {
        // delete appData for each deman bop
        std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
        int nBops;
        witGetOperationNBopEntries(mutableWitRun(),demanOpName.c_str(),&nBops);
        // loop once for each bop
        int b;
        for (b=0; b<nBops; ++b ) {
          ESO2mtmDemanBomAppData * srcAppData; 
          witGetBopEntryAppData(mutableWitRun(),demanOpName.c_str(),b,(void**)&srcAppData);
          delete srcAppData;
        }
      }
      
    } // end of p loop
    
  }

  // delete the witRun
  witDeleteRun(witRun());
}



#ifdef NDEBUG
#undef NDEBUG
#endif
//------------------------------------------------------------------------------
// Test function
//------------------------------------------------------------------------------
void
ESO2problem::test()
{
  //OsiRelFltEq eq(1e-05);
  CoinRelFltEq eq(1.e-05);

  {
    ESO2problem prob;
    
    prob.setNPeriods(12);
    assert( prob.getNPeriods() == 12 );
    
    prob.setTitle("wittitle");
    assert( prob.getTitle() == "wittitle");

    assert( prob.implosionCount()==0 );
    

  }


         
  // Test mtm interplant time and deman time
  {
    ESO2problem prob;
    prob.setNPeriods(25);
    prob.setPeriod1SupplyPerishPeriod(0);

    prob.addMtm("m1","loc1",0.,25);
    prob.setMtmSupply("m1","loc1",0,3.0f);
    
    prob.setMtmDemanCost("m1","loc1",4,2.0f);
    prob.setMtmDemanTime("m1","loc1",4,3.0f);

    prob.setMtmWfmv("m1","loc1",0,0.1f);

    prob.addMtmInterplant("m1","loc1","loc2",0.5f,1.0f);
#if 0
    std::vector<float> vTime = prob.floatToStlVec(0.0f);
    std::vector<float> vCost = vTime;
    vCost[3]=1.0f;
    prob.setMtmDemanCost("m1","loc1","loc2",vCost);
    vTime[3]=2.f;
    prob.setMtmDemanTime("m1","loc1","loc2",vTime);
#else
    prob.setMtmDemanCost("m1","loc1","loc2",3,1.0f);
    prob.setMtmDemanTime("m1","loc1","loc2",3,2.0f);
#endif
 
    prob.addDemanBom("m1","p1","loc1");

    prob.setDemanBomAttachRate("m1","p1","loc1",0,1.0f);

    prob.addPartDemand("p1","US","loc2");
    prob.setPartDemandDemandVol("p1","US","loc2",3,1.0f);
    prob.setPartDemandWac("p1","US","loc2",3,10.0f);
#if 0
    {
      std::string demanMtmWitName = demanMtmName("m1","loc1","loc2" );
      std::vector<float> demanTime = prob.witGetArcAttribute(witGetBomEntryOffset,demanMtmWitName,0);
      assert( demanTime[0]==100.0f );
      assert( demanTime[1]==3.0f );
      assert( demanTime[2]==100.0f );
      assert( demanTime[3]==100.0f );
    }
#endif

    prob.solveWithPegging();
    assert( prob.implosionCount()==6 );
    prob.reportPartDemand("p1","US","loc2",3);
    std::vector<float> sv = prob.getPartDemandShipVol("p1","US","loc2");
    assert(sv[0]==0.0f);
    assert(sv[1]==0.0f);
    assert(sv[2]==0.0f);
    assert(sv[3]==1.0f);
    assert(sv[4]==0.0f);
    
    std::vector<std::string> acquireMtms,mtmSrcLocs,mtmAcquireLocs;
    std::vector<int> mtmAcquirePeriods,depths;
    std::vector<float> mtmAcquireQuantity;       

    std::vector<std::string> demanMtms,demanLocs;
    std::vector<int> demanPeriods;
    std::vector<float> demanQuantity;    

    std::vector<std::string> features,featurePlantLocs;
    std::vector<int> featureAcquirePeriods;
    std::vector<float> featureAcquireQuantity;    
    std::vector<std::string> looseParts,loosePartPlantLocs;
    std::vector<int> loosePartAcquirePeriods;
    std::vector<float> loosePartAcquireQuantity;
    prob.getPartDemandPegging(
      "MtmAcquire",
      "p1","US","loc2",3, 
      acquireMtms,mtmAcquireLocs,mtmAcquirePeriods,depths,mtmAcquireQuantity );
    size_t m1= acquireMtms.size();

    
    prob.getPartDemandPegging(
      "MtmAcquire",
      "p1","US","loc2",0,  
      acquireMtms,mtmAcquireLocs,mtmAcquirePeriods,depths,mtmAcquireQuantity );
    size_t m2= acquireMtms.size();
    assert(m1!=m2);
  }

  
  // Test loose part perishability
  {
    ESO2problem prob;
    prob.setNPeriods(4);
    prob.setPeriod1SupplyPerishPeriod(2);
    prob.addLoosePart("lp1","loc1");
    prob.setLoosePartSupply("lp1","loc1",0,3.0f);

    prob.setLoosePartWfmv("lp1","loc1",0,0.1f);
    //prob.setLoosePartWfmv("lp1","loc1",1,1000.0f);
    //prob.setLoosePartWfmv("lp1","loc1",2,1000.0f);
    //prob.setLoosePartWfmv("lp1","loc1",3,1000.0f);

    prob.addPartDemand("lp1","US","loc1");
    prob.setPartDemandDemandVol("lp1","US","loc1",0,1.0f);
    prob.setPartDemandDemandVol("lp1","US","loc1",1,1.0f);
    prob.setPartDemandDemandVol("lp1","US","loc1",2,1.0f);
    prob.setPartDemandDemandVol("lp1","US","loc1",3,1.0f);
    prob.setPartDemandWac("lp1","US","loc1",0,10.0f);
    prob.setPartDemandWac("lp1","US","loc1",1,10.0f);
    prob.setPartDemandWac("lp1","US","loc1",2,10.0f);
    prob.setPartDemandWac("lp1","US","loc1",3,10.0f);

    prob.solveWithPegging();
    std::vector<float> sv = prob.getPartDemandShipVol("lp1","US","loc1");
    assert(sv[0]==1.0f);
    assert(sv[1]==1.0f);
    assert(sv[2]==1.0f);
    assert(sv[3]==0.0f);
  }

    // Test loose part perishability
  {
    ESO2problem prob;
    createModel(prob, "../data/loosePartPerishability", true );

    prob.solveWithPegging();
    std::vector<float> sv = prob.getPartDemandShipVol("lp1","US","loc1");
    assert(sv[0]==1.0f);
    assert(sv[1]==1.0f);
    assert(sv[2]==1.0f);
    assert(sv[3]==0.0f);
  }

    
  // Test feature perishability
  {
    ESO2problem prob;
    prob.setNPeriods(4);
    prob.setPeriod1SupplyPerishPeriod(2);
    prob.addFeature("f1","loc1");
    prob.setFeatureSupply("f1","loc1",0,3.0f);

    prob.setFeatureWfmv("f1","loc1",0,0.1f);
    //prob.setFeatureWfmv("f1","loc1",1,1000.1f);
    //prob.setFeatureWfmv("f1","loc1",2,1000.1f);
    //prob.setFeatureWfmv("f1","loc1",3,1000.1f);

    prob.addFeatureXref("p1","f1","loc1");
    prob.setFeatureXrefCost("p1","f1","loc1",0,0);
    prob.setFeatureXrefCost("p1","f1","loc1",1,0);
    prob.setFeatureXrefCost("p1","f1","loc1",2,0);
    prob.setFeatureXrefCost("p1","f1","loc1",3,0);
    prob.setFeatureXrefUsageTime("p1","f1","loc1",0,0.0f);
    prob.setFeatureXrefUsageTime("p1","f1","loc1",1,0.0f);
    prob.setFeatureXrefUsageTime("p1","f1","loc1",2,0.0f);
    prob.setFeatureXrefUsageTime("p1","f1","loc1",3,0.0f);
    prob.setFeatureXrefProdRate("p1","f1","loc1",0,1.0f);
    prob.setFeatureXrefProdRate("p1","f1","loc1",1,1.0f);
    prob.setFeatureXrefProdRate("p1","f1","loc1",2,1.0f);
    prob.setFeatureXrefProdRate("p1","f1","loc1",3,1.0f);

    prob.addPartDemand("p1","US","loc1");
    prob.setPartDemandDemandVol("p1","US","loc1",0,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",1,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",2,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",3,1.0f);
    prob.setPartDemandWac("p1","US","loc1",0,10.0f);
    prob.setPartDemandWac("p1","US","loc1",1,10.0f);
    prob.setPartDemandWac("p1","US","loc1",2,10.0f);
    prob.setPartDemandWac("p1","US","loc1",3,10.0f);

    prob.solveWithPegging();
    //prob.reportPartDemand("p1","US","loc1",0);
    std::vector<float> sv = prob.getPartDemandShipVol("p1","US","loc1");
    assert(sv[0]==1.0f);
    assert(sv[1]==1.0f);
    assert(sv[2]==1.0f);
    assert(sv[3]==0.0f);
  }

      
  // Test mtm perishability
  {
    ESO2problem prob;
    prob.setNPeriods(4);
    prob.setPeriod1SupplyPerishPeriod(2);
    prob.addMtm("m1","loc1",0,5);
    prob.setMtmSupply("m1","loc1",0,3.0f);

    prob.setMtmDemanCost("m1","loc1",0,0.0f);
    prob.setMtmDemanCost("m1","loc1",1,0.0f);
    prob.setMtmDemanCost("m1","loc1",2,0.0f);
    prob.setMtmDemanCost("m1","loc1",3,0.0f);

    prob.setMtmDemanTime("m1","loc1",0,0.0f);
    prob.setMtmDemanTime("m1","loc1",1,0.0f);
    prob.setMtmDemanTime("m1","loc1",2,0.0f);
    prob.setMtmDemanTime("m1","loc1",3,0.0f);

    prob.setMtmWfmv("m1","loc1",0,0.1f);
    prob.setMtmWfmv("m1","loc1",1,0.1f);
    prob.setMtmWfmv("m1","loc1",2,0.1f);
    prob.setMtmWfmv("m1","loc1",3,0.1f);

    prob.addDemanBom("m1","p1","loc1");

    prob.setDemanBomAttachRate("m1","p1","loc1",0,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",1,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",2,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",3,1.0f);

    prob.addPartDemand("p1","US","loc1");
    prob.setPartDemandDemandVol("p1","US","loc1",0,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",1,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",2,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc1",3,1.0f);
    prob.setPartDemandWac("p1","US","loc1",0,10.0f);
    prob.setPartDemandWac("p1","US","loc1",1,10.0f);
    prob.setPartDemandWac("p1","US","loc1",2,10.0f);
    prob.setPartDemandWac("p1","US","loc1",3,10.0f);

    prob.solveWithPegging();
    //prob.reportPartDemand("p1","US","loc1",0);
    std::vector<float> sv = prob.getPartDemandShipVol("p1","US","loc1");
    assert(sv[0]==1.0f);
    assert(sv[1]==1.0f);
    assert(sv[2]==1.0f);
    assert(sv[3]==0.0f);
  }

  
      
  // Test mtm perishability with mtm interplant
  {
    ESO2problem prob;
    prob.setNPeriods(4);
    prob.setPeriod1SupplyPerishPeriod(2);

    prob.addMtm("m1","loc1",0,5.);
    prob.setMtmSupply("m1","loc1",0,3.0f);

    prob.setMtmDemanCost("m1","loc1",0,0.0f);
    prob.setMtmDemanCost("m1","loc1",1,0.0f);
    prob.setMtmDemanCost("m1","loc1",2,0.0f);
    prob.setMtmDemanCost("m1","loc1",3,0.0f);

    prob.setMtmDemanTime("m1","loc1",0,0.0f);
    prob.setMtmDemanTime("m1","loc1",1,0.0f);
    prob.setMtmDemanTime("m1","loc1",2,0.0f);
    prob.setMtmDemanTime("m1","loc1",3,0.0f);

    prob.setMtmWfmv("m1","loc1",0,0.1f);
    //prob.setMtmWfmv("m1","loc1",1,0.1f);
    //prob.setMtmWfmv("m1","loc1",2,0.1f);
    //prob.setMtmWfmv("m1","loc1",3,0.1f);

    prob.addMtmInterplant("m1","loc1","loc2",0.0f,0.0f);

    prob.setMtmDemanCost("m1","loc1","loc2",0,0.0f);
    prob.setMtmDemanCost("m1","loc1","loc2",1,0.0f);
    prob.setMtmDemanCost("m1","loc1","loc2",2,0.0f);
    prob.setMtmDemanCost("m1","loc1","loc2",3,0.0f);

    prob.setMtmDemanTime("m1","loc1","loc2",0,0.0f);
    prob.setMtmDemanTime("m1","loc1","loc2",1,0.0f);
    prob.setMtmDemanTime("m1","loc1","loc2",2,0.0f);
    prob.setMtmDemanTime("m1","loc1","loc2",3,0.0f);

    prob.addDemanBom("m1","p1","loc1");

    prob.setDemanBomAttachRate("m1","p1","loc1",0,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",1,0.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",2,0.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",3,0.0f);

    prob.addPartDemand("p1","US","loc2");
    prob.setPartDemandDemandVol("p1","US","loc2",0,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc2",1,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc2",2,1.0f);
    prob.setPartDemandDemandVol("p1","US","loc2",3,1.0f);
    prob.setPartDemandWac("p1","US","loc2",0,10.0f);
    prob.setPartDemandWac("p1","US","loc2",1,10.0f);
    prob.setPartDemandWac("p1","US","loc2",2,10.0f);
    prob.setPartDemandWac("p1","US","loc2",3,10.0f);

    prob.solveWithPegging();
    prob.reportPartDemand("p1","US","loc2",0);
    std::vector<float> sv = prob.getPartDemandShipVol("p1","US","loc2");
    assert(sv[0]==1.0f);
    assert(sv[1]==1.0f);
    assert(sv[2]==1.0f);
    assert(sv[3]==0.0f);
  }

  // Test moving loose part once
  {
    ESO2problem prob;
    prob.setNPeriods(1);
    prob.addPartsInterplant("loc1","loc2",0.0f,0.0f);   
    prob.addLoosePart("lp1","loc1");
    prob.setLoosePartSupply("lp1","loc1",0,1.0f);
    prob.setLoosePartWfmv("lp1","loc1",0,0.1f);
    prob.addPartDemand("lp1","US","loc2");
    prob.setPartDemandDemandVol("lp1","US","loc2",0,1.0f);
    prob.setPartDemandWac("lp1","US","loc2",0,10.0f);

    prob.solveWithPegging();
    std::vector<float> sv = prob.getPartDemandShipVol("lp1","US","loc2");
    assert(sv[0]==1.0f);
  }

    
  
  // Test moving loose part twice
  {
    ESO2problem prob;
    prob.setNPeriods(1);
    prob.addPartsInterplant("loc1","loc2",0.0f,0.0f);   
    prob.addPartsInterplant("loc2","loc3",0.0f,0.0f);   
    prob.addLoosePart("lp1","loc1");
    prob.setLoosePartSupply("lp1","loc1",0,1.0f);
    prob.setLoosePartWfmv("lp1","loc1",0,0.1f);
    prob.addPartDemand("lp1","US","loc3");
    prob.setPartDemandDemandVol("lp1","US","loc3",0,1.0f);
    prob.setPartDemandWac("lp1","US","loc3",0,10.0f);

    prob.solveWithPegging();
    std::vector<float> sv = prob.getPartDemandShipVol("lp1","US","loc3");
    assert(sv[0]==0.0f); // If move twice supported then assert would be for 1.0f
  }
  
  // Test low priority demand
  {
    ESO2problem p1;
    p1.setWfmvScaleFactor(0.0f,0.0f);
    createModel(p1, "../data/03Apr07KevinOwithLPDemand", true );
    
    p1.solveWithPegging();


    // Open partShip file and write header.
    {
      std::string heading;
      heading="\"part\",\"custLoc\",\"plantLoc\",\"period\",\"demandVol\",\"shipVol\""; 
      printf("%s\n",heading.c_str());
      
      std::vector<std::string> parts;
      std::vector<std::string> custLocs;
      std::vector<std::string> plantLocs;
      p1.getPartDemands(parts,custLocs,plantLocs);
      
      // loop once for each shipped part
      int p;
      for ( p=0; p<parts.size(); p++ ) {
        
        std::vector<float> demandVol = p1.getPartDemandDemandVol(parts[p],custLocs[p],plantLocs[p]);
        std::vector<float> shipVol = p1.getPartDemandShipVol(parts[p],custLocs[p],plantLocs[p]);
        std::vector<float> wac = p1.getPartDemandWac(parts[p],custLocs[p],plantLocs[p]);
        
        for ( int t=0; t<shipVol.size(); t++ ) {
          if ( shipVol[t]==0.0 ) continue;
          printf( "\"%s\",\"%s\",\"%s\",%d,%f,%f\n",
            parts[p].c_str(),custLocs[p].c_str(),plantLocs[p].c_str(),t,demandVol[t],shipVol[t]);
          //partAcquireAvoidanceValue += shipVol[t]*wac[t];
        } // finished t loop
      } // finished p loop
    } // finished writing partShip file

    std::vector<float> vol = p1.getPartDemandShipVol("0000000P1413","980","980");
    assert(eq(vol[0],0.0));
    assert(eq(vol[1],137.));
    assert(eq(vol[2],137.));
    assert(eq(vol[3],21.));
    assert(eq(vol[4],16.));
    assert(eq(vol[5],16.));
    assert(eq(vol[6],16.));
    assert(eq(vol[7],23.));
    assert(eq(vol[8],20.));
    assert(eq(vol[9],21.));
    assert(eq(vol[10],22.));
    assert(eq(vol[11],28.));
    assert(eq(vol[12],55.));
    assert(eq(vol[13],55.));
    assert(eq(vol[14],56.));
    assert(eq(vol[15],57.));
    assert(eq(vol[16],3.));
    assert(eq(vol[17],3.));
    vol = p1.getPartDemandShipVol("0000000P1414","980","980");
    assert(eq(vol[0],0.0));
    assert(eq(vol[1],0.0));
    assert(eq(vol[2],0.0));
    assert(eq(vol[3],0.0));
    assert(eq(vol[4],0.0));
    assert(eq(vol[5],0.0));
    assert(eq(vol[6],0.0));
    assert(eq(vol[7],0.0));
    assert(eq(vol[8],0.0));
    assert(eq(vol[9],0.0));
    assert(eq(vol[10],0.0));
    assert(eq(vol[11],0.0));
    assert(eq(vol[12],0.0));
    assert(eq(vol[13],55.));
    assert(eq(vol[14],0.0));
    assert(eq(vol[15],47.));
    assert(eq(vol[16],0.0)||eq(vol[16],3.));

  } // end Test low priority demand

  // Test example3 - mtm only, high/low priority demand, perishable inventory
  {
    ESO2problem p1;
    createModel(p1, "../data/example3", true );
    p1.solveWithPegging();

    std::vector<float> sv = p1.getPartDemandShipVol("p2","highPriority1","loc3");
    assert(eq(sv[3],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","highPriority2","loc3");
    assert(eq(sv[4],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));
    
    sv = p1.getPartDemandShipVol("p2","highPriority3","loc3");
    assert(eq(sv[5],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","lowPriority1","loc3");
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),0.0f));

    sv = p1.getPartDemandShipVol("p2","lowPriority2","loc3");
    assert(eq(sv[5],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    std::vector<float> aq = p1.getMtmAcquireQtyWithOffset("mtm1","invLoc1","loc2");
    assert(eq(aq[0],1.0f));
    assert(eq(aq[1],1.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),2.0f));

    aq = p1.getMtmAcquireQtyWithOffset("mtm1","loc1","loc2");
    assert(eq(aq[2],2.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),2.0f));

    std::vector<float> pi = p1.getPartInterplantMoveVolWithOffset("p2","loc2","loc3");
    assert(eq(pi[2],1.0f));
    assert(eq(pi[3],1.0f));
    assert(eq(pi[4],2.0f));
    assert(eq(std::accumulate(pi.begin(),pi.end(),0.0f),4.0f));

    double obj=p1.getObjValue();
    //assert(eq(obj,484.));
    assert(eq(obj,488.));

    // test example 3 pegging
    {
      std::vector<std::string>  items,locs; 
      std::vector<int> periods; 
      std::vector<int> depths; 
      std::vector<float> quanity; 

      p1.getPartDemandPegging("MtmAcquire",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==90);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("mtm1","invLoc1",1-1,1.f));

      p1.getPartDemandPegging("MtmMoveFrom",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==91);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("mtm1","invLoc1",1-1,1.f));

      p1.getPartDemandPegging("MtmMovedTo",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==92);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("mtm1","loc2",2-1,1.f));
      
      p1.getPartDemandPegging("MtmDisassemble",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==140);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("mtm1","loc2",2-1,1.f));
      
      p1.getPartDemandPegging("PartHarvestedFromMtm",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==141);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc2",3-1,1.f));
      
      p1.getPartDemandPegging("PartMoveFrom",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==620);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc2",3-1,1.f));
      
      p1.getPartDemandPegging("PartMovedTo",  "p2","highPriority1","loc3",4-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==621);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc3",4-1,1.f));

    } // end of test example 3 pegging

  } // end of Test example3

  // test applying Wfmv ScaleFactor by Loc using example 3
  {
    ESO2problem px;
    createModel(px, "../data/example3", true );
    px.solveWithPegging();
    double objx=px.getObjValue();
    
    ESO2problem py;
    createModel(py, "../data/example3", true );
    py.setWfmvScaleFactor(0.5f,0.5f);
    py.solveWithPegging();
    double objy=py.getObjValue();
    
    ESO2problem pa;
    createModel(pa, "../data/example3", true );
    pa.setWfmvScaleFactor(0.75f,0.75f);
    pa.setApplyLocWfmvScaleFactor("loc1",1);
    pa.setApplyLocWfmvScaleFactor("invLoc1",1);
    pa.solveWithPegging();
    double obja=pa.getObjValue();
    
    ESO2problem pb;
    createModel(pb, "../data/example3", true );
    pb.setWfmvScaleFactor(0.5f,0.5f);
    pb.setApplyLocWfmvScaleFactor("loc1",1);
    pb.setApplyLocWfmvScaleFactor("invLoc1",1);
    pb.solveWithPegging();
    double objb=pb.getObjValue();

    assert(eq(objx,objy));
    assert(objx>obja);
    assert(obja<objb);
    //double dif1=obja-objx;
    //double dif2=objb-obja;
    //assert(eq(dif1,dif2));
    
  }



  // Test example4 - feature only, high/low priority demand, perishable inventory
  {
    ESO2problem p1;
    createModel(p1, "../data/example4", true );
    p1.solveWithPegging();

    std::vector<float> sv = p1.getPartDemandShipVol("p2","highPriority1","loc3");
    assert(eq(sv[2],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","highPriority2","loc3");
    assert(eq(sv[3],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));
    
    sv = p1.getPartDemandShipVol("p2","lowPriority2","loc3");
    assert(eq(sv[4],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","lowPriority1","loc3");
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),0.0f));


    std::vector<float> aq = p1.getFeatureAcquireQty("f1","invLoc4");
    assert(eq(aq[0],1.0f));
    assert(eq(aq[1],1.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),2.0f));

    aq = p1.getFeatureAcquireQty("f1","loc4");
    assert(eq(aq[2],1.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),1.0f));

    std::vector<float> fx = p1.getFeatureXrefVol("p2","f1","invLoc4");
    assert(eq(fx[1],1.0f));
    assert(eq(fx[2],1.0f));
    assert(eq(std::accumulate(fx.begin(),fx.end(),0.0f),2.0f));
    
    fx = p1.getFeatureXrefVol("p2","f1","loc4");
    assert(eq(fx[3],1.0f));
    assert(eq(std::accumulate(fx.begin(),fx.end(),0.0f),1.0f));

    std::vector<float> pi = p1.getPartInterplantMoveVolWithOffset("p2","invLoc4","loc3");
    assert(eq(pi[1],1.0f));
    assert(eq(pi[2],1.0f));
    assert(eq(std::accumulate(pi.begin(),pi.end(),0.0f),2.0f));

    pi = p1.getPartInterplantMoveVolWithOffset("p2","loc4","loc3");
    assert(eq(pi[3],1.0f));
    assert(eq(std::accumulate(pi.begin(),pi.end(),0.0f),1.0f));

    double obj=p1.getObjValue();
    //assert(eq(obj,1190.));
    assert(eq(obj,1193.));
    
    // test example 4 pegging
    {
      std::vector<std::string>  items,locs; 
      std::vector<int> periods;  
      std::vector<int> depths; 
      std::vector<float> quanity; 

      p1.getPartDemandPegging("MtmAcquire",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);

      p1.getPartDemandPegging("MtmMoveFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);

      p1.getPartDemandPegging("MtmMovedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);
      
      p1.getPartDemandPegging("MtmDisassemble",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);
      
      p1.getPartDemandPegging("PartHarvestedFromMtm",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);

      p1.getPartDemandPegging("FeatureAcquire",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==20);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("f1","invLoc4",1-1,1.f));

      p1.getPartDemandPegging("FeatureXrefFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==210);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("f1","invLoc4",1-1,1.f));

      p1.getPartDemandPegging("PartXrefedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==211);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","invLoc4",2-1,1.f));
      
      p1.getPartDemandPegging("PartMoveFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==280);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","invLoc4",2-1,1.f));
      
      p1.getPartDemandPegging("PartMovedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==281);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc3",3-1,1.f));

    } // end of test example 4 pegging


  } // end of Test example4


  // Test example5 - loose parts only, high/low priority demand, perishable inventory
  {
    ESO2problem p1;
    createModel(p1, "../data/example5", true );
    p1.solveWithPegging();

    std::vector<float> sv = p1.getPartDemandShipVol("p2","highPriority1","loc3");
    assert(eq(sv[2],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","highPriority2","loc3");
    assert(eq(sv[3],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));
    
    sv = p1.getPartDemandShipVol("p2","lowPriority2","loc3");
    assert(eq(sv[4],1.0f));
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),1.0f));

    sv = p1.getPartDemandShipVol("p2","lowPriority1","loc3");
    assert(eq(std::accumulate(sv.begin(),sv.end(),0.0f),0.0f));


    std::vector<float> aq = p1.getLoosePartAcquireQty("lp1","invLoc5");
    assert(eq(aq[0],1.0f));
    assert(eq(aq[1],1.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),2.0f));

    aq = p1.getLoosePartAcquireQty("lp1","loc5");
    assert(eq(aq[2],1.0f));
    assert(eq(std::accumulate(aq.begin(),aq.end(),0.0f),1.0f));

    std::vector<float> ap = p1.getAltVolWithOffset("lp1","p2","invLoc5");
    assert(eq(ap[0],1.0f));
    assert(eq(ap[1],1.0f));
    assert(eq(std::accumulate(ap.begin(),ap.end(),0.0f),2.0f));
    
    ap = p1.getAltVolWithOffset("lp1","p2","loc5");
    assert(eq(ap[2],1.0f));
    assert(eq(std::accumulate(ap.begin(),ap.end(),0.0f),1.0f));

    std::vector<float> pi = p1.getPartInterplantMoveVolWithOffset("p2","invLoc5","loc3");
    assert(eq(pi[1],1.0f));
    assert(eq(pi[2],1.0f));
    assert(eq(std::accumulate(pi.begin(),pi.end(),0.0f),2.0f));

    pi = p1.getPartInterplantMoveVolWithOffset("p2","loc5","loc3");
    assert(eq(pi[3],1.0f));
    assert(eq(std::accumulate(pi.begin(),pi.end(),0.0f),1.0f));

    double obj=p1.getObjValue();
    //assert(eq(obj,1190.));
    assert(eq(obj,1193.));

    // test example 5 pegging
    {
      std::vector<std::string>  items,locs; 
      std::vector<int> periods;  
      std::vector<int> depths; 
      std::vector<float> quanity; 
      
      p1.getPartDemandPegging("FeatureAcquire",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==0);

      p1.getPartDemandPegging("LoosePartAcquire",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==200);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("lp1","loc5",3-1,1.f));

      p1.getPartDemandPegging("PartAltFrom",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==480);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("lp1","loc5",3-1,1.f));

      p1.getPartDemandPegging("PartAltTo",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==481);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc5",4-1,1.f));
      
      p1.getPartDemandPegging("PartMoveFrom",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==550);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc5",4-1,1.f));
      
      p1.getPartDemandPegging("PartMovedTo",  "p2","lowPriority2","loc3",5-1, items,locs,periods,depths,quanity);
      assert(items.size()==1);
      assert(depths[0]==551);
      assert( ESO2stringStringIntFloatTuple(items[0],locs[0],periods[0],quanity[0]) == ESO2stringStringIntFloatTuple("p2","loc3",5-1,1.f));

    } // end of test example 5 pegging

  } // end of Test example5
  
//#define WRITE_RESULTS
#ifdef WRITE_RESULTS
  FILE * file = fopen("unitTestResults.csv","w");
  fprintf(file,"tc,perishLimit,p,sf,allowInventoryHoldingAtDemandLocation,removeCycles,objValue\n");
#else
  std::string fileName = "unitTestResults.csv";
  ESO2unitTestResultsData file(fileName.c_str());
#endif

  std::vector<std::string> testCases;
  testCases.push_back("../data/example2" );
  testCases.push_back("../data/03Apr07KevinO" );
  testCases.push_back("../data/03Apr03KevinOB" );
  testCases.push_back("../data/03Apr03KevinOA" );
  testCases.push_back("../data/03Mar31KevinO" );
  testCases.push_back("../data/testcaseA00" );
  testCases.push_back("../data/example1" );
  //testCases.push_back("../data/08JFP09base575" );
  
  std::vector<float> scaleFactors;
  scaleFactors.push_back(1.0f);
  scaleFactors.push_back(0.5f);
  scaleFactors.push_back(0.f);
  
  std::vector<int> mtmPriority;
  std::vector<int> featurePriority;
  std::vector<int> loosePartPriority;
  mtmPriority.push_back(3);
  featurePriority.push_back(1);
  loosePartPriority.push_back(2);
  mtmPriority.push_back(2);
  featurePriority.push_back(1);
  loosePartPriority.push_back(3);
  mtmPriority.push_back(2);
  featurePriority.push_back(2);
  loosePartPriority.push_back(2);
  mtmPriority.push_back(1);
  featurePriority.push_back(2);
  loosePartPriority.push_back(2);
  
  // Test pruning and assignment with varying
  // test problems, scale factors, and priorities.
  {
    int tc;
    for ( tc=0; tc<testCases.size(); ++tc ) {  

    for ( int allowInvAtDemLoc=0; allowInvAtDemLoc<2; ++allowInvAtDemLoc ) {
    
    int remCyc=allowInvAtDemLoc;
    //for ( int remCyc=0; remCyc<2; ++remCyc ) {

#if 0
      // Test getPartLocs function
      {
        ESO2problem prob;
        createModel(prob, testCases[tc], true );
        std::vector<std::string> parts = p.getParts();
        for ( part
      }
#endif
      
      //if ( tc==1 ) continue;
      //if ( tc==2 ) continue;
      //if ( tc==3 ) continue;
      //if ( tc==4 ) continue;
      //if ( tc==5 ) continue;

      int perishLimit;
      for ( perishLimit=0; perishLimit<6; perishLimit=perishLimit+3 ) {
        int p;
        for ( p=0; p<mtmPriority.size(); ++p ) {
          
          ESO2problem p1;
          ESO2problem p2;
          ESO2problem p3;
          
          p1.setPeriod1SupplyPerishPeriod(perishLimit);
          p1.setAllowInventoryHoldingAtDemandLocation(allowInvAtDemLoc);
          p1.setRemoveCycles(remCyc);
          
          bool useGlobalAttrFileSettings = false;
          createModel(p1, testCases[tc].c_str(), useGlobalAttrFileSettings );
          
          p1.setMtmPriority(mtmPriority[p]);
          p1.setFeaturePriority(featurePriority[p]);
          p1.setLoosePartPriority(loosePartPriority[p]);
          //p1.setFeaturePriority(4);
          //p1.setLoosePartPriority(4);
          
          p2=p1;
          p3=p2;
          p3.pruneWitModel();
          
          int sf;
          for ( sf=0; sf<scaleFactors.size(); ++sf ) {
            
            p1.setWfmvScaleFactor(scaleFactors[sf],scaleFactors[sf]);
            p2.setWfmvScaleFactor(scaleFactors[sf],scaleFactors[sf]);
            p3.setWfmvScaleFactor(scaleFactors[sf],scaleFactors[sf]);
            
            std::cout 
              <<"tc="<<tc 
              <<" perishLimit=" <<perishLimit
              <<" p=" <<p
              <<" sf=" <<sf
              <<std::endl;
               
            p1.solveWithPegging();
            p2.solveWithPegging();        
            p3.solveWithPegging();
            
            double p1Obj = p1.getObjValue();
            double p2Obj = p2.getObjValue();
            double p3Obj = p3.getObjValue();
            assert( p1Obj==p2Obj || tc==6 );
#if 1
            if ( p1Obj != p3Obj ) {
              p1.compareWitSolutions(p1,p3);
              //p3.reportPartDemand("p2","pok","pok",0);
              //p1.writeWitData("p1.wit");
              //p3.writeWitData("p3.wit");

            }
#endif
            assert( p1Obj==p3Obj || tc==6 );

            // determine which parts are being scrapped
            {  
              witAttr objItrState;
              witGetObjItrState(p3.witRun(), &objItrState);
              while( true )   {
                witAdvanceObjItr(p3.witRun());
                witGetObjItrState(p3.witRun(), &objItrState);
                if (objItrState==WitINACTIVE) break;
                if( objItrState == WitAT_PART ) {
                  char * name;
                  witGetObjItrPart(p3.witRun(),&name);

                  // if it is an IGF part, then OK to scrap
                  std::string stdName(name);
                  witFree(name);
                  if ( beginsWith(stdName,"igf: ") ) 
                    continue;

                  // if it is a wit modeling trick, then OK to scrap
                  if ( beginsWith(stdName,"regulator for: part: ") ) 
                    continue;
                  
                  std::vector<float> scrapVol = p3.witGetNameAttribute(witGetPartScrapVol,stdName);
                  
                  int p;
                  for( p=0; p<scrapVol.size(); p++ ) {
                    if (scrapVol[p]!=0.0) {
                      printf("Nonzero scrapVol[%d] for %s\n",p,stdName.c_str());
                      continue;
                    }
                  }
                }
              }

            }

            // Test KPI Functions
            {
              CoinRelFltEq eq(1.e-6);
              CoinRelFltEq eq5(1.e-5);
              double obj=p3.getObjValue();
              std::map<std::string,double> wacComponents;
              double wac=p3.sumOfWac(wacComponents);
              double featureWfmv=p3.sumOfFeatureWfmvWithScaleFactor();
              double loosePartWfmv=p3.sumOfLoosePartWfmvWithScaleFactor();
              double mtmWfmv=p3.sumOfMtmWfmvWithScaleFactor();
              double demanCost=p3.sumOfDemanCost();
              double mtmMoveCost=p3.sumOfMtmMoveCost();
              double partMoveCost=p3.sumOfPartMoveCost();
              double featureXrefCost=p3.sumOfFeatureXrefCost();
              double altCost=p3.sumOfAltCost();

              {
                std::map<std::string,double>::const_iterator it;
                double sumOfWacComponents=0;
                for( it=wacComponents.begin(); it!=wacComponents.end(); ++it ) {
                  sumOfWacComponents+=it->second;
                }
                assert( eq(sumOfWacComponents, wac ) );
              }
       
              double calcObj=
                wac -
                (mtmWfmv + featureWfmv + altCost + loosePartWfmv +
                demanCost +
                mtmMoveCost + partMoveCost +
                featureXrefCost);
              assert(eq5(calcObj,obj));
              
              double mtmTotalWfmvWithScale;
              double mtmSumAcquireCost;
              double mtmSumMoveCost;
              double mtmSumDemanCost;
              int mtmNumUnique;
              int mtmNumUniqueAcquired;
              double mtmSupplyQuantity;
              double mtmAcquiredQuantity;
              
              p3.mtmMetrics(
                mtmTotalWfmvWithScale,
                mtmSumAcquireCost,
                mtmSumMoveCost,
                mtmSumDemanCost,
                mtmNumUnique,
                mtmNumUniqueAcquired,
                mtmSupplyQuantity,
                mtmAcquiredQuantity);
              
              double featureTotalWfmvWithScale;
              double featureSumAcquireCost;
              double featureSumXrefCost;
              int featureNumUnique;
              int featureNumUniqueAcquired;
              double featureSupplyQuantity;
              double featureAcquiredQuantity;
              
              p3.featureMetrics(
                featureTotalWfmvWithScale,
                featureSumAcquireCost,
                featureSumXrefCost,
                featureNumUnique,
                featureNumUniqueAcquired,
                featureSupplyQuantity,
                featureAcquiredQuantity);

              double loosePartTotalWfmvWithScale;
              double loosePartSumAcquireCost;
              double loosePartAltSumCost;
              int loosePartNumUnique;
              int loosePartNumUniqueAcquired;
              double loosePartSupplyQuantity;
              double loosePartAcquiredQuantity;
              
              p3.loosePartMetrics(
                loosePartTotalWfmvWithScale,
                loosePartSumAcquireCost,
                loosePartAltSumCost,
                loosePartNumUnique,
                loosePartNumUniqueAcquired,
                loosePartSupplyQuantity,
                loosePartAcquiredQuantity);
              
              double partDemandSumDemandWac;
              double partDemandSumShippedWac;
              int partDemandNumUnique;
              int partDemandNumUniqueShipped;
              double partDemandSumDemandVol;
              double partDemandSumShipVol;
              std::map<std::string,double> sumShippedWacComponents;
              
              p3.partDemandMetrics(
                partDemandSumDemandWac,
                partDemandSumShippedWac,
                sumShippedWacComponents,
                partDemandNumUnique,
                partDemandNumUniqueShipped,
                partDemandSumDemandVol,
                partDemandSumShipVol);
            }

            
#ifdef WRITE_RESULTS
            {
              fprintf(file,"%d,%d,%d,%d,%d,%d,%f\n",tc,perishLimit,p,sf,allowInvAtDemLoc,remCyc,p1Obj);
            }
#else
            {
              float historicObjValue = file.objValueAsFloat(file.key(tc,perishLimit,p,sf,allowInvAtDemLoc,remCyc));
              assert( eq(p1Obj,historicObjValue) );
              //assert( eq(p1Obj,historicObjValue) || tc==5 );
            }
#endif
          } // end for sf loop  
        } // end for p loop
      } // end for perishLimit loop
    //} // end for remCyc loop
    } // end for allowInvAtDemLoc loop
    } // end for tc loop
  }
  
#ifdef WRITE_RESULTS
  fclose(file);
#endif
  
}


@


1.117
log
@Changes to add code to remove cycles. Also removes some pruning messages.
@
text
@d6889 1
a6889 1
  fprintf(file,"tc,perishLimit,p,sf,objValue\n");
d6903 1
d6932 5
d6963 2
d7051 1
d7079 1
a7079 1
              assert(eq(calcObj,obj));
d7155 1
a7155 1
              fprintf(file,"%d,%d,%d,%d,%f\n",tc,perishLimit,p,sf,p1Obj);
d7159 1
a7159 1
              float historicObjValue = file.objValueAsFloat(file.key(tc,perishLimit,p,sf));
d7167 2
@


1.116
log
@Restructured to get ready to implement solve that tolerates cycles.
Added a new method call sovleWithCycles.
At momement it just invokes solve followed by doPegging.
@
text
@d5 1
a424 1

d426 1
d466 4
a469 4
        std::vector<StdVecInt> impPersVecs;
        impPersVecs.push_back( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,demanOpName,0) );
        impPersVecs.push_back( getProb->witGetArcAttribute(witGetBopEntryImpactPeriod,moveAndAcquireOpName,0) );
        impPersVecs.push_back( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,moveAndAcquireOpName,0) );
d535 5
a539 4
     std::vector<StdVecInt> impPersVecs;
     impPersVecs.push_back( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,xrefOpName,0) );
     impPersVecs.push_back( getProb->witGetArcAttribute(witGetBopEntryImpactPeriod,acquireFeatureOpName,0) );
     impPersVecs.push_back( getProb->witGetArcAttribute(witGetBomEntryImpactPeriod,acquireFeatureOpName,0) );
d544 1
a544 1
     std::vector<float> applProdRate = getFeatureXrefProdRate(parts[x],features[x],locs[x]);
d576 2
a577 1
    delete getProb;
d3066 235
d3309 3
a3314 7
  //std::cout <<"Calling witWriteData" <<std::endl;
  //witWriteData(mutableWitRun(),"prune.wit");
  //witDeleteRun(witRun());
  
  //std::cout <<"Pruning unused objects from model" <<std::endl;
  //FILE * pruneF=fopen("prune.txt","w");

a3354 1

d3369 1
a3369 6
        std::cout <<"Prunning: " <<opName.c_str() <<std::endl;

        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",mpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",opName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",pName.c_str());
d3395 1
a3395 6
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;
        
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",mpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",opName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",pName.c_str());
d3422 1
a3422 7
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;

        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",mpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",opName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",igfPName.c_str());
d3451 1
a3451 7
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;

        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",mpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",opName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",igfFName.c_str());
a3481 5
      //std::string pName = partName(altParts[p],locs[p]);
      //std::string mpName = moveablePartName(altParts[p],locs[p]);
      //std::string opName = acquireFeatureName(features[p],locs[p]);
      //std::string igfFName = igfFeatureName(features[p],locs[p]);
      //std::string baseName = baseFeatureName(features[p],locs[p]);
a3483 1
        std::cout <<"Prunning: " <<upLevelPartName.c_str() <<std::endl;
d3485 10
a3494 11
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",mpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",opName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",pName.c_str());
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",igfFName.c_str());

        witSetPartSelForDel(witRun(),upLevelPartName.c_str(),WitTRUE);
        //witSetPartSelForDel(witRun(),moveableUpLevelPartName.c_str(),WitTRUE);
        //witSetOperationSelForDel(witRun(),ecOpName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),upLevelPartName.c_str(),WitTRUE);
        //alts_.erase(ecOpName);
d3496 2
a3497 1
        removePartOrFeatureLoc(altParts[p],locs[p]);
d3519 1
a3519 5
        std::cout <<"Prunning: " <<demanOpName.c_str() <<std::endl;
        
        //fprintf(pruneF,"witSetPartSelForDel\n%s\n",serverPName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",acquireOpName.c_str());
        //fprintf(pruneF,"witSetOperationSelForDel\n%s\n",demanOpName.c_str());
d3545 1
a3545 1
          std::cout <<"Prunning: " <<producedPart <<std::endl;  
a3546 1
          //fprintf(pruneF,"witSetPartSelForDel\n%s\n",producedPart);
a3572 2
  //fclose(pruneF);
  
d4080 1
d4619 49
d5686 5
d5708 10
d5749 1
d5849 1
d5904 1
@


1.115
log
@Modified pruning function to not use witGetPartBelowList.
@
text
@a3458 5
  // Label depth of Wit Objects to determine order that they are performed.
  // This is important when they are done in the same period
  std::map<std::string,int> operationDepths;
  std::map<std::string,int> partDepths;
  labelObjectDepth(operationDepths,partDepths);
d3879 16
a3894 1
  // Do pegging
d3896 11
a3906 19
    
    
#if 0
    // Is it only deman ops that have multiple bops?
    // Tests show that only demanOps have multiple bops
    {
      // Get all wit operations
      int nOps;
      char ** ops;
      witGetOperations(mutableWitRun(),&nOps,&ops);
      int o;
      for ( o=0; o<nOps; ++o ) {
        int nBops;
        witGetOperationNBopEntries(mutableWitRun(),ops[o],&nBops);
        if ( nBops> 1 ) 
          assert( isMtmDemanName(ops[o]) );
        witFree(ops[o]);
      }
      witFree(ops);
d3908 2
d3911 20
a3930 15
    
    
    // clear pegging info in partDemand appData which may be laying around from a prior call to solve
    {
      std::vector<std::string> parts;
      std::vector<std::string> custLocs;
      std::vector<std::string> plantLocs;
      getPartDemands( parts, custLocs, plantLocs);
      int p;
      for (p=0; p<parts.size(); ++p ) { 
        ESO2partDemandAppData * srcAppData;  
        std::string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
        witGetDemandAppData(mutableWitRun(),dName.c_str(),dName.c_str(),(void**)&srcAppData);
        srcAppData->clearPegging();
      }
d3932 36
a3967 34
    
    
    witGetPostprocessed(mutableWitRun(),&postProcessed);
    assert(postProcessed);
    
    
    // Set the PIP sequence
    std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple> demandSet;
    {
      witClearPipSeq(witRun());
      
      // Loop once for each demanded part
      std::vector<std::string> demdParts, demdCustLocs, demdPlantLocs;
      getPartDemands( demdParts, demdCustLocs, demdPlantLocs );
      int d;
      for ( d=0; d<demdParts.size(); ++d ) {
        
        std::string dName = partDemandName(demdParts[d], demdCustLocs[d], demdPlantLocs[d] );
        std::vector<float> shipVol = witGetDemandAttribute(witGetDemandShipVol,dName,dName);
        std::vector<float> shipReward = witGetDemandAttribute(witGetDemandObj1ShipReward,dName,dName);
        
        // Loop once for each period
        int t;
        for ( t=0; t<shipVol.size(); ++t ) {
          if ( shipVol[t]>0.0 ) {
            // Determine value of this shipment
            float value = shipVol[t] * shipReward[t];

            // determine pip sequence by inserting demand in sorted list
            ESO2pipSequenceTriple seq(dName.c_str(),t,shipVol[t],value);
            demandSet.insert(seq);
          }
        } // end loop for each perid t
      } // end loop for each demanded part d
a3968 14
  
      // Loop through each pipSequenceTriple and add them to the pip sequence
      std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple>::const_iterator it;
      int nInserted = 0;
      for (it=demandSet.begin(); it!=demandSet.end(); ++it ) {
        std::string dn = it->getDemandName();
        int sp = it->getShipPeriod();
        float isv = it->getIncShipVol();
        float v = it->getValue();
        witAppendToPipSeq(witRun(),dn.c_str(),dn.c_str(),sp,isv);
        nInserted++;
      }
      assert( nInserted==demandSet.size() );
    } // end setting the PIP sequence
d3970 32
a4001 2
    // Have WIT compute pegging
    witBuildPip(witRun());
d4003 9
a4011 15
    // Extract pegging and store in member data 
    {     
      // Loop through each pipSequenceTriple 
      std::set<ESO2pipSequenceTriple,ESO2sortPipSequenceTriple>::const_iterator it;
      for (it=demandSet.begin(); it!=demandSet.end(); ++it ) {
        std::string dn = it->getDemandName();
        int sp = it->getShipPeriod();
        float isv = it->getIncShipVol();
        ESO2partDemandAppData * appDataPtr;
        witGetDemandAppData(mutableWitRun(),dn.c_str(),dn.c_str(),(void**)&appDataPtr);
        std::string plantLoc = plantLocFromPartDemandName(dn);

        // Since birthed parts can have multiple bops producing them, we need to 
        // ensure that these produced parts are only pegged once
        std::set< std::string > peggedDemanPart;
d4013 2
a4014 1
        // Get operations pegged to demand
d4016 5
a4020 5
          int nOps;
          char ** ops;
          int * execPeriods;
          float * execVols;
          witGetDemandExecVolPip(mutableWitRun(),
d4022 11
a4032 1
            &nOps,&ops,&execPeriods,&execVols);  
d4034 87
a4120 19
          // get produced parts pegged to demand
          std::map<std::string,std::vector<std::pair<int,float> > > peggedProdParts;
          {
            int nProdParts;
            char ** prodParts;
            int * prodPeriods;
            float * prodVols;
            /*witGetDemandExecVolPip*/witGetDemandProdVolPip(mutableWitRun(),
              dn.c_str(),dn.c_str(),sp,
              &nProdParts,&prodParts,&prodPeriods,&prodVols);
            for (int pp=0; pp<nProdParts; ++pp) {
              std::string prodPart(prodParts[pp]);
              std::pair<int,float> periodVolPair(prodPeriods[pp],prodVols[pp]);
              peggedProdParts[prodPart].push_back(periodVolPair);
              witFree(prodParts[pp]);
            }
            witFree(prodParts);
            witFree(prodPeriods);
            witFree(prodVols);
d4122 15
a4136 75

          // loop once for each pegged operation
          int o;
          for ( o=0; o<nOps; ++o ) {
            if ( isAcquireMtmName(ops[o]) ) {  

              std::string mtm = mtmFromMtmName(ops[o]);
              std::string srcLoc = mtmSrcLocFromMtmName(ops[o]);
              std::string destLoc = mtmDestLocFromMtmName(ops[o]);
              // Need to shift period by acquire time.
              std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
              int shiftedPeriod = impPer[execPeriods[o]];
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("MtmAcquire",sp,mtm,srcLoc,shiftedPeriod,depth+0,execVols[o]); 
              appDataPtr->addPeggedItem("MtmMoveFrom",sp,mtm,srcLoc,shiftedPeriod,depth+1,execVols[o]); 
              appDataPtr->addPeggedItem("MtmMovedTo",sp,mtm,destLoc,execPeriods[o],depth+2,execVols[o]);         
            }
            else if ( isMtmDemanName(ops[o] ) ) {
              std::string mtm = mtmFromMtmName(ops[o]);
              std::string loc = mtmDestLocFromMtmName(ops[o]);
              // Need to shift period by deman time.
              std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
              int shiftedPeriod = impPer[execPeriods[o]];
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("MtmDisassemble",sp,mtm,loc,shiftedPeriod,depth,execVols[o]);

              // loop once for each Bop to find the pegged birthed part
              int nBops;
              witGetOperationNBopEntries(mutableWitRun(),ops[o],&nBops);
              for ( int b=0; b<nBops; ++b ) {
                // Get bops produced part
                char * witProdPart;
                witGetBopEntryProducedPart(mutableWitRun(),ops[o],b,&witProdPart);
                std::string prodPart = partFromPartName(witProdPart);
                std::string witProdPartAsStlString(witProdPart);
                witFree(witProdPart);

                // is current demand pegged to this produced part? If not, continue.
                if ( peggedProdParts.find(witProdPartAsStlString)==peggedProdParts.end() ) 
                  continue;

                // has this produced part already been pegged to the current demand
                if ( peggedDemanPart.find(witProdPartAsStlString)!=peggedDemanPart.end() ) 
                  continue;
                peggedDemanPart.insert(witProdPartAsStlString);

                // record produced part pegging in demand app data
                const std::vector<std::pair<int,float> > & vectorPeriodProdvolPairs =  peggedProdParts.find(witProdPartAsStlString)->second;
                for ( size_t ppp=0; ppp<vectorPeriodProdvolPairs.size(); ++ppp ) {
                  int prodPeriod = vectorPeriodProdvolPairs[ppp].first;
                  float prodVol = vectorPeriodProdvolPairs[ppp].second;
                  appDataPtr->addPeggedItem("PartHarvestedFromMtm",sp,prodPart,loc,prodPeriod,depth+1,prodVol);
                }
              } // end of loop b for each bop
            }
            else if ( isAcquireFeatureName(ops[o]) ) {
              std::string feature = featureFromFeatureName(ops[o]);
              std::string loc = locFromFeatureName(ops[o]);              
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("FeatureAcquire",sp,feature,loc,execPeriods[o],depth,execVols[o]);
            }
            else if ( isFeatureXrefName(ops[o]) ) {
              std::string feature = featureFromFeatureXrefName(ops[o]);
              std::string loc = locFromFeatureXrefName(ops[o]);
              std::string part = partFromFeatureXrefName(ops[o]);
              // Need to shift period by xref time.
              std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
              int shiftedPeriod = impPer[execPeriods[o]];
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("FeatureXrefFrom",sp,feature,loc,shiftedPeriod,depth,execVols[o]);
              appDataPtr->addPeggedItem("PartXrefedTo",sp,part,loc,execPeriods[o],depth+1,execVols[o]);
            }
            else if ( isAcquireLoosePartName(ops[o]) ) {
              std::string lp = loosePartFromLoosePartName(ops[o]);
              std::string loc = locFromLoosePartName(ops[o]);
d4138 2
a4139 1
              appDataPtr->addPeggedItem("LoosePartAcquire",sp,lp,loc,execPeriods[o],depth,execVols[o]);
a4140 32
            else if ( isAltName(ops[o]) ) {
              std::string fromPart = partFromAltName(ops[o]);
              std::string toPart = altPartFromAltName(ops[o]);
              std::string loc = locFromAltName(ops[o]);
              // Need to shift period by alt time.
              std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
              int shiftedPeriod = impPer[execPeriods[o]];
              int depth = operationDepths[ops[o]];
              appDataPtr->addPeggedItem("PartAltFrom",sp,fromPart,loc,shiftedPeriod,depth,execVols[o]);
              appDataPtr->addPeggedItem("PartAltTo",sp,toPart,loc,execPeriods[o],depth+1,execVols[o]);
            }
            else if ( isPartInterplantName(ops[o]) ) {
              std::string part = partFromPartInterplantName(ops[o]);
              std::string srcLoc = srcLocFromPartInterplantName(ops[o]);
              std::string destLoc = destLocFromPartInterplantName(ops[o]);
              // Need to shift period by acquire time.
              std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,ops[o],0);
              int shiftedPeriod = impPer[execPeriods[o]];
              bool skip=false;
              if ( 
                sp==shiftedPeriod &&
                sp==execPeriods[o] &&
                plantLoc == srcLoc &&
                plantLoc == destLoc ) 
                skip=true;
              if ( !skip ) {
                int depth = operationDepths[ops[o]];
                appDataPtr->addPeggedItem("PartMoveFrom",sp,part,srcLoc,shiftedPeriod,depth,execVols[o]); 
                appDataPtr->addPeggedItem("PartMovedTo",sp,part,destLoc,execPeriods[o],depth+1,execVols[o]);   
              }
            }
            witFree(ops[o]);
d4142 8
a4149 6
          witFree(ops);
          witFree(execPeriods);
          witFree(execVols);
        } // end Get pegged operations
      } // end Loop through each pipSequenceTriple 
    }  // end Extract pegging and store in member data 
d4151 1
a4151 2
  } // end Do pegging
}
d5933 1
a5933 1
    prob.solve();
d5996 1
a5996 1
    prob.solve();
d6009 1
a6009 1
    prob.solve();
d6055 1
a6055 1
    prob.solve();
d6105 1
a6105 1
    prob.solve();
d6169 1
a6169 1
    prob.solve();
d6190 1
a6190 1
    prob.solve();
d6210 1
a6210 1
    prob.solve();
d6221 1
a6221 1
    p1.solve();
d6296 1
a6296 1
    p1.solve();
d6386 1
a6386 1
    px.solve();
d6392 1
a6392 1
    py.solve();
d6400 1
a6400 1
    pa.solve();
d6408 1
a6408 1
    pb.solve();
d6426 1
a6426 1
    p1.solve();
d6532 1
a6532 1
    p1.solve();
d6719 3
a6721 3
            p1.solve();
            p2.solve();        
            p3.solve();
@


1.114
log
@modified to fix testing issue
@
text
@d3027 36
d3098 1
d3111 4
@


1.113
log
@Fixed bug when useApplyScaleFactorLocData was no
@
text
@d4856 1
a4856 1
      assert( compName!="-other-");
@


1.112
log
@no message
@
text
@d3586 3
a3588 5
        float scaleFactor = 1.0f;
        if ( getUseApplyScaleFactorLoc() ) {
          scaleFactor = 0.0f;
          if (getApplyLocWfmvScaleFactor(plantLocs[m],dp) ) scaleFactor = getWfmvScaleFactor(dp);
        } 
d3656 4
a3659 6
        float scaleFactor = 1.0f;
        if ( getUseApplyScaleFactorLoc() ) {
          scaleFactor = 0.0f;
          if (getApplyLocWfmvScaleFactor(featureLocs[f],dp) ) scaleFactor = getWfmvScaleFactor(dp);
        }
        
d3690 4
a3693 5
        float scaleFactor = 1.0f;
        if ( getUseApplyScaleFactorLoc() ) {
          scaleFactor = 0.0f;
          if (getApplyLocWfmvScaleFactor(loosePartLocs[l],dp) ) scaleFactor = getWfmvScaleFactor(dp);
        }
@


1.111
log
@added useApplyScaleFactorLocData to globalAttrData and code to support this attribute
@
text
@d3587 1
a3587 1
        if ( getApplyLocWfmvScaleFactor() ) {
d3659 1
a3659 1
        if ( getApplyLocWfmvScaleFactor() ) {
d3695 1
a3695 1
        if ( getApplyLocWfmvScaleFactor() ) {
d5275 6
a5280 1
bool ESO2problem::getApplyLocWfmvScaleFactor() const
d5283 1
a5283 1
  bool retVal = wfmvLocScaleFactorSfDemandFilePair_.size()>0;
d5288 1
d5440 1
d5539 1
d5593 1
d6287 2
a6288 2
    assert(eq(obj,484.));
    //assert(eq(obj,488.));
d6366 5
a6370 5
    //assert(objx>obja);
    //assert(obja<objb);
    double dif1=obja-objx;
    double dif2=objb-obja;
    assert(eq(dif1,dif2));
d6426 2
a6427 2
    assert(eq(obj,1190.));
    //assert(eq(obj,1193.));
d6532 2
a6533 2
    assert(eq(obj,1190.));
    //assert(eq(obj,1193.));
@


1.110
log
@Updates for scaling wfmv based on location
@
text
@d3585 6
a3590 3

        float scaleFactor = 0.0f;
        if (getApplyLocWfmvScaleFactor(plantLocs[m],dp) ) scaleFactor = getWfmvScaleFactor(dp);
d3658 5
a3662 2
        float scaleFactor = 0.0f;
        if (getApplyLocWfmvScaleFactor(featureLocs[f],dp) ) scaleFactor = getWfmvScaleFactor(dp);
d3694 5
a3698 2
        float scaleFactor = 0.0f;
        if (getApplyLocWfmvScaleFactor(loosePartLocs[l],dp) ) scaleFactor = getWfmvScaleFactor(dp);
d5275 6
d6278 2
a6279 2
    //assert(eq(obj,484.));
    assert(eq(obj,488.));
d6357 5
a6361 5
    assert(objx>obja);
    assert(obja<objb);
    //double dif1=obja-objx;
    //double dif2=objb-obja;
    //assert(eq(dif1,dif2));
d6417 2
a6418 2
    //assert(eq(obj,1190.));
    assert(eq(obj,1193.));
d6523 2
a6524 2
    //assert(eq(obj,1190.));
    assert(eq(obj,1193.));
@


1.109
log
@Added code to compute source of supply that makes up totalWac
@
text
@d3586 1
a3586 1
        float scaleFactor = 1.0f;
d3655 1
a3655 1
        float scaleFactor = 1.0f;
d3688 1
a3688 1
        float scaleFactor = 1.0f;
d6263 2
a6264 1
    assert(eq(obj,484.));
d6342 1
a6342 1
    assert(objx<obja);
d6344 3
a6346 3
    double dif1=obja-objx;
    double dif2=objb-obja;
    assert(eq(dif1,dif2));
d6402 2
a6403 1
    assert(eq(obj,1190.));
d6508 2
a6509 1
    assert(eq(obj,1190.));
@


1.108
log
@Updated so allowInventoryHoldingAtDemandLocation can be put into the globalAttrData file
@
text
@d2474 1
a2474 1
std::vector<std::string> ESO2problem::getPartDemandPeggedAttributeNames(
d4810 1
a4810 1
double ESO2problem::sumOfWac() const
d4813 1
d4815 2
d4831 1
d4835 21
a4855 1
      retVal += witShipVols[t]*witShipReward[t];
d5178 1
d5185 1
a5185 1
  sumShippedWac = sumOfWac();
d6703 1
d6705 2
a6706 1
              double wac=p3.sumOfWac();
d6715 9
a6724 1
              CoinRelFltEq eq(1.e-6);
d6792 1
d6797 1
@


1.107
log
@Updated eso2Problem to optionally allow inventory to be held at demand location
@
text
@d6594 2
a6595 2
          bool setPeriod1SupplyPerishabilityLimit = false;
          createModel(p1, testCases[tc].c_str(), setPeriod1SupplyPerishabilityLimit );
@


1.106
log
@modifed to use acclerated opt implode
@
text
@d2815 15
d2831 1
a2831 1
  witAddBomEntry(witRun(),dName.c_str(),pName.c_str());
d3397 1
a3397 1
  CoinRelFltEq eq(1.e-8);
d3456 1
d3460 7
d3727 2
a3728 1
        witSetNameBoundAttribute(witSetOperationExecBounds,dName, zeroTv,execSlb,execHub);
d4330 4
d5341 5
d5393 1
d5491 1
d5544 1
d6193 1
a6193 1
    assert(eq(vol[16],0.0));
@


1.105
log
@Updated to implement applyScaleFactorLoc
@
text
@d5410 2
a5411 2
  witSetAccAfterOptImp(witRun(),WitFALSE );
  witSetAccAfterSoftLB(witRun(),WitFALSE );
@


1.104
log
@modified the way the depth is stored in partDemandAppData
@
text
@d3432 114
a3547 1
  // Also set operations execBounds Hard Upper Bound to zero.
a3548 1
    float scaleFactor = getWfmvScaleFactor();
d3550 1
a3550 1
    // update wfmv and execBounds for mtms
d3562 3
a3567 6
#if 0
        std::vector<float>::iterator it;
        for(it=scaledWfmvVec.begin(); it!=scaledWfmvVec.end(); ++it ) {
          (*it) = (*it) * scaleFactor;
        }
#endif
a3577 2
        witSetNameAttribute(witSetOperationExecVol,acquireOpName, zeroTv); 
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv); 
a3609 2
            witSetNameAttribute(witSetOperationExecVol,acquireAndMoveOpName, zeroTv); 
            witSetNameBoundAttribute(witSetOperationExecBounds,acquireAndMoveOpName, zeroTv,zeroTv,zeroTv);
d3631 3
a3635 6
#if 0
        std::vector<float>::iterator it;
        for(it=wfmvVec.begin(); it!=wfmvVec.end(); ++it ) {
          (*it) = (*it) * scaleFactor;
        }
#else
d3645 1
a3645 4
#endif
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec); 
        witSetNameAttribute(witSetOperationExecVol,acquireOpName, zeroTv); 
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv);       
d3665 3
a3668 6
#if 0
        std::vector<float>::iterator it;
        for(it=wfmvVec.begin(); it!=wfmvVec.end(); ++it ) {
          (*it) = (*it) * scaleFactor;
        }
#else
d3678 1
a3678 4
#endif
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);
        witSetNameAttribute(witSetOperationExecVol,acquireOpName, zeroTv); 
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,zeroTv,zeroTv);           
d3686 1
a3686 14
  // Turn off all demands and set obj1ShipReward to Wac*wacScaleFactor
  {
    std::vector<std::string> parts, custLocs, plantLocs;
    getPartDemands( parts, custLocs, plantLocs );
    
    // loop once for each demand and set associated operations upper Exec Bounds to zero
    int d;
    for (d=0; d<parts.size(); ++d ) {
      std::string dName = partDemandName(parts[d],custLocs[d],plantLocs[d]);
      witSetNameBoundAttribute(witSetOperationExecBounds,dName, zeroTv,zeroTv,zeroTv);
      std::vector<float> scaledWac = getPartDemandScaledWac(parts[d],custLocs[d],plantLocs[d]);
      witSetDemandAttribute(witSetDemandObj1ShipReward, dName, dName, scaledWac);
    } // end of (d=0; d<parts.size(); ++d )
  } // end of Turn off all demands
a3687 4

  // Loop once for each demand priority
  int dp;
  for ( dp=0; dp<2; ++dp ) {
d5193 20
d5359 1
d5456 1
d5508 1
d6250 38
@


1.103
log
@Updated to have depth of pegging activity.
@
text
@d2989 1
a2989 1
    for( int depth=0; depth=depth+5; )   {
@


1.102
log
@updated to remove deprecated wit function witSetGroupPipMode
@
text
@d31 1
d2490 1
d2497 1
a2497 1
  appDataPtr->getPeggedItems(peggedAttributeName,shipPeriod,items,locs,periods,quantities);
d2972 41
d3294 1
d3403 6
d3717 1
a3717 1
#if 1
d3864 1
a3864 1
            witGetDemandProdVolPip(mutableWitRun(),
d3873 1
d3889 4
a3892 3
              appDataPtr->addPeggedItem("MtmAcquire",sp,mtm,srcLoc,shiftedPeriod,execVols[o]); 
              appDataPtr->addPeggedItem("MtmMoveFrom",sp,mtm,srcLoc,shiftedPeriod,execVols[o]); 
              appDataPtr->addPeggedItem("MtmMovedTo",sp,mtm,destLoc,execPeriods[o],execVols[o]);         
d3900 2
a3901 1
              appDataPtr->addPeggedItem("MtmDisassemble",sp,mtm,loc,shiftedPeriod,execVols[o]);
d3928 1
a3928 1
                  appDataPtr->addPeggedItem("PartHarvestedFromMtm",sp,prodPart,loc,prodPeriod,prodVol);
d3934 3
a3936 2
              std::string loc = locFromFeatureName(ops[o]);
              appDataPtr->addPeggedItem("FeatureAcquire",sp,feature,loc,execPeriods[o],execVols[o]);
d3945 3
a3947 2
              appDataPtr->addPeggedItem("FeatureXrefFrom",sp,feature,loc,shiftedPeriod,execVols[o]);
              appDataPtr->addPeggedItem("PartXrefedTo",sp,part,loc,execPeriods[o],execVols[o]);
d3952 2
a3953 1
              appDataPtr->addPeggedItem("LoosePartAcquire",sp,lp,loc,execPeriods[o],execVols[o]);
d3962 3
a3964 2
              appDataPtr->addPeggedItem("PartAltFrom",sp,fromPart,loc,shiftedPeriod,execVols[o]);
              appDataPtr->addPeggedItem("PartAltTo",sp,toPart,loc,execPeriods[o],execVols[o]);
d3981 3
a3983 2
                appDataPtr->addPeggedItem("PartMoveFrom",sp,part,srcLoc,shiftedPeriod,execVols[o]); 
                appDataPtr->addPeggedItem("PartMovedTo",sp,part,destLoc,execPeriods[o],execVols[o]);   
d5714 1
a5714 1
    std::vector<int> mtmAcquirePeriods;
d5730 1
a5730 1
      acquireMtms,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity );
d5737 1
a5737 1
      acquireMtms,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity );
d6109 1
d6112 1
a6112 1
      p1.getPartDemandPegging("MtmAcquire",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6114 1
d6117 1
a6117 1
      p1.getPartDemandPegging("MtmMoveFrom",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6119 1
d6122 1
a6122 1
      p1.getPartDemandPegging("MtmMovedTo",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6124 1
d6127 1
a6127 1
      p1.getPartDemandPegging("MtmDisassemble",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6129 1
d6132 1
a6132 1
      p1.getPartDemandPegging("PartHarvestedFromMtm",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6134 1
d6137 1
a6137 1
      p1.getPartDemandPegging("PartMoveFrom",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6139 1
d6142 1
a6142 1
      p1.getPartDemandPegging("PartMovedTo",  "p2","highPriority1","loc3",4-1, items,locs,periods,quanity);
d6144 1
d6208 2
a6209 1
      std::vector<int> periods; 
d6212 1
a6212 1
      p1.getPartDemandPegging("MtmAcquire",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6215 1
a6215 1
      p1.getPartDemandPegging("MtmMoveFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6218 1
a6218 1
      p1.getPartDemandPegging("MtmMovedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6221 1
a6221 1
      p1.getPartDemandPegging("MtmDisassemble",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6224 1
a6224 1
      p1.getPartDemandPegging("PartHarvestedFromMtm",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6227 1
a6227 1
      p1.getPartDemandPegging("FeatureAcquire",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6229 1
d6232 1
a6232 1
      p1.getPartDemandPegging("FeatureXrefFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6234 1
d6237 1
a6237 1
      p1.getPartDemandPegging("PartXrefedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6239 1
d6242 1
a6242 1
      p1.getPartDemandPegging("PartMoveFrom",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6244 1
d6247 1
a6247 1
      p1.getPartDemandPegging("PartMovedTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
d6249 1
d6313 2
a6314 1
      std::vector<int> periods; 
d6317 1
a6317 1
      p1.getPartDemandPegging("FeatureAcquire",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6320 1
a6320 1
      p1.getPartDemandPegging("LoosePartAcquire",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6322 1
d6325 1
a6325 1
      p1.getPartDemandPegging("PartAltFrom",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6327 1
d6330 1
a6330 1
      p1.getPartDemandPegging("PartAltTo",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6332 1
d6335 1
a6335 1
      p1.getPartDemandPegging("PartMoveFrom",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6337 1
d6340 1
a6340 1
      p1.getPartDemandPegging("PartMovedTo",  "p2","lowPriority2","loc3",5-1, items,locs,periods,quanity);
d6342 1
d6481 1
d6489 1
a6489 1
                  std::vector<float> scrapVol = p3.witGetNameAttribute(witGetPartScrapVol,name);
d6494 1
a6494 1
                      printf("Nonzero scrapVol[%d] for %s\n",p,name);
a6497 1
                  witFree(name);
@


1.101
log
@Changed code so that *O.csv files no longer has offset periods.
Attempted to remove in pegged file a move where the from/to locations are the same
@
text
@d5260 1
a5260 1
  witSetGroupPipMode(witRun(),WitTRUE);
d5583 1
a6269 1

d6363 7
@


1.100
log
@Fixup partShipReportO
@
text
@d924 8
d940 11
a950 6
#if 0
  std::vector<float> bomAcquire = witGetNameAttribute(witGetOperationExecVol,opName);
  //std::vector<float> subAcquire = witGetSubArcAttribute(witGetSubsBomEntrySubVol,opName,0,0);
  std::vector<float> offset = getMtmDemanTime(mtmName, srcLoc,destLoc );
  return shiftAttributeByOffset(bomAcquire,offset);
#endif
d953 1
d2152 1
a2152 1
std::vector<float> ESO2problem::getAltVol(
d2168 1
a2168 1
std::vector<float> ESO2problem::getAltVolForPartShipReportO(
d2337 1
a2337 1
std::vector<float> ESO2problem::getPartInterplantMoveVol(
d2360 1
a2360 1
std::vector<float> ESO2problem::getPartInterplantMoveVolForPartShipReportO(
d3791 1
d3916 11
a3926 2
              appDataPtr->addPeggedItem("PartMoveFrom",sp,part,srcLoc,shiftedPeriod,execVols[o]); 
              appDataPtr->addPeggedItem("PartMovedTo",sp,part,destLoc,execPeriods[o],execVols[o]);   
d6028 1
a6028 1
    std::vector<float> aq = p1.getMtmAcquireQty("mtm1","invLoc1","loc2");
d6033 1
a6033 1
    aq = p1.getMtmAcquireQty("mtm1","loc1","loc2");
d6037 1
a6037 1
    std::vector<float> pi = p1.getPartInterplantMoveVol("p2","loc2","loc3");
d6126 1
a6126 1
    std::vector<float> pi = p1.getPartInterplantMoveVol("p2","invLoc4","loc3");
d6131 1
a6131 1
    pi = p1.getPartInterplantMoveVol("p2","loc4","loc3");
d6216 1
a6216 1
    std::vector<float> ap = p1.getAltVol("lp1","p2","invLoc5");
d6221 1
a6221 1
    ap = p1.getAltVol("lp1","p2","loc5");
d6225 1
a6225 1
    std::vector<float> pi = p1.getPartInterplantMoveVol("p2","invLoc5","loc3");
d6230 1
a6230 1
    pi = p1.getPartInterplantMoveVol("p2","loc5","loc3");
@


1.99
log
@fix bug
@
text
@d2154 9
d2346 24
@


1.98
log
@Modified to use new wit API names that doesn't reference OSL
@
text
@d5201 1
a5201 1
  witSetPostSolveRecovery(witRun(),WitTRUE);
@


1.97
log
@fixed problem when operation has empty bom
@
text
@d3844 1
a3844 1
              appDataPtr->addPeggedItem("PartXrefTo",sp,part,loc,execPeriods[o],execVols[o]);
d4976 1
a4976 1
void ESO2problem::setOslMesgFileName(const std::string & name)
d4978 1
a4978 1
  witSetOslMesgFileName(witRun(),name.c_str());
d6110 1
a6110 1
      p1.getPartDemandPegging("PartXrefTo",  "p2","highPriority1","loc3",3-1, items,locs,periods,quanity);
@


1.96
log
@Added pegging of FeatureXref and AltPart operations
@
text
@d2339 1
a2340 1
  std::vector<int> impPer = witGetArcAttribute(witGetBomEntryImpactPeriod,witOpName,0 );
a2343 1
  assert(nBoms==1);
d2345 13
a2357 6
	std::vector<float> retVal=floatToStlVec(0.0f);
  for (int p=0;p<retVal.size(); ++p ){
    int ip = impPer[p];
    if ( ip == -1 ) continue;
    float ev = execVol[p];
    retVal[ ip ] = ev;
d2359 1
a2359 1
	return retVal;
@


1.95
log
@Added pegging to eso2Problem unitTest
@
text
@d3830 10
d3845 10
d4032 9
d4061 9
a4069 1

d6099 8
d6186 8
@


1.94
log
@modified function which offsets execVol to impact period.  some other clean up.
@
text
@d5946 36
d6037 36
d6129 23
@


1.93
log
@implemented pegging of harvested and moved parts
@
text
@d932 1
d937 2
d2146 1
d2150 2
d2329 1
d2333 2
d2337 1
a2337 1
std::vector<float> ESO2problem::shiftAttributeByOffset(const std::vector<float> & attrValue, const std::vector<float> & offset) const
d2339 7
d2347 6
a2352 5
	for (int p=0;p<retVal.size(); ++p ){
		if( p-offset[p] < 0.0 ) 
			continue;
		retVal[p-(int)(offset[p]+0.5f)]=attrValue[p];
	}
@


1.92
log
@Modified eso2 & eso2Problem to use generalized storing of pegged attributes in partDemandAppData
@
text
@d3722 5
a3726 1
        // Get pegged operations
d3734 23
a3756 1
            &nOps,&ops,&execPeriods,&execVols);          
d3778 29
d3818 10
d4035 9
@


1.91
log
@Modified to generalize the storing of pegged attributes in partDemandAppData
@
text
@d2402 25
d2428 1
a2428 1
// Pegging information
d2573 1
a3733 5
#if 0
              std::string opName = acquireMtmName(mtmName,srcLoc,destLoc);
              std::vector<float> offset = getMtmDemanTime(mtmName, srcLoc,destLoc );
              std::vector shiftedExecVols = shiftAttributeByOffset(execPeriods[o],offset);
#endif
d3735 3
d3741 3
a3743 1
              appDataPtr->addPeggedItem("MtmAcquire",sp,ops[o],shiftedPeriod,execVols[o]);         
d3746 2
d3751 1
a3751 1
              appDataPtr->addPeggedItem("MtmDisassemble",sp,ops[o],shiftedPeriod,execVols[o]);
d3754 3
a3756 1
              appDataPtr->addPeggedItem("FeatureAcquire",sp,ops[o],execPeriods[o],execVols[o]);
d3759 3
a3761 1
              appDataPtr->addPeggedItem("LoosePartAcquire",sp,ops[o],execPeriods[o],execVols[o]);
d5478 1
d5480 1
a5480 4
      acquireMtms,mtmSrcLocs,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity,
      demanMtms, demanLocs,demanPeriods,demanQuantity,
      features,featurePlantLocs,featureAcquirePeriods,featureAcquireQuantity,
      looseParts,loosePartPlantLocs,loosePartAcquirePeriods,loosePartAcquireQuantity );
d5485 1
d5487 1
a5487 4
      acquireMtms,mtmSrcLocs,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity,
      demanMtms, demanLocs,demanPeriods,demanQuantity,
      features,featurePlantLocs,featureAcquirePeriods,featureAcquireQuantity,
      looseParts,loosePartPlantLocs,loosePartAcquirePeriods,loosePartAcquireQuantity );
@


1.90
log
@Added pegging of deman info
@
text
@d2448 1
a2448 1
    appDataPtr->getPeggedAcquiredMtms(shipPeriod,witMtms,periods,quantities);
d2478 1
a2478 1
    appDataPtr->getPeggedDemanMtms(shipPeriod,witDemanOps,periods,quantities);
d2504 1
a2504 1
    appDataPtr->getPeggedAcquiredFeatures(shipPeriod,witFeatures,periods,quantities);
d2530 1
a2530 1
    appDataPtr->getPeggedAcquiredLooseParts(shipPeriod,witLooseParts,periods,quantities);
d3717 1
a3717 1
              appDataPtr->addPeggedAcquiredMtm(sp,ops[o],shiftedPeriod,execVols[o]);         
d3723 1
a3723 1
              appDataPtr->addPeggedDemanMtm(sp,ops[o],shiftedPeriod,execVols[o]);
d3726 1
a3726 1
              appDataPtr->addPeggedAcquiredFeature(sp,ops[o],execPeriods[o],execVols[o]);
d3729 1
a3729 1
              appDataPtr->addPeggedAcquiredLoosePart(sp,ops[o],execPeriods[o],execVols[o]);
@


1.89
log
@modifications to implement group pegging
@
text
@d2415 5
d2467 27
d3719 6
d5431 1
a5431 1
    std::vector<std::string> mtms,mtmSrcLocs,mtmAcquireLocs;
d5433 6
a5438 1
    std::vector<float> mtmAcquireQuantity;        
d5447 2
a5448 1
      mtms,mtmSrcLocs,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity,
d5451 1
a5451 1
    size_t m1= mtms.size();
d5456 2
a5457 1
      mtms,mtmSrcLocs,mtmAcquireLocs,mtmAcquirePeriods,mtmAcquireQuantity,
d5460 1
a5460 1
    size_t m2= mtms.size();
@


1.88
log
@fixed bug
@
text
@a3600 25
    // Set PIP share
    {
      float * oneTv = floatToConstFloatStar(1.f);
      
      // First set PIP share
      std::vector<std::string> mtmNames, mtmSrcLocs, mtmDestLocs;
      getMtmDemanLocs( mtmNames, mtmSrcLocs, mtmDestLocs );
      // Loop once for each deman operation
      int d;
      for ( d=0; d<mtmNames.size(); ++ d) {
        std::string witDemanOpName = demanMtmName( mtmNames[d], mtmSrcLocs[d], mtmDestLocs[d] );
        
        // Loop once for each bop
        int nBops;
        witGetOperationNBopEntries(mutableWitRun(),witDemanOpName.c_str(),&nBops);
        int b;
        for (b=0; b<nBops; ++b ) {
          float * ps;
          witGetBopEntryPipShare(mutableWitRun(),witDemanOpName.c_str(),b,&ps);
          witSetBopEntryPipShare(witRun(),witDemanOpName.c_str(),b,oneTv);
        } // end loop for each bop b
      } // end loop for each demanOp d
      delete [] oneTv;
      witPostprocess(witRun());
    } // end set pip share
d3672 1
a3672 32
            &nOps,&ops,&execPeriods,&execVols);
          //std::cout <<dn.c_str() <<std::endl;
          
          
          // Get set of pegged produced parts
          std::set<ESO2stringIntPair> setProdParts;
          std::map<ESO2stringIntPair,float> mapProdPartsQty;
          int nProds;
          char ** prodParts;
          int * prodPeriods;
          float * prodVols;
          witGetDemandProdVolPip(mutableWitRun(),
            dn.c_str(),dn.c_str(),sp,
            &nProds,&prodParts,&prodPeriods,&prodVols);
#if 0          
          int p;
          for (p=0; p<nProds; ++p) {
            std::cout <<"    "
              <<"p>" <<p <<" "
              <<"pPart>" <<prodParts[p] <<" "
              <<"pp>" <<prodPeriods[p] <<" "
              <<"pv>" <<prodVols[p] <<std::endl;
            ESO2stringIntPair prodPartPeriodPair(prodParts[p],prodPeriods[p]);
            setProdParts.insert(prodPartPeriodPair);
            mapProdPartsQty[prodPartPeriodPair]+=prodVols[p];
            witFree(prodParts[p]);
          }
          witFree(prodParts);
          witFree(prodPeriods);
          witFree(prodVols);
#endif
          
d3675 1
a3675 1
            if ( isAcquireMtmName(ops[o]) ) {
d3677 3
a3679 5
              std::cout <<"  "
                <<"sp>" <<sp <<" "
                <<"op>" <<ops[o] <<" "
                <<"ep>" <<execPeriods[o] <<" "
                <<"ev>" <<execVols[o] <<std::endl;
d3682 4
a3685 35
              
              // get parts produced by mtm
              std::string demMtmName = std::string(demanMtmName(
                  mtmFromMtmName(ops[o]),
                  mtmSrcLocFromMtmName(ops[o]),
                  mtmDestLocFromMtmName(ops[o]) ).c_str());
              std::vector<std::string> opProdParts = witGetOperProducts(demMtmName);
              
              // loop once for each bop
              int bop;
              for ( bop=0; bop<opProdParts.size(); ++bop) {
                //std::cout <<opProdParts[bop].c_str() <<" " <<execPeriods[o]<<std::endl;
                ESO2stringIntPair prodPartProdPeriodPair(opProdParts[bop],execPeriods[o]);
                if ( setProdParts.find(prodPartProdPeriodPair) != setProdParts.end() ) {
                  // demanufactured part is a peggedProdVol

                  // Get prodVol
                  std::vector<float> witProdRates = witGetArcAttribute(witGetBopEntryProductRate,demMtmName.c_str(),bop);

                  // Compute the quantity of the mtm to be acquired for the pegged prodVol and sideProdVol
                  float qtyAcquire = mapProdPartsQty[prodPartProdPeriodPair]/witProdRates[execPeriods[o]];

                  //appDataPtr->addPeggedAcquiredMtm(sp,ops[o],execPeriods[o],qtyAcquire);

                  CoinRelFltEq eq;
                  assert( eq(execVols[o],qtyAcquire));
#if 0
                  std::cout <<opProdParts[bop].c_str() <<" " <<execPeriods[o]<<" " <<witProdRates[execPeriods[o]] <<" " <<qtyAcquire <<std::endl;
#endif
                }
              }
              appDataPtr->addPeggedAcquiredMtm(sp,ops[o],execPeriods[o],execVols[o]);


              
d4999 2
@


1.87
log
@modifed to use Coin's test for float equality
@
text
@d4496 1
a4496 1
      assert( eq(witShipReward[t],scaledWacs[t]) );
@


1.86
log
@added wac scale factors (one for each demand file)
@
text
@d4478 1
d4495 2
a4496 2
      assert( witShipVols[t]==shipVols[t] );
      assert( witShipReward[t]==scaledWacs[t] );
@


1.85
log
@Updated to all setting of mtm, feature, and loosePart priority when satisfying priority 2 demand.
@
text
@d2694 1
a2694 1
  ESO2partDemandAppData * appData = new ESO2partDemandAppData;
d2726 1
d2729 4
d2817 1
d2819 17
d3415 1
a3415 1
  // Turn off all demands
d3425 2
d4209 1
d4228 12
d4491 1
a4491 1
    std::vector<float> wacs = getPartDemandWac(parts[i],custLocs[i],plantLocs[i]);
d4495 1
a4495 1
      assert( witShipReward[t]==wacs[t] );
d4843 1
a4843 1
    std::vector<float> wac = getPartDemandWac(parts[i],custLocs[i],plantLocs[i]);
d4850 1
a4850 1
      sumDemandWac += demandVol[t]*wac[t];
d4986 10
d5031 1
d5089 4
d5125 1
d5176 1
@


1.84
log
@Updated to add wfmv2ScaleFactor
@
text
@d3427 1
a3427 1
    } // end of Turn off all demands
d3447 1
a3447 1
          if (getMtmPriority()<=p) execHub = infinityTv;
d3464 1
a3464 1
              if (getMtmPriority()<=p) execHub = infinityTv;
d3486 1
a3486 1
          if (getFeaturePriority()<=p) execHub = infinityTv;
d3507 1
a3507 1
          if (getLoosePartPriority()<=p) execHub = infinityTv;
d4884 59
d4980 3
d5069 3
d5119 3
@


1.83
log
@Modified the setting of feature conversion cost and time by adding a new block that loops over the records in the featureConversionOverride data file.
@
text
@d2140 2
a2141 1
  std::vector<float> retVal;
d2143 3
a2145 2
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
d2158 20
d2356 1
a2356 2
  retVal = witGetArcAttribute(witGetBomEntryOffset,opName,0);

d2359 7
a2365 1
  assert(n==1);
d2871 1
d3005 1
d3037 2
a3038 2
        witSetPartSelForDel(witRun(),moveableUpLevelPartName.c_str(),WitTRUE);
        witSetOperationSelForDel(witRun(),ecOpName.c_str(),WitTRUE);
d3040 1
a3040 1
        alts_.erase(ecOpName);
d3046 1
d4828 1
a4828 1
void ESO2problem::setWfmvScaleFactor(float sf)
d4832 2
a4833 1
  appData->setWfmvScaleFactor(sf);
d4842 7
d5628 1
a5628 1
    p1.setWfmvScaleFactor(0.0f);
d5708 1
a5708 1
    std::vector<float> sv = p1.getPartDemandShipVol("p2","highPriorityDemand1","loc3");
d5712 1
a5712 1
    sv = p1.getPartDemandShipVol("p2","highPriorityDemand2","loc3");
d5716 1
a5716 1
    sv = p1.getPartDemandShipVol("p2","highPriorityDemand3","loc3");
d5720 1
a5720 1
    sv = p1.getPartDemandShipVol("p2","lowPriorityDemand1","loc3");
d5723 1
a5723 1
    sv = p1.getPartDemandShipVol("p2","lowPriorityDemand2","loc3");
d5749 106
d5856 1
d5947 3
a5949 3
            p1.setWfmvScaleFactor(scaleFactors[sf]);
            p2.setWfmvScaleFactor(scaleFactors[sf]);
            p3.setWfmvScaleFactor(scaleFactors[sf]);
@


1.82
log
@changes to improve setting of feature offset, prodRate, and execCost
@
text
@d1897 12
a1908 1

d1924 12
d4141 12
@


1.81
log
@Added a more general method for dealing with the ETN flags
@
text
@d318 1
a318 1
    int earliest = (int)(moveTime + 1);
d3461 1
a3461 1
#if 0
d4819 1
@


1.80
log
@updated to add low priority demand file
@
text
@d440 1
a440 1
        <<mtms.size()
d519 1
a519 1
        <<parts.size()
a928 2
  std::vector<float> retVal=floatToStlVec(0.0f);

d935 1
a935 7
  for (int p=0;p<retVal.size(); ++p ){
	  if( p-offset[p] < 0.0 ) 
		  continue;
	  retVal[p-offset[p]]=bomAcquire[p];
  }

  return retVal;
d1006 1
a1006 1
  std::vector<float> demanTime=floatToStlVec(np+1);
d2268 1
d2273 19
d2304 16
d3962 1
a3962 1
  int begPos = src.find(begMark);
d3966 1
a3966 1
  int endPos = src.find(endMark);
d3969 1
a3969 1
  int len = endPos-begPos;
d3977 1
a3977 1
  int begPos = src.find(begMark);
d3981 1
a3981 1
  int endPos = src.size();
d3983 1
a3983 1
  int len = endPos-begPos;
d3991 1
a3991 1
  int begPos = src.find(begString);
d3999 1
a3999 1
  int pos = haystack.find(needle);
d4576 1
a4576 1
    numUnique = mtms.size();
d4643 1
a4643 1
  numUnique = features.size();
d4688 1
a4688 1
  numUnique = looseParts.size();
d4732 1
a4732 1
  numUnique = parts.size();
d5296 1
a5296 1
    int m1= mtms.size();
d5304 1
a5304 1
    int m2= mtms.size();
d5628 44
d5674 4
d5774 3
a5776 3
            float p1Obj = p1.getObjValue();
            float p2Obj = p2.getObjValue();
            float p3Obj = p3.getObjValue();
d5839 1
a5839 1
              float calcObj=
@


1.79
log
@modified to skip over example1 in one of the tests
@
text
@d2 1
d332 1
a332 1
        offset[t] = t;
d372 1
a372 1
  int nLevels = impPersVecs.size();
d375 1
a375 1
  int np = impPersVecs[0].size();
d470 4
d483 1
a483 1
            if ( useMtmPerishableSupply(mtms[m],srcLocs[m],srcLocs[m],p ) ){
d837 8
d922 1
a922 4
  std::vector<float> retVal;
  std::string opName = acquireMtmName(mtmName,mtmLoc,mtmLoc);
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
  return retVal;
d929 4
a932 1
  std::vector<float> retVal;
d934 9
a942 1
  retVal = witGetNameAttribute(witGetOperationExecVol,opName);
d2593 1
a2593 1
                               const std::string & plantLoc )
d2652 25
a3308 1
  
a3309 3
  // Loop once for each priority
  int p;
  for ( p=1; p<4; ++p ) {
d3311 23
a3333 5
    // update execBounds for mtms
    { 
      std::vector<std::string> mtms;
      std::vector<std::string> plantLocs;
      getMtms(mtms,plantLocs);
d3335 6
a3340 7
      // loop once for each mtm
      int m;
      for ( m=0; m<mtms.size(); m++ ) {           
        std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );    
        std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
        // Get execVol and set to softLower bound
        std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
d3342 15
a3356 4
        if (getMtmPriority()<=p) execHub = infinityTv;
        else  execHub = zeroTv;
        //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub);  
        setExecBounds(acquireOpName, zeroTv,execSlb,execHub);  
d3358 33
a3390 20
        // are there any locations that this mtm is moved to?
        if ( mtmAcquireExists(mtmBName) ) {
          // Get all locations that this mtm can be moved to
          const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
          // Loop once for each location this mtm can be moved to
          std::set<std::string>::const_iterator locIt;
          for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
            const std::string & destLoc = *locIt;
            std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );       
            // Get execVol and set to softLower bound
            std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireAndMoveOpName);
            std::vector<float> execHub;
            if (getMtmPriority()<=p) execHub = infinityTv;
            else  execHub = zeroTv;
            //witSetNameBoundAttribute(witSetOperationExecBounds,acquireAndMoveOpName, zeroTv,execSlb,execHub);
            setExecBounds(acquireAndMoveOpName, zeroTv,execSlb,execHub);            
          } // end of locIt loop
        } // end of if (mtmAcquireExists(baseMtmName))
      } // end of loop m      
    } // end of update execBounds for mtms
d3392 19
a3410 5
    // update execBounds for features
    {
      std::vector<std::string> features;
      std::vector<std::string> featureLocs;
      getFeatures(features,featureLocs);
a3411 20
      // loop once for each feature
      int f;
      for ( f=0; f<features.size(); f++ ) {      
        std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );        
        // Get execVol and set to softLower bound
        std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
        std::vector<float> execHub;
        if (getFeaturePriority()<=p) execHub = infinityTv;
        else  execHub = zeroTv;
        //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub); 
        setExecBounds(acquireOpName, zeroTv,execSlb,execHub);            
      } // end of loop f      
    } // end of update execBounds for features


    // update execBounds for looseParts
    {
      std::vector<std::string> looseParts;
      std::vector<std::string> loosePartLocs;
      getLooseParts(looseParts,loosePartLocs);
d3413 19
a3431 13
      // loop once for each loosePart
      int l;
      for ( l=0; l<looseParts.size(); l++ ) {            
        std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );  
        // Get execVol and set to softLower bound
        std::vector<float> execSlb = witGetNameAttribute(witGetOperationExecVol,acquireOpName);
        std::vector<float> execHub;
        if (getLoosePartPriority()<=p) execHub = infinityTv;
        else  execHub = zeroTv;
        //witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub); 
        setExecBounds(acquireOpName, zeroTv,execSlb,execHub);                       
      } // end of loop l
    } // end of update execBounds for looseParts
d3434 7
a3440 7
    // Write wit data file before invoking witOptImplode
    {
      char asChar[100];
      sprintf(asChar,"%d",implosionCount());
      std::string witDataFileName = std::string("implode")+std::string(asChar)+".wit";
      writeWitData(witDataFileName);
    }
d3442 8
a3449 7

    std::cout <<"Calling witOptImplode" <<std::endl;
    witOptImplode (witRun());
    implosionCount_++;
    std::cout <<"Returned from witOptImplode call" <<std::endl;
    //reportPartDemand("p2","pok","pok",0);
  } // end of p loop for each priority
d5182 1
d5245 1
a5245 1
    assert( prob.implosionCount()==3 );
d5522 77
d5657 1
d5659 2
d5848 2
a5849 1
              assert(p1Obj == historicObjValue || tc==5 );
@


1.78
log
@Modified to try to write a report with info kevin is asking for
@
text
@d5536 1
a5536 1
            assert( p1Obj==p2Obj );
@


1.77
log
@changed code to use std::string rather than BCP_string
@
text
@d2087 10
d2238 12
@


1.76
log
@Changes to add loc to altData file.
Changes to start implementing PIP (pegging).
@
text
@d43 1
a43 1
                                           const BCP_string & operationName,
d60 1
a60 1
bool ESO2problem::witGetDemandExists(const BCP_string & pn, const BCP_string & dn ) const
d82 1
a82 1
                                const BCP_string & id,
d123 1
a123 1
        BCP_string id = BCP_string(demandName) + "/" + demandedPartName;
d153 1
a153 1
        BCP_string id = BCP_string(demandName) + "/" + demandedPartName;
d187 1
a187 1
        BCP_string id = BCP_string("Operation:: ") + operationName;
d216 1
a216 1
        BCP_string id = BCP_string("Operation:: ") + operationName;
d255 1
a255 1
        BCP_string id = BCP_string("Subs:: ") + operationName + " bomEntry: " + bomEntryAsChar + " subEntry: " + subEntryAsChar;
d289 1
a289 1
        BCP_string id = BCP_string("Subs:: ") + operationName + "bomEntry: " + bomEntryAsChar + "subEntry: " + subEntryAsChar;
d302 2
a303 2
       const BCP_string & acquireOperation, 
       const BCP_string & acquiredPart,
d428 3
a430 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d443 1
a443 1
      BCP_string baseDemanOpName = demanMtmName(mtms[m],srcLocs[m],srcLocs[m] );
d458 2
a459 2
        BCP_string demanOpName = demanMtmName(mtms[m],srcLocs[m],destLocs[m] );
        BCP_string moveAndAcquireOpName = acquireMtmName(mtms[m],srcLocs[m],destLocs[m] );
d502 3
a504 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d523 2
a524 2
     BCP_string xrefOpName = featureXrefName(parts[x],features[x],locs[x] );
     BCP_string acquireFeatureOpName = acquireFeatureName(features[x],locs[x] );
d576 2
a577 2
                         const BCP_string & part,
                         const BCP_string & partLoc,
d581 2
a582 2
  BCP_string acquireOpName = acquireLoosePartName(part,partLoc);  
  BCP_string acquiredPartName = igfLoosePartName(part,partLoc);
d586 2
a587 2
                         const BCP_string & feature,
                         const BCP_string & featureLoc,
d591 2
a592 2
  BCP_string acquireOpName = acquireFeatureName(feature,featureLoc);  
  BCP_string acquiredPartName = igfFeatureName(feature,featureLoc);
d596 3
a598 3
                         const BCP_string & mtm,
                         const BCP_string & srcLoc,
                         const BCP_string & destLoc,
d603 2
a604 2
  BCP_string moveAndAcquireOpName = acquireMtmName(mtm,srcLoc,destLoc);  
  BCP_string acquiredPartName = igfMtmName(mtm,srcLoc);
d609 2
a610 2
                         const BCP_string & witAcquireOpName,
                         const BCP_string & witAcquiredPartName,
d661 1
a661 1
void ESO2problem::addNonScrapableCapacity(const BCP_string & name )
d673 1
a673 1
void ESO2problem::addMtm(const BCP_string & mtmName, const BCP_string & mtmLoc,
d676 4
a679 4
  BCP_string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
  BCP_string acquireMtmWitName = acquireMtmName(mtmName, mtmLoc, mtmLoc );
  BCP_string serverMtmWitName = serverMtmName(mtmName, mtmLoc, mtmLoc );
  BCP_string demanMtmWitName = demanMtmName(mtmName, mtmLoc, mtmLoc );
d715 1
a715 1
  BCP_string baseName = baseMtmName(mtmName, mtmLoc );
d720 1
a720 1
bool ESO2problem::mtmExists(const BCP_string & mtmName, const BCP_string & mtmLoc )const
d722 1
a722 1
  BCP_string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
d732 2
a733 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc, 
d737 1
a737 1
  BCP_string name = igfMtmName(mtmName, mtmLoc );
d741 2
a742 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc, 
d746 1
a746 1
  BCP_string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
d752 2
a753 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc ) const
d755 1
a755 1
  BCP_string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
d761 3
a763 3
                     const BCP_string & mtmName, 
                     const BCP_string & supplyLoc, 
                     const BCP_string & demanLoc, 
d767 1
a767 1
  BCP_string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d771 2
a772 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc, 
d776 1
a776 1
  BCP_string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d780 3
a782 3
    const BCP_string & mtmName, 
    const BCP_string & supplyLoc, 
    const BCP_string & demanLoc,
d785 1
a785 1
  BCP_string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d789 2
a790 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc ) const
d792 1
a792 1
  BCP_string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d796 2
a797 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc, 
d801 1
a801 1
  BCP_string name = demanMtmName(mtmName, mtmLoc,mtmLoc );
d806 3
a808 3
                     const BCP_string & mtmName, 
                     const BCP_string & supplyLoc, 
                     const BCP_string & demanLoc, 
d812 1
a812 1
  BCP_string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d817 3
a819 3
    const BCP_string & mtmName, 
    const BCP_string & supplyLoc,  
    const BCP_string & demanLoc, 
d822 1
a822 1
  BCP_string name = demanMtmName(mtmName, supplyLoc,demanLoc );
d826 2
a827 2
    const BCP_string & mtmName, 
    const BCP_string & mtmLoc ) const
d829 1
a829 1
  BCP_string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d835 2
a836 2
    std::vector<BCP_string> & mtms,
    std::vector<BCP_string> & mtmLoc ) const
d848 1
a848 1
  std::set<BCP_string>::const_iterator it;
d858 3
a860 3
    std::vector<BCP_string> & mtms,
    std::vector<BCP_string> & srcLocs,
    std::vector<BCP_string> & destLocs ) const
d870 2
a871 2
    const BCP_string & mtm = mtmFromMtmName(mtmNames_[m]);
    const BCP_string & srcLoc = mtmDestLocFromMtmName(mtmNames_[m]);
d873 1
a873 1
  std::set<BCP_string>::const_iterator it;
d875 2
a876 2
    const BCP_string & mtm = mtmFromMtmName(*it);
    const BCP_string & srcLoc = mtmDestLocFromMtmName(*it);
d883 1
a883 1
    BCP_string mtmBName = baseMtmName(mtm,srcLoc);
d889 1
a889 1
      const std::set<BCP_string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d892 1
a892 1
      std::set<BCP_string>::const_iterator locIt;
d894 1
a894 1
        const BCP_string & destLoc = *locIt;
d906 2
a907 2
                                                 const BCP_string & mtmName, 
                                                 const BCP_string & mtmLoc )const
d910 1
a910 1
  BCP_string opName = acquireMtmName(mtmName,mtmLoc,mtmLoc);
d915 3
a917 3
                                                 const BCP_string & mtmName, 
                                                 const BCP_string & srcLoc , 
                                                 const BCP_string & destLoc )const
d920 1
a920 1
  BCP_string opName = acquireMtmName(mtmName,srcLoc,destLoc);
d925 2
a926 2
                                                 const BCP_string & mtmName, 
                                                 const BCP_string & mtmLoc )const
d929 1
a929 1
  BCP_string name = igfMtmName(mtmName,mtmLoc);
d938 1
a938 1
bool ESO2problem::mtmInterplantExists     (const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc )const
d940 1
a940 1
  BCP_string mtmBName = baseMtmName(mtm,srcLoc);
d943 1
a943 1
bool ESO2problem::mtmInterplantExists     (const BCP_string & mtm, const BCP_string & srcLoc )const
d945 1
a945 1
  BCP_string mtmBName = baseMtmName(mtm,srcLoc);
d949 3
a951 3
                                   const BCP_string & mtm, 
                                   const BCP_string & srcLoc, 
                                   const BCP_string & destLoc,
d957 5
a961 5
  BCP_string mtmBName = baseMtmName(mtm,srcLoc);
  BCP_string igfMtmWitName = igfMtmName(mtm, srcLoc );
  BCP_string acquireMtmWitName = acquireMtmName(mtm, srcLoc, destLoc );
  BCP_string serverMtmWitName = serverMtmName(mtm, srcLoc, destLoc );
  BCP_string demanMtmWitName = demanMtmName(mtm, srcLoc, destLoc );
d999 1
a999 1
void ESO2problem::setMtmInterplantMoveCost(const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveCost )
d1001 1
a1001 1
  BCP_string name = acquireMtmName(mtm, srcLoc, destLoc );
d1006 1
a1006 1
void ESO2problem::setMtmInterplantMoveTime(const BCP_string & mtm, const BCP_string & srcLoc, const BCP_string & destLoc, int period, float moveTime )
d1008 1
a1008 1
  BCP_string opName = acquireMtmName(mtm,srcLoc,destLoc); 
d1038 1
a1038 1
std::vector<float> ESO2problem::getMtmInterplantMoveCost(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const
d1040 1
a1040 1
  BCP_string name = acquireMtmName(mtm, srcLoc, destLoc );
d1045 1
a1045 1
std::vector<float> ESO2problem::getMtmInterplantMoveTime(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const
d1048 1
a1048 1
  BCP_string opName = acquireMtmName(mtm,srcLoc,destLoc);
d1052 1
a1052 1
std::vector<float> ESO2problem::getMtmInterplantMoveVol(const BCP_string & mtm,const BCP_string & srcLoc, const BCP_string & destLoc )const
d1055 1
a1055 1
  BCP_string opName = acquireMtmName(mtm,srcLoc,destLoc);
d1063 1
a1063 1
void ESO2problem::addPartOrFeatureLoc(const BCP_string & partOrFeatureName, const BCP_string & loc )
d1081 1
a1081 1
void ESO2problem::removePartOrFeatureLoc(const BCP_string & partOrFeatureName, const BCP_string & loc )
d1101 1
a1101 1
std::vector<BCP_string> ESO2problem::getPartLocs(const BCP_string & partName ) const
d1103 1
a1103 1
  std::vector<BCP_string> retVal;
d1122 1
a1122 1
void ESO2problem::addMtmAcquireLoc(const BCP_string & mtmName, const BCP_string & mtmAcquireLoc )
d1148 1
a1148 1
bool ESO2problem::mtmAcquireLocExists(const BCP_string & mtmName, const BCP_string & mtmAcquireLoc ) const
d1161 1
a1161 1
bool ESO2problem::mtmAcquireExists(const BCP_string & mtmName ) const
d1172 1
a1172 1
const std::set<BCP_string> & ESO2problem::getMtmAcquireLocs(const BCP_string & mtmName)const
d1188 1
a1188 1
void ESO2problem::addFeature(const BCP_string & featureName, const BCP_string & featureLoc )
d1190 3
a1192 3
  BCP_string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
  BCP_string acquireFeatureWitName = acquireFeatureName(featureName, featureLoc );
  BCP_string serverFeatureWitName = partName(featureName, featureLoc );
d1205 2
a1206 2
  BCP_string serverOwnedFeatureName = partName(featureName, featureLoc );
  BCP_string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1214 1
a1214 1
  BCP_string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1230 1
a1230 1
  BCP_string baseName = baseFeatureName(featureName, featureLoc );
d1233 1
a1233 1
bool ESO2problem::featureExists(const BCP_string & featureName, const BCP_string & featureLoc )const
d1235 1
a1235 1
  BCP_string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
d1242 1
a1242 1
void ESO2problem::setFeatureSupply(const BCP_string & featureName, const BCP_string & featureLoc, int period, float supply )
d1244 1
a1244 1
  BCP_string name = igfFeatureName(featureName, featureLoc );
d1247 1
a1247 1
void ESO2problem::setFeatureWfmv(const BCP_string & featureName, const BCP_string & featureLoc, int period, float wholeSaleFairMarketValue )
d1249 1
a1249 1
  BCP_string name = acquireFeatureName(featureName, featureLoc );
d1257 2
a1258 2
    std::vector<BCP_string> & features,
    std::vector<BCP_string> & featureLocs ) const
d1270 1
a1270 1
  std::set<BCP_string>::const_iterator it;
d1279 2
a1280 2
                                                 const BCP_string & featureName, 
                                                 const BCP_string & featureLoc )const
d1283 1
a1283 1
  BCP_string opName = acquireFeatureName(featureName,featureLoc);
d1288 2
a1289 2
                                                 const BCP_string & featureName, 
                                                 const BCP_string & featureLoc )const
d1292 1
a1292 1
  BCP_string name = igfFeatureName(featureName,featureLoc);
d1298 2
a1299 2
                                                 const BCP_string & featureName, 
                                                 const BCP_string & featureLoc )const
d1301 1
a1301 1
  BCP_string name = acquireFeatureName(featureName,featureLoc);
d1317 1
a1317 1
void ESO2problem::addLoosePart(const BCP_string & loosePartName, const BCP_string & loosePartLoc )
d1319 3
a1321 3
  BCP_string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
  BCP_string acquireLoosePartWitName = acquireLoosePartName(loosePartName, loosePartLoc );
  BCP_string serverLoosePartWitName = moveablePartName(loosePartName, loosePartLoc );
d1350 1
a1350 1
  BCP_string baseName = baseLoosePartName(loosePartName, loosePartLoc );
d1353 1
a1353 1
bool ESO2problem::loosePartExists(const BCP_string & loosePartName, const BCP_string & loosePartLoc )const
d1355 1
a1355 1
  BCP_string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
d1362 1
a1362 1
void ESO2problem::setLoosePartSupply(const BCP_string & loosePartName, const BCP_string & loosePartLoc, int period, float supply )
d1364 1
a1364 1
  BCP_string name = igfLoosePartName(loosePartName, loosePartLoc );
d1367 1
a1367 1
void ESO2problem::setLoosePartWfmv(const BCP_string & loosePartName, const BCP_string & loosePartLoc, int period, float wholeSaleFairMarketValue )
d1369 1
a1369 1
  BCP_string name = acquireLoosePartName(loosePartName, loosePartLoc );
d1377 2
a1378 2
    std::vector<BCP_string> & looseParts,
    std::vector<BCP_string> & loosePartLocs ) const
d1390 1
a1390 1
  std::set<BCP_string>::const_iterator it;
d1399 2
a1400 2
                                                 const BCP_string & loosePartName, 
                                                 const BCP_string & loosePartLoc )const
d1403 1
a1403 1
  BCP_string opName = acquireLoosePartName(loosePartName,loosePartLoc);
d1408 2
a1409 2
                                                 const BCP_string & loosePartName, 
                                                 const BCP_string & loosePartLoc )const
d1412 1
a1412 1
  BCP_string name = igfLoosePartName(loosePartName,loosePartLoc);
d1417 2
a1418 2
                                                 const BCP_string & loosePartName, 
                                                 const BCP_string & loosePartLoc )const
d1420 1
a1420 1
  BCP_string name = acquireLoosePartName(loosePartName,loosePartLoc);
d1428 1
a1428 1
void ESO2problem::addPartWithOutApplyingInterplants(const BCP_string & part, const BCP_string & partLoc )
d1430 2
a1431 2
  BCP_string witName = partName(part, partLoc );
  BCP_string moveAbleWitName = moveablePartName(part, partLoc );
d1442 1
a1442 1
void ESO2problem::addPart(const BCP_string & part, const BCP_string & partLoc )
d1444 2
a1445 2
  BCP_string witName = partName(part, partLoc );
  BCP_string moveAbleWitName = moveablePartName(part, partLoc );
d1455 1
a1455 1
    const BCP_string & destLoc = interPlantVec[l].getDestLoc();
d1475 1
a1475 1
bool ESO2problem::partExists(const BCP_string & name, const BCP_string & loc )const
d1477 1
a1477 1
  BCP_string witName = partName(name, loc );
d1488 1
a1488 1
bool ESO2problem::demanBomExists(const BCP_string & mtm, const BCP_string & part, const BCP_string & loc )const
d1497 1
a1497 1
void ESO2problem::addDemanBom(const BCP_string & mtm, const BCP_string & part, const BCP_string & loc )
d1514 2
a1515 2
  BCP_string producedPart = moveablePartName(part, loc );
  BCP_string demanOp = demanMtmName(mtm, loc, loc );
d1531 1
a1531 1
  BCP_string mtmBName = baseMtmName(mtm,loc);
d1537 1
a1537 1
    const std::set<BCP_string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1540 1
a1540 1
    std::set<BCP_string>::const_iterator locIt;
d1542 1
a1542 1
      const BCP_string & destLoc = *locIt;
d1557 1
a1557 1
      BCP_string producedPart = moveablePartName(part, destLoc );
d1577 1
a1577 1
std::vector<BCP_string> ESO2problem::getDemanBoms(const BCP_string & mtm, const BCP_string & mtmSrcLoc, const BCP_string & demanLoc)const
d1579 1
a1579 1
  std::vector<BCP_string> retVal;
d1581 1
a1581 1
  BCP_string demanOp = demanMtmName(mtm, mtmSrcLoc, demanLoc );
d1621 3
a1623 3
          const BCP_string & mtm, 
          const BCP_string & part, 
          const BCP_string & loc, 
d1629 2
a1630 2
  BCP_string producedPart = moveablePartName(part, loc );
  BCP_string demanOp = demanMtmName(mtm, loc, loc );
d1645 1
a1645 1
  BCP_string mtmBName = baseMtmName(mtm,loc);
d1651 1
a1651 1
    const std::set<BCP_string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1654 1
a1654 1
    std::set<BCP_string>::const_iterator locIt;
d1656 1
a1656 1
      const BCP_string & destLoc = *locIt;
d1673 3
a1675 3
          const BCP_string & mtm, 
          const BCP_string & part, 
          const BCP_string & loc ) const
d1677 2
a1678 2
  BCP_string producedPart = moveablePartName(part, loc );
  BCP_string demanOp = demanMtmName(mtm, loc, loc );
d1691 3
a1693 3
                                const BCP_string & mtm, 
                                const BCP_string & part, 
                                const BCP_string & loc ) const
d1696 2
a1697 2
  BCP_string producedPart = moveablePartName(part, loc );
  BCP_string producingOp = demanMtmName(mtm, loc, loc );
d1705 2
a1706 2
                                const BCP_string & opName, 
                                const BCP_string & partName
d1734 3
a1736 3
                                  const BCP_string & part, 
                                  const BCP_string & feature, 
                                  const BCP_string & loc )const
d1738 1
a1738 1
  BCP_string xrefName = featureXrefName(part,feature,loc);
d1746 3
a1748 3
                               const BCP_string & part, 
                               const BCP_string & feature, 
                               const BCP_string & loc )
d1755 3
a1757 3
  BCP_string xrefName = featureXrefName(part,feature,loc);  
  BCP_string refPartName = moveablePartName(part,loc); 
  BCP_string featureName = partName(feature,loc);
d1802 3
a1804 3
          const BCP_string & part, 
          const BCP_string & feature, 
          const BCP_string & loc, 
d1809 1
a1809 1
  BCP_string xrefName = featureXrefName(part,feature,loc);
d1827 2
a1828 2
  BCP_string xrefOpName = featureXrefName(part,feature,loc );
  BCP_string acquireFeatureOpName = acquireFeatureName(feature,loc );
d1871 3
a1873 3
          const BCP_string & part, 
          const BCP_string & feature, 
          const BCP_string & loc, 
d1877 1
a1877 1
  BCP_string xrefOpName = featureXrefName(part,feature,loc);
d1886 3
a1888 3
          const BCP_string & part, 
          const BCP_string & feature, 
          const BCP_string & loc, 
d1892 1
a1892 1
  BCP_string xrefOpName = featureXrefName(part,feature,loc);
d1902 3
a1904 3
    std::vector<BCP_string> & parts,
    std::vector<BCP_string> & features,
    std::vector<BCP_string> & locs ) const
d1918 1
a1918 1
  std::set<BCP_string>::const_iterator it;
d1927 3
a1929 3
                                                 const BCP_string & part,
                                                 const BCP_string & feature, 
                                                 const BCP_string & loc )const
d1932 1
a1932 1
  BCP_string opName = featureXrefName(part,feature,loc);
d1938 3
a1940 3
                                                 const BCP_string & part,
                                                 const BCP_string & feature, 
                                                 const BCP_string & loc )const
d1943 1
a1943 1
  BCP_string opName = featureXrefName(part,feature,loc);
d1950 3
a1952 3
                                                 const BCP_string & part,
                                                 const BCP_string & feature, 
                                                 const BCP_string & loc )const
d1955 1
a1955 1
  BCP_string opName = featureXrefName(part,feature,loc);
d1970 3
a1972 3
                                  const BCP_string & partOrFeature, 
                                  const BCP_string & altPart, 
                                  const BCP_string & loc )const
d1974 1
a1974 1
  BCP_string ecOpName = altName(partOrFeature,altPart,loc);
d1983 3
a1985 3
                               const BCP_string & partOrFeature, 
                               const BCP_string & altPart, 
                               const BCP_string & loc,
d1991 3
a1993 3
  BCP_string ecOpName = altName(partOrFeature,altPart,loc);  
  BCP_string upLevelPartName = moveablePartName(altPart,loc); 
  BCP_string downLevelPartName = partName(partOrFeature,loc);
d2025 3
a2027 3
          const BCP_string & upLevelPart, 
          const BCP_string & downLevelPart, 
          const BCP_string & loc, 
d2031 2
a2032 2
  BCP_string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //BCP_string producedPart = partName(upLevelPart,loc);
d2041 3
a2043 3
          const BCP_string & upLevelPart, 
          const BCP_string & downLevelPart, 
          const BCP_string & loc, 
d2047 1
a2047 1
  BCP_string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc);
d2055 3
a2057 3
          const BCP_string & upLevelPart, 
          const BCP_string & downLevelPart, 
          const BCP_string & loc, 
d2061 2
a2062 2
  BCP_string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //BCP_string producedPart = partName(upLevelPart,loc);
d2073 3
a2075 3
    std::vector<BCP_string> & partOrFeatures,
    std::vector<BCP_string> & altParts,
    std::vector<BCP_string> & locs ) const
d2080 1
a2080 1
  std::set<BCP_string>::const_iterator it;
d2090 3
a2092 3
                                                 const BCP_string & partOrFeature,
                                                 const BCP_string & altPart, 
                                                 const BCP_string & loc )const
d2095 1
a2095 1
  BCP_string opName = altName(partOrFeature,altPart,loc);
d2101 3
a2103 3
                                                 const BCP_string & partOrFeature,
                                                 const BCP_string & altPart, 
                                                 const BCP_string & loc )const
d2106 1
a2106 1
  BCP_string opName = altName(partOrFeature,altPart,loc);
d2116 3
a2118 3
                                  const BCP_string & part, 
                                  const BCP_string & srcLoc, 
                                  const BCP_string & destLoc )const
d2120 1
a2120 1
  BCP_string opName = partInterplantName(part,srcLoc,destLoc);
d2129 2
a2130 2
                                     const BCP_string & srcLoc, 
                                     const BCP_string & destLoc, 
d2139 3
a2141 3
                               const BCP_string & part, 
                               const BCP_string & srcLoc, 
                               const BCP_string & destLoc, 
d2146 3
a2148 3
  BCP_string opName = partInterplantName(part,srcLoc,destLoc);  
  BCP_string srcPartName = moveablePartName(part,srcLoc); 
  BCP_string destPartName = partName(part,destLoc);
d2175 3
a2177 3
          const BCP_string & part, 
          const BCP_string & srcLoc, 
          const BCP_string & destLoc, 
d2181 1
a2181 1
  BCP_string opName = partInterplantName(part,srcLoc,destLoc);
d2189 3
a2191 3
          const BCP_string & part, 
          const BCP_string & srcLoc, 
          const BCP_string & destLoc, 
d2195 1
a2195 1
  BCP_string opName = partInterplantName(part,srcLoc,destLoc); 
d2204 3
a2206 3
                    std::vector<BCP_string> & parts, 
                    std::vector<BCP_string> & srcLocs, 
                    std::vector<BCP_string> &destLocs ) const
d2220 1
a2220 1
  std::set<BCP_string>::const_iterator it;
d2229 3
a2231 3
                                        const BCP_string & part,
                                        const BCP_string & srcLoc, 
                                        const BCP_string & destLoc )const
d2234 1
a2234 1
  BCP_string opName = partInterplantName(part,srcLoc,destLoc);
d2239 3
a2241 3
                                        const BCP_string & part,
                                        const BCP_string & srcLoc, 
                                        const BCP_string & destLoc )const
d2244 1
a2244 1
  BCP_string opName = partInterplantName(part,srcLoc,destLoc);
d2254 3
a2256 3
                                  const BCP_string & part, 
                                  const BCP_string & custLoc, 
                                  const BCP_string & plantLoc )const
d2260 2
a2261 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2273 1
a2273 1
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
d2284 3
a2286 3
    const BCP_string & part, 
    const BCP_string & custLoc, 
    const BCP_string & plantLoc, 
d2289 3
a2291 3
    std::vector<BCP_string> & mtms, 
    std::vector<BCP_string> & mtmSrcLocs, 
    std::vector<BCP_string> & mtmAcquireLocs, 
d2295 2
a2296 2
    std::vector<BCP_string> & features, 
    std::vector<BCP_string> & featurePlantLocs, 
d2300 2
a2301 2
    std::vector<BCP_string> & looseParts, 
    std::vector<BCP_string> & loosePartPlantLocs, 
d2307 1
a2307 1
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
d2326 1
a2326 1
      BCP_string t = mtmFromMtmName(witMtms[m].c_str());
d2355 1
a2355 1
      BCP_string t = featureFromFeatureName(witFeatures[m].c_str());
d2381 1
a2381 1
      BCP_string t = loosePartFromLoosePartName(witLooseParts[m].c_str());
d2396 1
a2396 1
void ESO2problem::reportPart(const BCP_string & witPartName, 
d2405 1
a2405 1
  BCP_string indent="";
d2512 3
a2514 3
void ESO2problem::reportPartDemand(const BCP_string & part, 
                      const BCP_string & custLoc, 
                      const BCP_string & plantLoc, 
d2517 3
a2519 3
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2548 7
a2554 7
                               const BCP_string & part, 
                               const BCP_string & custLoc, 
                               const BCP_string & plantLoc )
{
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2580 3
a2582 3
                               const BCP_string & part, 
                               const BCP_string & custLoc, 
                               const BCP_string & plantLoc,
d2586 2
a2587 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string rName = partDemandRegulatorName(part,custLoc,plantLoc);
d2597 3
a2599 3
                               const BCP_string & part, 
                               const BCP_string & custLoc, 
                               const BCP_string & plantLoc,
d2603 2
a2604 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2612 3
a2614 3
                                 std::vector<BCP_string> & parts, 
                                 std::vector<BCP_string> & custLocs, 
                                 std::vector<BCP_string> &plantLocs ) const
d2628 1
a2628 1
  std::set<BCP_string>::const_iterator it;
d2637 3
a2639 3
                                                     const BCP_string & part,
                                                     const BCP_string & custLoc, 
                                                     const BCP_string & plantLoc )const
d2642 2
a2643 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2648 3
a2650 3
                                                     const BCP_string & part,
                                                     const BCP_string & custLoc, 
                                                     const BCP_string & plantLoc )const
d2653 2
a2654 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2659 3
a2661 3
                                                     const BCP_string & part,
                                                     const BCP_string & custLoc, 
                                                     const BCP_string & plantLoc )const
d2664 2
a2665 2
  BCP_string dName = partDemandName(part,custLoc,plantLoc);
  BCP_string pName = partName(part,plantLoc);
d2690 1
a2690 1
  std::set<BCP_string> activeParts;
d2714 1
a2714 1
          BCP_string activePart(belowList[b]);
d2727 3
a2729 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d2733 4
a2736 4
      BCP_string pName = partName(parts[p],destLocs[p]);
      BCP_string mpName = moveablePartName(parts[p],destLocs[p]);
      BCP_string opName = partInterplantName(parts[p],srcLocs[p],destLocs[p]);
      //BCP_string srcPName = partName(parts[p],destLocs[p]);
d2759 3
a2761 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d2765 3
a2767 3
      BCP_string pName = partName(parts[p],locs[p]);
      BCP_string mpName = moveablePartName(parts[p],locs[p]);
      BCP_string opName = featureXrefName(parts[p],features[p],locs[p]);
d2790 2
a2791 2
    std::vector<BCP_string> parts;
    std::vector<BCP_string> locs;
d2795 5
a2799 5
      BCP_string pName = partName(parts[p],locs[p]);
      BCP_string mpName = moveablePartName(parts[p],locs[p]);
      BCP_string opName = acquireLoosePartName(parts[p],locs[p]);
      BCP_string igfPName = igfLoosePartName(parts[p],locs[p]);
      BCP_string baseName = baseLoosePartName(parts[p],locs[p]);
d2825 2
a2826 2
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d2830 5
a2834 5
      BCP_string pName = partName(features[p],locs[p]);
      BCP_string mpName = moveablePartName(features[p],locs[p]);
      BCP_string opName = acquireFeatureName(features[p],locs[p]);
      BCP_string igfFName = igfFeatureName(features[p],locs[p]);
      BCP_string baseName = baseFeatureName(features[p],locs[p]);
d2861 3
a2863 3
    std::vector<BCP_string> partOrFeatures;
    std::vector<BCP_string> altParts;
    std::vector<BCP_string> locs;
d2868 10
a2877 10
      BCP_string ecOpName = altName(partOrFeatures[p],altParts[p],locs[p]);   
      BCP_string upLevelPartName = partName(altParts[p],locs[p]); 
      BCP_string moveableUpLevelPartName = moveablePartName(altParts[p],locs[p]); 
      BCP_string downLevelPartName = partName(partOrFeatures[p],locs[p]);

      //BCP_string pName = partName(altParts[p],locs[p]);
      //BCP_string mpName = moveablePartName(altParts[p],locs[p]);
      //BCP_string opName = acquireFeatureName(features[p],locs[p]);
      //BCP_string igfFName = igfFeatureName(features[p],locs[p]);
      //BCP_string baseName = baseFeatureName(features[p],locs[p]);
d2901 3
a2903 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d2908 5
a2912 5
      BCP_string igfPName = igfMtmName(mtms[p],srcLocs[p] );
      BCP_string acquireOpName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
      BCP_string serverPName = serverMtmName(mtms[p],srcLocs[p],destLocs[p] );
      BCP_string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
      BCP_string baseName = baseMtmName(mtms[p],srcLocs[p] );
d3033 1
a3033 1
                                const BCP_string opName,
d3063 1
a3063 1
  std::vector<BCP_string> mtms,srcLocs,demanLocs;
d3067 1
a3067 1
    std::vector<BCP_string> prodParts = getDemanBoms(mtms[msdTriple],srcLocs[msdTriple],demanLocs[msdTriple]);
d3070 2
a3071 2
      BCP_string pName = partName(prodParts[pp], demanLocs[msdTriple] );
      BCP_string moveablePName = moveablePartName(prodParts[pp], demanLocs[msdTriple] );
d3090 2
a3091 2
      std::vector<BCP_string> mtms;
      std::vector<BCP_string> plantLocs;
d3098 2
a3099 2
        BCP_string mtmBName = baseMtmName(mtms[m],plantLocs[m] );         
        BCP_string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
d3126 1
a3126 1
          const std::set<BCP_string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d3129 1
a3129 1
          std::set<BCP_string>::const_iterator locIt;
d3131 1
a3131 1
            const BCP_string & destLoc = *locIt;
d3134 1
a3134 1
            BCP_string acquireMtmWitName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
d3151 1
a3151 1
            BCP_string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
d3166 2
a3167 2
      std::vector<BCP_string> features;
      std::vector<BCP_string> featureLocs;
d3174 2
a3175 2
        BCP_string featureName = baseFeatureName(features[f],featureLocs[f] );         
        BCP_string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );
d3205 2
a3206 2
      std::vector<BCP_string> looseParts;
      std::vector<BCP_string> loosePartLocs;
d3213 2
a3214 2
        BCP_string loosePartName = baseLoosePartName(looseParts[l],loosePartLocs[l] );         
        BCP_string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );
d3249 2
a3250 2
      std::vector<BCP_string> mtms;
      std::vector<BCP_string> plantLocs;
d3256 2
a3257 2
        BCP_string mtmBName = baseMtmName(mtms[m],plantLocs[m] );    
        BCP_string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
d3269 1
a3269 1
          const std::set<BCP_string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d3271 1
a3271 1
          std::set<BCP_string>::const_iterator locIt;
d3273 2
a3274 2
            const BCP_string & destLoc = *locIt;
            BCP_string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );       
d3289 2
a3290 2
      std::vector<BCP_string> features;
      std::vector<BCP_string> featureLocs;
d3296 1
a3296 1
        BCP_string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );        
d3310 2
a3311 2
      std::vector<BCP_string> looseParts;
      std::vector<BCP_string> loosePartLocs;
d3317 1
a3317 1
        BCP_string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );  
d3333 1
a3333 1
      BCP_string witDataFileName = BCP_string("implode")+BCP_string(asChar)+".wit";
d3376 3
a3378 3
      std::vector<BCP_string> parts;
      std::vector<BCP_string> custLocs;
      std::vector<BCP_string> plantLocs;
d3383 1
a3383 1
        BCP_string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
d3394 1
a3394 1
      std::vector<BCP_string> mtmNames, mtmSrcLocs, mtmDestLocs;
d3399 1
a3399 1
        BCP_string witDemanOpName = demanMtmName( mtmNames[d], mtmSrcLocs[d], mtmDestLocs[d] );
d3425 1
a3425 1
      std::vector<BCP_string> demdParts, demdCustLocs, demdPlantLocs;
d3430 1
a3430 1
        BCP_string dName = partDemandName(demdParts[d], demdCustLocs[d], demdPlantLocs[d] );
d3586 1
a3586 1
BCP_string ESO2problem::igfMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc )
d3590 1
a3590 1
BCP_string ESO2problem::acquireMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc )
d3594 1
a3594 1
BCP_string ESO2problem::serverMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc )
d3598 1
a3598 1
BCP_string ESO2problem::demanMtmName(const BCP_string & mtm,const BCP_string & mtmSrcLoc,const BCP_string & destLoc )
d3602 1
a3602 1
BCP_string ESO2problem::baseMtmName(const BCP_string & mtm,const BCP_string & mtmDestLoc )
d3606 1
a3606 1
BCP_string ESO2problem::mtmFromMtmName(const BCP_string & mtmName)
d3610 1
a3610 1
BCP_string ESO2problem::mtmDestLocFromMtmName(const BCP_string & mtmName)
d3612 1
a3612 1
  BCP_string retVal;
d3621 1
a3621 1
BCP_string ESO2problem::mtmSrcLocFromMtmName(const BCP_string & mtmName)
d3625 1
a3625 1
bool ESO2problem::isMtmDemanName( const BCP_string & witName )
d3633 1
a3633 1
bool ESO2problem::isAcquireMtmName( const BCP_string & witName )
d3645 1
a3645 1
BCP_string ESO2problem::igfFeatureName(const BCP_string & feature,const BCP_string & loc )
d3649 1
a3649 1
BCP_string ESO2problem::acquireFeatureName(const BCP_string & feature,const BCP_string & loc )
d3653 1
a3653 1
BCP_string ESO2problem::baseFeatureName(const BCP_string & feature,const BCP_string & loc )
d3657 1
a3657 1
BCP_string ESO2problem::featureFromFeatureName(const BCP_string & featureName)
d3661 1
a3661 1
BCP_string ESO2problem::locFromFeatureName(const BCP_string & featureName)
d3665 1
a3665 1
bool ESO2problem::isAcquireFeatureName( const BCP_string & witName )
d3678 1
a3678 1
BCP_string ESO2problem::igfLoosePartName(const BCP_string & loosePart,const BCP_string & loc )
d3682 1
a3682 1
BCP_string ESO2problem::acquireLoosePartName(const BCP_string & loosePart,const BCP_string & loc )
d3686 1
a3686 1
BCP_string ESO2problem::baseLoosePartName(const BCP_string & loosePart,const BCP_string & loc )
d3690 1
a3690 1
BCP_string ESO2problem::loosePartFromLoosePartName(const BCP_string & loosePartName)
d3694 1
a3694 1
BCP_string ESO2problem::locFromLoosePartName(const BCP_string & loosePartName)
d3698 1
a3698 1
bool ESO2problem::isAcquireLoosePartName( const BCP_string & witName )
d3709 1
a3709 1
bool ESO2problem::isAcquireName( const BCP_string & witName )
d3721 1
a3721 1
BCP_string ESO2problem::featureXrefName(const BCP_string & part, const BCP_string & feature, const BCP_string & loc)
d3725 1
a3725 1
BCP_string ESO2problem::partFromFeatureXrefName(const BCP_string & featXrefName)
d3729 1
a3729 1
BCP_string ESO2problem::featureFromFeatureXrefName(const BCP_string & featXrefName)
d3733 1
a3733 1
BCP_string ESO2problem::locFromFeatureXrefName(const BCP_string & featXrefName)
d3741 1
a3741 1
BCP_string ESO2problem::altName(const BCP_string & partOrFeature, const BCP_string & altPart, const BCP_string & loc)
d3745 1
a3745 1
BCP_string ESO2problem::partFromAltName(const BCP_string & altName)
d3749 1
a3749 1
BCP_string ESO2problem::altPartFromAltName(const BCP_string & altName)
d3753 1
a3753 1
BCP_string ESO2problem::locFromAltName(const BCP_string & altName)
d3761 1
a3761 1
BCP_string ESO2problem::partInterplantName(const BCP_string & part, const BCP_string & srcLoc, const BCP_string & destLoc)
d3765 1
a3765 1
BCP_string ESO2problem::partFromPartInterplantName(const BCP_string & partInterplantName)
d3769 1
a3769 1
BCP_string ESO2problem::srcLocFromPartInterplantName(const BCP_string & partInterplantName)
d3773 1
a3773 1
BCP_string ESO2problem::destLocFromPartInterplantName(const BCP_string & partInterplantName)
d3780 1
a3780 1
BCP_string ESO2problem::partDemandName(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc)
d3784 1
a3784 1
BCP_string ESO2problem::partDemandRegulatorName(const BCP_string & part, const BCP_string & custLoc, const BCP_string & plantLoc)
d3788 1
a3788 1
BCP_string ESO2problem::partFromPartDemandName(const BCP_string & partDemandName)
d3792 1
a3792 1
BCP_string ESO2problem::custLocFromPartDemandName(const BCP_string & partDemandName)
d3796 1
a3796 1
BCP_string ESO2problem::plantLocFromPartDemandName(const BCP_string & partDemandName)
d3805 1
a3805 1
BCP_string ESO2problem::partName(const BCP_string & part,const BCP_string & loc )
d3810 1
a3810 1
BCP_string ESO2problem::moveablePartName(const BCP_string & part,const BCP_string & loc )
d3815 1
a3815 1
BCP_string ESO2problem::partFromPartName( const BCP_string & partName )
d3823 4
a3826 4
BCP_string ESO2problem::textBetween(
                        const BCP_string & src, 
                        const BCP_string & begMark,
                        const BCP_string & endMark)
d3829 1
a3829 1
  assert( begPos != BCP_string::npos );
d3833 1
a3833 1
  assert( endPos != BCP_string::npos );
d3836 1
a3836 1
  BCP_string retVal = src.substr(begPos,len);
d3839 3
a3841 3
BCP_string ESO2problem::textAfter(
                        const BCP_string & src, 
                        const BCP_string & begMark)
d3844 1
a3844 1
  assert( begPos != BCP_string::npos );
d3850 1
a3850 1
  BCP_string retVal = src.substr(begPos,len);
d3854 2
a3855 2
                        const BCP_string & src, 
                        const BCP_string & begString)
d3862 2
a3863 2
                        const BCP_string & haystack, 
                        const BCP_string & needle)
d3866 1
a3866 1
  if ( pos!=BCP_string::npos ) return true;
d3879 1
a3879 1
    const BCP_string & name,
d3895 1
a3895 1
    const BCP_string & name,
d3906 1
a3906 1
    const BCP_string & name,
d3917 1
a3917 1
    const BCP_string & name,
d3933 1
a3933 1
    const BCP_string & name,
d3956 1
a3956 1
    const BCP_string & opName,
d3975 1
a3975 1
    const BCP_string & opName,
d3989 2
a3990 2
    const BCP_string & partName,
    const BCP_string & demandName,
d4006 1
a4006 1
    const BCP_string & name ) const
d4018 1
a4018 1
                                     const BCP_string & opName,
d4031 1
a4031 1
                                     const BCP_string & opName,
d4046 1
a4046 1
                                     const BCP_string & opName,
d4059 1
a4059 1
                                     const BCP_string & opName,
d4072 1
a4072 1
                                     const BCP_string & opName,
d4084 1
a4084 1
    const BCP_string & opName,
d4105 2
a4106 2
    const BCP_string & partName,
    const BCP_string & demandName )const
d4124 1
a4124 1
    std::vector<BCP_string> & resourceDescriptions,
d4132 1
a4132 1
  std::vector<BCP_string> projects;
d4166 1
a4166 1
void ESO2problem::setTitle( const BCP_string & title)
d4171 1
a4171 1
BCP_string ESO2problem::getTitle() const
d4175 1
a4175 1
  BCP_string retVal(t);
d4201 3
a4203 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d4207 1
a4207 1
    BCP_string witOpName = featureXrefName(parts[i],features[i],locs[i]);
d4222 3
a4224 3
  std::vector<BCP_string> parts;
  std::vector<BCP_string> srcLocs;
  std::vector<BCP_string> destLocs;
d4228 1
a4228 1
    BCP_string witMoveOpName = partInterplantName(parts[i],srcLocs[i],destLocs[i]);
d4243 3
a4245 3
  std::vector<BCP_string> parts;
  std::vector<BCP_string> custLocs;
  std::vector<BCP_string> plantLocs;
d4249 1
a4249 1
    BCP_string witDemandName = partDemandName(parts[i],custLocs[i],plantLocs[i]);
d4268 2
a4269 2
  std::vector<BCP_string> features;
  std::vector<BCP_string> plantLocs;
d4274 2
a4275 2
    BCP_string witAcquireOpName = acquireFeatureName(features[i],plantLocs[i]);
    //BCP_string witPartName = igfFeatureName(features[i],plantLocs[i]);
d4290 2
a4291 2
  std::vector<BCP_string> looseParts;
  std::vector<BCP_string> plantLocs;
d4296 2
a4297 2
    BCP_string witAcquireOpName = acquireLoosePartName(looseParts[i],plantLocs[i]);
    //BCP_string witPartName = igfLoosePartName(looseParts[i],plantLocs[i]);
d4322 3
a4324 3
    std::vector<BCP_string> partOrFeatures;
    std::vector<BCP_string> altParts;
    std::vector<BCP_string> locs;
d4331 1
a4331 1
    BCP_string witAltOpName = altName(partOrFeatures[i],altParts[i],locs[i]);
d4348 3
a4350 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d4355 2
a4356 2
    BCP_string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //BCP_string witPartName = igfFeatureName(features[i],plantLocs[i]);
d4378 3
a4380 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d4385 1
a4385 1
    BCP_string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
d4400 3
a4402 3
  std::vector<BCP_string> mtms;
  std::vector<BCP_string> srcLocs;
  std::vector<BCP_string> destLocs;
d4407 2
a4408 2
    BCP_string witAcquireOpName = demanMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //BCP_string witPartName = igfFeatureName(features[i],plantLocs[i]);
d4437 2
a4438 2
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> locs;
d4459 3
a4461 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d4504 2
a4505 2
  std::vector<BCP_string> features;
  std::vector<BCP_string> plantLocs;
d4549 2
a4550 2
  std::vector<BCP_string> looseParts;
  std::vector<BCP_string> plantLocs;
d4592 3
a4594 3
  std::vector<BCP_string> parts;
  std::vector<BCP_string> custLocs;
  std::vector<BCP_string> plantLocs;
d4623 1
a4623 1
void ESO2problem::setOslMesgFileName(const BCP_string & name)
d4683 1
a4683 1
void ESO2problem::writeWitData( BCP_string filename ) const
d4859 3
a4861 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> custLocs;
    std::vector<BCP_string> plantLocs;
d4867 1
a4867 1
      BCP_string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
d4875 2
a4876 2
    std::vector<BCP_string> parts;
    std::vector<BCP_string> locs;
d4882 1
a4882 1
      BCP_string opName = acquireLoosePartName(parts[p],locs[p]);
d4891 2
a4892 2
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d4898 1
a4898 1
      BCP_string opName = acquireFeatureName(features[p],locs[p]);
d4907 3
a4909 3
    std::vector<BCP_string> features;
    std::vector<BCP_string> parts;
    std::vector<BCP_string> locs;
d4915 1
a4915 1
      BCP_string opName = featureXrefName(features[p],parts[p],locs[p]);
d4924 3
a4926 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d4932 1
a4932 1
      BCP_string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4939 1
a4939 1
        BCP_string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4971 3
a4973 3
    std::vector<BCP_string> parts;
    std::vector<BCP_string> custLocs;
    std::vector<BCP_string> plantLocs;
d4978 1
a4978 1
      BCP_string dName = partDemandName(parts[p],custLocs[p],plantLocs[p]);
d4987 2
a4988 2
    std::vector<BCP_string> parts;
    std::vector<BCP_string> locs;
d4993 1
a4993 1
      BCP_string opName = acquireLoosePartName(parts[p],locs[p]);
d5001 2
a5002 2
    std::vector<BCP_string> features;
    std::vector<BCP_string> locs;
d5007 1
a5007 1
      BCP_string opName = acquireFeatureName(features[p],locs[p]);
d5015 3
a5017 3
    std::vector<BCP_string> features;
    std::vector<BCP_string> parts;
    std::vector<BCP_string> locs;
d5022 1
a5022 1
      BCP_string opName = featureXrefName(features[p],parts[p],locs[p]);
d5031 3
a5033 3
    std::vector<BCP_string> mtms;
    std::vector<BCP_string> srcLocs;
    std::vector<BCP_string> destLocs;
d5038 1
a5038 1
      BCP_string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
d5044 1
a5044 1
        BCP_string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
d5128 1
a5128 1
      BCP_string demanMtmWitName = demanMtmName("m1","loc1","loc2" );
d5147 1
a5147 1
    std::vector<BCP_string> mtms,mtmSrcLocs,mtmAcquireLocs;
d5150 1
a5150 1
    std::vector<BCP_string> features,featurePlantLocs;
d5153 1
a5153 1
    std::vector<BCP_string> looseParts,loosePartPlantLocs;
d5423 1
a5423 1
  BCP_string fileName = "unitTestResults.csv";
d5427 1
a5427 1
  std::vector<BCP_string> testCases;
d5468 1
a5468 1
        std::vector<BCP_string> parts = p.getParts();
d5539 1
a5539 1
                  BCP_string stdName(name);
@


1.75
log
@Code restored to state before etnParts were added
@
text
@d19 1
d28 1
d35 4
d845 1
a845 1
    mtmLoc.push_back( mtmLocFromMtmName(mtmNames_[m]) );
d851 1
a851 1
    mtmLoc.push_back( mtmLocFromMtmName(*it) );
d871 1
a871 1
    const BCP_string & srcLoc = mtmLocFromMtmName(mtmNames_[m]);
d876 1
a876 1
    const BCP_string & srcLoc = mtmLocFromMtmName(*it);
d1580 1
d1583 1
d1593 24
d2281 115
d2572 4
d3344 236
d3586 1
a3586 1
BCP_string ESO2problem::igfMtmName(const BCP_string & mtm,const BCP_string & mtmLoc )
d3588 1
a3588 1
  return "igf: "+baseMtmName(mtm,mtmLoc);
d3590 1
a3590 1
BCP_string ESO2problem::acquireMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc )
d3592 1
a3592 1
  return "acquire: "+baseMtmName(mtm,destLoc)+" from: "+mtmLoc;
d3594 1
a3594 1
BCP_string ESO2problem::serverMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc )
d3596 1
a3596 1
  return "server: "+baseMtmName(mtm,destLoc)+" from: "+mtmLoc;
d3598 1
a3598 1
BCP_string ESO2problem::demanMtmName(const BCP_string & mtm,const BCP_string & mtmLoc,const BCP_string & destLoc )
d3600 1
a3600 1
  return "deman: "+baseMtmName(mtm,destLoc)+" from: "+mtmLoc;
d3602 1
a3602 1
BCP_string ESO2problem::baseMtmName(const BCP_string & mtm,const BCP_string & mtmLoc )
d3604 1
a3604 1
  return "mtm "+mtm+" at "+mtmLoc;
d3610 12
a3621 1
BCP_string ESO2problem::mtmLocFromMtmName(const BCP_string & mtmName)
d3623 17
a3639 1
  return textAfter(mtmName," at ");
d3665 9
d3698 9
d3709 9
d3861 8
d4857 16
d4968 15
d5146 25
@


1.74
log
@Modified code to add etn flag to mtm, feature, and loose part
@
text
@d1095 1
a1095 1
std::vector<BCP_string> ESO2problem::getPartLocs(const BCP_string & partWEtnName ) const
d1100 1
a1100 1
  it = partOrFeatureLocs_.find(partWEtnName);
d1186 1
a1186 1
  BCP_string serverFeatureWitName = partWEtnName(featureName, featureLoc );
d1199 2
a1200 2
  BCP_string serverOwnedFeatureName = partWEtnName(featureName, featureLoc );
  BCP_string moveableServerOwnedFeatureName = moveablePartWEtnName(featureName, featureLoc );
d1208 1
a1208 1
  BCP_string moveableServerOwnedFeatureName = moveablePartWEtnName(featureName, featureLoc );
d1315 1
a1315 1
  BCP_string serverLoosePartWitName = moveablePartWEtnName(loosePartName, loosePartLoc );
d1424 2
a1425 3
  // Part with etn
  BCP_string witWEtnName = partWEtnName(part, partLoc );
  BCP_string moveAbleWEtnWitName = moveablePartWEtnName(part, partLoc );
d1427 5
a1431 26
  addNonScrapableCapacity( witWEtnName.c_str());
  addNonScrapableCapacity(moveAbleWEtnWitName.c_str());
  witAddOperation(witRun(),moveAbleWEtnWitName.c_str());
  witAddBomEntry(witRun(),moveAbleWEtnWitName.c_str(),moveAbleWEtnWitName.c_str());
  witAddBopEntry(witRun(),moveAbleWEtnWitName.c_str(),witWEtnName.c_str());

  // Part without etn
  BCP_string witWOEtnName = partWOEtnName(part, partLoc );
  BCP_string moveAbleWOEtnWitName = moveablePartWOEtnName(part, partLoc );
  addNonScrapableCapacity( witWOEtnName.c_str());
  addNonScrapableCapacity(moveAbleWOEtnWitName.c_str());
  witAddOperation(witRun(),moveAbleWOEtnWitName.c_str());
  witAddBomEntry(witRun(),moveAbleWOEtnWitName.c_str(),moveAbleWOEtnWitName.c_str());
  witAddBopEntry(witRun(),moveAbleWOEtnWitName.c_str(),witWOEtnName.c_str());

  // connect parts with and without etn
  BCP_string witName = partName(part, partLoc );
  witAddOperation(witRun(),witWEtnName.c_str());
  witAddBomEntry(witRun(),witWEtnName.c_str(),witWEtnName.c_str());
  witAddOperation(witRun(),witWOEtnName.c_str());
  witAddBomEntry(witRun(),witWOEtnName.c_str(),witWEtnName.c_str());
  addNonScrapableCapacity(witName.c_str());
  
  witAddBopEntry(witRun(), witWEtnName.c_str(),witName.c_str());
  witAddBopEntry(witRun(),witWOEtnName.c_str(),witName.c_str());

d1438 2
a1439 2
  //BCP_string witName = partWEtnName(part, partLoc );
  //BCP_string moveAbleWitName = moveablePartWEtnName(part, partLoc );
d1471 1
a1471 1
  BCP_string witName = partWEtnName(name, loc );
d1503 2
a1504 2
  witSetNameAttribute(witSetPartObj1ScrapCost,partWEtnName(part, loc ),0.0f);
  witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartWEtnName(part, loc ),0.0f);
d1508 1
a1508 1
  BCP_string producedPart = moveablePartWEtnName(part, loc );
d1545 2
a1546 2
      witSetNameAttribute(witSetPartObj1ScrapCost,partWEtnName(part, destLoc ),0.0f);
      witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartWEtnName(part, destLoc ),0.0f);
d1551 1
a1551 1
      BCP_string producedPart = moveablePartWEtnName(part, destLoc );
d1583 1
a1583 1
    retVal.push_back(partFromPartWEtnName(prodPart));    
d1597 1
a1597 1
  BCP_string producedPart = moveablePartWEtnName(part, loc );
d1645 1
a1645 1
  BCP_string producedPart = moveablePartWEtnName(part, loc );
d1664 1
a1664 1
  BCP_string producedPart = moveablePartWEtnName(part, loc );
d1674 1
a1674 1
                                const BCP_string & partWEtnName
d1689 1
a1689 1
    if(partWEtnName==prodPartFromWit) retVal=bei;
d1724 2
a1725 2
  BCP_string refPartName = moveablePartWEtnName(part,loc); 
  BCP_string featureName = partWEtnName(feature,loc);
d1960 2
a1961 2
  BCP_string upLevelPartName = moveablePartWEtnName(altPart,loc); 
  BCP_string downLevelPartName = partWEtnName(partOrFeature,loc);
d2000 1
a2000 1
  //BCP_string producedPart = partWEtnName(upLevelPart,loc);
d2030 1
a2030 1
  //BCP_string producedPart = partWEtnName(upLevelPart,loc);
d2115 2
a2116 2
  BCP_string srcPartName = moveablePartWEtnName(part,srcLoc); 
  BCP_string destPartName = partWEtnName(part,destLoc);
d2229 1
a2229 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2372 1
a2372 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2407 1
a2407 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2453 1
a2453 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2492 1
a2492 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2503 1
a2503 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2514 1
a2514 1
  BCP_string pName = partWEtnName(part,plantLoc);
d2582 2
a2583 2
      BCP_string pName = moveablePartWEtnName(parts[p],destLocs[p]);
      BCP_string mpName = moveablePartWEtnName(parts[p],destLocs[p]);
d2585 1
a2585 1
      //BCP_string srcPName = partWEtnName(parts[p],destLocs[p]);
d2614 2
a2615 2
      BCP_string pName = partWEtnName(parts[p],locs[p]);
      BCP_string mpName = moveablePartWEtnName(parts[p],locs[p]);
d2619 1
a2619 1
        std::cout <<"Prunning featureXrefs: " <<pName.c_str() <<std::endl;
d2629 1
a2629 1
        witSetOperationSelForDel(witRun(),mpName.c_str(),WitTRUE);
d2644 2
a2645 2
      BCP_string pName = partWEtnName(parts[p],locs[p]);
      BCP_string mpName = moveablePartWEtnName(parts[p],locs[p]);
d2651 1
a2651 1
        std::cout <<"Prunning loose parts: " <<pName.c_str() <<std::endl;
d2662 1
a2662 1
        witSetOperationSelForDel(witRun(),mpName.c_str(),WitTRUE);
d2679 2
a2680 2
      BCP_string pName = partWEtnName(features[p],locs[p]);
      BCP_string mpName = moveablePartWEtnName(features[p],locs[p]);
d2686 1
a2686 1
        std::cout <<"Prunning features: " <<pName.c_str() <<std::endl;
d2697 1
a2697 1
        witSetOperationSelForDel(witRun(),mpName.c_str(),WitTRUE);
d2718 3
a2720 3
      BCP_string upLevelPartName = partWEtnName(altParts[p],locs[p]); 
      BCP_string moveableUpLevelPartName = moveablePartWEtnName(altParts[p],locs[p]); 
      BCP_string downLevelPartName = partWEtnName(partOrFeatures[p],locs[p]);
d2722 2
a2723 2
      //BCP_string pName = partWEtnName(altParts[p],locs[p]);
      //BCP_string mpName = moveablePartWEtnName(altParts[p],locs[p]);
d2729 1
a2729 1
        std::cout <<"Prunning alts: " <<upLevelPartName.c_str() <<std::endl;
d2740 1
a2740 1
        witSetOperationSelForDel(witRun(),moveableUpLevelPartName.c_str(),WitTRUE);
d2764 1
a2764 1
        std::cout <<"Prunning mtm deman locs: " <<demanOpName.c_str() <<std::endl;
d2794 1
a2794 1
          std::cout <<"Prunning : " <<producedPart <<std::endl;  
d2799 1
a2799 1
          assert(strcmp(op,moveableProducedPart)==0);
d2841 2
a2842 2
        char * partWEtnName;
        witGetObjItrPart(witRun(),&partWEtnName);
d2845 3
a2847 3
        if( activeParts.find(partWEtnName)==activeParts.end() ) {
          std::cout <<"Inactive part: " <<partWEtnName <<std::endl;
          //witSetPartSelForDel(witRun(),partWEtnName,WitTRUE);
d2849 1
a2849 1
        witFree(partWEtnName);
d2919 2
a2920 2
      BCP_string pName = partWEtnName(prodParts[pp], demanLocs[msdTriple] );
      BCP_string moveablePName = moveablePartWEtnName(prodParts[pp], demanLocs[msdTriple] );
a3367 18
BCP_string ESO2problem::partWEtnName(const BCP_string & part,const BCP_string & loc )
{
  return "part: "+part+" with etn at "+loc;
}

BCP_string ESO2problem::moveablePartWEtnName(const BCP_string & part,const BCP_string & loc )
{
  return "moveable"+partWEtnName(part,loc);
}

BCP_string ESO2problem::partFromPartWEtnName( const BCP_string & partWEtnName )
{
  return textBetween(partWEtnName, "part: ", " with etn at " );
}
BCP_string ESO2problem::partWOEtnName(const BCP_string & part,const BCP_string & loc )
{
  return "part: "+part+" without etn at "+loc;
}
d3369 1
a3369 1
BCP_string ESO2problem::moveablePartWOEtnName(const BCP_string & part,const BCP_string & loc )
d3371 1
a3371 1
  return "moveable"+partWOEtnName(part,loc);
d3374 1
a3374 1
BCP_string ESO2problem::partFromPartWOEtnName( const BCP_string & partWEtnName )
d3376 1
a3376 1
  return textBetween(partWEtnName, "part: ", " without etn at " );
d3514 1
a3514 1
  //int bei = getBopEntryIndex(opName,partWEtnName);
d3540 1
a3540 1
    const BCP_string & partWEtnName,
d3548 1
a3548 1
  witGetFunc(mutableWitRun(),partWEtnName.c_str(),demandName.c_str(),&floatStar);
d3550 1
a3550 1
  witSetFunc(witRun(),partWEtnName.c_str(),demandName.c_str(),floatStar);
d3656 1
a3656 1
    const BCP_string & partWEtnName,
d3660 1
a3660 1
  witGetFunc(mutableWitRun(),partWEtnName.c_str(),demandName.c_str(),&attr);
@


1.73
log
@modified to reduce the number of times wit does preprocessing
@
text
@d1095 1
a1095 1
std::vector<BCP_string> ESO2problem::getPartLocs(const BCP_string & partName ) const
d1100 1
a1100 1
  it = partOrFeatureLocs_.find(partName);
d1186 1
a1186 1
  BCP_string serverFeatureWitName = partName(featureName, featureLoc );
d1199 2
a1200 2
  BCP_string serverOwnedFeatureName = partName(featureName, featureLoc );
  BCP_string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1208 1
a1208 1
  BCP_string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1315 1
a1315 1
  BCP_string serverLoosePartWitName = moveablePartName(loosePartName, loosePartLoc );
d1424 20
d1445 9
a1453 7
  BCP_string moveAbleWitName = moveablePartName(part, partLoc );
  assert( !partExists(part,partLoc) );
  addNonScrapableCapacity( witName.c_str());
  addNonScrapableCapacity(moveAbleWitName.c_str());
  witAddOperation(witRun(),witName.c_str());
  witAddBomEntry(witRun(),witName.c_str(),moveAbleWitName.c_str());
  witAddBopEntry(witRun(),witName.c_str(),witName.c_str());
d1460 2
a1461 2
  BCP_string witName = partName(part, partLoc );
  BCP_string moveAbleWitName = moveablePartName(part, partLoc );
d1493 1
a1493 1
  BCP_string witName = partName(name, loc );
d1525 2
a1526 2
  witSetNameAttribute(witSetPartObj1ScrapCost,partName(part, loc ),0.0f);
  witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartName(part, loc ),0.0f);
d1530 1
a1530 1
  BCP_string producedPart = moveablePartName(part, loc );
d1567 2
a1568 2
      witSetNameAttribute(witSetPartObj1ScrapCost,partName(part, destLoc ),0.0f);
      witSetNameAttribute(witSetPartObj1ScrapCost,moveablePartName(part, destLoc ),0.0f);
d1573 1
a1573 1
      BCP_string producedPart = moveablePartName(part, destLoc );
d1605 1
a1605 1
    retVal.push_back(partFromPartName(prodPart));    
d1619 1
a1619 1
  BCP_string producedPart = moveablePartName(part, loc );
d1667 1
a1667 1
  BCP_string producedPart = moveablePartName(part, loc );
d1686 1
a1686 1
  BCP_string producedPart = moveablePartName(part, loc );
d1696 1
a1696 1
                                const BCP_string & partName
d1711 1
a1711 1
    if(partName==prodPartFromWit) retVal=bei;
d1746 2
a1747 2
  BCP_string refPartName = moveablePartName(part,loc); 
  BCP_string featureName = partName(feature,loc);
d1982 2
a1983 2
  BCP_string upLevelPartName = moveablePartName(altPart,loc); 
  BCP_string downLevelPartName = partName(partOrFeature,loc);
d2022 1
a2022 1
  //BCP_string producedPart = partName(upLevelPart,loc);
d2052 1
a2052 1
  //BCP_string producedPart = partName(upLevelPart,loc);
d2137 2
a2138 2
  BCP_string srcPartName = moveablePartName(part,srcLoc); 
  BCP_string destPartName = partName(part,destLoc);
d2251 1
a2251 1
  BCP_string pName = partName(part,plantLoc);
d2394 1
a2394 1
  BCP_string pName = partName(part,plantLoc);
d2429 1
a2429 1
  BCP_string pName = partName(part,plantLoc);
d2475 1
a2475 1
  BCP_string pName = partName(part,plantLoc);
d2514 1
a2514 1
  BCP_string pName = partName(part,plantLoc);
d2525 1
a2525 1
  BCP_string pName = partName(part,plantLoc);
d2536 1
a2536 1
  BCP_string pName = partName(part,plantLoc);
d2604 2
a2605 2
      BCP_string pName = partName(parts[p],destLocs[p]);
      BCP_string mpName = moveablePartName(parts[p],destLocs[p]);
d2607 1
a2607 1
      //BCP_string srcPName = partName(parts[p],destLocs[p]);
d2636 2
a2637 2
      BCP_string pName = partName(parts[p],locs[p]);
      BCP_string mpName = moveablePartName(parts[p],locs[p]);
d2641 1
a2641 1
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;
d2651 1
a2651 1
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
d2666 2
a2667 2
      BCP_string pName = partName(parts[p],locs[p]);
      BCP_string mpName = moveablePartName(parts[p],locs[p]);
d2673 1
a2673 1
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;
d2684 1
a2684 1
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
d2701 2
a2702 2
      BCP_string pName = partName(features[p],locs[p]);
      BCP_string mpName = moveablePartName(features[p],locs[p]);
d2708 1
a2708 1
        std::cout <<"Prunning: " <<pName.c_str() <<std::endl;
d2719 1
a2719 1
        witSetOperationSelForDel(witRun(),pName.c_str(),WitTRUE);
d2740 3
a2742 3
      BCP_string upLevelPartName = partName(altParts[p],locs[p]); 
      BCP_string moveableUpLevelPartName = moveablePartName(altParts[p],locs[p]); 
      BCP_string downLevelPartName = partName(partOrFeatures[p],locs[p]);
d2744 2
a2745 2
      //BCP_string pName = partName(altParts[p],locs[p]);
      //BCP_string mpName = moveablePartName(altParts[p],locs[p]);
d2751 1
a2751 1
        std::cout <<"Prunning: " <<upLevelPartName.c_str() <<std::endl;
d2762 1
a2762 1
        witSetOperationSelForDel(witRun(),upLevelPartName.c_str(),WitTRUE);
d2786 1
a2786 1
        std::cout <<"Prunning: " <<demanOpName.c_str() <<std::endl;
d2816 1
a2816 1
          std::cout <<"Prunning: " <<producedPart <<std::endl;  
d2821 1
a2821 1
          assert(strcmp(op,producedPart)==0);
d2863 2
a2864 2
        char * partName;
        witGetObjItrPart(witRun(),&partName);
d2867 3
a2869 3
        if( activeParts.find(partName)==activeParts.end() ) {
          std::cout <<"Inactive part: " <<partName <<std::endl;
          //witSetPartSelForDel(witRun(),partName,WitTRUE);
d2871 1
a2871 1
        witFree(partName);
d2941 2
a2942 2
      BCP_string pName = partName(prodParts[pp], demanLocs[msdTriple] );
      BCP_string moveablePName = moveablePartName(prodParts[pp], demanLocs[msdTriple] );
d3390 18
d3409 1
a3409 1
BCP_string ESO2problem::moveablePartName(const BCP_string & part,const BCP_string & loc )
d3411 1
a3411 1
  return "moveable"+partName(part,loc);
d3414 1
a3414 1
BCP_string ESO2problem::partFromPartName( const BCP_string & partName )
d3416 1
a3416 1
  return textBetween(partName, "part: ", " at " );
d3554 1
a3554 1
  //int bei = getBopEntryIndex(opName,partName);
d3580 1
a3580 1
    const BCP_string & partName,
d3588 1
a3588 1
  witGetFunc(mutableWitRun(),partName.c_str(),demandName.c_str(),&floatStar);
d3590 1
a3590 1
  witSetFunc(witRun(),partName.c_str(),demandName.c_str(),floatStar);
d3696 1
a3696 1
    const BCP_string & partName,
d3700 1
a3700 1
  witGetFunc(mutableWitRun(),partName.c_str(),demandName.c_str(),&attr);
@


1.72
log
@modified to reduce the number of times wit does preprocessing
@
text
@d523 3
a525 3
     impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,xrefOpName,0) );
     impPersVecs.push_back( witGetArcAttribute(witGetBopEntryImpactPeriod,acquireFeatureOpName,0) );
     impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,acquireFeatureOpName,0) );
d4913 1
a4913 1
#define WRITE_RESULTS
@


1.71
log
@Replaced std::string with BCP_string to work around VAC compiler problem
@
text
@d21 1
d31 1
d405 2
a406 2
// Set prodRates from attach rates
void ESO2problem::setDemanBomProdRates()
a408 1
  std::cout <<"Setting attachRates using period of mtm supply" <<std::endl;
d411 1
a411 1
  setDemanBomProdRatesAreSet(true);
d419 3
d487 75
a562 1
    std::cout <<"Finished setting attachRates using period of mtm supply" <<std::endl;
d1595 1
a1595 1
  setDemanBomProdRatesAreSet(false);
d1718 2
d1745 2
d1750 10
d1764 1
a1764 1
  delete [] prodRate;
d1778 10
a1809 1
#if 1
a1831 3
#else
  witProdRate[period] = applProdRate;
#endif
d1834 1
d1917 17
d1984 1
a1984 1
  float * prodRate = floatToConstFloatStar(0.f);
d2530 1
a2530 1
  setDemanBomProdRates();
d2928 1
a2928 1
  setDemanBomProdRates();
a3768 23
#if 0
double ESO2problem::sumOfAlternatePartCost() const
{
  double retVal=0.0;
  int np=getNPeriods();
    std::vector<BCP_string> upLevelParts;
    std::vector<BCP_string> downLevelParts;
    std::vector<BCP_string> plantLocs;
    getAlternateParts(upLevelParts,downLevelParts,plantLocs);
  int i;
  for ( i=0; i<upLevelParts.size(); ++i ) {
    BCP_string witOpName = alternatePartName(upLevelParts[i],downLevelParts[i],plantLocs[i]);
    std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witOpName);
    std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witOpName);
    
    int t;
    for ( t=0; t<np; ++t ) {
      retVal += execVol[t]*execCost[t];
    }
  }
  return retVal;
}
#endif
d3867 28
d4083 1
d4087 1
d4095 1
d4256 1
a4256 1
demanBomProdRatesAreSet_(false),
d4342 1
a4342 1
demanBomProdRatesAreSet_(false),
d4389 1
a4389 1
  demanBomProdRatesAreSet_  = source.demanBomProdRatesAreSet_;
d4439 17
d4532 16
d4913 1
a4913 1
//#define WRITE_RESULTS
d4923 1
d5019 1
a5019 1
            assert( p1Obj==p3Obj || tc==5 );
d5068 1
d5073 1
a5073 1
                (mtmWfmv + featureWfmv + loosePartWfmv +
d5117 1
d5126 1
@


1.70
log
@desparate change to try to fix things
@
text
@d35 1
a35 1
                                           const std::string & operationName,
d52 1
a52 1
bool ESO2problem::witGetDemandExists(const std::string & pn, const std::string & dn ) const
d74 1
a74 1
                                const std::string & id,
d85 1
a85 1
      std::cout <<id <<" period: " <<t <<" vol: " <<execTv1[t] <<" " <<execTv2[t] <<" cost: " <<costTv1[t] <<" " <<costTv2[t] <<std::endl;
d115 1
a115 1
        std::string id = std::string(demandName) + "/" + demandedPartName;
d145 1
a145 1
        std::string id = std::string(demandName) + "/" + demandedPartName;
d179 1
a179 1
        std::string id = std::string("Operation:: ") + operationName;
d208 1
a208 1
        std::string id = std::string("Operation:: ") + operationName;
d247 1
a247 1
        std::string id = std::string("Subs:: ") + operationName + " bomEntry: " + bomEntryAsChar + " subEntry: " + subEntryAsChar;
d281 1
a281 1
        std::string id = std::string("Subs:: ") + operationName + "bomEntry: " + bomEntryAsChar + "subEntry: " + subEntryAsChar;
d294 2
a295 2
       const std::string & acquireOperation, 
       const std::string & acquiredPart,
d418 3
a420 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d433 1
a433 1
      std::string baseDemanOpName = demanMtmName(mtms[m],srcLocs[m],srcLocs[m] );
d448 2
a449 2
        std::string demanOpName = demanMtmName(mtms[m],srcLocs[m],destLocs[m] );
        std::string moveAndAcquireOpName = acquireMtmName(mtms[m],srcLocs[m],destLocs[m] );
d492 2
a493 2
                         const std::string & part,
                         const std::string & partLoc,
d497 2
a498 2
  std::string acquireOpName = acquireLoosePartName(part,partLoc);  
  std::string acquiredPartName = igfLoosePartName(part,partLoc);
d502 2
a503 2
                         const std::string & feature,
                         const std::string & featureLoc,
d507 2
a508 2
  std::string acquireOpName = acquireFeatureName(feature,featureLoc);  
  std::string acquiredPartName = igfFeatureName(feature,featureLoc);
d512 3
a514 3
                         const std::string & mtm,
                         const std::string & srcLoc,
                         const std::string & destLoc,
d519 2
a520 2
  std::string moveAndAcquireOpName = acquireMtmName(mtm,srcLoc,destLoc);  
  std::string acquiredPartName = igfMtmName(mtm,srcLoc);
d525 2
a526 2
                         const std::string & witAcquireOpName,
                         const std::string & witAcquiredPartName,
d577 1
a577 1
void ESO2problem::addNonScrapableCapacity(const std::string & name )
d589 1
a589 1
void ESO2problem::addMtm(const std::string & mtmName, const std::string & mtmLoc,
d592 4
a595 4
  std::string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
  std::string acquireMtmWitName = acquireMtmName(mtmName, mtmLoc, mtmLoc );
  std::string serverMtmWitName = serverMtmName(mtmName, mtmLoc, mtmLoc );
  std::string demanMtmWitName = demanMtmName(mtmName, mtmLoc, mtmLoc );
d631 1
a631 1
  std::string baseName = baseMtmName(mtmName, mtmLoc );
d636 1
a636 1
bool ESO2problem::mtmExists(const std::string & mtmName, const std::string & mtmLoc )const
d638 1
a638 1
  std::string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
d648 2
a649 2
    const std::string & mtmName, 
    const std::string & mtmLoc, 
d653 1
a653 1
  std::string name = igfMtmName(mtmName, mtmLoc );
d657 2
a658 2
    const std::string & mtmName, 
    const std::string & mtmLoc, 
d662 1
a662 1
  std::string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
d668 2
a669 2
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
d671 1
a671 1
  std::string name = acquireMtmName(mtmName, mtmLoc, mtmLoc );
d677 3
a679 3
                     const std::string & mtmName, 
                     const std::string & supplyLoc, 
                     const std::string & demanLoc, 
d683 1
a683 1
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d687 2
a688 2
    const std::string & mtmName, 
    const std::string & mtmLoc, 
d692 1
a692 1
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d696 3
a698 3
    const std::string & mtmName, 
    const std::string & supplyLoc, 
    const std::string & demanLoc,
d701 1
a701 1
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d705 2
a706 2
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
d708 1
a708 1
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d712 2
a713 2
    const std::string & mtmName, 
    const std::string & mtmLoc, 
d717 1
a717 1
  std::string name = demanMtmName(mtmName, mtmLoc,mtmLoc );
d722 3
a724 3
                     const std::string & mtmName, 
                     const std::string & supplyLoc, 
                     const std::string & demanLoc, 
d728 1
a728 1
  std::string name = demanMtmName(mtmName, supplyLoc, demanLoc );
d733 3
a735 3
    const std::string & mtmName, 
    const std::string & supplyLoc,  
    const std::string & demanLoc, 
d738 1
a738 1
  std::string name = demanMtmName(mtmName, supplyLoc,demanLoc );
d742 2
a743 2
    const std::string & mtmName, 
    const std::string & mtmLoc ) const
d745 1
a745 1
  std::string name = demanMtmName(mtmName, mtmLoc, mtmLoc );
d751 2
a752 2
    std::vector<std::string> & mtms,
    std::vector<std::string> & mtmLoc ) const
d764 1
a764 1
  std::set<std::string>::const_iterator it;
d774 3
a776 3
    std::vector<std::string> & mtms,
    std::vector<std::string> & srcLocs,
    std::vector<std::string> & destLocs ) const
d786 2
a787 2
    const std::string & mtm = mtmFromMtmName(mtmNames_[m]);
    const std::string & srcLoc = mtmLocFromMtmName(mtmNames_[m]);
d789 1
a789 1
  std::set<std::string>::const_iterator it;
d791 2
a792 2
    const std::string & mtm = mtmFromMtmName(*it);
    const std::string & srcLoc = mtmLocFromMtmName(*it);
d799 1
a799 1
    std::string mtmBName = baseMtmName(mtm,srcLoc);
d805 1
a805 1
      const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d808 1
a808 1
      std::set<std::string>::const_iterator locIt;
d810 1
a810 1
        const std::string & destLoc = *locIt;
d822 2
a823 2
                                                 const std::string & mtmName, 
                                                 const std::string & mtmLoc )const
d826 1
a826 1
  std::string opName = acquireMtmName(mtmName,mtmLoc,mtmLoc);
d831 3
a833 3
                                                 const std::string & mtmName, 
                                                 const std::string & srcLoc , 
                                                 const std::string & destLoc )const
d836 1
a836 1
  std::string opName = acquireMtmName(mtmName,srcLoc,destLoc);
d841 2
a842 2
                                                 const std::string & mtmName, 
                                                 const std::string & mtmLoc )const
d845 1
a845 1
  std::string name = igfMtmName(mtmName,mtmLoc);
d854 1
a854 1
bool ESO2problem::mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc )const
d856 1
a856 1
  std::string mtmBName = baseMtmName(mtm,srcLoc);
d859 1
a859 1
bool ESO2problem::mtmInterplantExists     (const std::string & mtm, const std::string & srcLoc )const
d861 1
a861 1
  std::string mtmBName = baseMtmName(mtm,srcLoc);
d865 3
a867 3
                                   const std::string & mtm, 
                                   const std::string & srcLoc, 
                                   std::string destLoc,
d873 5
a877 5
  std::string mtmBName = baseMtmName(mtm,srcLoc);
  std::string igfMtmWitName = igfMtmName(mtm, srcLoc );
  std::string acquireMtmWitName = acquireMtmName(mtm, srcLoc, destLoc );
  std::string serverMtmWitName = serverMtmName(mtm, srcLoc, destLoc );
  std::string demanMtmWitName = demanMtmName(mtm, srcLoc, destLoc );
d915 1
a915 1
void ESO2problem::setMtmInterplantMoveCost(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveCost )
d917 1
a917 1
  std::string name = acquireMtmName(mtm, srcLoc, destLoc );
d922 1
a922 1
void ESO2problem::setMtmInterplantMoveTime(const std::string & mtm, const std::string & srcLoc, const std::string & destLoc, int period, float moveTime )
d924 1
a924 1
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc); 
d954 1
a954 1
std::vector<float> ESO2problem::getMtmInterplantMoveCost(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
d956 1
a956 1
  std::string name = acquireMtmName(mtm, srcLoc, destLoc );
d961 1
a961 1
std::vector<float> ESO2problem::getMtmInterplantMoveTime(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
d964 1
a964 1
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc);
d968 1
a968 1
std::vector<float> ESO2problem::getMtmInterplantMoveVol(const std::string & mtm,const std::string & srcLoc, const std::string & destLoc )const
d971 1
a971 1
  std::string opName = acquireMtmName(mtm,srcLoc,destLoc);
d979 1
a979 1
void ESO2problem::addPartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc )
d997 1
a997 1
void ESO2problem::removePartOrFeatureLoc(const std::string & partOrFeatureName, const std::string & loc )
d1017 1
a1017 1
std::vector<std::string> ESO2problem::getPartLocs(const std::string & partName ) const
d1019 1
a1019 1
  std::vector<std::string> retVal;
d1038 1
a1038 1
void ESO2problem::addMtmAcquireLoc(const std::string & mtmName, std::string mtmAcquireLoc )
d1040 1
d1049 1
d1059 3
d1064 1
a1064 1
bool ESO2problem::mtmAcquireLocExists(const std::string & mtmName, const std::string & mtmAcquireLoc ) const
d1077 1
a1077 1
bool ESO2problem::mtmAcquireExists(const std::string & mtmName ) const
d1088 1
a1088 1
const std::set<std::string> & ESO2problem::getMtmAcquireLocs(const std::string & mtmName)const
d1104 1
a1104 1
void ESO2problem::addFeature(const std::string & featureName, const std::string & featureLoc )
d1106 3
a1108 3
  std::string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
  std::string acquireFeatureWitName = acquireFeatureName(featureName, featureLoc );
  std::string serverFeatureWitName = partName(featureName, featureLoc );
d1121 2
a1122 2
  std::string serverOwnedFeatureName = partName(featureName, featureLoc );
  std::string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1130 1
a1130 1
  std::string moveableServerOwnedFeatureName = moveablePartName(featureName, featureLoc );
d1146 1
a1146 1
  std::string baseName = baseFeatureName(featureName, featureLoc );
d1149 1
a1149 1
bool ESO2problem::featureExists(const std::string & featureName, const std::string & featureLoc )const
d1151 1
a1151 1
  std::string igfFeatureWitName = igfFeatureName(featureName, featureLoc );
d1158 1
a1158 1
void ESO2problem::setFeatureSupply(const std::string & featureName, const std::string & featureLoc, int period, float supply )
d1160 1
a1160 1
  std::string name = igfFeatureName(featureName, featureLoc );
d1163 1
a1163 1
void ESO2problem::setFeatureWfmv(const std::string & featureName, const std::string & featureLoc, int period, float wholeSaleFairMarketValue )
d1165 1
a1165 1
  std::string name = acquireFeatureName(featureName, featureLoc );
d1173 2
a1174 2
    std::vector<std::string> & features,
    std::vector<std::string> & featureLocs ) const
d1186 1
a1186 1
  std::set<std::string>::const_iterator it;
d1195 2
a1196 2
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
d1199 1
a1199 1
  std::string opName = acquireFeatureName(featureName,featureLoc);
d1204 2
a1205 2
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
d1208 1
a1208 1
  std::string name = igfFeatureName(featureName,featureLoc);
d1214 2
a1215 2
                                                 const std::string & featureName, 
                                                 const std::string & featureLoc )const
d1217 1
a1217 1
  std::string name = acquireFeatureName(featureName,featureLoc);
d1233 1
a1233 1
void ESO2problem::addLoosePart(const std::string & loosePartName, const std::string & loosePartLoc )
d1235 3
a1237 3
  std::string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
  std::string acquireLoosePartWitName = acquireLoosePartName(loosePartName, loosePartLoc );
  std::string serverLoosePartWitName = moveablePartName(loosePartName, loosePartLoc );
d1266 1
a1266 1
  std::string baseName = baseLoosePartName(loosePartName, loosePartLoc );
d1269 1
a1269 1
bool ESO2problem::loosePartExists(const std::string & loosePartName, const std::string & loosePartLoc )const
d1271 1
a1271 1
  std::string igfLoosePartWitName = igfLoosePartName(loosePartName, loosePartLoc );
d1278 1
a1278 1
void ESO2problem::setLoosePartSupply(const std::string & loosePartName, const std::string & loosePartLoc, int period, float supply )
d1280 1
a1280 1
  std::string name = igfLoosePartName(loosePartName, loosePartLoc );
d1283 1
a1283 1
void ESO2problem::setLoosePartWfmv(const std::string & loosePartName, const std::string & loosePartLoc, int period, float wholeSaleFairMarketValue )
d1285 1
a1285 1
  std::string name = acquireLoosePartName(loosePartName, loosePartLoc );
d1293 2
a1294 2
    std::vector<std::string> & looseParts,
    std::vector<std::string> & loosePartLocs ) const
d1306 1
a1306 1
  std::set<std::string>::const_iterator it;
d1315 2
a1316 2
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
d1319 1
a1319 1
  std::string opName = acquireLoosePartName(loosePartName,loosePartLoc);
d1324 2
a1325 2
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
d1328 1
a1328 1
  std::string name = igfLoosePartName(loosePartName,loosePartLoc);
d1333 2
a1334 2
                                                 const std::string & loosePartName, 
                                                 const std::string & loosePartLoc )const
d1336 1
a1336 1
  std::string name = acquireLoosePartName(loosePartName,loosePartLoc);
d1344 1
a1344 1
void ESO2problem::addPartWithOutApplyingInterplants(const std::string & part, const std::string & partLoc )
d1346 2
a1347 2
  std::string witName = partName(part, partLoc );
  std::string moveAbleWitName = moveablePartName(part, partLoc );
d1358 1
a1358 1
void ESO2problem::addPart(const std::string & part, const std::string & partLoc )
d1360 2
a1361 2
  std::string witName = partName(part, partLoc );
  std::string moveAbleWitName = moveablePartName(part, partLoc );
d1371 1
a1371 1
    const std::string & destLoc = interPlantVec[l].getDestLoc();
d1391 1
a1391 1
bool ESO2problem::partExists(const std::string & name, const std::string & loc )const
d1393 1
a1393 1
  std::string witName = partName(name, loc );
d1404 1
a1404 1
bool ESO2problem::demanBomExists(const std::string & mtm, const std::string & part, const std::string & loc )const
d1413 1
a1413 1
void ESO2problem::addDemanBom(const std::string & mtm, const std::string & part, const std::string & loc )
d1430 2
a1431 2
  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );
d1447 1
a1447 1
  std::string mtmBName = baseMtmName(mtm,loc);
d1453 1
a1453 1
    const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1456 1
a1456 1
    std::set<std::string>::const_iterator locIt;
d1458 1
a1458 1
      const std::string & destLoc = *locIt;
d1473 1
a1473 1
      std::string producedPart = moveablePartName(part, destLoc );
d1493 1
a1493 1
std::vector<std::string> ESO2problem::getDemanBoms(const std::string & mtm, const std::string & mtmSrcLoc, const std::string & demanLoc)const
d1495 2
a1496 2
  std::vector<std::string> retVal;
  std::string demanOp = demanMtmName(mtm, mtmSrcLoc, demanLoc );
d1511 3
a1513 3
          const std::string & mtm, 
          const std::string & part, 
          const std::string & loc, 
d1519 2
a1520 2
  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );
d1535 1
a1535 1
  std::string mtmBName = baseMtmName(mtm,loc);
d1541 1
a1541 1
    const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1544 1
a1544 1
    std::set<std::string>::const_iterator locIt;
d1546 1
a1546 1
      const std::string & destLoc = *locIt;
d1563 3
a1565 3
          const std::string & mtm, 
          const std::string & part, 
          const std::string & loc ) const
d1567 2
a1568 2
  std::string producedPart = moveablePartName(part, loc );
  std::string demanOp = demanMtmName(mtm, loc, loc );
d1581 3
a1583 3
                                const std::string & mtm, 
                                const std::string & part, 
                                const std::string & loc ) const
d1586 2
a1587 2
  std::string producedPart = moveablePartName(part, loc );
  std::string producingOp = demanMtmName(mtm, loc, loc );
d1595 2
a1596 2
                                const std::string & opName, 
                                const std::string & partName
d1624 3
a1626 3
                                  const std::string & part, 
                                  const std::string & feature, 
                                  const std::string & loc )const
d1628 1
a1628 1
  std::string xrefName = featureXrefName(part,feature,loc);
d1636 3
a1638 3
                               const std::string & part, 
                               const std::string & feature, 
                               const std::string & loc )
d1643 3
a1645 3
  std::string xrefName = featureXrefName(part,feature,loc);  
  std::string refPartName = moveablePartName(part,loc); 
  std::string featureName = partName(feature,loc);
d1678 3
a1680 3
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
d1685 1
a1685 1
  std::string xrefName = featureXrefName(part,feature,loc);
d1693 2
a1694 2
  std::string xrefOpName = featureXrefName(part,feature,loc );
  std::string acquireFeatureOpName = acquireFeatureName(feature,loc );
d1740 3
a1742 3
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
d1746 1
a1746 1
  std::string xrefOpName = featureXrefName(part,feature,loc);
d1755 3
a1757 3
          const std::string & part, 
          const std::string & feature, 
          const std::string & loc, 
d1761 1
a1761 1
  std::string xrefOpName = featureXrefName(part,feature,loc);
d1771 3
a1773 3
    std::vector<std::string> & parts,
    std::vector<std::string> & features,
    std::vector<std::string> & locs ) const
d1787 1
a1787 1
  std::set<std::string>::const_iterator it;
d1796 3
a1798 3
                                                 const std::string & part,
                                                 const std::string & feature, 
                                                 const std::string & loc )const
d1801 1
a1801 1
  std::string opName = featureXrefName(part,feature,loc);
d1807 3
a1809 3
                                                 const std::string & part,
                                                 const std::string & feature, 
                                                 const std::string & loc )const
d1812 1
a1812 1
  std::string opName = featureXrefName(part,feature,loc);
d1822 3
a1824 3
                                  const std::string & partOrFeature, 
                                  const std::string & altPart, 
                                  const std::string & loc )const
d1826 1
a1826 1
  std::string ecOpName = altName(partOrFeature,altPart,loc);
d1835 3
a1837 3
                               const std::string & partOrFeature, 
                               const std::string & altPart, 
                               const std::string & loc,
d1843 3
a1845 3
  std::string ecOpName = altName(partOrFeature,altPart,loc);  
  std::string upLevelPartName = moveablePartName(altPart,loc); 
  std::string downLevelPartName = partName(partOrFeature,loc);
d1877 3
a1879 3
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
d1883 2
a1884 2
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //std::string producedPart = partName(upLevelPart,loc);
d1893 3
a1895 3
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
d1899 1
a1899 1
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc);
d1907 3
a1909 3
          const std::string & upLevelPart, 
          const std::string & downLevelPart, 
          const std::string & loc, 
d1913 2
a1914 2
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc); 
  //std::string producedPart = partName(upLevelPart,loc);
d1925 3
a1927 3
    std::vector<std::string> & partOrFeatures,
    std::vector<std::string> & altParts,
    std::vector<std::string> & locs ) const
d1932 1
a1932 1
  std::set<std::string>::const_iterator it;
d1942 3
a1944 3
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
d1947 1
a1947 1
  std::string opName = altName(partOrFeature,altPart,loc);
d1953 3
a1955 3
                                                 const std::string & partOrFeature,
                                                 const std::string & altPart, 
                                                 const std::string & loc )const
d1958 1
a1958 1
  std::string opName = altName(partOrFeature,altPart,loc);
d1968 3
a1970 3
                                  const std::string & part, 
                                  const std::string & srcLoc, 
                                  const std::string & destLoc )const
d1972 1
a1972 1
  std::string opName = partInterplantName(part,srcLoc,destLoc);
d1981 2
a1982 2
                                     const std::string & srcLoc, 
                                     const std::string & destLoc, 
d1991 3
a1993 3
                               const std::string & part, 
                               const std::string & srcLoc, 
                               const std::string & destLoc, 
d1998 3
a2000 3
  std::string opName = partInterplantName(part,srcLoc,destLoc);  
  std::string srcPartName = moveablePartName(part,srcLoc); 
  std::string destPartName = partName(part,destLoc);
d2027 3
a2029 3
          const std::string & part, 
          const std::string & srcLoc, 
          const std::string & destLoc, 
d2033 1
a2033 1
  std::string opName = partInterplantName(part,srcLoc,destLoc);
d2041 3
a2043 3
          const std::string & part, 
          const std::string & srcLoc, 
          const std::string & destLoc, 
d2047 1
a2047 1
  std::string opName = partInterplantName(part,srcLoc,destLoc); 
d2056 3
a2058 3
                    std::vector<std::string> & parts, 
                    std::vector<std::string> & srcLocs, 
                    std::vector<std::string> &destLocs ) const
d2072 1
a2072 1
  std::set<std::string>::const_iterator it;
d2081 3
a2083 3
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
d2086 1
a2086 1
  std::string opName = partInterplantName(part,srcLoc,destLoc);
d2091 3
a2093 3
                                        const std::string & part,
                                        const std::string & srcLoc, 
                                        const std::string & destLoc )const
d2096 1
a2096 1
  std::string opName = partInterplantName(part,srcLoc,destLoc);
d2106 3
a2108 3
                                  const std::string & part, 
                                  const std::string & custLoc, 
                                  const std::string & plantLoc )const
d2112 2
a2113 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2125 1
a2125 1
  std::string dName = partDemandName(part,custLoc,plantLoc);
d2133 1
a2133 1
void ESO2problem::reportPart(const std::string & witPartName, 
d2142 1
a2142 1
  std::string indent="";
d2249 3
a2251 3
void ESO2problem::reportPartDemand(const std::string & part, 
                      const std::string & custLoc, 
                      const std::string & plantLoc, 
d2254 3
a2256 3
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2285 7
a2291 7
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc )
{
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string regulatorName = partDemandRegulatorName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2313 3
a2315 3
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc,
d2319 2
a2320 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string rName = partDemandRegulatorName(part,custLoc,plantLoc);
d2330 3
a2332 3
                               const std::string & part, 
                               const std::string & custLoc, 
                               const std::string & plantLoc,
d2336 2
a2337 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2345 3
a2347 3
                                 std::vector<std::string> & parts, 
                                 std::vector<std::string> & custLocs, 
                                 std::vector<std::string> &plantLocs ) const
d2361 1
a2361 1
  std::set<std::string>::const_iterator it;
d2370 3
a2372 3
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
d2375 2
a2376 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2381 3
a2383 3
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
d2386 2
a2387 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2392 3
a2394 3
                                                     const std::string & part,
                                                     const std::string & custLoc, 
                                                     const std::string & plantLoc )const
d2397 2
a2398 2
  std::string dName = partDemandName(part,custLoc,plantLoc);
  std::string pName = partName(part,plantLoc);
d2423 1
a2423 1
  std::set<std::string> activeParts;
d2447 1
a2447 1
          std::string activePart(belowList[b]);
d2460 3
a2462 3
    std::vector<std::string> parts;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d2466 4
a2469 4
      std::string pName = partName(parts[p],destLocs[p]);
      std::string mpName = moveablePartName(parts[p],destLocs[p]);
      std::string opName = partInterplantName(parts[p],srcLocs[p],destLocs[p]);
      //std::string srcPName = partName(parts[p],destLocs[p]);
d2492 3
a2494 3
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> locs;
d2498 3
a2500 3
      std::string pName = partName(parts[p],locs[p]);
      std::string mpName = moveablePartName(parts[p],locs[p]);
      std::string opName = featureXrefName(parts[p],features[p],locs[p]);
d2523 2
a2524 2
    std::vector<std::string> parts;
    std::vector<std::string> locs;
d2528 5
a2532 5
      std::string pName = partName(parts[p],locs[p]);
      std::string mpName = moveablePartName(parts[p],locs[p]);
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
      std::string igfPName = igfLoosePartName(parts[p],locs[p]);
      std::string baseName = baseLoosePartName(parts[p],locs[p]);
d2558 2
a2559 2
    std::vector<std::string> features;
    std::vector<std::string> locs;
d2563 5
a2567 5
      std::string pName = partName(features[p],locs[p]);
      std::string mpName = moveablePartName(features[p],locs[p]);
      std::string opName = acquireFeatureName(features[p],locs[p]);
      std::string igfFName = igfFeatureName(features[p],locs[p]);
      std::string baseName = baseFeatureName(features[p],locs[p]);
d2594 3
a2596 3
    std::vector<std::string> partOrFeatures;
    std::vector<std::string> altParts;
    std::vector<std::string> locs;
d2601 10
a2610 10
      std::string ecOpName = altName(partOrFeatures[p],altParts[p],locs[p]);   
      std::string upLevelPartName = partName(altParts[p],locs[p]); 
      std::string moveableUpLevelPartName = moveablePartName(altParts[p],locs[p]); 
      std::string downLevelPartName = partName(partOrFeatures[p],locs[p]);

      //std::string pName = partName(altParts[p],locs[p]);
      //std::string mpName = moveablePartName(altParts[p],locs[p]);
      //std::string opName = acquireFeatureName(features[p],locs[p]);
      //std::string igfFName = igfFeatureName(features[p],locs[p]);
      //std::string baseName = baseFeatureName(features[p],locs[p]);
d2634 3
a2636 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d2641 5
a2645 5
      std::string igfPName = igfMtmName(mtms[p],srcLocs[p] );
      std::string acquireOpName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string serverPName = serverMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
      std::string baseName = baseMtmName(mtms[p],srcLocs[p] );
d2766 1
a2766 1
                                const std::string opName,
d2796 1
a2796 1
  std::vector<std::string> mtms,srcLocs,demanLocs;
d2800 1
a2800 1
    std::vector<std::string> prodParts = getDemanBoms(mtms[msdTriple],srcLocs[msdTriple],demanLocs[msdTriple]);
d2803 2
a2804 2
      std::string pName = partName(prodParts[pp], demanLocs[msdTriple] );
      std::string moveablePName = moveablePartName(prodParts[pp], demanLocs[msdTriple] );
d2823 2
a2824 2
      std::vector<std::string> mtms;
      std::vector<std::string> plantLocs;
d2831 2
a2832 2
        std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );         
        std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
d2859 1
a2859 1
          const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d2862 1
a2862 1
          std::set<std::string>::const_iterator locIt;
d2864 1
a2864 1
            const std::string & destLoc = *locIt;
d2867 1
a2867 1
            std::string acquireMtmWitName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
d2884 1
a2884 1
            std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
d2899 2
a2900 2
      std::vector<std::string> features;
      std::vector<std::string> featureLocs;
d2907 2
a2908 2
        std::string featureName = baseFeatureName(features[f],featureLocs[f] );         
        std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );
d2938 2
a2939 2
      std::vector<std::string> looseParts;
      std::vector<std::string> loosePartLocs;
d2946 2
a2947 2
        std::string loosePartName = baseLoosePartName(looseParts[l],loosePartLocs[l] );         
        std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );
d2982 2
a2983 2
      std::vector<std::string> mtms;
      std::vector<std::string> plantLocs;
d2989 2
a2990 2
        std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );    
        std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );
d3002 1
a3002 1
          const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
d3004 1
a3004 1
          std::set<std::string>::const_iterator locIt;
d3006 2
a3007 2
            const std::string & destLoc = *locIt;
            std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );       
d3022 2
a3023 2
      std::vector<std::string> features;
      std::vector<std::string> featureLocs;
d3029 1
a3029 1
        std::string acquireOpName = acquireFeatureName(features[f],featureLocs[f] );        
d3043 2
a3044 2
      std::vector<std::string> looseParts;
      std::vector<std::string> loosePartLocs;
d3050 1
a3050 1
        std::string acquireOpName = acquireLoosePartName(looseParts[l],loosePartLocs[l] );  
d3066 1
a3066 1
      std::string witDataFileName = std::string("implode")+std::string(asChar)+".wit";
d3083 1
a3083 1
std::string ESO2problem::igfMtmName(const std::string & mtm,const std::string & mtmLoc )
d3087 1
a3087 1
std::string ESO2problem::acquireMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc )
d3091 1
a3091 1
std::string ESO2problem::serverMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc )
d3095 1
a3095 1
std::string ESO2problem::demanMtmName(const std::string & mtm,const std::string & mtmLoc,const std::string & destLoc )
d3099 1
a3099 1
std::string ESO2problem::baseMtmName(const std::string & mtm,const std::string & mtmLoc )
d3103 1
a3103 1
std::string ESO2problem::mtmFromMtmName(const std::string & mtmName)
d3107 1
a3107 1
std::string ESO2problem::mtmLocFromMtmName(const std::string & mtmName)
d3115 1
a3115 1
std::string ESO2problem::igfFeatureName(const std::string & feature,const std::string & loc )
d3119 1
a3119 1
std::string ESO2problem::acquireFeatureName(const std::string & feature,const std::string & loc )
d3123 1
a3123 1
std::string ESO2problem::baseFeatureName(const std::string & feature,const std::string & loc )
d3127 1
a3127 1
std::string ESO2problem::featureFromFeatureName(const std::string & featureName)
d3131 1
a3131 1
std::string ESO2problem::locFromFeatureName(const std::string & featureName)
d3139 1
a3139 1
std::string ESO2problem::igfLoosePartName(const std::string & loosePart,const std::string & loc )
d3143 1
a3143 1
std::string ESO2problem::acquireLoosePartName(const std::string & loosePart,const std::string & loc )
d3147 1
a3147 1
std::string ESO2problem::baseLoosePartName(const std::string & loosePart,const std::string & loc )
d3151 1
a3151 1
std::string ESO2problem::loosePartFromLoosePartName(const std::string & loosePartName)
d3155 1
a3155 1
std::string ESO2problem::locFromLoosePartName(const std::string & loosePartName)
d3164 1
a3164 1
std::string ESO2problem::featureXrefName(const std::string & part, const std::string & feature, const std::string & loc)
d3168 1
a3168 1
std::string ESO2problem::partFromFeatureXrefName(const std::string & featXrefName)
d3172 1
a3172 1
std::string ESO2problem::featureFromFeatureXrefName(const std::string & featXrefName)
d3176 1
a3176 1
std::string ESO2problem::locFromFeatureXrefName(const std::string & featXrefName)
d3184 1
a3184 1
std::string ESO2problem::altName(const std::string & partOrFeature, const std::string & altPart, const std::string & loc)
d3188 1
a3188 1
std::string ESO2problem::partFromAltName(const std::string & altName)
d3192 1
a3192 1
std::string ESO2problem::altPartFromAltName(const std::string & altName)
d3196 1
a3196 1
std::string ESO2problem::locFromAltName(const std::string & altName)
d3204 1
a3204 1
std::string ESO2problem::partInterplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc)
d3208 1
a3208 1
std::string ESO2problem::partFromPartInterplantName(const std::string & partInterplantName)
d3212 1
a3212 1
std::string ESO2problem::srcLocFromPartInterplantName(const std::string & partInterplantName)
d3216 1
a3216 1
std::string ESO2problem::destLocFromPartInterplantName(const std::string & partInterplantName)
d3223 1
a3223 1
std::string ESO2problem::partDemandName(const std::string & part, const std::string & custLoc, const std::string & plantLoc)
d3227 1
a3227 1
std::string ESO2problem::partDemandRegulatorName(const std::string & part, const std::string & custLoc, const std::string & plantLoc)
d3231 1
a3231 1
std::string ESO2problem::partFromPartDemandName(const std::string & partDemandName)
d3235 1
a3235 1
std::string ESO2problem::custLocFromPartDemandName(const std::string & partDemandName)
d3239 1
a3239 1
std::string ESO2problem::plantLocFromPartDemandName(const std::string & partDemandName)
d3248 1
a3248 1
std::string ESO2problem::partName(const std::string & part,const std::string & loc )
d3253 1
a3253 1
std::string ESO2problem::moveablePartName(const std::string & part,const std::string & loc )
d3258 1
a3258 1
std::string ESO2problem::partFromPartName( const std::string & partName )
d3266 4
a3269 4
std::string ESO2problem::textBetween(
                        const std::string & src, 
                        const std::string & begMark,
                        const std::string & endMark)
d3272 1
a3272 1
  assert( begPos != std::string::npos );
d3276 1
a3276 1
  assert( endPos != std::string::npos );
d3279 1
a3279 1
  std::string retVal = src.substr(begPos,len);
d3282 3
a3284 3
std::string ESO2problem::textAfter(
                        const std::string & src, 
                        const std::string & begMark)
d3287 1
a3287 1
  assert( begPos != std::string::npos );
d3293 1
a3293 1
  std::string retVal = src.substr(begPos,len);
d3297 2
a3298 2
                        const std::string & src, 
                        const std::string & begString)
d3314 1
a3314 1
    const std::string & name,
d3330 1
a3330 1
    const std::string & name,
d3341 1
a3341 1
    const std::string & name,
d3352 1
a3352 1
    const std::string & name,
d3368 1
a3368 1
    const std::string & name,
d3391 1
a3391 1
    const std::string & opName,
d3410 1
a3410 1
    const std::string & opName,
d3424 2
a3425 2
    const std::string & partName,
    const std::string & demandName,
d3441 1
a3441 1
    const std::string & name ) const
d3453 1
a3453 1
                                     const std::string & opName,
d3466 1
a3466 1
                                     const std::string & opName,
d3481 1
a3481 1
                                     const std::string & opName,
d3494 1
a3494 1
                                     const std::string & opName,
d3507 1
a3507 1
                                     const std::string & opName,
d3519 1
a3519 1
    const std::string & opName,
d3540 2
a3541 2
    const std::string & partName,
    const std::string & demandName )const
d3559 1
a3559 1
    std::vector<std::string> & resourceDescriptions,
d3567 1
a3567 1
  std::vector<std::string> projects;
d3601 1
a3601 1
void ESO2problem::setTitle( const std::string & title)
d3606 1
a3606 1
std::string ESO2problem::getTitle() const
d3610 1
a3610 1
  std::string retVal(t);
d3636 3
a3638 3
    std::vector<std::string> parts;
    std::vector<std::string> features;
    std::vector<std::string> locs;
d3642 1
a3642 1
    std::string witOpName = featureXrefName(parts[i],features[i],locs[i]);
d3658 3
a3660 3
    std::vector<std::string> upLevelParts;
    std::vector<std::string> downLevelParts;
    std::vector<std::string> plantLocs;
d3664 1
a3664 1
    std::string witOpName = alternatePartName(upLevelParts[i],downLevelParts[i],plantLocs[i]);
d3680 3
a3682 3
  std::vector<std::string> parts;
  std::vector<std::string> srcLocs;
  std::vector<std::string> destLocs;
d3686 1
a3686 1
    std::string witMoveOpName = partInterplantName(parts[i],srcLocs[i],destLocs[i]);
d3701 3
a3703 3
  std::vector<std::string> parts;
  std::vector<std::string> custLocs;
  std::vector<std::string> plantLocs;
d3707 1
a3707 1
    std::string witDemandName = partDemandName(parts[i],custLocs[i],plantLocs[i]);
d3726 2
a3727 2
  std::vector<std::string> features;
  std::vector<std::string> plantLocs;
d3732 2
a3733 2
    std::string witAcquireOpName = acquireFeatureName(features[i],plantLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
d3748 2
a3749 2
  std::vector<std::string> looseParts;
  std::vector<std::string> plantLocs;
d3754 2
a3755 2
    std::string witAcquireOpName = acquireLoosePartName(looseParts[i],plantLocs[i]);
    //std::string witPartName = igfLoosePartName(looseParts[i],plantLocs[i]);
d3778 3
a3780 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d3785 2
a3786 2
    std::string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
d3808 3
a3810 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d3815 1
a3815 1
    std::string witAcquireOpName = acquireMtmName(mtms[i],srcLocs[i],destLocs[i]);
d3830 3
a3832 3
  std::vector<std::string> mtms;
  std::vector<std::string> srcLocs;
  std::vector<std::string> destLocs;
d3837 2
a3838 2
    std::string witAcquireOpName = demanMtmName(mtms[i],srcLocs[i],destLocs[i]);
    //std::string witPartName = igfFeatureName(features[i],plantLocs[i]);
d3867 2
a3868 2
    std::vector<std::string> mtms;
    std::vector<std::string> locs;
d3889 3
a3891 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d3934 2
a3935 2
  std::vector<std::string> features;
  std::vector<std::string> plantLocs;
d3976 2
a3977 2
  std::vector<std::string> looseParts;
  std::vector<std::string> plantLocs;
d4019 3
a4021 3
  std::vector<std::string> parts;
  std::vector<std::string> custLocs;
  std::vector<std::string> plantLocs;
d4050 1
a4050 1
void ESO2problem::setOslMesgFileName(const std::string & name)
d4110 1
a4110 1
void ESO2problem::writeWitData( std::string filename ) const
d4286 2
a4287 2
    std::vector<std::string> parts;
    std::vector<std::string> locs;
d4293 1
a4293 1
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
d4302 2
a4303 2
    std::vector<std::string> features;
    std::vector<std::string> locs;
d4309 1
a4309 1
      std::string opName = acquireFeatureName(features[p],locs[p]);
d4318 3
a4320 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d4326 1
a4326 1
      std::string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4333 1
a4333 1
        std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4366 2
a4367 2
    std::vector<std::string> parts;
    std::vector<std::string> locs;
d4372 1
a4372 1
      std::string opName = acquireLoosePartName(parts[p],locs[p]);
d4380 2
a4381 2
    std::vector<std::string> features;
    std::vector<std::string> locs;
d4386 1
a4386 1
      std::string opName = acquireFeatureName(features[p],locs[p]);
d4394 3
a4396 3
    std::vector<std::string> mtms;
    std::vector<std::string> srcLocs;
    std::vector<std::string> destLocs;
d4401 1
a4401 1
      std::string opName = acquireMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4407 1
a4407 1
        std::string demanOpName = demanMtmName(mtms[p],srcLocs[p],destLocs[p] );
d4491 1
a4491 1
      std::string demanMtmWitName = demanMtmName("m1","loc1","loc2" );
d4761 2
a4762 2
  std::string fileName = "unitTestResults.csv";
  ESO2unitTestResultsData file(fileName);
d4765 1
a4765 1
  std::vector<std::string> testCases;
d4805 1
a4805 1
        std::vector<std::string> parts = p.getParts();
d4825 1
a4825 1
          createModel(p1, testCases[tc], setPeriod1SupplyPerishabilityLimit );
d4876 1
a4876 1
                  std::string stdName(name);
@


1.69
log
@desparate change to try to fix things
@
text
@d867 1
a867 1
                                   const std::string & destLoc,
@


1.68
log
@Added code to covert from old file format to new
@
text
@d1038 1
a1038 1
void ESO2problem::addMtmAcquireLoc(const std::string & mtmName, const std::string & mtmAcquireLoc )
@


1.67
log
@Added code to write alt output file
@
text
@d3291 9
d4869 9
d4880 1
a4880 1

@


1.66
log
@Added code for setting alts
@
text
@d1935 4
a1938 4
#if 0
std::vector<float> ESO2problem::getAlternatePartEcVol(
                                                 const std::string & upLevelPart,
                                                 const std::string & downLevelPart, 
d1942 1
a1942 1
  std::string opName = alternatePartName(upLevelPart,downLevelPart,loc);
d1947 3
a1949 3
std::vector<float> ESO2problem::getAlternatePartCost(
                                                 const std::string & upLevelPart,
                                                 const std::string & downLevelPart, 
d1953 1
a1953 1
  std::string opName = alternatePartName(upLevelPart,downLevelPart,loc);
d1957 1
a1957 1
#endif
@


1.65
log
@Modified so there there is a scrap cost on all parts (except for parts created from demanufacturing).
This is an attempt to ensure all acquired parts are consumed.
@
text
@d976 61
d1349 3
a1812 1
#if 0
d1816 3
a1818 3
bool ESO2problem::alternatePartExists(
                                  const std::string & upLevelPart, 
                                  const std::string & downLevelPart, 
d1821 1
a1821 1
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc);
d1828 13
a1840 10
void ESO2problem::addAlternatePart(
                               const std::string & upLevelPart, 
                               const std::string & downLevelPart, 
                               const std::string & loc )
{
  assert( !alternatePartExists(upLevelPart,downLevelPart,loc) );
  assert(  partExists(downLevelPart,loc) );
  std::string ecOpName = alternatePartName(upLevelPart,downLevelPart,loc);  
  std::string upLevelPartName = moveablePartName(upLevelPart,loc); 
  std::string downLevelPartName = partName(downLevelPart,loc);
d1846 4
d1851 2
a1852 3
  // if produced part does not exist, then add it to model
  if ( !partExists(upLevelPart,loc) ) {
    addPart(upLevelPart,loc);
d1859 1
a1859 1
  float * cost = floatToConstFloatStar(bigM());
d1867 1
a1867 1
  alternateParts_.insert(ecOpName);
d1869 2
a1870 1
  
d1917 1
d1919 3
a1921 3
void ESO2problem::getAlternateParts(
    std::vector<std::string> & upLevelParts,
    std::vector<std::string> & downLevelParts,
d1924 2
a1925 2
  upLevelParts.clear();
  downLevelParts.clear();
a1926 9
#if 0
  int nItems = alternateParts_.size();
  int n;
  for ( n=0; n<nItems; n++ ) {
    upLevelParts.push_back( upLevelPartFromAlternatePartName(alternateParts_[n]) );
    downLevelParts.push_back( downLevelPartFromAlternatePartName(alternateParts_[n]) );
    locs.push_back( locFromAlternatePartName(alternateParts_[n]) );
  }
#else
d1928 4
a1931 4
  for ( it=alternateParts_.begin(); it!=alternateParts_.end(); ++it ) {
    upLevelParts.push_back( upLevelPartFromAlternatePartName(*it) );
    downLevelParts.push_back( downLevelPartFromAlternatePartName(*it) );
    locs.push_back( locFromAlternatePartName(*it) );
a1932 1
#endif
d1935 1
d2479 2
d2510 2
d2545 2
d2580 43
d3056 1
d3064 1
a3175 1
#if 0
d3179 1
a3179 1
std::string ESO2problem::alternatePartName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc)
d3181 1
a3181 1
  return "ec: "+downLevelPart+" to "+upLevelPart+" at "+loc;
d3183 1
a3183 1
std::string ESO2problem::downLevelPartFromAlternatePartName(const std::string & alternatePartName)
d3185 1
a3185 1
  return textBetween(alternatePartName,"ec: "," to ");
d3187 1
a3187 1
std::string ESO2problem::upLevelPartFromAlternatePartName(const std::string & alternatePartName)
d3189 1
a3189 1
  return textBetween(alternatePartName," to "," at ");
d3191 1
a3191 1
std::string ESO2problem::locFromAlternatePartName(const std::string & alternatePartName)
d3193 1
a3193 1
  return textAfter(alternatePartName," at ");
a3194 1
#endif
d4120 1
d4201 1
a4201 1
//alternateParts_(),
d4206 1
d4248 1
a4248 1
  //alternateParts_  = source.alternateParts_;
d4253 1
d4785 10
@


1.64
log
@Added bigM method to eso2Problem and updated code to use this constant
@
text
@d28 265
d575 10
d608 1
a608 1
  witAddPart(witRun(), serverMtmWitName.c_str(), WitCAPACITY);
d892 1
a892 1
  witAddPart(witRun(), serverMtmWitName.c_str(), WitCAPACITY);
d1283 2
a1284 2
  witAddPart(witRun(), witName.c_str(), WitCAPACITY);
  witAddPart(witRun(), moveAbleWitName.c_str(), WitCAPACITY);
d1353 6
d1395 6
d1424 17
d2122 2
d2134 1
d2227 1
a2227 1
  witAddPart(witRun(),dName.c_str(),WitCAPACITY);
d2239 1
a2239 1
  witAddPart(witRun(),regulatorName.c_str(),WitCAPACITY);
d2676 19
d2957 1
d3142 5
d3213 11
d3240 19
d4672 2
a4673 1
      //if ( tc != 5 ) continue;
d4692 2
d4714 37
a4750 1
            assert( p1Obj==p3Obj );
d4848 1
a4848 1
              assert(p1Obj == historicObjValue);
@


1.63
log
@Added code to write wit data files before each implode call
@
text
@d631 1
a631 1
  std::vector<float> demanCost=floatToStlVec(10000.0f);
d795 1
a795 1
  float * acquireCost = floatToConstFloatStar(1000000.f);
d915 1
a915 1
  float * acquireCost = floatToConstFloatStar(1000000.f);
d1287 1
a1287 1
  float * cost = floatToConstFloatStar(1000000.f);
d1297 1
a1297 1
  float * usageTime = floatToConstFloatStar(1000000.f);
d1486 1
a1486 1
  float * cost = floatToConstFloatStar(1000000.f);
d2432 1
a2432 1
                scaledWfmvWithMoveCostVec[p] = 100000.f;
@


1.62
log
@changes to have demanCost and demanTime be from deman location, rather supply loc and time
@
text
@d2619 8
d2629 1
d3631 1
d3637 1
d3721 1
d3767 1
d3957 2
d4011 1
@


1.61
log
@changes to have demanCost and demanTime be from deman location, rather supply loc and time
@
text
@d4250 1
a4250 1
#define WRITE_RESULTS
@


1.60
log
@Modified to implement featureXref
@
text
@d402 10
d420 9
d446 20
d631 1
a631 1
  std::vector<float> demanCost=getMtmDemanCost(mtm,srcLoc);
d634 1
a634 1
  std::vector<float> demanTime=getMtmDemanTime(mtm,srcLoc );
d3965 11
d3982 2
a3983 2
    prob.setPartDemandDemandVol("p1","US","loc2",4,1.0f);
    prob.setPartDemandWac("p1","US","loc2",4,10.0f);
d3996 1
a3996 1
    prob.reportPartDemand("p1","US","loc2",4);
d4001 2
a4002 2
    assert(sv[3]==0.0f);
    assert(sv[4]==1.0f);
d4175 10
d4250 1
a4250 1
//#define WRITE_RESULTS
@


1.59
log
@Added some diagnostics
@
text
@d217 1
a217 1
    } // end of p loop
d272 1
a272 1
  // Test Kevin's claims about mtmSupply
d1209 199
d1552 1
d2075 1
a2075 1
  // Remove inactive alternateParts
d2077 2
a2078 2
    std::vector<std::string> upLevelParts;
    std::vector<std::string> downLevelParts;
d2080 1
a2080 1
    getAlternateParts( upLevelParts, downLevelParts, locs);
d2082 4
a2085 4
    for (p=0; p<upLevelParts.size(); ++p ) {
      std::string pName = partName(upLevelParts[p],locs[p]);
      std::string mpName = moveablePartName(upLevelParts[p],locs[p]);
      std::string opName = alternatePartName(upLevelParts[p],downLevelParts[p],locs[p]);
d2099 1
a2099 1
        alternateParts_.erase(opName);
d2669 21
d2708 1
d3097 22
a3118 1

d3140 1
d3394 1
a3394 1
  sumXrefCost = sumOfAlternatePartCost();
d3592 1
a3592 1
alternateParts_(),
d3652 2
a3653 2
  witSetAccAfterOptImp(witRun(),WitTRUE );
  witSetAccAfterSoftLB(witRun(),WitTRUE );
d3675 2
a3676 1
alternateParts_(),
d3720 2
a3721 1
  alternateParts_  = source.alternateParts_;
d4014 13
a4026 13
    prob.addAlternatePart("p1","f1","loc1");
    prob.setAlternatePartCost("p1","f1","loc1",0,0);
    prob.setAlternatePartCost("p1","f1","loc1",1,0);
    prob.setAlternatePartCost("p1","f1","loc1",2,0);
    prob.setAlternatePartCost("p1","f1","loc1",3,0);
    prob.setAlternatePartProdRate("p1","f1","loc1",0,1.0f);
    prob.setAlternatePartProdRate("p1","f1","loc1",1,1.0f);
    prob.setAlternatePartProdRate("p1","f1","loc1",2,1.0f);
    prob.setAlternatePartProdRate("p1","f1","loc1",3,1.0f);
    prob.setAlternatePartUsageTime("p1","f1","loc1",0,0.0f);
    prob.setAlternatePartUsageTime("p1","f1","loc1",1,0.0f);
    prob.setAlternatePartUsageTime("p1","f1","loc1",2,0.0f);
    prob.setAlternatePartUsageTime("p1","f1","loc1",3,0.0f);
d4232 4
a4235 1
    for ( tc=0; tc<testCases.size(); ++tc ) {    
d4285 1
a4285 1
              double alternatePartCost=p3.sumOfAlternatePartCost();
d4293 1
a4293 1
                alternatePartCost);
@


1.58
log
@Fix to mtm metric calculations
@
text
@d3131 2
a3132 1
        if( acquireQty[t] > 0.0 ) nonZero=true;
@


1.57
log
@Modified kpi's to be computed in double precision
\
@
text
@d3087 4
a3090 13
  std::vector<std::string> mtms;
  std::vector<std::string> srcLocs;
  std::vector<std::string> destLocs;
  getMtmDemanLocs(mtms,srcLocs,destLocs);
  
  totalWfmvWithScale = 0.0;
  numUnique = mtms.size();
  numUniqueAcquired =0;
  supplyQuantity =0;
  acquiredQuantity = 0;

  int i;
  for ( i=0; i<numUnique; ++i ) {
d3092 42
a3133 14
    //std::string witAcquireOpName = demanMtmName(mtms[i],srcLocs[i],destLocs[i]);
    std::vector<float> wfmv = getMtmWfmv(mtms[i],srcLocs[i]);
    std::vector<float> supplyQty = getMtmSupply(mtms[i],srcLocs[i]);
    std::vector<float> acquireQty = getMtmAcquireQty(mtms[i],srcLocs[i]);
    //std::vector<float> execVol = witGetNameAttribute(witGetOperationExecVol,witAcquireOpName);
    //std::vector<float> execCost = witGetNameAttribute(witGetOperationObj1ExecCost,witAcquireOpName);

    int t;
    bool nonZero = false;
    for ( t=0; t<np; ++t ) {
      totalWfmvWithScale += supplyQty[t]*wfmv[t]*scaleFactor;
      supplyQuantity += supplyQty[t];
      acquiredQuantity += acquireQty[t];
      if( acquireQty[t] > 0.0 ) nonZero=true;
a3134 1
    if (nonZero) numUniqueAcquired++;
@


1.56
log
@updated tolerances for eps
@
text
@d2865 1
a2865 1
float ESO2problem::getObjValue() const
d2867 1
d2871 2
a2872 1
  return objVal;
d2876 1
a2876 1
float ESO2problem::sumOfAlternatePartCost() const
d2878 1
a2878 1
  float retVal=0.0f;
d2897 1
a2897 1
float ESO2problem::sumOfPartMoveCost() const
d2899 1
a2899 1
  float retVal=0.0f;
d2918 1
a2918 1
float ESO2problem::sumOfWac() const
d2920 1
a2920 1
  float retVal=0.0f;
d2943 1
a2943 1
float ESO2problem::sumOfFeatureWfmvWithScaleFactor() const
d2945 1
a2945 1
  float retVal=0.0f;
d2965 1
a2965 1
float ESO2problem::sumOfLoosePartWfmvWithScaleFactor() const
d2967 1
a2967 1
  float retVal=0.0f;
d2995 1
a2995 1
float ESO2problem::sumOfMtmWfmvWithScaleFactorAndMoveCost() const
d2997 1
a2997 1
  float retVal=0.0f;
d3019 1
a3019 1
float ESO2problem::sumOfMtmWfmvWithScaleFactor() const
d3021 1
a3021 1
  float retVal=sumOfMtmWfmvWithScaleFactorAndMoveCost()-sumOfMtmMoveCost();
d3025 1
a3025 1
float ESO2problem::sumOfMtmMoveCost() const
d3027 1
a3027 1
  float retVal=0.0f;
d3047 1
a3047 1
float ESO2problem::sumOfDemanCost() const
d3049 1
a3049 1
  float retVal=0.0f;
d3071 4
a3074 4
                              float & totalWfmvWithScale,
                              float & sumAcquireCost,
                              float & sumMoveCost,
                              float & sumDemanCost,
d3077 2
a3078 2
                              float & supplyQuantity,
                              float & acquiredQuantity)
d3121 3
a3123 3
                              float & totalWfmvWithScale,
                              float & sumAcquireCost,
                              float & sumXrefCost,
d3126 2
a3127 2
                              float & supplyQuantity,
                              float & acquiredQuantity)
d3165 2
a3166 2
                              float & totalWfmvWithScale,
                              float & sumAcquireCost,
d3169 2
a3170 2
                              float & supplyQuantity,
                              float & acquiredQuantity)
d3209 2
a3210 2
                              float & sumDemandWac,
                              float & sumShippedWac,
d3213 2
a3214 2
                              float & sumDemandVol,
                              float & sumShipVol)
d4009 9
a4017 9
              float obj=p3.getObjValue();
              float wac=p3.sumOfWac();
              float featureWfmv=p3.sumOfFeatureWfmvWithScaleFactor();
              float loosePartWfmv=p3.sumOfLoosePartWfmvWithScaleFactor();
              float mtmWfmv=p3.sumOfMtmWfmvWithScaleFactor();
              float demanCost=p3.sumOfDemanCost();
              float mtmMoveCost=p3.sumOfMtmMoveCost();
              float partMoveCost=p3.sumOfPartMoveCost();
              float alternatePartCost=p3.sumOfAlternatePartCost();
d4028 4
a4031 4
              float mtmTotalWfmvWithScale;
              float mtmSumAcquireCost;
              float mtmSumMoveCost;
              float mtmSumDemanCost;
d4034 2
a4035 2
              float mtmSupplyQuantity;
              float mtmAcquiredQuantity;
d4047 3
a4049 3
              float featureTotalWfmvWithScale;
              float featureSumAcquireCost;
              float featureSumXrefCost;
d4052 2
a4053 2
              float featureSupplyQuantity;
              float featureAcquiredQuantity;
d4064 2
a4065 2
              float loosePartTotalWfmvWithScale;
              float loosePartSumAcquireCost;
d4068 2
a4069 2
              float loosePartSupplyQuantity;
              float loosePartAcquiredQuantity;
d4079 2
a4080 2
              float partDemandSumDemandWac;
              float partDemandSumShippedWac;
d4083 2
a4084 2
              float partDemandSumDemandVol;
              float partDemandSumShipVol;
@


1.55
log
@Added writing of kpi's
@
text
@d2109 1
a2109 1
  CoinRelFltEq eq(1.e-6);
@


1.54
log
@Changed espilon to make in bigger when testing execBounds
@
text
@d2873 376
d4004 89
@


1.53
log
@added code to ensure slb is less than hub
@
text
@d2109 1
a2109 1
  CoinRelFltEq eq;
@


1.52
log
@changes to improve performance
@
text
@d17 1
a17 1
//#include "OsiFloatEqual.h"
d2101 17
d2315 2
a2316 1
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub);            
d2332 2
a2333 1
            witSetNameBoundAttribute(witSetOperationExecBounds,acquireAndMoveOpName, zeroTv,execSlb,execHub);            
d2354 2
a2355 1
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub);            
d2375 2
a2376 1
        witSetNameBoundAttribute(witSetOperationExecBounds,acquireOpName, zeroTv,execSlb,execHub);           
@


1.51
log
@changed freq of setting attach rate msg
@
text
@a145 51
#if 0
  std::vector<std::string> mtmNames;
  std::vector<std::string> mtmLocs;
  getMtms(mtmNames,mtmLocs );
  
  // loop once for each mtm
  int m;
  for ( m=0; m<mtmLocs.size(); ++m ) {
    
    std::string baseDemanOpName = demanMtmName(mtmNames[m],mtmLocs[m],mtmLocs[m] );

    int nBops;
    witGetOperationNBopEntries(mutableWitRun(),baseDemanOpName.c_str(),&nBops);
    // loop once for each bop
    int b;
    for ( b=0; b<nBops; ++ b) {
      
      ESO2mtmDemanBomAppData * bopAppData; 
      witGetBopEntryAppData(mutableWitRun(),baseDemanOpName.c_str(),b,(void**)&bopAppData);
      std::vector<float> attachRate = bopAppData->getAttachRate();

      witSetArcAttribute(witSetBopEntryProductRate,baseDemanOpName,b,attachRate);
      
      // Are there any interplant moves for this mtm
      std::string mtmBName = baseMtmName(mtmNames[m],mtmLocs[m]);
      if ( mtmAcquireExists(mtmBName) ) {
        
        // MTM has move operations so set prodRate for each move to location
        
        // Get all locations that this mtm can be moved to
        const std::set<std::string> & moveToLocs = getMtmAcquireLocs(mtmBName);
        
        // Loop once for each location this mtm can be moved to
        std::set<std::string>::const_iterator locIt;
        for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
          const std::string & destLoc = *locIt;
          
          // set ProdRate
          std::string demanOp = demanMtmName(mtmNames[m],mtmLocs[m],destLoc);
          witSetArcAttribute(witSetBopEntryProductRate,demanOp, b, attachRate );
          
        } // end of locIt loop
        
      } // end of if (mtmAcquireExists(baseMtmName)) 
      
    } // end of for b
  } // end of for m
    


#else
d202 1
a202 10

#if 0
            // determine if deman in period p is consuming supply from period 0
            // via substitute bom
            bool useSubs = true;
            if ( p<subEarliestPer ) useSubs=false;
            if ( p>subLatestPer ) useSubs=false;
            if ( mtmSupply[0]==0.0f ) useSubs=false;
#endif

a211 1
 
a217 1
#endif
a256 41
#if 0
  int subEarliestPer;
  int subLatestPer;
  witGetSubsBomEntryEarliestPeriod(mutableWitRun(),moveAndAcquireOpName.c_str(),0,0,&subEarliestPer);
  witGetSubsBomEntryLatestPeriod(mutableWitRun(),moveAndAcquireOpName.c_str(),0,0,&subLatestPer);
  
  // get supply of mtm
  std::vector<float> mtmSupply = getMtmSupply(mtm,srcLoc);
  
  // Test Kevin's claims about mtmSupply
  bool ok=true;
  int badPer;
  int p;
  if ( mtmSupply[0]!= 0.0f ) {
    for ( p=1; p<mtmSupply.size(); ++p ) {
      if ( mtmSupply[p] != 0.0f ) {
        ok=false;
        badPer=p;
        break;
      }
    }
  }
  if ( !ok ) {
    std::cout 
      <<"-------------------------------------------------------"            <<std::endl
      <<"Warning: mtm supply in first period and another period is non-zero."<<std::endl
      <<"   mtm name: " <<mtm.c_str()                                    <<std::endl
      <<"   mtm source location: " <<srcLoc.c_str()                      <<std::endl
      <<"   mtm supply in first period: " <<mtmSupply[0]                     <<std::endl
      <<"   mtm supply in period "<<badPer+1 <<" is " <<mtmSupply[badPer]    <<std::endl
      <<"-------------------------------------------------------"            <<std::endl;
  }
  
  // determine if deman in period is consuming supply from period 0
  // via substitute bom
  bool useSubs = true;
  if ( period<subEarliestPer ) useSubs=false;
  if ( period>subLatestPer ) useSubs=false;
  if ( mtmSupply[0]==0.0f ) useSubs=false;
  return useSubs;
#endif
d268 1
a268 1
  
d273 13
a285 9
  bool ok=true;
  int badPer;
  int p;
  if ( supply[0]!= 0.0f ) {
    for ( p=1; p<supply.size(); ++p ) {
      if ( supply[p] != 0.0f ) {
        ok=false;
        badPer=p;
        break;
d288 2
a289 4
  }
  if ( !ok ) {
    // only issue warning if hasn't already been done for this operation
    if ( perishableSupplyWarningMsgIssued_.find(witAcquireOpName)==perishableSupplyWarningMsgIssued_.end() ) {
d297 1
a297 1
      perishableSupplyWarningMsgIssued_.insert(witAcquireOpName);
d304 1
d2840 1
a2842 6
int ESO2problem::getNPeriods() const
{
  int retVal;
  witGetNPeriods(mutableWitRun(),&retVal);
  return retVal;
}
a2911 4
int ESO2problem::getPeriod1SupplyPerishPeriod() const
{
  return period1SupplyPerishPeriod_;
}
d2926 1
d2936 1
a2936 1
perishableSupplyWarningMsgIssued_(),
d3009 1
d3019 1
a3019 1
perishableSupplyWarningMsgIssued_(),
d3053 1
d3063 1
a3063 1
  perishableSupplyWarningMsgIssued_ = source.perishableSupplyWarningMsgIssued_;
@


1.50
log
@fix to have wfmv be source of perishable supply when non-perishable supply has supplyVol=0
@
text
@d211 1
a211 1
      if ( (m % 1)==0 ) 
@


1.49
log
@Modified to use a copy of the eso2Problem when getting impact periods to improve performance
@
text
@d226 1
a226 1
        witGetBopEntryAppData(mutableWitRun(),baseDemanOpName.c_str(),b,(void**)&bopAppData);
a245 32
        // Get periods that substitute arc is active
        int subEarliestPer;
        int subLatestPer;
        witGetSubsBomEntryEarliestPeriod(getProb->mutableWitRun(),moveAndAcquireOpName.c_str(),0,0,&subEarliestPer);
        witGetSubsBomEntryLatestPeriod(getProb->mutableWitRun(),moveAndAcquireOpName.c_str(),0,0,&subLatestPer);

        // get supply of mtm
        std::vector<float> mtmSupply = getProb->getMtmSupply(mtms[m],srcLocs[m]);

        // Test Kevin's claims about mtmSupply
        bool ok=true;
        int badPer;
        int p;
        if ( mtmSupply[0]!= 0.0f ) {
          for ( p=1; p<np; ++p ) {
            if ( mtmSupply[p] != 0.0f ) {
              ok=false;
              badPer=p;
              break;
            }
          }
        }
        if ( !ok ) {
          std::cout 
            <<"-------------------------------------------------------"            <<std::endl
            <<"Warning: mtm supply in first period and another period is non-zero."<<std::endl
            <<"   mtm name: " <<mtms[m].c_str()                                    <<std::endl
            <<"   mtm source location: " <<srcLocs[m].c_str()                      <<std::endl
            <<"   mtm supply in first period: " <<mtmSupply[0]                     <<std::endl
            <<"   mtm supply in period "<<badPer+1 <<" is " <<mtmSupply[badPer]    <<std::endl
            <<"-------------------------------------------------------"            <<std::endl;
        }
d249 1
d254 1
d261 1
d263 1
a263 1
            if ( useSubs ) {
d270 1
a270 1
          // std::cout <<p <<" " <<impPers[p] <<" " <<prodRate[p] <<std::endl;
d284 127
d414 2
a415 1
void ESO2problem::addMtm(const std::string & mtmName, const std::string & mtmLoc )
d440 5
d446 1
a446 1
  float * demanTime = floatToConstFloatStar( (float) np );
d2237 2
a2239 1
        std::vector<float> scaledWfmvVec = wfmvVec;
d2243 10
d2274 1
a2274 1
            for(int p=0; p<moveCost.size(); ++p ) {
d2278 6
a2283 1
                scaledWfmvWithMoveCostVec[p] = scaleFactor*wfmvVec[impPer[p]] + moveCost[p];
d2313 1
d2318 11
d2352 1
d2357 11
d3044 1
d3126 1
d3169 1
d3359 1
a3359 1
    prob.addMtm("m1","loc1");
d3407 3
a3409 3
    prob.setLoosePartWfmv("lp1","loc1",1,0.1f);
    prob.setLoosePartWfmv("lp1","loc1",2,0.1f);
    prob.setLoosePartWfmv("lp1","loc1",3,0.1f);
d3452 3
a3454 3
    prob.setFeatureWfmv("f1","loc1",1,0.1f);
    prob.setFeatureWfmv("f1","loc1",2,0.1f);
    prob.setFeatureWfmv("f1","loc1",3,0.1f);
d3495 1
a3495 1
    prob.addMtm("m1","loc1");
d3547 1
a3547 1
    prob.addMtm("m1","loc1");
d3561 3
a3563 3
    prob.setMtmWfmv("m1","loc1",1,0.1f);
    prob.setMtmWfmv("m1","loc1",2,0.1f);
    prob.setMtmWfmv("m1","loc1",3,0.1f);
d3570 3
a3572 3
    prob.setDemanBomAttachRate("m1","p1","loc1",1,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",2,1.0f);
    prob.setDemanBomAttachRate("m1","p1","loc1",3,1.0f);
d3585 1
a3585 1
    //prob.reportPartDemand("p1","US","loc1",0);
@


1.48
log
@added progress message
@
text
@d198 6
d211 1
a211 1
      if ( (m % 500)==0 ) 
d240 3
a242 3
        impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,demanOpName,0) );
        impPersVecs.push_back( witGetArcAttribute(witGetBopEntryImpactPeriod,moveAndAcquireOpName,0) );
        impPersVecs.push_back( witGetArcAttribute(witGetBomEntryImpactPeriod,moveAndAcquireOpName,0) );
d249 2
a250 2
        witGetSubsBomEntryEarliestPeriod(witRun(),moveAndAcquireOpName.c_str(),0,0,&subEarliestPer);
        witGetSubsBomEntryLatestPeriod(witRun(),moveAndAcquireOpName.c_str(),0,0,&subLatestPer);
d253 1
a253 1
        std::vector<float> mtmSupply = getMtmSupply(mtms[m],srcLocs[m]);
d309 1
@


1.47
log
@Changed default demanTime to be nPeriods+1.
Fixed so demanTime is properly considered after interPlant moves.
Updated to set deman prodRate to attach rate associated with period of supply being deman'ed
@
text
@d142 1
d204 8
d303 1
@


1.46
log
@fixed up reporting to include demand wac cost
@
text
@d20 1
d89 207
d324 5
d1012 1
d1030 6
d1082 1
a1082 1
          float prodRate )
d1084 2
d1091 5
d1099 1
a1099 1
    period,prodRate);
d1120 1
a1120 1
          period,prodRate);
d1125 18
d1551 1
a1551 1
    // get operation exec cost
d1553 1
d1564 2
a1565 1
      <<indent.c_str() <<"bop prodRate: "   <<bopProdRate[period] <<std::endl
d1567 1
d1778 4
d2085 1
a2085 1
  
d2092 4
d2136 3
a2138 1
            std::vector<float> scaledWfmvWithMoveCostVec = wfmvVec;
d2141 1
d2143 4
a2146 1
              scaledWfmvWithMoveCostVec[p] = scaleFactor*wfmvVec[p] + moveCost[p];
d2880 1
d2961 1
d3003 1
d3052 1
a3052 1
  // Copy Mtm App Data
d3066 18
a3083 1
    }
d3128 1
a3128 1
  // delete Mtm App Data
d3140 17
a3156 1
    }
d3186 281
@


1.45
log
@fixed code to handle move time on substitute mtms
@
text
@d1360 1
a1360 1
      reportPart(consumedPart,newPer,recursionDepth, newReqVol, newReqVol );
d1386 3
a1388 1
    <<"shipVol: "     <<shipVol[period] <<std::endl;
@


1.44
log
@More diagnositic info
@
text
@d29 2
a30 1
       const std::string & acquiredPart )
d33 1
d36 31
a66 1
  if ( perishLimit==0 ) return;
d68 1
d86 1
d106 1
a106 1
  addSubsForPeriod1SupplyPerishPeriod(acquireMtmWitName,igfMtmWitName);
d337 1
a337 1
  addSubsForPeriod1SupplyPerishPeriod(acquireMtmWitName,igfMtmWitName);
d382 23
d502 1
a502 1
  addSubsForPeriod1SupplyPerishPeriod(acquireFeatureWitName,igfFeatureWitName);
d631 1
a631 1
  addSubsForPeriod1SupplyPerishPeriod(acquireLoosePartWitName,igfLoosePartWitName);
d1259 3
a1261 1
                             int recursionDepth ) const
d1279 2
d1303 6
d1311 3
d1318 2
d1343 5
a1347 2
      if ( subImpPer[period]!=-1 )
        reportPart(consumedPart,subImpPer[period],recursionDepth );
d1357 4
a1360 2
      // report on consumed part
      reportPart(consumedPart,newPer,recursionDepth );
d1378 1
d1392 1
a1392 1
    reportPart(pName,period,0);
d2283 1
d2412 18
a2446 110
#if 0
//-------------------------------------------------------------------------
// Resource Name Methods
//-------------------------------------------------------------------------
std::string ESO2problem::ibmBenchResourceName(const std::string & role,int band)
{
  return "ibmBench "+resourceName(role,band);
}
std::string ESO2problem::contrBenchResourceName(const std::string & role,int band)
{
  return "contractor "+resourceName(role,band);
}


std::string ESO2problem::resourceName(const std::string & role,int band)
{
  char bandchar[100];
  sprintf( bandchar, "%d", band );
  std::string retVal = "role:"+role + " band:"+bandchar;
  return retVal;
}


std::string ESO2problem::roleFromResourceName(const std::string & resName )
{  
  std::string begMark = "role:";
  std::string endMark = " band:";

  int begPos = resName.find(begMark);
  assert( begPos != std::string::npos );
  begPos = begPos+begMark.size();

  int endPos = resName.find(endMark);
  assert( endPos != std::string::npos );

  int len = endPos-begPos;
  std::string retVal = resName.substr(begPos,len);
  return retVal;
}

int ESO2problem::bandFromResourceName(const std::string & resName )
{  
  std::string begMark = " band:";

  int begPos = resName.find(begMark);
  assert( begPos != std::string::npos );
  begPos = begPos+begMark.size();

  int endPos = resName.size();

  int len = endPos-begPos;
  std::string bandName = resName.substr(begPos,len);
  int retVal=atoi(bandName.c_str());
  return retVal;
}

std::string ESO2problem::ibmProjectResourceLinkName(const std::string & proj,const std::string & role,int band)
{
  return "ibm "+projectResourceLinkName(proj,role,band);
}
std::string ESO2problem::contrProjectResourceLinkName(const std::string & proj,const std::string & role,int band)
{
  return "contractor "+projectResourceLinkName(proj,role,band);
}
std::string ESO2problem::projectResourceLinkName(const std::string & proj,const std::string & role,int band)
{
  std::string retVal = "proj:"+proj + " " + resourceName(role,band);
  return retVal;
}

std::string ESO2problem::roleFromProjectResourceLinkName(const std::string & projResrcLinkName )
{  
  return roleFromResourceName(projResrcLinkName);
}
int ESO2problem::bandFromProjectResourceLinkName(const std::string & projResrcLinkName )
{  
  return bandFromResourceName(projResrcLinkName);
}
std::string ESO2problem::projectFromProjectResourceLinkName(const std::string & projResrcLinkName )
{  
  std::string begMark = "proj:";
  std::string endMark = " role:";

  int begPos = projResrcLinkName.find(begMark);
  assert( begPos != std::string::npos );
  begPos = begPos+begMark.size();

  int endPos = projResrcLinkName.find(endMark);
  assert( endPos != std::string::npos );

  int len = endPos-begPos;
  std::string retVal = projResrcLinkName.substr(begPos,len);
  return retVal;
}
#endif

#if 0
//-------------------------------------------------------------------------
// Project Resource Link Methods
//-------------------------------------------------------------------------
void ESO2problem::addProjectResourceLink(
    const std::string & project,
    const std::string & role, int band)
{
  int nP=getNPeriods();

  std::string ibmLinkName   =   ibmProjectResourceLinkName(project,role,band);
  std::string contrLinkName = contrProjectResourceLinkName(project,role,band);
  std::string      linkName =      projectResourceLinkName(project,role,band);
  projectResourceLinkNames_.push_back(linkName);
a2447 2
  std::string   ibmResrcName =   ibmBenchResourceName(role,band);
  std::string contrResrcName = contrBenchResourceName(role,band);
a2448 192
  witAddOperation(witRun(),  ibmLinkName.c_str());
  witAddOperation(witRun(),contrLinkName.c_str());

  witAddBomEntry(witRun(),  ibmLinkName.c_str(),  ibmResrcName.c_str());
  witAddBomEntry(witRun(),contrLinkName.c_str(),contrResrcName.c_str());

  float   ibmCost =   getResourceIbmCost(role,band);
  float contrCost = getResourceContrCost(role,band);
  float rateScale = getProjectRateScale(project);

  int np = getNPeriods();
  float *   ibmExecCost = new float[np];
  float * contrExecCost = new float[np];
  float * subsCost = new float[np];

  int t;
  for ( t=0; t<np; t++ ) {
      ibmExecCost[t] =   ibmCost * rateScale;
    contrExecCost[t] = contrCost * rateScale;
    if ( ibmExecCost[t] > contrExecCost[t] ) {
      // set cost of substituting contractor to be 1% higher then the cost of using IBM
      float ibmCostUplifted = ibmExecCost[t] * 1.01f;
      subsCost[t] = ibmCostUplifted - contrExecCost[t];
    }
    else {
      subsCost[t]=0.0f;
    }
  }

  witSetOperationObj1ExecCost(witRun(),  ibmLinkName.c_str(),  ibmExecCost);
  witSetOperationObj1ExecCost(witRun(),contrLinkName.c_str(),contrExecCost);

  delete []   ibmExecCost;
  delete [] contrExecCost;

  witAddPart(witRun(),  ibmLinkName.c_str(),WitCAPACITY);
  witAddPart(witRun(),contrLinkName.c_str(),WitCAPACITY);
  
  witAddBopEntry(witRun(),  ibmLinkName.c_str(),  ibmLinkName.c_str());
  witAddBopEntry(witRun(),contrLinkName.c_str(),contrLinkName.c_str());

  witAddOperation(witRun(),linkName.c_str());
  witAddBomEntry(witRun(),linkName.c_str(),ibmLinkName.c_str());
  witAddSubsBomEntry(witRun(),linkName.c_str(),0,contrLinkName.c_str());

  // This is were cost of using a contractor is set in a way to ensure
  // that IBMers are selected over contractors
  witSetSubsBomEntryObj1SubCost(witRun(),linkName.c_str(),0,0,subsCost);
  delete []   subsCost;
    
  witAddPart(witRun(),linkName.c_str(),WitCAPACITY);  
  witAddBopEntry(witRun(),  linkName.c_str(),  linkName.c_str());

  float * offset = new float[nP];
  for( t=0; t<nP; t++ ) offset[t]=0.0f;

  float * consRate = new float[nP];
  for( t=0; t<nP; t++ ) consRate[t]=0.0f;

  // Add one bomEntry for each period
  for ( t=0; t<np; t++ ) {
    witAddBomEntry(witRun(),project.c_str(),linkName.c_str());
    
    int nBoms;
    witGetOperationNBomEntries(witRun(),project.c_str(),&nBoms);

    // set the offset to -period number
    offset[0]=-t;
    witSetBomEntryOffset(witRun(),project.c_str(),nBoms-1,offset);

    // set the consRate to zero (default value maybe 1).
    witSetBomEntryConsRate(witRun(),project.c_str(),nBoms-1,consRate);
  }

  delete [] consRate;
  delete [] offset;

}

void ESO2problem::getProjectResourceLinks(
    std::vector<std::string> & projects,
    std::vector<std::string> & roles, std::vector<int> & bands) const
{
  projects.clear();
  roles.clear();
  bands.clear();
  int nLinks = projectResourceLinkNames_.size();
  int l;
  for ( l=0; l<nLinks; l++ ) {
    projects.push_back( projectFromProjectResourceLinkName(projectResourceLinkNames_[l]) );
    roles.push_back( roleFromProjectResourceLinkName(projectResourceLinkNames_[l]) );
    bands.push_back( bandFromProjectResourceLinkName(projectResourceLinkNames_[l]) );
  }
}

// Return the range of bomEntry indices connecting the operation and part
void ESO2problem::getOperationBomEntryIndices(
                                 const std::string & opName,
                                 const std::string & consPartName,
                                 int & bomEntryIndexFirst,
                                 int & bomEntryIndexLast )
{
  bomEntryIndexFirst=-1;
  bomEntryIndexLast=-1;
  int nBoms;
  witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms);

  int b;
  for ( b=0; b<nBoms; b++ ){
    char * thisConsPart;
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),b,&thisConsPart);
    if ( consPartName==thisConsPart ) bomEntryIndexFirst=b;
    witFree(thisConsPart);
    if( bomEntryIndexFirst != -1 ) break;
  }

  if ( bomEntryIndexFirst != -1 ) {
    int nP=getNPeriods();
    bomEntryIndexLast = bomEntryIndexFirst + nP-1;
    
    char * thisConsPart;
    witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bomEntryIndexLast,&thisConsPart);
    assert( consPartName==thisConsPart );
    witFree(thisConsPart);
  }
}

void ESO2problem::setProjectResourceLinkConsRate(
                                                const std::string & project,
                                                const std::string & role, int band,
                                                const std::vector<float> & consRate)
{
  int nP=getNPeriods();
  assert(consRate.size()==nP);

  float * consRateVec = new float[nP];
  
  std::string      linkName =      projectResourceLinkName(project,role,band);

  int bomEntryIndexFirst;
  int bomEntryIndexLast;
  getOperationBomEntryIndices(project,linkName,bomEntryIndexFirst,bomEntryIndexLast);

  // Loop once for each bomEntry
  int b;
  for ( b=bomEntryIndexFirst; b<=bomEntryIndexLast; b++ ) {
    
    int t;
    for ( t=0; t<nP; t++ ) consRateVec[t]=consRate[b-bomEntryIndexFirst];
    
    witSetBomEntryConsRate(witRun(),project.c_str(),b,consRateVec);
  }

  delete [] consRateVec;
}

std::vector<float>  ESO2problem::getProjectResourceLinkConsRate(
    const std::string & project,
    const std::string & role, int band)
{
  std::vector<float> retVal;

  int nP=getNPeriods();

  float * consRateVec;
  float * offsetVec;
  
  std::string      linkName =      projectResourceLinkName(project,role,band);

  int bomEntryIndexFirst;
  int bomEntryIndexLast;
  getOperationBomEntryIndices(project,linkName,bomEntryIndexFirst,bomEntryIndexLast);

  // Loop once for each bomEntry
  int b;
  for ( b=bomEntryIndexFirst; b<=bomEntryIndexLast; b++ ) {

    witGetBomEntryConsRate(mutableWitRun(),project.c_str(),b,&consRateVec);
    
    retVal.push_back(consRateVec[0]);
    assert(consRateVec[0]==consRateVec[nP-1]);
    witFree(consRateVec);
    
    witGetBomEntryOffset(mutableWitRun(),project.c_str(),b,&offsetVec);
    assert( offsetVec[0]==-(b-bomEntryIndexFirst) );
    witFree(offsetVec);
  }

  assert(retVal.size()==nP);
  return retVal;
}
#endif
@


1.43
log
@removed purge executable from appl.mk
@
text
@d1247 1
d1262 2
d1267 3
a1269 1
        <<indent.c_str() <<"subImpact period: "   <<subImpPer[period] <<std::endl;
d2296 1
a2296 1
// Get vector of bom/bop float* attribute
d2309 1
a2309 1
// Get vector of bom/bop int* attribute
d2319 11
@


1.42
log
@added code to traverse tree for one demand
@
text
@d1308 1
a1308 1
  else {
d1310 1
a1310 1
  }
@


1.41
log
@updated to put osl log file input/output directory
@
text
@d1200 117
d2275 45
@


1.40
log
@modified to not write zero's to output file
@
text
@d2561 6
@


1.39
log
@Fixed problem with displaying header record in output files
@
text
@d448 1
a448 1
  addPartWithApplyingInterplants(featureName,featureLoc);
d673 1
a673 1
void ESO2problem::addPartWithApplyingInterplants(const std::string & part, const std::string & partLoc )
d677 1
a677 2
  bool partExist = partExists(part,partLoc);
  assert(!partExist);
d688 1
a688 10
  addPartWithApplyingInterplants(part,partLoc);
#if 0
  bool partExist = partExists(part,partLoc);
  assert(!partExist);
  witAddPart(witRun(), witName.c_str(), WitCAPACITY);
  witAddPart(witRun(), moveAbleWitName.c_str(), WitCAPACITY);
  witAddOperation(witRun(),witName.c_str());
  witAddBomEntry(witRun(),witName.c_str(),moveAbleWitName.c_str());
  witAddBopEntry(witRun(),witName.c_str(),witName.c_str());
#endif
d699 1
a699 1
    bool partExist = partExists(part,destLoc);
a1079 3

  // Set Bop to not be explodable to avoid cycles
  //witSetBopEntryExpAllowed(witRun(),opName.c_str(),0,WitFALSE);
@


1.38
log
@Some modification of messages displayed and fixing up end period for last supply period perishability.
@
text
@d2672 10
@


1.37
log
@Remove mtm from demanData
@
text
@d13 1
d34 1
a34 1
  //if ( perishLimit==0 ) return;
d36 1
a36 1
  if ( perishLimit>(np-1) ) perishLimit = np-1;
d793 1
d800 1
d1847 1
a1847 1
    //std::cout <<"Calling witOptImplode" <<std::endl;
d1849 1
a1849 1
    //std::cout <<"Returned from witOptImplode call" <<std::endl;
d2667 5
@


1.36
log
@Updated to add error messages dealing with period1SupplyPerishPeriod
@
text
@d1338 7
d1395 6
d1424 6
d1454 7
d1487 7
d1522 5
d1537 2
d1540 1
d1545 4
a1548 1
          witSetOperationSelForDel(witRun(),op,WitTRUE);          
d1551 3
a1553 1
          std::cout <<"Prunning: " <<producedPart <<std::endl;          
d1555 1
d1579 5
a1583 1
  witPurgeData(witRun());
d1630 3
d1843 2
a1844 2
    

d1846 1
@


1.35
log
@changed name of globalAttribute period1PerishabilityLimit to period1SupplyPerishPeriod
@
text
@d2894 1
a2894 1
      for ( perishLimit=0; perishLimit<7; perishLimit=perishLimit+3 ) {
@


1.34
log
@Changes to implement period1SupplyPerishabilityLimit
@
text
@d26 1
a26 1
void ESO2problem::addSubsForPeriod1PerishabilityLimit(
d30 1
a30 1
  int perishLimit = getPeriod1PerishabilityLimit();
d71 1
a71 1
  addSubsForPeriod1PerishabilityLimit(acquireMtmWitName,igfMtmWitName);
d302 1
a302 1
  addSubsForPeriod1PerishabilityLimit(acquireMtmWitName,igfMtmWitName);
d444 1
a444 1
  addSubsForPeriod1PerishabilityLimit(acquireFeatureWitName,igfFeatureWitName);
d573 1
a573 1
  addSubsForPeriod1PerishabilityLimit(acquireLoosePartWitName,igfLoosePartWitName);
d2565 1
a2565 1
void ESO2problem::setPeriod1PerishabilityLimit( int periods )
d2568 1
a2568 1
  period1PerishabilityLimit_=periods;
d2570 1
a2570 1
int ESO2problem::getPeriod1PerishabilityLimit() const
d2572 1
a2572 1
  return period1PerishabilityLimit_;
d2599 1
a2599 1
period1PerishabilityLimit_(0)
d2664 1
a2664 1
period1PerishabilityLimit_(0)
d2705 1
a2705 1
  period1PerishabilityLimit_  = source.period1PerishabilityLimit_;
d2902 1
a2902 1
          p1.setPeriod1PerishabilityLimit(perishLimit);
@


1.33
log
@Updated to change 1 to be the first period.
Added additional test to see if objValue has changed
@
text
@d26 8
d35 18
d63 2
d70 3
a80 7
#if 0
  // Set default acquistion cost
  float * acquireCost = floatToConstFloatStar(1000000.f);
  witSetOperationObj1ExecCost(witRun(),acquireMtmWitName.c_str(),acquireCost);
  free(acquireCost);
#endif

a81 1
  int np = getNPeriods();
d301 3
d441 4
a444 1
  witAddBomEntry(witRun(), acquireFeatureWitName.c_str(), igfFeatureWitName.c_str() );
d572 2
d2565 9
d2598 2
a2599 1
loosePartPriority_(1)
d2663 2
a2664 1
loosePartPriority_(1)
d2705 1
d2853 1
a2853 1
  fprintf(file,"tc,p,sf,objValue\n");
d2892 11
a2902 18
    for ( tc=0; tc<testCases.size(); ++tc ) { 
      int p;
      for ( p=0; p<mtmPriority.size(); ++p ) {
        
        ESO2problem p1;
        ESO2problem p2;
        ESO2problem p3;
        createModel(p1, testCases[tc] );
        p1.setMtmPriority(mtmPriority[p]);
        p1.setFeaturePriority(featurePriority[p]);
        p1.setLoosePartPriority(loosePartPriority[p]);
        
        p2=p1;
        p3=p2;
        p3.pruneWitModel();
        
        int sf;
        for ( sf=0; sf<scaleFactors.size(); ++sf ) {
d2904 2
a2905 3
          p1.setWfmvScaleFactor(scaleFactors[sf]);
          p2.setWfmvScaleFactor(scaleFactors[sf]);
          p3.setWfmvScaleFactor(scaleFactors[sf]);
d2907 3
a2909 3
          p1.solve();
          p2.solve();        
          p3.solve();
d2911 3
a2913 5
          float p1Obj = p1.getObjValue();
          float p2Obj = p2.getObjValue();
          float p3Obj = p3.getObjValue();
          assert( p1Obj==p2Obj );
          assert( p1Obj==p3Obj );
d2915 17
d2933 3
a2935 3
          {
            fprintf(file,"%d,%d,%d,%f\n",tc,p,sf,p1Obj);
          }
d2937 4
a2940 4
          {
            float historicObjValue = file.objValueAsFloat(file.key(tc,p,sf));
            assert(p1Obj == historicObjValue);
          }
d2942 4
a2945 4

        }
      }
    }
@


1.32
log
@changes for building on aix
@
text
@d23 1
d2807 9
d2881 12
d2898 3
a2900 1

@


1.31
log
@Some changes getting ready for AIX build
@
text
@d198 1
a198 1
      const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d201 1
a201 1
      std::set<std::string>>::const_iterator locIt;
d389 1
a389 1
const std::set<std::string>> & ESO2problem::getMtmAcquireLocs(const std::string & mtmName)const
d743 1
a743 1
    const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d746 1
a746 1
    std::set<std::string>>::const_iterator locIt;
d799 1
a799 1
    const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d802 1
a802 1
    std::set<std::string>>::const_iterator locIt;
d1595 1
a1595 1
          const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1598 1
a1598 1
          std::set<std::string>>::const_iterator locIt;
d1702 1
a1702 1
          const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1704 1
a1704 1
          std::set<std::string>>::const_iterator locIt;
@


1.30
log
@updated unitTest to do something useful.
fixed problems with prunning. Now works for all testCases.
@
text
@d9 1
a9 1
#include <assert.h>
d11 2
a12 2
#include <float.h>
#include <stdio.h>
d535 1
a535 1
  std::string serverLoosePartWitName = partName(loosePartName, loosePartLoc );
d1503 1
a1503 1
#if 1
d2807 1
d2811 1
@


1.29
log
@Changed so partInterplants are applied to parts obtained from an mtm that has had an interplant move.
@
text
@d10 1
a10 1
#include <iostream.h>
d22 2
d64 1
a64 1
  mtmNames_.push_back(baseName);
d149 1
d156 7
d174 1
d181 6
d417 2
a418 1
#if 1
d420 1
d422 4
a425 2
#else
  addPart(featureName,featureLoc);
d427 4
a430 1
  witAddBopEntry(witRun(), acquireFeatureWitName.c_str(), serverFeatureWitName.c_str() );
d445 1
a445 1
  featureNames_.push_back(baseName);
d476 1
d483 7
d563 1
a563 1
  loosePartNames_.push_back(baseName);
d594 1
d601 7
d640 12
d655 3
d661 5
d726 1
a726 1
  std::string producedPart = partName(part, loc );
d757 1
a757 1
      std::string producedPart = partName(part, destLoc );
d782 1
a782 1
  std::string producedPart = partName(part, loc );
d826 1
a826 1
  std::string producedPart = partName(part, loc );
d883 1
a883 1
  std::string upLevelPartName = partName(upLevelPart,loc); 
d908 1
a908 1
  alternateParts_.push_back(ecOpName);
d966 1
d974 8
d1041 1
a1041 1
  std::string srcPartName = partName(part,srcLoc); 
d1057 1
a1057 1
  witSetBopEntryExpAllowed(witRun(),opName.c_str(),0,WitFALSE);
d1069 1
a1069 1
  partInterplants_.push_back(opName);
d1108 1
d1116 8
d1203 1
a1203 1
  partDemands_.push_back(dName);
d1246 1
d1254 8
a1297 7
#if 0
  //----------------------
  // Methods for projects. To be added.
  //----------------------
void ESO2problem::addProject(const std::string & project )
{
  // wit part name is same as project name
a1298 2
  // Add project to list of all project names
  featureNames_.push_back (project);
d1300 5
a1304 25
  //----------------------------------------------
  // Create Wit Objects which model a project
  //----------------------------------------------
  witAddPart (witRun(), project.c_str(), WitCAPACITY);
  ILSprojAppData * projAppData = new ILSprojAppData;
  witSetPartAppData (mutableWitRun(), project.c_str(), projAppData);

  witAddOperation (witRun(), project.c_str());
  witAddBopEntry (witRun(), project.c_str(), project.c_str());

  witAddDemand (witRun(), project.c_str(), project.c_str());

  int np=getNPeriods();
  float * tv=new float[np];
  int t=0;
  for(t=0;t<np;t++) tv[t]=0.0;
  tv[0]=1.0;
  witSetOperationIncLotSize(witRun(), project.c_str(),tv);
  witSetOperationYieldRate(witRun(), project.c_str(),tv);
  delete [] tv;
}


// Get list of all projects
void ESO2problem::getProjects(std::vector<std::string> & projects ) const
d1306 1
a1306 3
  projects = featureNames_;
}
#endif
d1308 32
a1339 3
#if 0
void ESO2problem::setProjectCloseProb(const std::string & project, float closingProbability){
  ILSprojAppData * appData;
d1341 160
a1500 103
  witGetPartAppData(mutableWitRun(), project.c_str(), (void**)&appData);
  appData->setCloseProb (closingProbability);
}

float ESO2problem::getProjectCloseProb(const std::string & project) const
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(), (void**)&appData);
  float retVal = appData->getCloseProb();
  return retVal;
}

void ESO2problem::setProjectRateScale(const std::string & project, float rateScale)
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(), (void**)&appData);
  appData->setRateScale (rateScale);
}

float ESO2problem::getProjectRateScale(const std::string & project) const
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(), (void**)&appData);
  float retVal = appData->getRateScale();
  return retVal;
}

void ESO2problem::setProjectStartPeriod(const std::string & project, int startPeriod)
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(), (void**)&appData);
  appData->setStartPeriod (startPeriod);
}

int ESO2problem::getProjectStartPeriod(const std::string & project ) const
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(),(void**)&appData);
  int retVal = appData->getStartPeriod();
  return retVal;
}

void ESO2problem::setProjectRevenue(const std::string & project, float revenue)
{
  int i;
  int nP = getNPeriods ();
  float *revVector = new float[nP];

  // Set wit shipReward to be 10 times revenue.
  // This ensures that only grossly unprofitable projects will not be done
  // and accomodates the aritifical cost added to model when substituting
  // contractor for ibmer.
  for (i=0; i<nP; i++) revVector[i] = 10.0f*revenue;

  witSetDemandObj1ShipReward (witRun(), project.c_str(), project.c_str(), revVector);
  delete[] revVector;
}

float ESO2problem::getProjectRevenue(const std::string & project ) const
{
  float retVal;
  float *revVector;

  witGetDemandObj1ShipReward (mutableWitRun(), project.c_str(), project.c_str(), &revVector);
  retVal = revVector[0]/10.f;
  witFree (revVector);
  return retVal;
}

std::vector<float> ESO2problem::getProjectExecVol(const std::string & project ) const
{
  ILSprojAppData * appData;

  witGetPartAppData(mutableWitRun(), project.c_str(),(void**)&appData);
  std::vector<float> retVal = appData->getExecVol();
  return retVal;
}
#endif

#if 0
//-------------------------------------------------------------------------
// Resource Methods
//-------------------------------------------------------------------------
void ESO2problem::addResource(const std::string & role, int band )
{
  // create wit part name from role and band
  std::string ibmBRN = ibmBenchResourceName(role,band);
  std::string contrBRN = contrBenchResourceName(role,band);
  std::string rn = resourceName(role,band);

  // Add resource to list of all resource names
  mtmNames_.push_back(rn);

  //----------------------------------------------
  // Create Wit Objects which model a resource
  //----------------------------------------------
  witAddPart(witRun(),ibmBRN.c_str(),WitCAPACITY);
  witAddPart(witRun(),contrBRN.c_str(),WitCAPACITY);
a1501 2
  ILSresrcAppData * ibmAppData = new ILSresrcAppData;
  witSetPartAppData(mutableWitRun(),ibmBRN.c_str(),ibmAppData);
d1503 32
a1534 3
  ILSresrcAppData * contrAppData = new ILSresrcAppData;
  witSetPartAppData(mutableWitRun(),contrBRN.c_str(),contrAppData);
}
d1536 9
a1544 11
void ESO2problem::getResources(
    std::vector<std::string> & roles,
    std::vector<int> & bands ) const
{
  roles.clear();
  bands.clear();
  int nResrcs = mtmNames_.size();
  int r;
  for ( r=0; r<nResrcs; r++ ) {
    roles.push_back( roleFromResourceName(mtmNames_[r]) );
    bands.push_back( bandFromResourceName(mtmNames_[r]) );
a1545 1
}
d1547 1
a1547 64
// Sanjeeb: Add resource costs
void ESO2problem::setResourceIbmCost( const std::string & role, int band, float ibmCost)
{
  std::string resrcName   = ibmBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  appData->setCost(ibmCost);
}

void ESO2problem::setResourceContrCost(const std::string & role, int band, float contrCost)
{
  std::string resrcName   = contrBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  appData->setCost(contrCost);
}

// Sanjeeb: Get resource costs
float ESO2problem::getResourceIbmCost(const std::string & role, int band)
{
  std::string resrcName   = ibmBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  float retVal = appData->getCost();
  return retVal;
}

float ESO2problem::getResourceContrCost (const std::string & role, int band)
{
  std::string resrcName   = contrBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  float retVal = appData->getCost();
  return retVal;
}

void ESO2problem::setResourceIbmSupplyVol (const std::string & role, int band, std::vector<float> supplyVol)
{
  float *vol = stlVecToFloatStar (supplyVol);
  std::string resrcName = ibmBenchResourceName(role, band);

  witSetPartSupplyVol (witRun(), resrcName.c_str(), vol);
  delete [] vol;
}

std::vector<float> ESO2problem::getResourceIbmSupplyVol (const std::string & role, int band)
{
  float *vol;
  std::string resrcName = ibmBenchResourceName(role, band);
  std::vector<float> svol;

  witGetPartSupplyVol (witRun(), resrcName.c_str(), &vol);
  svol = witFloatStarToStlVec (vol);
  witFree (vol);
  return svol;
}

void ESO2problem::setResourceContrSupplyVol (const std::string & role, int band, std::vector<float> supplyVol)
{
  float *vol = stlVecToFloatStar (supplyVol);
  std::string resrcName = contrBenchResourceName(role, band);

  witSetPartSupplyVol (witRun(), resrcName.c_str(), vol);
  delete [] vol;
a1549 31
std::vector<float> ESO2problem::getResourceContrSupplyVol (const std::string & role, int band)
{
  float *vol;
  std::string resrcName = contrBenchResourceName(role, band);
  std::vector<float> svol;

  witGetPartSupplyVol (witRun(), resrcName.c_str(), &vol);
  svol = witFloatStarToStlVec (vol);
  witFree (vol);
  return svol;
}

std::vector< std::vector<float> > ESO2problem::getResourceIbmConsVol (const std::string & role, int band)
{
  std::string resrcName   = ibmBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  std::vector< std::vector<float> > retVal = appData->getConsVol();
  return retVal;
}
std::vector< std::vector<float> > ESO2problem::getResourceContrConsVol (const std::string & role, int band)
{

  std::string resrcName   = contrBenchResourceName(role, band);
  ILSresrcAppData * appData;
  witGetPartAppData(mutableWitRun(),resrcName.c_str(),(void**)&appData);
  std::vector< std::vector<float> > retVal = appData->getConsVol();
  return retVal;
}
#endif

d1555 2
a1675 2
 
  //writeWitData("eso2.wit");
d1917 5
d2671 49
a2720 35
#if 0
  // copy project app data
  std::vector<std::string> projects;
  getProjects (projects);
  int p;
  for(p=0; p<featureNames_.size(); p++) {    
    ILSprojAppData * srcAppData;  
    ILSprojAppData * sinkAppData;

    witGetPartAppData(source.mutableWitRun(), projects[p].c_str(), (void**)&srcAppData);
    sinkAppData = new ILSprojAppData(*srcAppData);    
    witSetPartAppData(witRun(), projects[p].c_str(), sinkAppData);
  }

  // copy resource app data
  std::vector<std::string> roles;
  std::vector<int> bands;
  getResources(roles,bands);
  int r;
  for( r=0; r<mtmNames_.size(); r++ ) {    
    ILSresrcAppData * srcAppData;  
    ILSresrcAppData * sinkAppData;
    std::string resrcName;

    resrcName = ibmBenchResourceName(roles[r], bands[r]);
    witGetPartAppData(source.mutableWitRun(),resrcName.c_str(),(void**)&srcAppData);
    sinkAppData = new ILSresrcAppData(*srcAppData);    
    witSetPartAppData(witRun(),resrcName.c_str(),sinkAppData);

    resrcName = contrBenchResourceName(roles[r], bands[r]);
    witGetPartAppData(source.mutableWitRun(),resrcName.c_str(),(void**)&srcAppData);
    sinkAppData = new ILSresrcAppData(*srcAppData);  
    witSetPartAppData(witRun(),resrcName.c_str(),sinkAppData);
  }
#endif
d2733 28
a2760 11

#if 0
  // Delete project app data
  std::vector<std::string> projects;
  getProjects (projects);
  int p;
  for(p=0; p<featureNames_.size(); p++) {    
    ILSprojAppData * projAppData;  

    witGetPartAppData(mutableWitRun(), projects[p].c_str(), (void**)&projAppData);
    delete projAppData;
d2762 14
a2775 18

  // Delete resource appData
  std::vector<std::string> roles;
  std::vector<int> bands;
  getResources(roles,bands);
  int r;
  for( r=0; r<mtmNames_.size(); r++ ) {
    ILSresrcAppData * appData;
    witGetPartAppData(
      mutableWitRun(),
      ibmBenchResourceName(roles[r], bands[r]).c_str(),
      (void**)&appData);
    delete appData;
    witGetPartAppData(
      mutableWitRun(),
      contrBenchResourceName(roles[r], bands[r]).c_str(),
      (void**)&appData);
    delete appData;
a2776 1
#endif
a2802 81
#if 0
    // test resource name methods
    assert( roleFromResourceName(resourceName("Role X Y Z",9))=="Role X Y Z" );
    assert( bandFromResourceName(resourceName("Role X Y Z",9))==9 );

    // test projectResourceLinkName name methods
    assert( projectFromProjectResourceLinkName(projectResourceLinkName("P1","Role X Y Z",9))=="P1" );
    assert( roleFromProjectResourceLinkName(projectResourceLinkName("P1","Role X Y Z",9))=="Role X Y Z" );
    assert( bandFromProjectResourceLinkName(projectResourceLinkName("P1","Role X Y Z",9))==9 );
    
    prob.addResource("role1",6);
#endif
  }
  
#if 0
  // Test getResources method
  {
    ESO2problem p;
    std::vector<std::string> roles;
    std::vector<int> bands;
    p.getResources(roles,bands);
    assert(roles.size()==0);
    assert(bands.size()==0);
    p.addResource("plumber",5);
    p.addResource("teacher",6);
    p.addResource("fireman",9);
    p.getResources(roles,bands);
    assert(roles.size()==3);
    assert(bands.size()==roles.size());
    assert(roles[0]=="plumber");
    assert(roles[1]=="teacher");
    assert(roles[2]=="fireman");
    assert(bands[0]==5);
    assert(bands[1]==6);
    assert(bands[2]==9);
  }
#endif

#if 0
  // Test add costs & get costs fns for projects
  {    
    ESO2problem p0;
    {      
      ESO2problem p;
      p.addProject("plumbing");

      p.setProjectCloseProb ("plumbing", .75f); // check for 0 <= <= 1 ?
      assert(p.getProjectCloseProb ("plumbing") == .75f);
      p.setProjectRateScale ("plumbing", 1.5f); // check for 0 <= <= 1 ?
      assert(p.getProjectRateScale ("plumbing") == 1.5f);
      p.setProjectStartPeriod ("plumbing", 1);
      assert(p.getProjectStartPeriod ("plumbing") == 1);
      p.setProjectRevenue ("plumbing", 7.5f);
      assert(p.getProjectRevenue ("plumbing") == 7.5f);
      p0=p;
    }
    assert(p0.getProjectCloseProb ("plumbing") == .75f);
    assert(p0.getProjectRateScale ("plumbing") == 1.5f);
    assert(p0.getProjectStartPeriod ("plumbing") == 1);
    assert(p0.getProjectRevenue ("plumbing") == 7.5f);
    assert(p0.getProjectExecVol ("plumbing").size() == 0);
  }

  // Test resource methods
  {    
    ESO2problem p0;
    {
      ESO2problem p;
      float co;
      
      p.addResource("plumber",5);
      p.setResourceIbmCost ("plumber", 5, 7.0f);
      co = p.getResourceIbmCost ("plumber", 5);
      assert(co == 7.0f);
      p.setResourceContrCost ("plumber", 5, 4.0f);
      co = p.getResourceContrCost ("plumber", 5);
      assert(co == 4.0f);
      p0=p;
    }
    assert(p0.getResourceIbmCost("plumber", 5)==7.0f);
    assert(p0.getResourceContrCost("plumber", 5)==4.0f);
a2803 27
    {
      ESO2problem p;
      p.setNPeriods(3);
      std::vector<float> v(3), u;
      v[0] = 1.0f; v[1] = 2.5f; v[2] = 3.5f;

      p.addResource("plumber",5);
      p.setResourceContrSupplyVol ("plumber",5,v);
      u = p.getResourceContrSupplyVol ("plumber", 5);
      assert(u[0] == 1.0f);
      assert(u[1] == 2.5f);
      assert(u[2] == 3.5f);

      p.setResourceIbmSupplyVol ("plumber",5,v);
      u = p.getResourceIbmSupplyVol ("plumber", 5);
      assert(u[0] == 1.0f);
      assert(u[1] == 2.5f);
      assert(u[2] == 3.5f);

      std::vector< std::vector<float> > cv;
      cv=p.getResourceIbmConsVol("plumber",5);
      assert(cv.size()==0.0);

      cv=p.getResourceContrConsVol("plumber",5);
      assert(cv.size()==0.0);

    }
d2806 29
a2834 1
  // Test projectResourceLink methods
d2836 35
a2870 69
    ESO2problem p0;
    std::vector<std::string> projects;
    std::vector<std::string> roles;
    std::vector<int> bands;
    {
      ESO2problem p;
      p.setNPeriods(4);
      p.addProject("p1");
      p.addProject("p2");
      p.addResource("r1",7);
      p.addResource("r2",8);

      p.getProjectResourceLinks(projects,roles,bands);
      assert(projects.size()==0);
      assert(projects.size()==roles.size());
      assert(projects.size()==bands.size());

      p.addProjectResourceLink("p1","r1",7);
      p.addProjectResourceLink("p2","r1",7);
      p.addProjectResourceLink("p1","r2",8);
      p.addProjectResourceLink("p2","r2",8);

      p.getProjectResourceLinks(projects,roles,bands);
      assert(projects.size()==4);
      assert(projects.size()==roles.size());
      assert(projects.size()==bands.size());
      assert( projects[0]=="p1" );
      assert( roles[0]=="r1" );
      assert( bands[0]==7 );
      assert( projects[3]=="p2" );
      assert( roles[3]=="r2" );
      assert( bands[3]==8 );

      std::vector<float> cr;
      cr = p.getProjectResourceLinkConsRate("p1","r1",7);
      assert(cr.size()==4);
      assert( cr[0]==0.0f);
      assert( cr[1]==0.0f);
      assert( cr[2]==0.0f);
      assert( cr[3]==0.0f);

      cr[1]=4.0f;
      p.setProjectResourceLinkConsRate("p1","r1",7,cr);
      cr = p.getProjectResourceLinkConsRate("p1","r1",7);
      assert(cr.size()==4);
      assert( cr[0]==0.0f);
      assert( cr[1]==4.0f);
      assert( cr[2]==0.0f);
      assert( cr[3]==0.0f);

      cr[3]=6.0f;
      p.setProjectResourceLinkConsRate("p1","r1",7,cr);
      cr = p.getProjectResourceLinkConsRate("p1","r1",7);
      assert(cr.size()==4);
      assert( cr[0]==0.0f);
      assert( cr[1]==4.0f);
      assert( cr[2]==0.0f);
      assert( cr[3]==6.0f);

      cr[0]=8.0f;
      p.setProjectResourceLinkConsRate("p1","r2",8,cr);
      cr = p.getProjectResourceLinkConsRate("p1","r2",8);
      assert(cr.size()==4);
      assert( cr[0]==8.0f);
      assert( cr[1]==4.0f);
      assert( cr[2]==0.0f);
      assert( cr[3]==6.0f);

      p0 = p;
a2871 25
    p0.getProjectResourceLinks(projects,roles,bands);
    assert(projects.size()==4);
    assert(projects.size()==roles.size());
    assert(projects.size()==bands.size());
    assert( projects[0]=="p1" );
    assert( roles[0]=="r1" );
    assert( bands[0]==7 );
    assert( projects[3]=="p2" );
    assert( roles[3]=="r2" );
    assert( bands[3]==8 );
    
    std::vector<float> cr;
    cr = p0.getProjectResourceLinkConsRate("p1","r1",7);
    assert(cr.size()==4);
    assert( cr[0]==0.0f);
    assert( cr[1]==4.0f);
    assert( cr[2]==0.0f);
    assert( cr[3]==6.0f);
    
    cr = p0.getProjectResourceLinkConsRate("p1","r2",8);
    assert(cr.size()==4);
    assert( cr[0]==8.0f);
    assert( cr[1]==4.0f);
    assert( cr[2]==0.0f);
    assert( cr[3]==6.0f);
a2872 1
#endif
a2873 1
}
d2875 1
a2875 7
#if 0
void ESO2problem::setProbabilityGrid(const std::vector<float> & probGrid)
{
  // set global app data to probability Grid
  ILSprobAppData * appData;
  witGetAppData(mutableWitRun(),(void**)&appData);
  appData->setProbGrid(probGrid);
a2876 8
std::vector<float> ESO2problem::getProbabilityGrid()
{
  ILSprobAppData * appData;
  witGetAppData(mutableWitRun(), (void**)&appData);
  std::vector<float> retVal = appData->getProbGrid();
  return retVal;
}
#endif
@


1.28
log
@File changes to allow all parts and mtms defined at a srcLoc to have interplant move operations added.
@
text
@d400 4
d405 1
d603 2
d606 27
d952 11
d1509 2
a1510 1
        for(it=wfmvVec.begin(); it!=wfmvVec.end(); ++it ) {
d1513 1
a1513 1
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec); 
d1528 1
a1528 1
            std::vector<float> execCost;
d1532 1
a1532 1
              float v = scaleFactor*wfmvVec[p] + moveCost[p];
d1536 1
a1536 1
            witSetNameAttribute(witSetOperationObj1ExecCost,acquireAndMoveOpName, wfmvVec);
d2399 7
d2477 1
d2541 1
d2581 1
@


1.27
log
@Added partInterplantMoveDefault input data file
@
text
@d240 6
a245 1
void ESO2problem::addMtmInterplant        (const std::string & mtm, const std::string & srcLoc, const std::string & destLoc )
d261 2
a262 3
  float npAsFloat = getNPeriods(); 
  std::vector<float> defaultMoveTime = floatToStlVec(npAsFloat);
  witSetArcAttribute(witSetBomEntryOffset,acquireMtmWitName,0,defaultMoveTime);
d275 2
d278 7
a284 1
  
d1023 1
d2463 2
@


1.26
log
@Modifications to add mtmPriority, featurePriority, and loosePartPriority
@
text
@d57 2
d115 7
d132 7
d879 11
d909 3
a911 1
                               const std::string & destLoc )
d933 9
a941 4
  // set default values
  float * cost = floatToConstFloatStar(1000000.f);
  witSetOperationObj1ExecCost(witRun(),opName.c_str(),cost);
  delete [] cost;
d1000 10
d1138 11
@


1.25
log
@Updated to set aquireCost of features and looseParts using scale factors
@
text
@d780 1
a780 1
  free(cost);
d784 1
a784 1
  free(prodRate);
d907 1
a907 1
  free(cost);
d1310 1
a1310 1
  free (vol);
d1331 1
a1331 1
  free (vol);
d1371 7
a1377 1
  // Set obj1ExecCost of mtm acquire operations to wfmv * wfmvScaleFactor
d1381 1
a1381 1
    // update wfmv for mtms
d1399 3
a1401 1
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);  
d1423 2
d1452 3
a1454 1
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);        
d1479 3
a1481 1
        witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);        
d1486 1
a1486 1
  } // finished setting obj1ExecCost
d1489 83
a1571 23
#if 0
  // set DemandCumShipBounds
    while (true) {
      witAdvanceObjItr (witRun());
      witAttr objItrState;
      witGetObjItrState (witRun(), & objItrState);
      if (objItrState == WitINACTIVE) 
        break;
      if (objItrState == WitAT_DEMAND) {
        char * demandedPartName;
        char * demandName;
        witGetObjItrDemand(witRun(), &demandedPartName, &demandName);
        float * dv;
        witGetDemandDemandVol(mutableWitRun(),demandedPartName,demandName,&dv);
        witSetDemandCumShipBounds(witRun(),
          demandedPartName,demandName,
          NULL,NULL,dv);
        witFree(dv);
        witFree(demandedPartName);
        witFree(demandName);
      }
    }
#endif
d1574 1
d1794 18
a1811 1
  free(fltStar);
d1844 1
a1844 1
  free(fltStar);
d2300 36
d2355 4
a2358 1
mtmAcquireLocs_()
d2394 1
a2394 1
  //witSetAccAfterSoftLB(witRun(),WitTRUE );
d2416 4
a2419 1
mtmAcquireLocs_()
d2456 3
@


1.24
log
@Added loosePart data file
@
text
@d19 2
d375 1
d380 6
d407 4
a410 1
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
d446 9
d485 1
d490 6
d517 4
a520 1
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
d555 9
a563 1

d1375 5
a1379 17
    std::vector<std::string> mtms;
    std::vector<std::string> plantLocs;
    getMtms(mtms,plantLocs);
    
    // loop once for each mtm
    int m;
    for ( m=0; m<mtms.size(); m++ ) {
      std::vector<float> wfmvVec = getMtmWfmv(mtms[m],plantLocs[m]);          
      std::string mtmBName = baseMtmName(mtms[m],plantLocs[m] );         
      std::string acquireOpName = acquireMtmName(mtms[m],plantLocs[m],plantLocs[m] );

      // Set wfmv for aquiring mtm at its src location (without moving it)
      std::vector<float>::iterator it;
      for(it=wfmvVec.begin(); it!=wfmvVec.end(); ++it ) {
        (*it) = (*it) * scaleFactor;
      }
      witSetNameAttribute(witSetOperationObj1ExecCost,acquireOpName, wfmvVec);  
d1381 6
a1386 2
      // are there any locations that this mtm is moved to?
      if ( mtmAcquireExists(mtmBName) ) {
d1388 6
a1393 2
        // Get all locations that this mtm can be moved to
        const std::set<std::string>> & moveToLocs = getMtmAcquireLocs(mtmBName);
d1395 2
a1396 6
        // Loop once for each location this mtm can be moved to
        std::set<std::string>>::const_iterator locIt;
        for(locIt=moveToLocs.begin(); locIt!=moveToLocs.end(); ++locIt ) {
          const std::string & destLoc = *locIt;
          std::vector<float> moveCost = getMtmInterplantMoveCost(mtms[m],plantLocs[m],destLoc);
          std::vector<float> execCost;
d1398 2
a1399 4
          // compute execCost. this is scaleFactor*wfmv + moveCost
          for(int p=0; p<moveCost.size(); ++p ) {
            float v = scaleFactor*wfmvVec[p] + moveCost[p];
          }
d1401 16
a1416 2
          std::string acquireAndMoveOpName = acquireMtmName(mtms[m],plantLocs[m],destLoc );
          witSetNameAttribute(witSetOperationObj1ExecCost,acquireAndMoveOpName, wfmvVec);
d1418 50
a1467 1
        } // end of locIt loop
d1469 1
a1469 1
      } // end of if (mtmAcquireExists(baseMtmName))
d1471 1
a1471 1
    } // end of loop m
@


1.23
log
@Added loop to do multiple solves each with different wfmvScaleFactor
@
text
@d435 90
d1467 24
d2131 1
d2189 1
d2225 1
@


1.22
log
@modifications to accomodate 2/18 file format changes
@
text
@d2055 3
@


1.21
log
@Added writing for mtm and feature supplyVol to output files
@
text
@d28 3
a30 3
  std::string acquireMtmWitName = acquireMtmName(mtmName, mtmLoc );
  std::string serverMtmWitName = serverMtmName(mtmName, mtmLoc );
  std::string demanMtmWitName = demanMtmName(mtmName, mtmLoc );
d59 1
d88 1
a88 4
  std::string name = acquireMtmName(mtmName, mtmLoc );
#if 0
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
#endif
d97 1
a97 4
  std::string name = acquireMtmName(mtmName, mtmLoc );
#if 0
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
#endif
d108 1
a108 1
  std::string name = demanMtmName(mtmName, mtmLoc );
d117 1
a117 1
  std::string name = demanMtmName(mtmName, mtmLoc );
d133 1
a133 1
    mtmLoc.push_back( locFromMtmName(mtmNames_[m]) );
d137 42
d184 11
a194 1
  std::string opName = acquireMtmName(mtmName,mtmLoc);
d209 145
d474 1
a474 1
  // link mtm demanufacturing operation with produced part
d476 1
a476 1
  std::string demanOp = demanMtmName(mtm, loc );
d482 40
a521 3
  float * prodRate = floatToConstFloatStar(0.f);
  witSetBopEntryProductRate(witRun(),demanOp.c_str(),nBops-1,prodRate);
  free(prodRate);
d524 1
a524 1
void ESO2problem::setDemanBomProdRate(
d532 3
a534 1
  std::string demanOp = demanMtmName(mtm, loc );
d540 25
d576 1
a576 1
  std::string producingOp = demanMtmName(mtm, loc );
d610 1
a610 1
// etnCsp methods
d612 1
a612 1
bool ESO2problem::etnCspBomExists(
d617 1
a617 1
  std::string ecOpName = etnCspName(upLevelPart,downLevelPart,loc);
d624 1
a624 1
void ESO2problem::addEtnCspBom(
d629 1
a629 1
  assert( !etnCspBomExists(upLevelPart,downLevelPart,loc) );
d631 1
a631 1
  std::string ecOpName = etnCspName(upLevelPart,downLevelPart,loc);  
d657 1
a657 1
  etnCspBoms_.push_back(ecOpName);
d660 1
a660 1
void ESO2problem::setEtnCspBomProdRate(
d667 1
a667 1
  std::string ecOpName = etnCspName(upLevelPart,downLevelPart,loc); 
d676 1
a676 1
void ESO2problem::setEtnCspBomCost(
d683 1
a683 1
  std::string ecOpName = etnCspName(upLevelPart,downLevelPart,loc);
d690 1
a690 1
void ESO2problem::setEtnCspBomUsageTime(
d697 1
a697 1
  std::string ecOpName = etnCspName(upLevelPart,downLevelPart,loc); 
d707 1
a707 1
void ESO2problem::getEtnCspBoms(
d715 1
a715 1
  int nItems = etnCspBoms_.size();
d718 3
a720 3
    upLevelParts.push_back( upLevelPartFromEtnCspName(etnCspBoms_[n]) );
    downLevelParts.push_back( downLevelPartFromEtnCspName(etnCspBoms_[n]) );
    locs.push_back( locFromEtnCspName(etnCspBoms_[n]) );
d724 1
a724 1
std::vector<float> ESO2problem::getEtnCspBomEcVol(
d730 1
a730 1
  std::string opName = etnCspName(upLevelPart,downLevelPart,loc);
d736 1
a736 1
// interplant methods
d738 1
a738 1
bool ESO2problem::interplantExists(
d743 1
a743 1
  std::string opName = interplantName(part,srcLoc,destLoc);
d750 1
a750 1
void ESO2problem::addInterplant(
d755 2
a756 2
  assert( !interplantExists(part,srcLoc,destLoc) );
  std::string opName = interplantName(part,srcLoc,destLoc);  
d780 1
a780 1
  interplants_.push_back(opName);
d782 1
a782 1
void ESO2problem::setInterplantMoveCost(
d789 1
a789 1
  std::string opName = interplantName(part,srcLoc,destLoc);
d796 1
a796 1
void ESO2problem::setInterplantMoveTime(
d803 1
a803 1
  std::string opName = interplantName(part,srcLoc,destLoc); 
d811 1
a811 1
void ESO2problem::getInterplants( 
d819 1
a819 1
  int nItems = interplants_.size();
d822 3
a824 3
    parts.push_back( partFromInterplantName(interplants_[n]) );
    srcLocs.push_back( srcLocFromInterplantName(interplants_[n]) );
    destLocs.push_back( destLocFromInterplantName(interplants_[n]) );
d827 1
a827 1
std::vector<float> ESO2problem::getInterplantMoveVol(
d833 1
a833 1
  std::string opName = interplantName(part,srcLoc,destLoc);
d1254 4
a1257 1
      std::string opName = acquireMtmName(mtms[m],plantLocs[m] );
d1262 27
a1288 1
      witSetNameAttribute(witSetOperationObj1ExecCost,opName, wfmvVec);      
d1324 1
a1324 1
std::string ESO2problem::igfMtmName(const std::string & mtm,const std::string & loc )
d1326 1
a1326 1
  return "igf: "+baseMtmName(mtm,loc);
d1328 1
a1328 1
std::string ESO2problem::acquireMtmName(const std::string & mtm,const std::string & loc )
d1330 1
a1330 1
  return "acquire: "+baseMtmName(mtm,loc);
d1332 1
a1332 1
std::string ESO2problem::serverMtmName(const std::string & mtm,const std::string & loc )
d1334 1
a1334 1
  return "server: "+baseMtmName(mtm,loc);
d1336 1
a1336 1
std::string ESO2problem::demanMtmName(const std::string & mtm,const std::string & loc )
d1338 1
a1338 1
  return "deman: "+baseMtmName(mtm,loc);
d1340 1
a1340 1
std::string ESO2problem::baseMtmName(const std::string & mtm,const std::string & loc )
d1342 1
a1342 1
  return "mtm "+mtm+" at "+loc;
d1348 1
a1348 1
std::string ESO2problem::locFromMtmName(const std::string & mtmName)
d1381 1
a1381 1
std::string ESO2problem::etnCspName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc)
d1385 1
a1385 1
std::string ESO2problem::downLevelPartFromEtnCspName(const std::string & etnCspName)
d1387 1
a1387 1
  return textBetween(etnCspName,"ec: "," to ");
d1389 1
a1389 1
std::string ESO2problem::upLevelPartFromEtnCspName(const std::string & etnCspName)
d1391 1
a1391 1
  return textBetween(etnCspName," to "," at ");
d1393 1
a1393 1
std::string ESO2problem::locFromEtnCspName(const std::string & etnCspName)
d1395 1
a1395 1
  return textAfter(etnCspName," at ");
d1399 1
a1399 1
// interplant Name Methods
d1401 1
a1401 1
std::string ESO2problem::interplantName(const std::string & part, const std::string & srcLoc, const std::string & destLoc)
d1405 1
a1405 1
std::string ESO2problem::partFromInterplantName(const std::string & interplantName)
d1407 1
a1407 1
  return textBetween(interplantName,"move: "," from ");
d1409 1
a1409 1
std::string ESO2problem::srcLocFromInterplantName(const std::string & interplantName)
d1411 1
a1411 1
  return textBetween(interplantName," from "," to ");
d1413 1
a1413 1
std::string ESO2problem::destLocFromInterplantName(const std::string & interplantName)
d1415 1
a1415 1
  return textAfter(interplantName," to ");
d1537 12
d1580 13
d2017 4
a2020 3
etnCspBoms_(),
interplants_(),
partDemands_()
d2071 4
a2074 3
etnCspBoms_(),
interplants_(),
partDemands_()
d2106 2
a2107 2
  etnCspBoms_  = source.etnCspBoms_;
  interplants_  = source.interplants_;
d2109 1
@


1.20
log
@Added regulator capacity to enforce demand perishability
@
text
@d151 9
d230 9
@


1.19
log
@Mtm's wfmv costs are now scaled.
@
text
@d572 2
a575 1
  bool retVal=false;
d578 1
a578 1
  witGetPartDemands(mutableWitRun(),pName.c_str(),&nDems,&dNames);
d585 8
d601 1
d603 17
a619 1
  witAddDemand(witRun(),pName.c_str(),dName.c_str());
d631 1
a631 1
  std::string pName = partName(part,plantLoc);
d633 5
a637 1
    pName, dName, period, demandVol);
d650 1
a650 1
    pName, dName, period, wac);
d679 1
a679 1
  retVal = witGetDemandAttribute(witGetDemandShipVol,pName,dName);
d690 1
a690 1
  retVal = witGetDemandAttribute(witGetDemandDemandVol,pName,dName);
d990 1
d1012 1
d1120 4
@


1.18
log
@Added mtm acquire operation appData and storing wfmv here.
@
text
@d45 1
d50 1
d938 20
a957 1
  // TO DO: add code to scale wfmv
d960 1
d1164 11
@


1.17
log
@added methods for set/getting wfmvScaleFactor
@
text
@d18 1
d49 5
d84 13
a96 1
{ 
d98 1
d100 4
@


1.16
log
@updated to write shipVol results
@
text
@d17 1
d512 27
d1035 1
a1035 1
  return textAfter(interplantName," to: ");
d1567 15
d1634 1
a1634 2
#if 0
  ILSprobAppData * problemAppData = new ILSprobAppData;
a1635 1
#endif
a1687 1
#if 0
d1690 2
a1691 2
    ILSprobAppData * srcAppData;  
    ILSprobAppData * sinkAppData;
d1693 1
a1693 1
    sinkAppData = new ILSprobAppData(*srcAppData);    
d1697 1
a1737 1
#if 0
d1740 1
a1740 1
    ILSprobAppData * probAppData;  
d1745 1
@


1.15
log
@code to write etnCsp output file has been added
@
text
@d479 2
d541 1
d570 41
d886 22
d997 12
a1008 1

d1014 13
a1026 1
  return custLoc;
d1029 1
d1144 14
d1554 3
a1556 1
etnCspBoms_()
d1609 3
a1611 1
etnCspBoms_()
d1644 2
@


1.14
log
@Renamed some methods that had overloaded names to unique names for better readability
@
text
@d174 24
d356 2
d405 29
d894 9
d911 12
d1449 2
a1450 1
featureNames_()
d1502 2
a1503 1
featureNames_()
d1535 1
@


1.13
log
@added code to write mtmAcquirePlan file
@
text
@d70 1
a70 1
  witSet(&witGetPartSupplyVol,witSetPartSupplyVol,name,period,supply);
d79 1
a79 1
  witSet(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
d88 1
a88 1
  witSet(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,demanCost);
d97 1
a97 1
  witSet(witGetBomEntryOffset,witSetBomEntryOffset,
d166 1
a166 1
  witSet(witGetPartSupplyVol,witSetPartSupplyVol,name,period,supply);
d171 1
a171 1
  witSet(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
d237 1
a237 1
  witSet(witGetBopEntryProductRate,
d343 1
a343 1
  witSet(
d358 1
a358 1
  witSet(
d373 1
a373 1
  witSet(
d433 1
a433 1
  witSet(
d447 1
a447 1
  witSet(
d911 1
a911 1
void ESO2problem::witSet(
d929 1
a929 1
void ESO2problem::witSet(
@


1.12
log
@Added solve
@
text
@a62 57
// Set element of Part/Operation float* attribute, given period and float
void ESO2problem::witSet(
    witGetNameFloatStarStar witGetFunc,
    witSetNameFloatStar     witSetFunc,
    const std::string & name,
    int period, 
    float flt )    
{ 
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetFunc(mutableWitRun(),name.c_str(),&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),name.c_str(),floatStar);
  witFree(floatStar);
}


// Set element of Bop/Bop Entry float* attribute, given period and float
void ESO2problem::witSet(
    witGetNameIndexFloatStarStar witGetFunc,
    witSetNameIndexFloatStar     witSetFunc,
    const std::string & opName,
    int index,
    int period, 
    float flt )    
{ 
  assert( period>= 0 );
  assert( period<getNPeriods() );
  //int bei = getBopEntryIndex(opName,partName);
  //assert( bei!=-1 );
  float * floatStar;
  witGetFunc(mutableWitRun(),opName.c_str(),index,&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),opName.c_str(),index,floatStar);
  witFree(floatStar);
}


// Set element on demand float* attribute, given period and fltValue
void ESO2problem::witSetDemandAttribute(
    witGetDblNameFloatStarStar      witGetFunc,
    witSetDblNameFloatStar          witSetFunc,
    const std::string & partName,
    const std::string & demandName,
    int period, 
    float flt )
{
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetFunc(mutableWitRun(),partName.c_str(),demandName.c_str(),&floatStar);
  floatStar[period] = flt;
  witSetFunc(witRun(),partName.c_str(),demandName.c_str(),floatStar);
  witFree(floatStar);
}

d102 26
d815 8
d872 75
d949 17
d967 11
@


1.11
log
@updated to read interplant and partDemand files
@
text
@a153 9
#if 0
  assert( period>= 0 );
  assert( period<getNPeriods() );
  float * floatStar;
  witGetBomEntryOffset(mutableWitRun(),name.c_str(),0,&floatStar);
  floatStar[period] = time;
  witSetBomEntryOffset(witRun(),name.c_str(),0,floatStar);
  witFree(floatStar);
#else
a155 1
#endif
a173 3
#if 0
  witAddPart(witRun(), serverFeatureWitName.c_str(), WitCAPACITY);
#else
a174 1
#endif
a271 10
#if 0
  int be = getBopEntryIndex(mtm,part,loc);
  assert( be!=-1 );
  
  float * floatStar;
  witGetBopEntryProductRate(mutableWitRun(),demanOp.c_str(),be,&floatStar);
  floatStar[period] = prodRate;
  witSetBopEntryProductRate(witRun(),demanOp.c_str(),be,floatStar);
  witFree(floatStar);
#endif
d448 3
a477 1
  //std::string producedPart = partName(upLevelPart,loc);
d811 11
a1718 95
}
#endif

#if 0
// Optimization function
void ESO2problem::solve()
{

  std::vector<float> probGrid = getProbabilityGrid();

  // create demandVol vector and zero vector
  int np=getNPeriods();
  float * tv=new float[np];
  float * zero=new float[np];
  float * projExecVolHLB=new float[np];
  int t=0;
  for(t=0;t<np;t++) {tv[t]=0.0; zero[t]=0.0; projExecVolHLB[t]=0.0;}
  tv[0]=1.0;

  // Get list of all projects
  std::vector<std::string> projects;
  getProjects(projects);

  // Get list of all resources
  std::vector<std::string> roles;
  std::vector<int>  bands;
  getResources(roles,bands);

  // loop once for each point in grid
  int g;
  for( g=0; g<probGrid.size(); g++ ) {

    // set demandVol
    int p;
    for(p=0; p<projects.size(); p++) {
      float projProb = getProjectCloseProb(projects[p]);
      if ( projProb>=probGrid[g] ) {
        witSetDemandDemandVol(witRun(),projects[p].c_str(),projects[p].c_str(),tv);
      }
      else {
        witSetDemandDemandVol(witRun(),projects[p].c_str(),projects[p].c_str(),zero);
      }
    }

    witOptImplode (witRun());

    // Loop once for each resource
    // Get the resource's consVol and save it in appData
    int r;
    for(r=0; r<roles.size(); r++) {

      // get consVol for prob<=gridProb[g] and save in app date
      ILSresrcAppData * appData;
      float * cv;
      std::string resrcName;

      // IBM Resource Cons Vol
      resrcName = ibmBenchResourceName(roles[r],bands[r]);
      witGetPartConsVol(mutableWitRun(),resrcName.c_str(),&cv);
      witGetPartAppData(mutableWitRun(), resrcName.c_str(), (void**)&appData);
      appData->pushConsVol(witFloatStarToStlVec(cv));
      witFree(cv);

      // Contractor Resource Cons Vol
      resrcName = contrBenchResourceName(roles[r],bands[r]);
      witGetPartConsVol(mutableWitRun(),resrcName.c_str(),&cv);
      witGetPartAppData(mutableWitRun(), resrcName.c_str(), (void**)&appData);
      appData->pushConsVol(witFloatStarToStlVec(cv));
      witFree(cv);
    }
    
    // Ensure that the projects presently executed,
    // will again be executed on next iteration of g for loop.
    for(p=0; p<projects.size(); p++) {
      float * ev;
      witGetOperationExecVol(mutableWitRun(),projects[p].c_str(),&ev);
      
      // if this is the last g loop iteration, then don't set
      // ExecBounds so FSS will work.
      if ( g+1<probGrid.size() ) {
        projExecVolHLB[0] = ev[0];
        witSetOperationExecBounds(witRun(),projects[p].c_str(),
          projExecVolHLB,projExecVolHLB,NULL);
      }
      
      ILSprojAppData * appData;
      witGetPartAppData(mutableWitRun(), projects[p].c_str(), (void**)&appData);
      appData->pushExecVol(ev[0]);
      witFree(ev);
    }
  }

  delete [] projExecVolHLB;
  delete [] tv;
  delete [] zero;
@


1.10
log
@setting etnCsp usageTime attribute
@
text
@d102 18
d341 1
a341 1
// Methods for projects. To be added.
d433 118
a550 1
}  
d552 12
d874 7
d883 9
a891 1
// part Name Methods
d893 1
a893 1
std::string ESO2problem::partName(const std::string & part,const std::string & loc )
d895 1
a895 1
  return "part: "+part+" at "+loc;
d899 1
a899 1
// etnCsp Name Methods
d901 1
a901 1
std::string ESO2problem::etnCspName(const std::string & upLevelPart, const std::string & downLevelPart, const std::string & loc)
d903 1
a903 1
  return "ec: "+downLevelPart+" to "+upLevelPart+" at "+loc;
d908 1
d1311 1
a1311 1
  //witSetMesgTimesPrint( witRun(), WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
@


1.9
log
@setting more etnCsp attributes. More still to do.
@
text
@d81 4
a84 4
// Set element of Bop Entry float* attribute, given period and float
void ESO2problem::witSetBop(
    witGetNameBopIndexFloatStarStar witGetFunc,
    witSetNameBopIndexFloatStar     witSetFunc,
d86 1
a86 1
    const std::string & partName,
d92 2
a93 2
  int bei = getBopEntryIndex(opName,partName);
  assert( bei!=-1 );
d95 1
a95 1
  witGetFunc(mutableWitRun(),opName.c_str(),bei,&floatStar);
d97 1
a97 1
  witSetFunc(witRun(),opName.c_str(),bei,floatStar);
d101 1
d136 1
a136 1
  
d144 4
d263 2
a264 1
  witSetBop(witGetBopEntryProductRate,
d266 1
a266 1
    demanOp, producedPart,
d379 2
a380 2
  std::string producedPart = partName(upLevelPart,loc);
  witSetBop(
d383 1
a383 1
    ecOpName, producedPart,
d401 15
@


1.8
log
@Updated to show that an upLevelPart can be created from different down levelParts
@
text
@d80 21
a255 3
  assert( period>= 0 );
  assert( period<getNPeriods() );

d258 5
a262 1

d271 1
a271 1

a280 2
  int retVal = -1;
  
d284 1
d286 11
d301 1
a301 1
  witGetOperationNBopEntries(mutableWitRun(),producingOp.c_str(),&nBops);
d306 2
a307 2
    witGetBopEntryProducedPart(mutableWitRun(),producingOp.c_str(),bei,&prodPartFromWit);
    if(producedPart==prodPartFromWit) retVal=bei;
a350 2
  else
    cout <<"hello";
d364 32
@


1.7
log
@adding etnCsp structures, not yet setting attributes
@
text
@d319 2
@


1.6
log
@removed more references to usageTime from file formats in demanBom.
updated code to set demanBom prodRate to default value specified in file formats.
@
text
@d283 51
d650 10
@


1.5
log
@Changes to read demanBom file
@
text
@d219 7
@


1.4
log
@added code to set feature supply and wfmv
@
text
@d132 1
a132 1
  std::string serverFeatureWitName = serverFeatureName(featureName, featureLoc );
d140 1
d142 3
d176 100
a578 4
std::string ESO2problem::serverFeatureName(const std::string & feature,const std::string & loc )
{
  return "server: "+baseFeatureName(feature,loc);
}
d584 8
@


1.3
log
@added code to process feature file
@
text
@d96 1
a96 1
  witSet(&witGetOperationObj1ExecCost,&witSetOperationObj1ExecCost,name,period,wholeSaleFairMarketValue);
d105 1
a105 1
  witSet(&witGetOperationObj1ExecCost,&witSetOperationObj1ExecCost,name,period,demanCost);
d162 2
d165 4
a168 2
void ESO2problem::setFeatureWfmv(const std::string & featureName, const std::string & featureLoc, int period, float supply )
{
@


1.2
log
@added setting of demanCost
@
text
@d20 3
d89 9
d107 60
d460 20
d909 1
@


1.1
log
@updated to add eso2Problem class and eso2 main program
@
text
@d59 18
d83 11
a93 8
  assert( period>= 0 );
  assert( period<getNPeriods() );
  std::string igfMtmWitName = igfMtmName(mtmName, mtmLoc );
  float * supplyVol;
  witGetPartSupplyVol(mutableWitRun(),igfMtmWitName.c_str(),&supplyVol);
  supplyVol[period] = supply;
  witSetPartSupplyVol(witRun(),igfMtmWitName.c_str(),supplyVol);
  witFree(supplyVol);
d791 1
a791 1
  witSetMesgTimesPrint( witRun(), WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
@


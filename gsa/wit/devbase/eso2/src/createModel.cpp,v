head	1.48;
access;
symbols
	abandoningEtnParts:1.31
	beforeEtnParts:1.30;
locks; strict;
comment	@// @;


1.48
date	2008.02.15.01.13.58;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.16.14.31.46;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.31.09.28.49;	author fasano;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.02.30.59;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.02.15.04.39;	author fasano;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.27.02.19.05;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.24.17.14.26;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.14.16.56.25;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.12.18.44.39;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.07.16.57.14;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.07.03.27.53;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.03.20.05.57;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.03.13.50.26;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.29.02.16.43;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.29.18.27.37;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.21.17.23.50;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.21.14.21.11;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.19.19.43.35;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.08.15.35.00;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.15.20.23.30;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.10.22.24.01;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.31.16.50.29;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.29.19.16.00;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.24.23.05.57;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.24.23.02.44;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.24.22.46.34;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.24.22.23.04;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.24.22.17.07;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.24.21.58.21;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.16.15.11.08;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.08.15.36.45;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.29.13.20.50;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.14.18.49.52;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.24.20.11.24;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.21.19.33.38;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.30.01.32.07;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.18.21.10.56;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.18.21.05.31;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.18.20.48.18;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.18.14.33.47;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.17.14.08.47;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.17.13.06.13;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.17.01.26.47;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.15.20.19.25;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.12.01.21.18;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.11.01.19.45;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.11.00.22.33;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.04.22.06.12;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Changes to add code to remove cycles. Also removes some pruning messages.
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#endif


#include "wit.h"

#include <map>
#include <vector>
#include <algorithm>

#include <cassert>
#include <iostream>
#include <cfloat>
#include <cctype>
#include <cmath>


#include "eso2.h"
#include "globalAttrData.h"
#include "mtmData.h"
#include "applyScaleFactorLocData.h"
#include "featureData.h"
#include "featureXrefData.h"
#include "featureConversionData.h"
#include "featureConversionOverrideData.h"
#include "loosePartData.h"
#include "mtmDemanBomData.h"
#include "altData.h"
#include "altExcludeLocData.h"
#include "altOverrideData.h"
#include "partInterplantData.h"
#include "partInterplantOverrideData.h"
#include "mtmInterplantData.h"
#include "mtmInterplantOverrideData.h"
#include "partDemandData.h"
#include "demanData.h"
#include "demanOverrideData.h"
#include "eso2Problem.h"


typedef std::vector<std::string> StdStringVec;


// Add all interplant moves from the specified mtm & srcLoc
// This is not a recursive function because an mtm is only moved once.
void addAllMtmInterplants(
                    ESO2problem & eso2Prob,
                    std::map<std::string,StdStringVec> srcToDestLocs,
                    const ESO2mtmInterplantData & mtmInterplantFile,
                    const ESO2demanData & demanFile,
                    const ESO2demanOverrideData & demanOverrideFile,
                    const std::string & mtm,
                    const std::string & srcLoc)
{
  int nPeriods = eso2Prob.getNPeriods();
  const StdStringVec & destLocs = srcToDestLocs[srcLoc];

  // Loop once for each destination location
  size_t l=0;
  for ( l=0; l<destLocs.size(); l++ ) {
    std::string destLoc = destLocs[l];
    // does mtm at dest loc exist
    bool mtmExist = eso2Prob.mtmExists(mtm,destLoc);
    
    // If link between srcLoc and destLoc for part does not exist, then add it to model
    if ( !eso2Prob.mtmInterplantExists(mtm,srcLoc,destLoc ) ) {
      
      // Get default move cost and time between srcLoc and destLoc
      float defaultMoveCost = ESO2problem::bigM();
      float defaultMoveTime = 0.0f;
      if ( mtmInterplantFile.keyExists(srcLoc,destLoc) ) {
        defaultMoveCost = mtmInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
        defaultMoveTime = mtmInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
      }
      else {
        // Default mtm interplant move time and cost does not exist
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: default mtm interplant move time and cost does not exist in mtmInterplantData file" <<std::endl
          <<"   mtmInterplantData filename: " <<mtmInterplantFile.filename().c_str()   <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
          <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
          <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<std::endl
          <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
      }
           
      eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
      
      // Get demanufacturing time and cost
      float demanCostDefault = ESO2problem::bigM();
      float demanTimeDefault = (float)nPeriods+1;
      bool usingDefault=true;
      std::vector<float> demanCost = eso2Prob.floatToStlVec(demanCostDefault);
      std::vector<float> demanTime = eso2Prob.floatToStlVec(demanTimeDefault);
      if ( demanFile.keyExists(destLoc) ) {
         demanCost = eso2Prob.floatToStlVec(demanFile.demanCostAsFloat(destLoc));
         demanTime = eso2Prob.floatToStlVec(demanFile.demanTimeAsFloat(destLoc));
         usingDefault=false;
      }   
      // Loop once for each period looking for demanCost and demanTime 
      for ( int p=0; p<nPeriods; p++ ) {
        std::string keyO = demanOverrideFile.key(mtm,destLoc,p);
        if ( demanOverrideFile.keyExists(keyO) ) {
          demanCost[p] = demanOverrideFile.demanCostAsFloat(keyO);
          demanTime[p] = demanOverrideFile.demanTimeAsFloat(keyO);
          usingDefault=false;
        }
      }
      if (usingDefault) {
            // No demanufacturing cost or time specified
            std::cout 
              <<"-------------------------------------------------------"        <<std::endl
              <<"Warning: An mtm interplant does not have a demanufacturing cost or time specified."   <<std::endl
              <<"   mtmInterplant filename: " <<mtmInterplantFile.filename().c_str()                 <<std::endl
              <<"   mtm: " <<mtm.c_str()                                         <<std::endl
              <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
              <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
              <<"   deman filename: " <<demanFile.filename().c_str()             <<std::endl
              <<"   demanOverride filename: " <<demanOverrideFile.filename().c_str()     <<std::endl
              <<"   A demanCost of " <<demanCostDefault <<" will be used."              <<std::endl
              <<"   A demanTime of " <<demanTimeDefault <<" will be used."              <<std::endl
              <<"-------------------------------------------------------"        <<std::endl;
      }
      
      
      eso2Prob.setMtmDemanCost(mtm,srcLoc, destLoc,demanCost);
      eso2Prob.setMtmDemanTime(mtm,srcLoc, destLoc,demanTime);
      
    } // end adding interplant.

    //if ( !mtmExist ) {
    //  addAllMtmInterplants( eso2Prob, srcToDestLocs, mtmInterplantFile, mtm, destLoc);
    //}
  }  // end for l 
}

void createModel(
                 ESO2problem & eso2Prob, 
                 const std::string & inputDirectory,
                 bool useGlobalAttrFileSettings  )
{
  std::cout <<"Reading input files" <<std::endl;
  
  int nPeriods;      

  // Set up interplant moves info
  typedef std::vector<std::string> StdStringVec;
  //std::map<std::string,StdStringVec> partSrcToDests;
  std::map<std::string,StdStringVec> mtmSrcToDests;
  
  // Read Global Attributes
  std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
  ESO2globalAttrData globalAttrFile(globalAttrFileName);
  {      
    std::string title=globalAttrFile.fieldAsString("title","attrValue");
    eso2Prob.setTitle(title);
    
    nPeriods=globalAttrFile.fieldAsInt("nPeriods","attrValue");
    eso2Prob.setNPeriods(nPeriods);

    // Handle period1SupplyPerishPeriod attribute
    {
      bool attrExists = globalAttrFile.keyExists("period1SupplyPerishPeriod");
      if ( !attrExists ) {
        // Priority attribute does not exist
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Error: period1SupplyPerishPeriod not specified."                <<std::endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
          <<"   valid range: 1<=period1SupplyPerishPeriod<=" <<nPeriods      <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        exit(1);
      }
      
      int period1SupplyPerishPeriod = globalAttrFile.fieldAsInt("period1SupplyPerishPeriod","attrValue");
      if ( period1SupplyPerishPeriod<1 || period1SupplyPerishPeriod>nPeriods ) {
        // period1SupplyPerishPeriod is out of range
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Error: period1SupplyPerishPeriod is out of range."              <<std::endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
          <<"   period1SupplyPerishPeriod: " <<period1SupplyPerishPeriod     <<std::endl
          <<"   valid range: 1<=period1SupplyPerishPeriod<=" <<nPeriods      <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        exit(1);
      }         

      // Check to see if perishPeriod is to be set using value obtained from globalAttr file.
      // In unitTest this is skipped some many perishPeriod can be run.
      if ( useGlobalAttrFileSettings ) {        
        eso2Prob.setPeriod1SupplyPerishPeriod(period1SupplyPerishPeriod-1);
      }
    } // end of Handle period1SupplyPerishPeriod attribute

    // Handle allowInventoryHoldingAtDemandLocation attribute
    {
      bool attrExists = globalAttrFile.keyExists("allowInventoryHoldingAtDemandLocation");
      bool allowInventoryHoldingAtDemandLocation = false;
      
      if ( !attrExists ) {
      // allowInventoryHoldingAtDemandLocation attribute does not exist
      std::cout 
      <<"-------------------------------------------------------"        <<std::endl
      <<"Error: allowInventoryHoldingAtDemandLocation not specified."    <<std::endl
      <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
      <<"   valid range: 0<=allowInventoryHoldingAtDemandLocation<=1"    <<std::endl
      <<"-------------------------------------------------------"        <<std::endl;
      exit(1);
      }

      if ( attrExists ) {
        int allowInventoryHoldingAtDemandLocationAsInt = globalAttrFile.fieldAsInt("allowInventoryHoldingAtDemandLocation","attrValue");
        if ( allowInventoryHoldingAtDemandLocationAsInt<0 || allowInventoryHoldingAtDemandLocationAsInt>1 ) {
          // allowInventoryHoldingAtDemandLocation is out of range
          std::cout 
            <<"-------------------------------------------------------"                                 <<std::endl
            <<"Error: allowInventoryHoldingAtDemandLocation is out of range."                           <<std::endl
            <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()                           <<std::endl
            <<"   allowInventoryHoldingAtDemandLocation: " <<allowInventoryHoldingAtDemandLocationAsInt <<std::endl
            <<"   valid range: 0<=allowInventoryHoldingAtDemandLocation<=1"                             <<std::endl
            <<"-------------------------------------------------------"                                 <<std::endl;
          exit(1);
        }  
        if (allowInventoryHoldingAtDemandLocationAsInt==1)
          allowInventoryHoldingAtDemandLocation = true;
      }

      // Check to see if allowInventoryHoldingAtDemandLocation is to be set using value obtained from globalAttr file.
      // In unitTest this is skipped some many perishPeriod can be run.
      if ( useGlobalAttrFileSettings ) {        
        eso2Prob.setAllowInventoryHoldingAtDemandLocation(allowInventoryHoldingAtDemandLocation);
      }
    }  // End of Handle allowInventoryHoldingAtDemandLocation attribute


    // Handle removeCycles attribute
    {
      bool attrExists = globalAttrFile.keyExists("removeCycles");
      bool removeCycles = false;
      
      if ( !attrExists ) {
      // removeCycles attribute does not exist
      std::cout 
      <<"-------------------------------------------------------"        <<std::endl
      <<"Error: removeCycles not specified."    <<std::endl
      <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
      <<"   valid range: 0<=removeCycles<=1"    <<std::endl
      <<"-------------------------------------------------------"        <<std::endl;
      exit(1);
      }

      if ( attrExists ) {
        int removeCyclesAsInt = globalAttrFile.fieldAsInt("removeCycles","attrValue");
        if ( removeCyclesAsInt<0 || removeCyclesAsInt>1 ) {
          // removeCycles is out of range
          std::cout 
            <<"-------------------------------------------------------"                                 <<std::endl
            <<"Error: removeCycles is out of range."                           <<std::endl
            <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()                           <<std::endl
            <<"   removeCycles: " <<removeCyclesAsInt <<std::endl
            <<"   valid range: 0<=removeCycles<=1"                             <<std::endl
            <<"-------------------------------------------------------"                                 <<std::endl;
          exit(1);
        }  
        if (removeCyclesAsInt==1)
          removeCycles = true;
      }

      // Check to see if removeCycles is to be set using value obtained from globalAttr file.
      // In unitTest this is skipped some many perishPeriod can be run.
      if ( useGlobalAttrFileSettings ) {        
        eso2Prob.setRemoveCycles(removeCycles);
      }
    }  // End of Handle removeCycles attribute










    // Handle wacScaleFactor & wacScaleFactor1 Attributes
    {
      std::vector<std::string> wacScaleFactorAttrNames;
      wacScaleFactorAttrNames.push_back("wacScaleFactor");
      wacScaleFactorAttrNames.push_back("wac2ScaleFactor");
      std::vector<float> wacScaleFactors;

        // loop once for each scale factor
        for (size_t a=0; a<wacScaleFactorAttrNames.size(); ++a ) {
          bool attrExists = globalAttrFile.keyExists(wacScaleFactorAttrNames[a]);
          if ( !attrExists ) {
            // Priority attribute does not exist
            std::cout 
              <<"-------------------------------------------------------"        <<std::endl
              <<"Error: "+wacScaleFactorAttrNames[a]+" not specified."           <<std::endl
              <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
              <<"-------------------------------------------------------"        <<std::endl;
            exit(1);
          }

          float wacScaleFactor = globalAttrFile.fieldAsFloat(wacScaleFactorAttrNames[a],"attrValue");
          wacScaleFactors.push_back(wacScaleFactor);
        }  // end loop for each scale factor 

        // Set the scale factors.
        eso2Prob.setWacScaleFactors(wacScaleFactors[0],wacScaleFactors[1]);
    } // end handling wacScaleFactor & wacScaleFactor1 Attributes

    // Does useApplyScaleFactorLocData in global attribute file indicate that useApplyScaleFactorLocData should be used?
    std::string useApplyScaleFactorLocData = globalAttrFile.fieldAsString("useApplyScaleFactorLocData","attrValue");
    std::transform(
        useApplyScaleFactorLocData.begin(), 
        useApplyScaleFactorLocData.end(), 
        useApplyScaleFactorLocData.begin(),
        (int(*)(int)) std::toupper);
    if ( useApplyScaleFactorLocData=="N" || useApplyScaleFactorLocData=="NO" ) {
        std::cout <<"Not using useApplyScaleFactorLocData" <<std::endl;
        eso2Prob.setUseApplyScaleFactorLoc(false);
    } else {

        std::cout <<"Using useApplyScaleFactorLocData" <<std::endl;
        eso2Prob.setUseApplyScaleFactorLoc(true);

        // Read applyScaleFactorLoc file
        {  
            std::string applyScaleFactorLocFileName = inputDirectory + "/applyScaleFactorLocData.csv";
            ESO2applyScaleFactorLocData applyScaleFactorLocFile(applyScaleFactorLocFileName);

            ESO2applyScaleFactorLocDataIterator applyScaleFactorLocFileIter(applyScaleFactorLocFile);

            // loop once for each record in partInterplant file
            for ( ; applyScaleFactorLocFileIter()!=NULL; ) {
                std::string plantLoc = applyScaleFactorLocFileIter.plantLoc();
                int demandFileNumber = applyScaleFactorLocFileIter.partDemandFileNumberAsInt();
                eso2Prob.setApplyLocWfmvScaleFactor(plantLoc,demandFileNumber);
            }

        } // end of read applyScaleFactorLoc file
    }  // else part of "if ( useApplyScaleFactorLocData=="N" || useApplyScaleFactorLocData=="NO" )"

    std::vector<std::string> priorities;
    priorities.push_back("mtmPriority");
    priorities.push_back("featurePriority");
    priorities.push_back("loosePartPriority");
    priorities.push_back("mtm2Priority");
    priorities.push_back("feature2Priority");
    priorities.push_back("loosePart2Priority");
    size_t p;
    for ( p=0; p<priorities.size(); ++p ) {
      bool attrExists = globalAttrFile.keyExists(priorities[p]);
      if ( !attrExists ) {
        // Priority attribute does not exist
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Error: " <<priorities[p].c_str() <<" not specified."            <<std::endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
          <<"   valid range: 1<=" <<priorities[p].c_str() <<"<=4"            <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        exit(1);
      }
      int priority = globalAttrFile.fieldAsInt(priorities[p],"attrValue");
      if ( priority<1 || priority>4 ) {
        // Priority is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Error: " <<priorities[p].c_str() <<" is out of allowed range"   <<std::endl
          <<"   gloabalAttr filename: " <<globalAttrFile.filename().c_str()  <<std::endl
          <<"   " <<priorities[p].c_str() <<": " <<globalAttrFile.fieldAsString(priorities[p],"attrValue").c_str() <<std::endl
          <<"   valid range: 1<=" <<priorities[p].c_str() <<"<=4"            <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        exit(1);
      }
      if ( p==0 ) eso2Prob.setMtmPriority(priority);
      else if ( p==1 )  eso2Prob.setFeaturePriority(priority);
      else if ( p==2 )  eso2Prob.setLoosePartPriority(priority);
      else if ( p==3 )  eso2Prob.setMtm2Priority(priority);
      else if ( p==4 )  eso2Prob.setFeature2Priority(priority);
      else if ( p==5 )  eso2Prob.setLoosePart2Priority(priority);
    }
  }

  // Read part interplant File and set up structures for using data
  std::cout <<"Reading input file: partInterplantData" <<std::endl;
  std::string partInterplantFileName = inputDirectory + "/partInterplantData.csv";
  ESO2partInterplantData partInterplantFile(partInterplantFileName);
  {
    ESO2partInterplantDataIterator partInterplantFileIter(partInterplantFile);
    
    // loop once for each record in partInterplant file
    for ( ; partInterplantFileIter()!=NULL; ) {
      std::string srcLoc = partInterplantFileIter.srcLoc();
      std::string destLoc = partInterplantFileIter.destLoc();
      float defaultMoveCost = partInterplantFileIter.defaultMoveCostAsFloat();
      float defaultMoveTime = partInterplantFileIter.defaultMoveTimeAsFloat();
      eso2Prob.addPartsInterplant(srcLoc,destLoc,defaultMoveCost,defaultMoveTime);      
    }
  }

  // Read mtm interplant File and set up structures for using data
  std::string mtmInterplantFileName = inputDirectory + "/mtmInterplantData.csv";
  ESO2mtmInterplantData mtmInterplantFile(mtmInterplantFileName);
  {
    ESO2mtmInterplantDataIterator mtmInterplantFileIter(mtmInterplantFile);
    
    // loop once for each record in partInterplant file
    for ( ; mtmInterplantFileIter()!=NULL; ) {
      std::string srcLoc = mtmInterplantFileIter.srcLoc();
      std::string destLoc = mtmInterplantFileIter.destLoc();
      mtmSrcToDests[srcLoc].push_back(destLoc);     
    }
  }
  
  
  // Read MTM File, and demanFiles
  {
    std::cout <<"Reading input file: mtmData" <<std::endl;
    
    std::string mtmFileName = inputDirectory + "/mtmData.csv";
    ESO2mtmData mtmFile(mtmFileName);
    ESO2mtmDataIterator mtmFileIter(mtmFile);
    
    std::string demanFileName = inputDirectory + "/demanData.csv";
    ESO2demanData demanFile(demanFileName);
    
    std::string demanOverrideFileName = inputDirectory + "/demanOverrideData.csv";
    ESO2demanOverrideData demanOverrideFile(demanOverrideFileName);
    
    // loop once for each record in mtm file
    for ( ; mtmFileIter()!=NULL; ) {
      std::string mtm = mtmFileIter.mtm();
      std::string plantLoc = mtmFileIter.plantLoc();
      int period = mtmFileIter.periodAsInt();
      float supply = mtmFileIter.supplyAsFloat();
      float wfmv = mtmFileIter.wfmvAsFloat();
      //float demanCost = mtmFileIter.demanCostAsFloat();
      //float demanTime = mtmFileIter.demanTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   mtm filename: " <<mtmFile.filename().c_str()                 <<std::endl
          <<"   mtm file line number: " <<mtmFileIter.recNum()               <<std::endl
          <<"   mtm: " <<mtm.c_str()                                         <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }

      // Get demanufacturing time and cost
      float demanCost = ESO2problem::bigM();
      float demanTime = (float)nPeriods+1;
      
      // Add Mtm if it has not been created
      bool addedMtm = false;
      if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
        
        if ( demanFile.keyExists(plantLoc) ) {
          demanCost = demanFile.demanCostAsFloat(plantLoc);
          demanTime = demanFile.demanTimeAsFloat(plantLoc);
        }
        
        addedMtm=true;
        eso2Prob.addMtm(mtm,plantLoc,demanCost,demanTime);
      }

      {
        std::string keyO = demanOverrideFile.key(mtm,plantLoc,period);
        if ( demanOverrideFile.keyExists(keyO) ) {
          demanCost = demanOverrideFile.demanCostAsFloat(keyO);
          demanTime = demanOverrideFile.demanTimeAsFloat(keyO);
        }
        else {
          if ( demanFile.keyExists(plantLoc) ) {
            demanCost = demanFile.demanCostAsFloat(plantLoc);
            demanTime = demanFile.demanTimeAsFloat(plantLoc);
          }
          else {
            // No demanufacturing cost or time specified
            std::cout 
              <<"-------------------------------------------------------"        <<std::endl
              <<"Warning: An mtm does not have a demanufacturing cost or time specified."   <<std::endl
              <<"   mtm filename: " <<mtmFile.filename().c_str()                 <<std::endl
              <<"   mtm file line number: " <<mtmFileIter.recNum()               <<std::endl
              <<"   mtm: " <<mtm.c_str()                                         <<std::endl
              <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
              <<"   period: " <<period                                           <<std::endl
              <<"   deman filename: " <<demanFile.filename().c_str()             <<std::endl
              <<"   demanOverride filename: " <<demanOverrideFile.filename().c_str()     <<std::endl
              <<"   A demanCost of " <<demanCost <<" will be used."              <<std::endl
              <<"   A demanTime of " <<demanTime <<" will be used."              <<std::endl
              <<"-------------------------------------------------------"        <<std::endl;
          }
        }
      }
      
      eso2Prob.setMtmSupply(mtm,plantLoc,period-1,supply);
      eso2Prob.setMtmWfmv(mtm,plantLoc,period-1,wfmv);
      eso2Prob.setMtmDemanCost(mtm,plantLoc,period-1,demanCost);
      eso2Prob.setMtmDemanTime(mtm,plantLoc,period-1,demanTime);
        
      addAllMtmInterplants(
        eso2Prob, mtmSrcToDests, 
        mtmInterplantFile, demanFile, demanOverrideFile, 
        mtm,plantLoc);
      
    } // end loop reading mtm file record
  } // end of block reading mtm file

  // Read mtmInterplantOverride File
  {
    std::cout <<"Reading input file: mtmInterplantOverrideData" <<std::endl;
    std::string mtmInterplantOverrideFileName = inputDirectory + "/mtmInterplantOverrideData.csv";
    ESO2mtmInterplantOverrideData mtmInterplantOverrideFile(mtmInterplantOverrideFileName);
    ESO2mtmInterplantOverrideDataIterator mtmInterplantOverrideFileIter(mtmInterplantOverrideFile);
    
    // loop once for each record in mtmInterplant file
    for ( ; mtmInterplantOverrideFileIter()!=NULL; ) {
      std::string mtm = mtmInterplantOverrideFileIter.mtm();
      std::string srcLoc = mtmInterplantOverrideFileIter.srcLoc();
      std::string destLoc = mtmInterplantOverrideFileIter.destLoc();
      int period = mtmInterplantOverrideFileIter.periodAsInt();
      float moveCost = mtmInterplantOverrideFileIter.moveCostAsFloat();
      float moveTime = mtmInterplantOverrideFileIter.moveTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<std::endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<std::endl
          <<"   mtmInterplant: " <<mtm.c_str()                               <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl           
          <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
             
      // Test to make sure mtm exists
      if ( !eso2Prob.mtmExists(mtm,srcLoc) ) {
        // mtm does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"      <<std::endl
          <<"Warning: mtm at srcLoc does not exist"                        <<std::endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<std::endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<std::endl
          <<"   mtmInterplant: " <<mtm.c_str()                             <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                 <<std::endl          
          <<"   destLoc: " <<destLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                         <<std::endl
          <<"   record will be ignored. "                                  <<std::endl
          <<"-------------------------------------------------------"      <<std::endl;
        continue;
      }  
      
      // Test to make sure not interplanting to self
      if ( srcLoc==destLoc ) {
        // can not interplant to self
        std::cout 
          <<"-------------------------------------------------------"      <<std::endl
          <<"Warning: srcLoc and destLoc are same location"                <<std::endl
          <<"   mtmInterplant filename: " <<mtmInterplantOverrideFile.filename().c_str()   <<std::endl
          <<"   mtmInterplant file line number: " <<mtmInterplantOverrideFileIter.recNum() <<std::endl
          <<"   mtmInterplant: " <<mtm.c_str()                             <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                 <<std::endl          
          <<"   destLoc: " <<destLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                         <<std::endl
          <<"   record will be ignored. "                                  <<std::endl
          <<"-------------------------------------------------------"      <<std::endl;
        continue;
      }

      // if mtmInterplant connection does not exist, then add it
      if ( !eso2Prob.mtmInterplantExists(mtm,srcLoc,destLoc) ) {
        // add mtmInterplant connection
        
        // Get default move cost and time between srcLoc and destLoc
        float defaultMoveCost = ESO2problem::bigM();
        float defaultMoveTime = 0.0f;
        if ( mtmInterplantFile.keyExists(srcLoc,destLoc) ) {
          defaultMoveCost = mtmInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
          defaultMoveTime = mtmInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
        }
        else {
          // Default part interplant move time and cost does not exist
          std::cout 
            <<"-------------------------------------------------------"        <<std::endl
            <<"Warning: default mtm interplant move time and cost does not exist in mtmInterplantData file" <<std::endl
            <<"   mtmInterplantData filename: " <<mtmInterplantFile.filename().c_str()   <<std::endl
            <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
            <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
            <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<std::endl
            <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<std::endl
            <<"-------------------------------------------------------"        <<std::endl;
        }
        eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
      }
      
      eso2Prob.setMtmInterplantMoveCost(mtm,srcLoc,destLoc,period-1,moveCost);
      eso2Prob.setMtmInterplantMoveTime(mtm,srcLoc,destLoc,period-1,moveTime);
      
    } // end loop reading mtmInterplant file record
  } // end of block reading mtmInterplant file





  
  // Read Feature File
  {
    std::cout <<"Reading input file: featureData" <<std::endl;
    std::string featureFileName = inputDirectory + "/featureData.csv";
    ESO2featureData featureFile(featureFileName);
    ESO2featureDataIterator featureFileIter(featureFile);
    
    // loop once for each record in feature file
    for ( ; featureFileIter()!=NULL; ) {
      std::string feature = featureFileIter.feature();
      std::string plantLoc = featureFileIter.plantLoc();
      int period = featureFileIter.periodAsInt();
      float supply = featureFileIter.supplyAsFloat();
      float wfmv = featureFileIter.wfmvAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   feature filename: " <<featureFile.filename().c_str()         <<std::endl
          <<"   feature file line number: " <<featureFileIter.recNum()       <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      if ( !eso2Prob.featureExists(feature,plantLoc) ) {
        eso2Prob.addFeature(feature,plantLoc);
      }
      
      eso2Prob.setFeatureSupply(feature,plantLoc,period-1,supply);
      eso2Prob.setFeatureWfmv(feature,plantLoc,period-1,wfmv);
      
    } // end loop reading feature file record
  } // end of block reading feature file
  

  

  
  // Read LoosePart File
  {
    std::cout <<"Reading input file: loosePartData" <<std::endl;
    std::string loosePartFileName = inputDirectory + "/loosePartData.csv";
    ESO2loosePartData loosePartFile(loosePartFileName);
    ESO2loosePartDataIterator loosePartFileIter(loosePartFile);
    
    // loop once for each record in loosePart file
    for ( ; loosePartFileIter()!=NULL; ) {
      std::string loosePart = loosePartFileIter.part();
      std::string plantLoc = loosePartFileIter.plantLoc();
      int period = loosePartFileIter.periodAsInt();
      float supply = loosePartFileIter.supplyAsFloat();
      float wfmv = loosePartFileIter.wfmvAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   loosePart filename: " <<loosePartFile.filename().c_str()         <<std::endl
          <<"   loosePart file line number: " <<loosePartFileIter.recNum()       <<std::endl
          <<"   part: " <<loosePart.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      if ( !eso2Prob.loosePartExists(loosePart,plantLoc) ) {
        eso2Prob.addLoosePart(loosePart,plantLoc);
#if 0
        // add move to all destLocs
        addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, loosePart,plantLoc);
#endif
      }
      
      eso2Prob.setLoosePartSupply(loosePart,plantLoc,period-1,supply);
      eso2Prob.setLoosePartWfmv(loosePart,plantLoc,period-1,wfmv);
      
    } // end loop reading loosePart file record
  } // end of block reading loosePart file
  
  // Read Mtm Demanufacturing Bom File
  {
    std::cout <<"Reading input file: mtmDemanBomData" <<std::endl;
    std::string mtmDemanBomFileName = inputDirectory + "/mtmDemanBomData.csv";
    ESO2mtmDemanBomData mtmDemanBomFile(mtmDemanBomFileName);
    ESO2mtmDemanBomDataIterator mtmDemanBomFileIter(mtmDemanBomFile);
    
    // loop once for each record in mtmDemanBom file
    for ( ; mtmDemanBomFileIter()!=NULL; ) {
      if ( (mtmDemanBomFileIter.recNum() % 500)==0 ) std::cout <<"  Reading record number:" <<mtmDemanBomFileIter.recNum() <<std::endl;
      std::string mtm = mtmDemanBomFileIter.mtm();
      std::string part = mtmDemanBomFileIter.part();
      std::string srcLoc = mtmDemanBomFileIter.srcLoc();
      int period = mtmDemanBomFileIter.periodAsInt();
      float attachRate = mtmDemanBomFileIter.attachRateAsFloat();
#if 0
      int etnFlag = mtmDemanBomFileIter.etnFlagAsInt();

      // check to see if this record is to be filtered
      if ( etnFlagFilter==0 && etnFlag!=0 ) continue;
      if ( etnFlagFilter==1 && etnFlag!=1 ) continue;
#endif
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str() <<std::endl
          <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<std::endl
          <<"   mtm: " <<mtm.c_str()                                         <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure mtm exists
      if ( !eso2Prob.mtmExists(mtm,srcLoc) ) {
        // mtm does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"          <<std::endl
          <<"Warning: mtm at srcLoc does not exist"                            <<std::endl
          <<"   mtmDemanBom filename: " <<mtmDemanBomFile.filename().c_str()   <<std::endl
          <<"   mtmDemanBom file line number: " <<mtmDemanBomFileIter.recNum() <<std::endl
          <<"   mtm: " <<mtm.c_str()                                           <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                     <<std::endl
          <<"   record will be ignored. "                                      <<std::endl
          <<"-------------------------------------------------------"          <<std::endl;
        continue;
      }
      
      // If bom entry does not exist, then add it to model
      if ( !eso2Prob.demanBomExists(mtm,part,srcLoc ) ) {
        //bool partExists = eso2Prob.partExists(part,srcLoc);
        eso2Prob.addDemanBom(mtm,part,srcLoc);
        //std::cout <<"    " <<mtmDemanBomFileIter.recNum() <<" addDemanBom" <<std::endl;
 
      }
      
      eso2Prob.setDemanBomAttachRate(mtm,part,srcLoc,period-1,attachRate);
      //std::cout <<"    " <<mtmDemanBomFileIter.recNum() <<"   setDemanBomAttachRate" <<std::endl;
 
      
    } // end loop reading mtmDemanBom file record
  } // end of block reading mtmDemanBom file

  // Read feature xref and conversion Files
  {
    std::cout <<"Reading input files: featureXrefData, & featureConversionData" <<std::endl;
    std::string featureXrefFileName = inputDirectory + "/featureXrefData.csv";
    std::string featureConversionFileName = inputDirectory + "/featureConversionData.csv";
    ESO2featureXrefData featureXrefFile(featureXrefFileName);
    ESO2featureConversionData featureConversionFile(featureConversionFileName);
    ESO2featureXrefDataIterator featureXrefFileIter(featureXrefFile);
    
    // loop once for each record in featureXref file
    for ( ; featureXrefFileIter()!=NULL; ) {
      if ( (featureXrefFileIter.recNum() % 500)==0 ) std::cout <<"  Reading record number:" <<featureXrefFileIter.recNum() <<std::endl;
      std::string part = featureXrefFileIter.part();
      std::string feature = featureXrefFileIter.feature();
      std::string plantLoc = featureXrefFileIter.plantLoc();
      int period = featureXrefFileIter.periodAsInt();
      float prodRate = featureXrefFileIter.prodRateAsFloat();

 

      std::string featureConversionFileKey = featureConversionFile.key(plantLoc);
      if (!featureConversionFile.keyExists(featureConversionFileKey)) {
        // cost and usageTime not specifed
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: feature conversion cost and usageTime not specifed in featureConversion file."   <<std::endl
          <<"   featureConversion filename: " <<featureConversionFile.filename().c_str()               <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   cost will be set to: " <<ESO2problem::bigM()                 <<std::endl
          <<"   usageTime will be set to: " <<ESO2problem::bigM()            <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
      }
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   featureXref filename: " <<featureXrefFile.filename().c_str() <<std::endl
          <<"   featureXref line number: " <<featureXrefFileIter.recNum()        <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure feature exists
      if ( !eso2Prob.featureExists(feature,plantLoc) ) {
        // feature does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: feature at plantLoc does not exist"              <<std::endl
          <<"   featureXref filename: " <<featureXrefFile.filename().c_str()           <<std::endl
          <<"   featureXref file line number: " <<featureXrefFileIter.recNum()         <<std::endl
          <<"   feature: " <<feature.c_str()                     <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
            
#if 0
      // Test to make sure part exists
      if ( !eso2Prob.partExists(part,plantLoc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part at plantLoc does not exist"              <<std::endl
          <<"   featureXref filename: " <<featureXrefFile.filename().c_str()           <<std::endl
          <<"   featureXref file line number: " <<featureXrefFileIter.recNum()         <<std::endl
          <<"   part: " <<part.c_str()                     <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
#endif

      // Test to make sure downLevel and upLevel part are not same part
      if ( part==feature ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part and feature are the same part."      <<std::endl
          <<"   featureXref filename: " <<featureXrefFile.filename().c_str()     <<std::endl
          <<"   featureXref file line number: " <<featureXrefFileIter.recNum()   <<std::endl
          <<"   feature: " <<feature.c_str()                     <<std::endl
          <<"   part: " <<part.c_str()                         <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // If bom between part and feature part does not exist, then add it to model
      if ( !eso2Prob.featureXrefExists(part,feature,plantLoc ) ) {
        //bool partExists = eso2Prob.partExists(upLevelPart,plantLoc);
        eso2Prob.addFeatureXref(part,feature,plantLoc);
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, upLevelPart,plantLoc);
        float cost = ESO2problem::bigM();
        float usageTime = ESO2problem::bigM();  
        if ( featureConversionFile.keyExists(featureConversionFileKey) ) {
          cost = featureConversionFile.costAsFloat(featureConversionFileKey);
          usageTime = featureConversionFile.usageTimeAsFloat(featureConversionFileKey);
        }
        eso2Prob.setFeatureXrefUsageTime(part,feature,plantLoc,usageTime);
        eso2Prob.setFeatureXrefCost(part,feature,plantLoc,cost);
      }
      
      eso2Prob.setFeatureXrefProdRate(part,feature,plantLoc,period-1,prodRate);
      
    } // end loop reading featureXref file record
  } // end of block reading feature files

  // Read feature conversion override File
  {
    std::cout <<"Reading input file featureConversionOverrideData" <<std::endl;
    std::string featureConversionOverrideFileName = inputDirectory + "/featureConversionOverrideData.csv";
    ESO2featureConversionOverrideData featureConversionOverrideFile(featureConversionOverrideFileName);
    ESO2featureConversionOverrideDataIterator featureConversionOverrideFileIter(featureConversionOverrideFile);
    
    // loop once for each record in featureXref file
    for ( ; featureConversionOverrideFileIter()!=NULL; ) {
      std::string part = featureConversionOverrideFileIter.part();
      std::string feature = featureConversionOverrideFileIter.feature();
      std::string plantLoc = featureConversionOverrideFileIter.plantLoc();
      int period = featureConversionOverrideFileIter.periodAsInt();
      float cost = featureConversionOverrideFileIter.costAsFloat();
      float usageTime = featureConversionOverrideFileIter.usageTimeAsFloat();

      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   featureConversionOverride filename: " <<featureConversionOverrideFile.filename().c_str() <<std::endl
          <<"   featureConversionOverride line number: " <<featureConversionOverrideFileIter.recNum()        <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure feature exists
      if ( !eso2Prob.featureExists(feature,plantLoc) ) {
        // feature does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: feature at plantLoc does not exist"                    <<std::endl
          <<"   featureConversionOverride filename: " <<featureConversionOverrideFile.filename().c_str()   <<std::endl
          <<"   featureConversionOverride file line number: " <<featureConversionOverrideFileIter.recNum()     <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
            
      // Test to make sure part exists
      if ( !eso2Prob.partExists(part,plantLoc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part at plantLoc does not exist"                       <<std::endl
          <<"   featureConversionOverride filename: " <<featureConversionOverrideFile.filename().c_str() <<std::endl
          <<"   featureConversionOverride file line number: " <<featureConversionOverrideFileIter.recNum()   <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }

      // Test to make sure downLevel and upLevel part are not same part
      if ( part==feature ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part and feature are the same part."                   <<std::endl
          <<"   featureConversionOverride filename: " <<featureConversionOverrideFile.filename().c_str()     <<std::endl
          <<"   featureConversionOverride file line number: " <<featureConversionOverrideFileIter.recNum()       <<std::endl
          <<"   feature: " <<feature.c_str()                                 <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // The period of usageTime and Cost are when the conversion is complete, so must be offset by usageTime
      int completionPeriod = (int)(period+usageTime+0.5);
      if (completionPeriod<nPeriods) {
        eso2Prob.setFeatureXrefUsageTime(part,feature,plantLoc,completionPeriod-1,usageTime);
        eso2Prob.setFeatureXrefCost(part,feature,plantLoc,completionPeriod-1,cost);
      }

      
    } // end loop reading featureConversionOverride file record
  } // end of block reading featureConversionOverride files

   
  // Read part interplant override File
  {
    std::cout <<"Reading input file: partInterplantOverrideData" <<std::endl;
    std::string partInterplantOverrideDataFileName = inputDirectory + "/partInterplantOverrideData.csv";
    ESO2partInterplantOverrideData partInterplantOverrideDataFile(partInterplantOverrideDataFileName);
    ESO2partInterplantOverrideDataIterator partInterplantOverrideFileIter(partInterplantOverrideDataFile);
    
    // loop once for each record in partInterplant file
    for ( ; partInterplantOverrideFileIter()!=NULL; ) {
      std::string part = partInterplantOverrideFileIter.part();
      std::string srcLoc = partInterplantOverrideFileIter.srcLoc();
      std::string destLoc = partInterplantOverrideFileIter.destLoc();
      int period = partInterplantOverrideFileIter.periodAsInt();
      float moveCost = partInterplantOverrideFileIter.moveCostAsFloat();
      float moveTime = partInterplantOverrideFileIter.moveTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   partInterplantOverride filename: " <<partInterplantOverrideDataFile.filename().c_str()   <<std::endl
          <<"   partInterplantOverride file line number: " <<partInterplantOverrideFileIter.recNum() <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
          <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure part exists
      if ( !eso2Prob.partExists(part,srcLoc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part at srcLoc does not exist"                         <<std::endl
          <<"   partInterplantOverride filename: " <<partInterplantOverrideDataFile.filename().c_str()   <<std::endl
          <<"   partInterplantOverride file line number: " <<partInterplantOverrideFileIter.recNum() <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      
      // If link between srcLoc and destLoc for part does not exist, then add it to model
      if ( !eso2Prob.partInterplantExists(part,srcLoc,destLoc ) ) {
        // Get default move cost and time between srcLoc and destLoc
        float defaultMoveCost = ESO2problem::bigM();
        float defaultMoveTime = 0.0f;
        if ( partInterplantFile.keyExists(srcLoc,destLoc) ) {
          defaultMoveCost = partInterplantFile.defaultMoveCostAsFloat(srcLoc,destLoc);
          defaultMoveTime = partInterplantFile.defaultMoveTimeAsFloat(srcLoc,destLoc);
        }
        else {
          // Default part interplant move time and cost does not exist
          std::cout 
            <<"-------------------------------------------------------"        <<std::endl
            <<"Warning: default part interplant move time and cost does not exist in partInterplantMoveDefaults file" <<std::endl
            <<"   partInterplant filename: " <<partInterplantFile.filename().c_str()   <<std::endl
            <<"   srcLoc: " <<srcLoc.c_str()                                   <<std::endl
            <<"   destLoc: " <<destLoc.c_str()                                 <<std::endl
            <<"   defaultMoveCost will be set to: " <<defaultMoveCost          <<std::endl
            <<"   defaultMoveTime will be set to: " <<defaultMoveTime          <<std::endl
            <<"-------------------------------------------------------"        <<std::endl;
        }
        eso2Prob.addPartInterplant(part,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
        
        
        //bool partExists = eso2Prob.partExists(part,destLoc);
        
        //std::map<std::string,StdStringVec>> singleSrcToDest;
        //singleSrcToDest[srcLoc].push_back(destLoc);
        //eso2Prob.addPartInterplant(part,srcLoc,destLoc,ESO2problem::bigM(),0.0);
        
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,destLoc);
      }
     
      eso2Prob.setPartInterplantMoveCost(part,srcLoc,destLoc,period-1,moveCost);
      eso2Prob.setPartInterplantMoveTime(part,srcLoc,destLoc,period-1,moveTime);

    } // end loop reading partInterplant file record
  } // end of block reading partInterplant file

#if 0
  // Read alt and altExcludeLoc Files
  {
    std::cout <<"Reading input file: altData" <<std::endl;
    std::string altFileName = inputDirectory + "/altData.csv";
    ESO2altData altFile(altFileName);
    ESO2altDataIterator altFileIter(altFile);
    
    std::string altExcludeLocFileName = inputDirectory + "/altExcludeLocData.csv";
    ESO2altExcludeLocData altExludeLocFile(altExcludeLocFileName);
    
    std::string altOverrideFileName = inputDirectory + "/altOverrideData.csv";
    ESO2altOverrideData altOverrideFile(altOverrideFileName);

    std::string newAltDataFileName = inputDirectory + "/newAltData.csv";
    FILE * newAltDataFilePtr = fopen(newAltDataFileName.c_str(),"w");
    std::string heading="\"part\",\"altPart\",\"loc\",\"altConvCost\",\"altConvTime\""; 
    fprintf(newAltDataFilePtr,"%s\n",heading.c_str());
    
    
    // loop once for each record in alternatePart file
    for ( ; altFileIter()!=NULL; ) {
      std::string altPart = altFileIter.altPart();
      std::string part = altFileIter.part();
      //std::string plantLoc = alternatePartFileIter.plantLoc();
      //int period = alternatePartFileIter.periodAsInt();
      float prodRate = 1.0f;
      float defConvCost = altFileIter.altConvCostAsFloat();
      float defConvTime = altFileIter.altConvTimeAsFloat();
      
#if 0
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()           <<std::endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()         <<std::endl
          <<"   upLevelPart: " <<upLevelPart.c_str()                         <<std::endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
#endif
      
      std::vector<std::string> locs = eso2Prob.getPartLocs(part);
      // Test to make sure part part exists
      if ( locs.size()==0 ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part does not exist"                                   <<std::endl
          <<"   alt filename: " <<altFile.filename().c_str()                 <<std::endl
          <<"   alt file line number: " <<altFileIter.recNum()               <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   altPart: " <<altPart.c_str()                                 <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }

      // Test to make sure downLevel and upLevel part are not same part
      if ( part==altPart ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part and altPart are the same part."                   <<std::endl
          <<"   alt filename: " <<altFile.filename().c_str()                 <<std::endl
          <<"   alt file line number: " <<altFileIter.recNum()               <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   altPart: " <<altPart.c_str()                                 <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // loop once for each location where downLevel part exists
      int l;
      for ( l=0; l<locs.size(); ++l ) {

        // check to see if this location is to be excluded
        std::string altExcludeLocKey = altExludeLocFile.key(part,altPart,locs[l]);
        if ( altExludeLocFile.keyExists(altExcludeLocKey) ) 
          continue;
    
        // If bom between downLevel and upLevel part does not exist, then add it to model
        const std::string & loc = locs[l];
        if ( !eso2Prob.altExists(part,altPart,loc) ) {

          float convCost,convTime;
          
          // check to see if there is an override entry
          std::string overrideKey = altOverrideFile.key(part,altPart,loc);
          if ( altOverrideFile.keyExists(overrideKey) ) {            
            convCost = altOverrideFile.altConvCostAsFloat(overrideKey);
            convTime = altOverrideFile.altConvTimeAsFloat(overrideKey);
          }
          else {
            convCost = defConvCost;
            convTime = defConvTime;
          }
          eso2Prob.addAlt(part,altPart,locs[l],convCost,convTime);

          fprintf(newAltDataFilePtr,"\"%s\",\"%s\",\"%s\",%f,%f\n",part.c_str(),altPart.c_str(),locs[l].c_str(),convCost,convTime);

        }

      } // end loop for ( l=0; l<locs.size(); ++l ) 
    } // end loop reading alt file record
    fclose(newAltDataFilePtr);
  } // end of block reading alt file
#endif

  
#if 1
  // Read alt
  {
    std::cout <<"Reading input file: altData" <<std::endl;
    std::string altFileName = inputDirectory + "/altData.csv";
    ESO2altData altFile(altFileName);
    ESO2altDataIterator altFileIter(altFile);
    
    
    // loop once for each record in alternatePart file
    for ( ; altFileIter()!=NULL; ) {
      std::string altPart = altFileIter.altPart();
      std::string part = altFileIter.part();
      std::string loc = altFileIter.loc();
      float prodRate = 1.0f;
      float convCost = altFileIter.altConvCostAsFloat();
      float convTime = altFileIter.altConvTimeAsFloat();
      
      // Test to make sure part part exists
      if ( !eso2Prob.partExists(part,loc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part does not exist"                                   <<std::endl
          <<"   alt filename: " <<altFile.filename().c_str()                 <<std::endl
          <<"   alt file line number: " <<altFileIter.recNum()               <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   loc: "  <<loc.c_str()                                       <<std::endl
          <<"   altPart: " <<altPart.c_str()                                 <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure downLevel and upLevel part are not same part
      if ( part==altPart ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part and altPart are the same part."                   <<std::endl
          <<"   alt filename: " <<altFile.filename().c_str()                 <<std::endl
          <<"   alt file line number: " <<altFileIter.recNum()               <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   altPart: " <<altPart.c_str()                                 <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      
      if ( !eso2Prob.altExists(part,altPart,loc) ) {
        eso2Prob.addAlt(part,altPart,loc,convCost,convTime);
      }
      
    } // end loop reading alt file record
  } // end of block reading alt file
#endif


  
  // Read partDemand & partDemandLowPriority Files
  {
    std::vector<std::string> partDemandFileNames;
    partDemandFileNames.push_back("partDemandData");
    partDemandFileNames.push_back("partDemand2Data");
    
    std::vector<std::string> nEtnFlagsGlobalAttr;
    nEtnFlagsGlobalAttr.push_back("nEtnFlagFilters");
    nEtnFlagsGlobalAttr.push_back("nEtn2FlagFilters");
    
    std::vector<std::string> etnFlagNGlobalAttr;
    etnFlagNGlobalAttr.push_back("etnFlagFilter");
    etnFlagNGlobalAttr.push_back("etn2FlagFilter");
    
    int pdf;
    for ( pdf=0; pdf<2; ++pdf ) {
      std::cout <<"Reading input file: " <<partDemandFileNames[pdf] <<std::endl;
      std::string partDemandFileName = inputDirectory + "/" + partDemandFileNames[pdf] + ".csv";
      ESO2partDemandData partDemandFile(partDemandFileName);
      ESO2partDemandDataIterator partDemandFileIter(partDemandFile);
      
      // create set of etn flags that will be used for the current demand file
      std::set<std::string> etnFlags;
      {
         int nEtnFlagFilters = globalAttrFile.fieldAsInt(nEtnFlagsGlobalAttr[pdf],"attrValue");
         for ( int i=0; i<nEtnFlagFilters; ++i ) {
           char sAsChar[100];
           sprintf(sAsChar,"%d",i+1);
           std::string attrName = etnFlagNGlobalAttr[pdf]+std::string(sAsChar);
           std::string filter = globalAttrFile.fieldAsString(attrName,"attrValue");
           etnFlags.insert(filter);
         }
      } // finished creating set of etn flags
      
      // loop once for each record in partDemand file
      int nDemandsRead = 0;
      int nDemandsAdded = 0;
      for ( ; partDemandFileIter()!=NULL; ) {
        
        std::string part = partDemandFileIter.part();
        std::string custLoc = partDemandFileIter.custLoc();
        std::string plantLoc = partDemandFileIter.plantLoc();
        int period = partDemandFileIter.periodAsInt();
        float demandVol = partDemandFileIter.demandVolAsFloat();
        float wac = partDemandFileIter.wacAsFloat();
        std::string etnFlag = partDemandFileIter.etnFlag();
        nDemandsRead++;
        
        // check to see if this record is to be filtered
#if 0
        if ( etnFlagFilter==0 && etnFlag!=0 ) continue;
        if ( etnFlagFilter==1 && etnFlag!=1 ) continue;
#endif
        if ( etnFlags.find(etnFlag)==etnFlags.end() ) continue;
        
        // Test to make sure period is in range
        if ( period<1 || period>nPeriods ) {
          // Period is out of range. Write message
          std::cout 
            <<"-------------------------------------------------------"        <<std::endl
            <<"Warning: period out of allowed range"                           <<std::endl
            <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<std::endl
            <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<std::endl
            <<"   part: " <<part.c_str()                                       <<std::endl
            <<"   custLoc: " <<custLoc.c_str()                                 <<std::endl
            <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
            <<"   period: " <<period                                           <<std::endl
            <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
            <<"   record will be ignored. "                                    <<std::endl
            <<"-------------------------------------------------------"        <<std::endl;
          continue;
        }
        
        // Test to make sure mtm exists
        if ( !eso2Prob.partExists(part,plantLoc) ) {
          // part does not exist so record is invalid
          std::cout 
            <<"-------------------------------------------------------"        <<std::endl
            <<"Warning: part at plantLoc does not exist"                       <<std::endl
            <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<std::endl
            <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<std::endl
            <<"   part: " <<part.c_str()                                       <<std::endl
            <<"   srcLoc: " <<plantLoc.c_str()                                 <<std::endl
            <<"   record will be ignored. "                                    <<std::endl
            <<"-------------------------------------------------------"        <<std::endl;
          continue;
        }
        
        // If demand does not exist, then add it to model
        if ( !eso2Prob.partDemandExists(part,custLoc,plantLoc ) ) {
          eso2Prob.addPartDemand(part,custLoc,plantLoc);
          eso2Prob.setPartDemandPriority(part,custLoc,plantLoc,pdf);
        }
        
        eso2Prob.setPartDemandDemandVol(part,custLoc,plantLoc,period-1,demandVol);
        eso2Prob.setPartDemandWac(part,custLoc,plantLoc,period-1,wac);
        nDemandsAdded++;
        
      } // end loop reading partDemand file record
      std::cout <<"   "<<nDemandsRead  <<" demand records read." <<std::endl;
      std::cout <<"   "<<nDemandsAdded <<" demand records added to eso2 model." <<std::endl;
    } // end of loop which iterates over pardDemand files. for ( pdf=0; pdf<2; ++pdf )
  } // end of block reading partDemand file

} // end function createModel

@


1.47
log
@Updated to support inventory at demand location.
@
text
@d238 50
@


1.46
log
@no message
@
text
@d202 1
a202 1
      /*
d204 1
a204 1
      // Priority attribute does not exist
d207 1
a207 1
      <<"Error: period1SupplyPerishPeriod not specified."                <<std::endl
d209 1
a209 1
      <<"   valid range: 1<=period1SupplyPerishPeriod<=" <<nPeriods      <<std::endl
a212 1
      */
d223 1
a223 1
            <<"   valid range: 0<=period1SupplyPerishPeriod<=" <<1                                      <<std::endl
@


1.45
log
@added useApplyScaleFactorLocData to globalAttrData and code to support this attribute
@
text
@d276 1
d280 1
@


1.44
log
@Updated so allowInventoryHoldingAtDemandLocation can be put into the globalAttrData file
@
text
@d11 1
d16 1
d267 26
a292 4
    // Read applyScaleFactorLoc file
    {  
      std::string applyScaleFactorLocFileName = inputDirectory + "/applyScaleFactorLocData.csv";
      ESO2applyScaleFactorLocData applyScaleFactorLocFile(applyScaleFactorLocFileName);
d294 2
a295 10
      ESO2applyScaleFactorLocDataIterator applyScaleFactorLocFileIter(applyScaleFactorLocFile);

      // loop once for each record in partInterplant file
      for ( ; applyScaleFactorLocFileIter()!=NULL; ) {
        std::string plantLoc = applyScaleFactorLocFileIter.plantLoc();
        int demandFileNumber = applyScaleFactorLocFileIter.partDemandFileNumberAsInt();
        eso2Prob.setApplyLocWfmvScaleFactor(plantLoc,demandFileNumber);
      }

    } // end of read applyScaleFactorLoc file
@


1.43
log
@Updated to implement applyScaleFactorLoc
@
text
@d141 1
a141 1
                 bool setPeriod1SupplyPerishPeriod  )
d187 2
a188 1
      }      
d191 1
a191 1
      if ( setPeriod1SupplyPerishPeriod ) {        
d194 42
a235 1
    }
@


1.42
log
@modifed to write out the number of demand records added to model.
updated scoFile to use WallyProj trim eol method.
@
text
@d21 1
d223 16
@


1.41
log
@added wac scale factors (one for each demand file)
@
text
@d1185 2
d1196 1
d1238 1
a1238 1
        // If bom between downLevel and upLevel part does not exist, then add it to model
d1246 1
d1249 2
@


1.40
log
@Updated to all setting of mtm, feature, and loosePart priority when satisfying priority 2 demand.
@
text
@d194 28
@


1.39
log
@Modified the setting of feature conversion cost and time by adding a new block that loops over the records in the featureConversionOverride data file.
@
text
@d198 5
a202 2
    int p;
    for ( p=0; p<3; ++p ) {
d229 3
@


1.38
log
@changes to improve setting of feature offset, prodRate, and execCost
@
text
@d631 1
a631 1
    std::cout <<"Reading input files: featureXrefData, featureConversionData, & featureConversionOverrideData" <<std::endl;
a633 1
    std::string featureConversionOverrideFileName = inputDirectory + "/featureConversionOverrideData.csv";
a635 1
    ESO2featureConversionOverrideData featureConversionOverrideFile(featureConversionOverrideFileName);
d647 4
a650 18
      float defaultCost = ESO2problem::bigM();
      float defaultUsageTime = ESO2problem::bigM();
      float cost = defaultCost;
      float usageTime = defaultUsageTime;
      bool defaultSet = true;
      std::string key = featureConversionFile.key(plantLoc);
      if ( featureConversionFile.keyExists(key) ) {
        defaultSet = false;
        cost = featureConversionFile.costAsFloat(key);
        usageTime = featureConversionFile.usageTimeAsFloat(key);
      }
      key = featureConversionOverrideFile.key(part,feature,plantLoc,period);
      if ( featureConversionOverrideFile.keyExists(key) ) {
        defaultSet = false;
        cost = featureConversionOverrideFile.costAsFloat(key);
        usageTime = featureConversionOverrideFile.usageTimeAsFloat(key);
      }
      if ( defaultSet ) {
d654 2
a655 3
          <<"Warning: feature conversion cost and usageTime not specifed."   <<std::endl
          <<"   featureConversion filename: " <<featureConversionFile.filename().c_str()   <<std::endl
          <<"   featureConversionOverride filename: " <<featureConversionOverrideFile.filename().c_str()   <<std::endl
d660 2
a661 2
          <<"   cost will be set to: " <<cost                                <<std::endl
          <<"   usageTime will be set to: " <<usageTime                      <<std::endl
d738 95
d836 1
a836 1
      int completionPeriod = (int) period+usageTime;
d841 1
a841 1
      eso2Prob.setFeatureXrefProdRate(part,feature,plantLoc,period-1,prodRate);
d843 2
a844 2
    } // end loop reading featureXref file record
  } // end of block reading feature files
@


1.37
log
@updated to new name for low priority part demand file
@
text
@d640 1
a640 1
    // loop once for each record in alternatePart file
d757 6
a763 2
      eso2Prob.setFeatureXrefCost(part,feature,plantLoc,period-1,cost);
      eso2Prob.setFeatureXrefUsageTime(part,feature,plantLoc,period-1,usageTime);
@


1.36
log
@Added a more general method for dealing with the ETN flags
@
text
@d1038 1
a1038 1
    partDemandFileNames.push_back("partDemandPriority2Data");
d1042 1
a1042 1
    nEtnFlagsGlobalAttr.push_back("nEtnPriority2FlagFilters");
d1046 1
a1046 1
    etnFlagNGlobalAttr.push_back("etnPriority2FlagFilter");
@


1.35
log
@updated to add low priority demand file
@
text
@d58 1
a58 1
  int l=0;
d91 1
a91 1
      float demanTimeDefault = nPeriods+1;
d304 1
a304 1
      float demanTime = nPeriods+1;
d1038 9
a1046 5
    partDemandFileNames.push_back("partDemandLowPriorityData");

    std::vector<std::string> etnFlagNames;
    etnFlagNames.push_back("etnFlagFilterForHighPriorityDemand");
    etnFlagNames.push_back("etnFlagFilterForLowPriorityDemand");
d1055 12
a1066 1
      int etnFlagFilter = globalAttrFile.fieldAsInt(etnFlagNames[pdf],"attrValue");
d1077 1
a1077 1
        int etnFlag = partDemandFileIter.etnFlagAsInt();
d1080 1
d1083 2
@


1.34
log
@changed code to use std::string rather than BCP_string
@
text
@d1033 2
a1034 2
   
  // Read partDemand File
d1036 7
a1042 6
    std::cout <<"Reading input file: partDemandData" <<std::endl;
    std::string partDemandFileName = inputDirectory + "/partDemandData.csv";
    ESO2partDemandData partDemandFile(partDemandFileName);
    ESO2partDemandDataIterator partDemandFileIter(partDemandFile);

    int etnFlagFilter = globalAttrFile.fieldAsInt("etnFlagFilter","attrValue");
d1044 6
a1049 14
    // loop once for each record in partDemand file
    for ( ; partDemandFileIter()!=NULL; ) {

      std::string part = partDemandFileIter.part();
      std::string custLoc = partDemandFileIter.custLoc();
      std::string plantLoc = partDemandFileIter.plantLoc();
      int period = partDemandFileIter.periodAsInt();
      float demandVol = partDemandFileIter.demandVolAsFloat();
      float wac = partDemandFileIter.wacAsFloat();
      int etnFlag = partDemandFileIter.etnFlagAsInt();

      // check to see if this record is to be filtered
      if ( etnFlagFilter==0 && etnFlag!=0 ) continue;
      if ( etnFlagFilter==1 && etnFlag!=1 ) continue;
d1051 1
a1051 17
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<std::endl
          <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   custLoc: " <<custLoc.c_str()                                 <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
d1053 59
a1111 24
      // Test to make sure mtm exists
      if ( !eso2Prob.partExists(part,plantLoc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: part at plantLoc does not exist"                       <<std::endl
          <<"   partDemand filename: " <<partDemandFile.filename().c_str()   <<std::endl
          <<"   partDemand file line number: " <<partDemandFileIter.recNum() <<std::endl
          <<"   part: " <<part.c_str()                                       <<std::endl
          <<"   srcLoc: " <<plantLoc.c_str()                                 <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // If bom between downLevel and upLevel part does not exist, then add it to model
      if ( !eso2Prob.partDemandExists(part,custLoc,plantLoc ) ) {
        eso2Prob.addPartDemand(part,custLoc,plantLoc);
      }
     
      eso2Prob.setPartDemandDemandVol(part,custLoc,plantLoc,period-1,demandVol);
      eso2Prob.setPartDemandWac(part,custLoc,plantLoc,period-1,wac);

    } // end loop reading partDemand file record
@


1.33
log
@Changes to add loc to altData file.
Changes to start implementing PIP (pegging).
@
text
@a37 1
#include "BCP_string.h"
d40 1
a40 1
typedef std::vector<BCP_string> StdStringVec;
d47 1
a47 1
                    std::map<BCP_string,StdStringVec> srcToDestLocs,
d51 2
a52 2
                    const BCP_string & mtm,
                    const BCP_string & srcLoc)
d60 1
a60 1
    BCP_string destLoc = destLocs[l];
d102 1
a102 1
        BCP_string keyO = demanOverrideFile.key(mtm,destLoc,p);
d139 1
a139 1
                 const BCP_string & inputDirectory,
d147 3
a149 3
  typedef std::vector<BCP_string> StdStringVec;
  //std::map<BCP_string,StdStringVec> partSrcToDests;
  std::map<BCP_string,StdStringVec> mtmSrcToDests;
d152 1
a152 1
  BCP_string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d155 1
a155 1
    BCP_string title=globalAttrFile.fieldAsString("title","attrValue");
d194 1
a194 1
    std::vector<BCP_string> priorities;
d231 1
a231 1
  BCP_string partInterplantFileName = inputDirectory + "/partInterplantData.csv";
d238 2
a239 2
      BCP_string srcLoc = partInterplantFileIter.srcLoc();
      BCP_string destLoc = partInterplantFileIter.destLoc();
d247 1
a247 1
  BCP_string mtmInterplantFileName = inputDirectory + "/mtmInterplantData.csv";
d254 2
a255 2
      BCP_string srcLoc = mtmInterplantFileIter.srcLoc();
      BCP_string destLoc = mtmInterplantFileIter.destLoc();
d265 1
a265 1
    BCP_string mtmFileName = inputDirectory + "/mtmData.csv";
d269 1
a269 1
    BCP_string demanFileName = inputDirectory + "/demanData.csv";
d272 1
a272 1
    BCP_string demanOverrideFileName = inputDirectory + "/demanOverrideData.csv";
d277 2
a278 2
      BCP_string mtm = mtmFileIter.mtm();
      BCP_string plantLoc = mtmFileIter.plantLoc();
d320 1
a320 1
        BCP_string keyO = demanOverrideFile.key(mtm,plantLoc,period);
d365 1
a365 1
    BCP_string mtmInterplantOverrideFileName = inputDirectory + "/mtmInterplantOverrideData.csv";
d371 3
a373 3
      BCP_string mtm = mtmInterplantOverrideFileIter.mtm();
      BCP_string srcLoc = mtmInterplantOverrideFileIter.srcLoc();
      BCP_string destLoc = mtmInterplantOverrideFileIter.destLoc();
d470 1
a470 1
    BCP_string featureFileName = inputDirectory + "/featureData.csv";
d476 2
a477 2
      BCP_string feature = featureFileIter.feature();
      BCP_string plantLoc = featureFileIter.plantLoc();
d516 1
a516 1
    BCP_string loosePartFileName = inputDirectory + "/loosePartData.csv";
d522 2
a523 2
      BCP_string loosePart = loosePartFileIter.part();
      BCP_string plantLoc = loosePartFileIter.plantLoc();
d562 1
a562 1
    BCP_string mtmDemanBomFileName = inputDirectory + "/mtmDemanBomData.csv";
d569 3
a571 3
      BCP_string mtm = mtmDemanBomFileIter.mtm();
      BCP_string part = mtmDemanBomFileIter.part();
      BCP_string srcLoc = mtmDemanBomFileIter.srcLoc();
d632 3
a634 3
    BCP_string featureXrefFileName = inputDirectory + "/featureXrefData.csv";
    BCP_string featureConversionFileName = inputDirectory + "/featureConversionData.csv";
    BCP_string featureConversionOverrideFileName = inputDirectory + "/featureConversionOverrideData.csv";
d643 3
a645 3
      BCP_string part = featureXrefFileIter.part();
      BCP_string feature = featureXrefFileIter.feature();
      BCP_string plantLoc = featureXrefFileIter.plantLoc();
d654 1
a654 1
      BCP_string key = featureConversionFile.key(plantLoc);
d768 1
a768 1
    BCP_string partInterplantOverrideDataFileName = inputDirectory + "/partInterplantOverrideData.csv";
d774 3
a776 3
      BCP_string part = partInterplantOverrideFileIter.part();
      BCP_string srcLoc = partInterplantOverrideFileIter.srcLoc();
      BCP_string destLoc = partInterplantOverrideFileIter.destLoc();
d841 1
a841 1
        //std::map<BCP_string,StdStringVec>> singleSrcToDest;
d859 1
a859 1
    BCP_string altFileName = inputDirectory + "/altData.csv";
d863 1
a863 1
    BCP_string altExcludeLocFileName = inputDirectory + "/altExcludeLocData.csv";
d866 1
a866 1
    BCP_string altOverrideFileName = inputDirectory + "/altOverrideData.csv";
d869 1
a869 1
    BCP_string newAltDataFileName = inputDirectory + "/newAltData.csv";
d871 1
a871 1
    BCP_string heading="\"part\",\"altPart\",\"loc\",\"altConvCost\",\"altConvTime\""; 
d877 3
a879 3
      BCP_string altPart = altFileIter.altPart();
      BCP_string part = altFileIter.part();
      //BCP_string plantLoc = alternatePartFileIter.plantLoc();
d905 1
a905 1
      std::vector<BCP_string> locs = eso2Prob.getPartLocs(part);
d941 1
a941 1
        BCP_string altExcludeLocKey = altExludeLocFile.key(part,altPart,locs[l]);
d946 1
a946 1
        const BCP_string & loc = locs[l];
d952 1
a952 1
          BCP_string overrideKey = altOverrideFile.key(part,altPart,loc);
d978 1
a978 1
    BCP_string altFileName = inputDirectory + "/altData.csv";
d985 3
a987 3
      BCP_string altPart = altFileIter.altPart();
      BCP_string part = altFileIter.part();
      BCP_string loc = altFileIter.loc();
d1037 1
a1037 1
    BCP_string partDemandFileName = inputDirectory + "/partDemandData.csv";
d1046 3
a1048 3
      BCP_string part = partDemandFileIter.part();
      BCP_string custLoc = partDemandFileIter.custLoc();
      BCP_string plantLoc = partDemandFileIter.plantLoc();
@


1.32
log
@Code restored to state before etnParts were added
@
text
@d856 1
a856 1

d869 6
d963 3
d967 1
a967 5
#if 0      
        eso2Prob.setAlternatePartProdRate(upLevelPart,downLevelPart,plantLoc,period-1,prodRate);
        eso2Prob.setAlternatePartCost(upLevelPart,downLevelPart,plantLoc,period-1,cost);
        eso2Prob.setAlternatePartUsageTime(upLevelPart,downLevelPart,plantLoc,period-1,usageTime);
#endif
d970 1
d972 1
d975 57
@


1.31
log
@Code updated to read new format. (does not yet implement function supported by new format)
@
text
@a644 1
      int etnFlag = featureXrefFileIter.etnFlagAsInt();
d661 1
a661 1
      key = featureConversionOverrideFile.key(part,etnFlag,feature,plantLoc,period);
a872 1
      int altPartEtnFlag = altFileIter.altPartEtnFlagAsInt();
a873 1
      int partEtnFlag = altFileIter.partEtnFlagAsInt();
d936 1
a936 1
        BCP_string altExcludeLocKey = altExludeLocFile.key(part,partEtnFlag,altPart,altPartEtnFlag,locs[l]);
d947 1
a947 1
          BCP_string overrideKey = altOverrideFile.key(part,partEtnFlag,altPart,altPartEtnFlag,loc);
a988 1
#if 0
a993 1
#endif
@


1.30
log
@Removed some debugging code
@
text
@d645 1
d662 1
a662 1
      key = featureConversionOverrideFile.key(part,feature,plantLoc,period);
d874 1
d876 1
d939 1
a939 1
        BCP_string altExcludeLocKey = altExludeLocFile.key(part,altPart,locs[l]);
d950 1
a950 1
          BCP_string overrideKey = altOverrideFile.key(part,altPart,loc);
d992 1
d998 1
@


1.29
log
@Changed partOrFeature datafile field to be part
@
text
@d354 5
a358 10

      if ( addedMtm ) {
        if ( mtm == "9401150" ) {
          std::cout <<"Reached problem mtm" <<std::endl;
        }
         addAllMtmInterplants(
           eso2Prob, mtmSrcToDests, 
           mtmInterplantFile, demanFile, demanOverrideFile, 
           mtm,plantLoc);
      }
@


1.28
log
@moved etn flag from mtmDemanBom to partDemand files
@
text
@d878 1
a878 1
      BCP_string partOrFeature = altFileIter.partOrFeature();
d905 2
a906 2
      std::vector<BCP_string> locs = eso2Prob.getPartLocs(partOrFeature);
      // Test to make sure partOrFeature part exists
d911 1
a911 1
          <<"Warning: partOrFeature does not exist"                          <<std::endl
d914 1
a914 1
          <<"   partOrFeature: " <<partOrFeature.c_str()                     <<std::endl
d922 1
a922 1
      if ( partOrFeature==altPart ) {
d926 1
a926 1
          <<"Warning: partOrFeature and altPart are the same part."          <<std::endl
d929 1
a929 1
          <<"   partOrFeature: " <<partOrFeature.c_str()                     <<std::endl
d941 1
a941 1
        BCP_string altExcludeLocKey = altExludeLocFile.key(partOrFeature,altPart,locs[l]);
d947 1
a947 1
        if ( !eso2Prob.altExists(partOrFeature,altPart,loc) ) {
d952 1
a952 1
          BCP_string overrideKey = altOverrideFile.key(partOrFeature,altPart,loc);
d961 1
a961 1
          eso2Prob.addAlt(partOrFeature,altPart,locs[l],convCost,convTime);
@


1.27
log
@minor changes to output messages
@
text
@a570 2

    int etnFlagFilter = globalAttrFile.fieldAsInt("etnFlagFilter","attrValue");
d580 1
d586 1
d982 2
d994 5
@


1.26
log
@Replaced std::string with BCP_string to work around VAC compiler problem
@
text
@d87 1
a87 4
      
      
      //std::cout <<"JPF calling eso2Prob.addMtmInterplant mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
      //const BCP_string tempDestLoc = destLoc;
a88 2
      //destLoc = tempDestLoc;
      //std::cout <<"JPF returning eso2Prob.addMtmInterplant mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
d126 4
a129 8
      if ( eso2Prob.mtmInterplantExists(mtm,srcLoc,destLoc ) ) {
        std::cout <<"JPF setMtmDemanCost: mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
        eso2Prob.setMtmDemanCost(mtm,srcLoc, destLoc,demanCost);
        eso2Prob.setMtmDemanTime(mtm,srcLoc, destLoc,demanTime);
      }
      else {
        std::cout <<"JPF: mtm interplant should exist but does not. mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
      }
d648 1
@


1.25
log
@desparate change to try to fix things
@
text
@d38 1
d41 1
a41 1
typedef std::vector<std::string> StdStringVec;
d48 1
a48 1
                    std::map<std::string,StdStringVec> srcToDestLocs,
d52 2
a53 2
                    const std::string & mtm,
                    const std::string & srcLoc)
d56 1
a56 1
  StdStringVec destLocs = srcToDestLocs[srcLoc];
d61 1
a61 1
    std::string destLoc = destLocs[l];
d89 5
a93 5
      std::cout <<"JPF calling eso2Prob.addMtmInterplant mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
      const std::string tempDestLoc = destLoc;
      eso2Prob.addMtmInterplant(mtm,srcLoc,tempDestLoc,defaultMoveCost,defaultMoveTime);
      destLoc = tempDestLoc;
      std::cout <<"JPF returning eso2Prob.addMtmInterplant mtm=" <<mtm.c_str() <<" srcLoc=" <<srcLoc.c_str() <<" destLoc=" <<destLoc.c_str() <<std::endl;
d108 1
a108 1
        std::string keyO = demanOverrideFile.key(mtm,destLoc,p);
d149 1
a149 1
                 const std::string & inputDirectory,
d157 3
a159 3
  typedef std::vector<std::string> StdStringVec;
  //std::map<std::string,StdStringVec> partSrcToDests;
  std::map<std::string,StdStringVec> mtmSrcToDests;
d162 1
a162 1
  std::string globalAttrFileName = inputDirectory + "/globalAttrData.csv";
d165 1
a165 1
    std::string title=globalAttrFile.fieldAsString("title","attrValue");
d204 1
a204 1
    std::vector<std::string> priorities;
d241 1
a241 1
  std::string partInterplantFileName = inputDirectory + "/partInterplantData.csv";
d248 2
a249 2
      std::string srcLoc = partInterplantFileIter.srcLoc();
      std::string destLoc = partInterplantFileIter.destLoc();
d257 1
a257 1
  std::string mtmInterplantFileName = inputDirectory + "/mtmInterplantData.csv";
d264 2
a265 2
      std::string srcLoc = mtmInterplantFileIter.srcLoc();
      std::string destLoc = mtmInterplantFileIter.destLoc();
d275 1
a275 1
    std::string mtmFileName = inputDirectory + "/mtmData.csv";
d279 1
a279 1
    std::string demanFileName = inputDirectory + "/demanData.csv";
d282 1
a282 1
    std::string demanOverrideFileName = inputDirectory + "/demanOverrideData.csv";
d287 2
a288 2
      std::string mtm = mtmFileIter.mtm();
      std::string plantLoc = mtmFileIter.plantLoc();
d330 1
a330 1
        std::string keyO = demanOverrideFile.key(mtm,plantLoc,period);
d380 1
a380 1
    std::string mtmInterplantOverrideFileName = inputDirectory + "/mtmInterplantOverrideData.csv";
d386 3
a388 3
      std::string mtm = mtmInterplantOverrideFileIter.mtm();
      std::string srcLoc = mtmInterplantOverrideFileIter.srcLoc();
      std::string destLoc = mtmInterplantOverrideFileIter.destLoc();
d485 1
a485 1
    std::string featureFileName = inputDirectory + "/featureData.csv";
d491 2
a492 2
      std::string feature = featureFileIter.feature();
      std::string plantLoc = featureFileIter.plantLoc();
d531 1
a531 1
    std::string loosePartFileName = inputDirectory + "/loosePartData.csv";
d537 2
a538 2
      std::string loosePart = loosePartFileIter.part();
      std::string plantLoc = loosePartFileIter.plantLoc();
d577 1
a577 1
    std::string mtmDemanBomFileName = inputDirectory + "/mtmDemanBomData.csv";
d586 3
a588 3
      std::string mtm = mtmDemanBomFileIter.mtm();
      std::string part = mtmDemanBomFileIter.part();
      std::string srcLoc = mtmDemanBomFileIter.srcLoc();
d647 3
a649 3
    std::string featureXrefFileName = inputDirectory + "/featureXrefData.csv";
    std::string featureConversionFileName = inputDirectory + "/featureConversionData.csv";
    std::string featureConversionOverrideFileName = inputDirectory + "/featureConversionOverrideData.csv";
d657 3
a659 3
      std::string part = featureXrefFileIter.part();
      std::string feature = featureXrefFileIter.feature();
      std::string plantLoc = featureXrefFileIter.plantLoc();
d668 1
a668 1
      std::string key = featureConversionFile.key(plantLoc);
d782 1
a782 1
    std::string partInterplantOverrideDataFileName = inputDirectory + "/partInterplantOverrideData.csv";
d788 3
a790 3
      std::string part = partInterplantOverrideFileIter.part();
      std::string srcLoc = partInterplantOverrideFileIter.srcLoc();
      std::string destLoc = partInterplantOverrideFileIter.destLoc();
d855 1
a855 1
        //std::map<std::string,StdStringVec>> singleSrcToDest;
d873 1
a873 1
    std::string altFileName = inputDirectory + "/altData.csv";
d877 1
a877 1
    std::string altExcludeLocFileName = inputDirectory + "/altExcludeLocData.csv";
d880 1
a880 1
    std::string altOverrideFileName = inputDirectory + "/altOverrideData.csv";
d885 3
a887 3
      std::string altPart = altFileIter.altPart();
      std::string partOrFeature = altFileIter.partOrFeature();
      //std::string plantLoc = alternatePartFileIter.plantLoc();
d913 1
a913 1
      std::vector<std::string> locs = eso2Prob.getPartLocs(partOrFeature);
d949 1
a949 1
        std::string altExcludeLocKey = altExludeLocFile.key(partOrFeature,altPart,locs[l]);
d954 1
a954 1
        const std::string & loc = locs[l];
d960 1
a960 1
          std::string overrideKey = altOverrideFile.key(partOrFeature,altPart,loc);
d987 1
a987 1
    std::string partDemandFileName = inputDirectory + "/partDemandData.csv";
d994 3
a996 3
      std::string part = partDemandFileIter.part();
      std::string custLoc = partDemandFileIter.custLoc();
      std::string plantLoc = partDemandFileIter.plantLoc();
@


1.24
log
@desparate change to try to fix things
@
text
@d60 1
a60 1
    const std::string destLoc = destLocs[l];
d91 1
@


1.23
log
@desparate change to try to fix things
@
text
@d47 1
a47 1
                    std::map<std::string,StdStringVec> & srcToDestLocs,
d60 1
a60 1
    const std::string & destLoc = destLocs[l];
@


1.22
log
@added some diagnostic code
@
text
@d89 2
a90 1
      eso2Prob.addMtmInterplant(mtm,srcLoc,destLoc,defaultMoveCost,defaultMoveTime);
@


1.21
log
@added some diagnostic code
@
text
@d88 1
a88 1
      std::cout <<"JPF calling eso2Prob.addMtmInterplant" <<std::endl;
d90 1
a90 1
      std::cout <<"JPF returning eso2Prob.addMtmInterplant" <<std::endl;
@


1.20
log
@added some diagnostic code
@
text
@d87 2
d90 1
d129 1
@


1.19
log
@Added code for setting alts
@
text
@d106 1
a106 1
          usingDefault=true;
d125 7
a131 2
      eso2Prob.setMtmDemanCost(mtm,srcLoc, destLoc,demanCost);
      eso2Prob.setMtmDemanTime(mtm,srcLoc, destLoc,demanTime);
d358 3
@


1.18
log
@Added bigM method to eso2Problem and updated code to use this constant
@
text
@d27 3
a29 1
#include "alternatePartData.h"
a762 84
#if 0  
  // Read alternatePart File
  {
    std::cout <<"Reading input file: alternatePartData" <<std::endl;
    std::string alternatePartFileName = inputDirectory + "/alternatePartData.csv";
    ESO2alternatePartData alternatePartFile(alternatePartFileName);
    ESO2alternatePartDataIterator alternatePartFileIter(alternatePartFile);
    
    // loop once for each record in alternatePart file
    for ( ; alternatePartFileIter()!=NULL; ) {
      std::string upLevelPart = alternatePartFileIter.upLevelPart();
      std::string downLevelPart = alternatePartFileIter.downLevelPart();
      std::string plantLoc = alternatePartFileIter.plantLoc();
      int period = alternatePartFileIter.periodAsInt();
      float prodRate = alternatePartFileIter.prodRateAsFloat();
      float cost = alternatePartFileIter.costAsFloat();
      float usageTime = alternatePartFileIter.usageTimeAsFloat();
      
      // Test to make sure period is in range
      if ( period<1 || period>nPeriods ) {
        // Period is out of range. Write message
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: period out of allowed range"                           <<std::endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()           <<std::endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()         <<std::endl
          <<"   upLevelPart: " <<upLevelPart.c_str()                         <<std::endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   valid range: 0<period<=" <<nPeriods                          <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // Test to make sure downLevel part exists
      if ( !eso2Prob.partExists(downLevelPart,plantLoc) ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: downLevelPart at plantLoc does not exist"              <<std::endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()           <<std::endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()         <<std::endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }

      // Test to make sure downLevel and upLevel part are not same part
      if ( downLevelPart==upLevelPart ) {
        // part does not exist so record is invalid
        std::cout 
          <<"-------------------------------------------------------"        <<std::endl
          <<"Warning: downLevelPart and upLevelPart are the same part."      <<std::endl
          <<"   alternatePart filename: " <<alternatePartFile.filename().c_str()     <<std::endl
          <<"   alternatePart file line number: " <<alternatePartFileIter.recNum()   <<std::endl
          <<"   downLevelPart: " <<downLevelPart.c_str()                     <<std::endl
          <<"   upLevelPart: " <<upLevelPart.c_str()                         <<std::endl
          <<"   plantLoc: " <<plantLoc.c_str()                               <<std::endl
          <<"   period: " <<period                                           <<std::endl
          <<"   record will be ignored. "                                    <<std::endl
          <<"-------------------------------------------------------"        <<std::endl;
        continue;
      }
      
      // If bom between downLevel and upLevel part does not exist, then add it to model
      if ( !eso2Prob.alternatePartExists(upLevelPart,downLevelPart,plantLoc ) ) {
        //bool partExists = eso2Prob.partExists(upLevelPart,plantLoc);
        eso2Prob.addAlternatePart(upLevelPart,downLevelPart,plantLoc);
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, upLevelPart,plantLoc);
      }
      
      eso2Prob.setAlternatePartProdRate(upLevelPart,downLevelPart,plantLoc,period-1,prodRate);
      eso2Prob.setAlternatePartCost(upLevelPart,downLevelPart,plantLoc,period-1,cost);
      eso2Prob.setAlternatePartUsageTime(upLevelPart,downLevelPart,plantLoc,period-1,usageTime);
      
    } // end loop reading alternatePart file record
  } // end of block reading alternatePart file
#endif

d853 115
@


1.17
log
@changes to have demanCost and demanTime be from deman location, rather supply loc and time
@
text
@d66 1
a66 1
      float defaultMoveCost = 1000000.f;
d88 1
a88 1
      float demanCostDefault = 10000.f;
d299 1
a299 1
      float demanCost = 10000;
d433 1
a433 1
        float defaultMoveCost = 1000000.f;
d646 2
a647 2
      float defaultCost = 10000.00f;
      float defaultUsageTime = 10000.00f;
d899 1
a899 1
        float defaultMoveCost = 1000000.f;
d924 1
a924 1
        //eso2Prob.addPartInterplant(part,srcLoc,destLoc,100000.0,0.0);
@


1.16
log
@Modified to implement featureXref
@
text
@d47 2
d52 1
d84 1
d86 39
d257 1
a257 1
  // Read MTM File
d351 4
a354 1
         addAllMtmInterplants(eso2Prob, mtmSrcToDests, mtmInterplantFile, mtm,plantLoc);
@


1.15
log
@fix to have wfmv be source of perishable supply when non-perishable supply has supplyVol=0
@
text
@d22 3
d580 136
a715 2
  
  
d797 1
a797 1

@


1.14
log
@Changed default demanTime to be nPeriods+1.
Fixed so demanTime is properly considered after interPlant moves
@
text
@d255 14
a296 6
      }
      
      bool addedMtm = false;
      if ( !eso2Prob.mtmExists(mtm,plantLoc) ) {
        addedMtm=true;
        eso2Prob.addMtm(mtm,plantLoc);
@


1.13
log
@updated to put osl log file input/output directory
@
text
@d71 1
a71 1
          <<"   partInterplantData filename: " <<mtmInterplantFile.filename().c_str()   <<std::endl
d254 1
a254 1
      float demanTime = 0.0;
d285 1
d287 1
a288 1
        addAllMtmInterplants(eso2Prob, mtmSrcToDests, mtmInterplantFile, mtm,plantLoc);
d295 4
@


1.12
log
@Added progress messages
@
text
@d554 2
a555 4
        
        //// if part is a new part, then add all of its interplant moves
        //if ( !partExists )
        //  addAllPartInterplants(eso2Prob, partSrcToDests, partInterplantFile, part,srcLoc);
d559 2
@


1.11
log
@Added progress messages
@
text
@d506 1
a506 1
      if ( mtmDemanBomFileIter.recNum() % 500 ) std::cout <<"  Reading record number:" <<mtmDemanBomFileIter.recNum() <<std::endl;
@


1.10
log
@Added progress messages
@
text
@d506 1
@


1.9
log
@Remove mtm from demanData
@
text
@d180 1
d213 2
d300 1
d405 1
d451 1
d497 1
d567 1
d651 1
d741 1
@


1.8
log
@Updated to add error messages dealing with period1SupplyPerishPeriod
@
text
@d259 3
a261 4
          std::string key = demanFile.key(mtm,plantLoc);
          if ( demanFile.keyExists(key) ) {
            demanCost = demanFile.demanCostAsFloat(key);
            demanTime = demanFile.demanTimeAsFloat(key);
@


1.7
log
@changed name of globalAttribute period1PerishabilityLimit to period1SupplyPerishPeriod
@
text
@d111 14
a124 1
    if ( setPeriod1SupplyPerishPeriod ) {
d126 16
a141 1
      eso2Prob.setPeriod1SupplyPerishPeriod(period1SupplyPerishPeriod);
@


1.6
log
@Changes to implement period1SupplyPerishabilityLimit
@
text
@d90 1
a90 1
                 bool setPeriod1PerishabilityLimit  )
d111 3
a113 3
    if ( setPeriod1PerishabilityLimit ) {
      int period1PerishabilityLimit = globalAttrFile.fieldAsInt("period1PerishabilityLimit","attrValue");
      eso2Prob.setPeriod1PerishabilityLimit(period1PerishabilityLimit);
@


1.5
log
@Updated to have deman and demanOverride input files
@
text
@d87 4
a90 1
void createModel(ESO2problem & eso2Prob, const std::string & inputDirectory )
d110 5
@


1.4
log
@Updated to change 1 to be the first period.
Added additional test to see if objValue has changed
@
text
@d30 2
d180 6
d193 2
a194 2
      float demanCost = mtmFileIter.demanCostAsFloat();
      float demanTime = mtmFileIter.demanTimeAsFloat();
d211 34
@


1.3
log
@changes for building on aix
@
text
@d189 1
a189 1
      if ( period<0 || period>=nPeriods ) {
d199 1
a199 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d210 4
a213 4
      eso2Prob.setMtmSupply(mtm,plantLoc,period,supply);
      eso2Prob.setMtmWfmv(mtm,plantLoc,period,wfmv);
      eso2Prob.setMtmDemanCost(mtm,plantLoc,period,demanCost);
      eso2Prob.setMtmDemanTime(mtm,plantLoc,period,demanTime);
d234 1
a234 1
      if ( period<0 || period>=nPeriods ) {
d245 1
a245 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d311 2
a312 2
      eso2Prob.setMtmInterplantMoveCost(mtm,srcLoc,destLoc,period,moveCost);
      eso2Prob.setMtmInterplantMoveTime(mtm,srcLoc,destLoc,period,moveTime);
d337 1
a337 1
      if ( period<0 || period>=nPeriods ) {
d347 1
a347 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d357 2
a358 2
      eso2Prob.setFeatureSupply(feature,plantLoc,period,supply);
      eso2Prob.setFeatureWfmv(feature,plantLoc,period,wfmv);
d382 1
a382 1
      if ( period<0 || period>=nPeriods ) {
d392 1
a392 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d406 2
a407 2
      eso2Prob.setLoosePartSupply(loosePart,plantLoc,period,supply);
      eso2Prob.setLoosePartWfmv(loosePart,plantLoc,period,wfmv);
d434 1
a434 1
      if ( period<0 || period>=nPeriods ) {
d444 1
a444 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d475 1
a475 1
      eso2Prob.setDemanBomAttachRate(mtm,part,srcLoc,period,attachRate);
d498 1
a498 1
      if ( period<0 || period>=nPeriods ) {
d509 1
a509 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d555 3
a557 3
      eso2Prob.setAlternatePartProdRate(upLevelPart,downLevelPart,plantLoc,period,prodRate);
      eso2Prob.setAlternatePartCost(upLevelPart,downLevelPart,plantLoc,period,cost);
      eso2Prob.setAlternatePartUsageTime(upLevelPart,downLevelPart,plantLoc,period,usageTime);
d580 1
a580 1
      if ( period<0 || period>=nPeriods ) {
d591 1
a591 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d647 2
a648 2
      eso2Prob.setPartInterplantMoveCost(part,srcLoc,destLoc,period,moveCost);
      eso2Prob.setPartInterplantMoveTime(part,srcLoc,destLoc,period,moveTime);
d670 1
a670 1
      if ( period<0 || period>=nPeriods ) {
d681 1
a681 1
          <<"   valid range: 0<=period<" <<nPeriods                          <<std::endl
d707 2
a708 2
      eso2Prob.setPartDemandDemandVol(part,custLoc,plantLoc,period,demandVol);
      eso2Prob.setPartDemandWac(part,custLoc,plantLoc,period,wac);
@


1.2
log
@Some changes getting ready for AIX build
@
text
@d40 1
a40 1
                    std::map<std::string,StdStringVec>> & srcToDestLocs,
@


1.1
log
@updated unitTest to do something useful.
fixed problems with prunning. Now works for all testCases.
@
text
@d12 1
a12 1
#include <assert.h>
d14 2
a15 2
#include <float.h>
#include <math.h>
@


head	1.33;
access;
symbols
	start:1.1.1.1 IBM:1.1.1;
locks; strict;
comment	@// @;


1.33
date	2006.10.06.17.07.35;	author gresh;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.18.17.47.45;	author gresh;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.17.18.11.15;	author gresh;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.01.14.21.12;	author gresh;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.09.13.46.45;	author gresh;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.30.15.29.30;	author gresh;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.30.15.20.45;	author swwhite;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.24.18.04.29;	author gresh;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.24.16.42.20;	author gresh;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.22.15.32.05;	author gresh;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.18.17.33.52;	author gresh;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.18.17.23.18;	author gresh;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.15.14.26.29;	author gresh;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.08.16.05.34;	author gresh;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.18.13.27.04;	author gresh;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.21.15.22.42;	author gresh;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.17.17.49.17;	author gresh;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.02.18.25.37;	author gresh;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.02.16.33.46;	author gresh;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.01.16.21.28;	author gresh;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.28.18.11.37;	author gresh;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.28.15.58.18;	author gresh;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.28.15.35.11;	author gresh;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.28.14.37.26;	author gresh;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.27.19.22.37;	author gresh;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.24.19.52.59;	author gresh;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.24.19.03.56;	author gresh;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.24.16.57.43;	author gresh;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.23.18.56.10;	author gresh;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.23.14.39.45;	author gresh;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.23.13.50.38;	author gresh;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.22.19.03.35;	author gresh;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.22.15.41.58;	author fasano;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.02.22.15.41.58;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.33
log
@*** empty log message ***
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#pragma warning(disable:4290)
#endif

#include <numeric>
#include <set>
#include <algorithm>

#include <cassert>
#include <iostream>
#include <cfloat>
#include <cstdio>
#include <climits>

#include "CoinFinite.h"
#include "CoinFloatEqual.h"
#include "demandPlanningProblem.h"
#include "demandPlanning.h"
//#include "solutionAppData.h"
#include "resourceAppData.h"
#include "populateDP.h"
//#include "rcpOptException.h"
#include "checkWitRC.h"
//#include "rcpOptIntException.h"


extern bool witOK;

// default constructor
demandPlanningProblem::demandPlanningProblem()
:
SCOproblemBase(),
demandNames_(),
solutionNames_(),
resourceNames_()

{
  checkWitRC(witSetExecEmptyBom(witRun(),WitTRUE));
}

// destructor
demandPlanningProblem::~demandPlanningProblem()
{
  if (witOK)
    gutsOfDestructor();
}
//reinitialize
void demandPlanningProblem::reInitialize() {
	SCOproblemBase::reInitialize();
}

// copy constructor
demandPlanningProblem::demandPlanningProblem( const demandPlanningProblem & source ):
SCOproblemBase(source),
demandNames_(),
solutionNames_(),
resourceNames_()

{
  gutsOfCopy(source);
}

// assignment operator
demandPlanningProblem&
demandPlanningProblem::operator=(const demandPlanningProblem& rhs)
{  
  if (this != &rhs) { 
    SCOproblemBase::operator=(rhs);
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object

void demandPlanningProblem::gutsOfCopy( const demandPlanningProblem& source )
{
  resourceNames_ = source.resourceNames_;
  demandNames_ = source.demandNames_;
  solutionNames_ = source.solutionNames_;
  isDivisibleDemand_ = source.isDivisibleDemand_;
  isMrp_ = source.isMrp_;

  // copy solution appData
  //unsigned int e;
  //std::vector<std::string> solutionNames;
  //getSolutionNames(solutionNames);
  //for ( e=0; e<solutionNames.size(); ++e ) { 
   // std::string theSolution = solutionName(solutionNames[e]);
    //DPsolutionAppData * srcAppData;    
    //DPsolutionAppData * sinkAppData;
    //checkWitRC(witGetPartAppData(source.mutableWitRun(),theSolution.c_str(),(void**)&srcAppData));
    //sinkAppData = new DPsolutionAppData(*srcAppData);    
    //checkWitRC(witSetPartAppData(witRun(),theSolution.c_str(),sinkAppData));
  //}

  // copy resource appData
  {
    unsigned int r;
    std::vector<DPvectorString> names;
    getResourceNames(names);
    for ( r=0; r<names.size(); ++r ) { 
      std::string resourceName = baseResourceName(names[r]);
      DPresourceAppData * srcAppData;  
      DPresourceAppData * sinkAppData;  
      checkWitRC(witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData));
      sinkAppData = new DPresourceAppData(*srcAppData);   
      checkWitRC(witSetPartAppData(witRun(),resourceName.c_str(),sinkAppData)); 
    }
  }
}

// destructor
void demandPlanningProblem::gutsOfDestructor()
{
  // delete solution appData
  //unsigned int e;
  //std::vector<std::string> solutionNames;
  //getSolutionNames(solutionNames);
  //for ( e=0; e<solutionNames.size(); ++e ) { 
  //  std::string theSolution = solutionName(solutionNames[e]);
   // DPsolutionAppData * srcAppData;  
    //checkWitRC(witGetOperationAppData(mutableWitRun(),theSolution.c_str(),(void**)&srcAppData));
	//delete srcAppData;
	//checkWitRC(witGetPartAppData(mutableWitRun(),theSolution.c_str(),(void**)&srcAppData));
   // delete srcAppData;
  //}
  // delete resource appData  
  {
    int r;
    
    std::vector<DPvectorString> names;
    getResourceNames(names);
    int numResources = names.size();
    
 
    for ( r=0; r<numResources; ++r ) { 
        DPresourceAppData * srcAppData;
        std::string resourceName = baseResourceName(names[r]);
        checkWitRC(witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData));
        delete srcAppData;
    }
  }
  
}

//general methods
void demandPlanningProblem::setIsMrpProblem(bool isMrp) {
	isMrp_ = isMrp;
}
bool demandPlanningProblem::isMrpProblem() {
	return isMrp_;
}
void demandPlanningProblem::setDivisibleDemand(bool isDivisibleDemand) {
	isDivisibleDemand_ = isDivisibleDemand;
}
bool demandPlanningProblem::isDivisibleDemand() {
	return isDivisibleDemand_;
}
void demandPlanningProblem::setEquitableAllocation(bool equitable) {
  if (equitable)
	checkWitRC(witSetEquitability(witRun(),100));
  else
    checkWitRC(witSetEquitability(witRun(),1));

}
void demandPlanningProblem::purge() {
		checkWitRC(witPurgeData(witRun()));
}
void demandPlanningProblem::netSupply() {
	//run MRP on the model
    checkWitRC(witMrp(witRun()));

    std::vector<std::vector<std::string> > names;
    getResourceNames(names);
    int numResources = names.size();
    int np = getNPeriods();

    //pick off the results
    for (int r=0; r<numResources; ++r ) {
      std::string rName;
      rName = baseResourceName(names[r]);
	  float * excessVol;
	  checkWitRC(witGetPartMrpExcessVol(witRun(),rName.c_str(),&excessVol));
	  checkWitRC(witSetPartSupplyVol(witRun(),rName.c_str(),excessVol));
	  checkWitRC(witFree(excessVol));
    }
	checkWitRC(witPurgeData(witRun()));
	
}
void demandPlanningProblem::writeModel(std::string modelName)
{
  checkWitRC(witSetMesgFileAccessMode(witRun(),true,"w"));
  checkWitRC(witWriteData(witRun(),modelName.c_str()));
}
void demandPlanningProblem::setUserNPeriods(int nPeriods) {
	userNPeriods_ = nPeriods;
}
int demandPlanningProblem::getUserNPeriods() {
	int retVal = userNPeriods_;
	return retVal;
}
void demandPlanningProblem::doMrp() {
  checkWitRC(witMrp(witRun()));

  std::vector<std::vector<std::string> > names;
  getResourceNames(names);
  int numResources = names.size();
  int np = getNPeriods();

  //pick off the results
  for (int r=0; r<numResources; ++r ) {
    std::string rName;
    rName = baseResourceName(names[r]);
    std::vector<float> reqQty = witGetNameAttribute(witGetPartMrpConsVol,rName);
	//std::vector<float> supplyQty = witGetNameAttribute(witGetPartSupplyVol,rName);
    for (int t=0; t<np; t++ ) {
      setResourceReqQuantity(names[r],t,reqQty[t]);
    }
  }

  witWriteData(witRun(),"foo.dat");
  //do the same for solutions
  std::vector<std::string> sNames;
  getSolutionNames(sNames);
  int numSolutions = sNames.size();
#if 0 //doesn't make sense at the moment
  for (int s=0; s<numSolutions; ++s) {
	  std::string theSolution = solutionName(sNames[s]);
      //float *reqQty;
	  //std::vector<float> reqQty = witGetNameAttribute(witGetPartMrpConsVol,theSolution);
	  std::vector<float> reqQty = witGetNameAttribute(witGetOperationMrpExecVol,theSolution);
	  //checkWitRC(witGetPartMrpConsVol(witRun(),theSolution.c_str(),&reqQty));
	
	  for (int t=0; t<np; t++) {
		  int duration = getSolutionDuration(sNames[s]);
		  //I put the requirement back to the beginning of the solution engagement
		  if (t-duration+1>=0)
			  setSolutionReqQuantity(sNames[s],t-duration+1,reqQty[t]);
	  }
	  //checkWitRC(witFree(reqQty));
  }
#endif

}
void demandPlanningProblem::doImplosionProblem() {
  checkWitRC(witHeurImplode(witRun()));

 
}

  //----------------------
  // Methods for solutions.
  //----------------------
void demandPlanningProblem::addSolution(const std::string & sName) {
  std::string theSolution = solutionName(sName);
  checkWitRC(witAddPart(witRun(),theSolution.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),theSolution.c_str()));
  checkWitRC(witAddBopEntry(witRun(),theSolution.c_str(),theSolution.c_str()));
  int nP = getNPeriods();
  //DPsolutionAppData * appData = new DPsolutionAppData(nP);
  //checkWitRC(witSetPartAppData(witRun(),theSolution.c_str(),appData));
  solutionNames_.insert(theSolution);
}
void demandPlanningProblem::setSolutionForDeletion(const std::string & sName) {
	std::string theSolution = solutionName(sName);
	checkWitRC(witSetPartSelForDel(witRun(), theSolution.c_str(),WitTRUE));
	checkWitRC(witSetOperationSelForDel(witRun(), theSolution.c_str(),WitTRUE));
	solutionNames_.erase(theSolution);
}
void demandPlanningProblem::setSolutionIncLotSize(const std::string & sName, float lotSize) {
	std::string theSolution = solutionName(sName);
	float * incLotSize = floatToFloatStar(lotSize);
	checkWitRC(witSetOperationIncLotSize(witRun(),theSolution.c_str(),incLotSize));
	delete [] incLotSize;
	return;
}
void demandPlanningProblem::getSolutionNames( std::vector<std::string> & solutionNames ) const
{
  solutionNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=solutionNames_.begin(); it!=solutionNames_.end(); ++it ) {
    solutionNames.push_back( solutionFromSolutionName(*it) );
  }
}
bool demandPlanningProblem::solutionExists(const std::string & sName)
{
  std::string witName = solutionName(sName);
  return witPartExists(witName);
}

std::string demandPlanningProblem::solutionName(const std::string & sName )const
{
  return "solution: "+sName;
}
std::string demandPlanningProblem::solutionFromSolutionName(const std::string & sName)
{
  return textAfter(sName,"solution: ");
}

  //----------------------
  // Methods for resources.
  //----------------------  


void demandPlanningProblem::addResource(const std::vector<std::string> &resourceAttributeVector) {
  std::string resourceName = baseResourceName(resourceAttributeVector);
  checkWitRC(witAddPart(witRun(),resourceName.c_str(),WitCAPACITY));
  resourceNames_.insert(resourceName);
  // Add appData for working resource
  int np = getNPeriods();
  DPresourceAppData * appData = new DPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),resourceName.c_str(),appData));
}
void demandPlanningProblem::setResourceSupplyQuantity(const std::vector<std::string> &resourceAttributeVector, float supply) {
	std::string resourceName = baseResourceName(resourceAttributeVector);
	float * supplyVol = floatToFloatStar(supply);
	checkWitRC(witSetPartSupplyVol(witRun(), resourceName.c_str(), supplyVol));
	delete [] supplyVol;
}
void demandPlanningProblem::setResourceSupplyQuantityByPeriod(const std::vector<std::string> &resourceAttributeVector, float supply, int period) {
	std::string resourceName = baseResourceName(resourceAttributeVector);
	float *supplyVol;
	checkWitRC(witGetPartSupplyVol(witRun(),resourceName.c_str(),&supplyVol));
    supplyVol[period] = supply;
	checkWitRC(witSetPartSupplyVol(witRun(), resourceName.c_str(), supplyVol));
	witFree(supplyVol);
}

std::string demandPlanningProblem::baseResourceName(const std::vector<std::string> &resourceAttributeVector )const
{ 
  std::string retVal;
  int numAttributes = resourceAttributeVector.size();
 
  for (int i=0; i<numAttributes-1; i++) {
    std::string attributeName = getResourceIdentifierNames()[i];
    std::string attributeValue = resourceAttributeVector.at(i);
    retVal = retVal + attributeName + ": " + attributeValue + " ";
  }
  std::string attributeName = getResourceIdentifierNames()[numAttributes-1];
  std::string attributeValue = resourceAttributeVector.at(numAttributes-1);
  retVal = retVal + attributeName + ": " + attributeValue;
  return retVal;
}

const std::vector<std::string> & demandPlanningProblem::getResourceIdentifierNames() const
{
  return resourceIdentifierNames_;
}

void demandPlanningProblem::addResourceIdentifierName(const std::string & resourceIdentifierName )
{
  int nResIdentNames = resourceNames_.size();
  
  // resource identifier names must be specified before adding resources.
  // make sure this is the case.
  assert( nResIdentNames == 0 );
  
  resourceIdentifierNames_.push_back(resourceIdentifierName);
  
}
bool demandPlanningProblem::resourceExists(const std::vector<std::string> &resourceAttributeVector)const 
{
  std::string witName = baseResourceName(resourceAttributeVector);
  return witPartExists(witName);
}
void demandPlanningProblem::setResourceReqQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float reqQuantity)
{
  std::string rName = baseResourceName(resourceIdentifierValues);
  DPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),rName.c_str(),(void**)&appData));
  appData->setReq(period, reqQuantity);

}
std::vector<float> demandPlanningProblem::getResourceReqQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues)
{
  std::string rName = baseResourceName(resourceIdentifierValues);
  DPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),rName.c_str(),(void**)&appData));
  return appData->getReq();
}
// Return list of names.
// returned value names[i][j]
//   where i=[0,numberOfResourceIdentifiers]
//         j=[0,numberOfResources]
void demandPlanningProblem::getResourceNames( std::vector<std::vector<std::string> > & names )const
{
  names.clear();
  
  // loop once for each resource
  std::set<std::string>::const_iterator r;
  for ( r=resourceNames_.begin(); r!=resourceNames_.end(); ++r) {
    
    const std::string & baseName = *r;
    DPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
    
    names.push_back( resourceIdValues );
  }
}
std::vector<std::string> demandPlanningProblem::resourceIdentifierValuesFromResourceName(const std::string &baseResourceName ) const
{
  std::vector<std::string> retVal;
  for (unsigned int i=0; i<getResourceIdentifierNames().size(); ++i ) {
    std::string value = resourceIdentifierValueFromResourceName(baseResourceName, i);
    retVal.push_back(value);
  }
  return retVal;
}

std::string demandPlanningProblem::resourceIdentifierValueFromResourceName(const std::string &resourcename, int which)const
{
  int last = getResourceIdentifierNames().size()-1;
  std::string retVal;
  if (which!=last) {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    std::string nextone = getResourceIdentifierNames()[which+1];
    nextone = " " +nextone + ": ";
    retVal = textBetween(resourcename, thisone, nextone);
  }
  else {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    retVal = textAfter(resourcename, thisone);
  }
  return retVal;
}




  //----------------------
  // Methods for boms.
  //----------------------  



float demandPlanningProblem::getResourceRequirement(const std::string &sName,const std::vector<std::string> &resourceIdentifierValues, int period) {
	std::string theSolution = solutionName(sName);
	std::string resName = baseResourceName(resourceIdentifierValues);
	//get the boms for the solution
	int numBomEntries;
	checkWitRC(witGetOperationNBomEntries(witRun(),theSolution.c_str(),&numBomEntries));
	for (int j=0; j<numBomEntries; j++) {
		char * partName;
		float *consRate;
		checkWitRC(witGetBomEntryConsumedPart(witRun(),theSolution.c_str(),j,&partName));
		if (partName==resName) {
			checkWitRC(witGetBomEntryConsRate(witRun(),theSolution.c_str(),j,&consRate));
		    //any are ok to return; all the same
			float retVal = consRate[period];
			checkWitRC(witFree(partName));
			checkWitRC(witFree(consRate));
			return retVal;
		}
		checkWitRC(witFree(partName));
	}
    return -1;
}
void demandPlanningProblem::addResourceRequirement(const std::string & sName, 
                        const std::vector<std::string> &resourceIdentifierValues,
						float hoursPerSolnHour)
{ 
  std::string resourceName = baseResourceName(resourceIdentifierValues);
  std::string theSolution = solutionName(sName);

  checkWitRC(witAddBomEntry(witRun(),theSolution.c_str(), resourceName.c_str()));
  int added;
  checkWitRC(witGetOperationNBomEntries(witRun(),theSolution.c_str(),&added));
  float *consRate=floatToFloatStar(hoursPerSolnHour); 
  checkWitRC(witSetBomEntryConsRate(witRun(),theSolution.c_str(),added-1,consRate));
  delete [] consRate;
  checkWitRC(witSetBomEntryLatestPeriod(witRun(),theSolution.c_str(),added-1,getNPeriods()-1));
}
void demandPlanningProblem::addAtomicSolutionRequirements(const std::string & specificSName, 
														  const std::string & sName, 
														  int duration)
{ 
  std::string theSolution = solutionName(sName);
  std::string theSpecificSolution = solutionName(specificSName);

  for (int i=0; i<duration; i++) {
     checkWitRC(witAddBomEntry(witRun(),theSpecificSolution.c_str(), theSolution.c_str()));
	 int added;
     checkWitRC(witGetOperationNBomEntries(witRun(),theSpecificSolution.c_str(),&added));
     float *offset=floatToFloatStar((float)-i);
	 checkWitRC(witSetBomEntryOffset(witRun(),theSpecificSolution.c_str(),added-1,offset));
     float *consRate=floatToFloatStar(1.0); 
     checkWitRC(witSetBomEntryConsRate(witRun(),theSpecificSolution.c_str(),added-1,consRate));
	 //latest period should be nPeriods-1-i;
	 
	 int latestPeriod = getNPeriods()-1-i;
	 
	 checkWitRC(witSetBomEntryLatestPeriod(witRun(),theSpecificSolution.c_str(),added-1,latestPeriod));
     delete [] consRate;
	 delete [] offset;
  }
}
  //----------------------
  // Methods for demands.
  //----------------------  
void demandPlanningProblem::addToOngoingDemandList(const std::pair<std::string, std::string>  p) {
	ongoingDemandList_.push_back(p);
}
void demandPlanningProblem::addToWedgeDemandList(const std::pair<std::string, std::string>  p) {
	wedgeDemandList_.push_back(p);
}
void demandPlanningProblem::addToOpportunityDemandList(const std::pair<std::string, std::string>  p) {
	opportunityDemandList_.push_back(p);
}
std::vector<std::pair<std::string, std::string> >  demandPlanningProblem::getWedgeDemandList() {
	return wedgeDemandList_;
}
std::vector<std::pair<std::string, std::string> > demandPlanningProblem::getOpportunityDemandList() {
	return opportunityDemandList_;
}
std::vector<std::pair<std::string, std::string> > demandPlanningProblem::getOngoingDemandList() {
	return ongoingDemandList_;
}
void demandPlanningProblem::setDemandPriority(const std::string &dName, const std::string &sName, int priority) {
	std::string theSolution = solutionName(sName);
	std::string theDemand = demandName(dName);
	int * demandPriority = intToIntStar(priority);
	checkWitRC(witSetDemandPriority(witRun(),theSolution.c_str(),theDemand.c_str(),demandPriority));
	delete [] demandPriority;
}
void demandPlanningProblem::addDemand(const std::string &dName, const std::string &sName, const std::string &demandType) {
	  //get the name of the solution "part"


	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);
	  std::pair<std::string, std::string> p;
	  p.first = dName;
	  p.second = sName;
	  demandNames_.push_back(p);



      checkWitRC(witAddDemand(witRun(),theSolution.c_str(),theDemand.c_str()));
	  //initialize
	  float * demandVol = floatToFloatStar(0.0f);
	  checkWitRC(witSetDemandDemandVol(witRun(),theSolution.c_str(),theDemand.c_str(),demandVol));
      //don't let anything ship late unless specifically told otherwise
	  int * lateAllowance = intToIntStar(0);
	  checkWitRC(witSetDemandShipLateUB(witRun(), theSolution.c_str(), theDemand.c_str(), lateAllowance));
	  delete [] lateAllowance;
	  delete [] demandVol;

	  if (demandType == "wedge") {
		  addToWedgeDemandList(p);
		  setDemandPriority(dName,sName,3);
	  }
	  else if (demandType == "opportunity") {
		  addToOpportunityDemandList(p);
		  setDemandPriority(dName,sName,2);
	  }
	  else if (demandType == "ongoing") {
		  addToOngoingDemandList(p);
		  setDemandPriority(dName,sName,1);
	  }


}

void demandPlanningProblem::setDemandForDeletion(const std::string & dName, const std::string & sName) {
	std::string theDemand = demandName(dName);
	std::string theSolution = solutionName(sName);
	checkWitRC(witSetDemandSelForDel(witRun(), theSolution.c_str(),theDemand.c_str(),WitTRUE));
}
void demandPlanningProblem::setDemandShipLateAllowance(const std::string & dName, const std::string & sName, int allowance) {
	  std::string theDemand = demandName(dName);
	  std::string theSolution = solutionName(sName);
	  int * lateAllowance = intToIntStar(allowance);
	  checkWitRC(witSetDemandShipLateUB(witRun(),theSolution.c_str(), theDemand.c_str(), lateAllowance));
	  delete [] lateAllowance;
  }

  int demandPlanningProblem::getDemandPeriodShipped(const std::string & dName, const std::string & sName) {
	  float *shipVol;
	  std::string theDemand = demandName(dName);
	  std::string theSolution = solutionName(sName);
	  checkWitRC(witGetDemandShipVol(witRun(), theSolution.c_str(), theDemand.c_str(), &shipVol));
	  for (int i=0; i<getNPeriods(); i++) {
		  if (shipVol[i]>0) {
			  checkWitRC(witFree(shipVol));
			  return i;
		  }
	  }
	  checkWitRC(witFree(shipVol));
	  return -1;
	  }
  float demandPlanningProblem::getDemandTotalQuantityShipped(const std::string & dName, const std::string & sName) {
	//figure out how much of the demand shipped
	float *shipVol;
	float totalShipVol=0;
	std::string theDemand = demandName(dName);
	std::string theSolution = solutionName(sName);
    checkWitRC(witGetDemandShipVol(witRun(),theSolution.c_str(), theDemand.c_str(), &shipVol));
	for (int i=0; i<getNPeriods(); i++) {
		totalShipVol=totalShipVol+shipVol[i];
	}
	checkWitRC(witFree(shipVol));
	return totalShipVol;
  }

  bool demandPlanningProblem::getDemandShipped(const std::string & dName, const std::string & sName) {
	//figure out whether or not this demand shipped
	float *shipVol;
	std::string theDemand = demandName(dName);
	std::string theSolution = solutionName(sName);
    checkWitRC(witGetDemandShipVol(witRun(),theSolution.c_str(), theDemand.c_str(), &shipVol));
	for (int i=0; i<getNPeriods(); i++) {
		if (shipVol[i]>0) {
			checkWitRC(witFree( shipVol));
			return true;
		}
	}
	checkWitRC(witFree(shipVol));
	return false;
  }
float demandPlanningProblem::getDemandQuantityShipped(const std::string & dName, const std::string & sName, int period) {
	//figure out whether or not this demand shipped
	float *shipVol;
	std::string theDemand = demandName(dName);
	std::string theSolution = solutionName(sName);
    checkWitRC(witGetDemandShipVol(witRun(),theSolution.c_str(), theDemand.c_str(), &shipVol));
	float shipAmount = shipVol[period];

	checkWitRC(witFree(shipVol));
	return shipAmount;
  }
  std::vector<std::pair<std::string, std::string> > demandPlanningProblem::getDemandNames() {
	  return demandNames_;
  }
 
  void demandPlanningProblem::setDemandQuantity(const std::string &dName, const std::string &sName, int period, float quantity){
	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);

	  float * demandVol;
	  checkWitRC(witGetDemandDemandVol(witRun(),theSolution.c_str(),theDemand.c_str(),&demandVol));

	  float currentDemand = demandVol[period];
	  demandVol[period]=currentDemand+quantity;
	  checkWitRC(witSetDemandDemandVol(witRun(),theSolution.c_str(), theDemand.c_str(), demandVol));

      checkWitRC(witFree( demandVol));
}
 void demandPlanningProblem::resetDemandQuantity(const std::string &dName, const std::string &sName){
	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);

      float *quantity=floatToFloatStar(0.0);

	  checkWitRC(witSetDemandDemandVol(witRun(),theSolution.c_str(), theDemand.c_str(), quantity));

      delete [] quantity;
}

bool demandPlanningProblem::demandExists(const std::string &dName, const std::string &sName)const {
 	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);
   
	  return witGetDemandExists(theSolution,theDemand);
}
std::string demandPlanningProblem::demandName(const std::string & dName )const
{
  return "demand: "+dName;
}
//std::string demandPlanningProblem::demandScalingName(const std::string & dName, const std::string & sName )const
//{
//	return "demand: "+dName + " solution: " + sName;
//}



void demandPlanningProblem::test()
  {

    CoinRelFltEq eq(.0001);



	//test solutions
	{
    demandPlanningProblem prob;
    prob.setNPeriods(5);

	std::cerr <<"solutions";

    prob.addSolution("s1");  
    prob.addSolution("s2");
    
    assert(  prob.solutionExists("s1") );
    assert(  prob.solutionExists("s2") );
    assert( !prob.solutionExists("e3") );
    

  
    std::vector<std::string> solutionNames;
    prob.getSolutionNames(solutionNames);
    assert( solutionNames.size()==2 );
    assert( solutionNames[0]=="s1" || solutionNames[1]=="s1" );
    assert( solutionNames[0]=="s2" || solutionNames[1]=="s2" );

 
    
  }
  std::cerr <<"resources";
  // Test resources
  {
    demandPlanningProblem prob;
    prob.setNPeriods(4);
    
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    std::vector<std::string> resNames = prob.getResourceIdentifierNames();
	assert(resNames[0]=="jobRole");
	assert(resNames[1]=="skillSet");
    
   
    DPvectorString res1;
    res1.push_back("appDeveloper");
    res1.push_back("java");
    prob.addResource(res1);
    
    DPvectorString res2;
    res2.push_back("architect");
    res2.push_back("c++");
    prob.addResource(res2);

    DPvectorString res3;
    res2.push_back("architect");
    res2.push_back("c");


	//assert(resourceExists(res1));
	//assert(resourceExists(res2));
	//assert(!resourceExists(res3));

	prob.setResourceReqQuantity(res1,0,2.0f);
	prob.setResourceReqQuantity(res1,3,1.3f);
	std::vector<float> reqQ = prob.getResourceReqQuantity(res1);
	assert(eq(reqQ[0],2.0f));
	assert(eq(reqQ[1],0.0f));
	assert(eq(reqQ[2],0.0f));
	assert(eq(reqQ[3],1.3f));
    
    std::vector<DPvectorString> resourceNames;
    prob.getResourceNames(resourceNames);
    assert(resourceNames.size()==2);
    assert( resourceNames[0][0]=="appDeveloper" || resourceNames[1][0]=="appDeveloper" );
    assert( resourceNames[0][0]=="architect" || resourceNames[1][0]=="architect" );
    
    assert( resourceNames[0][1]=="java" || resourceNames[1][1]=="java" );
    assert( resourceNames[0][1]=="c++" || resourceNames[1][1]=="c++" );

	//std::string baseName = baseResourceName(res1);
	//resourceNames = prob.resourceIdentifierValuesFromResourceName(baseName);
	//assert(resourceNames[0]=="appDeveloper");
	//assert(resourceNames[1]=="java");
	//std::string resourceName = prob.resourceIdentifierValueFromResourceName(baseName,0);
	//assert(resourceName=="appDeveloper");
	//resourceName = prob.resourceIdentifierValueFromResourceName(baseName,1);
	//assert(resourceName=="java");
  }

  //now redo the tests with the "duration" solution model. Should get the same
  //results.

   std::cerr <<"firstExample";

  //now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/firstExample";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
	float foo=reqQty[0];
    assert(eq(reqQty[0],0.6f ));
    assert(eq(reqQty[1],0.6f ));
    assert(eq(reqQty[2],0.6f ));
    assert(eq(reqQty[3],0.6f ));
    assert(eq(reqQty[4],0.6f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res3;
    res3.push_back("JR2");res3.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res4;
    res4.push_back("JR3");res4.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res4);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));


    DPvectorString res5; //ongoing
    res5.push_back("JRC");res5.push_back("SSC");
    reqQty = prob.getResourceReqQuantity(res5);
    assert(eq(reqQty[0],1.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

	DPvectorString res6; //ongoing
    res6.push_back("JRD");res6.push_back("SSD");
    reqQty = prob.getResourceReqQuantity(res6);
    assert(eq(reqQty[0],2.0f ));
    assert(eq(reqQty[1],2.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

  }    



   std::cerr <<"jrssCombined";

  //now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/jrssCombined";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
    assert(eq(reqQty[0],1.8f ));
    assert(eq(reqQty[1],1.8f ));
    assert(eq(reqQty[2],1.95f ));
    assert(eq(reqQty[3],1.125f ));
    assert(eq(reqQty[4],1.20f ));
	float foo = reqQty[5];
    assert(eq(reqQty[5],1.05f ));

    DPvectorString res2;
    res2.push_back("JR2SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],6.308f ));
    assert(eq(reqQty[1],6.56f ));
    assert(eq(reqQty[2],4.81f ));
    assert(eq(reqQty[3],3.435f ));
    assert(eq(reqQty[4],3.452f ));

    DPvectorString res3;
    res3.push_back("JR3SS3");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],1.654f ));
    assert(eq(reqQty[1],1.78f ));
    assert(eq(reqQty[2],0.78f ));
    assert(eq(reqQty[3],0.78f ));
    assert(eq(reqQty[4],0.726f ));


  }    
    std::cerr <<"firstExampleUncertainStart";

   {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/firstExampleUncertainStart";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
	float foo=reqQty[0];
    assert(eq(reqQty[0],0.3f ));
    assert(eq(reqQty[1],0.3f ));
    assert(eq(reqQty[2],1.6f ));
    assert(eq(reqQty[3],1.3f ));
    assert(eq(reqQty[4],0.6f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res3;
    res3.push_back("JR2");res3.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.4f ));
    assert(eq(reqQty[3],0.4f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res4;
    res4.push_back("JR3");res4.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res4);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));


    DPvectorString res5; //ongoing
    res5.push_back("JRC");res5.push_back("SSC");
    reqQty = prob.getResourceReqQuantity(res5);
    assert(eq(reqQty[0],1.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

	DPvectorString res6; //ongoing
    res6.push_back("JRD");res6.push_back("SSD");
    reqQty = prob.getResourceReqQuantity(res6);
    assert(eq(reqQty[0],2.0f ));
    assert(eq(reqQty[1],2.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

  }     
  std::cerr <<"uncertainStart";

  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/uncertainStart";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.15f ));
	assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[3],0.525f ));
    assert(eq(reqQty[4],0.75f ));
    assert(eq(reqQty[5],0.60f ));
    assert(eq(reqQty[6],0.225f ));
    assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[8],0.0f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));
    assert(eq(reqQty[5],0.0f ));
    assert(eq(reqQty[6],0.0f ));
    assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[8],0.0f ));



  }    

    //now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/firstExample";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
	float foo=reqQty[0];
    assert(eq(reqQty[0],0.6f ));
    assert(eq(reqQty[1],0.6f ));
    assert(eq(reqQty[2],0.6f ));
    assert(eq(reqQty[3],0.6f ));
    assert(eq(reqQty[4],0.6f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res3;
    res3.push_back("JR2");res3.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res4;
    res4.push_back("JR3");res4.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res4);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));


    DPvectorString res5; //ongoing
    res5.push_back("JRC");res5.push_back("SSC");
    reqQty = prob.getResourceReqQuantity(res5);
    assert(eq(reqQty[0],1.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

	DPvectorString res6; //ongoing
    res6.push_back("JRD");res6.push_back("SSD");
    reqQty = prob.getResourceReqQuantity(res6);
    assert(eq(reqQty[0],2.0f ));
    assert(eq(reqQty[1],2.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

  }    



   std::cerr <<"jrssCombined";

  //now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/jrssCombined";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
    assert(eq(reqQty[0],1.8f ));
    assert(eq(reqQty[1],1.8f ));
    assert(eq(reqQty[2],1.95f ));
    assert(eq(reqQty[3],1.125f ));
    assert(eq(reqQty[4],1.20f ));
    assert(eq(reqQty[5],1.05f ));

    DPvectorString res2;
    res2.push_back("JR2SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],6.308f ));
    assert(eq(reqQty[1],6.56f ));
    assert(eq(reqQty[2],4.81f ));
    assert(eq(reqQty[3],3.435f ));
    assert(eq(reqQty[4],3.452f ));

    DPvectorString res3;
    res3.push_back("JR3SS3");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],1.654f ));
    assert(eq(reqQty[1],1.78f ));
    assert(eq(reqQty[2],0.78f ));
    assert(eq(reqQty[3],0.78f ));
    assert(eq(reqQty[4],0.726f ));


  }    
    std::cerr <<"firstExampleUncertainStart";

   {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/firstExampleUncertainStart";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
	float foo=reqQty[0];
    assert(eq(reqQty[0],0.3f ));
    assert(eq(reqQty[1],0.3f ));
    assert(eq(reqQty[2],1.6f ));
    assert(eq(reqQty[3],1.3f ));
    assert(eq(reqQty[4],0.6f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res3;
    res3.push_back("JR2");res3.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res3);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.4f ));
    assert(eq(reqQty[3],0.4f ));
    assert(eq(reqQty[4],0.0f ));

    DPvectorString res4;
    res4.push_back("JR3");res4.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res4);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));


    DPvectorString res5; //ongoing
    res5.push_back("JRC");res5.push_back("SSC");
    reqQty = prob.getResourceReqQuantity(res5);
    assert(eq(reqQty[0],1.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

	DPvectorString res6; //ongoing
    res6.push_back("JRD");res6.push_back("SSD");
    reqQty = prob.getResourceReqQuantity(res6);
    assert(eq(reqQty[0],2.0f ));
    assert(eq(reqQty[1],2.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));

  }     
  std::cerr <<"uncertainStart";

  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/uncertainStart";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doMrp();
      
    DPvectorString res1;
    res1.push_back("JR1");res1.push_back("SS1");
    std::vector<float> reqQty = prob.getResourceReqQuantity(res1);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.15f ));
	assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[3],0.525f ));
    assert(eq(reqQty[4],0.75f ));
    assert(eq(reqQty[5],0.60f ));
    assert(eq(reqQty[6],0.225f ));
    assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[8],0.0f ));

    DPvectorString res2;
    res2.push_back("JR1");res2.push_back("SS2");
    reqQty = prob.getResourceReqQuantity(res2);
    assert(eq(reqQty[0],0.0f ));
    assert(eq(reqQty[1],0.0f ));
    assert(eq(reqQty[2],0.0f ));
    assert(eq(reqQty[3],0.0f ));
    assert(eq(reqQty[4],0.0f ));
    assert(eq(reqQty[5],0.0f ));
    assert(eq(reqQty[6],0.0f ));
    assert(eq(reqQty[7],0.0f ));
    assert(eq(reqQty[8],0.0f ));



  }    
//now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/testImplosion_priority";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doImplosionProblem();
      
     //get the list of demands
	std::vector<std::pair<std::string, std::string> > demands;
	demands = prob.getOpportunityDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		int periodShipped = prob.getDemandPeriodShipped(demandName, solutionName);
		assert(shipped == false);
		assert(demandName == "contract1");
		assert(solutionName == "contract1:AAA:d2");
		
		
	}
	
	//now do the wedge demand
	
    //get the list of demands
	demands = prob.getWedgeDemandList();
  
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == true);
		assert(demandName == "wedge");
		assert(solutionName == "AAA");
			
	}
	//first do the ongoing demand
	
    //get the list of demands
	demands = prob.getOngoingDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == true);
		assert(demandName == "d1");
		assert(solutionName == "d1:AAA:d3");
	}

  }
//now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/testImplosion_late";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doImplosionProblem();
      
     //get the list of demands
	std::vector<std::pair<std::string, std::string> > demands;
	demands = prob.getOpportunityDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		int periodShipped = prob.getDemandPeriodShipped(demandName, solutionName);
		assert(shipped == true);
		assert(demandName == "contract1");
		assert(solutionName == "contract1:AAA:d2");
		
		
	}
	
	//now do the wedge demand
	
    //get the list of demands
	demands = prob.getWedgeDemandList();
  
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == true);
		assert(demandName == "wedge");
		assert(solutionName == "AAA");
			
	}
	//first do the ongoing demand
	
    //get the list of demands
	demands = prob.getOngoingDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == true);
		assert(demandName == "d1");
		assert(solutionName == "d1:AAA:d3");
	}

  }

  //now do some meaningful tests with various test directories.
  {
    demandPlanningProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/testImplosion_resourceshortage";
	bool simulation = false;
    populateWithDuration(&prob, inputDirectory, simulation,false);
    
    prob.doImplosionProblem();
      
     //get the list of demands
	std::vector<std::pair<std::string, std::string> > demands;
	demands = prob.getOpportunityDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		int periodShipped = prob.getDemandPeriodShipped(demandName, solutionName);
		assert(shipped == false);
		assert(demandName == "contract1");
		assert(solutionName == "contract1:AAA:d2");
		
		
	}
	
	//now do the wedge demand
	
    //get the list of demands
	demands = prob.getWedgeDemandList();
  
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == false);
		assert(demandName == "wedge");
		assert(solutionName == "AAA");
			
	}
	//first do the ongoing demand
	
    //get the list of demands
	demands = prob.getOngoingDemandList();
    
	for (unsigned int i=0; i<demands.size(); i++) {
		std::pair<std::string, std::string> p = demands[i];
		std::string demandName = p.first;
		std::string solutionName = p.second;
        bool shipped = prob.getDemandShipped(demandName, solutionName);
		assert(shipped == false);
		assert(demandName == "d1");
		assert(solutionName == "d1:AAA:d3");
	}

  }


  }@


1.32
log
@removed a small memory leak
@
text
@d324 8
d480 1
d497 5
@


1.31
log
@changes to support available to promise
@
text
@d579 1
@


1.30
log
@change tolerance, and add some more models for the future
@
text
@d21 1
a21 1
#include "solutionAppData.h"
d49 4
d77 1
d87 11
a97 11
  unsigned int e;
  std::vector<std::string> solutionNames;
  getSolutionNames(solutionNames);
  for ( e=0; e<solutionNames.size(); ++e ) { 
    std::string theSolution = solutionName(solutionNames[e]);
    DPsolutionAppData * srcAppData;    
    DPsolutionAppData * sinkAppData;
    checkWitRC(witGetPartAppData(source.mutableWitRun(),theSolution.c_str(),(void**)&srcAppData));
    sinkAppData = new DPsolutionAppData(*srcAppData);    
    checkWitRC(witSetPartAppData(witRun(),theSolution.c_str(),sinkAppData));
  }
d119 11
a129 9
  unsigned int e;
  std::vector<std::string> solutionNames;
  getSolutionNames(solutionNames);
  for ( e=0; e<solutionNames.size(); ++e ) { 
    std::string theSolution = solutionName(solutionNames[e]);
    DPsolutionAppData * srcAppData;  
    checkWitRC(witGetOperationAppData(mutableWitRun(),theSolution.c_str(),(void**)&srcAppData));
    delete srcAppData;
  }
d169 24
d263 2
a264 2
  DPsolutionAppData * appData = new DPsolutionAppData(nP);
  checkWitRC(witSetPartAppData(witRun(),theSolution.c_str(),appData));
d267 6
a302 16
#if 0
std::vector<float> demandPlanningProblem::getSolutionReqQuantity(std::string &sName)
{
  std::string theSolution = solutionName(sName);
  DPsolutionAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),theSolution.c_str(),(void**)&appData));
  return appData->getReq();
}
void demandPlanningProblem::setSolutionReqQuantity(std::string sName, int period, float req)
{
  std::string theSolution = solutionName(sName);
  DPsolutionAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),theSolution.c_str(),(void**)&appData));
  appData->setReq(period,req);
}
#endif
d558 7
a564 1
  void demandPlanningProblem::setDemandShipLateAllowance(const std::string & dName, const std::string & sName, int allowance) {
d772 1
a772 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d844 1
a844 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d886 1
a886 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d954 1
a954 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d995 1
a995 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1067 1
a1067 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1108 1
a1108 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1176 1
a1176 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1216 1
a1216 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1274 1
a1274 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
d1333 1
a1333 1
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation);
@


1.29
log
@also run an MRP so that we can find out the required resources. Write out those
results as well. Call witGetMrpConsVol instead of ReqVol to get resource requirements.
@
text
@d78 2
d149 13
d558 14
@


1.28
log
@change directory name
@
text
@d171 2
a172 1
    std::vector<float> reqQty = witGetNameAttribute(witGetPartReqVol,rName);
@


1.27
log
@*** empty log message ***
@
text
@d1215 1
a1215 1
    inputDirectory = outputDirectory = "../data/testImplosion_allowlate";
@


1.26
log
@made wedge demand have a lower priority than opportunity
@
text
@d20 1
d1153 177
@


1.25
log
@changes to deal properly with durations, incLotSize, simulation/implosion, etc.
@
text
@d507 1
a507 1
		  setDemandPriority(dName,sName,2);
@


1.24
log
@implosion examples/code
@
text
@d219 7
d528 13
d556 11
@


1.23
log
@added support for "ship late allowance"
@
text
@d140 6
d450 26
a475 1
  void demandPlanningProblem::addDemand(const std::string &dName, const std::string &sName) {
d477 2
d487 1
d498 14
d683 1
a683 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d755 1
a755 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d797 1
a797 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d865 1
a865 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d906 1
a906 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d978 1
a978 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d1019 1
a1019 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
d1087 1
a1087 2
	bool mrpProblem = true;
    populateWithDuration(prob, inputDirectory, outputDirectory,simulation,mrpProblem);
@


1.22
log
@added support for doing heuristic implosion given resource supply quantity
@
text
@d458 5
a462 1
      delete [] demandVol;
d465 8
@


1.21
log
@handle non-integer durations (not quite done yet though). need to scale last period's quantity by fractional duration.
@
text
@d34 2
d52 2
d75 2
d194 5
d267 6
d433 1
a433 1
     float *offset=floatToFloatStar(-i);
d448 4
a452 9
	  //we need to add a scaling operation
	  //std::string theDemandScaling = demandScalingName(dName,sName);
	  //checkWitRC(witAddOperation(witRun(),theDemandScaling.c_str()));
	  //checkWitRC(witAddPart(witRun(),theDemandScaling.c_str(),WitCAPACITY));
	  //checkWitRC(witAddBomEntry(witRun(),theDemandScaling.c_str(),theSolution.c_str()));
	  //checkWitRC(witAddBopEntry(witRun(),theDemandScaling.c_str(),theDemandScaling.c_str()));

	  //get the duration of the solution. We need to adjust the period of the
	  //demand to be when the solution is DONE
d461 18
d622 3
a624 1
    populateWithDuration(prob, inputDirectory, outputDirectory,false);
d695 3
a697 1
    populateWithDuration(prob, inputDirectory, outputDirectory,false);
d738 3
a740 1
    populateWithDuration(prob, inputDirectory, outputDirectory, false);
d807 3
a809 1
    populateWithDuration(prob, inputDirectory, outputDirectory, false);
d849 3
a851 1
    populateWithDuration(prob, inputDirectory, outputDirectory,false);
d922 3
a924 1
    populateWithDuration(prob, inputDirectory, outputDirectory,false);
d964 3
a966 1
    populateWithDuration(prob, inputDirectory, outputDirectory, false);
d1033 3
a1035 1
    populateWithDuration(prob, inputDirectory, outputDirectory, false);
@


1.20
log
@put back in a model which includes durations for projects (for
avail to promise potential work).
@
text
@d675 1
@


1.19
log
@changed to "one period" solutions to better handle ongoing and wedge demands
@
text
@d405 19
d463 10
d582 2
d592 219
a810 1
    populate(prob, inputDirectory, outputDirectory,false);
d881 1
a881 1
    populate(prob, inputDirectory, outputDirectory,false);
d921 1
a921 1
    populate(prob, inputDirectory, outputDirectory, false);
d988 1
a988 1
    populate(prob, inputDirectory, outputDirectory, false);
@


1.18
log
@simulation for variance
@
text
@d169 1
d185 1
d216 1
a216 13
void demandPlanningProblem::setSolutionDuration(const std::string & sName, int periods) {
        DPsolutionAppData * appData;
		std::string theSolution = solutionName(sName);
		checkWitRC(witGetPartAppData(mutableWitRun(),theSolution.c_str(),(void**)&appData));
		appData->setDuration(periods);
}
int demandPlanningProblem::getSolutionDuration(const std::string & sName) {
        DPsolutionAppData * appData;
		std::string theSolution = solutionName(sName);
        checkWitRC(witGetPartAppData(mutableWitRun(),theSolution.c_str(),(void**)&appData));
        int duration = appData->getDuration();
		return duration;
}
d225 1
d240 1
a366 31
//this gets or adds a uniform set of bom entries over the duration of the
//solution. We are using a trick here to enable ongoing engagements
//to be treated in a clean way.
float demandPlanningProblem::getConstantResourceRequirement(const std::string &sName,const std::vector<std::string> &resourceIdentifierValues) {
	std::string theSolution = solutionName(sName);
	std::string resName = baseResourceName(resourceIdentifierValues);
	//get the boms for the solution
	int numBomEntries;
	checkWitRC(witGetOperationNBomEntries(witRun(),theSolution.c_str(),&numBomEntries));
	for (int j=0; j<numBomEntries; j++) {
		char * partName;
		float *consRate;
		checkWitRC(witGetBomEntryConsumedPart(witRun(),theSolution.c_str(),j,&partName));
		if (partName==resName) {
			checkWitRC(witGetBomEntryConsRate(witRun(),theSolution.c_str(),j,&consRate));
		    //any are ok to return; all the same
			float retVal = consRate[0];
			checkWitRC(witFree(partName));
			checkWitRC(witFree(consRate));
			return retVal;
		}
		checkWitRC(witFree(partName));
	}
    return -1;
}
void demandPlanningProblem::addConstantResourceRequirement(const std::string & sName, 
                        const std::vector<std::string> &resourceIdentifierValues,
						float hoursPerSolnHour)
{ 
  std::string resourceName = baseResourceName(resourceIdentifierValues);
  std::string theSolution = solutionName(sName);
d368 1
a368 15
  //for each period in the duration, we need to add a bom entry 
  int duration = getSolutionDuration(sName);
  for (int i=0; i<duration; i++) {
	  checkWitRC(witAddBomEntry(witRun(),theSolution.c_str(), resourceName.c_str()));
	  int added;
      checkWitRC(witGetOperationNBomEntries(witRun(),theSolution.c_str(),&added));
	  float *consrate = floatToFloatStar(hoursPerSolnHour);  
	  float * offset = floatToFloatStar((float)i);
	  checkWitRC(witSetBomEntryOffset(witRun(),theSolution.c_str(),added-1,offset));
	  checkWitRC(witSetBomEntryConsRate(witRun(),theSolution.c_str(),added-1,consrate));
	  checkWitRC(witSetBomEntryEarliestPeriod(witRun(),theSolution.c_str(),added-1,i));
	  delete [] consrate;
	  delete [] offset;
  }
}
d393 1
a393 1
						int period, float hoursPerSolnHour)
a397 5
  //for the period, we need to add a bom entry 
  int duration = getSolutionDuration(sName);
  if (period>duration-1) {

  }
a401 2
  float * offset = floatToFloatStar((float)period);
  checkWitRC(witSetBomEntryOffset(witRun(),theSolution.c_str(),added-1,offset));
a402 1
  checkWitRC(witSetBomEntryEarliestPeriod(witRun(),theSolution.c_str(),added-1,period));
a403 1
  delete [] offset;
a421 1
	  int duration = getSolutionDuration(sName);
d430 1
a430 13
  void demandPlanningProblem::resetDemandQuantity(const std::string &dName, const std::string &sName, int period, float quantity) {
 	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);

	  float * demandVol = floatToFloatStar(0.0);
	  int duration = getSolutionDuration(sName);
	  demandVol[period+duration-1]=quantity;
	  checkWitRC(witSetDemandDemandVol(witRun(),theSolution.c_str(), theDemand.c_str(), demandVol));


      delete [] demandVol;

  }
d438 2
a439 2
	  int duration = getSolutionDuration(sName);
	  demandVol[period+duration-1]=quantity;
a441 4
	  //we need to add a scaling operation
	  //std::string theDemandScaling = demandScalingName(dName,sName);
      //float * productRate = floatToFloatStar(1.0f/quantity);
	  //checkWitRC(witSetBopEntryProductRate(witRun(),theDemandScaling.c_str(),0,productRate));
d483 1
a483 4
    assert( prob.getSolutionDuration("s1") == 0 );
    prob.setSolutionDuration("s1",4);
    assert( prob.getSolutionDuration("s1") == 4 );
    
d491 1
a491 6
    prob.setSolutionReqQuantity(solutionNames[0],0,1.2f);
	prob.setSolutionReqQuantity(solutionNames[0],1,3.4f);
	std::vector<float> req = prob.getSolutionReqQuantity(solutionNames[0]);
	assert(eq(req[0],1.2f));
	assert(eq(req[1],3.4f));
	assert(eq(req[2],0.0f));
a552 17
  //bom
  {
	  demandPlanningProblem prob;
	  prob.setNPeriods(4);
	  std::vector<std::string> rName;
	  rName.push_back("jr");
	  rName.push_back("ss");
	  float hours = 2.0f;
	  prob.addResourceIdentifierName("jobRole");
	  prob.addResourceIdentifierName("skillSet");
	  std::string sName = "sss";
	  prob.addSolution(sName);
	  prob.setSolutionDuration(sName,2);
	  prob.addResource(rName);
	  prob.addConstantResourceRequirement(sName,rName,hours);
	  float h = prob.getConstantResourceRequirement(sName,rName);
	  assert(eq(h,2.0f));
a553 1
  }
d569 4
a572 4
    assert(eq(reqQty[0],0.3f ));
    assert(eq(reqQty[1],0.3f ));
    assert(eq(reqQty[2],1.6f ));
    assert(eq(reqQty[3],1.3f ));
d589 2
a590 2
    assert(eq(reqQty[2],0.4f ));
    assert(eq(reqQty[3],0.4f ));
d622 44
a769 12
	//check the solution requirements
	std::string solName="AAA";
	reqQty = prob.getSolutionReqQuantity(solName);
	assert(eq(reqQty[0],0.0f ));
	assert(eq(reqQty[1],0.0f ));
	assert(eq(reqQty[2],0.5f ));
	assert(eq(reqQty[3],1.25f ));
	assert(eq(reqQty[4],0.75f ));
	assert(eq(reqQty[5],0.0f ));
	assert(eq(reqQty[6],0.0f ));
	assert(eq(reqQty[7],0.0f ));
	assert(eq(reqQty[8],0.0f ));
a770 11
	solName="BBB";
	reqQty = prob.getSolutionReqQuantity(solName);
	assert(eq(reqQty[0],0.81f ));
	assert(eq(reqQty[1],1.89f ));
	assert(eq(reqQty[2],0.0f ));
	assert(eq(reqQty[3],0.0f ));
	assert(eq(reqQty[4],0.0f ));
	assert(eq(reqQty[5],0.0f ));
	assert(eq(reqQty[6],0.0f ));
	assert(eq(reqQty[7],0.0f ));
	assert(eq(reqQty[8],0.0f ));
@


1.17
log
@changed model to remove intermediate operation/part to do the 1/quantity. Now I just apply the probability directly to the quantity demanded.
@
text
@d493 13
a546 4
#if 0



a547 1
#endif
@


1.16
log
@improved the names of some routines
@
text
@d136 1
d138 7
a144 1

d164 1
d171 4
a174 2
      float *reqQty;
	  checkWitRC(witGetPartMrpConsVol(mutableWitRun(),theSolution.c_str(),&reqQty));
d182 1
a182 1
	  checkWitRC(witFree(reqQty));
d476 5
a480 5
	  std::string theDemandScaling = demandScalingName(dName,sName);
	  checkWitRC(witAddOperation(witRun(),theDemandScaling.c_str()));
	  checkWitRC(witAddPart(witRun(),theDemandScaling.c_str(),WitCAPACITY));
	  checkWitRC(witAddBomEntry(witRun(),theDemandScaling.c_str(),theSolution.c_str()));
	  checkWitRC(witAddBopEntry(witRun(),theDemandScaling.c_str(),theDemandScaling.c_str()));
d486 1
a486 1
      checkWitRC(witAddDemand(witRun(),theDemandScaling.c_str(),theDemand.c_str()));
d489 1
a489 1
	  checkWitRC(witSetDemandDemandVol(witRun(),theDemandScaling.c_str(),theDemand.c_str(),demandVol));
d497 3
a499 11
	  //we need to add a scaling operation
	  std::string theDemandScaling = demandScalingName(dName,sName);
      float * productRate = floatToFloatStar(1.0f/quantity);
	  checkWitRC(witSetBopEntryProductRate(witRun(),theDemandScaling.c_str(),0,productRate));
      delete [] productRate;
}
void demandPlanningProblem::setDemandProbability(const std::string &dName, const std::string &sName, int period, float probability) {
	  
	  std::string theSolution = solutionName(sName);
	  std::string theDemand = demandName(dName);
	  std::string theDemandScaling = demandScalingName(dName,sName);
d501 2
d504 4
a507 5
	  //do the probability
	  float * demandVol;
	  checkWitRC(witGetDemandDemandVol(witRun(),theDemandScaling.c_str(),theDemand.c_str(),&demandVol));
	  demandVol[period+duration-1]=probability;
	  checkWitRC(witSetDemandDemandVol(witRun(),theDemandScaling.c_str(),theDemand.c_str(),demandVol));
d510 1
d521 4
a524 4
std::string demandPlanningProblem::demandScalingName(const std::string & dName, const std::string & sName )const
{
	return "demand: "+dName + " solution: " + sName;
}
d658 1
a658 1
    populate(prob, inputDirectory, outputDirectory);
d725 1
a725 1
    populate(prob, inputDirectory, outputDirectory);
d792 1
a792 1
    populate(prob, inputDirectory, outputDirectory);
@


1.15
log
@more testing of api for ::test
@
text
@d365 1
a365 1
//this adds a uniform set of bom entries over the duration of the
d368 1
a368 1
float demandPlanningProblem::getBomEntryQuantity(const std::string &sName,const std::vector<std::string> &resourceIdentifierValues) {
d390 1
a390 1
void demandPlanningProblem::addBomEntries(const std::string & sName, 
d412 45
d642 2
a643 2
	  prob.addBomEntries(sName,rName,hours);
	  float h = prob.getBomEntryQuantity(sName,rName);
@


1.14
log
@changes related to accumulating requirements for each solution over
time (for Mark S)
@
text
@d167 4
a170 1
		  setSolutionReqQuantity(sNames[s],t,reqQty[t]);
a235 1
  int duration = getSolutionDuration(sName);
d237 1
a237 2
  //I put the requirement back to the beginning of the solution engagement
  appData->setReq(period-duration+1,req);
d368 22
d395 1
a395 1
  std::string solName = solutionName(sName);
d400 1
a400 1
	  checkWitRC(witAddBomEntry(witRun(),solName.c_str(), resourceName.c_str()));
d402 1
a402 1
      checkWitRC(witGetOperationNBomEntries(witRun(),solName.c_str(),&added));
a403 1
	  //float * offset = floatToFloatStar((float)-i);
d405 3
a407 3
	  checkWitRC(witSetBomEntryOffset(witRun(),solName.c_str(),added-1,offset));
	  checkWitRC(witSetBomEntryConsRate(witRun(),solName.c_str(),added-1,consrate));
	  checkWitRC(witSetBomEntryEarliestPeriod(witRun(),solName.c_str(),added-1,i));
a480 2
    demandPlanningProblem prob;
    prob.setNPeriods(2);
d484 7
d493 3
d515 7
a521 1
    
d524 1
a524 2
 	std::cerr <<"resources";
 
d532 3
d536 1
a536 3
    //assert( prob.resourceIdentifierNameExists("jobRole") );
    //assert( !prob.resourceIdentifierNameExists("jobRoleXX") );
    
a539 1
   
a544 1
    
d546 55
a600 10
    
    std::vector<DPvectorString> resNames;
    prob.getResourceNames(resNames);
    assert(resNames.size()==2);
    assert( resNames[0][0]=="appDeveloper" || resNames[1][0]=="appDeveloper" );
    assert( resNames[0][0]=="architect" || resNames[1][0]=="architect" );
    
    assert( resNames[0][1]=="java" || resNames[1][1]=="java" );
    assert( resNames[0][1]=="c++" || resNames[1][1]=="c++" );
    
d602 1
a602 1
  std::cerr <<"firstExample";
@


1.13
log
@testing messages
@
text
@d157 15
d182 3
a184 2
  DPsolutionAppData * appData = new DPsolutionAppData();
  checkWitRC(witSetOperationAppData(witRun(),theSolution.c_str(),appData));
d204 1
a204 1
		checkWitRC(witGetOperationAppData(mutableWitRun(),theSolution.c_str(),(void**)&appData));
d210 1
a210 1
        checkWitRC(witGetOperationAppData(mutableWitRun(),theSolution.c_str(),(void**)&appData));
d222 1
a222 1
std::string demandPlanningProblem::demandName(const std::string & dName )const
d224 4
a227 1
  return "demand: "+dName;
d229 1
a229 1
std::string demandPlanningProblem::demandScalingName(const std::string & dName, const std::string & sName )const
d231 6
a236 1
	return "demand: "+dName + " solution: " + sName;
a238 1

d438 1
a438 1
      witFree( demandVol);
d446 9
d695 25
@


1.12
log
@misc updates.
@
text
@d434 2
d456 2
a457 1
  
d491 1
d559 2
d626 2
@


1.11
log
@fix memory leak
@
text
@a630 1
	float foo=reqQty[0];
d634 1
a634 2
	    assert(eq(reqQty[7],0.0f ));
    foo = reqQty[3];
@


1.10
log
@handle odds and uncertain start times. Unit test was updated as well
@
text
@d403 1
a403 1
  void demandPlanningProblem::setDemandProbability(const std::string &dName, const std::string &sName, int period, float probability) {
a410 1
	  int nPeriods = getNPeriods();
d415 1
a415 1
     // delete [] demandVol;
@


1.9
log
@uncertain start probability
@
text
@d210 4
a213 1

d370 1
a370 1
  void demandPlanningProblem::addDemand(const std::string &dName, const std::string &sName, int period, float quantity) {
d375 7
d386 2
a387 6
	  //only add it if we haven't already
	  if (!witGetDemandExists(theSolution,theDemand))
		  checkWitRC(witAddDemand(witRun(),theSolution.c_str(),theDemand.c_str()));
	  
	  //do the quantity
	  int nPeriods = getNPeriods();
d389 2
a390 2
	  demandVol[period+duration-1]=quantity;
	  checkWitRC(witSetDemandDemandVol(witRun(),theSolution.c_str(),theDemand.c_str(),demandVol));
d392 17
a408 1
      delete [] demandVol;
d410 7
a416 1
  
d431 1
a431 1
    CoinRelFltEq eq;
d556 103
a658 1
  
@


1.8
log
@ongoing demand is now added
@
text
@d376 3
a378 1
	  checkWitRC(witAddDemand(witRun(),theSolution.c_str(),theDemand.c_str()));
@


1.7
log
@added trick with placing demand at *end* of solution duration, with positive
offsets, and with first periods on boms set.
@
text
@d507 18
@


1.6
log
@added unit test
@
text
@d22 1
d339 2
a340 1
//solution
d355 2
a356 1
	  float * offset = floatToFloatStar((float)-i);
d358 2
a359 1
	  witSetBomEntryConsRate(witRun(),solName.c_str(),added-1,consrate);
d371 5
d381 1
a381 1
	  demandVol[period]=quantity;
d400 3
a402 1
    
d459 50
@


1.5
log
@updates
@
text
@d32 2
a33 1
SCOproblemBase()
d48 2
a49 1
SCOproblemBase(source)
d69 29
a97 1
  
d103 26
d166 1
a166 1
  DPsolutionAppData * appData = new DPsolutionAppData;
d168 5
a172 10

  //Set the scrap cost for the engagement to a trivial quantity to prevent extra quantity from being built
  //float * scrapCost = floatToFloatStar(1.0f);
  //checkWitRC(witSetPartObj1ScrapCost(witRun(),theSolution.c_str(),scrapCost));
  //delete [] scrapCost;


  //float * vecOne = floatToFloatStar(1.0);
  //checkWitRC(witSetOperationIncLotSize(witRun(),theEngagement.c_str(),vecOne));
  //delete [] vecOne;
d174 4
a177 4
  //RCPengagementAppData * appData = new RCPengagementAppData;
  //checkWitRC(witSetPartAppData(witRun(),theEngagement.c_str(),appData));
  
  solutionNames_.insert(theSolution);
d201 4
d375 1
d384 64
@


1.4
log
@*** empty log message ***
@
text
@d21 1
d82 19
d146 1
a146 1
std::string demandPlanningProblem::solutionName(const std::string & sName )
d150 4
d160 2
d166 4
a169 1

d209 68
d295 6
a300 4
      float *consrate = floatToFloatStar(hoursPerSolnHour);  
	  float * offset = floatToFloatStar(-i);
	  checkWitRC(witSetBomEntryOffset(witRun(),solName.c_str(),i,offset));
	  witSetBomEntryConsRate(witRun(),solName.c_str(),i,consrate);
d304 15
d323 6
@


1.3
log
@new files
@
text
@d108 5
d126 1
a126 1
std::string demandPlanningProblem::solutionName(const std::string & solutionName )
d128 1
a128 1
  return "solution: "+solutionName;
@


1.2
log
@new files for appdata
@
text
@d75 6
d170 5
@


1.1
log
@Initial revision
@
text
@d20 1
d76 71
d148 4
d153 36
d190 3
@


1.1.1.1
log
@initial import
@
text
@@

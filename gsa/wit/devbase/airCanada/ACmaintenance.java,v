head	1.50;
access;
symbols;
locks; strict;
comment	@# @;


1.50
date	2002.12.16.19.49.10;	author yingdong;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.16.15.20.52;	author yingdong;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.04.21.22.25;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.04.21.18.58;	author fasano;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.04.16.57.44;	author yingdong;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.02.13.56.47;	author yingdong;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.25.21.29.24;	author yingdong;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.25.21.08.47;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.25.18.33.14;	author yingdong;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.25.18.07.17;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.25.17.49.10;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.25.17.47.16;	author fasano;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.25.13.41.47;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.25.11.45.16;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.24.21.44.43;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.24.16.42.05;	author yingdong;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.24.05.10.59;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.23.18.40.34;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.23.00.13.31;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.22.22.03.22;	author yingdong;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.22.20.38.48;	author yingdong;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.22.15.53.07;	author yingdong;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.22.06.06.01;	author yingdong;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.20.14.02.16;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.20.01.37.23;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.19.20.57.08;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.19.13.45.45;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.18.03.52.32;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.18.03.45.12;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.17.22.20.04;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.17.22.11.44;	author fasano;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.17.16.39.02;	author fasano;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.17.16.06.31;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.14.03.37.59;	author fasano;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.12.22.01.12;	author yingdong;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.12.03.40.02;	author yingdong;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.11.21.49.36;	author yingdong;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.19.42.42;	author yingdong;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.06.19.29.40;	author yingdong;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.06.16.55.30;	author yingdong;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.05.19.54.33;	author yingdong;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.05.19.50.37;	author yingdong;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.05.19.27.59;	author yingdong;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.05.19.09.46;	author yingdong;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.05.17.16.06;	author yingdong;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.05.15.58.43;	author yingdong;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.05.14.47.10;	author yingdong;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.05.14.39.06;	author yingdong;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.05.14.36.39;	author yingdong;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.31.19.33.23;	author yingdong;	state Exp;
branches;
next	;


desc
@@


1.50
log
@no message
@
text
@package com.ibm.mathsci.witApplications.airCanada;

import com.ibm.mathsci.mshcalc.MshException;
import com.ibm.mathsci.witinterface.*;

/**
 * @@author JPF2
 *
 * Air Canada Maintenance
 * This class allows one to:
 *   1. Define Resources
 *   2. Define Maintenance Events
 *   3. Optimally plan maintenance event schdule
 *   4. Get planned maintenance schedule
 *   6. Get consumed resources
 */
public class ACmaintenance extends WitInterface {

	/**
	 * Store info on maintenance event attributes that is not readily available from WitRun.
	 */
	protected class ACmaintenanceEventAttr {

        // PlaneType is an input
        String planeType_ = null;
        
        // ScheduledHangar most be computed after solve method
        String scheduledHangar_ = null;
        
        int plannedDuration_ = 0;
        
        float laborHours_=0.f;
        
		/**
		 * Constructor for ACmaintenanceEvent.
		 */
		public ACmaintenanceEventAttr() {
			super();
		}

		public String getPlaneType() {
			return planeType_;
		}

		public String getScheduledHangar() {
			return scheduledHangar_;
		}

		public void setPlaneType(String planeType_) {
			this.planeType_ = planeType_;
		}

		public void setScheduledHangar(String scheduledHangar_) {
			this.scheduledHangar_ = scheduledHangar_;
		}

		public int getPlannedDuration() {
			return plannedDuration_;
		}

		public void setPlannedDuration(int plannedDuration_) {
			this.plannedDuration_ = plannedDuration_;
		}
	
		public float getLaborHours() {
			return laborHours_;
		}

		public void setLaborHours(float laborHours_) {
			this.laborHours_ = laborHours_;
		}

	}
private WitRun wr_ = null;
private java.util.Vector maintenanceEventNames_ = new java.util.Vector();
static private java.util.Vector locationNames_ = new java.util.Vector();
private boolean hangarsAndLaborDefined_ = false;
private java.util.Hashtable maintenanceEventAttr_ = new java.util.Hashtable();
private ACpegYwgEventsToHangars ywgHangarAssignment_;
private int nPeriods_=26; /* Cache locally to improve perfomance */
     

static {
	locationNames_.add("YUL");
	locationNames_.add("YVR");
	locationNames_.add("YWG");
	locationNames_.add("YYC");
}

    private void setMaintenanceEventPlaneType( String event, String planeType ) {
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	meAttr.setPlaneType(planeType);
    }
    public String getMaintenanceEventPlaneType( String event ) {
    	String retVal;
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	retVal = meAttr.getPlaneType();
    	return retVal;
    }
    private void setMaintenanceEventScheduledHangar( String event, String hangar ) {
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	meAttr.setScheduledHangar(hangar);
    }
    public String getMaintenanceEventScheduledHangar( String event ) {
    	String retVal;
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	retVal = meAttr.getScheduledHangar();
    	return retVal;
    }
    private void setMaintenanceEventPlannedDuration( String event, int d ) {
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	meAttr.setPlannedDuration(d);
    }
    public int getMaintenanceEventPlannedDuration( String event ) {
    	int retVal;
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	retVal = meAttr.getPlannedDuration();
    	return retVal;
    }
    private void setMaintenanceEventLaborHours( String event, float d ) {
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	meAttr.setLaborHours(d);
    }
    public float getMaintenanceEventLaborHours( String event ) {
    	float retVal;
    	ACmaintenanceEventAttr meAttr = (ACmaintenanceEventAttr)maintenanceEventAttr_.get(event);
    	retVal = meAttr.getLaborHours();
    	return retVal;
    }

   	private WitRun witRun() {
		if (wr_ == null) {
			WitRun[] wrP = new WitRun[1];
			int rc;
			wrP[0] = new WitRun();
			try {
				rc = witNewRun(wrP);
		    	wr_ = wrP[0];
		   	    
                // Turn off WIT informational messages
                witSetMesgTimesPrint( wr_, 1, -1, 0);
                // Turn off warning msg about long names.
                witSetMesgTimesPrint( wr_, 1, 338, 0);

		   	    rc = witInitialize(wr_);
		   	    
                witSetObjChoice( wr_, 1 );
                witSetUseFocusHorizons( wr_, 0 );

                witSetExecEmptyBom( wr_, 0 );
                witSetMultiRoute( wr_, 1 );

			} catch (com.ibm.mathsci.mshcalc.MshException e) {
				e.printStackTrace();
			}
		}
		return wr_;
    }
    
	/**
	 * Constructor for ACmaintenance.
	 */
	public ACmaintenance() {
		super();
	}
	
	public void finalize() {
		try {
			if (wr_ != null) {
				witDeleteRun(wr_);
				wr_ = null;
			}
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
		}
	}


	
	public void setPlanningHorizon(int numPeriods ) {
	  try {
	    witSetNPeriods(witRun(),numPeriods);
	    nPeriods_=numPeriods;
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	}	
	
	public int getPlanningHorizon() {
	  //int nPeriods[] = new int[1];
	  //try {
	  //  witGetNPeriods(witRun(),nPeriods);
      //} catch (com.ibm.mathsci.mshcalc.MshException e) {
	  //  e.printStackTrace(); System.exit(0);
      //}
	  //return nPeriods[0];
	  return nPeriods_;
	}
	
	public boolean getLaborResourceExists(String location) throws ACexception {
	  boolean retVal = false;
	  try {
	  	int exists[] = { 0 };
	  	String lrn = laborResourceName(location);
	    witGetPartExists(witRun(),lrn,exists);
	    if ( exists[0]==1 ) retVal = true;
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
      return retVal;
	}	
		
	public boolean getMaintenanceEventExists(String eventName) {
	  boolean retVal = false;
	  try {
	  	int exists[] = { 0 };
	    witGetPartExists(witRun(),eventName,exists);
	    if ( exists[0]==1 ) retVal = true;
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
      return retVal;
	}
	
	public void setLocationLaborHoursSupplyVol(
		String location,
		int period,
		float availableSupply)
		throws ACexception {
		try {

	  	    // Make sure hangars are defined
	  	    defineHangarsAndLabor();
	  	
			String lrn = laborResourceName(location);

			// labor resource had better already exist	
			if (!getLaborResourceExists(location)) {
				throw new ACexception(
					"Labor Resource at location " + location 
						+ " does not exist");
			}	

			// check to ensure period is within valid range
			int nP = getPlanningHorizon();
			if (period >= nP) {
				throw new ACexception(
					"Specified period "
						+ period
						+ " is greater than planning horizion");
			}

			// Get the current supplyVol
			float supplyVol[] = getLocationLaborHoursSupplyVol(location);

			// Increment supplyVol by availability
			supplyVol[period] = availableSupply;

			// Set new supplyVol
			witSetPartSupplyVol(witRun(), lrn, supplyVol);

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}

	public float[] getLocationLaborHoursSupplyVol(String location)
		throws ACexception {
		int nP = getPlanningHorizon();
		float supplyVol[][] = new float[1][nP];
		try {

			String lrn = laborResourceName(location);

			// labor resource had better already exist	
			if (!getLaborResourceExists(location)) {
				throw new ACexception(
					"Labor Resource at location "
						+ location
						+ " does not exist");
			}

			witGetPartSupplyVol(witRun(), lrn, supplyVol);

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return supplyVol[0];
	}

	public float[] getLocationLaborHoursConsVol(String location)
		throws ACexception {
		int nP = getPlanningHorizon();
		float vol[][] = new float[1][nP];
		try {

			String lrn = laborResourceName(location);

			// labor resource had better already exist	
			if (!getLaborResourceExists(location)) {
				throw new ACexception(
					"Labor Resource at location "
						+ location
						+ " does not exist");
			}

			witGetPartConsVol(witRun(), lrn, vol);

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return vol[0];
	}

	
	// Return number planes in hangar in each period
	public float[] getHangarUsage( int hangarNumber, String location, String planeType )
	throws ACexception 
	{
		int nP = getPlanningHorizon();
		float retVal[][] = new float[1][nP];
		String hangarName;
		try {

            if ( location==yyc() ) {
            	if ( planeType!=narrow() )throw new ACexception("getHangarUsage. Location YYC does not have planeType " + planeType );
			    if ( hangarNumber!=1 )throw new ACexception("getHangarUsage. Location YYC does not have hangar number " + hangarNumber );
			    hangarName = hangarSpaceName(planeType,location);
			    witGetPartConsVol(witRun(), hangarName, retVal);
            }
            else if ( location==ywg() ) {
            	if ( planeType!=narrow() )throw new ACexception("getHangarUsage. Location YWG does not have planeType " + planeType );
			    if ( hangarNumber==1 ) hangarName = hangar1()+"_at_" + ywg();
			    else if ( hangarNumber==2 ) hangarName = hangar2()+"_at_" + ywg();
			    else throw new ACexception("getHangarUsage. Location YWG does not have hangar number " + hangarNumber );
	
	             int hangConsVol[] = ywgHangarAssignment_.getHangarUsage(hangarNumber);
	             for (int t=0; t<nP; t++ ) retVal[0][t]=hangConsVol[t];
			     }
            else if ( location==yvr() ) {
                if ( hangarNumber!=1 )throw new ACexception("getHangarUsage. Location YVR does not have hangar number " + hangarNumber );
			    hangarName = hangarSpaceName(planeType,location);
			    witGetPartConsVol(witRun(), hangarName, retVal);
		    }
            else if ( location==yul() ) {
            	if ( hangarNumber<1 || hangarNumber>2 )throw new ACexception("getHangarUsage. Location YUL does not have hangar number " + hangarNumber ); 
	            if ( hangarNumber==1 && planeType==narrow() ) throw new ACexception("getHangarUsage. Location YUL does not have narrow planes in hangar 1");
	            if ( hangarNumber==2 && planeType==b747() ) throw new ACexception("getHangarUsage. Location YUL does not have B747 planes in hangar 2");
	            hangarName = hangarSpaceName(planeType,location);
	            if ( planeType==wide() ) {
	            	if ( hangarNumber==1 ) hangarName+="_"+hangar1();
	            	else  hangarName+="_"+hangar2();
	            }
		    	witGetPartConsVol(witRun(), hangarName, retVal);
	        }
	        else {
	        	throw new ACexception("getHangarUsage. Unknown location specified: " + location );
	        }

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return retVal[0];
	}
    
    
    public void addMaintenanceEvent(String eventName) 
	throws ACexception {
	  try {
	  	if ( getMaintenanceEventExists(eventName) ) {
	  		throw new ACexception(
	  		  "Cannot addMaintenanceEvent. Event named " + eventName +
	  		  " already exists.");
	  	}
	  	
	  	// Make sure hangars are defined
	  	defineHangarsAndLabor();
	  	
	    witAddPart(witRun(),eventName,getWitAttr("WitMATERIAL"));
	    witAddDemand(witRun(),eventName,eventName);
	    
	    // Maintain a vector of maintenance events
	    maintenanceEventNames_.add(eventName);
	    
	    // Maintain a table of supplemental maintenance event attributes
    	maintenanceEventAttr_.put(eventName,new ACmaintenanceEventAttr());
	    
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	}
	
	public java.util.Vector getMaintenanceEvents() 
	{
		return maintenanceEventNames_;
	}
	

	
	
	
	static public java.util.Vector getLocations() 
	{
		return locationNames_;
	}
	
	
	
	public int getMaintenanceEventDesiredStartPeriod(String eventName)
	throws ACexception {
		int retVal = -1;
		try {
			if ( !getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventPlannedStartPeriod. Event named "
						+ eventName
						+ " does not exist.");
		     }
			

			// Get wit shipVol to determine events scheduled date
			int nP = getPlanningHorizon();
			float shipVol[][] = new float[1][nP];
			
			witGetDemandDemandVol(witRun(), eventName, eventName, shipVol);

			for (int t = 0;t < nP;t++) {
				if (shipVol[0][t] != 0) {
					retVal = t;
					break;
				}
			}

			
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return retVal;
	}
		  	
	public int getMaintenanceEventScheduledStartPeriod(String eventName)
		throws ACexception {
	    int retVal = -1;
		int nP = getPlanningHorizon();
		float prodVol[][] = new float[1][nP];
		try {

			if ( !getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventScheduledStartPeriod. Event named "
						+ eventName
						+ " does not exist.");
		}

			witGetPartProdVol(witRun(),eventName, prodVol);
			for (int t=0; t<nP; t++ ) {
				float pvt = prodVol[0][t];
				if ( prodVol[0][t]!=0.f ) {
					retVal = t;
					float fraction=1;
					if ( prodVol[0][t]!=1.f ) {
			//	       throw new ACexception(
			//		       "getMaintenanceEventScheduledStartPeriod: Non-integer prodVol. "
			//			+ "prodVol["+t+"]="+prodVol[0][t]);
			         fraction=prodVol[0][t];
					}
					break;
				}
			}

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return retVal;
	}


     public float getMaintenanceEventScheduledStartFraction(String eventName)
		throws ACexception {
	    int retVal = -1;
	    float fraction=0;
		int nP = getPlanningHorizon();
		float prodVol[][] = new float[1][nP];
		try {

			if ( !getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventScheduledStartPeriod. Event named "
						+ eventName
						+ " does not exist.");
		}

			witGetPartProdVol(witRun(),eventName, prodVol);
			for (int t=0; t<nP; t++ ) {
				float pvt = prodVol[0][t];
				if ( prodVol[0][t]!=0.f ) {
					retVal = t;
					fraction=1;
					if ( prodVol[0][t]!=1.f ) {
			//	       throw new ACexception(
			//		       "getMaintenanceEventScheduledStartPeriod: Non-integer prodVol. "
			//			+ "prodVol["+t+"]="+prodVol[0][t]);
			         fraction=prodVol[0][t];
					}
					break;
				}
			}

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return fraction;
	}
	// Test that a maintenance event is done in at most one location
	public boolean maintEventsDoNotSpanLocations() throws ACexception {
		boolean retVal = true;
		try {
			int np = getPlanningHorizon();
			float execVol[][] = new float[1][np];
			java.util.Vector mes = getMaintenanceEvents();
			for (int m = 0; m < mes.size(); m++) {
				String eventName = (String) mes.elementAt(m);

				float sumExecVol = 0.0f;
				java.util.Vector locs = getLocations();
				for (int l = 0; l < locs.size(); l++) {
					String loc = (String) locs.elementAt(l);

					String maintLoc =
						maintenanceEventAtLocationName(eventName, loc);

					// If this event can not be done at this location
					// then operation will not exist
					int exists[] = { 0 };
					witGetOperationExists(witRun(), maintLoc, exists);
					if (exists[0] == 0)
						continue;

					witGetOperationExecVol(witRun(), maintLoc, execVol);

					for (int t = 0; t < np; t++) {
						float execVolT = execVol[0][t];
/*						if (execVolT != 0.0 && execVolT != 1.0) {
							throw new ACexception(
								"Fractional execution of maintenance event. For event "
									+ eventName
									+ " the execVol is not 0 or 1.");
						}*/
						sumExecVol += execVolT;
					}
				}

/*				if (sumExecVol != 0.0 && sumExecVol != 1.0) {
					throw new ACexception(
						"Fractional execution of maintenance event. For event "
							+ eventName
							+ " the execVol is not 0 or 1.");
				}*/

				sumExecVol = 0.0f;
			}

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}

		return retVal;
	}

	public String getMaintenanceEventScheduledLocation(String eventName)
		throws ACexception {
		String retVal = none();
		try {
			if (!getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventLocation. Event named "
						+ eventName
						+ " does not exist.");
			}

			int sp = getMaintenanceEventScheduledStartPeriod(eventName);

			if (sp != -1) {
				int np = getPlanningHorizon();
				float execVol[][] = new float[1][np];

				java.util.Vector locs = getLocations();
				for (int l = 0; l < locs.size(); l++) {
					String loc = (String) locs.elementAt(l);

					String maintLoc =
						maintenanceEventAtLocationName(eventName, loc);

					// If this event can not be done at this location
					// then operation will not exist
					int exists[] = { 0 };
					witGetOperationExists(witRun(), maintLoc, exists);
					if (exists[0] == 0)
						continue;

					witGetOperationExecVol(witRun(), maintLoc, execVol);

 /*                   if (execVol[0][sp]!=0.0 && execVol[0][sp]!=1.0 ) {
                    	throw new ACexception(
					      "Cannot getMaintenanceEventLocation. For event "
						   + eventName	+ " the execVol is not 0 or 1.");
                    }*/
					if (execVol[0][sp] > 0.0f ) {
						retVal = loc;
						break;
					}
				}
			}

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return retVal;
	}

  		public String getAnotherMaintenanceEventScheduledLocation(String eventName, String existingLoc)
		throws ACexception {
		String retVal = none();
		try {
			if (!getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventLocation. Event named "
						+ eventName
						+ " does not exist.");
			}

			int sp = getMaintenanceEventScheduledStartPeriod(eventName);

			if (sp != -1) {
				int np = getPlanningHorizon();
				float execVol[][] = new float[1][np];

				java.util.Vector locs = getLocations();
				for (int l = 0; l < locs.size(); l++) {
					String loc = (String) locs.elementAt(l);
					if(loc!=existingLoc){

					String maintLoc =
						maintenanceEventAtLocationName(eventName, loc);

					// If this event can not be done at this location
					// then operation will not exist
					int exists[] = { 0 };
					witGetOperationExists(witRun(), maintLoc, exists);
					if (exists[0] == 0)
						continue;

					witGetOperationExecVol(witRun(), maintLoc, execVol);

 /*                   if (execVol[0][sp]!=0.0 && execVol[0][sp]!=1.0 ) {
                    	throw new ACexception(
					      "Cannot getMaintenanceEventLocation. For event "
						   + eventName	+ " the execVol is not 0 or 1.");
                    }*/
					if (execVol[0][sp] > 0.0f ) {
						retVal = loc;
						break;
					}}
				}
			}

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
		return retVal;
	}
  	

	public void setMaintenanceEventStartPeriodRange(
	  String eventName,
	  int desiredPeriod,
	  int earliestPeriod,
	  int latestPeriod)
	throws ACexception {
	  try {
	  	if ( !getMaintenanceEventExists(eventName) ) {
	  		throw new ACexception(
	  		  "Cannot setMaintenanceEventRequiredCompletionPeriods. Event named " + eventName +
	  		  " does not exist.");
	  	}
	  	int buildAheadUB = desiredPeriod - earliestPeriod;
	  	if ( buildAheadUB < 0 ) {
	  		throw new ACexception(
	  		  "Error setMaintenanceEventRequiredCompletionPeriods. Event named " + eventName +
	  		  ". Cannot have earliestPeriod>desiredPeriod.");
	  	}
	  	int shipLateUB = latestPeriod-desiredPeriod;
	  	if ( shipLateUB < 0 ) {
	  		throw new ACexception(
	  		  "Error setMaintenanceEventRequiredCompletionPeriods. Event named " + eventName +
	  		  ". Cannot have latestPeriod<desiredPeriod.");
	  	}
	  	
	 
	  	int ph = getPlanningHorizon();	  	
	  	
	  	int baub[] = new int [ph];
	  	for ( int t=0; t<ph; t++ ) baub[t] = 0;
	  	for ( int t=desiredPeriod; buildAheadUB>0 && t>=0; t-- ) {
	  		baub[t]=buildAheadUB;
	  		buildAheadUB--;
	  	}
	    witSetPartBuildAheadUB(witRun(),eventName,baub);
	    witSetPartBuildNstn(witRun(),eventName,1);
	    
	  	int slub[] = new int [ph];
	  	for ( int t=0; t<ph; t++ ) slub[t] = 0;
	  	for ( int t=desiredPeriod; shipLateUB>0 && t<ph; t++ ) {
	  		slub[t]=shipLateUB;
	  		shipLateUB--;
	  	}
	    witSetDemandShipLateUB(witRun(),eventName,eventName,slub);
	    
	  	float dv[] = new float [ph];
	  	for ( int t=0; t<ph; t++ ) dv[t] = 0;
	  	dv[desiredPeriod]=1.0f;
	    witSetDemandDemandVol(witRun(),eventName,eventName,dv);
	    
	    float shipReward[] = new float [ph];
	  	for ( int t=0; t<ph; t++ ) shipReward[t] = 0;

	  	float duration = getMaintenanceEventPlannedDuration(eventName);
	  	String planeType =  getMaintenanceEventPlaneType(eventName);
	  	shipReward[desiredPeriod] = duration*1000.00f;
	  	if ( planeType==wide() ) shipReward[desiredPeriod]=shipReward[desiredPeriod]*100000.0f;
	  	else shipReward[desiredPeriod]=0.f;
	  	for ( int t=desiredPeriod-1; t>=0; t-- ) {
	  		if ( baub[t]==0.0f ) break;
	  		shipReward[t]=shipReward[t+1]/2.0f;
	  	}
	  	for ( int t=desiredPeriod+1; t<ph; t++ ) {
	  		if ( slub[t]==0.0f ) break;
	  		shipReward[t]=shipReward[t-1]/10.0f;
	  	}
	  	witSetDemandObj1ShipReward(witRun(),eventName,eventName,shipReward);
	    
	  	int priority[] = new int [ph];
	  	for ( int t=0; t<ph; t++ ) priority[t] = 1;
	    witSetDemandPriority(witRun(),eventName,eventName,priority);
	    
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	}
	
	 private void addMaintenanceEventResourceLinks(
		String maintEvent,
		String location,
		String planeType,
		int duration,
		float totalLaborHours)
		throws ACexception {
		try {
			if (!getMaintenanceEventExists(maintEvent)) {
				throw new ACexception(
					"Cannot addMaintenanceEventResourceLinks because event does not exist. Event named "
						+ maintEvent);
			}

			String labor = laborResourceName(location);
			String hangar = hangarSpaceName(planeType, location, duration);
			String maintLoc =
				maintenanceEventAtLocationName(maintEvent, location);

           // Make sure link does not already exist
           int exists[] = { 0 };
	  	   witGetOperationExists(witRun(),maintLoc,exists);
	       if ( exists[0]==1 )  {
				throw new ACexception(
					"Cannot addMaintenanceEventResourceLinks because link already exists. Event named "
						+ maintEvent
						+ ". Location is " + location);
		    }
	    
	    
			int np = getPlanningHorizon();
			float incLotSize[] = new float[np];
			for (int t = 0; t < np; t++) incLotSize[t]=1.0f;
			
			witAddOperation(witRun(), maintLoc);
			witSetOperationIncLotSize(witRun(),maintLoc,incLotSize);
			witAddBopEntry(witRun(), maintLoc, maintEvent);
			setMaintenanceEventPlannedDuration( maintEvent, duration );

			float offset[][]      = new float[1][np];
			float consRate[][] = new float[1][np];
			float dailyConsRate = totalLaborHours/duration;
			for (int t = 0; t < np; t++) {
				consRate[0][t] = dailyConsRate;
			}

			// connect to labor. One bomEntry for each day of duration
			for (int be = 0; be < duration; be++) {
				witAddBomEntry(witRun(), maintLoc, labor);

				// Set offset. Becareful with this. It is tricky
				for (int t = 0; t < np; t++) {
					offset[0][t] = be-duration+1;
				}
				witSetBomEntryOffset(witRun(), maintLoc, be, offset[0]);
				witSetBomEntryConsRate(witRun(), maintLoc, be, consRate[0]);
			}


			// Unfortunately connecting to hangar depends on the location
			// and planeType.
			if (location == yul() && planeType == wide()) {
				defineWideAtYulForNnnDays(duration);
				witAddBomEntry(witRun(), maintLoc, hangar);
			} else {
				// connect to hangar. One bomEntry for each day of duration
				for (int be = 0; be < duration; be++) {
					witAddBomEntry(witRun(), maintLoc, hangar);

					// Set offset. Becareful with this. It is tricky
					for (int t = 0; t < np; t++) offset[0][t] = be-duration+1;
					witSetBomEntryOffset(witRun(),maintLoc,	duration + be,offset[0]);
				}
			}
			
			setMaintenanceEventPlaneType(maintEvent,planeType);
			setMaintenanceEventPlannedDuration(maintEvent,duration);
			setMaintenanceEventLaborHours(maintEvent,totalLaborHours);

		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}
	
		
	public void addMaintenanceEventResourceLinks(
		String maintEvent,
		String planeType,
		int duration,
		float totalLaborHours)
		throws ACexception {
		// add event if to all locations that can accomodate
		// this type of plane	
		if (planeType == narrow()) {
			addMaintenanceEventResourceLinks(
				maintEvent,
				ywg(),
				planeType,
				duration,
				totalLaborHours);
				
			addMaintenanceEventResourceLinks(
				maintEvent,
				yyc(),
				planeType,
				duration,
				totalLaborHours);		
		}
		addMaintenanceEventResourceLinks(
			maintEvent,
			yul(),
			planeType,
			duration,
			totalLaborHours);
		addMaintenanceEventResourceLinks(
			maintEvent,
			yvr(),
			planeType,
			duration,
			totalLaborHours);
	}
	
	/**
	 * Class for assigning hangars to maintenance events at YWG.
	 * There are 2 narrow hangars to be assigned.
	 */
	class ACpegYwgEventsToHangars {

		int nPlanesInHangar[][] = null;
		
		public ACpegYwgEventsToHangars(int np) {
			super();
			nPlanesInHangar = new int[2][np];
			for (int h = 0; h < 2; h++) {
				for (int t = 0; t < np; t++) {
					nPlanesInHangar[h][t] = 0;
				}
			}
		}

		public int[] getHangarUsage(int hangarNumber) {
			return nPlanesInHangar[hangarNumber-1];
		}
		
		// given startPeriod and duration assign event to a hangar
		public String assignedHangar(
			String event,
			int startPeriod,
			int duration)
			throws ACexception {
			String retVal;
			// Check to see if there is room in hangar 1
			boolean roomInH1 = true;
			for (int t = startPeriod; t < startPeriod + duration; t++) {
				if (nPlanesInHangar[0][t] >= 5) {
					roomInH1 = false;
					break;
				}
			}
			if (roomInH1) {
				// Allocate maintenance event to H1
				for (int t = startPeriod; t < startPeriod + duration; t++) {
					nPlanesInHangar[0][t]++;
				}
				retVal = hangar1();
			} else {
				// Allocate plane to hangar 2
				for (int t = startPeriod; t < startPeriod + duration; t++) {
					if (nPlanesInHangar[1][t] >= 2) {
						throw new ACexception("ACmaintenance: Problem allocating planes to YWG Hangars ");
					}
					nPlanesInHangar[1][t]++;
				}
				retVal = hangar2();
			}
			return retVal;
		}
	}
	
	public void solve() throws ACexception {
		try {
			// Select LP or Heuristic
			// For mip, set OptWitLotSizes to 1 and use OptImplode
			//witSetOptWithLotSizes(witRun(),1);
			witOptImplode(witRun());
			//witHeurImplode(witRun());
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}

		//Solve is completed. Do postProcessing

		// Determine maintenance event hangar allocation
		//try {
			// Loop once for each event
			java.util.Vector events = getMaintenanceEvents();
			for (int e = 0; e < events.size(); e++) {
				String eventName = (String) events.elementAt(e);
				System.out.println("Postprocess: event "+e+" "+eventName);
				String schedLoc =
					getMaintenanceEventScheduledLocation(eventName);
				System.out.println("  schedLoc "+schedLoc);
				String planeType = getMaintenanceEventPlaneType(eventName);
				System.out.println("  planeType "+planeType);

				if (schedLoc == yul()) {
					if (planeType == b747())
						setMaintenanceEventScheduledHangar(
							eventName,
							hangar1());
					else if (planeType == narrow())
						setMaintenanceEventScheduledHangar(
							eventName,
							hangar2());
					else {
						/*
						 * This code is not correct for determing hangar usage.
				    	int pd = getMaintenanceEventPlannedDuration(eventName);
				    	int np = getPlanningHorizon();
						String h1 = yulWideForNnDaysH1(pd);
						String h2 = yulWideForNnDaysH2(pd);
						int ssd = getMaintenanceEventScheduledStartPeriod(eventName);
						float consVol[][] = new float[1][np];
						witGetPartConsVol(witRun(),h1,consVol);
						if ( consVol[0][ssd] != 0 ) {
							setMaintenanceEventScheduledHangar(	eventName,hangar1() );
						} else {
						   witGetPartConsVol(witRun(),h2,consVol);
						   if ( consVol[0][ssd] != 0 ) {
							  setMaintenanceEventScheduledHangar(eventName,hangar2() );
					       } else {
						      setMaintenanceEventScheduledHangar(eventName,"none" ); //Should not get here!!
						   }
						}
						*/
						setMaintenanceEventScheduledHangar(
							eventName,
							hangar1()+"_or_"+hangar2());
					}
				} else if (schedLoc == ywg()) {
					int sp = getMaintenanceEventScheduledStartPeriod(eventName);
					int pd = getMaintenanceEventPlannedDuration(eventName);

					String hangar =
						ywgHangarAssignment_.assignedHangar(eventName, sp, pd);
					setMaintenanceEventScheduledHangar(eventName, hangar);

				} else if (schedLoc == yvr()) {
					setMaintenanceEventScheduledHangar(eventName, hangar1());
				} else if (schedLoc == yyc()) {
					setMaintenanceEventScheduledHangar(eventName, hangar1());
				}
				
				System.out.println("  hangar "+getMaintenanceEventScheduledHangar(eventName));
			}
		//} catch (com.ibm.mathsci.mshcalc.MshException e) {
		//	e.printStackTrace();
		//	System.exit(0);
		//}
	}
	
	
	private static String none() { return "none"; }
	private static String hangar1() { return "H1"; }
	private static String hangar2() { return "H2"; }
	public static String narrow() { return "narrow"; }
	public static String wide() { return "wide"; }
	public static String b747() { return "747"; }
	public static String yul() { return "YUL"; }
	public static String ywg() { return "YWG"; }
	public static String yvr() { return "YVR"; }
	public static String yyc() { return "YYC"; }
			
	private static String yulWideForNnDaysH1(int days) throws ACexception {
		String retVal=null;
		String wideForNnDays = hangarSpaceName(wide(), yul(), days);
		retVal = wideForNnDays + "_at_"+hangar1();
		return retVal;
	}		
	private static String yulWideForNnDaysH2(int days) throws ACexception {
		String retVal=null;
		String wideForNnDays = hangarSpaceName(wide(), yul(), days);
		retVal = wideForNnDays + "_at_"+hangar2();
		return retVal;
	}	

	private static String hangarSpaceName(
	  String planeType, 
	  String location) throws ACexception
    {
    	if ( !getLocations().contains(location) ) {
    		throw new ACexception("Undefined location specified: "+location);
    	}
		return planeType + "_at_" + location;
	}
	private static String hangarSpaceName(
	   String planeType, 
	   String location, 
	   int days )
	{
		String retVal;
		retVal = planeType + "_at_" + location;
		if ( location==yul() && planeType==wide() ) {
			retVal = retVal + "_for_" + Integer.toString(days) + "_days";
		}
		return retVal;
	}
	private static String laborResourceName(String location) throws ACexception
	{
    	if ( !getLocations().contains(location) ) {
    		throw new ACexception("Undefined location specified: "+location);
    	}
		return "Labor_at_" + location;
	}
	private static String maintenanceEventAtLocationName(String maintEvent, String location ) 
	throws ACexception
	{
    	if ( !getLocations().contains(location) ) {
    		throw new ACexception("Undefined location specified: "+location);
    	}
		return maintEvent + "_at_" + location;
	}
	
	private void defineYwgHangar() throws ACexception {
		try {
			String hsn = hangarSpaceName(narrow(), ywg());
			String hangar1Name = hangar1()+"_at_" + ywg();
			String hangar2Name = hangar2()+"_at_" + ywg();

			int nP = getPlanningHorizon();			
			
			// Define YWG pegging class to allocate
			// maintenance events to hangars
			ywgHangarAssignment_ = new ACpegYwgEventsToHangars(nP);
				
			float supplyVol[][] = new float[1][nP];
			for (int t = 0; t < nP; t++)
				supplyVol[0][t] = 1.0f;

			witAddPart(witRun(), hsn, getWitAttr("WitCAPACITY"));

            // Add Hangar 1
			witAddOperation(witRun(), hangar1Name);
			witAddBopEntry(witRun(), hangar1Name, hsn);
			witSetBopEntryProdRate(witRun(), hangar1Name, 0, 5.0f);
			witAddPart(witRun(), hangar1Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), hangar1Name, hangar1Name);
			witSetPartSupplyVol(witRun(),hangar1Name,supplyVol[0]);
			
            // Add Hangar 2
			witAddOperation(witRun(), hangar2Name);
			witAddBopEntry(witRun(), hangar2Name, hsn);
			witSetBopEntryProdRate(witRun(), hangar2Name, 0, 2.0f);
			witAddPart(witRun(), hangar2Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), hangar2Name, hangar2Name);
			witSetPartSupplyVol(witRun(),hangar2Name,supplyVol[0]);
			
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}
		
	private void defineYycHangar() throws ACexception  {
		try {
			String hsn = hangarSpaceName(narrow(), yyc());
			String hangar1Name = hangar1()+"_at_" + yyc();
			
			int nP = getPlanningHorizon();
			float supplyVol[][] = new float[1][nP];
			for (int t = 0; t < nP; t++)
				supplyVol[0][t] = 1.0f;

			witAddPart(witRun(), hsn, getWitAttr("WitCAPACITY"));

            // Add Hangar 1
			witAddOperation(witRun(), hangar1Name);
			witAddBopEntry(witRun(), hangar1Name, hsn);
			witSetBopEntryProdRate(witRun(), hangar1Name, 0, 2.0f);
			witAddPart(witRun(), hangar1Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), hangar1Name, hangar1Name);
			witSetPartSupplyVol(witRun(),hangar1Name,supplyVol[0]);
			
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}

			
	private void defineYvrHangar() throws ACexception {
		try {
			String narrow = hangarSpaceName(narrow(), yvr());
			String wide = hangarSpaceName(wide(), yvr());
			String b747 = hangarSpaceName(b747(), yvr());
			String b747P = b747+"_prime";
			String b747L = b747+"_limitToOne";
			String hangar1Name = hangar1()+"_at_" + yvr();
			
			int nP = getPlanningHorizon();
			float v5[][] = new float[1][nP];
			float v1p2[][] = new float[1][nP];
			float v1p5[][] = new float[1][nP];
			for (int t = 0; t < nP; t++) {
				v5[0][t] = 5.0f;
				v1p2[0][t] = 1.2f;
				v1p5[0][t] = 1.5f;
			}

			witAddPart(witRun(), narrow, getWitAttr("WitCAPACITY"));
			witAddPart(witRun(), wide, getWitAttr("WitCAPACITY"));
			witAddPart(witRun(), b747, getWitAttr("WitCAPACITY"));
			
			witAddOperation(witRun(),narrow);
			witAddOperation(witRun(),wide);
			witAddOperation(witRun(),b747);
			
			witAddBopEntry(witRun(),narrow,narrow);
			witAddBopEntry(witRun(),wide,wide);
			witAddBopEntry(witRun(),b747,b747);

            // Add Hangar 1
			witAddPart(witRun(), hangar1Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), narrow, hangar1Name);
			witAddBomEntry(witRun(), wide, hangar1Name);			
			witSetBomEntryConsRate(witRun(), narrow, 0, v1p2[0]);
			witSetBomEntryConsRate(witRun(), wide, 0, v1p2[0]);
			witSetPartSupplyVol(witRun(),hangar1Name,v5[0]);
			
			// B747 is more complicated to ensure that hangar can only accomodate one 747
			witAddPart(witRun(), b747P, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(),b747,b747P);
			witAddOperation(witRun(),b747P);
			witAddBopEntry(witRun(),b747P,b747P);
			witAddBomEntry(witRun(), b747P, hangar1Name);			
			witSetBomEntryConsRate(witRun(), b747P, 0, v1p5[0]);			
			
			witAddPart(witRun(), b747L, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(),b747,b747L);	
			
			
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}
			
	private void defineYulHangar() throws ACexception {
		try {
			String narrow = hangarSpaceName(narrow(), yul());
			String wide = hangarSpaceName(wide(), yul());
			String wideH1 = wide+"_"+hangar1();
			String wideH2 = wide+"_"+hangar2();
			String b747 = hangarSpaceName(b747(), yul());
			String hangar1Name = hangar1()+"_at_" + yul();
			String hangar2Name = hangar2()+"_at_" + yul();
			
			int nP = getPlanningHorizon();
			float v1[][] = new float[1][nP];
			float v4[][] = new float[1][nP];
			float v1p5[][] = new float[1][nP];
			for (int t = 0; t < nP; t++) {
				v1[0][t]   = 1.0f;
				v1p5[0][t] = 1.5f;
				v4[0][t]   = 4.0f;
			}

			witAddPart(witRun(), narrow, getWitAttr("WitCAPACITY"));
			witAddPart(witRun(), wideH1, getWitAttr("WitCAPACITY"));
			witAddPart(witRun(), wideH2, getWitAttr("WitCAPACITY"));
			witAddPart(witRun(), b747, getWitAttr("WitCAPACITY"));
			
			witAddOperation(witRun(),narrow);
			witAddOperation(witRun(),wideH1);
			witAddOperation(witRun(),wideH2);
			witAddOperation(witRun(),b747);
			
			witAddBopEntry(witRun(),narrow,narrow);
			witAddBopEntry(witRun(),wideH1,wideH1);
			witAddBopEntry(witRun(),wideH2,wideH2);
			witAddBopEntry(witRun(),b747,b747);

            // Add Hangar 1
			witAddPart(witRun(), hangar1Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), b747, hangar1Name);			
			witAddBomEntry(witRun(), wideH1, hangar1Name);			
			witSetBomEntryConsRate(witRun(), b747, 0, v1p5[0]);
			witSetBomEntryConsRate(witRun(), wideH1, 0, v1[0]);
			witSetPartSupplyVol(witRun(),hangar1Name,v4[0]);
			
            // Add Hangar 2
			witAddPart(witRun(), hangar2Name, getWitAttr("WitCAPACITY"));
			witAddBomEntry(witRun(), wideH2, hangar1Name);			
			witAddBomEntry(witRun(), narrow, hangar1Name);			
			witSetBomEntryConsRate(witRun(), wideH2, 0, v1[0]);
			witSetBomEntryConsRate(witRun(), narrow, 0, v1[0]);
			witSetPartSupplyVol(witRun(),hangar2Name,v1[0]);
				
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}
		
	
	private void defineWideAtYulForNnnDays(int days) throws ACexception {
		try {
			String wide = hangarSpaceName(wide(), yul());
			String wideH1 = wide+"_"+hangar1();
			String wideH2 = wide+"_"+hangar2();
			String wideForNnDays = hangarSpaceName(wide(), yul(), days);
			String wideForNnDaysH1 = yulWideForNnDaysH1(days);
			String wideForNnDaysH2 = yulWideForNnDaysH2(days);
			
			// Test to see if WideAtYulForDdd days has already been defined
			int exists[] = { 0 };
	        witGetPartExists(witRun(),wideForNnDays,exists);
			if (exists[0]==0 ) {
				witAddPart(witRun(), wideForNnDays, getWitAttr("WitCAPACITY"));
				witAddOperation(witRun(), wideForNnDaysH1);
				witAddOperation(witRun(), wideForNnDaysH2);

				witAddBopEntry(witRun(), wideForNnDaysH1, wideForNnDays);
				witAddBopEntry(witRun(), wideForNnDaysH2, wideForNnDays);

				// For Heuristic Implosion favor H2 when allocating 
				// wide planes.  This is because H2 can also be used for narrow
				// planes. Narrow planes seem to be available at all locations
				// so it may not be as difficult to find a place for a narrow plane.
				witSetBopEntryExpAversion(witRun(), wideForNnDaysH1, 0, 2.0f);
				witSetBopEntryExpAversion(witRun(), wideForNnDaysH2, 0, 1.0f);

				int nP = getPlanningHorizon();
				float offset[][] = new float[1][nP];

				for (int be = 0; be < days; be++) {
					witAddBomEntry(witRun(), wideForNnDaysH1, wideH1);
					witAddBomEntry(witRun(), wideForNnDaysH2, wideH2);

					// Set offset. Becareful with this. It is tricky
					for (int t = 0; t < nP; t++)
						offset[0][t] = be - days + 1;
					witSetBomEntryOffset(
						witRun(),
						wideForNnDaysH1,
						be,
						offset[0]);
					witSetBomEntryOffset(
						witRun(),
						wideForNnDaysH2,
						be,
						offset[0]);
				}
			}
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}

	private void defineLabor() throws ACexception {
		try {
			java.util.Vector locs = getLocations();
			int nLocs = locs.size();
			for (int l = 0; l < nLocs; l++) {
				String loc = (String) locs.elementAt(l);
				String resourceName = laborResourceName(loc);
				witAddPart(witRun(), resourceName, getWitAttr("WitCAPACITY"));

			}
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}


	private void defineHangarsAndLabor() throws ACexception {
		// Only define hangars once.
		// Do not define in constructor because number
		// of periods in problem is not yet known.
		// Number of periods must be defined before defining hangars.
		if (!hangarsAndLaborDefined_) {
			defineYwgHangar();
			defineYycHangar();
			defineYvrHangar();
			defineYulHangar();
			defineLabor();				
			hangarsAndLaborDefined_ = true;
		}
	}
	
	// Method to test this class by invoking
	// member functions and checking for reasonable
	// results
	public static void test() {

     	// Test some adds, sets, & gets
		try {

			ACmaintenance ac = new ACmaintenance();

			// Test [gs]etPlanningHorizon
			{
				int np = ac.getPlanningHorizon();
				if (np != 26)
					throw new ACexception("getPlanningHorizon failure 1");
				ac.setPlanningHorizon(5);
				np = ac.getPlanningHorizon();
				if (np != 5)
					throw new ACexception("getPlanningHorizon failure 2");
			}

			// Test labor methods
			{
				ac.setLocationLaborHoursSupplyVol("YUL", 3, 23.f);
				float lh[] = ac.getLocationLaborHoursSupplyVol("YUL");
				if (lh[0] != 0.0f)
					throw new ACexception("getLocationLaborHours failure 1");
				if (lh[1] != 0.0f)
					throw new ACexception("getLocationLaborHours failure 2");
				if (lh[2] != 0.0f)
					throw new ACexception("getLocationLaborHours failure 3");
				if (lh[3] != 23.0f)
					throw new ACexception("getLocationLaborHours failure 4");
				if (lh[4] != 0.0f)
					throw new ACexception("getLocationLaborHours failure 5");
			}

			// Test maintenance event methods
			{
				if (ac.getMaintenanceEventExists("M1"))
					throw new ACexception("getMaintenanceEventExists failure 1");
				if (ac.getMaintenanceEvents().size() != 0)
					throw new ACexception("getMaintenanceEvents failure 1");
				ac.addMaintenanceEvent("M1");
				if (!ac.getMaintenanceEventExists("M1"))
					throw new ACexception("getMaintenanceEventExists failure 2");
				if (ac.getMaintenanceEventDesiredStartPeriod("M1") != -1)
					throw new ACexception("getMaintenanceEventPlannedStartPeriod failure 1");
				if (ac.getMaintenanceEvents().size() != 1)
					throw new ACexception("getMaintenanceEvents failure 2");
				if (ac.getMaintenanceEvents().elementAt(0) != "M1")
					throw new ACexception("getMaintenanceEvents failure 3");

				ac.setMaintenanceEventStartPeriodRange("M1", 1, 0, 3);
				if (ac.getMaintenanceEventDesiredStartPeriod("M1") != 1)
					throw new ACexception("getMaintenanceEventPlannedStartPeriod failure 1");
				ac.setMaintenanceEventStartPeriodRange("M1", 2, 0, 3);
				if (ac.getMaintenanceEventDesiredStartPeriod("M1") != 2)
					throw new ACexception("getMaintenanceEventPlannedStartPeriod failure 2");

				ac.addMaintenanceEventResourceLinks("M1", wide(), 2, 300.f);
				ac.addMaintenanceEvent("M2");
				ac.addMaintenanceEventResourceLinks("M2", narrow(), 4, 300.f);
				
				if (ac.getMaintenanceEventPlaneType("M1") != wide() )
					throw new ACexception("getMaintenanceEventPlaneType failure 1");
				if (ac.getMaintenanceEventPlaneType("M2") != narrow() )
					throw new ACexception("getMaintenanceEventPlaneType failure 2");
				
				//ac.setMaintenanceEventPlanning("M1",1,2,400,"YUL");	
			}
			
			ac.solve();
			ac.finalize();
			
		} catch (ACexception ace) {
			ace.printStackTrace();
			System.out.println(ace.getMessage());
		}
     	
		
		// Set up a small problem and run solve to check results
		try  {
			
			String loc=yul();
			String planeType=wide();
			int np = 5;
			ACmaintenance ac = new ACmaintenance();
			ac.setPlanningHorizon(np);
			ac.addMaintenanceEvent("M1");
			ac.setMaintenanceEventStartPeriodRange("M1", 2, 0, 2);
			ac.addMaintenanceEventResourceLinks("M1", planeType, 2, 300.f);
			for (int t=0; t<5; t++ ) ac.setLocationLaborHoursSupplyVol(loc, t, 350.f);
			ac.setLocationLaborHoursSupplyVol(loc, 2, 0.f);
			
			ac.solve();
			
			int p=ac.getMaintenanceEventScheduledStartPeriod("M1");
		   System.out.println("Scheduled starting date for ");
		    	System.out.println("      Maintenance event: M1");
		    	System.out.println("      is "+ p);
		    	
		   String scheduledLocation=ac.getMaintenanceEventScheduledLocation("M1");
		   System.out.println("Scheduled location for ");
		    	System.out.println("      Maintenance event: M1");
		    	System.out.println("      is "+ scheduledLocation);
			float [] hangar1Usage = ac.getHangarUsage(1,loc,planeType);
			float [] hangar2Usage = ac.getHangarUsage(2,loc,planeType);
			float [] laborConsVol = ac.getLocationLaborHoursConsVol(loc);
			int schedPeriod=ac.getMaintenanceEventScheduledStartPeriod("M1");
			if (schedPeriod != 0)
					throw new ACexception("getMaintenanceEventScheduledStartPeriod failure 1");
			String eventLoc=ac.getMaintenanceEventScheduledLocation("M1");
			if (eventLoc != loc)
					throw new ACexception("getMaintenanceEventLocation failure 1");
            
		}
		catch (ACexception ace) {
			ace.printStackTrace();
			System.out.println(ace.getMessage());
		}

		// Test pegging of YWG hangars to maintenance events
		try  {
			
			String loc=ywg();
			String planeType=narrow();
			int np = 5;
			ACmaintenance ac = new ACmaintenance();
			ac.setPlanningHorizon(np);
			for (int t=0; t<5; t++ ) ac.setLocationLaborHoursSupplyVol(loc, t, 1000.f);
			
			ac.addMaintenanceEvent("M0");
			ac.setMaintenanceEventStartPeriodRange("M0", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M0", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M1");
			ac.setMaintenanceEventStartPeriodRange("M1", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M1", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M2");
			ac.setMaintenanceEventStartPeriodRange("M2", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M2", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M3");
			ac.setMaintenanceEventStartPeriodRange("M3", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M3", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M4");
			ac.setMaintenanceEventStartPeriodRange("M4", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M4", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M5");
			ac.setMaintenanceEventStartPeriodRange("M5", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M5", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M6");
			ac.setMaintenanceEventStartPeriodRange("M6", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M6", planeType, 1, 100.f);
			ac.addMaintenanceEvent("M7");
			ac.setMaintenanceEventStartPeriodRange("M7", 2, 2, 2);
			ac.addMaintenanceEventResourceLinks("M7", planeType, 1, 100.f);			
			ac.solve();
			
			// Get some results from planned schedule
			int sp [] = new int[8];
			sp[0]=ac.getMaintenanceEventScheduledStartPeriod("M0");
			sp[1]=ac.getMaintenanceEventScheduledStartPeriod("M1");
			sp[2]=ac.getMaintenanceEventScheduledStartPeriod("M2");
			sp[3]=ac.getMaintenanceEventScheduledStartPeriod("M3");
			sp[4]=ac.getMaintenanceEventScheduledStartPeriod("M4");
			sp[5]=ac.getMaintenanceEventScheduledStartPeriod("M5");
			sp[6]=ac.getMaintenanceEventScheduledStartPeriod("M6");
			sp[7]=ac.getMaintenanceEventScheduledStartPeriod("M7");
			float [] laborConsVol = ac.getLocationLaborHoursConsVol(loc);
			float [] hangar1Usage = ac.getHangarUsage(1,loc,planeType);
			float [] hangar2Usage = ac.getHangarUsage(2,loc,planeType);
			String hang[] = new String[8];
			hang[0]=ac.getMaintenanceEventScheduledHangar("M0");
			hang[1]=ac.getMaintenanceEventScheduledHangar("M1");
			hang[2]=ac.getMaintenanceEventScheduledHangar("M2");
			hang[3]=ac.getMaintenanceEventScheduledHangar("M3");
			hang[4]=ac.getMaintenanceEventScheduledHangar("M4");
			hang[5]=ac.getMaintenanceEventScheduledHangar("M5");
			hang[6]=ac.getMaintenanceEventScheduledHangar("M6");
			hang[7]=ac.getMaintenanceEventScheduledHangar("M7");
			
			// Test results
			if (laborConsVol[0] != 0)
					throw new ACexception("getLocationLaborHoursConsVol failure 1");
			if (laborConsVol[1] != 0)
					throw new ACexception("getLocationLaborHoursConsVol failure 2");
			if (laborConsVol[2] != 700)
					throw new ACexception("getLocationLaborHoursConsVol failure 3");
			if (laborConsVol[3] != 0)
					throw new ACexception("getLocationLaborHoursConsVol failure 4");
			if (laborConsVol[4] != 0)
					throw new ACexception("getLocationLaborHoursConsVol failure 5");
					
			if (hangar1Usage[0]+hangar2Usage[0] != 0)
					throw new ACexception("getHangarUsage failure 1");
			if (hangar1Usage[1]+hangar2Usage[1] != 0)
					throw new ACexception("getHangarUsage failure 2");
			if (hangar1Usage[2]+hangar2Usage[2] != 7)
					throw new ACexception("getHangarUsage failure 3");
			if (hangar1Usage[3]+hangar2Usage[3] != 0)
					throw new ACexception("getHangarUsage failure 4");
			if (hangar1Usage[4]+hangar2Usage[4] != 0)
					throw new ACexception("getHangarUsage failure 5");
					
			int h1Sum = 0;
			int h2Sum = 0;
			for ( int m=0; m<8; m++ ) {
				if ( hang[m]==hangar1() ) h1Sum++;				
				if ( hang[m]==hangar2() ) h2Sum++;
			}
			if (h1Sum!=5)
					throw new ACexception("getMaintenanceEventScheduledHangar failure 1");
			if (h2Sum!=2)
					throw new ACexception("getMaintenanceEventScheduledHangar failure 2");
					
					
					

         
		  
            
		}
		catch (ACexception ace) {
			ace.printStackTrace();
			System.out.println(ace.getMessage());
		}

    }
}
@


1.49
log
@no message
@
text
@d465 1
d467 4
a470 3
				       throw new ACexception(
					       "getMaintenanceEventScheduledStartPeriod: Non-integer prodVol. "
						+ "prodVol["+t+"]="+prodVol[0][t]);
d483 38
d550 1
a550 1
						if (execVolT != 0.0 && execVolT != 1.0) {
d555 1
a555 1
						}
d560 1
a560 1
				if (sumExecVol != 0.0 && sumExecVol != 1.0) {
d565 1
a565 1
				}
d611 1
a611 1
                    if (execVol[0][sp]!=0.0 && execVol[0][sp]!=1.0 ) {
d615 2
a616 2
                    }
					if (execVol[0][sp] == 1.0f ) {
d620 53
@


1.48
log
@modified to use LP and not mip
@
text
@d468 1
a468 1
						+ "prodVol["+t+"]="+prodVol[t]);
d647 1
a647 1
	  	if ( planeType==wide() ) shipReward[desiredPeriod]=shipReward[desiredPeriod]*10000000000.0f;
d705 1
@


1.47
log
@Added method to test to see if maint event spans locations
@
text
@d851 1
a851 1
			witSetOptWithLotSizes(witRun(),1);
@


1.46
log
@Input the earliest and latest periods
@
text
@d481 57
d851 1
a851 1
			// witSetOptWithLotSizes(witRun(),1);
@


1.45
log
@no message
@
text
@d462 1
d470 1
d795 2
a796 2
			//witOptImplode(witRun());
			witHeurImplode(witRun());
@


1.44
log
@Different weights
@
text
@d793 2
a794 2
			witOptImplode(witRun());
			//witHeurImplode(witRun());
@


1.43
log
@Playing with objective function
@
text
@d584 1
@


1.42
log
@output update
@
text
@d32 2
d64 8
d120 10
d584 5
a588 1
	  	shipReward[desiredPeriod] = getMaintenanceEventPlannedDuration(eventName)*1000.00f;
d684 1
@


1.41
log
@updated to write planeType in maintenance event output
@
text
@d1390 6
@


1.40
log
@Fixed syntax/compile problem
@
text
@d84 1
a84 1
    private String getMaintenanceEventPlaneType( String event ) {
@


1.39
log
@Added method to create wideHangarName at YUL
@
text
@d777 1
a777 1
		try {
d839 4
a842 4
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
@


1.38
log
@Added the setting of DemandObj1ShipReward attribute
@
text
@d777 1
a777 1
		{
d798 21
a818 1
					else
d821 2
a822 1
							hangar1() + "_or_" + hangar2());
d839 3
d856 13
d1087 2
a1088 1
				
d1095 2
a1096 2
			String wideForNnDaysH1 = wideForNnDays + "_at_"+hangar1();
			String wideForNnDaysH2 = wideForNnDays + "_at_"+hangar2();
@


1.37
log
@Modified to use LP solver
Cached numPeriods
@
text
@d222 1
a222 1
			}
d538 2
a539 1
	  	int ph = getPlanningHorizon();
d561 13
@


1.36
log
@Added code to peg a maintenance event at YWG to a hangar.
@
text
@d70 1
d160 1
a160 1
	public void setPlanningHorizon(int weeks) {
d162 2
a163 1
	    witSetNPeriods(witRun(),weeks);
d170 8
a177 7
	  int nPeriods[] = new int[1];
	  try {
	    witGetNPeriods(witRun(),nPeriods);
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	  return nPeriods[0];
d601 2
a602 2
			float incLotSize[][] = new float[1][np];
			for (int t = 0; t < np; t++) incLotSize[0][t]=1.0f;
d605 1
a605 1
			//witSetOperationIncLotSize(witRun(),maintLoc,incLotSize);
d752 3
a754 3
			//witSetOptWithLotSizes(witRun(),1);
			//witOptImplode(witRun());
			witHeurImplode(witRun());
@


1.35
log
@update the planeType
@
text
@d18 1
d29 3
d55 8
d69 1
d99 10
d308 2
a309 1
			    hangarName = hangarSpaceName(planeType,location);;
d316 3
d323 1
d334 1
a339 9
			witGetPartConsVol(witRun(), hangarName, retVal);
			
			if ( location==ywg() ) {
				float prodRate;
				if ( hangarNumber==1 ) prodRate=5.0f;
				else prodRate=2f;
				for ( int t=0; t<nP; t++ ) retVal[0][t]=retVal[0][t]*prodRate;
			}

d642 1
d688 57
d759 33
a791 6
		// Loop once for each event
		java.util.Vector events = getMaintenanceEvents();
		for (int e = 0; e < events.size(); e++) {
			String eventName = (String) events.elementAt(e);
			String schedLoc = getMaintenanceEventScheduledLocation(eventName);
			String planeType = getMaintenanceEventPlaneType(eventName);
d793 1
a793 2
			if (schedLoc == yul()) {
				if (planeType == b747())
d795 5
a799 14
				else if (planeType == narrow())
					setMaintenanceEventScheduledHangar(eventName, hangar2());
				else
					setMaintenanceEventScheduledHangar(
						eventName,
						hangar1() + "_or_" + hangar2());
			} else if (schedLoc == ywg()) {
				setMaintenanceEventScheduledHangar(
					eventName,
					hangar1() + "_or_" + hangar2());
			} else if (schedLoc == yvr()) {
				setMaintenanceEventScheduledHangar(eventName, hangar1());
			} else if (schedLoc == yyc()) {
				setMaintenanceEventScheduledHangar(eventName, hangar1());
d811 5
a815 4
	private static String yul() { return "YUL"; }
	private static String ywg() { return "YWG"; }
	private static String yvr() { return "YVR"; }
	private static String yyc() { return "YYC"; }
d859 6
a864 1
			int nP = getPlanningHorizon();
d884 1
a884 1
			witAddBomEntry(witRun(), hangar2Name, hangar1Name);
d1116 1
a1116 1
			defineLabor();
d1237 98
a1334 23
            /*
            // Loop once for each maintenance event and print results
            System.out.println("\"maintEvent\",\"startPeriod\",\"location\"");
            java.util.Vector mes = ac.getMaintenanceEvents();
            for ( int m=0; m<mes.size(); m++ ) {
            	String me = (String)mes.elementAt(m);
            	int sp = ac.getMaintenanceEventScheduledStartPeriod(me);
            	String el = ac.getMaintenanceEventScheduledLocation(me);
            	System.out.println("\""+me+"\","+sp+",\""+el+"\"");
            }
            
            // Loop once for each location and get labor hours consumed                  
            java.util.Vector locs = ac.getLocations();            
            System.out.println("\"location\",\"period\",\"laborSupply\",\"laborConsumed\"");
            for ( int l=0; l<locs.size(); l++ ) {
            	String location = (String)locs.elementAt(l);
            	float [] locConsVol = ac.getLocationLaborHoursConsVol(location);
            	float [] locSupplyVol = ac.getLocationLaborHoursSupplyVol(location);
            	for ( int t=0; t<np; t ++ ) {
            		System.out.println("\""+location+"\","+t+","+locSupplyVol[t]+","+locConsVol[t]);
            	}
            }
            */
a1340 2

		
@


1.34
log
@Added class to hold maintenanceEvent attributes that are not readily available from WitRun
@
text
@d713 3
a715 3
	private static String narrow() { return "narrow"; }
	private static String wide() { return "wide"; }
	private static String b747() { return "747"; }
@


1.33
log
@Added method getMaintenanceEventScheduledHangar
Method is not complete but works correctly for 2 locations and returns a decent answer for the other two.
@
text
@d18 34
d56 2
d65 22
d343 1
d346 3
d487 1
a487 37


	public String getMaintenanceEventScheduledHangar(String eventName)
		throws ACexception {
		String retVal = none();
		//try {
			if (!getMaintenanceEventExists(eventName)) {
				throw new ACexception(
					"Cannot getMaintenanceEventLocation. Event named "
						+ eventName
						+ " does not exist.");
			}

			String schedLoc = getMaintenanceEventScheduledLocation(eventName);

			if (schedLoc == yul() ) {
				retVal = hangar1() + "_or_" + hangar2();
			}
			else if ( schedLoc == ywg() ) {
				retVal = hangar1() + "_or_" + hangar2();
		    }
			else if ( schedLoc == yvr() ) {
				retVal = hangar1();
		    }
			else if ( schedLoc == yyc() ) {
				retVal = hangar1();
		    }

		//} catch (com.ibm.mathsci.mshcalc.MshException e) {
		//	e.printStackTrace();
		//	System.exit(0);
		//}
		return retVal;
	}


	  	
d620 2
d667 1
a667 2
	public void solve() throws ACexception
	{
d678 29
d1084 5
d1135 2
a1136 1

d1158 1
@


1.32
log
@Added code so max duration does not need to be known ahead of time.
Updated getMaintenanceEventScheduledLocation
Removed some dead commented code
@
text
@d231 2
a232 2
			    if ( hangarNumber==1 ) hangarName = "hg1_at_" + ywg();
			    else if ( hangarNumber==2 ) hangarName = "hg2_at_" + ywg();
d245 2
a246 2
	            	if ( hangarNumber==1 ) hangarName+="_hg1";
	            	else  hangarName+="_hg2";
d376 1
a376 1
		String retVal = "none";
d427 34
d654 3
d704 2
a705 2
			String hangar1Name = "hg1_at_" + ywg();
			String hangar2Name = "hg2_at_" + ywg();
d739 1
a739 1
			String hangar1Name = "hg1_at_" + yyc();
d770 1
a770 1
			String hangar1Name = "hg1_at_" + yvr();
d824 2
a825 2
			String wideH1 = wide+"_hg1";
			String wideH2 = wide+"_hg2";
d827 2
a828 2
			String hangar1Name = "hg1_at_" + yul();
			String hangar2Name = "hg2_at_" + yul();
d880 2
a881 2
			String wideH1 = wide+"_hg1";
			String wideH2 = wide+"_hg2";
d883 2
a884 2
			String wideForNnDaysH1 = wideForNnDays + "_at_H1";
			String wideForNnDaysH2 = wideForNnDays + "_at_H2";
@


1.31
log
@output on unitTest
@
text
@d67 4
a70 1
			witDeleteRun(witRun());
a118 12
	}	
	/*
	public boolean getMaintenanceEventResourceLinkExists(String eventName,String consResource) {
	  boolean retVal = false;
	  try {
	  	int exists[] = { 0 };
	    witGetOperationExists(witRun(),eventName,exists);
	    if ( exists[0]==1 ) retVal = true;
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
      return retVal;
a119 1
	*/
a267 24

/*
	 public void addSpaceResource(
	  String resourceName,
	  float availableSupply )
	throws ACexception {
	  try {
	    if ( !getLaborResourceExists(resourceName) ) {
	      // Resource is not defined to wit, so define it.
	      witAddPart(witRun(),resourceName,getWitAttr("WitCAPACITY"));
	    }
        int nP = getPlanningHorizon();
        float supplyVol[]=new float[nP];
	    for(int t = 0;t < nP;t++)
	     {
	     	supplyVol[t]=availableSupply;
	     }
	     witSetPartSupplyVol(witRun(),resourceName,supplyVol);
	       
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	}
*/ 
d295 6
a300 1
	}	
d306 2
d317 1
a317 1
		}
d374 1
a374 2

        public String getMaintenanceEventScheduledLocation(String eventName)
d376 1
a376 3
		int nP = getPlanningHorizon();
		String retVal="empty";
		float prodVol[][] = new float[1][nP];
d378 1
a378 2

			if ( !getMaintenanceEventExists(eventName)) {
d380 1
a380 1
					"Cannot getMaintenanceEventScheduledStartPeriod. Event named "
d383 33
a415 6
		       }
            String eventLocation1=eventName+"_at_yul";
			witGetPartProdVol(witRun(),eventLocation1, prodVol);
			for (int t=0; t<nP; t++ ) {
				if ( prodVol[0][t]!=0.f ) 
					retVal = "YUL";
d417 2
a418 19
			String eventLocation2=eventName+"_at_YVR";	
			witGetPartProdVol(witRun(),eventLocation2, prodVol);
			for (int t=0; t<nP; t++ ) {
				if ( prodVol[0][t]!=0.f ) 
					retVal = "YVR";
				}
		    String eventLocation3=eventName+"_at_YWG";	
			witGetPartProdVol(witRun(),eventLocation3, prodVol);
			for (int t=0; t<nP; t++ ) {
				if ( prodVol[0][t]!=0.f ) 
					retVal = "YWG";
				}
			String eventLocation4=eventName+"_at_yyc";	
			witGetPartProdVol(witRun(),eventLocation4, prodVol);
			for (int t=0; t<nP; t++ ) {
				if ( prodVol[0][t]!=0.f ) 
					retVal = "YYC";
				}				
				
a424 43
	/*
	public void setMaintenanceEventPlanning(String eventName,int desiredPeriod,
	  int elapseDays, float laborHours, String location)
	throws ACexception {
	  try {
	  	if ( !getMaintenanceEventExists(eventName) ) {
	  		throw new ACexception(
	  		  "Cannot setMaintenanceEventPlanning. Event named " + eventName +
	  		  " does not exist.");
	  	}
	  	
	  	  String mei[]= new String [elapseDays];
	  	  witAddOperation(witRun(), eventName);
	  	  witAddBopEntry(witRun(),eventName, eventName);
	  	 
	  	  
	  	for ( int t=0; t<elapseDays; t++ ) 
	  	{
	  	     
	  	     String s=new String(Integer.toString(t));
			 mei[t]=eventName+s;
	  	     witAddBomEntry(witRun(),eventName,mei[t]);
	  	     witAddOperation(witRun(),mei[t]);
	  	     witAddBopEntry(witRun(), mei[t], mei[t]);
	  	     witAddBomEntry(witRun(), mei[t], location);
	  	     laborHours=laborHours/elapseDays;
	  	     witSetBomEntryConsRate(witRun(), mei[t],0,laborHours);
	  	}
	  	
	  	 } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
	  }
	}
	*/

	/*
	private void witSetBomEntryConsRate(
		WitRun witRun,
		String string,
		int i,
		float f) {
	}
	*/
a425 1
	  	     
a427 2
	  	
	  	
a534 2
				
				float [] supplyVol = getLocationLaborHoursSupplyVol(location);
d548 1
a603 67
	/*  
    public void addSpaceHangarLink(
	  String spaceResource,
	  String hangarArrangement,
	  float productionRate,
	  String hangarResource)
	throws ACexception {
	  try {
	  	if ( !getResourceExists(spaceResource) ) {
	  		throw new ACexception(
	  		  "Cannot addSpaceHangarLink because space resource does not exist. Resource named " 
	  		  + spaceResource);}
	  	if ( !getResourceExists(hangarResource) ) {
	  		throw new ACexception(
	  		  "Cannot addSpaceHangarLink because the hangar resource does not exist. Resource named " 
	  		  + hangarResource);}
	  		  
	  		  
	  		  witAddOperation(witRun(), hangarArrangement);
	  		  witAddBopEntry(witRun(), hangarArrangement, spaceResource);
	  		  int ph = getPlanningHorizon();
	  		  float ha[] = new float [ph];
	  		  float cr[]= new float [ph];
	  	      for ( int t=0; t<ph; t++ ) {ha[t] = productionRate; cr[t]=1;}
	  		  witSetBopEntryProductRate(witRun(), hangarArrangement, 0, ha);
	  		  witAddBomEntry(witRun(), hangarArrangement, hangarResource);
	  		  witSetBomEntryConsRate(witRun(), hangarArrangement, 0, cr);
	  		  } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
	  }
	}
	*/
	  
	/*	
	public void setMaintenanceEventRecourseLinkConsumptionRate(
		String maintenanceEvent,
		String consumedResource,
		float consumptionRate)
		throws ACexception {
		try {
			if (!getMaintenanceEventResourceLinkExists(maintenanceEvent, consumedResource)) {
				throw new ACexception(
					"Cannot setMaintenanceEventRecourseLinkConsumptionRate because link does not exist."
						+ " Maintenance Event named "
						+ maintenanceEvent
						+ " Consumed Resource named "
						+ consumedResource);
			}

			int nP = getPlanningHorizon();

			// Create vector of ConsRates
			float consRateVec[][] = new float[1][nP];
			for (int t = 0; t < nP; t++)
				consRateVec[0][t]=consumptionRate;

			witSetBomEntryConsRate(
				witRun(),
				maintenanceEvent,
				0,
				consRateVec[0]);
		} catch (com.ibm.mathsci.mshcalc.MshException e) {
			e.printStackTrace();
			System.exit(0);
		}
	}
	*/
d610 2
a611 2
			// witSetOptWithLotSizes(witRun(),1);
			// witOptImplode(witRun());
a796 1
			float offset[][] = new float[1][nP];
d833 56
a888 35
			
            // Now add wideAtYulForNnDays
            // Loop once for each duration
            int maxDuration = 50;
            if ( maxDuration>nP ) maxDuration=nP;
            for (int d=1; d<maxDuration; d++) {
            	String wideForNnDays = hangarSpaceName(wide(), yul(), d);
            	String wideForNnDaysH1 = wideForNnDays+"_at_H1";
            	String wideForNnDaysH2 = wideForNnDays+"_at_H2";
            	witAddPart(witRun(), wideForNnDays, getWitAttr("WitCAPACITY"));
            	witAddOperation(witRun(), wideForNnDaysH1);
            	witAddOperation(witRun(), wideForNnDaysH2);
            	
            	witAddBopEntry(witRun(),wideForNnDaysH1,wideForNnDays);
            	witAddBopEntry(witRun(),wideForNnDaysH2,wideForNnDays);
            	
            	// For Heuristic Implosion favor H2 when allocating 
            	// wide planes.  This is because H2 can also be used for narrow
            	// planes. Narrow planes seem to be available at all locations
            	// so it may not be as difficult to find a place for a narrow plane.
            	witSetBopEntryExpAversion(witRun(),wideForNnDaysH1,0, 2.0f);
            	witSetBopEntryExpAversion(witRun(),wideForNnDaysH2,0, 1.0f);
            	
            	for (int be=0; be<d; be++ ) {
            	  witAddBomEntry(witRun(),wideForNnDaysH1,wideH1);
            	  witAddBomEntry(witRun(),wideForNnDaysH2,wideH2);
            	  
            	  // Set offset. Becareful with this. It is tricky
            	  for (int t = 0; t < nP; t++) offset[0][t] = be-d+1;
            	  witSetBomEntryOffset(witRun(),wideForNnDaysH1,be,offset[0]);
            	  witSetBomEntryOffset(witRun(),wideForNnDaysH2,be,offset[0]);
            	}
            }
			
			
d894 1
a894 1
	
d904 2
a905 3
			} 
		}
		catch (com.ibm.mathsci.mshcalc.MshException e) {
d932 1
a932 2
     if ( false ) {
		// Test some adds, sets, & gets
d995 1
a996 4
			
			
			ac.finalize();

d1001 1
a1001 2
     }
		
d1008 1
d1010 1
a1010 1
			ac.setPlanningHorizon(5);
d1014 1
a1014 1
			for (int t=0; t<5; t++ ) ac.setLocationLaborHoursSupplyVol(loc, t, 1500.f);
d1034 26
a1059 1

@


1.30
log
@output location
@
text
@d415 1
a415 1
            String eventLocation1=eventName+"_at_YUL";
d1107 1
d1113 2
d1139 9
@


1.29
log
@Maximum Duration
@
text
@d401 45
@


1.28
log
@SQL fixed; Input set
@
text
@d927 1
a927 1
            int maxDuration = 30;
@


1.27
log
@Added some code to get ready to do mip solves.
Set BopAversions in a way that I think will provide better heuristic solutions (YUL first assigns wide planes to Hangar 2)
@
text
@d509 1
a509 1
	private void addMaintenanceEventResourceLinks(
@


1.26
log
@Modified so buildAhead is working
@
text
@d538 5
d544 1
a546 1
			int np = getPlanningHorizon();
d598 1
a598 13
		// this type of plane
		addMaintenanceEventResourceLinks(
			maintEvent,
			yul(),
			planeType,
			duration,
			totalLaborHours);
		addMaintenanceEventResourceLinks(
			maintEvent,
			yvr(),
			planeType,
			duration,
			totalLaborHours);	
d614 12
d698 4
d936 1
d939 8
@


1.25
log
@Modified so offsets on Boms are correct.
@
text
@d372 1
a372 1
		float shipVol[][] = new float[1][nP];
d382 1
a382 1
			witGetDemandShipVol(witRun(),eventName,eventName, shipVol);
d384 1
a384 1
				if ( shipVol[0][t]!=0.f ) {
d386 1
a386 1
					if ( shipVol[0][t]!=1.f ) {
d388 2
a389 2
					       "getMaintenanceEventScheduledStartPeriod: Non-integer shipVol. "
						+ "ShipVol["+t+"]="+shipVol[t]);
d485 1
d1066 1
a1066 1
			ac.setMaintenanceEventStartPeriodRange("M1", 2, 1, 2);
d1068 2
a1069 2
			for (int t=0; t<5; t++ ) ac.setLocationLaborHoursSupplyVol(loc, t, 500.f);
			//ac.setLocationLaborHoursSupplyVol(loc, 2, 0.f);
d1077 1
a1077 1
			if (schedPeriod != 2)
@


1.24
log
@Added some methods to get results.
Turned multRoute on.
Changed some method names.
Altered the way offsets are set (to be correct, hopefully)
@
text
@d921 2
d924 4
a927 2
            	witAddOperation(witRun(), wideForNnDays);
            	witAddBopEntry(witRun(),wideForNnDays,wideForNnDays);
d929 2
a930 2
            	  witAddBomEntry(witRun(),wideForNnDays,wideH1);
            	  witAddBomEntry(witRun(),wideForNnDays,wideH2);
d934 2
a935 1
            	  witSetBomEntryOffset(witRun(),wideForNnDays,be,offset[0]);
d1065 1
a1065 1
			ac.setMaintenanceEventStartPeriodRange("M1", 2, 2, 2);
d1076 1
a1076 1
			if (schedPeriod != 1)
@


1.23
log
@Fixed syntax errors present in prior commit and beefed up test method.
@
text
@d49 1
a49 1
                witSetMultiRoute( wr_, 0 );
d65 10
d131 1
a131 1
	public void setLocationLaborHours(
d160 1
a160 1
			float supplyVol[] = getLocationLaborHours(location);
d163 1
a163 1
			supplyVol[period] += availableSupply;
d174 1
a174 1
	public float[] getLocationLaborHours(String location)
d199 80
d335 1
a335 1
	public int getMaintenanceEventPlannedStartPeriod(String eventName)
d367 34
a400 1
	
d446 1
a446 1
	  	
d499 4
d551 2
d556 1
a556 1
					offset[0][t] = be;
d562 2
a563 1
			// Unfortunately connects to hangar depends on the location
d573 1
a573 1
					for (int t = 0; t < np; t++) offset[0][t] = be;
d604 1
a604 1
			totalLaborHours);
d612 1
d618 1
a618 2
				totalLaborHours);

d917 3
a919 1
            for (int d=1; d<30; d++) {
d929 1
a929 1
            	  for (int t = 0; t < nP; t++) offset[0][t] = be;
d978 3
d982 1
d998 2
a999 2
				ac.setLocationLaborHours("YUL", 3, 23.f);
				float lh[] = ac.getLocationLaborHours("YUL");
d1021 1
a1021 1
				if (ac.getMaintenanceEventPlannedStartPeriod("M1") != -1)
d1027 6
a1032 6
					
				ac.setMaintenanceEventStartPeriodRange("M1",1,0,3);
				if (ac.getMaintenanceEventPlannedStartPeriod("M1") != 1 )
					throw new ACexception("getMaintenanceEventPlannedStartPeriod failure 1");			
				ac.setMaintenanceEventStartPeriodRange("M1",2,0,3);
				if (ac.getMaintenanceEventPlannedStartPeriod("M1") != 2 )
d1034 2
a1035 2
				
				ac.addMaintenanceEventResourceLinks("M1",wide(),2,300.f);
d1037 1
a1037 1
				ac.addMaintenanceEventResourceLinks("M2",narrow(),4,300.f);
d1040 4
d1049 31
a1079 1
	}
d1082 1
@


1.22
log
@added methods to set resource and maintenance attributes.
added methods to link maintEvents with resources
@
text
@d455 1
a455 1
	private void addMaintenanceEventResourceLinks(
d461 15
a475 2
			// add event if to all locations that can accomodate
			// this type of plane
d478 1
a478 1
				yul(),
d484 1
a484 1
				yvr(),
a487 13
			if (planeType == narrow()) {
				addMaintenanceEventResourceLinks(
					maintEvent,
					ywg(),
					planeType,
					duration,
					totalLaborHours);
				addMaintenanceEventResourceLinks(
					maintEvent,
					yyc(),
					planeType,
					duration,
					totalLaborHours);
d489 1
a489 2
			}
		} 
d899 1
a899 1
				ac.addMaintenanceEventResourceLinks("M1",yul(),wide(),2,300.f);
d901 1
a901 1
				ac.addMaintenanceEventResourceLinks("M2",yul(),narrow(),4,300.f);
@


1.21
log
@Commented out older code which managed hangars
@
text
@d18 11
a28 5

    private WitRun wr_=null;
    private java.util.Vector maintenanceEventNames_ = new java.util.Vector();
    private boolean hangarsDefined_ = false;
    
d83 1
a83 1
	public boolean getResourceExists(String resourceName) {
d87 2
a88 1
	    witGetPartExists(witRun(),resourceName,exists);
d95 1
a95 1
	
d107 1
d119 1
d121 67
a187 34
	public void addPeriodResource(
	  String resourceName,
	  int period,
	  float availableSupply )
	throws ACexception {
	  try {
		
	    // Has Resource already been defined to wit?	
	    if ( !getResourceExists(resourceName) ) {
	      // Resource is not defined to wit, so define it.
	      witAddPart(witRun(),resourceName,getWitAttr("WitCAPACITY"));
	    }
	    
	    // check to ensure period is within valid range
	    int nP = getPlanningHorizon();
	    if ( period>=nP ) {
	    	throw new ACexception(
	    	"Specified period "+period+" is greater than planning horizion");
	    }
	    
	    // Get the current supplyVol
	    float supplyVol[][]=new float[1][nP];;
	    witGetPartSupplyVol(witRun(),resourceName,supplyVol);
	    
	    // Increment supplyVol by availability
	    supplyVol[0][period] += availableSupply;
	    
	    // Set new supplyVol
	    witSetPartSupplyVol(witRun(),resourceName,supplyVol[0]);
	    
      } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
      }
	}  
d189 1
d195 1
a195 1
	    if ( !getResourceExists(resourceName) ) {
d210 2
a211 1
	}  
d224 1
a224 1
	  	defineHangars();
d226 1
a226 1
	    witAddPart(witRun(),eventName,getWitAttr("WitCAPACITY"));
d239 4
d261 1
a261 1
			witGetDemandShipVol(witRun(), eventName, eventName, shipVol);
a264 1
					// throw exception if not 1, because something is wrong in code
d278 1
d311 1
d313 1
a313 1
	
d320 1
d328 1
a328 1
	public void setMaintenanceEventRequiredStartingPeriods(
d332 1
a332 2
	  int latestPeriod,
	  float laborHours)
d357 4
a360 1
	  	baub[desiredPeriod]=buildAheadUB;
d363 7
a369 4
	  	int lp[] = new int [ph];
	  	for ( int t=0; t<ph; t++ ) lp[t] = 11;
	  	lp[desiredPeriod]=shipLateUB;
	    witSetDemandShipLateUB(witRun(),eventName,eventName,lp);
d372 2
a373 2
	  	for ( int t=0; t<ph; t++ ) lp[t] = 0;
	  	dv[desiredPeriod]=laborHours;
d381 110
a490 28
	public void addMaintenanceEventResourceLink(
	  String maintaintanceEvent,
	  String consumedResource,
	  String spaceResource)
	throws ACexception {
	  try {
	  	if ( !getMaintenanceEventExists(maintaintanceEvent) ) {
	  		throw new ACexception(
	  		  "Cannot addMaintenanceEventResourceLink because event does not exist. Event named " 
	  		  + maintaintanceEvent);}
	  	if ( !getResourceExists(consumedResource) ) {
	  		throw new ACexception(
	  		  "Cannot addMaintenanceEventResourceLink because resource does not exist. Event named " 
	  		  + consumedResource);}
	  	if ( !getResourceExists(spaceResource) ) {
	  		throw new ACexception(
	  		  "Cannot addMaintenanceEventResourceLink because resource does not exist. Event named " 
	  		  + spaceResource);}
	  		  
	 	witAddOperation(witRun(), maintaintanceEvent);
	  	witAddBomEntry(witRun(),maintaintanceEvent,consumedResource);
	  	witAddBopEntry(witRun(),maintaintanceEvent,maintaintanceEvent);
	  	spaceResource=spaceResource+"At"+consumedResource;
	  	witAddBomEntry(witRun(),maintaintanceEvent,spaceResource);
	  	
	  	 } catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
	  }
d524 2
a525 1
	  	
d558 2
d578 7
a584 2
	private static String hangarSpaceName(String planeType, String location )
	{
d586 1
a586 1
	}	
d599 15
d615 1
a615 1
	private void defineYwgHangar() {
d650 1
a650 1
	private void defineYycHangar() {
d677 1
a677 1
	private void defineYvrHangar() {
d687 8
a694 3
			float supplyVol[][] = new float[1][nP];
			for (int t = 0; t < nP; t++)
				supplyVol[0][t] = 5.0f;
d712 3
a714 3
			witSetBomEntryConsRate(witRun(), narrow, 0, 1.2f);
			witSetBomEntryConsRate(witRun(), wide, 1, 1.2f);
			witSetPartSupplyVol(witRun(),hangar1Name,supplyVol[0]);
d722 1
a722 1
			witSetBomEntryConsRate(witRun(), b747P, 2, 1.5f);			
d734 1
a734 1
	private void defineYulHangar() {
d745 3
a747 1
			float supplyVol[][] = new float[1][nP];
d749 5
a753 2
			for (int t = 0; t < nP; t++)
				supplyVol[0][t] = 4.0f;
d774 3
a776 3
			witSetBomEntryConsRate(witRun(), b747, 0, 1.5f);
			witSetBomEntryConsRate(witRun(), wideH1, 1, 1.f);
			witSetPartSupplyVol(witRun(),hangar1Name,supplyVol[0]);
d782 3
a784 5
			witSetBomEntryConsRate(witRun(), wideH2, 0, 1.0f);
			witSetBomEntryConsRate(witRun(), narrow, 1, 1.0f);			
			for (int t = 0; t < nP; t++)
				supplyVol[0][t] = 1.0f;
			witSetPartSupplyVol(witRun(),hangar2Name,supplyVol[0]);
d809 9
d819 10
a828 1
	private void defineHangars() {
d833 1
a833 1
		if (!hangarsDefined_) {
d838 2
a839 1
			hangarsDefined_ = true;
d851 48
a898 23
			int np = ac.getPlanningHorizon();
			if (np != 26)
				throw new ACexception("getPlanningHorizon failure 1");
			ac.setPlanningHorizon(5);
			np = ac.getPlanningHorizon();
			if (np != 5)
				throw new ACexception("getPlanningHorizon failure 2");

            // Test maintenance event methods
            if ( ac.getMaintenanceEventExists("M1") )
				throw new ACexception("getMaintenanceEventExists failure 1");
			if ( ac.getMaintenanceEvents().size()!=0 )
				throw new ACexception("getMaintenanceEvents failure 1");
            ac.addMaintenanceEvent("M1");
            if ( !ac.getMaintenanceEventExists("M1") )
				throw new ACexception("getMaintenanceEventExists failure 2");
			if ( ac.getMaintenanceEventPlannedStartPeriod("M1")!=-1 )
				throw new ACexception("getMaintenanceEventPlannedStartPeriod failure 1");
			if ( ac.getMaintenanceEvents().size()!=1 )
				throw new ACexception("getMaintenanceEvents failure 2");
			if ( ac.getMaintenanceEvents().elementAt(0) != "M1" )
				throw new ACexception("getMaintenanceEvents failure 3");
			//ac.setMaintenanceEventPlanning("M1",1,2,400,"YUL");	
d900 6
@


1.20
log
@added code to define hangars
@
text
@d355 2
a356 2
	  
	public void addSpaceHangarLink(
d386 1
@


1.19
log
@Added getMaintenanceEvents method
@
text
@d21 1
d178 4
d429 226
d693 1
@


1.18
log
@Changed maintenance event to be a capacity.
Added a test method. This method calls ACmaintenance methods and checks to see that results are reasonable.
@
text
@d187 5
d443 2
d450 4
@


1.17
log
@Set some standard witGlobal parameters including turning informational messages off.
@
text
@d20 1
a29 1
		   	    rc = witInitialize(wr_);
d36 2
d177 1
a177 1
	    witAddPart(witRun(),eventName,getWitAttr("WitMATERIAL"));
d179 3
d416 32
@


1.16
log
@no message
@
text
@d30 12
@


1.15
log
@no message
@
text
@d221 3
a223 1
	  	     mei[t]=eventName+"t";
@


1.14
log
@no message
@
text
@d203 45
d319 1
d329 2
d344 9
a352 3
	  		  witAddOperation(witRun(), spaceResource);
	  		  witAddBopEntry(witRun(), spaceResource, spaceResource);
	  		  witAddBomEntry(witRun(), spaceResource, hangarResource);
@


1.13
log
@no message
@
text
@d254 2
a255 1
	  String consumedResource)
d266 5
a270 1
	  	
d274 2
@


1.12
log
@no message
@
text
@d132 23
a154 1
	
d274 23
@


1.11
log
@no message
@
text
@d216 1
a216 1
	  	for ( int t=0; t<ph; t++ ) lp[t] = 0;
@


1.10
log
@no message
@
text
@d186 2
a187 1
	  int latestPeriod)
d222 1
a222 1
	  	dv[desiredPeriod]=1;
@


1.9
log
@no message
@
text
@d182 1
a182 1
	public void setMaintenanceEventRequiredCompletionPeriods(
@


1.8
log
@no message
@
text
@d136 1
a136 1
	  	if ( !getMaintenanceEventExists(eventName) ) {
d243 1
a243 1
	//  	witAddOperation(witRun(), maintaintanceEvent);
@


1.7
log
@no message
@
text
@d243 1
a243 1
	  	witAddOperation(witRun(), maintaintanceEvent);
@


1.6
log
@no message
@
text
@d3 1
d136 1
a136 1
	  	if ( getMaintenanceEventExists(eventName) ) {
d149 2
a150 1
		throws ACexception {
d152 1
a152 1
			if (!getMaintenanceEventExists(eventName)) {
d157 2
a158 2
			}
			int retVal = -1;
d166 1
a166 3
			for (int t = 0;
			t < nP;
			t++) {
d174 1
a174 1
			return retVal;
d179 1
d252 1
a252 1
		String maintaintanceEvent,
d257 1
a257 1
			if (!getMaintenanceEventResourceLinkExists(maintaintanceEvent, consumedResource)) {
d261 1
a261 1
						+ maintaintanceEvent
d275 1
a275 1
				maintaintanceEvent,
d283 10
@


1.5
log
@no message
@
text
@d83 11
d147 34
d233 1
a233 1
	  	if ( getMaintenanceEventExists(maintaintanceEvent) ) {
d235 6
a240 2
	  		  "Cannot addMaintenanceEventResourceLink. Event named " + maintaintanceEvent +
	  		  " already exists.");}
d244 1
d250 31
a280 16
	  public void setMaintenanceEventRecourseLinkConsumptionRate(
	  String maintaintanceEvent,
	  String consumedRecource,
	  float consumptionRate)
	throws ACexception {
	  try {
	  	if ( getMaintenanceEventExists(maintaintanceEvent) ) {
	  		throw new ACexception(
	  		  "Cannot addMaintenanceEventResourceLinkConsumptionRate. Event named " + maintaintanceEvent +
	  		  " already exists.");
	  	} 
	  	
	  	witAddDemand(witRun(),maintaintanceEvent,maintaintanceEvent);
	  	} catch (com.ibm.mathsci.mshcalc.MshException e) {
	    e.printStackTrace(); System.exit(0);
	  }
@


1.4
log
@no message
@
text
@d203 1
a203 1
	  int consumptionRate)
@


1.3
log
@no message
@
text
@d192 3
a194 2
	  	witAddPart(witRun(),consumedResource,getWitAttr("WitMATERIAL"));
	  	witAddDemand(witRun(),maintaintanceEvent,maintaintanceEvent);
@


1.2
log
@no message
@
text
@d191 1
a191 1
	  		  " already exists.");
d193 2
a194 2
//	  	witAddDemand(witRun(),maintaintanceEvent,maintaintanceEvent);
	  	} } catch (com.ibm.mathsci.mshcalc.MshException e) {
d209 4
a212 1
	  	} } catch (com.ibm.mathsci.mshcalc.MshException e) {
@


1.1
log
@Moved Java Classes from src directory to AirCanada directory
@
text
@d161 1
d181 31
@


head	1.58;
access;
symbols;
locks; strict;
comment	@# @;


1.58
date	2002.12.17.16.53.22;	author yingdong;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.16.20.42.31;	author yingdong;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.16.19.49.18;	author yingdong;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.16.15.20.58;	author yingdong;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.04.21.18.59;	author fasano;	state Exp;
branches;
next	1.53;

1.53
date	2002.12.04.20.36.55;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.04.16.57.44;	author yingdong;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.02.13.56.47;	author yingdong;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.26.15.44.33;	author yingdong;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.25.21.29.24;	author yingdong;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.25.21.10.13;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.25.19.32.00;	author yingdong;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.25.18.33.19;	author yingdong;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.25.18.07.17;	author fasano;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.25.16.01.54;	author yingdong;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.25.14.47.24;	author fasano;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.25.13.41.22;	author fasano;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.25.11.45.47;	author fasano;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.24.21.44.43;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.24.16.39.36;	author yingdong;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.24.04.07.05;	author yingdong;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.23.18.40.35;	author fasano;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.23.15.04.42;	author fasano;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.23.04.19.15;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.23.02.20.26;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.23.00.13.31;	author fasano;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.22.22.03.22;	author yingdong;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.22.20.38.48;	author yingdong;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.22.19.22.19;	author yingdong;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.22.15.53.07;	author yingdong;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.22.06.06.01;	author yingdong;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.21.22.38.25;	author yingdong;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.21.17.19.47;	author yingdong;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.19.13.45.45;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.18.03.45.28;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.17.22.20.04;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.17.16.00.41;	author fasano;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.12.21.19.43;	author yingdong;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.12.03.40.02;	author yingdong;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.11.21.49.42;	author yingdong;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.06.21.34.40;	author yingdong;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.06.20.11.54;	author yingdong;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.06.16.55.30;	author yingdong;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.05.19.54.34;	author yingdong;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.05.19.52.20;	author yingdong;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.05.19.28.05;	author yingdong;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.05.19.09.40;	author yingdong;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.05.17.16.54;	author yingdong;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.05.15.58.49;	author yingdong;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.05.15.48.16;	author yingdong;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.05.15.31.21;	author yingdong;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.05.14.36.51;	author yingdong;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.01.18.53.19;	author yingdong;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.01.14.18.40;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.31.22.59.51;	author yingdong;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.31.19.38.45;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.31.19.37.22;	author yingdong;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.31.19.33.23;	author yingdong;	state Exp;
branches;
next	;


desc
@@


1.58
log
@LP with fractional output
@
text
@package com.ibm.mathsci.witApplications.airCanada;

import java.net.*;
import java.sql.*;
import java.util.*;
import java.io.*;
import java.text.DateFormat;

//
/**
 * @@author JPF2
 *
 * Air Canada Main Program
 */
public class ACmain {

	public static void main(String[] args)throws Exception  {
		
		try {
		  Calendar cal = GregorianCalendar.getInstance();
		  DateFormat dateFormatter = DateFormat.getDateInstance(DateFormat.DEFAULT);
		  
		  // Create instance of planning problem
		  ACmaintenance acm = new ACmaintenance();
		
		  // Set number of periods in planning horizon
		  int ph = 50;

		  acm.setPlanningHorizon(ph);		
	  
          // Load the jdbc-odbc bridge driver
		  Class.forName ("sun.jdbc.odbc.JdbcOdbcDriver");

          // Attempt to connect to a driver.  Each one
		  // of the registered drivers will be loaded until
		  // one is found that can process this URL
	      String url   = "jdbc:odbc:WIT_HM-list";
		  Connection con = DriverManager.getConnection (url, "","");

 		  // If we were unable to connect, an exception
		  // would have been thrown.  So, if we get here,
		  // we are successfully connected to the URL

		  // Get the DatabaseMetaData object and display
		  // some information about the connection
		  DatabaseMetaData dma = con.getMetaData ();
		  System.out.println("\nConnected to " + dma.getURL());
		  System.out.println("Driver       " +	dma.getDriverName());
		  System.out.println("Version      " +	dma.getDriverVersion());
		  System.out.println("");

		  // Create a Statement object so we can submit
		  // SQL statements to the driver
		  Statement stmt = con.createStatement ();

		  // Set up Period manager class
		  ResultSet rs = stmt.executeQuery ("SELECT Min(SchedStartDate) FROM [Events and Resource Consumption$]");		  
          rs.next();
          java.util.Date sdate = rs.getDate(1);
          ACperiods perMgr = new ACperiods(sdate,ph);
          System.out.println(DateFormat.getDateInstance().format(sdate));
          rs.close();

		  //rs = stmt.executeQuery ( "SELECT Max(ElapseDays) FROM [Events and Resource Consumption$]");
		  //rs.next();
		  //int maxD = rs.getInt(1);
		  //System.out.println("Maximum duration of a maintenance event will be "+maxD);
		  //rs.close();
		  
		  // Submit a query, creating a ResultSet object
		  // containing PeriodResource Table data
		  rs = stmt.executeQuery ("SELECT * FROM [Available Resources$]");

		// Loop once for each row of PeriodResource Table
		//boolean more = rs.next();
		while (rs.next()) {
			String loc = " ";
			java.util.Date date;
			int p = -1;
			float lh = 0.f;
			// Get data from row and pass to acm object
			date = rs.getDate("date");

			// If date is not within planning horizon then skip;
			if (!perMgr.inRange(date))
				continue;

			p = perMgr.periodNumber(date);
			loc = rs.getString("resourceId");
			lh = rs.getFloat("laborHours");

			//System.out.println(loc+" "+p+" "+DateFormat.getDateInstance().format(date)+" "+lh);	    

			acm.setLocationLaborHoursSupplyVol(loc, p, lh);

		}

          // Close result set
		  rs.close();  
		  
		
		  
		  // Get data from LaborConsumption Table
//  	  rs = stmt.executeQuery ("SELECT [Available Resources$].period,[Events and Resource Consumption$].laborHours,[Available Resources$].resourceId,[Events and Resource Consumption$].maintEventId FROM [Available Resources$],[Events and Resource Consumption$]");		  
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate,EarliestDate, LatestDate, BodyType, Location,ElapseDays,laborHours FROM [Events and Resource Consumption$]");		  
		  
		// Loop once for each row of LaborConsumption Table
		//more = rs.next();
		while (rs.next()) {
			// Get data from row and pass to acm object
			String mei = rs.getString("MaintEventId");
			java.util.Date date = rs.getDate("SchedStartDate");
			
			// If date is not within planning then skip
			if (!perMgr.inRange(date))
				continue;
			int p = perMgr.periodNumber(date);
			
			date = rs.getDate("EarliestDate");
			
			// If date is not within planning then skip
			if (!perMgr.inRange(date))
				continue;
		
			int earliestPeriod = perMgr.periodNumber(date);
			if (earliestPeriod < 0)
				earliestPeriod = 0;
			
			date = rs.getDate("LatestDate");
			
			// If date is not within planning then skip
			if (!perMgr.inRange(date))
				continue;
			int latestPeriod  = perMgr.periodNumber(date);

			int sp = rs.getInt("BodyType");
			int ed = rs.getInt("ElapseDays");
			if ( p+ed >= ph ) continue; 
			float lh = rs.getFloat("laborHours");

			System.out.println("Adding event " + mei);
			acm.addMaintenanceEvent(mei);
			System.out.println("  Completed adding event ");
			
		
			System.out.println(
				"  Setting event period ranges "
					+ p
					+ " "
					+ earliestPeriod
					+ " "
					+ latestPeriod);
			

			String planeType = ACmaintenance.wide();
			if (sp == 0) {
				planeType = ACmaintenance.narrow();
			}
			if (sp == 2) {
				planeType = ACmaintenance.b747();
			}
			acm.addMaintenanceEventResourceLinks(mei, planeType, ed, lh);
            acm.setMaintenanceEventStartPeriodRange(
				mei,
				p,
				earliestPeriod,
				latestPeriod);
			System.out.println("  Completed setting event period ranges");
			System.out.println(
				"  Setting event period links "
					+ planeType
					+ " "
					+ ed
					+ " "
					+ lh);
		
			System.out.println("  Completed setting event period links  ");

			// Fetch the next result set row
			//more = rs.next();
		}

	      
          // Close result set, statement and db connection
		  rs.close(); 
		  stmt.close();
		  con.close();
  		 

        // All model data has been read and provided to ACmaintenance object
        // Now solve problem
		  
		 
        
        acm.solve();  
        
        // Test that maintenance events don't span locations
        boolean solnOK = acm.maintEventsDoNotSpanLocations();
        
        // Now get results and write to a file
        // Display which events can be performed
        //* loop once for each maintenance event
        //* get period when maintenance event will be scheduled (getMaintenanceEventScheduledPeriod)
        //* convert period to date
        //* write maintenance event name and date	  
        
  
			// Loop once for each maintenance event and print results
			System.out.println(
				"\"maintEvent\",\"planeType\",\"duration\",\"laborHours\",\"desiredStartPeriod\",\"schedStartPeriod\",\"desiredStartDate\",\"schedStartDate\",\"location\",\"hangar\"");
			java.util.Vector mes = acm.getMaintenanceEvents();
			for (int m = 0; m < mes.size(); m++) {
				String me = (String) mes.elementAt(m);
				int dur = acm.getMaintenanceEventPlannedDuration(me);
				int dsp = acm.getMaintenanceEventDesiredStartPeriod(me);
				java.util.Date desiredDate = perMgr.date(dsp);
				int ssp = acm.getMaintenanceEventScheduledStartPeriod(me);
				float frac=acm.getMaintenanceEventScheduledStartFraction(me);
				java.util.Date schedDate = perMgr.date(ssp);
				String el = acm.getMaintenanceEventScheduledLocation(me);
				String h = acm.getMaintenanceEventScheduledHangar(me);
				String planeType = acm.getMaintenanceEventPlaneType(me);
				float laborHours = acm.getMaintenanceEventLaborHours(me);
				System.out.println(
					"\""
						+ me
						+ "\",\""
						+ planeType
						+ "\","
						+ dur
						+ ","
						+ "\""
						+ laborHours
						+ ","
						+ dsp
						+ ","
						+ ssp
						+ ",\""
						+ DateFormat.getDateInstance().format(desiredDate)
						+ "\",\""
						+ DateFormat.getDateInstance().format(schedDate)
						+ "\",\""
						+ el
						+ "\",\""
						+ frac
						+ "\",\""
						+ h
						+ "\"");
						if(frac != 1 && frac !=0){
							String ael = acm.getAnotherMaintenanceEventScheduledLocation(me, el);
				//String h = acm.getMaintenanceEventScheduledHangar(me);
				//String planeType = acm.getMaintenanceEventPlaneType(me);
				//float laborHours = acm.getMaintenanceEventLaborHours(me);
				float dfrac=1-frac;
				System.out.println(
					"\""
						+ me
						+ "\",\""
						+ planeType
						+ "\","
						+ dur
						+ ","
						+ "\""
						+ laborHours
						+ ","
						+ dsp
						+ ","
						+ ssp
						+ ",\""
						+ DateFormat.getDateInstance().format(desiredDate)
						+ "\",\""
						+ DateFormat.getDateInstance().format(schedDate)
						+ "\",\""
						+ ael
						+ "\",\""
						+ dfrac
						+ "\",\""
						+ h
						+ "\"");}
							
			}

			// Loop once for each location and get labor hours consumed                  
			java.util.Vector locs = acm.getLocations();
			System.out.println(
				"\"location\",\"period\",\"date\",\"laborSupply\",\"laborConsumed\",\"laborExcess\"");
			for (int l = 0; l < locs.size(); l++) {
				String location = (String) locs.elementAt(l);
				float[] locConsVol = acm.getLocationLaborHoursConsVol(location);
				float[] locSupplyVol =
					acm.getLocationLaborHoursSupplyVol(location);
				for (int t = 0; t < ph; t++) {
				    java.util.Date d = perMgr.date(t);
				    String dateAsString = DateFormat.getDateInstance().format(d);
					System.out.println(
						"\""
							+ location
							+ "\","
							+ t
							+ ",\""
							+ dateAsString
							+ "\","
							+ locSupplyVol[t]
							+ ","
							+ locConsVol[t]
							+ ","
							+ (locSupplyVol[t]-locConsVol[t]));
				}
			}
			
			// Write out hangar usage
			
			// Hangar usage at YUL
			float[] yulWideH1   = acm.getHangarUsage( 1, ACmaintenance.yul(), ACmaintenance.wide() );
			float[] yulWideH2   = acm.getHangarUsage( 2, ACmaintenance.yul(), ACmaintenance.wide() );
			float[] yulB747H1   = acm.getHangarUsage( 1, ACmaintenance.yul(), ACmaintenance.b747() );
			float[] yulNarrowH2 = acm.getHangarUsage( 2, ACmaintenance.yul(), ACmaintenance.narrow() );		
				
			
			
			
			//Hangar usage at YVR
			float[] yvrNarrowH1 = acm.getHangarUsage(1,ACmaintenance.yvr(), ACmaintenance.narrow());
			float[] yvrWideH1 = acm.getHangarUsage(1,ACmaintenance.yvr(), ACmaintenance.wide());
			float[] yvrB747H1 = acm.getHangarUsage(1,ACmaintenance.yvr(), ACmaintenance.b747());
			
			
			
			//Hangar usage at YWG
			float[] ywgNarrowH1 = acm.getHangarUsage(1,ACmaintenance.ywg(), ACmaintenance.narrow());
			float[] ywgNarrowH2 = acm.getHangarUsage(2,ACmaintenance.ywg(), ACmaintenance.narrow());
			
			
			//Hangar usage at YYC
			float[] yycNarrowH1 = acm.getHangarUsage(1,ACmaintenance.yyc(), ACmaintenance.narrow());
			
				
			System.out.println(
				"\"period\",\"date\",\"yulWideH1\",\"yulWideH2\",\"yulB747H1\",\"yulNarrowH2\",\"yvrNarrowH1\",\"yvrWideH1\",\"yvrB747H1\",\"ywgNarrowH1\",\"ywgNarrowH2\",\"yycNarrowH1\"");
			for ( int t=0; t<ph; t++ ) {
				java.util.Date d = perMgr.date(t);
				String dateAsString = DateFormat.getDateInstance().format(d);
				System.out.println(t+",\""+dateAsString+"\","+yulWideH1[t]+","+yulWideH2[t]+","+yulB747H1[t]+","+yulNarrowH2[t]+","+yvrNarrowH1[t]+","+yvrWideH1[t]+","+yvrB747H1[t]+","+ywgNarrowH1[t]+","+ywgNarrowH2[t]+","+yycNarrowH1[t]);
			}
		}
		catch ( ACexception e ) {
			e.printStackTrace();			
		}
		
	    catch (SQLException ex) {

	    	// A SQLException was generated.  Catch it and
		    // display the error information.  Note that there
		    // could be multiple error objects chained
		    // together

        	System.out.println ("\n*** SQLException caught ***\n");

        	while (ex != null) {
		      System.out.println ("SQLState: " + ex.getSQLState ());
		      System.out.println ("Message:  " + ex.getMessage ());
	          System.out.println ("Vendor:   " + ex.getErrorCode ());
		      ex = ex.getNextException ();
		      System.out.println ("");
		    }
	    }
	    catch (java.lang.Exception ex) {

    		// Got some other type of exception.  Dump it.

    		ex.printStackTrace ();
    	}


	}
}
@


1.57
log
@fractional completion
@
text
@d27 1
a27 1
		  int ph = 120;
@


1.56
log
@b
@
text
@d27 1
a27 1
		  int ph = 50;
@


1.55
log
@no message
@
text
@d218 1
d245 2
d249 32
@


1.54
log
@Added method to test to see if maint event spans locations
@
text
@d27 1
a27 1
		  int ph = 120;
d162 1
d176 1
a176 1
			acm.addMaintenanceEventResourceLinks(mei, planeType, ed, lh);
@


1.53
log
@Added code to display excessLabor
@
text
@d27 1
a27 1
		  int ph = 20;
d195 3
@


1.52
log
@Input the earliest and latest periods
@
text
@d247 1
a247 1
				"\"location\",\"period\",\"date\",\"laborSupply\",\"laborConsumed\"");
d266 3
a268 1
							+ locConsVol[t]);
@


1.51
log
@no message
@
text
@d27 1
a27 1
		  int ph = 365;
d105 1
a105 1
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate,BodyType, Location,ElapseDays,laborHours FROM [Events and Resource Consumption$]");		  
d118 17
d144 2
a145 4
			int earliestPeriod = p - 1;
			if (earliestPeriod < 0)
				earliestPeriod = 0;
			int latestPeriod = p;
@


1.50
log
@no message
@
text
@d27 1
a27 1
		  int ph = 60;
d207 1
a207 1
						+ "\","
d212 1
a212 1
						+ "\","
@


1.49
log
@Different weights
@
text
@d27 1
a27 1
		  int ph = 30;
@


1.48
log
@changed output format
@
text
@d28 1
d138 1
a138 6
			acm.setMaintenanceEventStartPeriodRange(
				mei,
				p,
				earliestPeriod,
				latestPeriod);
			System.out.println("  Completed setting event period ranges");
d147 6
a152 1

@


1.47
log
@output update
@
text
@d27 1
a27 1
		  int ph = 20;
d190 1
a190 1
				"\"maintEvent\",\"planeType\",\"duration\",\"desiredStartPeriod\",\"schedStartPeriod\",\"desiredStartDate\",\"schedStartDate\",\"location\",\"hangar\"");
d202 1
d211 3
d282 1
a282 1
				"\"period\",\"date\", \"yulWideH1\",\"yulWideH2\",\"yulB747H1\",\"yulNarrowH2\",\"yvrNarrowH1\",\"yvrWideH1\",\"yvrB747H1\", \"ywgNarrowH1\", \"ywgNarrowH2\", \"yycNarrowH1\"");
d285 2
a286 1
				System.out.println(t+","+d+","+yulWideH1[t]+","+yulWideH2[t]+","+yulB747H1[t]+","+yulNarrowH2[t]+","+yvrNarrowH1[t]+","+yvrWideH1[t]+","+yvrB747H1[t]+","+ywgNarrowH1[t]+","+ywgNarrowH2[t]+","+yycNarrowH1[t]);
@


1.46
log
@output update
@
text
@d278 1
a278 1
				"\"period\",\"date\"\"yulWideH1\",\"yulWideH2\",\"yulB747H1\",\"yulNarrowH2\",\"yvrNarrowH1\",\"yvrWideH1\",\"yvrB747H1\", \"ywgNarrowH1\", \"ywgNarrowH2\", \"yycNarrowH1\"");
@


1.45
log
@updated to write planeType in maintenance event output
@
text
@d278 1
a278 1
				"\"period\",\"yulWideH1\",\"yulWideH2\",\"yulB747H1\",\"yulNarrowH2\",\"yvrNarrowH1\",\"yvrWideH1\",\"yvrB747H1\", \"ywgNarrowH1\", \"ywgNarrowH2\", \"yycNarrowH1\"");
d280 2
a281 1
				System.out.println(t+","+yulWideH1[t]+","+yulWideH2[t]+","+yulB747H1[t]+","+yulNarrowH2[t]+","+yvrNarrowH1[t]+","+yvrWideH1[t]+","+yvrB747H1[t]+","+ywgNarrowH1[t]+","+ywgNarrowH2[t]+","+yycNarrowH1[t]);
@


1.44
log
@output update
@
text
@d190 1
a190 1
				"\"maintEvent\",\"duration\",\"desiredStartPeriod\",\"schedStartPeriod\",\"desiredStartDate\",\"schedStartDate\",\"location\",\"hangar\"");
d201 1
d205 2
@


1.43
log
@Added code to write hangar usage
@
text
@d248 2
d253 21
a273 1
			float[] yulNarrowH2 = acm.getHangarUsage( 2, ACmaintenance.yul(), ACmaintenance.narrow() );			
d275 1
a275 1
				"\"period\",\"yulWideH1\",\"yulWideH2\",\"yulB747H1\",\"yulNarrowH2\"");
d277 1
a277 1
				System.out.println(t+","+yulWideH1[t]+","+yulWideH2[t]+","+yulB747H1[t]+","+yulNarrowH2[t]);
@


1.42
log
@Added inRange method to ACperiods to determine if a Date is within the planning horizon
@
text
@d246 11
@


1.41
log
@Added ability to set number of periods to limit run time
@
text
@d74 3
a76 3
		boolean more = rs.next();
		while (more) {
			String loc=" ";
d78 17
a94 20
			int p=-1;
			float lh=0.f;
			try {

				// Get data from row and pass to acm object
				loc = rs.getString("resourceId");
				lh = rs.getFloat("laborHours");
				date = rs.getDate("date");
				p = perMgr.periodNumber(date);

				//System.out.println(loc+" "+p+" "+DateFormat.getDateInstance().format(date)+" "+lh);	    

				acm.setLocationLaborHoursSupplyVol(loc, p, lh);

			} catch (ACexception ace) {
				//System.out.println("Not setting LocationLaborHoursSupplyVol "+loc+" "+p+" "+DateFormat.getDateInstance().format(sdate)+" "+lh);
			    //ace.printStackTrace ();
			}
			// Fetch the next result set row
			more = rs.next();
d107 44
a150 49
		more = rs.next();
		while (more) {
			try {
				String mei = rs.getString("MaintEventId");
				java.util.Date date = rs.getDate("SchedStartDate");
				// Get data from row and pass to acm object
				int sp = rs.getInt("BodyType");
				int ed = rs.getInt("ElapseDays");
				int p = perMgr.periodNumber(date);
				float lh = rs.getFloat("laborHours");

				System.out.println("Adding event " + mei);
				acm.addMaintenanceEvent(mei);
				System.out.println("  Completed adding event ");
				int earliestPeriod = p - 1;
				if (earliestPeriod < 0)
					earliestPeriod = 0;
				int latestPeriod = p;
				System.out.println(
					"  Setting event period ranges "
						+ p
						+ " "
						+ earliestPeriod
						+ " "
						+ latestPeriod);
				acm.setMaintenanceEventStartPeriodRange(
					mei,
					p,
					earliestPeriod,
					latestPeriod);
				System.out.println("  Completed setting event period ranges");

				String planeType = ACmaintenance.wide();
				if (sp == 0) {
					planeType = ACmaintenance.narrow();
				}
				if (sp == 2) {
					planeType = ACmaintenance.b747();
				}

				System.out.println(
					"  Setting event period links "
						+ planeType
						+ " "
						+ ed
						+ " "
						+ lh);
				acm.addMaintenanceEventResourceLinks(mei, planeType, ed, lh);
				System.out.println("  Completed setting event period links  ");
d152 9
a160 2
			} catch (ACexception ace) {
			}
d163 2
a164 2
			more = rs.next();
		}       
@


1.40
log
@Added code to peg a maintenance event at YWG to a hangar.
@
text
@d27 1
a27 1
		  int ph = 365;
d73 26
a98 17
		  // Loop once for each row of PeriodResource Table
		  boolean more = rs.next ();
	      while (more) {

		    // Get data from row and pass to acm object
		    String loc = rs.getString("resourceId");
            java.util.Date date = rs.getDate("date");
		    int p = perMgr.periodNumber(date);
		    float lh = rs.getFloat("laborHours");	
		    
		    //System.out.println(loc+" "+p+" "+DateFormat.getDateInstance().format(date)+" "+lh);	    
	
		    acm.setLocationLaborHoursSupplyVol(loc,p,lh);

		    // Fetch the next result set row
		    more = rs.next ();
	      }
d109 52
a160 24
		  // Loop once for each row of LaborConsumption Table
		  more = rs.next ();
	      while (more) {
			String mei = rs.getString("MaintEventId");
		    java.util.Date date = rs.getDate("SchedStartDate");
		    // Get data from row and pass to acm object
		    int sp=rs.getInt("BodyType");
		    int ed =rs.getInt("ElapseDays");
		    int p = perMgr.periodNumber(date);
		    float lh = rs.getFloat("laborHours");
            
            System.out.println("Adding event "+mei);
            acm.addMaintenanceEvent(mei);                       
            System.out.println("  Completed adding event ");
		    int earliestPeriod = p-1;
		    if( earliestPeriod<0 ) earliestPeriod=0;
		    int latestPeriod = p;           
            System.out.println("  Setting event period ranges "+p+" "+earliestPeriod+" "+latestPeriod);
	        acm.setMaintenanceEventStartPeriodRange(mei,p,earliestPeriod, latestPeriod);  
            System.out.println("  Completed setting event period ranges");
            
			String planeType = ACmaintenance.wide();
			if (sp == 0) {
				planeType = ACmaintenance.narrow();
d162 4
a165 12
			if (sp == 2) {
				planeType = ACmaintenance.b747();
			}
		    
		    
            System.out.println("  Setting event period links "+planeType+" "+ed+" "+lh);
		    acm.addMaintenanceEventResourceLinks(mei,planeType,ed,lh);
            System.out.println("  Completed setting event period links  ");
            
		    // Fetch the next result set row
		    more = rs.next ();
	      }          
d190 2
a191 1
			System.out.println("\"maintEvent\",\"startPeriod\",\"startDate\",\"location\",\"hangar\"");
d195 5
a199 3
				int sp = acm.getMaintenanceEventScheduledStartPeriod(me);
				java.util.Date schedDate = perMgr.date(sp);
				String dateAsString = DateFormat.getDateInstance().format(schedDate);
d202 18
a219 1
				System.out.println("\"" + me + "\"," + sp +"\",\"" + dateAsString + "\",\"" + el + "\",\"" + h + "\"");
@


1.39
log
@no message
@
text
@d121 7
a127 4
            String planeType="wide";
//		    if(sp=="wide"){planeType = "wide"; /* or "747" or "narrow" */}
		    if(sp==0){planeType = "narrow"; /* or "747" or "narrow" */}
		    if(sp==2){planeType = "747"; /* or "747" or "narrow" */}
@


1.38
log
@extend bodytypes
@
text
@d94 2
d106 1
a106 1
		    String sp=rs.getString("BodyType");
d121 5
a125 1
		    String planeType = sp; /* or "747" or "narrow" */
@


1.37
log
@Added method getMaintenanceEventScheduledHangar
Method is not complete but works correctly for 2 locations and returns a decent answer for the other two.
@
text
@d119 1
a119 1
		    String planeType = "wide"; /* or "747" or "narrow" */
@


1.36
log
@Fixed problem with calendar
@
text
@d152 1
a152 1
			System.out.println("\"maintEvent\",\"startPeriod\",\"startDate\",\"location\"");
d160 2
a161 1
				System.out.println("\"" + me + "\"," + sp +"\",\"" + dateAsString + "\",\"" + el + "\"");
@


1.35
log
@Updated ACperiods to have method to return date from period.
Added ACperiods.test method.
Updated ACunitTest to call new test method.
Updated ACmain to use new ACperiods method.
@
text
@d78 1
a78 1
		    String ri = rs.getString("resourceId");
d81 3
a83 1
		    float lh = rs.getFloat("laborHours");		    
d85 1
a85 1
		    acm.setLocationLaborHoursSupplyVol(ri,p,lh);
@


1.34
log
@Added code to print out some results and cleaned up by removing some commented code.
@
text
@d27 2
a28 4
		  int planningHorizon = 365;
		  acm.setPlanningHorizon(planningHorizon);
		  int ph = acm.getPlanningHorizon();
		
d150 1
a150 1
			System.out.println("\"maintEvent\",\"startPeriod\",\"location\"");
d155 2
d158 1
a158 1
				System.out.println("\"" + me + "\"," + sp + ",\"" + el + "\"");
d164 1
a164 1
				"\"location\",\"period\",\"laborSupply\",\"laborConsumed\"");
d170 3
a172 1
				for (int t = 0; t < planningHorizon; t++) {
d178 3
a180 1
							+ ","
@


1.33
log
@Added code so max duration does not need to be known ahead of time.
Updated getMaintenanceEventScheduledLocation
Removed some dead commented code
@
text
@d27 2
a28 1
		  acm.setPlanningHorizon(365);
a98 1
		  Map map = new HashMap();
d111 1
a111 1
            System.out.println("  Completed adding event "+mei);
d115 1
a115 1
            System.out.println("  Setting event period Ranges ");
d117 1
a117 1
            System.out.println("  Completed setting event period ranges"+mei);
d121 1
a121 1
            System.out.println("  Setting event period Links ");
d123 1
a123 3
            System.out.println("  Completed setting event period Links ");
		    //acm.addMaintenanceEventResourceLink(mei, ri, sp);
		    //acm.setMaintenanceEventRecourseLinkConsumptionRate(mei,ri,lh/q);
a124 1
		   
d130 1
a130 1
          // Close result set
d132 2
a133 2
		  
		  // sql statement and db connection
d150 32
a181 25
        rs = stmt.executeQuery ("SELECT MaintEventId FROM [Events and Resource Consumption$]");		  
		  
		  // Loop once for each row of LaborConsumption Table

		  more = rs.next ();
	      while (more) {
			String mei = rs.getString("MaintEventId");
		    
		   int p=acm.getMaintenanceEventScheduledStartPeriod(mei);
		   System.out.println("Scheduled starting date for ");
		    	System.out.println("      Maintenance event: "+mei);
		    	System.out.println("      is "+ p);
		    	
	/*	   String scheduledLocation=acm.getMaintenanceEventScheduledLocation(mei);
		   System.out.println("Scheduled location for ");
		    	System.out.println("      Maintenance event: "+mei);
		    	System.out.println("      is "+ scheduledLocation);
*/
		    // Fetch the next result set row
		    more = rs.next ();
	      }
	      
		  rs.close(); 
		  stmt.close();
		  con.close();
@


1.32
log
@output on unitTest
@
text
@d64 6
a69 5
		  rs = stmt.executeQuery ( "SELECT Max(ElapseDays) FROM [Events and Resource Consumption$]");
		  rs.next();
		  int maxD = rs.getInt(1);
		  System.out.println("Maximum duration of a maintenance event will be "+maxD);
		  rs.close();
a92 36
		  // Get data from MaintenanceEvent Table
//		  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource Consumption$]");		  
	  	/*  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource Consumption$]");		  

		  // Loop once for each row of Maintenance Table
		  more = rs.next ();
	      while (more) {

		    // Get data from row and pass to acm object
		    String mei = rs.getString("MaintEventId");
		    java.util.Date date = rs.getDate("SchedStartDate");
		    
		    int p=-1;
		    try {
		       p = perMgr.periodNumber(date);
		 
		       acm.addMaintenanceEvent(mei);
		       acm.setMaintenanceEventStartPeriodRange(mei,p,p,p);
		  //     int earliestPeriod = p-1;
		   //    if( earliestPeriod<0 ) earliestPeriod=0;

		//       acm.setMaintenanceEventRequiredStartingPeriods(mei,p,earliestPeriod,p);
		    }
		    catch (ACexception periodExp) {
		    	System.out.println("Error adding MaintenanceEvent");
		    	System.out.println("      Maintenance event: "+mei);
		    	System.out.println("      Date: "+DateFormat.getDateInstance().format(date));
		    	System.out.println("      "+periodExp.getMessage());
		    }
		    // Fetch the next result set row
		    more = rs.next ();
	      }
	      
          // Close result set
		  rs.close(); 
		  */
d109 3
a111 1
            acm.addMaintenanceEvent(mei);
d114 6
a119 2
		    int latestPeriod = p;
	        acm.setMaintenanceEventStartPeriodRange(mei,p,earliestPeriod, latestPeriod);
d121 1
a121 1
		    String planeType = "wide"; /* or "747" or "narrow" */
d123 1
d127 1
a127 17
		    
		    /* The following describes the relationship between the space constraint and the hangars
		     */
		     
	    ACstringPair key = new ACstringPair(sp,mei);
		    
		    if ( !map.containsKey(key) ) {
		    	// add entry
		    	float [] lhs = new float[ph];
		    	lhs[p] = lh;
		    	map.put(key,lhs);
		    }
		    else {
		    	float [] lhs = (float[])map.get(key);
		    	lhs[p] = lh;
		    }	 

d130 1
a130 8
	      }
	      for (Iterator i=map.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry e = (Map.Entry) i.next();
            ACstringPair key = (ACstringPair)e.getKey();
            float [] lhs = (float[])e.getValue();
            System.out.println(e.getKey() + ": " + e.getValue());
           }
          
a141 32
		  
		/*
		 * HANGARS ARE NOW HARD CODED INTO ACmaintenance Class
		 * as described in powerPoint charts.
		    /* The following describes the relationship between the space constraint and the hangars
		     
		  acm.addSpaceHangarLink("wideAtYUL","4WideBody",4, "HG1YUL");
		  acm.addSpaceHangarLink("wideAtYUL","2WideBody1B747",2, "HG1YUL");
		  acm.addSpaceHangarLink("747AtYUL","2WideBody1B747",1, "HG1YUL");
		  acm.addSpaceHangarLink("wideAtYUL","1WideBody",4, "HG2YUL");
		  acm.addSpaceHangarLink("narrowAtYUL","1NarrowBody",4, "HG2YUL");
		  
		  acm.addSpaceHangarLink("wideAtYVR","1WideBody3NarrowBody",1, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","1WideBody3NarrowBody",3, "HG1YVR");
		  acm.addSpaceHangarLink("wideAtYVR","2WideBody2NarrowBody",2, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","2WideBody2NarrowBody",2, "HG1YVR");
		  acm.addSpaceHangarLink("wideAtYVR","3WideBody1NarrowBody",3, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","3WideBody1NarrowBody",1, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","3NarrowBody1B747",3, "HG1YVR");
		  acm.addSpaceHangarLink("747AtYVR","3NarrowBody1B747",1, "HG1YVR");
		  acm.addSpaceHangarLink("wideAtYVR","1WideBody2NarrowBody1B747",1, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","1WideBody2NarrowBody1B747",2, "HG1YVR");
		  acm.addSpaceHangarLink("747AtYVR","1WideBody2NarrowBody1B747",1, "HG1YVR");
		  acm.addSpaceHangarLink("wideAtYVR","2WideBody1NarrowBody1B747",2, "HG1YVR");
		  acm.addSpaceHangarLink("narrowAtYVR","2WideBody1NarrowBody1B747",1, "HG1YVR");
		  acm.addSpaceHangarLink("747AtYVR","2WideBody1NarrowBody1B747",1, "HG1YVR");
		  
		  acm.addSpaceHangarLink("narrowAtYWG","5NarrowBody",5, "HG1YWG");
		  acm.addSpaceHangarLink("narrowAtYWG","2NarrowBodyYWG",2, "HG1YWG");
		  
		  acm.addSpaceHangarLink("narrowAtYYC","2NarrowBodyYYC",2, "HG1YYC");
          */
d144 1
a144 1
        acm.solve();  //witHeurImplode
@


1.31
log
@output location
@
text
@d249 1
a249 1
		   String scheduledLocation=acm.getMaintenanceEventScheduledLocation(mei);
d253 1
a253 1

@


1.30
log
@Minor changes
@
text
@d248 5
@


1.29
log
@Maximum Duration
@
text
@d67 1
a67 1
		  System.out.println("MAximum duration of a maintenance event will be "+maxD);
@


1.28
log
@SQL fixed; Input set
@
text
@d64 5
@


1.27
log
@fix the sql error(2)
@
text
@d89 1
a89 1
	  	  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource Consumption$]");		  
d104 1
d122 1
a122 1
		  
d139 1
a139 1
            
@


1.26
log
@fix the sql error
@
text
@d153 1
a153 1
	/*	    ACstringPair key = new ACstringPair(ri,mei);
d165 1
a165 1
*/
d169 1
a169 1
/*	      for (Iterator i=map.entrySet().iterator(); i.hasNext(); ) {
d175 1
a175 1
           */
@


1.25
log
@Added some methods to get results.
Turned multRoute on.
Changed some method names.
Altered the way offsets are set (to be correct, hopefully)
@
text
@d66 1
a66 1
		  rs = stmt.executeQuery ("SELECT * FROM [Available Resources 1$]");
d89 1
a89 1
	  	  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource 1$]");		  
d124 1
a124 1
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate,BodyType, Location,ElapseDays,laborHours FROM [Events and Resource 1$]");		  
d230 1
a230 1
        rs = stmt.executeQuery ("SELECT MaintEventId FROM [Events and Resource 1$]");		  
@


1.24
log
@modified to use new methods
@
text
@d78 1
a78 1
		    acm.setLocationLaborHours(ri,p,lh);
d238 1
a238 1
		   int p=acm.getMaintenanceEventPlannedStartPeriod(mei);
@


1.23
log
@Commented out older code which managed hangars
@
text
@d78 1
a78 1
		    acm.addPeriodResource(ri,p,lh);
a132 1
		    String ri=rs.getString("Location");
d134 1
a134 1
		    int q =rs.getInt("ElapseDays");
d138 10
a147 4
            acm.setMaintenanceEventPlanning(mei, p, q, lh, ri);
	        acm.setMaintenanceEventRequiredStartingPeriods(mei,p,p,p+q, lh);
		    acm.addMaintenanceEventResourceLink(mei, ri, sp);
		    acm.setMaintenanceEventRecourseLinkConsumptionRate(mei,ri,lh/q);
@


1.22
log
@Fixed up some comments
@
text
@d183 3
a185 1
		  
d187 1
a187 1
		     */
d213 1
a213 1

@


1.21
log
@no message
@
text
@d30 1
a30 3
		  // Tell ACM about data in Period Resource Table
		  // Adding a comment JP
		  
@


1.20
log
@no message
@
text
@d141 2
a142 3
            for ( int t=0; t<q; t++ )
            { 
	        acm.setMaintenanceEventRequiredStartingPeriods(mei,p+t,p+t,p+t, lh);
d145 1
a145 1
            }
@


1.19
log
@no message
@
text
@d140 4
a143 2

	        acm.setMaintenanceEventRequiredStartingPeriods(mei,p,p,p+q, lh);
d145 6
a150 2
		    acm.setMaintenanceEventRecourseLinkConsumptionRate(mei,ri,1);
	  
d178 1
a178 1

d184 32
@


1.18
log
@no message
@
text
@d126 1
a126 1
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate,Location,ElapseDays,laborHours FROM [Events and Resource 1$]");		  
d136 1
d142 1
a142 1
		    acm.addMaintenanceEventResourceLink(mei, ri);
@


1.17
log
@no message
@
text
@d144 1
a144 1
		    ACstringPair key = new ACstringPair(ri,mei);
d156 1
a156 1

d160 1
a160 1
	      for (Iterator i=map.entrySet().iterator(); i.hasNext(); ) {
d166 1
d171 1
a171 1
		  
d173 1
a173 2
  		  stmt.close();
		  con.close();
d195 4
a198 2
		   acm.getMaintenanceEventPlannedStartPeriod(mei);
		 
d205 2
a206 1
		  
@


1.16
log
@no message
@
text
@d186 17
@


1.15
log
@no message
@
text
@d106 2
a107 2
		       int earliestPeriod = p-1;
		       if( earliestPeriod<0 ) earliestPeriod=0;
d109 1
a109 1
		       acm.setMaintenanceEventRequiredStartingPeriods(mei,p,earliestPeriod,p);
d140 1
a140 1
	
d142 1
a142 1
		    acm.setMaintenanceEventRecourseLinkConsumptionRate(mei,ri,lh);
@


1.14
log
@no message
@
text
@d109 1
a109 1
		       acm.setMaintenanceEventRequiredCompletionPeriods(mei,p,earliestPeriod,p);
@


1.13
log
@no message
@
text
@d9 1
a9 1

@


1.12
log
@no message
@
text
@d126 1
a126 1
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate,Location,ElapseDays,laborHours FROM [Events and Resource Consumption$]");		  
@


1.11
log
@no message
@
text
@d178 1
a178 1
        //acm.solve();  //witHeurImplode
@


1.10
log
@no message
@
text
@d173 13
a185 1
		  con.close();		  
d209 1
a209 2
	    
    	catch (java.lang.Exception ex) {
@


1.9
log
@no message
@
text
@d141 3
a143 1
		    
@


1.8
log
@no message
@
text
@d91 1
a91 1
	  	  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource Consumption$]");		  
d126 1
a126 1
		  rs = stmt.executeQuery ("SELECT MaintEventId,SchedStartDate, Location,ElapseDays, laborHours FROM [Events and Resource 1$]");		  
d136 1
a136 1
		    int q =rs.getInt("Elapsdays");
@


1.7
log
@no message
@
text
@d68 1
a68 1
		  rs = stmt.executeQuery ("SELECT * FROM [Available Resources$]");
d91 1
a91 1
	  	  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource$]");		  
@


1.6
log
@test on cvs
@
text
@d126 1
a126 1
		  rs = stmt.executeQuery ("SELECT [Available Resources 1$].date,[Events and Resource 1$].laborHours,[Available Resources 1$].resourceId,[Events and Resource 1$].MaintEventId FROM [Available Resources 1$],[Events and Resource 1$]");		  
d132 2
a133 1

d135 2
a136 1
		    java.util.Date date = rs.getDate("date");
d139 2
a140 2
		    String ri = rs.getString("resourceId");
		    String mei = rs.getString("MaintEventId");
@


1.5
log
@Testing cvs with Yingdong
@
text
@d2 1
a2 1
// JPF
d68 1
a68 1
		  rs = stmt.executeQuery ("SELECT * FROM [Available Resources 1$]");
d91 1
a91 1
	  	  rs = stmt.executeQuery ("SELECT MaintEventId, SchedStartDate FROM [Events and Resource 1$]");		  
@


1.4
log
@modification at 6pm, 10/31/02
@
text
@d2 1
a2 1

@


1.3
log
@playing with cvs
@
text
@d27 1
a27 1
		  acm.setPlanningHorizon(26);
d68 1
a68 1
		  rs = stmt.executeQuery ("SELECT * FROM [Available Resources$]");
d90 3
a92 2
		  rs = stmt.executeQuery ("SELECT MtceEventId,SchedStartDate FROM [Events and Resource Consumption$]");		  
		  
d98 1
a98 1
		    String mei = rs.getString("MtceEventId");
d125 2
a126 1
		  rs = stmt.executeQuery ("SELECT [Available Resources$].resourceId,[Available Resources$].period,[Events and Resource Consumption$].laborHours,[Events and Resource Consumption$].mtceEventId FROM [Available Resources$],[Events and Resource Consumption$]");		  
d134 2
a135 1
		    int p = rs.getInt("period");
d138 1
a138 1
		    String mei = rs.getString("mtceEventId");
@


1.2
log
@Playing with cvs
@
text
@d31 1
a31 1
		  // Adding a comment
@


1.1
log
@Moved Java Classes from src directory to AirCanada directory
@
text
@d31 1
@


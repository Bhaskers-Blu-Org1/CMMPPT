head	1.64;
access;
symbols
	start:1.1.1.1 dummy-vendor:1.1.1;
locks; strict;
comment	@# @;


1.64
date	2011.07.19.21.37.07;	author rjw;	state dead;
branches;
next	1.63;

1.63
date	2011.07.19.21.13.15;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.19.19.22.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.15.23.19.01;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.15.17.42.32;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.15.15.51.21;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.14.23.40.35;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.12.22.40.00;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.08.20.46.01;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.07.19.29.39;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.07.19.05.04;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.06.22.29.20;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.06.19.22.46;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.06.17.32.39;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.05.21.15.06;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.01.16.24.30;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.01.15.56.24;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.30.23.43.50;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.30.22.03.41;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.29.14.22.27;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.27.21.02.11;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.22.22.09.44;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.22.15.07.27;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.21.22.18.05;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.20.15.55.32;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.20.15.13.20;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.17.22.09.07;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.17.18.23.05;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.11.00.15.40;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.10.21.55.15;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.10.21.34.25;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.10.21.13.48;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.10.19.37.19;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.09.23.27.53;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.09.22.11.56;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.09.18.09.22;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.08.23.36.39;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.08.22.40.11;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.08.20.13.57;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.07.23.38.51;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.07.20.14.11;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.07.19.47.02;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.06.20.33.33;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.06.16.39.08;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.03.22.23.44;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.31.19.26.20;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.25.21.39.27;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.24.23.44.42;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.24.21.09.39;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.24.18.46.16;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.24.17.56.47;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.22.02.10.43;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.22.00.33.13;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.20.23.52.01;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.20.21.57.20;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.20.21.30.12;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.20.19.26.50;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.20.15.16.18;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.19.23.31.44;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.17.21.32.49;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.17.20.58.43;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.17.19.32.25;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.17.16.09.19;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.16.22.08.55;	author rjw;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.05.16.22.08.55;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Scheme ==> ModelScheme
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M Source File Scheme.java.
////////////////////////////////////////////////////////////////////////////////

package com.ibm.witm;

import static com.ibm.witm.Utility.*;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

/*******************************************************************************
 * A Scheme is the central object representing the static structure or "scheme"
 * of a WIT model, i.e., the data-independent aspects of the model.<br><br>
 * 
 * The factory method for creating instances of this class is
 * Scheme.newScheme (theName).
 *******************************************************************************
 */
public final class Scheme
{
////////////////////////////////////////////////////////////////////////////////
// Private Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The current Scheme that will be used by various WIT-M methods, if any;
 * otherwise null.
 *******************************************************************************
 */
   private static Scheme current = null;
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The name of the model.
 *******************************************************************************
 */
   private final String myName;
   
/*******************************************************************************
 * True, iff this Scheme is "frozen".
 *******************************************************************************
 */
   private boolean frozen = false;

/*******************************************************************************
 * The set of the names of all of schematic objects that belong to this Scheme.
 *******************************************************************************
 */
   private final HashSet <String> allNames;

/*******************************************************************************
 * A list of all Categories that belong to this Scheme.
 *******************************************************************************
 */
   private final ArrayList <ItemCategory <?>> myCategories;

/*******************************************************************************
 * The GLOBAL ItemCategory for this Scheme.
 *******************************************************************************
 */
   private final PrimitiveCategory myGlobalCategory;

/*******************************************************************************
 * The PERIOD ItemCategory for this Scheme.
 *******************************************************************************
 */
   private final PrimitiveCategory myPeriodCategory;

////////////////////////////////////////////////////////////////////////////////
// Private Constructor
////////////////////////////////////////////////////////////////////////////////

   private Scheme (String theName)
      {
      myName           = theName;
      
      allNames         = new HashSet <String> ();
      
      myCategories     = new ArrayList <ItemCategory <?>> ();
      
      myGlobalCategory = new PrimitiveCategory (this, "GLOBAL");
      myPeriodCategory = new PrimitiveCategory (this, "PERIOD");
      
      current          = this;
      
      storeName (theName);
      }

////////////////////////////////////////////////////////////////////////////////
// Private Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that the current Scheme is not null.
 *******************************************************************************
 */
   private static void requireCurScheme ()
      {
      if (current == null)
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to a method that requires a current Scheme when the\n"
             + "   current Scheme is null.\n");
      }

/*******************************************************************************
 * Verifies that newTupleCategory (...) was called with at least one
 * ItemCategory.<br>
 * To be called by newTupleCategory.
 *******************************************************************************
 */
   private static void requireAtLeast1Cat (
         String             theName,
         ItemCategory <?>[] theDimenArr)
      {
      if (theDimenArr.length == 0)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Scheme.newTupleCategory (theName, theDimens)\n"
             + "   with no Categories.\n"
             + "\n"
             + "      theName: \"" + theName + "\"\n");
         }
      }
   
/*******************************************************************************
 * Verifies that the Scheme of each ItemCategory in theDimenArr is the current
 * Scheme.<br>
 * To be called by newTupleCategory.
 *******************************************************************************
 */
   private static void requireSchemesBeCur (
         String             theName,
         ItemCategory <?>[] theDimenArr)
      {
      for (ItemCategory <?> theItemCat: theDimenArr)
         {
         if (theItemCat.getScheme () != current)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   Scheme.newTupleCategory (theName, theDimens)\n"
                + "   with at least one ItemCategory whose Scheme is not the\n" 
                + "   current Scheme.\n"
                + "\n"
                + "      theName:        " +            theName    + "\n"
                + "      ItemCategory:   " + theItemCat.getName () + "\n"
                + "         Scheme:      " + theItemCat.
                                                getScheme ().
                                                        getName () + "\n"
                + "      Current Scheme: " + current.   getName () + "\n");
         }
      }
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that this Scheme is not frozen.
 *******************************************************************************
 */
   private void prohibitFrozen ()
      {
      if (frozen)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to setCurrentScheme (theScheme) with a frozen Scheme.\n"
             + "\n"
             + "      Scheme: " + myName + "\n");
      }

/*******************************************************************************
 * Verifies that this Scheme is frozen.
 *******************************************************************************
 */
   private void requireFrozen (String theName)
      {
      if (! frozen)
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to Scheme.newModelInstance (theName), when the Scheme\n"
             + "   was not frozen:\n"
             + "\n"
             + "      Scheme:             " + myName  + "\n"
             + "      ModelInstance Name: " + theName + "\n");
      }
   
////////////////////////////////////////////////////////////////////////////////
// Package Internal Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that theName does not duplicate the name of an existing schematic
 * object in this Scheme.
 *******************************************************************************
 */
   void prohibitDupName (String theName, String signature)
      {
      if (allNames.contains (theName))
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to " + signature + "\n"
             + "   with a name that duplicates the name of an existing\n"
             + "   schematic object in the Scheme.\n"
             + "\n"
             + "      Duplicate Name: \"" + theName + "\"\n");
      }

/*******************************************************************************
 * Stores theName as the name of a schematic object that belongs to this Scheme.
 *******************************************************************************
 */
   void storeName (String theName)
      {
      allNames.add (theName);
      }

/*******************************************************************************
 * Stores theItemCat (a newly constructed ItemCategory) in this Scheme.
 *******************************************************************************
 */
   void store (ItemCategory <?> theItemCat)
      {
      myCategories.add (theItemCat);
      }

/*******************************************************************************
 * @@return An unmodifiable view of a list of all Categories that belong to this
 *         Scheme.
 *******************************************************************************
 */
   List <ItemCategory <?>> getCategories ()
      {
      return Collections.unmodifiableList (myCategories);
      }

/*******************************************************************************
 * @@return The GLOBAL ItemCategory for this Scheme.<br>
 * (Internal Version)
 *******************************************************************************
 */
   PrimitiveCategory getGlobalCat ()
      {
      return myGlobalCategory;
      }

/*******************************************************************************
 * @@return The PERIOD ItemCategory for this Scheme.<br>
 * (Internal Version)
 *******************************************************************************
 */
   PrimitiveCategory getPeriodCat ()
      {
      return myPeriodCategory;
      }

////////////////////////////////////////////////////////////////////////////////
// Public Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Sets the current Scheme.
 * 
 * @@param theScheme The Scheme which is to become current. (Null is allowed.)
 * 
 * @@throws IllegalArgumentException If theScheme is frozen
 *******************************************************************************
 */
   public static void setCurrentScheme (Scheme theScheme)
      {
      if (theScheme != null)
         theScheme.prohibitFrozen ();

      current = theScheme;
      }

/*******************************************************************************
 * @@return The current Scheme, if any; otherwise null.
 *******************************************************************************
 */
   public static Scheme getCurrentScheme ()
      {
      return current;
      }

/*******************************************************************************
 * Puts the current Scheme into a frozen state.<br>
 * When a Scheme is frozen, its state and the state of the Categories and
 * Properties that belong to it cannot be changed.<br>
 * This method also sets the current Scheme reference to null.<br>
 * In general, a frozen Scheme is never allowed to be the current Scheme.
 * 
 * @@throws IllegalStateException If the current Scheme is null
 *******************************************************************************
 */
   public static void freezeCurrentScheme ()
      {
      Scheme theScheme;
      
      requireCurScheme ();
      
      theScheme = current;
      current   = null;
      
      for (ItemCategory <?> theItemCat: theScheme.myCategories)
         theItemCat.freeze ();
      
      theScheme.frozen = true;
      }

/*******************************************************************************
 * Returns the GLOBAL ItemCategory ("GLOBAL") for the current Scheme.<br>
 * It is recommended that a reference to this ItemCategory be stored in the
 * application program as a static field called GLOBAL.
 * 
 * @@return The GLOBAL ItemCategory for the current Scheme.
 * 
 * @@throws IllegalStateException If the current Scheme is null
 *******************************************************************************
 */
   public static PrimitiveCategory getGlobalCategory ()
      {
      requireCurScheme ();
      
      return current.myGlobalCategory;
      }

/*******************************************************************************
 * Returns the PERIOD ItemCategory for the current Scheme.<br>
 * It is recommended that a reference to this ItemCategory be stored in the
 * application program as a static field called PERIOD.
 * 
 * @@return The PERIOD ItemCategory for the current Scheme.
 * 
 * @@throws IllegalStateException If the current Scheme is null
 *******************************************************************************
 */
   public static PrimitiveCategory getPeriodCategory ()
      {
      requireCurScheme ();
      
      return current.myPeriodCategory;
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new Scheme.<br>
 * Sets the current Scheme to the new Scheme.<br>
 *
 * @@param  theName              The name of the WIT Model
 * @@return                      The new Scheme
 * @@throws NullPointerException If theName is null
 *******************************************************************************
 */
   public static Scheme newScheme (String theName)
      {
      prohibitNull (theName, "theName");
      
      return new Scheme (theName);
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new PrimitiveCategory that will belong to the current Scheme.
 * 
 * @@param theName                   The name of the PrimitiveCategory to be
 *                                  constructed
 * @@return                          The new PrimitiveCategory
 * @@throws NullPointerException     If theName is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If theName duplicates the name of an
 *                                  existing PrimitiveCategory in the current
 *                                  Scheme
 *******************************************************************************
 */
   public static PrimitiveCategory newPrimitiveCategory (String theName)
      {
      prohibitNull       (theName, "theName");
      requireCurScheme   ();
      current.
         prohibitDupName (theName, "Scheme.newPrimitiveCategory (theName)");
      
      return new PrimitiveCategory (current, theName);
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new TupleCategory for the current Scheme.
 * 
 * @@param  theName                  The name of the TupleCategory to be
 *                                  constructed
 * @@param  theDimens                The Categories that are to be the
 *                                  dimensions of the TupleCategory    
 * @@return                          The new TupleCategory
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If no Categories are given
 * @@throws IllegalArgumentException The Categories do not all belong to the
 *                                  current Scheme
 * @@throws IllegalArgumentException If theName duplicates the name of an
 *                                  existing TupleCategory in the current Scheme
 *******************************************************************************
 */
   public static TupleCategory newTupleCategory (
         String              theName,
         ItemCategory <?>... theDimens)
      {
      prohibitNull            (theName,   "theName");
      prohibitNullArray       (theDimens, "theDimens");
      requireCurScheme        ();
      requireAtLeast1Cat      (theName,   theDimens);
      requireSchemesBeCur     (theName,   theDimens);
      current.prohibitDupName (theName,   "Scheme.newTupleCategory (theName)");
      
      return new TupleCategory (current, theName, theDimens);
      }

////////////////////////////////////////////////////////////////////////////////
// Public Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * @@return The name of the WIT model
 *******************************************************************************
 */
   public String getName ()
      {
      return myName;
      }

/*******************************************************************************
 * @@return True, iff this Scheme is "frozen".<br>
 * When a Scheme is frozen, its state cannot be changed.
 *******************************************************************************
 */
   public boolean isFrozen ()
      {
      return frozen;
      }

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */      @@Override
   public String toString ()
      {
      return concatenation ("Scheme \"", myName, "\""); 
      }
   
/*******************************************************************************
 * Prints this Scheme.
 * 
 * @@param theStream the PrintStream to which this Scheme is to be printed.
 *******************************************************************************
 */
   public void print (PrintStream theStream)
      {
      theStream.printf (
         "Detailed Print of Scheme %s:%n"
       + "%n"
       + "Frozen Scheme? %s%n",
         myName,
         frozen);
      
      for (ItemCategory <?> theItemCat: myCategories)
         theItemCat.print (theStream);
      }

/*******************************************************************************
 * Factory method: Constructs a new ModelInstance for this Scheme.<br>
 * The current ModelInstance is set to the new ModelInstance.<br>
 *
 * @@param  theName               The name of the new ModelInstance
 * @@return                       The new ModelInstance
 * @@throws NullPointerException  If any argument is null
 * @@throws IllegalStateException If this Scheme is not frozen
 *******************************************************************************
 */
   public ModelInstance newModelInstance (String theName)
      {
      prohibitNull  (theName, "theName");
      requireFrozen (theName);
      
      return new ModelInstance (this, theName);
      }
      
////////////////////////////////////////////////////////////////////////////////
}
@


1.63
log
@Embodiment ==> ModelInstance
@
text
@@


1.62
log
@Efficient String concatenation.
@
text
@d196 1
a196 1
             + "   Call to Scheme.newEmbodiment (theName), when the Scheme\n"
d199 2
a200 2
             + "      Scheme:          " + myName  + "\n"
             + "      Embodiment Name: " + theName + "\n");
d486 2
a487 2
 * Factory method: Constructs a new Embodiment for this Scheme.<br>
 * The current Embodiment is set to the new Embodiment.<br>
d489 2
a490 2
 * @@param  theName               The name of the new Embodiment
 * @@return                       The new Embodiment
d495 1
a495 1
   public Embodiment newEmbodiment (String theName)
d500 1
a500 1
      return new Embodiment (this, theName);
@


1.61
log
@newOperation
@
text
@d463 1
a463 1
      return "Scheme \"" + myName + "\""; 
@


1.60
log
@Category ==> ItemCategory
@
text
@d475 1
a475 1
         "Detailed Print of Scheme \"%s\":%n"
@


1.59
log
@Checking for duplicate schematic names.
@
text
@d63 1
a63 1
   private final ArrayList <Category <?>> myCategories;
d66 1
a66 1
 * The GLOBAL Category for this Scheme.
d72 1
a72 1
 * The PERIOD Category for this Scheme.
d87 1
a87 1
      myCategories     = new ArrayList <Category <?>> ();
d117 1
a117 1
 * Category.<br>
d122 2
a123 2
         String         theName,
         Category <?>[] theDimenArr)
d138 1
a138 1
 * Verifies that the Scheme of each Category in theDimenArr is the current
d144 2
a145 2
         String         theName,
         Category <?>[] theDimenArr)
d147 1
a147 1
      for (Category <?> theCat: theDimenArr)
d149 1
a149 1
         if (theCat.getScheme () != current)
d155 1
a155 1
                + "   with at least one Category whose Scheme is not the\n" 
d158 6
a163 5
                + "      theName:        " +         theName    + "\n"
                + "      Category:       " + theCat .getName () + "\n"
                + "         Scheme:      " 
                +           theCat.getScheme ()     .getName () + "\n"
                + "      Current Scheme: " + current.getName () + "\n");
d235 1
a235 1
 * Stores theCat (a newly constructed Category) in this Scheme.
d238 1
a238 1
   void store (Category <?> theCat)
d240 1
a240 1
      myCategories.add (theCat);
d248 1
a248 1
   List <Category <?>> getCategories ()
d254 1
a254 1
 * @@return The GLOBAL Category for this Scheme.<br>
d264 1
a264 1
 * @@return The PERIOD Category for this Scheme.<br>
d321 2
a322 2
      for (Category <?> theCat: theScheme.myCategories)
         theCat.freeze ();
d328 2
a329 2
 * Returns the GLOBAL Category ("GLOBAL") for the current Scheme.<br>
 * It is recommended that a reference to this Category be stored in the
d332 1
a332 1
 * @@return The GLOBAL Category for the current Scheme.
d345 2
a346 2
 * Returns the PERIOD Category for the current Scheme.<br>
 * It is recommended that a reference to this Category be stored in the
d349 1
a349 1
 * @@return The PERIOD Category for the current Scheme.
d421 2
a422 2
         String          theName,
         Category <?>... theDimens)
d481 2
a482 2
      for (Category <?> theCat: myCategories)
         theCat.print (theStream);
@


1.58
log
@Signatures with argument names.
@
text
@d13 1
d54 6
d85 2
d93 2
a115 26
 * Verifies that theName does not duplicate the name of an existing Category in
 * the current Scheme.
 * 
 * @@param sigString The signature of the public method called.
 *******************************************************************************
 */
   private static void prohibitDupCatName (String theName, String sigString)
      {
      for (Category <?> theCat: current.myCategories)
         {
         if (theCat.getName ().equals (theName))
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   Scheme." + sigString + ",\n"
                + "   where the name String duplicates the name of an\n"
                + "   existing Category in the current Scheme.\n"
                + "\n"
                + "      Duplicate Name: \"" + theName + "\"\n");
            }
         }
      }

/*******************************************************************************
d207 27
d395 2
a396 1
      prohibitDupCatName (theName, "newPrimitiveCategory (theName)");
d423 6
a428 6
      prohibitNull        (theName,   "theName");
      prohibitNullArray   (theDimens, "theDimens");
      requireCurScheme    ();
      requireAtLeast1Cat  (theName,   theDimens);
      requireSchemesBeCur (theName,   theDimens);
      prohibitDupCatName  (theName,   "newTupleCategory (theName, theDimens)");
@


1.57
log
@Compound ==> Tuple
@
text
@d20 1
a20 1
 * Scheme.newScheme (String).
d145 1
a145 2
             + "   Call to\n"
             + "   Scheme.newTupleCategory (String, Category <?>...)\n"
d148 1
a148 1
             + "      TupleCategory Name: \"" + theName + "\"\n");
d169 1
a169 1
                + "   Scheme.newTupleCategory (String, Category <?>...)\n"
d173 1
a173 1
                + "      TupleCategory:  " +         theName    + "\n"
d195 1
a195 1
             + "   Call to setCurrentScheme (Scheme) with a frozen Scheme.\n"
d210 1
a210 1
             + "   Call to Scheme.newEmbodiment (String), when the Scheme\n"
d383 1
a383 1
      prohibitDupCatName (theName, "newPrimitiveCategory (String)");
d415 1
a415 4
      
      prohibitDupCatName  (
         theName,
         "newTupleCategory (String, Category <?>...)");
@


1.56
log
@Class ProblemMgr.
@
text
@d131 1
a131 1
 * Verifies that newCompoundCategory (...) was called with at least one
d133 1
a133 1
 * To be called by newCompoundCategory.
d146 1
a146 1
             + "   Scheme.newCompoundCategory (String, Category <?>...)\n"
d149 1
a149 1
             + "      CompoundCategory Name: \"" + theName + "\"\n");
d156 1
a156 1
 * To be called by newCompoundCategory.
d170 1
a170 1
                + "   Scheme.newCompoundCategory (String, Category <?>...)\n"
d174 5
a178 5
                + "      CompoundCategory: " +         theName    + "\n"
                + "      Category:         " + theCat .getName () + "\n"
                + "         Scheme:        " 
                +           theCat.getScheme ()       .getName () + "\n"
                + "      Current Scheme:   " + current.getName () + "\n");
d391 1
a391 1
 * Constructs a new CompoundCategory for the current Scheme.
d393 1
a393 1
 * @@param  theName                  The name of the CompoundCategory to be
d396 2
a397 2
 *                                  dimensions of the CompoundCategory    
 * @@return                          The new CompoundCategory
d404 1
a404 2
 *                                  existing CompoundCategory in the current
 *                                  Scheme
d407 1
a407 1
   public static CompoundCategory newCompoundCategory (
d419 1
a419 1
         "newCompoundCategory (String, Category <?>...)");
d421 1
a421 1
      return new CompoundCategory (current, theName, theDimens);
@


1.55
log
@PERIOD Primitives
@
text
@d6 1
a6 1
package       com.ibm.witm;
@


1.54
log
@Period Primitives.
@
text
@d251 10
@


1.53
log
@Removed period index Property.
@
text
@d59 1
a59 1
 * The global Category ("GLOBAL") for this Scheme.
d65 1
a65 1
 * The period Category ("PERIOD") for this Scheme.
d242 1
a242 1
 * @@return The global category for this Scheme.<br>
d306 1
a306 1
 * Returns the global Category ("GLOBAL") for the current Scheme.<br>
d310 1
a310 1
 * @@return The global Category for the current Scheme.
d323 1
a323 1
 * Returns the period Category ("PERIOD") for the current Scheme.<br>
d327 1
a327 1
 * @@return The period category for the current Scheme.
@


1.52
log
@Moved some responsibility to constructors.
@
text
@a69 6
/*******************************************************************************
 * The period index Property ("PERIOD_INDEX") for this Scheme.
 *******************************************************************************
 */
   private final Property <Integer> myPeriodIndexProperty;

d76 1
a76 1
      myName                = theName;
d78 1
a78 1
      myCategories          = new ArrayList <Category <?>> ();
d80 2
a81 2
      myGlobalCategory      = new PrimitiveCategory (this, "GLOBAL");
      myPeriodCategory      = new PrimitiveCategory (this, "PERIOD");
d83 1
a83 7
      myPeriodIndexProperty =
         new Property <Integer> (
            Integer.class,
            myPeriodCategory,
            "PERIOD_INDEX");

      current               = this;
d242 2
a243 1
 * @@return The global category for this Scheme.
d246 1
a246 1
   PrimitiveCategory getGlobalCategoryInternal ()
a339 18
 * Returns the period index Property ("PERIOD_INDEX") for the current Scheme.
 * <br>
 * It is recommended that a reference to this Property be stored in the
 * application program as a static field called PERIOD_INDEX.
 * 
 * @@return The period index Property for the current Scheme.
 * 
 * @@throws IllegalStateException If the current Scheme is null
 *******************************************************************************
 */
   public static Property<Integer> getPeriodIndexProperty ()
      {
      requireCurScheme ();
      
      return current.myPeriodIndexProperty;
      }

/*******************************************************************************
@


1.51
log
@Period Category
@
text
@a79 4
/*******************************************************************************
 * Constructor
 *******************************************************************************
 */
d82 1
a82 7
      myName           = theName;
      
      myCategories     = new ArrayList <Category <?>> ();
      
      myGlobalCategory = new PrimitiveCategory (this, "GLOBAL");
      
      myCategories.add (myGlobalCategory);
d84 1
a84 1
      myPeriodCategory = new PrimitiveCategory (this, "PERIOD");
d86 2
a87 1
      myCategories.add (myPeriodCategory);
d90 6
a95 1
         myPeriodCategory.newPropertyInternal (Integer.class, "PERIOD_INDEX");
d235 9
d371 1
a371 1
 * The current Scheme is set to the new Scheme.<br>
d382 1
a382 3
      current = new Scheme (theName);
      
      return current;
a400 2
      PrimitiveCategory thePrimCat;
      
d405 1
a405 5
      thePrimCat = new PrimitiveCategory (current, theName);
      
      current.myCategories.add (thePrimCat);
      
      return thePrimCat;
a430 2
      CompoundCategory theCompCat;
      
d441 1
a441 5
      theCompCat = new CompoundCategory (current, theName, theDimens);
      
      current.myCategories.add (theCompCat);
      
      return theCompCat;
a506 2
      Embodiment theEmb;
      
d510 1
a510 5
      theEmb = new Embodiment (this, theName);
      
      Embodiment.setCurrentEmbodiment (theEmb);
      
      return theEmb;
@


1.50
log
@Implementation ==> Embodiment
@
text
@d59 1
a59 1
 * The global category for this Scheme.
d64 12
d93 7
d312 5
a316 1
 * @@return The global category for the current Scheme.
d329 35
@


1.49
log
@Moved newImplementation from Implementation to Scheme.
@
text
@d208 1
a208 1
             + "   Call to Scheme.newImplementation (String), when the Scheme\n"
d211 2
a212 2
             + "      Scheme:              " + myName  + "\n"
             + "      Implementation Name: " + theName + "\n");
d447 2
a448 2
 * Factory method: Constructs a new Implementation for this Scheme.<br>
 * The current Implementation is set to the new Implementation.<br>
d450 2
a451 2
 * @@param  theName               The name of the new Implementation
 * @@return                       The new Implementation
d456 1
a456 1
   public Implementation newImplementation (String theName)
d458 1
a458 1
      Implementation theImple;
d463 1
a463 1
      theImple = new Implementation (this, theName);
d465 1
a465 1
      Implementation.setCurrentImplementation (theImple);
d467 1
a467 1
      return theImple;
@


1.48
log
@Moved newProperty to class Category
@
text
@d184 1
a184 2
 * Verifies that this Scheme is not frozen.<br>
 * To be called by setCurrentScheme.
d198 17
d446 24
@


1.47
log
@//=== ==> /////
@
text
@a12 1
import java.util.HashSet;
a178 27
/*******************************************************************************
 * Verifies that theName does not duplicate the name of an existing Property in
 * the current Scheme.<br>
 * To be called by newProperty (...).
 *******************************************************************************
 */
   private static void prohibitDupPropName (
         String theName,
         String sigString)
      {
      for (Category <?> theCat: current.myCategories)
         for (Property <?> theProp: theCat.getProperties ())
            {
            if (theName.equals (theProp.getName ()))
               throw
                  new IllegalArgumentException (
                     "\n\n"
                   + "   Call to\n"
                   + "   Scheme." + sigString + ","
                   + "\n"
                   + "   where the String duplicates the name of an existing\n"
                   + "   Property in the current Scheme.\n"
                   + "\n"
                   + "      Duplicate Name: \"" + theName + "\"\n");
            }
      }

a378 43
/*******************************************************************************
 * Factory method:<br>
 * Constructs a new Property {@@literal<V>} that will be associated with the
 * current Scheme.
 * 
 * @@param <V>          The value type of the Property (compile time)
 * @@param theValueType The value type of the Property (run time)
 * @@param theCat       The Category to which the Property will belong.
 * @@param theName      The name of the Property
 * @@return             The new Property {@@literal<V>}
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If theName duplicates the name of an 
 *                                  existing Property in the current Scheme
 *******************************************************************************
 */
   public static <V> Property <V> newProperty (
         Class <V>    theValueType,
         Category <?> theCat,
         String       theName)
      {
      Property <V> theProp;
      
      prohibitNull     (theValueType, "theValueType");
      prohibitNull     (theCat,       "theCat");
      prohibitNull     (theName,      "theName");
      requireCurScheme ();
      
      prohibitDupPropName (
         theName,
         "newProperty (Class <V>, Category <?>, String)");
      
      theProp =
         new Property <V> (theValueType, theCat, theName)
            {
            };
      
      theCat.store (theProp);

      return theProp;
      }

@


1.46
log
@Various revisions.
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d26 1
a26 1
//==============================================================================
d28 1
a28 1
//==============================================================================
d37 1
a37 1
//==============================================================================
d39 1
a39 1
//==============================================================================
d65 1
a65 1
//==============================================================================
d67 1
a67 1
//==============================================================================
d84 1
a84 1
//==============================================================================
d86 1
a86 1
//==============================================================================
d207 1
a207 1
//==============================================================================
d209 1
a209 1
//==============================================================================
d227 1
a227 1
//==============================================================================
d229 1
a229 1
//==============================================================================
d250 1
a250 1
//==============================================================================
d252 1
a252 1
//==============================================================================
d450 1
a450 1
//==============================================================================
d452 1
a452 1
//==============================================================================
d501 1
a501 1
//==============================================================================
@


1.45
log
@Global Category / Primitive.
@
text
@d27 1
a27 1
// Private Members
d37 4
d65 4
d70 1
a70 1
 * Constructor.
d84 4
a102 16
 * Verifies that this Scheme is not frozen.<br>
 * To be called by setCurrentScheme.
 *******************************************************************************
 */
   private void prohibitFrozen ()
      {
      if (frozen)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to setCurrentScheme (Scheme) with a frozen Scheme.\n"
             + "\n"
             + "      Scheme: " + myName + "\n");
      }

/*******************************************************************************
d186 3
a188 1
   private static final void prohibitDupPropName (String theName)
d198 1
a198 1
                   + "   Scheme.newProperty (Class <V>, Category <?>, String),"
d208 21
a228 1
// Package Internal Members
d251 1
a251 1
// Public Members
a254 28
 * @@return The name of the WIT model
 *******************************************************************************
 */
   public String getName ()
      {
      return myName;
      }

/*******************************************************************************
 * @@return True, iff this Scheme is "frozen".<br>
 * When a Scheme is frozen, its state cannot be changed.
 *******************************************************************************
 */
   public boolean isFrozen ()
      {
      return frozen;
      }

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */
   @@Override public String toString ()
      {
      return "Scheme \"" + myName + "\""; 
      }
   
/*******************************************************************************
a317 19
 * Prints this Scheme.
 * 
 * @@param theStream the PrintStream to which this Scheme is to be printed.
 *******************************************************************************
 */
   public void print (PrintStream theStream)
      {
      theStream.printf (
         "Detailed Print of Scheme \"%s\":%n"
       + "%n"
       + "Frozen Scheme? %s%n",
         myName,
         frozen);
      
      for (Category <?> theCat: myCategories)
         theCat.print (theStream);
      }

/*******************************************************************************
d409 2
a410 2
 * Constructs a new Property <V> that will be associated with the current
 * Scheme.
d412 2
a413 1
 * @@param theValueType The value type of the Property
d416 1
a416 1
 * @@return             The new Property <V>
d424 1
a424 1
   public static final <V> Property <V> newProperty (
d431 8
a438 5
      prohibitNull        (theValueType, "theValueType");
      prohibitNull        (theCat,       "theCat");
      prohibitNull        (theName,      "theName");
      requireCurScheme    ();
      prohibitDupPropName (theName);
d440 4
a443 1
      theProp = new Property <V> (theValueType, theCat, theName);
d451 51
@


1.44
log
@Re-arranged members.
@
text
@d56 6
d67 7
a73 2
      myName       = theName;
      myCategories = new ArrayList <Category <?>> ();
d223 9
d315 13
@


1.43
log
@Tuple ==> Compound
@
text
@d27 1
a27 1
// Public
d31 2
a32 7
 * Factory method:<br>
 * Constructs a new Scheme.<br>
 * The current Scheme is set to the new Scheme.<br>
 *
 * @@param  theName              The name of the WIT Model
 * @@return                      The new Scheme
 * @@throws NullPointerException If theName is null
d35 2
a36 9
   public static Scheme newScheme (String theName)
      {
      prohibitNull (theName, "theName");
      
      current = new Scheme (theName);
      
      return current;
      }

d38 1
a38 11
 * Factory method:<br>
 * Constructs a new PrimitiveCategory that will belong to the current Scheme.
 * 
 * @@param theName                   The name of the PrimitiveCategory to be
 *                                  constructed
 * @@return                          The new PrimitiveCategory
 * @@throws NullPointerException     If theName is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If theName duplicates the name of an
 *                                  existing PrimitiveCategory in the current
 *                                  Scheme
d41 1
a41 170
   public static PrimitiveCategory newPrimitiveCategory (String theName)
      {
      PrimitiveCategory thePrimCat;
      
      prohibitNull       (theName, "theName");
      requireCurScheme   ();
      prohibitDupCatName (theName, "newPrimitiveCategory (String)");
      
      thePrimCat = new PrimitiveCategory (current, theName);
      
      current.myCategories.add (thePrimCat);
      
      return thePrimCat;
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new CompoundCategory for the current Scheme.
 * 
 * @@param  theName                  The name of the CompoundCategory to be
 *                                  constructed
 * @@param  theDimens                The Categories that are to be the
 *                                  dimensions of the CompoundCategory    
 * @@return                          The new CompoundCategory
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If no Categories are given
 * @@throws IllegalArgumentException The Categories do not all belong to the
 *                                  current Scheme
 * @@throws IllegalArgumentException If theName duplicates the name of an
 *                                  existing CompoundCategory in the current
 *                                  Scheme
 *******************************************************************************
 */
   public static CompoundCategory newCompoundCategory (
         String          theName,
         Category <?>... theDimens)
      {
      CompoundCategory theCompCat;
      
      prohibitNull        (theName,   "theName");
      prohibitNullArray   (theDimens, "theDimens");
      requireCurScheme    ();
      requireAtLeast1Cat  (theName,   theDimens);
      requireSchemesBeCur (theName,   theDimens);
      
      prohibitDupCatName  (
         theName,
         "newCompoundCategory (String, Category <?>...)");
      
      theCompCat = new CompoundCategory (current, theName, theDimens);
      
      current.myCategories.add (theCompCat);
      
      return theCompCat;
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new Property <V> that will be associated with the current
 * Scheme.
 * 
 * @@param theValueType The value type of the Property
 * @@param theCat       The Category to which the Property will belong.
 * @@param theName      The name of the Property
 * @@return             The new Property <V>
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Scheme is null
 * @@throws IllegalArgumentException If theName duplicates the name of an 
 *                                  existing Property in the current Scheme
 *******************************************************************************
 */
   public static final <V> Property <V> newProperty (
         Class <V>    theValueType,
         Category <?> theCat,
         String       theName)
      {
      Property <V> theProp;
      
      prohibitNull        (theValueType, "theValueType");
      prohibitNull        (theCat,       "theCat");
      prohibitNull        (theName,      "theName");
      requireCurScheme    ();
      prohibitDupPropName (theName);
      
      theProp = new Property <V> (theValueType, theCat, theName);
      
      theCat.store (theProp);

      return theProp;
      }

/*******************************************************************************
 * Prints this Scheme.
 * 
 * @@param theStream the PrintStream to which this Scheme is to be printed.
 *******************************************************************************
 */
   public void print (PrintStream theStream)
      {
      theStream.printf (
         "Detailed Print of Scheme \"%s\":%n"
       + "%n"
       + "Frozen Scheme? %s%n",
         myName,
         frozen);
      
      for (Category <?> theCat: myCategories)
         theCat.print (theStream);
      }

/*******************************************************************************
 * Sets the current Scheme.
 * 
 * @@param theScheme The Scheme which is to become current. (Null is allowed.)
 * 
 * @@throws IllegalArgumentException If theScheme is frozen
 *******************************************************************************
 */
   public static void setCurrentScheme (Scheme theScheme)
      {
      if (theScheme != null)
         theScheme.prohibitFrozen ();

      current = theScheme;
      }

/*******************************************************************************
 * @@return The current Scheme, if any; otherwise null.
 *******************************************************************************
 */
   public static Scheme getCurrentScheme ()
      {
      return current;
      }

/*******************************************************************************
 * Puts the current Scheme into a frozen state.<br>
 * When a Scheme is frozen, its state and the state of the Categories and
 * Properties that belong to it cannot be changed.<br>
 * This method also sets the current Scheme reference to null.<br>
 * In general, a frozen Scheme is never allowed to be the current Scheme.
 * 
 * @@throws IllegalStateException If the current Scheme is null
 *******************************************************************************
 */
   public static void freezeCurrentScheme ()
      {
      Scheme theScheme;
      
      requireCurScheme ();
      
      theScheme = current;
      current   = null;
      
      for (Category <?> theCat: theScheme.myCategories)
         theCat.freeze ();
      
      theScheme.frozen = true;
      }

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */
   @@Override public String toString ()
      {
      return "Scheme \"" + myName + "\""; 
      }
d44 1
a44 1
 * @@return The name of the WIT model
d47 1
a47 4
   public String getName ()
      {
      return myName;
      }
d50 1
a50 2
 * @@return True, iff this Scheme is "frozen".<br>
 * When a Scheme is frozen, its state cannot be changed.
d53 1
a53 22
   public boolean isFrozen ()
      {
      return frozen;
      }

//==============================================================================
// Package Internal
//==============================================================================

/*******************************************************************************
 * @@return An unmodifiable view of a list of all Categories that belong to this
 *         Scheme.
 *******************************************************************************
 */
   List <Category <?>> getCategories ()
      {
      return Collections.unmodifiableList (myCategories);
      }

//==============================================================================
// Private
//==============================================================================
d198 37
d236 1
a236 2
 * current is the current Scheme that will be used by various WIT-M methods,
 * if any; otherwise null.
d239 4
a242 1
   private static Scheme current = null;
d245 53
a297 1
 * The name of the WIT model.
d300 61
a360 2
   private final String myName;
   
d362 16
a377 1
 * True, iff this Scheme is "frozen".
d380 22
a401 1
   private boolean frozen = false;
d404 13
a416 1
 * A list of all Categories that belong to this Scheme.
d419 19
a437 1
   private final ArrayList <Category <?>> myCategories;
@


1.42
log
@Doc comments
@
text
@d80 1
a80 1
 * Constructs a new TupleCategory for the current Scheme.
d82 1
a82 1
 * @@param  theName                  The name of the TupleCategory to be
d85 2
a86 2
 *                                  dimensions of the TupleCategory    
 * @@return                          The new TupleCategory
d93 2
a94 1
 *                                  existing TupleCategory in the current Scheme
d97 1
a97 1
   public static TupleCategory newTupleCategory (
d101 1
a101 1
      TupleCategory theTupleCat;
d111 1
a111 1
         "newTupleCategory (String, Category <?>...)");
d113 1
a113 1
      theTupleCat = new TupleCategory (current, theName, theDimens);
d115 1
a115 1
      current.myCategories.add (theTupleCat);
d117 1
a117 1
      return theTupleCat;
d338 3
a340 3
 * Verifies that newTupleCategory (...) was called with at least one Category.
 * <br>
 * To be called by newTupleCategory.
d352 2
a353 1
             + "   Call to Scheme.newTupleCategory (String, Category <?>...)\n"
d356 1
a356 1
             + "      TupleCategory Name: \"" + theName + "\"\n");
d363 1
a363 1
 * To be called by newTupleCategory.
d377 1
a377 1
                + "   Scheme.newTupleCategory (String, Category <?>...)\n"
d381 5
a385 5
                + "      TupleCategory:  " +         theName    + "\n"
                + "      Category:       " + theCat .getName () + "\n"
                + "         Scheme:      " 
                +           theCat.getScheme ()     .getName () + "\n"
                + "      Current Scheme: " + current.getName () + "\n");
@


1.41
log
@Revised comments, etc.
@
text
@d18 4
a21 1
 * of a WIT model, i.e., the data-independent aspects of the model.
@


1.40
log
@prohibitFrozen
@
text
@d221 3
a223 3
/* *****************************************************************************
 * Doc comment inherited.
 * *****************************************************************************
@


1.39
log
@Removed Scheme.myPropertyNames.
@
text
@d182 1
a182 1
         prohibitFrozenScheme (theScheme);
d292 1
a292 1
 * Verifies that theScheme is not frozen.<br>
d296 1
a296 1
   private static void prohibitFrozenScheme (Scheme theScheme)
d298 1
a298 1
      if (theScheme.frozen)
d304 1
a304 1
             + "      Scheme: " + theScheme.getName () + "\n");
@


1.38
log
@myPrimitiveCategories and myTupleCategories ==> myCategories
@
text
@a144 2
      current.myPropertyNames.add (theName);
      
d273 2
a274 3
      myName          = theName;
      myCategories    = new ArrayList <Category <?>>      ();
      myPropertyNames = new HashSet   <String>            ();
d392 15
a406 12
      if (current.myPropertyNames.contains (theName))
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Scheme.newProperty (Class <V>, Category <?>, String),\n"
             + "   where the name String duplicates the name of an existing\n"
             + "   Property in the current Scheme.\n"
             + "\n"
             + "      Duplicate Name: \"" + theName + "\"\n");
         }
a433 6
/*******************************************************************************
 * The set of the names of the Properties in this Scheme.
 *******************************************************************************
 */
   private final HashSet <String> myPropertyNames;

@


1.37
log
@Replaced ItemCategory with Category <?>.
@
text
@d64 3
a66 3
      prohibitNull           (theName, "theName");
      requireCurScheme       ();
      prohibitDupPrimCatName (theName);
d70 1
a70 1
      current.myPrimitiveCategories.add (thePrimCat);
d99 9
a107 6
      prohibitNull            (theName,   "theName");
      prohibitNullArray       (theDimens, "theDimens");
      requireCurScheme        ();
      requireAtLeast1Cat      (theName,   theDimens);
      requireSchemesBeCur     (theName,   theDimens);
      prohibitDupTupleCatName (theName);
d111 1
a111 1
      current.myTupleCategories.add (theTupleCat);
d169 2
a170 5
      for (PrimitiveCategory thePrimCategory: myPrimitiveCategories)
         thePrimCategory.print (theStream);
      
      for (TupleCategory theTupleCat: myTupleCategories)
         theTupleCat.print (theStream);
d217 2
a218 2
      for (TupleCategory theTupleCat: theScheme.myTupleCategories)
         theTupleCat.freeze ();
d256 2
a257 12
 * @@return An unmodifiable view of a list of all PrimitiveCategories that belong
 *         to this Scheme.
 *******************************************************************************
 */
   List <PrimitiveCategory> getPrimitiveCategories ()
      {
      return Collections.unmodifiableList (myPrimitiveCategories);
      }

/*******************************************************************************
 * @@return An unmodifiable view of a list of all TupleCategories that belong to
 *         this Scheme.
d260 1
a260 1
   List <TupleCategory> getTupleCategories ()
d262 1
a262 1
      return Collections.unmodifiableList (myTupleCategories);
d275 3
a277 4
      myName                = theName;
      myPrimitiveCategories = new ArrayList <PrimitiveCategory> ();
      myTupleCategories     = new ArrayList <TupleCategory>     ();
      myPropertyNames       = new HashSet   <String>            ();
d311 4
a314 3
 * Verifies that theName does not duplicate the name of an existing
 * PrimitiveCategory in the current Scheme.<br>
 * To be called by newPrimitiveCategory.
d317 1
a317 1
   private static void prohibitDupPrimCatName (String theName)
d319 1
a319 1
      for (PrimitiveCategory thePrimCat: current.myPrimitiveCategories)
d321 1
a321 1
         if (thePrimCat.getName ().equals (theName))
d326 4
a329 3
                + "   Call to Scheme.newPrimitiveCategory (String), where\n"
                + "   the String duplicates the name of an existing\n"
                + "   PrimitiveCategory in the current Scheme.\n"
a387 25
 * Verifies that theName does not duplicate the name of an existing
 * TupleCategory in the current Scheme.<br>
 * To be called by newTupleCategory (...).
 *******************************************************************************
 */
   private static void prohibitDupTupleCatName (String theName)
      {
      for (TupleCategory theDupCat: current.myTupleCategories)
         {
         if (theDupCat.getName ().equals (theName))
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   Scheme.newTupleCategory (String, Category <?>...)\n"
                + "   where the name String duplicates the name of an\n"
                + "   existing TupleCategory in the current Scheme.\n"
                + "\n"
                + "      Duplicate Name: \"" + theName + "\"\n");
            }
         }
      }

/*******************************************************************************
d429 1
a429 7
 * A list of all PrimitiveCategories that belong to this Scheme.
 *******************************************************************************
 */
   private final ArrayList <PrimitiveCategory> myPrimitiveCategories;

/*******************************************************************************
 * A list of all TupleCategories that belong to this Scheme.
d432 1
a432 1
   private final ArrayList <TupleCategory> myTupleCategories;
@


1.36
log
@Dimension index.
@
text
@d81 1
a81 1
 * @@param  theDimens                The ItemCategories that are to be the
d86 2
a87 2
 * @@throws IllegalArgumentException If no ItemCategories are given
 * @@throws IllegalArgumentException The ItemCategories do not all belong to the
d95 1
a95 1
         ItemCategory... theDimens)
d102 1
a102 1
      requireAtLeast1ItemCat  (theName,   theDimens);
d119 1
a119 1
 * @@param theItemCat   The ItemCategory to which the Property will belong.
d131 1
a131 1
         ItemCategory theItemCat,
d137 1
a137 1
      prohibitNull        (theItemCat,   "theItemCat");
d144 1
a144 1
      theProp = new Property <V> (theValueType, theItemCat, theName);
d146 1
a146 1
      theItemCat.store (theProp);
d200 1
a200 1
 * When a Scheme is frozen, its state and the state of the ItemCategories and
d346 2
a347 2
 * Verifies that newTupleCategory (...) was called with at least one
 * ItemCategory.<br>
d351 1
a351 1
   private static void requireAtLeast1ItemCat (
d353 1
a353 1
         ItemCategory[] theDimenArr)
d360 2
a361 2
             + "   Call to Scheme.newTupleCategory (String, ItemCategory...)\n"
             + "   with no ItemCategories.\n"
d368 1
a368 1
 * Verifies that the Scheme of each ItemCategory in theDimenArr is the current
d375 1
a375 1
         ItemCategory[] theDimenArr)
d377 1
a377 1
      for (ItemCategory theItemCat: theDimenArr)
d379 1
a379 1
         if (theItemCat.getScheme () != current)
d384 3
a386 3
                + "   Scheme.newTupleCategory (String, ItemCategory...)\n"
                + "   with at least one ItemCategory whose Scheme is not\n" 
                + "   the current Scheme.\n"
d388 5
a392 6
                + "      TupleCategory Name: " + theName + "\n"
                + "      ItemCategory:       " + theItemCat.getName () + "\n"
                + "         Scheme:          " + theItemCat.
                                                    getScheme ().
                                                       getName ()      + "\n"
                + "      Current Scheme:     " + current.getName ()    + "\n");
d412 1
a412 1
                + "   Scheme.newTupleCategory (String, ItemCategory...)\n"
d435 1
a435 1
             + "   Scheme.newProperty (Class <V>, ItemCategory, String),\n"
@


1.35
log
@Minor revision
@
text
@d99 6
a104 6
      prohibitNull                 (theName,   "theName");
      prohibitNullArray            (theDimens, "theDimens");
      requireCurScheme             ();
      requireAtLeast1ItemCat       (theName,   theDimens);
      requireSchemesBeCur          (theName,   theDimens);
      prohibitDupTupleCategoryName (theName);
d214 5
a218 2
      theScheme        = current;
      current          = null;
d403 1
a403 1
   private static void prohibitDupTupleCategoryName (String theName)
@


1.34
log
@prohibitFrozenScheme
@
text
@a252 16
 * Verifies that theScheme is not frozen.<br>
 * To be called by setCurrentScheme.
 *******************************************************************************
 */
   private static void prohibitFrozenScheme (Scheme theScheme)
      {
      if (theScheme.frozen)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to setCurrentScheme (Scheme) with a frozen Scheme.\n"
             + "\n"
             + "      Scheme: " + theScheme.getName () + "\n");
      }

/*******************************************************************************
d303 16
@


1.33
log
@Moved newProperty from ItemCategory to Scheme.
@
text
@a151 38
 * Factory method:<br>
 * Constructs a new Property <V> that will be associated with this ItemCategory.
 * 
 * @@param theValueType The value type of the Property
 * @@param theName      The name       of the Property
 * @@return             The new Property <V>
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the Scheme to which this ItemCategory
 *                                  belongs is frozen
 * @@throws IllegalArgumentException If theName duplicates the name of an 
 *                                  existing Property in the Scheme of this
 *                                  ItemCategory
 *******************************************************************************
 *//*
   public final <V> Property <V> newProperty (
         Class <V> theValueType,
         String    theName)
      {
      prohibitNull (theValueType, "theValueType");
      prohibitNull (theName,      "theName");
      
      myScheme.prohibitFrozen ();
      
      for (ItemCategory theItemCat: myScheme.getPrimitiveCategories ())
         {
         theItemCat.prohibitDupPropName (theName);
         }
      
      for (ItemCategory theItemCat: myScheme.getTupleCategories ())
         {
         theItemCat.prohibitDupPropName (theName);
         }
      
      return new Property <V> (this, theValueType, theName);
      }
*/
/*******************************************************************************
d178 1
a178 1
 * @@throws IllegalStateException If theScheme is frozen
d184 2
a185 2
         theScheme.prohibitFrozen ();
      
d253 2
a254 1
 * Verifies that this Scheme is not frozen.
d257 1
a257 1
   void prohibitFrozen ()
d259 1
a259 1
      if (frozen)
d261 1
a261 1
            new IllegalStateException (
d263 1
a263 2
             + "   Call to a method that changes with state of a Scheme\n"
             + "   when the Scheme was frozen:\n"
d265 1
a265 1
             + "      " + this + "\n");
@


1.32
log
@Moved newTupleCategory from TupleCategory to Scheme.
@
text
@d13 1
d114 76
d339 1
d458 22
d510 6
@


1.31
log
@newPrimitiveCategory with current Scheme.
@
text
@d53 1
a53 1
 * @@throws IllegalStateException If the current Scheme is null
d75 38
a213 35
 * Stores theTupleCat in this Scheme.
 *******************************************************************************
 */
   void store (TupleCategory theTupleCat)
      {
      myTupleCategories.add (theTupleCat);
      }

/*******************************************************************************
 * Verifies that theName does not duplicate the name of an existing
 * TupleCategory in this Scheme.<br>
 * To be called by TupleCategory.newTupleCategory (...).
 *******************************************************************************
 */
   void prohibitDupTupleCategoryName (String theName)
      {
      for (TupleCategory theDupCategory: myTupleCategories)
         {
         if (theDupCategory.getName ().equals (theName))
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   TupleCategory.newTupleCategory (String, ItemCategory...)"
                + "\n"
                + "   where the String duplicates the name of an existing\n"
                + "   TupleCategory in the Scheme of the ItemCategories.\n"
                + "\n"
                + "      Duplicate Name: \"" + theName + "\"\n");
            }
         }
      }

/*******************************************************************************
d303 77
@


1.30
log
@A frozen Scheme cannot be the current Scheme.
@
text
@d47 1
a47 1
 * Constructs a new PrimitiveCategory that will belong to this Scheme.
d53 1
d55 2
a56 2
 *                                  existing PrimitiveCategory in this Scheme
 * @@throws IllegalStateException    If this Scheme is frozen
d59 1
a59 1
   public PrimitiveCategory newPrimitiveCategory (String theName)
d61 9
a69 5
      prohibitNull                (theName, "theName");

      prohibitDupPrimCategoryName (theName);

      prohibitFrozen ();
d71 1
a71 1
      return new PrimitiveCategory (this, theName);
a175 9
 * Stores thePrimCat in this Scheme.
 *******************************************************************************
 */
   void store (PrimitiveCategory thePrimCat)
      {
      myPrimitiveCategories.add (thePrimCat);
      }

/*******************************************************************************
d277 1
a277 1
 * PrimitiveCategory in this Scheme.<br>
d281 1
a281 1
   private void prohibitDupPrimCategoryName (String theName)
d283 1
a283 1
      for (PrimitiveCategory thePrimCategory: myPrimitiveCategories)
d285 1
a285 1
         if (thePrimCategory.getName ().equals (theName))
d292 1
a292 1
                + "   PrimitiveCategory in the Scheme.\n"
@


1.29
log
@Reverting to state as of yesterday 6/8/11 15:00.
@
text
@d95 2
d101 3
d117 5
a121 3
 * Puts this Scheme into a frozen state.<br>
 * When a Scheme is frozen, its state and the state of the ItemCategories that
 * belong to it cannot be changed.
d123 1
a123 1
 * @@throws IllegalStateException If this Scheme is frozen
d126 1
a126 1
   public void freeze ()
d128 6
a133 1
      prohibitFrozen ();
d135 1
a135 1
      frozen = true;
d266 14
@


1.28
log
@Setting current Implementation requires matching current Scheme.
@
text
@a7 1
import static com.ibm.witm.Scheme.getCurrentScheme;
a94 2
 * 
 * @@throws IllegalStateException If a current Implementation exists
a98 2
      prohibitCurImp (theScheme);
      
a202 14
 * Verifies that the current Scheme is not null.
 *******************************************************************************
 */
   static void requireCurScheme ()
      {
      if (current == null)
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to a method that requires a current Scheme when the\n"
             + "   current Scheme is null.\n");
      }

/*******************************************************************************
a253 25
 * Verifies that there is no current Implementation.<br>
 * To be called by setCurrentScheme (...).
 *******************************************************************************
 */
   private static void prohibitCurImp (Scheme theScheme)
      {
      Implementation curImpl;
      
      curImpl = Implementation.getCurrentImplementation ();
      
      if (curImpl != null)
         {
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to Scheme.setCurrentScheme (Scheme) while a current\n"
             + "   Implementation exists.\n"
             + "\n"
             + "      Scheme:                 "   + theScheme          +   "\n"
             + "      Current Implementation: \"" + curImpl.getName () + "\"\n"
               );
         }
      }

/*******************************************************************************
d264 1
d273 1
@


1.27
log
@Testing for current Scheme.
@
text
@a237 16
 * Sets the current Scheme to match the current Implementation.
 *******************************************************************************
 */
   static void matchCurSchemeToCurImpl ()
      {
      Implementation curImpl;
      
      curImpl = Implementation.getCurrentImplementation ();
      
      if (curImpl != null)
         current = curImpl.getScheme ();
      else
         current = null;
      }

/*******************************************************************************
@


1.26
log
@Matching current Scheme to current Implementation.
@
text
@d8 1
d208 14
@


1.25
log
@Current Scheme.
@
text
@d95 2
d101 2
d223 16
d274 25
a308 1
            {
a316 1
            }
@


1.24
log
@Renaming
@
text
@d28 2
a29 1
 * Constructs a new Scheme.
d40 3
a42 1
      return new Scheme (theName);
d92 20
d278 7
@


1.23
log
@Revised some messsages.
@
text
@d136 1
a136 1
 * Stores thePrimCategory in this Scheme.
d139 1
a139 1
   void store (PrimitiveCategory thePrimCategory)
d141 1
a141 1
      myPrimitiveCategories.add (thePrimCategory);
@


1.22
log
@Type ==> Category
@
text
@d169 1
a169 1
                + "   TupleCategory.newTupleCategory (theName, theElCategories)"
d171 2
a172 2
                + "   where theName duplicates the name of an existing\n"
                + "   TupleCategory in the Scheme.\n"
d245 3
a247 3
                + "   Call to theScheme.newPrimitiveCategory (theName), where\n"
                + "   theName duplicates the name of an existing\n"
                + "   PrimitiveCategory in theScheme.\n"
@


1.21
log
@Element     ==> Item
ElementType ==> ItemTYpe
@
text
@d44 1
a44 1
 * Constructs a new PrimitiveType that will belong to this Scheme.
d46 1
a46 1
 * @@param theName                   The name of the PrimitiveType to be
d48 1
a48 1
 * @@return                          The new PrimitiveType
d51 1
a51 1
 *                                  existing PrimitiveType in this Scheme
d55 1
a55 1
   public PrimitiveType newPrimitiveType (String theName)
d57 1
a57 1
      prohibitNull            (theName, "theName");
d59 1
a59 1
      prohibitDupPrimTypeName (theName);
d63 1
a63 1
      return new PrimitiveType (this, theName);
d81 2
a82 2
      for (PrimitiveType thePrimType: myPrimitiveTypes)
         thePrimType.print (theStream);
d84 2
a85 2
      for (TupleType theTupleType: myTupleTypes)
         theTupleType.print (theStream);
d90 2
a91 2
 * When a Scheme is frozen, its state and the state of the ItemTypes
 * that belong to it cannot be changed.
d136 1
a136 1
 * Stores thePrimType in this Scheme.
d139 1
a139 1
   void store (PrimitiveType thePrimType)
d141 1
a141 1
      myPrimitiveTypes.add (thePrimType);
d145 1
a145 1
 * Stores theTupleType in this Scheme.
d148 1
a148 1
   void store (TupleType theTupleType)
d150 1
a150 1
      myTupleTypes.add (theTupleType);
d155 2
a156 2
 * TupleType in this Scheme.<br>
 * To be called by TupleType.newTupleType (...).
d159 1
a159 1
   void prohibitDupTupleTypeName (String theName)
d161 1
a161 1
      for (TupleType theDupType: myTupleTypes)
d163 1
a163 1
         if (theDupType.getName ().equals (theName))
d169 1
a169 1
                + "   TupleType.newTupleType (theName, theElTypes)"
d172 1
a172 1
                + "   TupleType in the Scheme.\n"
d196 1
a196 1
 * @@return An unmodifiable view of a list of all PrimitiveTypes that belong
d200 1
a200 1
   List <PrimitiveType> getPrimitiveTypes ()
d202 1
a202 1
      return Collections.unmodifiableList (myPrimitiveTypes);
d206 2
a207 2
 * @@return An unmodifiable view of a list of all TupleTypes that belong to this
 *         Scheme.
d210 1
a210 1
   List <TupleType> getTupleTypes ()
d212 1
a212 1
      return Collections.unmodifiableList (myTupleTypes);
d225 3
a227 3
      myName            = theName;
      myPrimitiveTypes = new ArrayList <PrimitiveType> ();
      myTupleTypes     = new ArrayList <TupleType>     ();
d232 2
a233 2
 * PrimitiveType in this Scheme.<br>
 * To be called by newPrimitiveType.
d236 1
a236 1
   private void prohibitDupPrimTypeName (String theName)
d238 1
a238 1
      for (PrimitiveType thePrimType: myPrimitiveTypes)
d240 1
a240 1
         if (thePrimType.getName ().equals (theName))
d245 1
a245 1
                + "   Call to theScheme.newPrimitiveType (theName), where\n"
d247 1
a247 1
                + "   PrimitiveType in theScheme.\n"
d267 1
a267 1
 * A list of all PrimitiveTypes that belong to this Scheme.
d270 1
a270 1
   private final ArrayList <PrimitiveType> myPrimitiveTypes;
d273 1
a273 1
 * A list of all TupleTypes that belong to this Scheme.
d276 1
a276 1
   private final ArrayList <TupleType> myTupleTypes;
@


1.20
log
@Moved some factory methods.
@
text
@d90 1
a90 1
 * When a Scheme is frozen, its state and the state of the ElementTypes
@


1.19
log
@Embodiment ==> Implementation
@
text
@a102 19
/*******************************************************************************
 * Factory method: Constructs a new Implementation for this Scheme.<br>
 * The new Implementation becomes the current Implementation for the Thread.
 *
 * @@param  theName               The name of the new Implementation
 * @@return                       The new Implementation
 * @@throws NullPointerException  If theName is null
 * @@throws IllegalStateException If this Scheme is not frozen
 *******************************************************************************
 */
   public Implementation newImplementation (String theName)
      {
      prohibitNull  (theName, "theName");
      
      requireFrozen (theName);
      
      return new Implementation (this, theName);
      }
   
a254 18
 * Verifies that this Scheme is frozen.<br>
 * To be called by newImplementation (theName).
 *******************************************************************************
 */
   private void requireFrozen (String theName)
      {
      if (! frozen)
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to theScheme.newImplementation (theName), when\n"
             + "   theScheme was not frozen:\n"
             + "\n"
             + "      theScheme: " + this    + "\n"
             + "      theName:   " + theName + "\n");
      }

/*******************************************************************************
@


1.18
log
@currentEmbodiment
@
text
@d104 2
a105 2
 * Factory method: Constructs a new Embodiment for this Scheme.<br>
 * The new Embodiment becomes the current Embodiment for the Thread.
d107 2
a108 2
 * @@param  theName               The name of the new Embodiment
 * @@return                       The new Embodiment
d113 1
a113 1
   public Embodiment newEmbodiment (String theName)
d119 1
a119 1
      return new Embodiment (this, theName);
d275 1
a275 1
 * To be called by newEmbodiment (theName).
d284 2
a285 2
             + "   Call to theScheme.newEmbodiment (theName), when theScheme\n"
             + "   was not frozen:\n"
@


1.17
log
@newTuple
@
text
@d104 2
a105 1
 * Factory method: Constructs a new Embodiment for this Scheme.
@


1.16
log
@Storing of objects.
@
text
@d122 2
a123 2
 * The doc comment is inherited
 *******************************************************************************
@


1.15
log
@Category ==> Type
@
text
@d57 1
a57 3
      PrimitiveType thePrimType;
      
      prohibitNull           (theName, "theName");
d63 1
a63 5
      thePrimType = new PrimitiveType (this, theName);
      
      myPrimitiveTypes.add (thePrimType);
      
      return thePrimType;
d154 18
a197 21
 * Factory method:<br>
 * Constructs a new TupleType for this Scheme.<br>
 * To be called by TupleType.newTupleType (...).
 * @@param  theName    The name of the TupleType to be constructed
 * @@param  theElTypes The ElementTypes that are to be the coordinates of the
 *                    TupleType    
 * @@return            The new TupleType
 *******************************************************************************
 */
   TupleType newTupleType (String theName, ElementType[] theElTypeArr)
      {
      TupleType theTupleType;
      
      theTupleType = new TupleType (this, theName, theElTypeArr);
      
      myTupleTypes.add (theTupleType);
      
      return theTupleType;
      }

/*******************************************************************************
@


1.14
log
@Fulfillment ==> Embodiment
@
text
@d44 1
a44 1
 * Constructs a new PrimitiveCategory that will belong to this Scheme.
d46 1
a46 1
 * @@param theName                   The name of the PrimitiveCategory to be
d48 1
a48 1
 * @@return                          The new PrimitiveCategory
d51 1
a51 1
 *                                  existing PrimitiveCategory in this Scheme
d55 1
a55 1
   public PrimitiveCategory newPrimitiveCategory (String theName)
d57 1
a57 1
      PrimitiveCategory thePrimCat;
d61 1
a61 1
      prohibitDupPrimCatName (theName);
d65 1
a65 1
      thePrimCat = new PrimitiveCategory (this, theName);
d67 1
a67 1
      myPrimitiveCategories.add (thePrimCat);
d69 1
a69 1
      return thePrimCat;
d87 2
a88 2
      for (PrimitiveCategory thePrimCat: myPrimitiveCategories)
         thePrimCat.print (theStream);
d90 2
a91 2
      for (TupleCategory theTupleCat: myTupleCategories)
         theTupleCat.print (theStream);
d96 1
a96 1
 * When a Scheme is frozen, its state and the state of the ElementCategories
d161 2
a162 2
 * TupleCategory in this Scheme.<br>
 * To be called by TupleCategory.newTupleCategory (...).
d165 1
a165 1
   void prohibitDupTupleCatName (String theName)
d167 1
a167 1
      for (TupleCategory theDupCat: myTupleCategories)
d169 1
a169 1
         if (theDupCat.getName ().equals (theName))
d175 1
a175 1
                + "   TupleCategory.newTupleCategory (theName, theElCats)"
d178 1
a178 1
                + "   TupleCategory in the Scheme.\n"
d187 6
a192 6
 * Constructs a new TupleCategory for this Scheme.<br>
 * To be called by TupleCategory.newTupleCategory (...).
 * @@param  theName   The name of the TupleCategory to be constructed
 * @@param  theElCats The ElementCategories that are to be the coordinates of the
 *                   TupleCategory    
 * @@return           The new TupleCategory
d195 1
a195 3
   TupleCategory newTupleCategory (
         String            theName,
         ElementCategory[] theElCatArr)
d197 1
a197 1
      TupleCategory theTupleCat;
d199 1
a199 1
      theTupleCat = new TupleCategory (this, theName, theElCatArr);
d201 1
a201 1
      myTupleCategories.add (theTupleCat);
d203 1
a203 1
      return theTupleCat;
d223 1
a223 1
 * @@return An unmodifiable view of a list of all PrimitiveCategories that belong
d227 1
a227 1
   List <PrimitiveCategory> getPrimitiveCategories ()
d229 1
a229 1
      return Collections.unmodifiableList (myPrimitiveCategories);
d233 2
a234 2
 * @@return An unmodifiable view of a list of all TupleCategories that belong
 *         to this Scheme.
d237 1
a237 1
   List <TupleCategory> getTupleCategories ()
d239 1
a239 1
      return Collections.unmodifiableList (myTupleCategories);
d252 3
a254 3
      myName                = theName;
      myPrimitiveCategories = new ArrayList <PrimitiveCategory> ();
      myTupleCategories     = new ArrayList <TupleCategory>     ();
d259 2
a260 2
 * PrimitiveCategory in this Scheme.<br>
 * To be called by newPrimitiveCategory.
d263 1
a263 1
   private void prohibitDupPrimCatName (String theName)
d265 1
a265 1
      for (PrimitiveCategory thePrimCat: myPrimitiveCategories)
d267 1
a267 1
         if (thePrimCat.getName ().equals (theName))
d272 1
a272 1
                + "   Call to theScheme.newPrimitiveCategory (theName), where\n"
d274 1
a274 1
                + "   PrimitiveCategory in theScheme.\n"
d312 1
a312 1
 * A list of all PrimitiveCategories that belong to this Scheme.
d315 1
a315 1
   private final ArrayList <PrimitiveCategory> myPrimitiveCategories;
d318 1
a318 1
 * A list of all TupleCategories that belong to this Scheme.
d321 1
a321 1
   private final ArrayList <TupleCategory> myTupleCategories;
@


1.13
log
@Compound ==> Tuple
@
text
@d110 1
a110 1
 * Factory method: Constructs a new Fulfillment for this Scheme.
d112 2
a113 2
 * @@param  theName               The name of the new Fulfillment
 * @@return                       The new Fulfillment
d118 1
a118 1
   public Fulfillment newFulfillment (String theName)
d124 1
a124 1
      return new Fulfillment (this, theName);
d285 1
a285 1
 * To be called by newFulfillment (theName).
d294 1
a294 1
             + "   Call to theScheme.newFulfillment (theName), when theScheme\n"
@


1.12
log
@Created class CompoundMgr.
@
text
@d90 2
a91 2
      for (CompoundCategory theCompCat: myCompoundCategories)
         theCompCat.print (theStream);
d161 2
a162 2
 * CompoundCategory in this Scheme.<br>
 * To be called by CompoundCategory.newCompoundCategory (...).
d165 1
a165 1
   void prohibitDupCompCatName (String theName)
d167 1
a167 1
      for (CompoundCategory theDupCat: myCompoundCategories)
d175 1
a175 1
                + "   CompoundCategory.newCompoundCategory (theName, theElCats)"
d178 1
a178 1
                + "   CompoundCategory in the Scheme.\n"
d187 3
a189 3
 * Constructs a new CompoundCategory for this Scheme.<br>
 * To be called by CompoundCategory.newCompoundCategory (...).
 * @@param  theName   The name of the CompoundCategory to be constructed
d191 2
a192 2
 *                   CompoundCategory    
 * @@return           The new CompoundCategory
d195 1
a195 1
   CompoundCategory newCompoundCategory (
d199 1
a199 1
      CompoundCategory theCompCat;
d201 1
a201 1
      theCompCat = new CompoundCategory (this, theName, theElCatArr);
d203 1
a203 1
      myCompoundCategories.add (theCompCat);
d205 1
a205 1
      return theCompCat;
d235 1
a235 1
 * @@return An unmodifiable view of a list of all CompoundCategories that belong
d239 1
a239 1
   List <CompoundCategory> getCompoundCategories ()
d241 1
a241 1
      return Collections.unmodifiableList (myCompoundCategories);
d256 1
a256 1
      myCompoundCategories  = new ArrayList <CompoundCategory>  ();
d320 1
a320 1
 * A list of all CompoundCategories that belong to this Scheme.
d323 1
a323 1
   private final ArrayList <CompoundCategory> myCompoundCategories;
@


1.11
log
@CompoundCategory
@
text
@d234 10
@


1.10
log
@Exception messages.
@
text
@d89 3
@


1.9
log
@Check for duplicate ComponentCategory name.
@
text
@d171 1
d174 2
a175 2
                + "   was called where theName duplicates the name of an\n"
                + "   existing CompoundCategory in the Scheme.\n"
d215 1
a215 1
             + "   A method was called that changes with state of a Scheme\n"
d261 2
a262 2
                + "   theScheme.newPrimitiveCategory (theName) was called\n"
                + "   where theName duplicates the name of an existing\n"
d281 2
a282 2
             + "   theScheme.newFulfillment (theName) was called\n"
             + "   when theScheme was not frozen:\n"
@


1.8
log
@AppProblem ==> Fulfillment
@
text
@d124 2
a125 1
/*******************************************************************************
d157 48
d242 1
d305 6
@


1.7
log
@@@Override annotations
@
text
@d17 1
a17 2
 * of a WIT application problem, i.e., the data-independent aspects of the
 * problem.
d107 1
a107 1
 * Factory method: Constructs a new AppProblem for this Scheme.
d109 2
a110 2
 * @@param  theName               The name of the new AppProblem
 * @@return                       The new AppProblem
d115 1
a115 1
   public AppProblem newAppProblem (String theName)
d121 1
a121 1
      return new AppProblem (this, theName);
d221 1
a221 1
 * To be called by newAppProblem (theName).
d230 1
a230 1
             + "   theScheme.newAppProblem (theName) was called\n"
@


1.6
log
@Created CompoundCategory
@
text
@a125 2
 * @@return Format:<br>
 *         Scheme "{getName ()}"
d128 1
a128 1
   public String toString ()
@


1.5
log
@Scheme printing
@
text
@d33 1
a33 1
 * @@throws NullPointerException If theName == null
d112 1
a112 1
 * @@throws NullPointerException  If theName == null
d213 1
a213 1
                + "   theScheme.newPrimitiveCategory (theName) was invoked\n"
@


1.4
log
@Class Property
@
text
@d81 9
a89 7
      theStream.
         printf (
            "Detailed Print of Scheme \"%s\":%n"
          + "%n"
          + "Frozen Scheme? %s%n",
            myName,
            frozen);
@


1.3
log
@Unique Property names.
@
text
@d10 1
d28 1
a28 1
 * Factory method: <br>
d44 1
a44 16
 * Puts this Scheme into a frozen state. <br>
 * When a Scheme is frozen, its state and the state of the ElementCategories
 * that belong to it cannot be changed.
 * 
 * @@throws IllegalStateException If this Scheme is frozen
 *******************************************************************************
 */
   public void freeze ()
      {
      prohibitFrozen ();
      
      frozen = true;
      }

/*******************************************************************************
 * Factory method: <br>
d74 32
d124 1
a124 1
 * @@return Format: <br>
d143 1
a143 1
 * @@return True, iff this Scheme is "frozen". <br>
a156 49
 * Verifies that theName does not duplicate the name of an existing Property in
 * this Scheme.<br>
 * To be called by theElCat.newProperty.
 *******************************************************************************
 */
   void prohibitDupPropName (String theName)
      {
      for (Property <?> theProp: myProperties)
         {
         if (theProp.getName ().equals (theName))
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   theElCat.newProperty (theValueType, theName) was\n"
                + "   invoked where theName duplicates the name of an\n"
                + "   existing Property in the Scheme.\n"
                + "\n"
                + "      Duplicate Name: \"" + theName + "\"\n");
            }
         }
      }

/*******************************************************************************
 * Factory method: <br>
 * Constructs a new Property {@@literal<V>}. <br>
 * To be called by theElCat.newProperty (...).
 * 
 * @@param theElCat     The ElementCategory of the Property
 * @@param theValueType The value type      of the Property
 * @@param theName      The name            of the Property
 * @@return             The new Property
 *******************************************************************************
 */
   final <V> Property <V> newProperty (
         ElementCategory theElCat,
         Class <V>       theValueType,
         String          theName)
      {
      Property <V> theProp;
      
      theProp = new Property <V> (theElCat, theValueType, theName);
      
      myProperties.add (theProp);
      
      return theProp;
      }

/*******************************************************************************
a193 1
      myProperties          = new ArrayList <Property <?>>      ();
d198 1
a198 1
 * PrimitiveCategory in this Scheme. <br>
d221 1
a221 1
 * Verifies that this Scheme is frozen. <br>
d245 1
a245 1
 * A list of all PrimitiveCategories that belong to this Scheme.
d248 1
a248 1
   private final ArrayList <PrimitiveCategory> myPrimitiveCategories;
d251 1
a251 1
 * A list of all Properties that belong to ElementCategories in this Scheme.
d254 1
a254 7
   private final ArrayList <Property <?>> myProperties;

/*******************************************************************************
 * True, iff this Scheme is "frozen".
 *******************************************************************************
 */
   private boolean frozen = false;
@


1.2
log
@Created generic class Property.
@
text
@d43 1
a43 1
 * Puts this Scheme into a frozen state. </br>
d66 1
a66 1
 *                                  existing ElementCategory in this Scheme
d74 1
a74 1
      prohibitNull         (theName, "theName");
d76 1
a76 1
      prohibitDupElCatName (theName);
a81 1
      myElementCategories  .add (thePrimCat);
d125 1
a125 1
 * @@return True, iff this Scheme is "frozen". </br>
d139 49
a223 1
      myElementCategories   = new ArrayList <ElementCategory>   ();
d225 1
d230 1
a230 1
 * ElementCategory in this Scheme.
d234 1
a234 1
   private void prohibitDupElCatName (String theName)
d236 1
a236 1
      for (ElementCategory theElCat: myElementCategories)
d238 1
a238 1
         if (theElCat.getName ().equals (theName))
d245 1
a245 1
                + "   ElementCategory in theScheme.\n"
d253 1
a253 1
 * Verifies that this Scheme is frozen. </br>
d277 1
a277 1
 * A list of all ElementCategories that belong to this Scheme.
d280 1
a280 1
   private final ArrayList <ElementCategory> myElementCategories;
d283 1
a283 1
 * A list of all PrimitiveCategories that belong to this Scheme.
d286 1
a286 1
   private final ArrayList <PrimitiveCategory> myPrimitiveCategories;
@


1.1
log
@Initial revision
@
text
@d44 2
a45 1
 * When a Scheme is frozen, its state cannot be changed.
d140 16
a204 16
 * Verifies that this Scheme is not frozen.
 *******************************************************************************
 */
   private void prohibitFrozen ()
      {
      if (frozen)
         throw
            new IllegalStateException (
               "\n\n"
             + "   A method was called that changes with state of a Scheme\n"
             + "   when the Scheme was frozen:\n"
             + "\n"
             + "      " + this + "\n");
      }

/*******************************************************************************
@


1.1.1.1
log
@Renaming WIT-ML to WIT-M.

@
text
@@

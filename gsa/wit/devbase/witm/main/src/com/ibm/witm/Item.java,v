head	1.51;
access;
symbols;
locks; strict;
comment	@# @;


1.51
date	2011.10.07.23.01.54;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.05.23.07.33;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.04.22.57.13;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2011.09.14.21.38.21;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.14.20.58.56;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.14.19.02.09;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.14.15.31.33;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.09.21.17.38;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.08.22.43.38;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.07.23.15.39;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.07.22.26.21;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.07.21.43.37;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.21.18.05.48;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.21.16.27.41;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.20.23.49.44;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.20.23.04.23;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.20.22.13.43;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.20.20.18.26;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.20.18.38.43;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.20.16.35.23;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.19.21.37.03;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.19.21.13.11;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.19.19.21.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.15.23.19.00;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.15.21.46.54;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.15.17.42.30;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.14.23.40.33;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.08.23.31.55;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.08.20.45.58;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.06.22.29.19;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.05.21.15.04;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.01.15.56.22;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.30.23.43.48;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.30.23.25.40;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.30.22.03.39;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.29.14.22.26;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.23.22.52.04;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.22.15.07.26;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.20.15.13.19;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.17.18.23.02;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.16.23.49.52;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.16.16.26.26;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.15.22.25.19;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.09.18.19.22;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.09.18.09.21;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.08.20.54.58;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.08.20.13.56;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.07.22.05.16;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.07.19.47.02;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.06.20.33.29;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.06.16.39.06;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.51
log
@TemporalVariable ==> VariableByPeriod, etc.
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M Source File Item.java.
////////////////////////////////////////////////////////////////////////////////

package com.ibm.witm;

import static com.ibm.witm.Utility.*;
import static com.ibm.witm.WitJHandler.*;

import com.ibm.witj.*;

/*******************************************************************************
 * An Item represents a data object in a WIT application problem. Each
 * Item belongs to a particular ModelInstance and a particular ItemCategory.
 * The Items that belong to a given ModelInstance are the building blocks
 * that make up the ModelInstance.
 *******************************************************************************
 */
public abstract class Item
{
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The ItemCategory to which this Item belongs.
 *******************************************************************************
 */
   private final ItemCategory <?> myItemCategory;
   
/*******************************************************************************
 * The ModelInstance that owns this Item.
 *******************************************************************************
 */
   private final ModelInstance myModelInstance;
   
/*******************************************************************************
 * myPropValueArr[theProp.getIndex ()] is the value of theProp associated with
 * this Item.
 *******************************************************************************
 */
   private final Object[] myPropValueArr;
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that the ItemCategory of theProp matches the ItemCategory of this
 * Item.
 *******************************************************************************
 */
   private final void reqCatsMatch (Property <?> theProp, String signature)
      {
      if (theProp.getItemCategory () != myItemCategory)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Item." + signature + ", where the ItemCategory of\n"
             + "   the Property does not match the ItemCategory of the Item.\n"
             + "\n"
             + "      Property:        " + theProp                    + "\n"
             + "         ItemCategory: " + theProp.getItemCategory () + "\n"
             + "      Item:            " + this                       + "\n"
             + "         ItemCategory: " + myItemCategory             + "\n");
         }
      }
   
/*******************************************************************************
 * Verifies that the value type of theProp is not a subclass of
 * VariableByPeriod.
 *******************************************************************************
 */
   private final void rejVarByPeriod (Property <?> theProp)
      {
      if (VariableByPeriod.class.isAssignableFrom (theProp.getValueType ()))
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Item.set (theProb, theValue), with a Property\n"
             + "   whose value type is a subclass of VariableByPeriod <V>.\n"
             + "\n"
             + "      Property:   " + theProp          + "\n"
             + "      Value Type: " + theProp.
                                      getValueType ().
                                      getSimpleName () + "\n");
         }
      }
   
/*******************************************************************************
 * Verifies that thePart belongs to the current Problem.
 *******************************************************************************
 */
   private final void reqProbIsCur (Part thePart)
      {
      if (thePart.getProblem () != getCurrentProblem ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Item.newDemand (theProp, thePart), where thePart\n"
             + "   does not belong to the current Problem.\n"
             + "\n"
             + "      thePart: " + thePart + "\n");
      }
   
////////////////////////////////////////////////////////////////////////////////
// Package-Internal Constructor
////////////////////////////////////////////////////////////////////////////////
   
   Item (ItemCategory <?> theItemCat, ModelInstance theInst)
      {
      assert (theInst.getModelScheme () == theItemCat.getModelScheme ());
      
      myItemCategory  = theItemCat;
      
      myModelInstance = theInst;
      
      myPropValueArr  = new Object[theItemCat.getProperties ().size ()];
      
      if (theInst.getPeriodMgr ().isFrozen ())
         buildVariableByPeriods ();
      }

////////////////////////////////////////////////////////////////////////////////
// Package-Internal Non-Static Methods
////////////////////////////////////////////////////////////////////////////////
   
/*******************************************************************************
 * Returns a String that identifies this Item among Items of its ItemCategory.
 * Note that the String returned might not be unique.
 *******************************************************************************
 */
   abstract String getID ();

/*******************************************************************************
 * Sets the value of a Property for this Item to theValue.
 * (Internal Version)
 *******************************************************************************
 */
   final <V> void setValue (Property <V> theProp, V theValue)
      {
      myPropValueArr[theProp.getIndex ()] = theValue;
      }

/*******************************************************************************
 * Retrieves the value of a Property for this Item.
 * (Internal Version)
 *******************************************************************************
 */           @@SuppressWarnings("unchecked")
   final <V> V getValue (Property <V> theProp)
      {
      return (V) myPropValueArr[theProp.getIndex ()];
      }

/*******************************************************************************
 * Creates and stores the instances of VariableByPeriod subclasses that are to
 * be Property values for this Item.
 *******************************************************************************
 */
   void buildVariableByPeriods ()
      {
      PeriodMgr            thePeriodMgr;
      VariableByPeriod <?> theVarByPer;
      
      thePeriodMgr = myModelInstance.getPeriodMgr ();
      
      for (Property <?> theProp: myItemCategory.getProperties ())
         {
         if (! VariableByPeriod.class.isAssignableFrom (theProp.getValueType ()))
            continue;
         
         if      (theProp.getValueType () == DoubleByPeriod.class)
            theVarByPer = new DoubleByPeriod (thePeriodMgr);
         
         else if (theProp.getValueType () == IntegerByPeriod.class)
            theVarByPer = new IntegerByPeriod (thePeriodMgr);
         
         else if (theProp.getValueType () == BooleanByPeriod.class)
            theVarByPer = new BooleanByPeriod (thePeriodMgr);
         
         else
            throw new AssertionError ();
            
         myPropValueArr[theProp.getIndex ()] = theVarByPer;
         }
      }
   
////////////////////////////////////////////////////////////////////////////////
// Public Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * @@return The ItemCategory to which this Item belongs
 *******************************************************************************
 */
   public final ItemCategory <?> getItemCategory ()
      {
      return myItemCategory;
      }

/*******************************************************************************
 * @@return The ModelScheme for this Item.
 *******************************************************************************
 */
   public final ModelScheme getModelScheme ()
      {
      return myModelInstance.getModelScheme ();
      }

/*******************************************************************************
 * @@return The ModelInstance that owns this Item
 *******************************************************************************
 */
   public final ModelInstance getModelInstance ()
      {
      return myModelInstance;
      }

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */                   @@Override
   public final String toString ()
      {
      return concatenation (myItemCategory.getName (), " ", getID ());
      }
   
/*******************************************************************************
 * Sets the value of a Property for this Item to a specified value.
 * Specifically, a reference to the specified object is stored, rather than a
 * copy of it.
 * 
 * @@param <V>      The value type of the Property
 * @@param theProp  The Property whose value is to be set
 * @@param theValue The V instance to which the Property value is to be set.
 *
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 * @@throws IllegalArgumentException If the value type of theProp is a subclass
 *                                  of VariableByPeriod <V>.
 *******************************************************************************
 */
   public final <V> void set (Property <V> theProp, V theValue)
      {
      rejNull        (theProp, "theProp");
      reqCatsMatch   (theProp, "set (theProp, theValue)");
      rejVarByPeriod (theProp);
      
      setValue       (theProp, theValue);
      }

/*******************************************************************************
 * Retrieves the value of a Property for this Item.
 * 
 * @@param <V>     The value type of the Property
 * @@param theProp The Property whose value is to be retrieved
 * @@return        A reference to the current value of the Property for this
 *                Item
 * 
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 *******************************************************************************
 */
   public final <V> V get (Property <V> theProp)
      {
      rejNull      (theProp, "theProp");
      reqCatsMatch (theProp, "get (theProp)");
      
      return getValue (theProp);
      }

/*******************************************************************************
 * Creates a new Part in the current Problem and stores a reference to it as the
 * value of a Property of this Item.
 * 
 * @@param theProp    The Property in which the reference to the Part is to be
 *                   stored.
 * @@param thePartCat The Part ItemCategory of the new Part.
 * @@return           The new Part
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 * @@throws IllegalStateException    If the current WitJHandler is null
 *******************************************************************************
 */
   public final Part newPart (Property <Part> theProp, Part.Category thePartCat)
      {
      rejNull       (theProp,    "theProp");
      rejNull       (thePartCat, "thePartCat");
      reqCatsMatch  (theProp,    "newPart (theProp, thePartCat)");
      reqCurProbMgr ();
      
      return getCurrentWitJHandler ().newPart (this, theProp, thePartCat);
      }

/*******************************************************************************
 * Creates a new Operation in the current Problem and stores a reference to it
 * as the value of a Property of this Item.
 * 
 * @@param theProp The Property in which the reference to the Operation is to be
 *                stored.
 * @@return        The new Operation
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 * @@throws IllegalStateException    If the current WitJHandler is null
 *******************************************************************************
 */
   public final Operation newOperation (Property <Operation> theProp)
      {
      rejNull       (theProp, "theProp");
      reqCatsMatch  (theProp, "newOperation (theProp)");
      reqCurProbMgr ();
      
      return getCurrentWitJHandler ().newOperation (this, theProp);
      }

/*******************************************************************************
 * Creates a new Demand in the current Problem and stores a reference to it as
 * the value of a Property of this Item.
 * 
 * @@param theProp The Property in which the reference to the Demand is to be
 *                stored.
 * @@param thePart The Part with which the Demand is to be associated
 * @@return        The new Demand
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 * @@throws IllegalStateException    If the current WitJHandler is null
 * @@throws IllegalArgumentException If thePart does not belong to the current
 *                                  Problem
 *******************************************************************************
 */
   public final Demand newDemand (Property <Demand> theProp, Part thePart)
      {
      rejNull       (theProp, "theProp");
      rejNull       (thePart, "thePart");
      reqCatsMatch  (theProp, "newDemand (theProp, thePart)");
      reqCurProbMgr ();
      reqProbIsCur  (thePart);
      
      return getCurrentWitJHandler ().newDemand (this, theProp, thePart);
      }

/*******************************************************************************
 * Creates a new BomEntry in the current Problem and stores a reference to it as
 * the value of a Property of this Item.
 * 
 * @@param theProp The Property in which the reference to the BomEntry is to be
 *                stored.
 * @@param theOpn  The Operation with which the BomEntry is to be associated
 * @@param thePart The Part with which the BomEntry is to be associated
 * @@return        The new BomEntry
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 *******************************************************************************
 */
   public final BomEntry newBomEntry (
         Property <BomEntry> theProp,
         Operation           theOpn,
         Part                thePart)
      {
      BomEntry theBomEnt;
      
      rejNull      (theProp, "theProp");
      rejNull      (theOpn,  "theOpn");
      rejNull      (thePart, "thePart");
      reqCatsMatch (theProp, "newBomEntry (theProp, theOpn, thePart)");
      
      theBomEnt = BomEntry.newInstance (theOpn, thePart);
      
      set (theProp, theBomEnt);
      
      return theBomEnt;
      }

/*******************************************************************************
 * Creates a new BopEntry in the current Problem and stores a reference to it as
 * the value of a Property of this Item.
 * 
 * @@param theProp The Property in which the reference to the BopEntry is to be
 *                stored.
 * @@param theOpn  The Operation with which the BopEntry is to be associated
 * @@param thePart The Part with which the BopEntry is to be associated
 * @@return        The new BopEntry
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 *******************************************************************************
 */
   public final BopEntry newBopEntry (
         Property <BopEntry> theProp,
         Operation           theOpn,
         Part                thePart)
      {
      BopEntry theBopEnt;
      
      rejNull      (theProp, "theProp");
      rejNull      (theOpn,  "theOpn");
      rejNull      (thePart, "thePart");
      reqCatsMatch (theProp, "newBopEntry (theProp, theOpn, thePart)");
      
      theBopEnt = BopEntry.newInstance (theOpn, thePart);
      
      set (theProp, theBopEnt);
      
      return theBopEnt;
      }

/*******************************************************************************
 * Creates a new Substitute in the current Problem and stores a reference to it as
 * the value of a Property of this Item.
 * 
 * @@param theProp   The Property in which the reference to the Substitute is to
 *                  be stored.
 * @@param theBomEnt The BomEntry with which the Substitute is to be associated
 * @@param thePart   The Part with which the Substitute is to be associated
 * @@return          The new Substitute
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
 *******************************************************************************
 */
   public final Substitute newSubstitute (
         Property <Substitute> theProp,
         BomEntry              theBomEnt,
         Part                  thePart)
      {
      Substitute theSub;
      
      rejNull      (theProp,    "theProp");
      rejNull      (theBomEnt,  "theBomEnt");
      rejNull      (thePart,    "thePart");
      reqCatsMatch (theProp,    "newSubstitute (theProp, theBomEnt, thePart)");
      
      theSub = Substitute.newInstance (theBomEnt, thePart);
      
      set (theProp, theSub);
      
      return theSub;
      }

////////////////////////////////////////////////////////////////////////////////
}
@


1.50
log
@ban ==> rej
@
text
@d73 1
a73 1
 * TemporalVariable.
d76 1
a76 1
   private final void rejTemporalVar (Property <?> theProp)
d78 1
a78 1
      if (TemporalVariable.class.isAssignableFrom (theProp.getValueType ()))
d84 1
a84 1
             + "   whose value type is a subclass of TemporalVariable <V>.\n"
d124 1
a124 1
         buildTemporalVariables ();
d159 1
a159 1
 * Creates and stores the instances of TemporalVariable subclasses that are to
d163 1
a163 1
   void buildTemporalVariables ()
d166 1
a166 1
      TemporalVariable <?> theTempVar;
d172 1
a172 1
         if (! TemporalVariable.class.isAssignableFrom (theProp.getValueType ()))
d175 2
a176 2
         if      (theProp.getValueType () == TemporalDouble.class)
            theTempVar = new TemporalDouble (thePeriodMgr);
d178 2
a179 2
         else if (theProp.getValueType () == TemporalInteger.class)
            theTempVar = new TemporalInteger (thePeriodMgr);
d181 2
a182 2
         else if (theProp.getValueType () == TemporalBoolean.class)
            theTempVar = new TemporalBoolean (thePeriodMgr);
d187 1
a187 1
         myPropValueArr[theProp.getIndex ()] = theTempVar;
d244 1
a244 1
 *                                  of TemporalVariable <V>.
d251 1
a251 1
      rejTemporalVar (theProp);
@


1.49
log
@bar ==> ban
@
text
@d76 1
a76 1
   private final void banTemporalVar (Property <?> theProp)
d249 1
a249 1
      banNull        (theProp, "theProp");
d251 1
a251 1
      banTemporalVar (theProp);
d271 1
a271 1
      banNull      (theProp, "theProp");
d294 2
a295 2
      banNull       (theProp,    "theProp");
      banNull       (thePartCat, "thePartCat");
d318 1
a318 1
      banNull       (theProp, "theProp");
d344 2
a345 2
      banNull       (theProp, "theProp");
      banNull       (thePart, "thePart");
d375 3
a377 3
      banNull      (theProp, "theProp");
      banNull      (theOpn,  "theOpn");
      banNull      (thePart, "thePart");
d409 3
a411 3
      banNull      (theProp, "theProp");
      banNull      (theOpn,  "theOpn");
      banNull      (thePart, "thePart");
d443 3
a445 3
      banNull      (theProp,    "theProp");
      banNull      (theBomEnt,  "theBomEnt");
      banNull      (thePart,    "thePart");
@


1.48
log
@Added class TemporalBoolean.
@
text
@d76 1
a76 1
   private final void barTemporalVar (Property <?> theProp)
d249 1
a249 1
      barNull        (theProp, "theProp");
d251 1
a251 1
      barTemporalVar (theProp);
d271 1
a271 1
      barNull      (theProp, "theProp");
d294 2
a295 2
      barNull       (theProp,    "theProp");
      barNull       (thePartCat, "thePartCat");
d318 1
a318 1
      barNull       (theProp, "theProp");
d344 2
a345 2
      barNull       (theProp, "theProp");
      barNull       (thePart, "thePart");
d375 3
a377 3
      barNull      (theProp, "theProp");
      barNull      (theOpn,  "theOpn");
      barNull      (thePart, "thePart");
d409 3
a411 3
      barNull      (theProp, "theProp");
      barNull      (theOpn,  "theOpn");
      barNull      (thePart, "thePart");
d443 3
a445 3
      barNull      (theProp,    "theProp");
      barNull      (theBomEnt,  "theBomEnt");
      barNull      (thePart,    "thePart");
@


1.47
log
@Added class TemporalInteger.
@
text
@d166 1
a166 1
      TemporalVariable <?> thePerVal;
d176 1
a176 1
            thePerVal = new TemporalDouble (thePeriodMgr);
d179 4
a182 1
            thePerVal = new TemporalInteger (thePeriodMgr);
d187 1
a187 1
         myPropValueArr[theProp.getIndex ()] = thePerVal;
@


1.46
log
@PeriodValue  ==> TemporalVariable
PeriodDouble ==> TemporalDouble
@
text
@d165 1
d168 2
d175 6
a180 2
         if (theProp.getValueType () == TemporalDouble.class)
            thePerVal = new TemporalDouble (myModelInstance.getPeriodMgr ());
@


1.45
log
@ProblemManager ==> WitJHandler
@
text
@d72 2
a73 1
 * Verifies that the value type of theProp is not a subclass of PeriodValue.
d76 1
a76 1
   private final void barPeriodValue (Property <?> theProp)
d78 1
a78 1
      if (PeriodValue.class.isAssignableFrom (theProp.getValueType ()))
d84 1
a84 1
             + "   whose value type is a subclass of PeriodValue <V>.\n"
d124 1
a124 1
         buildPeriodValues ();
d159 2
a160 2
 * Creates and stores the instances of PeriodValue subclasses that are to be
 * Property values for this Item.
d163 1
a163 1
   void buildPeriodValues ()
d165 1
a165 1
      PeriodValue <?> thePerVal;
d169 1
a169 1
         if (! PeriodValue.class.isAssignableFrom (theProp.getValueType ()))
d172 2
a173 2
         if (theProp.getValueType () == PeriodDouble.class)
            thePerVal = new PeriodDouble (myModelInstance.getPeriodMgr ());
d234 1
a234 1
 *                                  of PeriodValue <V>.
d241 1
a241 1
      barPeriodValue (theProp);
@


1.44
log
@Class renaming:
   ValueByPeriod  ==> PeriodValue
   DoubleByPeriod ==> PeriodDouble
@
text
@d9 1
a9 1
import static com.ibm.witm.ProblemManager.*;
d278 1
a278 1
 * @@throws IllegalStateException    If the current ProblemManager is null
d288 1
a288 1
      return getCurrentProblemManager ().newPart (this, theProp, thePartCat);
d302 1
a302 1
 * @@throws IllegalStateException    If the current ProblemManager is null
d311 1
a311 1
      return getCurrentProblemManager ().newOperation (this, theProp);
d326 1
a326 1
 * @@throws IllegalStateException    If the current ProblemManager is null
d339 1
a339 1
      return getCurrentProblemManager ().newDemand (this, theProp, thePart);
@


1.43
log
@ValueByPeriod
@
text
@d72 1
a72 1
 * Verifies that the value type of theProp is not a subclass of ValueByPeriod.
d75 1
a75 1
   private final void barValueByPeriod (Property <?> theProp)
d77 1
a77 1
      if (ValueByPeriod.class.isAssignableFrom (theProp.getValueType ()))
d83 1
a83 1
             + "   whose value type is a subclass of ValueByPeriod <V>.\n"
d123 1
a123 1
         buildValueByPeriods ();
d158 1
a158 1
 * Creates and stores the instances of ValueByPeriod subclasses that are to be
d162 1
a162 1
   void buildValueByPeriods ()
d164 1
a164 1
      ValueByPeriod <?> theVBP;
d168 1
a168 1
         if (! ValueByPeriod.class.isAssignableFrom (theProp.getValueType ()))
d171 2
a172 2
         if (theProp.getValueType () == DoubleByPeriod.class)
            theVBP = new DoubleByPeriod (myModelInstance.getPeriodMgr ());
d176 1
a176 1
         myPropValueArr[theProp.getIndex ()] = theVBP;
d233 1
a233 1
 *                                  of ValueByPeriod <V>.
d238 3
a240 3
      barNull          (theProp, "theProp");
      reqCatsMatch     (theProp, "set (theProp, theValue)");
      barValueByPeriod (theProp);
d242 1
a242 1
      setValue         (theProp, theValue);
@


1.42
log
@ValueByPeriod
@
text
@a107 24
/*******************************************************************************
 * Creates and stores the instances of ValueByPeriod subclasses that are to be
 * Property values for this Item.
 *******************************************************************************
 */
   private final void buildValueByPeriods ()
      {
      ValueByPeriod <?> theVBP;
      
      for (Property <?> theProp: myItemCategory.getProperties ())
         {
         if (! ValueByPeriod.class.isAssignableFrom (theProp.getValueType ()))
            continue;
         
         if (theProp.getValueType () == DoubleByPeriod.class)
            theVBP = new DoubleByPeriod (myModelInstance);

         else
            throw new AssertionError ();
            
         myPropValueArr[theProp.getIndex ()] = theVBP;
         }
      }
   
d122 2
a123 1
      buildValueByPeriods ();
d157 23
d214 1
a214 1
 */            @@Override
@


1.41
log
@ValueByPeriod.
@
text
@d108 24
d144 3
a146 1
      myPropValueArr  = new Object[theItemCat.nProperties ()];
@


1.40
log
@ValueByPeriod
@
text
@d72 1
a72 1
 * Verifies that the value type of theProp is not a ValueByPeriod class.
d83 1
a83 2
             + "   whose value type is ValueByPeriod <V> or one of its\n"
             + "   subclasses.\n"
d85 1
a85 1
             + "      Property:   " + theProp                + "\n"
d87 2
a88 2
                                         getValueType ().
                                            getSimpleName () + "\n");
d206 2
a207 2
 * @@throws IllegalArgumentException If the value type of theProp is
 *                                  ValueByPeriod <V> or one of its subclasses.
@


1.39
log
@newSubstitute
@
text
@d72 22
d207 2
d213 3
a215 2
      barNull      (theProp, "theProp");
      reqCatsMatch (theProp, "set (theProp, theValue)");
d217 1
a217 1
      setValue     (theProp, theValue);
@


1.38
log
@newBopEntry
@
text
@d360 34
@


1.37
log
@newBomEntry
@
text
@d326 34
@


1.36
log
@newDemand
@
text
@d11 1
a11 4
import com.ibm.witj.Component;
import com.ibm.witj.Demand;
import com.ibm.witj.Operation;
import com.ibm.witj.Part;
d217 1
a217 1
 * Creates new Part in the current Problem and stores a reference to it as the
d242 2
a243 2
 * Creates new Operation in the current Problem and stores a reference to it as
 * the value of a Property of this Item.
d265 1
a265 1
 * Creates new Demand in the current Problem and stores a reference to it as
d292 34
@


1.35
log
@newDemand
@
text
@d75 1
a75 1
 * Verifies that theComp belongs to the current Problem.
d78 1
a78 4
   private final void reqProbIsCur (
         Component theComp,
         String    signature,
         String    argName)
d80 1
a80 1
      if (theComp.getProblem () != getCurrentProblem ())
d84 2
a85 2
             + "   Call to Item." + signature + ", where\n"
             + "   " + argName + " does not belong to the current Problem.\n"
d87 1
a87 1
             + "      " + argName + ": " + theComp + "\n");
d290 1
a290 1
      reqProbIsCur  (thePart, "newDemand (theProp, thePart)", "thePart");
@


1.34
log
@ProblemMgr ==> ProblemManager
@
text
@d11 2
d74 19
d270 28
@


1.33
log
@Some renaming.
@
text
@d9 1
a9 1
import static com.ibm.witm.ProblemMgr.*;
d213 1
a213 1
 * @@throws IllegalStateException    If the current ProblemMgr is null
d218 4
a221 4
      barNull          (theProp,    "theProp");
      barNull          (thePartCat, "thePartCat");
      reqCatsMatch     (theProp,    "newPart (theProp, thePartCat)");
      reqCurProblemMgr ();
d223 1
a223 1
      return getCurrentProblemMgr ().newPart (this, theProp, thePartCat);
d237 1
a237 1
 * @@throws IllegalStateException    If the current ProblemMgr is null
d242 3
a244 3
      barNull          (theProp, "theProp");
      reqCatsMatch     (theProp, "newOperation (theProp)");
      reqCurProblemMgr ();
d246 1
a246 1
      return getCurrentProblemMgr ().newOperation (this, theProp);
@


1.32
log
@Minor revisions.
@
text
@d55 1
a55 3
   private final void requireCatsMatch (
         Property <?> theProp,
         String       signature)
d174 2
a175 2
      prohibitNull     (theProp, "theProp");
      requireCatsMatch (theProp, "set (theProp, theValue)");
d177 1
a177 1
      setValue         (theProp, theValue);
d195 2
a196 2
      prohibitNull     (theProp, "theProp");
      requireCatsMatch (theProp, "get (theProp)");
d218 4
a221 4
      prohibitNull         (theProp,    "theProp");
      prohibitNull         (thePartCat, "thePartCat");
      requireCatsMatch     (theProp,    "newPart (theProp, thePartCat)");
      requireCurProblemMgr ();
d242 3
a244 3
      prohibitNull         (theProp, "theProp");
      requireCatsMatch     (theProp, "newOperation (theProp)");
      requireCurProblemMgr ();
@


1.31
log
@Scheme ==> ModelScheme
@
text
@d64 2
a65 3
             + "   Call to Item." + signature + " with a Property of an\n"
             + "   ItemCategory that does not match the ItemCategory of the\n"
             + "   Item.\n"
d67 4
a70 3
             + "      " + this    + "\n"
             + "      " + theProp + " of "
                        + theProp.getItemCategory () + "\n");
d177 1
a177 1
      requireCatsMatch (theProp, "set (theProb, theValue)");
@


1.30
log
@Embodiment ==> ModelInstance
@
text
@d80 1
a80 1
      assert (theInst.getScheme () == theItemCat.getScheme ());
d134 1
a134 1
 * @@return The Scheme for this Item.
d137 1
a137 1
   public final Scheme getScheme ()
d139 1
a139 1
      return myModelInstance.getScheme ();
@


1.29
log
@Efficient String concatenation.
@
text
@d16 3
a18 3
 * Item belongs to a particular Embodiment and a particular ItemCategory.
 * The Items that belong to a given Embodiment are the building blocks
 * that make up the Embodiment.
d34 1
a34 1
 * The Embodiment that owns this Item.
d37 1
a37 1
   private final Embodiment myEmbodiment;
d78 1
a78 1
   Item (ItemCategory <?> theItemCat, Embodiment theEmb)
d80 1
a80 1
      assert (theEmb.getScheme () == theItemCat.getScheme ());
d82 1
a82 1
      myItemCategory = theItemCat;
d84 1
a84 1
      myEmbodiment   = theEmb;
d86 1
a86 1
      myPropValueArr = new Object[theItemCat.nProperties ()];
d139 1
a139 1
      return myEmbodiment.getScheme ();
d143 1
a143 1
 * @@return The Embodiment that owns this Item
d146 1
a146 1
   public final Embodiment getEmbodiment ()
d148 1
a148 1
      return myEmbodiment;
@


1.28
log
@newOperation
@
text
@d157 1
a157 1
      return myItemCategory.getName () + " " + getID ();
@


1.27
log
@Long names.
@
text
@d11 1
d228 23
@


1.26
log
@Category ==> ItemCategory
@
text
@a45 20
// Private Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that the current ProblemMgr is not null.
 *******************************************************************************
 */
   private static void requireCurProblemMgr ()
      {
      if (getCurrentProblemMgr () == null)
         {
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to a method that requires a current ProblemMgr when\n"
             + "   the current ProblemMgr is null.\n");
         }
      }

////////////////////////////////////////////////////////////////////////////////
d93 7
d113 1
a113 2
 */
              @@SuppressWarnings("unchecked")
d151 9
a218 3
      String thePartName;
      Part   thePart;
      
d224 1
a224 10
      thePartName = Integer.toString (getCurrentProblemMgr ().nPartsCreated ());
      
      thePart     =
         Part.newInstance (getCurrentProblem (), thePartName, thePartCat);

      getCurrentProblemMgr ().recPartCreated ();
      
      setValue (theProp, thePart);
      
      return thePart;
@


1.25
log
@Signatures with argument names.
@
text
@d15 1
a15 1
 * Item belongs to a particular Embodiment and a particular Category.
d27 1
a27 1
 * The Category to which this Item belongs.
d30 1
a30 1
   private final Category <?> myCategory;
d70 2
a71 1
 * Verifies that the Category of theProp matches the Category of this Item.
d78 1
a78 1
      if (theProp.getCategory () != myCategory)
d83 3
a85 2
             + "   Call to Item." + signature + " with a Property of a\n"
             + "   Category that does not match the Category of the Item.\n"
d89 1
a89 1
                        + theProp.getCategory () + "\n");
d97 1
a97 1
   Item (Category <?> theCat, Embodiment theEmb)
d99 1
a99 1
      assert (theEmb.getScheme () == theCat.getScheme ());
d101 1
a101 1
      myCategory     = theCat;
d105 1
a105 1
      myPropValueArr = new Object[theCat.nProperties ()];
d138 1
a138 1
 * @@return The Category to which this Item belongs
d141 1
a141 1
   public final Category <?> getCategory ()
d143 1
a143 1
      return myCategory;
d174 2
a175 2
 * @@throws IllegalArgumentException If the Category of theProp does not match
 *                                  the Category of this Item.
d195 2
a196 2
 * @@throws IllegalArgumentException If the Category of theProp does not match
 *                                  the Category of this Item.
d213 1
a213 1
 * @@param thePartCat The Part Category of the new Part.
d217 2
a218 2
 * @@throws IllegalArgumentException If the Category of theProp does not match
 *                                  the Category of this Item.
@


1.24
log
@Item.newPart
@
text
@d179 1
a179 1
      requireCatsMatch (theProp, "set (Property <V>, V)");
d200 1
a200 1
      requireCatsMatch (theProp, "get (Property <V>)");
d227 1
a227 1
      requireCatsMatch     (theProp,    "newPart (Property <V>)");
@


1.23
log
@Class ProblemMgr.
@
text
@d9 3
d46 20
a199 1
      
d205 37
@


1.22
log
@Removed period index Property.
@
text
@d6 1
a6 1
package       com.ibm.witm;
@


1.21
log
@Implementation ==> Embodiment
@
text
@a155 1
      
d158 1
a158 1
      setValue (theProp, theValue);
@


1.20
log
@Moved newProperty to class Category
@
text
@d12 3
a14 3
 * Item belongs to a particular Implementation and a particular Category.
 * The Items that belong to a given Implementation are the building blocks
 * that make up the Implementation.
d30 1
a30 1
 * The Implementation that owns this Item.
d33 1
a33 1
   private final Implementation myImplementation;
d72 1
a72 1
   Item (Category <?> theCat, Implementation theImple)
d74 1
a74 1
      assert (theImple.getScheme () == theCat.getScheme ());
d76 1
a76 1
      myCategory       = theCat;
d78 1
a78 1
      myImplementation = theImple;
d80 1
a80 1
      myPropValueArr   = new Object[theCat.nProperties ()];
d127 1
a127 1
      return myImplementation.getScheme ();
d131 1
a131 1
 * @@return The Implementation that owns this Item
d134 1
a134 1
   public final Implementation getImplementation ()
d136 1
a136 1
      return myImplementation;
@


1.19
log
@//=== ==> /////
@
text
@a73 2
      int nProps;
      
d80 1
a80 3
      nProps           = theCat.getProperties ().size ();
      
      myPropValueArr   = new Object[nProps];
@


1.18
log
@Re-arranged source code.
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d19 1
a19 1
//==============================================================================
d21 1
a21 1
//==============================================================================
d42 1
a42 1
//==============================================================================
d44 1
a44 1
//==============================================================================
d68 1
a68 1
//==============================================================================
d70 1
a70 1
//==============================================================================
d87 1
a87 1
//==============================================================================
d89 1
a89 1
//==============================================================================
d112 1
a112 1
//==============================================================================
d114 1
a114 1
//==============================================================================
d188 1
a188 1
//==============================================================================
@


1.17
log
@Various revisions.
@
text
@d20 94
a113 1
// Public
a116 2
 * Accessor.
 * 
a134 2
 * Accessor.
 * 
a188 89
// Package-Internal
//==============================================================================
   
/*******************************************************************************
 * Constructor.
 *******************************************************************************
 */
   Item (Category <?> theCat, Implementation theImple)
      {
      int nProps;
      
      assert (theImple.getScheme () == theCat.getScheme ());
      
      myCategory       = theCat;
      
      myImplementation = theImple;
      
      nProps           = theCat.getProperties ().size ();
      
      myPropValueArr   = new Object[nProps];
      }

/*******************************************************************************
 * Sets the value of a Property for this Item to theValue.
 * (Internal Version)
 *******************************************************************************
 */
   final <V> void setValue (Property <V> theProp, V theValue)
      {
      myPropValueArr[theProp.getIndex ()] = theValue;
      }

/*******************************************************************************
 * Retrieves the value of a Property for this Item.
 * (Internal Version)
 *******************************************************************************
 */
              @@SuppressWarnings("unchecked")
   final <V> V getValue (Property <V> theProp)
      {
      return (V) myPropValueArr[theProp.getIndex ()];
      }

//==============================================================================
// Private
//==============================================================================

/*******************************************************************************
 * Verifies that the Category of theProp matches the Category of this Item.
 *******************************************************************************
 */
   private final void requireCatsMatch (
         Property <?> theProp,
         String       signature)
      {
      if (theProp.getCategory () != myCategory)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Item." + signature + " with a Property of a\n"
             + "   Category that does not match the Category of the Item.\n"
             + "\n"
             + "      " + this    + "\n"
             + "      " + theProp + " of "
                        + theProp.getCategory () + "\n");
         }
      }
   
/*******************************************************************************
 * The Category to which this Item belongs.
 *******************************************************************************
 */
   private final Category <?> myCategory;
   
/*******************************************************************************
 * The Implementation that owns this Item.
 *******************************************************************************
 */
   private final Implementation myImplementation;
   
/*******************************************************************************
 * myPropValueArr[theProp.getIndex ()] is the value of theProp associated with
 * this Item.
 *******************************************************************************
 */
   private final Object[] myPropValueArr;
   
//==============================================================================
@


1.16
log
@Global Category / Primitive.
@
text
@d74 1
a74 1
      setInternal      (theProp, theValue);
d96 1
a96 1
      return getInternal (theProp);
d123 1
a123 1
 * Sets the value of a Property for this Item to a specified value.
d127 1
a127 1
   final <V> void setInternal (Property <V> theProp, V theValue)
d137 2
a138 2
                     @@SuppressWarnings("unchecked")
   final <V> V getInternal (Property <V> theProp)
@


1.15
log
@getSlice
@
text
@d74 1
a74 1
      myPropValueArr[theProp.getIndex ()] = theValue;
a89 1
                     @@SuppressWarnings("unchecked")
d96 1
a96 1
      return (V) myPropValueArr[theProp.getIndex ()];
d122 21
@


1.14
log
@Doc comments
@
text
@d90 1
a90 1
                      @@SuppressWarnings("unchecked")
d108 1
a108 1
   Item (Category <?> theCat, Implementation theImpl)
d112 1
a112 1
      assert (theImpl.getScheme () == theCat.getScheme ());
d116 1
a116 1
      myImplementation = theImpl;
@


1.13
log
@Removed Scheme.myPropertyNames.
@
text
@d55 3
a57 3
 * Sets the value of a Property for this Item to a specified value, an
 * instance of type V.<br>
 * Specifically, a reference to the specified V instance is stored.
d59 1
d80 1
@


1.12
log
@Replaced ItemCategory with Category <?>.
@
text
@d108 2
d116 3
a118 1
      myPropValueArr   = new Object[theCat.getNProperties ()];
@


1.11
log
@Name change.
@
text
@d12 1
a12 1
 * Item belongs to a particular Implementation and a particular ItemCategory.
d26 1
a26 1
 * @@return The ItemCategory to which this Item belongs
d29 1
a29 1
   public final ItemCategory getItemCategory ()
d31 1
a31 1
      return myItemCategory;
d63 2
a64 2
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
d69 1
a69 1
      prohibitNull             (theProp, "theProp");
d71 1
a71 1
      requireItemCatsMatch (theProp, "set (Property <V>, V)");
d84 2
a85 2
 * @@throws IllegalArgumentException If the ItemCategory of theProp does not
 *                                  match the ItemCategory of this Item.
d91 1
a91 1
      prohibitNull             (theProp, "theProp");
d93 1
a93 1
      requireItemCatsMatch (theProp, "get (Property <V>)");
d106 1
a106 1
   Item (ItemCategory theItemCat, Implementation theImpl)
d108 1
a108 1
      assert (theImpl.getScheme () == theItemCat.getScheme ());
d110 1
a110 1
      myItemCategory   = theItemCat;
d114 1
a114 1
      myPropValueArr   = new Object[theItemCat.getNProperties ()];
d122 1
a122 2
 * Verifies that the ItemCategory of theProp matches the ItemCategory of this
 * Item.
d125 1
a125 1
   private final void requireItemCatsMatch (
d129 1
a129 1
      if (theProp.getItemCategory () != myItemCategory)
d134 2
a135 3
             + "   Call to Item." + signature + " with a Property of\n"
             + "   an ItemCategory that does not match the ItemCategory\n"
             + "   to which the Item belongs.\n"
d139 1
a139 1
                        + theProp.getItemCategory () + "\n");
d144 1
a144 1
 * The ItemCategory to which this Item belongs.
d147 1
a147 1
   private final ItemCategory myItemCategory;
@


1.10
log
@Removed getPrimitive.
@
text
@d71 1
a71 1
      requireElCategoriesMatch (theProp, "set (Property <V>, V)");
d93 1
a93 1
      requireElCategoriesMatch (theProp, "get (Property <V>)");
d126 1
a126 1
   private final void requireElCategoriesMatch (
@


1.9
log
@Tuple.get (ItemCategory)
@
text
@a54 13
 * Casting method
 * 
 * @@return this Item, cast as a Primitive
 * 
 * @@throws ClassCastException If this Item is not a Primitive
 *******************************************************************************
 */
   public final Primitive getPrimitive ()
      {
      return (Primitive) this;
      }

/*******************************************************************************
@


1.8
log
@theImple ==> theImpl
@
text
@d35 9
@


1.7
log
@Reverting to state as of yesterday 6/8/11 15:00.
@
text
@d110 1
a110 1
   Item (ItemCategory theItemCat, Implementation theImple)
d112 1
a112 1
      assert (theImple.getScheme () == theItemCat.getScheme ());
d116 1
a116 1
      myImplementation = theImple;
@


1.6
log
@Checking for ItemCategory in current Scheme.
@
text
@d110 1
a110 1
   Item (ItemCategory theItemCat, Implementation theImpl)
d112 2
d116 1
a116 1
      myImplementation = theImpl;
@


1.5
log
@Matching current Scheme to current Implementation.
@
text
@a111 2
      assert (theImpl.getScheme () == theItemCat.getScheme ());
      
@


1.4
log
@Minor revision.
@
text
@d110 1
a110 1
   Item (ItemCategory theItemCat, Implementation theImple)
d112 1
a112 1
      assert (theImple.getScheme () == theItemCat.getScheme ());
d116 1
a116 1
      myImplementation = theImple;
@


1.3
log
@Revised some messsages.
@
text
@d110 1
a110 1
   Item (ItemCategory theItemCat, Implementation theImp)
d112 1
a112 1
      assert (theImp.getScheme () == theItemCat.getScheme ());
d116 1
a116 1
      myImplementation = theImp;
@


1.2
log
@Type ==> Category
@
text
@d75 1
a75 1
      requireElCategoriesMatch (theProp, "set");
d97 1
a97 1
      requireElCategoriesMatch (theProp, "get");
d132 1
a132 1
         String       methName)
d139 1
a139 1
             + "   Call to theItem." + methName + " (...) with a Property of\n"
@


1.1
log
@Element     ==> Item
ElementType ==> ItemTYpe
@
text
@d12 1
a12 1
 * Item belongs to a particular Implementation and a particular ItemType.
d26 1
a26 1
 * @@return The ItemType to which this Item belongs
d29 1
a29 1
   public final ItemType getItemType ()
d31 1
a31 1
      return myItemType;
d67 2
a68 2
 * @@throws IllegalArgumentException If the ItemType of theProp does not
 *                                  match the ItemType of this Item.
d73 1
a73 1
      prohibitNull        (theProp, "theProp");
d75 1
a75 1
      requireElTypesMatch (theProp, "set");
d88 2
a89 2
 * @@throws IllegalArgumentException If the ItemType of theProp does not
 *                                  match the ItemType of this Item.
d95 1
a95 1
      prohibitNull        (theProp, "theProp");
d97 1
a97 1
      requireElTypesMatch (theProp, "get");
d110 1
a110 1
   Item (ItemType theElType, Implementation theImp)
d112 1
a112 1
      assert (theImp.getScheme () == theElType.getScheme ());
d114 1
a114 1
      myItemType       = theElType;
d118 1
a118 1
      myPropValueArr   = new Object[theElType.getNProperties ()];
d126 2
a127 2
 * Verifies that the ItemType of theProp matches the ItemType of
 * this Item.
d130 1
a130 1
   private final void requireElTypesMatch (
d134 1
a134 1
      if (theProp.getItemType () != myItemType)
d140 2
a141 2
             + "   an ItemType that does not match the\n"
             + "   ItemType to which the Item belongs.\n"
d145 1
a145 1
                        + theProp.getItemType () + "\n");
d150 1
a150 1
 * The ItemType to which this Item belongs.
d153 1
a153 1
   private final ItemType myItemType;
@


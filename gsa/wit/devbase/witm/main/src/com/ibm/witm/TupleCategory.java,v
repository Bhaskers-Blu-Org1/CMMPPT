head	1.39;
access;
symbols;
locks; strict;
comment	@# @;


1.39
date	2011.10.10.20.07.51;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.10.05.23.07.37;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.10.04.22.57.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.09.13.20.48.09;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.09.08.22.43.40;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.22.23.47.24;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.20.18.38.46;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.19.21.37.07;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.19.21.13.16;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.19.19.22.02;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.15.23.19.02;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.15.17.42.33;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.15.15.51.22;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.14.23.40.36;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.14.21.22.47;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.14.20.24.04;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.13.22.51.52;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.13.19.45.48;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.12.22.40.01;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.22.22.09.45;	author rjw;	state dead;
branches;
next	1.19;

1.19
date	2011.06.22.15.07.28;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.21.22.18.06;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.20.21.44.05;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.20.17.48.37;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.20.16.07.45;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.17.22.09.07;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.17.18.23.06;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.16.23.36.14;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.16.15.35.14;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.15.22.25.20;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.11.00.15.41;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.10.19.37.19;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.07.20.56.02;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.07.20.14.11;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.07.19.47.03;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.07.18.37.07;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.06.20.33.34;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.24.18.46.17;	author rjw;	state dead;
branches;
next	1.1;

1.1
date	2011.05.22.02.10.44;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.39
log
@getCellAsPrimitive (...).
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M Source File TupleCategory.java.
////////////////////////////////////////////////////////////////////////////////

package com.ibm.witm;

import static com.ibm.witm.Utility.*;

import java.io  .PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/*******************************************************************************
 * A TupleCategory is an ItemCategory of Tuples.<br><br>
 * 
 * The factory method for creating instances of this class is
 * ModelScheme.newTupleCategory (theName, theDimens).
 *******************************************************************************
 */
public final class TupleCategory extends ItemCategory <Tuple>
{
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The "dimensions" of this TupleCategory<br>
 * For each Tuple in this TupleCategory, the number of coordinates of the
 * Tuple must match myDimensions.size () and
 * for i = 0, ... myDimensions.size () - 1, coordinate #i of the Tuple must
 * belong to myDimensions.get (i).<br>
 * This List is an unmodifiable view of an ArrayList.
 *******************************************************************************
 */
   private final List <ItemCategory <?>> myDimensions;

/*******************************************************************************
 * This field is null until the ModelScheme for this TupleCategory is frozen.
 * After the ModelScheme for this TupleCategory is frozen:
 *    uniqueDimenIndexArr[theItemCat.getCatIndex ()] =
 *       The dimension index of theItemCat in this TupleCategory,
 *           if there is exactly one.<br>
 *       -1, if there is no matching dimension.<br>
 *       -2, if there is more than one matching dimension.
 *******************************************************************************
 */
   private int[] uniqueDimenIndexArr = null;

/*******************************************************************************
 * A list of all DimensionIDs that apply to this TupleCategory.
 *******************************************************************************
 */
   private final ArrayList <DimensionID <?>> myDimensionIDs;

////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that theIdx >= 0.
 *******************************************************************************
 */
   private void rejNegDimenIdx (String theName, int theIdx)
      {
      if (theIdx < 0)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   TupleCategory.newDimensionID (theName, theItemCat, theIdx),"
             + "\n"
             + "   where theIdx < 0.\n"
             + "\n"
             + "      theName: \"" + theName + "\"\n"
             + "      theIdx:  "   + theIdx  + "\n");
         }
      }

/*******************************************************************************
 * Verifies that theIdx < # dimensions.
 *******************************************************************************
 */
   private void rejDimenIdxTooHigh (String theName, int theIdx)
      {
      if (theIdx >= myDimensions.size ())
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   TupleCategory.newDimensionID (theName, theItemCat, theIdx),"
             + "\n"
             + "   where theIdx >= the # of dimensions of the TupleCategory.\n"
             + "\n"
             + "      theName:         \"" + theName              + "\"\n"
             + "      TupleCategory:   "   + getName ()           +   "\n"
             + "      # of Dimensions: "   + myDimensions.size () +   "\n"
             + "      theIdx:          "   + theIdx               +   "\n");
         }
      }

/*******************************************************************************
 * Verifies that theItemCat matches the dimension for theIdx.
 *******************************************************************************
 */
   private void reqCatMatchesDimen (ItemCategory <?> theItemCat, int theIdx)
      {
      ItemCategory<?> theDimen;
      
      theDimen = myDimensions.get (theIdx);
      
      if (theItemCat != theDimen)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   TupleCategory.newDimensionID (theName, theItemCat, theIdx),"
             + "\n"
             + "   where theItemCat does not match the dimension of the\n"
             + "   TupleCategory indexed by theIdx.\n"
             + "\n"
             + "      TupleCategory:        " + getName ()            + "\n"
             + "      theItemCat:           " + theItemCat.getName () + "\n"
             + "      theIdx:               " + theIdx                + "\n"
             + "      Dimension for theIdx: " + theDimen.getName ()   + "\n");
         }
      }

/*******************************************************************************
 * Verifies that the # of coordinates passed to a method matches the # of
 * dimensions in this TupleCategory.
 * 
 * @@param signature The signature of the method called
 *******************************************************************************
 */
   private void checkNCoords (Item[] theCoordArr, String signature)
      {
      if (theCoordArr.length != myDimensions.size ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to TupleCategory." + signature + ",\n"
             + "   where the number of coordinates passed does not match the\n"
             + "   number of dimensions of the TupleCategory.\n"
             + "\n"
             + "      TupleCategory:        " + getName ()           + "\n"
             + "      # Dimensions:         " + myDimensions.size () + "\n"
             + "      # Coordinates Passed: " + theCoordArr.length   + "\n");
        }
   
/*******************************************************************************
 * Verifies that the Categories of the coordinates passed to a method match the
 * dimensions of this TupleCategory.
 * 
 * @@param signature The signature of the method called
 *******************************************************************************
 */
   private void checkCategories (Item[] theCoordArr, String signature)
      {
      int              theIdx;
      ItemCategory <?> theItemCat;
      ItemCategory <?> theDimen;
      
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theItemCat = theCoordArr[theIdx].getItemCategory ();
         
         theDimen   = myDimensions.get (theIdx);
         
         if (theItemCat != theDimen)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to TupleCategory." + signature + ",\n"
                + "   where the ItemCategory of at least one of the\n"
                + "   coordinates passed does not match the corresponding\n"
                + "   dimension of the TupleCategory.\n"
                + "\n"
                + "      TupleCategory:           " +          getName () + "\n"
                + "      Dimension Index:         " + theIdx              + "\n"
                + "      Dimension:               " + theDimen.getName () + "\n"
                + "      Coordinate ItemCategory: " + theItemCat.
                                                         getName ()       + "\n"
                );
         }
      }
   
/*******************************************************************************
 * Verifies that the Items passed to a method all belong to the current
 * ModelInstance.
 *******************************************************************************
 */
   private void reqModelInstsMatchCur (Item[] theCoordArr, String signature)
      {
      int           theIdx;
      ModelInstance theInst;
      
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theInst = theCoordArr[theIdx].getModelInstance ();
         
         if (theInst != curModelInst ())
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to TupleCategory." + signature + ",\n"
                + "   where at least one of the coordinate Items does not\n"
                + "   belong to the current ModelInstance.\n"
                + "\n"
                + "      TupleCategory:            "   
                +           getName ()                   + "\n"
                + "      Coordinate Index:         "
                +           theIdx                       + "\n"
                + "      Coordinate:               "
                +           theCoordArr[theIdx]          + "\n"
                + "      Coordinate ModelInstance: \""
                +           theInst.getName ()         + "\"\n"
                + "      Current    ModelInstance: \""
                +           curModelInst ().getName () + "\"\n");
         }
      }
   
/*******************************************************************************
 * Verifies that theCoordArr does not duplicate the coordinate list of a
 * Tuple of this TupleCategory in the current ModelInstance.
 *******************************************************************************
 */
   private void rejDupCoords (Item[] theCoordArr)
      {
      Tuple theTuple;
      
      theTuple = curModelInst ().getTupleMgr (this).getTuple (theCoordArr);
      
      if (theTuple != null)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to TupleCategory.newTuple (Item...)\n"
             + "   with a coordinate list that duplicates coordinate list of\n"
             + "   an existing Tuple of the TupleCategory in the\n"
             + "   current ModelInstance.\n"
             + "\n"
             + "      Tuple: " + theTuple + "\n");
      }
   
////////////////////////////////////////////////////////////////////////////////
// Package Internal Constructor
////////////////////////////////////////////////////////////////////////////////

   TupleCategory (
         ModelScheme        theScheme,
         String             theName,
         ItemCategory <?>[] theDimenArr)
      {
      super (theScheme, theName);
      
      ArrayList <ItemCategory <?>> theDimens;
      
      theDimens = new ArrayList <ItemCategory <?>> (theDimenArr.length);
      
      Collections.addAll (theDimens, theDimenArr);
      
      myDimensions   = Collections.unmodifiableList (theDimens);
      
      myDimensionIDs = new ArrayList <DimensionID <?>> (0);
      }

////////////////////////////////////////////////////////////////////////////////
// Package Internal Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Stores theDimID as one of the DimensionIDs that apply to this TupleCategory.
 *******************************************************************************
 */
   void store (DimensionID <?> theDimID)
      {
      myDimensionIDs.add (theDimID);
      }
   
/*******************************************************************************
 * Sets up uniqueDimenIndexArr.
 *******************************************************************************
 */    @@Override 
   void freeze ()
      {
      int nCats;
      int theIdx;
      int theItemCatIdx;
      
      nCats = getModelScheme ().getItemCategories ().size ();

      uniqueDimenIndexArr = new int[nCats];
      
      Arrays.fill (uniqueDimenIndexArr, 0, nCats, -1);
      
      for (theIdx = 0; theIdx < myDimensions.size (); theIdx ++)
         {
         theItemCatIdx = myDimensions.get (theIdx).getIndex ();
         
         if (uniqueDimenIndexArr[theItemCatIdx] == -1)
            {
            uniqueDimenIndexArr[theItemCatIdx] = theIdx;
            }
         else
            {
            uniqueDimenIndexArr[theItemCatIdx] = -2;
            }
         }
      }
   
/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */    @@Override
   void printConcrete (PrintStream theStream)
      {
      int theIdx;
      
      theStream.printf (
         "%n"
      +  "TupleCategory %s:%n%n",
         getName ());

      for (theIdx = 0; theIdx < myDimensions.size (); theIdx ++)
         {
         theStream.printf (
            "   Dimension #%d: %s%n",
            theIdx,
            myDimensions.get (theIdx).getName ());
         
         for (DimensionID <?> theDimID: myDimensionIDs)
            {
            if (theDimID.getDimIndex () == theIdx)
               theStream.printf (
                  "             ID: %s%n",
                  theDimID.getName ());
            }
         }
      }

/*******************************************************************************
 * {@@inheritDoc}
********************************************************************************
 */           @@Override 
   ItemMgr <?> newItemMgr (ModelInstance theInst)
      {
      return new TupleMgr (this, theInst);
      }

/*******************************************************************************
 * @@return The "dimensions" of this TupleCategory, stored as an unmodifiable
 *         view of an ArrayList.
 *******************************************************************************
 */
   List <ItemCategory <?>> getDimensions ()
      {
      return myDimensions;
      }

/*******************************************************************************
 * @@return The unique dimension index of theItemCat in this TupleCatagory, if
 *         there is exactly one<br>
 *         -1, if there is no matching dimension<br>
 *         -2, if there is more than one matching dimension
 * 
 * @@throws NullPointerException If the ModelScheme for this TupleCategory is not
 *                              frozen.
 *******************************************************************************
 */
   int uniqueDimenIndex (ItemCategory <?> theItemCat)
      {
      return uniqueDimenIndexArr[theItemCat.getIndex ()];
      }

////////////////////////////////////////////////////////////////////////////////
// Public Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */             @@Override
   public String toString ()
      {
      return getName ();
      }
   
/*******************************************************************************
 * Factory method:<br>
 * Constructs a new DimensionID {@@literal<I>} that will apply to this
 * TupleCategory.
 * 
 * @@param <I>         The Item type of the DimensionID to be constructed
 * @@param theName     The name of the DimensionID to be constructed
 * @@param theItemCat  The ItemCategory of the dimension to be identified
 * @@param theIdx      The index of the dimension to be identified
 * @@return            The new DimensionID {@@literal<I>}
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If theIdx is not in the range:
 *                                  0 <= theIdx < # dimensions
 * @@throws IllegalArgumentException If theItemCat does not match the dimension
 *                                  of this TupleCategory indexed by theIdx.
 * @@throws IllegalStateException    If the ModelScheme of this TupleCategory is
 *                                  frozen
 * @@throws IllegalArgumentException If theName duplicates the name of an 
 *                                  existing schematic object in the
 *                                  ModelScheme of this TupleCategory
 *******************************************************************************
 */
   public <I extends Item> DimensionID <I> newDimensionID (
         String           theName,
         ItemCategory <I> theItemCat,
         int              theIdx)
      {
      rejNull              (theName,    "theName");
      rejNull              (theItemCat, "theItemCat");
      rejNegDimenIdx       (theName,    theIdx);
      rejDimenIdxTooHigh   (theName,    theIdx);
      reqCatMatchesDimen   (theItemCat, theIdx);
      rejFrozenScheme (
         "TupleCategory.newDimensionID (theName, theItemCat, theIdx)");
      getModelScheme ().rejDupName (
         theName,
         "TupleCategory.newDimensionID (theName, theItemCat, theIdx)");
      
      return new DimensionID <I> (theName, this, theIdx);
      }

/*******************************************************************************
 * Factory method:<br>
 * Constructs a new Tuple for this TupleCategory in the current ModelInstance.
 *
 * @@param theCoords                 The Items that are to be the coordinates
 *                                  of the Tuple
 * @@return                          The new Tuple
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current ModelInstance is null
 * @@throws IllegalStateException    If the ModelScheme of this TupleCategory
 *                                  does not match the ModelScheme of the
 *                                  current ModelInstance
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current ModelInstance
 * @@throws IllegalArgumentException If the Items match the coordinate list of an
 *                                  existing Tuple of this TupleCategory
 *                                  in the current ModelInstance
 *******************************************************************************
 */
   public Tuple newTuple (Item... theCoords)
      {
      rejNullArray                 (theCoords, "theCoords");
      reqCurModelInst              ();
      reqSchemeMatchesCurModelInst ();
      checkNCoords                 (theCoords, "newTuple (theCoords)");
      checkCategories              (theCoords, "newTuple (theCoords)");
      reqModelInstsMatchCur        (theCoords, "newTuple (theCoords)");
      rejDupCoords                 (theCoords);
      
      return new Tuple (this, curModelInst (), theCoords);
      }
   
/*******************************************************************************
 * Tuple look-up method.
 * 
 * @@param theCoords                 The list of coordinates for the Tuple to
 *                                  be retrieved
 * @@return                          The Tuple of this TupleCategory in the
 *                                  current ModelInstance whose coordinates
 *                                  match theCoords, if any; otherwise null.
 *                                  
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current ModelInstance is null
 * @@throws IllegalStateException    If the ModelScheme of this TupleCategory
 *                                  does not match the ModelScheme of the
 *                                  current ModelInstance
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current ModelInstance
 *******************************************************************************
 */
   public Tuple get (Item... theCoords)
      {
      rejNullArray                 (theCoords,  "theCoords");
      reqCurModelInst              ();
      reqSchemeMatchesCurModelInst ();
      checkNCoords                 (theCoords, "get (theCoords)");
      checkCategories              (theCoords, "get (theCoords)");
      reqModelInstsMatchCur        (theCoords, "get (theCoords)");
      
      return curModelInst ().getTupleMgr (this).getTuple (theCoords);
      }
   
/*******************************************************************************
 * Computes a "slice": the set of all Tuples of this TupleCategory in the
 * current ModelInstance whose coordinates match a "pattern". The pattern is a
 * sequence of n Item references, where n is the number of dimensions in the
 * TupleCatagory. Some of the Item references may be null. A Tuple will be
 * in the slice, iff it belongs to the TupleCategory and to the current
 * ModelInstance and for each coordinate of the Tuple, either the coordinate
 * == the corresponding Item in the pattern, or the corresponding Item
 * reference in the pattern is null. Thus the nulls in the pattern function as
 * "wild cards" that match all Items.<br>
 * <br>
 * The slice is computed by looping through each Tuple of this
 * TupleCategory in the current ModelInstance and adding to the slice each
 * Tuple whose coordinates match the pattern. The Tuples are listed in the
 * order in which they were created.
 * 
 * @@see    getSliceDense
 * 
 * @@param  thePattern The pattern to which the Tuples in the slice are to be
 *                    matched
 * @@return            The slice
 * 
 * @@throws NullPointerException     If thePattern is a null references
 * @@throws IllegalStateException    If the current ModelInstance is null
 * @@throws IllegalStateException    If the ModelScheme of this TupleCategory
 *                                  does not match the ModelScheme of the
 *                                  current ModelInstance
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current ModelInstance
 *******************************************************************************
 */
   public List <Tuple> getSliceSparse (Item... thePattern)
      {
      rejNull                      (thePattern, "thePattern");
      reqCurModelInst              ();
      reqSchemeMatchesCurModelInst ();
      
      checkNCoords                 (thePattern, "getSliceSparse (thePattern)");
      checkCategories              (thePattern, "getSliceSparse (thePattern)");
      reqModelInstsMatchCur        (thePattern, "getSliceSparse (thePattern)");
      
      return curModelInst ().getTupleMgr (this).getSliceSparse (thePattern);
      }
   
/*******************************************************************************
 * Computes a "slice": the set of all Tuples of this TupleCategory in the
 * current ModelInstance whose coordinates match a "pattern". The pattern is a
 * sequence of n Item references, where n is the number of dimensions in the
 * TupleCatagory. Some of the Item references may be null. A Tuple will be
 * in the slice, iff it belongs to the TupleCategory and to the current
 * ModelInstance and for each coordinate of the Tuple, either the coordinate
 * == the corresponding Item in the pattern, or the corresponding Item
 * reference in the pattern is null. Thus the nulls in the pattern function as
 * "wild cards" that match all Items.<br>
 * <br>
 * The slice is computed by performing a multiply-nested loop that iterates
 * through each possible coordinate specification that would match the pattern
 * and adds to the slice the corresponding Tuple if it exists. The Tuples
 * are listed in lexicographic order.
 * 
 * @@see    getSliceSparse
 * 
 * @@param  thePattern The pattern to which the Tuples in the slice are to be
 *                    matched
 * @@return            The slice
 * 
 * @@throws NullPointerException     If thePattern is a null references
 * @@throws IllegalStateException    If the current ModelInstance is null
 * @@throws IllegalStateException    If the ModelScheme of this TupleCategory
 *                                  does not match the ModelScheme of the
 *                                  current ModelInstance
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current ModelInstance
 *******************************************************************************
 */
   public List <Tuple> getSliceDense (Item... thePattern)
      {
      rejNull                      (thePattern, "thePattern");
      reqCurModelInst              ();
      reqSchemeMatchesCurModelInst ();
      
      checkNCoords                 (thePattern, "getSliceDense (thePattern)");
      checkCategories              (thePattern, "getSliceDense (thePattern)");
      reqModelInstsMatchCur        (thePattern, "getSliceDense (thePattern)");
      
      return curModelInst ().getTupleMgr (this).getSliceDense (thePattern);
      }
   
////////////////////////////////////////////////////////////////////////////////
}
@


1.38
log
@ban ==> rej
@
text
@d483 3
a485 3
 * @@return                          The Tuple of theTupleCat in the current
 *                                  ModelInstance whose coordinates match
 *                                  theCoords, if any; otherwise null.
@


1.37
log
@bar ==> ban
@
text
@d66 1
a66 1
   private void banNegDimenIdx (String theName, int theIdx)
d87 1
a87 1
   private void banDimenIdxTooHigh (String theName, int theIdx)
d239 1
a239 1
   private void banDupCoords (Item[] theCoordArr)
d428 4
a431 4
      banNull              (theName,    "theName");
      banNull              (theItemCat, "theItemCat");
      banNegDimenIdx       (theName,    theIdx);
      banDimenIdxTooHigh   (theName,    theIdx);
d433 1
a433 1
      banFrozenScheme (
d435 1
a435 1
      getModelScheme ().banDupName (
d467 1
a467 1
      banNullArray                 (theCoords, "theCoords");
d473 1
a473 1
      banDupCoords                 (theCoords);
d501 1
a501 1
      banNullArray                 (theCoords,  "theCoords");
d547 1
a547 1
      banNull                      (thePattern, "thePattern");
d594 1
a594 1
      banNull                      (thePattern, "thePattern");
@


1.36
log
@Simplified toString.
@
text
@d66 1
a66 1
   private void barNegDimenIdx (String theName, int theIdx)
d87 1
a87 1
   private void barDimenIdxTooHigh (String theName, int theIdx)
d239 1
a239 1
   private void barDupCoords (Item[] theCoordArr)
d428 4
a431 4
      barNull              (theName,    "theName");
      barNull              (theItemCat, "theItemCat");
      barNegDimenIdx       (theName,    theIdx);
      barDimenIdxTooHigh   (theName,    theIdx);
d433 1
a433 1
      barFrozenScheme (
d435 1
a435 1
      getModelScheme ().barDupName (
d467 1
a467 1
      barNullArray                 (theCoords, "theCoords");
d473 1
a473 1
      barDupCoords                 (theCoords);
d501 1
a501 1
      barNullArray                 (theCoords,  "theCoords");
d547 1
a547 1
      barNull                      (thePattern, "thePattern");
d594 1
a594 1
      barNull                      (thePattern, "thePattern");
@


1.35
log
@ValueByPeriod
@
text
@d397 1
a397 1
      return concatenation ("TupleCategory ", getName ());
@


1.34
log
@Class PeriodTrait
@
text
@d302 1
a302 1
      nCats = getModelScheme ().getCategories ().size ();
d394 1
a394 1
 */      @@Override
@


1.33
log
@Some renaming.
@
text
@d397 1
a397 1
      return concatenation ("TupleCategory \"", getName (), "\"");
d418 3
@


1.32
log
@Scheme ==> ModelScheme
@
text
@d66 1
a66 1
   private void prohibitNegDimenIdx (String theName, int theIdx)
d87 1
a87 1
   private void prohibitDimenIdxTooHigh (String theName, int theIdx)
d110 1
a110 1
   private void requireCatMatchesDimen (ItemCategory <?> theItemCat, int theIdx)
d201 1
a201 1
   private void requireModelInstsMatchCur (Item[] theCoordArr, String signature)
d239 1
a239 1
   private void prohibitDupCoords (Item[] theCoordArr)
d262 1
a262 1
         ModelScheme        theModelScheme,
d266 1
a266 1
      super (theModelScheme, theName);
d425 6
a430 6
      prohibitNull            (theName,    "theName");
      prohibitNull            (theItemCat, "theItemCat");
      prohibitNegDimenIdx     (theName,    theIdx);
      prohibitDimenIdxTooHigh (theName,    theIdx);
      requireCatMatchesDimen  (theItemCat, theIdx);
      prohibitFrozenModelScheme (
d432 1
a432 1
      getModelScheme ().prohibitDupName (
d464 7
a470 7
      prohibitNullArray                (theCoords, "theCoords");
      requireCurModelInst              ();
      requireSchemeMatchesCurModelInst ();
      checkNCoords                     (theCoords, "newTuple (theCoords)");
      checkCategories                  (theCoords, "newTuple (theCoords)");
      requireModelInstsMatchCur        (theCoords, "newTuple (theCoords)");
      prohibitDupCoords                (theCoords);
d498 6
a503 6
      prohibitNullArray                (theCoords,  "theCoords");
      requireCurModelInst              ();
      requireSchemeMatchesCurModelInst ();
      checkNCoords                     (theCoords, "get (theCoords)");
      checkCategories                  (theCoords, "get (theCoords)");
      requireModelInstsMatchCur        (theCoords, "get (theCoords)");
d544 7
a550 7
      prohibitNull                     (thePattern, "thePattern");
      requireCurModelInst              ();
      requireSchemeMatchesCurModelInst ();
      
      checkNCoords              (thePattern, "getSliceSparse (thePattern)");
      checkCategories           (thePattern, "getSliceSparse (thePattern)");
      requireModelInstsMatchCur (thePattern, "getSliceSparse (thePattern)");
d591 7
a597 7
      prohibitNull                     (thePattern, "thePattern");
      requireCurModelInst              ();
      requireSchemeMatchesCurModelInst ();
      
      checkNCoords              (thePattern, "getSliceDense (thePattern)");
      checkCategories           (thePattern, "getSliceDense (thePattern)");
      requireModelInstsMatchCur (thePattern, "getSliceDense (thePattern)");
@


1.31
log
@Embodiment ==> ModelInstance
@
text
@d20 1
a20 1
 * Scheme.newTupleCategory (theName, theDimens).
d41 2
a42 2
 * This field is null until the Scheme for this TupleCategory is frozen.
 * After the Scheme for this TupleCategory is frozen:
d262 1
a262 1
         Scheme             theScheme,
d266 1
a266 1
      super (theScheme, theName);
d302 1
a302 1
      nCats = getScheme ().getCategories ().size ();
d378 1
a378 1
 * @@throws NullPointerException If the Scheme for this TupleCategory is not
d416 1
a416 1
 * @@throws IllegalStateException    If the Scheme of this TupleCategory is
d430 1
a430 1
      prohibitFrozenScheme    (
d432 1
a432 1
      getScheme ().prohibitDupName (
d449 3
a451 3
 * @@throws IllegalStateException    If the Scheme of this TupleCategory does
 *                                  not match the Scheme of the current
 *                                  ModelInstance
d486 3
a488 3
 * @@throws IllegalStateException    If the Scheme of this TupleCategory does
 *                                  not match the Scheme of the current
 *                                  ModelInstance
d532 3
a534 3
 * @@throws IllegalStateException    If the Scheme of this TupleCategory does
 *                                  not match the Scheme of the current
 *                                  ModelInstance
d579 3
a581 3
 * @@throws IllegalStateException    If the Scheme of this TupleCategory does
 *                                  not match the Scheme of the current
 *                                  ModelInstance
@


1.30
log
@Efficient String concatenation.
@
text
@d198 1
a198 1
 * Embodiment.
d201 1
a201 1
   private void requireEmbsMatchCur (Item[] theCoordArr, String signature)
d203 2
a204 2
      int        theIdx;
      Embodiment theEmb;
d211 1
a211 1
         theEmb = theCoordArr[theIdx].getEmbodiment ();
d213 1
a213 1
         if (theEmb != curEmbodiment ())
d219 1
a219 1
                + "   belong to the current Embodiment.\n"
d221 10
a230 6
                + "      TupleCategory:         "   + getName ()          + "\n"
                + "      Coordinate Index:      "   + theIdx              + "\n"
                + "      Coordinate:            "   + theCoordArr[theIdx] + "\n"
                + "      Coordinate Embodiment: \"" + theEmb.getName () + "\"\n"
                + "      Current    Embodiment: \""
                +           curEmbodiment ().getName () + "\"\n");
d236 1
a236 1
 * Tuple of this TupleCategory in the current Embodiment.
d243 1
a243 1
      theTuple = curEmbodiment ().getTupleMgr (this).getTuple (theCoordArr);
d252 1
a252 1
             + "   current Embodiment.\n"
d357 1
a357 1
   ItemMgr <?> newItemMgr (Embodiment theEmb)
d359 1
a359 1
      return new TupleMgr (this, theEmb);
d441 1
a441 1
 * Constructs a new Tuple for this TupleCategory in the current Embodiment.
d448 1
a448 1
 * @@throws IllegalStateException    If the current Embodiment is null
d451 1
a451 1
 *                                  Embodiment
d456 1
a456 1
 *                                  current Embodiment
d459 1
a459 1
 *                                  in the current Embodiment
d464 7
a470 7
      prohibitNullArray          (theCoords, "theCoords");
      requireCurEmbodiment       ();
      requireSchemeMatchesCurEmb ();
      checkNCoords               (theCoords, "newTuple (theCoords)");
      checkCategories            (theCoords, "newTuple (theCoords)");
      requireEmbsMatchCur        (theCoords, "newTuple (theCoords)");
      prohibitDupCoords          (theCoords);
d472 1
a472 1
      return new Tuple (this, curEmbodiment (), theCoords);
d481 1
a481 1
 *                                  Embodiment whose coordinates match
d485 1
a485 1
 * @@throws IllegalStateException    If the current Embodiment is null
d488 1
a488 1
 *                                  Embodiment
d493 1
a493 1
 *                                  current Embodiment
d498 6
a503 6
      prohibitNullArray          (theCoords,  "theCoords");
      requireCurEmbodiment       ();
      requireSchemeMatchesCurEmb ();
      checkNCoords               (theCoords, "get (theCoords)");
      checkCategories            (theCoords, "get (theCoords)");
      requireEmbsMatchCur        (theCoords, "get (theCoords)");
d505 1
a505 1
      return curEmbodiment ().getTupleMgr (this).getTuple (theCoords);
d510 1
a510 1
 * current Embodiment whose coordinates match a "pattern". The pattern is a
d514 1
a514 1
 * Embodiment and for each coordinate of the Tuple, either the coordinate
d520 1
a520 1
 * TupleCategory in the current Embodiment and adding to the slice each
d531 1
a531 1
 * @@throws IllegalStateException    If the current Embodiment is null
d534 1
a534 1
 *                                  Embodiment
d539 1
a539 1
 *                                  current Embodiment
d544 7
a550 6
      prohibitNull               (thePattern, "thePattern");
      requireCurEmbodiment       ();
      requireSchemeMatchesCurEmb ();
      checkNCoords               (thePattern, "getSliceSparse (thePattern)");
      checkCategories            (thePattern, "getSliceSparse (thePattern)");
      requireEmbsMatchCur        (thePattern, "getSliceSparse (thePattern)");
d552 1
a552 1
      return curEmbodiment ().getTupleMgr (this).getSliceSparse (thePattern);
d557 1
a557 1
 * current Embodiment whose coordinates match a "pattern". The pattern is a
d561 1
a561 1
 * Embodiment and for each coordinate of the Tuple, either the coordinate
d578 1
a578 1
 * @@throws IllegalStateException    If the current Embodiment is null
d581 1
a581 1
 *                                  Embodiment
d586 1
a586 1
 *                                  current Embodiment
d591 7
a597 6
      prohibitNull               (thePattern, "thePattern");
      requireCurEmbodiment       ();
      requireSchemeMatchesCurEmb ();
      checkNCoords               (thePattern, "getSliceDense (thePattern)");
      checkCategories            (thePattern, "getSliceDense (thePattern)");
      requireEmbsMatchCur        (thePattern, "getSliceDense (thePattern)");
d599 1
a599 2
      return
         curEmbodiment ().getTupleMgr (this).getSliceDense (thePattern);
@


1.29
log
@newOperation
@
text
@d393 1
a393 1
      return "TupleCategory \"" + getName () + "\"";
@


1.28
log
@Category ==> ItemCategory
@
text
@d329 1
a329 1
      +  "TupleCategory \"%s\":%n%n",
@


1.27
log
@Checking for duplicate schematic names.
@
text
@d17 1
a17 1
 * A TupleCategory is an Category of Tuples.<br><br>
d23 1
a23 1
public final class TupleCategory extends Category <Tuple>
d38 1
a38 1
   private final List <Category <?>> myDimensions;
d43 2
a44 2
 *    uniqueDimenIndexArr[theCat.getCatIndex ()] =
 *       The dimension index of theCat in this TupleCategory,
d74 2
a75 1
             + "   TupleCategory.newDimensionID (theName, theCat, theIdx),\n"
d95 2
a96 1
             + "   TupleCategory.newDimensionID (theName, theCat, theIdx),\n"
d107 1
a107 1
 * Verifies that theCat matches the dimension for theIdx.
d110 1
a110 1
   private void requireCatMatchesDimen (Category <?> theCat, int theIdx)
d112 1
a112 1
      Category<?> theDimen;
d116 1
a116 1
      if (theCat != theDimen)
d122 3
a124 2
             + "   TupleCategory.newDimensionID (theName, theCat, theIdx),\n"
             + "   where theCat does not match the dimension of the\n"
d127 4
a130 4
             + "      TupleCategory:        " + getName ()          + "\n"
             + "      theCat:               " + theCat.getName ()   + "\n"
             + "      theIdx:               " + theIdx              + "\n"
             + "      Dimension for theIdx: " + theDimen.getName () + "\n");
d165 3
a167 3
      int          theIdx;
      Category <?> theCat;
      Category <?> theDimen;
d174 1
a174 1
         theCat   = theCoordArr[theIdx].getCategory ();
d176 1
a176 1
         theDimen = myDimensions.get (theIdx);
d178 1
a178 1
         if (theCat != theDimen)
d183 1
a183 1
                + "   where the Category of at least one of the\n"
d187 5
a191 4
                + "      TupleCategory:       " +          getName () + "\n"
                + "      Dimension Index:     " + theIdx              + "\n"
                + "      Dimension:           " + theDimen.getName () + "\n"
                + "      Coordinate Category: " + theCat  .getName () + "\n"
d258 3
a260 3
         Scheme         theScheme,
         String         theName,
         Category <?>[] theDimenArr)
d264 1
a264 1
      ArrayList <Category <?>> theDimens;
d266 1
a266 1
      theDimens = new ArrayList <Category <?>> (theDimenArr.length);
d296 1
a296 1
      int theCatIdx;
d306 1
a306 1
         theCatIdx = myDimensions.get (theIdx).getIndex ();
d308 1
a308 1
         if (uniqueDimenIndexArr[theCatIdx] == -1)
d310 1
a310 1
            uniqueDimenIndexArr[theCatIdx] = theIdx;
d314 1
a314 1
            uniqueDimenIndexArr[theCatIdx] = -2;
d363 1
a363 1
   List <Category <?>> getDimensions ()
d369 1
a369 1
 * @@return The unique dimension index of theCat in this TupleCatagory, if
d378 1
a378 1
   int uniqueDimenIndex (Category <?> theCat)
d380 1
a380 1
      return uniqueDimenIndexArr[theCat.getIndex ()];
d401 5
a405 5
 * @@param <I>     The Item type of the DimensionID to be constructed
 * @@param theName The name of the DimensionID to be constructed
 * @@param theCat  The Category of the dimension to be identified
 * @@param theIdx  The index of the dimension to be identified
 * @@return        The new DimensionID {@@literal<I>}
d410 2
a411 2
 * @@throws IllegalArgumentException If theCat does not match the dimension of
 *                                  this TupleCategory indexed by theIdx.
d417 9
a425 9
         String       theName,
         Category <I> theCat,
         int          theIdx)
      {
      prohibitNull            (theName, "theName");
      prohibitNull            (theCat,  "theCat");
      prohibitNegDimenIdx     (theName, theIdx);
      prohibitDimenIdxTooHigh (theName, theIdx);
      requireCatMatchesDimen  (theCat, theIdx);
d427 1
a427 1
         "TupleCategory.newDimensionID (theName, theCat, theIdx)");
d430 1
a430 1
         "TupleCategory.newDimensionID (theName, theCat, theIdx)");
@


1.26
log
@Signatures with argument names.
@
text
@d424 3
@


1.25
log
@Printing of DimensionIDs.
@
text
@d20 1
a20 1
 * Scheme.newTupleCategory (String, Category <?>...).
d456 3
a458 3
      checkNCoords               (theCoords, "newTuple (Item...)");
      checkCategories            (theCoords, "newTuple (Item...)");
      requireEmbsMatchCur        (theCoords, "newTuple (Item...)");
d490 3
a492 3
      checkNCoords               (theCoords, "get (Item...)");
      checkCategories            (theCoords, "get (Item...)");
      requireEmbsMatchCur        (theCoords, "get (Item...)");
d536 3
a538 3
      checkNCoords               (thePattern, "getSliceSparse (Item...)");
      checkCategories            (thePattern, "getSliceSparse (Item...)");
      requireEmbsMatchCur        (thePattern, "getSliceSparse (Item...)");
d582 3
a584 3
      checkNCoords               (thePattern, "getSliceDense (Item...)");
      checkCategories            (thePattern, "getSliceDense (Item...)");
      requireEmbsMatchCur        (thePattern, "getSliceDense (Item...)");
@


1.24
log
@Error tests for newDimensionID.
@
text
@d52 6
d266 3
a268 1
      myDimensions = Collections.unmodifiableList (theDimens);
d276 9
d325 1
a325 1
      +  "TupleCategory \"%s\":%n",
d334 8
@


1.23
log
@Class DimensionID <I>
@
text
@d60 1
a60 1
   private void prohibitNegDimenIdx (int theIdx)
d67 2
a68 1
             + "   Call to TupleCategory.newDimensionID (theCat, theIdx),\n"
d71 2
a72 2
             + "      TupleCategory: " + getName () + "\n"
             + "      theIdx:        " + theIdx       + "\n");
d80 1
a80 1
   private void prohibitDimenIdxTooHigh (int theIdx)
d87 2
a88 1
             + "   Call to TupleCategory.newDimensionID (theCat, theIdx),\n"
d91 4
a94 3
             + "      TupleCategory:   " + getName ()           + "\n"
             + "      # of Dimensions: " + myDimensions.size () + "\n"
             + "      theIdx:          " + theIdx               + "\n");
d113 2
a114 1
             + "   Call to TupleCategory.newDimensionID (theCat, theIdx),\n"
d369 1
a369 1
 * Constructs a new DimensionID {@@literal<I>} that will be associated with this
d372 5
a376 4
 * @@param <I>    The Item type of the DimensionID to be constructed
 * @@param theCat The Category of the dimension to be identified
 * @@param theIdx The index of the dimension to be identified
 * @@return       The new DimensionID {@@literal<I>}
d378 1
a378 1
 * @@throws NullPointerException     If any theCat is null
d388 1
d392 4
a395 3
      prohibitNull            (theCat, "theCat");
      prohibitNegDimenIdx     (theIdx);
      prohibitDimenIdxTooHigh (theIdx);
d397 2
a398 1
      prohibitFrozenScheme    ("TupleCategory.newDimensionID (theCat, theIdx)");
d400 1
a400 1
      return new DimensionID <I> (this, theIdx);
@


1.22
log
@Class DimensionID.
@
text
@d57 65
d365 32
@


1.21
log
@Compound ==> Tuple
@
text
@d44 2
a45 2
 *       The unique dimension index of theCat in this TupleCategory,
 *          if there is exactly one<br>
@


1.20
log
@Tuple ==> Compound
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d6 1
a6 1
package       com.ibm.witm;
d25 3
a27 3
//==============================================================================
// Public
//==============================================================================
d30 90
a119 1
 * {@@inheritDoc}
d122 1
a122 1
   @@Override public String toString ()
d124 25
a148 1
      return "TupleCategory \"" + getName () + "\"";
a150 4
//==============================================================================
// Package Internal
//==============================================================================

d152 2
a153 1
 * Constructor
d156 26
a181 1
   TupleCategory (Scheme theScheme, String theName, Category <?>[] theDimenArr)
d194 4
d201 2
a202 2
 */
   @@Override void freeze ()
d232 2
a233 11
 */
   @@Override ItemMgr <?> newItemMgr ()
      {
      return new TupleMgr ();
      }
   
/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */
   @@Override void printConcrete (PrintStream theStream)
d246 1
a246 1
            theIdx + 1,
d252 9
d285 3
a287 3
//==============================================================================
// Private
//==============================================================================
d290 109
a398 6
 * The "dimensions" of this TupleCategory<br>
 * For each Tuple in this TupleCategory, the number of coordinates of the Tuple
 * must match myDimensions.size () and
 * for i = 0, ... myDimensions.size () - 1, coordinate #i of the Tuple must
 * belong to myDimensions.get (i).<br>
 * This List is an unmodifiable view of an ArrayList.
d401 12
a412 2
   private final List <Category <?>> myDimensions;

d414 31
a444 7
 * This field is null until the Scheme for this TupleCategory is frozen.
 * After the Scheme for this TupleCategory is frozen:
 *    uniqueDimenIndexArr[theCat.getCatIndex ()] =
 *       The unique dimension index of theCat in this TupleCategory,
 *          if there is exactly one<br>
 *       -1, if there is no matching dimension.<br>
 *       -2, if there is more than one matching dimension.
d447 14
a460 3
   private int[] uniqueDimenIndexArr = null;

//==============================================================================
@


1.19
log
@Doc comments
@
text
@@


1.18
log
@Revised comments, etc.
@
text
@d17 4
a20 1
 * A TupleCategory is an Category of Tuples.
@


1.17
log
@Tuple.get (Category, int)
@
text
@d26 3
a28 3
/* *****************************************************************************
 * Doc comment inherited.
 * *****************************************************************************
d87 3
a89 3
/* *****************************************************************************
 * Doc comment inherited.
 * *****************************************************************************
d96 3
a98 3
/* *****************************************************************************
 * Doc comment inherited.
 * *****************************************************************************
@


1.16
log
@1-based indexing of dimensions/coordinates
@
text
@d112 2
a113 3
            "   Coordinate Category #%d:%n"
          + "      %s%n",
            theIdx,
@


1.15
log
@Category.newItemMgr.
@
text
@d49 1
a49 1
      theDimens      = new ArrayList <Category <?>> (theDimenArr.length);
d53 1
a53 1
      myDimensions   = Collections.unmodifiableList (theDimens);
@


1.14
log
@myPrimitiveCategories and myTupleCategories ==> myCategories
@
text
@d91 9
@


1.13
log
@Replaced ItemCategory with Category <?>.
@
text
@d57 1
a57 2
 * Performs actions to be taken when the Scheme is being frozen.<br>
 * Specifically, sets up uniqueDimenIndexArr.
d60 1
a60 1
   void freeze ()
d66 1
a66 2
      nCats = getScheme ().getPrimitiveCategories ().size ()
            + getScheme ().getTupleCategories     ().size ();
d87 3
a89 3
/*******************************************************************************
 * Prints this TupleCategory to theStream.
 *******************************************************************************
d91 1
a91 1
   void print (PrintStream theStream)
a107 2
      
      printProperties (theStream);
@


1.12
log
@ItemMgr <I>
@
text
@d17 1
a17 1
 * A TupleCategory is an ItemCategory for Tuples.
d43 1
a43 1
   TupleCategory (Scheme theScheme, String theName, ItemCategory[] theDimenArr)
d47 1
a47 1
      ArrayList <ItemCategory> theDimens;
d49 1
a49 1
      theDimens      = new ArrayList <ItemCategory> (theDimenArr.length);
d65 1
a65 1
      int theItemCatIdx;
d76 1
a76 1
         theItemCatIdx = myDimensions.get (theIdx).getIndex ();
d78 1
a78 1
         if (uniqueDimenIndexArr[theItemCatIdx] == -1)
d80 1
a80 1
            uniqueDimenIndexArr[theItemCatIdx] = theIdx;
d84 1
a84 1
            uniqueDimenIndexArr[theItemCatIdx] = -2;
d119 1
a119 1
   List <ItemCategory> getDimensions ()
d125 1
a125 1
 * @@return The unique dimension index of theItemCat in this TupleCatagory, if
d127 2
a128 2
 *         -1, if there is no matching dimension.<br>
 *         -2, if there is more than one matching dimension.
d134 1
a134 1
   int uniqueDimenIndex (ItemCategory theItemCat)
d136 1
a136 1
      return uniqueDimenIndexArr[theItemCat.getIndex ()];
d152 1
a152 1
   private final List <ItemCategory> myDimensions;
d157 2
a158 2
 *    uniqueDimenIndexArr[theItemCat.getItemCatIndex ()] =
 *       The unique dimension index of theItemCat in this TupleCatagory,
@


1.11
log
@Added Category <I extends Item>
@
text
@a53 2
      
      myIndex        = theScheme.getTupleCategories ().size ();
d76 1
a76 1
         theItemCatIdx = myDimensions.get (theIdx).getItemCatIndex ();
d136 1
a136 10
      return uniqueDimenIndexArr[theItemCat.getItemCatIndex ()];
      }

/*******************************************************************************
 * @@return A unique index for this TupleCategory.
 *******************************************************************************
 */
   int getIndex ()
      {
      return myIndex;
a165 7
/*******************************************************************************
 * A unique index for this TupleCategory.<br>
 * # of TupleCategories in the Scheme that were constructed before this one.
 *******************************************************************************
 */
   private final int myIndex;

@


1.10
log
@Tuple.get (ItemCategory)
@
text
@d20 1
a20 1
public final class TupleCategory extends ItemCategory
@


1.9
log
@Dimension index.
@
text
@d132 2
a133 1
 * @@throws NullPointerException If the Scheme is not frozen.
d166 7
a172 1
 * @@see uniqueDimenIndex
@


1.8
log
@Moved newTupleCategory from TupleCategory to Scheme.
@
text
@d12 1
d59 33
d127 14
d165 6
@


1.7
log
@Moved getAll (TupleCategory).
@
text
@a24 38
/*******************************************************************************
 * Factory method:<br>
 * Constructs a new TupleCategory.
 * 
 * @@param  theName                  The name of the TupleCategory to be
 *                                  constructed
 * @@param  theDimens                The ItemCategories that are to be the
 *                                  dimensions of the TupleCategory    
 * @@return                          The new TupleCategory
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If no ItemCategories are given
 * @@throws IllegalArgumentException The ItemCategories do all belong to the same
 *                                  Scheme
 * @@throws IllegalStateException    If the Scheme of the ItemCategories is
 *                                  frozen
 *******************************************************************************
 */
   public static TupleCategory newTupleCategory (
         String          theName,
         ItemCategory... theDimens)
      {
      Scheme theScheme;
      
      prohibitNull           (theName,   "theName");
      prohibitNullArray      (theDimens, "theDimens");
      
      requireAtLeast1ItemCat (theName,   theDimens);
      requireSchemesMatch    (theName,   theDimens);
   
      theScheme = theDimens[0].getScheme ();
      
      theScheme.prohibitDupTupleCategoryName (theName);
      
      theScheme.prohibitFrozen ();
      
      return new TupleCategory (theScheme, theName, theDimens);
      }

d39 19
a105 82
 * Constructor
 *******************************************************************************
 */
   private TupleCategory (
         Scheme         theScheme,
         String         theName,
         ItemCategory[] theDimenArr)
      {
      super (theScheme, theName);
      
      ArrayList <ItemCategory> theDimens;
      
      theDimens      = new ArrayList <ItemCategory> (theDimenArr.length);
      
      Collections.addAll (theDimens, theDimenArr);
      
      myDimensions   = Collections.unmodifiableList (theDimens);
      
      myIndex        = theScheme.getTupleCategories ().size ();
      
      theScheme.store (this);
      }

/*******************************************************************************
 * Verifies that newTupleCategory (...) was called with at least one
 * ItemCategory.<br>
 * To be called by newTupleCategory.
 *******************************************************************************
 */
   private static void requireAtLeast1ItemCat (
         String         theName,
         ItemCategory[] theDimenArr)
      {
      if (theDimenArr.length == 0)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   TupleCategory.newTupleCategory (String, ItemCategory...)\n"
             + "   with no ItemCategories.\n"
             + "\n"
             + "      TupleCategory Name: \"" + theName + "\"\n");
         }
      }
   
/*******************************************************************************
 * Verifies that newTupleCategory (...) was called with ItemCategories whose
 * Schemes match.
 *******************************************************************************
 */
   private static void requireSchemesMatch (
         String         theName,
         ItemCategory[] theDimenArr)
      {
      Scheme theScheme;
      int    theIdx;
      
      theScheme = theDimenArr[0].getScheme ();
      
      for (theIdx = 1; theIdx < theDimenArr.length; theIdx ++)
         {
         if (theDimenArr[theIdx].getScheme () != theScheme)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   TupleCategory.newTupleCategory (String, ItemCategory...)"
                + "\n"
                + "   with ItemCategories whose Schemes do not match.\n"
                + "\n"
                + "      theName:      " + theName + "\n"
                + "      theDimens[0]: \"" + theDimenArr[0].getName () + "\", "
                +        "Scheme: \"" + theScheme.getName () + "\"\n"
                + "      theDimens[" + theIdx + "]: "
                +        "\"" + theDimenArr[theIdx].getName () + "\", "
                +        "Scheme: \"" + theDimenArr[theIdx].getName ()
                +        "\"\n");
         }
      }
   
/*******************************************************************************
@


1.6
log
@Renaming
@
text
@a62 20
/*******************************************************************************
 * Tuple List method
 * 
 * @@return An unmodifiable List of all of the Tuples of this TupleCategory
 *         in the current Implementation, listed in the order in which they were
 *         created.
 * 
 * @@throws IllegalStateException If the current Implementation is null
 * @@throws IllegalStateException If the Scheme of this TupleCategory does not
 *                               match the Scheme of the current Implementation
 *******************************************************************************
 */
   public List <Tuple> getAll ()
      {
      requireCurImplementation   ();
      requireSchemeMatchesCurImp ();
      
      return getTupleMgr ().getTuples ();
      }
   
a206 9
 * @@return The TupleMgr of the current Implementation for this TupleCategory.
 *******************************************************************************
 */
   private TupleMgr getTupleMgr ()
      {
      return curImplementation ().getTupleMgr (this);
      }
   
/*******************************************************************************
@


1.5
log
@Revised some messsages.
@
text
@d197 1
a197 1
         String          theName,
@


1.4
log
@Moved newTuple from TupleCategory to Implementation.
@
text
@d183 3
a185 2
             + "   Call to TupleCategory.newTupleCategory (...) with no\n"
             + "   ItemCategories.\n"
d212 3
a214 3
                + "   TupleCategory.newTupleCategory (theName, theDimens)\n"
                + "   with dimension ItemCategories whose Schemes do not\n"
                + "   match.\n"
@


1.3
log
@Type ==> Category
@
text
@d10 3
a12 2
import java.io.PrintStream;
import java.util.Arrays;
a63 30
 * Factory method:<br>
 * Constructs a new Tuple of this TupleCategory
 *
 * @@param theCoords                 The Items that are to be the coordinates
 *                                  of the Tuple
 * @@return                          The new Tuple
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategories of the Items do not
 *                                  match the corresponding dimension
 *                                  ItemCategories of this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  same Implementation
 *******************************************************************************
 */
   public Tuple newTuple (Item... theCoords)
      {
      Implementation theImp;
      
      prohibitNullArray   (theCoords, "theCoords");
      
      checkItemCategories (theCoords);
   
      requireImpsMatch    (theCoords);
      
      theImp = theCoords[0].getImplementation ();

      return new Tuple (this, theImp, theCoords);
      }
   
/*******************************************************************************
d109 1
a109 1
      for (theIdx = 0; theIdx < myDimensionArr.length; theIdx ++)
d115 1
a115 1
            myDimensionArr[theIdx].getName ());
d122 10
d155 7
a161 1
      myDimensionArr = Arrays.copyOf (theDimenArr, theDimenArr.length);
a225 76
 * Verifies that the ItemCategories of the Items passed to newTuple match
 * myDimensionArr.
 *******************************************************************************
 */
   private void checkItemCategories (Item[] theCoordArr)
      {
      int theIdx;
      
      if (theCoordArr.length != myDimensionArr.length)
         {
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to theTupleCategory.newTuple (theCoords) where the\n"
             + "   number of coordinates does not match the number of\n"
             + "   dimensions in theTupleCategory.\n"
             + "\n"
             + "      TupleCategory: " + getName ()            + "\n"
             + "      # Coordinates: " + theCoordArr   .length + "\n"
             + "      # Dimensions:  " + myDimensionArr.length + "\n");         
         }
      
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx].getItemCategory () != myDimensionArr[theIdx])
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to theTupleCategory.newTuple (theCoords) where\n"
                + "   the ItemCategory of one of the coordinates does not\n"
                + "   match the corresponding dimension of theTupleCategory.\n"
                + "\n"
                + "      TupleCategory:           " + getName () + "\n"
                + "      Coordinate Index:        " + theIdx     + "\n"
                + "      Coordinate ItemCategory: "
                +        theCoordArr[theIdx].getItemCategory ().getName ()
                + "\n"
                + "      TupleCategory Dimension: "
                +        myDimensionArr[theIdx].getName ()       + "\n");
            }
         }
      }
   
/*******************************************************************************
 * Verifies the the Items passed to newTuple all belong to the same
 * Implementation.
 *******************************************************************************
 */
   private void requireImpsMatch (Item[] theCoordArr)
      {
      int theIdx;
      
      for (theIdx = 1; theIdx < theCoordArr.length; theIdx ++)
         {
         if (   theCoordArr[theIdx].getImplementation ()
             != theCoordArr[0]     .getImplementation ())
            {
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to theTupleCategory.newTuple (theCoords) where the\n"
                + "   coordinates do not all belong to the same"
                +	"   Implementation.\n"
                + "\n"
                + "      TupleCategory:                   " + getName ()  + "\n"
                + "      Implementation of Coordinate #0: \""
                +        theCoordArr[0].getImplementation ().getName () + "\"\n"
                + "      Implementation of Coordinate #" + theIdx + ": \""
                +        theCoordArr[theIdx].getImplementation ().getName ()
                +        "\"\n");
            }
         }
      }
   
/*******************************************************************************
d237 4
a240 3
 * must match myDimensionArr.length and
 * for i = 0, ... myDimensionArr.length - 1, coordinate #i of the Tuple must
 * belong to myDimensionArr[i].
d243 1
a243 1
   private final ItemCategory[] myDimensionArr;
@


1.2
log
@Category ==> Type
@
text
@d12 1
d15 1
a15 1
 * A TupleCategory is an ElementCategory for Tuples.
d18 1
a18 1
public final class TupleCategory extends ElementCategory
d30 2
a31 2
 * @@param  theElCats                The ElementCategories that are to be the
 *                                  coordinates of the TupleCategory    
d34 4
a37 4
 * @@throws IllegalArgumentException If no ElementCategories are given
 * @@throws IllegalArgumentException The ElementCategories do all belong to the
 *                                  same Scheme
 * @@throws IllegalStateException    If the Scheme of the ElementCategories is
d42 2
a43 2
         String             theName,
         ElementCategory... theElCats)
a44 1
      int    theIdx;
d47 2
a48 6
      prohibitNull (theName,   "theName");
      prohibitNull (theElCats, "theElCats");
      
      for (theIdx = 0; theIdx < theElCats.length; theIdx++)
         if (theElCats[theIdx] == null)
            prohibitNull (theElCats[theIdx], "theElCats[" + theIdx + "]");
d50 2
a51 2
      requireAtLeast1ElCat (theName, theElCats);
      requireSchemesMatch  (theName, theElCats);
d53 1
a53 1
      theScheme = theElCats[0].getScheme ();
d55 1
a55 1
      theScheme.prohibitDupTupleCatName (theName);
d59 1
a59 1
      return theScheme.newTupleCategory (theName, theElCats);
d62 13
a74 2
/* *****************************************************************************
 * The doc comment is inherited
d77 1
a77 1
   @@Override public String toString ()
d79 11
a89 1
      return "TupleCategory \"" + getName () + "\"";
a91 4
//==============================================================================
// Package Internal
//==============================================================================

d93 9
a101 1
 * To be called by theScheme.newTupleCategory (...).
d104 1
a104 4
   TupleCategory (
         Scheme            theScheme,
         String            theName,
         ElementCategory[] theElCatArr)
d106 2
a107 1
      super (theScheme, theName);
d109 10
a118 3
      myCoordinateArr = Arrays.copyOf (theElCatArr, theElCatArr.length);
      
      myIndex         = theScheme.getTupleCategories ().size ();
d120 4
d138 1
a138 1
      for (theIdx = 0; theIdx < myCoordinateArr.length; theIdx++)
d144 1
a144 1
            myCoordinateArr[theIdx].getName ());
d164 20
a183 2
 * Verifies that newTupleCategory (...) was called with at least 1
 * ElementCategory.<br>
d187 3
a189 3
   private static void requireAtLeast1ElCat (
         String            theName,
         ElementCategory[] theElCatArr)
d191 1
a191 1
      if (theElCatArr.length == 0)
d197 1
a197 1
             + "   ElementCategories.\n"
d204 2
a205 3
 * Verifies that newTupleCategory (...) was called with ElementCategories
 * whose Schemes match.<br>
 * To be called by newTupleCategory.
d209 2
a210 2
         String            theName,
         ElementCategory[] theElCatArr)
d215 31
a245 1
      theScheme = theElCatArr[0].getScheme ();
d247 1
a247 1
      for (theIdx = 1; theIdx < theElCatArr.length; theIdx++)
a248 1
         if (theElCatArr[theIdx].getScheme () != theScheme)
d252 3
a254 2
             + "   Call to TupleCategory.newTupleCategory (...) with\n"
             + "   ElementCategories whose Schemes do not match.\n"
d256 55
a310 5
             + "      theElCats[0]: \"" + theElCatArr[0].getName () + "\", "
             +        "Scheme: \"" + theScheme.getName () + "\"\n"
             + "      theElCats[" + theIdx + "]: "
             +        "\"" + theElCatArr[theIdx].getName () + "\", "
             +        "Scheme: \"" + theElCatArr[theIdx].getName () + "\"\n");
d315 14
a328 5
 * The coordinate Categories of this TupleCategory<br>
 * For each Tuple in this TupleCategory, the number of coordinates of the
 * Tuple must match myCoordinateArr.length and
 * for i = 0, ... myCoordinateArr.length - 1, coordinate #i of the Tuple must
 * belong to myCoordinateArr[i].
d331 1
a331 1
   private final ElementCategory[] myCoordinateArr;
@


1.1
log
@Compound ==> Tuple
@
text
@@


head	1.54;
access;
symbols;
locks; strict;
comment	@# @;


1.54
date	2011.07.05.21.15.03;	author rjw;	state dead;
branches;
next	1.53;

1.53
date	2011.07.01.22.30.00;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.01.22.12.53;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.01.21.37.30;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.01.21.17.41;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.01.20.57.49;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.01.20.44.49;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.01.20.17.34;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.01.18.51.33;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.01.16.24.30;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.01.15.56.22;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.01.14.15.33;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.30.23.43.47;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.30.22.03.38;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.29.15.53.10;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.29.15.31.36;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.29.14.22.26;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.24.20.29.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.24.16.42.08;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.23.22.52.04;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.22.22.09.43;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.22.17.52.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.22.15.07.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.22.14.08.07;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.21.22.18.03;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.20.17.48.36;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.20.16.07.44;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.17.22.09.06;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.17.18.23.02;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.16.23.36.12;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.10.19.37.18;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.09.22.11.54;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.09.18.19.21;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.09.18.09.21;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.08.23.43.46;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.08.23.36.38;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.08.22.40.10;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.08.20.54.57;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.08.20.13.56;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.07.23.38.50;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.07.22.57.43;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.07.22.05.16;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.07.21.16.28;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.07.20.56.01;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.07.20.14.10;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.07.19.47.01;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.07.18.37.06;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.06.20.33.28;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.06.16.39.05;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.03.23.47.45;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.03.23.15.50;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.03.22.48.03;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.03.22.23.43;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.31.19.26.18;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Implementation ==> Embodiment
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M Source File Implementation.java.
////////////////////////////////////////////////////////////////////////////////

package       com.ibm.witm;

/*******************************************************************************
 * An Implementation is the central object representing a concrete
 * implementation of a WIT model, i.e., a WIT model as populated with specific
 * data.<br><br>
 *
 * The factory method for this class is
 * Implementation.newImplementation (Scheme, String).
 *******************************************************************************
 */
public final class Implementation
{
////////////////////////////////////////////////////////////////////////////////
// Private Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * current is the current Implementation that will be used by various WIT-M
 * methods, if any; otherwise null.
 *******************************************************************************
 */
   private static Implementation current = null;
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The Scheme implemented by this Implementation
 *******************************************************************************
 */
   private final Scheme myScheme;
   
/*******************************************************************************
 * The name of this Implementation
 *******************************************************************************
 */
   private final String myName;
   
/*******************************************************************************
 * myItemMgrArr[theCat.getIndex ()] is the ItemMgr for theCat in this
 * Implementation.
 *******************************************************************************
 */
   private final ItemMgr <?> [] myItemMgrArr;

/*******************************************************************************
 * The global Primitive for this Implementation.
 *******************************************************************************
 */
   private final Primitive myGlobalPrimitive;
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * @@return The array of ItemMgrs to which myItemMgrArr is to be set in the ctor.
 *******************************************************************************
 */
   private ItemMgr <?>[] newItemMgrArr ()
      {
      int           nCats;
      ItemMgr <?>[] theItemMgrArr;
      int           theIdx;
      
      nCats         = myScheme.getCategories ().size ();
      
      theItemMgrArr = new ItemMgr <?>[nCats];

      for (Category <?> theCat: myScheme.getCategories ())
         {
         theIdx                = theCat.getIndex   ();
         
         theItemMgrArr[theIdx] = theCat.newItemMgr (this);
         }
      
      return theItemMgrArr;
      }
   
////////////////////////////////////////////////////////////////////////////////
// Package Internal Constructor
////////////////////////////////////////////////////////////////////////////////

   Implementation (Scheme theScheme, String theName)
      {
      PrimitiveCategory theGlobalCat;
      
      myScheme          = theScheme;
      myName            = theName;
      myItemMgrArr      = newItemMgrArr   ();

      theGlobalCat      = theScheme.getGlobalCategoryInternal ();
      
      myGlobalPrimitive = new Primitive (theGlobalCat, "Global", this);
      }

////////////////////////////////////////////////////////////////////////////////
// Package Internal Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * @@return the ItemMgr for theCat in this Implementation.
 *******************************************************************************
 */
                               @@SuppressWarnings("unchecked")
   <I extends Item> ItemMgr <I> getItemMgr (Category <I> theCat)
      {
      ItemMgr <?> theItemMgr;
      
      assert (theCat.getScheme () == myScheme);
         
      theItemMgr = myItemMgrArr[theCat.getIndex ()];
      
      return (ItemMgr <I>) theItemMgr;
      }
  
/*******************************************************************************
 * @@return the PrimitiveMgr for thePrimCat in this Implementation.
 *******************************************************************************
 */
   PrimitiveMgr getPrimitiveMgr (PrimitiveCategory thePrimCat)
      {
      return (PrimitiveMgr) getItemMgr (thePrimCat);
      }
   
/*******************************************************************************
 * @@return the CompoundMgr for theCompCat in this Implementation.
 *******************************************************************************
 */
   CompoundMgr getCompoundMgr (CompoundCategory theCompCat)
      {
      return (CompoundMgr) getItemMgr (theCompCat);
      }
   
////////////////////////////////////////////////////////////////////////////////
// Public Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Sets the current Implementation.<br>
 * 
 * @@param theImple The Implementation which is to become current.
 *                 (Null is allowed.)
 *******************************************************************************
 */
   public static void setCurrentImplementation (Implementation theImple)
      {
      current = theImple;
      }

/*******************************************************************************
 * @@return The current Implementation, if any; otherwise null.
 *******************************************************************************
 */
   public static Implementation getCurrentImplementation ()
      {
      return current;
      }

/*******************************************************************************
 * @@return The global Primitive for the current Implementation.
 *******************************************************************************
 */
   public static Primitive getGlobalPrimitive ()
      {
      return current.myGlobalPrimitive;
      }

////////////////////////////////////////////////////////////////////////////////
// Public Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * @@return The name of this Implementation
 *******************************************************************************
 */
   public String getName ()
      {
      return myName;
      }

/*******************************************************************************
 * @@return The Scheme of this Implementation
 *******************************************************************************
 */
   public Scheme getScheme ()
      {
      return myScheme;
      }

/*******************************************************************************
 * {@@inheritDoc}
 *******************************************************************************
 */     @@Override
   public String toString ()
      {
      return "Implementation \"" + myName + "\"";
      }
   
////////////////////////////////////////////////////////////////////////////////
// Static initialization block
//
// This block contains vacuous code that refers to class InputTable, so that
// class InputTable and the classes it refers to will be compiled whenever class
// Implementation is compiled.
////////////////////////////////////////////////////////////////////////////////

   static
      {
      if (false)
         InputTable.class.toString ();
      }
   
////////////////////////////////////////////////////////////////////////////////
}
@


1.53
log
@getGlobal Implementation == Property.
@
text
@@


1.52
log
@setGlobal Implementation ==> Property
@
text
@a7 2
import static com.ibm.witm.Utility.*;

a59 38
// Private Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Verifies that the current Implementation is not null.
 *******************************************************************************
 */
   private static void requireCurImplementation ()
      {
      if (current == null)
         {
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to a method that requires a current Implementation\n"
             + "   when the current Implementation is null.\n");
         }
      }

/*******************************************************************************
 * Verifies that theProp is global.
 *******************************************************************************
 */
   private static void requireGlobalCat (
         Property <?> theProp,
         String       signature)
      {
      if (! theProp.getCategory ().isGlobal ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Implementation." + signature + " with a non-global\n"
             + "   Property.\n"
             + "\n"
             + "      " + theProp + " of " + theProp.getCategory () + "\n");
      }
   
////////////////////////////////////////////////////////////////////////////////
a175 23
/*******************************************************************************
 * Retrieves the value of a global Property for this Item.
 * 
 * @@param <V>     The value type of the Property
 * @@param theProp The Property whose value is to be retrieved
 * @@return        A reference to the current value of the Property for this
 *                Item
 * 
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the Category of theProp is not the
 *                                  global Category.
 * @@throws IllegalStateException    If the current Implementation is null
 *******************************************************************************
 */
   public static <V> V getGlobal (Property <V> theProp)
      {
      prohibitNull             (theProp, "theProp");
      requireGlobalCat         (theProp, "get (Property <V>, V)");
      requireCurImplementation ();
      
      return current.myGlobalPrimitive.getValue (theProp);
      }

@


1.51
log
@getSlice Implementation ==> CompoundCategory
@
text
@a216 23
 * Sets the value of a global Property for this Implementation to a specified
 * value.
 * 
 * @@param <V>      The value type of the Property
 * @@param theProp  The Property whose value is to be set
 * @@param theValue The V instance to which the Property value is to be set.
 *
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the Category of theProp is not the
 *                                  global Category.
 * @@throws IllegalStateException    If the current Implementation is null
 *******************************************************************************
 */
   public static <V> void setGlobal (Property <V> theProp, V theValue)
      {
      prohibitNull             (theProp, "theProp");
      requireGlobalCat         (theProp, "set (Property <V>, V)");
      requireCurImplementation ();
      
      current.myGlobalPrimitive.setValue (theProp, theValue);
      }

/*******************************************************************************
@


1.50
log
@get Implementation ==> CompoundCategory
@
text
@a9 2
import java.util.List;

a81 136
 * Verifies that the Scheme of theCat matches the Scheme of the current
 * Implementation.
 *******************************************************************************
 */
   private static void requireSchemeMatchesCurImp (Category <?> theCat)
      {
      if (theCat.getScheme () != current.getScheme ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   A method was called with a Category <?> argument that\n"
             + "   belonged to a Scheme that does not match the Scheme of\n"
             + "   the current Implementation.\n"
             + "\n"
             + "      Category:               "
             +        theCat              .getName () + "\n"
             + "         Scheme:              "
             +        theCat.getScheme () .getName () + "\n"
             + "      Current Implementation: "
             +        current             .getName () + "\n"
             + "         Scheme:              "
             +        current.getScheme ().getName () + "\n");
      }

/*******************************************************************************
 * Verifies that the # of coordinates passed to a method matches the # of
 * dimensions in the CompoundCategory.
 * 
 * @@param signature The signature of the method called
 *******************************************************************************
 */
   private static void checkNCoords (
         CompoundCategory theCompCat,
         Item[]           theCoordArr,
         String           signature)
      {
      int nDimens;
      
      nDimens = theCompCat.getDimensions ().size ();
      
      if (theCoordArr.length != nDimens)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Implementation." + signature + ",\n"
             + "   where the number of coordinates passed does not match the\n"
             + "   number of dimensions of the CompoundCategory.\n"
             + "\n"
             + "      CompoundCategory:     " + theCompCat .getName () + "\n"
             + "      # Dimensions:         " + nDimens                + "\n"
             + "      # Coordinates Passed: " + theCoordArr.length     + "\n");
      }
   
/*******************************************************************************
 * Verifies that the Categories of the coordinates passed to a method match the
 * dimensions of the CompoundCategory passed to the method.
 * 
 * @@param signature The signature of the method called
 *******************************************************************************
 */
   private static void checkCategories (
         CompoundCategory theCompCat,
         Item[]           theCoordArr,
         String           signature)
      {
      int          theIdx;
      Category <?> theCat;
      Category <?> theDimen;
      
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theCat   = theCoordArr[theIdx].getCategory ();
         
         theDimen = theCompCat.getDimensions ().get (theIdx);
         
         if (theCat != theDimen)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to Implementation." + signature + ",\n"
                + "   where the Category of at least one of the\n"
                + "   coordinates passed does not match the corresponding\n"
                + "   dimension of the CompoundCategory.\n"
                + "\n"
                + "      CompoundCategory:    " + theCompCat.getName () + "\n"
                + "      Dimension #:         " + (theIdx + 1)          + "\n"
                + "      Dimension:           " + theDimen  .getName () + "\n"
                + "      Coordinate Category: " + theCat    .getName () + "\n"
                );
         }
      }
   
/*******************************************************************************
 * Verifies that the Items passed to a method all belong to the current
 * Implementation.
 *******************************************************************************
 */
   private static void requireImpsMatchCur (
         CompoundCategory theCompCat,
         Item[]           theCoordArr,
         String           signature)
      {
      int            theIdx;
      Implementation theImple;
      
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theImple = theCoordArr[theIdx].getImplementation ();
         
         if (theImple != current)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to Implementation." + signature + ",\n"
                + "   where at least one of the coordinate Items does not\n"
                + "   belong to the current Implementation.\n"
                + "\n"
                + "      CompoundCategory:          "   + theCompCat.getName ()
                + "\n"
                + "      Coordinate Index:          "   + (theIdx + 1) + "\n"
                + "      Coordinate:                "   + theCoordArr[theIdx]
                + "\n"
                + "      Coordinate Implementation: \"" + theImple.getName ()
                + "\"\n"
                + "      Current    Implementation: \"" + current .getName ()
                + "\"\n");
         }
      }
   
/*******************************************************************************
a216 48
 * Computes a "slice": the set of all Compounds of a CompoundCategory in the
 * current implementation whose coordinates match a "pattern". The pattern is a
 * sequence of n Item references, where n is the number of dimensions in the
 * CompoundCatagory. Some of the Item references may be null. A Compound will be
 * in the slice, iff it belongs to the CompoundCategory and to the current
 * Implementation and for each coordinate of the Compound, either the coordinate
 * == the corresponding Item in the pattern, or the corresponding Item
 * reference in the pattern is null. Thus the nulls in the pattern function as
 * "wild cards" that match all Items.
 * 
 * @@param  theCompCat The CompoundCatagory to which the Compounds in the slice
 *                    are to belong.
 * @@param  thePattern The pattern to which the Compounds in the slice are to be
 *                    matched
 * @@return            The slice
 * 
 * @@throws NullPointerException     If theCompCat or thePattern are null
 *                                  references
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
 *******************************************************************************
 */
   public static List <Compound> getSlice (
         CompoundCategory theCompCat,
         Item...          thePattern)
      {
      String signature;
      
      signature = "getSlice (CompoundCategory, Item...)";
      
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNull               (thePattern, "thePattern");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, thePattern, signature);
      checkCategories            (theCompCat, thePattern, signature);
      requireImpsMatchCur        (theCompCat, thePattern, signature);
      
      return current.getCompoundMgr (theCompCat).getSlice (thePattern);
      }
   
/*******************************************************************************
@


1.49
log
@get Implementation ==> PrimitiveCategory
@
text
@a354 39
 * Compound look-up method.
 * 
 * @@param theCompCat                The CompoundCategory to which the retrieved
 *                                  Compound is to belong
 * @@param theCoords                 The list of coordinates for the Compound to
 *                                  be retrieved
 * @@return                          The Compound of theCompCat in the current
 *                                  Implementation whose coordinates match
 *                                  theCoords, if any; otherwise null.
 *                                  
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
 *******************************************************************************
 */
   public static Compound get (CompoundCategory theCompCat, Item... theCoords)
      {
      String signature;
      
      signature = "get (CompoundCategory, Item...)";
      
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNullArray          (theCoords,  "theCoords");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, theCoords, signature);
      checkCategories            (theCompCat, theCoords, signature);
      requireImpsMatchCur        (theCompCat, theCoords, signature);
      
      return current.getCompoundMgr (theCompCat).getCompound (theCoords);
      }
   
/*******************************************************************************
@


1.48
log
@Moved getAll from Implementation to Category.
@
text
@a354 26
 * Primitive look-up method.
 * 
 * @@param  thePrimCat The PrimitiveCategory to which the retrieved Primitive is
 *                    to belong
 * @@param  theName    The name of the Primitive to be retrieved
 * @@return            The Primitive of thePrimCat in the current Implementation
 *                    whose name matches theName, if any; otherwise null
 *         
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does
 *                                  not match the Scheme of the current
 *                                  Implementation
 *******************************************************************************
 */
   public static Primitive get (PrimitiveCategory thePrimCat, String theName)
      {
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
      
      return current.getPrimitiveMgr (thePrimCat).getPrimitive (theName);
      }
   
/*******************************************************************************
@


1.47
log
@Moved newCompound from Implementation to CompoundCategory.
@
text
@a354 25
 * Item list retrieval method.
 * 
 * @@param  <I>    The type of Item to be listed (either Primitive or Compound)
 * @@param  theCat The Category {@@literal<I>} to which the listed I instances
 *                will belong
 * @@return        An unmodifiable List of all of the I instances of theCat in
 *                in current Implementation, listed in the order in which they
 *                were created.
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of theCat does not match the
 *                                  Scheme of the current Implementation
 *******************************************************************************
 */
   public static <I extends Item> List <I> getAll (Category <I> theCat)
      {
      prohibitNull               (theCat, "theCat");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCat);
      
      return current.getItemMgr (theCat).getInstances ();
      }

/*******************************************************************************
@


1.46
log
@Moved newPrimitive from Implementation to PrimitiveCategory.
@
text
@a219 27
 * Verifies that theCoordArr does not duplicate the coordinate list of a
 * Compound of theCompCat in the current Implementation.<br>
 * To be called by newCompound (CompoundCategory, Item...).
 *******************************************************************************
 */
   private static void prohibitDupCoords (
         CompoundCategory theCompCat,
         Item[]           theCoordArr)
      {
      Compound theComp;
      
      theComp = current.getCompoundMgr (theCompCat).getCompound (theCoordArr);
      
      if (theComp != null)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newCompound (CompoundCategory, Item...)\n"
             + "   with a coordinate list that duplicates coordinate list of\n"
             + "   an existing Compound of the CompoundCategory in the\n"
             + "   current Implementation.\n"
             + "\n"
             + "      Compound: " + theComp + "\n");
      }
   
/*******************************************************************************
a354 48
 * Factory method:<br>
 * Constructs a new Compound in the current Implementation
 *
 * @@param theCompCat                The CompoundCategory to which the Compound
 *                                  is to belong
 * @@param theCoords                 The Items that are to be the coordinates
 *                                  of the Compound
 * @@return                          The new Compound
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
 * @@throws IllegalArgumentException If the Items match the coordinate list of an
 *                                  existing Compound of theCompCat in the
 *                                  current Implementation
 *******************************************************************************
 */
   public static Compound newCompound (
         CompoundCategory theCompCat,
         Item...          theCoords)
      {
      String   signature;
      Compound theComp;
      
      signature = "newCompound (CompoundCategory, Item...)";
      
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNullArray          (theCoords,  "theCoords");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, theCoords, signature);
      checkCategories            (theCompCat, theCoords, signature);
      requireImpsMatchCur        (theCompCat, theCoords, signature);
      prohibitDupCoords          (theCompCat, theCoords);
      
      theComp = new Compound (theCompCat, current, theCoords);
      
      current.getCompoundMgr (theCompCat).store (theComp);
      
      return theComp;
      }
   
/*******************************************************************************
@


1.45
log
@Moved newImplementation from Implementation to Scheme.
@
text
@a108 44
 * Verifies that thePrimCat is not the global Category.<br>
 * To be called by newPrimitive (thePrimCat, theName).
 *******************************************************************************
 */
   private static void prohibitGlobalCat (PrimitiveCategory thePrimCat)
      {
      if (thePrimCat.isGlobal())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newPrimitive (PrimitiveCategory, String),\n"
             + "   where the PrimitiveCategory is the global Category.\n");
      }
   
/*******************************************************************************
 * Verifies that theName does not match the name of a Primitive of
 * thePrimCat in the current Implementation.<br>
 * To be called by newPrimitive (thePrimCat, theName).
 *******************************************************************************
 */
   private static void prohibitDupName (
         PrimitiveCategory thePrimCat,
         String            theName)
      {
      Primitive thePrim;
      
      thePrim = current.getPrimitiveMgr (thePrimCat).getPrimitive (theName);
      
      if (thePrim != null)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newPrimitive (PrimitiveCategory, String),\n"
             + "   where the name String matches the name of an existing\n"
             + "   Primitive of the PrimitiveCategory in the current\n"
             + "   Implementation.\n"
             + "\n"
             + "      PrimitiveCategory: "   + thePrimCat.getName () + "\n"
             + "      Name String:       \"" +            theName    + "\"\n");
      }
   
/*******************************************************************************
a291 9
/*******************************************************************************
 * @@return the PrimitiveMgr for thePrimCat in this Implementation.
 *******************************************************************************
 */
   private PrimitiveMgr getPrimitiveMgr (PrimitiveCategory thePrimCat)
      {
      return (PrimitiveMgr) getItemMgr (thePrimCat);
      }
   
d330 9
a382 38
 * Constructs a new Primitive in the current Implementation.
 *   
 * @@param  thePrimCat               The PrimitiveCategory to which the Primitive
 *                                  will belong
 * @@param  theName                  The name for the Primitive 
 * @@return                          The new Primitive
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does
 *                                  not match the Scheme of the current
 *                                  Implementation
 * @@throws IllegalArgumentException If theName matches the name of an existing
 *                                  Primitive of thePrimitiveCategory in the
 *                                  current Implementation
 *******************************************************************************
 */
   public static Primitive newPrimitive (
         PrimitiveCategory thePrimCat,
         String            theName)
      {
      Primitive thePrim;
      
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
      prohibitGlobalCat          (thePrimCat);
      prohibitDupName            (thePrimCat, theName);
      
      thePrim = new Primitive (thePrimCat, theName, current);
      
      current.getPrimitiveMgr (thePrimCat).store (thePrim);
      
      return thePrim;
      }

/*******************************************************************************
 * Factory method:<br>
@


1.44
log
@Moved newProperty to class Category
@
text
@a63 17
// Private Constructor
////////////////////////////////////////////////////////////////////////////////

   private Implementation (Scheme theScheme, String theName)
      {
      PrimitiveCategory theGlobalCat;
      
      myScheme          = theScheme;
      myName            = theName;
      myItemMgrArr      = newItemMgrArr   ();

      theGlobalCat      = theScheme.getGlobalCategoryInternal ();
      
      myGlobalPrimitive = new Primitive (theGlobalCat, "Global", this);
      }

////////////////////////////////////////////////////////////////////////////////
a67 19
 * Verifies that theScheme is frozen.<br>
 * To be called only by newImplementation.
 *******************************************************************************
 */
   private static void requireFrozenScheme (Scheme theScheme, String theName)
      {
      if (! theScheme.isFrozen ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newImplementation (Scheme, String),\n"
             + "   when the Scheme was not frozen:\n"
             + "\n"
             + "      Scheme:              " + theScheme.getName () + "\n"
             + "      Implementation Name: " + theName              + "\n");
      }
   
/*******************************************************************************
d346 17
a425 27
 * Factory method: Constructs a new Implementation.<br>
 * The current Implementation is set to the new Implementation.<br>
 * The current Scheme is set to the theScheme.
 *
 * @@param  theScheme                The Scheme to be implemented by the new
 *                                  Implementation
 * @@param  theName                  The name of the new Implementation
 * @@return                          The new Implementation
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If theScheme is not frozen
 *******************************************************************************
 */
   public static Implementation newImplementation (
         Scheme theScheme,
         String theName)
      {
      prohibitNull (theScheme, "theScheme");
      prohibitNull (theName,   "theName");
      
      requireFrozenScheme (theScheme, theName);
   
      current = new Implementation (theScheme, theName);
      
      return current;
      }
      
/*******************************************************************************
@


1.43
log
@set/get ==> set/getGlobal
@
text
@d732 1
a732 1
   public static final <V> V getGlobal (Property <V> theProp)
@


1.42
log
@//=== ==> /////
@
text
@d709 1
a709 1
   public static <V> void set (Property <V> theProp, V theValue)
d732 1
a732 1
   public static final <V> V get (Property <V> theProp)
@


1.41
log
@Various revisions.
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d23 1
a23 1
//==============================================================================
d25 1
a25 1
//==============================================================================
d34 1
a34 1
//==============================================================================
d36 1
a36 1
//==============================================================================
d63 1
a63 1
//==============================================================================
d65 1
a65 1
//==============================================================================
d80 1
a80 1
//==============================================================================
d82 1
a82 1
//==============================================================================
d344 1
a344 1
//==============================================================================
d346 1
a346 1
//==============================================================================
d381 1
a381 1
//==============================================================================
d383 1
a383 1
//==============================================================================
d410 1
a410 1
//==============================================================================
d412 1
a412 1
//==============================================================================
d741 1
a741 1
//==============================================================================
d743 1
a743 1
//==============================================================================
d772 1
a772 1
//==============================================================================
d778 1
a778 1
//==============================================================================
d786 1
a786 1
//==============================================================================
@


1.40
log
@Minor revision.
@
text
@d61 1
a61 1
   private Primitive myGlobalPrimitive;
d73 2
a74 2
      myItemMgrArr      = newItemMgrArr ();
      
d354 3
a356 5
      int              nCats;
      ItemMgr <?>[]    theItemMgrArr;
      int              theIdx;
      ItemMgr <?>      theItemMgr;
      CompoundCategory theCompCat;
d364 1
a364 1
         theIdx = theCat.getIndex   ();
d366 1
a366 14
         if (theCat instanceof PrimitiveCategory)
            {
            theItemMgr = new PrimitiveMgr ();
            }
         else
            {
            assert (theCat instanceof CompoundCategory);
            
            theCompCat = (CompoundCategory) theCat;
            
            theItemMgr = new CompoundMgr (theCompCat, this);
            }
         
         theItemMgrArr[theIdx] = theItemMgr;
d389 1
a389 1
                                       @@SuppressWarnings("unchecked")
d715 1
a715 1
      current.myGlobalPrimitive.setInternal (theProp, theValue);
d738 1
a738 1
      return current.myGlobalPrimitive.getInternal (theProp);
d766 2
a767 2
 */
   @@Override public String toString ()
@


1.39
log
@Re-arranged class Implementation.
@
text
@d73 1
a73 1
      myItemMgrArr      = newItemMgrArr (theScheme);
d352 1
a352 1
   private ItemMgr <?>[] newItemMgrArr (Scheme theScheme)
d360 1
a360 1
      nCats         = theScheme.getCategories ().size ();
d364 1
a364 1
      for (Category <?> theCat: theScheme.getCategories ())
@


1.38
log
@Global Category / Primitive.
@
text
@d24 1
a24 1
// Public
d28 2
a29 10
 * Factory method: Constructs a new Implementation.<br>
 * The current Implementation is set to the new Implementation.<br>
 * The current Scheme is set to the theScheme.
 *
 * @@param  theScheme                The Scheme to be implemented by the new
 *                                  Implementation
 * @@param  theName                  The name of the new Implementation
 * @@return                          The new Implementation
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If theScheme is not frozen
d32 1
a32 8
   public static Implementation newImplementation (
         Scheme theScheme,
         String theName)
      {
      prohibitNull (theScheme, "theScheme");
      prohibitNull (theName,   "theName");
      
      requireFrozenScheme (theScheme, theName);
d34 3
a36 42
      current = new Implementation (theScheme, theName);
      
      return current;
      }
      
/*******************************************************************************
 * Factory method:<br>
 * Constructs a new Primitive in the current Implementation.
 *   
 * @@param  thePrimCat               The PrimitiveCategory to which the Primitive
 *                                  will belong
 * @@param  theName                  The name for the Primitive 
 * @@return                          The new Primitive
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does not
 *                                  match the Scheme of the current
 *                                  Implementation
 * @@throws IllegalArgumentException If theName matches the name of an existing
 *                                  Primitive of thePrimitiveCategory in the
 *                                  current Implementation
 *******************************************************************************
 */
   public static Primitive newPrimitive (
         PrimitiveCategory thePrimCat,
         String            theName)
      {
      Primitive thePrim;
      
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
      prohibitGlobalCat          (thePrimCat);
      prohibitDupName            (thePrimCat, theName);
      
      thePrim = new Primitive (thePrimCat, theName, current);
      
      current.getPrimitiveMgr (thePrimCat).store (thePrim);
      
      return thePrim;
      }
d39 1
a39 13
 * Item list retrieval method.
 * 
 * @@param  <I>    The type of Item to be listed (either Primitive or Compound)
 * @@param  theCat The Category {@@literal<I>} to which the listed I instances
 *                will belong
 * @@return        An unmodifiable List of all of the I instances of theCat in
 *                in current Implementation, listed in the order in which they
 *                were created.
 * 
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of theCat does not match the
 *                                  Scheme of the current Implementation
d42 2
a43 9
   public static <I extends Item> List <I> getAll (Category <I> theCat)
      {
      prohibitNull               (theCat, "theCat");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCat);
      
      return current.getItemMgr (theCat).getInstances ();
      }

d45 1
a45 13
 * Primitive look-up method.
 * 
 * @@param  thePrimCat The PrimitiveCategory to which the retrieved Primitive is
 *                    to belong
 * @@param  theName    The name of the Primitive to be retrieved
 * @@return            The Primitive of thePrimCat in the current Implementation
 *                    whose name matches theName, if any; otherwise null
 *         
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does
 *                                  not match the Scheme of the current
 *                                  Implementation
d48 1
a48 9
   public static Primitive get (PrimitiveCategory thePrimCat, String theName)
      {
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
      
      return current.getPrimitiveMgr (thePrimCat).getPrimitive (theName);
      }
d51 2
a52 20
 * Factory method:<br>
 * Constructs a new Compound in the current Implementation
 *
 * @@param theCompCat                The CompoundCategory to which the Compound
 *                                  is to belong
 * @@param theCoords                 The Items that are to be the coordinates
 *                                  of the Compound
 * @@return                          The new Compound
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
 * @@throws IllegalArgumentException If the Items match the coordinate list of an
 *                                  existing Compound of theCompCat in the
 *                                  current Implementation
d55 2
a56 25
   public static Compound newCompound (
         CompoundCategory theCompCat,
         Item...          theCoords)
      {
      String   signature;
      Compound theComp;
      
      signature = "newCompound (CompoundCategory, Item...)";
      
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNullArray          (theCoords,  "theCoords");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, theCoords, signature);
      checkCategories            (theCompCat, theCoords, signature);
      requireImpsMatchCur        (theCompCat, theCoords, signature);
      prohibitDupCoords          (theCompCat, theCoords);
      
      theComp = new Compound (theCompCat, current, theCoords);
      
      current.getCompoundMgr (theCompCat).store (theComp);
      
      return theComp;
      }
   
d58 1
a58 19
 * Compound look-up method.
 * 
 * @@param theCompCat                The CompoundCategory to which the retrieved
 *                                  Compound is to belong
 * @@param theCoords                 The list of coordinates for the Compound to
 *                                  be retrieved
 * @@return                          The Compound of theCompCat in the current
 *                                  Implementation whose coordinates match
 *                                  theCoords, if any; otherwise null.
 *                                  
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
d61 1
a61 16
   public static Compound get (CompoundCategory theCompCat, Item... theCoords)
      {
      String signature;
      
      signature = "get (CompoundCategory, Item...)";
      
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNullArray          (theCoords,  "theCoords");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, theCoords, signature);
      checkCategories            (theCompCat, theCoords, signature);
      requireImpsMatchCur        (theCompCat, theCoords, signature);
      
      return current.getCompoundMgr (theCompCat).getCompound (theCoords);
      }
d63 5
a67 32
/*******************************************************************************
 * Computes a "slice": the set of all Compounds of a CompoundCategory in the
 * current implementation whose coordinates match a "pattern". The pattern is a
 * sequence of n Item references, where n is the number of dimensions in the
 * CompoundCatagory. Some of the Item references may be null. A Compound will be
 * in the slice, iff it belongs to the CompoundCategory and to the current
 * Implementation and for each coordinate of the Compound, either the coordinate
 * == the corresponding Item in the pattern, or the corresponding Item
 * reference in the pattern is null. Thus the nulls in the pattern function as
 * "wild cards" that match all Items.
 * 
 * @@param  theCompCat The CompoundCatagory to which the Compounds in the slice
 *                    are to belong.
 * @@param  thePattern The pattern to which the Compounds in the slice are to be
 *                    matched
 * @@return            The slice
 * 
 * @@throws NullPointerException     If theCompCat or thePattern are null
 *                                  references
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theCompCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If the Categories of the Items do not match
 *                                  the corresponding dimension Categories of
 *                                  theCompCat
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  current Implementation
 *******************************************************************************
 */
   public static List <Compound> getSlice (
         CompoundCategory theCompCat,
         Item...          thePattern)
d69 1
a69 1
      String signature;
d71 3
a73 1
      signature = "getSlice (CompoundCategory, Item...)";
d75 1
a75 7
      prohibitNull               (theCompCat, "theCompCat");
      prohibitNull               (thePattern, "thePattern");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theCompCat);
      checkNCoords               (theCompCat, thePattern, signature);
      checkCategories            (theCompCat, thePattern, signature);
      requireImpsMatchCur        (theCompCat, thePattern, signature);
d77 1
a77 24
      return current.getCompoundMgr (theCompCat).getSlice (thePattern);
      }
   
/*******************************************************************************
 * Sets the value of a global Property for this Implementation to a specified
 * value.
 * 
 * @@param <V>      The value type of the Property
 * @@param theProp  The Property whose value is to be set
 * @@param theValue The V instance to which the Property value is to be set.
 *
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the Category of theProp is not the
 *                                  global Category.
 * @@throws IllegalStateException    If the current Implementation is null
 *******************************************************************************
 */
   public static <V> void set (Property <V> theProp, V theValue)
      {
      prohibitNull             (theProp, "theProp");
      requireGlobalCat         (theProp, "set (Property <V>, V)");
      requireCurImplementation ();
      
      current.myGlobalPrimitive.setInternal (theProp, theValue);
d79 4
d85 2
a86 11
 * Retrieves the value of a global Property for this Item.
 * 
 * @@param <V>     The value type of the Property
 * @@param theProp The Property whose value is to be retrieved
 * @@return        A reference to the current value of the Property for this
 *                Item
 * 
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the Category of theProp is not the
 *                                  global Category.
 * @@throws IllegalStateException    If the current Implementation is null
d89 1
a89 1
   public static final <V> V get (Property <V> theProp)
d91 10
a100 5
      prohibitNull             (theProp, "theProp");
      requireGlobalCat         (theProp, "get (Property <V>, V)");
      requireCurImplementation ();
      
      return current.myGlobalPrimitive.getInternal (theProp);
d102 1
a102 1

d104 1
a104 27
 * Retrieves the value of a Property for this Item.
 * 
 * @@param <V>     The value type of the Property
 * @@param theProp The Property whose value is to be retrieved
 * @@return        A reference to the current value of the Property for this
 *                Item
 * 
 * @@throws NullPointerException     If theProp is null
 * @@throws IllegalArgumentException If the Category of theProp does not match
 *                                  the Category of this Item.
 *******************************************************************************
 *//*
                     @@SuppressWarnings("unchecked")
   public final <V> V get (Property <V> theProp)
      {
      prohibitNull     (theProp, "theProp");
      
      requireCatsMatch (theProp, "get (Property <V>)");
      
      return (V) myPropValueArr[theProp.getIndex ()];
      }
*/
/*******************************************************************************
 * Sets the current Implementation.<br>
 * 
 * @@param theImple The Implementation which is to become current.
 *                 (Null is allowed.)
d107 1
a107 1
   public static void setCurrentImplementation (Implementation theImple)
d109 8
a116 1
      current = theImple;
d120 2
a121 1
 * @@return The current Implementation, if any; otherwise null.
d124 1
a124 1
   public static Implementation getCurrentImplementation ()
d126 16
a141 1
      return current;
d145 2
a146 1
 * {@@inheritDoc}
d149 1
a149 1
   @@Override public String toString ()
d151 7
a157 1
      return "Implementation \"" + myName + "\"";
d161 3
a163 1
 * @@return The name of this Implementation
d166 3
a168 1
   public String getName ()
d170 16
a185 1
      return myName;
d187 1
a187 1

d189 4
a192 1
 * @@return The Scheme of this Implementation
d195 4
a198 1
   public Scheme getScheme ()
d200 15
a214 10
      return myScheme;
      }

/*******************************************************************************
 * @@return The global Primitive for the current Implementation.
 *******************************************************************************
 */
   public static Primitive getGlobalPrimitive ()
      {
      return current.myGlobalPrimitive;
a215 4

//==============================================================================
// Package Internal
//==============================================================================
d218 4
a221 1
 * @@return the CompoundMgr for theCompCat in this Implementation.
d224 4
a227 1
   CompoundMgr getCompoundMgr (CompoundCategory theCompCat)
d229 28
a256 1
      return (CompoundMgr) getItemMgr (theCompCat);
d260 2
a261 1
 * @@return the ItemMgr for theCat in this Implementation.
d264 4
a267 2
                                       @@SuppressWarnings("unchecked")
   <I extends Item> ItemMgr <I> getItemMgr (Category <I> theCat)
d269 2
a270 1
      ItemMgr <?> theItemMgr;
d272 6
a277 1
      assert (theCat.getScheme () == myScheme);
d279 18
a296 3
      theItemMgr = myItemMgrArr[theCat.getIndex ()];
      
      return (ItemMgr <I>) theItemMgr;
a298 4
//==============================================================================
// Private
//==============================================================================

d300 3
a302 1
 * Constructor.
d305 3
a307 1
   private Implementation (Scheme theScheme, String theName)
d309 1
a309 1
      PrimitiveCategory theGlobalCat;
d311 1
a311 3
      myScheme          = theScheme;
      myName            = theName;
      myItemMgrArr      = newItemMgrArr (theScheme);
d313 11
a323 3
      theGlobalCat      = theScheme.getGlobalCategoryInternal ();
      
      myGlobalPrimitive = new Primitive (theGlobalCat, "Global", this);
d325 1
a325 1

d327 1
a327 2
 * Verifies that theScheme is frozen.<br>
 * To be called only by newImplementation.
d330 3
a332 1
   private static void requireFrozenScheme (Scheme theScheme, String theName)
d334 1
a334 1
      if (! theScheme.isFrozen ())
d338 2
a339 3
             + "   Call to\n"
             + "   Implementation.newImplementation (Scheme, String),\n"
             + "   when the Scheme was not frozen:\n"
d341 1
a341 2
             + "      Scheme:              " + theScheme.getName () + "\n"
             + "      Implementation Name: " + theName              + "\n");
d344 4
d362 48
a409 5
      theItemMgrArr = new ItemMgr <?>[nCats];

      for (Category <?> theCat: theScheme.getCategories ())
         {
         theIdx = theCat.getIndex   ();
d411 1
a411 15
         if (theCat instanceof PrimitiveCategory)
            {
            theItemMgr = new PrimitiveMgr ();
            }
         else
            {
            assert (theCat instanceof CompoundCategory);
            
            theCompCat = (CompoundCategory) theCat;
            
            theItemMgr = new CompoundMgr (theCompCat, this);
            }
         
         theItemMgrArr[theIdx] = theItemMgr;
         }
d413 10
a422 1
      return theItemMgrArr;
d425 4
d430 4
a433 1
 * Verifies that the current Implementation is not null.
d436 1
a436 1
   private static void requireCurImplementation ()
d438 1
a438 8
      if (current == null)
         {
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to a method that requires a current Implementation\n"
             + "   when the current Implementation is null.\n");
         }
d442 1
a442 2
 * Verifies that the Scheme of theCat matches the Scheme of the current
 * Implementation.
d445 1
a445 1
   private static void requireSchemeMatchesCurImp (Category <?> theCat)
d447 1
a447 16
      if (theCat.getScheme () != current.getScheme ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   A method was called with a Category <?> argument that\n"
             + "   belonged to a Scheme that does not match the Scheme of\n"
             + "   the current Implementation.\n"
             + "\n"
             + "      Category:               "
             +        theCat              .getName () + "\n"
             + "         Scheme:              "
             +        theCat.getScheme () .getName () + "\n"
             + "      Current Implementation: "
             +        current             .getName () + "\n"
             + "         Scheme:              "
             +        current.getScheme ().getName () + "\n");
d451 1
a451 2
 * Verifies that thePrimCat is not the global Category.<br>
 * To be called by newPrimitive (thePrimCat, theName).
d454 1
a454 1
   private static void prohibitGlobalCat (PrimitiveCategory thePrimCat)
d456 1
a456 7
      if (thePrimCat.isGlobal())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newPrimitive (PrimitiveCategory, String),\n"
             + "   where the PrimitiveCategory is the global Category.\n");
d458 1
a458 1
   
d460 10
a469 3
 * Verifies that theName does not match the name of a Primitive of
 * thePrimCat in the current Implementation.<br>
 * To be called by newPrimitive (thePrimCat, theName).
d472 3
a474 3
   private static void prohibitDupName (
         PrimitiveCategory thePrimCat,
         String            theName)
d476 2
a477 1
      Primitive thePrim;
d479 3
a481 1
      thePrim = current.getPrimitiveMgr (thePrimCat).getPrimitive (theName);
d483 1
a483 12
      if (thePrim != null)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newPrimitive (PrimitiveCategory, String),\n"
             + "   where the name String matches the name of an existing\n"
             + "   Primitive of the PrimitiveCategory in the current\n"
             + "   Implementation.\n"
             + "\n"
             + "      PrimitiveCategory: "   + thePrimCat.getName () + "\n"
             + "      Name String:       \"" +            theName    + "\"\n");
d485 1
a485 1
   
d487 15
a501 4
 * Verifies that the # of coordinates passed to a method matches the # of
 * dimensions in the CompoundCategory.
 * 
 * @@param signature The signature of the method called
d504 3
a506 4
   private static void checkNCoords (
         CompoundCategory theCompCat,
         Item[]           theCoordArr,
         String           signature)
d508 10
a517 1
      int nDimens;
d519 1
a519 1
      nDimens = theCompCat.getDimensions ().size ();
d521 1
a521 11
      if (theCoordArr.length != nDimens)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Implementation." + signature + ",\n"
             + "   where the number of coordinates passed does not match the\n"
             + "   number of dimensions of the CompoundCategory.\n"
             + "\n"
             + "      CompoundCategory:     " + theCompCat .getName () + "\n"
             + "      # Dimensions:         " + nDimens                + "\n"
             + "      # Coordinates Passed: " + theCoordArr.length     + "\n");
d523 1
a523 1
   
d525 20
a544 4
 * Verifies that the Categories of the coordinates passed to a method match the
 * dimensions of the CompoundCategory passed to the method.
 * 
 * @@param signature The signature of the method called
d547 1
a547 1
   private static void checkCategories (
d549 1
a549 2
         Item[]           theCoordArr,
         String           signature)
d551 17
a567 3
      int          theIdx;
      Category <?> theCat;
      Category <?> theDimen;
d569 1
a569 24
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theCat   = theCoordArr[theIdx].getCategory ();
         
         theDimen = theCompCat.getDimensions ().get (theIdx);
         
         if (theCat != theDimen)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to Implementation." + signature + ",\n"
                + "   where the Category of at least one of the\n"
                + "   coordinates passed does not match the corresponding\n"
                + "   dimension of the CompoundCategory.\n"
                + "\n"
                + "      CompoundCategory:    " + theCompCat.getName () + "\n"
                + "      Dimension #:         " + (theIdx + 1)          + "\n"
                + "      Dimension:           " + theDimen  .getName () + "\n"
                + "      Coordinate Category: " + theCat    .getName () + "\n"
                );
         }
d573 13
a585 2
 * Verifies that the Items passed to a method all belong to the current
 * Implementation.
d588 1
a588 4
   private static void requireImpsMatchCur (
         CompoundCategory theCompCat,
         Item[]           theCoordArr,
         String           signature)
d590 3
a592 2
      int            theIdx;
      Implementation theImple;
d594 1
a594 25
      for (theIdx = 0; theIdx < theCoordArr.length; theIdx ++)
         {
         if (theCoordArr[theIdx] == null)
            continue;
         
         theImple = theCoordArr[theIdx].getImplementation ();
         
         if (theImple != current)
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to Implementation." + signature + ",\n"
                + "   where at least one of the coordinate Items does not\n"
                + "   belong to the current Implementation.\n"
                + "\n"
                + "      CompoundCategory:          "   + theCompCat.getName ()
                + "\n"
                + "      Coordinate Index:          "   + (theIdx + 1) + "\n"
                + "      Coordinate:                "   + theCoordArr[theIdx]
                + "\n"
                + "      Coordinate Implementation: \"" + theImple.getName ()
                + "\"\n"
                + "      Current    Implementation: \"" + current .getName ()
                + "\"\n");
         }
d596 1
a596 1
   
d598 13
a610 3
 * Verifies that theCoordArr does not duplicate the coordinate list of a
 * Compound of theCompCat in the current Implementation.<br>
 * To be called by newCompound (CompoundCategory, Item...).
d613 1
a613 3
   private static void prohibitDupCoords (
         CompoundCategory theCompCat,
         Item[]           theCoordArr)
d615 4
a618 1
      Compound theComp;
d620 1
a620 13
      theComp = current.getCompoundMgr (theCompCat).getCompound (theCoordArr);
      
      if (theComp != null)
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to\n"
             + "   Implementation.newCompound (CompoundCategory, Item...)\n"
             + "   with a coordinate list that duplicates coordinate list of\n"
             + "   an existing Compound of the CompoundCategory in the\n"
             + "   current Implementation.\n"
             + "\n"
             + "      Compound: " + theComp + "\n");
d624 19
a642 1
 * Verifies that theProp is global.
d645 1
a645 3
   private static void requireGlobalCat (
         Property <?> theProp,
         String       signature)
d647 13
a659 8
      if (! theProp.getCategory ().isGlobal ())
         throw
            new IllegalArgumentException (
               "\n\n"
             + "   Call to Implementation." + signature + " with a non-global\n"
             + "   Property.\n"
             + "\n"
             + "      " + theProp + " of " + theProp.getCategory () + "\n");
d663 26
a688 1
 * @@return the PrimitiveMgr for thePrimCat in this Implementation.
d691 3
a693 1
   private PrimitiveMgr getPrimitiveMgr (PrimitiveCategory thePrimCat)
d695 13
a707 1
      return (PrimitiveMgr) getItemMgr (thePrimCat);
d711 11
a721 2
 * current is the current Implementation that will be used by various WIT-M
 * methods, if any; otherwise null.
d724 9
a732 2
   private static Implementation current = null;
   
d734 11
a744 1
 * The Scheme implemented by this Implementation
d747 13
a759 2
   private final Scheme myScheme;
   
d761 1
a761 1
 * The name of this Implementation
d764 5
a768 2
   private final String myName;
   
d770 1
a770 2
 * myItemMgrArr[theCat.getIndex ()] is the ItemMgr for theCat in this
 * Implementation.
d773 4
a776 1
   private final ItemMgr <?> [] myItemMgrArr;
d779 1
a779 1
 * The global Primitive for this Implementation.
d782 4
a785 1
   private Primitive myGlobalPrimitive;
@


1.37
log
@0-based indexing of coordinates and dimensions
@
text
@d82 1
d279 69
a377 2
 * Accessor.
 * 
a386 2
 * Accessor
 * 
d395 9
d443 9
a451 3
      myScheme     = theScheme;
      myName       = theName;
      myItemMgrArr = newItemMgrArr (theScheme);
d550 1
a550 2
             +        current.getScheme ().getName () + "\n"
               );
d554 16
d736 18
d788 6
@


1.36
log
@Added tests for CompoundCategory of a CompoundCategory.
Fixed a bug for this case.
@
text
@d602 1
a602 1
                + "      Coordinate #:              "   + (theIdx + 1) + "\n"
@


1.35
log
@getSlice
@
text
@d334 1
a334 3
 * Builds the String to be used by theComp.toString ().
 * 
 * @@return The String
d337 1
a337 1
   String toStringFor (Compound theComp)
d339 1
a339 28
      int    nCoords;
      int    theIdx;
      String theString;
      
      myStringBuilder.setLength (0);
      
      myStringBuilder.append (theComp.getCompoundCategory ().getName ());
      
      myStringBuilder.append (" (");
      
      myStringBuilder.append (theComp.getCoordinateList ().get (0));
      
      nCoords = theComp.getCoordinateList ().size ();
      
      for (theIdx = 1; theIdx < nCoords; theIdx ++)
         {
         myStringBuilder.append (", ");
      
         myStringBuilder.append (theComp.getCoordinateList ().get (theIdx));
         }
      
      myStringBuilder.append (")");
      
      theString = myStringBuilder.toString ();
      
      myStringBuilder.setLength (0);
      
      return theString;
d368 3
a370 5
      myScheme        = theScheme;
      myName          = theName;
      myItemMgrArr    = newItemMgrArr (theScheme);
      
      myStringBuilder = new StringBuilder (100);
a648 9
 * @@return the CompoundMgr for theCompCat in this Implementation.
 *******************************************************************************
 */
   private CompoundMgr getCompoundMgr (CompoundCategory theCompCat)
      {
      return (CompoundMgr) getItemMgr (theCompCat);
      }
   
/*******************************************************************************
a673 6
/*******************************************************************************
 * A buffer for building Strings in this Implementation.
 *******************************************************************************
 */
   private final StringBuilder myStringBuilder;
   
@


1.34
log
@Tuple ==> Compound
@
text
@d86 1
a86 1
      getCurPrimitiveMgr (thePrimCat).store (thePrim);
d113 1
a113 1
      return getCurItemMgr (theCat).getInstances ();
d139 1
a139 1
      return getCurPrimitiveMgr (thePrimCat).getPrimitive (theName);
d185 1
a185 1
      getCurCompoundMgr (theCompCat).store (theComp);
d226 49
a274 1
      return getCurCompoundMgr (theCompCat).getCompound (theCoords);
d280 2
a281 2
 * @@param theImpl The Implementation which is to become current.
 *                (Null is allowed.)
d284 1
a284 1
   public static void setCurrentImplementation (Implementation theImpl)
d286 1
a286 1
      current = theImpl;
d371 16
d427 1
a427 1
   private static ItemMgr <?>[] newItemMgrArr (Scheme theScheme)
d429 5
a433 4
      int           nCats;
      ItemMgr <?>[] theItemMgrArr;
      int           theIdx;
      ItemMgr <?>   theItemMgr;
d441 15
a455 3
         theIdx     = theCat.getIndex   ();
         theItemMgr = theCat.newItemMgr ();
               
d516 1
a516 1
      thePrim = getCurPrimitiveMgr (thePrimCat).getPrimitive (theName);
d544 1
a544 1
      List <Category <?>> theDimens;
d546 1
a546 1
      theDimens = theCompCat.getDimensions ();
d548 1
a548 1
      if (theCoordArr.length != theDimens.size ())
d557 1
a557 1
             + "      # Dimensions:         " + theDimens  .size ()    + "\n"
d563 1
a563 1
 * dimensions of the CompoundCategory.
d579 3
d604 1
a604 1
 * Verifies the the Items passed to newCompound all belong to the current
d614 1
a614 1
      Implementation theImpl;
d618 2
a619 1
         theImpl = theCoordArr[theIdx].getImplementation ();
d621 3
a623 1
         if (theImpl != current)
d636 1
a636 1
                + "      Coordinate Implementation: \"" + theImpl.getName ()
d638 1
a638 1
                + "      Current    Implementation: \"" + current.getName ()
d655 1
a655 1
      theComp = getCurCompoundMgr (theCompCat).getCompound (theCoordArr);
d671 1
a671 10
 * @@return the PrimitiveMgr for thePrimCat in the current Implementation.
 *******************************************************************************
 */
   private static PrimitiveMgr getCurPrimitiveMgr (PrimitiveCategory thePrimCat)
      {
      return (PrimitiveMgr) getCurItemMgr (thePrimCat);
      }
   
/*******************************************************************************
 * @@return the CompoundMgr for theCompCat in the current Implementation.
d674 1
a674 1
   private static CompoundMgr getCurCompoundMgr (CompoundCategory theCompCat)
d676 1
a676 1
      return (CompoundMgr) getCurItemMgr (theCompCat);
d680 1
a680 1
 * @@return the ItemMgr for theCat in the current Implementation.
d683 1
a683 3
                                               @@SuppressWarnings("unchecked")
   private static <I extends Item> ItemMgr <I> getCurItemMgr (
         Category <I> theCat)
d685 1
a685 7
      ItemMgr <?> theItemMgr;
      
      assert (theCat.getScheme () == current.myScheme);
         
      theItemMgr = current.myItemMgrArr[theCat.getIndex ()];
      
      return (ItemMgr <I>) theItemMgr;
@


1.33
log
@Implementation.get (TupleCategory, Item...)
@
text
@d94 1
a94 1
 * @@param  <I>    The type of Item to be listed (either Primitive or Tuple)
d144 1
a144 1
 * Constructs a new Tuple in the current Implementation
d146 2
a147 2
 * @@param theTupleCat               The TupleCategory to which the Tuple is to
 *                                  belong
d149 2
a150 2
 *                                  of the Tuple
 * @@return                          The new Tuple
d153 1
a153 1
 * @@throws IllegalStateException    If the Scheme of theTupleCat does not match
d157 1
a157 1
 *                                  theTupleCat
d161 1
a161 1
 *                                  existing Tuple of theTupleCat in the
d165 3
a167 1
   public static Tuple newTuple (TupleCategory theTupleCat, Item... theCoords)
d169 2
a170 2
      String signature;
      Tuple  theTuple;
d172 1
a172 1
      signature = "newTuple (TupleCategory, Item...)";
d174 2
a175 2
      prohibitNull               (theTupleCat, "theTupleCat");
      prohibitNullArray          (theCoords,   "theCoords");
d177 5
a181 5
      requireSchemeMatchesCurImp (theTupleCat);
      checkNCoords               (theTupleCat, theCoords, signature);
      checkCategories            (theTupleCat, theCoords, signature);
      requireImpsMatchCur        (theTupleCat, theCoords, signature);
      prohibitDupCoords          (theTupleCat, theCoords);
d183 1
a183 1
      theTuple = new Tuple (theTupleCat, current, theCoords);
d185 1
a185 1
      getCurTupleMgr (theTupleCat).store (theTuple);
d187 1
a187 1
      return theTuple;
d191 1
a191 1
 * Tuple look-up method.
d193 5
a197 5
 * @@param theTupleCat               The TupleCategory to which the retrieved
 *                                  Tuple is to belong
 * @@param theCoords                 The list of coordinates for the Tuple to be
 *                                  retrieved
 * @@return                          The Tuple of theTupleCat in the current
d203 1
a203 1
 * @@throws IllegalStateException    If the Scheme of theTupleCat does not match
d207 1
a207 1
 *                                  theTupleCat
d212 1
a212 1
   public static Tuple get (TupleCategory theTupleCat, Item... theCoords)
d216 1
a216 1
      signature = "get (TupleCategory, Item...)";
d218 2
a219 2
      prohibitNull               (theTupleCat, "theTupleCat");
      prohibitNullArray          (theCoords,   "theCoords");
d221 4
a224 4
      requireSchemeMatchesCurImp (theTupleCat);
      checkNCoords               (theTupleCat, theCoords, signature);
      checkCategories            (theTupleCat, theCoords, signature);
      requireImpsMatchCur        (theTupleCat, theCoords, signature);
d226 1
a226 1
      return getCurTupleMgr (theTupleCat).getTuple (theCoords);
d286 1
a286 1
 * Builds the String to be used by theTuple.toString ().
d291 1
a291 1
   String toStringFor (Tuple theTuple)
d299 1
a299 1
      myStringBuilder.append (theTuple.getTupleCategory ().getName ());
d303 1
a303 1
      myStringBuilder.append (theTuple.getCoordinateList ().get (0));
d305 1
a305 1
      nCoords = theTuple.getCoordinateList ().size ();
d311 1
a311 1
         myStringBuilder.append (theTuple.getCoordinateList ().get (theIdx));
d457 1
a457 1
 * dimensions in the TupleCategory.
d463 3
a465 3
         TupleCategory theTupleCat,
         Item[]        theCoordArr,
         String        signature)
d469 1
a469 1
      theDimens = theTupleCat.getDimensions ();
d477 1
a477 1
             + "   number of dimensions of the TupleCategory.\n"
d479 1
a479 1
             + "      TupleCategory:        " + theTupleCat.getName () + "\n"
d486 1
a486 1
 * dimensions of the TupleCategory.
d492 3
a494 3
         TupleCategory theTupleCat,
         Item[]        theCoordArr,
         String        signature)
d504 1
a504 1
         theDimen = theTupleCat.getDimensions ().get (theIdx);
d513 1
a513 1
                + "   dimension of the TupleCategory.\n"
d515 4
a518 4
                + "      TupleCategory:       " + theTupleCat.getName () + "\n"
                + "      Dimension #:         " + (theIdx + 1)           + "\n"
                + "      Dimension:           " + theDimen   .getName () + "\n"
                + "      Coordinate Category: " + theCat     .getName () + "\n"
d524 1
a524 1
 * Verifies the the Items passed to newTuple all belong to the current
d529 3
a531 3
         TupleCategory theTupleCat,
         Item[]        theCoordArr,
         String        signature)
d548 1
a548 1
                + "      TupleCategory:             "   + theTupleCat.getName ()
d561 3
a563 3
 * Verifies that theCoordArr does not duplicate the coordinate list of a Tuple
 * of theTupleCat in the current Implementation.<br>
 * To be called by newTuple (TupleCategory, Item...).
d567 2
a568 2
         TupleCategory theTupleCat,
         Item[]        theCoordArr)
d570 1
a570 1
      Tuple theTuple;
d572 1
a572 1
      theTuple = getCurTupleMgr (theTupleCat).getTuple (theCoordArr);
d574 1
a574 1
      if (theTuple != null)
d578 2
a579 1
             + "   Call to Implementation.newTuple (TupleCategory, Item...)\n"
d581 2
a582 2
             + "   an existing Tuple of the TupleCategory in the current\n"
             + "   Implementation.\n"
d584 1
a584 1
             + "      Tuple: " + theTuple + "\n");
d597 1
a597 1
 * @@return the TupleMgr for theTupleCat in the current Implementation.
d600 1
a600 1
   private static TupleMgr getCurTupleMgr (TupleCategory theTupleCat)
d602 1
a602 1
      return (TupleMgr) getCurItemMgr (theTupleCat);
@


1.32
log
@Doc comments
@
text
@d92 1
a92 1
 * Item method.
d167 4
a170 1
      Tuple theTuple;
d172 1
a172 1
      prohibitNull               (theTupleCat, "theTuple");
d176 3
a178 3
      checkNCategories           (theTupleCat, theCoords);
      checkCategories            (theTupleCat, theCoords);
      requireImpsMatchCur        (theTupleCat, theCoords);
d189 39
d454 1
a454 1
 * Verifies that the # of coordinates passed to newTuple matches the # of
d456 2
d460 1
a460 1
   private static void checkNCategories (
d462 2
a463 1
         Item[]        theCoordArr)
d473 3
a475 4
             + "   Call to\n"
             + "   Implementation.newTuple (TupleCategory, Item...), where\n"
             + "   the number of coordinate Items does not match the number\n"
             + "   of dimension ItemTypes in theTupleCategory.\n"
d477 3
a479 3
             + "      TupleCategory:          " + theTupleCat.getName () + "\n"
             + "      # Coordinate Items:     " + theCoordArr.length     + "\n"
             + "      # Dimension  ItemTypes: " + theDimens  .size ()    + "\n");         
d483 1
a483 1
 * Verifies that the Categories of the Items passed to newTuple match the
d485 2
d491 2
a492 1
         Item[]        theCoordArr)
d508 1
a508 2
                + "   Call to\n"
                + "   Implementation.newTuple (TupleCategory, Item...)\n"
d510 1
a510 1
                + "   coordinate Items does not match the corresponding\n"
d513 4
a516 5
                + "      TupleCategory:           " + theTupleCat.getName ()
                                                                          + "\n"
                + "      Coordinate #:            " + (theIdx + 1)        + "\n"
                + "      Coordinate Category:     " + theCat  .getName () + "\n"
                + "      TupleCategory Dimension: " + theDimen.getName () + "\n"
d528 2
a529 1
         Item[]        theCoordArr)
d542 1
a542 2
                + "   Call to\n"
                + "   Implementation.newTuple (TupleCategory, Item...)\n"
@


1.31
log
@Internal Tuple look-up.
@
text
@d17 2
a18 1
 * The factory method for this class is method newImplementation of this class.
d92 1
a92 1
 * Primitive / Tuple List method.
d94 1
@


1.30
log
@Revised comments, etc.
@
text
@d158 3
d174 1
d512 26
@


1.29
log
@1-based indexing of dimensions/coordinates
@
text
@d200 3
a202 3
/* *****************************************************************************
 * Doc comment inherited.
 * *****************************************************************************
d285 1
a285 1
      myItemMgrArr    = newItemMgrArr  ();
d313 1
a313 1
   private ItemMgr <?>[] newItemMgrArr ()
d320 1
a320 1
      nCats         = myScheme.getCategories ().size ();
d324 1
a324 1
      for (Category <?> theCat: myScheme.getCategories ())
@


1.28
log
@Category.newItemMgr.
@
text
@d236 3
a238 1
 * Builds and returns the String to be used by theTuple.toString ().
d463 1
a463 1
                + "      Coordinate Index:        " + theIdx              + "\n"
d497 1
a497 1
                + "      Coordinate #:              "   + theIdx + "\n"
@


1.27
log
@myPrimitiveCategories and myTupleCategories ==> myCategories
@
text
@d324 2
a325 6
         theIdx     = theCat.getIndex ();
         
         theItemMgr =
            (theCat instanceof PrimitiveCategory)?
               new PrimitiveMgr ():
               new TupleMgr     ();
@


1.26
log
@Replaced ItemCategory with Category <?>.
@
text
@d316 1
d318 1
a318 2
      nCats =   myScheme.getPrimitiveCategories ().size ()
              + myScheme.getTupleCategories     ().size ();
d322 1
a322 1
      for (PrimitiveCategory thePrimCat: myScheme.getPrimitiveCategories ())
d324 1
a324 1
         theIdx                = thePrimCat.getIndex ();
d326 6
a331 8
         theItemMgrArr[theIdx] = new PrimitiveMgr ();
         }

      for (TupleCategory theTupleCat: myScheme.getTupleCategories ())
         {
         theIdx                = theTupleCat.getIndex ();
         
         theItemMgrArr[theIdx] = new TupleMgr ();
@


1.25
log
@ItemMgr <I>
@
text
@d153 3
a155 3
 * @@throws IllegalArgumentException If the ItemCategories of the Items do not
 *                                  match the corresponding dimension
 *                                  ItemCategories of theTupleCat
d168 2
a169 2
      checkNItemCategories       (theTupleCat, theCoords);
      checkItemCategories        (theTupleCat, theCoords);
d313 1
a313 1
      int           nItemCats;
d317 2
a318 2
      nItemCats =   myScheme.getPrimitiveCategories ().size ()
                  + myScheme.getTupleCategories     ().size ();
d320 1
a320 1
      theItemMgrArr = new ItemMgr <?>[nItemCats];
d356 2
a357 2
 * Verifies that the Scheme of theItemCat matches the Scheme of the
 * current Implementation.
d360 1
a360 1
   private static void requireSchemeMatchesCurImp (ItemCategory theItemCat)
d362 1
a362 1
      if (theItemCat.getScheme () != current.getScheme ())
d366 1
a366 1
             + "   A method was called with an ItemCategory argument that\n"
d370 2
a371 2
             + "      ItemCategory:           "
             +        theItemCat             .getName () + "\n"
d373 1
a373 1
             +        theItemCat.getScheme ().getName () + "\n"
d375 1
a375 1
             +        current                .getName () + "\n"
d377 1
a377 1
             +        current   .getScheme ().getName () + "\n"
d414 1
a414 1
   private static void checkNItemCategories (
d418 1
a418 1
      List <ItemCategory> theDimens;
d437 1
a437 1
 * Verifies that the ItemCategories of the Items passed to newTuple match the
d441 1
a441 1
   private static void checkItemCategories (
d446 2
a447 2
      ItemCategory theItemCat;
      ItemCategory theDimen;
d451 1
a451 1
         theItemCat = theCoordArr[theIdx].getItemCategory ();
d453 1
a453 1
         theDimen   = theTupleCat.getDimensions ().get (theIdx);
d455 1
a455 1
         if (theItemCat != theDimen)
d461 1
a461 1
                + "   where the ItemCategory of at least one of the\n"
d466 5
a470 6
                + "\n"
                + "      Coordinate Index:        " + theIdx     + "\n"
                + "      Coordinate ItemCategory: " + theItemCat .getName ()
                + "\n"
                + "      TupleCategory Dimension: " + theDimen   .getName ()
                + "\n");
d566 1
a566 1
 * myItemMgrArr[theItemCat.getIndex ()] is the ItemMgr for theItemCat in this
@


1.24
log
@Moved newTupleCategory from TupleCategory to Scheme.
@
text
@d91 1
a91 1
 * Primitive List method.
d93 5
a97 5
 * @@param  thePrimCat The PrimitiveCategory to which the listed Primitives
 *                    will belong
 * @@return            An unmodifiable List of all of the Primitives of
 *                    thePrimCat in the current Implementation, listed in the
 *                    order in which they were created.
d101 2
a102 2
 * @@throws IllegalArgumentException If the Scheme of thePrimCat does not match
 *                                  the Scheme of the current Implementation
d105 1
a105 1
   public static List <Primitive> getAll (PrimitiveCategory thePrimCat)
d107 1
a107 1
      prohibitNull               (thePrimCat, "thePrimCat");
d109 1
a109 1
      requireSchemeMatchesCurImp (thePrimCat);
d111 1
a111 1
      return getCurPrimitiveMgr (thePrimCat).getPrimitives ();
d113 1
a113 1
   
a179 24
 * Tuple List method
 * 
 * @@param  theTupleCat The TupleCategory to which the retrieved Tuples will
 *                     belong
 * @@return             An unmodifiable List of all of the Tuples of theTupleCat
 *                     in the current Implementation, listed in the order in
 *                     which they were created.
 * 
 * @@throws NullPointerException  If any argument is null
 * @@throws IllegalStateException If the current Implementation is null
 * @@throws IllegalStateException If the Scheme of theTupleCat does not match
 *                               the Scheme of the current Implementation
 *******************************************************************************
 */
   public static List <Tuple> getAll (TupleCategory theTupleCat)
      {
      prohibitNull               (theTupleCat, "theTupleCat");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theTupleCat);
      
      return getCurTupleMgr (theTupleCat).getTuples ();
      }
   
/*******************************************************************************
d281 5
a285 5
      myScheme          = theScheme;
      myName            = theName;
      myPrimitiveMgrArr = newPrimMgrArr  ();
      myTupleMgrArr     = newTupleMgrArr ();
      myStringBuilder   = new StringBuilder (100);
d308 1
a308 2
 * @@return The array of PrimitiveMgrs to which myPrimitiveMgrArr is to be set in
 *         the ctor.
d311 1
a311 1
   private PrimitiveMgr[] newPrimMgrArr ()
d313 3
a315 3
      int            nPrimCats;
      PrimitiveMgr[] thePrimMgrArr;
      int            theIdx;
d317 2
a318 3
      nPrimCats     = myScheme.getPrimitiveCategories ().size ();
      
      thePrimMgrArr = new PrimitiveMgr[nPrimCats];
d320 2
d326 1
a326 1
         thePrimMgrArr[theIdx] = new PrimitiveMgr (this, thePrimCat);
d328 1
a328 19
      
      return thePrimMgrArr;
      }
   
/*******************************************************************************
 * @@return The array of TupleMgrs to which myTupleMgrArr is to be set in the
 *         ctor.
 *******************************************************************************
 */
   private TupleMgr[] newTupleMgrArr ()
      {
      int        nPrimCats;
      TupleMgr[] theTupleMgrArr;
      int        theIdx;
      
      nPrimCats      = myScheme.getTupleCategories ().size ();
      
      theTupleMgrArr = new TupleMgr[nPrimCats];
      
d331 1
a331 1
         theIdx                 = theTupleCat.getIndex ();
d333 1
a333 1
         theTupleMgrArr[theIdx] = new TupleMgr (this, theTupleCat);
d336 1
a336 1
      return theTupleMgrArr;
d518 1
a518 3
      assert (thePrimCat.getScheme () == current.myScheme);
         
      return current.myPrimitiveMgrArr[thePrimCat.getIndex ()];
d527 14
a540 1
      assert (theTupleCat.getScheme () == current.myScheme);
d542 3
a544 1
      return current.myTupleMgrArr[theTupleCat.getIndex ()];
d563 1
a563 1
*/
d567 2
a568 2
 * myPrimitiveMgrArr[thePrimCat.getIndex ()] is the PrimitiveMgr for thePrimCat
 * in this Implementation.
d570 3
a572 10
*/
   private final PrimitiveMgr[] myPrimitiveMgrArr;
   
/*******************************************************************************
 * myTupleMgrArr[theTupleCat.getIndex ()] is the TupleMgr for theTupleCat in
 * this Implementation.
 *******************************************************************************
*/
   private final TupleMgr[] myTupleMgrArr;
   
d576 1
a576 1
*/
@


1.23
log
@A frozen Scheme cannot be the current Scheme.
@
text
@d327 2
a328 2
             + "      Scheme: " + theScheme.getName () + "\n"
             + "      String: " + theName              + "\n");
@


1.22
log
@theImple ==> theImpl
@
text
@a47 2
      Scheme.setCurrentScheme (theScheme);
      
a204 1
 * Also sets the current Scheme to match the current Implementation.
a211 5
      if (theImpl != null)
         Scheme.setCurrentScheme (theImpl.myScheme);
      else
         Scheme.setCurrentScheme (null);
      
@


1.21
log
@Reverting to state as of yesterday 6/8/11 15:00.
@
text
@d209 2
a210 2
 * @@param theImple The Implementation which is to become current.
 *                 (Null is allowed.)
d213 1
a213 1
   public static void setCurrentImplementation (Implementation theImple)
d215 2
a216 2
      if (theImple != null)
         Scheme.setCurrentScheme (theImple.myScheme);
d220 1
a220 1
      current = theImple;
d535 1
a535 1
      Implementation theImple;
d539 1
a539 1
         theImple = theCoordArr[theIdx].getImplementation ();
d541 1
a541 1
         if (theImple != current)
d555 1
a555 1
                + "      Coordinate Implementation: \"" + theImple.getName ()
@


1.20
log
@Revised a comment.
@
text
@a8 1
import static com.ibm.witm.Scheme .getCurrentScheme;
d27 1
a27 1
 * Factory method: Constructs a new Implementation for the current Scheme.<br>
d29 1
d31 6
a36 5
 * @@param  theName               The name of the new Implementation
 * @@return                       The new Implementation
 * @@throws NullPointerException  If any argument is null
 * @@throws IllegalStateException If the current Scheme is null
 * @@throws IllegalStateException If the current Scheme is not frozen
d39 3
a41 1
   public static Implementation newImplementation (String theName)
d43 2
a44 1
      prohibitNull            (theName, "theName");
d46 3
a48 3
      Scheme.requireCurScheme ();
      
      requireCurSchemeFrozen  (theName);
d50 1
a50 1
      current = new Implementation (getCurrentScheme (), theName);
d65 3
a67 2
 * @@throws IllegalArgumentException If thePrimCat does not belong to the
 *                                  current Scheme
d79 5
a83 5
      prohibitNull             (thePrimCat, "thePrimCat");
      prohibitNull             (theName,    "theName");
      requireCurImplementation ();
      requireSchemeIsCur       (thePrimCat);
      prohibitDupName          (thePrimCat, theName);
d103 2
a104 2
 * @@throws IllegalArgumentException If thePrimCat does not belong to the
 *                                  current Scheme
d109 3
a111 3
      prohibitNull             (thePrimCat, "thePrimCat");
      requireCurImplementation ();
      requireSchemeIsCur       (thePrimCat);
d127 3
a129 2
 * @@throws IllegalArgumentException If thePrimCat does not belong to the
 *                                  current Scheme
d134 4
a137 4
      prohibitNull             (thePrimCat, "thePrimCat");
      prohibitNull             (theName,    "theName");
      requireCurImplementation ();
      requireSchemeIsCur       (thePrimCat);
d153 2
a154 2
 * @@throws IllegalArgumentException If theTupleCat does not belong to the
 *                                  current Scheme
d166 7
a172 7
      prohibitNull             (theTupleCat, "theTuple");
      prohibitNullArray        (theCoords,   "theCoords");
      requireCurImplementation ();
      requireSchemeIsCur       (theTupleCat);
      checkNItemCategories     (theTupleCat, theCoords);
      checkItemCategories      (theTupleCat, theCoords);
      requireImpsMatchCur      (theTupleCat, theCoords);
d190 4
a193 6
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalStateException    If the current Implementation is null
 * @@throws IllegalStateException    If the Scheme of theTupleCat does not match
 *                                  the Scheme of the current Implementation
 * @@throws IllegalArgumentException If theTupleCat does not belong to the
 *                                  current Scheme
d198 3
a200 3
      prohibitNull             (theTupleCat, "theTupleCat");
      requireCurImplementation ();
      requireSchemeIsCur       (theTupleCat);
d206 2
a207 1
 * Sets the current Implementation.
d209 2
a210 5
 * @@param theImpl The Implementation which is to become current.
 *                (Null is allowed.)
 *
 * @@throws IllegalArgumentException If the Implementation is not null and does
 *                                  not belong to the current Scheme
d213 1
a213 1
   public static void setCurrentImplementation (Implementation theImpl)
d215 4
a218 1
      requireSchemeIsCur (theImpl);
d220 1
a220 1
      current = theImpl;
d321 1
a321 1
 * Verifies that the current Scheme is frozen.<br>
d325 1
a325 1
   private static void requireCurSchemeFrozen (String theName)
d327 1
a327 1
      if (! getCurrentScheme ().isFrozen ())
d329 1
a329 1
            new IllegalStateException (
d332 2
a333 2
             + "   Implementation.newImplementation (String),\n"
             + "   when the current Scheme is not frozen:\n"
d335 2
a336 3
             + "      Current Scheme: " + getCurrentScheme ().getName () + "\n"
             + "      String:         " + theName                        + "\n"
               );
d396 1
d402 1
d410 1
a410 1
   private static void requireSchemeIsCur (ItemCategory theItemCat)
d412 1
a412 1
      if (theItemCat.getScheme () != getCurrentScheme ())
d417 2
a418 1
             + "   does not belong to the current Scheme.\n"
d420 8
a427 3
             + "      ItemCategory:   " + theItemCat.getName ()    + "\n"
             + "         Scheme:      " + theItemCat.getScheme ()  + "\n"
             + "      Current Scheme: " + getCurrentScheme ()      + "\n"
d535 1
a535 1
      Implementation theImpl;
d539 1
a539 1
         theImpl = theCoordArr[theIdx].getImplementation ();
d541 1
a541 1
         if (theImpl != current)
d555 1
a555 1
                + "      Coordinate Implementation: \"" + theImpl.getName ()
a562 23
 * Verifies that theImpl belongs to the current Scheme.<br>
 * To be called by setCurrentImplementation.
 *******************************************************************************
 */
   private static void requireSchemeIsCur (Implementation theImpl)
      {
      if (theImpl != null)
         if (theImpl.myScheme != getCurrentScheme ())
            throw
               new IllegalArgumentException (
                  "\n\n"
                + "   Call to\n"
                + "   Implementation.setCurrentImplementation (Implementation)"
                + "\n"
                + "   with an Implementation that does not belong to the\n"
                + "   current Scheme.\n"
                + "\n"
                + "      Implementation: \"" + theImpl.getName   () + "\"\n"
                + "         Scheme:      "   + theImpl.getScheme () + "\n"
                + "      Current Scheme: "   + getCurrentScheme  () + "\n");
      }
   
/*******************************************************************************
d568 2
d579 2
d586 1
a586 3
 * methods, if any; otherwise null.<br>
 * Invariant: Whenever the current Implementation is not null, its Scheme will
 * be the current Scheme.
@


1.19
log
@Setting current Implementation requires matching current Scheme.
@
text
@d593 3
a595 1
 * methods, if any; otherwise null.
@


1.18
log
@Testing for current Scheme.
@
text
@d202 1
a202 2
 * Sets the current Implementation.<br>
 * Also sets the current Scheme to match the current Implementation.
d206 3
d213 2
a215 2
      
      Scheme.matchCurSchemeToCurImpl ();
d413 3
a415 6
             + "      ItemCategory:   "
             +        theItemCat                .getName () + "\n"
             + "         Scheme:      "
             +           theItemCat.getScheme ().getName () + "\n"
             + "      Current Scheme: "
             +        getCurrentScheme ()       .getName () + "\n"
d551 23
@


1.17
log
@Checking for ItemCategory in current Scheme.
@
text
@d9 1
d28 1
a28 1
 * Factory method: Constructs a new Implementation.<br>
a29 1
 * The current Scheme is set to the theScheme.
d31 5
a35 6
 * @@param  theScheme                The Scheme to be implemented by the new
 *                                  Implementation
 * @@param  theName                  The name of the new Implementation
 * @@return                          The new Implementation
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If theScheme is not frozen
d38 1
a38 3
   public static Implementation newImplementation (
         Scheme theScheme,
         String theName)
d40 3
a42 2
      prohibitNull (theScheme, "theScheme");
      prohibitNull (theName,   "theName");
d44 1
a44 3
      requireFrozenScheme (theScheme, theName);
   
      current = new Implementation (theScheme, theName);
d46 1
a46 1
      Scheme.matchCurSchemeToCurImpl ();
d314 1
a314 1
 * Verifies that theScheme is frozen.<br>
d318 1
a318 1
   private static void requireFrozenScheme (Scheme theScheme, String theName)
d320 1
a320 1
      if (! theScheme.isFrozen ())
d322 1
a322 1
            new IllegalArgumentException (
d325 2
a326 2
             + "   Implementation.newImplementation (Scheme, String),\n"
             + "   when the Scheme was not frozen:\n"
d328 3
a330 2
             + "      Scheme: " + theScheme.getName () + "\n"
             + "      String: " + theName              + "\n");
a389 1
         {
a394 1
         }
d404 1
a404 1
      if (theItemCat.getScheme () != Scheme.getCurrentScheme ())
d416 1
a416 1
             +        Scheme.getCurrentScheme ().getName () + "\n"
@


1.16
log
@Matching current Scheme to current Implementation.
@
text
@d65 2
a66 3
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does not
 *                                  match the Scheme of the current
 *                                  Implementation
d78 5
a82 5
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
      prohibitDupName            (thePrimCat, theName);
d102 2
a103 2
 * @@throws IllegalArgumentException If the Scheme of thePrimCat does not match
 *                                  the Scheme of the current Implementation
d108 3
a110 3
      prohibitNull               (thePrimCat, "thePrimCat");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
d126 2
a127 3
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does
 *                                  not match the Scheme of the current
 *                                  Implementation
d132 4
a135 4
      prohibitNull               (thePrimCat, "thePrimCat");
      prohibitNull               (theName,    "theName");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (thePrimCat);
d151 2
a152 2
 * @@throws IllegalStateException    If the Scheme of theTupleCat does not match
 *                                  the Scheme of the current Implementation
d164 7
a170 7
      prohibitNull               (theTupleCat, "theTuple");
      prohibitNullArray          (theCoords,   "theCoords");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theTupleCat);
      checkNItemCategories       (theTupleCat, theCoords);
      checkItemCategories        (theTupleCat, theCoords);
      requireImpsMatchCur        (theTupleCat, theCoords);
d188 6
a193 4
 * @@throws NullPointerException  If any argument is null
 * @@throws IllegalStateException If the current Implementation is null
 * @@throws IllegalStateException If the Scheme of theTupleCat does not match
 *                               the Scheme of the current Implementation
d198 3
a200 3
      prohibitNull               (theTupleCat, "theTupleCat");
      requireCurImplementation   ();
      requireSchemeMatchesCurImp (theTupleCat);
d407 1
a407 1
   private static void requireSchemeMatchesCurImp (ItemCategory theItemCat)
d409 1
a409 1
      if (theItemCat.getScheme () != current.getScheme ())
d414 1
a414 2
             + "   belonged to a Scheme that does not match the Scheme of\n"
             + "   the current Implementation.\n"
d416 6
a421 8
             + "      ItemCategory:           "
             +        theItemCat             .getName () + "\n"
             + "         Scheme:              "
             +        theItemCat.getScheme ().getName () + "\n"
             + "      Current Implementation: "
             +        current                .getName () + "\n"
             + "         Scheme:              "
             +        current   .getScheme ().getName () + "\n"
a561 2
      assert (thePrimCat.getScheme () == current.myScheme);
         
a570 2
      assert (theTupleCat.getScheme () == current.myScheme);
         
@


1.15
log
@Current Scheme.
@
text
@d48 1
a48 1
      Scheme.setCurrentScheme (theScheme);
d50 1
a50 1
      current = new Implementation (theScheme, theName);
d209 2
a210 2
 * @@param theImple The Implementation which is to become current.
 *                 (Null is allowed.)
d213 1
a213 1
   public static void setCurrentImplementation (Implementation theImple)
d215 1
a215 4
      if (theImple != null)
         Scheme.setCurrentScheme (theImple.myScheme);
      else
         Scheme.setCurrentScheme (null);
d217 1
a217 1
      current = theImple;
d532 1
a532 1
      Implementation theImple;
d536 1
a536 1
         theImple = theCoordArr[theIdx].getImplementation ();
d538 1
a538 1
         if (theImple != current)
d552 1
a552 1
                + "      Coordinate Implementation: \"" + theImple.getName ()
@


1.14
log
@Moved current Implementation check.
@
text
@d28 2
a29 1
 * The new Implementation becomes the current Implementation.
d48 5
a52 1
      return new Implementation (theScheme, theName);
d206 2
a207 1
 * Sets the current Implementation.
d215 5
d224 1
a224 2
 * @@return The current Implementation in the current Thread, if any;
 *         otherwise null.
d308 1
a308 2
 * Constructor.<br>
 * The new Implementation becomes the current Implementation for the Thread.
a312 5
      assert (theScheme != null);
      assert (theName   != null);
      
      assert (theScheme.isFrozen ());
      
a317 2
   
      current           = this;
@


1.13
log
@Minor revision.
@
text
@d388 16
@


1.12
log
@Removed some unneeded mathods.
@
text
@d203 2
a204 2
 * @@param theImp The Implementation which is to become current.
 *               (Null is allowed.)
d207 1
a207 1
   public static void setCurrentImplementation (Implementation theImp)
d209 1
a209 1
      current = theImp;
d517 1
a517 1
      Implementation theImp;
d521 1
a521 1
         theImp = theCoordArr[theIdx].getImplementation ();
d523 1
a523 1
         if (theImp != current)
d537 1
a537 1
                + "      Coordinate Implementation: \"" + theImp.getName ()
@


1.11
log
@Moved getAll (TupleCategory).
@
text
@d148 2
d161 7
a167 6
      prohibitNull             (theTupleCat, "theTuple");
      prohibitNullArray        (theCoords,   "theCoords");
      requireCurImplementation ();
      checkNItemCategories     (theTupleCat, theCoords);
      checkItemCategories      (theTupleCat, theCoords);
      requireImpsMatchCur      (theTupleCat, theCoords);
d185 1
d187 1
a187 1
 * @@throws IllegalStateException If the Scheme of theTupleCate does not match
a257 11
 * @@return the TupleMgr for theTupleCat in this Implementation.
 *******************************************************************************
 */
   TupleMgr getTupleMgr (TupleCategory theTupleCat)
      {
      assert (theTupleCat.getScheme () == myScheme);
         
      return myTupleMgrArr[theTupleCat.getIndex ()];
      }
   
/*******************************************************************************
@


1.10
log
@Renaming
@
text
@d104 1
a104 1
      prohibitNull               (thePrimCat, "thePrimitiveCategory");
d159 1
a159 1
      prohibitNull             (theTupleCat, "theTupleCategory");
d174 11
a184 12
 * Factory method:<br>
 * Constructs a new Tuple of this TupleCategory
 *
 * @@param theCoords                 The Items that are to be the coordinates
 *                                  of the Tuple
 * @@return                          The new Tuple
 * @@throws NullPointerException     If any argument is null
 * @@throws IllegalArgumentException If the ItemCategories of the Items do not
 *                                  match the corresponding dimension
 *                                  ItemCategories of this TupleCategory
 * @@throws IllegalArgumentException If the Items do not all belong to the 
 *                                  same Implementation
d186 2
a187 2
 *//*
   public Tuple newTuple (Item... theCoords)
d189 3
a191 1
      Implementation theImp;
d193 2
a194 3
      prohibitNullArray   (theCoords, "theCoords");
      
      checkItemCategories (theCoords);
a195 7
      requireImpsMatch    (theCoords);
      
      theImp = theCoords[0].getImplementation ();

      return new Tuple (this, theImp, theCoords);
      }
*/   
@


1.9
log
@Revised some messsages.
@
text
@d54 1
a54 1
 * @@param  thePrimitiveCategory     The PrimitiveCategory to which the Primitive
d69 1
a69 1
         PrimitiveCategory thePrimitiveCategory,
d74 2
a75 2
      prohibitNull               (thePrimitiveCategory, "thePrimitiveCategory");
      prohibitNull               (theName,              "theName");
d77 2
a78 2
      requireSchemeMatchesCurImp (thePrimitiveCategory);
      prohibitDupName            (thePrimitiveCategory, theName);
d80 1
a80 1
      thePrim = new Primitive (thePrimitiveCategory, theName, current);
d82 1
a82 1
      getCurPrimitiveMgr (thePrimitiveCategory).store (thePrim);
d90 5
a94 6
 * @@param  thePrimitiveCategory The PrimitiveCategory to which the listed 
 *                              Primitives will belong
 * @@return                      An unmodifiable List of all of the Primitives of
 *                              thePrimitiveCategory in the current
 *                              Implementation, listed in the order in which
 *                              they were created.
d98 2
a99 3
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveCategory does
 *                                  not match the Scheme of the current
 *                                  Implementation
d102 1
a102 2
   public static List <Primitive> getAll (
         PrimitiveCategory thePrimitiveCategory)
d104 1
a104 1
      prohibitNull               (thePrimitiveCategory, "thePrimitiveCategory");
d106 1
a106 1
      requireSchemeMatchesCurImp (thePrimitiveCategory);
d108 1
a108 1
      return getCurPrimitiveMgr (thePrimitiveCategory).getPrimitives ();
d114 5
a118 7
 * @@param  thePrimitiveCategory The PrimitiveCategory to which the retrieved
 *                              Primitive is to belong
 * @@param  theName              The name of the Primitive to be retrieved
 * 
 * @@return                      The Primitive of thePrimitiveCategory in the
 *                              current  Implementation whose name matches
 *                              theName, if any; otherwise null
d127 1
a127 3
   public static Primitive get (
         PrimitiveCategory thePrimitiveCategory,
         String            theName)
d129 2
a130 2
      prohibitNull               (thePrimitiveCategory, "thePrimitiveCategory");
      prohibitNull               (theName,              "theName");
d132 1
a132 1
      requireSchemeMatchesCurImp (thePrimitiveCategory);
d134 1
a134 1
      return getCurPrimitiveMgr (thePrimitiveCategory).getPrimitive (theName);
d141 1
a141 1
 * @@param theTupleCategory          The TupleCategory to which the Tuple is to
d150 1
a150 1
 *                                  ItemCategories of theTupleCategory
d155 1
a155 3
   public static Tuple newTuple ( 
         TupleCategory theTupleCategory,
         Item...       theCoords)
d159 2
a160 2
      prohibitNull             (theTupleCategory, "theTupleCategory");
      prohibitNullArray        (theCoords,        "theCoords");
d162 3
a164 3
      checkNItemCategories     (theTupleCategory, theCoords);
      checkItemCategories      (theTupleCategory, theCoords);
      requireImpsMatchCur      (theTupleCategory, theCoords);
d166 1
a166 1
      theTuple = new Tuple (theTupleCategory, current, theCoords);
d168 1
a168 1
      getCurTupleMgr (theTupleCategory).store (theTuple);
@


1.8
log
@Moved newTuple from TupleCategory to Implementation.
@
text
@d353 2
a354 2
             + "   Implementation.newImplementation (theScheme, theName),\n"
             + "   when theScheme was not frozen:\n"
d356 2
a357 2
             + "      theScheme: " + theScheme.getName () + "\n"
             + "      theName:   " + theName              + "\n");
d455 3
a457 3
             + "   Implementation.newPrimitive (thePrimitiveCategory, theName),\n"
             + "   where the theName matches the name of an existing\n"
             + "   Primitive of thePrimitiveCategory in the current\n"
d461 1
a461 1
             + "      Name:              \"" +            theName    + "\"\n");
d482 3
a484 3
             + "   Implementation.newTuple (theTupleCategory, theCoords)\n"
             + "   where the number of coordinates does not match the number\n"
             + "   of dimensions in theTupleCategory.\n"
d486 3
a488 3
             + "      TupleCategory: " + theTupleCat.getName () + "\n"
             + "      # Coordinates: " + theCoordArr.length     + "\n"
             + "      # Dimensions:  " + theDimens  .size ()    + "\n");         
d515 1
a515 1
                + "   Implementation.newTuple (theTupleCategory, theCoords)\n"
d517 2
a518 2
                + "   coordinates does not match the corresponding dimension\n"
                + "   of theTupleCategory.\n"
d551 3
a553 3
                + "   Implementation.newTuple (theTupleCategory, theCoords)\n"
                + "   where at least one of the coordinates does not belong\n"
                + "   to the current Implementation.\n"
@


1.7
log
@Type ==> Category
@
text
@d145 69
a213 1
 * Sets the current Implementation in the current Thread.
a360 18
 * Verifies that this Scheme is frozen.<br>
 * To be called by newImplementation (theName).
 *******************************************************************************
 *//*
   private void requireFrozen (String theName)
      {
      if (! frozen)
         throw
            new IllegalStateException (
               "\n\n"
             + "   Call to theScheme.newImplementation (theName), when\n"
             + "   theScheme was not frozen:\n"
             + "\n"
             + "      theScheme: " + this    + "\n"
             + "      theName:   " + theName + "\n");
      }
*/
/*******************************************************************************
a417 1
         {
a433 1
         }
d465 103
d579 11
@


1.6
log
@Element     ==> Item
ElementType ==> ItemTYpe
@
text
@d54 1
a54 1
 * @@param  thePrimitiveType         The PrimitiveType to which the Primitive
d60 1
a60 1
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveType does not
d64 1
a64 1
 *                                  Primitive of thePrimitiveType in the
d69 2
a70 2
         PrimitiveType thePrimitiveType,
         String        theName)
d74 2
a75 2
      prohibitNull               (thePrimitiveType, "thePrimitiveType");
      prohibitNull               (theName,          "theName");
d77 2
a78 2
      requireSchemeMatchesCurImp (thePrimitiveType);
      prohibitDupName            (thePrimitiveType, theName);
d80 1
a80 1
      thePrim = new Primitive (thePrimitiveType, theName, current);
d82 1
a82 1
      getCurPrimitiveMgr (thePrimitiveType).store (thePrim);
d90 6
a95 5
 * @@param  thePrimitiveType The PrimitiveType to which the listed Primitives
 *                          will belong
 * @@return                  An unmodifiable List of all of the Primitives of
 *                          thePrimitiveType in the current Implementation,
 *                          listed in the order in which they were created.
d99 2
a100 2
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveType does not
 *                                  match the Scheme of the current
d104 2
a105 1
   public static List <Primitive> getAll (PrimitiveType thePrimitiveType)
d107 1
a107 1
      prohibitNull               (thePrimitiveType, "thePrimitiveType");
d109 1
a109 1
      requireSchemeMatchesCurImp (thePrimitiveType);
d111 1
a111 1
      return getCurPrimitiveMgr (thePrimitiveType).getPrimitives ();
d117 3
a119 3
 * @@param  thePrimitiveType The PrimitiveType to which the retrieved Primitive
 *                          is to belong
 * @@param  theName          The name of the Primitive to be retrieved
d121 3
a123 3
 * @@return                  The Primitive of thePrimitiveType in the current 
 *                          Implementation whose name matches theName, if any;
 *                          otherwise null
d127 2
a128 2
 * @@throws IllegalArgumentException If the Scheme of thePrimitiveType does not
 *                                  match the Scheme of the current
d132 3
a134 1
   public static Primitive get (PrimitiveType thePrimitiveType, String theName)
d136 2
a137 2
      prohibitNull               (thePrimitiveType, "thePrimitiveType");
      prohibitNull               (theName,          "theName");
d139 1
a139 1
      requireSchemeMatchesCurImp (thePrimitiveType);
d141 1
a141 1
      return getCurPrimitiveMgr (thePrimitiveType).getPrimitive (theName);
d202 1
a202 1
 * @@return the TupleMgr for thePrimType in this Implementation.
d205 1
a205 1
   TupleMgr getTupleMgr (TupleType theTupleType)
d207 1
a207 1
      assert (theTupleType.getScheme () == myScheme);
d209 1
a209 1
      return myTupleMgrArr[theTupleType.getIndex ()];
d224 1
a224 1
      myStringBuilder.append (theTuple.getTupleType ().getName ());
d317 1
a317 1
      int            nPrimTypes;
d321 1
a321 1
      nPrimTypes    = myScheme.getPrimitiveTypes ().size ();
d323 1
a323 1
      thePrimMgrArr = new PrimitiveMgr[nPrimTypes];
d325 1
a325 1
      for (PrimitiveType thePrimType: myScheme.getPrimitiveTypes ())
d327 1
a327 1
         theIdx                = thePrimType.getIndex ();
d329 1
a329 1
         thePrimMgrArr[theIdx] = new PrimitiveMgr (this, thePrimType);
d342 1
a342 1
      int        nPrimTypes;
d346 1
a346 1
      nPrimTypes     = myScheme.getTupleTypes ().size ();
d348 1
a348 1
      theTupleMgrArr = new TupleMgr[nPrimTypes];
d350 1
a350 1
      for (TupleType thePrimType: myScheme.getTupleTypes ())
d352 1
a352 1
         theIdx                 = thePrimType.getIndex ();
d354 1
a354 1
         theTupleMgrArr[theIdx] = new TupleMgr (this, thePrimType);
d361 1
a361 1
 * Verifies that the Scheme of theItemType matches the Scheme of the
d365 1
a365 1
   private static void requireSchemeMatchesCurImp (ItemType theItemType)
d367 1
a367 1
      if (theItemType.getScheme () != current.getScheme ())
d372 1
a372 1
             + "   A method was called with an ItemType argument that\n"
d376 2
a377 2
             + "      ItemType:               "
             +        theItemType             .getName () + "\n"
d379 1
a379 1
             +        theItemType.getScheme ().getName () + "\n"
d381 1
a381 1
             +        current                 .getName () + "\n"
d383 1
a383 1
             +        current    .getScheme ().getName () + "\n"
d390 2
a391 2
 * thePrimitiveType in the current Implementation.<br>
 * To be called by newPrimitive (thePrimitiveType, theName).
d395 2
a396 2
         PrimitiveType thePrimitiveType,
         String        theName)
d400 1
a400 1
      thePrim = getCurPrimitiveMgr (thePrimitiveType).getPrimitive (theName);
d407 1
a407 1
             + "   Implementation.newPrimitive (thePrimitiveType, theName),\n"
d409 1
a409 1
             + "   Primitive of thePrimitiveType in the current\n"
d412 2
a413 2
             + "      PrimitiveType: "   + thePrimitiveType.getName () + "\n"
             + "      Name:          \"" +                  theName    + "\"\n");
d417 1
a417 1
 * @@return the PrimitiveMgr for thePrimType in the current Implementation.
d420 1
a420 1
   private static PrimitiveMgr getCurPrimitiveMgr (PrimitiveType thePrimType)
d422 1
a422 1
      assert (thePrimType.getScheme () == current.myScheme);
d424 1
a424 1
      return current.myPrimitiveMgrArr[thePrimType.getIndex ()];
d447 2
a448 2
 * myPrimitiveMgrArr[thePrimType.getIndex ()] is the PrimitiveMgr for
 * thePrimType in this Implementation.
d454 2
a455 2
 * myTupleMgrArr[theTupleType.getIndex ()] is the TupleMgr for thePrimType
 * in this Implementation.
@


1.5
log
@getPrimitiveMgr
@
text
@d357 1
a357 1
 * Verifies that the Scheme of theElementType matches the Scheme of the
d361 1
a361 1
   private static void requireSchemeMatchesCurImp (ElementType theElementType)
d363 1
a363 1
      if (theElementType.getScheme () != current.getScheme ())
d368 1
a368 1
             + "   A method was called with an ElementType argument that\n"
d372 2
a373 2
             + "      ElementType:            "
             +        theElementType             .getName () + "\n"
d375 1
a375 1
             +        theElementType.getScheme ().getName () + "\n"
d377 1
a377 1
             +        current                    .getName () + "\n"
d379 1
a379 1
             +        current       .getScheme ().getName () + "\n"
@


1.4
log
@Moved get (PT, Name).
@
text
@d72 2
d80 5
a84 1
      return new Primitive (thePrimitiveType, theName, current);
d109 1
a109 1
      return current.getPrimitiveMgr (thePrimitiveType).getPrimitives ();
d137 1
a137 1
      return current.getPrimitiveMgr (thePrimitiveType).getPrimitive (theName);
a197 11
 * @@return the PrimitiveMgr for thePrimType in this Implementation.
 *******************************************************************************
 */
   PrimitiveMgr getPrimitiveMgr (PrimitiveType thePrimType)
      {
      assert (thePrimType.getScheme () == myScheme);
         
      return myPrimitiveMgrArr[thePrimType.getIndex ()];
      }
   
/*******************************************************************************
d396 1
a396 2
      thePrim =
         current.getPrimitiveMgr (thePrimitiveType).getPrimitive (theName);
d413 11
@


1.3
log
@Moved getAll.
@
text
@d82 1
a82 1
 * Primitive List method
d84 5
a88 3
 * @@return An unmodifiable List of all of the Primitives of thePrimitiveType
 *         in the current Implementation, listed in the order in which they were
 *         created.
d107 1
a107 1
 * Primitive List method
d109 3
a111 3
 * @@return An unmodifiable List of all of the Primitives of this PrimitiveType
 *         in the current Implementation, listed in the order in which they were
 *         created.
d113 9
a121 3
 * @@throws IllegalStateException If the current Implementation is null
 * @@throws IllegalStateException If the Scheme of this PrimitiveType does not
 *                               match the Scheme of the current Implementation
d123 2
a124 2
 *//*
   public List <Primitive> getAll ()
d126 2
d129 1
a129 1
      requireSchemeMatchesCurImp ();
d131 1
a131 1
      return getPrimitiveMgr ().getPrimitives ();
d133 1
a133 1
*/   
@


1.2
log
@Moved some factory methods.
@
text
@d82 43
@


1.1
log
@Embodiment ==> Implementation
@
text
@d17 1
a17 3
 * Please Note:<br>
 * The factory method for creating instances of this class is method
 * newImplementation of class Scheme.
d27 55
d90 1
a90 1
      currentImplementation = theImp;
d100 1
a100 1
      return currentImplementation;
a138 21
 * Constructor.<br>
 * The new Implementation becomes the current Implementation for the Thread.
 *******************************************************************************
 */
   Implementation (Scheme theScheme, String theName)
      {
      assert (theScheme != null);
      assert (theName   != null);
      
      assert (theScheme.isFrozen ());
      
      myScheme              = theScheme;
      myName                = theName;
      myPrimitiveMgrArr     = newPrimMgrArr  ();
      myTupleMgrArr         = newTupleMgrArr ();
      myStringBuilder       = new StringBuilder (100);
   
      currentImplementation = this;
      }

/*******************************************************************************
d201 58
d309 59
a367 2
 * currentImplementation is the current Implementation that will be used by
 * various WIT-M methods, if any; otherwise null.
d370 1
a370 1
   private static Implementation currentImplementation = null;
d373 1
a373 1
 * The Scheme of this Implementation
@


head	1.132;
access;
symbols
	start:1.1.1.1 dummy-vendor:1.1.1;
locks; strict;
comment	@# @;


1.132
date	2011.10.10.21.13.54;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2011.10.10.20.22.20;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2011.10.07.23.02.04;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.05.22.51.43;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2011.10.05.22.18.18;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2011.10.04.22.35.53;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2011.09.30.21.52.19;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2011.09.22.22.19.35;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2011.09.21.20.32.58;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2011.09.20.23.42.15;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2011.09.20.23.22.25;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2011.09.20.19.32.38;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2011.09.14.23.14.39;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2011.09.14.21.40.31;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2011.09.14.21.38.25;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2011.09.14.20.59.01;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2011.09.14.19.02.15;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2011.09.14.16.26.50;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2011.09.14.15.31.40;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2011.09.14.15.06.28;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2011.09.13.23.25.23;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2011.09.13.22.53.07;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2011.09.13.20.48.12;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2011.09.10.00.18.15;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2011.09.09.21.17.48;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2011.09.09.16.09.21;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2011.09.08.23.04.35;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.08.10.23.25.12;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.22.23.47.27;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.07.22.20.05.28;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.07.22.17.51.17;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.22.16.15.36;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.21.21.44.52;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.21.18.05.51;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.21.16.27.46;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2011.07.20.23.49.47;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2011.07.20.22.51.05;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.20.22.13.47;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.20.20.18.30;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.20.19.16.52;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.20.16.35.29;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.19.21.37.10;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.19.21.13.22;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2011.07.15.23.19.05;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2011.07.15.21.46.59;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.07.15.17.42.37;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.07.14.23.53.12;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.14.22.55.07;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.07.14.20.24.07;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2011.07.13.23.35.34;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2011.07.13.23.06.25;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2011.07.12.22.40.04;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2011.07.08.23.31.59;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.07.08.20.46.06;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.08.15.44.06;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.08.15.11.04;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.07.19.29.42;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2011.07.07.19.05.07;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.06.22.29.22;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2011.07.06.17.32.47;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2011.07.05.21.15.09;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.05.20.01.49;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.01.22.30.04;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.01.22.12.57;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.01.21.37.33;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.01.21.17.44;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.01.20.57.53;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.01.20.44.52;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.01.20.17.38;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.01.18.51.36;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.01.16.24.33;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.01.15.56.27;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.01.14.15.36;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.30.23.56.15;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.30.23.43.55;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.29.14.22.33;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.24.20.29.52;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.24.19.47.41;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.24.19.32.18;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.06.24.16.42.36;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.23.23.15.45;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.23.22.53.15;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2011.06.22.22.09.49;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2011.06.22.19.31.04;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2011.06.20.21.44.08;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.20.17.48.41;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.17.18.23.11;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.16.16.26.29;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.16.16.11.42;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.15.22.25.24;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.10.21.13.51;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.10.19.37.26;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.09.23.27.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.09.22.12.03;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.09.18.19.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.09.18.09.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.08.22.40.13;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.08.20.14.03;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.07.23.38.55;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.07.22.05.21;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.07.20.56.05;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.07.18.37.12;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.06.20.33.39;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.06.16.39.12;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.03.23.15.53;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.03.22.48.07;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.03.22.23.48;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.05.31.19.26.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.27.23.55.15;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.27.22.12.28;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.27.21.22.46;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.26.23.40.17;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.26.22.58.19;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.26.22.32.22;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.26.21.24.29;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.26.21.00.53;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.26.00.17.19;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.25.21.39.30;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.25.19.16.33;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.24.18.46.21;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.24.17.56.52;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.24.00.11.55;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.22.02.10.54;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.20.23.52.04;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.20.19.52.37;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.20.19.26.56;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.20.18.18.57;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.18.19.55.02;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.18.17.46.08;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.17.20.58.46;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.17.17.57.02;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.16.22.08.54;	author rjw;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.05.16.22.08.54;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.132
log
@getCellAsPrimitive (...)
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M/Test Source File UnitTester.java.
////////////////////////////////////////////////////////////////////////////////

package com.ibm.witm.test;

import com.ibm.witj.BomEntry;
import com.ibm.witj.BopEntry;
import com.ibm.witj.Demand;
import com.ibm.witj.Operation;
import com.ibm.witj.Part;
import com.ibm.witj.Substitute;

import com.ibm.witm.DimensionID;
import com.ibm.witm.InputRow;
import com.ibm.witm.InputTable;
import com.ibm.witm.BooleanByPeriod;
import com.ibm.witm.DoubleByPeriod;
import com.ibm.witm.ModelInstance;
import com.ibm.witm.Period;
import com.ibm.witm.IntegerByPeriod;
import com.ibm.witm.Tuple;
import com.ibm.witm.TupleCategory;
import com.ibm.witm.Item;
import com.ibm.witm.Primitive;
import com.ibm.witm.PrimitiveCategory;
import com.ibm.witm.Property;
import com.ibm.witm.ModelScheme;

import static com.ibm.witm.ModelScheme   .*;
import static com.ibm.witm.ModelInstance .*;
import static com.ibm.witm.WitJHandler.*;

import static com.ibm.witj.Attribute.*;
import static com.ibm.witj.Part.Category.*;

/*******************************************************************************
 * Responsible for performing a unit test of WIT-M.
 *******************************************************************************
 */
final class UnitTester
{
////////////////////////////////////////////////////////////////////////////////
// Private Static Fields
//
// Declaration of the UNIT_TEST ModelScheme and its elements.
// UNIT_TEST is the main ModelScheme for the unit test.
////////////////////////////////////////////////////////////////////////////////

   private static final ModelScheme                UNIT_TEST;
   
   private static final PrimitiveCategory          GLOBAL;
   private static final Property <Double>          GLOBAL_DBL;
   
   private static final PrimitiveCategory          A;
   private static final Property <Integer>         A_INT;
   private static final Property <DoubleByPeriod>  A_DBP;
   private static final Property <IntegerByPeriod> A_IBP;
   private static final Property <BooleanByPeriod> A_BBP;
   private static final Property <Part>            A_MAT;
   private static final Property <Part>            A_CAP;
   
   private static final PrimitiveCategory          B;
   private static final Property <Operation>       B_OPN;
   private static final Property <Demand>          B_DEM;
   
   private static final TupleCategory              A_B_A;
   private static final DimensionID <Primitive>    A_0;
   private static final DimensionID <Primitive>    A_2;
   private static final Property <String>          A_B_A_STR;
   private static final Property <Part>            A_B_A_MAT;
   private static final Property <BomEntry>        A_B_A_BOM;
   private static final Property <BopEntry>        A_B_A_BOP;
   private static final Property <Substitute>      A_B_A_SUB;
   
   private static final TupleCategory              B_ABA;
   
////////////////////////////////////////////////////////////////////////////////
// Static Initialization Block
//
// Construction of the UNIT_TEST ModelScheme and its elements.
////////////////////////////////////////////////////////////////////////////////
   
   static
      {
      UNIT_TEST  =        newModelScheme       ("UNIT_TEST");
      
      GLOBAL     =        getGlobalCategory    ();
      GLOBAL_DBL = GLOBAL.newProperty          ("GLOBAL_DBL", Double.class);
      
      A          =        newPrimitiveCategory ("A");
      A_INT      = A.     newProperty          ("A_INT",      Integer.class);
      A_DBP      = A.     newProperty          ("A_DBP",      DoubleByPeriod.
                                                              class);
      A_IBP      = A.     newProperty          ("A_IBP",      IntegerByPeriod.
                                                              class);
      A_BBP      = A.     newProperty          ("A_BBP",      BooleanByPeriod.
                                                              class);
      A_MAT      = A.     newProperty          ("A_MAT",      Part.class);
      A_CAP      = A.     newProperty          ("A_CAP",      Part.class);
      
      B          =        newPrimitiveCategory ("B");
      B_OPN      = B.     newProperty          ("B_OPN",      Operation.class);
      B_DEM      = B.     newProperty          ("B_DEM",      Demand.class);
      
      A_B_A      =        newTupleCategory     ("A_B_A",      A, B, A);
      A_0        = A_B_A. newDimensionID       ("A_0",        A, 0); 
      A_2        = A_B_A. newDimensionID       ("A_2",        A, 2); 
      A_B_A_STR  = A_B_A. newProperty          ("A_B_A_STR",  String.class);
      A_B_A_MAT  = A_B_A. newProperty          ("A_B_A_MAT",  Part.class);
      A_B_A_BOM  = A_B_A. newProperty          ("A_B_A_BOM",  BomEntry.class);
      A_B_A_BOP  = A_B_A. newProperty          ("A_B_A_BOP",  BopEntry.class);
      A_B_A_SUB  = A_B_A. newProperty          ("A_B_A_SUB",  Substitute.class);
      
      B_ABA      =        newTupleCategory     ("B_ABA",      B, A_B_A);
      }

////////////////////////////////////////////////////////////////////////////////
// Private Static Fields
//
// Declaration of the POK ModelScheme and its elements.
// POK is the ModelScheme for tests of classes InputTable and InputRow.
////////////////////////////////////////////////////////////////////////////////
   
   private static final ModelScheme       POK;
   
   private static final PrimitiveCategory AREA;

////////////////////////////////////////////////////////////////////////////////
// Static Initialization Block
//
// Construction of the POK ModelScheme and its elements.
////////////////////////////////////////////////////////////////////////////////
   
   static
      {
      POK  = newModelScheme       ("POK");
      
      AREA = newPrimitiveCategory ("Area");
      
      freezeCurrentModelScheme ();
      }
   
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The main ModelInstance for the unit test.
 *******************************************************************************
 */
   private ModelInstance unitTestModInst;
   
/*******************************************************************************
 * The ModelInstance for the tests of InputTable and InputRow.
 *******************************************************************************
 */                     @@SuppressWarnings("unused")
   private ModelInstance pokModInst;
   
////////////////////////////////////////////////////////////////////////////////
// Private Constructor
////////////////////////////////////////////////////////////////////////////////

   private UnitTester ()
      {
      unitTestModInst = null;
      pokModInst      = null;
      }

////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Tests class ModelScheme.
 *******************************************************************************
 */
   private void testModelScheme ()
      {
      assert (getCurrentModelScheme () == null);
      
      setCurrentModelScheme (UNIT_TEST);
      
      System.out.printf (
         "%n"
       + "ModelScheme %s:%n"
       + "   Name:   \"%s\"%n"
       + "   Frozen: %s%n",
         UNIT_TEST,
         UNIT_TEST.getName (),
         UNIT_TEST.isFrozen ());
      
      System.out.printf (
         "%n"
       + "----------------------------------------"
       + "----------------------------------------%n%n");
      
      UNIT_TEST.print    (System.out);
      
      System.out.printf (
         "----------------------------------------"
       + "----------------------------------------%n");
      
      freezeCurrentModelScheme ();
      }

/*******************************************************************************
 * Tests class PrimitiveCategory.
 *******************************************************************************
 */
   private void testPrimitiveCategory ()
      {
      System.out.printf (
         "%n"
       + "PrimitiveCategory %s:%n"
       + "   ModelScheme: \"%s\"%n"
       + "   Name:        \"%s\"%n",
         A,
         A.getModelScheme ().getName (),
         A                  .getName ());
      }

/*******************************************************************************
 * Tests class TupleCategory.
 *******************************************************************************
 */
   private void testTupleCategory ()
      {
      System.out.printf (
         "%n"
       + "TupleCategory %s:%n"
       + "   ModelScheme: \"%s\"%n"
       + "   Name:        \"%s\"%n",
         A_B_A,
         A_B_A.getModelScheme ().getName (),
         A_B_A                  .getName ());
      }

/*******************************************************************************
 * Tests class DimensionID.
 *******************************************************************************
 */
   private void testDimensionID ()
      {
      System.out.printf (
         "%n"
       + "DimensionID %s%n",
         A_2);
      }

/*******************************************************************************
 * Tests class Property.
 *******************************************************************************
 */
   private void testProperty ()
      {
      System.out.printf (
         "%n"
       + "Property %s:%n"
       + "   Name:         %s%n"
       + "   Value Type:   %s%n"
       + "   ItemCategory: %s%n",
         A_INT,
         A_INT                   .getName       (),
         A_INT.getValueType    ().getSimpleName (),
         A_INT.getItemCategory ().getName       ());
      }

/*******************************************************************************
 * Tests class ModelInstance.
 *******************************************************************************
 */
   private void testModelInstance ()
      {
      assert (getCurrentModelInstance () == null);
      
      unitTestModInst = UNIT_TEST.newModelInstance ("Unit-Test");
      
      System.out.printf (
         "%n"
       + "ModelInstance \"%s\":%n"
       + "   ModelScheme: \"%s\"%n"
       + "   Name:        \"%s\"%n",
         unitTestModInst,
         unitTestModInst.getModelScheme ().getName (),
         unitTestModInst                  .getName ());
      
      UNIT_TEST.newModelInstance ("ModelInstance #2");

      System.out.printf (
         "%n"
       + "Current ModelInstance: \"%s\"%n",
         getCurrentModelInstance ().getName ());
      
      setCurrentModelInstance (unitTestModInst);
      
      System.out.printf (
         "%n"
       + "Current ModelInstance: \"%s\"%n",
         getCurrentModelInstance ().getName ());
      }

/*******************************************************************************
 * Tests class Primitive.
 *******************************************************************************
 */
   private void testPrimitive ()
      {
      Primitive theA;
      Primitive foundPrim;
      
      theA = A.newPrimitive ("1");
             B.newPrimitive ("2");
             A.newPrimitive ("3");

      System.out.printf (
         "%n"
       + "%s:%n"
       + "   ModelInstance:     \"%s\"%n"
       + "   ItemCategory:      \"%s\"%n"
       + "   PrimitiveCategory: \"%s\"%n"
       + "   Name:              \"%s\"%n",
         theA,
         theA.getModelInstance     ().getName (),
         theA.getItemCategory      ().getName (),
         theA.getPrimitiveCategory ().getName (),
         theA                        .getName ());
      
      foundPrim = A.get ("1");

      assert (foundPrim == theA);

      System.out.printf (
         "%n"
       + "A Primitives:%n");
      
      for (Primitive thePrim: A.getAll ())
         {
         System.out.printf ("   %s%n", thePrim);
         }
      
      System.out.printf (
         "%n"
       + "Global Primitive: %s%n",
         getGlobalPrimitive ());
      }
   
/*******************************************************************************
 * Tests class Tuple.
 *******************************************************************************
 */
   private void testTuple ()
      {
      Primitive theA1;
      Primitive theB2;
      Primitive theA3;
      Tuple     theA1_B2_A3;
      Tuple     theA_B_A;
      Tuple     theB_ABA;
      Primitive thePrim;
      String    theText;

      theA1       = A.get ("1");
      theB2       = B.get ("2");
      theA3       = A.get ("3");
      
      theA1_B2_A3 = A_B_A.newTuple (theA1, theB2, theA3);
      
      A_B_A.newTuple (theA1, theB2, theA1);
      
      assert (theA1_B2_A3.getTupleCategory () == A_B_A);
      
      System.out.printf (
         "%n"
       + "%s:%n",
         theA1_B2_A3);
      
      System.out.printf (
         "%n"
       + "   B Coordinate: %s%n",
         theA1_B2_A3.get (B));
      
      System.out.printf (
         "%n"
       + "All Tuples of type A_B_A:%n");
      
      for (Tuple locA_B_A: A_B_A.getAll ())
         {
         System.out.printf (
            "   %s%n",
            locA_B_A);
         }
      
      theA_B_A = A_B_A.get (theA3, theB2, theA1);
      
      assert (theA_B_A == null);
      
      theA_B_A = A_B_A.get (theA1, theB2, theA3);
      
      assert (theA_B_A == theA1_B2_A3);
      
      theA_B_A.set (A_B_A_STR, "ABA Text");
      
      theText = theA_B_A.get (A_B_A_STR);
      
      assert (theText.equals ("ABA Text"));
      
      theB_ABA = B_ABA.newTuple (theB2, theA1_B2_A3);
      
      System.out.printf (
         "%n"
       + "The B_ABA:%n"
       + "   %s%n",
         theB_ABA);
         
      thePrim  = theB_ABA.get (A_B_A).get (B);
      
      assert (thePrim == theB2);
      
      thePrim = theA1_B2_A3.get (A_2);
      
      assert (thePrim == theA3);
      }
   
/*******************************************************************************
 * Tests getSliceSparse (...) and getSliceDense (...) on thePattern.
 *******************************************************************************
 */
   private void testSlice (String thePatternText, Item...  thePattern)
      {
      System.out.printf (
         "%n"
         + "Slice (" + thePatternText + "):%n");
      
      System.out.printf ("   Sparse:%n");
      
      for (Tuple theTuple: A_B_A.getSliceSparse (thePattern))
         System.out.printf ("      %s%n", theTuple);
      
      System.out.printf ("   Dense:%n");
      
      for (Tuple theTuple: A_B_A.getSliceDense (thePattern))
         System.out.printf ("      %s%n", theTuple);
      }
  
/*******************************************************************************
 * Tests getSliceSparse (...) and getSliceDense (...).
 *******************************************************************************
 */
   private void testSlice ()
      {
      Primitive A1;
      Primitive A2;
      Primitive A3;
      Primitive B1;
      Primitive B2;
      
      UNIT_TEST.newModelInstance ("Slice Test");
      
      A1 = A.newPrimitive ("1");
      A2 = A.newPrimitive ("2");
      A3 = A.newPrimitive ("3");
      B1 = B.newPrimitive ("1");
      B2 = B.newPrimitive ("2");
      
      A_B_A.newTuple (A3, B2, A3);
      A_B_A.newTuple (A3, B2, A1);
      A_B_A.newTuple (A3, B1, A2);
      A_B_A.newTuple (A2, B2, A3);
      A_B_A.newTuple (A2, B2, A1);
      A_B_A.newTuple (A2, B1, A2);
      A_B_A.newTuple (A1, B2, A2);
      A_B_A.newTuple (A1, B1, A3);
      A_B_A.newTuple (A1, B1, A1);
      
      System.out.printf (
         "%n"
         + "Tuples for the Slice Test:%n");
      
      for (Tuple theTuple: A_B_A.getAll ())
         System.out.printf ("   %s%n", theTuple);
      
      testSlice ("A2, B2, A3",         A2,   B2,   A3);
      testSlice ("A2, B2, A2",         A2,   B2,   A2);
      testSlice ("Null, B1, A2",     null,   B1,   A2);
      testSlice ("A2, Null, Null",     A2, null, null);
      testSlice ("Null, Null, Null", null, null, null);
      
      setCurrentModelInstance (unitTestModInst);
      }
   
/*******************************************************************************
 * Tests the set and get methods for Properties.
 *******************************************************************************
 */
   private void testPropertySetGet ()
      {
      Item    theA;
      Integer theInteger;
      Double  theDouble;
      
      theA = A.get ("1");
      
      theInteger = theA.get (A_INT);
      
      assert (theInteger == null);
      
      theA.set (A_INT, 17);
      
      theInteger = theA.get (A_INT);
      
      assert (theInteger == 17);
      
      theA.set (A_INT, null);
      
      theInteger = theA.get (A_INT);
      
      assert (theInteger == null);
      
      GLOBAL_DBL.setGlobal (29.7);
      
      theDouble = GLOBAL_DBL.getGlobal ();
      
      assert (theDouble == 29.7);
      }

/*******************************************************************************
 * Tests class Period.
 *******************************************************************************
 */
   private void testPeriod ()
      {
      Period    theFebPer;
      Primitive theA;
      
                  newPeriod ("January");
      theFebPer = newPeriod ("February");
      
      theA      = A.get ("1");
      
      assert (theA.get (A_DBP) == null);
      assert (theA.get (A_IBP) == null);
      assert (theA.get (A_BBP) == null);
      
      System.out.printf (
         "%n"
       + "Frozen Period Set? %s%n",
         frozenPeriodSet ());
      
      freezePeriodSet ();
      
      System.out.printf (
         "%n"
       + "Frozen Period Set? %s%n",
         frozenPeriodSet ());
      
      assert (theA.get (A_DBP) != null);
      assert (theA.get (A_IBP) != null);
      assert (theA.get (A_BBP) != null);
      
      System.out.printf (
         "%n"
       + "# Periods: %d%n"
       + "Periods:%n",
         getNPeriods ());
      
      for (Period thePer: getAllPeriods ())
         System.out.printf (
            "   %s%n"
          + "      Name:   %s%n"
          + "      Index:  %s%n",
            thePer,
            thePer.getName  (),
            thePer.getIndex ());
      
      assert (getPeriod ("February") == theFebPer);
      }
   
/*******************************************************************************
 * Tests class DoubleByPeriod.
 *******************************************************************************
 */
   private void testDoubleByPeriod ()
      {
      Primitive theA1;
      Period    febPer;
      double    theDbl;
      double[]  theDblArr;
      
      theA1  = A.get ("1");
      
      febPer = getPeriod ("February");
      
      theA1.get (A_DBP).set (febPer, 26.8);
      
      theDbl = theA1.get (A_DBP).get (febPer);
      
      assert (theDbl == 26.8);
      
      theDblArr = new double[2];
      
      theA1.get (A_DBP).getArray (theDblArr);
      
      assert (theDblArr[0] ==  0.0);
      assert (theDblArr[1] == 26.8);
      
      theA1.get (A_DBP).setArray (new double[] {3.4, 6.7});
      
      System.out.printf (
         "%n"
       + "1.A_DBP:  %s%n",
         theA1.get (A_DBP));
      }

/*******************************************************************************
 * Tests class IntegerByPeriod.
 *******************************************************************************
 */
   private void testIntegerByPeriod ()
      {
      Primitive theA1;
      Period    febPer;
      int       theInt;
      int[]     theIntArr;

      theA1  = A.get ("1");
      
      febPer = getPeriod ("February");
      
      theA1.get (A_IBP).set (febPer, 17);
      
      theInt = theA1.get (A_IBP).get (febPer);
      
      assert (theInt == 17);
      
      theIntArr = new int[2];
      
      theA1.get (A_IBP).getArray (theIntArr);
      
      assert (theIntArr[0] ==  0);
      assert (theIntArr[1] == 17);
      
      theA1.get (A_IBP).setArray (new int[] {93, 48});
      
      System.out.printf (
         "%n"
       + "1.A_IBP:  %s%n",
         theA1.get (A_IBP));
      }

/*******************************************************************************
 * Tests class BooleanByPeriod.
 *******************************************************************************
 */
   private void testBooleanByPeriod ()
      {
      Primitive theA1;
      Period    febPer;
      boolean   theBool;
      boolean[] theBoolArr;

      theA1  = A.get ("1");
      
      febPer = getPeriod ("February");
      
      theA1.get (A_BBP).set (febPer, true);
      
      theBool = theA1.get (A_BBP).get (febPer);
      
      assert (theBool);
      
      theBoolArr = new boolean[2];
      
      theA1.get (A_BBP).getArray (theBoolArr);
      
      assert (! theBoolArr[0]);
      assert   (theBoolArr[1]);
      
      theA1.get (A_BBP).setArray (new boolean[] {true, false});
      
      System.out.printf (
         "%n"
       + "1.A_BBP:  %s%n",
         theA1.get (A_BBP));
      }

/*******************************************************************************
 * Tests class WitJHandler.
 *******************************************************************************
 */
   private void testWitJHandler ()
      {
      assert (getCurrentWitJHandler () == null);
      assert (getCurrentProblem     () == null);
      
      newWitJHandler ();
      
      getCurrentProblem ().set (title, "WIT-M Unit Test");

      assert (! getUseShortNames ());
      
      setUseShortNames (true);

      assert (getUseShortNames ());
      }

/*******************************************************************************
 * Tests Item.newPart, Item.newOperation, etc.
 *******************************************************************************
 */
   private void testNewComp ()
      {
      Primitive theA1;
      Primitive theB2;
      Primitive theA3;
      Tuple     theA1_B2_A3;
      
      theA1 = A.get ("1");
      theB2 = B.get ("2");
      theA3 = A.get ("3");
      
      theA1_B2_A3 = A_B_A.get (theA1, theB2, theA3);
      
      theA1      .newPart      (A_CAP,     CAPACITY);
      
      setUseShortNames (false);
      
      theA1      .newPart      (A_MAT,     MATERIAL);
      theA3      .newPart      (A_MAT,     MATERIAL);
      theA1_B2_A3.newPart      (A_B_A_MAT, MATERIAL);
      theB2      .newOperation (B_OPN);
      theB2      .newDemand    (B_DEM,     theA1.get (A_MAT));

      theA1_B2_A3.
         newBomEntry  (
            A_B_A_BOM,
            theA1_B2_A3.get (B)  .get (B_OPN),
            theA1_B2_A3.get (A_0).get (A_MAT));

      theA1_B2_A3.
         newBopEntry  (
            A_B_A_BOP,
            theA1_B2_A3.get (B)  .get (B_OPN),
            theA1_B2_A3.get (A_2).get (A_MAT));

      theA1_B2_A3.
         newSubstitute (
            A_B_A_SUB,
            theA1_B2_A3          .get (A_B_A_BOM),
            theA1_B2_A3.get (A_2).get (A_MAT));

      System.out.printf (
         "%n"
         + "A1    .A_CAP:     %s%n"
         + "A1    .A_MAT:     %s%n"
         + "A3    .A_CAP:     %s%n"
         + "A3    .A_MAT:     %s%n"
         + "A1B2A3.A_B_A_MAT: %s%n"
         + "B2    .B_OPN:     %s%n"
         + "B2    .B_DEM:     %s%n"
         + "A1B2A3.A_B_A_BOM: %s%n"
         + "A1B2A3.A_B_A_BOP: %s%n"
         + "A1B2A3.A_B_A_SUB: %s%n",
         theA1      .get (A_CAP),
         theA1      .get (A_MAT),
         theA3      .get (A_CAP),
         theA3      .get (A_MAT),
         theA1_B2_A3.get (A_B_A_MAT),
         theB2      .get (B_OPN),
         theB2      .get (B_DEM),
         theA1_B2_A3.get (A_B_A_BOM),
         theA1_B2_A3.get (A_B_A_BOP),
         theA1_B2_A3.get (A_B_A_SUB));
      }

/*******************************************************************************
 * Tests class InputTable by processing the file period.csv.
 *******************************************************************************
 */
   private void procPeriodCSV ()
      {
      InputTable theTable;
      
      pokModInst = POK.newModelInstance ("Poughkeepsie");
      
      theTable   = InputTable.newInputTable ("POK/period.csv");
      
      System.out.printf (
         "%n"
       + "%s%n",
         theTable);
         
      for (InputRow theRow: theTable.getInputRows ())
         if (theRow.getIndex () > 1)
            newPeriod (theRow.getCell (1));
      
      System.out.printf (
         "%n"
       + "Periods for POK Problem:%n");
         
      for (Period thePer: getAllPeriods ())
         System.out.printf ("   %s%n", thePer.getName ());
      }
 
/*******************************************************************************
 * Tests class InputTable by processing the file area.csv.
 *******************************************************************************
 */
   private void procAreaCSV ()
      {
      InputTable theTable;
      
      theTable = InputTable.newInputTable ("POK/area.csv");
      
      for (InputRow theRow: theTable.getInputRows ())
         if (theRow.getIndex () > 1)
            AREA.newPrimitive (theRow.getCell (1));
      
      System.out.printf (
         "%n"
       + "Areas for POK Problem:%n");
         
      for (Primitive theArea: AREA.getAll ())
         System.out.printf ("   %s%n", theArea.getName ());
      }
 
/*******************************************************************************
 * Tests class InputRow by processing the file area-shift-period.csv.
 *******************************************************************************
 */
   private void procAreaShiftPeriodCSV ()
      {
      InputTable theTable;
      InputRow   theRow65;
      
      theTable = InputTable.newInputTable ("POK/area-shift-period.csv");
      
      theRow65 = theTable.getInputRow (65);
      
      theRow65.requireNCells (5);
      
      System.out.printf (
         "%n"
       + "%s:%n%n"
       + "   Line #:       %d%n"
       + "   # of Cells:   %d%n"
       + "   Area:         %s%n"
       + "   Shift:        %d%n"
       + "   Period:       %s%n"
       + "   Period Index: %d%n"
       + "   Min Workers:  %s%n"
       + "   Max Workers:  %.1f%n",
         theRow65,
         theRow65.getIndex           (),
         theRow65.nCells             (),
         theRow65.getCellAsPrimitive (1, AREA).getName (),
         theRow65.getCellAsInt       (2, "Shift"),
         theRow65.getCellAsPeriod    (3).getName (),
         theRow65.getCellAsPeriod    (3).getIndex (),
         theRow65.getCell            (4),
         theRow65.getCellAsDouble    (5, "Max Workers"));
      }
 
/*******************************************************************************
 * Releases / deactivates various objects associated with the test.
 *******************************************************************************
 */
   private void shutDown ()
      {
      getCurrentProblem ().deactivate ();
      
      setCurrentWitJHandler   (null);
      setCurrentModelInstance (null);
      }

/*******************************************************************************
 * Internal implementation of the unit test.
 *******************************************************************************
 */
   private void perfTest ()
      {
      testModelScheme        ();
      testPrimitiveCategory  ();
      testTupleCategory      ();
      testDimensionID        ();
      testProperty           ();
      testModelInstance      ();
      testPrimitive          ();
      testTuple              ();
      testSlice              ();
      testPropertySetGet     ();
      testPeriod             ();
      testDoubleByPeriod     ();
      testIntegerByPeriod    ();
      testBooleanByPeriod    ();
      testWitJHandler        ();
      testNewComp            ();
      procPeriodCSV          ();
      procAreaCSV            ();
      procAreaShiftPeriodCSV ();
      shutDown               ();
      }

////////////////////////////////////////////////////////////////////////////////
// Package Internal Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Performs a unit test of WIT-M: Invokes all public methods of WIT-M.
 *******************************************************************************
 */
   static void performTest ()
      {
      try
         {
         UnitTester theUnitTester;
         
         theUnitTester = new UnitTester ();

         theUnitTester.perfTest ();
         }

      catch (Exception theExc)
         {
         theExc.printStackTrace ();

         System.exit (4);
         }

      System.out.printf (
         "\n"
       + "Normal termination of unit test.%n");
      }

////////////////////////////////////////////////////////////////////////////////
}
@


1.131
log
@getCellAsPeriod
@
text
@d126 3
a128 1
   private static final ModelScheme POK;
d138 3
a140 1
      POK = newModelScheme ("POK");
d778 1
a778 1
 * Tests class InputTable.
d781 1
a781 1
   private void testInputTable ()
d807 23
a829 1
 * Tests class InputRow.
d832 1
a832 1
   private void testInputRow ()
d852 1
d855 8
a862 7
         theRow65.getIndex        (),
         theRow65.nCells          (),
         theRow65.getCell         (1),
         theRow65.getCellAsInt    (2, "Shift"),
         theRow65.getCellAsPeriod (3).getName (),
         theRow65.getCellAsPeriod (3).getIndex (),
         theRow65.getCellAsDouble (5, "Max Workers"));
d883 20
a902 19
      testModelScheme       ();
      testPrimitiveCategory ();
      testTupleCategory     ();
      testDimensionID       ();
      testProperty          ();
      testModelInstance     ();
      testPrimitive         ();
      testTuple             ();
      testSlice             ();
      testPropertySetGet    ();
      testPeriod            ();
      testDoubleByPeriod    ();
      testIntegerByPeriod   ();
      testBooleanByPeriod   ();
      testWitJHandler       ();
      testNewComp           ();
      testInputTable        ();
      testInputRow          ();
      shutDown              ();
@


1.130
log
@TemporalVariable ==> VariableByPeriod, etc.
@
text
@d832 2
a833 2
         theRow65.getCellAsPeriod (3, "Period").getName (),
         theRow65.getCellAsPeriod (3, "Period").getIndex (),
@


1.129
log
@getInputRow
@
text
@d18 2
a19 2
import com.ibm.witm.TemporalBoolean;
import com.ibm.witm.TemporalDouble;
d22 1
a22 1
import com.ibm.witm.TemporalInteger;
d58 3
a60 3
   private static final Property <TemporalDouble>  A_TMP_DBL;
   private static final Property <TemporalInteger> A_TMP_INT;
   private static final Property <TemporalBoolean> A_TMP_BOOL;
d94 1
a94 1
      A_TMP_DBL  = A.     newProperty          ("A_TMP_DBL",  TemporalDouble.
d96 1
a96 1
      A_TMP_INT  = A.     newProperty          ("A_TMP_INT",  TemporalInteger.
d98 1
a98 1
      A_TMP_BOOL = A.     newProperty          ("A_TMP_BOOL", TemporalBoolean.
d538 3
a540 3
      assert (theA.get (A_TMP_DBL)  == null);
      assert (theA.get (A_TMP_INT)  == null);
      assert (theA.get (A_TMP_BOOL) == null);
d554 3
a556 3
      assert (theA.get (A_TMP_DBL)  != null);
      assert (theA.get (A_TMP_INT)  != null);
      assert (theA.get (A_TMP_BOOL) != null);
d577 1
a577 1
 * Tests class TemporalDouble.
d580 1
a580 1
   private void testTemporalDouble ()
d591 1
a591 1
      theA1.get (A_TMP_DBL).set (febPer, 26.8);
d593 1
a593 1
      theDbl = theA1.get (A_TMP_DBL).get (febPer);
d599 1
a599 1
      theA1.get (A_TMP_DBL).getArray (theDblArr);
d604 1
a604 1
      theA1.get (A_TMP_DBL).setArray (new double[] {3.4, 6.7});
d608 2
a609 2
       + "1.A_TMP_DBL:  %s%n",
         theA1.get (A_TMP_DBL));
d613 1
a613 1
 * Tests class TemporalInteger.
d616 1
a616 1
   private void testTemporalInteger ()
d627 1
a627 1
      theA1.get (A_TMP_INT).set (febPer, 17);
d629 1
a629 1
      theInt = theA1.get (A_TMP_INT).get (febPer);
d635 1
a635 1
      theA1.get (A_TMP_INT).getArray (theIntArr);
d640 1
a640 1
      theA1.get (A_TMP_INT).setArray (new int[] {93, 48});
d644 2
a645 2
       + "1.A_TMP_INT:  %s%n",
         theA1.get (A_TMP_INT));
d649 1
a649 1
 * Tests class TemporalBoolean.
d652 1
a652 1
   private void testTemporalBoolean ()
d663 1
a663 1
      theA1.get (A_TMP_BOOL).set (febPer, true);
d665 1
a665 1
      theBool = theA1.get (A_TMP_BOOL).get (febPer);
d671 1
a671 1
      theA1.get (A_TMP_BOOL).getArray (theBoolArr);
d676 1
a676 1
      theA1.get (A_TMP_BOOL).setArray (new boolean[] {true, false});
d680 2
a681 2
       + "1.A_TMP_BOOL:  %s%n",
         theA1.get (A_TMP_BOOL));
d866 3
a868 3
      testTemporalDouble    ();
      testTemporalInteger   ();
      testTemporalBoolean   ();
@


1.128
log
@Added POK Scheme and ModelInstance.
Tested getCellAsPeriod.
@
text
@d813 1
a813 1
      theRow65 = theTable.getInputRows ().get (64);
@


1.127
log
@getCellAsPeriod (...)
@
text
@d47 2
a48 1
// Declaration of the ModelScheme and its elements.
d82 1
a82 1
// Construction of the ModelScheme and its elements.
d120 22
d149 7
a155 1
   private ModelInstance mainModelInstance;
d163 2
a164 1
      mainModelInstance = null;
a176 4
      assert (getCurrentModelScheme () == UNIT_TEST);
      
      setCurrentModelScheme (null);
      
d274 1
a274 1
      mainModelInstance = UNIT_TEST.newModelInstance ("Unit-Test");
d281 3
a283 3
         mainModelInstance,
         mainModelInstance.getModelScheme ().getName (),
         mainModelInstance                  .getName ());
d292 1
a292 1
      setCurrentModelInstance (mainModelInstance);
d486 1
a486 1
      setCurrentModelInstance (mainModelInstance);
d781 3
a783 1
      theTable = InputTable.newInputTable ("POK/period.csv");
d787 1
a787 2
       + "%s:%n"
       + "%n",
d791 9
a799 1
         System.out.printf ("   %s%n", theRow);
d809 1
a809 1
      InputRow   theRow3;
d813 1
a813 1
      theRow3  = theTable.getInputRows ().get (2);
d815 1
a815 1
      theRow3.requireNCells (5);
d820 15
a834 11
       + "   Index:       %d%n"
       + "   # of Cells:  %d%n"
       + "   Area:        %s%n"
       + "   Shift:       %d%n"
       + "   Max Workers: %.1f%n",
         theRow3,
         theRow3.getIndex        (),
         theRow3.nCells          (),
         theRow3.getCell         (1),
         theRow3.getCellAsInt    (2, "Shift"),
         theRow3.getCellAsDouble (5, "Max Workers"));
a853 2
      throws
         Exception
@


1.126
log
@getCellAsInt
@
text
@d748 1
a748 1
 * Creates and returns the InputTable for testInputTableAndRow.
d751 1
a751 1
   private InputTable buildInputTable ()
d753 3
a755 4
      try
         {
         return InputTable.newInputTable ("POK/area-shift-period.csv");
         }
d757 8
a764 10
      catch (Exception theExc)
         {
         throw
            new RuntimeException (
               "\n"
             + "\n"
             + "  An Exception was throw during an invocation of\n"
             + "  InputTable.newInputTable (...).\n",
               theExc);
         }
d768 1
a768 1
 * Tests classes InputTable and InputRow.
d771 1
a771 1
   private void testInputTableAndRow ()
d776 1
a776 1
      theTable = buildInputTable ();
d778 1
a778 20
      System.out.printf (
         "%n"
       + "%s:%n"
       + "%n",
         theTable);
         
      for (InputRow theRow: theTable.getInputRows ())
         {
         theRow.requireNCells (5);
         
         if (theRow.getIndex () == 1)
            continue;
         
         System.out.printf (
            "   Line #%3d: Area: %22s, Shift: %1d, Max Workers: %4.1f%n",
            theRow.getIndex        (),
            theRow.getCell         (1),
            theRow.getCellAsInt    (2, "Shift"),
            theRow.getCellAsDouble (5, "Max Workers"));
         }
d780 1
a780 1
      theRow3 = theTable.getInputRows ().get (2);
d784 6
a789 1
       + "%s: # of Cells = %d%n",
d791 5
a795 1
         theRow3.nCells ());
d834 2
a835 1
      testInputTableAndRow     ();
@


1.125
log
@InputRow
@
text
@d795 1
a795 1
            "   Line #%3d: Area: %22s, Max Workers: %4.1f%n",
d798 2
a799 1
            theRow.getCellAsDouble (5, "Max Workers"));     
@


1.124
log
@getCellAsDouble
@
text
@d789 2
d798 1
a798 1
            theRow.getCellAsDouble (5));     
@


1.123
log
@InputRow
@
text
@d748 23
d793 4
a796 4
            "   Period %9s: # Weekend Days: %2s%n",
            theRow.getCell (1),
            theRow.getCell (4)
            );     
d803 1
a803 1
       + "%s: #Cells = %d%n",
a808 23
 * Creates and returns the InputTable for testInputTableAndRow.
 *******************************************************************************
 */
   private InputTable buildInputTable ()
      {
      try
         {
         return InputTable.newInputTable ("POK/period.csv");
         }
      
      catch (Exception theExc)
         {
         throw
            new RuntimeException (
               "\n"
             + "\n"
             + "  An Exception was throw during an invocation of\n"
             + "  InputTable.newInputTable (...).\n",
               theExc);
         }
      }
 
/*******************************************************************************
@


1.122
log
@InputTables
@
text
@d751 1
a751 1
   private void testInputTableRow ()
d753 2
a754 1
      InputTable theTable = null;
d756 1
a756 15
      try
         {
         theTable = InputTable.newInputTable ("POK/period.csv");
         }
      
      catch (Exception theExc)
         {
         throw
            new RuntimeException (
               "\n"
             + "\n"
             + "  An Exception was throw during an invocation of\n"
             + "  InputTable.newInputTable (...).\n",
               theExc);
         }
d776 2
d780 26
a805 2
       + "%s%n",
         theTable.getInputRows ().get (2));
d844 1
a844 1
      testInputTableRow     ();
@


1.121
log
@InputTables
@
text
@d771 5
a775 1
      System.out.printf ("%n");
d783 1
a783 1
            "Period %9s: # Weekend Days: %2s%n",
d788 5
@


1.120
log
@getNPeriods ()
@
text
@d16 2
a25 2
import com.ibm.witm.InputRow;
import com.ibm.witm.InputTable;
a141 70
 * Tests class InputTable and the classes that support it.
 *******************************************************************************
 */
   private void testInputTable ()
      throws
         Exception
      {
      InputTable theTable;

      theTable = InputTable.newInputTable ("area.csv");

      printTable       (theTable);
      printNonHeadings (theTable);
      }

/*******************************************************************************
 * Prints theTable.
 *******************************************************************************
 */
   private void printTable (InputTable theTable)
      {
      for (InputRow theRow: theTable.getRows ())
         {
         System.out.printf (
            "%n"
          + "Row %2d:%n"
          + "   Area:          = \"%s\"%n"
          + "   Work_Type:     = \"%s\"%n"
          + "   Workload_Type: = \"%s\"%n"
          + "   #Shifts:       = \"%s\"%n"
          + "   Min_IBM%%:      = \"%s\"%n"
          + "   #999:          = \"%s\"%n"
          + "   Training_Time: = \"%s\"%n",
            theRow.getIndex (),
            theRow.getCell ("Area"),
            theRow.getCell ("Work_Type"),
            theRow.getCell ("Workload_Type"),
            theRow.getCell ("#Shifts"),
            theRow.getCell ("Min_IBM%"),
            theRow.getCell ("#999"),
            theRow.getCell ("Training_Time"));
         }
      }

/*******************************************************************************
 * Prints some Strings that are not headings in theTable.
 *******************************************************************************
 */
   private void printNonHeadings (InputTable theTable)
      {
      String[] nonHeadings;

      System.out.printf (
         "%n"
       + "Not headings in the table:%n"
       + "%n");

      nonHeadings =
         theTable.findNonHeadings (
            "#Shifts",
            "Something Else",
            "Min_IBM%");

      for (String nonHeading: nonHeadings)
         System.out.printf (
            "   \"%s\"%n",
            nonHeading);
      }

/*******************************************************************************
d748 39
a805 1
      testInputTable        ();
d822 1
@


1.119
log
@Minor test.
@
text
@d604 3
a606 1
       + "Periods:%n");
@


1.118
log
@Added class TemporalBoolean.
@
text
@d582 3
a584 2
      assert (theA.get (A_TMP_DBL) == null);
      assert (theA.get (A_TMP_INT) == null);
d598 3
a600 2
      assert (theA.get (A_TMP_DBL) != null);
      assert (theA.get (A_TMP_INT) != null);
@


1.117
log
@Added class TemporalInteger.
@
text
@d16 1
d57 3
a59 2
   private static final Property <TemporalDouble>  A_TEMP_DBL;
   private static final Property <TemporalInteger> A_TEMP_INT;
d93 1
a93 1
      A_TEMP_DBL = A.     newProperty          ("A_TEMP_DBL", TemporalDouble.
d95 3
a97 1
      A_TEMP_INT = A.     newProperty          ("A_TEMP_INT", TemporalInteger.
d582 2
a583 2
      assert (theA.get (A_TEMP_DBL) == null);
      assert (theA.get (A_TEMP_INT) == null);
d597 2
a598 2
      assert (theA.get (A_TEMP_DBL) != null);
      assert (theA.get (A_TEMP_INT) != null);
d631 1
a631 1
      theA1.get (A_TEMP_DBL).set (febPer, 26.8);
d633 1
a633 1
      theDbl = theA1.get (A_TEMP_DBL).get (febPer);
d639 1
a639 1
      theA1.get (A_TEMP_DBL).getArray (theDblArr);
d644 1
a644 1
      theA1.get (A_TEMP_DBL).setArray (new double[] {3.4, 6.7});
d648 2
a649 2
       + "1.A_TEMP_DBL:  %s%n",
         theA1.get (A_TEMP_DBL));
d667 1
a667 1
      theA1.get (A_TEMP_INT).set (febPer, 17);
d669 1
a669 1
      theInt = theA1.get (A_TEMP_INT).get (febPer);
d675 1
a675 1
      theA1.get (A_TEMP_INT).getArray (theIntArr);
d680 37
a716 1
      theA1.get (A_TEMP_INT).setArray (new int[] {93, 48});
d720 2
a721 2
       + "1.A_TEMP_INT:  %s%n",
         theA1.get (A_TEMP_INT));
d847 1
@


1.116
log
@PeriodValue  ==> TemporalVariable
PeriodDouble ==> TemporalDouble
@
text
@d19 1
d49 1
a49 1
   private static final ModelScheme               UNIT_TEST;
d51 2
a52 2
   private static final PrimitiveCategory         GLOBAL;
   private static final Property <Double>         GLOBAL_DBL;
d54 19
a72 18
   private static final PrimitiveCategory         A;
   private static final Property <Integer>        A_INT;
   private static final Property <TemporalDouble> A_PER_DBL;
   private static final Property <Part>           A_MAT;
   private static final Property <Part>           A_CAP;
   
   private static final PrimitiveCategory         B;
   private static final Property <Operation>      B_OPN;
   private static final Property <Demand>         B_DEM;
   
   private static final TupleCategory             A_B_A;
   private static final DimensionID <Primitive>   A_0;
   private static final DimensionID <Primitive>   A_2;
   private static final Property <String>         A_B_A_STR;
   private static final Property <Part>           A_B_A_MAT;
   private static final Property <BomEntry>       A_B_A_BOM;
   private static final Property <BopEntry>       A_B_A_BOP;
   private static final Property <Substitute>     A_B_A_SUB;
d74 1
a74 1
   private static final TupleCategory             B_ABA;
d91 3
a93 1
      A_PER_DBL  = A.     newProperty          ("A_PER_DBL",  TemporalDouble.
d578 2
a579 1
      assert (theA.get (A_PER_DBL) == null);
d593 2
a594 1
      assert (theA.get (A_PER_DBL) != null);
d613 1
a613 1
 * Tests generic class TemporalVariable <V> and its subclasses.
d616 1
a616 1
   private void testTemporalVariable ()
d627 1
a627 1
      theA1.get (A_PER_DBL).set (febPer, 26.8);
d629 1
a629 1
      theDbl = theA1.get (A_PER_DBL).get (febPer);
d635 1
a635 1
      theA1.get (A_PER_DBL).getArray (theDblArr);
d640 37
a676 1
      theA1.get (A_PER_DBL).setArray (new double[] {3.4, 6.7});
d680 2
a681 2
       + "1.A_PER_DBL:  %s%n",
         theA1.get (A_PER_DBL));
d805 2
a806 1
      testTemporalVariable  ();
@


1.115
log
@Name change.
@
text
@d16 1
a16 1
import com.ibm.witm.PeriodDouble;
d48 1
a48 1
   private static final ModelScheme             UNIT_TEST;
d50 2
a51 2
   private static final PrimitiveCategory       GLOBAL;
   private static final Property <Double>       GLOBAL_DBL;
d53 18
a70 18
   private static final PrimitiveCategory       A;
   private static final Property <Integer>      A_INT;
   private static final Property <PeriodDouble> A_PER_DBL;
   private static final Property <Part>         A_MAT;
   private static final Property <Part>         A_CAP;
   
   private static final PrimitiveCategory       B;
   private static final Property <Operation>    B_OPN;
   private static final Property <Demand>       B_DEM;
   
   private static final TupleCategory           A_B_A;
   private static final DimensionID <Primitive> A_0;
   private static final DimensionID <Primitive> A_2;
   private static final Property <String>       A_B_A_STR;
   private static final Property <Part>         A_B_A_MAT;
   private static final Property <BomEntry>     A_B_A_BOM;
   private static final Property <BopEntry>     A_B_A_BOP;
   private static final Property <Substitute>   A_B_A_SUB;
d72 1
a72 1
   private static final TupleCategory           B_ABA;
d89 1
a89 1
      A_PER_DBL  = A.     newProperty          ("A_PER_DBL",  PeriodDouble.
d607 1
a607 1
 * Tests generic class PeriodValue <V> and its subclasses.
d610 1
a610 1
   private void testPeriodValue ()
d763 1
a763 1
      testPeriodValue       ();
@


1.114
log
@ProblemManager ==> WitJHandler
@
text
@d629 1
a629 1
      theA1.get (A_PER_DBL).get (theDblArr);
d634 1
a634 1
      theA1.get (A_PER_DBL).set (new double[] {3.4, 6.7});
@


1.113
log
@Name change
@
text
@d31 1
a31 1
import static com.ibm.witm.ProblemManager.*;
d643 1
a643 1
 * Tests class ProblemManager.
d646 1
a646 1
   private void testProblemManager ()
d648 2
a649 2
      assert (getCurrentProblemManager () == null);
      assert (getCurrentProblem        () == null);
d651 1
a651 1
      newProblemManager ();
d739 2
a740 2
      setCurrentProblemManager (null);
      setCurrentModelInstance  (null);
d764 1
a764 1
      testProblemManager    ();
@


1.112
log
@PeriodDouble
@
text
@d655 1
a655 1
      assert (! getShortNames ());
d657 1
a657 1
      setShortNames (true);
d659 1
a659 1
      assert (getShortNames ());
d681 1
a681 1
      setShortNames (false);
@


1.111
log
@PeriodDouble
@
text
@d615 1
d627 7
@


1.110
log
@Simplified toString.
@
text
@d626 2
@


1.109
log
@Simplified toString ().
@
text
@d219 1
a219 1
       + "%s:%n"
d248 1
a248 1
       + "%s:%n"
d264 1
a264 1
       + "%s:%n"
d292 1
a292 1
       + "%s:%n"
d314 1
a314 1
       + "%s:%n"
@


1.108
log
@Class renaming:
   ValueByPeriod  ==> PeriodValue
   DoubleByPeriod ==> PeriodDouble
@
text
@d280 1
a280 1
       + "%s%n",
@


1.107
log
@ValueByPeriod
@
text
@d16 1
a16 1
import com.ibm.witm.DoubleByPeriod;
d48 1
a48 1
   private static final ModelScheme               UNIT_TEST;
d50 2
a51 2
   private static final PrimitiveCategory         GLOBAL;
   private static final Property <Double>         GLOBAL_DBL;
d53 18
a70 18
   private static final PrimitiveCategory         A;
   private static final Property <Integer>        A_INT;
   private static final Property <DoubleByPeriod> A_DBP;
   private static final Property <Part>           A_MAT;
   private static final Property <Part>           A_CAP;
   
   private static final PrimitiveCategory         B;
   private static final Property <Operation>      B_OPN;
   private static final Property <Demand>         B_DEM;
   
   private static final TupleCategory             A_B_A;
   private static final DimensionID <Primitive>   A_0;
   private static final DimensionID <Primitive>   A_2;
   private static final Property <String>         A_B_A_STR;
   private static final Property <Part>           A_B_A_MAT;
   private static final Property <BomEntry>       A_B_A_BOM;
   private static final Property <BopEntry>       A_B_A_BOP;
   private static final Property <Substitute>     A_B_A_SUB;
d72 1
a72 1
   private static final TupleCategory             B_ABA;
d89 1
a89 1
      A_DBP      = A.     newProperty          ("A_DBP",      DoubleByPeriod.
d574 1
a574 1
      assert (theA.get (A_DBP) == null);
d588 1
a588 1
      assert (theA.get (A_DBP) != null);
d607 1
a607 1
 * Tests generic class ValueByPeriod <V> and its subclasses.
d610 1
a610 1
   private void testValueByPeriod ()
d620 1
a620 1
      theA1.get (A_DBP).set (febPer, 26.8);
d622 1
a622 1
      theDbl = theA1.get (A_DBP).get (febPer);
d628 2
a629 2
       + "1.A_DBP:  %s%n",
         theA1.get (A_DBP));
d753 1
a753 1
      testValueByPeriod     ();
@


1.106
log
@ValueByPeriod
@
text
@d16 1
d48 1
a48 1
   private static final ModelScheme              UNIT_TEST;
d50 2
a51 2
   private static final PrimitiveCategory        GLOBAL;
   private static final Property    <Double>     GLOBAL_DBL;
d53 18
a70 17
   private static final PrimitiveCategory        A;
   private static final Property    <Integer>    A_INT;
   private static final Property    <Part>       A_MAT;
   private static final Property    <Part>       A_CAP;
   
   private static final PrimitiveCategory        B;
   private static final Property    <Operation>  B_OPN;
   private static final Property    <Demand>     B_DEM;
   
   private static final TupleCategory            A_B_A;
   private static final DimensionID <Primitive>  A_0;
   private static final DimensionID <Primitive>  A_2;
   private static final Property    <String>     A_B_A_STR;
   private static final Property    <Part>       A_B_A_MAT;
   private static final Property    <BomEntry>   A_B_A_BOM;
   private static final Property    <BopEntry>   A_B_A_BOP;
   private static final Property    <Substitute> A_B_A_SUB;
d72 1
a72 1
   private static final TupleCategory            B_ABA;
d89 2
d526 35
d566 2
a567 1
      Period theFebPer;
d572 4
d588 2
d607 1
a607 1
 * Tests the set and get methods for Properties.
d610 1
a610 1
   private void testPropertySetGet ()
d612 3
a614 3
      Item    theA;
      Integer theInteger;
      Double  theDouble;
d616 1
a616 1
      theA = A.get ("1");
d618 1
a618 1
      theInteger = theA.get (A_INT);
d620 1
a620 1
      assert (theInteger == null);
d622 1
a622 1
      theA.set (A_INT, 17);
d624 1
a624 1
      theInteger = theA.get (A_INT);
d626 4
a629 13
      assert (theInteger == 17);
      
      theA.set (A_INT, null);
      
      theInteger = theA.get (A_INT);
      
      assert (theInteger == null);
      
      GLOBAL_DBL.setGlobal (29.7);
      
      theDouble = GLOBAL_DBL.getGlobal ();
      
      assert (theDouble == 29.7);
d751 1
d753 1
a753 1
      testPropertySetGet    ();
@


1.105
log
@Removed generic class PeriodTrait <V>.
@
text
@d47 1
a47 1
   private static final ModelScheme             UNIT_TEST;
d49 2
a50 2
   private static final PrimitiveCategory       GLOBAL;
   private static final Property <Double>       GLOBAL_DBL;
d52 17
a68 17
   private static final PrimitiveCategory       A;
   private static final Property    <Integer>   A_INT;
   private static final Property    <Part>      A_MAT;
   private static final Property    <Part>      A_CAP;
   
   private static final PrimitiveCategory       B;
   private static final Property <Operation>    B_OPN;
   private static final Property <Demand>       B_DEM;
   
   private static final TupleCategory           A_B_A;
   private static final DimensionID <Primitive> A_0;
   private static final DimensionID <Primitive> A_2;
   private static final Property <String>       A_B_A_STR;
   private static final Property <Part>         A_B_A_MAT;
   private static final Property <BomEntry>     A_B_A_BOM;
   private static final Property <BopEntry>     A_B_A_BOP;
   private static final Property <Substitute>   A_B_A_SUB;
d70 1
a70 1
   private static final TupleCategory           B_ABA;
@


1.104
log
@Class PeriodTrait
@
text
@a17 1
import com.ibm.witm.PeriodTrait;
a53 1
   private static final PeriodTrait <Integer>   A_INT_PT;
a86 1
      A_INT_PT   = A.     newPeriodTrait       ("A_INT_PT",   Integer.class);
a298 18
 * Tests class PeriodTrait.
 *******************************************************************************
 */
   private void testPeriodTrait ()
      {
      System.out.printf (
         "%n"
       + "%s:%n"
       + "   Name:         %s%n"
       + "   Value Type:   %s%n"
       + "   ItemCategory: %s%n",
         A_INT_PT,
         A_INT_PT                   .getName       (),
         A_INT_PT.getValueType    ().getSimpleName (),
         A_INT_PT.getItemCategory ().getName       ());
      }

/*******************************************************************************
a709 1
      testPeriodTrait       ();
@


1.103
log
@Period set freeze
@
text
@d18 1
d54 4
a57 3
   private static final Property <Integer>      A_INT;
   private static final Property <Part>         A_MAT;
   private static final Property <Part>         A_CAP;
d89 1
d292 1
a292 1
       + "   ItemCategory: \"%s\"%n"
d294 1
a294 1
       + "   Name:         \"%s\"%n",
d296 1
a296 1
         A_INT.getItemCategory ().getName       (),
d298 19
a316 1
         A_INT                   .getName       ());
d731 1
@


1.102
log
@Class Period
@
text
@d534 12
@


1.101
log
@Class Period
@
text
@d537 7
a543 1
         System.out.printf ("   %s%n", thePer);
@


1.100
log
@Removed first implementation of the period concept.
@
text
@d17 1
d522 21
d696 1
@


1.99
log
@newSubstitute
@
text
@a50 2
   private static final PrimitiveCategory       PERIOD;
   
a83 2
      PERIOD     =        getPeriodCategory    ();
      
a338 1
      Primitive theWedPer;
a373 11
      
                  PERIOD.newPrimitive ("Monday");
                  PERIOD.newPrimitive ("Tuesday");
      theWedPer = PERIOD.newPrimitive ("Wednesday");
      
      System.out.printf (
         "%n"
       + "Wednesday Period: %s%n"
       + "   Period Index:  %d%n",
         theWedPer,
         theWedPer.getPeriodIndex ());
@


1.98
log
@newBopEntry
@
text
@d13 1
d69 1
d104 1
d592 1
a592 1
 * Tests Item.newPart and Item.newOperation.
d630 6
d646 2
a647 1
         + "A1B2A3.A_B_A_BOP: %s%n",
d656 2
a657 1
         theA1_B2_A3.get (A_B_A_BOP));
@


1.97
log
@newBomEntry
@
text
@d9 1
d67 1
d101 1
d621 6
d636 2
a637 1
         + "A1B2A3.A_B_A_BOM: %s%n",
d645 2
a646 1
         theA1_B2_A3.get (A_B_A_BOM));
@


1.96
log
@longNames ==> shortNames
@
text
@d8 1
d12 1
a54 1
   private static final Property <Operation>    A_OPN;
d57 1
d61 1
d65 1
a87 1
      A_OPN      = A.     newProperty          ("A_OPN",      Operation.class);
d90 1
d94 1
d98 1
d609 1
a609 1
      theA3      .newOperation (A_OPN);
d612 6
d625 3
a627 2
         + "A3    .A_OPN:     %s%n"
         + "B2    .B_DEM:     %s%n",
d633 3
a635 2
         theA3      .get (A_OPN),
         theB2      .get (B_DEM));
@


1.95
log
@newDemand
@
text
@d572 1
a572 1
      assert (! getLongNames ());
d574 1
a574 1
      setLongNames (true);
d576 1
a576 1
      assert (getLongNames ());
d597 3
@


1.94
log
@ProblemMgr ==> ProblemManager
@
text
@d8 1
d56 1
d87 1
d601 1
d610 2
a611 1
         + "A3    .A_OPN:     %s%n",
d617 2
a618 1
         theA3      .get (A_OPN));
@


1.93
log
@Revised String conventions
@
text
@d22 3
a24 3
import static com.ibm.witm.ModelScheme    .*;
import static com.ibm.witm.ModelInstance.*;
import static com.ibm.witm.ProblemMgr.*;
d557 1
a557 1
 * Tests class ProblemMgr.
d560 1
a560 1
   private void testProblemMgr ()
d562 2
a563 2
      assert (getCurrentProblemMgr () == null);
      assert (getCurrentProblem    () == null);
d565 1
a565 1
      newProblemMgr ();
d623 2
a624 2
      setCurrentProblemMgr    (null);
      setCurrentModelInstance (null);
d646 1
a646 1
      testProblemMgr        ();
@


1.92
log
@Minor revisions.
@
text
@d330 3
a332 3
      theA = A.newPrimitive ("#1");
             B.newPrimitive ("#2");
             A.newPrimitive ("#3");
d347 1
a347 1
      foundPrim = A.get ("#1");
d392 3
a394 3
      theA1       = A.get ("#1");
      theB2       = B.get ("#2");
      theA3       = A.get ("#3");
d489 5
a493 5
      A1 = A.newPrimitive ("#1");
      A2 = A.newPrimitive ("#2");
      A3 = A.newPrimitive ("#3");
      B1 = B.newPrimitive ("#1");
      B2 = B.newPrimitive ("#2");
d531 1
a531 1
      theA = A.get ("#1");
d587 3
a589 3
      theA1 = A.get ("#1");
      theB2 = B.get ("#2");
      theA3 = A.get ("#3");
@


1.91
log
@Scheme ==> ModelScheme
@
text
@d41 2
a42 1
   private static final ModelScheme                  UNIT_TEST;
d45 1
d47 1
d53 1
d55 1
d60 1
d71 2
a72 1
      UNIT_TEST  =        newModelScheme            ("UNIT_TEST");
d75 1
d77 1
d83 1
d85 1
d90 1
d213 1
a213 1
       + "----------------------------------------%n");
d234 1
a234 1
       + "   Name:   \"%s\"%n",
d237 1
a237 1
         A             .getName ());
d250 1
a250 1
       + "   Name:   \"%s\"%n",
d253 1
a253 1
         A_B_A             .getName ());
d300 1
a300 1
       + "   Name:   \"%s\"%n",
d303 1
a303 1
         mainModelInstance             .getName ());
d636 1
a636 1
      testModelScheme            ();
@


1.90
log
@Embodiment ==> ModelInstance
@
text
@d20 1
a20 1
import com.ibm.witm.Scheme;
d22 1
a22 1
import static com.ibm.witm.Scheme    .*;
d38 1
a38 1
// Declaration of the Scheme and its elements.
d41 1
a41 1
   private static final Scheme                  UNIT_TEST;
d60 1
a60 1
// Construction of the Scheme and its elements.
d65 1
a65 1
      UNIT_TEST  =        newScheme            ("UNIT_TEST");
d176 1
a176 1
 * Tests class Scheme.
d179 1
a179 1
   private void testScheme ()
d181 1
a181 1
      assert (getCurrentScheme () == UNIT_TEST);
d183 1
a183 1
      setCurrentScheme (null);
d185 1
a185 1
      assert (getCurrentScheme () == null);
d187 1
a187 1
      setCurrentScheme (UNIT_TEST);
d209 1
a209 1
      freezeCurrentScheme ();
d221 1
a221 1
       + "   Scheme: \"%s\"%n"
d224 1
a224 1
         A.getScheme ().getName (),
d237 1
a237 1
       + "   Scheme: \"%s\"%n"
d240 1
a240 1
         A_B_A.getScheme ().getName (),
d287 1
a287 1
       + "   Scheme: \"%s\"%n"
d290 1
a290 1
         mainModelInstance.getScheme ().getName (),
d624 1
a624 1
      testScheme            ();
@


1.89
log
@newOperation
@
text
@d11 1
a11 1
import com.ibm.witm.Embodiment;
d23 1
a23 1
import static com.ibm.witm.Embodiment.*;
d87 1
a87 1
 * The main Embodiment for the unit test.
d90 1
a90 1
   private Embodiment mainEmbodiment;
d98 1
a98 1
      mainEmbodiment = null;
d275 1
a275 1
 * Tests class Embodiment.
d278 1
a278 1
   private void testEmbodiment ()
d280 1
a280 1
      assert (getCurrentEmbodiment () == null);
d282 1
a282 1
      mainEmbodiment = UNIT_TEST.newEmbodiment ("Unit-Test");
d289 3
a291 3
         mainEmbodiment,
         mainEmbodiment.getScheme ().getName (),
         mainEmbodiment             .getName ());
d293 1
a293 1
      UNIT_TEST.newEmbodiment ("Embodiment #2");
d297 2
a298 2
       + "Current Embodiment: \"%s\"%n",
         getCurrentEmbodiment ().getName ());
d300 1
a300 1
      setCurrentEmbodiment (mainEmbodiment);
d304 2
a305 2
       + "Current Embodiment: \"%s\"%n",
         getCurrentEmbodiment ().getName ());
d325 1
a325 1
       + "   Embodiment:        \"%s\"%n"
d330 1
a330 1
         theA.getEmbodiment        ().getName (),
d475 1
a475 1
      UNIT_TEST.newEmbodiment ("Slice Test");
d506 1
a506 1
      setCurrentEmbodiment (mainEmbodiment);
d611 2
a612 2
      setCurrentProblemMgr (null);
      setCurrentEmbodiment (null);
d629 1
a629 1
      testEmbodiment        ();
@


1.88
log
@Long names.
@
text
@d8 1
d49 1
d65 15
a79 14
      UNIT_TEST    =        newScheme            ("UNIT_TEST");
      GLOBAL       =        getGlobalCategory    ();
      GLOBAL_DBL   = GLOBAL.newProperty          ("GLOBAL_DBL", Double.class);
      PERIOD       =        getPeriodCategory    ();
      A            =        newPrimitiveCategory ("A");
      A_INT        = A.     newProperty          ("A_INT",      Integer.class);
      A_MAT        = A.     newProperty          ("A_MAT",      Part.class);
      A_CAP        = A.     newProperty          ("A_CAP",      Part.class);
      B            =        newPrimitiveCategory ("B");
      A_B_A        =        newTupleCategory     ("A_B_A",      A, B, A);
      A_2          = A_B_A. newDimensionID       ("A_2",        A, 2); 
      A_B_A_STR    = A_B_A. newProperty          ("A_B_A_STR",  String.class);
      A_B_A_MAT    = A_B_A. newProperty          ("A_B_A_MAT",  Part.class);
      B_ABA        =        newTupleCategory     ("B_ABA",      B, A_B_A);
d565 1
a565 1
 * Tests Item.newPart.
d568 1
a568 1
   private void testNewPart ()
d581 5
a585 5
      theA1.newPart (A_CAP, CAPACITY);
      theA1.newPart (A_MAT, MATERIAL);
      theA3.newPart (A_MAT, MATERIAL);
      
      theA1_B2_A3.newPart (A_B_A_MAT, MATERIAL);
d593 2
a594 1
         + "A1B2A3.A_B_A_MAT: %s%n",
d599 2
a600 1
         theA1_B2_A3.get (A_B_A_MAT));
d635 1
a635 1
      testNewPart           ();
@


1.87
log
@Category ==> ItemCategory
@
text
@a49 1
                       @@SuppressWarnings("unused")
d52 1
d75 1
d553 6
d567 4
a570 9
      Primitive A1;
      Primitive A3;
      
      A1 = A.get ("#1");
      A3 = A.get ("#3");
      
      A1.newPart (A_CAP, CAPACITY);
      A1.newPart (A_MAT, MATERIAL);
      A3.newPart (A_MAT, MATERIAL);
d572 12
d586 10
a595 8
         + "A1.A_CAP: %s%n"
         + "A1.A_MAT: %s%n"
         + "A3.A_CAP: %s%n"
         + "A3.A_MAT: %s%n",
         A1.get (A_CAP),
         A1.get (A_MAT),
         A3.get (A_CAP),
         A3.get (A_MAT));
@


1.86
log
@Removed Tuple.get (theCat, theIdx).
@
text
@d261 3
a263 3
       + "   Category:   \"%s\"%n"
       + "   Value Type: %s%n"
       + "   Name:       \"%s\"%n",
d265 3
a267 3
         A_INT.getCategory  ().getName       (),
         A_INT.getValueType ().getSimpleName (),
         A_INT                .getName       ());
d322 1
a322 1
       + "   Category:          \"%s\"%n"
d327 1
a327 1
         theA.getCategory          ().getName (),
@


1.85
log
@Tests for Tuple.get (theDimID).
@
text
@a397 5
       + "   Coordinate #3: %s%n",
         theA1_B2_A3.get (A, 2));
      
      System.out.printf (
         "%n"
@


1.84
log
@Error tests for newDimensionID.
@
text
@d437 4
@


1.83
log
@DimensionID
@
text
@d50 2
a53 2
                       @@SuppressWarnings("unused")
   private static final DimensionID <Primitive> FOO;
d65 1
a65 1
      GLOBAL_DBL   = GLOBAL.newProperty          (Double.class,  "GLOBAL_DBL");
d68 3
a70 3
      A_INT        = A.     newProperty          (Integer.class, "A_INT");
      A_MAT        = A.     newProperty          (Part.class,    "A_MAT");
      A_CAP        = A.     newProperty          (Part.class,    "A_CAP");
d72 4
a75 4
      A_B_A        =        newTupleCategory     ("A_B_A",       A, B, A);
      FOO          = A_B_A. newDimensionID       (A,             2); 
      A_B_A_STR    = A_B_A. newProperty          (String.class,  "A_B_A_STR");
      B_ABA        =        newTupleCategory     ("B_ABA",       B, A_B_A);
d241 12
d607 1
@


1.82
log
@Re-organized the static fields.
@
text
@d9 1
d40 14
a53 12
   private static final Scheme             UNIT_TEST;
   private static final PrimitiveCategory  GLOBAL;
   private static final Property <Double>  GLOBAL_DBL_PROP;
   private static final PrimitiveCategory  PERIOD;
   private static final PrimitiveCategory  A;
   private static final Property <Integer> A_INT_PROP;
   private static final Property <Part>    A_MAT;
   private static final Property <Part>    A_CAP;
   private static final PrimitiveCategory  B;
   private static final TupleCategory      A_B_A;
   private static final Property <String>  A_B_A_STRING_PROP;
   private static final TupleCategory      B_ABA;
d63 13
a75 19
      UNIT_TEST         = newScheme            ("UNIT_TEST");
      GLOBAL            = getGlobalCategory    ();
      GLOBAL_DBL_PROP   = GLOBAL.newProperty   (Double.class,
                                                "GLOBAL_DBL_PROP");
      PERIOD            = getPeriodCategory    ();
      A                 = newPrimitiveCategory ("A");
      A_INT_PROP        = A.newProperty        (Integer.class,
                                                "A_INT_PROP");
      A_MAT             = A.newProperty        (Part.class,
                                                "A_MAT");
      A_CAP             = A.newProperty        (Part.class,
                                                "A_CAP");
      B                 = newPrimitiveCategory ("B");
      A_B_A             = newTupleCategory     ("A_B_A",
                                                A, B, A);
      A_B_A_STRING_PROP = A_B_A.newProperty    (String.class,
                                                "A_B_A_STRING_PROP");
      B_ABA             = newTupleCategory     ("B_ABA",
                                                B, A_B_A);
d252 4
a255 4
         A_INT_PROP,
         A_INT_PROP.getCategory  ().getName       (),
         A_INT_PROP.getValueType ().getSimpleName (),
         A_INT_PROP                .getName       ());
d408 1
a408 1
      theA_B_A.set (A_B_A_STRING_PROP, "ABA Text");
d410 1
a410 1
      theText = theA_B_A.get (A_B_A_STRING_PROP);
d506 1
a506 1
      theInteger = theA.get (A_INT_PROP);
d510 1
a510 1
      theA.set (A_INT_PROP, 17);
d512 1
a512 1
      theInteger = theA.get (A_INT_PROP);
d516 1
a516 1
      theA.set (A_INT_PROP, null);
d518 1
a518 1
      theInteger = theA.get (A_INT_PROP);
d522 1
a522 1
      GLOBAL_DBL_PROP.setGlobal (29.7);
d524 1
a524 1
      theDouble = GLOBAL_DBL_PROP.getGlobal ();
@


1.81
log
@Compound ==> Tuple
@
text
@d35 2
d39 18
a56 19
/*******************************************************************************
 * The Scheme for the unit test.
 *******************************************************************************
 */
   private static final Scheme   UNIT_TEST =
                     newScheme ("UNIT_TEST");

/*******************************************************************************
 * The GLOBAL Category for the unit test.
 *******************************************************************************
 */
   private static final PrimitiveCategory GLOBAL = getGlobalCategory ();

/*******************************************************************************
 * A global Double-valued Property.
 *******************************************************************************
 */
   private static final Property <Double>        GLOBAL_DBL_PROP =
              GLOBAL.newProperty (Double.class, "GLOBAL_DBL_PROP");
d58 22
a79 5
/*******************************************************************************
 * The PERIOD Category for the unit test.
 *******************************************************************************
 */
   private static final PrimitiveCategory PERIOD = getPeriodCategory ();
a80 56
/*******************************************************************************
 * The Category of "A-Primitives".
 *******************************************************************************
 */
   private static final PrimitiveCategory   A =
                     newPrimitiveCategory ("A");
   
/*******************************************************************************
 * An Integer-valued Property of Category A. 
 *******************************************************************************
 */
   private static final Property <Integer>        A_INT_PROP =
                   A.newProperty (Integer.class, "A_INT_PROP");
   
/*******************************************************************************
 * The material Part associated with an A.
 *******************************************************************************
 */
   private static final Property <Part>        A_MAT =
                   A.newProperty (Part.class, "A_MAT");
   
/*******************************************************************************
 * The capacity Part associated with an A.
 *******************************************************************************
 */
   private static final Property <Part>        A_CAP =
                   A.newProperty (Part.class, "A_CAP");
   
/*******************************************************************************
 * The Category of "B-Primitives".
 *******************************************************************************
 */
   private static final PrimitiveCategory   B =
                     newPrimitiveCategory ("B");
   
/*******************************************************************************
 * Tuples of type (A, B, A)
 *******************************************************************************
 */
   private static final TupleCategory   A_B_A =
                     newTupleCategory ("A_B_A", A, B, A);
   
/*******************************************************************************
 * A String-valued Property of Category A_B_A. 
 *******************************************************************************
 */
   private static final Property <String>        A_B_A_STRING_PROP =
               A_B_A.newProperty (String.class, "A_B_A_STRING_PROP");
   
/*******************************************************************************
 * Tuples of type (B, A_B_A)
 *******************************************************************************
 */
   private static final TupleCategory   B_ABA =
                     newTupleCategory ("B_ABA", B, A_B_A);
   
@


1.80
log
@Item.newPart
@
text
@d10 2
a11 2
import com.ibm.witm.Compound;
import com.ibm.witm.CompoundCategory;
d99 1
a99 1
 * Compounds of type (A, B, A)
d102 2
a103 2
   private static final CompoundCategory   A_B_A =
                     newCompoundCategory ("A_B_A", A, B, A);
d113 1
a113 1
 * Compounds of type (B, A_B_A)
d116 2
a117 2
   private static final CompoundCategory   B_ABA =
                     newCompoundCategory ("B_ABA", B, A_B_A);
d266 1
a266 1
 * Tests class CompoundCategory.
d269 1
a269 1
   private void testCompoundCategory ()
d391 1
a391 1
 * Tests class Compound.
d394 1
a394 1
   private void testCompound ()
d399 3
a401 3
      Compound  theA1_B2_A3;
      Compound  theA_B_A;
      Compound  theB_ABA;
d409 1
a409 1
      theA1_B2_A3 = A_B_A.newCompound (theA1, theB2, theA3);
d411 1
a411 1
      A_B_A.newCompound (theA1, theB2, theA1);
d413 1
a413 1
      assert (theA1_B2_A3.getCompoundCategory () == A_B_A);
d432 1
a432 1
       + "All Compounds of type A_B_A:%n");
d434 1
a434 1
      for (Compound locA_B_A: A_B_A.getAll ())
d455 1
a455 1
      theB_ABA = B_ABA.newCompound (theB2, theA1_B2_A3);
d480 2
a481 2
      for (Compound theComp: A_B_A.getSliceSparse (thePattern))
         System.out.printf ("      %s%n", theComp);
d485 2
a486 2
      for (Compound theComp: A_B_A.getSliceDense (thePattern))
         System.out.printf ("      %s%n", theComp);
d509 9
a517 9
      A_B_A.newCompound (A3, B2, A3);
      A_B_A.newCompound (A3, B2, A1);
      A_B_A.newCompound (A3, B1, A2);
      A_B_A.newCompound (A2, B2, A3);
      A_B_A.newCompound (A2, B2, A1);
      A_B_A.newCompound (A2, B1, A2);
      A_B_A.newCompound (A1, B2, A2);
      A_B_A.newCompound (A1, B1, A3);
      A_B_A.newCompound (A1, B1, A1);
d521 1
a521 1
         + "Compounds for the Slice Test:%n");
d523 2
a524 2
      for (Compound theComp: A_B_A.getAll ())
         System.out.printf ("   %s%n", theComp);
d635 1
a635 1
      testCompoundCategory  ();
d639 1
a639 1
      testCompound          ();
@


1.79
log
@Class ProblemMgr.
@
text
@d8 1
d25 1
d71 15
a85 1
 * The Category of "B-Primitives".
d88 2
a89 2
   private static final PrimitiveCategory   B =
                     newPrimitiveCategory ("B");
d92 1
a92 1
 * An Integer-valued Property of Category A. 
d95 2
a96 2
   private static final Property <Integer>        A_INT_PROP =
                   A.newProperty (Integer.class, "A_INT_PROP");
d582 37
d621 1
a621 3
      
      assert (getCurrentProblemMgr () == null);
      assert (getCurrentProblem    () == null);
d643 2
@


1.78
log
@Current Problem
@
text
@a7 1
import com.ibm.witj.Problem;
d21 1
d555 1
a555 1
 * Tests access to WIT-J.
d558 1
a558 1
   private void testWitJ ()
d560 2
a561 1
      Problem theProblem;
d563 1
a563 1
      theProblem = newProblem ();
d565 1
a565 1
      theProblem.set (title, "WIT-M Unit Test");
d567 1
a567 1
      assert (getCurrentProblem () == null);
d569 2
a570 3
      setCurrentProblem (theProblem);
      
      assert (getCurrentProblem () == theProblem);
d591 1
a591 1
      testWitJ              ();
@


1.77
log
@Initial invocation of WIT-J.
@
text
@d565 6
@


1.76
log
@PERIOD Primitives
@
text
@d8 1
d23 2
d555 13
d585 1
@


1.75
log
@Period Primitives.
@
text
@d366 1
a366 1
       + "   Index:         %d%n",
d368 1
a368 1
         theWedPer.getIndex ());
@


1.74
log
@Removed period index Property.
@
text
@d40 1
a40 1
 * The global Category for the unit test.
d53 1
a53 1
 * The period Category for the unit test.
d55 1
a55 1
 */                                      @@SuppressWarnings("unused")
d322 1
d358 11
@


1.73
log
@Period Category
@
text
@a58 7
 * The period index Property for the unit test.
 *******************************************************************************
 */                                       @@SuppressWarnings("unused")
   private static final Property <Integer> PERIOD_INDEX =
                                           getPeriodIndexProperty ();
   
/*******************************************************************************
@


1.72
log
@Implementation ==> Embodiment
@
text
@d49 15
a63 2
   private static final Property <Double>         GLOBAL_DBL_PROP =
              GLOBAL.newProperty (Double.class,  "GLOBAL_DBL_PROP");
@


1.71
log
@getSliceSparse
@
text
@d8 1
a8 1
import com.ibm.witm.Implementation;
d19 2
a20 2
import static com.ibm.witm.Scheme        .*;
import static com.ibm.witm.Implementation.*;
d99 1
a99 1
 * The main Implementation for the unit test.
d102 1
a102 1
   private Implementation mainImplementation;
d110 1
a110 1
      mainImplementation = null;
d275 1
a275 1
 * Tests class Implementation.
d278 1
a278 1
   private void testImplementation ()
d280 1
a280 1
      assert (getCurrentImplementation () == null);
d282 1
a282 1
      mainImplementation = UNIT_TEST.newImplementation ("Unit-Test");
d289 3
a291 3
         mainImplementation,
         mainImplementation.getScheme ().getName (),
         mainImplementation             .getName ());
d293 1
a293 1
      UNIT_TEST.newImplementation ("Implementation #2");
d297 2
a298 2
       + "Current Implementation: \"%s\"%n",
         getCurrentImplementation ().getName ());
d300 1
a300 1
      setCurrentImplementation (mainImplementation);
d304 2
a305 2
       + "Current Implementation: \"%s\"%n",
         getCurrentImplementation ().getName ());
d324 1
a324 1
       + "   Implementation:    \"%s\"%n"
d329 1
a329 1
         theA.getImplementation    ().getName (),
d464 1
a464 1
      UNIT_TEST.newImplementation ("Slice Test");
d495 1
a495 1
      setCurrentImplementation (mainImplementation);
d546 1
a546 1
      testImplementation    ();
@


1.70
log
@getGlobal Implementation == Property.
@
text
@d432 22
a453 1
 * Tests getSlice (...).
d472 8
a480 8
      A_B_A.newCompound (A1, B1, A3);
      A_B_A.newCompound (A1, B2, A2);
      A_B_A.newCompound (A2, B1, A2);
      A_B_A.newCompound (A2, B2, A1);
      A_B_A.newCompound (A2, B2, A3);
      A_B_A.newCompound (A3, B1, A2);
      A_B_A.newCompound (A3, B2, A1);
      A_B_A.newCompound (A3, B2, A3);
d489 5
a493 34
      System.out.printf (
         "%n"
         + "Slice (A2, B2, A3):%n");
      
      for (Compound theComp: A_B_A.getSlice (A2, B2, A3))
         System.out.printf ("   %s%n", theComp);
      
      System.out.printf (
         "%n"
         + "Slice (A2, B2, A2):%n");
      
      for (Compound theComp: A_B_A.getSlice (A2, B2, A2))
         System.out.printf ("   %s%n", theComp);
      
      System.out.printf (
         "%n"
         + "Slice (Null, B1, A2):%n");
      
      for (Compound theComp: A_B_A.getSlice (null, B1, A2))
         System.out.printf ("   %s%n", theComp);
      
      System.out.printf (
         "%n"
         + "Slice (A2, Null, Null):%n");
      
      for (Compound theComp: A_B_A.getSlice (A2, null, null))
         System.out.printf ("   %s%n", theComp);
      
      System.out.printf (
         "%n"
         + "Slice (Null, Null, Null):%n");
      
      for (Compound theComp: A_B_A.getSlice (null, null, null))
         System.out.printf ("   %s%n", theComp);
@


1.69
log
@setGlobal Implementation ==> Property
@
text
@d536 1
a536 1
      theDouble = getGlobal (GLOBAL_DBL_PROP);
@


1.68
log
@getSlice Implementation ==> CompoundCategory
@
text
@d534 1
a534 1
      setGlobal (GLOBAL_DBL_PROP, 29.7);
@


1.67
log
@get Implementation ==> CompoundCategory
@
text
@d472 1
a472 1
      for (Compound theComp: getSlice (A_B_A, A2, B2, A3))
d479 1
a479 1
      for (Compound theComp: getSlice (A_B_A, A2, B2, A2))
d486 1
a486 1
      for (Compound theComp: getSlice (A_B_A, null, B1, A2))
d493 1
a493 1
      for (Compound theComp: getSlice (A_B_A, A2, null, null))
d500 1
a500 1
      for (Compound theComp: getSlice (A_B_A, null, null, null))
@


1.66
log
@get Implementation ==> PrimitiveCategory
@
text
@d404 1
a404 1
      theA_B_A = get (A_B_A, theA3, theB2, theA1);
d408 1
a408 1
      theA_B_A = get (A_B_A, theA1, theB2, theA3);
@


1.65
log
@Moved getAll from Implementation to Category.
@
text
@d334 1
a334 1
      foundPrim = get (A, "#1");
d368 3
a370 3
      theA1       = get (A, "#1");
      theB2       = get (B, "#2");
      theA3       = get (A, "#3");
d516 1
a516 1
      theA = get (A, "#1");
@


1.64
log
@Moved newCompound from Implementation to CompoundCategory.
@
text
@d342 1
a342 1
      for (Primitive thePrim: getAll (A))
d397 1
a397 1
      for (Compound locA_B_A: getAll (A_B_A))
d465 1
a465 1
      for (Compound theComp: getAll (A_B_A))
@


1.63
log
@Moved newPrimitive from Implementation to PrimitiveCategory.
@
text
@d372 1
a372 1
      theA1_B2_A3 = newCompound (A_B_A, theA1, theB2, theA3);
d374 1
a374 1
      newCompound (A_B_A, theA1, theB2, theA1);
d418 1
a418 1
      theB_ABA = newCompound (B_ABA, theB2, theA1_B2_A3);
d451 9
a459 9
      newCompound (A_B_A, A1, B1, A1);
      newCompound (A_B_A, A1, B1, A3);
      newCompound (A_B_A, A1, B2, A2);
      newCompound (A_B_A, A2, B1, A2);
      newCompound (A_B_A, A2, B2, A1);
      newCompound (A_B_A, A2, B2, A3);
      newCompound (A_B_A, A3, B1, A2);
      newCompound (A_B_A, A3, B2, A1);
      newCompound (A_B_A, A3, B2, A3);
@


1.62
log
@Moved newImplementation from Implementation to Scheme.
@
text
@d317 3
a319 3
      theA = newPrimitive (A, "#1");
             newPrimitive (B, "#2");
             newPrimitive (A, "#3");
d445 5
a449 5
      A1 = newPrimitive (A, "#1");
      A2 = newPrimitive (A, "#2");
      A3 = newPrimitive (A, "#3");
      B1 = newPrimitive (B, "#1");
      B2 = newPrimitive (B, "#2");
@


1.61
log
@Moved newProperty to class Category
@
text
@d282 1
a282 1
      mainImplementation = newImplementation (UNIT_TEST, "Unit-Test");
d293 1
a293 1
      newImplementation (UNIT_TEST, "Implementation #2");
d443 1
a443 1
      newImplementation (UNIT_TEST, "Slice Test");
@


1.60
log
@set/get ==> set/getGlobal
@
text
@d49 2
a50 2
   private static final Property <Double>                GLOBAL_DBL_PROP =
                     newProperty (Double.class, GLOBAL, "GLOBAL_DBL_PROP");
d70 2
a71 2
   private static final Property <Integer>           A_INT_PROP =
                     newProperty (Integer.class, A, "A_INT_PROP");
d84 2
a85 2
   private static final Property <String>               A_B_A_STRING_PROP =
                     newProperty (String.class, A_B_A, "A_B_A_STRING_PROP");
d397 1
a397 1
      for (Compound locA_B: getAll (A_B_A))
d401 1
a401 1
            locA_B);
@


1.59
log
@Re-arranged source code.
@
text
@d534 1
a534 1
      set (GLOBAL_DBL_PROP, 29.7);
d536 1
a536 1
      theDouble = get (GLOBAL_DBL_PROP);
@


1.58
log
@//=== ==> /////
@
text
@d29 1
a29 1
// Package
d33 1
a33 1
 * Performs a unit test of WIT-M: Invokes all public methods of WIT-M.
d36 2
a37 7
   static void performTest ()
      {
      try
         {
         UnitTester theUnitTester;
         
         theUnitTester = new UnitTester ();
d39 5
a43 14
         theUnitTester.perfTest ();
         }

      catch (Exception theExc)
         {
         theExc.printStackTrace ();

         System.exit (4);
         }

      System.out.printf (
         "\n"
       + "Normal termination of unit test.%n");
      }
d45 49
d95 1
a95 1
// Private
d97 1
a97 1
   
d99 1
a99 1
 * Constructor.
d102 6
d113 3
a115 19
/*******************************************************************************
 * Internal implementation of the unit test.
 *******************************************************************************
 */
   private void perfTest ()
      throws
         Exception
      {
      testInputTable        ();
      testScheme            ();
      testPrimitiveCategory ();
      testCompoundCategory  ();
      testProperty          ();
      testImplementation    ();
      testPrimitive         ();
      testCompound          ();
      testSlice             ();
      testPropertySetGet    ();
      }
d542 1
a542 1
 * The Scheme for the unit test.
d545 19
a563 2
   private static final Scheme   UNIT_TEST =
                     newScheme ("UNIT_TEST");
d566 1
a566 1
 * The global Category for the unit test.
d569 22
a590 1
   private static final PrimitiveCategory GLOBAL = getGlobalCategory ();
a591 55
/*******************************************************************************
 * A global Double-valued Property.
 *******************************************************************************
 */
   private static final Property <Double>                GLOBAL_DBL_PROP =
                     newProperty (Double.class, GLOBAL, "GLOBAL_DBL_PROP");
   
/*******************************************************************************
 * The Category of "A-Primitives".
 *******************************************************************************
 */
   private static final PrimitiveCategory   A =
                     newPrimitiveCategory ("A");
   
/*******************************************************************************
 * The Category of "B-Primitives".
 *******************************************************************************
 */
   private static final PrimitiveCategory   B =
                     newPrimitiveCategory ("B");
   
/*******************************************************************************
 * An Integer-valued Property of Category A. 
 *******************************************************************************
 */
   private static final Property <Integer>           A_INT_PROP =
                     newProperty (Integer.class, A, "A_INT_PROP");
   
/*******************************************************************************
 * Compounds of type (A, B, A)
 *******************************************************************************
 */
   private static final CompoundCategory   A_B_A =
                     newCompoundCategory ("A_B_A", A, B, A);
   
/*******************************************************************************
 * A String-valued Property of Category A_B_A. 
 *******************************************************************************
 */
   private static final Property <String>               A_B_A_STRING_PROP =
                     newProperty (String.class, A_B_A, "A_B_A_STRING_PROP");
   
/*******************************************************************************
 * Compounds of type (B, A_B_A)
 *******************************************************************************
 */
   private static final CompoundCategory   B_ABA =
                     newCompoundCategory ("B_ABA", B, A_B_A);
   
/*******************************************************************************
 * The main Implementation for the unit test.
 *******************************************************************************
 */
   private Implementation mainImplementation;
   
@


1.57
log
@Global Category / Primitive.
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d28 1
a28 1
//==============================================================================
d30 1
a30 1
//==============================================================================
d59 1
a59 1
//==============================================================================
d61 1
a61 1
//==============================================================================
d584 1
a584 1
//==============================================================================
@


1.56
log
@0-based indexing of coordinates and dimensions
@
text
@d89 1
a89 1
      testItem              ();
d300 1
d305 1
d321 5
d482 1
a482 1
 * Tests class Item.
d485 1
a485 1
   private void testItem ()
d489 1
a492 5
      System.out.printf (
         "%n"
       + "Category: \"%s\"%n",
         theA.getCategory ().getName ());
      
d508 6
d524 13
d565 1
a565 1
 * An String-valued Property of Category A_B_A. 
@


1.55
log
@A_PRIM ==>A, B_PRIM ==> B
@
text
@d359 1
a359 1
         theA1_B2_A3.get (A, 3));
@


1.54
log
@Slice Test
@
text
@d210 3
a212 3
         A_PRIM,
         A_PRIM.getScheme ().getName (),
         A_PRIM             .getName ());
d289 1
a289 1
      Primitive theA_PRIM;
d292 3
a294 3
      theA_PRIM = newPrimitive (A_PRIM, "#1");
                  newPrimitive (B_PRIM, "#2");
                  newPrimitive (A_PRIM, "#3");
d302 4
a305 4
         theA_PRIM,
         theA_PRIM.getImplementation    ().getName (),
         theA_PRIM.getPrimitiveCategory ().getName (),
         theA_PRIM                        .getName ());
d307 1
a307 1
      foundPrim = get (A_PRIM, "#1");
d309 1
a309 1
      assert (foundPrim == theA_PRIM);
d313 1
a313 1
       + "A_PRIM Primitives:%n");
d315 1
a315 1
      for (Primitive thePrim: getAll (A_PRIM))
d336 3
a338 3
      theA1       = get (A_PRIM, "#1");
      theB2       = get (B_PRIM, "#2");
      theA3       = get (A_PRIM, "#3");
d353 2
a354 2
       + "   B_PRIM Coordinate: %s%n",
         theA1_B2_A3.get (B_PRIM));
d359 1
a359 1
         theA1_B2_A3.get (A_PRIM, 3));
d394 1
a394 1
      thePrim  = theB_ABA.get (A_B_A).get (B_PRIM);
d413 5
a417 5
      A1 = newPrimitive (A_PRIM, "#1");
      A2 = newPrimitive (A_PRIM, "#2");
      A3 = newPrimitive (A_PRIM, "#3");
      B1 = newPrimitive (B_PRIM, "#1");
      B2 = newPrimitive (B_PRIM, "#2");
d480 1
a480 1
      Item    theA_PRIM;
d483 1
a483 1
      theA_PRIM = get (A_PRIM, "#1");
d488 1
a488 1
         theA_PRIM.getCategory ().getName ());
d490 1
a490 1
      theInteger = theA_PRIM.get (A_INT_PROP);
d494 1
a494 1
      theA_PRIM.set (A_INT_PROP, 17);
d496 1
a496 1
      theInteger = theA_PRIM.get (A_INT_PROP);
d500 1
a500 1
      theA_PRIM.set (A_INT_PROP, null);
d502 1
a502 1
      theInteger = theA_PRIM.get (A_INT_PROP);
d515 1
a515 1
 * The Items of this PrimitiveCategory are "A-Primitives".
d518 2
a519 2
   private static final PrimitiveCategory   A_PRIM =
                     newPrimitiveCategory ("A_PRIM");
d522 1
a522 1
 * The Items of this PrimitiveCategory are "B-Primitives".
d525 2
a526 2
   private static final PrimitiveCategory   B_PRIM =
                     newPrimitiveCategory ("B_PRIM");
d529 1
a529 1
 * An Integer-valued Property of Category A_PRIM. 
d532 2
a533 2
   private static final Property <Integer>                A_INT_PROP =
                     newProperty (Integer.class, A_PRIM, "A_INT_PROP");
d536 1
a536 1
 * Compounds of type (A_PRIM, B_PRIM, A_PRIM)
d540 1
a540 1
                     newCompoundCategory ("A_B_A", A_PRIM, B_PRIM, A_PRIM);
d550 1
a550 1
 * Compounds of type (B_PRIM, A_B_A)
d554 1
a554 1
                     newCompoundCategory ("B_ABA", B_PRIM, A_B_A);
@


1.53
log
@Added tests for CompoundCategory of a CompoundCategory.
Fixed a bug in Compound.toString () for this case.
@
text
@d69 1
d83 1
a83 1
      testCompoundCategory     ();
d87 2
a88 1
      testCompound             ();
d255 1
a255 1
      Implementation theImple;
d257 1
a257 7
      theImple = getCurrentImplementation ();
      
      assert (theImple == null);
      
      newImplementation (UNIT_TEST, "Unit-Test");
      
      theImple = getCurrentImplementation ();
d264 3
a266 3
         theImple,
         theImple.getScheme ().getName (),
         theImple             .getName ());
d275 1
a275 1
      setCurrentImplementation (theImple);
d400 75
d556 6
@


1.52
log
@Error test for getSlice.
@
text
@d336 3
d383 18
d465 1
a465 1
 * Compounds of type (A_PRIM, B_PRIM)
a474 1
                       @@SuppressWarnings("unused")
d478 7
@


1.51
log
@getSlice
@
text
@a382 8
 * Tests getSlice (...)
 *******************************************************************************
 */
   private void testSlice ()
      {
      }

/*******************************************************************************
@


1.50
log
@Tuple ==> Compound
@
text
@d253 1
a253 1
      Implementation theImpl;
d255 1
a255 1
      theImpl = getCurrentImplementation ();
d257 1
a257 1
      assert (theImpl == null);
d261 1
a261 1
      theImpl = getCurrentImplementation ();
d268 3
a270 3
         theImpl,
         theImpl.getScheme ().getName (),
         theImpl             .getName ());
d279 1
a279 1
      setCurrentImplementation (theImpl);
d334 2
a335 2
      Compound     theA1_B2_A3;
      Compound     theA_B_A;
d381 8
d462 1
a462 1
                        @@SuppressWarnings("unused")
@


1.49
log
@Test for get (TupleCategory, ...)
@
text
@d9 2
a10 2
import com.ibm.witm.Tuple;
import com.ibm.witm.TupleCategory;
d82 1
a82 1
      testTupleCategory     ();
d86 1
a86 1
      testTuple             ();
d214 1
a214 1
 * Tests class TupleCategory.
d217 1
a217 1
   private void testTupleCategory ()
d326 1
a326 1
 * Tests class Tuple.
d329 1
a329 1
   private void testTuple ()
d334 2
a335 2
      Tuple     theA1_B2_A3;
      Tuple     theA_B_A;
d341 1
a341 1
      theA1_B2_A3 = newTuple (A_B_A, theA1, theB2, theA3);
d343 1
a343 1
      newTuple (A_B_A, theA1, theB2, theA1);
d345 1
a345 1
      assert (theA1_B2_A3.getTupleCategory () == A_B_A);
d364 1
a364 1
       + "All Tuples of type A_B_A:%n");
d366 1
a366 1
      for (Tuple locA_B: getAll (A_B_A))
d444 1
a444 1
 * Tuples of type (A_PRIM, B_PRIM)
d447 2
a448 2
   private static final TupleCategory   A_B_A =
                     newTupleCategory ("A_B_A", A_PRIM, B_PRIM, A_PRIM);
@


1.48
log
@Tuple.get (Category, int)
@
text
@d334 1
d337 3
a339 3
      theA1    = get (A_PRIM, "#1");
      theB2    = get (B_PRIM, "#2");
      theA3    = get (A_PRIM, "#3");
d341 1
a341 1
      theA_B_A = newTuple (A_B_A, theA1, theB2, theA3);
d343 3
a345 1
      assert (theA_B_A.getTupleCategory () == A_B_A);
d350 1
a350 1
         theA_B_A);
d355 1
a355 1
         theA_B_A.get (B_PRIM));
d360 1
a360 1
         theA_B_A.get (A_PRIM, 3));
d372 8
@


1.47
log
@1-based indexing of dimensions/coordinates
@
text
@d224 3
a226 3
         A_B,
         A_B.getScheme ().getName (),
         A_B             .getName ());
d296 3
a298 3
      theA_PRIM = newPrimitive (A_PRIM, "Test");
      
                  newPrimitive (B_PRIM, "Test");
d307 3
a309 3
         theA_PRIM.getImplementation     ().getName (),
         theA_PRIM.getPrimitiveCategory  ().getName (),
         theA_PRIM                         .getName ());
d311 1
a311 1
      foundPrim = get (A_PRIM, "Test");
d331 8
a338 6
      Primitive theA_PRIM;
      Primitive theB_PRIM;
      Tuple     theA_B;

      theA_PRIM = get (A_PRIM, "Test");
      theB_PRIM = get (B_PRIM, "Test");
d340 1
a340 1
      theA_B    = newTuple (A_B, theA_PRIM, theB_PRIM);
d342 1
a342 1
      assert (theA_B.getTupleCategory () == A_B);
d347 6
a352 1
         theA_B);
d356 2
a357 2
       + "   B_PRIM Coordinate: \"%s\"%n",
         theA_B.get (B_PRIM).getName ());
d361 1
a361 1
       + "All Tuples of type A_B:%n");
d363 1
a363 1
      for (Tuple locA_B: getAll (A_B))
d380 1
a380 1
      theA_PRIM = get (A_PRIM, "Test");
d436 2
a437 2
   private static final TupleCategory   A_B =
                     newTupleCategory ("A_B", A_PRIM, B_PRIM);
d440 1
a440 1
 * An Integer-valued Property of Category A_A. 
d444 2
a445 2
   private static final Property <String>             A_B_STRING_PROP =
                     newProperty (String.class, A_B, "A_B_STRING_PROP");
@


1.46
log
@Replaced ItemCategory with Category <?>.
@
text
@a333 1
      int       theIdx;
a346 8
      for (theIdx = 0; theIdx < 2; theIdx ++)
         {
         System.out.printf (
            "   Coordinate # %d: %s%n",
            theIdx,
            theA_B.getCoordinateList ().get (theIdx));
         }
      
@


1.45
log
@Removed getPrimitive.
@
text
@d238 3
a240 3
       + "   ItemCategory: \"%s\"%n"
       + "   Value Type:   %s%n"
       + "   Name:         \"%s\"%n",
d242 3
a244 3
         A_INT_PROP.getItemCategory ().getName       (),
         A_INT_PROP.getValueType    ().getSimpleName (),
         A_INT_PROP                   .getName       ());
d386 2
a387 2
       + "ItemCategory: \"%s\"%n",
         theA_PRIM.getItemCategory ().getName ());
@


1.44
log
@get (Category <I>)
@
text
@a403 2
      
      theA_PRIM.getPrimitive ();
@


1.43
log
@Tuple.get (ItemCategory)
@
text
@d358 2
a359 2
       + "   B_PRIM Coordinate: %s%n",
         theA_B.get (B_PRIM));
@


1.42
log
@Moved newProperty from ItemCategory to Scheme.
@
text
@d224 3
a226 3
         A_A,
         A_A.getScheme ().getName (),
         A_A             .getName ());
d293 1
a293 1
      Primitive firstA_PRIM;
d296 1
a296 1
      firstA_PRIM = newPrimitive (A_PRIM, "First");
d298 1
a298 1
                    newPrimitive (A_PRIM, "Second");
d306 4
a309 4
         firstA_PRIM,
         firstA_PRIM.getImplementation     ().getName (),
         firstA_PRIM.getPrimitiveCategory  ().getName (),
         firstA_PRIM                         .getName ());
d311 1
a311 1
      foundPrim = get (A_PRIM, "First");
d313 1
a313 1
      assert (foundPrim == firstA_PRIM);
d331 3
a333 3
      Primitive firstA_PRIM;
      Primitive secondA_PRIM;
      Tuple     theA_A_1_2;
d336 2
a337 2
      firstA_PRIM  = get (A_PRIM, "First");
      secondA_PRIM = get (A_PRIM, "Second");
d339 1
a339 1
      theA_A_1_2 = newTuple (A_A, firstA_PRIM, secondA_PRIM);
d341 1
a341 1
      assert (theA_A_1_2.getTupleCategory () == A_A);
d346 1
a346 1
         theA_A_1_2);
d353 1
a353 1
            theA_A_1_2.getCoordinateList ().get (theIdx));
d358 2
a359 1
       + "All Tuples of type A_A:%n");
d361 5
a365 1
      for (Tuple theA_A: getAll (A_A))
d369 1
a369 1
            theA_A);
d379 1
a379 1
      Item    firstA_PRIM;
d382 1
a382 1
      firstA_PRIM = get (A_PRIM, "First");
d387 1
a387 1
         firstA_PRIM.getItemCategory ().getName ());
d389 1
a389 1
      theInteger = firstA_PRIM.get (A_INT_PROP);
d393 1
a393 1
      firstA_PRIM.set (A_INT_PROP, 17);
d395 1
a395 1
      theInteger = firstA_PRIM.get (A_INT_PROP);
d399 1
a399 1
      firstA_PRIM.set (A_INT_PROP, null);
d401 1
a401 1
      theInteger = firstA_PRIM.get (A_INT_PROP);
d405 1
a405 1
      firstA_PRIM.getPrimitive ();
d423 7
d437 1
a437 1
 * Tuples of type (A_PRIM, A_PRIM)
d440 2
a441 2
   private static final TupleCategory   A_A =
                     newTupleCategory ("A_A", A_PRIM, A_PRIM);
d448 2
a449 2
   private static final Property <String>             A_A_STRING_PROP =
                     newProperty (String.class, A_A, "A_A_STRING_PROP");
@


1.41
log
@Moved newTupleCategory from TupleCategory to Scheme.
@
text
@d421 2
a422 2
   private static final Property <Integer>        A_INT_PROP =
              A_PRIM.newProperty (Integer.class, "A_INT_PROP");
d436 2
a437 2
   private static final Property <String>        A_A_STRING_PROP =
                 A_A.newProperty (String.class, "A_A_STRING_PROP");
@


1.40
log
@newPrimitiveCategory with current Scheme.
@
text
@a19 1
import static com.ibm.witm.TupleCategory .newTupleCategory;
@


1.39
log
@A frozen Scheme cannot be the current Scheme.
@
text
@d416 1
a416 1
           UNIT_TEST.newPrimitiveCategory ("A_PRIM");
@


1.38
log
@theImple ==> theImpl
@
text
@a69 7
      Implementation curImpl;
      
      curImpl = Implementation.getCurrentImplementation ();
      
      assert (curImpl == null);
      
      newImplementation (UNIT_TEST, "Unit-Test");
d194 2
d258 6
a279 2
      setCurrentScheme (null);
      
a281 2
      assert (getCurrentScheme () == UNIT_TEST);

a440 10
// Static initialization block
// Freezes the Scheme.
//==============================================================================

   static
      {
      UNIT_TEST.freeze ();
      }
   
//==============================================================================
@


1.37
log
@Reverting to state as of yesterday 6/8/11 15:00.
@
text
@d70 1
a70 1
      Implementation curImple;
d72 1
a72 1
      curImple = Implementation.getCurrentImplementation ();
d74 1
a74 1
      assert (curImple == null);
d259 1
a259 1
      Implementation theImple;
d261 1
a261 1
      theImple = getCurrentImplementation ();
d268 3
a270 3
         theImple,
         theImple.getScheme ().getName (),
         theImple             .getName ());
d281 1
a281 1
      setCurrentImplementation (theImple);
@


1.36
log
@Testing for current Scheme.
@
text
@d70 7
d259 1
a259 5
      Implementation mainImple;
      
      assert (getCurrentImplementation () == null);
      
      newImplementation ("Unit-Test");
d261 1
a261 1
      mainImple = getCurrentImplementation ();
d268 3
a270 3
         mainImple,
         mainImple.getScheme ().getName (),
         mainImple             .getName ());
d272 1
a272 1
      newImplementation ("Implementation #2");
d279 3
a281 1
      setCurrentImplementation (mainImple);
d283 2
@


1.35
log
@Matching current Scheme to current Implementation.
@
text
@d256 1
a256 1
      newImplementation (UNIT_TEST, "Unit-Test");
d269 1
a269 1
      newImplementation (UNIT_TEST, "Implementation #2");
@


1.34
log
@Current Scheme.
@
text
@a69 7
      Implementation curImple;
      
      curImple = Implementation.getCurrentImplementation ();
      
      assert (curImple == null);
      
      newImplementation (UNIT_TEST, "Unit-Test");
d252 3
a254 1
      Implementation theImple;
d256 3
a258 1
      theImple = getCurrentImplementation ();
d265 3
a267 3
         theImple,
         theImple.getScheme ().getName (),
         theImple             .getName ());
d276 1
a276 3
      setCurrentScheme (null);
      
      setCurrentImplementation (theImple);
a277 2
      assert (getCurrentScheme () == UNIT_TEST);

@


1.33
log
@Minor revision.
@
text
@d19 1
a19 1
import static com.ibm.witm.Scheme        .newScheme;
d174 8
d279 2
d282 2
@


1.32
log
@Moved getAll (TupleCategory).
@
text
@d70 1
a70 1
      Implementation curImp;
d72 1
a72 1
      curImp = Implementation.getCurrentImplementation ();
d74 1
a74 1
      assert (curImp == null);
d76 1
a76 1
      myImplementation = newImplementation (UNIT_TEST, "Unit-Test");
d251 4
d260 3
a262 3
         myImplementation,
         myImplementation.getScheme ().getName (),
         myImplementation             .getName ());
d269 1
a269 1
         Implementation.getCurrentImplementation ().getName ());
d271 1
a271 1
      Implementation.setCurrentImplementation (myImplementation);
d276 1
a276 1
         Implementation.getCurrentImplementation ().getName ());
d424 1
a424 1
 * An Integer-valued Property of Category A_PRIM. 
a430 6
/*******************************************************************************
 * The Implementation for the unit test.
 *******************************************************************************
 */
   private final Implementation myImplementation;
   
@


1.31
log
@Moved newTuple from TupleCategory to Implementation.
@
text
@d348 1
a348 1
      for (Tuple theA_A: A_A.getAll ())
@


1.30
log
@Type ==> Category
@
text
@d327 1
a327 1
      theA_A_1_2 = A_A.newTuple (firstA_PRIM, secondA_PRIM);
@


1.29
log
@Element     ==> Item
ElementType ==> ItemTYpe
@
text
@d10 1
a10 1
import com.ibm.witm.TupleType;
d15 1
a15 1
import com.ibm.witm.PrimitiveType;
d20 1
a20 1
import static com.ibm.witm.TupleType     .newTupleType;
d87 9
a95 9
      testInputTable     ();
      testScheme         ();
      testPrimitiveType  ();
      testTupleType      ();
      testProperty       ();
      testImplementation ();
      testPrimitive      ();
      testTuple          ();
      testItem           ();
d196 1
a196 1
 * Tests class PrimitiveType.
d199 1
a199 1
   private void testPrimitiveType ()
d212 1
a212 1
 * Tests class TupleType.
d215 1
a215 1
   private void testTupleType ()
d236 3
a238 3
       + "   ItemType:   \"%s\"%n"
       + "   Value Type: %s%n"
       + "   Name:       \"%s\"%n",
d240 3
a242 3
         A_INT_PROP.getItemType  ().getName       (),
         A_INT_PROP.getValueType ().getSimpleName (),
         A_INT_PROP                .getName       ());
d291 3
a293 3
       + "   Implementation: \"%s\"%n"
       + "   PrimitiveType:  \"%s\"%n"
       + "   Name:           \"%s\"%n",
d295 3
a297 3
         firstA_PRIM.getImplementation ().getName (),
         firstA_PRIM.getPrimitiveType  ().getName (),
         firstA_PRIM                     .getName ());
d329 1
a329 1
      assert (theA_A_1_2.getTupleType () == A_A);
d369 2
a370 2
       + "ItemType: \"%s\"%n",
         firstA_PRIM.getItemType ().getName ());
d399 1
a399 1
 * The Items of this PrimitiveType are "A-Primitives".
d402 2
a403 2
   private static final PrimitiveType   A_PRIM =
           UNIT_TEST.newPrimitiveType ("A_PRIM");
d406 1
a406 1
 * An Integer-valued Property of Type A_PRIM. 
d416 2
a417 2
   private static final TupleType   A_A =
                     newTupleType ("A_A", A_PRIM, A_PRIM);
d420 1
a420 1
 * An Integer-valued Property of Type A_PRIM. 
@


1.28
log
@Moved get (PT, Name).
@
text
@d11 1
a11 1
import com.ibm.witm.Element;
d95 1
a95 1
      testElement        ();
d236 3
a238 3
       + "   ElementType: \"%s\"%n"
       + "   Value Type:  %s%n"
       + "   Name:        \"%s\"%n",
d240 3
a242 3
         A_INT_PROP.getElementType ().getName       (),
         A_INT_PROP.getValueType   ().getSimpleName (),
         A_INT_PROP                  .getName       ());
d357 1
a357 1
 * Tests class Element.
d360 1
a360 1
   private void testElement ()
d362 1
a362 1
      Element firstA_PRIM;
d369 2
a370 2
       + "ElementType: \"%s\"%n",
         firstA_PRIM.getElementType ().getName ());
d399 1
a399 1
 * The Elements of this PrimitiveType are "A-Primitives".
@


1.27
log
@Moved getAll.
@
text
@d299 1
a299 1
      foundPrim = A_PRIM.get ("First");
d324 2
a325 2
      firstA_PRIM  = A_PRIM.get ("First");
      secondA_PRIM = A_PRIM.get ("Second");
d365 1
a365 1
      firstA_PRIM = A_PRIM.get ("First");
@


1.26
log
@Moved some factory methods.
@
text
@d300 1
a300 1
      
d307 1
a307 1
      for (Primitive thePrim: A_PRIM.getAll ())
d312 1
a312 1

@


1.25
log
@Embodiment ==> Implementation
@
text
@d19 3
a21 2
import static com.ibm.witm.Scheme   .newScheme;
import static com.ibm.witm.TupleType.newTupleType;
d76 1
a76 1
      myImplementation = UNIT_TEST.newImplementation ("Unit-Test");
d260 1
a260 1
      UNIT_TEST.newImplementation ("Implementation #2");
d284 1
a284 1
      firstA_PRIM = A_PRIM.newPrimitive ("First");
d286 1
a286 1
                    A_PRIM.newPrimitive ("Second");
@


1.24
log
@theTupleType.getAll
@
text
@d8 1
a8 1
import com.ibm.witm.Embodiment;
d69 1
a69 1
      Embodiment curEmb;
d71 1
a71 1
      curEmb = Embodiment.getCurrentEmbodiment ();
d73 1
a73 1
      assert (curEmb == null);
d75 1
a75 1
      myEmbodiment = UNIT_TEST.newEmbodiment ("Unit-Test");
d86 9
a94 9
      testInputTable    ();
      testScheme        ();
      testPrimitiveType ();
      testTupleType     ();
      testProperty      ();
      testEmbodiment    ();
      testPrimitive     ();
      testTuple         ();
      testElement       ();
d245 1
a245 1
 * Tests class Embodiment.
d248 1
a248 1
   private void testEmbodiment ()
d255 3
a257 3
         myEmbodiment,
         myEmbodiment.getScheme ().getName (),
         myEmbodiment             .getName ());
d259 1
a259 1
      UNIT_TEST.newEmbodiment ("Embodiment #2");
d263 2
a264 2
       + "Current Embodiment: \"%s\"%n",
         Embodiment.getCurrentEmbodiment ().getName ());
d266 1
a266 1
      Embodiment.setCurrentEmbodiment (myEmbodiment);
d270 2
a271 2
       + "Current Embodiment: \"%s\"%n",
         Embodiment.getCurrentEmbodiment ().getName ());
d290 3
a292 3
       + "   Embodiment:    \"%s\"%n"
       + "   PrimitiveType: \"%s\"%n"
       + "   Name:          \"%s\"%n",
d294 3
a296 3
         firstA_PRIM.getEmbodiment    ().getName (),
         firstA_PRIM.getPrimitiveType ().getName (),
         firstA_PRIM                    .getName ());
d427 1
a427 1
 * The Embodiment for the unit test.
d430 1
a430 1
   private final Embodiment myEmbodiment;
@


1.23
log
@theTuple.toString.
@
text
@d342 11
@


1.22
log
@Coordinate List
@
text
@d332 2
a333 1
       + "testTuple%n");
@


1.21
log
@Removed some Embodiment arg methods.
@
text
@d321 2
a322 1
      
d333 8
@


1.20
log
@thePrimitiveType.get
@
text
@d285 1
a285 1
                    A_PRIM.newPrimitive ("Second", myEmbodiment);
a309 9
      
      System.out.printf (
         "%n"
       + "A_PRIM Primitives:%n");
      
      for (Primitive thePrim: A_PRIM.getAll (myEmbodiment))
         {
         System.out.printf ("   %s%n", thePrim);
         }
d322 1
a322 1
      firstA_PRIM  = A_PRIM.get ("First", myEmbodiment);
@


1.19
log
@getAll
@
text
@d298 1
a298 1
      foundPrim = A_PRIM.get ("First", myEmbodiment);
d332 1
a332 1
      secondA_PRIM = A_PRIM.get ("Second", myEmbodiment);
d352 1
a352 1
      firstA_PRIM = A_PRIM.get ("First", myEmbodiment);
@


1.18
log
@newPrimitive
@
text
@d304 10
a313 1
       + "Primitives:%n");
@


1.17
log
@Test of newPrimitive.
@
text
@d283 1
a283 1
      firstA_PRIM = A_PRIM.newPrimitive               ("First");
@


1.16
log
@Current Embodiment
@
text
@d285 1
a285 1
                    A_PRIM.newPrimitive (myEmbodiment, "Second");
d298 1
a298 1
      foundPrim = A_PRIM.get (myEmbodiment, "First");
d322 2
a323 2
      firstA_PRIM  = A_PRIM.get (myEmbodiment, "First");
      secondA_PRIM = A_PRIM.get (myEmbodiment, "Second");
d343 1
a343 1
      firstA_PRIM = A_PRIM.get (myEmbodiment, "First");
@


1.15
log
@currentEmbodiment
@
text
@d283 1
a283 1
      firstA_PRIM = A_PRIM.newPrimitive (myEmbodiment, "First");
d391 1
a393 1
                        @@SuppressWarnings("unused")
@


1.14
log
@Tests of newTuple.
@
text
@a66 9
   private UnitTester (Embodiment theEmbodiment)
      {
      myEmbodiment = theEmbodiment;
      }

/*******************************************************************************
 * Constructor.
 *******************************************************************************
 */
d69 6
d258 14
@


1.13
log
@Category ==> Type
@
text
@d9 1
d96 1
d302 22
@


1.12
log
@Fulfillment ==> Embodiment
@
text
@d9 1
a9 1
import com.ibm.witm.TupleCategory;
d14 1
a14 1
import com.ibm.witm.PrimitiveCategory;
d18 2
a19 2
import static com.ibm.witm.Scheme       .newScheme;
import static com.ibm.witm.TupleCategory.newTupleCategory;
d88 8
a95 8
      testInputTable        ();
      testScheme            ();
      testPrimitiveCategory ();
      testTupleCategory     ();
      testProperty          ();
      testEmbodiment        ();
      testPrimitive         ();
      testElement           ();
d196 1
a196 1
 * Tests class PrimitiveCategory.
d199 1
a199 1
   private void testPrimitiveCategory ()
d212 1
a212 1
 * Tests class TupleCategory.
d215 1
a215 1
   private void testTupleCategory ()
d236 3
a238 3
       + "   ElementCategory: \"%s\"%n"
       + "   Value Type:      %s%n"
       + "   Name:            \"%s\"%n",
d240 3
a242 3
         A_INT_PROP.getElementCategory ().getName       (),
         A_INT_PROP.getValueType       ().getSimpleName (),
         A_INT_PROP                      .getName       ());
d277 3
a279 3
       + "   Embodiment:        \"%s\"%n"
       + "   PrimitiveCategory: \"%s\"%n"
       + "   Name:              \"%s\"%n",
d281 3
a283 3
         firstA_PRIM.getEmbodiment        ().getName (),
         firstA_PRIM.getPrimitiveCategory ().getName (),
         firstA_PRIM                        .getName ());
d312 2
a313 2
       + "ElementCategory: \"%s\"%n",
         firstA_PRIM.getElementCategory ().getName ());
d342 1
a342 1
 * The Elements of this PrimitiveCategory are "A-Primitives".
d345 2
a346 2
   private static final PrimitiveCategory   A_PRIM =
           UNIT_TEST.newPrimitiveCategory ("A_PRIM");
d349 1
a349 1
 * An Integer-valued Property of Category A_PRIM. 
d359 2
a360 2
   private static final TupleCategory   A_A =
                     newTupleCategory ("A_A", A_PRIM, A_PRIM);
d363 1
a363 1
 * An Integer-valued Property of Category A_PRIM. 
@


1.11
log
@Primitives
@
text
@d8 1
a8 1
import com.ibm.witm.Fulfillment;
d66 1
a66 1
   private UnitTester (Fulfillment theFulfillment)
d68 1
a68 1
      myFulfillment = theFulfillment;
d77 1
a77 1
      myFulfillment = UNIT_TEST.newFulfillment ("Unit-Test");
d93 1
a93 1
      testFulfillment       ();
d246 1
a246 1
 * Tests class Fulfillment.
d249 1
a249 1
   private void testFulfillment ()
d256 3
a258 3
         myFulfillment,
         myFulfillment.getScheme ().getName (),
         myFulfillment             .getName ());
d270 1
a270 1
      firstA_PRIM = A_PRIM.newPrimitive (myFulfillment, "First");
d272 1
a272 1
                    A_PRIM.newPrimitive (myFulfillment, "Second");
d277 1
a277 1
       + "   Fulfillment:       \"%s\"%n"
d281 1
a281 1
         firstA_PRIM.getFulfillment       ().getName (),
d285 1
a285 1
      foundPrim = A_PRIM.get (myFulfillment, "First");
d293 1
a293 1
      for (Primitive thePrim: A_PRIM.getAll (myFulfillment))
d308 1
a308 1
      firstA_PRIM = A_PRIM.get (myFulfillment, "First");
d371 1
a371 1
 * The Fulfillment for the unit test.
d374 1
a374 1
   private final Fulfillment myFulfillment;
@


1.10
log
@Compound ==> Tuple
@
text
@d270 1
a270 1
      firstA_PRIM = myFulfillment.newPrimitive (A_PRIM, "First");
d272 1
a272 1
                    myFulfillment.newPrimitive (A_PRIM, "Second");
d285 1
a285 1
      foundPrim = myFulfillment.get (A_PRIM, "First");
d293 1
a293 1
      for (Primitive thePrim: myFulfillment.get (A_PRIM))
d308 1
a308 1
      firstA_PRIM = myFulfillment.get (A_PRIM, "First");
@


1.9
log
@CompoundCategory
@
text
@d9 1
a9 1
import com.ibm.witm.CompoundCategory;
d18 2
a19 2
import static com.ibm.witm.Scheme          .newScheme;
import static com.ibm.witm.CompoundCategory.newCompoundCategory;
d91 1
a91 1
      testCompoundCategory  ();
d212 1
a212 1
 * Tests class CompoundCategory.
d215 1
a215 1
   private void testCompoundCategory ()
d359 2
a360 2
   private static final CompoundCategory   A_A =
                     newCompoundCategory ("A_A", A_PRIM, A_PRIM);
@


1.8
log
@theElem.getPrimitive ()
@
text
@d91 1
d212 16
d363 8
@


1.7
log
@AppProblem ==> Fulfillment
@
text
@d313 2
@


1.6
log
@Added tests for newCompoundCategory.
@
text
@d8 1
a8 1
import com.ibm.witm.AppProblem;
d66 1
a66 1
   private UnitTester (AppProblem theAppProblem)
d68 1
a68 1
      myAppProblem = theAppProblem;
d77 1
a77 1
      myAppProblem = UNIT_TEST.newAppProblem ("Unit-Test");
d92 1
a92 1
      testAppProblem        ();
d229 1
a229 1
 * Tests class AppProblem.
d232 1
a232 1
   private void testAppProblem ()
d239 3
a241 3
         myAppProblem,
         myAppProblem.getScheme ().getName (),
         myAppProblem             .getName ());
d253 1
a253 1
      firstA_PRIM = myAppProblem.newPrimitive (A_PRIM, "First");
d255 1
a255 1
                    myAppProblem.newPrimitive (A_PRIM, "Second");
d260 1
a260 1
       + "   AppProblem:        \"%s\"%n"
d264 1
a264 1
         firstA_PRIM.getAppProblem        ().getName (),
d268 1
a268 1
      foundPrim = myAppProblem.get (A_PRIM, "First");
d276 1
a276 1
      for (Primitive thePrim: myAppProblem.get (A_PRIM))
d291 1
a291 1
      firstA_PRIM = myAppProblem.get (A_PRIM, "First");
d344 1
a344 1
 * The AppProblem for the unit test.
d347 1
a347 1
   private final AppProblem myAppProblem;
@


1.5
log
@theElem.get (...)
@
text
@d9 1
d18 3
d319 2
a320 2
   private static final Scheme             UNIT_TEST =
                        Scheme.newScheme ("UNIT_TEST");
d330 1
a332 1
                                                  @@SuppressWarnings("unused")
d337 7
@


1.4
log
@Error testing for theElem.set.
@
text
@d285 1
d294 4
d299 10
@


1.3
log
@Class Property
@
text
@d90 1
a246 1
      Element   theElem;
a263 6
      theElem = firstA_PRIM;
      
      System.out.printf (
         "   ElementCategory:   \"%s\"%n",
         theElem.getElementCategory ().getName ());
      
d279 18
@


1.2
log
@Property Accessors
@
text
@d176 11
@


1.1
log
@Initial revision
@
text
@d14 1
d87 1
d195 18
d288 7
@


1.1.1.1
log
@Renaming WIT-ML to WIT-M.

@
text
@@

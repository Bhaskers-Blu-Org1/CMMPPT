head	1.99;
access;
symbols;
locks; strict;
comment	@# @;


1.99
date	2011.10.10.21.13.54;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2011.10.10.20.22.20;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2011.10.10.20.07.55;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2011.10.07.23.02.03;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2011.10.05.22.51.43;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2011.10.04.22.35.53;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.30.21.52.19;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2011.09.30.20.42.26;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.30.00.05.15;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.22.22.19.34;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.21.20.32.57;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2011.09.21.16.04.22;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.20.19.32.38;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.09.14.19.02.15;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.14.16.26.50;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.09.14.15.31.39;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2011.09.13.22.53.06;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2011.09.09.21.17.47;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2011.09.08.22.43.44;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.07.22.26.24;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.09.07.21.43.41;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.22.20.05.28;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.22.16.15.35;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.21.21.44.51;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2011.07.20.22.13.47;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.20.20.18.30;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2011.07.20.19.16.51;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2011.07.20.16.35.28;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.19.21.37.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.19.21.13.21;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.15.17.42.36;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.15.15.51.25;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.14.23.53.12;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.14.22.55.07;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.14.20.24.07;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.13.20.49.35;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.12.22.40.04;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.12.21.08.17;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.07.19.29.41;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.07.19.05.07;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.05.21.15.09;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.05.20.01.48;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.01.22.12.56;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.01.21.37.33;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.01.21.17.44;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.01.20.44.52;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.01.20.17.38;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.01.18.51.36;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.01.16.24.33;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.01.15.56.27;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.01.14.15.35;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.01.14.01.41;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.30.23.43.54;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.29.14.22.31;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.24.20.29.51;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.23.23.15.45;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.23.22.53.15;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.22.22.09.48;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.22.19.47.33;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.22.14.08.11;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.20.21.44.08;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.20.17.48.41;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.17.22.09.10;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.17.18.23.10;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.16.23.36.16;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.15.22.25.23;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.10.21.13.51;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.10.19.37.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.09.23.27.57;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.09.22.12.02;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.09.18.19.26;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.09.18.09.26;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.08.23.36.41;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.08.22.40.13;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.08.20.30.00;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.08.20.14.02;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.07.20.56.04;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.07.18.37.11;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.06.20.33.38;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.06.16.39.12;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.03.22.48.07;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.03.22.23.48;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.31.19.26.25;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.27.17.54.26;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.26.23.40.17;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.26.22.32.21;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.26.21.00.53;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.26.18.49.12;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.26.00.17.19;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.25.19.16.33;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.24.18.46.21;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.24.17.56.52;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.24.00.11.55;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.22.02.10.54;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.20.21.30.19;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.20.19.26.55;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.20.18.18.57;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.18.19.55.01;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.18.18.23.55;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.99
log
@getCellAsPrimitive (...)
@
text
@
////////////////////////////////////////////////////////////////////////////////
// WIT-M/Test Source File ErrorTester.java.
////////////////////////////////////////////////////////////////////////////////

package com.ibm.witm.test;

import com.ibm.witj.Demand;
import com.ibm.witj.Part;
import com.ibm.witm.DimensionID;
import com.ibm.witm.InputTable;
import com.ibm.witm.DoubleByPeriod;
import com.ibm.witm.ModelInstance;
import com.ibm.witm.Period;
import com.ibm.witm.Primitive;
import com.ibm.witm.PrimitiveCategory;
import com.ibm.witm.Property;
import com.ibm.witm.ModelScheme;
import com.ibm.witm.Tuple;
import com.ibm.witm.TupleCategory;
import com.ibm.witm.VariableByPeriod;

import static com.ibm.witm.ModelScheme.*;
import static com.ibm.witm.ModelInstance.*;
import static com.ibm.witm.WitJHandler.*;

import static com.ibm.witj.Part.Category.*;

/*******************************************************************************
 * Responsible for performing a series of tests on WIT-M each of which
 * generates an error condition that causes an Exception to be thrown.
 *******************************************************************************
 */
final class ErrorTester
{
////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Fields
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * The index of the error test cased to be performed.
 *******************************************************************************
 */
   private final int curCaseIdx;
   
/*******************************************************************************
 * The main ModelScheme to be used for an error test.
 *******************************************************************************
 */
   private final ModelScheme ERROR_TEST;

////////////////////////////////////////////////////////////////////////////////
// Private Constructor
////////////////////////////////////////////////////////////////////////////////

   private ErrorTester (int theCaseIdx)
      {
      curCaseIdx = theCaseIdx;
      
      ERROR_TEST = newModelScheme ("ERROR_TEST");
      }

////////////////////////////////////////////////////////////////////////////////
// Private Non-Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Prints a heading for the error test case indexed by theCaseIdx.
 * 
 * @@param text Text describing the error test case.
 *******************************************************************************
 */
   private void printHeading (String text)
      {
      System.out.printf (
         "\n"
       + "----------------------------------------"
       + "----------------------------------------\n"
       + "WIT-M Error Test Case %d:\n"
       + "\n"
       + "%s\n"
       + "----------------------------------------"
       + "----------------------------------------\n"
       + "\n",
         curCaseIdx,
         text);
      }

/*******************************************************************************
 * Creates myModelInstance.
 *******************************************************************************
 */
   private void makeModelInstance ()
      {
      setCurrentModelScheme (ERROR_TEST);
      
      freezeCurrentModelScheme ();
      
      ERROR_TEST.newModelInstance ("Test Case #" + curCaseIdx);
      }

/*******************************************************************************
 * Performs error test case 1.
 *******************************************************************************
 */
   private void testCase1 ()
      {
      printHeading ("Passing a null argument to newModelScheme.");

      newModelScheme (null);
      }

/*******************************************************************************
 * Performs error test case 2.
 *******************************************************************************
 */
   private void testCase2 ()
      {
      printHeading ("This test case is no longer used.");

      throw new UnsupportedOperationException ();
      }

/*******************************************************************************
 * Performs error test case 3.
 *******************************************************************************
 */
   private void testCase3 ()
      {
      printHeading ("Creating a PrimitiveCategory with a duplicate name.");

      newPrimitiveCategory ("A");
      newPrimitiveCategory ("A");
      }

/*******************************************************************************
 * Performs error test case 4.
 *******************************************************************************
 */
   private void testCase4 ()
      {
      PrimitiveCategory A;

      printHeading (
         "Call to PrimitiveCategory.newPrimitive (...) with a ModelScheme\n"
       + "mismatch.");
      
      newModelScheme ("SCHEME_B");
      
      A = newPrimitiveCategory ("A");
      
      makeModelInstance ();
      
      A.newPrimitive ("1");
      }
   
/*******************************************************************************
 * Performs error test case 5.
 *******************************************************************************
 */
   private void testCase5 ()
      {
      printHeading (
         "Call to newPrimitiveCategory when there is no current ModelScheme.");
      
      setCurrentModelScheme (null);
      
      newPrimitiveCategory ("A");
      }

/*******************************************************************************
 * Performs error test case 6.
 *******************************************************************************
 */
   private void testCase6 ()
      {
      printHeading (
         "Call to ModelScheme.newModelInstance (...) on an unfrozen\n"
       + "ModelScheme.");
      
      ERROR_TEST.newModelInstance ("Test Case #6");
      }

/*******************************************************************************
 * Performs error test case 7.
 *******************************************************************************
 */
   private void testCase7 ()
      {
      PrimitiveCategory A;

      printHeading (
         "Call to PrimitiveCategory.newPrimitive (...) with a name collision.");
      
      A = newPrimitiveCategory ("A");
      
      makeModelInstance ();
      
      A.newPrimitive ("A1");
      A.newPrimitive ("A1");
      }

/*******************************************************************************
 * Performs error test case 8.
 *******************************************************************************
 */
   private void testCase8 ()
      {
      PrimitiveCategory A;

      printHeading (
         "Call to a modifying method on the result of ItemCategory.getAll ().");
      
      A = newPrimitiveCategory ("A");
      
      makeModelInstance ();
      
      A.getAll ().clear ();
      }

/*******************************************************************************
 * Performs error test case 9.
 *******************************************************************************
 */
   private void testCase9 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a duplicate name.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A", A, 1);
      }

/*******************************************************************************
 * Performs error test case 10.
 *******************************************************************************
 */
   private void testCase10 ()
      {
      PrimitiveCategory A; 
      PrimitiveCategory B; 
      Property <String> C;
      Primitive         theB;
      
      printHeading ("Call to theItem.set (...) with an ItemCategory mismatch.");
      
      A = newPrimitiveCategory ("A");
      B = newPrimitiveCategory ("B");
      
      C = A.newProperty ("C", String.class);
      
      makeModelInstance ();
      
      theB = B.newPrimitive ("1");
      
      theB.set (C, "Text");
      }

/*******************************************************************************
 * Performs error test case 11.
 *******************************************************************************
 */
   private void testCase11 ()
      {
      PrimitiveCategory A; 
      PrimitiveCategory B; 
      Property <String> C;
      Primitive         theB;
      
      printHeading ("Call to theItem.get (...) with an ItemCategory mismatch.");
      
      A = newPrimitiveCategory ("A");
      B = newPrimitiveCategory ("B");
      
      C = A.newProperty ("C", String.class);
      
      makeModelInstance ();
      
      theB = B.newPrimitive ("1");
      
      theB.get (C);
      }

/*******************************************************************************
 * Performs error test case 12.
 *******************************************************************************
 */
   private void testCase12 ()
      {
      printHeading (
         "Call to newTupleCategory with a null ItemCategory reference.");
      
      newTupleCategory ("A", null, null);
      }

/*******************************************************************************
 * Performs error test case 13.
 *******************************************************************************
 */
   private void testCase13 ()
      {
      printHeading ("Call to newTupleCategory with no Categories.");
      
      newTupleCategory ("A");
      }

/*******************************************************************************
 * Performs error test case 14.
 *******************************************************************************
 */
   private void testCase14 ()
      {
      PrimitiveCategory A;
      PrimitiveCategory B;

      printHeading ("Call to newTupleCategory with a ModelScheme mismatch.");
      
      A = newPrimitiveCategory ("A");
      
      newModelScheme ("C");
      
      B = newPrimitiveCategory ("B");
      
      newTupleCategory ("D", A, B);
      }

/*******************************************************************************
 * Performs error test case 15.
 *******************************************************************************
 */
   private void testCase15 ()
      {
      PrimitiveCategory A;
      
      printHeading ("Call to newTupleCategory with a duplicate name.");
      
      A = newPrimitiveCategory ("A");
      
      newTupleCategory ("A", A, A);
      }

/*******************************************************************************
 * Performs error test case 16.
 *******************************************************************************
 */
   private void testCase16 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA;
      Tuple             theB;
      
      printHeading (
         "Call to TupleCategory.get (Item...) with a coordinate of the\n"
       + "wrong ItemCategory.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      
      theB = B.newTuple (theA);
      
      B.get (theB);
      }

/*******************************************************************************
 * Performs error test case 17.
 *******************************************************************************
 */
   private void testCase17 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA2;
      Primitive         theA1;
      
      printHeading (
         "Call to newTuple with a coordinate from a non-current\n"
       + "ModelInstance.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);
      
      makeModelInstance ();
      
      theA2 = A.newPrimitive ("2");
      
      ERROR_TEST.newModelInstance ("theInst_17_B");
      
      theA1 = A.newPrimitive ("1");
      
      B.newTuple (theA1, theA2);
      }

/*******************************************************************************
 * Performs error test case 18.
 *******************************************************************************
 */
   private void testCase18 ()
      {
      PrimitiveCategory A;
      
      printHeading (
         "Call to ModelInstance.newPrimitive (...) when the current\n"
       + "ModelInstance is null.");
      
      A = newPrimitiveCategory ("A");
      
      A.newPrimitive ("1");
      }

/*******************************************************************************
 * Performs error test case 19.
 *******************************************************************************
 */
   private void testCase19 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA;
      
      printHeading (
         "Call to getSliceDense, where the number of coordinates in the\n"
       + "pattern does not match the number of dimensions in the\n"
       + "TupleCategory.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");

      B.getSliceDense (theA);
      }

/*******************************************************************************
 * Performs error test case 20.
 *******************************************************************************
 */
   private void testCase20 ()
      {
      printHeading ("Call to setCurrentModelScheme with a frozen ModelScheme.");
      
      freezeCurrentModelScheme ();

      setCurrentModelScheme (ERROR_TEST);
      }

/*******************************************************************************
 * Performs error test case 21.
 *******************************************************************************
 */
   private void testCase21 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA;
      Tuple             theB;
      PrimitiveCategory C;
      
      printHeading (
         "Call to Tuple.get (ItemCategory <I>) with an ItemCategory and Tuple\n"
       + "whose ModelSchemes do not match.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theB = B.newTuple     (theA);
      
      newModelScheme ("SCHEME21");
      
      C = newPrimitiveCategory ("C");
      
      theB.get (C);
      }

/*******************************************************************************
 * Performs error test case 22.
 *******************************************************************************
 */
   private void testCase22 ()
      {
      PrimitiveCategory A;
      PrimitiveCategory B;
      TupleCategory     C;
      Primitive         theA;
      Tuple             theC;
      
      printHeading (
         "Call to Tuple.get (ItemCategory <I>) with an ItemCategory that is\n"
       + "not a dimension of the TupleCategory of the Tuple.");
      
      A = newPrimitiveCategory ("A");
      B = newPrimitiveCategory ("B");
      C = newTupleCategory     ("C", A, A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theC = C.newTuple     (theA, theA);
      
      theC.get (B);
      }

/*******************************************************************************
 * Performs error test case 23.
 *******************************************************************************
 */
   private void testCase23 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA;
      Tuple             theB;
      
      printHeading (
         "Call to Tuple.get (ItemCategory <I>) with an ItemCategory that\n"
       + "occurs more than once as a dimension of the TupleCategory of the\n"
       + "Tuple.\n");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theB = B.newTuple     (theA, theA);
      
      theB.get (A);
      }

/*******************************************************************************
 * Performs error test case 24.
 *******************************************************************************
 */
   private void testCase24 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a negative\n"
       + "dimension index.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_N1", A, -1);
      }

/*******************************************************************************
 * Performs error test case 25.
 *******************************************************************************
 */
   private void testCase25 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a dimension index\n"
       + "that's too high.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_2", A, 2);
      }

/*******************************************************************************
 * Performs error test case 26.
 *******************************************************************************
 */
   private void testCase26 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with an ItemCategory\n"
       + "that does not match the ItemCategory of the indexed dimension.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_2", B, 1);
      }

/*******************************************************************************
 * Performs error test case 27.
 *******************************************************************************
 */
   private void testCase27 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      Primitive         theA;
      
      printHeading (
         "Call to TupleCategory.newTuple (Item...) with a coordinate\n"
       + "list that duplicates that of an existing Tuple.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      
      B.newTuple (theA, theA);
      B.newTuple (theA, theA);
      }

/*******************************************************************************
 * Performs error test case 28.
 *******************************************************************************
 */
   private void testCase28 ()
      {
      PrimitiveCategory theGlobalCat;
      
      printHeading (
         "Call to PrimitiveCategory.newPrimitive (...) on the global\n"
       + "ItemCategory.");
      
      theGlobalCat = getGlobalCategory ();
      
      makeModelInstance ();

      theGlobalCat.newPrimitive ("My Global");
      }
   
/*******************************************************************************
 * Performs error test case 29.
 *******************************************************************************
 */
   private void testCase29 ()
      {
      PrimitiveCategory A; 
      Property <String> B;
      
      printHeading (
         "Call to Property.setGlobal (...) on a non-global Property.");
      
      A = newPrimitiveCategory ("A");
      
      B = A.newProperty ("B", String.class);
      
      makeModelInstance ();
      
      B.setGlobal ("Text");
      }

/*******************************************************************************
 * Performs error test case 30.
 *******************************************************************************
 */
   private void testCase30 ()
      {
      PrimitiveCategory A;
      Property <Part>   A_MAT;
      PrimitiveCategory B;
      Property <Demand> B_DEM;
      Primitive         theA;
      Primitive         theB;
      
      printHeading (
         "Call to Item.newDemand (...) with a Part that does not belong to\n"
       + "the current Problem.");
      
      A     = newPrimitiveCategory ("A");
      A_MAT = A.newProperty        ("A_MAT", Part.class);
      
      B     = newPrimitiveCategory ("B");
      B_DEM = B.newProperty        ("B_DEM", Demand.class);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theB = B.newPrimitive ("2");
      
      newWitJHandler ();
      
      theA.newPart (A_MAT, CAPACITY);
      
      newWitJHandler ();
      
      theB.newDemand (B_DEM, theA.get (A_MAT));
      }

/*******************************************************************************
 * Performs error test case 31.
 *******************************************************************************
 */
   private void testCase31 ()
      {
      PrimitiveCategory A;
      Property <Part>   A_CAP;
      Primitive         theA;
      
      printHeading (
         "Call to Item.newPart (...) when the current WitJHandler is null.");
      
      A     = newPrimitiveCategory ("A");
      
      A_CAP = A.newProperty ("A_CAP", Part.class);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      
      theA.newPart (A_CAP, CAPACITY);
      }

/*******************************************************************************
 * Performs error test case 32.
 *******************************************************************************
 */
   private void testCase32 ()
      {
      PrimitiveCategory A;
      
      printHeading (
         "Call to ItemCategory.newProperty on an ItemCategory whose\n"
       + "ModelScheme is frozen.");
      
      A = newPrimitiveCategory ("A");
      
      makeModelInstance ();
      
      A.newProperty ("INT_PROP", Integer.class);
      }

/*******************************************************************************
 * Performs error test case 33.
 *******************************************************************************
 */
   private void testCase33 ()
      {
      PrimitiveCategory       A;
      TupleCategory           B;
      DimensionID <Primitive> A_1;
      TupleCategory           C;
      Primitive               theA;
      Tuple                   theB;
      Tuple                   theC;
      
      printHeading (
         "Call to Tuple.get (theDimID), where theDimID does not apply to the\n"
       + "TupleCategory of the Tuple.");
      
      A   = newPrimitiveCategory ("A");
      B   = newTupleCategory     ("B",   A, A);
      A_1 = B.newDimensionID     ("A_1", A, 1);
      C   = newTupleCategory     ("C",   B, A);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theB = B.newTuple     (theA, theA);
      theC = C.newTuple     (theB, theA);
      
      theC.get (A_1);
      }

/*******************************************************************************
 * Performs error test case 34.
 *******************************************************************************
 */
   private void testCase34 ()
      {
      printHeading (
         "Call to Period.newPeriod (...) with a name collision.");
      
      makeModelInstance ();
      
      newPeriod ("January");
      newPeriod ("February");
      newPeriod ("January");
      }

/*******************************************************************************
 * Performs error test case 35.
 *******************************************************************************
 */
   private void testCase35 ()
      {
      printHeading (
         "Call to Period.newPeriod (...) when the set of Periods for the\n"
       + "current ModelInstance is frozen.");

      makeModelInstance ();
      
      newPeriod ("January");
      
      freezePeriodSet ();
      
      newPeriod ("February");
      }

/*******************************************************************************
 * Performs error test case 36.
 *******************************************************************************
 */
   private void testCase36 ()
      {
      PrimitiveCategory         A; 
      Property <DoubleByPeriod> B;
      Primitive                 theA;
      
      printHeading (
         "Call to theItem.set (...) with a Property of value type\n"
       + "DoubleByPeriod.");
      
      A = newPrimitiveCategory ("A");
      
      B = A.newProperty ("B", DoubleByPeriod.class);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      
      theA.set (B, null);
      }

/*******************************************************************************
 * Performs error test case 37.
 *******************************************************************************
 */
   private void testCase37 ()
      {
      PrimitiveCategory A; 
      
      printHeading (
         "Call to theItemCat.newProperty (...) with VariableByPeriod as the\n"
       + "value type.");
      
      A = newPrimitiveCategory ("A");
      
      A.newProperty ("B", VariableByPeriod.class);
      }

/*******************************************************************************
 * Performs error test case 38.
 *******************************************************************************
 */
   private void testCase38 ()
      {
      PrimitiveCategory         A; 
      Property <DoubleByPeriod> B;
      Period                    thePer;
      Primitive                 theA;
      
      printHeading (
         "Call to theVariableByPeriod.set (...), with a ModelInstance\n"
       + "mismatch.");
      
      A = newPrimitiveCategory ("A");
      
      B = A.newProperty ("B", DoubleByPeriod.class);
      
      makeModelInstance ();
      
      thePer = newPeriod ("Today");
      
      ERROR_TEST.newModelInstance ("theInst_38_2");
      
      freezePeriodSet ();
      
      theA = A.newPrimitive ("A1");
      
      theA.get (B).set (thePer, 17.2);
      }

/*******************************************************************************
 * Performs error test case 39.
 *******************************************************************************
 */
   private void testCase39 ()
      {
      PrimitiveCategory         A; 
      Property <DoubleByPeriod> B;
      Primitive                 theA;
      double[]                  theDblArr;
      
      printHeading (
         "Call to DoubleByPeriod.setArray (theDblArr) with an array length\n"
       + "mismatch.");
      
      A = newPrimitiveCategory ("A");
      
      B = A.newProperty ("B", DoubleByPeriod.class);
      
      makeModelInstance ();
      
      newPeriod ("Today");
      
      freezePeriodSet ();
      
      theA = A.newPrimitive ("A1");
      
      theDblArr = new double[2];
      
      theA.get (B).setArray (theDblArr);
      }

/*******************************************************************************
 * Performs error test case 40.
 *******************************************************************************
 */
   private void testCase40 ()
      {
      printHeading (
         "Call to InputTable.newInputTable (...) with a file name for which\n"
       + "there is no such file.");

      InputTable.newInputTable ("No-Such.csv");
      }

/*******************************************************************************
 * Performs error test case 41.
 *******************************************************************************
 */
   private void testCase41 ()
      {
      printHeading ("I/O exception while reading the file for an InputTable.");
      
      InputTable.setTestMode (1);

      InputTable.newInputTable ("POK/period.csv");
      }

/*******************************************************************************
 * Performs error test case 42.
 *******************************************************************************
 */
   private void testCase42 ()
      {
      printHeading ("I/O exception while closing the file for an InputTable.");
      
      InputTable.setTestMode (2);

      InputTable.newInputTable ("POK/skillgroup.csv");
      }

/*******************************************************************************
 * Performs error test case 43.
 *******************************************************************************
 */
   private void testCase43 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputRow.requireNCells (...) on an InputRow with the\n"
       + "wrong # of cells.");
      
      theTable = InputTable.newInputTable ("POK/period.csv");
      
      theTable.getInputRow (7).requireNCells (17);
      }

/*******************************************************************************
 * Performs error test case 44.
 *******************************************************************************
 */
   private void testCase44 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputRow.getCell (...) with a column index that's out of\n"
       + "bounds.");
      
      theTable = InputTable.newInputTable ("POK/period.csv");
      
      theTable.getInputRow (3).getCell (5);
      }

/*******************************************************************************
 * Performs error test case 45.
 *******************************************************************************
 */
   private void testCase45 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputRow.getCellAsDouble (...) on a cell that cannot be\n"
       + "converted to a double.");
      
      theTable = InputTable.newInputTable ("POK/period.csv");
      
      theTable.getInputRow (3).getCellAsDouble (1, "Max Workers");
      }

/*******************************************************************************
 * Performs error test case 46.
 *******************************************************************************
 */
   private void testCase46 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputRow.getCellAsInt (...) on a cell that cannot be\n"
       + "converted to an int.");
      
      theTable = InputTable.newInputTable ("POK/skillgroup.csv");
      
      theTable.getInputRow (8).getCellAsInt (2, "Shift");
      }

/*******************************************************************************
 * Performs error test case 47.
 *******************************************************************************
 */
   private void testCase47 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputRow.getCellAsPeriod (...) on a cell that is not the\n"
       + "name of a Period.");
      
      makeModelInstance ();
      
      theTable = InputTable.newInputTable ("POK/area-shift-period.csv");
      
      theTable.getInputRow (7).getCellAsPeriod (3);
      }

/*******************************************************************************
 * Performs error test case 48.
 *******************************************************************************
 */
   private void testCase48 ()
      {
      InputTable theTable;
      
      printHeading (
         "Call to theInputTable.getInputRow (...) with a row index that's out\n"
       + "of bounds.");
      
      theTable = InputTable.newInputTable ("POK/area-shift-period.csv");
      
      theTable.getInputRow (200);
      }

/*******************************************************************************
 * Performs error test case 49.
 *******************************************************************************
 */
   private void testCase49 ()
      {
      PrimitiveCategory AREA;
      InputTable        theTable;
      
      printHeading (
         "Call to theInputRow.getCellAsPrimitive (...) on a cell that does\n"
       + "not match the name of a Primitive of the specified\n"
       + "PrimitiveCategory.");
      
      AREA = newPrimitiveCategory ("AREA");
      
      makeModelInstance ();
      
      theTable = InputTable.newInputTable ("POK/area-shift-period.csv");
      
      theTable.getInputRow (7).getCellAsPrimitive (1, AREA);
      }

/*******************************************************************************
 * Performs the error test indexed by curCaseIdx.
 *******************************************************************************
 */
   private void innerTestCurCase ()
      {
      switch (curCaseIdx)
         {
         case 1:
            testCase1 ();
            break;

         case 2:
            testCase2 ();
            break;

         case 3:
            testCase3 ();
            break;

         case 4:
            testCase4 ();
            break;

         case 5:
            testCase5 ();
            break;

         case 6:
            testCase6 ();
            break;

         case 7:
            testCase7 ();
            break;

         case 8:
            testCase8 ();
            break;

         case 9:
            testCase9 ();
            break;

         case 10:
            testCase10 ();
            break;

         case 11:
            testCase11 ();
            break;

         case 12:
            testCase12 ();
            break;

         case 13:
            testCase13 ();
            break;

         case 14:
            testCase14 ();
            break;

         case 15:
            testCase15 ();
            break;

         case 16:
            testCase16 ();
            break;

         case 17:
            testCase17 ();
            break;

         case 18:
            testCase18 ();
            break;

         case 19:
            testCase19 ();
            break;

         case 20:
            testCase20 ();
            break;

         case 21:
            testCase21 ();
            break;

         case 22:
            testCase22 ();
            break;

         case 23:
            testCase23 ();
            break;

         case 24:
            testCase24 ();
            break;

         case 25:
            testCase25 ();
            break;

         case 26:
            testCase26 ();
            break;

         case 27:
            testCase27 ();
            break;

         case 28:
            testCase28 ();
            break;

         case 29:
            testCase29 ();
            break;

         case 30:
            testCase30 ();
            break;

         case 31:
            testCase31 ();
            break;

         case 32:
            testCase32 ();
            break;

         case 33:
            testCase33 ();
            break;

         case 34:
            testCase34 ();
            break;

         case 35:
            testCase35 ();
            break;

         case 36:
            testCase36 ();
            break;

         case 37:
            testCase37 ();
            break;

         case 38:
            testCase38 ();
            break;

         case 39:
            testCase39 ();
            break;

         case 40:
            testCase40 ();
            break;

         case 41:
            testCase41 ();
            break;

         case 42:
            testCase42 ();
            break;

         case 43:
            testCase43 ();
            break;

         case 44:
            testCase44 ();
            break;

         case 45:
            testCase45 ();
            break;

         case 46:
            testCase46 ();
            break;

         case 47:
            testCase47 ();
            break;

         case 48:
            testCase48 ();
            break;

         case 49:
            testCase49 ();
            break;

         default:
            throw new AssertionError ();
         }
      }

/*******************************************************************************
 * Performs the error test indexed by curCaseIdx.
 *******************************************************************************
 */
   private void testCurCase ()
      {
      try
         {
         innerTestCurCase ();
 
         throw
            new AssertionError (
               "\n\n"
             + "   Test Case " + curCaseIdx + " completed without throwing "
             +    "an exception.\n");
         }

      catch (Exception theExc)
         {
         System.out.flush ();
         
         theExc.printStackTrace ();
                  
         System.out.flush ();
         }
      
      ModelInstance.setCurrentModelInstance (null);
      
      setCurrentWitJHandler (null);

      System.out.printf (
         "\n"
       + "Error Test Case %d now concludes.\n",
         curCaseIdx);
      }

////////////////////////////////////////////////////////////////////////////////
// Package-Internal Static Methods
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * Performs an error test.
 *******************************************************************************
 */
   static void performTest ()
      {
      int         theCaseIdx;
      ErrorTester theErrTester;
      
      for (theCaseIdx = 1; theCaseIdx <= 49; theCaseIdx ++)
         {
         theErrTester = new ErrorTester (theCaseIdx);
      
         theErrTester.testCurCase ();
         }

      System.out.println (
         "\n"
       + "Normal termination of error test.");
      }

////////////////////////////////////////////////////////////////////////////////
}
@


1.98
log
@getCellAsPeriod
@
text
@d1082 1
a1082 1
      theTable.getInputRow (7).getCellAsPrimitive (AREA, 1);
@


1.97
log
@getCellAsPrimitive (...).
@
text
@d1042 1
a1042 1
      theTable.getInputRow (7).getCellAsPeriod (3, "Month (First Day)");
@


1.96
log
@TemporalVariable ==> VariableByPeriod, etc.
@
text
@d1063 23
d1285 4
d1343 1
a1343 1
      for (theCaseIdx = 1; theCaseIdx <= 48; theCaseIdx ++)
@


1.95
log
@getInputRow
@
text
@d12 1
a12 1
import com.ibm.witm.TemporalDouble;
d21 1
a21 1
import com.ibm.witm.TemporalVariable;
d820 1
a820 1
      Property <TemporalDouble> B;
d825 1
a825 1
       + "TemporalDouble.");
d829 1
a829 1
      B = A.newProperty ("B", TemporalDouble.class);
d847 1
a847 1
         "Call to theItemCat.newProperty (...) with TemporalVariable as the\n"
d852 1
a852 1
      A.newProperty ("B", TemporalVariable.class);
d862 1
a862 1
      Property <TemporalDouble> B;
d867 1
a867 1
         "Call to theTemporalVariable.set (...), with a ModelInstance\n"
d872 1
a872 1
      B = A.newProperty ("B", TemporalDouble.class);
d894 1
a894 1
      Property <TemporalDouble> B;
d899 1
a899 1
         "Call to TemporalDouble.setArray (theDblArr) with an array length\n"
d904 1
a904 1
      B = A.newProperty ("B", TemporalDouble.class);
@


1.94
log
@getCellAsPeriod (...)
@
text
@d972 1
a972 1
      theTable.getInputRows ().get (6).requireNCells (17);
d989 1
a989 1
      theTable.getInputRows ().get (2).getCell (5);
d1006 1
a1006 1
      theTable.getInputRows ().get (2).getCellAsDouble (1, "Max Workers");
d1023 1
a1023 1
      theTable.getInputRows ().get (7).getCellAsInt (2, "Shift");
d1042 18
a1059 1
      theTable.getInputRows ().get (6).getCellAsPeriod (3, "Month (First Day)");
d1258 4
d1316 1
a1316 1
      for (theCaseIdx = 1; theCaseIdx <= 47; theCaseIdx ++)
@


1.93
log
@getCellAsInt
@
text
@a105 1
   
d1027 19
d1237 4
d1295 1
a1295 1
      for (theCaseIdx = 1; theCaseIdx <= 46; theCaseIdx ++)
@


1.92
log
@FileFormatException
@
text
@d1011 17
d1215 4
d1273 1
a1273 1
      for (theCaseIdx = 1; theCaseIdx <= 45; theCaseIdx ++)
@


1.91
log
@InputTable
@
text
@a7 2
import java.io.IOException;

a924 2
      throws
         IOException
a937 2
      throws
         IOException
d940 2
d943 1
a943 1
      InputTable.newInputTableWithIOExc ("POK/period.csv");
d951 13
a963 2
      throws
         IOException
d977 1
a977 1
 * Performs error test case 43.
d980 1
a980 3
   private void testCase43 ()
      throws
         IOException
d994 1
a994 1
 * Performs error test case 44.
d997 1
a997 3
   private void testCase44 ()
      throws
         IOException
a1014 2
      throws
         IOException
d1194 4
d1252 1
a1252 1
      for (theCaseIdx = 1; theCaseIdx <= 44; theCaseIdx ++)
@


1.90
log
@InputRow
@
text
@d945 13
d970 1
a970 1
 * Performs error test case 42.
d973 1
a973 1
   private void testCase42 ()
d989 1
a989 1
 * Performs error test case 43.
d992 1
a992 1
   private void testCase43 ()
d1189 4
d1247 1
a1247 1
      for (theCaseIdx = 1; theCaseIdx <= 43; theCaseIdx ++)
@


1.89
log
@getCellAsDouble
@
text
@a120 2
      throws
         IOException
d122 1
a122 3
      printHeading (
         "Call to InputTable.newInputTable (...) with a file name for which\n"
       + "there is no such file.");
d124 1
a124 1
      InputTable.newInputTable ("No-Such.csv");
d930 34
d976 1
a976 1
 * Performs error test case 41.
d979 1
a979 1
   private void testCase41 ()
d991 1
a991 1
      theTable.getInputRows ().get (2).getCellAsDouble (1);
d1168 8
d1230 1
a1230 1
      for (theCaseIdx = 1; theCaseIdx <= 41; theCaseIdx ++)
@


1.88
log
@InputTables
@
text
@d81 1
a81 1
       + "WIT-MF Error Test Case %d:\n"
d946 19
d1134 4
d1192 1
a1192 1
      for (theCaseIdx = 1; theCaseIdx <= 40; theCaseIdx ++)
@


1.87
log
@InputTables
@
text
@d927 19
d1111 4
d1169 1
a1169 1
      for (theCaseIdx = 1; theCaseIdx <= 39; theCaseIdx ++)
@


1.86
log
@PeriodValue  ==> TemporalVariable
PeriodDouble ==> TemporalDouble
@
text
@d8 2
d13 1
a15 1
import com.ibm.witm.InputTable;
d122 1
a122 1
         Exception
a123 2
      InputTable theTable;

d125 2
a126 1
         "Call to theInputRow.getCell (...) with an invalid heading.");
d128 1
a128 3
      theTable = InputTable.newInputTable ("area.csv");
         
      theTable.getRows ().get (0).getCell ("nonsense");
d932 1
a932 1
         Exception
@


1.85
log
@Name change.
@
text
@d11 1
a11 1
import com.ibm.witm.PeriodDouble;
d21 1
a21 1
import com.ibm.witm.PeriodValue;
d827 3
a829 3
      PrimitiveCategory       A; 
      Property <PeriodDouble> B;
      Primitive               theA;
d833 1
a833 1
       + "PeriodDouble.");
d837 1
a837 1
      B = A.newProperty ("B", PeriodDouble.class);
d855 1
a855 1
         "Call to theItemCat.newProperty (...) with PeriodValue as the\n"
d860 1
a860 1
      A.newProperty ("B", PeriodValue.class);
d869 4
a872 4
      PrimitiveCategory       A; 
      Property <PeriodDouble> B;
      Period                  thePer;
      Primitive               theA;
d875 2
a876 1
         "Call to thePeriodValue.set (...), with a ModelInstance mismatch.");
d880 1
a880 1
      B = A.newProperty ("B", PeriodDouble.class);
d901 4
a904 4
      PrimitiveCategory       A; 
      Property <PeriodDouble> B;
      Primitive               theA;
      double[]                theDblArr;
d907 1
a907 1
         "Call to PeriodDouble.setArray (theDblArr) with an array length\n"
d912 1
a912 1
      B = A.newProperty ("B", PeriodDouble.class);
@


1.84
log
@ProblemManager ==> WitJHandler
@
text
@d906 2
a907 1
         "Call to PeriodDouble.set (theDblArr) with an array length mismatch.");
d923 1
a923 1
      theA.get (B).set (theDblArr);
@


1.83
log
@PeriodDouble
@
text
@d25 1
a25 1
import static com.ibm.witm.ProblemManager.*;
d702 1
a702 1
      newProblemManager ();
d706 1
a706 1
      newProblemManager ();
d722 1
a722 1
         "Call to Item.newPart (...) when the current ProblemManager is null.");
d1124 1
a1124 1
      setCurrentProblemManager (null);
@


1.82
log
@Class renaming:
   ValueByPeriod  ==> PeriodValue
   DoubleByPeriod ==> PeriodDouble
@
text
@d895 31
d1087 4
d1145 1
a1145 1
      for (theCaseIdx = 1; theCaseIdx <= 38; theCaseIdx ++)
@


1.81
log
@ValueByPeriod
@
text
@d11 1
a11 1
import com.ibm.witm.DoubleByPeriod;
d21 1
a21 1
import com.ibm.witm.ValueByPeriod;
d827 3
a829 3
      PrimitiveCategory         A; 
      Property <DoubleByPeriod> B;
      Primitive                 theA;
d833 1
a833 1
       + "DoubleByPeriod.\n");
d837 1
a837 1
      B = A.newProperty ("B", DoubleByPeriod.class);
d855 1
a855 1
         "Call to theItemCat.newProperty (...) with ValueByPeriod as the\n"
d860 1
a860 1
      A.newProperty ("B", ValueByPeriod.class);
d869 4
a872 4
      PrimitiveCategory         A; 
      Property <DoubleByPeriod> B;
      Period                    thePer;
      Primitive                 theA;
d875 1
a875 1
         "Call to ValueByPeriod (...), with a ModelInstance mismatch.");
d879 1
a879 1
      B = A.newProperty ("B", DoubleByPeriod.class);
@


1.80
log
@ValueByPeriod.
@
text
@d14 1
d856 1
a856 1
       + "value type.\n");
d864 31
d1052 4
d1110 1
a1110 1
      for (theCaseIdx = 1; theCaseIdx <= 37; theCaseIdx ++)
@


1.79
log
@ValueByPeriod
@
text
@d20 1
d846 17
d1016 4
d1074 1
a1074 1
      for (theCaseIdx = 1; theCaseIdx <= 36; theCaseIdx ++)
@


1.78
log
@Period set freeze
@
text
@d11 1
d820 25
d994 4
d1052 1
a1052 1
      for (theCaseIdx = 1; theCaseIdx <= 35; theCaseIdx ++)
@


1.77
log
@Class Period
@
text
@d800 19
d964 4
d1022 1
a1022 1
      for (theCaseIdx = 1; theCaseIdx <= 34; theCaseIdx ++)
@


1.76
log
@Removed first implementation of the period concept.
@
text
@d21 1
d784 16
d941 4
d999 1
a999 1
      for (theCaseIdx = 1; theCaseIdx <= 33; theCaseIdx ++)
@


1.75
log
@newDemand
@
text
@d677 3
d681 1
d684 2
a685 1
         "Call to Primitive.getPeriodIndex () on a non-PERIOD Primitive.");
d687 5
a691 1
      A = newPrimitiveCategory ("A");
d696 3
d700 5
a704 1
      theA.getPeriodIndex ();
a782 37
 * Performs error test case 34.
 *******************************************************************************
 */
   private void testCase34 ()
      {
      PrimitiveCategory A;
      Property <Part>   A_MAT;
      PrimitiveCategory B;
      Property <Demand> B_DEM;
      Primitive         theA;
      Primitive         theB;
      
      printHeading (
         "Call to Item.newDemand (...) with a Part that does not belong to\n"
       + "the current Problem.");
      
      A     = newPrimitiveCategory ("A");
      A_MAT = A.newProperty        ("A_MAT", Part.class);
      
      B     = newPrimitiveCategory ("B");
      B_DEM = B.newProperty        ("B_DEM", Demand.class);
      
      makeModelInstance ();
      
      theA = A.newPrimitive ("1");
      theB = B.newPrimitive ("2");
      
      newProblemManager ();
      
      theA.newPart (A_MAT, CAPACITY);
      
      newProblemManager ();
      
      theB.newDemand (B_DEM, theA.get (A_MAT));
      }
   
/*******************************************************************************
a923 4
         case 34:
            testCase34 ();
            break;

d956 2
d978 1
a978 1
      for (theCaseIdx = 1; theCaseIdx <= 34; theCaseIdx ++)
@


1.74
log
@ProblemMgr ==> ProblemManager
@
text
@d8 1
d21 2
d767 37
d945 4
d1001 1
a1001 1
      for (theCaseIdx = 1; theCaseIdx <= 33; theCaseIdx ++)
@


1.73
log
@Revised String conventions
@
text
@d699 1
a699 1
         "Call to Item.newPart (...) when the current ProblemMgr is null.");
@


1.72
log
@Minor revisions.
@
text
@d155 1
a155 1
      A.newPrimitive ("#1");
d260 1
a260 1
      theB = B.newPrimitive ("#1");
d285 1
a285 1
      theB = B.newPrimitive ("#1");
d368 1
a368 1
      theA = A.newPrimitive ("#1");
d395 1
a395 1
      theA2 = A.newPrimitive ("#2");
d399 1
a399 1
      theA1 = A.newPrimitive ("#1");
d418 1
a418 1
      A.newPrimitive ("#1");
d441 1
a441 1
      theA = A.newPrimitive ("#1");
d480 1
a480 1
      theA = A.newPrimitive ("#1");
d512 1
a512 1
      theA = A.newPrimitive ("#1");
d539 1
a539 1
      theA = A.newPrimitive ("#1");
d621 1
a621 1
      theA = A.newPrimitive ("#1");
d683 1
a683 1
      theA = A.newPrimitive ("#1");
d707 1
a707 1
      theA = A.newPrimitive ("#1");
d756 1
a756 1
      theA = A.newPrimitive ("#1");
@


1.71
log
@Scheme ==> ModelScheme
@
text
@d703 1
a703 1
      A_CAP = A.newProperty ("A-CAP", Part.class);
@


1.70
log
@Embodiment ==> ModelInstance
@
text
@d15 1
a15 1
import com.ibm.witm.Scheme;
d19 1
a19 1
import static com.ibm.witm.Scheme.*;
d40 1
a40 1
 * The main Scheme to be used for an error test.
d43 1
a43 1
   private final Scheme ERROR_TEST;
d53 1
a53 1
      ERROR_TEST = newScheme ("ERROR_TEST");
d88 1
a88 1
      setCurrentScheme (ERROR_TEST);
d90 1
a90 1
      freezeCurrentScheme ();
d102 1
a102 1
      printHeading ("Passing a null argument to newScheme.");
d104 1
a104 1
      newScheme (null);
d146 1
a146 1
         "Call to PrimitiveCategory.newPrimitive (...) with a Scheme\n"
d149 1
a149 1
      newScheme ("SCHEME_B");
d165 1
a165 1
         "Call to newPrimitiveCategory when there is no current Scheme.");
d167 1
a167 1
      setCurrentScheme (null);
d179 2
a180 1
         "Call to Scheme.newModelInstance (...) on an unfrozen Scheme.");
d322 1
a322 1
      printHeading ("Call to newTupleCategory with a Scheme mismatch.");
d326 1
a326 1
      newScheme ("C");
d452 1
a452 1
      printHeading ("Call to setCurrentScheme with a frozen Scheme.");
d454 1
a454 1
      freezeCurrentScheme ();
d456 1
a456 1
      setCurrentScheme (ERROR_TEST);
d473 1
a473 1
       + "whose Schemes do not match.");
d483 1
a483 1
      newScheme ("SCHEME21");
d721 2
a722 2
         "Call to ItemCategory.newProperty on an ItemCategory whose Scheme is\n"
       + "frozen.");
@


1.69
log
@Category ==> ItemCategory
@
text
@d10 1
a10 1
import com.ibm.witm.Embodiment;
d83 1
a83 1
 * Creates myEmbodiment.
d86 1
a86 1
   private void makeEmbodiment ()
d92 1
a92 1
      ERROR_TEST.newEmbodiment ("Test Case #" + curCaseIdx);
d153 1
a153 1
      makeEmbodiment ();
d179 1
a179 1
         "Call to Scheme.newEmbodiment (...) on an unfrozen Scheme.");
d181 1
a181 1
      ERROR_TEST.newEmbodiment ("Test Case #6");
d197 1
a197 1
      makeEmbodiment ();
d216 1
a216 1
      makeEmbodiment ();
d257 1
a257 1
      makeEmbodiment ();
d282 1
a282 1
      makeEmbodiment ();
d365 1
a365 1
      makeEmbodiment ();
d386 2
a387 1
         "Call to newTuple with a coordinate from a non-current Embodiment.");
d392 1
a392 1
      makeEmbodiment ();
d396 1
a396 1
      ERROR_TEST.newEmbodiment ("theEmb_17_B");
d412 2
a413 2
         "Call to Embodiment.newPrimitive (...) when the current Embodiment\n"
       + "is null.");
d438 1
a438 1
      makeEmbodiment ();
d477 1
a477 1
      makeEmbodiment ();
d509 1
a509 1
      makeEmbodiment ();
d536 1
a536 1
      makeEmbodiment ();
d618 1
a618 1
      makeEmbodiment ();
d640 1
a640 1
      makeEmbodiment ();
d661 1
a661 1
      makeEmbodiment ();
d680 1
a680 1
      makeEmbodiment ();
d704 1
a704 1
      makeEmbodiment ();
d725 1
a725 1
      makeEmbodiment ();
d753 1
a753 1
      makeEmbodiment ();
d935 1
a935 1
      Embodiment.setCurrentEmbodiment (null);
@


1.68
log
@Checking for duplicate schematic names.
@
text
@d212 1
a212 1
         "Call to a modifying method on the result of Category.getAll ().");
d250 1
a250 1
      printHeading ("Call to theItem.set (...) with a Category mismatch.");
d275 1
a275 1
      printHeading ("Call to theItem.get (...) with a Category mismatch.");
d296 1
a296 1
         "Call to newTupleCategory with a null Category reference.");
d360 1
a360 1
       + "wrong Category.");
d470 1
a470 1
         "Call to Tuple.get (Category <I>) with a Category and Tuple\n"
d501 2
a502 2
         "Call to Tuple.get (Category <I>) with a Category that is not a\n"
       + "dimension of the TupleCategory of the Tuple.");
d528 3
a530 2
         "Call to Tuple.get (Category <I>) with a Category that occurs\n"
       + "more than once as a dimension of the TupleCategory of the Tuple.\n");
d591 2
a592 2
         "Call to TupleCategory.newDimensionID (...) with a Category that\n"
       + "does not match the Category of the indexed dimension.");
d635 1
a635 1
       + "Category.");
d719 2
a720 1
         "Call to Category.newProperty on a Category whose Scheme is frozen.");
@


1.67
log
@Removed Tuple.get (theCat, theIdx).
@
text
@d228 4
a231 3
      PrimitiveCategory B;

      printHeading ("Creating a Property with a duplicate name.");
d234 3
a236 4
      B = newPrimitiveCategory ("B");
      
      A.newProperty ("C", Boolean.class);
      B.newProperty ("C", String .class);
@


1.66
log
@Tests for Tuple.get (theDimID).
@
text
@a549 2
      Primitive         theA;
      Tuple             theB;
d552 2
a553 2
         "Call to Tuple.get (Category <I>, int) with a negative\n"
       + "coordinate index.\n");
d557 2
a558 7
      
      makeEmbodiment ();
      
      theA = A.newPrimitive ("#1");
      theB = B.newTuple     (theA, theA);
      
      theB.get (A, -1);
a568 2
      Primitive         theA;
      Tuple             theB;
d571 1
a571 1
         "Call to Tuple.get (Category <I>, int) with a coordinate index\n"
d576 2
a577 7
      
      makeEmbodiment ();
      
      theA = A.newPrimitive ("#1");
      theB = B.newTuple     (theA, theA);
      
      theB.get (A, 2);
a587 2
      Primitive         theA;
      Tuple             theB;
d590 2
a591 2
         "Call to Tuple.get (Category <I>, int) with a Category/dimension\n"
       + "mis-match.");
d595 2
a596 7
      
      makeEmbodiment ();
      
      theA = A.newPrimitive ("#1");
      theB = B.newTuple     (theA, theA);
      
      theB.get (B, 1);
a732 57
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a negative\n"
       + "dimension index.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_N1", A, -1);
      }

/*******************************************************************************
 * Performs error test case 34.
 *******************************************************************************
 */
   private void testCase34 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a dimension index\n"
       + "that's too high.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_2", A, 2);
      }

/*******************************************************************************
 * Performs error test case 35.
 *******************************************************************************
 */
   private void testCase35 ()
      {
      PrimitiveCategory A;
      TupleCategory     B;
      
      printHeading (
         "Call to TupleCategory.newDimensionID (...) with a Category that\n"
       + "does not match the Category of the indexed dimension.");
      
      A = newPrimitiveCategory ("A");
      B = newTupleCategory     ("B", A, A);

      B.newDimensionID ("A_2", B, 1);
      }

/*******************************************************************************
 * Performs error test case 36.
 *******************************************************************************
 */
   private void testCase36 ()
      {
a900 12
         case 34:
            testCase34 ();
            break;

         case 35:
            testCase35 ();
            break;

         case 36:
            testCase36 ();
            break;

d953 1
a953 1
      for (theCaseIdx = 1; theCaseIdx <= 36; theCaseIdx ++)
@


1.65
log
@Error tests for newDimensionID.
@
text
@d9 1
d806 32
d987 4
d1043 1
a1043 1
      for (theCaseIdx = 1; theCaseIdx <= 35; theCaseIdx ++)
@


1.64
log
@Bug Fix: Prohibit newProperty on a frozen Scheme.
@
text
@d234 2
a235 2
      A.newProperty (Boolean.class, "C");
      B.newProperty (String .class, "C");
d254 1
a254 1
      C = A.newProperty (String.class, "C");
d279 1
a279 1
      C = A.newProperty (String.class, "C");
d677 1
a677 1
      B = A.newProperty (String.class, "B");
d720 1
a720 1
      A_CAP = A.newProperty (Part.class, "A-CAP");
d744 58
a801 1
      A.newProperty (Integer.class, "INT_PROP");
d942 12
d1006 1
a1006 1
      for (theCaseIdx = 1; theCaseIdx <= 32; theCaseIdx ++)
@


1.63
log
@Compound ==> Tuple
@
text
@d720 1
a720 1
      A_CAP = A.newProperty (Part.class, "A+CAP");
d730 18
d881 4
d900 5
a904 1
         throw new AssertionError ();
d937 1
a937 1
      for (theCaseIdx = 1; theCaseIdx <= 31; theCaseIdx ++)
@


1.62
log
@Error test for newPart.
@
text
@d15 2
a16 2
import com.ibm.witm.Compound;
import com.ibm.witm.CompoundCategory;
d295 1
a295 1
         "Call to newCompoundCategory with a null Category reference.");
d297 1
a297 1
      newCompoundCategory ("A", null, null);
d306 1
a306 1
      printHeading ("Call to newCompoundCategory with no Categories.");
d308 1
a308 1
      newCompoundCategory ("A");
d320 1
a320 1
      printHeading ("Call to newCompoundCategory with a Scheme mismatch.");
d328 1
a328 1
      newCompoundCategory ("D", A, B);
d339 1
a339 1
      printHeading ("Call to newCompoundCategory with a duplicate name.");
d343 1
a343 1
      newCompoundCategory ("A", A, A);
d353 1
a353 1
      CompoundCategory  B;
d355 1
a355 1
      Compound          theB;
d358 1
a358 1
         "Call to CompoundCategory.get (Item...) with a coordinate of the\n"
d362 1
a362 1
      B = newCompoundCategory  ("B", A);
d368 1
a368 1
      theB = B.newCompound (theA);
d380 1
a380 1
      CompoundCategory  B;
d385 1
a385 2
         "Call to newCompound with a coordinate from a non-current\n"
       + "Embodiment.");
d388 1
a388 1
      B = newCompoundCategory  ("B", A, A);
d398 1
a398 1
      B.newCompound (theA1, theA2);
d425 1
a425 1
      CompoundCategory  B;
d431 1
a431 1
       + "CompoundCategory.");
d434 1
a434 1
      B = newCompoundCategory  ("B", A, A);
d463 1
a463 1
      CompoundCategory  B;
d465 1
a465 1
      Compound          theB;
d469 1
a469 1
         "Call to Compound.get (Category <I>) with a Category and Compound\n"
d473 1
a473 1
      B = newCompoundCategory  ("B", A);
d478 1
a478 1
      theB = B.newCompound (theA);
d495 1
a495 1
      CompoundCategory  C;
d497 1
a497 1
      Compound          theC;
d500 2
a501 2
         "Call to Compound.get (Category <I>) with a Category that is not a\n"
       + "dimension of the CompoundCategory of the Compound.");
d505 1
a505 1
      C = newCompoundCategory  ("C", A, A);
d510 1
a510 1
      theC = C.newCompound  (theA, theA);
d522 1
a522 1
      CompoundCategory  B;
d524 1
a524 1
      Compound          theB;
d527 2
a528 3
         "Call to Compound.get (Category <I>) with a Category that occurs\n"
       + "more than once as a dimension of the CompoundCategory of the\n"
       + "Compound.");
d531 1
a531 1
      B = newCompoundCategory  ("B", A, A);
d536 1
a536 1
      theB = B.newCompound  (theA, theA);
d548 1
a548 1
      CompoundCategory  B;
d550 1
a550 1
      Compound          theB;
d553 1
a553 1
         "Call to Compound.get (Category <I>, int) with a negative\n"
d557 1
a557 1
      B = newCompoundCategory  ("B", A, A);
d562 1
a562 1
      theB = B.newCompound  (theA, theA);
d574 1
a574 1
      CompoundCategory  B;
d576 1
a576 1
      Compound          theB;
d579 1
a579 1
         "Call to Compound.get (Category <I>, int) with a coordinate index\n"
d583 1
a583 1
      B = newCompoundCategory  ("B", A, A);
d588 1
a588 1
      theB = B.newCompound  (theA, theA);
d600 1
a600 1
      CompoundCategory  B;
d602 1
a602 1
      Compound          theB;
d605 1
a605 1
         "Call to Compound.get (Category <I>, int) with a Category/dimension\n"
d609 1
a609 1
      B = newCompoundCategory  ("B", A, A);
d614 1
a614 1
      theB = B.newCompound  (theA, theA);
d626 1
a626 1
      CompoundCategory  B;
d630 2
a631 2
         "Call to CompoundCategory.newCompound (Item...) with a coordinate\n"
       + "list that duplicates that of an existing Compound.");
d634 1
a634 1
      B = newCompoundCategory  ("B", A, A);
d640 2
a641 2
      B.newCompound (theA, theA);
      B.newCompound (theA, theA);
@


1.61
log
@PERIOD Primitives
@
text
@d8 1
d19 1
d708 24
d861 4
d913 1
a913 1
      for (theCaseIdx = 1; theCaseIdx <= 30; theCaseIdx ++)
@


1.60
log
@Period Primitives.
@
text
@d693 2
a694 1
      printHeading ("Call to Primitive.getIndex () on a non-PERIOD Primitive.");
d702 1
a702 1
      theA.getIndex ();
@


1.59
log
@Implementation ==> Embodiment
@
text
@d176 1
a176 1
         "Call to Scheme.newEmbodiment (...) with an unfrozen Scheme.");
d673 1
a673 1
         "Call to Property.setGlobal (...) with a non-global Property.");
d685 20
d830 4
d882 1
a882 1
      for (theCaseIdx = 1; theCaseIdx <= 29; theCaseIdx ++)
@


1.58
log
@getSliceSparse
@
text
@d8 1
a8 1
import com.ibm.witm.Implementation;
d80 1
a80 1
 * Creates myImplementation.
d83 1
a83 1
   private void makeImplementation ()
d89 1
a89 1
      ERROR_TEST.newImplementation ("Test Case #" + curCaseIdx);
d150 1
a150 1
      makeImplementation ();
d176 1
a176 1
         "Call to Scheme.newImplementation (...) with an unfrozen Scheme.");
d178 1
a178 1
      ERROR_TEST.newImplementation ("Test Case #6");
d194 1
a194 1
      makeImplementation ();
d213 1
a213 1
      makeImplementation ();
d254 1
a254 1
      makeImplementation ();
d279 1
a279 1
      makeImplementation ();
d362 1
a362 1
      makeImplementation ();
d384 1
a384 1
       + "Implementation.");
d389 1
a389 1
      makeImplementation ();
d393 1
a393 1
      ERROR_TEST.newImplementation ("theImple_17_B");
d409 2
a410 2
         "Call to Implementation.newPrimitive (...) when the current\n"
       + "Implementation is null.");
d435 1
a435 1
      makeImplementation ();
d474 1
a474 1
      makeImplementation ();
d506 1
a506 1
      makeImplementation ();
d533 1
a533 1
      makeImplementation ();
d559 1
a559 1
      makeImplementation ();
d585 1
a585 1
      makeImplementation ();
d611 1
a611 1
      makeImplementation ();
d636 1
a636 1
      makeImplementation ();
d658 1
a658 1
      makeImplementation ();
d679 1
a679 1
      makeImplementation ();
d837 1
a837 1
      Implementation.setCurrentImplementation (null);
@


1.57
log
@setGlobal Implementation ==> Property
@
text
@d428 3
a430 2
         "Call to getSlice, where the number of coordinates in the pattern\n"
       + "does not match the number of dimensions in the CompoundCategory.");
d439 1
a439 1
      B.getSlice (theA);
@


1.56
log
@getSlice Implementation ==> CompoundCategory
@
text
@d17 1
a17 2
import static com.ibm.witm.Scheme        .*;
import static com.ibm.witm.Implementation.*;
d672 1
a672 1
         "Call to Implementation.setGlobal (...) with a non-global Property.");
d680 1
a680 1
      setGlobal (B, "Text");
@


1.55
log
@get Implementation ==> CompoundCategory
@
text
@d439 1
a439 1
      getSlice (B, theA);
@


1.54
log
@Moved getAll from Implementation to Category.
@
text
@d357 1
a357 1
         "Call to get (CompoundCategory, Item...) with a coordinate of the\n"
d369 1
a369 1
      get (B, theB);
@


1.53
log
@Moved newCompound from Implementation to CompoundCategory.
@
text
@d210 1
a210 2
         "Call to a modifying method on the result of\n"
       + "Implementation.getAll (Category <I>).");
d216 1
a216 1
      getAll (A).clear ();
@


1.52
log
@Moved newPrimitive from Implementation to PrimitiveCategory.
@
text
@d368 1
a368 1
      theB = newCompound (B, theA);
d399 1
a399 1
      newCompound (B, theA1, theA2);
d478 1
a478 1
      theB = newCompound  (B, theA);
d510 1
a510 1
      theC = newCompound  (C, theA, theA);
d537 1
a537 1
      theB = newCompound  (B, theA, theA);
d563 1
a563 1
      theB = newCompound  (B, theA, theA);
d589 1
a589 1
      theB = newCompound  (B, theA, theA);
d615 1
a615 1
      theB = newCompound  (B, theA, theA);
d631 1
a631 1
         "Call to newCompound (CompoundCategory, Item...) with a coordinate\n"
d641 2
a642 2
      newCompound (B, theA, theA);
      newCompound (B, theA, theA);
@


1.51
log
@Moved newImplementation from Implementation to Scheme.
@
text
@d144 2
a145 1
         "Call to Implementation.newPrimitive (...) with a Scheme mismatch.");
d153 1
a153 1
      newPrimitive (A, "#1");
d191 1
a191 1
         "Call to Implementation.newPrimitive (...) with a name collision.");
d197 2
a198 2
      newPrimitive (A, "A1");
      newPrimitive (A, "A1");
d258 1
a258 1
      theB = newPrimitive (B, "#1");
d283 1
a283 1
      theB = newPrimitive (B, "#1");
d366 1
a366 1
      theA = newPrimitive (A, "#1");
d393 1
a393 1
      theA2 = newPrimitive (A, "#2");
d397 1
a397 1
      theA1 = newPrimitive (A, "#1");
d416 1
a416 1
      newPrimitive (A, "#1");
d438 1
a438 1
      theA = newPrimitive (A, "#1");
d477 1
a477 1
      theA = newPrimitive (A, "#1");
d509 1
a509 1
      theA = newPrimitive (A, "#1");
d536 1
a536 1
      theA = newPrimitive (A, "#1");
d562 1
a562 1
      theA = newPrimitive (A, "#1");
d588 1
a588 1
      theA = newPrimitive (A, "#1");
d614 1
a614 1
      theA = newPrimitive (A, "#1");
d639 1
a639 1
      theA = newPrimitive (A, "#1");
d654 2
a655 1
         "Call to Implementation.newPrimitive (...) with the global Category.");
d661 1
a661 1
      newPrimitive (theGlobalCat, "My Global");
@


1.50
log
@Moved newProperty to class Category
@
text
@d90 1
a90 1
      newImplementation (ERROR_TEST, "Test Case #" + curCaseIdx);
d176 1
a176 2
         "Call to Implementation.newImplementation (...)\n"
       + "with an unfrozen Scheme.");
d178 1
a178 1
      newImplementation (ERROR_TEST, "Test Case #6");
d394 1
a394 1
      newImplementation (ERROR_TEST, "theImple_17_B");
@


1.49
log
@set/get ==> set/getGlobal
@
text
@d234 2
a235 2
      newProperty (Boolean.class, A, "C");
      newProperty (String .class, B, "C");
d254 1
a254 1
      C = newProperty (String.class, A, "C");
d279 1
a279 1
      C = newProperty (String.class, A, "C");
d677 1
a677 1
      B = newProperty (String.class, A, "B");
@


1.48
log
@Re-arranged source code.
@
text
@d673 1
a673 1
         "Call to Implementation.set (...) with a non-global Property.");
d681 1
a681 1
      set (B, "Text");
@


1.47
log
@//=== ==> /////
@
text
@d28 1
a28 1
// Package-Internal
d32 7
a38 1
 * Performs an error test.
d41 1
a41 16
   static void performTest ()
      {
      int         theCaseIdx;
      ErrorTester theErrTester;
      
      for (theCaseIdx = 1; theCaseIdx <= 29; theCaseIdx ++)
         {
         theErrTester = new ErrorTester (theCaseIdx);
      
         theErrTester.testCurCase ();
         }

      System.out.println (
         "\n"
       + "Normal termination of error test.");
      }
d44 1
a44 1
// Private
a46 4
/*******************************************************************************
 * Private Constructor
 *******************************************************************************
 */
d54 4
d59 3
a61 1
 * Performs the error test indexed by curCaseIdx.
d64 1
a64 1
   private void testCurCase ()
a65 18
      try
         {
         innerTestCurCase ();
 
         throw new AssertionError ();
         }

      catch (Exception theExc)
         {
         System.out.flush ();
         
         theExc.printStackTrace ();
                  
         System.out.flush ();
         }
      
      Implementation.setCurrentImplementation (null);

d68 10
a77 2
       + "Error Test Case %d now concludes.\n",
         curCaseIdx);
d81 1
a81 1
 * Performs the error test indexed by curCaseIdx.
d84 1
a84 3
   private void innerTestCurCase ()
      throws
         Exception
d86 5
a90 121
      switch (curCaseIdx)
         {
         case 1:
            testCase1 ();
            break;

         case 2:
            testCase2 ();
            break;

         case 3:
            testCase3 ();
            break;

         case 4:
            testCase4 ();
            break;

         case 5:
            testCase5 ();
            break;

         case 6:
            testCase6 ();
            break;

         case 7:
            testCase7 ();
            break;

         case 8:
            testCase8 ();
            break;

         case 9:
            testCase9 ();
            break;

         case 10:
            testCase10 ();
            break;

         case 11:
            testCase11 ();
            break;

         case 12:
            testCase12 ();
            break;

         case 13:
            testCase13 ();
            break;

         case 14:
            testCase14 ();
            break;

         case 15:
            testCase15 ();
            break;

         case 16:
            testCase16 ();
            break;

         case 17:
            testCase17 ();
            break;

         case 18:
            testCase18 ();
            break;

         case 19:
            testCase19 ();
            break;

         case 20:
            testCase20 ();
            break;

         case 21:
            testCase21 ();
            break;

         case 22:
            testCase22 ();
            break;

         case 23:
            testCase23 ();
            break;

         case 24:
            testCase24 ();
            break;

         case 25:
            testCase25 ();
            break;

         case 26:
            testCase26 ();
            break;

         case 27:
            testCase27 ();
            break;

         case 28:
            testCase28 ();
            break;

         case 29:
            testCase29 ();
            break;

         default:
            throw new AssertionError ();
         }
d469 2
a470 2
         "Call to Compound.get (Category <I>) with a Category and Compound whose\n"
       + "Schemes do not match.");
d527 3
a529 2
         "Call to Compound.get (Category <I>) with a Category that occurs more\n"
       + "than once as a dimension of the CompoundCategory of the Compound.");
d683 1
a683 1
   
d685 1
a685 3
 * Prints a heading for the error test case indexed by theCaseIdx.
 * 
 * @@param text Text describing the error test case.
d688 3
a690 1
   private void printHeading (String text)
d692 121
a812 12
      System.out.printf (
         "\n"
       + "----------------------------------------"
       + "----------------------------------------\n"
       + "WIT-MF Error Test Case %d:\n"
       + "\n"
       + "%s\n"
       + "----------------------------------------"
       + "----------------------------------------\n"
       + "\n",
         curCaseIdx,
         text);
d816 1
a816 1
 * Creates myImplementation.
d819 1
a819 1
   private void makeImplementation ()
d821 15
a835 1
      setCurrentScheme (ERROR_TEST);
d837 6
a842 3
      freezeCurrentScheme ();
      
      newImplementation (ERROR_TEST, "Test Case #" + curCaseIdx);
d845 4
d850 1
a850 1
 * The index of the error test cased to be performed.
d853 16
a868 7
   private final int curCaseIdx;
   
/*******************************************************************************
 * The main Scheme to be used for an error test.
 *******************************************************************************
 */
   private final Scheme ERROR_TEST;
@


1.46
log
@Global Category / Primitive.
@
text
@d2 1
a2 1
//==============================================================================
d4 1
a4 1
//==============================================================================
d27 1
a27 1
//==============================================================================
d29 1
a29 1
//==============================================================================
d52 1
a52 1
//==============================================================================
d54 1
a54 1
//==============================================================================
d865 1
a865 1
//==============================================================================
@


1.45
log
@0-based indexing of coordinates and dimensions
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 27; theCaseIdx ++)
d215 8
d765 2
a766 2
         "Call to newCompound (CompoundCategory, Item...) with a coordinate list\n"
       + "that duplicates that of an existing Compound.");
d780 39
@


1.44
log
@Error test for getSlice.
@
text
@d680 2
a681 2
         "Call to Compound.get (Category <I>, int) with a coordinate # that's\n"
       + "too low.");
d691 1
a691 1
      theB.get (A, 0);
d706 2
a707 2
         "Call to Compound.get (Category <I>, int) with a coordinate # that's\n"
       + "too high.");
d717 1
a717 1
      theB.get (A, 3);
d743 1
a743 1
      theB.get (B, 2);
@


1.43
log
@getSlice
@
text
@d480 1
a480 1
      CompoundCategory     B;
d482 1
a482 1
      Compound             theB;
d489 1
a489 2
      
      B = newCompoundCategory ("B", A);
d507 1
a507 1
      CompoundCategory     B;
d516 1
a516 1
      B = newCompoundCategory     ("B", A, A);
d553 1
a553 1
      CompoundCategory     B;
d557 2
a558 2
         "Call to newCompound, where the number of coordinates does not match\n"
       + "the number of dimensions in the CompoundCategory.");
d561 1
a561 1
      B = newCompoundCategory     ("B", A, A);
d567 1
a567 1
      newCompound (B, theA);
d590 1
a590 1
      CompoundCategory     B;
d592 1
a592 1
      Compound             theB;
d600 1
a600 1
      B = newCompoundCategory     ("B", A);
d605 1
a605 2
      
      theB = newCompound (B, theA);
d622 1
a622 1
      CompoundCategory     C;
d624 1
a624 1
      Compound             theC;
d632 1
a632 1
      C = newCompoundCategory     ("C", A, A);
d637 1
a637 1
      theC = newCompound     (C, theA, theA);
d649 1
a649 1
      CompoundCategory     B;
d651 1
a651 1
      Compound             theB;
d658 1
a658 1
      B = newCompoundCategory     ("B", A, A);
d663 1
a663 1
      theB = newCompound     (B, theA, theA);
d675 1
a675 1
      CompoundCategory     B;
d677 1
a677 1
      Compound             theB;
d684 1
a684 1
      B = newCompoundCategory     ("B", A, A);
d689 1
a689 1
      theB = newCompound     (B, theA, theA);
d701 1
a701 1
      CompoundCategory     B;
d703 1
a703 1
      Compound             theB;
d710 1
a710 1
      B = newCompoundCategory     ("B", A, A);
d715 1
a715 1
      theB = newCompound     (B, theA, theA);
d727 1
a727 1
      CompoundCategory     B;
d729 1
a729 1
      Compound             theB;
d736 1
a736 1
      B = newCompoundCategory     ("B", A, A);
d741 1
a741 1
      theB = newCompound     (B, theA, theA);
d753 1
a753 1
      CompoundCategory     B;
d761 1
a761 1
      B = newCompoundCategory     ("B", A, A);
@


1.42
log
@Tuple ==> Compound
@
text
@d523 1
a523 1
      newImplementation (ERROR_TEST, "theImpl_17_B");
@


1.41
log
@Error test for get (TupleCategory, ...)
@
text
@d14 2
a15 2
import com.ibm.witm.Tuple;
import com.ibm.witm.TupleCategory;
d422 1
a422 1
         "Call to newTupleCategory with a null Category reference.");
d424 1
a424 1
      newTupleCategory ("A", null, null);
d433 1
a433 1
      printHeading ("Call to newTupleCategory with no Categories.");
d435 1
a435 1
      newTupleCategory ("A");
d447 1
a447 1
      printHeading ("Call to newTupleCategory with a Scheme mismatch.");
d455 1
a455 1
      newTupleCategory ("D", A, B);
d466 1
a466 1
      printHeading ("Call to newTupleCategory with a duplicate name.");
d470 1
a470 1
      newTupleCategory ("A", A, A);
d480 1
a480 1
      TupleCategory     B;
d482 1
a482 1
      Tuple             theB;
d485 1
a485 1
         "Call to get (TupleCategory, Item...) with a coordinate of the\n"
d490 1
a490 1
      B = newTupleCategory ("B", A);
d496 1
a496 1
      theB = newTuple (B, theA);
d508 1
a508 1
      TupleCategory     B;
d513 1
a513 1
         "Call to newTuple with a coordinate from a non-current\n"
d517 1
a517 1
      B = newTupleCategory     ("B", A, A);
d527 1
a527 1
      newTuple (B, theA1, theA2);
d554 1
a554 1
      TupleCategory     B;
d558 2
a559 2
         "Call to newTuple, where the number of coordinates does not match\n"
       + "the number of dimensions in the TupleCategory.");
d562 1
a562 1
      B = newTupleCategory     ("B", A, A);
d568 1
a568 1
      newTuple (B, theA);
d591 1
a591 1
      TupleCategory     B;
d593 1
a593 1
      Tuple             theB;
d597 1
a597 1
         "Call to Tuple.get (Category <I>) with a Category and Tuple whose\n"
d601 1
a601 1
      B = newTupleCategory     ("B", A);
d607 1
a607 1
      theB = newTuple (B, theA);
d624 1
a624 1
      TupleCategory     C;
d626 1
a626 1
      Tuple             theC;
d629 2
a630 2
         "Call to Tuple.get (Category <I>) with a Category that is not a\n"
       + "dimension of the TupleCategory of the Tuple.");
d634 1
a634 1
      C = newTupleCategory     ("C", A, A);
d639 1
a639 1
      theC = newTuple     (C, theA, theA);
d651 1
a651 1
      TupleCategory     B;
d653 1
a653 1
      Tuple             theB;
d656 2
a657 2
         "Call to Tuple.get (Category <I>) with a Category that occurs more\n"
       + "than once as a dimension of the TupleCategory of the Tuple.");
d660 1
a660 1
      B = newTupleCategory     ("B", A, A);
d665 1
a665 1
      theB = newTuple     (B, theA, theA);
d677 1
a677 1
      TupleCategory     B;
d679 1
a679 1
      Tuple             theB;
d682 1
a682 1
         "Call to Tuple.get (Category <I>, int) with a coordinate # that's\n"
d686 1
a686 1
      B = newTupleCategory     ("B", A, A);
d691 1
a691 1
      theB = newTuple     (B, theA, theA);
d703 1
a703 1
      TupleCategory     B;
d705 1
a705 1
      Tuple             theB;
d708 1
a708 1
         "Call to Tuple.get (Category <I>, int) with a coordinate # that's\n"
d712 1
a712 1
      B = newTupleCategory     ("B", A, A);
d717 1
a717 1
      theB = newTuple     (B, theA, theA);
d729 1
a729 1
      TupleCategory     B;
d731 1
a731 1
      Tuple             theB;
d734 1
a734 1
         "Call to Tuple.get (Category <I>, int) with a Category/dimension\n"
d738 1
a738 1
      B = newTupleCategory     ("B", A, A);
d743 1
a743 1
      theB = newTuple     (B, theA, theA);
d755 1
a755 1
      TupleCategory     B;
d759 2
a760 2
         "Call to newTuple (TupleCategory, Item...) with a coordinate list\n"
       + "that duplicates that of an existing Tuple.");
d763 1
a763 1
      B = newTupleCategory     ("B", A, A);
d769 2
a770 2
      newTuple (B, theA, theA);
      newTuple (B, theA, theA);
@


1.40
log
@Internal Tuple look-up.
@
text
@d485 2
a486 1
         "Call to newTuple with a coordinate of the wrong Category.");
d498 1
a498 1
             newTuple (B, theB);
d759 2
a760 2
         "Call to Implementation.newTuple (TupleCategory, Item...) with a\n"
       + "coordinate list that duplicates that of an existing Tuple.");
@


1.39
log
@Tuple.get (Category, int)
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 26; theCaseIdx ++)
d211 4
d682 1
a682 1
       + "too low.\n");
d708 1
a708 1
       + "too high.\n");
d734 1
a734 1
       + "mis-match.\n");
d748 25
@


1.38
log
@1-based indexing of dimensions/coordinates
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 23; theCaseIdx ++)
d199 12
d646 1
a646 1
      TupleCategory     C;
d648 1
a648 1
      Tuple             theC;
d655 79
a733 1
      C = newTupleCategory     ("C", A, A);
d738 1
a738 1
      theC = newTuple     (C, theA, theA);
d740 1
a740 1
      theC.get (A);
@


1.37
log
@myPrimitiveCategories and myTupleCategories ==> myCategories
@
text
@d492 1
a493 1
      Primitive         theA2;
d504 1
a504 1
      theA1 = newPrimitive (A, "#1");
d508 1
a508 1
      theA2 = newPrimitive (A, "#2");
d510 1
a510 1
      newTuple (B, theA2, theA1);
@


1.36
log
@Replaced ItemCategory with Category <?>.
@
text
@d454 1
a454 2
      newTupleCategory ("B", A, A);
      newTupleCategory ("B", A, A);
@


1.35
log
@ItemMgr <I>
@
text
@d360 1
a360 1
      printHeading ("Call to theItem.set (...) with an ItemCategory mismatch.");
d385 1
a385 2
      printHeading (
         "Call to theItem.get (...) with an ItemCategory mismatch.");
d406 1
a406 1
         "Call to newTupleCategory with a null ItemCategory reference.");
d417 1
a417 1
      printHeading ("Call to newTupleCategory with no ItemCategories.");
d470 1
a470 1
         "Call to newTuple with a coordinate of the wrong ItemCategory.");
d581 2
a582 2
         "Call to Tuple.get (ItemCategory) with an ItemCategory and Tuple\n"
       + "whose Schemes do not match.");
d613 1
a613 1
         "Call to Tuple.get (ItemCategory) with an ItemCategory that is not a\n"
d640 2
a641 2
         "Call to Tuple.get (ItemCategory) with an ItemCategory that occurs\n"
       + "more than once as a dimension of the TupleCategory of the Tuple.");
@


1.34
log
@Tuple.get (ItemCategory)
@
text
@d322 1
a322 1
       + "Implementation.getAll (PrimitiveCategory).");
@


1.33
log
@Moved newProperty from ItemCategory to Scheme.
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 20; theCaseIdx ++)
d187 12
d242 2
a243 2
      newPrimitiveCategory ("PRIMCAT3");
      newPrimitiveCategory ("PRIMCAT3");
d252 1
a252 1
      PrimitiveCategory PRIMCAT4;
d257 1
a257 1
      newScheme ("SCHEME4");
d259 1
a259 1
      PRIMCAT4 = newPrimitiveCategory ("PRIMCAT4");
d263 1
a263 1
      newPrimitive (PRIMCAT4, "Prim4");
d277 1
a277 1
      newPrimitiveCategory ("PT_5_1");
d299 1
a299 1
      PrimitiveCategory PRIMCAT7;
d304 1
a304 1
      PRIMCAT7 = newPrimitiveCategory ("PRIMCAT7");
d308 2
a309 2
      newPrimitive (PRIMCAT7, "Prim7");
      newPrimitive (PRIMCAT7, "Prim7");
d318 1
a318 1
      PrimitiveCategory PRIMCAT8;
d324 1
a324 1
      PRIMCAT8 = newPrimitiveCategory ("PRIMCAT8");
d328 1
a328 1
      getAll (PRIMCAT8).clear ();
d337 2
a338 2
      PrimitiveCategory PRIMCAT91;
      PrimitiveCategory PRIMCAT92;
d342 2
a343 2
      PRIMCAT91 = newPrimitiveCategory ("PRIMCAT91");
      PRIMCAT92 = newPrimitiveCategory ("PRIMCAT92");
d345 2
a346 2
      newProperty (Boolean.class, PRIMCAT91, "PROP9");
      newProperty (String .class, PRIMCAT92, "PROP9");
d355 4
a358 4
      PrimitiveCategory PRIMCAT10_1; 
      PrimitiveCategory PRIMCAT10_2; 
      Property <String> PROP10_1;
      Primitive         thePRIMCAT10_2;
d362 2
a363 2
      PRIMCAT10_1    = newPrimitiveCategory ("PRIMCAT10_1");
      PRIMCAT10_2    = newPrimitiveCategory ("PRIMCAT10_2");
d365 1
a365 1
      PROP10_1       = newProperty (String.class, PRIMCAT10_1, "PROP10_1");
d369 1
a369 1
      thePRIMCAT10_2 = newPrimitive (PRIMCAT10_2, "#1");
d371 1
a371 1
      thePRIMCAT10_2.set (PROP10_1, "Test");
d380 4
a383 4
      PrimitiveCategory PRIMCAT11_1; 
      PrimitiveCategory PRIMCAT11_2; 
      Property <String> PROP11_1;
      Primitive         thePRIMCAT11_2;
d388 2
a389 2
      PRIMCAT11_1    = newPrimitiveCategory ("PRIMCAT11_1");
      PRIMCAT11_2    = newPrimitiveCategory ("PRIMCAT11_2");
d391 1
a391 1
      PROP11_1       = newProperty (String.class, PRIMCAT11_1, "PROP11_1");
d395 1
a395 1
      thePRIMCAT11_2 = newPrimitive (PRIMCAT11_2, "#1");
d397 1
a397 1
      thePRIMCAT11_2.get (PROP11_1);
d409 1
a409 1
      newTupleCategory ("COMP_12_1", null, null);
d420 1
a420 1
      newTupleCategory ("COMP_13_1");
d429 2
a430 2
      PrimitiveCategory PRIMCAT14_1;
      PrimitiveCategory PRIMCAT14_2;
d434 1
a434 1
      PRIMCAT14_1 = newPrimitiveCategory ("PRIMCAT14_1");
d436 1
a436 1
      newScheme ("SCHEME14_2");
d438 1
a438 1
      PRIMCAT14_2 = newPrimitiveCategory ("PRIMCAT14_2");
d440 1
a440 1
      newTupleCategory ("COMP_14_1_2", PRIMCAT14_1, PRIMCAT14_2);
d449 1
a449 1
      PrimitiveCategory PRIMCAT15_1;
d453 1
a453 1
      PRIMCAT15_1 = newPrimitiveCategory ("PRIMCAT15_1");
d455 2
a456 2
      newTupleCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
      newTupleCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
d465 4
a468 4
      PrimitiveCategory PT_16_1;
      TupleCategory     TT_16_1;
      Primitive         thePT_16_1;
      Tuple             theTT_16_1;
d473 1
a473 1
      PT_16_1 = newPrimitiveCategory ("PT_16_1");
d475 1
a475 1
      TT_16_1 = newTupleCategory ("TT_16_1", PT_16_1);
d479 1
a479 1
      thePT_16_1 = newPrimitive (PT_16_1, "thePT_16_1");
d481 1
a481 1
      theTT_16_1 = newTuple (TT_16_1, thePT_16_1);
d483 1
a483 1
                   newTuple (TT_16_1, theTT_16_1);
d492 4
a495 4
      PrimitiveCategory PT_17_1;
      TupleCategory     TT_17_1_17_1;
      Primitive         thePT_17_1A;
      Primitive         thePT_17_1B;
d501 2
a502 3
      PT_17_1      = newPrimitiveCategory ("PT_17_1");
      
      TT_17_1_17_1 = newTupleCategory ("TT_17_1_17_1", PT_17_1, PT_17_1);
d506 1
a506 1
      thePT_17_1A  = newPrimitive (PT_17_1, "thePT_17_1A");
d510 1
a510 1
      thePT_17_1B  = newPrimitive (PT_17_1, "thePT_17_1B");
d512 1
a512 1
      newTuple (TT_17_1_17_1, thePT_17_1B, thePT_17_1A);
d521 1
a521 1
      PrimitiveCategory PT_18_1;
d527 1
a527 1
      PT_18_1 = newPrimitiveCategory ("PT_18_1");
d529 1
a529 1
      newPrimitive (PT_18_1, "thePT_18_1");
d538 3
a540 3
      PrimitiveCategory PT_19_1;
      TupleCategory     TT_19_1_19_1;
      Primitive         thePT_19_1;
d546 2
a547 3
      PT_19_1      = newPrimitiveCategory ("PT_19_1");
      
      TT_19_1_19_1 = newTupleCategory ("TT_19_1_19_1", PT_19_1, PT_19_1);
d551 1
a551 1
      thePT_19_1 = newPrimitive (PT_19_1, "thePT_19_1");
d553 1
a553 1
      newTuple (TT_19_1_19_1, thePT_19_1);
d570 86
@


1.32
log
@Moved newTupleCategory from TupleCategory to Scheme.
@
text
@d333 2
a334 2
      PRIMCAT91.newProperty (Boolean.class, "PROP9");
      PRIMCAT92.newProperty (String .class, "PROP9");
d348 1
a348 2
      printHeading (
         "Call to theItem.set (...) with an ItemCategory mismatch.");
d353 1
a353 1
      PROP10_1       = PRIMCAT10_1.newProperty (String.class, "PROP10_1");
d379 1
a379 1
      PROP11_1       = PRIMCAT11_1.newProperty (String.class, "PROP11_1");
@


1.31
log
@newPrimitiveCategory with current Scheme.
@
text
@a17 1
import static com.ibm.witm.TupleCategory .newTupleCategory;
d37 2
a38 2
      int             theCaseIdx;
      ErrorTester theSQTester;
d42 1
a42 1
         theSQTester = new ErrorTester (theCaseIdx);
d44 1
a44 1
         theSQTester.testCurCase ();
@


1.30
log
@A frozen Scheme cannot be the current Scheme.
@
text
@d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 21; theCaseIdx ++)
a187 4
         case 21:
            testCase21 ();
            break;

d231 2
a232 2
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT3");
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT3");
a240 1
      Scheme            SCHEME4;
d246 1
a246 1
      SCHEME4  = newScheme ("SCHEME4");
d248 1
a248 1
      PRIMCAT4 = SCHEME4.newPrimitiveCategory ("PRIMCAT4");
d262 1
a262 1
         "Call to theScheme.newPrimitiveCategory (...) on a frozen Scheme.");
d264 1
a264 1
      freezeCurrentScheme ();
d266 1
a266 1
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT5");
d293 1
a293 1
      PRIMCAT7 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT7");
d313 1
a313 1
      PRIMCAT8 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT8");
d331 2
a332 2
      PRIMCAT91 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT91");
      PRIMCAT92 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT92");
d352 2
a353 2
      PRIMCAT10_1    = ERROR_TEST.newPrimitiveCategory ("PRIMCAT10_1");
      PRIMCAT10_2    = ERROR_TEST.newPrimitiveCategory ("PRIMCAT10_2");
d378 2
a379 2
      PRIMCAT11_1    = ERROR_TEST  .newPrimitiveCategory ("PRIMCAT11_1");
      PRIMCAT11_2    = ERROR_TEST  .newPrimitiveCategory ("PRIMCAT11_2");
a418 1
      Scheme            SCHEME14_2;
d424 1
a424 1
      SCHEME14_2  = newScheme ("SCHEME14_2");
d426 3
a428 2
      PRIMCAT14_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT14_1");
      PRIMCAT14_2 = SCHEME14_2.newPrimitiveCategory ("PRIMCAT14_2");
d443 1
a443 1
      PRIMCAT15_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT15_1");
d463 1
a463 1
      PT_16_1 = ERROR_TEST.newPrimitiveCategory ("PT_16_1");
d491 1
a491 1
      PT_17_1      = ERROR_TEST.newPrimitiveCategory ("PT_17_1");
d518 1
a518 1
      PT_18_1 = ERROR_TEST.newPrimitiveCategory ("PT_18_1");
d537 1
a537 1
      PT_19_1      = ERROR_TEST.newPrimitiveCategory ("PT_19_1");
a561 14
 * Performs error test case 21.
 *******************************************************************************
 */
   private void testCase21 ()
      {
      printHeading (
         "Call to freezeCurrentScheme when there is no current Scheme.");
      
      setCurrentScheme (null);
      
      freezeCurrentScheme ();
      }

/*******************************************************************************
@


1.29
log
@theImple ==> theImpl
@
text
@d17 1
a17 1
import static com.ibm.witm.Scheme        .newScheme;
d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 19; theCaseIdx ++)
d184 8
d269 1
a269 1
      ERROR_TEST.freeze ();
d554 27
d608 3
a610 1
      ERROR_TEST.freeze ();
@


1.28
log
@Reverting to state as of yesterday 6/8/11 15:00.
@
text
@d496 1
a496 1
      newImplementation (ERROR_TEST, "theImp_17_B");
@


1.27
log
@Setting current Implementation requires matching current Scheme.
@
text
@d17 1
a17 1
import static com.ibm.witm.Scheme        .*;
d38 1
a38 1
      int         theCaseIdx;
d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 22; theCaseIdx ++)
a183 12
         case 20:
            testCase20 ();
            break;

         case 21:
            testCase21 ();
            break;

         case 22:
            testCase22 ();
            break;

d276 1
a276 1
      newImplementation ("Test Case #6");
d496 1
a496 1
      newImplementation ("theImpl_17_B");
a545 49
 * Performs error test case 20.
 *******************************************************************************
 */
   private void testCase20 ()
      {
      printHeading (
         "Call to setCurrentScheme, while a current Implementation exists.");
      
      makeImplementation ();

      setCurrentScheme (null);
      }

/*******************************************************************************
 * Performs error test case 21.
 *******************************************************************************
 */
   private void testCase21 ()
      {
      printHeading (
         "Call to newImplementation when the current Scheme is null.");
      
      setCurrentScheme (null);
      
      newImplementation ("Test Case #21");
      }

/*******************************************************************************
 * Performs error test case 22.
 *******************************************************************************
 */
   private void testCase22 ()
      {
      Implementation theImpl;
      
      printHeading (
         "Call to setCurrentImplementation with an Implementation that does\n"
       + "not belong to the current Scheme.");
      
      makeImplementation ();
      
      theImpl = getCurrentImplementation ();

      setCurrentImplementation (null);
      setCurrentScheme         (null);
      setCurrentImplementation (theImpl);
      }

/*******************************************************************************
d575 1
a575 3
      Scheme.setCurrentScheme (ERROR_TEST);
      
      newImplementation ("Test Case #" + curCaseIdx);
@


1.26
log
@Testing for current Scheme.
@
text
@d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 21; theCaseIdx ++)
d192 4
d586 21
@


1.25
log
@Added test for setCurrentScheme.
@
text
@d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 20; theCaseIdx ++)
d188 4
d284 1
a284 1
      newImplementation (ERROR_TEST, "Test Case #6");
d504 1
a504 1
      newImplementation (ERROR_TEST, "theImpl_17_B");
d560 1
a560 1
         "Call to setCurrentScheme, while a current Implementation exists.\n");
d568 14
d611 3
a613 1
      newImplementation (ERROR_TEST, "Test Case #" + curCaseIdx);
@


1.24
log
@Matching current Scheme to current Implementation.
@
text
@d17 1
a17 1
import static com.ibm.witm.Scheme        .newScheme;
d38 1
a38 1
      int             theCaseIdx;
d41 1
a41 1
      for (theCaseIdx = 1; theCaseIdx <= 19; theCaseIdx ++)
d184 4
d550 14
@


1.23
log
@Moved getAll (TupleCategory).
@
text
@d496 1
a496 1
      newImplementation (ERROR_TEST, "theImp_17_B");
@


1.22
log
@Moved newTuple from TupleCategory to Implementation.
@
text
@d308 1
a308 1
       + "Implementation.getAll ().");
@


1.21
log
@Type ==> Category
@
text
@d468 1
a468 1
      theTT_16_1 = TT_16_1.newTuple (thePT_16_1);
d470 1
a470 1
      TT_16_1.             newTuple (theTT_16_1);
d485 2
a486 1
         "Call to newTuple with coordinates from different Implementations.");
d500 1
a500 1
      TT_17_1_17_1.newTuple (thePT_17_1A, thePT_17_1B);
d531 2
a532 2
         "Call to newTuple where the number of coordinates does not match the\n"
       + "number of dimensions in the TupleCategory.");
d542 1
a542 1
      TT_19_1_19_1.newTuple (thePT_19_1);
@


1.20
log
@Element     ==> Item
ElementType ==> ItemTYpe
@
text
@d11 1
a11 1
import com.ibm.witm.PrimitiveType;
d15 1
a15 1
import com.ibm.witm.TupleType;
d18 1
a18 1
import static com.ibm.witm.TupleType     .newTupleType;
d225 1
a225 2
      printHeading (
         "Creating a PrimitiveType with a duplicate name.");
d227 2
a228 2
      ERROR_TEST.newPrimitiveType ("PRIMTYPE3");
      ERROR_TEST.newPrimitiveType ("PRIMTYPE3");
d237 2
a238 2
      Scheme        SCHEME4;
      PrimitiveType PRIMTYPE4;
d243 1
a243 1
      SCHEME4   = newScheme ("SCHEME4");
d245 1
a245 1
      PRIMTYPE4 = SCHEME4.newPrimitiveType ("PRIMTYPE4");
d249 1
a249 1
      newPrimitive (PRIMTYPE4, "Prim4");
d259 1
a259 1
         "Call to theScheme.newPrimitiveType (...) on a frozen Scheme.");
d263 1
a263 1
      ERROR_TEST.newPrimitiveType ("PRIMTYPE5");
d285 1
a285 1
      PrimitiveType PRIMTYPE7;
d290 1
a290 1
      PRIMTYPE7 = ERROR_TEST.newPrimitiveType ("PRIMTYPE7");
d294 2
a295 2
      newPrimitive (PRIMTYPE7, "Prim7");
      newPrimitive (PRIMTYPE7, "Prim7");
d304 1
a304 1
      PrimitiveType PRIMTYPE8;
d310 1
a310 1
      PRIMTYPE8 = ERROR_TEST.newPrimitiveType ("PRIMTYPE8");
d314 1
a314 1
      getAll (PRIMTYPE8).clear ();
d323 2
a324 2
      PrimitiveType PRIMTYPE91;
      PrimitiveType PRIMTYPE92;
d328 2
a329 2
      PRIMTYPE91 = ERROR_TEST.newPrimitiveType ("PRIMTYPE91");
      PRIMTYPE92 = ERROR_TEST.newPrimitiveType ("PRIMTYPE92");
d331 2
a332 2
      PRIMTYPE91.newProperty (Boolean.class, "PROP9");
      PRIMTYPE92.newProperty (String .class, "PROP9");
d341 2
a342 2
      PrimitiveType     PRIMTYPE10_1; 
      PrimitiveType     PRIMTYPE10_2; 
d344 1
a344 1
      Primitive         thePRIMTYPE10_2;
d347 1
a347 1
         "Call to theItem.set (...) with an ItemType mismatch.");
d349 2
a350 2
      PRIMTYPE10_1    = ERROR_TEST.newPrimitiveType ("PRIMTYPE10_1");
      PRIMTYPE10_2    = ERROR_TEST.newPrimitiveType ("PRIMTYPE10_2");
d352 1
a352 1
      PROP10_1        = PRIMTYPE10_1.newProperty (String.class, "PROP10_1");
d356 1
a356 1
      thePRIMTYPE10_2 = newPrimitive (PRIMTYPE10_2, "#1");
d358 1
a358 1
      thePRIMTYPE10_2.set (PROP10_1, "Test");
d367 2
a368 2
      PrimitiveType     PRIMTYPE11_1; 
      PrimitiveType     PRIMTYPE11_2; 
d370 1
a370 1
      Primitive         thePRIMTYPE11_2;
d373 1
a373 1
         "Call to theItem.get (...) with an ItemType mismatch.");
d375 2
a376 2
      PRIMTYPE11_1    = ERROR_TEST  .newPrimitiveType ("PRIMTYPE11_1");
      PRIMTYPE11_2    = ERROR_TEST  .newPrimitiveType ("PRIMTYPE11_2");
d378 1
a378 1
      PROP11_1        = PRIMTYPE11_1.newProperty (String.class, "PROP11_1");
d382 1
a382 1
      thePRIMTYPE11_2 = newPrimitive (PRIMTYPE11_2, "#1");
d384 1
a384 1
      thePRIMTYPE11_2.get (PROP11_1);
d394 1
a394 1
         "Call to newTupleType with a null ItemType reference.");
d396 1
a396 1
      newTupleType ("COMP_12_1", null, null);
d405 1
a405 1
      printHeading ("Call to newTupleType with no ItemTypes.");
d407 1
a407 1
      newTupleType ("COMP_13_1");
d416 3
a418 3
      Scheme        SCHEME14_2;
      PrimitiveType PRIMTYPE14_1;
      PrimitiveType PRIMTYPE14_2;
d420 1
a420 1
      printHeading ("Call to newTupleType with a Scheme mismatch.");
d422 1
a422 1
      SCHEME14_2   = newScheme ("SCHEME14_2");
d424 2
a425 2
      PRIMTYPE14_1 = ERROR_TEST.newPrimitiveType ("PRIMTYPE14_1");
      PRIMTYPE14_2 = SCHEME14_2.newPrimitiveType ("PRIMTYPE14_2");
d427 1
a427 1
      newTupleType ("COMP_14_1_2", PRIMTYPE14_1, PRIMTYPE14_2);
d436 1
a436 1
      PrimitiveType PRIMTYPE15_1;
d438 1
a438 1
      printHeading ("Call to newTupleType with a duplicate name.");
d440 1
a440 1
      PRIMTYPE15_1 = ERROR_TEST.newPrimitiveType ("PRIMTYPE15_1");
d442 2
a443 2
      newTupleType ("COMP_15_1_1", PRIMTYPE15_1, PRIMTYPE15_1);
      newTupleType ("COMP_15_1_1", PRIMTYPE15_1, PRIMTYPE15_1);
d452 4
a455 4
      PrimitiveType PT_16_1;
      TupleType     TT_16_1;
      Primitive     thePT_16_1;
      Tuple         theTT_16_1;
d458 1
a458 1
         "Call to newTuple with a coordinate of the wrong ItemType.");
d460 1
a460 1
      PT_16_1 = ERROR_TEST.newPrimitiveType ("PT_16_1");
d462 1
a462 1
      TT_16_1 = newTupleType ("TT_16_1", PT_16_1);
d479 4
a482 4
      PrimitiveType PT_17_1;
      TupleType     TT_17_1_17_1;
      Primitive     thePT_17_1A;
      Primitive     thePT_17_1B;
d487 1
a487 1
      PT_17_1      = ERROR_TEST.newPrimitiveType ("PT_17_1");
d489 1
a489 1
      TT_17_1_17_1 = newTupleType ("TT_17_1_17_1", PT_17_1, PT_17_1);
d508 1
a508 1
      PrimitiveType PT_18_1;
d514 1
a514 1
      PT_18_1 = ERROR_TEST.newPrimitiveType ("PT_18_1");
d525 3
a527 3
      PrimitiveType PT_19_1;
      TupleType     TT_19_1_19_1;
      Primitive     thePT_19_1;
d531 1
a531 1
       + "number of dimensions in the TupleType.");
d533 1
a533 1
      PT_19_1      = ERROR_TEST.newPrimitiveType ("PT_19_1");
d535 1
a535 1
      TT_19_1_19_1 = newTupleType ("TT_19_1_19_1", PT_19_1, PT_19_1);
@


1.19
log
@Moved getAll.
@
text
@d348 1
a348 1
         "Call to theElem.set (...) with an ElementType mismatch.");
d374 1
a374 1
         "Call to theElem.get (...) with an ElementType mismatch.");
d395 1
a395 1
         "Call to newTupleType with a null ElementType reference.");
d406 1
a406 1
      printHeading ("Call to newTupleType with no ElementTypes.");
d459 1
a459 1
         "Call to newTuple with a coordinate of the wrong ElementType.");
@


1.18
log
@Moved some factory methods.
@
text
@d308 2
a309 1
         "Call to a modifying method on the result of thePrimType.getAll ().");
d315 1
a315 1
      PRIMTYPE8.getAll ().clear ();
@


1.17
log
@Embodiment ==> Implementation
@
text
@d17 3
a19 2
import static com.ibm.witm.Scheme   .newScheme;
import static com.ibm.witm.TupleType.newTupleType;
d242 1
a242 1
         "Call to thePrimType.newPrimitive (...) with a Scheme mismatch.");
d250 1
a250 1
      PRIMTYPE4.newPrimitive ("Prim4");
d274 2
a275 1
         "Call to theScheme.newImplementation (...) on an unfrozen Scheme.");
d277 1
a277 1
      ERROR_TEST.newImplementation ("Test Case #6");
d289 1
a289 1
         "Call to thePrimType.newPrimitive (...) with a name collision.");
d295 2
a296 2
      PRIMTYPE7.newPrimitive ("Prim7");
      PRIMTYPE7.newPrimitive ("Prim7");
d349 2
a350 2
      PRIMTYPE10_1 = ERROR_TEST.newPrimitiveType ("PRIMTYPE10_1");
      PRIMTYPE10_2 = ERROR_TEST.newPrimitiveType ("PRIMTYPE10_2");
d352 1
a352 1
      PROP10_1     = PRIMTYPE10_1.newProperty (String.class, "PROP10_1");
d356 1
a356 1
      thePRIMTYPE10_2 = PRIMTYPE10_2.newPrimitive ("#1");
d382 1
a382 1
      thePRIMTYPE11_2 = PRIMTYPE11_2.newPrimitive ("#1");
d466 1
a466 1
      thePT_16_1 = PT_16_1.newPrimitive ("thePT_16_1");
d468 1
a468 1
      theTT_16_1 = TT_16_1.newTuple      (thePT_16_1);
d470 1
a470 1
      TT_16_1.             newTuple      (theTT_16_1);
d493 1
a493 1
      thePT_17_1A  = PT_17_1.newPrimitive ("thePT_17_1A");
d495 1
a495 1
      ERROR_TEST.newImplementation ("theImp_17_B");
d497 1
a497 1
      thePT_17_1B  = PT_17_1.newPrimitive ("thePT_17_1B");
d511 2
a512 2
         "Call to newPrimitive (theName) when the current Implementation is\n"
       + "null.");
d516 1
a516 1
      PT_18_1.newPrimitive ("thePT_18_1");
d539 1
a539 1
      thePT_19_1 = PT_19_1.newPrimitive ("thePT_19_1");
d574 1
a574 1
      ERROR_TEST.newImplementation ("Test Case #" + curCaseIdx);
@


1.16
log
@Added a newTuple test.
@
text
@d8 1
a8 1
import com.ibm.witm.Embodiment;
d89 1
a89 1
      Embodiment.setCurrentEmbodiment (null);
d247 1
a247 1
      makeEmbodiment ();
d273 1
a273 1
         "Call to theScheme.newEmbodiment (...) on an unfrozen Scheme.");
d275 1
a275 1
      ERROR_TEST.newEmbodiment ("Test Case #6");
d291 1
a291 1
      makeEmbodiment ();
d310 1
a310 1
      makeEmbodiment ();
d352 1
a352 1
      makeEmbodiment ();
d378 1
a378 1
      makeEmbodiment ();
d462 1
a462 1
      makeEmbodiment ();
d483 1
a483 1
         "Call to newTuple with coordinates from different Embodiments.");
d489 1
a489 1
      makeEmbodiment ();
d493 1
a493 1
      ERROR_TEST.newEmbodiment ("theEmb_17_B");
d509 2
a510 1
         "Call to newPrimitive (theName) when the current Embodiment is null.");
d535 1
a535 1
      makeEmbodiment ();
d565 1
a565 1
 * Creates myEmbodiment.
d568 1
a568 1
   private void makeEmbodiment ()
d572 1
a572 1
      ERROR_TEST.newEmbodiment ("Test Case #" + curCaseIdx);
@


1.15
log
@Removed some Embodiment arg methods.
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 18; theCaseIdx ++)
d179 4
d517 25
@


1.14
log
@getAll
@
text
@d542 1
a542 1
      myEmbodiment = ERROR_TEST.newEmbodiment ("Test Case #" + curCaseIdx);
a556 7
/*******************************************************************************
 * The main Embodiment to be used for an error test.
 *******************************************************************************
 */
                      @@SuppressWarnings("unused")
   private Embodiment myEmbodiment = null;

@


1.13
log
@Test of newPrimitive.
@
text
@d302 1
a302 2
         "Call to a modifying method on the result of "
       + "theEmbodiment.get (thePrimType).");
d308 1
a308 1
      PRIMTYPE8.getAll (myEmbodiment).clear ();
d561 1
@


1.12
log
@Dimensions and Coordinates
@
text
@d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 17; theCaseIdx ++)
d88 2
d175 4
d498 16
@


1.11
log
@Current Embodiment
@
text
@d447 1
a447 1
         "Call to newTuple with an Element of the wrong ElementType.");
d474 1
a474 1
         "Call to newTuple with Elements of different Embodiments.");
@


1.10
log
@Tests of newTuple.
@
text
@d239 1
a239 1
      PRIMTYPE4.newPrimitive (myEmbodiment, "Prim4");
d283 2
a284 2
      PRIMTYPE7.newPrimitive (myEmbodiment, "Prim7");
      PRIMTYPE7.newPrimitive (myEmbodiment, "Prim7");
d345 1
a345 1
      thePRIMTYPE10_2 = PRIMTYPE10_2.newPrimitive (myEmbodiment, "#1");
d364 2
a365 2
      PRIMTYPE11_1 = ERROR_TEST.newPrimitiveType ("PRIMTYPE11_1");
      PRIMTYPE11_2 = ERROR_TEST.newPrimitiveType ("PRIMTYPE11_2");
d367 1
a367 1
      PROP11_1     = PRIMTYPE11_1.newProperty (String.class, "PROP11_1");
d371 1
a371 1
      thePRIMTYPE11_2 = PRIMTYPE11_2.newPrimitive (myEmbodiment, "#1");
d455 1
a455 1
      thePT_16_1 = PT_16_1.newPrimitive (myEmbodiment, "thePT_16_1");
d457 1
a457 1
      theTT_16_1 = TT_16_1.newTuple (thePT_16_1);
d459 1
a459 1
      TT_16_1.newTuple (theTT_16_1);
a470 1
      Embodiment    theEmb_17_B;
d482 1
a482 1
      thePT_17_1A  = PT_17_1.newPrimitive (myEmbodiment, "thePT_17_1A");
d484 1
a484 1
      theEmb_17_B  = ERROR_TEST.newEmbodiment ("theEmb_17_B");
d486 1
a486 1
      thePT_17_1B  = PT_17_1.newPrimitive (theEmb_17_B, "thePT_17_1B");
@


1.9
log
@Category ==> Type
@
text
@d14 2
d40 1
a40 1
      for (theCaseIdx = 1; theCaseIdx <= 15; theCaseIdx ++)
d165 8
d436 57
@


1.8
log
@Fulfillment ==> Embodiment
@
text
@d11 1
a11 1
import com.ibm.witm.PrimitiveCategory;
d15 2
a16 2
import static com.ibm.witm.Scheme       .newScheme;
import static com.ibm.witm.TupleCategory.newTupleCategory;
d205 1
a205 1
         "Creating a PrimitiveCategory with a duplicate name.");
d207 2
a208 2
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT3");
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT3");
d217 2
a218 2
      Scheme            SCHEME4;
      PrimitiveCategory PRIMCAT4;
d221 1
a221 1
         "Call to thePrimCat.newPrimitive (...) with a Scheme mismatch.");
d223 1
a223 1
      SCHEME4  = newScheme ("SCHEME4");
d225 1
a225 1
      PRIMCAT4 = SCHEME4.newPrimitiveCategory ("PRIMCAT4");
d229 1
a229 1
      PRIMCAT4.newPrimitive (myEmbodiment, "Prim4");
d239 1
a239 1
         "Call to theScheme.newPrimitiveCategory (...) on a frozen Scheme.");
d243 1
a243 1
      ERROR_TEST.newPrimitiveCategory ("PRIMCAT5");
d264 1
a264 1
      PrimitiveCategory PRIMCAT7;
d267 1
a267 1
         "Call to thePrimCat.newPrimitive (...) with a name collision.");
d269 1
a269 1
      PRIMCAT7 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT7");
d273 2
a274 2
      PRIMCAT7.newPrimitive (myEmbodiment, "Prim7");
      PRIMCAT7.newPrimitive (myEmbodiment, "Prim7");
d283 1
a283 1
      PrimitiveCategory PRIMCAT8;
d287 1
a287 1
       + "theEmbodiment.get (thePrimCat).");
d289 1
a289 1
      PRIMCAT8 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT8");
d293 1
a293 1
      PRIMCAT8.getAll (myEmbodiment).clear ();
d302 2
a303 2
      PrimitiveCategory PRIMCAT91;
      PrimitiveCategory PRIMCAT92;
d307 2
a308 2
      PRIMCAT91 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT91");
      PRIMCAT92 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT92");
d310 2
a311 2
      PRIMCAT91.newProperty (Boolean.class, "PROP9");
      PRIMCAT92.newProperty (String .class, "PROP9");
d320 2
a321 2
      PrimitiveCategory PRIMCAT10_1; 
      PrimitiveCategory PRIMCAT10_2; 
d323 1
a323 1
      Primitive         thePRIMCAT10_2;
d326 1
a326 1
         "Call to theElem.set (...) with an ElementCategory mismatch.");
d328 2
a329 2
      PRIMCAT10_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT10_1");
      PRIMCAT10_2 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT10_2");
d331 1
a331 1
      PROP10_1    = PRIMCAT10_1.newProperty (String.class, "PROP10_1");
d335 1
a335 1
      thePRIMCAT10_2 = PRIMCAT10_2.newPrimitive (myEmbodiment, "#1");
d337 1
a337 1
      thePRIMCAT10_2.set (PROP10_1, "Test");
d346 2
a347 2
      PrimitiveCategory PRIMCAT11_1; 
      PrimitiveCategory PRIMCAT11_2; 
d349 1
a349 1
      Primitive         thePRIMCAT11_2;
d352 1
a352 1
         "Call to theElem.get (...) with an ElementCategory mismatch.");
d354 2
a355 2
      PRIMCAT11_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT11_1");
      PRIMCAT11_2 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT11_2");
d357 1
a357 1
      PROP11_1    = PRIMCAT11_1.newProperty (String.class, "PROP11_1");
d361 1
a361 1
      thePRIMCAT11_2 = PRIMCAT11_2.newPrimitive (myEmbodiment, "#1");
d363 1
a363 1
      thePRIMCAT11_2.get (PROP11_1);
d373 1
a373 1
         "Call to newTupleCategory with a null ElementCategory reference.");
d375 1
a375 1
      newTupleCategory ("COMP_12_1", null, null);
d384 1
a384 1
      printHeading ("Call to newTupleCategory with no ElementCategories.");
d386 1
a386 1
      newTupleCategory ("COMP_13_1");
d395 3
a397 3
      Scheme            SCHEME14_2;
      PrimitiveCategory PRIMCAT14_1;
      PrimitiveCategory PRIMCAT14_2;
d399 1
a399 1
      printHeading ("Call to newTupleCategory with a Scheme mismatch.");
d401 1
a401 1
      SCHEME14_2  = newScheme ("SCHEME14_2");
d403 2
a404 2
      PRIMCAT14_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT14_1");
      PRIMCAT14_2 = SCHEME14_2.newPrimitiveCategory ("PRIMCAT14_2");
d406 1
a406 1
      newTupleCategory ("COMP_14_1_2", PRIMCAT14_1, PRIMCAT14_2);
d415 1
a415 1
      PrimitiveCategory PRIMCAT15_1;
d417 1
a417 1
      printHeading ("Call to newTupleCategory with a duplicate name.");
d419 1
a419 1
      PRIMCAT15_1 = ERROR_TEST.newPrimitiveCategory ("PRIMCAT15_1");
d421 2
a422 2
      newTupleCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
      newTupleCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
@


1.7
log
@Primitives
@
text
@d8 1
a8 1
import com.ibm.witm.Fulfillment;
d227 1
a227 1
      makeFulfillment ();
d229 1
a229 1
      PRIMCAT4.newPrimitive (myFulfillment, "Prim4");
d253 1
a253 1
         "Call to theScheme.newFulfillment (...) on an unfrozen Scheme.");
d255 1
a255 1
      ERROR_TEST.newFulfillment ("Test Case #6");
d271 1
a271 1
      makeFulfillment ();
d273 2
a274 2
      PRIMCAT7.newPrimitive (myFulfillment, "Prim7");
      PRIMCAT7.newPrimitive (myFulfillment, "Prim7");
d287 1
a287 1
       + "theFulfillment.get (thePrimCat).");
d291 1
a291 1
      makeFulfillment ();
d293 1
a293 1
      PRIMCAT8.getAll (myFulfillment).clear ();
d333 1
a333 1
      makeFulfillment ();
d335 1
a335 1
      thePRIMCAT10_2 = PRIMCAT10_2.newPrimitive (myFulfillment, "#1");
d359 1
a359 1
      makeFulfillment ();
d361 1
a361 1
      thePRIMCAT11_2 = PRIMCAT11_2.newPrimitive (myFulfillment, "#1");
d448 1
a448 1
 * Creates myFulfillment.
d451 1
a451 1
   private void makeFulfillment ()
d455 1
a455 1
      myFulfillment = ERROR_TEST.newFulfillment ("Test Case #" + curCaseIdx);
d471 1
a471 1
 * The main Fulfillment to be used for an error test.
d474 1
a474 1
   private Fulfillment myFulfillment = null;
@


1.6
log
@Compound ==> Tuple
@
text
@d221 1
a221 1
         "Call to theFulfillment.newPrimitive (...) with a Scheme mismatch.");
d229 1
a229 1
      myFullfillment.newPrimitive (PRIMCAT4, "Prim4");
d267 1
a267 1
         "Call to theFulfillment.newPrimitive (...) with a name collision.");
d273 2
a274 2
      myFullfillment.newPrimitive (PRIMCAT7, "Prim7");
      myFullfillment.newPrimitive (PRIMCAT7, "Prim7");
d293 1
a293 1
      myFullfillment.get (PRIMCAT8).clear ();
d335 1
a335 1
      thePRIMCAT10_2 = myFullfillment.newPrimitive (PRIMCAT10_2, "#1");
d361 1
a361 1
      thePRIMCAT11_2 = myFullfillment.newPrimitive (PRIMCAT11_2, "#1");
d448 1
a448 1
 * Creates myFullfillment.
d455 1
a455 1
      myFullfillment = ERROR_TEST.newFulfillment ("Test Case #" + curCaseIdx);
d474 1
a474 1
   private Fulfillment myFullfillment = null;
@


1.5
log
@Check for duplicate ComponentCategory name.
@
text
@d15 2
a16 2
import static com.ibm.witm.Scheme          .newScheme;
import static com.ibm.witm.CompoundCategory.newCompoundCategory;
d373 1
a373 1
         "Call to newCompoundCategory with a null ElementCategory reference.");
d375 1
a375 1
      newCompoundCategory ("COMP_12_1", null, null);
d384 1
a384 1
      printHeading ("Call to newCompoundCategory with no ElementCategories.");
d386 1
a386 1
      newCompoundCategory ("COMP_13_1");
d399 1
a399 1
      printHeading ("Call to newCompoundCategory with a Scheme mismatch.");
d406 1
a406 1
      newCompoundCategory ("COMP_14_1_2", PRIMCAT14_1, PRIMCAT14_2);
d417 1
a417 1
      printHeading ("Call to newCompoundCategory with a duplicate name.");
d421 2
a422 2
      newCompoundCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
      newCompoundCategory ("COMP_15_1_1", PRIMCAT15_1, PRIMCAT15_1);
@


1.4
log
@AppProblem ==> Fulfillment
@
text
@d38 1
a38 1
      for (theCaseIdx = 1; theCaseIdx <= 14; theCaseIdx ++)
d159 4
d410 16
@


1.3
log
@Added tests for newCompoundCategory.
@
text
@d8 1
a8 1
import com.ibm.witm.AppProblem;
d217 1
a217 1
         "Call to theAppProblem.newPrimitive (...) with a Scheme mismatch.");
d223 1
a223 1
      makeAppProblem ();
d225 1
a225 1
      myAppProblem.newPrimitive (PRIMCAT4, "Prim4");
d249 1
a249 1
         "Call to theScheme.newAppProblem (...) on an unfrozen Scheme.");
d251 1
a251 1
      ERROR_TEST.newAppProblem ("Test Case #6");
d263 1
a263 1
         "Call to theAppProblem.newPrimitive (...) with a name collision.");
d267 1
a267 1
      makeAppProblem ();
d269 2
a270 2
      myAppProblem.newPrimitive (PRIMCAT7, "Prim7");
      myAppProblem.newPrimitive (PRIMCAT7, "Prim7");
d283 1
a283 1
       + "theAppProblem.get (thePrimCat).");
d287 1
a287 1
      makeAppProblem ();
d289 1
a289 1
      myAppProblem.get (PRIMCAT8).clear ();
d329 1
a329 1
      makeAppProblem ();
d331 1
a331 1
      thePRIMCAT10_2 = myAppProblem.newPrimitive (PRIMCAT10_2, "#1");
d355 1
a355 1
      makeAppProblem ();
d357 1
a357 1
      thePRIMCAT11_2 = myAppProblem.newPrimitive (PRIMCAT11_2, "#1");
d428 1
a428 1
 * Creates myAppProblem.
d431 1
a431 1
   private void makeAppProblem ()
d435 1
a435 1
      myAppProblem = ERROR_TEST.newAppProblem ("Test Case #" + curCaseIdx);
d451 1
a451 1
 * The main AppProblem to be used for an error test.
d454 1
a454 1
   private AppProblem myAppProblem = null;
@


1.2
log
@theElem.get (...)
@
text
@d15 3
d38 1
a38 1
      for (theCaseIdx = 1; theCaseIdx <= 11; theCaseIdx ++)
d62 1
a62 1
      ERROR_TEST = Scheme.newScheme ("ERROR_TEST");
d147 12
d171 1
a171 2
      printHeading (
         "Passing a null argument to Scheme.newScheme (...).");
d173 1
a173 1
      Scheme.newScheme (null);
d219 1
a219 1
      SCHEME4  = Scheme.newScheme ("SCHEME4");
d322 1
a322 1
         "Calling theElem.set (...) with an ElementCategory mismatch.");
d348 1
a348 1
         "Calling theElem.get (...) with an ElementCategory mismatch.");
d363 43
@


1.1
log
@Status Quo Test ==> Error Test
@
text
@d35 1
a35 1
      for (theCaseIdx = 1; theCaseIdx <= 10; theCaseIdx ++)
d140 4
d323 26
@


head	1.7;
access;
symbols
	sce_5_01_20080919:1.6
	latest_sce_4_20_20060523:1.6.0.4
	sce_4_20_20060523:1.6
	latest_sce4_20_OSL:1.6.0.2
	sce_4_20_OSL:1.6
	sce_4_05_20040511:1.6
	sce_4_00_20040201:1.6
	nextGenBranch:1.5.0.2
	nextGenRoot:1.5
	sce_3_30_20030627:1.5
	EndRw-branch:1.3.0.2
	Root-of-EndRw:1.3
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2009.12.01.20.19.51;	author ervolina;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.05.12.37.42;	author dpc;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.15.23.05.47;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.15.19.36.34;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.00.35.03;	author fasano;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.12.02.17.42.24;	author austel;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.29.41;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.41;	author wit;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.08.17.42.29;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.7
log
@jettison references in scenario to Wit's OBJ2
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#endif

// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
#include <string>
// End of RW2STL -- inserted includes.
#include <math.h>
#include <iostream>


#include <scenario/src/difWitR.h>
#include <scenario/src/witRunVn.h>
#include <scenario/src/calendar.h>
#include <scenario/src/difEssSc.h>
#include <scenario/src/customer.h>


const std::string 
LgFrDataInterfaceImplementationFromWitRun::defaultRiskForecast(
                                     "RiskForecast.*");
const std::string 
LgFrDataInterfaceImplementationFromWitRun::defaultFirmForecast(
#if CUSTOMER_NUMBER == MOOGS_NUMBER
                                     "MPS.*"); 
#else							       
                                     "FirmForecast.*");
#endif
const std::string 
LgFrDataInterfaceImplementationFromWitRun::defaultNewOps(
                                     "NewOps.*");
const std::string 
LgFrDataInterfaceImplementationFromWitRun::defaultCommitted(
                                     "Committed.*");

//-------------------------------------------------------------------
// Set problem title (private member function, not allowed)
//-------------------------------------------------------------------
void
LgFrDataInterfaceImplementationFromWitRun::title(
     std::string t 
    )
{
    t = makeTitle();
    LgFrDataInterfaceImplementation::title(t);
}

//-------------------------------------------------------------------
// Return a problem title
//-------------------------------------------------------------------
std::string
LgFrDataInterfaceImplementationFromWitRun::title(
    const LgFrDataInterfaceEssentials * difEssenPtr)
const
{   
    std::string t = LgFrDataInterfaceImplementation::title(difEssenPtr);
    if ( t == "Unknown" )  // Make a title from dataset
	{
	    t = makeTitle(difEssenPtr);
	    ((LgFrDataInterfaceImplementation*)this)
		->LgFrDataInterfaceImplementation::title(t);
	}
    return t;
}

//-------------------------------------------------------------------
// Make a problem title
//-------------------------------------------------------------------
std::string
LgFrDataInterfaceImplementationFromWitRun::makeTitle(
    const LgFrDataInterfaceEssentials * difEssenPtr)
     const
{
  char * titleWR;
  
  witGetTitle(constWitRun(difEssenPtr), &titleWR);
  std::string titleName;
  sce::strip( titleName );
  portableFree(titleWR);
  return titleName;
}

//-------------------------------------------------------------------
//  
// Global functions to obtain the defined parts and capacities.
//
//-------------------------------------------------------------------

// Return: a LgFrPartVector object (vector of parts in general)
// used by difWitRunGetRawPart, difWitRunGetProductParts, difWitRunGetcapacityParts 
// to get different kinds of parts from WIT.
void *
difWitRunGetParts(
    const LgFrDataInterfaceImplementation *dImp, 
    const LgFrDataInterfaceEssentials *difEssenPtr,
    witAttr ma, 
    LgFrError& status)
{
  witAttr category;
  char * * partList;
  int listLen, i;

  LgFrDataInterfaceImplementationFromWitRun * dImpWR = (
      LgFrDataInterfaceImplementationFromWitRun * ) dImp;

  witGetParts(dImpWR->constWitRun(difEssenPtr), &listLen, &partList);
  LgFrPartVector * retVal = new LgFrPartVector;
  retVal->reserve( listLen );

  for (i = 0 ; i < listLen ; i++ )
    {
      witGetPartCategory (dImpWR->constWitRun(difEssenPtr), partList[i], &category);
      std::string pn(category);
//      if( pn.compareTo( pn(ma) ) == 0 )
      if( sce::matchRegexp( pn, ma) )
        {
          LgFrPart part = difEssenPtr->createAndInsertPart(partList[i]);
          retVal->push_back(part);
        }
      portableFree(partList[i]);
    }
  portableFree(partList);
  return retVal;
}

// difWitRunGetRawPart global function (registering in the attribute table).
// Get raw parts from WIT and insert them into set_of_part
// Return: a LgFrPartVector object (vector of raw parts).
void *
difWitRunGetRawParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetParts(dImp, difEssenPtr, WitRAW, status);
}

// difWitRunGetProductPart global function (registering in the attribute table).
// Get product parts from WIT and insert it into set_of_part
// Return: a LgFrPartVector object (vector of producible parts)
void*
difWitRunGetProductParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetParts(dImp, difEssenPtr, WitPRODUCT, status);
}

// difWitRunGetCapacityPart global function (registering in the attribute table).
// Get capacity parts from WIT and insert it into set_of_part
// Return: a LgFrPartVector object (vector of capacities).
void*
difWitRunGetCapacityParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetParts(dImp, difEssenPtr, WitCAPACITY, status);
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain part attributes
//
//-------------------------------------------------------------------


  
// difWitRunGetPartProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difWitRunGetPartProcCost(
    const LgFrDataInterfaceImplementation * difImp,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartUnitCost(difImp, itemPtrOrdVecPtr, status);
}

// difWitRunGetPartConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difWitRunGetPartConstrained(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)               
{
  LgFrDataInterfaceImplementationFromWitRun * dImpWR
      = (LgFrDataInterfaceImplementationFromWitRun * ) difImp;

  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve( pv.size() );   

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );
  }
  return &retVal; 
} 

// difWitRunGetPartProcLeadTime global function (registered in the attribute table).
// It returns a LgFrTimeVecFloatVector object.
void *
difWitRunGetPartProcLeadTime(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  float * cycleTime;  
  witAttr partCategory;
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int calNP(calendar.nPeriods());  // # periods in scenario calendar
  int witNP;                       // # periods in wit data file

  LgFrDataInterfaceImplementationFromWitRun * dImpWR
      = (LgFrDataInterfaceImplementationFromWitRun * ) difImp;

  witGetNPeriods( dImpWR->constWitRun(difEssenPtr), &witNP);
  LgFrTimeVecFloat tv(calNP);

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
  {
      witGetPartCategory(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &partCategory);
      if ( partCategory == WitRAW ) 
          retVal.push_back( 0.0 );
      else if (partCategory == WitPRODUCT) 
      {
	      witGetPartCycleTime(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), 
			          &cycleTime);
	      size_t j = 0; // Pulled out of the for below by RW2STL
	      for(j = 0; j < size_tMin(calNP, witNP); j++ )
          {
              tv[j] = cycleTime[j];
	      }
	      retVal.push_back( tv );
	      portableFree(cycleTime);
      }
  }
  return &retVal; 
}      

// Global function to get some part attributes, such as,
// Obj1ScrapCost, Obj1StockCost, and SupplyVol
// (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetPartAttrTimeVecFloat(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    apiFuncGetPartAttrTimeVecFloat apiFunc,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
  float * attrVal;
  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int calNP(calendar.nPeriods());  // # periods in scenario calendar
  int witNP;                       // # periods in wit data file

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) dImp; 

  witGetNPeriods( dImpWR->constWitRun(difEssenPtr), &witNP);
  LgFrTimeVecFloat tv(calNP);

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    apiFunc(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNP, witNP); j++ )
        tv[j] = attrVal[j];

    retVal.push_back( tv );
    portableFree(attrVal);
  }
  return &retVal;
}

// difWitRunGetPartObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetPartObj1ScrapCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartObj1ScrapCost, 
	  status, difEssenPtr);
}

// difWitRunGetPartObj1StockCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetPartObj1StockCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartObj1StockCost, 
	  status, difEssenPtr);
}

// difWitRunGetPartSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetPartSupplyVol(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat 
         (difImp, itemPtrOrdVecPtr, witGetPartSupplyVol, 
	  status, difEssenPtr);
}

//--------------------------------------------------------------------
//  
//   Methods to obtain producible part attributes
//
//-------------------------------------------------------------------

// difWitRunGetProductYield global function (registered in the attribute table).
// Return: a LgFrIntVector object
void *
difWitRunGetProductYield(
    const LgFrDataInterfaceImplementation * dImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) dImp; 

  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );
  int * yield;
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &yield);
    retVal.push_back( yield[0] );
    portableFree(yield);
  }
  return &retVal;
}

// difWitRunGetProductYieldFloat global function
// (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object
void *
difWitRunGetProductYieldFloat(
    const LgFrDataInterfaceImplementation * dImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) dImp;

  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
  int * yield;
  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int calNP(calendar.nPeriods());  // # periods in scenario calendar

  int witNP;                       // # periods in wit data file
  witGetNPeriods( dImpWR->constWitRun(difEssenPtr), &witNP);
  
  LgFrTimeVecFloat tv(calNP);

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &yield);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNP, witNP); j++ ) tv[j] = (float) yield[j];
    retVal.push_back( tv );
    portableFree(yield);
  }
  return &retVal;
}

// difWitRunGetProductCycleTime global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetProductCycleTime(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartCycleTime, 
	  status, difEssenPtr); 
}

// difWitRunGetProductObj1ProdCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetProductObj1ProdCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartObj1ProdCost, 
	  status, difEssenPtr); 
}

void*
difWitRunGetProductMinLotSize(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartMinLotSize, 
	  status, difEssenPtr); 
}

void*
difWitRunGetProductIncLotSize(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetPartAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetPartIncLotSize, 
	  status, difEssenPtr); 
}

//--------------------------------------------------------------------
//  
//   Methods to obtain demands
//
//-------------------------------------------------------------------

// return true if demandName matches compareExpression
bool
LgFrDataInterfaceImplementationFromWitRun::isADemand(
  std::string /* demandedPartName */,
  std::string demandName,
  std::string compareExpression) const
{
  if ( sce::matchRegexp( demandName, compareExpression ) )
    return true;
  else
    return false;
}

// return true if demandName is a NewOp
bool
LgFrDataInterfaceImplementationFromWitRun::isANewOpDemand(
  std::string demandedPartName,
  std::string demandName) const
{
  bool retVal = isADemand(demandedPartName,demandName,newOpsRE_);
  if ( retVal) {
    assert( ! isADemand(demandedPartName, demandName, firmForecastRE_));
    assert( ! isADemand(demandedPartName, demandName, riskForecastRE_));
  }
  return retVal;
}

// return true if demandName is a FirmForecast
bool
LgFrDataInterfaceImplementationFromWitRun::isAFirmForecastDemand(
  std::string demandedPartName,
  std::string demandName) const
{
  bool retVal = isADemand(demandedPartName,demandName,firmForecastRE_);
  if ( retVal) {
    assert( ! isADemand(demandedPartName, demandName, newOpsRE_));
    assert( ! isADemand(demandedPartName, demandName, riskForecastRE_));
  }
  return retVal;
}

// return true if demandName is a RiskForecast
bool
LgFrDataInterfaceImplementationFromWitRun::isARiskForecastDemand(
  std::string demandedPartName,
  std::string demandName) const
{
  bool retVal = isADemand(demandedPartName,demandName,riskForecastRE_);
  if ( retVal) {
    assert( ! isADemand(demandedPartName, demandName, newOpsRE_));
    assert( ! isADemand(demandedPartName, demandName, firmForecastRE_));
  }
  return retVal;
}

// return true if demandName is a Committed
bool
LgFrDataInterfaceImplementationFromWitRun::isACommittedDemand(
  std::string demandedPartName,
  std::string demandName) const
{
  bool retVal = false;
  if (
    (! isANewOpDemand(demandedPartName, demandName)) &&
    (! isAFirmForecastDemand(demandedPartName, demandName)) &&
    (! isARiskForecastDemand(demandedPartName, demandName)))
     return true;
  return retVal;
}

// demand in general
// Return: a LgFrDemandVector object (vector of demands in general)
// used by commited, newOps, firmForecast, riskForecast to get different
// kinds of demands from WIT.
void*
difWitRunGetDemands(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrDataInterfaceEssentials * difEssenPtr,
    bool
     ( LgFrDataInterfaceImplementationFromWitRun::*isA)
        (std::string, std::string)const,
    LgFrError & status
   )                                          
{

    char * * demandList;
    char * * partList;
    int lenDemandList, listLen;

    LgFrDataInterfaceImplementationFromWitRun * dImpWR 
	= (LgFrDataInterfaceImplementationFromWitRun * ) dImp;

    LgFrDemandVector& retVal = *(new LgFrDemandVector);
    witGetParts(dImpWR->constWitRun(difEssenPtr), &listLen, &partList);

    size_t j = 0; // Pulled out of the for below by RW2STL
    for (j = 0 ; j < listLen ; j++ )
      {
        witGetPartDemands(dImpWR->constWitRun(difEssenPtr), partList[j],
	                  &lenDemandList, &demandList);
        size_t i = 0; // Pulled out of the for below by RW2STL
        for (i = 0 ; i < lenDemandList ; i++ )
          {
	    std::string dn(demandList[i]);
            if ((dImpWR->*isA)(std::string(partList[j]),dn))
	      {     
                LgFrDemand demand = 
		  difEssenPtr->createAndInsertDemand(dn, partList[j]);
                retVal.push_back(demand);
	      } 
	      portableFree(demandList[i]);
	  }
	portableFree(demandList);
	portableFree(partList[j]); 
      }
    portableFree(partList);
    return &retVal;
} 

// difWitRunGetCommittedDemands global function (registering in the attribute table).
// Get committed demands from WIT and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of committed demands).
void *
difWitRunGetCommittedDemands(
  const LgFrDataInterfaceImplementation * dImp,
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetDemands(
      dImp,
      difEssenPtr, 
      & LgFrDataInterfaceImplementationFromWitRun::isACommittedDemand,
      status);
}

// difWitRunGetNewOpportunityDemands global function (registering in the attribute table).
// Get new opportunity demands from WIT and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of new opportunity demands).
void *
difWitRunGetNewOpportunityDemands(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetDemands(
      dImp,
      difEssenPtr, 
      & LgFrDataInterfaceImplementationFromWitRun::isANewOpDemand,
      status);
}

// difWitRunGetFirmForecastDemands global function (registering in the attribute table).
// Get firm forcast demands from WIT and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of firm forcast demands).
void *
difWitRunGetFirmForecastDemands(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetDemands(
      dImp,
      difEssenPtr, 
      & LgFrDataInterfaceImplementationFromWitRun::isAFirmForecastDemand,
      status);
}

// difWitRunGetRiskForecastDemands global function (registering in the attribute table).
// Get risk forcast demands from WIT and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of risk forcast demands).
void *
difWitRunGetRiskForecastDemands(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  return difWitRunGetDemands(
      dImp,
      difEssenPtr, 
      & LgFrDataInterfaceImplementationFromWitRun::isARiskForecastDemand,
      status);
}

// -------------------- ---------------------------------------------------
// Golbal functions to obtain demands attributes
// ------------------------------------------------------------------------



// Global function to get some demand attributes, such as,
// demandVol, getObj1CumShipReward, getObj1ShipReward
// (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetDemandAttrTimeVecFloat(
    const LgFrDataInterfaceImplementation * dImp,
      const LgFrItemPtrVector* itemPtrOrdVecPtr,
      apiFuncGetDemandAttrTimeVecFloat  apiFunc,
             LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) dImp; 

  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve ( dv.size() );      
  float * attrVal;
  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int calNp(calendar.nPeriods());  // # periods in scenario calendar
  int witNp;                       // # periods in wit data file

  LgFrTimeVecFloat tv(calNp);
  witGetNPeriods(dImpWR->constWitRun(difEssenPtr), &witNp);
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) 
  {
    apiFunc(dImpWR->constWitRun(difEssenPtr), 
	    ((LgFrDemand*)dv[i])->partPtr()->name().c_str(),
	    dv[i]->name().c_str(), &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNp, witNp); j++)
       tv[j] = attrVal[j];
    retVal.push_back( tv ); 
    portableFree(attrVal);
  }
  return &retVal;
}

// Global function to get some demand attributes, such as,
// demandPriority
// (registered in the attribute table).

// Should return a LgFrVectorTimeVecInt object, since LgFrTimeVecInt
// has not yet been implemented, now,
// simply returns a LgFrTimeVecFloatVector object.
void *
difWitRunGetDemandAttrTimeVecInt(
    const LgFrDataInterfaceImplementation * dImp,
      const LgFrItemPtrVector* itemPtrOrdVecPtr,
      apiFuncGetDemandAttrTimeVecInt apiFunc,
             LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) dImp; 

  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve ( dv.size() );      
  int * attrVal;
  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int calNp(calendar.nPeriods());  // # periods in scenario calendar
  int witNp;                       // # periods in wit data file

  LgFrTimeVecFloat tv(calNp);
  witGetNPeriods(dImpWR->constWitRun(difEssenPtr), &witNp);
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) 
  {
    apiFunc(dImpWR->constWitRun(difEssenPtr), 
	        ((LgFrDemand*)dv[i])->partPtr()->name().c_str(),
	        dv[i]->name().c_str(),
            &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNp, witNp); j++)
       tv[j] = (float)attrVal[j];
    retVal.push_back( tv ); 
    portableFree(attrVal);
  }
  return &retVal;
}

// difWitRunGetDemandVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetDemandVol(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetDemandAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetDemandDemandVol,
	  status, difEssenPtr); 
}

// difWitRunGetDemanObj1CumShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetDemandObj1CumShipReward(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetDemandAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetDemandObj1CumShipReward,
	  status, difEssenPtr); 
}

// difWitRunGetDemanObj1ShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difWitRunGetDemandObj1ShipReward(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetDemandAttrTimeVecFloat
         (difImp, itemPtrOrdVecPtr, witGetDemandObj1ShipReward,
	  status, difEssenPtr); 
}

// difWitRunGetDemanPriority global function (registered in the attribute table).
// Return: a LgFrVectorTimeVecInt object.
//
// Note that priority should be a TimeVecInt, and not  TimeVecFloat.
// should return LgFrVectorTimeVecInt jmt 7/21/95, need to implement TimeVectInt class.
// Now, simply returns a LgFrTimeVecFloatVector object.

void *
difWitRunGetDemandPriority(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  return difWitRunGetDemandAttrTimeVecInt
         (difImp, itemPtrOrdVecPtr, witGetDemandPriority,
	  status, difEssenPtr); 
}

//--------------------------------------------------------------------
//  
//   Global function to define BOM
//
//-------------------------------------------------------------------

void*
difWitRunDefineBom(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
    LgFrError &, // status, 
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
   int listLen,i,j;
   char * * partList;
   int nBomEntries;
   witAttr category;
   char * consumedPart;
   float usageRate,usageTime;
   int  earliestPeriod;
   int fallout, latestPeriod;
   witBoolean  mandEC;
   int nSubBom;
   float * obj1SubCost;
   float  obj2SubPenalty;

   const LgFrCalendar& calendar = difEssenPtr->calendar();
   int calNP(calendar.nPeriods());  // # periods in scenario calendar

   LgFrDataInterfaceImplementationFromWitRun * dImpWR 
     = (LgFrDataInterfaceImplementationFromWitRun * ) difImp; 

   WitRun* eater = 
     ((LgFrDataInterfaceEssentialsFromScenario*)difEssenPtr)
     ->mutableWitRun();

   witGetParts (dImpWR->constWitRun(difEssenPtr), &listLen, &partList);
   for (i= 0; i < listLen ; i++)
     {
       witGetPartCategory(dImpWR->constWitRun(difEssenPtr), partList[i], &category);
       if(category == WitPRODUCT ) 
         {
           witGetPartNBomEntries(dImpWR->constWitRun(difEssenPtr), partList[i], &nBomEntries);
           for (j = 0 ; j < nBomEntries ; j++)
             {
               witGetBomEntryConsumedPart(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &consumedPart);
               witAddBomEntry(eater, partList[i],consumedPart);
               witGetBomEntryUsageRate(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &usageRate);
               witGetBomEntryEarliestPeriod(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &earliestPeriod);
               witGetBomEntryFallout(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &fallout);
               witGetBomEntryLatestPeriod(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &latestPeriod);
               witGetBomEntryMandEC(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &mandEC);
               witGetBomEntryUsageTime(dImpWR->constWitRun(difEssenPtr),partList[i],j,
                                          &usageTime);
               witSetBomEntryUsageRate(eater, partList[i], 
                                j, usageRate);
               witSetBomEntryEarliestPeriod(eater, partList[i], 
                                j, size_tMin(calNP-1,earliestPeriod) );
               witSetBomEntryFallout(eater, partList[i], 
                                j, fallout);
               witSetBomEntryLatestPeriod(eater, partList[i], 
                                j, size_tMin(calNP-1,latestPeriod) );
               witSetBomEntryMandEC(eater, partList[i], 
                                j, mandEC);
               witSetBomEntryUsageTime(eater, partList[i], 
                                j, usageTime);
               witGetBomEntryNSubsBomEntries(dImpWR->constWitRun(difEssenPtr), partList[i], j,
                                             &nSubBom);
               size_t k = 0; // Pulled out of the for below by RW2STL
               for (k = 0; k < nSubBom ; k++)
                 {
                   
                   witAddSubsBomEntry(eater, partList[i], j, consumedPart);
                   witGetSubsBomEntryUsageRate(dImpWR->constWitRun(difEssenPtr), partList[i],
                                               j, k, &usageRate);
                   witGetSubsBomEntryEarliestPeriod(dImpWR->constWitRun(difEssenPtr), partList[i],
                                               j, k, &earliestPeriod);
                   witGetSubsBomEntryFallout(dImpWR->constWitRun(difEssenPtr), partList[i],
                                               j, k, &fallout);
                   witGetSubsBomEntryLatestPeriod(dImpWR->constWitRun(difEssenPtr), partList[i],
                                               j, k, &latestPeriod);
                   witGetSubsBomEntryObj1SubCost(dImpWR->constWitRun(difEssenPtr), partList[i], j,
                                               k, &obj1SubCost);
                   witSetSubsBomEntryUsageRate(eater, partList[i], j,
                                               k, usageRate);
                   witSetSubsBomEntryEarliestPeriod(eater, partList[i], j,
                                             k, 
                                             size_tMin(calNP-1,earliestPeriod));
                   witSetSubsBomEntryFallout(eater, partList[i], j,
                                               k, fallout);
                   witSetSubsBomEntryLatestPeriod(eater, partList[i], j,
                                             k, 
                                             size_tMin(calNP-1,latestPeriod));
                   witSetSubsBomEntryObj1SubCost(eater, partList[i], j,
                                               k, obj1SubCost);
                 }
                                        
                 portableFree(consumedPart);                       

             }
         }
       portableFree(partList[i]);
     }
   portableFree(partList);
   return 0;
}

// -----------------------------------------------------------------------
//  register functions
// -----------------------------------------------------------------------

void
registerWitRunDifImpFunctions(
    LgFrDataInterfaceImplementation * dImpWR) 
{
// Globle function for raw parts
// Register difWitRun global functions for
//   unitcost, procCost, obj1ScrapCost, obj1StockCost, and supplyVol.

dImpWR->registerFunction("rawUnitCost", material, part,
                            vectorFloat, difWitRunGetPartUnitCost);
dImpWR->registerFunction("rawProcCost", material, part,
                            vectorFloat, difWitRunGetPartProcCost);
dImpWR->registerFunction("rawConstrained", material, part,
                            vectorInt, difWitRunGetPartConstrained);
dImpWR->registerFunction("rawProcLeadTime", material, part,
                            timeVecFloat, difWitRunGetPartProcLeadTime);
dImpWR->registerFunction("rawObj1ScrapCost", material, part,
                            timeVecFloat, difWitRunGetPartObj1ScrapCost);
dImpWR->registerFunction("rawObj1StockCost", material, part,
                            timeVecFloat, difWitRunGetPartObj1StockCost);
dImpWR->registerFunction("rawSupplyVol", material, part,
                            timeVecFloat, difWitRunGetPartSupplyVol);


// Global functions for product parts.
// Register difWitRun global functions for
//   unitcost, procCost, constrained, yiels, procLeadTime, cycleTime, 
//   obj1ProdCost, obj1ScrapCost, obj1StockCost, supplyVol, and minLotSize. 

dImpWR->registerFunction("productUnitCost", material, part,
                            vectorFloat, difWitRunGetPartUnitCost);
dImpWR->registerFunction("productProcCost", material, part,
                            vectorFloat, difWitRunGetPartProcCost);
dImpWR->registerFunction("productConstrained", material, part,
                            vectorInt, difWitRunGetPartConstrained);
dImpWR->registerFunction("productYield", material, part,
                            vectorInt, difWitRunGetProductYield);
dImpWR->registerFunction("productYieldFloat", material, part,
                            timeVecFloat, difWitRunGetProductYieldFloat);
dImpWR->registerFunction("productProcLeadTime", material, part,
                            timeVecFloat, difWitRunGetPartProcLeadTime);
dImpWR->registerFunction("productCycleTime", material, part,
                           timeVecFloat , difWitRunGetProductCycleTime);
dImpWR->registerFunction("productObj1ProdCost", material, part,
                            timeVecFloat, difWitRunGetProductObj1ProdCost);
dImpWR->registerFunction("productObj1ScrapCost", material, part,
                            timeVecFloat, difWitRunGetPartObj1ScrapCost);
dImpWR->registerFunction("productObj1StockCost", material, part,
                            timeVecFloat, difWitRunGetPartObj1StockCost);
dImpWR->registerFunction("productSupplyVol", material, part,
                            timeVecFloat, difWitRunGetPartSupplyVol);
dImpWR->registerFunction("productMinLotSize", material, part,
                            timeVecFloat, difWitRunGetProductMinLotSize);
dImpWR->registerFunction("productIncLotSize", material, part,
                            timeVecFloat, difWitRunGetProductIncLotSize);


// Global functions for capacity parts.
// Register difWitRun global functions for
//   unitcost, constrained, obj1ScrapCost, and supplyVol 

dImpWR->registerFunction("capacityUnitCost", material, part,
                            vectorFloat, difWitRunGetPartUnitCost);
dImpWR->registerFunction("capacityConstrained", material, part,
                            vectorInt, difWitRunGetPartConstrained);
dImpWR->registerFunction("capacityObj1ScrapCost", material, part,
                            timeVecFloat, difWitRunGetPartObj1ScrapCost);
dImpWR->registerFunction("capacitySupplyVol", material, part,
                            timeVecFloat, difWitRunGetPartSupplyVol);


// Global functions for demands
// Register difWitRun global functions for
//  grossRev, demandVol, Obj1CumShipReward, priority, and obj1ShipReward.

dImpWR->registerFunction("demandGrossRev", demandType, demand,
                            vectorFloat, difWitRunGetDemandGrossRev);
dImpWR->registerFunction("demandVol", demandType, demand,
                            timeVecFloat, difWitRunGetDemandVol);
dImpWR->registerFunction("demandObj1CumShipReward", demandType, demand,
                            timeVecFloat, difWitRunGetDemandObj1CumShipReward);
dImpWR->registerFunction("demandObj1ShipReward", demandType, demand,
                            timeVecFloat, difWitRunGetDemandObj1ShipReward);
dImpWR->registerFunction("demandPriority", demandType, demand,
                            timeVecFloat,difWitRunGetDemandPriority );


// Parts table, register globle functions from difWitR, 7/19/95 DW 
dImpWR->registerFunction("rawParts", material, part,
			   orderedVecPart, difWitRunGetRawParts);
dImpWR->registerFunction("productParts", material, part,
			   orderedVecPart, difWitRunGetProductParts);
dImpWR->registerFunction("capacityParts", material, part,
			   orderedVecPart, difWitRunGetCapacityParts);

// using globle function from difWitR, 7/19/95 DW
dImpWR->registerFunction("committedDemands",demandType , demand,
			   orderedVecDemand, difWitRunGetCommittedDemands);
dImpWR->registerFunction("newOpportunityDemands", demandType, demand,
			   orderedVecDemand, difWitRunGetNewOpportunityDemands);
dImpWR->registerFunction("firmForecastDemands", demandType, demand,
			   orderedVecDemand, difWitRunGetFirmForecastDemands);
dImpWR->registerFunction("riskForecastDemands", demandType, demand,
			   orderedVecDemand, difWitRunGetRiskForecastDemands);
// Register define bom globle function
dImpWR->registerFunction("defineBom", material, part,
                            timeVecFloat, difWitRunDefineBom);

}

LgFrDataInterfaceImplementation * createWitRunDifImp(WitRun * wr)
{
   return new LgFrDataInterfaceImplementationFromWitRun(
                       wr,
                       "RiskForecast.*",
                       "FirmForecast.*",
                       "NewOps.*");
} 

// Free up any resources
void
LgFrDataInterfaceImplementationFromWitRun::deleteExtraResources()
{
  // Nothing to do here in base class
}



// -----------------------------------------------------------------------
//  standard methods
// -----------------------------------------------------------------------


// Return witRun
WitRun *  
LgFrDataInterfaceImplementationFromWitRun::constWitRun(
const LgFrDataInterfaceEssentials* difEssenPtr)
const
{
  LgFrDataInterfaceImplementationFromWitRun * const localThis =
        ( LgFrDataInterfaceImplementationFromWitRun * const ) this;
  if ( !validWitRun() ) localThis->witRunVeneerPtr_ = new LgFrWitRunVeneer;
  return witRunVeneerPtr_->constWitRun();
}

WitRun *  
LgFrDataInterfaceImplementationFromWitRun::mutableWitRun(
    const LgFrDataInterfaceEssentials*)
{
  if ( !validWitRun() ) witRunVeneerPtr_ = new LgFrWitRunVeneer;
  return witRunVeneerPtr_->mutableWitRun();
}

bool
LgFrDataInterfaceImplementationFromWitRun::validWitRun()
const
{
  return witRunVeneerPtr_!=0;
}

void
LgFrDataInterfaceImplementationFromWitRun::deleteWitRun()
{
  delete witRunVeneerPtr_;
  witRunVeneerPtr_ = 0;
}

// Make clone copy of object
LgFrDataInterfaceImplementation *
LgFrDataInterfaceImplementationFromWitRun::clone()
const
{
  return new LgFrDataInterfaceImplementationFromWitRun(*this);
}

// Destructor
LgFrDataInterfaceImplementationFromWitRun::~LgFrDataInterfaceImplementationFromWitRun()
{
  delete witRunVeneerPtr_;
}

// Assignment operator.
LgFrDataInterfaceImplementationFromWitRun&
LgFrDataInterfaceImplementationFromWitRun::operator=(
  const LgFrDataInterfaceImplementationFromWitRun& rhs)
{
  if (this != &rhs) {           // Check for assignment to self
    LgFrDataInterfaceImplementation::operator=  (rhs);     
     delete witRunVeneerPtr_;

     if ( rhs.witRunVeneerPtr_ != 0 ) 
       witRunVeneerPtr_ = new LgFrWitRunVeneer( *(rhs.witRunVeneerPtr_) );
     else
       witRunVeneerPtr_ = 0;

     riskForecastRE_ = rhs.riskForecastRE_;
     firmForecastRE_ = rhs.firmForecastRE_;
     newOpsRE_ = rhs.newOpsRE_;
  }
  return *this;
}

// Copy constructor
LgFrDataInterfaceImplementationFromWitRun::LgFrDataInterfaceImplementationFromWitRun(
  const LgFrDataInterfaceImplementationFromWitRun& source)
:
   LgFrDataInterfaceImplementation(source),
   witRunVeneerPtr_(0),
   riskForecastRE_(source.riskForecastRE_),
   firmForecastRE_(source.firmForecastRE_),
   newOpsRE_(source.newOpsRE_)
{
   if ( source.witRunVeneerPtr_ != 0 ) 
     witRunVeneerPtr_ = new LgFrWitRunVeneer( *(source.witRunVeneerPtr_) );
   else
     witRunVeneerPtr_ = 0;
}

// Preferred Constructor
LgFrDataInterfaceImplementationFromWitRun::LgFrDataInterfaceImplementationFromWitRun(
   WitRun * witRun,                                                      
   const std::string & rf, 
   const std::string & ff, 
   const std::string & no)
:
   LgFrDataInterfaceImplementation(),
   witRunVeneerPtr_(0),
   riskForecastRE_(rf),
   firmForecastRE_(ff),
   newOpsRE_(no)
{
   if ( witRun != 0 ) witRunVeneerPtr_ = new LgFrWitRunVeneer( witRun );
   std::string t = makeTitle(); 
   LgFrDataInterfaceImplementation::title(t);
}

// Default Constructor
// This is a private method
LgFrDataInterfaceImplementationFromWitRun::LgFrDataInterfaceImplementationFromWitRun()
:
   LgFrDataInterfaceImplementation(),
   witRunVeneerPtr_(0),
   riskForecastRE_(defaultRiskForecast),
   firmForecastRE_(defaultFirmForecast),
   newOpsRE_(defaultNewOps)
{
   // Nothing to do here
}     

#ifdef NDEBUG
#undef NDEBUG
#endif
// Tests this class.  Only returns if all tests passed
// 6/29/95 DW
void
LgFrDataInterfaceImplementationFromWitRun::contextTest
  (
   LgFrDataInterface    	* tdif1Ptr,	// testScenario1's
   LgFrLastProblemSolved        & lps,          // testScenario1's
   LgFrDataInterface    	* ts1dupDifPtr, // testScenario1dup's
   LgFrDataInterface    	* tdif2Ptr,	// testScenario2's
   const LgFrScenario           * scenPtr)	
{
  const float fltEps = .0001f;
  LgFrDataInterface& tdif1 = *tdif1Ptr;
  LgFrDataInterface& ts1dupDif = *ts1dupDifPtr;
  LgFrDataInterface& tdif2 = *tdif2Ptr;
  LgFrDataInterfaceImplementation* dimp 
      = tdif1.dataInterfaceImplementation();
  LgFrDataInterfaceImplementation* dimptsi 
      = ts1dupDif.dataInterfaceImplementation();
  LgFrDataInterfaceImplementation* dimp2 
      = tdif2.dataInterfaceImplementation();

  // Register all functions
  registerWitRunDifImpFunctions(dimp);
  registerWitRunDifImpFunctions(dimp2);

  // Test title method
  assert( tdif1.title() == "Diner");
  assert( ts1dupDif.title() == "Diner");
  assert( tdif2.title() == "Diner");
  assert( dimp->title() == "Diner");
  assert( dimptsi->title() == "Diner");
  assert( dimp2->title() == "Diner");
                    
  // Test get parts global functions
  LgFrDataInterfaceEssentialsFromScenario difEssen(scenPtr);
  LgFrPartVector partpv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	partpv, itemSubTypeStr, "rawParts" , &difEssen);
  LgFrPartVector raw = *rawPartsPtr;
  size_t t = 0; // Pulled out of the for below by RW2STL
  for(t = 0 ; t < 7 ; t++)
    witAddPart( lps.witRun(), raw[t].name().c_str(), WitRAW);
  assert( raw.size() == 7 );
  assert( raw[0].name() == "Egg" );
  assert( raw[1].name() == "Butter" );

  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	partpv, itemSubTypeStr, "productParts", &difEssen );
  LgFrPartVector product = * productPartsPtr;
  for( t = 0 ; t < 10 ; t++)
    witAddPart( lps.witRun(), product[t].name().c_str(), WitPRODUCT);
  assert( product.size() == 10 );
  assert( product[9].name() == "HamEgg_Sand" );

  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	partpv, itemSubTypeStr, "capacityParts", &difEssen );
  LgFrPartVector capacity = * capacityPartsPtr;
  for( t = 0 ; t < 2 ; t++)
    witAddPart( lps.witRun(), capacity[t].name().c_str(), WitCAPACITY);
  assert( capacity.size() == 2 );
  assert( capacity[0].name() == "Skillet" );

  // Test get raw attributes global functions
  {
  LgFrFloatVector* unitCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
	raw,itemSubTypeStr,"rawUnitCost", &difEssen ); 
  assert( unitCostVectPtr->size() == 7 );
  assert( (*unitCostVectPtr)[0] == 1.5 );

  LgFrIntVector* constrainedVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
       raw,itemSubTypeStr,"rawConstrained", &difEssen );
  assert( constrainedVectPtr->size() == 7 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrainedVectPtr->size(); i++) 
      assert( (*constrainedVectPtr)[i] );

  LgFrFloatVector* procCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
	raw,itemSubTypeStr,"rawProcCost", &difEssen ); 
  assert( procCostVectPtr->size() == 7 );
  assert( (*procCostVectPtr)[0] == 1.5 );

  LgFrTimeVecFloatVector* procLeadTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       raw,itemSubTypeStr,"rawProcLeadTime", &difEssen);
  assert( procLeadTimeVectPtr->size() == 7 );
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<procLeadTimeVectPtr->size(); j++){
      assert( (*procLeadTimeVectPtr)[j] == 0.0 );  }

  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	raw,itemSubTypeStr,"rawObj1ScrapCost", &difEssen );
  assert( obj1ScrapCostVectPtr->size() == 7 );
  assert( (*obj1ScrapCostVectPtr)[0] == 
	  LgFrTimeVecFloat(8,".01 .01 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1StockCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	raw,itemSubTypeStr,"rawObj1StockCost", &difEssen );
  assert( obj1StockCostVectPtr->size() == 7 );
  assert( (*obj1StockCostVectPtr)[0] == 
	  LgFrTimeVecFloat(8,".02 .02 0 0 0 0 0 0") ); 
 
  LgFrTimeVecFloatVector* supplyVolVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       raw,itemSubTypeStr,"rawSupplyVol", &difEssen);
  assert( supplyVolVectPtr->size() == 7 );
  assert( (*supplyVolVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 5.0 2.0 0 0 0 0 0 0") );
  }

  // Test get product attribute global functions
  {
  LgFrIntVector* yieldVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
       product,itemSubTypeStr,"productYield", &difEssen);
  assert( yieldVectPtr->size() == 10 );
  assert ((*yieldVectPtr)[0] == 99 );

  LgFrTimeVecFloatVector* cycleTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       product,itemSubTypeStr,"productCycleTime", &difEssen);
  assert( cycleTimeVectPtr->size() == 10 );
  assert( (*cycleTimeVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 0.3 0.3 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ProdCostVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
     product,itemSubTypeStr,"productObj1ProdCost", &difEssen);
  assert( obj1ProdCostVectPtr->size() == 10 );
  assert( (*obj1ProdCostVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 0.5 0.5 0 0 0 0 0 0") );

  LgFrFloatVector* unitCostVectPtr2
    = (LgFrFloatVector*) tdif1.partAttribute(
	product,itemSubTypeStr,"productUnitCost", &difEssen); 
  assert( unitCostVectPtr2->size() == 10 );
  assert ( fabs((*unitCostVectPtr2)[0] - 1.2) < fltEps );

  LgFrIntVector* constrainedVectPtr2
   = (LgFrIntVector*) tdif1.partAttribute(
       product,itemSubTypeStr,"productConstrained", &difEssen);
  assert( constrainedVectPtr2->size() == 10 );
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<constrainedVectPtr2->size(); k++) 
      assert( (*constrainedVectPtr2)[k] ); 

  LgFrFloatVector* procCostVectPtr2
    = (LgFrFloatVector*) tdif1.partAttribute(
	product,itemSubTypeStr,"productProcCost", &difEssen); 
  assert( procCostVectPtr2->size() == 10 );
  assert ( fabs((*procCostVectPtr2)[0] - 1.2) < fltEps );
  
  LgFrTimeVecFloatVector* obj1ProdCostVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
     product,itemSubTypeStr,"productObj1ProdCost", &difEssen);
  assert( obj1ProdCostVectPtr2->size() == 10 );
  assert( (*obj1ProdCostVectPtr2)[0] == 
	  LgFrTimeVecFloat(8," 0.5 0.5 0 0 0 0 0 0") );

  // procLeadTime functions for product has not been implemented yet.
  LgFrTimeVecFloatVector* procLeadTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       product,itemSubTypeStr,"productProcLeadTime", &difEssen);
  assert( procLeadTimeVectPtr->size() == 10 );
  assert( (*procLeadTimeVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 0.3 0.3 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	product,itemSubTypeStr,"productObj1ScrapCost", &difEssen );
  assert( obj1ScrapCostVectPtr2->size() == 10 );
  assert( (*obj1ScrapCostVectPtr2)[0] == 
	  LgFrTimeVecFloat(8," 0.23 0.23 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1StockCostVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	product,itemSubTypeStr,"productObj1StockCost", &difEssen );
  assert( obj1StockCostVectPtr2->size() == 10 );
  assert( (*obj1StockCostVectPtr2)[0] == 
	  LgFrTimeVecFloat(8," 0.24 0.24 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* supplyVolVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       product,itemSubTypeStr,"productSupplyVol", &difEssen);
  assert( supplyVolVectPtr2->size() == 10 );
  assert( (*supplyVolVectPtr2)[0] == 
	  LgFrTimeVecFloat(8," 0.01 0.01 0 0 0 0 0 0") );
  }

  // Test get capacity attributes global functions
  {
  LgFrFloatVector* unitCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
	capacity,itemSubTypeStr,"capacityUnitCost", &difEssen); 
  assert( unitCostVectPtr->size() == 2 );
  assert ( fabs((*unitCostVectPtr)[0] - 1.11 ) < fltEps );

  LgFrIntVector* constrainedVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
       capacity,itemSubTypeStr,"capacityConstrained", &difEssen);
  assert( constrainedVectPtr->size() == 2 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrainedVectPtr->size(); i++) 
      assert( (*constrainedVectPtr)[i] );

  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	capacity,itemSubTypeStr,"capacityObj1ScrapCost", &difEssen );
  assert( obj1ScrapCostVectPtr->size() == 2 );
  assert( (*obj1ScrapCostVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 0.33 0.22 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* supplyVolVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
       capacity,itemSubTypeStr,"capacitySupplyVol", &difEssen);
  assert( supplyVolVectPtr->size() == 2 );
  assert( (*supplyVolVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 15 20 0 0 0 0 0 0") );
  }

// Test Get Demands global functions
  LgFrDemandVector demandpv;

  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	demandpv, "committedDemands", &difEssen );
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 7 ); 
  
  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	demandpv, "newOpportunityDemands", &difEssen );
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 1 );

  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	demandpv, "firmForecastDemands", &difEssen );
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 1 );

  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	demandpv, "riskForecastDemands", &difEssen );
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 1 );

  // Test get demand attributes global functions
  LgFrFloatVector* grossRevVectPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
       committed,"demandGrossRev", &difEssen);
  assert( grossRevVectPtr->size() == 7 );
  assert ( fabs((*grossRevVectPtr)[0] - 3.1 ) < fltEps );

  grossRevVectPtr = (LgFrFloatVector*)
      tdif1.demandAttribute(newOpportunity,"demandGrossRev", &difEssen );
  assert( grossRevVectPtr->size() == 1 );
  assert ( fabs((*grossRevVectPtr)[0] - 3.55 ) < fltEps );

  grossRevVectPtr = (LgFrFloatVector*)
      tdif1.demandAttribute(firmForecast,"demandGrossRev", &difEssen );
  assert( grossRevVectPtr->size() == 1 );
  assert ( fabs((*grossRevVectPtr)[0] - 1.23 ) < fltEps );
    
  grossRevVectPtr = (LgFrFloatVector*)
      tdif1.demandAttribute(riskForecast,"demandGrossRev", &difEssen );
  assert( grossRevVectPtr->size() == 1 );
  assert ( fabs((*grossRevVectPtr)[0] - 2.45 ) < fltEps );

  LgFrTimeVecFloatVector * demandVolVectPtr = (LgFrTimeVecFloatVector *)
      tdif1.demandAttribute(committed, "demandVol", &difEssen);
  assert(demandVolVectPtr->size() == 7 );
  assert( (*demandVolVectPtr)[0] == 
	  LgFrTimeVecFloat(8," 0.14 0.14 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector * demandVolVectPtr2 = (LgFrTimeVecFloatVector *)
      tdif1.demandAttribute(newOpportunity, "demandVol", &difEssen);
  assert(demandVolVectPtr2->size() == 1 );
  assert( (*demandVolVectPtr2)[0] == 
	  LgFrTimeVecFloat(8," 3 4 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector * demandVolVectPtr3 = (LgFrTimeVecFloatVector *)
      tdif1.demandAttribute(firmForecast, "demandVol", &difEssen);
  assert(demandVolVectPtr3->size() == 1 );
  assert( (*demandVolVectPtr3)[0] == 
	  LgFrTimeVecFloat(8," 4 2 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector * demandVolVectPtr4 = (LgFrTimeVecFloatVector *)
      tdif1.demandAttribute(riskForecast, "demandVol", &difEssen);
  assert(demandVolVectPtr4->size() == 1 );
  assert( (*demandVolVectPtr4)[0] == 
	  LgFrTimeVecFloat(8," 0.27 0.27 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
	committed, "demandObj1CumShipReward", &difEssen);
  assert(obj1CumShipRewardVectPtr->size() == 7 );
  assert( (*obj1CumShipRewardVectPtr)[0] ==
          LgFrTimeVecFloat(8," 0.21 0.21 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
newOpportunity, "demandObj1CumShipReward", &difEssen);
  assert(obj1CumShipRewardVectPtr2->size() == 1 );
  assert( (*obj1CumShipRewardVectPtr2)[0] ==
          LgFrTimeVecFloat(8," 0.09 0.09 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr3
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
	firmForecast,"demandObj1CumShipReward", &difEssen);
  assert(obj1CumShipRewardVectPtr3->size() == 1 );
  assert( (*obj1CumShipRewardVectPtr3)[0] ==
          LgFrTimeVecFloat(8," 0.17 0.17 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr4
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
	riskForecast, "demandObj1CumShipReward", &difEssen);
  assert(obj1CumShipRewardVectPtr4->size() == 1 );
  assert( (*obj1CumShipRewardVectPtr4)[0] ==
          LgFrTimeVecFloat(8," 0.07 0.07 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
       committed, "demandObj1ShipReward", &difEssen);
  assert(obj1ShipRewardVectPtr->size() == 7 );
  assert( (*obj1ShipRewardVectPtr)[0] ==
          LgFrTimeVecFloat(8," 3.81 3.81 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
       newOpportunity, "demandObj1ShipReward", &difEssen);
  assert(obj1ShipRewardVectPtr2->size() == 1 );
  assert( (*obj1ShipRewardVectPtr2)[0] ==
          LgFrTimeVecFloat(8," 3.5 3.5 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr3
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
       firmForecast, "demandObj1ShipReward", &difEssen);
  assert(obj1ShipRewardVectPtr3->size() == 1 );
  assert( (*obj1ShipRewardVectPtr3)[0] ==
          LgFrTimeVecFloat(8," 1.12 1.12 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr4
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
       riskForecast, "demandObj1ShipReward", &difEssen);
  assert(obj1ShipRewardVectPtr4->size() == 1 );
  assert( (*obj1ShipRewardVectPtr4)[0] ==
          LgFrTimeVecFloat(8," 2.19 2.19 0 0 0 0 0 0") );

  // Test BOM
  LgFrDataInterfaceImplementationFromWitRun * dImpWR = (
      LgFrDataInterfaceImplementationFromWitRun * ) dimp;
  tdif1.partAttribute(
      partpv, itemSubTypeStr, "defineBom" , &difEssen);
  int nBomEntries, retInt;
  witBoolean retBool;
  float retFloat;
  char * consumedPartName; 
  witGetPartNBomEntries( lps.witRun(), "Plain_Omlet", &nBomEntries);
  assert( nBomEntries == 3);
  witGetBomEntryConsumedPart(lps.witRun(), "Plain_Omlet", 0,
                             &consumedPartName);
  assert ( std::string (consumedPartName) == std::string ("Skillet"));
  portableFree (consumedPartName);
  witGetBomEntryUsageRate( lps.witRun(), "Plain_Omlet", 0,
                           &retFloat);
  assert ( fabs(retFloat - 3.0) < fltEps );
  witGetBomEntryConsumedPart(lps.witRun(), "Plain_Omlet", 2,
                             &consumedPartName);
  assert ( std::string (consumedPartName) == std::string ("Butter"));
  portableFree (consumedPartName);
  witGetBomEntryEarliestPeriod(lps.witRun(), "Plain_Omlet", 2,
                               &retInt);
  assert ( retInt == 1 );
  witGetBomEntryLatestPeriod(lps.witRun(), "Plain_Omlet", 2,
                               &retInt);
  assert ( retInt == 1 );
  witGetBomEntryMandEC(lps.witRun(), "Plain_Omlet", 2,
                               &retBool);
  assert ( retBool );
  witGetBomEntryUsageRate(lps.witRun(), "Plain_Omlet", 2,
                               &retFloat);
  assert ( fabs(retFloat - 1.0) < fltEps );
  witGetBomEntryUsageTime(lps.witRun(), "Plain_Omlet", 2,
                               &retFloat);
  assert ( fabs(retFloat - 0.1) < fltEps );
}
@


1.6
log
@Changed (this-> ... ::operator= ) to ...::operator =
@
text
@a171 12
// difWitRunGetPartUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difWitRunGetPartUnitCost(
  const LgFrDataInterfaceImplementation * dImp,
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr) 
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
     = (LgFrDataInterfaceImplementationFromWitRun * ) dImp;
a172 12
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  float attrVal;
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartUnitCost(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &attrVal);
    retVal.push_back( attrVal );
  }
  return &retVal;
}
a656 17
// difWitRunGetDemandGrossRev global function (registering in the attribute table).
// Compute total demand gross revenue with data from WIT.
// Return: a LgFrFloatVector object (vector of demand gross revenues).
void *
difWitRunGetDemandGrossRev(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{

  LgFrDataInterfaceImplementationFromWitRun * dImpWR 
      = (LgFrDataInterfaceImplementationFromWitRun * ) difImp;   

  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
a657 11
  float grossRev;
  
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    witGetDemandGrossRev(
       dImpWR->constWitRun(difEssenPtr), (((LgFrDemand*)dv[i])->partPtr()->name().c_str()), 
       dv[i]->name().c_str(), &grossRev);
    retVal.push_back( grossRev );
  }
  return &retVal;
}
a896 2
                   witGetSubsBomEntryObj2SubPenalty(dImpWR->constWitRun(difEssenPtr), partList[i], j,
                                               k, &obj2SubPenalty);
a908 2
                   witSetSubsBomEntryObj2SubPenalty(eater, partList[i], j,
                                               k, obj2SubPenalty);
@


1.5
log
@Modified to build on windows laptop that was causing compiler to run out of stack space
@
text
@d1168 1
a1168 2
     (this->LgFrDataInterfaceImplementation::operator= ) (rhs);
     
@


1.4
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d1 4
@


1.3
log
@Modified to get sce to link on windows.
Code was changed to conditionally include implement statements
@
text
@d1 4
d6 1
a6 1
#include <iostream.h>
a7 2
#include <rw/rstream.h>
#include <rw/cstring.h>
d16 1
a16 6
#ifndef WIN32
// added for vacpp - vra
implement (RWGVector, int)
#endif

const RWCString 
d19 1
a19 1
const RWCString 
d26 1
a26 1
const RWCString 
d29 1
a29 1
const RWCString 
d38 1
a38 1
     RWCString t 
d48 1
a48 1
RWCString
d53 1
a53 1
    RWCString t = LgFrDataInterfaceImplementation::title(difEssenPtr);
d66 1
a66 1
RWCString
d74 2
a75 1
  RWCString titleName = RWCString( titleWR ).strip( RWCString::both );
d86 1
a86 1
// Return: a LgFrOrderedVectorPart object (vector of parts in general)
a102 4
//  took next line out because the derived class of this class also uses
//  this function.
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

d104 2
a105 2
  LgFrOrderedVectorPart * retVal
      = new LgFrOrderedVectorPart (listLen);
d110 3
a112 2
      RWCString pn(category);
      if( pn.compareTo( pn(ma) ) == 0 )
d115 1
a115 1
          retVal->insert(part);
d125 1
a125 1
// Return: a LgFrOrderedVectorPart object (vector of raw parts).
d129 1
a129 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d138 1
a138 1
// Return: a LgFrOrderedVectorPart object (vector of producible parts)
d142 1
a142 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d151 1
a151 1
// Return: a LgFrOrderedVectorPart object (vector of capacities).
d155 1
a155 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d169 1
a169 1
// it returns a LgFrVectorFloat object.
d173 1
a173 1
  const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d181 1
a181 3
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
d183 2
a184 1
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
d186 4
a189 3
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    witGetPartUnitCost(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), &attrVal);
    retVal[i] = attrVal;
d195 1
a195 1
// It returns a LgFrVectorFloat object.
d199 1
a199 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d207 1
a207 1
// It returns a LgFrVectorInt object
d211 1
a211 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
a216 4
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt( pv.entries() ));   
d218 7
a224 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  TRUE;
d230 1
a230 1
// It returns a LgFrVectorTimeVecFloat object.
d234 1
a234 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d241 4
a244 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
a251 2
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

d255 17
a271 11
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      witGetPartCategory(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), &partCategory);
      if ( partCategory == WitRAW ) retVal[i] = 0.0;
      else if (partCategory == WitPRODUCT) {
	  witGetPartCycleTime(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), 
			      &cycleTime);
	  for(size_t j = 0; j < size_tMin(calNP, witNP); j++ ){
          tv[j] = cycleTime[j];
	  }
	  retVal[i] =  tv;
	  portableFree(cycleTime);
d280 1
a280 1
// Return: a LgFrVectorTimeVecFloat object.
d284 1
a284 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d290 3
a292 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;       
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat ( pv.entries() ));
a300 2
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

d304 5
a308 3
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    apiFunc(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), &attrVal);
    for(size_t j = 0; j < size_tMin(calNP, witNP); j++ )
d311 1
a311 1
    retVal[i] =  tv;
d318 1
a318 1
// Return: a LgFrVectorTimeVecFloat object.
d322 1
a322 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d332 1
a332 1
// Return: a LgFrVectorTimeVecFloat object.
d336 1
a336 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d346 1
a346 1
// Return: a LgFrVectorTimeVecFloat object.
d350 1
a350 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d366 1
a366 1
// Return: a LgFrVectorInt object
d370 1
a370 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
a376 1
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
d378 3
a380 2
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
d382 4
a385 3
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), &yield);
    retVal[i] =  yield[0];
d393 1
a393 1
// Return: a LgFrVectorTimeVecFloat object
d397 1
a397 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d405 3
a407 2
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d417 6
a422 4
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name(), &yield);
    for(size_t j = 0; j < size_tMin(calNP, witNP); j++ ) tv[j] = (float) yield[j];
    retVal[i] =  tv;
d429 1
a429 1
// Return: a LgFrVectorTimeVecFloat object.
d433 1
a433 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d443 1
a443 1
// Return: a LgFrVectorTimeVecFloat object.
d447 1
a447 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d459 1
a459 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d471 1
a471 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d487 1
a487 1
RWBoolean
d489 3
a491 3
  RWCString /* demandedPartName */,
  RWCString demandName,
  RWCRegexp compareExpression) const
d493 2
a494 2
  if ( demandName.compareTo( demandName( compareExpression)) == 0)
    return TRUE;
d496 1
a496 1
    return FALSE;
d500 1
a500 1
RWBoolean
d502 2
a503 2
  RWCString demandedPartName,
  RWCString demandName) const
d505 1
a505 1
  RWBoolean retVal = isADemand(demandedPartName,demandName,newOpsRE_);
d514 1
a514 1
RWBoolean
d516 2
a517 2
  RWCString demandedPartName,
  RWCString demandName) const
d519 1
a519 1
  RWBoolean retVal = isADemand(demandedPartName,demandName,firmForecastRE_);
d528 1
a528 1
RWBoolean
d530 2
a531 2
  RWCString demandedPartName,
  RWCString demandName) const
d533 1
a533 1
  RWBoolean retVal = isADemand(demandedPartName,demandName,riskForecastRE_);
d542 1
a542 1
RWBoolean
d544 2
a545 2
  RWCString demandedPartName,
  RWCString demandName) const
d547 1
a547 1
  RWBoolean retVal = FALSE;
d552 1
a552 1
     return TRUE;
d557 1
a557 1
// Return: a LgFrOrderedVectorDemand object (vector of demands in general)
d564 1
a564 1
    RWBoolean
d566 1
a566 1
        (RWCString, RWCString)const,
a576 1
//    assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
d578 1
a578 1
    LgFrOrderedVectorDemand& retVal = *(new LgFrOrderedVectorDemand);
d581 2
a582 1
    for (size_t j = 0 ; j < listLen ; j++ )
d586 2
a587 1
        for (size_t i = 0 ; i < lenDemandList ; i++ )
d589 2
a590 2
	    RWCString dn(demandList[i]);
            if ((dImpWR->*isA)(RWCString(partList[j]),dn))
d594 1
a594 1
                retVal.insert(demand);
d607 1
a607 1
// Return: a LgFrOrderedVectorDemand object (vector of committed demands).
d611 1
a611 1
  const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d624 1
a624 1
// Return: a LgFrOrderedVectorDemand object (vector of new opportunity demands).
d628 1
a628 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d641 1
a641 1
// Return: a LgFrOrderedVectorDemand object (vector of firm forcast demands).
d645 1
a645 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d658 1
a658 1
// Return: a LgFrOrderedVectorDemand object (vector of risk forcast demands).
d662 1
a662 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d679 1
a679 1
// Return: a LgFrVectorFloat object (vector of demand gross revenues).
d683 1
a683 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
a689 1
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
d691 3
a693 2
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat( dv.entries() ));    
d697 2
a698 1
  for ( size_t i = 0; i < dv.entries(); i++ ) {
d700 3
a702 3
       dImpWR->constWitRun(difEssenPtr), (((LgFrDemand*)dv[i])->partPtr()->name()), 
       dv[i]->name(), &grossRev);
    retVal[i] = grossRev;
d710 1
a710 1
// Return: a LgFrVectorTimeVecFloat object.
d714 1
a714 1
      const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
a721 1
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
d723 4
a726 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;       
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat ( dv.entries() ));      
d734 3
a736 1
  for ( size_t i = 0; i < dv.entries(); i++) {
d738 4
a741 3
	    ((LgFrDemand*)dv[i])->partPtr()->name(),
	    dv[i]->name(), &attrVal);
    for(size_t j = 0; j < size_tMin(calNp, witNp); j++)
d743 1
a743 1
    retVal[i] =  tv; 
d755 1
a755 1
// simply returns a LgFrVectorTimeVecFloat object.
d759 1
a759 1
      const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
a766 1
//  assert( dImpWR->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
d768 4
a771 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;       
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat ( dv.entries() ));      
d779 3
a781 1
  for ( size_t i = 0; i < dv.entries(); i++) {
d783 5
a787 3
	    ((LgFrDemand*)dv[i])->partPtr()->name(),
	    dv[i]->name(), &attrVal);
    for(size_t j = 0; j < size_tMin(calNp, witNp); j++)
d789 1
a789 1
    retVal[i] =  tv; 
d796 1
a796 1
// Return: a LgFrVectorTimeVecFloat object.
d800 1
a800 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d810 1
a810 1
// Return: a LgFrVectorTimeVecFloat object.
d814 1
a814 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d824 1
a824 1
// Return: a LgFrVectorTimeVecFloat object.
d828 1
a828 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d842 1
a842 1
// Now, simply returns a LgFrVectorTimeVecFloat object.
d847 1
a847 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d865 1
a865 1
    const LgFrOrderedVectorItemPtr*, // itemPtrOrdVecPtr,
d930 2
a931 1
               for (size_t k = 0; k < nSubBom ; k++)
d970 1
a970 1
   return NULL;
a1109 8
// Return type identifier
isAReturnType
LgFrDataInterfaceImplementationFromWitRun::isA()
const
{
  return __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN;
}

d1130 1
a1130 1
RWBoolean
d1134 1
a1134 1
  return witRunVeneerPtr_!=NULL;
d1141 1
a1141 1
  witRunVeneerPtr_ = NULL;
d1168 1
a1168 1
     if ( rhs.witRunVeneerPtr_ != NULL ) 
d1171 1
a1171 1
       witRunVeneerPtr_ = NULL;
d1185 1
a1185 1
   witRunVeneerPtr_(NULL),
d1190 1
a1190 1
   if ( source.witRunVeneerPtr_ != NULL ) 
d1193 1
a1193 1
     witRunVeneerPtr_ = NULL;
d1199 3
a1201 3
   const RWCString & rf, 
   const RWCString & ff, 
   const RWCString & no)
d1204 1
a1204 1
   witRunVeneerPtr_(NULL),
d1209 2
a1210 2
   if ( witRun != NULL ) witRunVeneerPtr_ = new LgFrWitRunVeneer( witRun );
   RWCString t = makeTitle(); 
d1219 1
a1219 1
   witRunVeneerPtr_(NULL),
a1255 5
  // Test isA method
  assert (dimp->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
  assert (dimptsi->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);
  assert (dimp2->isA() == __LGFRDATAINTERFACEIMPLEMENTATIONFROMWITRUN);

d1266 4
a1269 4
  LgFrOrderedVectorPart partpv;
  RWCString itemSubTypeStr = "material";  
  LgFrOrderedVectorPart* rawPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1271 5
a1275 4
  LgFrOrderedVectorPart raw = *rawPartsPtr;
  for(size_t t = 0 ; t < 7 ; t++)
    witAddPart( lps.witRun(), raw[t].name(), WitRAW);
  assert( raw.entries() == 7 );
d1279 2
a1280 2
  LgFrOrderedVectorPart* productPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1282 1
a1282 1
  LgFrOrderedVectorPart product = * productPartsPtr;
d1284 2
a1285 2
    witAddPart( lps.witRun(), product[t].name(), WitPRODUCT);
  assert( product.entries() == 10 );
d1288 2
a1289 2
  LgFrOrderedVectorPart* capacityPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1291 1
a1291 1
  LgFrOrderedVectorPart capacity = * capacityPartsPtr;
d1293 2
a1294 2
    witAddPart( lps.witRun(), capacity[t].name(), WitCAPACITY);
  assert( capacity.entries() == 2 );
d1299 2
a1300 2
  LgFrVectorFloat* unitCostVectPtr
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1302 1
a1302 1
  assert( unitCostVectPtr->length() == 7 );
d1305 2
a1306 2
  LgFrVectorInt* constrainedVectPtr
   = (LgFrVectorInt*) tdif1.partAttribute(
d1308 3
a1310 2
  assert( constrainedVectPtr->length() == 7 );
  for (int i=0; i<constrainedVectPtr->length(); i++) 
d1313 2
a1314 2
  LgFrVectorFloat* procCostVectPtr
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1316 1
a1316 1
  assert( procCostVectPtr->length() == 7 );
d1319 2
a1320 2
  LgFrVectorTimeVecFloat* procLeadTimeVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1322 3
a1324 2
  assert( procLeadTimeVectPtr->length() == 7 );
  for (int j=0; j<procLeadTimeVectPtr->length(); j++){
d1327 2
a1328 2
  LgFrVectorTimeVecFloat* obj1ScrapCostVectPtr
    = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1330 1
a1330 1
  assert( obj1ScrapCostVectPtr->length() == 7 );
d1334 2
a1335 2
  LgFrVectorTimeVecFloat* obj1StockCostVectPtr
    = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1337 1
a1337 1
  assert( obj1StockCostVectPtr->length() == 7 );
d1341 2
a1342 2
  LgFrVectorTimeVecFloat* supplyVolVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1344 1
a1344 1
  assert( supplyVolVectPtr->length() == 7 );
d1351 2
a1352 2
  LgFrVectorInt* yieldVectPtr
   = (LgFrVectorInt*) tdif1.partAttribute(
d1354 1
a1354 1
  assert( yieldVectPtr->length() == 10 );
d1357 2
a1358 2
  LgFrVectorTimeVecFloat* cycleTimeVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1360 1
a1360 1
  assert( cycleTimeVectPtr->length() == 10 );
d1364 2
a1365 2
  LgFrVectorTimeVecFloat* obj1ProdCostVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1367 1
a1367 1
  assert( obj1ProdCostVectPtr->length() == 10 );
d1371 2
a1372 2
  LgFrVectorFloat* unitCostVectPtr2
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1374 1
a1374 1
  assert( unitCostVectPtr2->length() == 10 );
d1377 2
a1378 2
  LgFrVectorInt* constrainedVectPtr2
   = (LgFrVectorInt*) tdif1.partAttribute(
d1380 3
a1382 2
  assert( constrainedVectPtr2->length() == 10 );
  for (int k=0; k<constrainedVectPtr2->length(); k++) 
d1385 2
a1386 2
  LgFrVectorFloat* procCostVectPtr2
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1388 1
a1388 1
  assert( procCostVectPtr2->length() == 10 );
d1391 2
a1392 2
  LgFrVectorTimeVecFloat* obj1ProdCostVectPtr2
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1394 1
a1394 1
  assert( obj1ProdCostVectPtr2->length() == 10 );
d1399 2
a1400 2
  LgFrVectorTimeVecFloat* procLeadTimeVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1402 1
a1402 1
  assert( procLeadTimeVectPtr->length() == 10 );
d1406 2
a1407 2
  LgFrVectorTimeVecFloat* obj1ScrapCostVectPtr2
    = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1409 1
a1409 1
  assert( obj1ScrapCostVectPtr2->length() == 10 );
d1413 2
a1414 2
  LgFrVectorTimeVecFloat* obj1StockCostVectPtr2
    = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1416 1
a1416 1
  assert( obj1StockCostVectPtr2->length() == 10 );
d1420 2
a1421 2
  LgFrVectorTimeVecFloat* supplyVolVectPtr2
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1423 1
a1423 1
  assert( supplyVolVectPtr2->length() == 10 );
d1430 2
a1431 2
  LgFrVectorFloat* unitCostVectPtr
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1433 1
a1433 1
  assert( unitCostVectPtr->length() == 2 );
d1436 2
a1437 2
  LgFrVectorInt* constrainedVectPtr
   = (LgFrVectorInt*) tdif1.partAttribute(
d1439 3
a1441 2
  assert( constrainedVectPtr->length() == 2 );
  for (int i=0; i<constrainedVectPtr->length(); i++) 
d1444 2
a1445 2
  LgFrVectorTimeVecFloat* obj1ScrapCostVectPtr
    = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1447 1
a1447 1
  assert( obj1ScrapCostVectPtr->length() == 2 );
d1451 2
a1452 2
  LgFrVectorTimeVecFloat* supplyVolVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1454 1
a1454 1
  assert( supplyVolVectPtr->length() == 2 );
d1460 1
a1460 1
  LgFrOrderedVectorDemand demandpv;
d1462 2
a1463 2
  LgFrOrderedVectorDemand* committedDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1465 2
a1466 2
  LgFrOrderedVectorDemand committed = * committedDemandPtr; 
  assert( committed.entries() == 7 ); 
d1468 2
a1469 2
  LgFrOrderedVectorDemand* newOpportunityDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1471 2
a1472 2
  LgFrOrderedVectorDemand newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.entries() == 1 );
d1474 2
a1475 2
  LgFrOrderedVectorDemand* firmForecastDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1477 2
a1478 2
  LgFrOrderedVectorDemand firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.entries() == 1 );
d1480 2
a1481 2
  LgFrOrderedVectorDemand* riskForecastDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1483 2
a1484 2
  LgFrOrderedVectorDemand riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.entries() == 1 );
d1487 2
a1488 2
  LgFrVectorFloat* grossRevVectPtr
   = (LgFrVectorFloat*) tdif1.demandAttribute(
d1490 1
a1490 1
  assert( grossRevVectPtr->length() == 7 );
d1493 1
a1493 1
  grossRevVectPtr = (LgFrVectorFloat*)
d1495 1
a1495 1
  assert( grossRevVectPtr->length() == 1 );
d1498 1
a1498 1
  grossRevVectPtr = (LgFrVectorFloat*)
d1500 1
a1500 1
  assert( grossRevVectPtr->length() == 1 );
d1503 1
a1503 1
  grossRevVectPtr = (LgFrVectorFloat*)
d1505 1
a1505 1
  assert( grossRevVectPtr->length() == 1 );
d1508 1
a1508 1
  LgFrVectorTimeVecFloat * demandVolVectPtr = (LgFrVectorTimeVecFloat *)
d1510 1
a1510 1
  assert(demandVolVectPtr->length() == 7 );
d1514 1
a1514 1
  LgFrVectorTimeVecFloat * demandVolVectPtr2 = (LgFrVectorTimeVecFloat *)
d1516 1
a1516 1
  assert(demandVolVectPtr2->length() == 1 );
d1520 1
a1520 1
  LgFrVectorTimeVecFloat * demandVolVectPtr3 = (LgFrVectorTimeVecFloat *)
d1522 1
a1522 1
  assert(demandVolVectPtr3->length() == 1 );
d1526 1
a1526 1
  LgFrVectorTimeVecFloat * demandVolVectPtr4 = (LgFrVectorTimeVecFloat *)
d1528 1
a1528 1
  assert(demandVolVectPtr4->length() == 1 );
d1532 2
a1533 2
  LgFrVectorTimeVecFloat* obj1CumShipRewardVectPtr
    = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1535 1
a1535 1
  assert(obj1CumShipRewardVectPtr->length() == 7 );
d1539 2
a1540 2
  LgFrVectorTimeVecFloat* obj1CumShipRewardVectPtr2
    = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1542 1
a1542 1
  assert(obj1CumShipRewardVectPtr2->length() == 1 );
d1546 2
a1547 2
  LgFrVectorTimeVecFloat* obj1CumShipRewardVectPtr3
    = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1549 1
a1549 1
  assert(obj1CumShipRewardVectPtr3->length() == 1 );
d1553 2
a1554 2
  LgFrVectorTimeVecFloat* obj1CumShipRewardVectPtr4
    = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1556 1
a1556 1
  assert(obj1CumShipRewardVectPtr4->length() == 1 );
d1560 2
a1561 2
  LgFrVectorTimeVecFloat* obj1ShipRewardVectPtr
   = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1563 1
a1563 1
  assert(obj1ShipRewardVectPtr->length() == 7 );
d1567 2
a1568 2
  LgFrVectorTimeVecFloat* obj1ShipRewardVectPtr2
   = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1570 1
a1570 1
  assert(obj1ShipRewardVectPtr2->length() == 1 );
d1574 2
a1575 2
  LgFrVectorTimeVecFloat* obj1ShipRewardVectPtr3
   = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1577 1
a1577 1
  assert(obj1ShipRewardVectPtr3->length() == 1 );
d1581 2
a1582 2
  LgFrVectorTimeVecFloat* obj1ShipRewardVectPtr4
   = (LgFrVectorTimeVecFloat*) tdif1.demandAttribute(
d1584 1
a1584 1
  assert(obj1ShipRewardVectPtr4->length() == 1 );
d1601 1
a1601 1
  assert ( RWCString (consumedPartName) == RWCString ("Skillet"));
d1608 1
a1608 1
  assert ( RWCString (consumedPartName) == RWCString ("Butter"));
@


1.3.2.1
log
@Roguewave is gone
@
text
@a0 4
// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
#include <string>
// End of RW2STL -- inserted includes.
d2 1
a2 1
#include <iostream>
d4 2
d14 6
a19 1
const std::string 
d22 1
a22 1
const std::string 
d29 1
a29 1
const std::string 
d32 1
a32 1
const std::string 
d41 1
a41 1
     std::string t 
d51 1
a51 1
std::string
d56 1
a56 1
    std::string t = LgFrDataInterfaceImplementation::title(difEssenPtr);
d69 1
a69 1
std::string
d77 1
a77 2
  std::string titleName;
  sce::strip( titleName );
d88 1
a88 1
// Return: a LgFrPartVector object (vector of parts in general)
d105 4
d110 2
a111 2
  LgFrPartVector * retVal = new LgFrPartVector;
  retVal->reserve( listLen );
d116 2
a117 3
      std::string pn(category);
//      if( pn.compareTo( pn(ma) ) == 0 )
      if( sce::matchRegexp( pn, ma) )
d120 1
a120 1
          retVal->push_back(part);
d130 1
a130 1
// Return: a LgFrPartVector object (vector of raw parts).
d134 1
a134 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d143 1
a143 1
// Return: a LgFrPartVector object (vector of producible parts)
d147 1
a147 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d156 1
a156 1
// Return: a LgFrPartVector object (vector of capacities).
d160 1
a160 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d174 1
a174 1
// it returns a LgFrFloatVector object.
d178 1
a178 1
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
d186 3
a188 1
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
d190 1
a190 2
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );
d192 3
a194 4
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartUnitCost(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &attrVal);
    retVal.push_back( attrVal );
d200 1
a200 1
// It returns a LgFrFloatVector object.
d204 1
a204 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d212 1
a212 1
// It returns a LgFrIntVector object
d216 1
a216 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d222 4
d227 2
a228 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve( pv.size() );   

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );
d234 1
a234 1
// It returns a LgFrTimeVecFloatVector object.
d238 1
a238 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d245 3
a247 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d255 2
d260 11
a270 17
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
  {
      witGetPartCategory(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &partCategory);
      if ( partCategory == WitRAW ) 
          retVal.push_back( 0.0 );
      else if (partCategory == WitPRODUCT) 
      {
	      witGetPartCycleTime(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), 
			          &cycleTime);
	      size_t j = 0; // Pulled out of the for below by RW2STL
	      for(j = 0; j < size_tMin(calNP, witNP); j++ )
          {
              tv[j] = cycleTime[j];
	      }
	      retVal.push_back( tv );
	      portableFree(cycleTime);
d279 1
a279 1
// Return: a LgFrTimeVecFloatVector object.
d283 1
a283 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d289 3
a291 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d300 2
d305 3
a307 5
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    apiFunc(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNP, witNP); j++ )
d310 1
a310 1
    retVal.push_back( tv );
d317 1
a317 1
// Return: a LgFrTimeVecFloatVector object.
d321 1
a321 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d331 1
a331 1
// Return: a LgFrTimeVecFloatVector object.
d335 1
a335 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d345 1
a345 1
// Return: a LgFrTimeVecFloatVector object.
d349 1
a349 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d365 1
a365 1
// Return: a LgFrIntVector object
d369 1
a369 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d376 1
d378 2
a379 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );
d381 3
a383 4
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &yield);
    retVal.push_back( yield[0] );
d391 1
a391 1
// Return: a LgFrTimeVecFloatVector object
d395 1
a395 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d403 2
a404 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d414 4
a417 6
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    witGetPartYield(dImpWR->constWitRun(difEssenPtr), pv[i]->name().c_str(), &yield);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNP, witNP); j++ ) tv[j] = (float) yield[j];
    retVal.push_back( tv );
d424 1
a424 1
// Return: a LgFrTimeVecFloatVector object.
d428 1
a428 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d438 1
a438 1
// Return: a LgFrTimeVecFloatVector object.
d442 1
a442 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d454 1
a454 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d466 1
a466 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d482 1
a482 1
bool
d484 3
a486 3
  std::string /* demandedPartName */,
  std::string demandName,
  std::string compareExpression) const
d488 2
a489 2
  if ( sce::matchRegexp( demandName, compareExpression ) )
    return true;
d491 1
a491 1
    return false;
d495 1
a495 1
bool
d497 2
a498 2
  std::string demandedPartName,
  std::string demandName) const
d500 1
a500 1
  bool retVal = isADemand(demandedPartName,demandName,newOpsRE_);
d509 1
a509 1
bool
d511 2
a512 2
  std::string demandedPartName,
  std::string demandName) const
d514 1
a514 1
  bool retVal = isADemand(demandedPartName,demandName,firmForecastRE_);
d523 1
a523 1
bool
d525 2
a526 2
  std::string demandedPartName,
  std::string demandName) const
d528 1
a528 1
  bool retVal = isADemand(demandedPartName,demandName,riskForecastRE_);
d537 1
a537 1
bool
d539 2
a540 2
  std::string demandedPartName,
  std::string demandName) const
d542 1
a542 1
  bool retVal = false;
d547 1
a547 1
     return true;
d552 1
a552 1
// Return: a LgFrDemandVector object (vector of demands in general)
d559 1
a559 1
    bool
d561 1
a561 1
        (std::string, std::string)const,
d572 1
d574 1
a574 1
    LgFrDemandVector& retVal = *(new LgFrDemandVector);
d577 1
a577 2
    size_t j = 0; // Pulled out of the for below by RW2STL
    for (j = 0 ; j < listLen ; j++ )
d581 1
a581 2
        size_t i = 0; // Pulled out of the for below by RW2STL
        for (i = 0 ; i < lenDemandList ; i++ )
d583 2
a584 2
	    std::string dn(demandList[i]);
            if ((dImpWR->*isA)(std::string(partList[j]),dn))
d588 1
a588 1
                retVal.push_back(demand);
d601 1
a601 1
// Return: a LgFrDemandVector object (vector of committed demands).
d605 1
a605 1
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
d618 1
a618 1
// Return: a LgFrDemandVector object (vector of new opportunity demands).
d622 1
a622 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d635 1
a635 1
// Return: a LgFrDemandVector object (vector of firm forcast demands).
d639 1
a639 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d652 1
a652 1
// Return: a LgFrDemandVector object (vector of risk forcast demands).
d656 1
a656 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d673 1
a673 1
// Return: a LgFrFloatVector object (vector of demand gross revenues).
d677 1
a677 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d684 1
d686 2
a687 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
d691 1
a691 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
d693 3
a695 3
       dImpWR->constWitRun(difEssenPtr), (((LgFrDemand*)dv[i])->partPtr()->name().c_str()), 
       dv[i]->name().c_str(), &grossRev);
    retVal.push_back( grossRev );
d703 1
a703 1
// Return: a LgFrTimeVecFloatVector object.
d707 1
a707 1
      const LgFrItemPtrVector* itemPtrOrdVecPtr,
d715 1
d717 3
a719 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve ( dv.size() );      
d727 1
a727 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) 
  {
d729 3
a731 4
	    ((LgFrDemand*)dv[i])->partPtr()->name().c_str(),
	    dv[i]->name().c_str(), &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNp, witNp); j++)
d733 1
a733 1
    retVal.push_back( tv ); 
d745 1
a745 1
// simply returns a LgFrTimeVecFloatVector object.
d749 1
a749 1
      const LgFrItemPtrVector* itemPtrOrdVecPtr,
d757 1
d759 3
a761 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;       
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve ( dv.size() );      
d769 1
a769 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) 
  {
d771 3
a773 5
	        ((LgFrDemand*)dv[i])->partPtr()->name().c_str(),
	        dv[i]->name().c_str(),
            &attrVal);
    size_t j = 0; // Pulled out of the for below by RW2STL
    for(j = 0; j < size_tMin(calNp, witNp); j++)
d775 1
a775 1
    retVal.push_back( tv ); 
d782 1
a782 1
// Return: a LgFrTimeVecFloatVector object.
d786 1
a786 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d796 1
a796 1
// Return: a LgFrTimeVecFloatVector object.
d800 1
a800 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d810 1
a810 1
// Return: a LgFrTimeVecFloatVector object.
d814 1
a814 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d828 1
a828 1
// Now, simply returns a LgFrTimeVecFloatVector object.
d833 1
a833 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d851 1
a851 1
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
d916 1
a916 2
               size_t k = 0; // Pulled out of the for below by RW2STL
               for (k = 0; k < nSubBom ; k++)
d955 1
a955 1
   return 0;
d1095 8
d1123 1
a1123 1
bool
d1127 1
a1127 1
  return witRunVeneerPtr_!=0;
d1134 1
a1134 1
  witRunVeneerPtr_ = 0;
d1161 1
a1161 1
     if ( rhs.witRunVeneerPtr_ != 0 ) 
d1164 1
a1164 1
       witRunVeneerPtr_ = 0;
d1178 1
a1178 1
   witRunVeneerPtr_(0),
d1183 1
a1183 1
   if ( source.witRunVeneerPtr_ != 0 ) 
d1186 1
a1186 1
     witRunVeneerPtr_ = 0;
d1192 3
a1194 3
   const std::string & rf, 
   const std::string & ff, 
   const std::string & no)
d1197 1
a1197 1
   witRunVeneerPtr_(0),
d1202 2
a1203 2
   if ( witRun != 0 ) witRunVeneerPtr_ = new LgFrWitRunVeneer( witRun );
   std::string t = makeTitle(); 
d1212 1
a1212 1
   witRunVeneerPtr_(0),
d1249 5
d1264 4
a1267 4
  LgFrPartVector partpv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1269 4
a1272 5
  LgFrPartVector raw = *rawPartsPtr;
  size_t t = 0; // Pulled out of the for below by RW2STL
  for(t = 0 ; t < 7 ; t++)
    witAddPart( lps.witRun(), raw[t].name().c_str(), WitRAW);
  assert( raw.size() == 7 );
d1276 2
a1277 2
  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1279 1
a1279 1
  LgFrPartVector product = * productPartsPtr;
d1281 2
a1282 2
    witAddPart( lps.witRun(), product[t].name().c_str(), WitPRODUCT);
  assert( product.size() == 10 );
d1285 2
a1286 2
  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1288 1
a1288 1
  LgFrPartVector capacity = * capacityPartsPtr;
d1290 2
a1291 2
    witAddPart( lps.witRun(), capacity[t].name().c_str(), WitCAPACITY);
  assert( capacity.size() == 2 );
d1296 2
a1297 2
  LgFrFloatVector* unitCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
d1299 1
a1299 1
  assert( unitCostVectPtr->size() == 7 );
d1302 2
a1303 2
  LgFrIntVector* constrainedVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
d1305 2
a1306 3
  assert( constrainedVectPtr->size() == 7 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrainedVectPtr->size(); i++) 
d1309 2
a1310 2
  LgFrFloatVector* procCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
d1312 1
a1312 1
  assert( procCostVectPtr->size() == 7 );
d1315 2
a1316 2
  LgFrTimeVecFloatVector* procLeadTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1318 2
a1319 3
  assert( procLeadTimeVectPtr->size() == 7 );
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<procLeadTimeVectPtr->size(); j++){
d1322 2
a1323 2
  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1325 1
a1325 1
  assert( obj1ScrapCostVectPtr->size() == 7 );
d1329 2
a1330 2
  LgFrTimeVecFloatVector* obj1StockCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1332 1
a1332 1
  assert( obj1StockCostVectPtr->size() == 7 );
d1336 2
a1337 2
  LgFrTimeVecFloatVector* supplyVolVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1339 1
a1339 1
  assert( supplyVolVectPtr->size() == 7 );
d1346 2
a1347 2
  LgFrIntVector* yieldVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
d1349 1
a1349 1
  assert( yieldVectPtr->size() == 10 );
d1352 2
a1353 2
  LgFrTimeVecFloatVector* cycleTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1355 1
a1355 1
  assert( cycleTimeVectPtr->size() == 10 );
d1359 2
a1360 2
  LgFrTimeVecFloatVector* obj1ProdCostVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1362 1
a1362 1
  assert( obj1ProdCostVectPtr->size() == 10 );
d1366 2
a1367 2
  LgFrFloatVector* unitCostVectPtr2
    = (LgFrFloatVector*) tdif1.partAttribute(
d1369 1
a1369 1
  assert( unitCostVectPtr2->size() == 10 );
d1372 2
a1373 2
  LgFrIntVector* constrainedVectPtr2
   = (LgFrIntVector*) tdif1.partAttribute(
d1375 2
a1376 3
  assert( constrainedVectPtr2->size() == 10 );
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<constrainedVectPtr2->size(); k++) 
d1379 2
a1380 2
  LgFrFloatVector* procCostVectPtr2
    = (LgFrFloatVector*) tdif1.partAttribute(
d1382 1
a1382 1
  assert( procCostVectPtr2->size() == 10 );
d1385 2
a1386 2
  LgFrTimeVecFloatVector* obj1ProdCostVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1388 1
a1388 1
  assert( obj1ProdCostVectPtr2->size() == 10 );
d1393 2
a1394 2
  LgFrTimeVecFloatVector* procLeadTimeVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1396 1
a1396 1
  assert( procLeadTimeVectPtr->size() == 10 );
d1400 2
a1401 2
  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1403 1
a1403 1
  assert( obj1ScrapCostVectPtr2->size() == 10 );
d1407 2
a1408 2
  LgFrTimeVecFloatVector* obj1StockCostVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1410 1
a1410 1
  assert( obj1StockCostVectPtr2->size() == 10 );
d1414 2
a1415 2
  LgFrTimeVecFloatVector* supplyVolVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1417 1
a1417 1
  assert( supplyVolVectPtr2->size() == 10 );
d1424 2
a1425 2
  LgFrFloatVector* unitCostVectPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
d1427 1
a1427 1
  assert( unitCostVectPtr->size() == 2 );
d1430 2
a1431 2
  LgFrIntVector* constrainedVectPtr
   = (LgFrIntVector*) tdif1.partAttribute(
d1433 2
a1434 3
  assert( constrainedVectPtr->size() == 2 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrainedVectPtr->size(); i++) 
d1437 2
a1438 2
  LgFrTimeVecFloatVector* obj1ScrapCostVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1440 1
a1440 1
  assert( obj1ScrapCostVectPtr->size() == 2 );
d1444 2
a1445 2
  LgFrTimeVecFloatVector* supplyVolVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1447 1
a1447 1
  assert( supplyVolVectPtr->size() == 2 );
d1453 1
a1453 1
  LgFrDemandVector demandpv;
d1455 2
a1456 2
  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1458 2
a1459 2
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 7 ); 
d1461 2
a1462 2
  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1464 2
a1465 2
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 1 );
d1467 2
a1468 2
  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1470 2
a1471 2
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 1 );
d1473 2
a1474 2
  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1476 2
a1477 2
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 1 );
d1480 2
a1481 2
  LgFrFloatVector* grossRevVectPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
d1483 1
a1483 1
  assert( grossRevVectPtr->size() == 7 );
d1486 1
a1486 1
  grossRevVectPtr = (LgFrFloatVector*)
d1488 1
a1488 1
  assert( grossRevVectPtr->size() == 1 );
d1491 1
a1491 1
  grossRevVectPtr = (LgFrFloatVector*)
d1493 1
a1493 1
  assert( grossRevVectPtr->size() == 1 );
d1496 1
a1496 1
  grossRevVectPtr = (LgFrFloatVector*)
d1498 1
a1498 1
  assert( grossRevVectPtr->size() == 1 );
d1501 1
a1501 1
  LgFrTimeVecFloatVector * demandVolVectPtr = (LgFrTimeVecFloatVector *)
d1503 1
a1503 1
  assert(demandVolVectPtr->size() == 7 );
d1507 1
a1507 1
  LgFrTimeVecFloatVector * demandVolVectPtr2 = (LgFrTimeVecFloatVector *)
d1509 1
a1509 1
  assert(demandVolVectPtr2->size() == 1 );
d1513 1
a1513 1
  LgFrTimeVecFloatVector * demandVolVectPtr3 = (LgFrTimeVecFloatVector *)
d1515 1
a1515 1
  assert(demandVolVectPtr3->size() == 1 );
d1519 1
a1519 1
  LgFrTimeVecFloatVector * demandVolVectPtr4 = (LgFrTimeVecFloatVector *)
d1521 1
a1521 1
  assert(demandVolVectPtr4->size() == 1 );
d1525 2
a1526 2
  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1528 1
a1528 1
  assert(obj1CumShipRewardVectPtr->size() == 7 );
d1532 2
a1533 2
  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr2
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1535 1
a1535 1
  assert(obj1CumShipRewardVectPtr2->size() == 1 );
d1539 2
a1540 2
  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr3
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1542 1
a1542 1
  assert(obj1CumShipRewardVectPtr3->size() == 1 );
d1546 2
a1547 2
  LgFrTimeVecFloatVector* obj1CumShipRewardVectPtr4
    = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1549 1
a1549 1
  assert(obj1CumShipRewardVectPtr4->size() == 1 );
d1553 2
a1554 2
  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1556 1
a1556 1
  assert(obj1ShipRewardVectPtr->size() == 7 );
d1560 2
a1561 2
  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr2
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1563 1
a1563 1
  assert(obj1ShipRewardVectPtr2->size() == 1 );
d1567 2
a1568 2
  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr3
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1570 1
a1570 1
  assert(obj1ShipRewardVectPtr3->size() == 1 );
d1574 2
a1575 2
  LgFrTimeVecFloatVector* obj1ShipRewardVectPtr4
   = (LgFrTimeVecFloatVector*) tdif1.demandAttribute(
d1577 1
a1577 1
  assert(obj1ShipRewardVectPtr4->size() == 1 );
d1594 1
a1594 1
  assert ( std::string (consumedPartName) == std::string ("Skillet"));
d1601 1
a1601 1
  assert ( std::string (consumedPartName) == std::string ("Butter"));
@


1.2
log
@Added implement (RWGVector, XXX) to satisfy vacpp linker.
@
text
@d13 2
d17 1
@


1.1
log
@Initial revision
@
text
@d13 2
@


1.1.1.1
log
@Import scenario
@
text
@@

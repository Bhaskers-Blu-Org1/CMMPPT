head	1.4;
access;
symbols
	sce_5_01_20080919:1.4
	latest_sce_4_20_20060523:1.4.0.4
	sce_4_20_20060523:1.4
	latest_sce4_20_OSL:1.4.0.2
	sce_4_20_OSL:1.4
	sce_4_05_20040511:1.4
	sce_4_00_20040201:1.4
	nextGenBranch:1.3.0.2
	nextGenRoot:1.3
	sce_3_30_20030627:1.3
	EndRw-branch:1.2.0.6
	Root-of-EndRw:1.2
	EndWitRw-branch:1.2.0.4
	Root-of-EndWitRw:1.2
	RwToStl-branch:1.2.0.2
	Root-of-RwToStl:1.2
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2003.08.05.12.55.44;	author dpc;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.15.19.36.40;	author rwToStl;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.07.19.01.14;	author austel;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.02.24.15.29.46;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.46;	author wit;	state Exp;
branches;
next	;

1.2.6.1
date	2003.01.08.17.42.32;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Made several changes to the iosMode.  RW allowed for different modes to open a file but STL doesn't support some of those modes.
@
text
@#ifndef LGFR_IMPLOSION_OUTPUT_INTERFACE_H
#define LGFR_IMPLOSION_OUTPUT_INTERFACE_H
// RW2STL -- inserted:
#include <fstream>
#include <string>
// End of RW2STL -- inserted includes.

// This class writes an implosion solution to a file.

// Responsibilities are:
//   1. Write an implosion production schedule.
//   2. Write an implosion shipment schedule.
//   3. Write an implosion critical list.
//   4. Write a focussed shortage schedule (including the focus).
//   5. Write changes made to part supply and demand quantity and priority

// These responsibilities are met by using:
//   1. writeProductionSchedule. (2 methods)
//   2. writeShipmentSchedule. (2 methods)
//   3. writeCriticalList.
//   4. Write a focussed shortage schedule (including the focus).
//   5. writeChangedSupplyVolume writeChangedDemandVolume, 
//      writeChangedPriority



#include <scenario/src/partSchd.h>
#include <scenario/src/fssCtrl.h>
#include <scenario/src/scenario.h>


class LgFrSolutionOutputInterface  {

private:
  // Required to avoid "sorry, not implemented" messages on Sun
  static const std::string writeScheduleTitle;
  static const std::string fopenAccessModeAppend;
  static const std::string writeProductionScheduleTitle;
  static const std::string writeShipmentScheduleTitle;
  static const std::string writeRequirementScheduleTitle;
  static const std::string writeCriticalListTitle;
  static const std::string writeChangedSupplyVolumeTitle;
  static const std::string writeChangedDemandVolumeTitle;
  static const std::string writeChangedPriorityTitle;
  static const std::string writeFocusShortageScheduleTitle;
  static const std::string writeFocusShortageScheduleFocusHorizonTitle;
  static const LgFrSchedulePrintStyle pmTEXT;
public:
  friend class LgFrScenario;

  // Write a schedule.
  virtual
    bool            // true if no error was encountered
      writeSchedule(

         // part schedule to be written
         const LgFrScheduleFloat & schedule,

         // name of file to write  
         const std::string& fileName,

         // Title to be written as first records of file
         const std::string & title = 
            LgFrSolutionOutputInterface::writeScheduleTitle,

         // ofstream constructor mode.
         // Typical values are:
         //     std::ofstream::out | std::ofstream::app Append to an existing file.
         //     std::ofstream::out | std::ofStream::trunc OK to overwrite an existing file.
         const std::ios_base::openmode iosMode = std::ofstream::out 
                                      //   Use LgFrDoesFileExist() to determine
                                      //   existence of a file.
        )
      const;

  // Write output using WIT file formats.
  //
  // fileName: name of file to be written.
  // fopenAccessMode: fopen access mode used when opening file.
  // Typical values are:
  //     "a"          Append to an existing file.
  //     "w"          OK to overwrite an existing file.
  //
  // returns true if no error was encountered
  //
  // Use LgFrDoesFileExist() to determine existence of a file.
  virtual
    bool            // true if no error was encountered
      writeWitProductionSchedule(
         const std::string& fileName,
         const std::string & fopenAccessMode = 
            LgFrSolutionOutputInterface::fopenAccessModeAppend,
	 const LgFrSchedulePrintStyle & ot = pmTEXT)
      const;
  virtual
    bool            // true if no error was encountered
      writeWitShipmentSchedule(
         const std::string& fileName,
         const std::string & fopenAccessMode =             
            LgFrSolutionOutputInterface::fopenAccessModeAppend,
	 const LgFrSchedulePrintStyle & ot = pmTEXT)
      const;
  virtual
    bool            // true if no error was encountered
      writeWitRequirementSchedule(
         const std::string& fileName,
         const std::string & fopenAccessMode =             
            LgFrSolutionOutputInterface::fopenAccessModeAppend,
	 const LgFrSchedulePrintStyle & ot = pmTEXT)
      const;


  // Write methods which do not use WIT file formats.
  //
  // fileName: name of file to be written.
  // title : first record written to file.
  // iosMode : ofstream constructor mode.
  //    Typical values are:
  //        std::ofstream::out | std::ofstream::noreplace  Don't overwrite an existing file.
  //        std::ofstream::out | std::ofstream::app        Append to an existing file.
  //        std::ofstream::out                   OK to overwrite an existing file.
  //
  // returns true if no error was encountered
  //
  // Use LgFrDoesFileExist() to determine existence of a file.

  virtual
    bool            // true if no error was encountered
      writeProductionSchedule(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeProductionScheduleTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;
      // Note: This file does not include substitute usage

  virtual
    bool            // true if no error was encountered
      writeShipmentSchedule(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeShipmentScheduleTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  virtual
    bool            // true if no error was encountered
      writeRequirementSchedule(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeRequirementScheduleTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  virtual
    bool            // true if no error was encountered
      writeCriticalList(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeCriticalListTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  virtual
    bool            // true if no error was encountered
      writeChangedSupplyVolume(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeChangedSupplyVolumeTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  virtual
    bool            // true if no error was encountered
      writeChangedDemandVolume(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeChangedDemandVolumeTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  virtual
    bool            // true if no error was encountered
      writeChangedPriority(
         const std::string& fileName,
         const std::string & title = 
            LgFrSolutionOutputInterface::writeChangedPriorityTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;

  // Write Focus Shortage Schedule including focus horizon
  //
  // fileName: name of file to be written.
  // title1 : Record written for focus shortage schedule title.
  // title2 : Record written for focus horizon title.
  // iosMode : ofstream constructor mode.
  //    Typical values are:
  //        std::ofstream::out | std::ofstream::noreplace  Don't overwrite an existing file.
  //        std::ofstream::out | std::ofstream::app        Append to an existing file.
  //        std::ofstream::out                   OK to overwrite an existing file.
  //
  // returns true if no error was encountered
  //
  virtual
    bool            // true if no error was encountered
      writeFocusShortageSchedule(
         LgFrFocussedShortageScheduleControl & fssCtrl,
         const std::string& fileName,
         const std::string & title1 = 
            LgFrSolutionOutputInterface::writeFocusShortageScheduleTitle,
         const std::string & title2 = 
            LgFrSolutionOutputInterface::
               writeFocusShortageScheduleFocusHorizonTitle,
         const std::ios_base::openmode iosMode = std::ofstream::app
         )
      const;


  // Constructor
  LgFrSolutionOutputInterface();

  // Destructor
  ~LgFrSolutionOutputInterface();

  // test this class
  static void test();

  // The data for case11Scenario should come from
  // "u/implode/wit/data/csi/case11/wit.data"
  //
  // The data for case11Scenario should come from
  // "u/implode/wit/data/examples/diner12/wit.data"
  static void contextTest(
    LgFrScenarioSmartPointer case11Scenario,
      LgFrWorkingImplosionProblem &wip,
      LgFrLastProblemSolved &lps,
      LgFrSetOfParts &sop,
      LgFrSetOfDemands &sod,
    LgFrScenarioSmartPointer diner12Scenario,
     LgFrSetOfDemands &diner12Sod,
     LgFrFocussedShortageScheduleControl & diner12FssCtrl );

  //  static const std::ios_base::openmode noReplace;
private:

  LgFrScenario* const scenarioPtr_;

  // Assignment operator
  LgFrSolutionOutputInterface &
    operator=(
	      const LgFrSolutionOutputInterface& rhs);

  // A Copy constructor
  LgFrSolutionOutputInterface(
     const LgFrSolutionOutputInterface& source );

  // Another Constructor - should only be used by the Scenario constructor
  LgFrSolutionOutputInterface(
     LgFrScenario* scenario );

};

#endif
@


1.3
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@a67 1
         //     std::ofstream::out | noReplace          Don't overwrite an existing file.
d69 2
a70 2
         //     std::ofstream::out                      OK to overwrite an existing file.
         const int iosMode = std::ofstream::out | noReplace
d133 1
a133 1
         const int iosMode = std::ofstream::app
d144 1
a144 1
         const int iosMode = std::ofstream::app
d154 1
a154 1
         const int iosMode = std::ofstream::app
d164 1
a164 1
         const int iosMode = std::ofstream::app
d174 1
a174 1
         const int iosMode = std::ofstream::app
d184 1
a184 1
         const int iosMode = std::ofstream::app
d194 1
a194 1
         const int iosMode = std::ofstream::app
d221 1
a221 1
         const int iosMode = std::ofstream::app
d250 1
a250 1
  static const int noReplace;
@


1.2
log
@

NOTE CONCERNING FOR-SEMANTICS.

In old C++ semantics, this was illegal:
	for (int i=...) { ...}
	for (int i=...) { ...}

because the scope of i extended beyond the first for-loop, making
the second declaration a conflict.

In new C++ semantics, this is illegal:
	for (int i=...) { ...}
	for (i=...) { ...}

because the scope of i extends in the first for-loop, making
the use of "i" in the second loop unbound.

We can't have it both ways.  We could convert the source to be this:
	inti;
	for (i=...) { ...}
	for (i=...) { ...}

but rather than do that, I have opted to just use a special flag
("-qlanglvl=noansifor") to tell vacpp to use the old semantics.
This flag is in config/p_powerVac.mk.
We can always convert these for loops later if we like, and take
out the flag.


Now some notes concerning what I did in the various components.
Hopefully no one will ever have to read this.

CONFIG:
changed config/p_powerVac.mk by copying setting for ds_comp_std_flags
from config/p_power64v5.mk, to suppress error messages concerning
the technique to avoid accidental use of compiler-generated constructors.

WITUTIL:
changed return type of "main" to int in several files.

SCENARIO and SCE:
In many files, some member declarations had (unnecessary) qualifiers:

	class S {
	S::f();
	};

The obvious solution was to just remove the "S::" qualifier.



In some files (such as ipDifT.h), a member declaration using a class
name in a return type caused a syntax error; the compiler complained
about ambiguity.

	class X {
	C f();
	};

Solution:  add "class C" in front.  Should really have no possible problems.

	class C;
	class X {
	C f();
	};



Some classes declared protected members of other classes to be friends:

	class A {
	protected:
	  int mem();
	};

	class B {
	friend int A::mem();
	};

This is evidentally now illegal.  I suppose it makes sense that one
should already have access to the thing that one wants to be a friend of.

My solution was to just drop the "protected" keyword.
This allows everyone access to these members (which is presumably
undesirable), but at least doesn't allow the friend classes access
to the private data of this class (which presumably is desired).

Another alternative would be to keep the "protected" keyword and
add "friend class A" to the friend class.
The situation is now reversed; it would have the drawback of allowing
the friend class access to private data (which presumably isn't desired),
but would disallow non-friends access to these protected members.




attrInfo.h:  typedef declarations for functions types cannot have
default arguments, i.e. this is illegal:

	typedef int (*f)(int x = 1);

Solution:  drop the default argument:

	typedef int (*f)(int x);

(I suppose this makes sense, given that the treatment of default arguments
seems to have gotten a bit complicated - you can add and remove them
using new declarations.)



(THIS NOTE IS OBSOLETE since I ended up leaving these for-loops alone.
However, it may be useful if we ever do convert the source to the
new syntax.
calendar.C, consSS.C, difCmrpF.C, difWit[DR].C:
  added "int" (or size_t, as appropriate) to "for" loops:

was:
	for (int t=...) { ..}
	for (t=...) { ..}

now:
	for (int t=...) { ..}
	for (int t=...) { ..}

This is ok since t is initialized in each loop.

This wasn't possible in one spot in sched.C, in LgFrScheduleFloat::reduceItems.
It also wasn't possible in a spot in sce/ipSce.C.
It had code like this:
	int t;
	... code setting t
	for (...) {
	  for (int t = ...)
		...
	  somevar = t;
	}

According to the old rules, the assignment "somevar = t" refers to the
t in the nested for-loop.  I've changed it to this:

	for (...) {
	  int t;
	  for (t = ...)
		...
	  somevar = t;
	}

Fortunately, in most places the loop was not nested inside some other
construct, which makes it likely that I didn't make any mistakes.

END OBSOLETE NOTE)



demdSchd.C, partSchd.C, scenATP.C, ...:
  apparently, expressions that refer to a pointer-to-member must use "&":
	class C {
	int f();
	};

	g(C::f);	// ILLEGAL
	g(&C::f);	// GOOD BOY!

(maybe this makes parsing easier?)



dfa.C:  changed
	#include "dfa.h"
to
	#include <scenario/src/dfa.h>

so that the depedency generated by makedepend (and that ends up in Makefile)
doesn't cause problems.




lastPrbS.C:  "bool" is now a keyword.  Changed variable "bool" to "Bool".





multDSch.C:

start with this decl:

    LgFrMultiDemandScheduleFloat& msdClone = *msdClonePtr;

and this call:

    const LgFrSortingDemandScheduleFloat& demandSchdClone
      = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );


LgFrMultiDemandScheduleFloat (in multDSch.h) apparently inherits the
declaration of method "schedule" from its baseclass, LgFrMultiScheduleFloat
(in multiSch.h).

  // Return a non-const schedule
  virtual
    LgFrSortingScheduleFloatSmartPointer
     schedule(const LgFrScheduleDescriptor& sd) const;


class LgFrSortingScheduleFloatSmartPointer is defined in sortSchP.h.
Its baseclass is LgFrSortingScheduleFloatSmartPointerToConst,
defined in the same file, and that has no baseclass.

class LgFrSortingDemandScheduleFloatSmartPointer is defined in demdSchP.h,
and looks similar to LgFrSortingScheduleFloatSmartPointer,
probably one was copied from the other and the names were changed.

So, the problematic statement is probably the equivalent of casting a pointer.

This was the code I used instead.
It may just be that one can't cast using "&" anymore.

    LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
    LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
    const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);


This is *probably* ok, since both smartpointers have the same private
data fields (in their basetypes).  The code snippets below give the
general idea.  I imagine that this would all be done with templates
these days (if there isn't already a smartpointer library somewhere).



protected:
    LgFrSortingDemandScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingDemandScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;




protected:
    LgFrSortingScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;


Dereference is just what it should be:


const LgFrSortingDemandScheduleFloat &
LgFrSortingDemandScheduleFloatSmartPointer::operator*() const
{
    return *pointer_;
}

LgFrSortingScheduleFloat &
LgFrSortingScheduleFloatSmartPointer::operator*()
{
    return *pointer_;
}



SCE:
Created powerVac/Makefile
by copying power64/Makefile and just changine "power64" to "powerVac".





For convenience, here is the output of these commands:

	cvs diff scenario/src
	cvs diff sce/src


Index: scenario/src/attrInfo.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/attrInfo.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 attrInfo.h
17c17,20
< 	       const LgFrDataInterfaceEssentials* difEssenPtr = NULL);
---
>
> 	       // syntax error - typedefs can (no longer) have default args
> 	       const LgFrDataInterfaceEssentials* difEssenPtr /////= NULL
> 	       );
47c50
< LgFrAttributeInformation::LgFrAttributeInformation(const LgFrAttributeInformation& );
---
> LgFrAttributeInformation(const LgFrAttributeInformation& );
Index: scenario/src/backlgSS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/backlgSS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 backlgSS.h
83c83
<   LgFrBacklogScheduleStrategy::contextTest
---
>   contextTest
Index: scenario/src/calendar.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/calendar.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 calendar.h
252c252
<   LgFrCalendar::addMonths(const RWTime& aTime, unsigned numMonthsOut,
---
>   addMonths(const RWTime& aTime, unsigned numMonthsOut,
281c281
<   LgFrCalendar::display()
---
>   display()
Index: scenario/src/demdSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/demdSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 demdSchd.C
273c273
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
288c288
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
452c452
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
475c475
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
496c496
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
514c514
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/dfa.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/dfa.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 dfa.C
14c14,16
< #include "dfa.h"
---
>
> //#include "dfa.h"
> #include <scenario/src/dfa.h>
Index: scenario/src/filtStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/filtStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 filtStrt.h
89c89,90
< protected:
---
>   // see the comment in schdStrt.h.
>   /////protected:
Index: scenario/src/fssCtrl.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/fssCtrl.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 fssCtrl.h
109c109
<         LgFrFocussedShortageScheduleControl::isValid()
---
>         isValid()
117c117
<         LgFrFocussedShortageScheduleControl::focusChanged()
---
>         focusChanged()
151c151
<    LgFrFocussedShortageScheduleControl::LgFrFocussedShortageScheduleControl(
---
>    LgFrFocussedShortageScheduleControl(
Index: scenario/src/ipDifT.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/ipDifT.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 ipDifT.h
10a11,15
>
> // added to avoid syntax error in declaration of difTestingScenario below - vra
> class LgFrScenarioForDifTestingSmartPointer;
>
>
Index: scenario/src/lastPrbS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 lastPrbS.C
98c98
<    witBoolean bool;
---
>    witBoolean Bool;
100,101c100,101
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
248c248
<    witBoolean bool;
---
>    witBoolean Bool;
250,251c250,251
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
Index: scenario/src/lastPrbS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.h,v
retrieving revision 1.2
diff -r1.2 lastPrbS.h
182c182
<         LgFrLastProblemSolved::focusHorizon(
---
>         focusHorizon(
686c686
<         LgFrLastProblemSolved::cumShipBounds(
---
>         cumShipBounds(
760c760
<         LgFrLastProblemSolved::cumShipSoftLowerBound(
---
>         cumShipSoftLowerBound(
910c910
<       LgFrLastProblemSolved::getPartFloatVecAttribute(
---
>       getPartFloatVecAttribute(
917c917
<        LgFrLastProblemSolved::setPartFloatVecAttribute(
---
>        setPartFloatVecAttribute(
924c924
<       LgFrLastProblemSolved::setPartBoundsAttribute(
---
>       setPartBoundsAttribute(
933c933
<       LgFrLastProblemSolved::getDemandFloatVecAttribute(
---
>       getDemandFloatVecAttribute(
940c940
<       LgFrLastProblemSolved::getDemandSoftLowerBoundAttribute(
---
>       getDemandSoftLowerBoundAttribute(
947c947
<       LgFrLastProblemSolved::setDemandBoundsAttribute(
---
>       setDemandBoundsAttribute(
956c956
<    LgFrLastProblemSolved::writeSchedule(
---
>    writeSchedule(
Index: scenario/src/multDSch.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/multDSch.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 multDSch.C
436,438c436,446
<
<     const LgFrSortingDemandScheduleFloat& demandSchdClone
<       = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
---
>
>     //// LET'S TRY THIS AGAIN...
>     /////const LgFrSortingDemandScheduleFloat& demandSchdClone
>     /////= *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
>
>     LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
>     LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
>     const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);
>
>     ///// DONE
>
Index: scenario/src/outInter.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/outInter.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 outInter.h
43c43
<   static const LgFrSchedulePrintStyle LgFrSolutionOutputInterface::pmTEXT;
---
>   static const LgFrSchedulePrintStyle pmTEXT;
Index: scenario/src/pairComp.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/pairComp.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 pairComp.h
84c84,86
< protected:
---
>   // in scenario.h, class LgFrScenario declares these methods to be "friend".
>   // see the comment in schdStrt.h.
>   //// protected:
Index: scenario/src/partSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/partSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 partSchd.C
261c261
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
276c276
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
443c443
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
466c466
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
487c487
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
503c503
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/scenATP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenATP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenATP.C
484c484
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
513c513
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
Index: scenario/src/scenSnFS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenSnFS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenSnFS.h
16c16
<   LgFrScenarioSensitiveFilterStrategy::scenario(
---
>   scenario(
21c21
<   LgFrScenarioSensitiveFilterStrategy::scenarioPtr()
---
>   scenarioPtr()
Index: scenario/src/scenario.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenario.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenario.h
46a47,54
> // had to add this line in order to avoid syntax error concerning
> // the uses of this class in members below.
> // vacpp complained that is was ambiguous.
> // I don't know why.
> // Perhaps in older versions of the compiler the friend declarations
> // below also implicitly declared the class as well?
> class LgFrScheduleFactory;
>
231c239
<   const LgFrScheduleFactory*
---
>     const LgFrScheduleFactory*
Index: scenario/src/schFCMRP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFCMRP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFCMRP.C
82c82
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
184c184
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
370c370
<       usagePctSS->combiningFunction (LgFrTimeVecFloat::percentageOf);
---
>       usagePctSS->combiningFunction (&LgFrTimeVecFloat::percentageOf);
416c416
<       deltaSS->combiningFunction (LgFrTimeVecFloat::subtract);
---
>       deltaSS->combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schFctry.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFctry.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFctry.h
96c96
< friend LgFrScenarioBuilder;
---
> friend class LgFrScenarioBuilder;
Index: scenario/src/schdSnSS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdSnSS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdSnSS.C
242c242
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
260c260
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
613c613
<       cs1.combiningFunction (LgFrTimeVecFloat::subtract);
---
>       cs1.combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schdStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdStrt.h
141c141,168
< protected:
---
>   ////??????
>   // in scenario.h, class LgFrScenario declares (most of) the
>   // following methods to be "friend"s.
>   // I (vra) can't see how that would have ever been possible,
>   // given that these are protected methods.
>   // Perhaps the compilers are just more finicky now.
>   // As a hack to get this working right away, I will remove the
>   // protected keyword.
>   //
>   // An an alternative, one could add
>   //    friend class LgFrAttributeScheduleStrategy;
>   // to the classes that need access (such as LgFrScenario)
>   // and make these methods protected again.
>   //
>   // The differences between these two styles is:
>   //	dropping "protected" here allows everyone access,
>   //	(which presumably isn't intended),
>   //	but denies friends (such as LgFrScenario) access to private members
>   //	(which presumably is intended).
>   //
>   //	in contrast, using friend class LgFrAttributeScheduleStrategy
>   //	(and putting back the "protected" keyword here)
>   //	allows the friend classes access to private members
>   //	(presumably not intended),
>   //	but denies everyone else access to protected members
>   //	(presumably intended).
>   //
>   ////// protected:
Index: scenario/src/sched.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.C
578c578
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
585c585
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
594c594
<   return op(LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
---
>   return op(&LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
716c716
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
734c734
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
750c750
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
761c761
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/sched.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.h
81c81
<       LgFrScheduleFloat::capacity()
---
>       capacity()
Index: scenario/src/sortSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sortSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sortSchd.C
679c679
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
688c688
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
Index: scenario/src/wrkgProb.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/wrkgProb.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 wrkgProb.C
641c641
<                LgFrLastProblemSolved::capitalCost);
---
>                &LgFrLastProblemSolved::capitalCost);
650c650
<                       LgFrLastProblemSolved::capitalCost );
---
>                       &LgFrLastProblemSolved::capitalCost );
660c660
<                LgFrLastProblemSolved::equitability);
---
> 	     &LgFrLastProblemSolved::equitability);
669c669
<                       LgFrLastProblemSolved::equitability );
---
> 		    &LgFrLastProblemSolved::equitability );
679c679
<                LgFrLastProblemSolved::buildAhead);
---
> 		   &LgFrLastProblemSolved::buildAhead);
688c688
<                       LgFrLastProblemSolved::buildAhead );
---
> 			  &LgFrLastProblemSolved::buildAhead );
698c698
<                LgFrLastProblemSolved::computeCriticalList);
---
> 		   &LgFrLastProblemSolved::computeCriticalList);
707c707
<                       LgFrLastProblemSolved::computeCriticalList );
---
> 			  &LgFrLastProblemSolved::computeCriticalList );
717c717
<                LgFrLastProblemSolved::inventoryCost);
---
>                &LgFrLastProblemSolved::inventoryCost);
726c726
<                       LgFrLastProblemSolved::inventoryCost );
---
>                       &LgFrLastProblemSolved::inventoryCost );
736c736
<                LgFrLastProblemSolved::obj2WeightInventory);
---
>                &LgFrLastProblemSolved::obj2WeightInventory);
745c745
<                       LgFrLastProblemSolved::obj2WeightInventory );
---
>                       &LgFrLastProblemSolved::obj2WeightInventory );
755c755
<                LgFrLastProblemSolved::obj2WeightRevenue);
---
>                &LgFrLastProblemSolved::obj2WeightRevenue);
764c764
<                       LgFrLastProblemSolved::obj2WeightRevenue );
---
>                       &LgFrLastProblemSolved::obj2WeightRevenue );
774c774
<                LgFrLastProblemSolved::obj2WeightService);
---
>                &LgFrLastProblemSolved::obj2WeightService);
783c783
<                       LgFrLastProblemSolved::obj2WeightService );
---
>                       &LgFrLastProblemSolved::obj2WeightService );
793c793
<                LgFrLastProblemSolved::obj2WeightSubstitutes);
---
>                &LgFrLastProblemSolved::obj2WeightSubstitutes);
802c802
<                       LgFrLastProblemSolved::obj2WeightSubstitutes );
---
>                       &LgFrLastProblemSolved::obj2WeightSubstitutes );
812c812
<                LgFrLastProblemSolved::weightBounds);
---
>                &LgFrLastProblemSolved::weightBounds);
821c821
<                       LgFrLastProblemSolved::weightBounds );
---
>                       &LgFrLastProblemSolved::weightBounds );




Index: sce/src/aEngMgr.h
===================================================================
RCS file: /u/wit/devbase/sce/src/aEngMgr.h,v
retrieving revision 1.5
diff -r1.5 aEngMgr.h
77c77
< LgFrSceAllocationEngineMgr::sortID();
---
> sortID();
Index: sce/src/scePegging.C
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.C,v
retrieving revision 1.6
diff -r1.6 scePegging.C
121c121
<   virtual RWBoolean SceCollectableDouble::operator==(const SceCollectableDouble& c) const
---
>   virtual RWBoolean operator==(const SceCollectableDouble& c) const
124c124
<   virtual RWBoolean SceCollectableDouble::isEqual(const RWCollectable* c) const
---
>   virtual RWBoolean isEqual(const RWCollectable* c) const
Index: sce/src/scePegging.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.h,v
retrieving revision 1.4
diff -r1.4 scePegging.h
120c120
<   void ScePegging::computeConsVolAndUpdateConsDict(
---
>   void computeConsVolAndUpdateConsDict(
Index: sce/src/scenSce.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scenSce.h,v
retrieving revision 1.6
diff -r1.6 scenSce.h
35a36,38
> // added to avoid syntax error - vra
> class LgFrScenarioForSceSmartPointer;
>
@
text
@d3 4
d36 11
a46 11
  static const RWCString writeScheduleTitle;
  static const RWCString fopenAccessModeAppend;
  static const RWCString writeProductionScheduleTitle;
  static const RWCString writeShipmentScheduleTitle;
  static const RWCString writeRequirementScheduleTitle;
  static const RWCString writeCriticalListTitle;
  static const RWCString writeChangedSupplyVolumeTitle;
  static const RWCString writeChangedDemandVolumeTitle;
  static const RWCString writeChangedPriorityTitle;
  static const RWCString writeFocusShortageScheduleTitle;
  static const RWCString writeFocusShortageScheduleFocusHorizonTitle;
d53 1
a53 1
    RWBoolean            // TRUE if no error was encountered
d60 1
a60 1
         const RWCString fileName,
d63 1
a63 1
         const RWCString & title = 
d68 4
a71 4
         //     ios::out | ios::noreplace  Don't overwrite an existing file.
         //     ios::out | ios::app        Append to an existing file.
         //     ios::out                   OK to overwrite an existing file.
         const int iosMode = ios::out | ios::noreplace
d74 1
a74 1
         )
d85 1
a85 1
  // returns TRUE if no error was encountered
d89 1
a89 1
    RWBoolean            // TRUE if no error was encountered
d91 2
a92 2
         const RWCString fileName,
         const RWCString & fopenAccessMode = 
d97 1
a97 1
    RWBoolean            // TRUE if no error was encountered
d99 2
a100 2
         const RWCString fileName,
         const RWCString & fopenAccessMode =             
d105 1
a105 1
    RWBoolean            // TRUE if no error was encountered
d107 2
a108 2
         const RWCString fileName,
         const RWCString & fopenAccessMode =             
d120 3
a122 3
  //        ios::out | ios::noreplace  Don't overwrite an existing file.
  //        ios::out | ios::app        Append to an existing file.
  //        ios::out                   OK to overwrite an existing file.
d124 1
a124 1
  // returns TRUE if no error was encountered
d129 1
a129 1
    RWBoolean            // TRUE if no error was encountered
d131 2
a132 2
         const RWCString fileName,
         const RWCString & title = 
d134 1
a134 1
         const int iosMode = ios::out | ios::noreplace
d140 1
a140 1
    RWBoolean            // TRUE if no error was encountered
d142 2
a143 2
         const RWCString fileName,
         const RWCString & title = 
d145 1
a145 1
         const int iosMode = ios::out | ios::noreplace
d150 1
a150 1
    RWBoolean            // TRUE if no error was encountered
d152 2
a153 2
         const RWCString fileName,
         const RWCString & title = 
d155 1
a155 1
         const int iosMode = ios::out | ios::noreplace
d160 1
a160 1
    RWBoolean            // TRUE if no error was encountered
d162 2
a163 2
         const RWCString fileName,
         const RWCString & title = 
d165 1
a165 1
         const int iosMode = ios::out | ios::noreplace
d170 1
a170 1
    RWBoolean            // TRUE if no error was encountered
d172 2
a173 2
         const RWCString fileName,
         const RWCString & title = 
d175 1
a175 1
         const int iosMode = ios::out | ios::noreplace
d180 1
a180 1
    RWBoolean            // TRUE if no error was encountered
d182 2
a183 2
         const RWCString fileName,
         const RWCString & title = 
d185 1
a185 1
         const int iosMode = ios::out | ios::noreplace
d190 1
a190 1
    RWBoolean            // TRUE if no error was encountered
d192 2
a193 2
         const RWCString fileName,
         const RWCString & title = 
d195 1
a195 1
         const int iosMode = ios::out | ios::noreplace
d206 3
a208 3
  //        ios::out | ios::noreplace  Don't overwrite an existing file.
  //        ios::out | ios::app        Append to an existing file.
  //        ios::out                   OK to overwrite an existing file.
d210 1
a210 1
  // returns TRUE if no error was encountered
d213 1
a213 1
    RWBoolean            // TRUE if no error was encountered
d216 2
a217 2
         const RWCString fileName,
         const RWCString & title1 = 
d219 1
a219 1
         const RWCString & title2 = 
d222 1
a222 1
         const int iosMode = ios::out | ios::noreplace
d251 1
@


1.2.6.1
log
@Roguewave is gone
@
text
@a2 4
// RW2STL -- inserted:
#include <fstream>
#include <string>
// End of RW2STL -- inserted includes.
d32 11
a42 11
  static const std::string writeScheduleTitle;
  static const std::string fopenAccessModeAppend;
  static const std::string writeProductionScheduleTitle;
  static const std::string writeShipmentScheduleTitle;
  static const std::string writeRequirementScheduleTitle;
  static const std::string writeCriticalListTitle;
  static const std::string writeChangedSupplyVolumeTitle;
  static const std::string writeChangedDemandVolumeTitle;
  static const std::string writeChangedPriorityTitle;
  static const std::string writeFocusShortageScheduleTitle;
  static const std::string writeFocusShortageScheduleFocusHorizonTitle;
d49 1
a49 1
    bool            // true if no error was encountered
d56 1
a56 1
         const std::string& fileName,
d59 1
a59 1
         const std::string & title = 
d64 4
a67 4
         //     std::ofstream::out | noReplace          Don't overwrite an existing file.
         //     std::ofstream::out | std::ofstream::app Append to an existing file.
         //     std::ofstream::out                      OK to overwrite an existing file.
         const int iosMode = std::ofstream::out | noReplace
d70 1
a70 1
        )
d81 1
a81 1
  // returns true if no error was encountered
d85 1
a85 1
    bool            // true if no error was encountered
d87 2
a88 2
         const std::string& fileName,
         const std::string & fopenAccessMode = 
d93 1
a93 1
    bool            // true if no error was encountered
d95 2
a96 2
         const std::string& fileName,
         const std::string & fopenAccessMode =             
d101 1
a101 1
    bool            // true if no error was encountered
d103 2
a104 2
         const std::string& fileName,
         const std::string & fopenAccessMode =             
d116 3
a118 3
  //        std::ofstream::out | std::ofstream::noreplace  Don't overwrite an existing file.
  //        std::ofstream::out | std::ofstream::app        Append to an existing file.
  //        std::ofstream::out                   OK to overwrite an existing file.
d120 1
a120 1
  // returns true if no error was encountered
d125 1
a125 1
    bool            // true if no error was encountered
d127 2
a128 2
         const std::string& fileName,
         const std::string & title = 
d130 1
a130 1
         const int iosMode = std::ofstream::app
d136 1
a136 1
    bool            // true if no error was encountered
d138 2
a139 2
         const std::string& fileName,
         const std::string & title = 
d141 1
a141 1
         const int iosMode = std::ofstream::app
d146 1
a146 1
    bool            // true if no error was encountered
d148 2
a149 2
         const std::string& fileName,
         const std::string & title = 
d151 1
a151 1
         const int iosMode = std::ofstream::app
d156 1
a156 1
    bool            // true if no error was encountered
d158 2
a159 2
         const std::string& fileName,
         const std::string & title = 
d161 1
a161 1
         const int iosMode = std::ofstream::app
d166 1
a166 1
    bool            // true if no error was encountered
d168 2
a169 2
         const std::string& fileName,
         const std::string & title = 
d171 1
a171 1
         const int iosMode = std::ofstream::app
d176 1
a176 1
    bool            // true if no error was encountered
d178 2
a179 2
         const std::string& fileName,
         const std::string & title = 
d181 1
a181 1
         const int iosMode = std::ofstream::app
d186 1
a186 1
    bool            // true if no error was encountered
d188 2
a189 2
         const std::string& fileName,
         const std::string & title = 
d191 1
a191 1
         const int iosMode = std::ofstream::app
d202 3
a204 3
  //        std::ofstream::out | std::ofstream::noreplace  Don't overwrite an existing file.
  //        std::ofstream::out | std::ofstream::app        Append to an existing file.
  //        std::ofstream::out                   OK to overwrite an existing file.
d206 1
a206 1
  // returns true if no error was encountered
d209 1
a209 1
    bool            // true if no error was encountered
d212 2
a213 2
         const std::string& fileName,
         const std::string & title1 = 
d215 1
a215 1
         const std::string & title2 = 
d218 1
a218 1
         const int iosMode = std::ofstream::app
a246 1
  static const int noReplace;
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
  static const LgFrSchedulePrintStyle LgFrSolutionOutputInterface::pmTEXT;
@


1.1.1.1
log
@Import scenario
@
text
@@

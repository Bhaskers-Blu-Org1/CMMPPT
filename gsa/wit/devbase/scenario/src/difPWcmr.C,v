head	1.5;
access;
symbols
	sce_5_01_20080919:1.5
	latest_sce_4_20_20060523:1.5.0.6
	sce_4_20_20060523:1.5
	latest_sce4_20_OSL:1.5.0.4
	sce_4_20_OSL:1.5
	sce_4_05_20040511:1.5
	sce_4_00_20040201:1.5
	nextGenBranch:1.5.0.2
	nextGenRoot:1.5
	sce_3_30_20030627:1.5
	EndRw-branch:1.3.0.2
	Root-of-EndRw:1.3
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.01.15.23.05.47;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.15.19.36.33;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.00.35.03;	author fasano;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.12.02.17.42.23;	author austel;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.29.40;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.40;	author wit;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.08.17.42.28;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Modified to build on windows laptop that was causing compiler to run out of stack space
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#endif

// RW2STL -- inserted:
#include <string>
// End of RW2STL -- inserted includes.
#include <math.h>
#include <iostream>


#include <scenario/src/dif.h>
#include <scenario/src/difImpl.h>
#include <scenario/src/difPWcmr.h>
#include <scenario/src/calendar.h>
#include <scenario/src/difEssSc.h>
#include <scenario/src/timeVecs.h>

// -----------------------------------------------------------------------
//
//  Register all functions
//
// -----------------------------------------------------------------------

void
registerPWcmrpDifImpFunctions(
    LgFrDataInterfaceImplementation * dImp) 
{
    // Register all raw material attribute functions
    dImp->registerFunction("rawUnitCost", material, part,
			   vectorFloat, difPWcmrpGetRawUnitCost);
    dImp->registerFunction("rawProcCost", material, part,
			   vectorFloat, difPWcmrpGetRawProcCost);
    dImp->registerFunction("rawConstrained", material, part,
			   vectorInt, difPWcmrpGetRawConstrained);
    dImp->registerFunction("rawProcLeadTime", material, part,
			   timeVecFloat, difPWcmrpGetRawProcLeadTime);
    dImp->registerFunction("rawObj1ScrapCost", material, part,
			   timeVecFloat, difPWcmrpGetRawObj1ScrapCost);
    dImp->registerFunction("rawObj1StockCost", material, part,
			   timeVecFloat, difPWcmrpGetRawObj1StockCost);
    dImp->registerFunction("rawSupplyVol", material, part,
			   timeVecFloat, difPWcmrpGetRawSupplyVol);

    // Register all product attribute functions
    dImp->registerFunction("productUnitCost", material, part,
			   vectorFloat, difPWcmrpGetProductUnitCost);
    dImp->registerFunction("productProcCost", material, part,
			   vectorFloat, difPWcmrpGetProductProcCost);
    dImp->registerFunction("productConstrained", material, part,
			   vectorInt, difPWcmrpGetProductConstrained);
    dImp->registerFunction("productProcLeadTime", material, part,
			   timeVecFloat, difPWcmrpGetProductProcLeadTime);
    dImp->registerFunction("productYield", material, part,
			   vectorInt, difPWcmrpGetProductYield);
    dImp->registerFunction("productCycleTime", material, part,
			   timeVecFloat, difPWcmrpGetProductCycleTime);
    dImp->registerFunction("obj1ProdCost", material, part,
			   timeVecFloat, difPWcmrpGetObj1ProdCost);
    dImp->registerFunction("productObj1ScrapCost", material, part,
			   timeVecFloat, difPWcmrpGetProductObj1ScrapCost);
    dImp->registerFunction("productObj1StockCost", material, part,
			   timeVecFloat, difPWcmrpGetProductObj1StockCost);
    dImp->registerFunction("productSupplyVol", material, part,
			   timeVecFloat, difPWcmrpGetProductSupplyVol);
    dImp->registerFunction("productMinLotSize", material, part,
			   timeVecFloat, difPWcmrpGetProductMinLotSize);

    // Register all capacity attribute functions
    dImp->registerFunction("capacityUnitCost", material, part,
			   vectorFloat, difPWcmrpGetCapacityUnitCost);
    dImp->registerFunction("capacityConstrained", material, part,
			   vectorInt, difPWcmrpGetCapacityConstrained);
    dImp->registerFunction("capacityObj1ScrapCost", material, part,
			   timeVecFloat, difPWcmrpGetCapacityObj1ScrapCost);
    dImp->registerFunction("capacitySupplyVol", material, part,
			   timeVecFloat, difPWcmrpGetCapacitySupplyVol);

    // Register all functions to obtain demands
    dImp->registerFunction("committedDemands", demandType, demand,
		   orderedVecDemand, difPWcmrpGetCommittedDemands);
    dImp->registerFunction("newOpportunityDemands", demandType, demand,
		   orderedVecDemand, difPWcmrpGetNewOpportunityDemands);
    dImp->registerFunction("firmForecastDemands", demandType, demand,
			   orderedVecDemand, difPWcmrpGetFirmForecastDemands);
    dImp->registerFunction("riskForecastDemands", demandType, demand,
			   orderedVecDemand, difPWcmrpGetRiskForecastDemands);

    // Register all demand attribute functions
    dImp->registerFunction("demandGrossRev", demandType, demand,
			   vectorFloat, difPWcmrpGetDemandGrossRev);
    dImp->registerFunction("demandVol", demandType, demand,
			   timeVecFloat, difPWcmrpGetDemandVol);
    dImp->registerFunction("demandObj1CumShipReward", demandType, demand,
			   timeVecFloat, difPWcmrpGetDemandObj1CumShipReward);
    dImp->registerFunction("demandObj1ShipReward", demandType, demand,
			   timeVecFloat, difPWcmrpGetDemandObj1ShipReward);

    // jmt 6/27/95 need to have partTable and demandTable (similar to attrTable)
    // Register all functions to obtain parts
    dImp->registerFunction("rawParts", material, part,
			   orderedVecPart, difPWcmrpGetRawParts);
    dImp->registerFunction("productParts", material, part,
			   orderedVecPart, difPWcmrpGetProductParts);
    dImp->registerFunction("capacityParts", material, part,
			   orderedVecPart, difPWcmrpGetCapacityParts);

    // Register define bom globle function
    dImp->registerFunction("defineBom", material, part,
			   timeVecFloat, difPWcmrpDefineBom);

}

//-------------------------------------------------------------------
//  
//   Create a LgFrDataInterfaceImplementation object
//
//-------------------------------------------------------------------

LgFrDataInterfaceImplementation * createPWcmrpDifImp()
{
   return new LgFrDataInterfaceImplementation("internal data set pw1");
} 

//-------------------------------------------------------------------
//  
//   Global functions to obtain the defined parts and capacities.
//
//-------------------------------------------------------------------

// Return vector of raw materials.
// difPWcmrpGetRawParts global function (registering in the attribute table).
// Get raw parts for the perfect world CMRP and insert them into set_of_part
// Return: a LgFrPartVector object (vector of raw parts).
void *
difPWcmrpGetRawParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 ) 
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  LgFrPart part = difEssenPtr->createAndInsertPart("MEM_Module");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("CPU_Type_F");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("CPU_Type_S");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("RAW_Board_F");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("RAW_Board_S");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Disk_Drive_L");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Disk_Drive_S");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Screen_L");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Screen_S");
  retVal.push_back(part);
  status = 0;
  return &retVal;
}

// difPWcmrpGetProdcutParts global function (registering in the attribute table).
// Get product parts for the perfect world CMRP and insert it into set_of_part
// Return: a LgFrPartVector object (vector of producible parts)
void*
difPWcmrpGetProductParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrPartVector& retVal = *(new LgFrPartVector);

  // Subassemblies:
  LgFrPart part = difEssenPtr->createAndInsertPart("System_Board_1");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("System_Board_2");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("System_Board_3");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("System_Board_4");
  retVal.push_back(part);

  // Final Products
  part = difEssenPtr->createAndInsertPart("Computer_1");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_2");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_3");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_4");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_5");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_6");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_7");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Computer_8");
  retVal.push_back(part);
  status = 0;
  return &retVal;
}

// difPWcmrpGetCapacityParts global function (registering in the attribute table).
// Get capacity parts for the perfect world CMRP and insert it into set_of_part
// Return: a LgFrPartVector object (vector of producible parts)
void*
difPWcmrpGetCapacityParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 ) 
{
  LgFrPartVector& retVal = *(new LgFrPartVector);

  LgFrPart part = difEssenPtr->createAndInsertPart("Board_Assembly");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("Board_Test");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("System_Assembly");
  retVal.push_back(part);
  part = difEssenPtr->createAndInsertPart("System_Test");
  retVal.push_back(part);
  status = 0;
  return &retVal;
}

//-------------------------------------------------------------------
//  
//   Global functions to obtain raw material attributes
//
//-------------------------------------------------------------------

// difPWcmrpGetRawUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difPWcmrpGetRawUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    if ( pv[i]->name() == "MEM_Module" )
       retVal.push_back( 60.0 );
    else if ( pv[i]->name() == "CPU_Type_F" )
       retVal.push_back( 420.0 );
    else if ( pv[i]->name() == "CPU_Type_S" )
       retVal.push_back( 200.0 );
    else if ( pv[i]->name() == "RAW_Board_F" ) 
       retVal.push_back( 10.0 );
    else if ( pv[i]->name() == "RAW_Board_S" ) 
       retVal.push_back( 5.0 );
    else if ( pv[i]->name() == "Screen_L" ) 
       retVal.push_back( 1000.0 );
    else if ( pv[i]->name() == "Screen_S" ) 
       retVal.push_back( 430.0 );
    else if ( pv[i]->name() == "Disk_Drive_L" ) 
       retVal.push_back( 450.0 );
    else if ( pv[i]->name() == "Disk_Drive_S" ) 
       retVal.push_back( 300.0 );
    else
       retVal.push_back( 0.0 );
  }
  status = 0;
  return &retVal;
}
  
// difPWcmrpGetRawProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difPWcmrpGetRawProcCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.23f );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetRawConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difPWcmrpGetRawConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    if ( pv[i]->name() == "MEM_Module" )
       retVal.push_back( true );
    else if ( pv[i]->name() == "Screen_S" )
       retVal.push_back( true );
    else
       retVal.push_back( false );
  }
  status = 0;
  return &retVal; 
}

// difPWcmrpGetRawProcLeadTime global function (registered in the attribute table).
// It returns a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetRawProcLeadTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    if ( pv[i]->name() == "MEM_Module" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 8.0 ) );
    else if ( pv[i]->name() == "CPU_Type_F" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 3.0 ) );
    else if ( pv[i]->name() == "CPU_Type_S" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 2.0 ) );
    else if ( pv[i]->name() == "Screen_S" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 8.0 ) );
    else if ( pv[i]->name() == "Disk_Drive_L" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0 ) );
    else if ( pv[i]->name() == "Disk_Drive_S" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0 ) );
    else
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0 ) );
  }
  status = 0;
  return &retVal;
}      

// difPWcmrpGetRawObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetRawObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.12f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetRawObj1StockCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetRawObj1StockCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.10f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetRawSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetRawSupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    if ( pv[i]->name() == "MEM_Module" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 6000. 6000. 6000. 6000. 6000." ) );
    else if ( pv[i]->name() == "CPU_Type_F" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , "0. 700. 700. 700. 700. 0. 0. 0." ) );
    else if ( pv[i]->name() == "CPU_Type_S" )    
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Screen_S")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "1500. 1500. 2000. 2000. 2000. 2000. 2000. 2000." ) );
    else if ( pv[i]->name() == "Disk_Drive_L")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "3000. 0. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Disk_Drive_S")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 0. 0. 0. 0. 0. 0. 0." ) );
    else      
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0 ) );
  }  
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain producible part attributes
//
//-------------------------------------------------------------------

// difPWcmrpGetProductUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difPWcmrpGetProductUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    if ( pv[i]->name() == "Computer_1" )
       retVal.push_back( 1940. );
    else if ( pv[i]->name() == "Computer_2" )
       retVal.push_back( 2000. );
    else if ( pv[i]->name() == "Computer_3" )    
       retVal.push_back( 1715. );
    else if ( pv[i]->name() == "Computer_4")
       retVal.push_back( 1775. );
    else if ( pv[i]->name() == "Computer_5")
       retVal.push_back( 1565. );
    else if ( pv[i]->name() == "Computer_6")
       retVal.push_back( 1625. );
    else if ( pv[i]->name() == "Computer_7")
       retVal.push_back( 995. );
    else if ( pv[i]->name() == "Computer_8")
       retVal.push_back( 1055. );
    else if ( pv[i]->name() == "System_Board_1")
       retVal.push_back( 490. );
    else if ( pv[i]->name() == "System_Board_2")
       retVal.push_back( 550. );
    else if ( pv[i]->name() == "System_Board_3")
       retVal.push_back( 265. );
    else if ( pv[i]->name() == "System_Board_4")
       retVal.push_back( 325. );
    else
       retVal.push_back( 0.0 );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difPWcmrpGetProductProcCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.43f );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difPWcmrpGetProductConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( true );
  }
  status = 0;
  return &retVal; 
} 

// difPWcmrpGetProductProcLeadTime global function (registered in the attribute table).
// It returns a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetProductProcLeadTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    retVal.push_back( LgFrTimeVecFloat( nperiods , -2.0 ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductYield global function (registered in the attribute table).
// Return: a LgFrFloatVector object
void *
difPWcmrpGetProductYield(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 100 );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductCycleTime global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetProductCycleTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    if ( pv[i]->name() == "System_Board_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.2f ) );
    else if ( pv[i]->name() == "System_Board_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.9f ) );
    else if (pv[i]->name() == "System_Board_3")
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.5f ) );
    else if (pv[i]->name() == "System_Board_4")
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.7f ) );
    else
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
  }  
  status = 0;
  return &retVal;
}

// difPWcmrpGetObj1ProdCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetObj1ProdCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 3.4f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetProductObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductObj1StockCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetProductObj1StockCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.83f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetProductSupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    if ( pv[i]->name() == "Computer_1" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
    else if ( pv[i]->name() == "Computer_2" )
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
    else if ( pv[i]->name() == "Computer_3" )    
       retVal.push_back( LgFrTimeVecFloat( nperiods , "100. 100. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Computer_4")
       retVal.push_back( LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Computer_5")
       retVal.push_back( LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Computer_6")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "150. 200. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Computer_7")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "100. 200. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "Computer_8")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "200. 300. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "System_Board_1")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "650. 625. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "System_Board_2")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "800. 730. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "System_Board_3")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "2600. 3000. 0. 0. 0. 0. 0. 0." ) );
    else if ( pv[i]->name() == "System_Board_4")
       retVal.push_back( LgFrTimeVecFloat( nperiods , "2800. 3000. 0. 0. 0. 0. 0. 0." ) );
    else
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetProductMinLotSize global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void*
difPWcmrpGetProductMinLotSize(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<pv.size(); i++ ) { 
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0f ) );
  }
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain capacity attributes
//
//-------------------------------------------------------------------

// difPWcmrpGetCapacityUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difPWcmrpGetCapacityUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.46f );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetCapacityConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difPWcmrpGetCapacityConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( true );
  }
  status = 0;
  return &retVal; 
} 

// difPWcmrpGetCapacityObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetCapacityObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.73f ) );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetCapacitySupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetCapacitySupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    if ( pv[i]->name() == "Board_Assembly")
      retVal.push_back( LgFrTimeVecFloat(nperiods, "900. 900. 900. 900. 900. 900. 900. 900." ) );
    else if ( pv[i]->name() == "Board_Test") 
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1300. 1300. 1300. 1300. 1300. 1300. 1300. 1300." ) );
    else if ( pv[i]->name() == "System_Assembly")    
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." ) );
    else if ( pv[i]->name() == "System_Test")    
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." ) );
    else
      retVal.push_back( LgFrTimeVecFloat(nperiods , 0.0f ) );
  }
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain demands
//
//-------------------------------------------------------------------

// difPWcmrpGetCommittedDemands global function (registering in the attribute table).
// Get committed demands for the perfect world CMRP and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of committed demands).
void *
difPWcmrpGetCommittedDemands(
  const LgFrDataInterfaceImplementation * /* dImp,not used */,
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  // All demand names
  int nDemands = 13;
  std::string dn[] = 
  {
      "Albert_Einstein",
      "Robert_Oppenheimer",
      "Issac_Newton",
      "Mr_Pythagoras",
      "Turings_Machine_Shop",
      "Joseph_Orlicky",
      "Michael_Faraday",
      "Michael_Faraday",
      "Leonhard_Euler",
      "Thomas_Edisons_Repair",
      "Thomas_Edisons_Repair",
      "Thomas_Edisons_Repair",
      "Thomas_Edisons_Repair"
  };

  // All part names
  std::string pn[] =
  {
      "Computer_1",
      "Computer_2",
      "Computer_3",
      "Computer_4",
      "Computer_5",
      "Computer_6",
      "Computer_7",
      "System_Board_3",
      "Computer_8",
      "System_Board_1",
      "System_Board_2",
      "System_Board_3",
      "System_Board_4"
  };
  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
      {
	  LgFrDemand demand = 
	      difEssenPtr->createAndInsertDemand(dn[i], pn[i]);
	  retVal.push_back(demand);
      }
  status = 0;
  return &retVal;    
}

// difPWcmrpGetNewOpportunityDemands global function (registering in the attribute table).
// Get new opportunity demands for perfect world CMRP and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of new opportunity demands).
void *
difPWcmrpGetNewOpportunityDemands(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  // All demand names
  int nDemands = 3;
  std::string dn[] = 
  {
      "NewOpportunity",
      "NewOpportunity",
      "NewOpportunity"
  };

  // All part names
  std::string pn[] =
  {
      "Computer_1",
      "Computer_2",
      "Computer_3"
  };
  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
      {
	  LgFrDemand demand = 
	      difEssenPtr->createAndInsertDemand(dn[i], pn[i]);
	  retVal.push_back(demand);
      }
  status = 0;
  return &retVal;    
}

// difPWcmrpGetFirmForecastDemands global function (registering in the attribute table).
// Get firm forcast demands for perfect world CMRP and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of firm forcast demands).
void *
difPWcmrpGetFirmForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  // All demand names
  int nDemands = 12;
  std::string dn[] = 
  {
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast",
      "FirmForecast"
  };

  // All part names
  std::string pn[] =
  {
      "Computer_1",
      "Computer_2",
      "Computer_3",
      "Computer_4",
      "Computer_5",
      "Computer_6",
      "Computer_7",
      "Computer_8",
      "System_Board_1",
      "System_Board_2",
      "System_Board_3",
      "System_Board_4"
  };
  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
      {
	  LgFrDemand demand = 
	      difEssenPtr->createAndInsertDemand(dn[i], pn[i]);
	  retVal.push_back(demand);
      }
  status = 0;
  return &retVal;    
}

// difPWcmrpGetRiskForecastDemands global function (registering in the attribute table).
// Get risk forcast demands for perfect world CMRP and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of risk forcast demands).
void *
difPWcmrpGetRiskForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  // All demand names
  int nDemands = 3;
  std::string dn[] = 
  {
      "RiskForecast",
      "RiskForecast",
      "RiskForecast" 
  };

  // All part names
  std::string pn[] =
  {
      "Computer_1",
      "Computer_2",
      "Computer_3"
  };
  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
      {
	  LgFrDemand demand = 
	      difEssenPtr->createAndInsertDemand(dn[i], pn[i]);
	  retVal.push_back(demand);
      }
  status = 0;
  return &retVal;    
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain demand attributes
//
//-------------------------------------------------------------------

// difPWcmrpGetDemandGrossRev global function (registering in the attribute table).
// Compute total demand gross revenue
// Return: a LgFrFloatVector object (vector of demand gross revenues).
void *
difPWcmrpGetDemandGrossRev(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
 )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
  
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    if      ( dv[i]->name() == "Albert_Einstein" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Robert_Oppenheimer" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Issac_Newton" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Mr_Pythagoras" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Joseph_Orlicky" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Michael_Faraday" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Leonhard_Euler" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Turings_Machine_Shop" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "NewOpportunity" )  retVal.push_back( 222.f );
    else if ( dv[i]->name() == "FirmForecast" )  retVal.push_back( 333.f );
    else if ( dv[i]->name() == "RiskForecast" )  retVal.push_back( 444.f );
    else assert( 0 && "illegal demand name for Gross Revenue" );
  }
  status = 0;
  return &retVal;
}

// difPWcmrpGetDemandVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetDemandVol(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
    if ( dv[i]->name() == "Albert_Einstein" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "300. 300. 300. 300. 300. 200. 200. 100." ) );
    }  
    else if ( dv[i]->name() == "Robert_Oppenheimer" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "450. 350. 350. 350. 350. 150. 150. 150." ) );
    }
    else if ( dv[i]->name() == "Issac_Newton" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "500. 500. 400. 400. 300. 300. 300. 300." ) );
    }
    else if ( dv[i]->name() == "Mr_Pythagoras" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_4" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "600. 600. 600. 300. 300. 300. 200. 200." ) );
    }
    else if ( dv[i]->name() == "Joseph_Orlicky" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_6" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "750. 750. 750. 750. 600. 600. 600. 600." ) );
    }
    else if ( dv[i]->name() == "Michael_Faraday" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_7" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "700. 700. 700. 500. 500. 500. 500. 500." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "30. 30. 30. 20. 20. 20. 20. 20." ) );
    }
    else if ( dv[i]->name() == "Leonhard_Euler" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_8" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "900. 900. 800. 800. 800. 600. 600. 600." ) );
    }
    else if (dv[i]->name() == "Turings_Machine_Shop" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_5" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "800. 800. 800. 800. 500. 500. 500. 500." ) );
    }
    else if (dv[i]->name() == "Thomas_Edisons_Repair" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "10. 10. 10. 10. 10. 10. 10. 10." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "20. 20. 20. 10. 10. 10. 10. 10." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "40. 40. 40. 30. 30. 20. 20. 20." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_4" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "90. 90. 60. 60. 60. 60. 60.  60." ) );
    }    
    else if ( dv[i]->name() == "FirmForecast" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "100. 100. 100. 100. 100. 300. 300. 400." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, "100. 100. 300. 350. 350. 450. 500. 500." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,  "100. 100. 300. 300. 300. 300. 350. 350." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_4" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,  "100. 100. 400. 400. 400. 400. 750. 750." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_5" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 250. 250. 500. 500. 550. 550." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_6" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 300. 300. 300. 300. 500. 500." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_7" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 100. 500. 500. 500. 500. 500." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_8" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 200. 200. 400. 500. 500. 600. 600." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "10. 10. 20. 20. 20. 20. 20. 20." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "10. 10. 10. 30. 30. 30. 30. 30." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90." ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_4" )
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90." ) );
    }
    else if ( dv[i]->name() == "RiskForecast" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
    }      
    else if ( dv[i]->name() == "NewOpportunity" )  
        retVal.push_back( LgFrTimeVecFloat( nperiods, 0.0f ) );
    else assert( 0 && "illegal demand name for Demand Vol" );
  }      
  status = 0;
  return &retVal;
}

// difPWcmrpGetDemanObj1CumShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetDemandObj1CumShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
    if ( dv[i]->name() == "Albert_Einstein" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_1" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
    }
    else if ( dv[i]->name() == "Robert_Oppenheimer" ){    
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_2" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 125.f ) );
    }
    else if ( dv[i]->name() == "Issac_Newton" ){        
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
    }
    else if ( dv[i]->name() == "Mr_Pythagoras" ){     
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_4" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 125.f ) );
    }
    else if ( dv[i]->name() == "Joseph_Orlicky" ){    
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_6" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 90.f ) );
    }
    else if ( dv[i]->name() == "Michael_Faraday" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_7" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
      else if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "System_Board_3" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 90.f ) );
    }
    else if ( dv[i]->name() == "Leonhard_Euler" ){    
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_8" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 110.f ) );
    }
    else if ( dv[i]->name() == "Turings_Machine_Shop" ){
      if ( (((LgFrDemand*)dv[i])->partPtr()->name()) == "Computer_5" )
        retVal.push_back( LgFrTimeVecFloat( nperiods, 80.f ) );
    }
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 30.f ) );
    else if ( dv[i]->name() == "FirmForecast" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 0.f ) );
    else if ( dv[i]->name() == "RiskForecast" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 0.f ) );
    else assert( 0 && "illegal demand name for Cummulative Shipment Reward" );
  }      
  status = 0;
  return &retVal;
}

// difPWcmrpGetDemanObj1ShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difPWcmrpGetDemandObj1ShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
 )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 1.f ) );
  }      
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global function to define BOM
//
//-------------------------------------------------------------------
void*
difPWcmrpDefineBom(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
    LgFrError &, // status, 
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
   WitRun* eater = 
     ((LgFrDataInterfaceEssentialsFromScenario*)difEssenPtr)
     ->mutableWitRun();
   
   witAddBomEntry(eater,"System_Board_1","MEM_Module");
   witAddBomEntry(eater,"System_Board_1","CPU_Type_F");
   witAddBomEntry(eater,"System_Board_1","RAW_Board_F");
   witAddBomEntry(eater,"System_Board_1","Board_Assembly");
   witSetBomEntryUsageRate(eater,"System_Board_1", 3, 0.2f);    
   witAddBomEntry(eater,"System_Board_1","Board_Test");
   witSetBomEntryUsageRate(eater,"System_Board_1", 4, 0.1f);
   

   
   witAddBomEntry(eater,"System_Board_2","MEM_Module");
   witSetBomEntryUsageRate(eater,"System_Board_2", 0, 2); 
   witAddBomEntry(eater,"System_Board_2","CPU_Type_F");
   witAddBomEntry(eater,"System_Board_2","RAW_Board_F");
   witAddBomEntry(eater,"System_Board_2","Board_Assembly");
   witSetBomEntryUsageRate(eater,"System_Board_2", 3, 0.2f);    
   witAddBomEntry(eater,"System_Board_2","Board_Test");
   witSetBomEntryUsageRate(eater,"System_Board_2", 4, 0.2f);   

 
   
   witAddBomEntry(eater,"System_Board_3","MEM_Module");
   witAddBomEntry(eater,"System_Board_3","CPU_Type_S");
   witAddBomEntry(eater,"System_Board_3","RAW_Board_S");
   witAddBomEntry(eater,"System_Board_3","Board_Assembly");
   witSetBomEntryUsageRate(eater,"System_Board_3", 3, 0.1f);    
   witAddBomEntry(eater,"System_Board_3","Board_Test");
   witSetBomEntryUsageRate(eater,"System_Board_3", 4, 0.1f);      


   
   witAddBomEntry(eater,"System_Board_4","MEM_Module");
   witSetBomEntryUsageRate(eater,"System_Board_4", 0, 2);    
   witAddBomEntry(eater,"System_Board_4","CPU_Type_S");
   witAddBomEntry(eater,"System_Board_4","RAW_Board_S");
   witAddBomEntry(eater,"System_Board_4","Board_Assembly");
   witSetBomEntryUsageRate(eater,"System_Board_4", 3, 0.1f);    
   witAddBomEntry(eater,"System_Board_4","Board_Test");
   witSetBomEntryUsageRate(eater,"System_Board_4", 4, 0.2f);     

     
   
   witAddBomEntry(eater,"Computer_1","System_Board_1");
   witAddBomEntry(eater,"Computer_1","Disk_Drive_L");
   witAddBomEntry(eater,"Computer_1","Screen_L");
   witAddBomEntry(eater,"Computer_1","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_1", 3, 0.2f);    
   witAddBomEntry(eater,"Computer_1","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_1", 4, 0.3f);
   
   


   witAddBomEntry(eater,"Computer_2","System_Board_2");
   witAddBomEntry(eater,"Computer_2","Disk_Drive_L");
   witAddBomEntry(eater,"Computer_2","Screen_L");
   witAddBomEntry(eater,"Computer_2","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_2", 3, 0.2f);    
   witAddBomEntry(eater,"Computer_2","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_2", 4, 0.4f);   
   

   
   witAddBomEntry(eater,"Computer_3","System_Board_3");
   witAddBomEntry(eater,"Computer_3","Disk_Drive_L");
   witAddBomEntry(eater,"Computer_3","Screen_L");
   witAddBomEntry(eater,"Computer_3","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_3", 3, 0.2f);    
   witAddBomEntry(eater,"Computer_3","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_3", 4, 0.2f);    

   
   
   witAddBomEntry(eater,"Computer_4","System_Board_4");
   witAddBomEntry(eater,"Computer_4","Disk_Drive_L");
   witAddBomEntry(eater,"Computer_4","Screen_L");
   witAddBomEntry(eater,"Computer_4","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_4", 3, 0.2f);    
   witAddBomEntry(eater,"Computer_4","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_4", 4, 0.1f);       
   


   witAddBomEntry(eater,"Computer_5","System_Board_3");
   witAddBomEntry(eater,"Computer_5","Disk_Drive_S");
   witAddBomEntry(eater,"Computer_5","Screen_L");
   witAddBomEntry(eater,"Computer_5","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_5", 3, 0.15f);    
   witAddBomEntry(eater,"Computer_5","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_5", 4, 0.15f);       
      
   

   
   witAddBomEntry(eater,"Computer_6","System_Board_4");
   witAddBomEntry(eater,"Computer_6","Disk_Drive_S");
   witAddBomEntry(eater,"Computer_6","Screen_L");
   witAddBomEntry(eater,"Computer_6","System_Assembly");
   witSetBomEntryUsageRate(eater,"Computer_6", 3, 0.15f);    
   witAddBomEntry(eater,"Computer_6","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_6", 4, 0.1f);     
   

   
   witAddBomEntry(eater,"Computer_7","System_Board_3");
   witAddBomEntry(eater,"Computer_7","Disk_Drive_S");
   witAddBomEntry(eater,"Computer_7","Screen_S");
   witAddBomEntry(eater,"Computer_7","System_Assembly");   
   witSetBomEntryUsageRate(eater,"Computer_7", 3, 0.1f);    
   witAddBomEntry(eater,"Computer_7","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_7", 4, 0.1f);   
   

   
   witAddBomEntry(eater,"Computer_8","System_Board_4");
   witAddBomEntry(eater,"Computer_8","Disk_Drive_S");
   witAddBomEntry(eater,"Computer_8","Screen_S");
   witAddBomEntry(eater,"Computer_8","System_Assembly");   
   witSetBomEntryUsageRate(eater,"Computer_8", 3, 0.15f);    
   witAddBomEntry(eater,"Computer_8","System_Test");
   witSetBomEntryUsageRate(eater,"Computer_8", 4, 0.1f);      
   return 0;
}   

#ifdef NDEBUG
#undef NDEBUG
#endif
// tdif1 is a LgFrDataInterfaceImplementationPerfectWorldCMRP dif.
// ts1dupDif is the dif contained in the scenario created by invoking
// the scenario copy contructor on the scenario containing tdif1.
void
difPWcmrpContextTest(
   LgFrDataInterface    	& tdif1,	// testScenario1's
   LgFrDataInterface    	& ts1dupDif,	// testScenario1dup's
   const LgFrScenario           * scenPtr)	// testScenario1's
{
  const float fltEps = .0001f;

  LgFrDataInterfaceImplementation* dImp 
      = tdif1.dataInterfaceImplementation();
  LgFrDataInterfaceImplementation* dImptsi 
      = ts1dupDif.dataInterfaceImplementation();

  // Test title method
  assert( dImp->title() == "internal data set pw1" );
  assert( dImptsi->title()=="internal data set pw1" );
  assert( tdif1.title() == "internal data set pw1");
  assert( ts1dupDif.title() == "internal data set pw1");

  // Register all functions
  registerPWcmrpDifImpFunctions(dImp);

  // Test Get Part global functions
  LgFrDataInterfaceEssentialsFromScenario difEssen(scenPtr);
  LgFrPartVector pv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	pv, itemSubTypeStr, "rawParts", &difEssen);
  LgFrPartVector raw = *rawPartsPtr;

  assert( raw.size() == 9 );
  assert( raw[1].name() == "CPU_Type_F" );

  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	pv, itemSubTypeStr, "productParts", &difEssen);
  LgFrPartVector product = *productPartsPtr;

  assert( product.size() == 12 );
  assert( product[11].name() == "Computer_8" );

  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
	pv, itemSubTypeStr, "capacityParts", &difEssen);
  LgFrPartVector capacity = *capacityPartsPtr;

  assert( capacity.size() == 4 );
  assert( capacity[1].name() == "Board_Test" );

  // Test get raw material attributes functions
  {
  LgFrFloatVector* unitCostPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
	raw, itemSubTypeStr, "rawUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 9 );

  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
	  raw, itemSubTypeStr, "rawConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 9 );
  assert( constrained[0] );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=1; i<7; i++)
     assert( !constrained[i] );
  assert( constrained[8] );

  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  raw, itemSubTypeStr, "rawObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 9 );

  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  raw, itemSubTypeStr, "rawObj1StockCost", &difEssen);
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 9 );
  
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  raw, itemSubTypeStr, "rawSupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 9 );

  delete unitCostPtr;
  delete constrainedPtr;
  delete obj1ScrapCostPtr;
  delete obj1StockCostPtr;
  delete supplyVolPtr;

}

  delete rawPartsPtr;
  // Test get product attributes global functions
  {
  LgFrTimeVecFloatVector* cycleTimePtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productCycleTime", &difEssen);
  LgFrTimeVecFloatVector cycleTime = *cycleTimePtr;
  assert( cycleTime.size() == 12 );

  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 12 );
  
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 12 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.size(); i++)
  assert( constrained[i] );

  LgFrIntVector* yieldPtr
      = (LgFrIntVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productYield", &difEssen);
  LgFrIntVector yield = *yieldPtr;
  assert( yield.size() == 12 );

  LgFrTimeVecFloatVector* obj1ProdCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "obj1ProdCost", &difEssen);
  LgFrTimeVecFloatVector obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.size() == 12 );

  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 12 );
  
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productObj1StockCost", &difEssen);
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 12 );
  
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  product, itemSubTypeStr, "productSupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 12 );

  delete cycleTimePtr;
  delete unitCostPtr;
  delete constrainedPtr;
  delete yieldPtr;
  delete obj1ProdCostPtr;
  delete obj1ScrapCostPtr;
  delete obj1StockCostPtr;
  delete supplyVolPtr;

  }

  delete productPartsPtr;

  // Test get capacity attributes global functions
  {
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) tdif1.partAttribute(
	  capacity, itemSubTypeStr, "capacityUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 4 );

  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
	  capacity, itemSubTypeStr, "capacityConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 4 );
  assert( constrained[0] );

  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  capacity, itemSubTypeStr, "capacityObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 4 );

  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
	  capacity, itemSubTypeStr, "capacitySupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 4 );

  delete unitCostPtr;
  delete constrainedPtr;
  delete obj1ScrapCostPtr;
  delete supplyVolPtr;

  }

  delete capacityPartsPtr;

// Test Get Demands global functions
  LgFrDemandVector dv;

  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	dv, "committedDemands", &difEssen );
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 13 ); 

  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	dv, "newOpportunityDemands", &difEssen );
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 3 );
  assert( newOpportunity[0].name() == "NewOpportunity" );

  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	dv, "firmForecastDemands", &difEssen );
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 12 );
  assert( firmForecast[1].name() == "FirmForecast" );

  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
	dv, "riskForecastDemands", &difEssen );
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 3 );
  assert( riskForecast[0].name() == "RiskForecast" );
  assert( riskForecast[1].name() == "RiskForecast" );
  assert( riskForecast[2].name() == "RiskForecast" );

  // Test get demand attributes global functions
  LgFrFloatVector* committedGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
       committed,"demandGrossRev", &difEssen);
  LgFrFloatVector committedGrossRev = *committedGrossRevPtr;
  assert( committedGrossRev.size() == 13 );

  LgFrFloatVector* newOpportunityGrossRevPtr
      = (LgFrFloatVector*) tdif1.demandAttribute(
	  newOpportunity,"demandGrossRev", &difEssen);
  LgFrFloatVector newOpportunityGrossRev = *newOpportunityGrossRevPtr;
  assert( newOpportunityGrossRev.size() == 3 );

  LgFrFloatVector* firmForecastGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
       firmForecast,"demandGrossRev", &difEssen);
  LgFrFloatVector firmForecastGrossRev = *firmForecastGrossRevPtr;
  assert( firmForecastGrossRev.size() == 12 );

  LgFrFloatVector* riskForecastGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
       riskForecast,"demandGrossRev", &difEssen);
  LgFrFloatVector riskForecastGrossRev = *riskForecastGrossRevPtr;
  assert( riskForecastGrossRev.size() == 3 );

  delete riskForecastGrossRevPtr;
  delete firmForecastGrossRevPtr;
  delete newOpportunityGrossRevPtr;
  delete committedGrossRevPtr;
  delete committedDemandPtr;
  delete newOpportunityDemandPtr;
  delete firmForecastDemandPtr;
  delete riskForecastDemandPtr;

}

@


1.4
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d1 4
@


1.3
log
@Modified to get sce to link on windows.
Code was changed to conditionally include implement statements
@
text
@d1 3
d5 1
a5 1
#include <iostream.h>
a6 2
#include <rw/rstream.h>
#include <rw/cstring.h>
a14 7

#ifndef WIN32
// added for vacpp - vra
implement (RWGVector, int)
#endif


d130 1
a130 1
// Return: a LgFrOrderedVectorPart object (vector of raw parts).
d134 1
a134 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d137 1
a137 1
    ) 
d139 1
a139 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d141 1
a141 1
  retVal.insert(part);
d143 1
a143 1
  retVal.insert(part);
d145 1
a145 1
  retVal.insert(part);
d147 1
a147 1
  retVal.insert(part);
d149 1
a149 1
  retVal.insert(part);
d151 1
a151 1
  retVal.insert(part);
d153 1
a153 1
  retVal.insert(part);
d155 1
a155 1
  retVal.insert(part);
d157 1
a157 1
  retVal.insert(part);
d164 1
a164 1
// Return: a LgFrOrderedVectorPart object (vector of producible parts)
d168 1
a168 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d171 1
a171 1
    )
d173 1
a173 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d177 1
a177 1
  retVal.insert(part);
d179 1
a179 1
  retVal.insert(part);
d181 1
a181 1
  retVal.insert(part);
d183 1
a183 1
  retVal.insert(part);
d187 1
a187 1
  retVal.insert(part);
d189 1
a189 1
  retVal.insert(part);
d191 1
a191 1
  retVal.insert(part);
d193 1
a193 1
  retVal.insert(part);
d195 1
a195 1
  retVal.insert(part);
d197 1
a197 1
  retVal.insert(part);
d199 1
a199 1
  retVal.insert(part);
d201 1
a201 1
  retVal.insert(part);
d208 1
a208 1
// Return: a LgFrOrderedVectorPart object (vector of producible parts)
d212 1
a212 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d215 1
a215 1
    ) 
d217 1
a217 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d220 1
a220 1
  retVal.insert(part);
d222 1
a222 1
  retVal.insert(part);
d224 1
a224 1
  retVal.insert(part);
d226 1
a226 1
  retVal.insert(part);
d238 1
a238 1
// it returns a LgFrVectorFloat object.
d242 1
a242 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d245 1
a245 1
    )
d247 3
a249 2
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
d251 2
a252 1
  for ( size_t i = 0; i < pv.entries(); i++ ) {
d254 1
a254 1
       retVal[i] = 60.0 ;
d256 1
a256 1
       retVal[i] = 420.0 ;
d258 1
a258 1
       retVal[i] = 200.0 ;
d260 1
a260 1
       retVal[i] = 10.0 ;
d262 1
a262 1
       retVal[i] = 5.0 ;    
d264 1
a264 1
       retVal[i] = 1000.0 ;    
d266 1
a266 1
       retVal[i] = 430.0 ;
d268 1
a268 1
       retVal[i] = 450.0 ;
d270 1
a270 1
       retVal[i] = 300.0 ;
d272 1
a272 1
       retVal[i] = 0.0 ;     
d279 1
a279 1
// It returns a LgFrVectorFloat object.
d283 1
a283 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d286 1
a286 1
    )
d288 7
a294 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] = 1.23f;
d301 1
a301 1
// It returns a LgFrVectorInt object
d305 1
a305 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d308 1
a308 1
    )
d310 3
a312 2
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
d314 2
a315 1
  for ( size_t i = 0; i < pv.entries(); i++ ) {
d317 1
a317 1
       retVal[i] =  TRUE;
d319 1
a319 1
       retVal[i] =  TRUE;
d321 1
a321 1
       retVal[i] = FALSE;
d328 1
a328 1
// It returns a LgFrVectorTimeVecFloat object.
d332 1
a332 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d335 1
a335 1
    )
d337 4
a340 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d345 2
a346 1
  for ( size_t i = 0; i < pv.entries(); i++ ) { 
d348 1
a348 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 8.0 );
d350 1
a350 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 3.0 );
d352 1
a352 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 2.0 );
d354 1
a354 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 8.0 );
d356 1
a356 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 1.0 );
d358 1
a358 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 1.0 );
d360 1
a360 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0 );      
d367 1
a367 1
// Return: a LgFrVectorTimeVecFloat object.
d371 1
a371 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d374 1
a374 1
    )
d376 4
a379 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d384 3
a386 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  LgFrTimeVecFloat( nperiods, 0.12f );
d393 1
a393 1
// Return: a LgFrVectorTimeVecFloat object.
d397 1
a397 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d400 1
a400 1
    )
d402 4
a405 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d410 3
a412 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  LgFrTimeVecFloat( nperiods, 0.10f );
d419 1
a419 1
// Return: a LgFrVectorTimeVecFloat object.
d423 1
a423 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d426 1
a426 1
    )
d428 4
a431 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d436 2
a437 1
  for ( size_t i = 0; i < pv.entries(); i++ ) { 
d439 1
a439 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 6000. 6000. 6000. 6000. 6000." );
d441 1
a441 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "0. 700. 700. 700. 700. 0. 0. 0." );
d443 1
a443 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 0. 0. 0. 0. 0." );
d445 1
a445 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "1500. 1500. 2000. 2000. 2000. 2000. 2000. 2000." );
d447 1
a447 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "3000. 0. 0. 0. 0. 0. 0. 0." );
d449 1
a449 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "6000. 0. 0. 0. 0. 0. 0. 0." );
d451 1
a451 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0 );
d464 1
a464 1
// it returns a LgFrVectorFloat object.
d468 1
a468 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d471 1
a471 1
    )
d473 3
a475 2
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
d477 2
a478 1
  for ( size_t i = 0; i < pv.entries(); i++ ) {
d480 1
a480 1
       retVal[i] =  1940. ;
d482 1
a482 1
       retVal[i] = 2000. ;
d484 1
a484 1
       retVal[i] = 1715. ;
d486 1
a486 1
       retVal[i] = 1775. ;
d488 1
a488 1
       retVal[i] =  1565. ;    
d490 1
a490 1
       retVal[i] =  1625. ;
d492 1
a492 1
       retVal[i] = 995. ;
d494 1
a494 1
       retVal[i] = 1055. ;
d496 1
a496 1
       retVal[i] = 490. ;
d498 1
a498 1
       retVal[i] = 550. ;
d500 1
a500 1
       retVal[i] = 265. ;
d502 1
a502 1
       retVal[i] = 325. ;    
d504 1
a504 1
       retVal[i] = 0.0 ;  
d511 1
a511 1
// It returns a LgFrVectorFloat object.
d515 1
a515 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d518 1
a518 1
    )
d520 7
a526 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] = 1.43f;
d533 1
a533 1
// It returns a LgFrVectorInt object
d537 1
a537 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d540 1
a540 1
    )
d542 7
a548 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  TRUE;
d555 1
a555 1
// It returns a LgFrVectorTimeVecFloat object.
d559 1
a559 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d562 1
a562 1
    )
d564 4
a567 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d572 3
a574 2
  for ( size_t i = 0; i < pv.entries(); i++ ) { 
    retVal[i] =  LgFrTimeVecFloat( nperiods , -2.0 );
d581 1
a581 1
// Return: a LgFrVectorFloat object
d585 1
a585 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d588 1
a588 1
    )
d590 7
a596 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] = 100;
d603 1
a603 1
// Return: a LgFrVectorTimeVecFloat object.
d607 1
a607 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d610 1
a610 1
    )
d612 4
a615 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d620 2
a621 1
  for ( size_t i = 0; i < pv.entries(); i++ ) {
d623 1
a623 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.2f );
d625 1
a625 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.9f );
d627 1
a627 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.5f );
d629 1
a629 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.7f );
d631 1
a631 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0f );      
d638 1
a638 1
// Return: a LgFrVectorTimeVecFloat object.
d642 1
a642 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d645 1
a645 1
    )
d647 4
a650 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d655 3
a657 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods, 3.4f );
d664 1
a664 1
// Return: a LgFrVectorTimeVecFloat object.
d668 1
a668 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d671 1
a671 1
    )
d673 4
a676 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d681 3
a683 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  LgFrTimeVecFloat( nperiods, 1.0f );
d690 1
a690 1
// Return: a LgFrVectorTimeVecFloat object.
d694 1
a694 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d697 1
a697 1
    )
d699 4
a702 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d707 3
a709 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  LgFrTimeVecFloat( nperiods, 0.83f );
d716 1
a716 1
// Return: a LgFrVectorTimeVecFloat object.
d720 1
a720 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d723 1
a723 1
    )
d725 4
a728 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d733 2
a734 1
  for ( size_t i = 0; i < pv.entries(); i++ ) { 
d736 1
a736 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0f );
d738 1
a738 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0f );
d740 1
a740 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "100. 100. 0. 0. 0. 0. 0. 0." );
d742 1
a742 1
       retVal[i] =  LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." );
d744 1
a744 1
       retVal[i] =  LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." );
d746 1
a746 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "150. 200. 0. 0. 0. 0. 0. 0." );
d748 1
a748 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "100. 200. 0. 0. 0. 0. 0. 0." );
d750 1
a750 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "200. 300. 0. 0. 0. 0. 0. 0." );
d752 1
a752 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "650. 625. 0. 0. 0. 0. 0. 0." );
d754 1
a754 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "800. 730. 0. 0. 0. 0. 0. 0." );
d756 1
a756 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "2600. 3000. 0. 0. 0. 0. 0. 0." );
d758 1
a758 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , "2800. 3000. 0. 0. 0. 0. 0. 0." ); 
d760 1
a760 1
       retVal[i] =  LgFrTimeVecFloat( nperiods , 0.0f );
d767 1
a767 1
// Return: a LgFrVectorTimeVecFloat object.
d771 1
a771 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d774 1
a774 1
    )
d776 4
a779 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d784 3
a786 2
  for ( size_t i=0; i<pv.entries(); i++ ) { 
       retVal[i] =  LgFrTimeVecFloat( nperiods , 1.0f );
d799 1
a799 1
// it returns a LgFrVectorFloat object.
d803 1
a803 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d806 1
a806 1
    )
d808 7
a814 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] = 1.46f;
d821 1
a821 1
// It returns a LgFrVectorInt object
d825 1
a825 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d828 1
a828 1
    )
d830 7
a836 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  TRUE;
d843 1
a843 1
// Return: a LgFrVectorTimeVecFloat object.
d847 1
a847 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d850 1
a850 1
    )
d852 4
a855 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d860 3
a862 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
      retVal[i] =  LgFrTimeVecFloat( nperiods, 0.73f );
d869 1
a869 1
// Return: a LgFrVectorTimeVecFloat object.
d873 1
a873 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d876 1
a876 1
    )
d878 4
a881 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( pv.entries() ));   
d886 2
a887 1
  for ( size_t i = 0; i < pv.entries(); i++ ) { 
d889 1
a889 1
      retVal[i] = LgFrTimeVecFloat(nperiods, "900. 900. 900. 900. 900. 900. 900. 900." );
d891 1
a891 1
      retVal[i] =  LgFrTimeVecFloat(nperiods , "1300. 1300. 1300. 1300. 1300. 1300. 1300. 1300." );
d893 1
a893 1
      retVal[i] =  LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." );
d895 1
a895 1
      retVal[i] =  LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." );
d897 1
a897 1
      retVal[i] =  LgFrTimeVecFloat(nperiods , 0.0f );
d911 1
a911 1
// Return: a LgFrOrderedVectorDemand object (vector of committed demands).
d915 1
a915 1
  const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d919 2
a920 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d924 1
a924 1
  RWCString dn[] = 
d942 1
a942 1
  RWCString pn[] =
d959 2
a960 1
  for ( int i = 0; i < nDemands; i++ )
d964 1
a964 1
	  retVal.insert(demand);
d972 1
a972 1
// Return: a LgFrOrderedVectorDemand object (vector of new opportunity demands).
d976 1
a976 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d980 2
a981 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d985 1
a985 1
  RWCString dn[] = 
d993 1
a993 1
  RWCString pn[] =
d1000 2
a1001 1
  for ( int i = 0; i < nDemands; i++ )
d1005 1
a1005 1
	  retVal.insert(demand);
d1013 1
a1013 1
// Return: a LgFrOrderedVectorDemand object (vector of firm forcast demands).
d1017 1
a1017 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d1021 2
a1022 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d1026 1
a1026 1
  RWCString dn[] = 
d1043 1
a1043 1
  RWCString pn[] =
d1059 2
a1060 1
  for ( int i = 0; i < nDemands; i++ )
d1064 1
a1064 1
	  retVal.insert(demand);
d1072 1
a1072 1
// Return: a LgFrOrderedVectorDemand object (vector of risk forcast demands).
d1076 1
a1076 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d1080 2
a1081 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d1085 1
a1085 1
  RWCString dn[] = 
d1093 1
a1093 1
  RWCString pn[] =
d1100 2
a1101 1
  for ( int i = 0; i < nDemands; i++ )
d1105 1
a1105 1
	  retVal.insert(demand);
d1119 1
a1119 1
// Return: a LgFrVectorFloat object (vector of demand gross revenues).
d1123 1
a1123 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d1126 1
a1126 1
    )
d1128 3
a1130 2
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat( dv.entries() ));    
d1132 14
a1145 13
  for ( size_t i = 0; i < dv.entries(); i++ ) {
    if      ( dv[i]->name() == "Albert_Einstein" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Robert_Oppenheimer" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Issac_Newton" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Mr_Pythagoras" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Joseph_Orlicky" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Michael_Faraday" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Leonhard_Euler" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Turings_Machine_Shop" )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal[i] = 111.f;    
    else if ( dv[i]->name() == "NewOpportunity"  )  retVal[i] = 222.f;
    else if ( dv[i]->name() == "FirmForecast" )  retVal[i] = 333.f;
    else if ( dv[i]->name() == "RiskForecast" )  retVal[i] = 444.f;
d1153 1
a1153 1
// Return: a LgFrVectorTimeVecFloat object.
d1157 1
a1157 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d1160 1
a1160 1
    )
d1162 4
a1165 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d1170 2
a1171 1
  for ( int i = 0; i < dv.entries(); i++) {
d1174 1
a1174 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "300. 300. 300. 300. 300. 200. 200. 100." );
d1178 1
a1178 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "450. 350. 350. 350. 350. 150. 150. 150." );
d1182 1
a1182 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "500. 500. 400. 400. 300. 300. 300. 300." );
d1186 1
a1186 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "600. 600. 600. 300. 300. 300. 200. 200." );
d1190 1
a1190 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "750. 750. 750. 750. 600. 600. 600. 600." );
d1194 1
a1194 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "700. 700. 700. 500. 500. 500. 500. 500." );
d1196 1
a1196 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "30. 30. 30. 20. 20. 20. 20. 20." );
d1200 1
a1200 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "900. 900. 800. 800. 800. 600. 600. 600." );
d1204 1
a1204 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "800. 800. 800. 800. 500. 500. 500. 500." );
d1208 1
a1208 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "10. 10. 10. 10. 10. 10. 10. 10." );
d1210 1
a1210 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "20. 20. 20. 10. 10. 10. 10. 10." );
d1212 1
a1212 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "40. 40. 40. 30. 30. 20. 20. 20." );
d1214 1
a1214 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "90. 90. 60. 60. 60. 60. 60.  60." );
d1218 1
a1218 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "100. 100. 100. 100. 100. 300. 300. 400." );
d1220 1
a1220 1
        retVal[i] = LgFrTimeVecFloat( nperiods, "100. 100. 300. 350. 350. 450. 500. 500." );
d1222 1
a1222 1
        retVal[i] = LgFrTimeVecFloat( nperiods,  "100. 100. 300. 300. 300. 300. 350. 350." );
d1224 1
a1224 1
        retVal[i] = LgFrTimeVecFloat( nperiods,  "100. 100. 400. 400. 400. 400. 750. 750." );
d1226 1
a1226 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "100. 100. 250. 250. 500. 500. 550. 550." );
d1228 1
a1228 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "100. 100. 300. 300. 300. 300. 500. 500." );
d1230 1
a1230 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "100. 100. 100. 500. 500. 500. 500. 500." );
d1232 1
a1232 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "100. 200. 200. 400. 500. 500. 600. 600." );
d1234 1
a1234 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "10. 10. 20. 20. 20. 20. 20. 20." );
d1236 1
a1236 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "10. 10. 10. 30. 30. 30. 30. 30." );
d1238 1
a1238 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90." );
d1240 1
a1240 1
        retVal[i] = LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90."  );      
d1244 1
a1244 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.0f );
d1246 1
a1246 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.0f );
d1248 1
a1248 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 1.0f );
d1250 2
a1251 2
    else if ( dv[i]->name() == "NewOpportunity"  )  
        retVal[i] = LgFrTimeVecFloat( nperiods, 0.0f );
d1259 1
a1259 1
// Return: a LgFrVectorTimeVecFloat object.
d1263 1
a1263 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d1266 1
a1266 1
    )
d1268 4
a1271 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d1276 2
a1277 1
  for ( size_t i = 0; i < dv.entries(); i++) {
d1280 1
a1280 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 100.f );
d1284 1
a1284 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 125.f );
d1288 1
a1288 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 100.f );
d1292 1
a1292 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 125.f );
d1296 1
a1296 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 90.f );
d1300 1
a1300 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 100.f );
d1302 1
a1302 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 90.f ); 
d1306 1
a1306 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 110.f );
d1310 1
a1310 1
        retVal[i] = LgFrTimeVecFloat( nperiods, 80.f );
d1312 3
a1314 3
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal[i] = LgFrTimeVecFloat( nperiods, 30.f );    
    else if ( dv[i]->name() == "FirmForecast" )  retVal[i] = LgFrTimeVecFloat( nperiods, 0.f );
    else if ( dv[i]->name() == "RiskForecast" )  retVal[i] = LgFrTimeVecFloat( nperiods, 0.f );
d1322 1
a1322 1
// Return: a LgFrVectorTimeVecFloat object.
d1326 1
a1326 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d1329 1
a1329 1
    )
d1331 4
a1334 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d1339 3
a1341 2
  for ( size_t i = 0; i < dv.entries(); i++) {
    retVal[i] =  LgFrTimeVecFloat( nperiods, 1.f );
d1355 1
a1355 1
    const LgFrOrderedVectorItemPtr*, // itemPtrOrdVecPtr,
d1484 1
a1484 1
   return NULL;
a1505 5
  // Test isA method
  assert (dImp->isA() == __LGFRDATAINTERFACEIMPLEMENTATION);
  assert (dImptsi->isA() 
	  == __LGFRDATAINTERFACEIMPLEMENTATION);

d1517 4
a1520 4
  LgFrOrderedVectorPart pv;
  RWCString itemSubTypeStr = "material";  
  LgFrOrderedVectorPart* rawPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1522 1
a1522 1
  LgFrOrderedVectorPart raw = *rawPartsPtr;
d1524 1
a1524 1
  assert( raw.entries() == 9 );
d1527 2
a1528 2
  LgFrOrderedVectorPart* productPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1530 1
a1530 1
  LgFrOrderedVectorPart product = *productPartsPtr;
d1532 1
a1532 1
  assert( product.entries() == 12 );
d1535 2
a1536 2
  LgFrOrderedVectorPart* capacityPartsPtr
    = (LgFrOrderedVectorPart*) tdif1.partAttribute(
d1538 1
a1538 1
  LgFrOrderedVectorPart capacity = *capacityPartsPtr;
d1540 1
a1540 1
  assert( capacity.entries() == 4 );
d1545 2
a1546 2
  LgFrVectorFloat* unitCostPtr
    = (LgFrVectorFloat*) tdif1.partAttribute(
d1548 2
a1549 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 9 );
d1551 2
a1552 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) tdif1.partAttribute(
d1554 2
a1555 2
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 9 );
d1557 2
a1558 1
  for (int i=1; i<7; i++)
d1562 2
a1563 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1565 2
a1566 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 9 );
d1568 2
a1569 2
  LgFrVectorTimeVecFloat* obj1StockCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1571 2
a1572 2
  LgFrVectorTimeVecFloat obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.length() == 9 );
d1574 2
a1575 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1577 2
a1578 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 9 );
d1591 2
a1592 2
  LgFrVectorTimeVecFloat* cycleTimePtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1594 2
a1595 2
  LgFrVectorTimeVecFloat cycleTime = *cycleTimePtr;
  assert( cycleTime.length() == 12 );
d1597 2
a1598 2
  LgFrVectorFloat* unitCostPtr
      = (LgFrVectorFloat*) tdif1.partAttribute(
d1600 2
a1601 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 12 );
d1603 2
a1604 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) tdif1.partAttribute(
d1606 4
a1609 3
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 12 );
  for (int i=0; i<constrained.length(); i++)
d1612 2
a1613 2
  LgFrVectorInt* yieldPtr
      = (LgFrVectorInt*) tdif1.partAttribute(
d1615 2
a1616 2
  LgFrVectorInt yield = *yieldPtr;
  assert( yield.length() == 12 );
d1618 2
a1619 2
  LgFrVectorTimeVecFloat* obj1ProdCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1621 2
a1622 2
  LgFrVectorTimeVecFloat obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.length() == 12 );
d1624 2
a1625 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1627 2
a1628 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 12 );
d1630 2
a1631 2
  LgFrVectorTimeVecFloat* obj1StockCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1633 2
a1634 2
  LgFrVectorTimeVecFloat obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.length() == 12 );
d1636 2
a1637 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1639 2
a1640 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 12 );
d1657 2
a1658 2
  LgFrVectorFloat* unitCostPtr
      = (LgFrVectorFloat*) tdif1.partAttribute(
d1660 2
a1661 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 4 );
d1663 2
a1664 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) tdif1.partAttribute(
d1666 2
a1667 2
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 4 );
d1670 2
a1671 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1673 2
a1674 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 4 );
d1676 2
a1677 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) tdif1.partAttribute(
d1679 2
a1680 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 4 );
d1692 1
a1692 1
  LgFrOrderedVectorDemand dv;
d1694 2
a1695 2
  LgFrOrderedVectorDemand* committedDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1697 2
a1698 2
  LgFrOrderedVectorDemand committed = * committedDemandPtr; 
  assert( committed.entries() == 13 ); 
d1700 2
a1701 2
  LgFrOrderedVectorDemand* newOpportunityDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1703 2
a1704 2
  LgFrOrderedVectorDemand newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.entries() == 3 );
d1707 2
a1708 2
  LgFrOrderedVectorDemand* firmForecastDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1710 2
a1711 2
  LgFrOrderedVectorDemand firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.entries() == 12 );
d1714 2
a1715 2
  LgFrOrderedVectorDemand* riskForecastDemandPtr
    = (LgFrOrderedVectorDemand*) tdif1.demandAttribute(
d1717 2
a1718 2
  LgFrOrderedVectorDemand riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.entries() == 3 );
d1724 2
a1725 2
  LgFrVectorFloat* committedGrossRevPtr
   = (LgFrVectorFloat*) tdif1.demandAttribute(
d1727 2
a1728 2
  LgFrVectorFloat committedGrossRev = *committedGrossRevPtr;
  assert( committedGrossRev.length() == 13 );
d1730 2
a1731 2
  LgFrVectorFloat* newOpportunityGrossRevPtr
      = (LgFrVectorFloat*) tdif1.demandAttribute(
d1733 2
a1734 2
  LgFrVectorFloat newOpportunityGrossRev = *newOpportunityGrossRevPtr;
  assert( newOpportunityGrossRev.length() == 3 );
d1736 2
a1737 2
  LgFrVectorFloat* firmForecastGrossRevPtr
   = (LgFrVectorFloat*) tdif1.demandAttribute(
d1739 2
a1740 2
  LgFrVectorFloat firmForecastGrossRev = *firmForecastGrossRevPtr;
  assert( firmForecastGrossRev.length() == 12 );
d1742 2
a1743 2
  LgFrVectorFloat* riskForecastGrossRevPtr
   = (LgFrVectorFloat*) tdif1.demandAttribute(
d1745 2
a1746 2
  LgFrVectorFloat riskForecastGrossRev = *riskForecastGrossRevPtr;
  assert( riskForecastGrossRev.length() == 3 );
@


1.3.2.1
log
@Roguewave is gone
@
text
@a0 3
// RW2STL -- inserted:
#include <string>
// End of RW2STL -- inserted includes.
d2 1
a2 1
#include <iostream>
d4 2
d14 7
d136 1
a136 1
// Return: a LgFrPartVector object (vector of raw parts).
d140 1
a140 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d143 1
a143 1
 ) 
d145 1
a145 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d147 1
a147 1
  retVal.push_back(part);
d149 1
a149 1
  retVal.push_back(part);
d151 1
a151 1
  retVal.push_back(part);
d153 1
a153 1
  retVal.push_back(part);
d155 1
a155 1
  retVal.push_back(part);
d157 1
a157 1
  retVal.push_back(part);
d159 1
a159 1
  retVal.push_back(part);
d161 1
a161 1
  retVal.push_back(part);
d163 1
a163 1
  retVal.push_back(part);
d170 1
a170 1
// Return: a LgFrPartVector object (vector of producible parts)
d174 1
a174 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d177 1
a177 1
 )
d179 1
a179 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d183 1
a183 1
  retVal.push_back(part);
d185 1
a185 1
  retVal.push_back(part);
d187 1
a187 1
  retVal.push_back(part);
d189 1
a189 1
  retVal.push_back(part);
d193 1
a193 1
  retVal.push_back(part);
d195 1
a195 1
  retVal.push_back(part);
d197 1
a197 1
  retVal.push_back(part);
d199 1
a199 1
  retVal.push_back(part);
d201 1
a201 1
  retVal.push_back(part);
d203 1
a203 1
  retVal.push_back(part);
d205 1
a205 1
  retVal.push_back(part);
d207 1
a207 1
  retVal.push_back(part);
d214 1
a214 1
// Return: a LgFrPartVector object (vector of producible parts)
d218 1
a218 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d221 1
a221 1
 ) 
d223 1
a223 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d226 1
a226 1
  retVal.push_back(part);
d228 1
a228 1
  retVal.push_back(part);
d230 1
a230 1
  retVal.push_back(part);
d232 1
a232 1
  retVal.push_back(part);
d244 1
a244 1
// it returns a LgFrFloatVector object.
d248 1
a248 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d251 1
a251 1
 )
d253 2
a254 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );
d256 1
a256 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
d258 1
a258 1
       retVal.push_back( 60.0 );
d260 1
a260 1
       retVal.push_back( 420.0 );
d262 1
a262 1
       retVal.push_back( 200.0 );
d264 1
a264 1
       retVal.push_back( 10.0 );
d266 1
a266 1
       retVal.push_back( 5.0 );
d268 1
a268 1
       retVal.push_back( 1000.0 );
d270 1
a270 1
       retVal.push_back( 430.0 );
d272 1
a272 1
       retVal.push_back( 450.0 );
d274 1
a274 1
       retVal.push_back( 300.0 );
d276 1
a276 1
       retVal.push_back( 0.0 );
d283 1
a283 1
// It returns a LgFrFloatVector object.
d287 1
a287 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d290 1
a290 1
 )
d292 5
a296 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.23f );
d303 1
a303 1
// It returns a LgFrIntVector object
d307 1
a307 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d310 1
a310 1
 )
d312 2
a313 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );
d315 1
a315 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
d317 1
a317 1
       retVal.push_back( true );
d319 1
a319 1
       retVal.push_back( true );
d321 1
a321 1
       retVal.push_back( false );
d328 1
a328 1
// It returns a LgFrTimeVecFloatVector object.
d332 1
a332 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d335 1
a335 1
 )
d337 3
a339 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d344 1
a344 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
d346 1
a346 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 8.0 ) );
d348 1
a348 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 3.0 ) );
d350 1
a350 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 2.0 ) );
d352 1
a352 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 8.0 ) );
d354 1
a354 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0 ) );
d356 1
a356 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0 ) );
d358 1
a358 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0 ) );
d365 1
a365 1
// Return: a LgFrTimeVecFloatVector object.
d369 1
a369 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d372 1
a372 1
 )
d374 3
a376 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d381 2
a382 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.12f ) );
d389 1
a389 1
// Return: a LgFrTimeVecFloatVector object.
d393 1
a393 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d396 1
a396 1
 )
d398 3
a400 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d405 2
a406 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.10f ) );
d413 1
a413 1
// Return: a LgFrTimeVecFloatVector object.
d417 1
a417 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d420 1
a420 1
 )
d422 3
a424 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d429 1
a429 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
d431 1
a431 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 6000. 6000. 6000. 6000. 6000." ) );
d433 1
a433 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "0. 700. 700. 700. 700. 0. 0. 0." ) );
d435 1
a435 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 6000. 6000. 0. 0. 0. 0. 0." ) );
d437 1
a437 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "1500. 1500. 2000. 2000. 2000. 2000. 2000. 2000." ) );
d439 1
a439 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "3000. 0. 0. 0. 0. 0. 0. 0." ) );
d441 1
a441 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "6000. 0. 0. 0. 0. 0. 0. 0." ) );
d443 1
a443 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0 ) );
d456 1
a456 1
// it returns a LgFrFloatVector object.
d460 1
a460 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d463 1
a463 1
 )
d465 2
a466 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );
d468 1
a468 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
d470 1
a470 1
       retVal.push_back( 1940. );
d472 1
a472 1
       retVal.push_back( 2000. );
d474 1
a474 1
       retVal.push_back( 1715. );
d476 1
a476 1
       retVal.push_back( 1775. );
d478 1
a478 1
       retVal.push_back( 1565. );
d480 1
a480 1
       retVal.push_back( 1625. );
d482 1
a482 1
       retVal.push_back( 995. );
d484 1
a484 1
       retVal.push_back( 1055. );
d486 1
a486 1
       retVal.push_back( 490. );
d488 1
a488 1
       retVal.push_back( 550. );
d490 1
a490 1
       retVal.push_back( 265. );
d492 1
a492 1
       retVal.push_back( 325. );
d494 1
a494 1
       retVal.push_back( 0.0 );
d501 1
a501 1
// It returns a LgFrFloatVector object.
d505 1
a505 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d508 1
a508 1
 )
d510 5
a514 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.43f );
d521 1
a521 1
// It returns a LgFrIntVector object
d525 1
a525 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d528 1
a528 1
 )
d530 5
a534 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( true );
d541 1
a541 1
// It returns a LgFrTimeVecFloatVector object.
d545 1
a545 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d548 1
a548 1
 )
d550 3
a552 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d557 2
a558 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
    retVal.push_back( LgFrTimeVecFloat( nperiods , -2.0 ) );
d565 1
a565 1
// Return: a LgFrFloatVector object
d569 1
a569 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d572 1
a572 1
 )
d574 5
a578 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 100 );
d585 1
a585 1
// Return: a LgFrTimeVecFloatVector object.
d589 1
a589 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d592 1
a592 1
 )
d594 3
a596 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d601 1
a601 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
d603 1
a603 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.2f ) );
d605 1
a605 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.9f ) );
d607 1
a607 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.5f ) );
d609 1
a609 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.7f ) );
d611 1
a611 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
d618 1
a618 1
// Return: a LgFrTimeVecFloatVector object.
d622 1
a622 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d625 1
a625 1
 )
d627 3
a629 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d634 2
a635 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 3.4f ) );
d642 1
a642 1
// Return: a LgFrTimeVecFloatVector object.
d646 1
a646 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d649 1
a649 1
 )
d651 3
a653 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d658 2
a659 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
d666 1
a666 1
// Return: a LgFrTimeVecFloatVector object.
d670 1
a670 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d673 1
a673 1
 )
d675 3
a677 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d682 2
a683 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.83f ) );
d690 1
a690 1
// Return: a LgFrTimeVecFloatVector object.
d694 1
a694 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d697 1
a697 1
 )
d699 3
a701 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d706 1
a706 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
d708 1
a708 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
d710 1
a710 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
d712 1
a712 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "100. 100. 0. 0. 0. 0. 0. 0." ) );
d714 1
a714 1
       retVal.push_back( LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." ) );
d716 1
a716 1
       retVal.push_back( LgFrTimeVecFloat( nperiods ,  "100. 150. 0. 0. 0. 0. 0. 0." ) );
d718 1
a718 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "150. 200. 0. 0. 0. 0. 0. 0." ) );
d720 1
a720 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "100. 200. 0. 0. 0. 0. 0. 0." ) );
d722 1
a722 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "200. 300. 0. 0. 0. 0. 0. 0." ) );
d724 1
a724 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "650. 625. 0. 0. 0. 0. 0. 0." ) );
d726 1
a726 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "800. 730. 0. 0. 0. 0. 0. 0." ) );
d728 1
a728 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "2600. 3000. 0. 0. 0. 0. 0. 0." ) );
d730 1
a730 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , "2800. 3000. 0. 0. 0. 0. 0. 0." ) );
d732 1
a732 1
       retVal.push_back( LgFrTimeVecFloat( nperiods , 0.0f ) );
d739 1
a739 1
// Return: a LgFrTimeVecFloatVector object.
d743 1
a743 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d746 1
a746 1
 )
d748 3
a750 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d755 2
a756 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<pv.size(); i++ ) { 
       retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0f ) );
d769 1
a769 1
// it returns a LgFrFloatVector object.
d773 1
a773 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d776 1
a776 1
 )
d778 5
a782 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( 1.46f );
d789 1
a789 1
// It returns a LgFrIntVector object
d793 1
a793 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d796 1
a796 1
 )
d798 5
a802 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( true );
d809 1
a809 1
// Return: a LgFrTimeVecFloatVector object.
d813 1
a813 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d816 1
a816 1
 )
d818 3
a820 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d825 2
a826 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
      retVal.push_back( LgFrTimeVecFloat( nperiods, 0.73f ) );
d833 1
a833 1
// Return: a LgFrTimeVecFloatVector object.
d837 1
a837 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d840 1
a840 1
 )
d842 3
a844 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( pv.size() );   
d849 1
a849 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) { 
d851 1
a851 1
      retVal.push_back( LgFrTimeVecFloat(nperiods, "900. 900. 900. 900. 900. 900. 900. 900." ) );
d853 1
a853 1
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1300. 1300. 1300. 1300. 1300. 1300. 1300. 1300." ) );
d855 1
a855 1
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." ) );
d857 1
a857 1
      retVal.push_back( LgFrTimeVecFloat(nperiods , "1200. 1200. 1200. 1200. 1200. 1200. 1200. 1200." ) );
d859 1
a859 1
      retVal.push_back( LgFrTimeVecFloat(nperiods , 0.0f ) );
d873 1
a873 1
// Return: a LgFrDemandVector object (vector of committed demands).
d877 1
a877 1
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d881 2
a882 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d886 1
a886 1
  std::string dn[] = 
d904 1
a904 1
  std::string pn[] =
d921 1
a921 2
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
d925 1
a925 1
	  retVal.push_back(demand);
d933 1
a933 1
// Return: a LgFrDemandVector object (vector of new opportunity demands).
d937 1
a937 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d941 2
a942 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d946 1
a946 1
  std::string dn[] = 
d954 1
a954 1
  std::string pn[] =
d961 1
a961 2
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
d965 1
a965 1
	  retVal.push_back(demand);
d973 1
a973 1
// Return: a LgFrDemandVector object (vector of firm forcast demands).
d977 1
a977 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d981 2
a982 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d986 1
a986 1
  std::string dn[] = 
d1003 1
a1003 1
  std::string pn[] =
d1019 1
a1019 2
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
d1023 1
a1023 1
	  retVal.push_back(demand);
d1031 1
a1031 1
// Return: a LgFrDemandVector object (vector of risk forcast demands).
d1035 1
a1035 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d1039 2
a1040 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d1044 1
a1044 1
  std::string dn[] = 
d1052 1
a1052 1
  std::string pn[] =
d1059 1
a1059 2
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < nDemands; i++ )
d1063 1
a1063 1
	  retVal.push_back(demand);
d1077 1
a1077 1
// Return: a LgFrFloatVector object (vector of demand gross revenues).
d1081 1
a1081 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d1084 1
a1084 1
 )
d1086 2
a1087 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
d1089 13
a1101 14
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    if      ( dv[i]->name() == "Albert_Einstein" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Robert_Oppenheimer" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Issac_Newton" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Mr_Pythagoras" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Joseph_Orlicky" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Michael_Faraday" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Leonhard_Euler" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Turings_Machine_Shop" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "NewOpportunity" )  retVal.push_back( 222.f );
    else if ( dv[i]->name() == "FirmForecast" )  retVal.push_back( 333.f );
    else if ( dv[i]->name() == "RiskForecast" )  retVal.push_back( 444.f );
d1109 1
a1109 1
// Return: a LgFrTimeVecFloatVector object.
d1113 1
a1113 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d1116 1
a1116 1
 )
d1118 3
a1120 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d1125 1
a1125 2
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
d1128 1
a1128 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "300. 300. 300. 300. 300. 200. 200. 100." ) );
d1132 1
a1132 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "450. 350. 350. 350. 350. 150. 150. 150." ) );
d1136 1
a1136 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "500. 500. 400. 400. 300. 300. 300. 300." ) );
d1140 1
a1140 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "600. 600. 600. 300. 300. 300. 200. 200." ) );
d1144 1
a1144 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "750. 750. 750. 750. 600. 600. 600. 600." ) );
d1148 1
a1148 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "700. 700. 700. 500. 500. 500. 500. 500." ) );
d1150 1
a1150 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "30. 30. 30. 20. 20. 20. 20. 20." ) );
d1154 1
a1154 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "900. 900. 800. 800. 800. 600. 600. 600." ) );
d1158 1
a1158 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "800. 800. 800. 800. 500. 500. 500. 500." ) );
d1162 1
a1162 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "10. 10. 10. 10. 10. 10. 10. 10." ) );
d1164 1
a1164 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "20. 20. 20. 10. 10. 10. 10. 10." ) );
d1166 1
a1166 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "40. 40. 40. 30. 30. 20. 20. 20." ) );
d1168 1
a1168 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "90. 90. 60. 60. 60. 60. 60.  60." ) );
d1172 1
a1172 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "100. 100. 100. 100. 100. 300. 300. 400." ) );
d1174 1
a1174 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, "100. 100. 300. 350. 350. 450. 500. 500." ) );
d1176 1
a1176 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,  "100. 100. 300. 300. 300. 300. 350. 350." ) );
d1178 1
a1178 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,  "100. 100. 400. 400. 400. 400. 750. 750." ) );
d1180 1
a1180 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 250. 250. 500. 500. 550. 550." ) );
d1182 1
a1182 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 300. 300. 300. 300. 500. 500." ) );
d1184 1
a1184 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 100. 100. 500. 500. 500. 500. 500." ) );
d1186 1
a1186 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "100. 200. 200. 400. 500. 500. 600. 600." ) );
d1188 1
a1188 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "10. 10. 20. 20. 20. 20. 20. 20." ) );
d1190 1
a1190 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "10. 10. 10. 30. 30. 30. 30. 30." ) );
d1192 1
a1192 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90." ) );
d1194 1
a1194 1
        retVal.push_back( LgFrTimeVecFloat( nperiods,   "30. 30. 30. 60. 60. 60. 90. 90." ) );
d1198 1
a1198 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
d1200 1
a1200 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
d1202 1
a1202 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 1.0f ) );
d1204 2
a1205 2
    else if ( dv[i]->name() == "NewOpportunity" )  
        retVal.push_back( LgFrTimeVecFloat( nperiods, 0.0f ) );
d1213 1
a1213 1
// Return: a LgFrTimeVecFloatVector object.
d1217 1
a1217 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d1220 1
a1220 1
 )
d1222 3
a1224 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d1229 1
a1229 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
d1232 1
a1232 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
d1236 1
a1236 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 125.f ) );
d1240 1
a1240 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
d1244 1
a1244 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 125.f ) );
d1248 1
a1248 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 90.f ) );
d1252 1
a1252 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 100.f ) );
d1254 1
a1254 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 90.f ) );
d1258 1
a1258 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 110.f ) );
d1262 1
a1262 1
        retVal.push_back( LgFrTimeVecFloat( nperiods, 80.f ) );
d1264 3
a1266 3
    else if ( dv[i]->name() == "Thomas_Edisons_Repair" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 30.f ) );
    else if ( dv[i]->name() == "FirmForecast" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 0.f ) );
    else if ( dv[i]->name() == "RiskForecast" )  retVal.push_back( LgFrTimeVecFloat( nperiods, 0.f ) );
d1274 1
a1274 1
// Return: a LgFrTimeVecFloatVector object.
d1278 1
a1278 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d1281 1
a1281 1
 )
d1283 3
a1285 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d1290 2
a1291 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 1.f ) );
d1305 1
a1305 1
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
d1434 1
a1434 1
   return 0;
d1456 5
d1472 4
a1475 4
  LgFrPartVector pv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1477 1
a1477 1
  LgFrPartVector raw = *rawPartsPtr;
d1479 1
a1479 1
  assert( raw.size() == 9 );
d1482 2
a1483 2
  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1485 1
a1485 1
  LgFrPartVector product = *productPartsPtr;
d1487 1
a1487 1
  assert( product.size() == 12 );
d1490 2
a1491 2
  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) tdif1.partAttribute(
d1493 1
a1493 1
  LgFrPartVector capacity = *capacityPartsPtr;
d1495 1
a1495 1
  assert( capacity.size() == 4 );
d1500 2
a1501 2
  LgFrFloatVector* unitCostPtr
    = (LgFrFloatVector*) tdif1.partAttribute(
d1503 2
a1504 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 9 );
d1506 2
a1507 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
d1509 2
a1510 2
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 9 );
d1512 1
a1512 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=1; i<7; i++)
d1516 2
a1517 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1519 2
a1520 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 9 );
d1522 2
a1523 2
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1525 2
a1526 2
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 9 );
d1528 2
a1529 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1531 2
a1532 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 9 );
d1545 2
a1546 2
  LgFrTimeVecFloatVector* cycleTimePtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1548 2
a1549 2
  LgFrTimeVecFloatVector cycleTime = *cycleTimePtr;
  assert( cycleTime.size() == 12 );
d1551 2
a1552 2
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) tdif1.partAttribute(
d1554 2
a1555 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 12 );
d1557 2
a1558 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
d1560 3
a1562 4
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 12 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.size(); i++)
d1565 2
a1566 2
  LgFrIntVector* yieldPtr
      = (LgFrIntVector*) tdif1.partAttribute(
d1568 2
a1569 2
  LgFrIntVector yield = *yieldPtr;
  assert( yield.size() == 12 );
d1571 2
a1572 2
  LgFrTimeVecFloatVector* obj1ProdCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1574 2
a1575 2
  LgFrTimeVecFloatVector obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.size() == 12 );
d1577 2
a1578 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1580 2
a1581 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 12 );
d1583 2
a1584 2
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1586 2
a1587 2
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 12 );
d1589 2
a1590 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1592 2
a1593 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 12 );
d1610 2
a1611 2
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) tdif1.partAttribute(
d1613 2
a1614 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 4 );
d1616 2
a1617 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) tdif1.partAttribute(
d1619 2
a1620 2
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 4 );
d1623 2
a1624 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1626 2
a1627 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 4 );
d1629 2
a1630 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) tdif1.partAttribute(
d1632 2
a1633 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 4 );
d1645 1
a1645 1
  LgFrDemandVector dv;
d1647 2
a1648 2
  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1650 2
a1651 2
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 13 ); 
d1653 2
a1654 2
  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1656 2
a1657 2
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 3 );
d1660 2
a1661 2
  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1663 2
a1664 2
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 12 );
d1667 2
a1668 2
  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) tdif1.demandAttribute(
d1670 2
a1671 2
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 3 );
d1677 2
a1678 2
  LgFrFloatVector* committedGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
d1680 2
a1681 2
  LgFrFloatVector committedGrossRev = *committedGrossRevPtr;
  assert( committedGrossRev.size() == 13 );
d1683 2
a1684 2
  LgFrFloatVector* newOpportunityGrossRevPtr
      = (LgFrFloatVector*) tdif1.demandAttribute(
d1686 2
a1687 2
  LgFrFloatVector newOpportunityGrossRev = *newOpportunityGrossRevPtr;
  assert( newOpportunityGrossRev.size() == 3 );
d1689 2
a1690 2
  LgFrFloatVector* firmForecastGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
d1692 2
a1693 2
  LgFrFloatVector firmForecastGrossRev = *firmForecastGrossRevPtr;
  assert( firmForecastGrossRev.size() == 12 );
d1695 2
a1696 2
  LgFrFloatVector* riskForecastGrossRevPtr
   = (LgFrFloatVector*) tdif1.demandAttribute(
d1698 2
a1699 2
  LgFrFloatVector riskForecastGrossRev = *riskForecastGrossRevPtr;
  assert( riskForecastGrossRev.size() == 3 );
@


1.2
log
@Added implement (RWGVector, XXX) to satisfy vacpp linker.
@
text
@d14 2
d18 1
@


1.1
log
@Initial revision
@
text
@d14 4
@


1.1.1.1
log
@Import scenario
@
text
@@

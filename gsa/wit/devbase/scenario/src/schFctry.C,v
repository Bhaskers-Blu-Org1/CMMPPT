head	1.3;
access;
symbols
	sce_5_01_20080919:1.2
	latest_sce_4_20_20060523:1.2.0.6
	sce_4_20_20060523:1.2
	latest_sce4_20_OSL:1.2.0.4
	sce_4_20_OSL:1.2
	sce_4_05_20040511:1.2
	sce_4_00_20040201:1.2
	nextGenBranch:1.2.0.2
	nextGenRoot:1.2
	sce_3_30_20030627:1.2
	EndRw-branch:1.1.1.1.0.14
	Root-of-EndRw:1.1.1.1
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2009.12.01.20.19.51;	author ervolina;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.15.19.36.46;	author rwToStl;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.29.51;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.51;	author wit;	state Exp;
branches
	1.1.1.1.14.1;
next	;

1.1.1.1.14.1
date	2003.01.08.17.42.36;	author rwToStl;	state Exp;
branches;
next	1.1.1.1.14.2;

1.1.1.1.14.2
date	2003.01.09.13.54.39;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.3
log
@jettison references in scenario to Wit's OBJ2
@
text
@// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
#include <string>
// End of RW2STL -- inserted includes.

#include <scenario/src/schFctry.h>
#include <scenario/src/scenario.h>
#include <scenario/src/schdSnFS.h>
#include <scenario/src/cumSS.h>
#include <scenario/src/partCtFS.h>
#include <scenario/src/boolFS.h>
#include <scenario/src/partSS.h>
#include <scenario/src/prodSS.h>
#include <scenario/src/demVolSS.h>
#include <scenario/src/fssSS.h>
#include <scenario/src/backlgSS.h>
#include <scenario/src/critPaSS.h>
#include <scenario/src/excessSS.h>
#include <scenario/src/shipSS.h>
#include <scenario/src/supplySS.h>
#include <scenario/src/usageSS.h>
#include <scenario/src/reqSS.h>
#include <scenario/src/cycleSS.h>
#include <scenario/src/stockSS.h>
#include <scenario/src/scrapSS.h>
#include <scenario/src/schdDeSt.h>
#include <scenario/src/priorSS.h>
#include <scenario/src/partSchP.h>
#include <scenario/src/demdSchP.h>
#include <scenario/src/shpRewSS.h>
// #include <scenario/src/costSS.h>
#include <scenario/src/fssPrdSS.h>

// ---------------------------------------------------------------------
// Create a Part Schedule, set its partSS strategy
// and optional filterstrategy, data population is not done here.
// ---------------------------------------------------------------------
LgFrSortingPartScheduleFloatSmartPointer
LgFrScheduleFactory::createPartSched(
   const LgFrPartScheduleStrategy & partSS,
   const LgFrFilterStrategy * filterStrategyPtr,
   const LgFrPairCompareFloat * pairComparePtr,
   const bool ascending
                                     )
     const
{
 LgFrSortingPartScheduleFloatSmartPointer spsf = 
     LgFrSortingPartScheduleFloatSmartPointer(new LgFrSortingPartScheduleFloat());
                                           
 // Set it's strategy
 spsf->attributeScheduleStrategy(partSS);

 // Set it's filter strategy
 if ( filterStrategyPtr ) spsf->filterStrategy(*filterStrategyPtr);

 // Set it's sort strategy
 spsf->sort( pairComparePtr, ascending );

 // Return it
 return spsf;
}

// ---------------------------------------------------------------------
// Create a Demand Schedule, set it's demandSS strategy
// and optional filterstrategy, data population is not done here.
// ---------------------------------------------------------------------
LgFrSortingDemandScheduleFloatSmartPointer
LgFrScheduleFactory::createDemandSched(
   const LgFrDemandScheduleStrategy & demandSS,
   const LgFrFilterStrategy * filterStrategyPtr,
   const LgFrPairCompareFloat * pairComparePtr,
   const bool ascending
                                     )
     const
{
 LgFrSortingDemandScheduleFloatSmartPointer sdsf = 
     LgFrSortingDemandScheduleFloatSmartPointer(new LgFrSortingDemandScheduleFloat());
                                           
 // Set it's strategy
 sdsf->attributeScheduleStrategy(demandSS);

 // Set it's filter strategy
 if ( filterStrategyPtr ) sdsf->filterStrategy(*filterStrategyPtr);

 // Set it's sort strategy
 sdsf->sort( pairComparePtr, ascending );

 // Return it
 return sdsf;
}


LgFrSortingPartScheduleFloatSmartPointer								      
LgFrScheduleFactory::newPartScheduleFromExistingOne
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate,
   LgFrSortingPartScheduleFloatSmartPointer schedulePtrPtr)
  const
{	
  LgFrSortingPartScheduleFloatSmartPointer ptr;	
  									      
  /* Copy the saved schedule if necessary */				      
  if (deepCopy)								      
    ptr = schedulePtrPtr.deepCopy();			      
  else									      
    ptr = schedulePtrPtr;					      
  									      
  if (toPopulate) 
  {							      
    if ( LgFrScheduleFactory::scheduleType(desc, *(ptr->attributeScheduleStrategy()) ) == INPUT	||						      
    	 (this->lastProblemSolved()).imploded() )			      
    {								      
      if ( ptr->size() == 0 ) 
      {					      
	    /* Schedule does not seem to be populated, so populate it.	      
	     * Note: This is a heuristic.  The schedule may really be		      
	     * populated, but there is no way to tell.			      
	     * Note: ptr may point to a schedule in this schedule factory's	      
	     * list of schedule, so populating it will affect a schedule	      
	     * that is already in use.  If that behavior is not desired, the	      
	     * schedule factory users should use deep copy instead. */	      
	    ptr->populate();						      
      }									      
      else 
      {								      
	    /* The schedule seems to be populated.  Should it be repopulated?	      
	     * Pros: The argument says to repopulate it, and that would result      
	     * in up-to-date results.  Cons: If the schedule subscribes to its      
	     * data-source, it will be updated automatically whenever somthing      
	     * it depends on changes, so it ought to be up-to-date already.	      
	     * The Cons win.	*/					      
	    /* Do nothing */						      
      }									      
    }									      
  }									      
  else /* toPopulate is false */ 
  {					      
    if ( ptr->size() != 0 ) 
    {					      
      /* Dilemma: caller says not to populate the schedule, but it is already
       * populated.  Solution for now: print warning */		   	      
      this->printWarning();						      
    }									      
  }									      
  return ptr;								      
}

LgFrSortingDemandScheduleFloatSmartPointer								      
LgFrScheduleFactory::newDemandScheduleFromExistingOne
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate,
   LgFrSortingDemandScheduleFloatSmartPointer schedulePtrPtr)
  const
{	
  LgFrSortingDemandScheduleFloatSmartPointer ptr;	
  									      
  /* Copy the saved schedule if necessary */				      
  if (deepCopy)								      
    ptr = schedulePtrPtr.deepCopy();			      
  else									      
    ptr = schedulePtrPtr;					      
  									      
  if (toPopulate) 
  {							      
    if ( LgFrScheduleFactory::scheduleType(desc, *(ptr->attributeScheduleStrategy()) ) == INPUT	||						      
    	 (this->lastProblemSolved()).imploded() )			      
    {								      
      if ( ptr->size() == 0 ) 
      {					      
	    /* Schedule does not seem to be populated, so populate it.	      
	     * Note: This is a heuristic.  The schedule may really be		      
	     * populated, but there is no way to tell.			      
	     * Note: ptr may point to a schedule in this schedule factory's	      
	     * list of schedule, so populating it will affect a schedule	      
	     * that is already in use.  If that behavior is not desired, the	      
	     * schedule factory users should use deep copy instead. */	      
	    ptr->populate();						      
      }									      
      else 
      {								      
	    /* The schedule seems to be populated.  Should it be repopulated?	      
	     * Pros: The argument says to repopulate it, and that would result      
	     * in up-to-date results.  Cons: If the schedule subscribes to its      
	     * data-source, it will be updated automatically whenever somthing      
	     * it depends on changes, so it ought to be up-to-date already.	      
	     * The Cons win.	*/					      
	    /* Do nothing */						      
      }									      
    }									      
  }									      
  else /* toPopulate is false */ 
  {					      
    if ( ptr->size() != 0 ) 
    {					      
      /* Dilemma: caller says not to populate the schedule, but it is already
       * populated.  Solution for now: print warning */		   	      
      this->printWarning();						      
    }									      
  }									      
  return ptr;								      
}

// ------------------------------------------------------------------------------
// Create a new sorting part schedule
// Populate all input schedules if toPopulate flag = true.
// Populate all output schedules if implosion was run and toPopulate flag = true.
// -------------------------------------------------------------------------------
LgFrSortingPartScheduleFloatSmartPointer
  LgFrScheduleFactory::newPartSchedule  (const LgFrScheduleDescriptor& desc,
					 const bool deepCopy,
					 const bool toPopulate
					 )
     const
{
  LgFrSortingPartScheduleFloatSmartPointer schedulePtr = 0;
  NamePartDictionary::const_iterator it = ((LgFrScheduleFactory*)this)->partSchedules_.find( desc.name() );
  if( it != partSchedules_.end() )
      schedulePtr = (*it).second;

  if( !schedulePtr.null() &&  toPopulate )
  {
    return this->newPartScheduleFromExistingOne (desc, deepCopy, toPopulate, schedulePtr);
  }
  else 
  {
    // Either the schedule has not been created before, or the user
    // does not to use one that has already been populated, so make
    // it from scratch
    LgFrSortingPartScheduleFloatSmartPointer spsf
      = newPartScheduleFromScratch (desc, deepCopy, toPopulate);
    if ( schedulePtr.null() ) 
    {
      // This is the first time a schedule with this descriptor has
      // been made, so save it.
      // cast away const
      ((LgFrScheduleFactory *)this)->insertPartSchedule(desc, spsf);
    }
    return spsf;
  }
}

// --------------------------------------------------------------------------
// Return a schedule without getting it from the list of previously-
// constructed schedules
// --------------------------------------------------------------------------
LgFrSortingPartScheduleFloatSmartPointer 
LgFrScheduleFactory::newPartScheduleFromScratch
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate
   )
const
{
  LgFrScenarioSmartPointer scenario = this->scenario();
  LgFrPartScheduleStrategy *partSS;
  LgFrFilterStrategy * filterStrategyPtr = 0;
  LgFrPairCompareFloat * pairComparePtr = 0;
  bool ascending = true;
  if ( desc == LGFRCriticalPartSupplyVolume ) {
      // First get the critical list
      // Then, use a schedule sensitive filter startegy to get
      // the critical supply schedule.
      LgFrCriticalPartScheduleStrategy* criticalSS 
	= new LgFrCriticalPartScheduleStrategy(*scenario);
      LgFrSortingPartScheduleFloatSmartPointer
	  criticalSchedule = createPartSched(*criticalSS);
      LgFrScheduleSensitiveFilterStrategy cs;
      cs.schedule( criticalSchedule );
      LgFrSupplyScheduleStrategy* supplySS 
	= new LgFrSupplyScheduleStrategy(*scenario);
      LgFrSortingPartScheduleFloatSmartPointer
	  supplySchedule = createPartSched(*supplySS, &cs);
      delete criticalSS;
      delete supplySS;

      // cast away const
      ((LgFrScheduleFactory *)this)->insertPartSchedule(desc, supplySchedule);

      return supplySchedule; 
  }
  else if ( desc == LGFRCriticalPartRankingList )
      partSS = new LgFrCriticalPartScheduleStrategy(*scenario);
  else if ( desc == LGFRExcessVolume )
      partSS = new LgFrExcessScheduleStrategy(*scenario);
  else if ( desc == LGFRFocussedShortageSchedule )
      partSS = new LgFrFocussedShortageScheduleScheduleStrategy(*scenario);
  else if ( desc == LGFRFSSProductionVolume )
      partSS = new 
               LgFrFocussedShortageScheduleProductionScheduleStrategy(
               *scenario );
  else if ( desc == LGFRProductionVolume )
      partSS = new LgFrProductionScheduleStrategy(*scenario);
  else if ( desc == LGFRRequirementVolume )
      partSS = new LgFrRequirementScheduleStrategy(*scenario);
  else if ( desc == LGFRSupplyVolume ) {
      partSS = new LgFrSupplyScheduleStrategy(*scenario);

      // Code which will sort schedule's itemTimeVec's in descending order
      // pairComparePtr = new LgFrPairCompareFloat();
      // ascending = false;
  }
  else if ( desc == LGFRCycleTime ) 
      partSS = new LgFrCycleTimeScheduleStrategy(*scenario);
  else if ( desc == LGFRStockVolume ) 
      partSS = new LgFrStockScheduleStrategy(*scenario);
  else if ( desc == LGFRScrapVolume ) 
      partSS = new LgFrScrapScheduleStrategy(*scenario);
  else if ( desc == LGFRMaterialSupplyVolume) {
      partSS = new LgFrSupplyScheduleStrategy(*scenario);
      // Make a filter that keeps capacity PARTS out of the schedule
      filterStrategyPtr = new LgFrPartCategoryFilterStrategy (LgFrCAPACITY,
							*scenario);
  }
  else if ( desc == LGFRCapacitySupplyVolume) {
      partSS = new LgFrSupplyScheduleStrategy(*scenario);
      // Make a filter that keeps capacities out of the schedule
      LgFrPartCategoryFilterStrategy categoryFilter
	  = LgFrPartCategoryFilterStrategy (LgFrCAPACITY, *scenario);
      // Make a filter that only lets capacities into the schedule.  (The 
      // LgFrNotFilterStrategy makes a copy of categoryFilter.)
      filterStrategyPtr = new  LgFrNotFilterStrategy (categoryFilter);
  }
  else if ( desc == LGFRTotalPartDemandVol) {
      LgFrCumDemandsPartScheduleStrategy* totShipSS
	  = new LgFrCumDemandsPartScheduleStrategy(*scenario);
      LgFrSortingDemandScheduleFloatSmartPointer dependentSched = 
	  this->newDemandSchedule(LGFRDemandVolume, deepCopy, toPopulate);
      totShipSS->insertDemandSchedule(dependentSched);
      partSS = totShipSS;
      partSS->setOfParts(scenario->constSetOfParts());
  }
#if 0
  else if (desc ==  LGFRSupplyVolumeTimesUnitCost) {
      LgFrPartScheduleTimesUnitCostScheduleStrategy* supVolTimesUnitCostSS
	  = new LgFrPartScheduleTimesUnitCostScheduleStrategy (*scenario) ;
      LgFrSortingPartScheduleFloatSmartPointer tempSched =
        this->newPartSchedule(LGFRSupplyVolume, deepCopy, toPopulate);
      supVolTimesUnitCostSS->insertPartSchedule( tempSched );
      partSS = supVolTimesUnitCostSS;
      partSS->setOfParts( scenario->constSetOfParts() );
  }
  else if (desc ==  LGFRRequirementVolumeTimesUnitCost) {
      LgFrPartScheduleTimesUnitCostScheduleStrategy* ucSS
	  = new LgFrPartScheduleTimesUnitCostScheduleStrategy (*scenario) ;
      LgFrSortingPartScheduleFloatSmartPointer tempSched =
        this->newPartSchedule(LGFRRequirementVolume, deepCopy, toPopulate);
      ucSS->insertPartSchedule( tempSched );
      partSS = ucSS;
      partSS->setOfParts( scenario->constSetOfParts() );
  }
  else if (desc ==  LGFRStockVolumeTimesUnitCost) {
      LgFrPartScheduleTimesUnitCostScheduleStrategy* ucSS
	  = new LgFrPartScheduleTimesUnitCostScheduleStrategy (*scenario) ;
      LgFrSortingPartScheduleFloatSmartPointer tempSched =
        this->newPartSchedule(LGFRStockVolume, deepCopy, toPopulate);
      ucSS->insertPartSchedule( tempSched );
      partSS = ucSS;
      partSS->setOfParts( scenario->constSetOfParts() );
  }
#endif
  else if (desc == LGFRUsageVolume)     {
      LgFrUsageScheduleStrategy* usageSS
	  = new LgFrUsageScheduleStrategy(*scenario);
      LgFrSortingPartScheduleFloatSmartPointer dependentSupplySched1 = 
	  this->newPartSchedule(LGFRSupplyVolume, deepCopy, toPopulate);
      LgFrSortingPartScheduleFloatSmartPointer dependentProdSched2 = 
	  this->newPartSchedule(LGFRProductionVolume, deepCopy, toPopulate);
      LgFrSortingPartScheduleFloatSmartPointer dependentStockSched3 = 
	  this->newPartSchedule(LGFRStockVolume, deepCopy, toPopulate);
      LgFrSortingPartScheduleFloatSmartPointer dependentScrapSched4 = 
	  this->newPartSchedule(LGFRScrapVolume, deepCopy, toPopulate);
      usageSS->insertPartSchedule(dependentSupplySched1);
      usageSS->insertPartSchedule(dependentProdSched2);
      usageSS->insertPartSchedule(dependentStockSched3);
      usageSS->insertPartSchedule(dependentScrapSched4);
      partSS = usageSS;
  }
  else {
      std::cerr << "\nWrong part schedule description string \""
	   << desc.name() << "\" used.";
      return 0;
  }
  LgFrSortingPartScheduleFloatSmartPointer spsf = 
						createPartSched(
						   *partSS,
						   filterStrategyPtr,
						   pairComparePtr,
						   ascending);
  if ( toPopulate ) 
      // LgFrScheduleFactory::scheduleType is used in following line
      // to prevent a subclass's scheduleType from being used when the
      // schedule is being generated by this class
      if ( LgFrScheduleFactory::scheduleType(desc,*partSS)  == INPUT )
	  spsf->populate();
      else {
	  LgFrLastProblemSolved& lps = this->lastProblemSolved();
	  if ( lps.imploded() ) spsf->populate();
      }

  delete partSS;
  delete filterStrategyPtr;
  delete pairComparePtr;

  return spsf;
}


// ------------------------------------------------------------------------------
// Create a new sorting demand schedule
// Populate all input schedules if toPopulate flag = true.
// Populate all output schedules if implosion was run and toPopulate flag = true.
// ------------------------------------------------------------------------------
LgFrSortingDemandScheduleFloatSmartPointer
  LgFrScheduleFactory::newDemandSchedule(const LgFrScheduleDescriptor& desc,
					 const bool deepCopy,
					 const bool toPopulate
					 )
     const
{
  LgFrSortingDemandScheduleFloatSmartPointer schedulePtr = 0;
  NameDemandDictionary::const_iterator it = ((LgFrScheduleFactory*)this)->demandSchedules_.find( desc.name() );
  if( it != demandSchedules_.end() )
      schedulePtr = (*it).second;

//  std::string key(desc.name());
//  LgFrSortingDemandScheduleFloatSmartPointer* schedulePtr =
//    (LgFrSortingDemandScheduleFloatSmartPointer *)
//    demandSchedules_.findValue(&key);
  if (!schedulePtr.null()  &&  toPopulate )  {
    return this->newDemandScheduleFromExistingOne (desc, deepCopy, toPopulate, 
						   schedulePtr);
  }
  else {
    // Either the schedule has not been created before, or the user
    // does not to use one that has already been populated, so make
    // it from scratch
    LgFrSortingDemandScheduleFloatSmartPointer spsf
      = newDemandScheduleFromScratch (desc, deepCopy, toPopulate);
    if (schedulePtr == 0) {
      // This is the first time a schedule with this descriptor has
      // been made, so save it.
      // cast away const
      ((LgFrScheduleFactory *)this)->insertDemandSchedule(desc, spsf);
    }
    return spsf;
  }
}

// --------------------------------------------------------------------------
// Return a schedule without getting it from the list of previously-
// constructed schedules
// --------------------------------------------------------------------------
LgFrSortingDemandScheduleFloatSmartPointer 
LgFrScheduleFactory::newDemandScheduleFromScratch
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate
   )
const
{
  LgFrDemandScheduleStrategy *demandSS;
  if ( desc == LGFRDemandVolume ) 
      demandSS = new LgFrDemandVolumeScheduleStrategy(*(this->scenario()));
  else if ( desc == LGFRShipmentVolume )
      demandSS = new LgFrShipmentScheduleStrategy(*(this->scenario()));
  else if ( desc == LGFRBacklogVolume )
      demandSS = new LgFrBacklogScheduleStrategy(*(this->scenario()));
  else if ( desc == LGFRPriority )
      demandSS = new  LgFrPriorityScheduleStrategy(*(this->scenario()));
  else if ( desc == LGFRObj1ShipReward )
      demandSS = new  LgFrObj1ShipRewardScheduleStrategy(*(this->scenario()));
  else {
      std::cerr << "\nWrong demand schedule description string \""
	   << desc.name() << "\" used.";
      return 0;
  }
  LgFrSortingDemandScheduleFloatSmartPointer sdsf 
    = createDemandSched(*demandSS);
  if ( toPopulate )
      // LgFrScheduleFactory::scheduleType is used in following line
      // to prevent a subclass's scheduleType from being used when the
      // schedule is being generated by this class
      if ( LgFrScheduleFactory::scheduleType(desc,*demandSS) == INPUT )
	  sdsf->populate();
      else {
	  LgFrLastProblemSolved& lps = this->lastProblemSolved();
	  if ( lps.imploded() ) sdsf->populate();
      }
  delete demandSS;

  return sdsf;
}


// ---------------------------------------------------------------------
// Return the schedule type: INPUT or OUTPUT of implosion run.
// ---------------------------------------------------------------------
schdType
LgFrScheduleFactory::scheduleType(const LgFrScheduleDescriptor& desc,
				  const LgFrAttributeScheduleStrategy & ass)
     const
{
    if ( ass.isMutable() ) return INPUT;	// Doing it this way (instead
    if ( desc == LGFRSupplyVolumeTimesUnitCost ) // of using ||) allows
	return INPUT;				// inlining
    return OUTPUT;
}

std::string
LgFrScheduleFactory::abbreviationOf (const LgFrScheduleDescriptor & desc)
     const
{
  return desc.abbrev( scenario()->nationalLanguage() );
}

    
// ---------------------------------------------------------------------
// Return list of schedule descriptors which can be used by factory to
// create schedules.     
// ---------------------------------------------------------------------
LgFrScheduleDescriptorVector
LgFrScheduleFactory::demandScheduleDescriptors()
const
{
  return LgFrScheduleFactory::demandScheduleDescriptors_;
}
LgFrScheduleDescriptorVector
LgFrScheduleFactory::partScheduleDescriptors()
const
{
  return LgFrScheduleFactory::partScheduleDescriptors_;
}

// ---------------------------------------------------------------------
// Return the LastProblemSolved which belongs to this scenario
// ---------------------------------------------------------------------
LgFrLastProblemSolved&
  LgFrScheduleFactory::lastProblemSolved()
     const
{
    // cast the object so that it's non-const - HACK
  return ((LgFrScenarioSmartPointer&)scenarioPtr_)->lastProblemSolved();
}

// ---------------------------------------------------------------------
// Returns the factory's demandSchedules_
// ---------------------------------------------------------------------
NameDemandDictionary &
LgFrScheduleFactory::demandSchedules()
{
  return demandSchedules_;
}


// ---------------------------------------------------------------------
// Returns the factory's partSchedules_
// ---------------------------------------------------------------------
NamePartDictionary &
LgFrScheduleFactory::partSchedules()
{
  return partSchedules_;
}


// ---------------------------------------------------------------------
// Return the scenario ptr
// ---------------------------------------------------------------------
LgFrScenarioSmartPointer
  LgFrScheduleFactory::scenario()
     const
{
  return scenarioPtr_;
}
// ---------------------------------------------------------------------
//   methods for inserting Schedules into Dictionaries
// ---------------------------------------------------------------------
void
LgFrScheduleFactory::insertDemandSchedule(const LgFrScheduleDescriptor& desc,
					  LgFrSortingDemandScheduleFloatSmartPointer schedulePtr)
{
    demandSchedules_.insert( NameDemandPair( desc.name(), schedulePtr ) );
}

void
LgFrScheduleFactory::insertPartSchedule(const LgFrScheduleDescriptor& desc,
					  LgFrSortingPartScheduleFloatSmartPointer schedulePtr)
{
    partSchedules_.insert( NamePartPair( desc.name(), schedulePtr ) );
}

// Initialize static class data
LgFrScheduleDescriptorVector
LgFrScheduleFactory::demandScheduleDescriptors_
                     = LgFrScheduleFactory::initializeDemandScheduleDescriptors();
LgFrScheduleDescriptorVector
LgFrScheduleFactory::partScheduleDescriptors_
                     = LgFrScheduleFactory::initializePartScheduleDescriptors();

LgFrScheduleDescriptorVector
LgFrScheduleFactory::initializeDemandScheduleDescriptors()
{
  LgFrScheduleDescriptorVector retVal;
  retVal.push_back(LGFRDemandVolume);
  retVal.push_back(LGFRShipmentVolume);
  retVal.push_back(LGFRBacklogVolume);
  retVal.push_back(LGFRPriority);
  retVal.push_back(LGFRObj1ShipReward);
  return retVal;
}

LgFrScheduleDescriptorVector
LgFrScheduleFactory::initializePartScheduleDescriptors()
{
  LgFrScheduleDescriptorVector retVal;
  retVal.push_back(LGFRCriticalPartSupplyVolume);
  retVal.push_back(LGFRCriticalPartRankingList);
  retVal.push_back(LGFRExcessVolume);
  retVal.push_back(LGFRFocussedShortageSchedule);
  retVal.push_back(LGFRFSSProductionVolume);
  retVal.push_back(LGFRProductionVolume);
  retVal.push_back(LGFRRequirementVolume );
  retVal.push_back(LGFRSupplyVolume);
  retVal.push_back(LGFRCycleTime);
  retVal.push_back(LGFRStockVolume);
  retVal.push_back(LGFRScrapVolume);
  retVal.push_back(LGFRMaterialSupplyVolume);
  retVal.push_back(LGFRCapacitySupplyVolume);
  retVal.push_back(LGFRTotalPartDemandVol);
#if 0
  retVal.push_back(LGFRSupplyVolumeTimesUnitCost);
  retVal.push_back(LGFRStockVolumeTimesUnitCost);
#endif
  retVal.push_back(LGFRUsageVolume);
  return retVal;
}

// ---------------------------------------------------------------------
// Remove all of the descriptors and
// LgFrSortingPartScheduleFloatSmartPointer from the dictionaries.
// This frees the smart pointers.  As usual, the schedules they point to
// are deleted if and only if no other smart pointers point to the
// schedules.
// This routine is needed because of a catch-22: if a LgFrScheduleFactory
// LgFrSortingPartScheduleFloatSmartPointer's to schedules, the relevant
// scenario may never be deleted (because of subscriptions) and since
// the scenario won't be delete, the schedule factory won't be deleted,
// so the schedules won't be deleted, ....  By deleting the reference
// to the schedules in the schedule factory, the schedules can be
// deleted, so the scenario can be deleted, so the factory can be
// deleted.
// ---------------------------------------------------------------------
void
LgFrScheduleFactory::clearAndDestroy()
{
  //partSchedules().clearAndDestroy();
  //demandSchedules().clearAndDestroy();
}

// ---------------------------------------------------------------------
// Print warning about calling with toPopulate false when a populated
// schedule for the given descriptor already exists
// ---------------------------------------------------------------------
void
LgFrScheduleFactory::printWarning() const
{
  std::cerr << "Warning: Internal inconsistency.  Program tried to make a \n"
       << "schedule without numbers, but the numbers had already been\n"
       << "calculated, so they are being used anyway.  Unusual results may\n"
       << "appear." << std::endl;
}

// ---------------------------------------------------------------------
// Create a copy of the *this on the heap in the new scenario
// and return a pointer to it.
// ---------------------------------------------------------------------
LgFrScheduleFactory*
LgFrScheduleFactory::clone (LgFrScenarioSmartPointer newScenario)
     const
{
  return new LgFrScheduleFactory(newScenario);
}

// ---------------------------------------------------------------------
// Constructor
// ---------------------------------------------------------------------
LgFrScheduleFactory::LgFrScheduleFactory (LgFrScenarioSmartPointer scenPtr)
:   scenarioPtr_(scenPtr)
{
}

// ---------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------
LgFrScheduleFactory::~LgFrScheduleFactory()
{
}


#ifdef NDEBUG
#undef NDEBUG
#endif

// ---------------------------------------------------------------------
// test this class
// ---------------------------------------------------------------------
void
LgFrScheduleFactory::test()
{
}


// Expects *testScenario to contain data from
// /u/implode/wit/data/examples/diner12/wit.data and expects
// f to be the scedule factory for testScenario
void
LgFrScheduleFactory::contextTest(const LgFrScheduleFactory & f,
                                 LgFrScenarioSmartPointer & testScenario)
{
  // Test abbreviation function
  assert (f.abbreviationOf (LGFRSupplyVolume)
          != LGFRScrapVolume.abbrev()            );
  assert (f.abbreviationOf (LGFRSupplyVolume)
          == LGFRSupplyVolume.abbrev()           );
  assert (f.abbreviationOf (LGFRDemandVolume)
          == LGFRDemandVolume.abbrev()           );

  // test smart schedule stuff
  LgFrSortingDemandScheduleFloatSmartPointer priSchedule =
      f.newDemandSchedule(LGFRPriority, false);
  LgFrSortingDemandScheduleFloatSmartPointer priSchedule2 =
      f.newDemandSchedule(LGFRPriority, false);
  assert(priSchedule == priSchedule2);

  LgFrSortingPartScheduleFloatSmartPointer reqSchedule =
      f.newPartSchedule(LGFRRequirementVolume, false);
  LgFrSortingPartScheduleFloatSmartPointer reqSchedule2 =
      f.newPartSchedule(LGFRRequirementVolume, false);
  assert(reqSchedule == reqSchedule2);

  // test LGFRSupplyVolumeTimesUnitCost and LGFRSupplyVolume
  
  LgFrSortingPartScheduleFloatSmartPointer supplySchedule =
      f.newPartSchedule(LGFRSupplyVolume, false, true);
#if 0
  LgFrSortingPartScheduleFloatSmartPointer supplyTimesCostSchedule =
      f.newPartSchedule(LGFRSupplyVolumeTimesUnitCost, false, true);
  LgFrScheduleFloat & s = *supplySchedule;
  assert (s.size() != 0);
  assert (s == *supplyTimesCostSchedule); // unit costs in diner12 are all 1.0
#endif


  // test LGFRUsageVolume
  LgFrSortingPartScheduleFloatSmartPointer usageSchedule =
      f.newPartSchedule(LGFRUsageVolume, true, true);
  testScenario -> newImplosionSolution();
  LgFrUsageScheduleStrategy::quantityTest (*usageSchedule);

#if 0
  // test LGFRStockVolumeTimesUnitCost and LGFRStockVolume
  LgFrSortingPartScheduleFloatSmartPointer stockSchedule =
      f.newPartSchedule(LGFRStockVolume, false, true);
  LgFrSortingPartScheduleFloatSmartPointer stockTimesCostSchedule =
      f.newPartSchedule(LGFRStockVolumeTimesUnitCost, false, true);
  LgFrScheduleFloat & ss = *stockSchedule;
  assert (ss.size() != 0);
  assert (ss == *stockTimesCostSchedule); // unit costs in diner12 are all 1.0

  // test LGFRRequirementVolumeTimesUnitCost and LGFRRequirementVolume
  LgFrSortingPartScheduleFloatSmartPointer requirementSchedule =
      f.newPartSchedule(LGFRRequirementVolume, false, true);
  LgFrSortingPartScheduleFloatSmartPointer requirementTimesCostSchedule =
      f.newPartSchedule(LGFRRequirementVolumeTimesUnitCost, false, true);
  LgFrScheduleFloat & rs = *requirementSchedule;
  testScenario -> newExplosionSolution();
  assert (rs.size() != 0);
  assert (rs == *requirementTimesCostSchedule); // unit costs in diner12 are all 1.0
  assert (! (s == rs) );
  assert (! (ss == rs) );


  // test national language support of abbreviationOf method
  assert( testScenario->nationalLanguage() == English );
  assert (f.abbreviationOf (LGFRDemandVolume)
          == LGFRDemandVolume.abbrev( English )     );
  testScenario->nationalLanguage( Kana );
  assert( testScenario->nationalLanguage() == Kana );
  assert (f.abbreviationOf (LGFRDemandVolume)
          == LGFRDemandVolume.abbrev( Kana )     );
  assert (f.abbreviationOf (LGFRDemandVolume)
          != LGFRDemandVolume.abbrev( English )     );
  testScenario->nationalLanguage( English );
  assert( testScenario->nationalLanguage() == English );
#endif  

  // test scheduleDescriptor methods
  {
    LgFrScheduleDescriptorVector sd =
      f.LgFrScheduleFactory::demandScheduleDescriptors();
    // Test that each demand schedule can be created by this factory
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i = 0; i<sd.size(); i++ ) {
      LgFrSortingDemandScheduleFloatSmartPointer schedSP =
         f.newDemandSchedule( sd[i]); 
      assert( !schedSP.null() );
    }
  }
  {
    LgFrScheduleDescriptorVector sd =
      f.LgFrScheduleFactory::partScheduleDescriptors();
    // Test that each part schedule can be created by this factory
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i = 0; i<sd.size(); i++ ) {

      // There is a problem creating LGFRCriticalPartSupplyVolume schedule.
      // This needs to be investigated and fixed.
      // UnitTest will fail if this schedule is created.
      if ( sd[i] == LGFRCriticalPartSupplyVolume ) continue;
      
      LgFrSortingPartScheduleFloatSmartPointer schedSP =
         f.newPartSchedule( sd[i]); 
      assert( !schedSP.null() );
    }
  }

}
@


1.2
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d31 1
a31 1
#include <scenario/src/costSS.h>
d334 1
d362 1
d631 1
d634 1
d746 1
d752 1
d761 1
a761 1

d783 1
d796 1
a796 1
  
@


1.1
log
@Initial revision
@
text
@d1 5
a34 102
// LgFrSortingDemandScheduleFloatSmartPointerCollectable
// ---------------------------------------------------------------------

// isA(), newSpecies(), copy(), and some other things are defined
// by this macro
RWDEFINE_COLLECTABLE(LgFrSortingDemandScheduleFloatSmartPointerCollectable,
		     __LGFRSORTINGDEMANDSCHEDULEFLOATSMARTPOINTERCOLLECTABLE)

// Constructor
LgFrSortingDemandScheduleFloatSmartPointerCollectable::
LgFrSortingDemandScheduleFloatSmartPointerCollectable(LgFrSortingDemandScheduleFloatSmartPointer schedPtr)
    : schedulePtr_(schedPtr)
{
}

// Default Constructor
LgFrSortingDemandScheduleFloatSmartPointerCollectable::
LgFrSortingDemandScheduleFloatSmartPointerCollectable()
    : schedulePtr_()
{
}

// Destructor
LgFrSortingDemandScheduleFloatSmartPointerCollectable::
~LgFrSortingDemandScheduleFloatSmartPointerCollectable()
{
}

LgFrSortingDemandScheduleFloatSmartPointer
LgFrSortingDemandScheduleFloatSmartPointerCollectable::schedule()
{
    return schedulePtr_;
}


RWBoolean
LgFrSortingDemandScheduleFloatSmartPointerCollectable::isEqual(const RWCollectable* a) const
{
    assert( a->isA() == __LGFRSORTINGDEMANDSCHEDULEFLOATSMARTPOINTERCOLLECTABLE);
    return schedulePtr_ == ( (LgFrSortingDemandScheduleFloatSmartPointerCollectable*) a)->schedule();
}


unsigned
LgFrSortingDemandScheduleFloatSmartPointerCollectable::hash() const
{
    return __LGFRSORTINGDEMANDSCHEDULEFLOATSMARTPOINTERCOLLECTABLE;
}

// ---------------------------------------------------------------------
// LgFrSorting*ScheduleFloatSmartPointerCollectable
// ---------------------------------------------------------------------

// isA(), newSpecies(), copy(), and some other things are defined
// by this macro
RWDEFINE_COLLECTABLE(LgFrSortingPartScheduleFloatSmartPointerCollectable,
		     __LGFRSORTINGPARTSCHEDULEFLOATSMARTPOINTERCOLLECTABLE)


// Constructor
LgFrSortingPartScheduleFloatSmartPointerCollectable::
LgFrSortingPartScheduleFloatSmartPointerCollectable(LgFrSortingPartScheduleFloatSmartPointer schedPtr)
    : schedulePtr_(schedPtr)
{
}

// Default Constructor
LgFrSortingPartScheduleFloatSmartPointerCollectable::
LgFrSortingPartScheduleFloatSmartPointerCollectable()
    : schedulePtr_()
{
}

// Destructor
LgFrSortingPartScheduleFloatSmartPointerCollectable::
~LgFrSortingPartScheduleFloatSmartPointerCollectable()
{
}

LgFrSortingPartScheduleFloatSmartPointer
LgFrSortingPartScheduleFloatSmartPointerCollectable::schedule()
{
    return schedulePtr_;
}


RWBoolean
LgFrSortingPartScheduleFloatSmartPointerCollectable::isEqual(const RWCollectable* a) const
{
    assert( a->isA() == __LGFRSORTINGPARTSCHEDULEFLOATSMARTPOINTERCOLLECTABLE);
    return schedulePtr_ == ( (LgFrSortingPartScheduleFloatSmartPointerCollectable*) a)->schedule();
}


unsigned
LgFrSortingPartScheduleFloatSmartPointerCollectable::hash() const
{
    return __LGFRSORTINGPARTSCHEDULEFLOATSMARTPOINTERCOLLECTABLE;
}


// ---------------------------------------------------------------------
d43 1
a43 1
   const RWBoolean ascending
d72 1
a72 1
   const RWBoolean ascending
d93 48
a140 48
#define NEW_SCHEDULE_FROM_EXISTING_ONE(FUNCTION_NAME,RETURN_TYPE,PARM_TYPE)  \
RETURN_TYPE								      \
LgFrScheduleFactory::FUNCTION_NAME					      \
  (const LgFrScheduleDescriptor& desc,					      \
   const RWBoolean deepCopy,						      \
   const RWBoolean toPopulate,						      \
   PARM_TYPE* schedulePtrPtr)						      \
  const									      \
{									      \
  RETURN_TYPE ptr;							      \
  									      \
  /* Copy the saved schedule if necessary */				      \
  if (deepCopy)								      \
    ptr = schedulePtrPtr->schedule().deepCopy();			      \
  else									      \
    ptr = schedulePtrPtr->schedule();					      \
  									      \
  if (toPopulate) {							      \
    if ( LgFrScheduleFactory::scheduleType(desc,			      \
					   *(ptr->attributeScheduleStrategy())\
					  )				      \
	 == INPUT							      \
        ||							       	      \
	 (this->lastProblemSolved()).imploded() 			      \
       ) {								      \
      if ( ptr->entries() == 0 ) {					      \
	/* Schedule does not seem to be populated, so populate it.	      
	 * Note: This is a heuristic.  The schedule may really be		      
	 * populated, but there is no way to tell.			      
	 * Note: ptr may point to a schedule in this schedule factory's	      
	 * list of schedule, so populating it will affect a schedule	      
	 * that is already in use.  If that behavior is not desired, the	      
	 * schedule factory users should use deep copy instead. */	      \
	ptr->populate();						      \
      }									      \
      else {								      \
	/* The schedule seems to be populated.  Should it be repopulated?	      
	 * Pros: The argument says to repopulate it, and that would result      
	 * in up-to-date results.  Cons: If the schedule subscribes to its      
	 * data-source, it will be updated automatically whenever somthing      
	 * it depends on changes, so it ought to be up-to-date already.	      
	 * The Cons win.	*/					      \
	/* Do nothing */						      \
      }									      \
    }									      \
  }									      \
  else /* toPopulate is false */ {					      \
    if ( ptr->entries() != 0 ) {					      \
d142 62
a203 14
       * populated.  Solution for now: print warning */		   	      \
      this->printWarning();						      \
    }									      \
  }									      \
  return ptr;								      \
}

NEW_SCHEDULE_FROM_EXISTING_ONE(newPartScheduleFromExistingOne, \
			       LgFrSortingPartScheduleFloatSmartPointer, \
			       LgFrSortingPartScheduleFloatSmartPointerCollectable)

NEW_SCHEDULE_FROM_EXISTING_ONE(newDemandScheduleFromExistingOne, \
			       LgFrSortingDemandScheduleFloatSmartPointer, \
			       LgFrSortingDemandScheduleFloatSmartPointerCollectable)
a204 1
#undef NEW_SCHEDULE_FROM_EXISTING_ONE   
d207 2
a208 2
// Populate all input schedules if toPopulate flag = TRUE.
// Populate all output schedules if implosion was run and toPopulate flag = TRUE.
d212 2
a213 2
					 const RWBoolean deepCopy,
					 const RWBoolean toPopulate
d217 8
a224 7
  RWCollectableString key(desc.name());
  LgFrSortingPartScheduleFloatSmartPointerCollectable* schedulePtr =
    (LgFrSortingPartScheduleFloatSmartPointerCollectable *) 
    partSchedules_.findValue(&key);
  if (schedulePtr != NULL  &&  toPopulate )  {
    return this->newPartScheduleFromExistingOne (desc, deepCopy, toPopulate, 
						 schedulePtr);
d226 2
a227 1
  else {
d233 2
a234 1
    if (schedulePtr == NULL) {
d251 2
a252 2
   const RWBoolean deepCopy,
   const RWBoolean toPopulate
d258 3
a260 3
  LgFrFilterStrategy * filterStrategyPtr = NULL;
  LgFrPairCompareFloat * pairComparePtr = NULL;
  RWBoolean ascending = TRUE;
d302 1
a302 1
      // ascending = FALSE;
d379 1
a379 1
      cerr << "\nWrong part schedule description string \""
d381 1
a381 1
      return NULL;
d410 2
a411 2
// Populate all input schedules if toPopulate flag = TRUE.
// Populate all output schedules if implosion was run and toPopulate flag = TRUE.
d415 2
a416 2
					 const RWBoolean deepCopy,
					 const RWBoolean toPopulate
d420 10
a429 5
  RWCollectableString key(desc.name());
  LgFrSortingDemandScheduleFloatSmartPointerCollectable* schedulePtr =
    (LgFrSortingDemandScheduleFloatSmartPointerCollectable *)
    demandSchedules_.findValue(&key);
  if (schedulePtr != NULL  &&  toPopulate )  {
d439 1
a439 1
    if (schedulePtr == NULL) {
d456 2
a457 2
   const RWBoolean deepCopy,
   const RWBoolean toPopulate
d473 1
a473 1
      cerr << "\nWrong demand schedule description string \""
d475 1
a475 1
      return NULL;
d509 1
a509 1
RWCString
d521 1
a521 1
LgFrOrderedVectorScheduleDescriptor
d527 1
a527 1
LgFrOrderedVectorScheduleDescriptor
d548 1
a548 1
RWHashDictionary &
d558 1
a558 1
RWHashDictionary &
d581 1
a581 4
    LgFrSortingDemandScheduleFloatSmartPointerCollectable* value =
	new LgFrSortingDemandScheduleFloatSmartPointerCollectable(schedulePtr);
    demandSchedules_.insertKeyAndValue(new RWCollectableString(desc.name()),
				      value);
d588 1
a588 4
    LgFrSortingPartScheduleFloatSmartPointerCollectable* value =
	new LgFrSortingPartScheduleFloatSmartPointerCollectable(schedulePtr);
    partSchedules_.insertKeyAndValue(new RWCollectableString(desc.name()),
				      value);
d592 1
a592 1
LgFrOrderedVectorScheduleDescriptor
d595 1
a595 1
LgFrOrderedVectorScheduleDescriptor
d599 1
a599 1
LgFrOrderedVectorScheduleDescriptor
d602 6
a607 6
  LgFrOrderedVectorScheduleDescriptor retVal;
  retVal.insert(LGFRDemandVolume);
  retVal.insert(LGFRShipmentVolume);
  retVal.insert(LGFRBacklogVolume);
  retVal.insert(LGFRPriority);
  retVal.insert(LGFRObj1ShipReward);
d611 1
a611 1
LgFrOrderedVectorScheduleDescriptor
d614 18
a631 18
  LgFrOrderedVectorScheduleDescriptor retVal;
  retVal.insert(LGFRCriticalPartSupplyVolume);
  retVal.insert(LGFRCriticalPartRankingList);
  retVal.insert(LGFRExcessVolume);
  retVal.insert(LGFRFocussedShortageSchedule);
  retVal.insert(LGFRFSSProductionVolume);
  retVal.insert(LGFRProductionVolume);
  retVal.insert(LGFRRequirementVolume );
  retVal.insert(LGFRSupplyVolume);
  retVal.insert(LGFRCycleTime);
  retVal.insert(LGFRStockVolume);
  retVal.insert(LGFRScrapVolume);
  retVal.insert(LGFRMaterialSupplyVolume);
  retVal.insert(LGFRCapacitySupplyVolume);
  retVal.insert(LGFRTotalPartDemandVol);
  retVal.insert(LGFRSupplyVolumeTimesUnitCost);
  retVal.insert(LGFRStockVolumeTimesUnitCost);
  retVal.insert(LGFRUsageVolume);
d653 2
a654 2
  partSchedules().clearAndDestroy();
  demandSchedules().clearAndDestroy();
d664 1
a664 1
  cerr << "Warning: Internal inconsistency.  Program tried to make a \n"
d667 1
a667 1
       << "appear." << endl;
a688 5
void
LgFrScheduleFactory::initHashTable ()
{
}

a693 2
  demandSchedules_.clearAndDestroy();
  partSchedules_.clearAndDestroy();
d727 1
a727 1
      f.newDemandSchedule(LGFRPriority, FALSE);
d729 1
a729 1
      f.newDemandSchedule(LGFRPriority, FALSE);
d733 1
a733 1
      f.newPartSchedule(LGFRRequirementVolume, FALSE);
d735 1
a735 1
      f.newPartSchedule(LGFRRequirementVolume, FALSE);
d741 1
a741 1
      f.newPartSchedule(LGFRSupplyVolume, FALSE, TRUE);
d743 1
a743 1
      f.newPartSchedule(LGFRSupplyVolumeTimesUnitCost, FALSE, TRUE);
d745 1
a745 1
  assert (s.entries() != 0);
d751 1
a751 1
      f.newPartSchedule(LGFRUsageVolume, TRUE, TRUE);
d758 1
a758 1
      f.newPartSchedule(LGFRStockVolume, FALSE, TRUE);
d760 1
a760 1
      f.newPartSchedule(LGFRStockVolumeTimesUnitCost, FALSE, TRUE);
d762 1
a762 1
  assert (ss.entries() != 0);
d767 1
a767 1
      f.newPartSchedule(LGFRRequirementVolume, FALSE, TRUE);
d769 1
a769 1
      f.newPartSchedule(LGFRRequirementVolumeTimesUnitCost, FALSE, TRUE);
d772 1
a772 1
  assert (rs.entries() != 0);
d793 1
a793 1
    LgFrOrderedVectorScheduleDescriptor sd =
d796 2
a797 1
    for ( int i = 0; i<sd.entries(); i++ ) {
d804 1
a804 1
    LgFrOrderedVectorScheduleDescriptor sd =
d807 2
a808 1
    for ( int i = 0; i<sd.entries(); i++ ) {
@


1.1.1.1
log
@Import scenario
@
text
@@


1.1.1.1.14.1
log
@Roguewave is gone
@
text
@a0 5
// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
#include <string>
// End of RW2STL -- inserted includes.

d30 102
d140 1
a140 1
   const bool ascending
d169 1
a169 1
   const bool ascending
d190 48
a237 48
LgFrSortingPartScheduleFloatSmartPointer								      
LgFrScheduleFactory::newPartScheduleFromExistingOne
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate,
   LgFrSortingPartScheduleFloatSmartPointer schedulePtrPtr)
  const
{	
  LgFrSortingPartScheduleFloatSmartPointer ptr;	
  									      
  /* Copy the saved schedule if necessary */				      
  if (deepCopy)								      
    ptr = schedulePtrPtr.deepCopy();			      
  else									      
    ptr = schedulePtrPtr;					      
  									      
  if (toPopulate) 
  {							      
    if ( LgFrScheduleFactory::scheduleType(desc, *(ptr->attributeScheduleStrategy()) ) == INPUT	||						      
    	 (this->lastProblemSolved()).imploded() )			      
    {								      
      if ( ptr->size() == 0 ) 
      {					      
	    /* Schedule does not seem to be populated, so populate it.	      
	     * Note: This is a heuristic.  The schedule may really be		      
	     * populated, but there is no way to tell.			      
	     * Note: ptr may point to a schedule in this schedule factory's	      
	     * list of schedule, so populating it will affect a schedule	      
	     * that is already in use.  If that behavior is not desired, the	      
	     * schedule factory users should use deep copy instead. */	      
	    ptr->populate();						      
      }									      
      else 
      {								      
	    /* The schedule seems to be populated.  Should it be repopulated?	      
	     * Pros: The argument says to repopulate it, and that would result      
	     * in up-to-date results.  Cons: If the schedule subscribes to its      
	     * data-source, it will be updated automatically whenever somthing      
	     * it depends on changes, so it ought to be up-to-date already.	      
	     * The Cons win.	*/					      
	    /* Do nothing */						      
      }									      
    }									      
  }									      
  else /* toPopulate is false */ 
  {					      
    if ( ptr->size() != 0 ) 
    {					      
d239 14
a252 62
       * populated.  Solution for now: print warning */		   	      
      this->printWarning();						      
    }									      
  }									      
  return ptr;								      
}

LgFrSortingDemandScheduleFloatSmartPointer								      
LgFrScheduleFactory::newDemandScheduleFromExistingOne
  (const LgFrScheduleDescriptor& desc,
   const bool deepCopy,
   const bool toPopulate,
   LgFrSortingDemandScheduleFloatSmartPointer schedulePtrPtr)
  const
{	
  LgFrSortingDemandScheduleFloatSmartPointer ptr;	
  									      
  /* Copy the saved schedule if necessary */				      
  if (deepCopy)								      
    ptr = schedulePtrPtr.deepCopy();			      
  else									      
    ptr = schedulePtrPtr;					      
  									      
  if (toPopulate) 
  {							      
    if ( LgFrScheduleFactory::scheduleType(desc, *(ptr->attributeScheduleStrategy()) ) == INPUT	||						      
    	 (this->lastProblemSolved()).imploded() )			      
    {								      
      if ( ptr->size() == 0 ) 
      {					      
	    /* Schedule does not seem to be populated, so populate it.	      
	     * Note: This is a heuristic.  The schedule may really be		      
	     * populated, but there is no way to tell.			      
	     * Note: ptr may point to a schedule in this schedule factory's	      
	     * list of schedule, so populating it will affect a schedule	      
	     * that is already in use.  If that behavior is not desired, the	      
	     * schedule factory users should use deep copy instead. */	      
	    ptr->populate();						      
      }									      
      else 
      {								      
	    /* The schedule seems to be populated.  Should it be repopulated?	      
	     * Pros: The argument says to repopulate it, and that would result      
	     * in up-to-date results.  Cons: If the schedule subscribes to its      
	     * data-source, it will be updated automatically whenever somthing      
	     * it depends on changes, so it ought to be up-to-date already.	      
	     * The Cons win.	*/					      
	    /* Do nothing */						      
      }									      
    }									      
  }									      
  else /* toPopulate is false */ 
  {					      
    if ( ptr->size() != 0 ) 
    {					      
      /* Dilemma: caller says not to populate the schedule, but it is already
       * populated.  Solution for now: print warning */		   	      
      this->printWarning();						      
    }									      
  }									      
  return ptr;								      
}
d254 1
d257 2
a258 2
// Populate all input schedules if toPopulate flag = true.
// Populate all output schedules if implosion was run and toPopulate flag = true.
d262 2
a263 2
					 const bool deepCopy,
					 const bool toPopulate
d267 7
a273 8
  LgFrSortingPartScheduleFloatSmartPointer schedulePtr = 0;
  NamePartDictionary::const_iterator it = ((LgFrScheduleFactory*)this)->partSchedules_.find( desc.name() );
  if( it != partSchedules_.end() )
      schedulePtr = (*it).second;

  if( !schedulePtr.null() &&  toPopulate )
  {
    return this->newPartScheduleFromExistingOne (desc, deepCopy, toPopulate, schedulePtr);
d275 1
a275 2
  else 
  {
d281 1
a281 2
    if ( schedulePtr.null() ) 
    {
d298 2
a299 2
   const bool deepCopy,
   const bool toPopulate
d305 3
a307 3
  LgFrFilterStrategy * filterStrategyPtr = 0;
  LgFrPairCompareFloat * pairComparePtr = 0;
  bool ascending = true;
d349 1
a349 1
      // ascending = false;
d428 1
a428 1
      return 0;
d457 2
a458 2
// Populate all input schedules if toPopulate flag = true.
// Populate all output schedules if implosion was run and toPopulate flag = true.
d462 2
a463 2
					 const bool deepCopy,
					 const bool toPopulate
d467 5
a471 10
  LgFrSortingDemandScheduleFloatSmartPointer schedulePtr = 0;
  NameDemandDictionary::const_iterator it = ((LgFrScheduleFactory*)this)->demandSchedules_.find( desc.name() );
  if( it != demandSchedules_.end() )
      schedulePtr = (*it).second;

//  std::string key(desc.name());
//  LgFrSortingDemandScheduleFloatSmartPointer* schedulePtr =
//    (LgFrSortingDemandScheduleFloatSmartPointer *)
//    demandSchedules_.findValue(&key);
  if (!schedulePtr.null()  &&  toPopulate )  {
d481 1
a481 1
    if (schedulePtr == 0) {
d498 2
a499 2
   const bool deepCopy,
   const bool toPopulate
d517 1
a517 1
      return 0;
d551 1
a551 1
std::string
d563 1
a563 1
LgFrScheduleDescriptorVector
d569 1
a569 1
LgFrScheduleDescriptorVector
d590 1
a590 1
NameDemandDictionary &
d600 1
a600 1
NamePartDictionary &
d623 4
a626 1
    demandSchedules_.insert( NameDemandPair( desc.name(), schedulePtr ) );
d633 4
a636 1
    partSchedules_.insert( NamePartPair( desc.name(), schedulePtr ) );
d640 1
a640 1
LgFrScheduleDescriptorVector
d643 1
a643 1
LgFrScheduleDescriptorVector
d647 1
a647 1
LgFrScheduleDescriptorVector
d650 6
a655 6
  LgFrScheduleDescriptorVector retVal;
  retVal.push_back(LGFRDemandVolume);
  retVal.push_back(LGFRShipmentVolume);
  retVal.push_back(LGFRBacklogVolume);
  retVal.push_back(LGFRPriority);
  retVal.push_back(LGFRObj1ShipReward);
d659 1
a659 1
LgFrScheduleDescriptorVector
d662 18
a679 18
  LgFrScheduleDescriptorVector retVal;
  retVal.push_back(LGFRCriticalPartSupplyVolume);
  retVal.push_back(LGFRCriticalPartRankingList);
  retVal.push_back(LGFRExcessVolume);
  retVal.push_back(LGFRFocussedShortageSchedule);
  retVal.push_back(LGFRFSSProductionVolume);
  retVal.push_back(LGFRProductionVolume);
  retVal.push_back(LGFRRequirementVolume );
  retVal.push_back(LGFRSupplyVolume);
  retVal.push_back(LGFRCycleTime);
  retVal.push_back(LGFRStockVolume);
  retVal.push_back(LGFRScrapVolume);
  retVal.push_back(LGFRMaterialSupplyVolume);
  retVal.push_back(LGFRCapacitySupplyVolume);
  retVal.push_back(LGFRTotalPartDemandVol);
  retVal.push_back(LGFRSupplyVolumeTimesUnitCost);
  retVal.push_back(LGFRStockVolumeTimesUnitCost);
  retVal.push_back(LGFRUsageVolume);
d701 2
a702 2
  //partSchedules().clearAndDestroy();
  //demandSchedules().clearAndDestroy();
d737 5
d747 2
d782 1
a782 1
      f.newDemandSchedule(LGFRPriority, false);
d784 1
a784 1
      f.newDemandSchedule(LGFRPriority, false);
d788 1
a788 1
      f.newPartSchedule(LGFRRequirementVolume, false);
d790 1
a790 1
      f.newPartSchedule(LGFRRequirementVolume, false);
d796 1
a796 1
      f.newPartSchedule(LGFRSupplyVolume, false, true);
d798 1
a798 1
      f.newPartSchedule(LGFRSupplyVolumeTimesUnitCost, false, true);
d800 1
a800 1
  assert (s.size() != 0);
d806 1
a806 1
      f.newPartSchedule(LGFRUsageVolume, true, true);
d813 1
a813 1
      f.newPartSchedule(LGFRStockVolume, false, true);
d815 1
a815 1
      f.newPartSchedule(LGFRStockVolumeTimesUnitCost, false, true);
d817 1
a817 1
  assert (ss.size() != 0);
d822 1
a822 1
      f.newPartSchedule(LGFRRequirementVolume, false, true);
d824 1
a824 1
      f.newPartSchedule(LGFRRequirementVolumeTimesUnitCost, false, true);
d827 1
a827 1
  assert (rs.size() != 0);
d848 1
a848 1
    LgFrScheduleDescriptorVector sd =
d851 1
a851 2
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i = 0; i<sd.size(); i++ ) {
d858 1
a858 1
    LgFrScheduleDescriptorVector sd =
d861 1
a861 2
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i = 0; i<sd.size(); i++ ) {
@


1.1.1.1.14.2
log
@Removed STD_CPP_LIB #ifdefs
and went to std for cout
@
text
@d379 1
a379 1
      std::cerr << "\nWrong part schedule description string \""
d473 1
a473 1
      std::cerr << "\nWrong demand schedule description string \""
d664 1
a664 1
  std::cerr << "Warning: Internal inconsistency.  Program tried to make a \n"
d667 1
a667 1
       << "appear." << std::endl;
@



head	1.5;
access;
symbols
	sce_5_01_20080919:1.5
	latest_sce_4_20_20060523:1.5.0.6
	sce_4_20_20060523:1.5
	latest_sce4_20_OSL:1.5.0.4
	sce_4_20_OSL:1.5
	sce_4_05_20040511:1.5
	sce_4_00_20040201:1.5
	nextGenBranch:1.5.0.2
	nextGenRoot:1.5
	sce_3_30_20030627:1.5
	EndRw-branch:1.3.0.2
	Root-of-EndRw:1.3
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.01.15.23.05.47;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.15.19.36.34;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.00.35.03;	author fasano;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.12.02.17.42.23;	author austel;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.29.40;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.40;	author wit;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.08.17.42.28;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Modified to build on windows laptop that was causing compiler to run out of stack space
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#endif

// RW2STL -- inserted:
#include <string>
// End of RW2STL -- inserted includes.
#include <math.h>
#include <iostream>


#include <scenario/src/dif.h>
#include <scenario/src/difImpl.h>
#include <scenario/src/difTest.h>
#include <scenario/src/calendar.h>
#include <scenario/src/difEssSc.h>


//-------------------------------------------------------------------
//  
// Global functions to obtain the defined parts and capacities.
//
//-------------------------------------------------------------------

// difTestGetRawPart global function (registering in the attribute table).
// Get raw parts and insert them into set_of_part
// Return: a LgFrPartVector object (vector of raw parts).
void *
difTestGetRawParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  LgFrPart part = difEssenPtr->createAndInsertPart("Raw");
  retVal.push_back(part);
  status = 0;
  return &retVal;
}

// difTestGetProductPart global function (registering in the attribute table).
// Get product parts from WIT and insert it into set_of_part
// Return: a LgFrPartVector object (vector of producible parts)
void*
difTestGetProductParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  LgFrPart part = difEssenPtr->createAndInsertPart("Product");
  retVal.push_back(part);
  status = 0;
  return &retVal;
}

// difTestGetCapacityPart global function (registering in the attribute table).
// Get capacity parts from WIT and insert it into set_of_part
// Return: a LgFrPartVector object (vector of capacities).
void*
difTestGetCapacityParts(
    const LgFrDataInterfaceImplementation * dImp,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  LgFrPart part = difEssenPtr->createAndInsertPart("Capacity");
  retVal.push_back(part);  
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain raw part attributes
//
//-------------------------------------------------------------------

// difTestGetRawUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difTestGetRawUnitCost(
  const LgFrDataInterfaceImplementation * dImp,
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 123. );
  }

  status = 0;
  return &retVal;
}
  
// difTestGetPartProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difTestGetRawProcCost(
    const LgFrDataInterfaceImplementation * difImp,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 103. );
  }

  status = 0;
  return &retVal;
}

// difTestGetPartConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difTestGetRawConstrained(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)               
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
    retVal.push_back( false );

  status = 0;
  return &retVal; 
} 

// difTestGetPartProcLeadTime global function (registered in the attribute table).
// It returns a LgFrTimeVecFloatVector object.
void *
difTestGetRawProcLeadTime(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.00 ) );
  }

  status = 0;
  return &retVal;
}      


// difTestGetPartObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetRawObj1ScrapCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,2.34f ) );
  }

  status = 0;
  return &retVal;
}

// difTestGetPartObj1StockCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetRawObj1StockCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,3.f ) );
  }

  status = 0;
  return &retVal;
}

// difTestGetPartSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetRawSupplyVol(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
  {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,5.f ) );
  }

  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Global functions to obtain producible part attributes
//
//-------------------------------------------------------------------


// difTestGetProductProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difTestGetProductProcCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 3.01f );
  }

  status = 0;
  return &retVal;
}


// difTestGetProductUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difTestGetProductUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 3.21f );
  }

  status = 0;
  return &retVal;
}


// difTestGetProductConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difTestGetProductConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );    
  }

  status = 0;
  return &retVal;
}


// difTestGetProductYield global function (registered in the attribute table).
// Return: a LgFrIntVector object
void *
difTestGetProductYield(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 96 );
  }

  status = 0;
  return &retVal;
}


// difTestGetProductCycleTime global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetProductCycleTime(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.2f ) );
  }

  status = 0;
  return &retVal;
}


// difTestGetProductProcLeadTime global function (registered in the attribute table).
// It returns a LgFrTimeVecFloatVector object.
void *
difTestGetProductProcLeadTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , -1.0f ) );
  }

  status = 0;
  return &retVal;
}


// difTestGetProductObj1ProdCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetProductObj1ProdCost(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 3.4f ) );
  }

  status = 0;
  return &retVal;
}

// difTestGetProductObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetProductObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 5.6f ) );
  }

  status = 0;
  return &retVal;
}

// difTestGetProductObj1StockCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetProductObj1StockCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 7.8f ) );    
  }

  status = 0;
  return &retVal;
}

// difTestGetProductSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetProductSupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 9.0f ) );    
  }

  status = 0;
  return &retVal;
}

// difTestGetProductMinLotSize global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void*
difTestGetProductMinLotSize(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0f ) );    
  }

  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//  
//   Methods to obtain capacity attributes
//
//-------------------------------------------------------------------

// difTestGetCapacityUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difTestGetCapacityUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 2.46f );
  }

  status = 0;
  return &retVal;
}


//difTestGetCapacityConstrained global function (registered in the attribute table).
// It returns a LgFrIntVector object
void *
difTestGetCapacityConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );
  }

  status = 0;
  return &retVal;
}


//difTestGetCapacityObj1ScrapCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetCapacityObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */, 
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 78.f ) );
  }

  status = 0;
  return &retVal;
}


//difTestGetCapacitySupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetCapacitySupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 90.f ) );    
  }

  status = 0;
  return &retVal;
}


//--------------------------------------------------------------------
//  
//   Global functions to obtain demands
//
//-------------------------------------------------------------------

// difTestGetCommittedDemands global function (registering in the attribute table).
// Get committed demands and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of committed demands).
void *
difTestGetCommittedDemands(
  const LgFrDataInterfaceImplementation * /* dImp,not used */,
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  std::string dn = "Committed";
  std::string pn = "Product";

  LgFrDemand demand = 
      difEssenPtr->createAndInsertDemand(dn,pn);
  retVal.push_back(demand);

  status = 0;
  return &retVal;
}


// difTestGetNewOpportunityDemands global function (registering in the attribute table).
// Get new opportunity demands and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of new opportunity demands).
void *
difTestGetNewOpportunityDemands(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  std::string dn = "NewOpportunity";
  std::string pn = "Product";

  LgFrDemand demand = 
      difEssenPtr->createAndInsertDemand(dn,pn);
  retVal.push_back(demand);

  status = 0;
  return &retVal;
}


// difTestGetFirmForecastDemands global function (registering in the attribute table).
// Get firm forcast demands and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of firm forcast demands).
void *
difTestGetFirmForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  std::string dn = "FirmForecast";
  std::string pn = "Product";

  LgFrDemand demand = 
      difEssenPtr->createAndInsertDemand(dn,pn);
  retVal.push_back(demand);

  status = 0;
  return &retVal;
}


// difTestGetRiskForecastDemands global function (registering in the attribute table).
// Get risk forcast demands and insert them into set_of_demand
// Return: a LgFrDemandVector object (vector of risk forcast demands).
void *
difTestGetRiskForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr) 
{
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);

  std::string dn = "RiskForecast";
  std::string pn = "Product";

  LgFrDemand demand = 
      difEssenPtr->createAndInsertDemand(dn,pn);
  retVal.push_back(demand);

  status = 0;
  return &retVal;
}


//--------------------------------------------------------------------
//  
//   Global functions to obtain demand attributes
//
//-------------------------------------------------------------------

// difTestGetDemandGrossRev global function (registering in the attribute table).
// Compute total demand gross revenue
// Return: a LgFrFloatVector object (vector of demand gross revenues).
void *
difTestGetDemandGrossRev(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
  
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    if      ( dv[i]->name() == "Committed"     )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "NewOpportunity" )  retVal.push_back( 222.f );
    else if ( dv[i]->name() == "FirmForecast"   )  retVal.push_back( 333.f );
    else if ( dv[i]->name() == "RiskForecast"   )  retVal.push_back( 444.f );
    else assert( 0 && "illegal demand name for Gross Revenue" );
  }
  status = 0;
  return &retVal;
}


// difTestGetDemandVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetDemandVol(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 111.f ) );
  }
  status = 0;
  return &retVal;
}


// difTestGetDemanObj1CumShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetDemandObj1CumShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 222.f ) );
  }
  status = 0;
  return &retVal;
}


// difTestGetDemanObj1ShipReward global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difTestGetDemandObj1ShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    

  const LgFrCalendar& calendar = difEssenPtr->calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 333.f ) );
  }      
  status = 0;
  return &retVal;
}


//--------------------------------------------------------------------
//  
//   Global function to define BOM
//
//-------------------------------------------------------------------

void*
difTestDefineBom(
    const LgFrDataInterfaceImplementation * difImp, 
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
    LgFrError &, // status, 
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
   WitRun* eater = 
     ((LgFrDataInterfaceEssentialsFromScenario*)difEssenPtr)
     ->mutableWitRun();

   witAddBomEntry(eater,"Product","Raw");
   witAddBomEntry(eater,"Product","Capacity");
   return 0;
}

//---------------------------------------------------------------------------------------
// To create a LgFrDataInterfaceImplementation object for difTest
//---------------------------------------------------------------------------------------
LgFrDataInterfaceImplementation * 
createDifTestImp()
{
  return new LgFrDataInterfaceImplementation;
}


// -----------------------------------------------------------------------
//  register functions
// -----------------------------------------------------------------------

void
registerDifTestImpFunctions(
    LgFrDataInterfaceImplementation * dImp) 
{

  
    // Register all raw material attribute functions
    dImp->registerFunction("rawUnitCost", material, part,
			   vectorFloat, difTestGetRawUnitCost);
    dImp->registerFunction("rawProcCost", material, part,
			   vectorFloat, difTestGetRawProcCost);
    dImp->registerFunction("rawConstrained", material, part,
			   vectorInt, difTestGetRawConstrained);
    dImp->registerFunction("rawProcLeadTime", material, part,
			   timeVecFloat, difTestGetRawProcLeadTime);
    dImp->registerFunction("rawObj1ScrapCost", material, part,
			   timeVecFloat, difTestGetRawObj1ScrapCost);
    dImp->registerFunction("rawObj1StockCost", material, part,
			   timeVecFloat, difTestGetRawObj1StockCost);
    dImp->registerFunction("rawSupplyVol", material, part,
			   timeVecFloat, difTestGetRawSupplyVol);

    // Register all product attribute functions
    dImp->registerFunction("productUnitCost", material, part,
			   vectorFloat, difTestGetProductUnitCost);
    dImp->registerFunction("productProcCost", material, part,
			   vectorFloat, difTestGetProductProcCost);
    dImp->registerFunction("productConstrained", material, part,
			   vectorInt, difTestGetProductConstrained);
    dImp->registerFunction("productProcLeadTime", material, part,
       		   timeVecFloat, difTestGetProductProcLeadTime);
    dImp->registerFunction("productYield", material, part,
			   vectorInt, difTestGetProductYield);
    dImp->registerFunction("productCycleTime", material, part,
			   timeVecFloat, difTestGetProductCycleTime);
    dImp->registerFunction("obj1ProdCost", material, part,
			   timeVecFloat, difTestGetProductObj1ProdCost);
    dImp->registerFunction("productObj1ScrapCost", material, part,
			   timeVecFloat, difTestGetProductObj1ScrapCost);
    dImp->registerFunction("productObj1StockCost", material, part,
			   timeVecFloat, difTestGetProductObj1StockCost);
    dImp->registerFunction("productSupplyVol", material, part,
			   timeVecFloat, difTestGetProductSupplyVol);
    dImp->registerFunction("productMinLotSize", material, part,
			   timeVecFloat, difTestGetProductMinLotSize);

    // Register all capacity attribute functions
    dImp->registerFunction("capacityUnitCost", material, part,
			   vectorFloat, difTestGetCapacityUnitCost);
    dImp->registerFunction("capacityConstrained", material, part,
			   vectorInt, difTestGetCapacityConstrained);
    dImp->registerFunction("capacityObj1ScrapCost", material, part,
			   timeVecFloat, difTestGetCapacityObj1ScrapCost);
    dImp->registerFunction("capacitySupplyVol", material, part,
			   timeVecFloat, difTestGetCapacitySupplyVol);
   // Register all functions to obtain demands
    dImp->registerFunction("committedDemands", demandType, demand,
		   orderedVecDemand, difTestGetCommittedDemands);
    dImp->registerFunction("newOpportunityDemands", demandType, demand,
		   orderedVecDemand, difTestGetNewOpportunityDemands);
    dImp->registerFunction("firmForecastDemands", demandType, demand,
			   orderedVecDemand, difTestGetFirmForecastDemands);
    dImp->registerFunction("riskForecastDemands", demandType, demand,
			   orderedVecDemand, difTestGetRiskForecastDemands);

    // Register all demand attribute functions
    dImp->registerFunction("demandGrossRev", demandType, demand,
			   vectorFloat, difTestGetDemandGrossRev);
    dImp->registerFunction("demandVol", demandType, demand,
			   timeVecFloat, difTestGetDemandVol);
    dImp->registerFunction("demandObj1CumShipReward", demandType, demand,
			   timeVecFloat, difTestGetDemandObj1CumShipReward);
    dImp->registerFunction("demandObj1ShipReward", demandType, demand,
			   timeVecFloat, difTestGetDemandObj1ShipReward);
    // jmt 6/27/95 need to have partTable and demandTable (similar to attrTable)
    // Register all functions to obtain parts
    dImp->registerFunction("rawParts", material, part,
			   orderedVecPart, difTestGetRawParts);
    dImp->registerFunction("productParts", material, part,
			   orderedVecPart, difTestGetProductParts);

    dImp->registerFunction("capacityParts", material, part,
			   orderedVecPart, difTestGetCapacityParts);

    // Register define bom globle function
    dImp->registerFunction("defineBom", material, part,
			   timeVecFloat, difTestDefineBom);

}


#ifdef NDEBUG
#undef NDEBUG
#endif


// Tests this class.  Only returns if all tests passed
// Expects data in testScenario1 to have come from
// /u/implode/wit/data/examples/diner12/wit.data, and expects
// testScenario2 to have been made by copying testScenario1
// testSc.
// Right now, the only scenario that works correctly with a 
// LgFrTestDataInterface is LgFrScenarioforCMRP.  Although the above 
// comment says that data should have come from a file, it is probably
// misleading (WCD, 9/15/94).  The data from the file (which has already
// been put into WIT) is probably ignored.  This should be changed
// to take LgFrScenarioforCMRP's for the 1st and 6th arguments.
//
// TRE - 9/19/94:  The scenario being passed in here has already been
// "fedInto", and therefore has already used the dif being tested.  What
// makes this more confusing is that the dif can be used differently 
// depending on which scenario uses it (CMRP or ATP).  Hence I'm
// moving some of the testing done here into the ipCMRP and ipATP context
// tests.
//     Specifically, contextTest will not add parts to WIT, nor will it
// test its defineBOM() method with witGetPartNBOMEntries().  It will also
// not worry about how many parts (demands) are in setOfParts() (setOfDemands()).
// 

void
difTestContextTest
  (LgFrScenario        		& testScenario1,
   LgFrLastProblemSolved       	& /* lps */,      // testScenario1's
   LgFrDataInterface	       	& ts1dif,	// testScenario1's
   LgFrScenario 	       	& testScenario1dup,
   LgFrDataInterface	       	& ts1dupDif)	// testScenario1dup's
{
  const float fltEps = .0001f;
  LgFrCalendar& calendar = testScenario1.calendar();
  int nperiods = calendar.nPeriods();  // # periods in scenario calendar

  LgFrDataInterfaceImplementation* ts1difImp
      = ts1dif.dataInterfaceImplementation();
  LgFrDataInterfaceImplementation* ts1dupDifImp
      = ts1dupDif.dataInterfaceImplementation();

  // Test title method
  assert( ts1difImp->title() == "Test problem for LgFrDataInterfaceImplementation" );
  assert( ts1dupDifImp->title()=="Test problem for LgFrDataInterfaceImplementation" );
  assert( ts1dif.title() == "Test problem for LgFrDataInterfaceImplementation");
  assert( ts1dupDif.title() == "Test problem for LgFrDataInterfaceImplementation");

  // Register all functions
  registerDifTestImpFunctions(ts1difImp); 
  registerDifTestImpFunctions(ts1dupDifImp);

  // Test Get Part Methods
  LgFrDataInterfaceEssentialsFromScenario difEssen(&testScenario1);
  LgFrPartVector pv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
	pv, itemSubTypeStr, "rawParts", &difEssen);
  LgFrPartVector raw = *rawPartsPtr;
  assert( raw.size() == 1 );
  assert( raw[0].name() == "Raw" );

  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
	pv, itemSubTypeStr, "productParts", &difEssen);
  LgFrPartVector product = *productPartsPtr;
  assert( product.size() == 1 );
  assert( product[0].name() == "Product" );

  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
	pv, itemSubTypeStr, "capacityParts", &difEssen);
  LgFrPartVector capacity = *capacityPartsPtr;
  assert( capacity.size() == 1 );
  assert( capacity[0].name() == "Capacity" );

  // Test get raw material attributes functions
  {
  LgFrFloatVector* unitCostPtr
    = (LgFrFloatVector*) ts1dif.partAttribute(
	raw, itemSubTypeStr, "rawUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
  assert( fabs(unitCost[0] - 123.f) < fltEps );


  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
	  raw, itemSubTypeStr, "rawConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
  assert( !constrained[0] );

  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  raw, itemSubTypeStr, "rawObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
  assert( 
     obj1ScrapCost[0] 
       == LgFrTimeVecFloat( nperiods, 2.34f ) );

  
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  raw, itemSubTypeStr, "rawObj1StockCost", &difEssen);
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 1 );
  assert( 
     obj1StockCost[0] 
       == LgFrTimeVecFloat( nperiods, 3.f ) );


  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  raw, itemSubTypeStr, "rawSupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
  assert( supplyVol[0] 
	    == LgFrTimeVecFloat( nperiods, 5.f ) );

  delete unitCostPtr;
  delete constrainedPtr;
  delete obj1ScrapCostPtr;
  delete obj1StockCostPtr;
  delete supplyVolPtr;
}

  delete rawPartsPtr;


  // Test get product attributes global functions
  {
  LgFrTimeVecFloatVector* cycleTimePtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productCycleTime", &difEssen);
  LgFrTimeVecFloatVector cycleTime = *cycleTimePtr;
  assert( cycleTime.size() == 1 );
  assert( fabs(cycleTime[0][0] - 1.2f) < fltEps );

  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
  assert( fabs(unitCost[0] - 3.21f) < fltEps );


  LgFrFloatVector* procCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productProcCost", &difEssen);
  LgFrFloatVector procCost = *procCostPtr;
  assert( procCost.size() == 1 );
  assert( fabs(procCost[0] - 3.01f) < fltEps );

  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
  assert( constrained[0] );

  LgFrIntVector* yieldPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productYield", &difEssen);
  LgFrIntVector yield = *yieldPtr;
  assert( yield.size() == 1 );
  assert( yield[0]==96 );

  LgFrTimeVecFloatVector* obj1ProdCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "obj1ProdCost", &difEssen);
  LgFrTimeVecFloatVector obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.size() == 1 );
  assert( 
     obj1ProdCost[0] 
       == LgFrTimeVecFloat( nperiods, 3.4f ) );

  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
  assert( 
     obj1ScrapCost[0]
       == LgFrTimeVecFloat( nperiods, 5.6f ) );

  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productObj1StockCost", &difEssen);
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 1 );
  assert( 
     obj1StockCost[0] 
       == LgFrTimeVecFloat( nperiods, 7.8f ) );

  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productSupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
  assert( supplyVol[0] 
	    == LgFrTimeVecFloat( nperiods, 9.0f ) );


  LgFrTimeVecFloatVector* minLotSizePtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  product, itemSubTypeStr, "productMinLotSize", &difEssen);
  LgFrTimeVecFloatVector minLotSize = *minLotSizePtr;
  assert( minLotSize.size() == 1 );
  assert( minLotSize[0]
	    == LgFrTimeVecFloat( nperiods, 1.0f ) );

  delete cycleTimePtr;
  delete procCostPtr;
  delete unitCostPtr;
  delete constrainedPtr;
  delete yieldPtr; 
  delete obj1ProdCostPtr;
  delete obj1ScrapCostPtr;
  delete obj1StockCostPtr;
  delete supplyVolPtr;
  delete minLotSizePtr;
  }

  delete productPartsPtr;


  // Test get capacity attributes global functions
  {
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
	  capacity, itemSubTypeStr, "capacityUnitCost", &difEssen);
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
  assert( fabs(unitCost[0] - 2.46f) < fltEps );

  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
	  capacity, itemSubTypeStr, "capacityConstrained", &difEssen);
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
  assert( constrained[0] );

  
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  capacity, itemSubTypeStr, "capacityObj1ScrapCost", &difEssen);
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
  assert( 
     obj1ScrapCost[0] 
       == LgFrTimeVecFloat( nperiods, 78.f ) );

  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
	  capacity, itemSubTypeStr, "capacitySupplyVol", &difEssen);
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
  assert( supplyVol[0] 
	    == LgFrTimeVecFloat( nperiods, 90.f ) );

  delete unitCostPtr;
  delete constrainedPtr;
  delete obj1ScrapCostPtr;
  delete supplyVolPtr;
  }

  delete capacityPartsPtr;


  // Test for get demands global functions
  LgFrDemandVector dv;

  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
	dv, "committedDemands", &difEssen );
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 1 );
  assert( committed[0].name() == "Committed" );


  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
	dv, "newOpportunityDemands", &difEssen );
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 1 );
  assert( newOpportunity[0].name() == "NewOpportunity" );


  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
	dv, "firmForecastDemands", &difEssen );
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 1 );
  assert( firmForecast[0].name() == "FirmForecast" );

  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
	dv, "riskForecastDemands", &difEssen );
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 1 );
  assert( riskForecast[0].name() == "RiskForecast" );


  // Test get demand Attributes global functions
  {
  // Create a temporary set of demands
  LgFrSetOfDemands tempSod;
  tempSod.push_back( committed[0] );
  tempSod.push_back( newOpportunity[0] );
  tempSod.push_back( firmForecast[0] );
  tempSod.push_back( riskForecast[0] );


  LgFrFloatVector* grossRevPtr
   = (LgFrFloatVector*) ts1dif.demandAttribute(
       tempSod,"demandGrossRev", &difEssen);
  LgFrFloatVector grossRev = *grossRevPtr;
  assert( grossRev.size() == 4 );
  assert( fabs(grossRev[0] - 111.f ) < fltEps );
  assert( fabs(grossRev[1] - 222.f ) < fltEps );
  assert( fabs(grossRev[2] - 333.f ) < fltEps );
  assert( fabs(grossRev[3] - 444.f ) < fltEps );
  delete grossRevPtr;

  LgFrTimeVecFloatVector* demandVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
	  committed, "demandVol", &difEssen);
  LgFrTimeVecFloatVector demandVol = *demandVolPtr;
  assert( demandVol.size() == 1 );
  assert( demandVol[0] 
	    == LgFrTimeVecFloat( nperiods, 111.f ) );
  delete demandVolPtr;

  LgFrTimeVecFloatVector* obj1CumShipRewardPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
	  newOpportunity, "demandObj1CumShipReward", &difEssen);
  LgFrTimeVecFloatVector obj1CumShipReward = *obj1CumShipRewardPtr;
  assert(  obj1CumShipReward.size() == 1 );
  assert(  
    obj1CumShipReward[0] 
      == LgFrTimeVecFloat( nperiods, 222.f ) );
  delete obj1CumShipRewardPtr;

  LgFrTimeVecFloatVector* obj1ShipRewardPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
	  newOpportunity, "demandObj1ShipReward", &difEssen);
  LgFrTimeVecFloatVector obj1ShipReward = *obj1ShipRewardPtr;
  assert(  obj1ShipReward.size() == 1 );
  assert(  
    obj1ShipReward[0] 
      == LgFrTimeVecFloat( nperiods, 333.f ) );
  delete obj1ShipRewardPtr;

}

  delete committedDemandPtr;
  delete newOpportunityDemandPtr;
  delete firmForecastDemandPtr;
  delete riskForecastDemandPtr;
  
  // Test define BOM method
//  witAddPart( lps.witRun(), "Raw",     WitRAW );
//  witAddPart( lps.witRun(), "Product", WitPRODUCT );
//  witAddPart( lps.witRun(), "Capacity",WitCAPACITY );
//  ts1dif.defineBom( lps.witRun() );
//  int nBomEntries;
//  witGetPartNBomEntries( lps.witRun(), "Product", &nBomEntries );
//  assert ( nBomEntries == 2 );
}
@


1.4
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d1 4
@


1.3
log
@Modified to get sce to link on windows.
Code was changed to conditionally include implement statements
@
text
@d1 3
d5 1
a5 1
#include <iostream.h>
a6 2
#include <rw/rstream.h>
#include <rw/cstring.h>
a13 4
#ifndef WIN32
// added for vacpp - vra
implement (RWGVector, int)
#endif
d23 1
a23 1
// Return: a LgFrOrderedVectorPart object (vector of raw parts).
d27 1
a27 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d31 1
a31 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d33 1
a33 1
  retVal.insert(part);
d40 1
a40 1
// Return: a LgFrOrderedVectorPart object (vector of producible parts)
d44 1
a44 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d48 1
a48 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d50 1
a50 1
  retVal.insert(part);
d57 1
a57 1
// Return: a LgFrOrderedVectorPart object (vector of capacities).
d61 1
a61 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d65 1
a65 1
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
d67 1
a67 1
  retVal.insert(part);  
d79 1
a79 1
// it returns a LgFrVectorFloat object.
d83 1
a83 1
  const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d87 7
a93 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  123.;
d101 1
a101 1
// It returns a LgFrVectorFloat object.
d105 1
a105 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d109 7
a115 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  103.;
d123 1
a123 1
// It returns a LgFrVectorInt object
d127 1
a127 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d131 7
a137 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) 
    retVal[i] =  FALSE;
d144 1
a144 1
// It returns a LgFrVectorTimeVecFloat object.
d148 1
a148 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d152 4
a155 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d160 3
a162 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 1.00 );
d171 1
a171 1
// Return: a LgFrVectorTimeVecFloat object.
d175 1
a175 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d179 4
a182 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d187 3
a189 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods ,2.34f );
d197 1
a197 1
// Return: a LgFrVectorTimeVecFloat object.
d201 1
a201 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d205 4
a208 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d213 3
a215 2
  for ( size_t i=0; i<pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods ,3.f );
d223 1
a223 1
// Return: a LgFrVectorTimeVecFloat object.
d227 1
a227 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d231 4
a234 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d239 4
a242 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods ,5.f );
d257 1
a257 1
// It returns a LgFrVectorFloat object.
d261 1
a261 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d266 7
a272 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] = 3.01f;
d281 1
a281 1
// it returns a LgFrVectorFloat object.
d285 1
a285 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d290 7
a296 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] = 3.21f;
d305 1
a305 1
// It returns a LgFrVectorInt object
d309 1
a309 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d314 7
a320 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  TRUE;    
d329 1
a329 1
// Return: a LgFrVectorInt object
d333 1
a333 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d338 7
a344 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  96;
d353 1
a353 1
// Return: a LgFrVectorTimeVecFloat object.
d357 1
a357 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d361 4
a364 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d369 3
a371 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 1.2f );
d380 1
a380 1
// It returns a LgFrVectorTimeVecFloat object.
d384 1
a384 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d389 4
a392 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d397 3
a399 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , -1.0f );
d408 1
a408 1
// Return: a LgFrVectorTimeVecFloat object.
d412 1
a412 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d416 4
a419 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d424 3
a426 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 3.4f );
d434 1
a434 1
// Return: a LgFrVectorTimeVecFloat object.
d438 1
a438 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d443 4
a446 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d451 3
a453 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 5.6f );
d461 1
a461 1
// Return: a LgFrVectorTimeVecFloat object.
d465 1
a465 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d470 4
a473 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d478 3
a480 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 7.8f );    
d488 1
a488 1
// Return: a LgFrVectorTimeVecFloat object.
d492 1
a492 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d497 4
a500 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal 
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d505 3
a507 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 9.0f );    
d515 1
a515 1
// Return: a LgFrVectorTimeVecFloat object.
d519 1
a519 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d524 4
a527 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d532 3
a534 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 1.0f );    
d548 1
a548 1
// it returns a LgFrVectorFloat object.
d552 1
a552 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d557 7
a563 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  2.46f;
d572 1
a572 1
// It returns a LgFrVectorInt object
d576 1
a576 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d581 7
a587 5
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));

  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  TRUE;
d596 1
a596 1
// Return: a LgFrVectorTimeVecFloat object.
d600 1
a600 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d605 4
a608 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d613 3
a615 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 78.f );
d624 1
a624 1
// Return: a LgFrVectorTimeVecFloat object.
d628 1
a628 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d633 4
a636 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal
      = *(new LgFrVectorTimeVecFloat ( pv.entries() ));
d641 3
a643 2
  for ( size_t i = 0; i < pv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods , 90.f );    
d659 1
a659 1
// Return: a LgFrOrderedVectorDemand object (vector of committed demands).
d663 1
a663 1
  const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d667 2
a668 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d670 2
a671 2
  RWCString dn = "Committed";
  RWCString pn = "Product";
d675 1
a675 1
  retVal.insert(demand);
d684 1
a684 1
// Return: a LgFrOrderedVectorDemand object (vector of new opportunity demands).
d688 1
a688 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d692 2
a693 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d695 2
a696 2
  RWCString dn = "NewOpportunity";
  RWCString pn = "Product";
d700 1
a700 1
  retVal.insert(demand);
d709 1
a709 1
// Return: a LgFrOrderedVectorDemand object (vector of firm forcast demands).
d713 1
a713 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d717 2
a718 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d720 2
a721 2
  RWCString dn = "FirmForecast";
  RWCString pn = "Product";
d725 1
a725 1
  retVal.insert(demand);
d734 1
a734 1
// Return: a LgFrOrderedVectorDemand object (vector of risk forcast demands).
d738 1
a738 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d742 2
a743 2
  LgFrOrderedVectorDemand& retVal = 
      *(new LgFrOrderedVectorDemand);
d745 2
a746 2
  RWCString dn = "RiskForecast";
  RWCString pn = "Product";
d750 1
a750 1
  retVal.insert(demand);
d765 1
a765 1
// Return: a LgFrVectorFloat object (vector of demand gross revenues).
d769 1
a769 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d774 3
a776 2
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat( dv.entries() ));    
d778 6
a783 5
  for ( size_t i = 0; i < dv.entries(); i++ ) {
    if      ( dv[i]->name() == "Committed"     )  retVal[i] = 111.f;
    else if ( dv[i]->name() == "NewOpportunity" )  retVal[i] = 222.f;
    else if ( dv[i]->name() == "FirmForecast"   )  retVal[i] = 333.f;
    else if ( dv[i]->name() == "RiskForecast"   )  retVal[i] = 444.f;
d792 1
a792 1
// Return: a LgFrVectorTimeVecFloat object.
d796 1
a796 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d801 4
a804 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d809 3
a811 2
  for ( size_t i = 0; i < dv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods, 111.f );
d819 1
a819 1
// Return: a LgFrVectorTimeVecFloat object.
d823 1
a823 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d828 4
a831 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d836 3
a838 2
  for ( size_t i = 0; i < dv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods, 222.f );
d846 1
a846 1
// Return: a LgFrVectorTimeVecFloat object.
d850 1
a850 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d855 4
a858 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr; 
  LgFrVectorTimeVecFloat& retVal = 
      *(new LgFrVectorTimeVecFloat( dv.entries() ));    
d863 3
a865 2
  for ( size_t i=0; i<dv.entries(); i++ ) {
    retVal[i] =  LgFrTimeVecFloat( nperiods, 333.f );
d881 1
a881 1
    const LgFrOrderedVectorItemPtr*, // itemPtrOrdVecPtr,
d891 1
a891 1
   return NULL;
a1043 6
  // Test isA method
  assert (ts1dif.isA() == __LGFRDATAINTERFACE);
  assert (ts1dupDif.isA() == __LGFRDATAINTERFACE);
  assert (ts1difImp->isA() == __LGFRDATAINTERFACEIMPLEMENTATION);
  assert (ts1dupDifImp->isA() == __LGFRDATAINTERFACEIMPLEMENTATION);

d1056 4
a1059 4
  LgFrOrderedVectorPart pv;
  RWCString itemSubTypeStr = "material";  
  LgFrOrderedVectorPart* rawPartsPtr
    = (LgFrOrderedVectorPart*) ts1dif.partAttribute(
d1061 2
a1062 2
  LgFrOrderedVectorPart raw = *rawPartsPtr;
  assert( raw.entries() == 1 );
d1065 2
a1066 2
  LgFrOrderedVectorPart* productPartsPtr
    = (LgFrOrderedVectorPart*) ts1dif.partAttribute(
d1068 2
a1069 2
  LgFrOrderedVectorPart product = *productPartsPtr;
  assert( product.entries() == 1 );
d1072 2
a1073 2
  LgFrOrderedVectorPart* capacityPartsPtr
    = (LgFrOrderedVectorPart*) ts1dif.partAttribute(
d1075 2
a1076 2
  LgFrOrderedVectorPart capacity = *capacityPartsPtr;
  assert( capacity.entries() == 1 );
d1081 2
a1082 2
  LgFrVectorFloat* unitCostPtr
    = (LgFrVectorFloat*) ts1dif.partAttribute(
d1084 2
a1085 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 1 );
d1089 2
a1090 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) ts1dif.partAttribute(
d1092 2
a1093 2
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 1 );
d1096 2
a1097 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1099 2
a1100 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 1 );
d1106 2
a1107 2
  LgFrVectorTimeVecFloat* obj1StockCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1109 2
a1110 2
  LgFrVectorTimeVecFloat obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.length() == 1 );
d1116 2
a1117 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1119 2
a1120 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 1 );
d1136 2
a1137 2
  LgFrVectorTimeVecFloat* cycleTimePtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1139 2
a1140 2
  LgFrVectorTimeVecFloat cycleTime = *cycleTimePtr;
  assert( cycleTime.length() == 1 );
d1143 2
a1144 2
  LgFrVectorFloat* unitCostPtr
      = (LgFrVectorFloat*) ts1dif.partAttribute(
d1146 2
a1147 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 1 );
d1151 2
a1152 2
  LgFrVectorFloat* procCostPtr
      = (LgFrVectorFloat*) ts1dif.partAttribute(
d1154 2
a1155 2
  LgFrVectorFloat procCost = *procCostPtr;
  assert( procCost.length() == 1 );
d1158 2
a1159 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) ts1dif.partAttribute(
d1161 2
a1162 2
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 1 );
d1165 2
a1166 2
  LgFrVectorInt* yieldPtr
      = (LgFrVectorInt*) ts1dif.partAttribute(
d1168 2
a1169 2
  LgFrVectorInt yield = *yieldPtr;
  assert( yield.length() == 1 );
d1172 2
a1173 2
  LgFrVectorTimeVecFloat* obj1ProdCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1175 2
a1176 2
  LgFrVectorTimeVecFloat obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.length() == 1 );
d1181 2
a1182 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1184 2
a1185 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 1 );
d1190 2
a1191 2
  LgFrVectorTimeVecFloat* obj1StockCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1193 2
a1194 2
  LgFrVectorTimeVecFloat obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.length() == 1 );
d1199 2
a1200 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1202 2
a1203 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 1 );
d1208 2
a1209 2
  LgFrVectorTimeVecFloat* minLotSizePtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1211 2
a1212 2
  LgFrVectorTimeVecFloat minLotSize = *minLotSizePtr;
  assert( minLotSize.length() == 1 );
d1233 2
a1234 2
  LgFrVectorFloat* unitCostPtr
      = (LgFrVectorFloat*) ts1dif.partAttribute(
d1236 2
a1237 2
  LgFrVectorFloat unitCost = *unitCostPtr;
  assert( unitCost.length() == 1 );
d1240 2
a1241 2
  LgFrVectorInt* constrainedPtr
      = (LgFrVectorInt*) ts1dif.partAttribute(
d1243 2
a1244 2
  LgFrVectorInt constrained = *constrainedPtr;
  assert( constrained.length() == 1 );
d1248 2
a1249 2
  LgFrVectorTimeVecFloat* obj1ScrapCostPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1251 2
a1252 2
  LgFrVectorTimeVecFloat obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.length() == 1 );
d1257 2
a1258 2
  LgFrVectorTimeVecFloat* supplyVolPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.partAttribute(
d1260 2
a1261 2
  LgFrVectorTimeVecFloat supplyVol = *supplyVolPtr;
  assert( supplyVol.length() == 1 );
d1275 1
a1275 1
  LgFrOrderedVectorDemand dv;
d1277 2
a1278 2
  LgFrOrderedVectorDemand* committedDemandPtr
    = (LgFrOrderedVectorDemand*) ts1dif.demandAttribute(
d1280 2
a1281 2
  LgFrOrderedVectorDemand committed = * committedDemandPtr; 
  assert( committed.entries() == 1 );
d1285 2
a1286 2
  LgFrOrderedVectorDemand* newOpportunityDemandPtr
    = (LgFrOrderedVectorDemand*) ts1dif.demandAttribute(
d1288 2
a1289 2
  LgFrOrderedVectorDemand newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.entries() == 1 );
d1293 2
a1294 2
  LgFrOrderedVectorDemand* firmForecastDemandPtr
    = (LgFrOrderedVectorDemand*) ts1dif.demandAttribute(
d1296 2
a1297 2
  LgFrOrderedVectorDemand firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.entries() == 1 );
d1300 2
a1301 2
  LgFrOrderedVectorDemand* riskForecastDemandPtr
    = (LgFrOrderedVectorDemand*) ts1dif.demandAttribute(
d1303 2
a1304 2
  LgFrOrderedVectorDemand riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.entries() == 1 );
d1312 4
a1315 4
  tempSod.insert( committed[0] );
  tempSod.insert( newOpportunity[0] );
  tempSod.insert( firmForecast[0] );
  tempSod.insert( riskForecast[0] );
d1318 2
a1319 2
  LgFrVectorFloat* grossRevPtr
   = (LgFrVectorFloat*) ts1dif.demandAttribute(
d1321 2
a1322 2
  LgFrVectorFloat grossRev = *grossRevPtr;
  assert( grossRev.length() == 4 );
d1329 2
a1330 2
  LgFrVectorTimeVecFloat* demandVolPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.demandAttribute(
d1332 2
a1333 2
  LgFrVectorTimeVecFloat demandVol = *demandVolPtr;
  assert( demandVol.length() == 1 );
d1338 2
a1339 2
  LgFrVectorTimeVecFloat* obj1CumShipRewardPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.demandAttribute(
d1341 2
a1342 2
  LgFrVectorTimeVecFloat obj1CumShipReward = *obj1CumShipRewardPtr;
  assert(  obj1CumShipReward.length() == 1 );
d1348 2
a1349 2
  LgFrVectorTimeVecFloat* obj1ShipRewardPtr
      = (LgFrVectorTimeVecFloat*) ts1dif.demandAttribute(
d1351 2
a1352 2
  LgFrVectorTimeVecFloat obj1ShipReward = *obj1ShipRewardPtr;
  assert(  obj1ShipReward.length() == 1 );
@


1.3.2.1
log
@Roguewave is gone
@
text
@a0 3
// RW2STL -- inserted:
#include <string>
// End of RW2STL -- inserted includes.
d2 1
a2 1
#include <iostream>
d4 2
d13 4
d26 1
a26 1
// Return: a LgFrPartVector object (vector of raw parts).
d30 1
a30 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d34 1
a34 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d36 1
a36 1
  retVal.push_back(part);
d43 1
a43 1
// Return: a LgFrPartVector object (vector of producible parts)
d47 1
a47 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d51 1
a51 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d53 1
a53 1
  retVal.push_back(part);
d60 1
a60 1
// Return: a LgFrPartVector object (vector of capacities).
d64 1
a64 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d68 1
a68 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d70 1
a70 1
  retVal.push_back(part);  
d82 1
a82 1
// it returns a LgFrFloatVector object.
d86 1
a86 1
  const LgFrItemPtrVector* itemPtrOrdVecPtr,
d90 5
a94 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 123. );
d102 1
a102 1
// It returns a LgFrFloatVector object.
d106 1
a106 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d110 5
a114 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 103. );
d122 1
a122 1
// It returns a LgFrIntVector object
d126 1
a126 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d130 5
a134 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
    retVal.push_back( false );
d141 1
a141 1
// It returns a LgFrTimeVecFloatVector object.
d145 1
a145 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d149 3
a151 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d156 2
a157 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.00 ) );
d166 1
a166 1
// Return: a LgFrTimeVecFloatVector object.
d170 1
a170 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d174 3
a176 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d181 2
a182 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,2.34f ) );
d190 1
a190 1
// Return: a LgFrTimeVecFloatVector object.
d194 1
a194 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d198 3
a200 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d205 2
a206 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,3.f ) );
d214 1
a214 1
// Return: a LgFrTimeVecFloatVector object.
d218 1
a218 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d222 3
a224 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d229 2
a230 4
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) 
  {
    retVal.push_back( LgFrTimeVecFloat( nperiods ,5.f ) );
d245 1
a245 1
// It returns a LgFrFloatVector object.
d249 1
a249 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d254 5
a258 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 3.01f );
d267 1
a267 1
// it returns a LgFrFloatVector object.
d271 1
a271 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d276 5
a280 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 3.21f );
d289 1
a289 1
// It returns a LgFrIntVector object
d293 1
a293 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d298 5
a302 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );    
d311 1
a311 1
// Return: a LgFrIntVector object
d315 1
a315 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d320 5
a324 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 96 );
d333 1
a333 1
// Return: a LgFrTimeVecFloatVector object.
d337 1
a337 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d341 3
a343 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d348 2
a349 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.2f ) );
d358 1
a358 1
// It returns a LgFrTimeVecFloatVector object.
d362 1
a362 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d367 3
a369 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d374 2
a375 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , -1.0f ) );
d384 1
a384 1
// Return: a LgFrTimeVecFloatVector object.
d388 1
a388 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d392 3
a394 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d399 2
a400 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 3.4f ) );
d408 1
a408 1
// Return: a LgFrTimeVecFloatVector object.
d412 1
a412 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d417 3
a419 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d424 2
a425 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 5.6f ) );
d433 1
a433 1
// Return: a LgFrTimeVecFloatVector object.
d437 1
a437 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d442 3
a444 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d449 2
a450 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 7.8f ) );    
d458 1
a458 1
// Return: a LgFrTimeVecFloatVector object.
d462 1
a462 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d467 3
a469 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal 
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d474 2
a475 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 9.0f ) );    
d483 1
a483 1
// Return: a LgFrTimeVecFloatVector object.
d487 1
a487 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d492 3
a494 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d499 2
a500 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 1.0f ) );    
d514 1
a514 1
// it returns a LgFrFloatVector object.
d518 1
a518 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d523 5
a527 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( 2.46f );
d536 1
a536 1
// It returns a LgFrIntVector object
d540 1
a540 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d545 5
a549 7
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrIntVector& retVal = *(new LgFrIntVector);
  retVal.reserve ( pv.size() );

  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( true );
d558 1
a558 1
// Return: a LgFrTimeVecFloatVector object.
d562 1
a562 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d567 3
a569 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d574 2
a575 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 78.f ) );
d584 1
a584 1
// Return: a LgFrTimeVecFloatVector object.
d588 1
a588 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d593 3
a595 4
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal
      = *(new LgFrTimeVecFloatVector);
  retVal.reserve ( pv.size() );
d600 2
a601 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < pv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods , 90.f ) );    
d617 1
a617 1
// Return: a LgFrDemandVector object (vector of committed demands).
d621 1
a621 1
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d625 2
a626 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d628 2
a629 2
  std::string dn = "Committed";
  std::string pn = "Product";
d633 1
a633 1
  retVal.push_back(demand);
d642 1
a642 1
// Return: a LgFrDemandVector object (vector of new opportunity demands).
d646 1
a646 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d650 2
a651 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d653 2
a654 2
  std::string dn = "NewOpportunity";
  std::string pn = "Product";
d658 1
a658 1
  retVal.push_back(demand);
d667 1
a667 1
// Return: a LgFrDemandVector object (vector of firm forcast demands).
d671 1
a671 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d675 2
a676 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d678 2
a679 2
  std::string dn = "FirmForecast";
  std::string pn = "Product";
d683 1
a683 1
  retVal.push_back(demand);
d692 1
a692 1
// Return: a LgFrDemandVector object (vector of risk forcast demands).
d696 1
a696 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d700 2
a701 2
  LgFrDemandVector& retVal = 
      *(new LgFrDemandVector);
d703 2
a704 2
  std::string dn = "RiskForecast";
  std::string pn = "Product";
d708 1
a708 1
  retVal.push_back(demand);
d723 1
a723 1
// Return: a LgFrFloatVector object (vector of demand gross revenues).
d727 1
a727 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d732 2
a733 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrFloatVector& retVal = *(new LgFrFloatVector);
  retVal.reserve( dv.size() );    
d735 5
a739 6
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    if      ( dv[i]->name() == "Committed"     )  retVal.push_back( 111.f );
    else if ( dv[i]->name() == "NewOpportunity" )  retVal.push_back( 222.f );
    else if ( dv[i]->name() == "FirmForecast"   )  retVal.push_back( 333.f );
    else if ( dv[i]->name() == "RiskForecast"   )  retVal.push_back( 444.f );
d748 1
a748 1
// Return: a LgFrTimeVecFloatVector object.
d752 1
a752 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d757 3
a759 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d764 2
a765 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 111.f ) );
d773 1
a773 1
// Return: a LgFrTimeVecFloatVector object.
d777 1
a777 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d782 3
a784 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d789 2
a790 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i = 0; i < dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 222.f ) );
d798 1
a798 1
// Return: a LgFrTimeVecFloatVector object.
d802 1
a802 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d807 3
a809 4
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr; 
  LgFrTimeVecFloatVector& retVal = 
      *(new LgFrTimeVecFloatVector);
  retVal.reserve( dv.size() );    
d814 2
a815 3
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<dv.size(); i++ ) {
    retVal.push_back( LgFrTimeVecFloat( nperiods, 333.f ) );
d831 1
a831 1
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
d841 1
a841 1
   return 0;
d994 6
d1012 4
a1015 4
  LgFrPartVector pv;
  std::string itemSubTypeStr = "material";  
  LgFrPartVector* rawPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
d1017 2
a1018 2
  LgFrPartVector raw = *rawPartsPtr;
  assert( raw.size() == 1 );
d1021 2
a1022 2
  LgFrPartVector* productPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
d1024 2
a1025 2
  LgFrPartVector product = *productPartsPtr;
  assert( product.size() == 1 );
d1028 2
a1029 2
  LgFrPartVector* capacityPartsPtr
    = (LgFrPartVector*) ts1dif.partAttribute(
d1031 2
a1032 2
  LgFrPartVector capacity = *capacityPartsPtr;
  assert( capacity.size() == 1 );
d1037 2
a1038 2
  LgFrFloatVector* unitCostPtr
    = (LgFrFloatVector*) ts1dif.partAttribute(
d1040 2
a1041 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
d1045 2
a1046 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
d1048 2
a1049 2
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
d1052 2
a1053 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1055 2
a1056 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
d1062 2
a1063 2
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1065 2
a1066 2
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 1 );
d1072 2
a1073 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1075 2
a1076 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
d1092 2
a1093 2
  LgFrTimeVecFloatVector* cycleTimePtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1095 2
a1096 2
  LgFrTimeVecFloatVector cycleTime = *cycleTimePtr;
  assert( cycleTime.size() == 1 );
d1099 2
a1100 2
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
d1102 2
a1103 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
d1107 2
a1108 2
  LgFrFloatVector* procCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
d1110 2
a1111 2
  LgFrFloatVector procCost = *procCostPtr;
  assert( procCost.size() == 1 );
d1114 2
a1115 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
d1117 2
a1118 2
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
d1121 2
a1122 2
  LgFrIntVector* yieldPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
d1124 2
a1125 2
  LgFrIntVector yield = *yieldPtr;
  assert( yield.size() == 1 );
d1128 2
a1129 2
  LgFrTimeVecFloatVector* obj1ProdCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1131 2
a1132 2
  LgFrTimeVecFloatVector obj1ProdCost = *obj1ProdCostPtr;
  assert( obj1ProdCost.size() == 1 );
d1137 2
a1138 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1140 2
a1141 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
d1146 2
a1147 2
  LgFrTimeVecFloatVector* obj1StockCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1149 2
a1150 2
  LgFrTimeVecFloatVector obj1StockCost = *obj1StockCostPtr;
  assert( obj1StockCost.size() == 1 );
d1155 2
a1156 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1158 2
a1159 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
d1164 2
a1165 2
  LgFrTimeVecFloatVector* minLotSizePtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1167 2
a1168 2
  LgFrTimeVecFloatVector minLotSize = *minLotSizePtr;
  assert( minLotSize.size() == 1 );
d1189 2
a1190 2
  LgFrFloatVector* unitCostPtr
      = (LgFrFloatVector*) ts1dif.partAttribute(
d1192 2
a1193 2
  LgFrFloatVector unitCost = *unitCostPtr;
  assert( unitCost.size() == 1 );
d1196 2
a1197 2
  LgFrIntVector* constrainedPtr
      = (LgFrIntVector*) ts1dif.partAttribute(
d1199 2
a1200 2
  LgFrIntVector constrained = *constrainedPtr;
  assert( constrained.size() == 1 );
d1204 2
a1205 2
  LgFrTimeVecFloatVector* obj1ScrapCostPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1207 2
a1208 2
  LgFrTimeVecFloatVector obj1ScrapCost = *obj1ScrapCostPtr;
  assert( obj1ScrapCost.size() == 1 );
d1213 2
a1214 2
  LgFrTimeVecFloatVector* supplyVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.partAttribute(
d1216 2
a1217 2
  LgFrTimeVecFloatVector supplyVol = *supplyVolPtr;
  assert( supplyVol.size() == 1 );
d1231 1
a1231 1
  LgFrDemandVector dv;
d1233 2
a1234 2
  LgFrDemandVector* committedDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
d1236 2
a1237 2
  LgFrDemandVector committed = * committedDemandPtr; 
  assert( committed.size() == 1 );
d1241 2
a1242 2
  LgFrDemandVector* newOpportunityDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
d1244 2
a1245 2
  LgFrDemandVector newOpportunity = * newOpportunityDemandPtr; 
  assert( newOpportunity.size() == 1 );
d1249 2
a1250 2
  LgFrDemandVector* firmForecastDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
d1252 2
a1253 2
  LgFrDemandVector firmForecast = * firmForecastDemandPtr;
  assert( firmForecast.size() == 1 );
d1256 2
a1257 2
  LgFrDemandVector* riskForecastDemandPtr
    = (LgFrDemandVector*) ts1dif.demandAttribute(
d1259 2
a1260 2
  LgFrDemandVector riskForecast = * riskForecastDemandPtr;
  assert( riskForecast.size() == 1 );
d1268 4
a1271 4
  tempSod.push_back( committed[0] );
  tempSod.push_back( newOpportunity[0] );
  tempSod.push_back( firmForecast[0] );
  tempSod.push_back( riskForecast[0] );
d1274 2
a1275 2
  LgFrFloatVector* grossRevPtr
   = (LgFrFloatVector*) ts1dif.demandAttribute(
d1277 2
a1278 2
  LgFrFloatVector grossRev = *grossRevPtr;
  assert( grossRev.size() == 4 );
d1285 2
a1286 2
  LgFrTimeVecFloatVector* demandVolPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
d1288 2
a1289 2
  LgFrTimeVecFloatVector demandVol = *demandVolPtr;
  assert( demandVol.size() == 1 );
d1294 2
a1295 2
  LgFrTimeVecFloatVector* obj1CumShipRewardPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
d1297 2
a1298 2
  LgFrTimeVecFloatVector obj1CumShipReward = *obj1CumShipRewardPtr;
  assert(  obj1CumShipReward.size() == 1 );
d1304 2
a1305 2
  LgFrTimeVecFloatVector* obj1ShipRewardPtr
      = (LgFrTimeVecFloatVector*) ts1dif.demandAttribute(
d1307 2
a1308 2
  LgFrTimeVecFloatVector obj1ShipReward = *obj1ShipRewardPtr;
  assert(  obj1ShipReward.size() == 1 );
@


1.2
log
@Added implement (RWGVector, XXX) to satisfy vacpp linker.
@
text
@d13 1
a13 1

d16 1
@


1.1
log
@Initial revision
@
text
@d14 3
@


1.1.1.1
log
@Import scenario
@
text
@@

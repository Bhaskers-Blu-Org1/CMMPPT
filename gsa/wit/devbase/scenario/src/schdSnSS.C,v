head	1.3;
access;
symbols
	sce_5_01_20080919:1.3
	latest_sce_4_20_20060523:1.3.0.6
	sce_4_20_20060523:1.3
	latest_sce4_20_OSL:1.3.0.4
	sce_4_20_OSL:1.3
	sce_4_05_20040511:1.3
	sce_4_00_20040201:1.3
	nextGenBranch:1.3.0.2
	nextGenRoot:1.3
	sce_3_30_20030627:1.3
	EndRw-branch:1.2.0.6
	Root-of-EndRw:1.2
	EndWitRw-branch:1.2.0.4
	Root-of-EndWitRw:1.2
	RwToStl-branch:1.2.0.2
	Root-of-RwToStl:1.2
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.01.15.19.36.45;	author rwToStl;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.07.19.01.16;	author austel;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.02.24.15.29.51;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.51;	author wit;	state Exp;
branches;
next	;

1.2.6.1
date	2003.01.08.17.42.35;	author rwToStl;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2003.01.09.13.54.40;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.3
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL -- inserted includes.
#include <iostream>

#include <scenario/src/schdSnSS.h>
#include <scenario/src/itemTimV.h>
#include <scenario/src/supplySS.h>
#include <scenario/src/scenario.h>
#include <scenario/src/partSchd.h>
#include <scenario/src/partSchP.h>
#include <scenario/src/demdSchd.h>
#include <scenario/src/demdSchP.h>

//------------------------------------------------------------------------
//
//   	Implementation of LgFrPartScheduleSensitiveScheduleStrategy
//
//------------------------------------------------------------------------


//estimatedSize
size_t
LgFrPartScheduleSensitiveScheduleStrategy::estimatedSize(
   const LgFrSortingScheduleFloat& schedule )
const
{
  size_t retVal = 0;

  // Set ret value to maximum size of independent schedules
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=1;  i<schedules().size();  i++ ) 
    retVal = size_tMax(
                      retVal,
                      (schedules()[i])->size()
                      );

  if (  schedule.filterStrategy().GetFSType() != __LGFRFILTERSTRATEGY )
     retVal = retVal / 2 + 1;

  retVal = size_tMax(
                    retVal,
                    LgFrAttributeScheduleStrategy::estimatedSize( schedule )
                    );

  return retVal;
}


void
LgFrPartScheduleSensitiveScheduleStrategy::combiningFunction (
    LgFrTimeVecFloatOpFunction func)    
{
    combiningFunction_ = func;
}

// Populate Schedule with itemTimeVecs
void
LgFrPartScheduleSensitiveScheduleStrategy::kernalOfPopulate(
   LgFrSortingScheduleFloat& schedule )
const
{
  LgFrSortingScheduleFloat unfilteredSchedule;
  const LgFrSortingScheduleFloat& constUnfilteredSchedule = unfilteredSchedule;
  LgFrItemTimeVecPairFloat itv;

  // Combine the schedules using combiningFunction_
  size_t len = schedules().size();
  switch (len) {
  case 0:
      break;
  case 2:	// special case for better performance
      unfilteredSchedule = (schedules()[0])->op (combiningFunction_,
                                                 *schedules()[1] );
      break;
  default:     
      {
      unfilteredSchedule = *schedules()[0];
      size_t i = 0; // Pulled out of the for below by RW2STL
      for ( i=1;  i<len;  i++ ) 
	  unfilteredSchedule = 
	      unfilteredSchedule.op (combiningFunction_,
	                             *schedules()[i]);
      }
      break;
  }

  // Loop once for each itemTimeVec in the
  // unfiltered schedule and apply filter
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<unfilteredSchedule.size(); i++ ) {

     // Make itemTimeVec
     itv = constUnfilteredSchedule[i];

     // Check to see if j'th itemTimeVec is to be filtered out
     if ( schedule.filterStrategy().exclude( itv ) ) continue;

     // Insert itemTimeVec into schedule
     schedule.localInsert( itv );
  }

}



// Insert independent Schedule 
void
LgFrPartScheduleSensitiveScheduleStrategy::insertPartSchedule(
   LgFrSortingPartScheduleFloatSmartPointer schedule )
{
   localInsert( schedule );
}

void
LgFrPartScheduleSensitiveScheduleStrategy::insertDemandSchedule(
   LgFrSortingDemandScheduleFloatSmartPointer  )
{
   std::cerr <<"ERROR: LgFrPartScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<std::endl;
   std::cerr <<"Base class does not allow mixing demand and part schedules" <<std::endl;
   std::cerr <<"This method is to be overriden in derived classes which" <<std::endl;
   std::cerr <<"support mixing demand and part schedules" <<std::endl;
   abort();

   // In derived classes which support mixing of demand and part schedules
   // code as:
   //    localInsert( schedule );
}


// Insert independent Schedule 
// This is a protected function.
void
LgFrPartScheduleSensitiveScheduleStrategy::localInsert(
   LgFrSortingScheduleFloatSmartPointer schedule )
{
  independentSchedules_.push_back(schedule);
  size_t n = independentSchedules_.size();
  independentSchedules_[n-1] -> addDependent( this );
}

// Get independent Schedule
// This is a protected function.
const LgFrOrderedVectorSortingScheduleFloatSmartPointer &
LgFrPartScheduleSensitiveScheduleStrategy::schedules()
const
{
   return independentSchedules_;
}

// Make clone copy of object
LgFrAttributeScheduleStrategy *
LgFrPartScheduleSensitiveScheduleStrategy::clone()
const
{
  LgFrPartScheduleSensitiveScheduleStrategy* temp = new LgFrPartScheduleSensitiveScheduleStrategy(*this);

  // need to deep copy the independent schedules
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<temp->independentSchedules_.size(); i++ )  {
      // cast away const here to get subscription stuff to work
      temp->independentSchedules_[i]->removeDependentFromHeterogeneousList(temp );
      temp->independentSchedules_[i] = independentSchedules_[i].deepCopy();
      temp->independentSchedules_[i]->addDependent(temp );
  }
  return temp;
}

// Make clone copy of object with new Scenario
LgFrAttributeScheduleStrategy *
LgFrPartScheduleSensitiveScheduleStrategy::clone(LgFrScenario & newScenario)
const
{
  return new LgFrPartScheduleSensitiveScheduleStrategy(*this, newScenario);
}

// Assignment operator
LgFrPartScheduleSensitiveScheduleStrategy &
LgFrPartScheduleSensitiveScheduleStrategy::operator=(
			  const LgFrPartScheduleSensitiveScheduleStrategy& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
     (this->LgFrPartScheduleStrategy::operator= ) (rhs);
     
     size_t i = 0; // Pulled out of the for below by RW2STL
     for ( i=0; i<independentSchedules_.size(); i++ ) 
        independentSchedules_[i]->removeDependentFromHeterogeneousList( this );

     independentSchedules_.clear();

     for ( i=0; i<rhs.independentSchedules_.size(); i++ ) 
        // Insert does cloning and addDependent as required.
        localInsert( rhs.independentSchedules_[i] );

  }
  return *this;
}

// Copy constructor - shallow copy
LgFrPartScheduleSensitiveScheduleStrategy::
   LgFrPartScheduleSensitiveScheduleStrategy (
      const LgFrPartScheduleSensitiveScheduleStrategy & source)
:  
   LgFrPartScheduleStrategy( source ),
   independentSchedules_(),
   combiningFunction_(source.combiningFunction_),
   id_(__LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
     localInsert( source.independentSchedules_[i] );
}

// Copy constructor with new Scenario - deep copy
LgFrPartScheduleSensitiveScheduleStrategy::
   LgFrPartScheduleSensitiveScheduleStrategy (
      const LgFrPartScheduleSensitiveScheduleStrategy & source, 
      LgFrScenario & newScenario)
:  
   LgFrPartScheduleStrategy( 
      source, 
      newScenario ),
   independentSchedules_( ),
   combiningFunction_(source.combiningFunction_),
   id_(__LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
     localInsert( source.independentSchedules_[i].deepCopy() );
}

// Constructor
LgFrPartScheduleSensitiveScheduleStrategy::
   LgFrPartScheduleSensitiveScheduleStrategy (
     LgFrScenario & scenario )
:  LgFrPartScheduleStrategy(
      LgFrAttributeScheduleStrategy::setOfParts(scenario),
      &(implode(scenario)) ),
   independentSchedules_( ),
   combiningFunction_(&LgFrTimeVecFloat::add),
   id_(__LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  // Nothing to do here
}

static 
  const 
     LgFrSetOfPartsWithMovableParts 
        sopForDefaultConstructor = 
          LgFrSetOfPartsWithMovableParts();

// Default Constructor
// This is a private member function.
LgFrPartScheduleSensitiveScheduleStrategy::
   LgFrPartScheduleSensitiveScheduleStrategy ()
:  LgFrPartScheduleStrategy( sopForDefaultConstructor, 0 ),
   independentSchedules_( ),
   combiningFunction_(&LgFrTimeVecFloat::add),
   id_(__LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  // Nothing to do here
}


// Destructor
LgFrPartScheduleSensitiveScheduleStrategy::
   ~LgFrPartScheduleSensitiveScheduleStrategy ()
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<independentSchedules_.size(); i++ ) 
     independentSchedules_[i]->removeDependentFromHeterogeneousList( this );

  // Removing all of the items from independentSchedules_ explicitly
  // is redundant if the destructor of independentSchedules_ does it,
  // but this way we are sure it is done.
  independentSchedules_.clear();	
}

//------------------------------------------------------------------------
//
//   	Implementation of LgFrDemandScheduleSensitiveScheduleStrategy
//
//------------------------------------------------------------------------


//estimatedSize
size_t
LgFrDemandScheduleSensitiveScheduleStrategy::estimatedSize(
   const LgFrSortingScheduleFloat& schedule )
const
{
  size_t retVal = 0;

  // Set ret value to maximum size of independent schedules
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=1;  i<schedules().size();  i++ )
    retVal = size_tMax(
                      retVal,
                      (schedules()[i])->size()
                      );

  if (  schedule.filterStrategy().GetFSType() != __LGFRFILTERSTRATEGY )
     retVal = retVal / 2 + 1;

  retVal = size_tMax(
                    retVal,
                    LgFrAttributeScheduleStrategy::estimatedSize( schedule )
                    );

  return retVal;
}


// Populate Schedule with itemTimeVecs
void
LgFrDemandScheduleSensitiveScheduleStrategy::kernalOfPopulate(
   LgFrSortingScheduleFloat& schedule )
const
{

  LgFrSortingScheduleFloat unfilteredSchedule;
  const LgFrSortingScheduleFloat & constUnfilteredSchedule = unfilteredSchedule;
  LgFrItemTimeVecPairFloat itv;

  // Loop once for each independent schedule, adding it to the
  // unfilteredSchedule
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<schedules().size(); i++ ) 
     unfilteredSchedule = 
        (LgFrSortingScheduleFloat) 
           ( unfilteredSchedule + *schedules()[i] );

  // Loop once for each itemTimeVec in the
  // unfiltered schedule and apply filter
  for ( i=0; i<unfilteredSchedule.size(); i++ ) {

     // Make itemTimeVec
     itv = constUnfilteredSchedule[i];

     // Check to see if j'th itemTimeVec is to be filtered out
     if ( schedule.filterStrategy().exclude( itv ) ) continue;

     // Insert itemTimeVec into schedule
     schedule.localInsert( itv );
  }

}

// Insert independent Schedule 
void
LgFrDemandScheduleSensitiveScheduleStrategy::insertPartSchedule(
   LgFrSortingPartScheduleFloatSmartPointer  )
{
   std::cerr <<"ERROR: LgFrDemandScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<std::endl;
   std::cerr <<"Base class does not allow mixing demand and part schedules" <<std::endl;
   std::cerr <<"This method is to be overriden in derived classes which" <<std::endl;
   std::cerr <<"support mixing demand and part schedules" <<std::endl;
   abort();

   // In derived classes which support mixing of demand and part schedules
   // code as:
   //    localInsert( schedule );
}

void
LgFrDemandScheduleSensitiveScheduleStrategy::insertDemandSchedule(
   LgFrSortingDemandScheduleFloatSmartPointer schedule )
{
   localInsert( schedule );
}


// Insert independent Schedule 
// This is a protected function.
void
LgFrDemandScheduleSensitiveScheduleStrategy::localInsert(
   LgFrSortingScheduleFloatSmartPointer schedule )
{
  independentSchedules_.push_back(schedule);
  size_t n = independentSchedules_.size();
  independentSchedules_[n-1] -> addDependent( this );
}


// Get independent Schedule
// This is a protected function.
const LgFrOrderedVectorSortingScheduleFloatSmartPointer &
LgFrDemandScheduleSensitiveScheduleStrategy::schedules()
const
{
   return independentSchedules_;
}

// Make clone copy of object
LgFrAttributeScheduleStrategy *
LgFrDemandScheduleSensitiveScheduleStrategy::clone()
const
{
  LgFrDemandScheduleSensitiveScheduleStrategy* temp = new LgFrDemandScheduleSensitiveScheduleStrategy(*this);

  // need to deep copy the independent schedules


  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<temp->independentSchedules_.size(); i++ )  {
      // cast away const to get things to work here

      // clear out shallow copies of independent schedules
      temp->independentSchedules_[i]->removeDependentFromHeterogeneousList(temp );
      temp->independentSchedules_[i] = independentSchedules_[i].deepCopy();
      temp->independentSchedules_[i]->addDependent(temp );
  }
  return temp;
}

// Make clone copy of object with new Scenario
LgFrAttributeScheduleStrategy *
LgFrDemandScheduleSensitiveScheduleStrategy::clone(LgFrScenario & newScenario)
const
{
  return new LgFrDemandScheduleSensitiveScheduleStrategy(*this, newScenario);
}

// Assignment operator
LgFrDemandScheduleSensitiveScheduleStrategy &
LgFrDemandScheduleSensitiveScheduleStrategy::operator=(
			  const LgFrDemandScheduleSensitiveScheduleStrategy& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
     (this->LgFrDemandScheduleStrategy::operator= ) (rhs);
     
     size_t i = 0; // Pulled out of the for below by RW2STL
     for ( i=0; i<independentSchedules_.size(); i++ ) 
        independentSchedules_[i]->removeDependentFromHeterogeneousList( this );

     independentSchedules_.clear();

     for ( i=0; i<rhs.independentSchedules_.size(); i++ ) 
        // Insert does cloning and addDependent as required.
        localInsert( rhs.independentSchedules_[i] );
  }
  return *this;
}

// Copy constructor - shallow copy
LgFrDemandScheduleSensitiveScheduleStrategy::
   LgFrDemandScheduleSensitiveScheduleStrategy (
      const LgFrDemandScheduleSensitiveScheduleStrategy & source)
:  
   LgFrDemandScheduleStrategy( source ),
   independentSchedules_(),
   id_(__LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
     localInsert( source.independentSchedules_[i] );
}

// Copy constructor with new Scenario - deep copy independent schedules!
LgFrDemandScheduleSensitiveScheduleStrategy::
   LgFrDemandScheduleSensitiveScheduleStrategy (
      const LgFrDemandScheduleSensitiveScheduleStrategy & source, 
      LgFrScenario & newScenario)
:  
   LgFrDemandScheduleStrategy( 
      source, 
      newScenario ),
   independentSchedules_( ),
   id_(__LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
     localInsert( source.independentSchedules_[i].deepCopy() );
}
   

// Constructor
LgFrDemandScheduleSensitiveScheduleStrategy::
   LgFrDemandScheduleSensitiveScheduleStrategy (
     LgFrScenario & scenario )
:  LgFrDemandScheduleStrategy(
      LgFrAttributeScheduleStrategy::setOfDemands(scenario),
      &(implode(scenario)) ),
   independentSchedules_( ),
   id_(__LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  // Nothing to do here
}

// Default Constructor
// This is a private member function.
LgFrDemandScheduleSensitiveScheduleStrategy::
   LgFrDemandScheduleSensitiveScheduleStrategy ()
:  LgFrDemandScheduleStrategy( LgFrSetOfDemands(), 0 ),
   independentSchedules_( ),
   id_(__LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY)
{
  // Nothing to do here
}


// Destructor
LgFrDemandScheduleSensitiveScheduleStrategy::
   ~LgFrDemandScheduleSensitiveScheduleStrategy ()
{
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<independentSchedules_.size(); i++ ) 
     independentSchedules_[i]->removeDependentFromHeterogeneousList( this );

  // Removing all of the items from independentSchedules_ explicitly
  // is redundant if the destructor of independentSchedules_ does it,
  // but this way we are sure it is done.
  independentSchedules_.clear();	
}

//------------------------------------------------------------------------
//
//  		Test Methods
//
//------------------------------------------------------------------------

#ifdef NDEBUG
#undef NDEBUG
#endif

// test LgFrPartScheduleSensitiveScheduleStrategy methods.

void
LgFrPartScheduleSensitiveScheduleStrategy::test()
{
  LgFrPartScheduleSensitiveScheduleStrategy cs1;
  assert( cs1.independentSchedules_.size() == 0 );
}


// test LgFrPartScheduleSensitiveScheduleStrategy methods.
// Expects testScenario to contain data from
// /u/implode/wit/data/examples/diner12/wit.data
// Expects supplySchedule to be a supply schedule for testScenario
// (containing a LgFrSupplyScheduleStrategy)
void
LgFrPartScheduleSensitiveScheduleStrategy::contextTest
    (
     LgFrScenario & testScenario,
     LgFrSortingPartScheduleFloatSmartPointer supplySchedule    
     )
{
  LgFrPartScheduleSensitiveScheduleStrategy cs1;

  // Test inserting single dependent schedule
  cs1.insertPartSchedule( supplySchedule );
  assert( cs1.independentSchedules_[0] == supplySchedule );

  // Test copy constructor
  LgFrPartScheduleSensitiveScheduleStrategy cs2(cs1);
  assert( cs2.independentSchedules_[0] == supplySchedule );

  // Test inserting schedules
  assert( cs2.independentSchedules_.size() == 1 );
  cs2.insertPartSchedule( supplySchedule );
  assert( cs2.independentSchedules_[0] == supplySchedule );
  assert( cs2.independentSchedules_[1] == supplySchedule );
  assert( cs2.independentSchedules_.size() == 2 );

  // Test assignment operator
  LgFrPartScheduleSensitiveScheduleStrategy cs3;
  cs3 = cs2;
  assert( cs3.independentSchedules_[1] == supplySchedule );

  // Test clone method
  {
    LgFrAttributeScheduleStrategy *cs4Ptr = cs1.clone();
    assert( (  (LgFrPartScheduleSensitiveScheduleStrategy *) cs4Ptr)
            ->independentSchedules_.size() == 1 );
    // check equality of content - deep copy of schedules
    assert( *((  (LgFrPartScheduleSensitiveScheduleStrategy *) cs4Ptr))
            ->independentSchedules_[0]
            == *supplySchedule );
    
    // Test destructor
    delete cs4Ptr;
  }


  // Test Kernal of populate
  LgFrSortingPartScheduleFloatSmartPointer sup(new LgFrSortingPartScheduleFloat);
  sup->attributeScheduleStrategy( cs1 );
  sup->populate();
// check that the schedules are equivalent
  assert( *sup == *supplySchedule );  


  // Test kernalOfPopulate when this class is being used to subtract two
  // schedules
  {
      // Set up the strategy
      LgFrSortingPartScheduleFloatSmartPointer supplySchedule2
	 (new LgFrSortingPartScheduleFloat(*supplySchedule + *supplySchedule));
      LgFrPartScheduleSensitiveScheduleStrategy cs1;
      cs1.insertPartSchedule( supplySchedule ); 
      cs1.insertPartSchedule( supplySchedule2 );
      cs1.combiningFunction (&LgFrTimeVecFloat::subtract);

      // Set up the schedule that uses the strategy
      LgFrSortingPartScheduleFloat deltaSup;
      deltaSup.attributeScheduleStrategy( cs1 );
      deltaSup.populate();

      // Compare deltaSup to what it should be
      const LgFrSortingPartScheduleFloat & constSupplySchedule
	  = *supplySchedule;
      const LgFrSortingPartScheduleFloat & constSupplySchedule2 
	  = *supplySchedule2;

      const LgFrSortingPartScheduleFloat & constDeltaSup = deltaSup;
      int i = 0; // Pulled out of the for below by RW2STL
      for (i=0; i<supplySchedule->size(); i++ ) 
	  assert(         constDeltaSup[i].timeVecFloat() == 
			  (constSupplySchedule[i].timeVecFloat() - 
			   constSupplySchedule2[i].timeVecFloat()
			  )
	        );
  }

  // Test subscription mechanism
  const LgFrSortingPartScheduleFloat& constSupplySchedule = *supplySchedule;
  LgFrPart part2 = constSupplySchedule[2].part();
  supplySchedule->insertKeyAndValue( part2, LgFrTimeVecFloat(2, 3.1415f) );
// check that the schedules are equivalent
  assert( *sup == *supplySchedule );

  // Test scenario copy constructor - deep copies the dependent schedules over
  LgFrPartScheduleSensitiveScheduleStrategy scenCtor(cs1,testScenario);
  assert( scenCtor.independentSchedules_.size() ==  
               cs1.independentSchedules_.size() );

  // Test cloning w/scenario - this deep copies the dependent schedules over
  LgFrAttributeScheduleStrategy *cs6Ptr = cs1.clone(testScenario);
  // schedules do not have same address but have the same content
  assert( ((LgFrPartScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0] 
          != supplySchedule );
  assert( *(((LgFrPartScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0])
          == *supplySchedule );
  assert( ((LgFrPartScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0] 
          != cs1.independentSchedules_[0] );
  assert( *(((LgFrPartScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0])
          == *(cs1.independentSchedules_[0]) );


  // Test insertion methods that give ownershipp to the ASS.  If there are
  // memory leaks from this block only, there is something wrong with them or
  // with the destructor.
#ifdef DONE_TESTING_COPYING
  {
    LgFrPartScheduleSensitiveScheduleStrategy * cs8ptr
      = new LgFrPartScheduleSensitiveScheduleStrategy (testScenario);
    
    LgFrSortingPartScheduleFloat * ns1 = new
      LgFrSortingPartScheduleFloat(supplySchedule); // deleting cs8ptr should
                                                    // delete this
    cs8ptr->insertPartSchedule( *ns1 );
    assert( cs8ptr->independentSchedules_[0] == ns1 );
    LgFrSortingPartScheduleFloat * ns2 = new
      LgFrSortingPartScheduleFloat(supplySchedule); // deleting cs8ptr should
                                                    // delete this
    cs8ptr->insertPartSchedule( *ns2 );
    assert( cs8ptr->independentSchedules_[1] == ns2 );
    assert( cs8ptr->independentSchedules_.size() == 2 );
    delete cs8ptr;
  }
#endif
  
  delete cs6Ptr;
}


// test LgFrDemandScheduleSensitiveScheduleStrategy methods.

void
LgFrDemandScheduleSensitiveScheduleStrategy::test()
{
  LgFrDemandScheduleSensitiveScheduleStrategy cs1;
  assert( cs1.independentSchedules_.size() == 0 );
}


// test LgFrDemandScheduleSensitiveScheduleStrategy methods.
// Expects testScenario to contain data from
// /u/implode/wit/data/examples/diner12/wit.data
// Expects demandVolSchedule to be a supply schedule for testScenario
// (containing a LgFrSupplyScheduleStrategy)
void
LgFrDemandScheduleSensitiveScheduleStrategy::contextTest
    (
     LgFrScenario & testScenario,
     LgFrSortingDemandScheduleFloatSmartPointer demandVolSchedule    
     )
{
  LgFrDemandScheduleSensitiveScheduleStrategy cs1;

  // Test inserting single dependent schedule
  cs1.insertDemandSchedule( demandVolSchedule );
  assert( cs1.independentSchedules_[0] == demandVolSchedule );

  // Test copy constructor
  LgFrDemandScheduleSensitiveScheduleStrategy cs2(cs1);
  assert( cs2.independentSchedules_[0] == demandVolSchedule );

  // Test inserting schedules
  assert( cs2.independentSchedules_.size() == 1 );
  cs2.insertDemandSchedule( demandVolSchedule );
  assert( cs2.independentSchedules_[0] == demandVolSchedule );
  assert( cs2.independentSchedules_[1] == demandVolSchedule );
  assert( cs2.independentSchedules_.size() == 2 );

  // Test assignment operator
  LgFrDemandScheduleSensitiveScheduleStrategy cs3;
  cs3 = cs2;
  assert( cs3.independentSchedules_[1] == demandVolSchedule );

  // Test clone method - deep copy schedules
  {
    LgFrAttributeScheduleStrategy *cs4Ptr = cs1.clone();
    assert( (  (LgFrDemandScheduleSensitiveScheduleStrategy *) cs4Ptr)
            ->independentSchedules_.size() == 1 );
    // check contents - deep copied schedules
    assert( *((  (LgFrDemandScheduleSensitiveScheduleStrategy *) cs4Ptr))
            ->independentSchedules_[0] 
            == *demandVolSchedule );
    
    // Test destructor
    delete cs4Ptr;
  }


  // Test Kernal of populate
  LgFrSortingDemandScheduleFloat sup;
  sup.attributeScheduleStrategy( cs1 );
  sup.populate();
  assert( sup == *demandVolSchedule );

  // Test subscription mechanism
  const LgFrSortingDemandScheduleFloat & constSupplySchedule = *demandVolSchedule;
  LgFrDemand part2 = constSupplySchedule[2].demand();
  demandVolSchedule->insertKeyAndValue( part2, LgFrTimeVecFloat(2, 3.1415f) );
  assert( sup == *demandVolSchedule );

  // Test scenario copy constructor - deep copy
  LgFrDemandScheduleSensitiveScheduleStrategy scenCtor(cs1,testScenario);
  assert( scenCtor.independentSchedules_.size() ==  
               cs1.independentSchedules_.size() );

  // Test cloning w/scenario  - deep copy
  LgFrAttributeScheduleStrategy *cs6Ptr = cs1.clone(testScenario);
  assert( ((LgFrDemandScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0] 
          != demandVolSchedule );
  assert( ((LgFrDemandScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0] 
          != cs1.independentSchedules_[0] );
  assert( *(((LgFrDemandScheduleSensitiveScheduleStrategy *)cs6Ptr)->independentSchedules_[0])
          == *(cs1.independentSchedules_[0]) );

  delete cs6Ptr;


}
@


1.2
log
@

NOTE CONCERNING FOR-SEMANTICS.

In old C++ semantics, this was illegal:
	for (int i=...) { ...}
	for (int i=...) { ...}

because the scope of i extended beyond the first for-loop, making
the second declaration a conflict.

In new C++ semantics, this is illegal:
	for (int i=...) { ...}
	for (i=...) { ...}

because the scope of i extends in the first for-loop, making
the use of "i" in the second loop unbound.

We can't have it both ways.  We could convert the source to be this:
	inti;
	for (i=...) { ...}
	for (i=...) { ...}

but rather than do that, I have opted to just use a special flag
("-qlanglvl=noansifor") to tell vacpp to use the old semantics.
This flag is in config/p_powerVac.mk.
We can always convert these for loops later if we like, and take
out the flag.


Now some notes concerning what I did in the various components.
Hopefully no one will ever have to read this.

CONFIG:
changed config/p_powerVac.mk by copying setting for ds_comp_std_flags
from config/p_power64v5.mk, to suppress error messages concerning
the technique to avoid accidental use of compiler-generated constructors.

WITUTIL:
changed return type of "main" to int in several files.

SCENARIO and SCE:
In many files, some member declarations had (unnecessary) qualifiers:

	class S {
	S::f();
	};

The obvious solution was to just remove the "S::" qualifier.



In some files (such as ipDifT.h), a member declaration using a class
name in a return type caused a syntax error; the compiler complained
about ambiguity.

	class X {
	C f();
	};

Solution:  add "class C" in front.  Should really have no possible problems.

	class C;
	class X {
	C f();
	};



Some classes declared protected members of other classes to be friends:

	class A {
	protected:
	  int mem();
	};

	class B {
	friend int A::mem();
	};

This is evidentally now illegal.  I suppose it makes sense that one
should already have access to the thing that one wants to be a friend of.

My solution was to just drop the "protected" keyword.
This allows everyone access to these members (which is presumably
undesirable), but at least doesn't allow the friend classes access
to the private data of this class (which presumably is desired).

Another alternative would be to keep the "protected" keyword and
add "friend class A" to the friend class.
The situation is now reversed; it would have the drawback of allowing
the friend class access to private data (which presumably isn't desired),
but would disallow non-friends access to these protected members.




attrInfo.h:  typedef declarations for functions types cannot have
default arguments, i.e. this is illegal:

	typedef int (*f)(int x = 1);

Solution:  drop the default argument:

	typedef int (*f)(int x);

(I suppose this makes sense, given that the treatment of default arguments
seems to have gotten a bit complicated - you can add and remove them
using new declarations.)



(THIS NOTE IS OBSOLETE since I ended up leaving these for-loops alone.
However, it may be useful if we ever do convert the source to the
new syntax.
calendar.C, consSS.C, difCmrpF.C, difWit[DR].C:
  added "int" (or size_t, as appropriate) to "for" loops:

was:
	for (int t=...) { ..}
	for (t=...) { ..}

now:
	for (int t=...) { ..}
	for (int t=...) { ..}

This is ok since t is initialized in each loop.

This wasn't possible in one spot in sched.C, in LgFrScheduleFloat::reduceItems.
It also wasn't possible in a spot in sce/ipSce.C.
It had code like this:
	int t;
	... code setting t
	for (...) {
	  for (int t = ...)
		...
	  somevar = t;
	}

According to the old rules, the assignment "somevar = t" refers to the
t in the nested for-loop.  I've changed it to this:

	for (...) {
	  int t;
	  for (t = ...)
		...
	  somevar = t;
	}

Fortunately, in most places the loop was not nested inside some other
construct, which makes it likely that I didn't make any mistakes.

END OBSOLETE NOTE)



demdSchd.C, partSchd.C, scenATP.C, ...:
  apparently, expressions that refer to a pointer-to-member must use "&":
	class C {
	int f();
	};

	g(C::f);	// ILLEGAL
	g(&C::f);	// GOOD BOY!

(maybe this makes parsing easier?)



dfa.C:  changed
	#include "dfa.h"
to
	#include <scenario/src/dfa.h>

so that the depedency generated by makedepend (and that ends up in Makefile)
doesn't cause problems.




lastPrbS.C:  "bool" is now a keyword.  Changed variable "bool" to "Bool".





multDSch.C:

start with this decl:

    LgFrMultiDemandScheduleFloat& msdClone = *msdClonePtr;

and this call:

    const LgFrSortingDemandScheduleFloat& demandSchdClone
      = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );


LgFrMultiDemandScheduleFloat (in multDSch.h) apparently inherits the
declaration of method "schedule" from its baseclass, LgFrMultiScheduleFloat
(in multiSch.h).

  // Return a non-const schedule
  virtual
    LgFrSortingScheduleFloatSmartPointer
     schedule(const LgFrScheduleDescriptor& sd) const;


class LgFrSortingScheduleFloatSmartPointer is defined in sortSchP.h.
Its baseclass is LgFrSortingScheduleFloatSmartPointerToConst,
defined in the same file, and that has no baseclass.

class LgFrSortingDemandScheduleFloatSmartPointer is defined in demdSchP.h,
and looks similar to LgFrSortingScheduleFloatSmartPointer,
probably one was copied from the other and the names were changed.

So, the problematic statement is probably the equivalent of casting a pointer.

This was the code I used instead.
It may just be that one can't cast using "&" anymore.

    LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
    LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
    const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);


This is *probably* ok, since both smartpointers have the same private
data fields (in their basetypes).  The code snippets below give the
general idea.  I imagine that this would all be done with templates
these days (if there isn't already a smartpointer library somewhere).



protected:
    LgFrSortingDemandScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingDemandScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;




protected:
    LgFrSortingScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;


Dereference is just what it should be:


const LgFrSortingDemandScheduleFloat &
LgFrSortingDemandScheduleFloatSmartPointer::operator*() const
{
    return *pointer_;
}

LgFrSortingScheduleFloat &
LgFrSortingScheduleFloatSmartPointer::operator*()
{
    return *pointer_;
}



SCE:
Created powerVac/Makefile
by copying power64/Makefile and just changine "power64" to "powerVac".





For convenience, here is the output of these commands:

	cvs diff scenario/src
	cvs diff sce/src


Index: scenario/src/attrInfo.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/attrInfo.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 attrInfo.h
17c17,20
< 	       const LgFrDataInterfaceEssentials* difEssenPtr = NULL);
---
>
> 	       // syntax error - typedefs can (no longer) have default args
> 	       const LgFrDataInterfaceEssentials* difEssenPtr /////= NULL
> 	       );
47c50
< LgFrAttributeInformation::LgFrAttributeInformation(const LgFrAttributeInformation& );
---
> LgFrAttributeInformation(const LgFrAttributeInformation& );
Index: scenario/src/backlgSS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/backlgSS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 backlgSS.h
83c83
<   LgFrBacklogScheduleStrategy::contextTest
---
>   contextTest
Index: scenario/src/calendar.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/calendar.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 calendar.h
252c252
<   LgFrCalendar::addMonths(const RWTime& aTime, unsigned numMonthsOut,
---
>   addMonths(const RWTime& aTime, unsigned numMonthsOut,
281c281
<   LgFrCalendar::display()
---
>   display()
Index: scenario/src/demdSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/demdSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 demdSchd.C
273c273
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
288c288
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
452c452
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
475c475
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
496c496
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
514c514
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/dfa.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/dfa.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 dfa.C
14c14,16
< #include "dfa.h"
---
>
> //#include "dfa.h"
> #include <scenario/src/dfa.h>
Index: scenario/src/filtStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/filtStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 filtStrt.h
89c89,90
< protected:
---
>   // see the comment in schdStrt.h.
>   /////protected:
Index: scenario/src/fssCtrl.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/fssCtrl.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 fssCtrl.h
109c109
<         LgFrFocussedShortageScheduleControl::isValid()
---
>         isValid()
117c117
<         LgFrFocussedShortageScheduleControl::focusChanged()
---
>         focusChanged()
151c151
<    LgFrFocussedShortageScheduleControl::LgFrFocussedShortageScheduleControl(
---
>    LgFrFocussedShortageScheduleControl(
Index: scenario/src/ipDifT.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/ipDifT.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 ipDifT.h
10a11,15
>
> // added to avoid syntax error in declaration of difTestingScenario below - vra
> class LgFrScenarioForDifTestingSmartPointer;
>
>
Index: scenario/src/lastPrbS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 lastPrbS.C
98c98
<    witBoolean bool;
---
>    witBoolean Bool;
100,101c100,101
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
248c248
<    witBoolean bool;
---
>    witBoolean Bool;
250,251c250,251
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
Index: scenario/src/lastPrbS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.h,v
retrieving revision 1.2
diff -r1.2 lastPrbS.h
182c182
<         LgFrLastProblemSolved::focusHorizon(
---
>         focusHorizon(
686c686
<         LgFrLastProblemSolved::cumShipBounds(
---
>         cumShipBounds(
760c760
<         LgFrLastProblemSolved::cumShipSoftLowerBound(
---
>         cumShipSoftLowerBound(
910c910
<       LgFrLastProblemSolved::getPartFloatVecAttribute(
---
>       getPartFloatVecAttribute(
917c917
<        LgFrLastProblemSolved::setPartFloatVecAttribute(
---
>        setPartFloatVecAttribute(
924c924
<       LgFrLastProblemSolved::setPartBoundsAttribute(
---
>       setPartBoundsAttribute(
933c933
<       LgFrLastProblemSolved::getDemandFloatVecAttribute(
---
>       getDemandFloatVecAttribute(
940c940
<       LgFrLastProblemSolved::getDemandSoftLowerBoundAttribute(
---
>       getDemandSoftLowerBoundAttribute(
947c947
<       LgFrLastProblemSolved::setDemandBoundsAttribute(
---
>       setDemandBoundsAttribute(
956c956
<    LgFrLastProblemSolved::writeSchedule(
---
>    writeSchedule(
Index: scenario/src/multDSch.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/multDSch.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 multDSch.C
436,438c436,446
<
<     const LgFrSortingDemandScheduleFloat& demandSchdClone
<       = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
---
>
>     //// LET'S TRY THIS AGAIN...
>     /////const LgFrSortingDemandScheduleFloat& demandSchdClone
>     /////= *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
>
>     LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
>     LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
>     const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);
>
>     ///// DONE
>
Index: scenario/src/outInter.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/outInter.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 outInter.h
43c43
<   static const LgFrSchedulePrintStyle LgFrSolutionOutputInterface::pmTEXT;
---
>   static const LgFrSchedulePrintStyle pmTEXT;
Index: scenario/src/pairComp.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/pairComp.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 pairComp.h
84c84,86
< protected:
---
>   // in scenario.h, class LgFrScenario declares these methods to be "friend".
>   // see the comment in schdStrt.h.
>   //// protected:
Index: scenario/src/partSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/partSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 partSchd.C
261c261
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
276c276
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
443c443
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
466c466
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
487c487
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
503c503
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/scenATP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenATP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenATP.C
484c484
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
513c513
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
Index: scenario/src/scenSnFS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenSnFS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenSnFS.h
16c16
<   LgFrScenarioSensitiveFilterStrategy::scenario(
---
>   scenario(
21c21
<   LgFrScenarioSensitiveFilterStrategy::scenarioPtr()
---
>   scenarioPtr()
Index: scenario/src/scenario.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenario.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenario.h
46a47,54
> // had to add this line in order to avoid syntax error concerning
> // the uses of this class in members below.
> // vacpp complained that is was ambiguous.
> // I don't know why.
> // Perhaps in older versions of the compiler the friend declarations
> // below also implicitly declared the class as well?
> class LgFrScheduleFactory;
>
231c239
<   const LgFrScheduleFactory*
---
>     const LgFrScheduleFactory*
Index: scenario/src/schFCMRP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFCMRP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFCMRP.C
82c82
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
184c184
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
370c370
<       usagePctSS->combiningFunction (LgFrTimeVecFloat::percentageOf);
---
>       usagePctSS->combiningFunction (&LgFrTimeVecFloat::percentageOf);
416c416
<       deltaSS->combiningFunction (LgFrTimeVecFloat::subtract);
---
>       deltaSS->combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schFctry.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFctry.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFctry.h
96c96
< friend LgFrScenarioBuilder;
---
> friend class LgFrScenarioBuilder;
Index: scenario/src/schdSnSS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdSnSS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdSnSS.C
242c242
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
260c260
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
613c613
<       cs1.combiningFunction (LgFrTimeVecFloat::subtract);
---
>       cs1.combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schdStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdStrt.h
141c141,168
< protected:
---
>   ////??????
>   // in scenario.h, class LgFrScenario declares (most of) the
>   // following methods to be "friend"s.
>   // I (vra) can't see how that would have ever been possible,
>   // given that these are protected methods.
>   // Perhaps the compilers are just more finicky now.
>   // As a hack to get this working right away, I will remove the
>   // protected keyword.
>   //
>   // An an alternative, one could add
>   //    friend class LgFrAttributeScheduleStrategy;
>   // to the classes that need access (such as LgFrScenario)
>   // and make these methods protected again.
>   //
>   // The differences between these two styles is:
>   //	dropping "protected" here allows everyone access,
>   //	(which presumably isn't intended),
>   //	but denies friends (such as LgFrScenario) access to private members
>   //	(which presumably is intended).
>   //
>   //	in contrast, using friend class LgFrAttributeScheduleStrategy
>   //	(and putting back the "protected" keyword here)
>   //	allows the friend classes access to private members
>   //	(presumably not intended),
>   //	but denies everyone else access to protected members
>   //	(presumably intended).
>   //
>   ////// protected:
Index: scenario/src/sched.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.C
578c578
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
585c585
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
594c594
<   return op(LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
---
>   return op(&LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
716c716
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
734c734
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
750c750
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
761c761
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/sched.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.h
81c81
<       LgFrScheduleFloat::capacity()
---
>       capacity()
Index: scenario/src/sortSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sortSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sortSchd.C
679c679
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
688c688
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
Index: scenario/src/wrkgProb.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/wrkgProb.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 wrkgProb.C
641c641
<                LgFrLastProblemSolved::capitalCost);
---
>                &LgFrLastProblemSolved::capitalCost);
650c650
<                       LgFrLastProblemSolved::capitalCost );
---
>                       &LgFrLastProblemSolved::capitalCost );
660c660
<                LgFrLastProblemSolved::equitability);
---
> 	     &LgFrLastProblemSolved::equitability);
669c669
<                       LgFrLastProblemSolved::equitability );
---
> 		    &LgFrLastProblemSolved::equitability );
679c679
<                LgFrLastProblemSolved::buildAhead);
---
> 		   &LgFrLastProblemSolved::buildAhead);
688c688
<                       LgFrLastProblemSolved::buildAhead );
---
> 			  &LgFrLastProblemSolved::buildAhead );
698c698
<                LgFrLastProblemSolved::computeCriticalList);
---
> 		   &LgFrLastProblemSolved::computeCriticalList);
707c707
<                       LgFrLastProblemSolved::computeCriticalList );
---
> 			  &LgFrLastProblemSolved::computeCriticalList );
717c717
<                LgFrLastProblemSolved::inventoryCost);
---
>                &LgFrLastProblemSolved::inventoryCost);
726c726
<                       LgFrLastProblemSolved::inventoryCost );
---
>                       &LgFrLastProblemSolved::inventoryCost );
736c736
<                LgFrLastProblemSolved::obj2WeightInventory);
---
>                &LgFrLastProblemSolved::obj2WeightInventory);
745c745
<                       LgFrLastProblemSolved::obj2WeightInventory );
---
>                       &LgFrLastProblemSolved::obj2WeightInventory );
755c755
<                LgFrLastProblemSolved::obj2WeightRevenue);
---
>                &LgFrLastProblemSolved::obj2WeightRevenue);
764c764
<                       LgFrLastProblemSolved::obj2WeightRevenue );
---
>                       &LgFrLastProblemSolved::obj2WeightRevenue );
774c774
<                LgFrLastProblemSolved::obj2WeightService);
---
>                &LgFrLastProblemSolved::obj2WeightService);
783c783
<                       LgFrLastProblemSolved::obj2WeightService );
---
>                       &LgFrLastProblemSolved::obj2WeightService );
793c793
<                LgFrLastProblemSolved::obj2WeightSubstitutes);
---
>                &LgFrLastProblemSolved::obj2WeightSubstitutes);
802c802
<                       LgFrLastProblemSolved::obj2WeightSubstitutes );
---
>                       &LgFrLastProblemSolved::obj2WeightSubstitutes );
812c812
<                LgFrLastProblemSolved::weightBounds);
---
>                &LgFrLastProblemSolved::weightBounds);
821c821
<                       LgFrLastProblemSolved::weightBounds );
---
>                       &LgFrLastProblemSolved::weightBounds );




Index: sce/src/aEngMgr.h
===================================================================
RCS file: /u/wit/devbase/sce/src/aEngMgr.h,v
retrieving revision 1.5
diff -r1.5 aEngMgr.h
77c77
< LgFrSceAllocationEngineMgr::sortID();
---
> sortID();
Index: sce/src/scePegging.C
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.C,v
retrieving revision 1.6
diff -r1.6 scePegging.C
121c121
<   virtual RWBoolean SceCollectableDouble::operator==(const SceCollectableDouble& c) const
---
>   virtual RWBoolean operator==(const SceCollectableDouble& c) const
124c124
<   virtual RWBoolean SceCollectableDouble::isEqual(const RWCollectable* c) const
---
>   virtual RWBoolean isEqual(const RWCollectable* c) const
Index: sce/src/scePegging.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.h,v
retrieving revision 1.4
diff -r1.4 scePegging.h
120c120
<   void ScePegging::computeConsVolAndUpdateConsDict(
---
>   void computeConsVolAndUpdateConsDict(
Index: sce/src/scenSce.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scenSce.h,v
retrieving revision 1.6
diff -r1.6 scenSce.h
35a36,38
> // added to avoid syntax error - vra
> class LgFrScenarioForSceSmartPointer;
>
@
text
@d1 4
a4 1
#include <iostream.h>
d31 2
a32 1
  for ( size_t i=1;  i<schedules().length();  i++ ) 
d35 1
a35 1
                      (schedules()[i])->entries()
d38 1
a38 1
  if (  schedule.filterStrategy().isA() != __LGFRFILTERSTRATEGY )
d68 1
a68 1
  size_t len = schedules().length();
d79 2
a80 1
      for ( size_t i=1;  i<len;  i++ ) 
d90 2
a91 1
  for ( size_t i=0; i<unfilteredSchedule.entries(); i++ ) {
d119 6
a124 6
   cerr <<"ERROR: LgFrPartScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<endl;
   cerr <<"Base class does not allow mixing demand and part schedules" <<endl;
   cerr <<"This method is to be overriden in derived classes which" <<endl;
   cerr <<"support mixing demand and part schedules" <<endl;
   abort;
d138 2
a139 2
  independentSchedules_.insert(schedule);
  size_t n = independentSchedules_.entries();
d160 2
a161 1
  for ( size_t i=0; i<temp->independentSchedules_.entries(); i++ )  {
a177 8
// Return strategy identifier
isAReturnType
LgFrPartScheduleSensitiveScheduleStrategy::isA()
const
{
   return id_;
}

a182 1
  assert( id_ == rhs.id_ );
d186 2
a187 1
     for ( size_t i=0; i<independentSchedules_.entries(); i++ ) 
d192 1
a192 1
     for ( i=0; i<rhs.independentSchedules_.length(); i++ ) 
d210 2
a211 2
  assert( id_ == source.id_ );
  for ( size_t i=0; i<source.independentSchedules_.entries(); i++ ) 
d228 2
a229 2
  assert( id_ == source.id_ );
  for ( size_t i=0; i<source.independentSchedules_.entries(); i++ ) 
d257 1
a257 1
:  LgFrPartScheduleStrategy( sopForDefaultConstructor, NULL ),
d270 2
a271 1
  for ( size_t i=0; i<independentSchedules_.entries(); i++ ) 
d296 2
a297 1
  for ( size_t i=1;  i<schedules().length();  i++ )
d300 1
a300 1
                      (schedules()[i])->entries()
d303 1
a303 1
  if (  schedule.filterStrategy().isA() != __LGFRFILTERSTRATEGY )
d328 2
a329 1
  for ( size_t i=0; i<schedules().length(); i++ ) 
d336 1
a336 1
  for ( i=0; i<unfilteredSchedule.entries(); i++ ) {
d355 6
a360 6
   cerr <<"ERROR: LgFrDemandScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<endl;
   cerr <<"Base class does not allow mixing demand and part schedules" <<endl;
   cerr <<"This method is to be overriden in derived classes which" <<endl;
   cerr <<"support mixing demand and part schedules" <<endl;
   abort;
d381 2
a382 2
  independentSchedules_.insert(schedule);
  size_t n = independentSchedules_.entries();
d406 2
a407 1
  for ( size_t i=0; i<temp->independentSchedules_.entries(); i++ )  {
a425 8
// Return strategy identifier
isAReturnType
LgFrDemandScheduleSensitiveScheduleStrategy::isA()
const
{
   return id_;
}

a430 1
  assert( id_ == rhs.id_ );
d434 2
a435 1
     for ( size_t i=0; i<independentSchedules_.entries(); i++ ) 
d440 1
a440 1
     for ( i=0; i<rhs.independentSchedules_.entries(); i++ ) 
d456 2
a457 2
  assert( id_ == source.id_ );
  for ( size_t i=0; i<source.independentSchedules_.entries(); i++ ) 
d473 2
a474 2
  assert( id_ == source.id_ );
  for ( size_t i=0; i<source.independentSchedules_.entries(); i++ ) 
d496 1
a496 1
:  LgFrDemandScheduleStrategy( LgFrSetOfDemands(), NULL ),
d508 2
a509 1
  for ( size_t i=0; i<independentSchedules_.entries(); i++ ) 
d534 1
a534 3
  assert( cs1.id_ == __LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY );
  assert( cs1.independentSchedules_.entries() == 0 );
  assert( cs1.isA() == __LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY );
a557 1
  assert( cs2.isA() == __LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY );
d561 1
a561 1
  assert( cs2.independentSchedules_.entries() == 1 );
d565 1
a565 1
  assert( cs2.independentSchedules_.entries() == 2 );
a569 1
  assert( cs3.isA() == cs2.isA() );
a574 1
    assert( cs4Ptr->isA() == cs1.isA() );
d576 1
a576 1
            ->independentSchedules_.entries() == 1 );
d618 2
a619 1
      for (int i=0; i<supplySchedule->entries(); i++ ) 
d636 2
a637 3
  assert( scenCtor.id_ == __LGFRPARTSCHEDULESENSITIVESCHEDULESTRATEGY );
  assert( scenCtor.independentSchedules_.entries() ==  
               cs1.independentSchedules_.entries() );
a640 1
  assert( cs6Ptr->isA() == cs1.isA() );
d670 1
a670 1
    assert( cs8ptr->independentSchedules_.entries() == 2 );
d685 1
a685 3
  assert( cs1.id_ == __LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY );
  assert( cs1.independentSchedules_.entries() == 0 );
  assert( cs1.isA() == __LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY );
a708 1
  assert( cs2.isA() == __LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY );
d712 1
a712 1
  assert( cs2.independentSchedules_.entries() == 1 );
d716 1
a716 1
  assert( cs2.independentSchedules_.entries() == 2 );
a720 1
  assert( cs3.isA() == cs2.isA() );
a725 1
    assert( cs4Ptr->isA() == cs1.isA() );
d727 1
a727 1
            ->independentSchedules_.entries() == 1 );
d752 2
a753 3
  assert( scenCtor.id_ == __LGFRDEMANDSCHEDULESENSITIVESCHEDULESTRATEGY );
  assert( scenCtor.independentSchedules_.entries() ==  
               cs1.independentSchedules_.entries() );
a756 1
  assert( cs6Ptr->isA() == cs1.isA() );
@


1.2.6.1
log
@Roguewave is gone
@
text
@d1 1
a1 4
// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL -- inserted includes.
#include <iostream>
d28 1
a28 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=1;  i<schedules().size();  i++ ) 
d31 1
a31 1
                      (schedules()[i])->size()
d34 1
a34 1
  if (  schedule.filterStrategy().GetFSType() != __LGFRFILTERSTRATEGY )
d64 1
a64 1
  size_t len = schedules().size();
d75 1
a75 2
      size_t i = 0; // Pulled out of the for below by RW2STL
      for ( i=1;  i<len;  i++ ) 
d85 1
a85 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<unfilteredSchedule.size(); i++ ) {
d118 1
a118 1
   abort();
d132 2
a133 2
  independentSchedules_.push_back(schedule);
  size_t n = independentSchedules_.size();
d154 1
a154 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<temp->independentSchedules_.size(); i++ )  {
d171 8
d184 1
d188 1
a188 2
     size_t i = 0; // Pulled out of the for below by RW2STL
     for ( i=0; i<independentSchedules_.size(); i++ ) 
d193 1
a193 1
     for ( i=0; i<rhs.independentSchedules_.size(); i++ ) 
d211 2
a212 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
d229 2
a230 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
d258 1
a258 1
:  LgFrPartScheduleStrategy( sopForDefaultConstructor, 0 ),
d271 1
a271 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<independentSchedules_.size(); i++ ) 
d296 1
a296 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=1;  i<schedules().size();  i++ )
d299 1
a299 1
                      (schedules()[i])->size()
d302 1
a302 1
  if (  schedule.filterStrategy().GetFSType() != __LGFRFILTERSTRATEGY )
d327 1
a327 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<schedules().size(); i++ ) 
d334 1
a334 1
  for ( i=0; i<unfilteredSchedule.size(); i++ ) {
d358 1
a358 1
   abort();
d379 2
a380 2
  independentSchedules_.push_back(schedule);
  size_t n = independentSchedules_.size();
d404 1
a404 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<temp->independentSchedules_.size(); i++ )  {
d423 8
d436 1
d440 1
a440 2
     size_t i = 0; // Pulled out of the for below by RW2STL
     for ( i=0; i<independentSchedules_.size(); i++ ) 
d445 1
a445 1
     for ( i=0; i<rhs.independentSchedules_.size(); i++ ) 
d461 2
a462 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
d478 2
a479 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<source.independentSchedules_.size(); i++ ) 
d501 1
a501 1
:  LgFrDemandScheduleStrategy( LgFrSetOfDemands(), 0 ),
d513 1
a513 2
  size_t i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<independentSchedules_.size(); i++ ) 
d538 3
a540 1
  assert( cs1.independentSchedules_.size() == 0 );
d564 1
d568 1
a568 1
  assert( cs2.independentSchedules_.size() == 1 );
d572 1
a572 1
  assert( cs2.independentSchedules_.size() == 2 );
d577 1
d583 1
d585 1
a585 1
            ->independentSchedules_.size() == 1 );
d627 1
a627 2
      int i = 0; // Pulled out of the for below by RW2STL
      for (i=0; i<supplySchedule->size(); i++ ) 
d644 3
a646 2
  assert( scenCtor.independentSchedules_.size() ==  
               cs1.independentSchedules_.size() );
d650 1
d680 1
a680 1
    assert( cs8ptr->independentSchedules_.size() == 2 );
d695 3
a697 1
  assert( cs1.independentSchedules_.size() == 0 );
d721 1
d725 1
a725 1
  assert( cs2.independentSchedules_.size() == 1 );
d729 1
a729 1
  assert( cs2.independentSchedules_.size() == 2 );
d734 1
d740 1
d742 1
a742 1
            ->independentSchedules_.size() == 1 );
d767 3
a769 2
  assert( scenCtor.independentSchedules_.size() ==  
               cs1.independentSchedules_.size() );
d773 1
@


1.2.6.2
log
@Removed STD_CPP_LIB #ifdefs
and went to std for cout
@
text
@d119 5
a123 5
   std::cerr <<"ERROR: LgFrPartScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<std::endl;
   std::cerr <<"Base class does not allow mixing demand and part schedules" <<std::endl;
   std::cerr <<"This method is to be overriden in derived classes which" <<std::endl;
   std::cerr <<"support mixing demand and part schedules" <<std::endl;
d355 5
a359 5
   std::cerr <<"ERROR: LgFrDemandScheduleSensitiveScheduleStrategy::insertDemandSchedule"
        <<std::endl;
   std::cerr <<"Base class does not allow mixing demand and part schedules" <<std::endl;
   std::cerr <<"This method is to be overriden in derived classes which" <<std::endl;
   std::cerr <<"support mixing demand and part schedules" <<std::endl;
@


1.1
log
@Initial revision
@
text
@d242 1
a242 1
   combiningFunction_(LgFrTimeVecFloat::add),
d260 1
a260 1
   combiningFunction_(LgFrTimeVecFloat::add),
d613 1
a613 1
      cs1.combiningFunction (LgFrTimeVecFloat::subtract);
@


1.1.1.1
log
@Import scenario
@
text
@@

head	1.4;
access;
symbols
	sce_5_01_20080919:1.3
	latest_sce_4_20_20060523:1.3.0.6
	sce_4_20_20060523:1.3
	latest_sce4_20_OSL:1.3.0.4
	sce_4_20_OSL:1.3
	sce_4_05_20040511:1.3
	sce_4_00_20040201:1.3
	nextGenBranch:1.3.0.2
	nextGenRoot:1.3
	sce_3_30_20030627:1.3
	EndRw-branch:1.1.1.1.0.14
	Root-of-EndRw:1.1.1.1
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2010.04.20.14.31.16;	author ervolina;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.15.23.05.46;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.15.19.36.28;	author rwToStl;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.15.29.36;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.15.29.36;	author wit;	state Exp;
branches
	1.1.1.1.14.1;
next	;

1.1.1.1.14.1
date	2003.01.08.17.42.25;	author rwToStl;	state Exp;
branches;
next	1.1.1.1.14.2;

1.1.1.1.14.2
date	2003.01.09.13.54.43;	author rwToStl;	state Exp;
branches;
next	1.1.1.1.14.3;

1.1.1.1.14.3
date	2003.01.09.19.28.00;	author rwToStl;	state Exp;
branches;
next	1.1.1.1.14.4;

1.1.1.1.14.4
date	2003.01.14.19.05.41;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.4
log
@new function to support variablePeriods in SCE
@
text
@// RW2STL -- inserted:

#if defined(_MSC_VER)
#pragma warning(disable:4786)
#endif

#include <scenario/src/RWToSTLHelpers.h>
#include <string>
#include <sstream>
// End of RW2STL -- inserted includes.
// file: calendar.C
// author: tom

#include <stdlib.h>
#include <assert.h>
#include <scenario/src/calendar.h>

// fairly general constructor:
LgFrCalendar::LgFrCalendar(
	     size_t   nPeriods,
	     const LgFrDatetime&  horizonStart,
	     LgFrTimeUnit intervalUnit,
	     unsigned intervalUnitMultiplier)
: nPeriods_(nPeriods),
  startTimes_(),
  effectiveStartTimes_(),
  workUnits_(),
  intervalUnit_(intervalUnit),
  intervalUnitMultiplier_(intervalUnitMultiplier)
{
  if (nPeriods == 0) return;

  initializeOrderedVectors();
  
  // set first period
  startTimes_[0] = horizonStart;
  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nPeriods_; i++) {
    switch (intervalUnit_)  {
    case LgFrWeek:
      startTimes_[i+1] = startTimes_[i].plusWeeks( intervalUnitMultiplier );
      break;
    case LgFrDay:
      startTimes_[i+1] = startTimes_[i].plusDays( intervalUnitMultiplier );
      break;
    case LgFrMonth:
      startTimes_[i+1] = startTimes_[i].plusMonths( intervalUnitMultiplier );
      break;
    case LgFrHour:
      startTimes_[i+1] = startTimes_[i].plusHours( intervalUnitMultiplier );
      break;
    case LgFrMinute:
      startTimes_[i+1] = startTimes_[i].plusMinutes( intervalUnitMultiplier );
      break;
    case LgFrSecond:
      startTimes_[i+1] = startTimes_[i].plusSeconds( intervalUnitMultiplier );
      break;
    case LgFrQuarter:
      startTimes_[i+1] = startTimes_[i].plusQuarters( intervalUnitMultiplier );
      break;
    default:
      break;
    }
    LgFrDatetime dt = startTimes_[i+1];

    assert(startTimes_[i+1].isValid());
  }
  this->effectivePeriodStart();
}

// a more than fairly general constructor.
// This constructor takes a vector of periodStartTimes.
// Note: This vector must have length nPeriods+1.
//       The last entry is the starting time of what would be the next period.
//       This is used to calculate the size of the last period.
// The intervalUnit and intervalUnit multiplier seem to only be used if the
// number of periods in the calendar is increased.
LgFrCalendar::LgFrCalendar(
	     size_t   nPeriods,
	     const LgFrDatetimeVector&  periodStartTimes,
	     LgFrTimeUnit intervalUnit,
	     unsigned intervalUnitMultiplier)
: nPeriods_(nPeriods),
  startTimes_(),
  effectiveStartTimes_(),
  workUnits_(),
  intervalUnit_(intervalUnit),
  intervalUnitMultiplier_(intervalUnitMultiplier)
{
  if (nPeriods == 0) return;

  initializeOrderedVectors();
  
  // set period start times
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<=nPeriods_; i++) {    
    assert(periodStartTimes[i].isValid());
    startTimes_[i] = periodStartTimes[i];
  }
    
  this->effectivePeriodStart();
}


 // resize the calendar.  If you make it smaller, it gets
 // truncated.  If it gets bigger, then the extra periods
 // will have garbage in them.  In general, this makes the calendar
 // invalid.
void
LgFrCalendar::nPeriods(size_t nPeriods)
{
  // remember the old nPeriods
  size_t oldNPeriods = nPeriods_;


  nPeriods_ = nPeriods;
  
  // if its bigger, then fix!
  if (oldNPeriods < nPeriods)  {

      // insert new elements (ie, resize the vectors)
      LgFrDatetime aTime;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=oldNPeriods-1; t<nPeriods; t++)  {
	  startTimes_.push_back(aTime);
	  effectiveStartTimes_.push_back(aTime);
	  workUnits_.push_back(1.0);
      }
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);

    // fix the startDates.
    for (t=oldNPeriods-1; t<nPeriods_; t++) {
      switch (intervalUnit_)  {
        case LgFrWeek:
          startTimes_[t+1] = startTimes_[t].plusWeeks( nPeriods );
          break;
        case LgFrDay:
          startTimes_[t+1] = startTimes_[t].plusDays( nPeriods );
          break;
        case LgFrMonth:
          startTimes_[t+1] = startTimes_[t].plusMonths( nPeriods );
          break;
        case LgFrHour:
          startTimes_[t+1] = startTimes_[t].plusHours( nPeriods );
          break;
        case LgFrMinute:
          startTimes_[t+1] = startTimes_[t].plusMinutes( nPeriods );
          break;
        case LgFrSecond:
          startTimes_[t+1] = startTimes_[t].plusSeconds( nPeriods );
          break;
        case LgFrQuarter:
          startTimes_[t+1] = startTimes_[t].plusQuarters( nPeriods );
          break;
        default:
        break;
      }
      
      assert(startTimes_[t+1].isValid());
    }

    // set the workUnits to whatever they were in the last period
    for (t=oldNPeriods; t<nPeriods_; t++)
       workUnits_[t] = workUnits_[t-1];
  }
  this->effectivePeriodStart();
}

// get the nPeriods
size_t
LgFrCalendar::nPeriods()
     const
{
  return nPeriods_;
}

  // check the validity of the calendar:
bool
LgFrCalendar::isValid()
const
{
  // 0 periods is inValid
  if (nPeriods_ == 0) return false;
  

  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nPeriods_; i++) {
      // make sure each startTime is valid
      if (! startTimes_[i].isValid()) return false;
      if (! effectiveStartTimes_[i].isValid()) return false;

      // make sure period startTimes are increasing
      if (startTimes_[i] > startTimes_[i+1]) return false;
      if (effectiveStartTimes_[i] > effectiveStartTimes_[i+1]) return false;

      // make sure effectiveStarts are at least as early
      // as starts
      if (effectiveStartTimes_[i] > startTimes_[i]) return false;

    }

  if (! startTimes_[nPeriods_].isValid()) return false;
  if (! effectiveStartTimes_[nPeriods_].isValid()) return false;
  if (effectiveStartTimes_[nPeriods_] > startTimes_[nPeriods_]) return false;

  return true;
}  
  
 // set the start date/time of a period
void
LgFrCalendar::periodStart(size_t period, const LgFrDatetime& startTime)
{
  assert (period < nPeriods_);
  assert(startTime.isValid());
  startTimes_[period] = startTime;
  this->effectivePeriodStart();
}
  
  // get the start date/time of a period
LgFrDatetime
LgFrCalendar::periodStart(size_t period)
const
{
  assert (period < nPeriods_);
  return startTimes_[period];
}

// set the number of workTime units of a period
void
LgFrCalendar::workUnits(size_t period, float workAmt)
{
   assert (period < nPeriods_);
   workUnits_[period] = workAmt;
 }

// get the number of workTime units of a period
float
LgFrCalendar::workUnits(size_t period)
const
{
  assert (period < nPeriods_);
  return workUnits_[period];
}


// set/get the end of Last Period Date/Time
LgFrDatetime
LgFrCalendar::horizonEnd()
     const
{
  return startTimes_[nPeriods_];
}  

void
LgFrCalendar::horizonEnd(const LgFrDatetime& theEnd)
{
  assert (theEnd.isValid());
  startTimes_[nPeriods_] = theEnd;
  this->effectivePeriodStart();
}

// set/get the interval unit identifier
LgFrTimeUnit
LgFrCalendar::timeUnitType()
     const
{
  return intervalUnit_;
}

void
LgFrCalendar::timeUnitType(LgFrTimeUnit intervalUnit)
{
  intervalUnit_ = intervalUnit;
}

// set/get the interval unit multiplier
unsigned
LgFrCalendar::intervalUnitMultiplier()
       const
{
  return intervalUnitMultiplier_;
}

void
LgFrCalendar::intervalUnitMultiplier(unsigned intervalUnitMultiplier)
{
  intervalUnitMultiplier_ = intervalUnitMultiplier;
}

void
LgFrCalendar::display()
const
{
   std::cout << "\nCalendar Display\n"; 
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i < this->nPeriods(); i++) 
      std::cout << "Period " << i << ": " << this->periodStart(i).getDateAsString() << "\n";
}

// Return the period in which a specified Date/Time falls.
// Returned values:
//     0 <= nPeriods()-1   ==> date is within the horizon
//     -1                  ==> date is earlier than period 0
//     nPeriods()          ==> date is later than the end of the horizon
int
LgFrCalendar::period(const LgFrDatetime& aTime)
const
{
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<=nPeriods_; i++)  {
	if (aTime < startTimes_[i])
	    return i-1;
    }

  return nPeriods_;
}
 


// This routine is similar to period() except that it rounds to the 
// nearest period start date.  For example, if the PeriodStarts are
// 1/1/95, 2/1/95, and you enter 1/27/95, then it will return the 
// period for 2/1/95, since your target is more than halfway thru the
// the period.
//
//  Returns  k  such that:
//
//  startTime[k-1] + 1/2 length(k-1) <= aTime < startTime[k] + 1/2 * length(k)
//  and   -1 <= k <= nPeriods
//  
//  where:
//     length[k] is interpreted as the length of period k,
//     length[-1] = length[0],
//     length[nPeriods] = length[nPeriods - 1]
//     and startTime[-1] is interpreted as startTime[0] - length[0]
int 
LgFrCalendar::roundedPeriod(const LgFrDatetime& aTime)
const
{

    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<=nPeriods_; i++)   {
	if (aTime < effectiveStartTimes_[i])
	    return i-1;
	}

    // if aTime >= effectiveStartTimes_[nPeriods_]
    return nPeriods_;
}






// Translate (and round) a date into a period for purposes of 
// earlyEffectivePeriod effectivity records.
// Returns a value k, 0 <= k <= nPeriods
int 
LgFrCalendar::earlyEffectivePeriod(const LgFrDatetime& aTime)
const
{
    int early = this->roundedPeriod(aTime);
    if (early == -1)
	return 0;
    else
	return early;
}


// Translate (and round) a date into a period for purposes of 
// early effectivity records.
// Returns a value k, -1 <= k <= nPeriods - 1
int 
LgFrCalendar::lateEffectivePeriod(const LgFrDatetime& aTime)
const
{
    int late = this->roundedPeriod(aTime) - 1;
    if (late == -2)
	return -1;
    else 
	return late;
}


 // set the effective start date/time for all periods
void
LgFrCalendar::effectivePeriodStart()
{
// first consider period 0
    long diff = startTimes_[1].getValue() - startTimes_[0].getValue();
    long halfPeriodLength = diff/2;
    if (halfPeriodLength > startTimes_[0].getValue())
	    effectiveStartTimes_[0] = LgFrDatetime((unsigned long) 0);
    else 
	    effectiveStartTimes_[0] = startTimes_[0] - halfPeriodLength;

// Now do periods 1 to nPeriods_
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<nPeriods_; i++)   {
	    diff = startTimes_[i+1].getValue() - startTimes_[i].getValue();
	    halfPeriodLength = diff/2;
	    effectiveStartTimes_[i+1] = startTimes_[i+1] - halfPeriodLength;
    }

}

// Initialize ordered vector.
// This is used by constructors.
void
LgFrCalendar::initializeOrderedVectors()
{
  LgFrDatetime aTime;
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods_; t++)  {
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);
      workUnits_.push_back(1.0);
  }
  startTimes_.push_back(aTime);
  effectiveStartTimes_.push_back(aTime);
}


float
LgFrCalendar::numWorkingDaysInPeriodOverInterval(int period, 
						 const LgFrDatetime & intervalStart, 
						 const LgFrDatetime & intervalEnd)   
const
{
  LgFrDatetime tStart = this->periodStart(period);
  LgFrDatetime tEnd;
  if (period == this->nPeriods() - 1)
    tEnd = this->horizonEnd();
  else
    tEnd = this->periodStart(period + 1);
  
  // exclusive completely
  if ((intervalStart >= tEnd) || (intervalEnd <=  tStart))
    return 0.0;
  
  // inclusive completely 
  if ( (intervalStart <= tStart) && (tEnd <=  intervalEnd))
    return this->workUnits(period);

  // inclusiveEarly && exclusiveLate
  if ( (intervalStart <= tStart)  && (tEnd > intervalEnd) )  {
    long periodOverLap = intervalEnd.getValue() - tStart.getValue();
    long periodLength = tEnd.getValue() - tStart.getValue();
    float periodOverLapFraction = (float) periodOverLap / (float) periodLength;
    return  (this->workUnits(period) * periodOverLapFraction);
  }    

  // exclusiveEarly && inclusiveLate
  if ( (intervalStart > tStart)  && (tEnd <= intervalEnd) )  {
    long periodOverLap = tEnd.getValue() - intervalStart.getValue();
    long periodLength = tEnd.getValue() - tStart.getValue();
    float periodOverLapFraction = (float) periodOverLap / (float) periodLength;
    return  (this->workUnits(period) * periodOverLapFraction);
  }    

  // inclusiveEarly && inclusiveLate
  if ( (intervalStart > tStart)  && (tEnd > intervalEnd) )  {
    long periodOverLap = intervalEnd.getValue() - intervalStart.getValue();
    long periodLength = tEnd.getValue() - tStart.getValue();
    float periodOverLapFraction = (float) periodOverLap / (float) periodLength;
    return  (this->workUnits(period) * periodOverLapFraction);
  }    

  // anything else is an error
  assert(1 == 0);
  return 0.0;


}

// calendar utility to convert a std::string date in the form
// "YYYYMMDD" to a LgFrDatetime and vice versa.
// NOTE:  the method does NOT check the date validity  you should
// check the returned LgFrDatetime with isValid()
// NOTE 2: With the new LgFrDatetime (jan '03) that directly 
// supports the YYYYMMDD format, these have been greatly trivialized.
LgFrDatetime
LgFrCalendar::yyyymmdd(const std::string & aDateString)
const
{
    return LgFrDatetime( aDateString );
}


std::string
LgFrCalendar::yyyymmdd(const LgFrDatetime & aDate)
const
{
    return aDate.getDateAsString( "%Y%m%d" );
}

    
// Return a copy in the heap
LgFrCalendar*
LgFrCalendar::clone()
     const
{
  return new LgFrCalendar(*this);
}

// Format a LgFrCalendar into a std::string.
// Return a std::string representing the calendar, in the format specified by the formatStyle.
//
// width: ios width used to format each number in vector.
//
// precision: ios precision used to format each number in vector.
//
// iosFlags: ios formating flags used to format each number in vector.
//
std::string
LgFrCalendar::format( 
		      const LgFrCalendarFormatStyle formatStyle )
const
{

    std::string retVal;

    if (formatStyle == TimeVecPeriodStarts)  {

	    int x = 0; // Pulled out of the for below by RW2STL
	    for (x = 0; x < nPeriods_; x++ ){
            retVal += periodStart(x).getDateAsString();
            retVal += ' ';
        }
    }
    else {
	    std::cerr << "LgFrCalendar::format.  Unrecognized format style.\n";
	    abort();
    }
    return retVal;

};



// ----- Default Constructors -------

// default constructor 8 periods ==> weekly buckets starting 8/1/95 
LgFrCalendar::LgFrCalendar()
: nPeriods_(8),
  startTimes_(),
  effectiveStartTimes_(),
  workUnits_(),
  intervalUnit_(LgFrWeek),
  intervalUnitMultiplier_(1)
{

// initialize the Ordered Vectors
  LgFrDatetime aTime;
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods_; t++)  {
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);
      workUnits_.push_back(1.0);
  }
  startTimes_.push_back(aTime);
  effectiveStartTimes_.push_back(aTime);

  // set first period
  LgFrDatetime dt;
  dt.setDate( 8, 1, 1995 );
  startTimes_[0] = dt;
  
  for (t=0; t<nPeriods_; t++) 
    startTimes_[t+1] = LgFrDatetime(startTimes_[t]) + 7;
  
  // set the effectiveStartTimes_
  this->effectivePeriodStart();

  assert(this->isValid());
}

 // copy constructor
LgFrCalendar::LgFrCalendar(const LgFrCalendar& source)
: nPeriods_(source.nPeriods_),
  startTimes_(source.startTimes_),
  effectiveStartTimes_(source.effectiveStartTimes_),
  workUnits_(source.workUnits_),
  intervalUnit_(source.intervalUnit_),
  intervalUnitMultiplier_(source.intervalUnitMultiplier_)
{
  // nothing to do
}

// assignment operator
LgFrCalendar&
LgFrCalendar::operator=(const LgFrCalendar& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
    nPeriods_ = rhs.nPeriods_;
    startTimes_ = rhs.startTimes_;
    effectiveStartTimes_ = rhs.effectiveStartTimes_;
    workUnits_ = rhs.workUnits_;
    intervalUnit_ = rhs.intervalUnit_;
    intervalUnitMultiplier_ = rhs.intervalUnitMultiplier_;
  }
  return *this;
}

// destructor
LgFrCalendar::~LgFrCalendar()
{
  // nothing to do
}




#ifdef NDEBUG
#undef NDEBUG
#endif
// self-test
void
LgFrCalendar::test()
{

    assert( LgFrDatetime::unitTest() ); // Added Jan '03

    LgFrCalendarFormatStyle formatStyle = TimeVecPeriodStarts;

    LgFrCalendar myCal1 (6, LgFrDatetime("7/15/94"), LgFrMonth, 2);
    assert(myCal1.nPeriods() == 6);
    assert(myCal1.isValid());


    LgFrCalendar myCal2(9,                                       
			LgFrDatetime("12/30/94"),
			LgFrHour,
			8);

    assert(myCal2.isValid());


    LgFrCalendar myCal3(24,                                      
			LgFrDatetime("12/31/94"),
			LgFrMonth,
			1);

    assert(myCal3.isValid());

    // set period 1 to be earlier than period 0
    // and check for inValid.
    LgFrDatetime aNewTime (LgFrDatetime("12/15/94"));
    myCal3.periodStart(1, aNewTime);
    assert (aNewTime == myCal3.periodStart(1));
    assert (myCal3.isValid() == false);

    // set period 1 to be valid again
    myCal3.periodStart(1, LgFrDatetime("1/15/95"));
    assert(myCal3.isValid());

    // set horizon end to be earlier than period 0
    LgFrDatetime anEndTime (LgFrDatetime("12/15/93"));
    myCal3.horizonEnd(anEndTime);
    assert(anEndTime == myCal3.horizonEnd());

    // fix it
    LgFrDatetime goodEndTime (LgFrDatetime("12/15/99"));
    myCal3.horizonEnd(goodEndTime);
    assert(goodEndTime == myCal3.horizonEnd());
    assert (myCal3.isValid());

    assert (myCal3.period(goodEndTime) == myCal3.nPeriods());
    assert (myCal3.period(LgFrDatetime("1/16/95"))  ==  1);
    assert (myCal3.period(LgFrDatetime("1/14/94"))  == -1);
    assert (myCal3.period(LgFrDatetime("12/31/94")) ==  0);

    // myCal3.display();


    LgFrCalendar myCal4(64,                                      
			LgFrDatetime("1/1/94"),
			LgFrMonth,
			1);

    assert(myCal4.isValid());

    // increase to 12 periods and check
    myCal4.nPeriods(12);
    assert(myCal4.isValid());
    myCal4.display();
  
    // now do some funky stuff ...
    // set unitType to quarters and extend the calendar
    myCal4.timeUnitType(LgFrQuarter);
    myCal4.nPeriods(16);
    assert(myCal4.isValid());
    myCal4.display();

    LgFrCalendar myCal5(12,                                      
			LgFrDatetime("1/1/94"),
			LgFrMonth,
			1);

    assert(myCal5.isValid());

    assert(myCal5.roundedPeriod(LgFrDatetime("1/16/94")) == 0);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/17/94")) == 1);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/25/93")) == 0);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/11/93")) == -1);
    assert(myCal5.roundedPeriod(LgFrDatetime("5/25/94")) == 5);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/14/94")) == 11);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/25/94")) == 12);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/10/95")) == 12);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/20/95")) == 12);

    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("5/25/94")) == 5);
    assert(myCal5.lateEffectivePeriod( LgFrDatetime("5/25/94")) == 4);

    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("12/25/93")) == 0);
    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("12/25/91")) == 0);

    assert(myCal5.lateEffectivePeriod( LgFrDatetime("1/12/95")) == 11);
    assert(myCal5.lateEffectivePeriod( LgFrDatetime("1/25/95")) == 11);

    // happy new year!
    LgFrDatetime date1( "1/1/1995" );
    assert("19950101" == myCal5.yyyymmdd(date1));
    assert(date1 == myCal5.yyyymmdd("19950101"));

    // merry christmas
    LgFrDatetime date2( "12/25/1995" );
    assert("19951225" == myCal5.yyyymmdd(date2));
    assert(date2 == myCal5.yyyymmdd("19951225"));

    //Test the format method
    std::cout << "Testing the format method." << std::endl;

    std::cout << "The following should display a 1 month period, starting 1/1/96" << std::endl;
    LgFrCalendar formatCal1(1,                                     
			    LgFrDatetime("1/1/96"),
			    LgFrMonth,
			    1);
    std::cout << formatCal1.format(formatStyle) << std::endl;

    std::cout << "The following should display a 12 month period, starting 1/1/96 with a one month interval." << std::endl;
    LgFrCalendar formatCal2(12,                                     
			    LgFrDatetime("1/1/96"),
			    LgFrMonth,
			    1);
    std::cout << formatCal2.format(formatStyle) << std::endl;

    std::cout << "The following should display a 12 second periods, which should display the same date 12 times. 1/1/96" << std::endl;
    LgFrCalendar formatCal3(12,                                     
			    LgFrDatetime("1/1/96"),
			    LgFrSecond,
			    5);
    std::cout << formatCal3.format(formatStyle) << std::endl;

    std::cout << "The following should display a 12 minute periods, starting 1/1/96, which should display the same date, 12 times. 1/1/96." << std::endl;
    LgFrCalendar formatCal4(12,                                     
			    LgFrDatetime("1/1/96"),
			    LgFrMinute,
			    5);
    std::cout << formatCal4.format(formatStyle) << std::endl;

    std::cout << "The following should display 6 quarters, starting 1/1/96" << std::endl;
    LgFrCalendar formatCal5(6,                                     
			    LgFrDatetime("1/1/96"),
			    LgFrQuarter,
			    1);
    std::cout << formatCal5.format(formatStyle) << std::endl;

    // Test new constructor
    {
      LgFrDatetimeVector timeVec(4);
      timeVec[0]=LgFrDatetime("6/24/96");
      timeVec[1]=LgFrDatetime("7/2/96");
      timeVec[2]=LgFrDatetime("7/8/96");
      timeVec[3]=LgFrDatetime("8/5/96");
      LgFrCalendar cal(3,timeVec);
      std::cout << cal.format(formatStyle) << std::endl;
    }  
}


@


1.3
log
@Modified to build on windows laptop that was causing compiler to run out of stack space
@
text
@d427 52
@


1.2
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d2 5
@


1.1
log
@Initial revision
@
text
@d1 5
a8 7

#if defined (WIN32) || defined (__OS2__) || defined (__WINDOWS__)
#include <strstrea.h>
#else
#include <strstream.h>
#endif

a11 1
#include <rw/rstream.h>
d16 1
a16 1
	     const RWTime&  horizonStart,
d33 2
a34 1
  for (int i=0; i<nPeriods_; i++) {
d37 1
a37 1
      startTimes_[i+1] = RWDate(startTimes_[i]) + (7 * intervalUnitMultiplier);
d40 1
a40 1
      startTimes_[i+1] = RWDate(startTimes_[i]) + (1 * intervalUnitMultiplier);
d43 1
a43 2
      startTimes_[i+1] = addMonths(startTimes_[i], intervalUnitMultiplier,
                                   RWDate(startTimes_[0]).dayOfMonth());
d46 1
a46 1
      startTimes_[i+1] = startTimes_[i] + (3600 * intervalUnitMultiplier);
d49 1
a49 1
      startTimes_[i+1] = startTimes_[i] + (60 * intervalUnitMultiplier);
d52 1
a52 1
      startTimes_[i+1] = startTimes_[i] + (1 * intervalUnitMultiplier);
d55 1
a55 3
      startTimes_[i+1] = addMonths(startTimes_[i],
                                   3 * intervalUnitMultiplier,
                                   RWDate(startTimes_[0]).dayOfMonth());
d60 2
a61 1
    
d76 1
a76 1
	     const LgFrVectorRWTime&  periodStartTimes,
d91 2
a92 1
  for (int i=0; i<=nPeriods_; i++) {    
a100 25
// increment the period to the same day of the next month.  However, check
// to see that you don't go from, say, Jan 31 to Feb 31.  In this case,
// "rewind" to the last day of the month (ie, Feb 28 or Feb 29 if leapYear)
RWTime
LgFrCalendar::addMonths(const RWTime& aTime, unsigned numMonthsOut,
			unsigned newDay)
const
{
  unsigned newMonth = (RWDate(aTime)).month() + numMonthsOut;
  unsigned newYear  =  (RWDate(aTime)).year();
  if (newMonth > 12) {
     newYear += newMonth / 12;
     newMonth = newMonth % 12;
     if (newMonth == 0) newMonth = 12;
  }
			
  while (RWDate::dayWithinMonth(newMonth, newDay, newYear) == FALSE) {
     assert (newDay > 0);
     newDay--;
  }
  assert (RWDate(newDay, newMonth, newYear).isValid());
  return RWTime(RWDate(newDay, newMonth, newYear));
}

  
d118 6
a123 5
      RWTime aTime;
      for (int t=oldNPeriods-1; t<nPeriods; t++)  {
	  startTimes_.insert(aTime);
	  effectiveStartTimes_.insert(aTime);
	  workUnits_.insert(1.0);
d125 2
a126 2
      startTimes_.insert(aTime);
      effectiveStartTimes_.insert(aTime);
d131 22
a152 25
      case LgFrWeek:
        startTimes_[t+1] = RWDate(startTimes_[t]) + (7 * intervalUnitMultiplier_);
        break;
      case LgFrDay:
        startTimes_[t+1] = RWDate(startTimes_[t]) + (1 * intervalUnitMultiplier_);
        break;
      case LgFrMonth:
        startTimes_[t+1] = addMonths(startTimes_[t], intervalUnitMultiplier_,
                                     RWDate(startTimes_[0]).dayOfMonth());
        break;
      case LgFrHour:
        startTimes_[t+1] = startTimes_[t] + (3600 * intervalUnitMultiplier_);
        break;
      case LgFrMinute:
        startTimes_[t+1] = startTimes_[t] + (60 * intervalUnitMultiplier_);
        break;
      case LgFrSecond:
        startTimes_[t+1] = startTimes_[t] + (1 * intervalUnitMultiplier_);
        break;
      case LgFrQuarter:
        startTimes_[t+1] = addMonths(startTimes_[t],
                                     3 * intervalUnitMultiplier_,
                                     RWDate(startTimes_[0]).dayOfMonth());
        break;
      default:
d175 1
a175 1
RWBoolean
d180 1
a180 1
  if (nPeriods_ == 0) return FALSE;
d183 2
a184 1
  for (int i=0; i<nPeriods_; i++) {
d186 2
a187 2
      if (! startTimes_[i].isValid()) return FALSE;
      if (! effectiveStartTimes_[i].isValid()) return FALSE;
d190 2
a191 2
      if (startTimes_[i] > startTimes_[i+1]) return FALSE;
      if (effectiveStartTimes_[i] > effectiveStartTimes_[i+1]) return FALSE;
d195 1
a195 1
      if (effectiveStartTimes_[i] > startTimes_[i]) return FALSE;
d199 3
a201 3
  if (! startTimes_[nPeriods_].isValid()) return FALSE;
  if (! effectiveStartTimes_[nPeriods_].isValid()) return FALSE;
  if (effectiveStartTimes_[nPeriods_] > startTimes_[nPeriods_]) return FALSE;
d203 1
a203 1
  return TRUE;
d208 1
a208 1
LgFrCalendar::periodStart(size_t period, const RWTime& startTime)
d217 1
a217 1
RWTime
d244 1
a244 1
RWTime
d252 1
a252 1
LgFrCalendar::horizonEnd(const RWTime& theEnd)
d291 4
a294 3
   cout << "\nCalendar Display\n"; 
   for (int i=0; i < this->nPeriods(); i++) 
      cout << "Period " << i << ": " << this->periodStart(i) << "\n";
d303 1
a303 1
LgFrCalendar::period(const RWTime& aTime)
d306 2
a307 1
    for (int i=0; i<=nPeriods_; i++)  {
d334 1
a334 1
LgFrCalendar::roundedPeriod(const RWTime& aTime)
d338 2
a339 1
    for (int i=0; i<=nPeriods_; i++)   {
d357 1
a357 1
LgFrCalendar::earlyEffectivePeriod(const RWTime& aTime)
d372 1
a372 1
LgFrCalendar::lateEffectivePeriod(const RWTime& aTime)
d388 1
a388 1
    long diff = startTimes_[1].seconds() - startTimes_[0].seconds();
d390 2
a391 2
    if (halfPeriodLength > startTimes_[0])
	effectiveStartTimes_[0] = RWTime((unsigned long) 0);
d393 1
a393 1
	effectiveStartTimes_[0] = startTimes_[0] - halfPeriodLength;
d396 5
a400 4
    for (int i=0; i<nPeriods_; i++)   {
	diff = startTimes_[i+1].seconds() - startTimes_[i].seconds();
	halfPeriodLength = diff/2;
	effectiveStartTimes_[i+1] = startTimes_[i+1] - halfPeriodLength;
d410 6
a415 5
  RWTime aTime;
  for (int t=0; t<nPeriods_; t++)  {
      startTimes_.insert(aTime);
      effectiveStartTimes_.insert(aTime);
      workUnits_.insert(1.0);
d417 2
a418 2
  startTimes_.insert(aTime);
  effectiveStartTimes_.insert(aTime);
d422 2
a423 2
// calendar utility to convert a RWCString date in the form
// "YYYYMMDD" to a RWDate and vice versa.
d425 5
a429 51
// check the returned RWDate with isValid()
RWDate
LgFrCalendar::yyyymmdd(const RWCString & aDateString)
const
{
    long day = 0;
    long month = 0;
    long year = 0;

// parse the string 
    RWLocale::global().stringToNum(aDateString(0,4), &year);
    RWLocale::global().stringToNum(aDateString(4,2), &month);
    RWLocale::global().stringToNum(aDateString(6,2), &day);
    
    RWDate theDate(
	(unsigned) day,
	(unsigned) month,
	(unsigned) year);

    return theDate;
}


RWCString
LgFrCalendar::yyyymmdd(const RWDate & aDate)
const
{
    // initialize the string with the year (which should always be 4 digits)
    RWCString aDateString(RWLocale::global().asString((unsigned long) aDate.year()));

    // append the month (with a leading zero if its only one digit)
    if (aDate.month() < 10)
	aDateString.append("0");
    aDateString.append(RWLocale::global().asString((unsigned long) aDate.month()));

    // append the day (with a leading zero if its only one digit)
    if (aDate.dayOfMonth() < 10)
	aDateString.append("0");
    aDateString.append(RWLocale::global().asString((unsigned long) aDate.dayOfMonth()));

    return aDateString;

}

#if 0
// calendar utility to convert a RWCString date in the form
// "ddmonyy" to a RWDate and vice versa.
// NOTE:  the method does check the date validity  you should
// check the returned RWDate with isValid()
RWDate
LgFrCalendar::ddmonyy(const RWCString & aDateString)
d432 1
a432 6
    tm tmDate;

    RWLocale::global().stringToDate( aDateString, &tmDate );
    RWDate theDate( &tmDate );

    return theDate;
d436 2
a437 2
RWCString
LgFrCalendar::ddmonyy(const RWDate & aDate)
d440 1
a440 23
    long year = 0;

    // initialize string with day (2 digits with leading "0" if needed)
    RWCString aDateString;

    if (aDate.dayOfMonth() < 10)
      aDateString.append("0");
    aDateString.append
      (RWLocale::global().asString((unsigned long) aDate.dayOfMonth()));

    // append the three character text for the month name
    aDateString.append
      ( (aDate.monthName(RWLocale::global()))(0,3) );

    // turn the year into a 4-char string, to get the last 2 chars.
    RWCString aYear =
      (RWLocale::global().asString((unsigned long) aDate.year()));

    aDateString.append
      (aYear(2,2));

    return aDateString;

a441 1
#endif
d452 2
a453 2
// Format a LgFrCalendar into a RWCString.
// Return a RWCString representing the calendar, in the format specified by the formatStyle.
d461 1
a461 1
RWCString
d463 1
a463 4
		      const LgFrCalendarFormatStyle formatStyle,
		      const int width,
		      const int precision,
		      const long iosFlags )
d467 1
a467 3

    const RWLocale & thisLocality = RWLocale::global();
    RWCString retVal;
d471 5
a475 22
	ostrstream buf;
	buf.precision(precision);
	buf.setf( iosFlags );


	for (int x = 0; x < nPeriods_; x++ ){
	    buf.width( width );
	    buf
// #if CUSTOMER_NUMBER == MOOGS_NUMBER
// 	      <<  this->ddmonyy( RWDate(this->periodStart(x)) )
// #else
	      <<  RWDate(this->periodStart(x)).asString('x', thisLocality) 
// #endif
	      << ' ';
	};

	buf << ends;
	char *bufPtr = buf.str();

	retVal = bufPtr;

	delete bufPtr;
d477 3
a479 3
    else{
	cerr << "LgFrCalendar::format.  Unrecognized format style." << endl;
	abort();
d500 6
a505 5
  RWTime aTime;
  for (int t=0; t<nPeriods_; t++)  {
      startTimes_.insert(aTime);
      effectiveStartTimes_.insert(aTime);
      workUnits_.insert(1.0);
d507 2
a508 2
  startTimes_.insert(aTime);
  effectiveStartTimes_.insert(aTime);
d511 3
a513 1
  startTimes_[0] = RWTime(RWDate( 1, 8, 1995 /* "8/01/95" */ ));
d516 1
a516 1
    startTimes_[t+1] = RWDate(startTimes_[t]) + 7;
a557 111
#ifndef RW_NO_LOCALE

//-------------------------------------------------------------------------
//
// LgFrLocaleDdmonyy
//
//-------------------------------------------------------------------------
RWCString LgFrLocaleDdmonyy::asString(long p) const
{
  return RWLocaleSnapshot::asString(p);
}  
RWCString LgFrLocaleDdmonyy::asString(unsigned long p) const
{
  return RWLocaleSnapshot::asString(p);
}
RWCString LgFrLocaleDdmonyy:: asString(
  double f, int precision, RWBoolean showpoint) const
{
  return RWLocaleSnapshot::asString(f,precision,showpoint);
}

// This is the interesting method which needs to return the date in the
// new format
RWCString LgFrLocaleDdmonyy::asString(
  const struct tm* tmbuf, 
  char format,
  const RWZone& rwz)
const
{
  if ( format != 'x' )
  {
    return RWLocaleSnapshot::asString(tmbuf,format,rwz);
  }
  else {

    // Change locale to be default. RW uses C defaults. This ensures
    // that the number 1996 is converted to the string "1996" and not
    // "1,996".
    RWLocaleSnapshot  localeCDefault;
    const RWLocale * locale = &localeCDefault;
    const RWLocale * origLocale = RWLocale::global( locale );

    RWDate aDate( tmbuf );
    RWCString retVal;

    // initialize string with day (2 digits with leading "0" if needed)
    if (aDate.dayOfMonth() < 10)
      retVal.append("0");
    retVal.append
      (RWLocale::global().asString((unsigned long) aDate.dayOfMonth()));

    // append the three character text for the month name
    retVal.append
      ( (aDate.monthName(RWLocale::global()))(0,3) );

    // turn the year into a string, to get the last 2 chars.
    RWCString aYear =
      (RWLocale::global().asString((unsigned long) aDate.year()));

    // Get last two characters
#ifdef RW_NO_LOCALE
    assert( aYear.length() == 4 );
#else
    assert( aYear.mbLength() == 4 );
#endif
    RWCString yy = aYear( 2, 2 ); 

    retVal.append( yy );

    // Restore original locale
    RWLocale::global( origLocale );
    
    return retVal;
  }
}

// Constructor
LgFrLocaleDdmonyy::LgFrLocaleDdmonyy(
    const char * localeName)
  :
  RWLocaleSnapshot(localeName)
{
  // nothing to do here
}  

// destructor
LgFrLocaleDdmonyy::~LgFrLocaleDdmonyy()
{
  // nothing to do here
}  


// copy constructor
LgFrLocaleDdmonyy::LgFrLocaleDdmonyy(const LgFrLocaleDdmonyy& source)
  : RWLocaleSnapshot()
{
  // nothing to do here
}


// assignment operator
LgFrLocaleDdmonyy&
LgFrLocaleDdmonyy::operator=(
  const LgFrLocaleDdmonyy& rhs)
{
  if (this != &rhs) {           // Check for assignment to self
    // (this->RWLocaleSnapshot::operator= ) (rhs);
  }
  return *this;
}
#endif /* RW_NO_LOCALE */
d568 2
d572 1
a572 1
    LgFrCalendar myCal1 (6, RWTime(RWDate("7/15/94")), LgFrMonth, 2);
d576 1
d578 1
a578 1
			RWTime(RWDate("12/30/94"), "08:00"),
d586 1
a586 1
			RWTime(RWDate("12/31/94")),
a589 2


d594 1
a594 1
    RWTime aNewTime (RWDate("12/15/94"));
d597 1
a597 1
    assert (myCal3.isValid() == FALSE);
d600 1
a600 1
    myCal3.periodStart(1, RWTime(RWDate("1/15/95")));
d604 1
a604 1
    RWTime anEndTime (RWDate("12/15/93"));
d609 1
a609 1
    RWTime goodEndTime (RWDate("12/15/99"));
d615 3
a617 8
    assert (myCal3.period(RWTime(RWDate("1/16/95")))  ==  1);
    assert (myCal3.period(RWTime(RWDate("1/14/94")))  == -1);
    assert (myCal3.period(RWTime(RWDate("12/31/94"))) ==  0);





d623 1
a623 1
			RWTime(RWDate("1/1/94")),
d642 1
a642 1
			RWTime(RWDate("1/1/94")),
d648 9
a656 9
    assert(myCal5.roundedPeriod(RWTime(RWDate("1/16/94"))) == 0);
    assert(myCal5.roundedPeriod(RWTime(RWDate("1/17/94"))) == 1);
    assert(myCal5.roundedPeriod(RWTime(RWDate("12/25/93"))) == 0);
    assert(myCal5.roundedPeriod(RWTime(RWDate("12/11/93"))) == -1);
    assert(myCal5.roundedPeriod(RWTime(RWDate("5/25/94"))) == 5);
    assert(myCal5.roundedPeriod(RWTime(RWDate("12/14/94"))) == 11);
    assert(myCal5.roundedPeriod(RWTime(RWDate("12/25/94"))) == 12);
    assert(myCal5.roundedPeriod(RWTime(RWDate("1/10/95"))) == 12);
    assert(myCal5.roundedPeriod(RWTime(RWDate("1/20/95"))) == 12);
d658 2
a659 2
    assert(myCal5.earlyEffectivePeriod(RWTime(RWDate("5/25/94"))) == 5);
    assert(myCal5.lateEffectivePeriod( RWTime(RWDate("5/25/94"))) == 4);
d661 2
a662 2
    assert(myCal5.earlyEffectivePeriod(RWTime(RWDate("12/25/93"))) == 0);
    assert(myCal5.earlyEffectivePeriod(RWTime(RWDate("12/25/91"))) == 0);
d664 2
a665 2
    assert(myCal5.lateEffectivePeriod( RWTime(RWDate("1/12/95"))) == 11);
    assert(myCal5.lateEffectivePeriod( RWTime(RWDate("1/25/95"))) == 11);
d668 1
a668 1
    RWDate date1(1,1,1995);
d673 1
a673 1
    RWDate date2(25,12,1995);
a676 14
#if 0
    // happy new year!
    RWDate date3(1,1,2001);
    assert("01Jan01" == myCal5.ddmonyy(date3));
    RWDate date4(1,1,1901);
    assert(date4 == myCal5.ddmonyy("01Jan01"));

    // merry christmas
    RWDate date5(25,12,2001);
    assert("25Dec01" == myCal5.ddmonyy(date5));
    RWDate date6(25,12,1901);
    assert(date6 == myCal5.ddmonyy("25Dec01"));
#endif

d678 1
a678 1
    cout << "Testing the format method." << endl;
d680 1
a680 1
    cout << "The following should display a 1 month period, starting 1/1/96" << endl;
d682 1
a682 1
			    RWTime(RWDate("1/1/96")),
d685 1
a685 1
    cout << formatCal1.format(formatStyle) << endl;
d687 1
a687 1
    cout << "The following should display a 12 month period, starting 1/1/96 with a one month interval." << endl;
d689 1
a689 1
			    RWTime(RWDate("1/1/96")),
d692 1
a692 1
    cout << formatCal2.format(formatStyle) << endl;
d694 1
a694 1
    cout << "The following should display a 12 second periods, which should display the same date 12 times. 1/1/96" << endl;
d696 1
a696 1
			    RWTime(RWDate("1/1/96")),
d699 1
a699 1
    cout << formatCal3.format(formatStyle) << endl;
d701 1
a701 1
    cout << "The following should display a 12 minute periods, starting 1/1/96, which should display the same date, 12 times. 1/1/96." << endl;
d703 1
a703 1
			    RWTime(RWDate("1/1/96")),
d706 1
a706 1
    cout << formatCal4.format(formatStyle) << endl;
d708 1
a708 1
    cout << "The following should display 6 quarters, starting 1/1/96" << endl;
d710 1
a710 1
			    RWTime(RWDate("1/1/96")),
d713 1
a713 1
    cout << formatCal5.format(formatStyle) << endl;
d717 5
a721 5
      LgFrVectorRWTime timeVec(4);
      timeVec[0]=RWTime(RWDate("6/24/96"));
      timeVec[1]=RWTime(RWDate("7/2/96"));
      timeVec[2]=RWTime(RWDate("7/8/96"));
      timeVec[3]=RWTime(RWDate("8/5/96"));
d723 1
a723 1
      cout << cal.format(formatStyle) << endl;
a727 36
#ifndef RW_NO_LOCALE
// self-test
void
LgFrLocaleDdmonyy::test()
{
  {
  // Create locale with new date format
  LgFrLocaleDdmonyy localeDdmonyy;

  // Save original locale and set new one which formats dates ddmonyy.
  const RWLocale * origLocale = RWLocale::global( &localeDdmonyy );

  // Test formating
  assert( RWDate( 10, 1, 1956 ).asString('x') == RWCString("10Jan56") );

  // Restore original locale
  RWLocale::global( origLocale );
  }

  {
  // Create locale with new date format
  LgFrLocaleDdmonyy localeDdmonyy("");

  // Save original locale and set new one which formats dates ddmonyy.
  const RWLocale * origLocale = RWLocale::global( &localeDdmonyy );

  // Test formating
  assert( RWDate( 10, 1, 1956 ).asString('x') == RWCString("10Jan56") );

  // Restore original locale
  RWLocale::global( origLocale );
  }


}  
#endif /* RW_NO_LOCALE */
@


1.1.1.1
log
@Import scenario
@
text
@@


1.1.1.1.14.1
log
@Roguewave is gone
@
text
@a0 4
// RW2STL -- inserted:
#include <scenario/src/RWToSTLHelpers.h>
#include <string>
// End of RW2STL -- inserted includes.
d14 1
d19 1
a19 1
	     const SCETime&  horizonStart,
d36 1
a36 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nPeriods_; i++) {
d39 1
a39 1
      startTimes_[i+1] = SCEDate(startTimes_[i]) + (7 * intervalUnitMultiplier);
d42 1
a42 1
      startTimes_[i+1] = SCEDate(startTimes_[i]) + (1 * intervalUnitMultiplier);
d46 1
a46 1
                                   SCEDate(startTimes_[0]).dayOfMonth());
d60 1
a60 1
                                   SCEDate(startTimes_[0]).dayOfMonth());
d80 1
a80 1
	     const LgFrTimeVector&  periodStartTimes,
d95 1
a95 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<=nPeriods_; i++) {    
d107 2
a108 2
SCETime
LgFrCalendar::addMonths(const SCETime& aTime, unsigned numMonthsOut,
d112 2
a113 2
  unsigned newMonth = (SCEDate(aTime)).month() + numMonthsOut;
  unsigned newYear  =  (SCEDate(aTime)).year();
d120 1
a120 1
  while (SCEDate::dayWithinMonth(newMonth, newDay, newYear) == false) {
d124 2
a125 2
  assert (SCEDate(newDay, newMonth, newYear).isValid());
  return SCETime(SCEDate(newDay, newMonth, newYear));
d146 5
a150 6
      SCETime aTime;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=oldNPeriods-1; t<nPeriods; t++)  {
	  startTimes_.push_back(aTime);
	  effectiveStartTimes_.push_back(aTime);
	  workUnits_.push_back(1.0);
d152 2
a153 2
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);
d159 1
a159 1
        startTimes_[t+1] = SCEDate(startTimes_[t]) + (7 * intervalUnitMultiplier_);
d162 1
a162 1
        startTimes_[t+1] = SCEDate(startTimes_[t]) + (1 * intervalUnitMultiplier_);
d166 1
a166 1
                                     SCEDate(startTimes_[0]).dayOfMonth());
d180 1
a180 1
                                     SCEDate(startTimes_[0]).dayOfMonth());
d205 1
a205 1
bool
d210 1
a210 1
  if (nPeriods_ == 0) return false;
d213 1
a213 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nPeriods_; i++) {
d215 2
a216 2
      if (! startTimes_[i].isValid()) return false;
      if (! effectiveStartTimes_[i].isValid()) return false;
d219 2
a220 2
      if (startTimes_[i] > startTimes_[i+1]) return false;
      if (effectiveStartTimes_[i] > effectiveStartTimes_[i+1]) return false;
d224 1
a224 1
      if (effectiveStartTimes_[i] > startTimes_[i]) return false;
d228 3
a230 3
  if (! startTimes_[nPeriods_].isValid()) return false;
  if (! effectiveStartTimes_[nPeriods_].isValid()) return false;
  if (effectiveStartTimes_[nPeriods_] > startTimes_[nPeriods_]) return false;
d232 1
a232 1
  return true;
d237 1
a237 1
LgFrCalendar::periodStart(size_t period, const SCETime& startTime)
d246 1
a246 1
SCETime
d273 1
a273 1
SCETime
d281 1
a281 1
LgFrCalendar::horizonEnd(const SCETime& theEnd)
d321 1
a321 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i < this->nPeriods(); i++) 
d331 1
a331 1
LgFrCalendar::period(const SCETime& aTime)
d334 1
a334 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<=nPeriods_; i++)  {
d361 1
a361 1
LgFrCalendar::roundedPeriod(const SCETime& aTime)
d365 1
a365 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<=nPeriods_; i++)   {
d383 1
a383 1
LgFrCalendar::earlyEffectivePeriod(const SCETime& aTime)
d398 1
a398 1
LgFrCalendar::lateEffectivePeriod(const SCETime& aTime)
d416 2
a417 2
    if (halfPeriodLength > startTimes_[0].seconds())
	effectiveStartTimes_[0] = SCETime((unsigned long) 0);
d422 1
a422 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<nPeriods_; i++)   {
d435 5
a439 6
  SCETime aTime;
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods_; t++)  {
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);
      workUnits_.push_back(1.0);
d441 2
a442 2
  startTimes_.push_back(aTime);
  effectiveStartTimes_.push_back(aTime);
d446 2
a447 2
// calendar utility to convert a std::string date in the form
// "YYYYMMDD" to a SCEDate and vice versa.
d449 3
a451 3
// check the returned SCEDate with isValid()
SCEDate
LgFrCalendar::yyyymmdd(const std::string & aDateString)
d459 3
a461 3
    sce::fromString(aDateString.substr(0,4).c_str(), year);
    sce::fromString(aDateString.substr(4,2).c_str(), month);
    sce::fromString(aDateString.substr(6,2).c_str(), day);
d463 1
a463 1
    SCEDate theDate(
d472 2
a473 2
std::string
LgFrCalendar::yyyymmdd(const SCEDate & aDate)
d477 1
a477 1
    std::string aDateString(sce::stringFrom((unsigned long) aDate.year()));
d482 1
a482 1
    aDateString.append(sce::stringFrom((unsigned long) aDate.month()));
d487 1
a487 1
    aDateString.append(sce::stringFrom((unsigned long) aDate.dayOfMonth()));
d494 2
a495 2
// calendar utility to convert a std::string date in the form
// "ddmonyy" to a SCEDate and vice versa.
d497 3
a499 3
// check the returned SCEDate with isValid()
SCEDate
LgFrCalendar::ddmonyy(const std::string & aDateString)
d505 1
a505 1
    SCEDate theDate( &tmDate );
d511 2
a512 2
std::string
LgFrCalendar::ddmonyy(const SCEDate & aDate)
d518 1
a518 1
    std::string aDateString;
d530 1
a530 1
    std::string aYear =
d550 2
a551 2
// Format a LgFrCalendar into a std::string.
// Return a std::string representing the calendar, in the format specified by the formatStyle.
d559 1
a559 1
std::string
d568 3
a570 1
    std::string retVal;
d579 1
a579 2
	int x = 0; // Pulled out of the for below by RW2STL
	for (x = 0; x < nPeriods_; x++ ){
d583 1
a583 1
// 	      <<  this->ddmonyy( SCEDate(this->periodStart(x)) )
d585 1
a585 1
	      <<  SCEDate(this->periodStart(x)).asString('x') 
d620 5
a624 6
  SCETime aTime;
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods_; t++)  {
      startTimes_.push_back(aTime);
      effectiveStartTimes_.push_back(aTime);
      workUnits_.push_back(1.0);
d626 2
a627 2
  startTimes_.push_back(aTime);
  effectiveStartTimes_.push_back(aTime);
d630 1
a630 1
  startTimes_[0] = SCETime(SCEDate( 1, 8, 1995 /* "8/01/95" */ ));
d633 1
a633 1
    startTimes_[t+1] = SCEDate(startTimes_[t]) + 7;
d675 111
a795 2
    assert( SCETime::unitTest() );

d798 1
a798 1
    LgFrCalendar myCal1 (6, SCETime(SCEDate("7/15/94")), LgFrMonth, 2);
d803 1
a803 1
			SCETime(SCEDate("12/30/94"), "08:00"),
d811 1
a811 1
			SCETime(SCEDate("12/31/94")),
d821 1
a821 1
    SCETime aNewTime (SCEDate("12/15/94"));
d824 1
a824 1
    assert (myCal3.isValid() == false);
d827 1
a827 1
    myCal3.periodStart(1, SCETime(SCEDate("1/15/95")));
d831 1
a831 1
    SCETime anEndTime (SCEDate("12/15/93"));
d836 1
a836 1
    SCETime goodEndTime (SCEDate("12/15/99"));
d842 3
a844 3
    assert (myCal3.period(SCETime(SCEDate("1/16/95")))  ==  1);
    assert (myCal3.period(SCETime(SCEDate("1/14/94")))  == -1);
    assert (myCal3.period(SCETime(SCEDate("12/31/94"))) ==  0);
d855 1
a855 1
			SCETime(SCEDate("1/1/94")),
d874 1
a874 1
			SCETime(SCEDate("1/1/94")),
d880 9
a888 9
    assert(myCal5.roundedPeriod(SCETime(SCEDate("1/16/94"))) == 0);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("1/17/94"))) == 1);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("12/25/93"))) == 0);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("12/11/93"))) == -1);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("5/25/94"))) == 5);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("12/14/94"))) == 11);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("12/25/94"))) == 12);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("1/10/95"))) == 12);
    assert(myCal5.roundedPeriod(SCETime(SCEDate("1/20/95"))) == 12);
d890 2
a891 2
    assert(myCal5.earlyEffectivePeriod(SCETime(SCEDate("5/25/94"))) == 5);
    assert(myCal5.lateEffectivePeriod( SCETime(SCEDate("5/25/94"))) == 4);
d893 2
a894 2
    assert(myCal5.earlyEffectivePeriod(SCETime(SCEDate("12/25/93"))) == 0);
    assert(myCal5.earlyEffectivePeriod(SCETime(SCEDate("12/25/91"))) == 0);
d896 2
a897 2
    assert(myCal5.lateEffectivePeriod( SCETime(SCEDate("1/12/95"))) == 11);
    assert(myCal5.lateEffectivePeriod( SCETime(SCEDate("1/25/95"))) == 11);
d900 1
a900 1
    SCEDate date1(1,1,1995);
d905 1
a905 1
    SCEDate date2(25,12,1995);
d911 1
a911 1
    SCEDate date3(1,1,2001);
d913 2
a914 2
    SCEDate date4(1,1,1901);
    assert(date4 == myCal5.ddmonyy("01Jan70"));
d917 1
a917 1
    SCEDate date5(25,12,2001);
d919 1
a919 1
    SCEDate date6(25,12,1970);
d928 1
a928 1
			    SCETime(SCEDate("1/1/96")),
d935 1
a935 1
			    SCETime(SCEDate("1/1/96")),
d942 1
a942 1
			    SCETime(SCEDate("1/1/96")),
d949 1
a949 1
			    SCETime(SCEDate("1/1/96")),
d956 1
a956 1
			    SCETime(SCEDate("1/1/96")),
d963 5
a967 5
      LgFrTimeVector timeVec(4);
      timeVec[0]=SCETime(SCEDate("6/24/96"));
      timeVec[1]=SCETime(SCEDate("7/2/96"));
      timeVec[2]=SCETime(SCEDate("7/8/96"));
      timeVec[3]=SCETime(SCEDate("8/5/96"));
d974 36
@


1.1.1.1.14.2
log
@Removed STD_CPP_LIB #ifdefs
and went to std for cout
@
text
@a3 1
#include <sstream>
d8 2
a9 1
/*#if defined (WIN32) || defined (__OS2__) || defined (__WINDOWS__)
d13 1
a13 1
#endif*/
d327 1
a327 1
   std::cout << "\nCalendar Display\n"; 
d330 1
a330 1
      std::cout << "Period " << i << ": " << this->periodStart(i) << "\n";
d573 1
a573 1
		      const LgFrCalendarFormatStyle formatStyle )/*,
d576 1
a576 1
		      const long iosFlags )*/
d584 5
a588 3
	std::ostringstream buf;
	//buf.precision(precision);
	//buf.setf( iosFlags );
d591 8
a598 3
	    //buf.width( width );
	    buf <<  SCEDate(this->periodStart(x)).asString('x').c_str(); 
	    buf << " ";
d601 4
a604 2
    //buf << std::std::endl;
    retVal = buf.str();
d606 1
d609 1
a609 1
	std::cerr << "LgFrCalendar::format.  Unrecognized format style.\n";
d827 1
a827 1
    std::cout << "Testing the format method." << std::endl;
d829 1
a829 1
    std::cout << "The following should display a 1 month period, starting 1/1/96" << std::endl;
d834 1
a834 1
    std::cout << formatCal1.format(formatStyle) << std::endl;
d836 1
a836 1
    std::cout << "The following should display a 12 month period, starting 1/1/96 with a one month interval." << std::endl;
d841 1
a841 1
    std::cout << formatCal2.format(formatStyle) << std::endl;
d843 1
a843 1
    std::cout << "The following should display a 12 second periods, which should display the same date 12 times. 1/1/96" << std::endl;
d848 1
a848 1
    std::cout << formatCal3.format(formatStyle) << std::endl;
d850 1
a850 1
    std::cout << "The following should display a 12 minute periods, starting 1/1/96, which should display the same date, 12 times. 1/1/96." << std::endl;
d855 1
a855 1
    std::cout << formatCal4.format(formatStyle) << std::endl;
d857 1
a857 1
    std::cout << "The following should display 6 quarters, starting 1/1/96" << std::endl;
d862 1
a862 1
    std::cout << formatCal5.format(formatStyle) << std::endl;
d872 1
a872 1
      std::cout << cal.format(formatStyle) << std::endl;
@


1.1.1.1.14.3
log
@Fixed SCETime streaming problems
@
text
@d330 1
a330 1
      std::cout << "Period " << i << ": " << this->periodStart(i).asString() << "\n";
@


1.1.1.1.14.4
log
@New LgFrDatetime class
@
text
@d22 1
a22 1
	     const LgFrDatetime&  horizonStart,
d43 1
a43 1
      startTimes_[i+1] = startTimes_[i].plusWeeks( intervalUnitMultiplier );
d46 1
a46 1
      startTimes_[i+1] = startTimes_[i].plusDays( intervalUnitMultiplier );
d49 2
a50 1
      startTimes_[i+1] = startTimes_[i].plusMonths( intervalUnitMultiplier );
d53 1
a53 1
      startTimes_[i+1] = startTimes_[i].plusHours( intervalUnitMultiplier );
d56 1
a56 1
      startTimes_[i+1] = startTimes_[i].plusMinutes( intervalUnitMultiplier );
d59 1
a59 1
      startTimes_[i+1] = startTimes_[i].plusSeconds( intervalUnitMultiplier );
d62 3
a64 1
      startTimes_[i+1] = startTimes_[i].plusQuarters( intervalUnitMultiplier );
d69 1
a69 2
    LgFrDatetime dt = startTimes_[i+1];

d84 1
a84 1
	     const LgFrDatetimeVector&  periodStartTimes,
d112 2
a113 2
/*LgFrDatetime
LgFrCalendar::addMonths(const LgFrDatetime& aTime, unsigned numMonthsOut,
d117 2
a118 2
  unsigned newMonth = (LgFrDatetime(aTime)).month() + numMonthsOut;
  unsigned newYear  =  (LgFrDatetime(aTime)).year();
d125 1
a125 1
  while (LgFrDatetime::dayWithinMonth(newMonth, newDay, newYear) == false) {
d129 3
a131 3
  assert (LgFrDatetime(newDay, newMonth, newYear).isValid());
  return LgFrDatetime(LgFrDatetime(newDay, newMonth, newYear));
}*/
d151 1
a151 1
      LgFrDatetime aTime;
d164 25
a188 22
        case LgFrWeek:
          startTimes_[t+1] = startTimes_[t].plusWeeks( nPeriods );
          break;
        case LgFrDay:
          startTimes_[t+1] = startTimes_[t].plusDays( nPeriods );
          break;
        case LgFrMonth:
          startTimes_[t+1] = startTimes_[t].plusMonths( nPeriods );
          break;
        case LgFrHour:
          startTimes_[t+1] = startTimes_[t].plusHours( nPeriods );
          break;
        case LgFrMinute:
          startTimes_[t+1] = startTimes_[t].plusMinutes( nPeriods );
          break;
        case LgFrSecond:
          startTimes_[t+1] = startTimes_[t].plusSeconds( nPeriods );
          break;
        case LgFrQuarter:
          startTimes_[t+1] = startTimes_[t].plusQuarters( nPeriods );
          break;
        default:
d244 1
a244 1
LgFrCalendar::periodStart(size_t period, const LgFrDatetime& startTime)
d253 1
a253 1
LgFrDatetime
d280 1
a280 1
LgFrDatetime
d288 1
a288 1
LgFrCalendar::horizonEnd(const LgFrDatetime& theEnd)
d330 1
a330 1
      std::cout << "Period " << i << ": " << this->periodStart(i).getDateAsString() << "\n";
d339 1
a339 1
LgFrCalendar::period(const LgFrDatetime& aTime)
d370 1
a370 1
LgFrCalendar::roundedPeriod(const LgFrDatetime& aTime)
d393 1
a393 1
LgFrCalendar::earlyEffectivePeriod(const LgFrDatetime& aTime)
d408 1
a408 1
LgFrCalendar::lateEffectivePeriod(const LgFrDatetime& aTime)
d424 1
a424 1
    long diff = startTimes_[1].getValue() - startTimes_[0].getValue();
d426 2
a427 2
    if (halfPeriodLength > startTimes_[0].getValue())
	    effectiveStartTimes_[0] = LgFrDatetime((unsigned long) 0);
d429 1
a429 1
	    effectiveStartTimes_[0] = startTimes_[0] - halfPeriodLength;
d434 3
a436 3
	    diff = startTimes_[i+1].getValue() - startTimes_[i].getValue();
	    halfPeriodLength = diff/2;
	    effectiveStartTimes_[i+1] = startTimes_[i+1] - halfPeriodLength;
d446 1
a446 1
  LgFrDatetime aTime;
d459 1
a459 1
// "YYYYMMDD" to a LgFrDatetime and vice versa.
d461 2
a462 2
// check the returned LgFrDatetime with isValid()
LgFrDatetime
d466 3
a468 5
    return LgFrDatetime( aDateString );
    /*
    int day = 0;
    int month = 0;
    int year = 0;
d475 4
a478 2
    LgFrDatetime theDate;
    theDate.setDate( month, day, year );
d480 1
a480 1
    return theDate;*/
d485 1
a485 1
LgFrCalendar::yyyymmdd(const LgFrDatetime & aDate)
d488 1
a488 5
    std::string str = aDate.getDateAsString( "%Y%m%d" );
    return str;


/*    // initialize the string with the year (which should always be 4 digits)
d501 48
a548 1
    return aDateString; */
d551 1
d584 12
a595 5
	    int x = 0; // Pulled out of the for below by RW2STL
	    for (x = 0; x < nPeriods_; x++ ){
            retVal += periodStart(x).getDateAsString();
            retVal += ' ';
        }
d599 2
a600 2
	    std::cerr << "LgFrCalendar::format.  Unrecognized format style.\n";
	    abort();
d621 1
a621 1
  LgFrDatetime aTime;
d632 1
a632 3
  LgFrDatetime dt;
  dt.setDate( 8, 1, 1995 );
  startTimes_[0] = dt;
d635 1
a635 1
    startTimes_[t+1] = LgFrDatetime(startTimes_[t]) + 7;
d687 1
a687 1
    assert( LgFrDatetime::unitTest() );
d691 1
a691 1
    LgFrCalendar myCal1 (6, LgFrDatetime("7/15/94"), LgFrMonth, 2);
a694 1

d696 1
a696 1
			LgFrDatetime("12/30/94"),
d704 1
a704 1
			LgFrDatetime(LgFrDatetime("12/31/94")),
d708 2
d714 1
a714 1
    LgFrDatetime aNewTime (LgFrDatetime("12/15/94"));
d720 1
a720 1
    myCal3.periodStart(1, LgFrDatetime("1/15/95"));
d724 1
a724 1
    LgFrDatetime anEndTime (LgFrDatetime("12/15/93"));
d729 1
a729 1
    LgFrDatetime goodEndTime (LgFrDatetime("12/15/99"));
d735 8
a742 3
    assert (myCal3.period(LgFrDatetime("1/16/95"))  ==  1);
    assert (myCal3.period(LgFrDatetime("1/14/94"))  == -1);
    assert (myCal3.period(LgFrDatetime("12/31/94")) ==  0);
d748 1
a748 1
			LgFrDatetime(LgFrDatetime("1/1/94")),
d767 1
a767 1
			LgFrDatetime(LgFrDatetime("1/1/94")),
d773 9
a781 9
    assert(myCal5.roundedPeriod(LgFrDatetime("1/16/94")) == 0);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/17/94")) == 1);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/25/93")) == 0);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/11/93")) == -1);
    assert(myCal5.roundedPeriod(LgFrDatetime("5/25/94")) == 5);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/14/94")) == 11);
    assert(myCal5.roundedPeriod(LgFrDatetime("12/25/94")) == 12);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/10/95")) == 12);
    assert(myCal5.roundedPeriod(LgFrDatetime("1/20/95")) == 12);
d783 2
a784 2
    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("5/25/94")) == 5);
    assert(myCal5.lateEffectivePeriod( LgFrDatetime("5/25/94")) == 4);
d786 2
a787 2
    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("12/25/93")) == 0);
    assert(myCal5.earlyEffectivePeriod(LgFrDatetime("12/25/91")) == 0);
d789 2
a790 2
    assert(myCal5.lateEffectivePeriod( LgFrDatetime("1/12/95")) == 11);
    assert(myCal5.lateEffectivePeriod( LgFrDatetime("1/25/95")) == 11);
d793 1
a793 1
    LgFrDatetime date1( "1/1/1995" );
d798 1
a798 1
    LgFrDatetime date2( "12/25/1995" );
d802 14
d821 1
a821 1
			    LgFrDatetime(LgFrDatetime("1/1/96")),
d828 1
a828 1
			    LgFrDatetime(LgFrDatetime("1/1/96")),
d835 1
a835 1
			    LgFrDatetime(LgFrDatetime("1/1/96")),
d842 1
a842 1
			    LgFrDatetime(LgFrDatetime("1/1/96")),
d849 1
a849 1
			    LgFrDatetime(LgFrDatetime("1/1/96")),
d856 5
a860 5
      LgFrDatetimeVector timeVec(4);
      timeVec[0]=LgFrDatetime("6/24/96");
      timeVec[1]=LgFrDatetime("7/2/96");
      timeVec[2]=LgFrDatetime("7/8/96");
      timeVec[3]=LgFrDatetime("8/5/96");
@



head	1.22;
access;
symbols
	sce_5_01_20080919:1.20
	latest_sce_4_20_20060523:1.19.0.4
	sce_4_20_20060523:1.19
	latest_sce4_20_OSL:1.19.0.2
	sce_4_20_OSL:1.19
	sce_4_05_20040511:1.11
	sce_4_00_20040201:1.9
	nextGenBranch:1.9.0.2
	nextGenRoot:1.9
	sce_3_30_20030627:1.9
	EndRw-branch:1.5.0.4
	Root-of-EndRw:1.5
	rwToStl:1.5.0.2
	latest_sce_3_10_20010924:1.4.0.8
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.4.0.6
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.4
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2011.09.29.18.27.10;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.12.19.53.17;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.27.14.10.51;	author dpc;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.03.22.43.33;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.03.21.15.41;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.03.19.19.06;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.24.17.26.06;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.11.17.22.26;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.09.21.36.39;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.24.19.45.12;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.20.23.59.37;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.16.19.34.41;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.14.22.52.08;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.28.18.00.27;	author dpc;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.09.13.19.36;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.09.13.09.13;	author rwToStl;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.25.15.13.16;	author rwToStl;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.20.22.30.35;	author bobw;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.03.07.16.46.07;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.16.00.38;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.15.56.30;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.23.21.35.07;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2002.11.05.22.47.19;	author rwToStl;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.11.06.21.02.53;	author rwToStl;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.11.06.23.25.30;	author rwToStl;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.23.21.35.07;	author wit;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Added a proprietary statement to the source code and to the object code.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Message Class Library
//
// (C) Copyright IBM Corp. 1997, 2005  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//-----------------------------------------------------------------------------
// File arg.C
//
// Contains the declaration and implementation of the following classes:
//
// ArgValueType
//
// Contains the implementation of the following classes:
//
// Arg
//    BoolArg
//    IntArg
//    FloatArg
//    DoubleArg
//    StringArg
//    MsgFragArg
//    VectorArg
//       BoolVectorArg
//       IntVectorArg
//       FloatVectorArg
//       DoubleVectorArg
//       StringVectorArg
//
// ArgList
//-----------------------------------------------------------------------------

#include <mcl/src/arg.h>
#include <mcl/src/facility.h>
#include <mcl/src/msg.h>

#include <vector>
#include <iostream>

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//-----------------------------------------------------------------------------
// class ArgValueType.
//
// Responsible for some of the behavior of an Arg associated with the type
// of its value, where "value" refers to the scalar value associated with a
// scalar Arg or the scalar value of a single element of a VectorArg.
//-----------------------------------------------------------------------------

class MclArgValueType
   {
   public:

      //-----------------------------------------------------------------------
      // Access functions
      //-----------------------------------------------------------------------

      inline const std::string & name () const
         {
         return name_;
         }

      inline const std::string & validFlags () const
         {
         return validFlags_;
         }

      inline const std::string & testFormat () const
         {
         return testFormat_;
         }

      //-----------------------------------------------------------------------
      // Each of these functions returns the ArgValueType for the
      // appropriate type.
      //-----------------------------------------------------------------------

      inline static const MclArgValueType & boolType ()
         {
         reqSetUpDone ();

         return * boolTypePtr_;
         }

      inline static const MclArgValueType & intType ()
         {
         reqSetUpDone ();

         return * intTypePtr_;
         }

      inline static const MclArgValueType & floatType ()
         {
         reqSetUpDone ();

         return * floatTypePtr_;
         }

      inline static const MclArgValueType & doubleType ()
         {
         reqSetUpDone ();

         return * doubleTypePtr_;
         }

      inline static const MclArgValueType & stringType ()
         {
         reqSetUpDone ();

         return * stringTypePtr_;
         }

      inline static const MclArgValueType & msgFragType ()
         {
         reqSetUpDone ();

         return * msgFragTypePtr_;
         }

      //-----------------------------------------------------------------------

      static void setUpClass ();
         //
         // Does initial set up of this class the first time it is called
         // during the program process.

   private:

      MclArgValueType (
            const char * nameVal,
            const char * validFlagsVal,
            const char * testFormatVal);
         //
         // Constructor
         //
         // name_       <-- nameVal
         // validFlags_ <-- validFlagsVal
         // testFormat_ <-- testFormatVal

      ~MclArgValueType ();
         //
         // Destructor
         // It is not implemented, because the instances of this class are never
         // destructed.

      MclArgValueType             (const MclArgValueType &);
      MclArgValueType & operator= (const MclArgValueType &);
         //
         // Copy ctor and assignment are declared private and not implemented
         // so as to prevent inadvertant copying and assignment.

      inline static void reqSetUpDone ()
         {
         if (! setUpDone_)
            setUpNotDone ();
         }

      static void setUpNotDone ();
         //
         // Issues a client error indicating that a MclArg class constructor
         // was called when the Facility has not yet been called.

      //-----------------------------------------------------------------------
      // Data.
      //-----------------------------------------------------------------------

      const std::string name_;
         //
         // Text identifying this ArgValueType.

      const std::string validFlags_;
         //
         // The list of valid output format flags for Args that have this
         // ArgValueType.

      const std::string testFormat_;
         //
         // The format to be used for testing purposes.

      static const MclArgValueType *    boolTypePtr_;
      static const MclArgValueType *     intTypePtr_;
      static const MclArgValueType *   floatTypePtr_;
      static const MclArgValueType *  doubleTypePtr_;
      static const MclArgValueType *  stringTypePtr_;
      static const MclArgValueType * msgFragTypePtr_;
         //
         // Type behavior for Args whose values are ints, floats, strings, or
         // MsgFrags.
         // These are the only instances of this class that ever exist.
         // They are constructed by the first call to setUpClass () and never
         // destructed.

      static bool setUpDone_;
         //
         // True, iff setUpClass () has been called at least once during the
         // program process.
   };

//---------------------------------------------------------------------------
// Implementation of class MclArgValueType
//---------------------------------------------------------------------------

const MclArgValueType * MclArgValueType::   boolTypePtr_ = NULL;
const MclArgValueType * MclArgValueType::    intTypePtr_ = NULL;
const MclArgValueType * MclArgValueType::  floatTypePtr_ = NULL;
const MclArgValueType * MclArgValueType:: doubleTypePtr_ = NULL;
const MclArgValueType * MclArgValueType:: stringTypePtr_ = NULL;
const MclArgValueType * MclArgValueType::msgFragTypePtr_ = NULL;

bool                    MclArgValueType::     setUpDone_ = false;

//-----------------------------------------------------------------------------

void MclArgValueType::setUpClass ()
   {
   if (setUpDone_)
      return;

      boolTypePtr_ = new MclArgValueType ("bool",               "b",  "%b");
       intTypePtr_ = new MclArgValueType ("int",                "db", "%d");
     floatTypePtr_ = new MclArgValueType ("float",              "fg", "%g");
    doubleTypePtr_ = new MclArgValueType ("double",             "fg", "%.14g");
    stringTypePtr_ = new MclArgValueType ("const char *",       "s",  "%s");
   msgFragTypePtr_ = new MclArgValueType ("const MclMsgFrag *", "ms", "%m");

   setUpDone_      = true;
   }

//-----------------------------------------------------------------------------

MclArgValueType::MclArgValueType (
         const char * nameVal,
         const char * validFlagsVal,
         const char * testFormatVal):

      name_       (nameVal),
      validFlags_ (validFlagsVal),
      testFormat_ (testFormatVal)
   {
   }

//-----------------------------------------------------------------------------

void MclArgValueType::setUpNotDone ()
   {
   std::cerr <<
      "\n\n"
      "MCL CLIENT ERROR:\n\n"
      "   A constructor for an MclArg class was called when \n"
      "   the MclFacility constructor had not yet been called.\n";

   MclFacility::abortMcl ();
   }

//-----------------------------------------------------------------------------
//
// MclArg Implementation
//
//-----------------------------------------------------------------------------

MclArg::MclArg (const MclArgValueType & theValueType):
   myValueType_ (theValueType)
{
}

MclArg::~MclArg ()
   {
   }

void MclArg::format (
      std::string &       formattedArg,
      const std::string & theFormat,
      MclBoolean          reqVector,
      int                 argNum,
      const MclMsg *      theMsg)
      const
   {
   char theFlag;

   if (isaVector () != reqVector)
      vectornessError (reqVector, argNum, theMsg);

   theFlag = formatFlag (theFormat);

   if (myValueType_.validFlags ().find (theFlag) == std::string::npos)
      flagError (theFlag, argNum, theMsg);

   formatValidArg (formattedArg, theFormat, theMsg);
   }

void MclArg::getValueText (std::string & valueText, const MclMsg * theMsg) const
   {
   formatValidArg (valueText, myValueType_.testFormat (), theMsg);
   }

void MclArg::setUpClass ()
   {
   MclArgValueType::setUpClass ();
   }

MclArg::MclArg (const MclArg & theArg):
      myValueType_ (theArg.myValueType_)
   {
   }

void MclArg::getTypeName (std::string & theName) const
   {
   theName = myValueType_.name ();
   }

MclBoolean MclArg::isaVector () const
   {
   return FALSE;
   }

void MclArg::formatValidData (
      std::string &       formattedData,
      const std::string & theFormat,
      int                 theData,
      const MclFacility & theFacility)
   {
   if (formatFlag (theFormat) == 'b')
      {
      std::string stringFormat = theFormat;

      formatFlag (stringFormat) = 's';

      formatValidData (
         formattedData,
         stringFormat,
         theFacility.booleanText (theData));
      }
   else
      {
        char buffer[200];
   
        sprintf (buffer, theFormat.c_str(), theData);

        formattedData = buffer;
      }
   }

void MclArg::formatValidData (
      std::string &       formattedData,
      const std::string & theFormat,
      float               theData)
   {
   char buffer[100];

   sprintf (buffer, theFormat.c_str (), theData);

   formattedData = buffer;
   }

void MclArg::formatValidData (
      std::string &       formattedData,
      const std::string & theFormat,
      double              theData)
   {
   char buffer[100];

   sprintf (buffer, theFormat.c_str (), theData);

   formattedData = buffer;
   }

void MclArg::formatValidData (
      std::string &       formattedData,
      const std::string & theFormat,
      const char *        theData)
   {
     int stringLength;
     stringLength = strlen(theData);
     int width = getWidth(theFormat);
     if (stringLength < width)
       stringLength = width;
     char * buffer = new char[stringLength + 1];
     sprintf (buffer, theFormat.c_str(), theData);
     formattedData = buffer;
     delete [] buffer;
   }

char & MclArg::formatFlag (std::string & theFormat)
   {
   return theFormat[theFormat.length () - 1];
   }

char MclArg::formatFlag (const std::string & theFormat)
   {
   return theFormat[theFormat.length () - 1];
   }

void MclArg::vectornessError (
      MclBoolean     reqVector,
      int            argNum,
      const MclMsg * theMsg)
      const
   {
   std::string typeName;
   std::string valueText;

   getTypeName  (typeName);
   getValueText (valueText, theMsg);

   std::cerr <<
      "\n\n"
      "MCL CLIENT ERROR:\n\n"
      "   A " << (reqVector? "non-": "") <<
         "vector was passed as the argument corresponding to\n"
      "   a " << (reqVector? "": "non-") <<
         "vector argument given in the format string of a message.\n\n"
      "   Message ID:              \"" << theMsg->id () << "\"\n"
      "   Argument #:              "   << argNum        << "\n"
      "   Type of argument passed: "   << typeName.c_str()  << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n";

   MclFacility::abortMcl ();
   }

void MclArg::flagError (
      char           formatFlag,
      int            argNum,
      const MclMsg * theMsg)
      const
   {
   std::string validFlags = myValueType_.validFlags ();
   size_t    theIndex;
   std::string typeName;
   std::string valueText;

   getTypeName  (typeName);
   getValueText (valueText, theMsg);

   std::cerr <<
      "\n\n"
      "MCL CLIENT ERROR:\n\n"
      "   The type of an argument passed to a message does not match\n"
      "   the format flag given in the format string.\n\n"
      "   Message ID:              \"" << theMsg->id () << "\"\n"
      "   Argument #:              "   << argNum        << "\n"
      "   Format flag:             '"  << formatFlag    << "'\n"
      "   Type of argument passed: "   << typeName.c_str() << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n"
      "   The valid format flags for this type of argument are:";

   for (theIndex = 0; theIndex < validFlags.length (); ++ theIndex) 
      std::cerr << " '"  << validFlags.substr (theIndex, 1).c_str()  << "'";

   std::cerr << "\n";

   MclFacility::abortMcl ();
   }

int MclArg::getWidth(const std::string & format)
{
	size_t i = format.find('%');
	if( i < format.length() )
	{
		std::string widthStr;
		if( format[++i] == '-' )
			i++; // if a '-' was following the %, skip it;
		while( isdigit( format[i] ) )
			widthStr += format[i++];
		int length = atoi(widthStr.c_str());
		return length;
	}
	return -1;
  
}

//-----------------------------------------------------------------------------
//
// MclBoolArg Implementation
//
//-----------------------------------------------------------------------------

MclBoolArg::MclBoolArg(bool theBool):
  MclArg(MclArgValueType::boolType ()),
  myBool_    (theBool)
{
}

MclBoolArg::MclBoolArg(const MclBoolArg&  theBoolArg):
  MclArg(theBoolArg),
  myBool_    (theBoolArg.myBool_)
{
}

void MclBoolArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *      theMsg)
      const
   {
   formatValidData (formattedArg, theFormat, myBool_, theMsg->myFacility ());
   }

//-----------------------------------------------------------------------------
//
// MclIntArg Implementation
//
//-----------------------------------------------------------------------------

MclIntArg::MclIntArg(int i):
  MclArg(MclArgValueType::intType ()),
  i_    (i)
{
}

MclIntArg::MclIntArg(const MclIntArg&  i):
  MclArg(i),
  i_    (i.i_)
{
}

void MclIntArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *      theMsg)
      const
   {
   formatValidData (formattedArg, theFormat, i_, theMsg->myFacility ());
   }

//-----------------------------------------------------------------------------
//
// MclFloatArg Implementation
//
//-----------------------------------------------------------------------------

MclFloatArg::MclFloatArg(float f):
  MclArg(MclArgValueType::floatType ()),
  f_    (f)
{
}

MclFloatArg::MclFloatArg(const MclFloatArg& f):
  MclArg(f),
  f_ (f.f_)
{
}

void MclFloatArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *)
      const
   {
   formatValidData (formattedArg, theFormat, f_);
   }

//-----------------------------------------------------------------------------
//
// MclDoubleArg Implementation
//
//-----------------------------------------------------------------------------

MclDoubleArg::MclDoubleArg (double theDouble):

      MclArg    (MclArgValueType::doubleType ()),
      myDouble_ (theDouble)
   {
   }

//-----------------------------------------------------------------------------

MclDoubleArg::~MclDoubleArg ()
   {
   }

//-----------------------------------------------------------------------------

MclArg * MclDoubleArg::clone () const
   {
   return new MclDoubleArg (* this);
   }

//-----------------------------------------------------------------------------

MclDoubleArg::MclDoubleArg (const MclDoubleArg & theDblArg):

      MclArg    (theDblArg),
      myDouble_ (theDblArg.myDouble_)
   {
   }

//-----------------------------------------------------------------------------

void MclDoubleArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *)
      const
   {
   formatValidData (formattedArg, theFormat, myDouble_);
   }

//-----------------------------------------------------------------------------
//
// MclStringArg Implementation
//
//-----------------------------------------------------------------------------

MclStringArg::MclStringArg(const char * s):
  MclArg(MclArgValueType::stringType ()),
   string_(s)
{
MclFacility::forbidNullArg (s, "s", "MclStringArg::MclStringArg");
}

MclArg* MclStringArg::clone()const
{
  return new MclStringArg(*this);
}

MclStringArg::~MclStringArg()
{
  // Nothing to do here
}

MclStringArg::MclStringArg(const MclStringArg & source)
  :MclArg(source),
   string_(source.string_)
{
  // Nothing to do here
}

void MclStringArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *)
      const
   {
   formatValidData (formattedArg, theFormat, string_);
   }

//-----------------------------------------------------------------------------
//
// MclMsgFragArg Implementation
//
//-----------------------------------------------------------------------------

MclMsgFragArg::MclMsgFragArg (const MclMsgFrag * theFrag):
      MclArg  (MclArgValueType::msgFragType ()),
      myFrag_ (theFrag)
   {
   MclFacility::forbidNullArg (
      theFrag,
      "theFrag",
      "MclMsgFragArg::MclMsgFragArg");
   }

//-----------------------------------------------------------------------------

MclMsgFragArg::~MclMsgFragArg ()
   {
   }

//-----------------------------------------------------------------------------

MclArg * MclMsgFragArg::clone () const
   {
   return new MclMsgFragArg (*this);
   }

//-----------------------------------------------------------------------------

MclMsgFragArg::MclMsgFragArg (const MclMsgFragArg & source):
      MclArg  (source),
      myFrag_ (source.myFrag_)
   {
   }

//-----------------------------------------------------------------------------

void MclMsgFragArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *)
      const
   {
   std::string finalFormat = theFormat;

   if (formatFlag (finalFormat) == 'm')
       formatFlag (finalFormat) =  's';

   formatValidData (formattedArg, finalFormat, myFrag_->text ());
   }

//-----------------------------------------------------------------------------
//
// MclVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclVectorArg::MclVectorArg (int l, const MclArgValueType & theValueType):

   MclArg (theValueType),
   length_(l)
{
  // do nothing
}

MclVectorArg::~MclVectorArg()
{
}

MclVectorArg::MclVectorArg(const MclVectorArg& v):
   MclArg(v),
   length_(v.length_)
{
  // do nothing
}

void MclVectorArg::getTypeName (std::string & theName) const
   {
   MclArg::getTypeName (theName);

   theName += " Vector";
   }

MclBoolean MclVectorArg::isaVector () const
   {
   return TRUE;
   }

void MclVectorArg::formatValidArg (
      std::string &       formattedArg,
      const std::string & theFormat,
      const MclMsg *      theMsg)
      const
   {
   std::string formattedElem;
   size_t       i;
   size_t       charsAvail;
   size_t       charsAvailPerLine;
   std::string newLineString ("\n");

   newLineString += std::string (theMsg->vectorIndent(), ' ');

   charsAvailPerLine =
      theMsg->myFacility ().lineLength () - theMsg->vectorIndent ();

   if (theMsg->displayExternalNumber ())
       charsAvailPerLine -= 9;

   formattedArg = "";

   charsAvail = 0;

   for (i = 0; i < length_; ++ i)
      {
      formatElem (formattedElem, theFormat, i, theMsg->myFacility ());

      if (charsAvail < formattedElem.length () + 1)
         {
         formattedArg += newLineString;
         charsAvail    = charsAvailPerLine;
         }
      else
         {
         formattedArg += " ";
         charsAvail   --;
         }

      formattedArg += formattedElem.c_str();
      charsAvail   -= formattedElem.length ();
      }
   }

//-----------------------------------------------------------------------------
//
// MclBoolVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclBoolVectorArg::MclBoolVectorArg(const bool* v, int l):
   MclVectorArg(l, MclArgValueType::boolType ()),
   boolVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclBoolVectorArg::MclBoolVectorArg");
}

MclBoolVectorArg::~MclBoolVectorArg()
{
}


MclArg * MclBoolVectorArg::clone() const
{
  MclArg * newInst = new MclBoolVectorArg(*this);
  return newInst;
}

MclBoolVectorArg::MclBoolVectorArg(const MclBoolVectorArg& theBoolVec):
   MclVectorArg (theBoolVec),
   boolVec_      (theBoolVec.boolVec_)
{
}

void MclBoolVectorArg::formatElem (
      std::string &       formattedElem,
      const std::string & theFormat,
      int                 theIndex,
      const MclFacility & theFacility)
      const
   {
   formatValidData (formattedElem, theFormat, boolVec_[theIndex], theFacility);
   }

//-----------------------------------------------------------------------------
//
// MclIntVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclIntVectorArg::MclIntVectorArg(const int* v, int l):
   MclVectorArg(l, MclArgValueType::intType ()),
   intVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclIntVectorArg::MclIntVectorArg");
}

MclIntVectorArg::~MclIntVectorArg()
{
}


MclArg * MclIntVectorArg::clone() const
{
  MclArg * newInst = new MclIntVectorArg(*this);
  return newInst;
}

MclIntVectorArg::MclIntVectorArg(const MclIntVectorArg& iv):
   MclVectorArg (iv),
   intVec_      (iv.intVec_)
{
}

void MclIntVectorArg::formatElem (
      std::string &       formattedElem,
      const std::string & theFormat,
      int                 theIndex,
      const MclFacility & theFacility)
      const
   {
   formatValidData (formattedElem, theFormat, intVec_[theIndex], theFacility);
   }

//-----------------------------------------------------------------------------
//
// MclFloatVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclFloatVectorArg::MclFloatVectorArg(const float* v, int l):
   MclVectorArg(l, MclArgValueType::floatType ()),
   floatVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclFloatVectorArg::MclFloatVectorArg");
}

MclFloatVectorArg::~MclFloatVectorArg()
{
}


MclArg * MclFloatVectorArg::clone() const
{
  MclArg * newInst = new MclFloatVectorArg(*this);
  return newInst;
}

MclFloatVectorArg::MclFloatVectorArg(const MclFloatVectorArg& iv):
   MclVectorArg (iv),
   floatVec_      (iv.floatVec_)
{
}

void MclFloatVectorArg::formatElem (
      std::string &       formattedElem,
      const std::string & theFormat,
      int                 theIndex,
      const MclFacility &)
      const
   {
   formatValidData (formattedElem, theFormat, floatVec_[theIndex]);
   }

//-----------------------------------------------------------------------------
//
// MclDoubleVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclDoubleVectorArg::MclDoubleVectorArg (const double * theCVec, int lengthArg):

      MclVectorArg (lengthArg, MclArgValueType::doubleType ()),
      doubleVec_   (theCVec)
   {
   if (lengthArg > 0)
      MclFacility::forbidNullArg (
         theCVec,
         "theCVec",
         "MclDoubleVectorArg::MclDoubleVectorArg");
   }

//-----------------------------------------------------------------------------

MclDoubleVectorArg::~MclDoubleVectorArg ()
   {
   }

//-----------------------------------------------------------------------------

MclArg * MclDoubleVectorArg::clone () const
   {
   return (new MclDoubleVectorArg (* this));
   }

//-----------------------------------------------------------------------------

MclDoubleVectorArg::MclDoubleVectorArg (
         const MclDoubleVectorArg & theDblVecArg):

      MclVectorArg (theDblVecArg),
      doubleVec_   (theDblVecArg.doubleVec_)
   {
   }

//-----------------------------------------------------------------------------

void MclDoubleVectorArg::formatElem (
      std::string &       formattedElem,
      const std::string & theFormat,
      int                 theIndex,
      const MclFacility &)
      const
   {
   formatValidData (formattedElem, theFormat, doubleVec_[theIndex]);
   }

//-----------------------------------------------------------------------------
//
// MclStringVectorArg Implementation
//
//-----------------------------------------------------------------------------

MclStringVectorArg::MclStringVectorArg(const char* const * v, int l):
      MclVectorArg(l, MclArgValueType::stringType ()),
      strVec_     (v)
   {
   int i;

   if (l > 0)
      MclFacility::forbidNullArg (
         v,
         "v",
         "MclStringVectorArg::MclStringVectorArg");

   for (i = 0; i < l; ++ i)
      MclFacility::forbidNullArg (
         v[i],
         "v[i]",
         "MclStringVectorArg::MclStringVectorArg");
   }

MclStringVectorArg::~MclStringVectorArg()
{
}


MclArg * MclStringVectorArg::clone() const
{
  MclArg * newInst = new MclStringVectorArg(*this);
  return newInst;
}

MclStringVectorArg::MclStringVectorArg(const MclStringVectorArg& sv):
   MclVectorArg (sv),
   strVec_      (sv.strVec_)
{
}

void MclStringVectorArg::formatElem (
      std::string &       formattedElem,
      const std::string & theFormat,
      int                 theIndex,
      const MclFacility &)
      const
   {
   formatValidData (formattedElem, theFormat, strVec_[theIndex]);
   }

//---------------------------------------------------------------------------
// Implementation of MclMakeVec functions.
//---------------------------------------------------------------------------

DECLSPEC MclBoolVectorArg STDCALL MclMakeVec (
      const bool * theBoolVector,
      int          length)
   {
   return MclBoolVectorArg (theBoolVector, length);
   }

DECLSPEC MclIntVectorArg STDCALL MclMakeVec (
      const int * theIntVector,
      int         length)
   {
   return MclIntVectorArg (theIntVector, length);
   }

DECLSPEC MclFloatVectorArg STDCALL MclMakeVec (
      const float * theFloatVector,
      int           length)
   {
   return MclFloatVectorArg (theFloatVector, length);
   }

DECLSPEC MclStringVectorArg STDCALL MclMakeVec (
      const char * const * theStringVector,
      int                  length)
   {
   return MclStringVectorArg (theStringVector, length);
   }

//---------------------------------------------------------------------------
//
// MclArgList Implementation
//
//---------------------------------------------------------------------------

// Default constructor
MclArgList::MclArgList()
{
  //Nothing to do here
}

// Destructor
MclArgList::~MclArgList()
{
  for ( size_t i=0; i<list_.size(); i++ ) delete list_[i];
}

// operator[]
const MclArg &
MclArgList::operator[]( size_t i )
const
{
  return *(list_[i-1]);
}

size_t MclArgList::length () const
   {
   return list_.size ();
   }

// operator <<

MclArgList & MclArgList::operator << (const MclArg & theArg)
   {
   MclArg * theCopy = theArg.clone ();

   list_.push_back (theCopy);

   return * this;
   }

MclArgList & MclArgList::operator << (bool theBool)
   {
   MclBoolArg theBoolArg (theBool);

   return (* this) << theBoolArg;
   }

MclArgList & MclArgList::operator << (int theInt)
   {
   MclIntArg theIntArg (theInt);

   return (* this) << theIntArg;
   }

MclArgList & MclArgList::operator << (float theFloat)
   {
   MclFloatArg theFloatArg (theFloat);

   return (* this) << theFloatArg;
   }

MclArgList & MclArgList::operator << (const char * theCstring)
   {
   MclStringArg theStringArg (theCstring);

   return (* this) << theStringArg;
   }

MclArgList & MclArgList::operator << (const MclMsgFrag * theFrag)
   {
   MclMsgFragArg theMsgFragArg (theFrag);

   return (* this) << theMsgFragArg;
   }

MclArgList & MclArgList::operator << (const std::string & theString)
   {
   MclStringArg theStringArg (theString.c_str ());

   return (* this) << theStringArg;
   }
@


1.21
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d1 14
@


1.20
log
@Fixed memory mismatch on the delete
@
text
@a26 4
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

d32 1
d34 4
a37 1
#include <iostream>
@


1.19
log
@[multi-thread]
@
text
@d377 1
a377 1
     delete buffer;
@


1.18
log
@[multi-thread]
@
text
@d77 1
a77 1
         reqFacilityCtor ();
d84 1
a84 1
         reqFacilityCtor ();
d91 1
a91 1
         reqFacilityCtor ();
d98 1
a98 1
         reqFacilityCtor ();
d105 1
a105 1
         reqFacilityCtor ();
d112 1
a112 1
         reqFacilityCtor ();
d149 1
a149 1
      inline static void reqFacilityCtor ()
d151 2
a152 2
         if (! MclFacility::ctorCalled ())
            noFacilityCtor ();
d155 1
a155 1
      static void noFacilityCtor ();
d207 1
a207 1
bool                    MclArgValueType::setUpDone_      = false;
d241 1
a241 1
void MclArgValueType::noFacilityCtor ()
@


1.17
log
@[multi-thread]
@
text
@a5 1
// ArgPtrVector
a50 15
      MclArgValueType (
            const char * nameVal,
            const char * validFlagsVal,
            const char * testFormatVal);
         //
         // Constructor
         //
         // name_       <-- nameVal
         // validFlags_ <-- validFlagsVal
         // testFormat_ <-- testFormatVal

      ~MclArgValueType ();
         //
         // Destructor

d55 1
a55 1
      inline const std::string & name       () const
d57 1
a57 1
         return                name_;
d62 1
a62 1
         return                validFlags_;
d65 1
a65 1
      inline const std::string & testFormat     () const
d67 1
a67 1
         return                testFormat_;
d77 3
a79 1
         return derefNonNull (              boolTypePtr_);
d84 3
a86 1
         return derefNonNull (              intTypePtr_);
d91 3
a93 1
         return derefNonNull (              floatTypePtr_);
d98 3
a100 1
         return derefNonNull (              doubleTypePtr_);
d105 3
a107 1
         return derefNonNull (              stringTypePtr_);
d112 3
a114 1
         return derefNonNull (              msgFragTypePtr_);
d119 1
a119 1
      static void initialize ();
d121 4
a124 1
         // Initializes this class.
d126 4
a129 1
      static void shutDown ();
d131 5
a135 1
         // Shuts down this class: returns it to an uninitialized state.
d137 5
a141 1
   private:
d149 1
a149 2
      inline static const MclArgValueType & derefNonNull (
            const MclArgValueType * theArgValueTypePtr)
d151 2
a152 4
         if (theArgValueTypePtr == NULL)
            missingFacility ();

         return * theArgValueTypePtr;
d155 1
a155 1
      static void missingFacility ();
d158 1
a158 1
         // was called when no Facility exists.
d164 1
a164 7
      //-----------------------------------------------------------------------
      // Note: the MclStrings declared here are really const, but have to
      // be declared as non-const in order to avoid a bug in either Rogue
      // Wave or the compiler that caused them to all have the same value.
      //-----------------------------------------------------------------------

      std::string name_;
d168 1
a168 1
      std::string validFlags_;
d173 1
a173 1
      std::string testFormat_;
d177 6
a182 6
      static MclArgValueType *    boolTypePtr_;
      static MclArgValueType *     intTypePtr_;
      static MclArgValueType *   floatTypePtr_;
      static MclArgValueType *  doubleTypePtr_;
      static MclArgValueType *  stringTypePtr_;
      static MclArgValueType * msgFragTypePtr_;
d186 8
d200 6
a205 21
MclArgValueType * MclArgValueType::   boolTypePtr_ = NULL;
MclArgValueType * MclArgValueType::    intTypePtr_ = NULL;
MclArgValueType * MclArgValueType::  floatTypePtr_ = NULL;
MclArgValueType * MclArgValueType:: doubleTypePtr_ = NULL;
MclArgValueType * MclArgValueType:: stringTypePtr_ = NULL;
MclArgValueType * MclArgValueType::msgFragTypePtr_ = NULL;

//-----------------------------------------------------------------------------

MclArgValueType::MclArgValueType (
         const char * nameVal,
         const char * validFlagsVal,
         const char * testFormatVal):

      name_       (nameVal),
      validFlags_ (validFlagsVal),
      testFormat_ (testFormatVal)
   {
   }

//-----------------------------------------------------------------------------
d207 1
a207 3
MclArgValueType::~MclArgValueType ()
   {
   }
d211 1
a211 1
void MclArgValueType::initialize ()
d213 2
a214 3
   MclFacility::mustBeInitShutDown ("MclArgValueType::initialize");

   assert (intTypePtr_ == NULL);
d222 2
d228 8
a235 1
void MclArgValueType::shutDown ()
a236 17
   MclFacility::mustBeInitShutDown ("MclArgValueType::shutDown");

   assert (intTypePtr_ != NULL);

   delete    boolTypePtr_;
   delete     intTypePtr_;
   delete   floatTypePtr_;
   delete  doubleTypePtr_;
   delete  stringTypePtr_;
   delete msgFragTypePtr_;

      boolTypePtr_ = NULL;
       intTypePtr_ = NULL;
     floatTypePtr_ = NULL;
    doubleTypePtr_ = NULL;
    stringTypePtr_ = NULL;
   msgFragTypePtr_ = NULL;
d241 1
a241 1
void MclArgValueType::missingFacility ()
a242 2
   assert (MclFacility::nInstances () == 0);

d246 2
a247 2
      "   An MclArg class constructor was called "
         "when no MclFacility exists.\n";
d293 1
a293 1
void MclArg::initialize ()
d295 1
a295 10
   MclFacility::mustBeInitShutDown ("MclArg::initialize");

   MclArgValueType::initialize ();
   }

void MclArg::shutDown ()
   {
   MclFacility::mustBeInitShutDown ("MclArg::shutDown");

   MclArgValueType::shutDown ();
@


1.16
log
@Attempt to fix 2 syntax errors found by the MS compiler.
@
text
@d4 5
d41 231
d277 4
a280 12
MclArg::MclArg (
         char         validFlag1Val,
         char         validFlag2Val,
         const char * testFormatVal,
         const char * typeNameVal):

      validFlag1_ (validFlag1Val),
      validFlag2_ (validFlag2Val),
      testFormat_ (testFormatVal),
      typeName_   (typeNameVal)
   {
   }
d301 2
a302 3
   if (theFlag != validFlag1_)
      if ((validFlag2_ == ' ') || (theFlag != validFlag2_))
         flagError (theFlag, argNum, theMsg);
d309 6
a314 1
   std::string theFormat;
d316 6
a321 1
   theFormat = testFormat_;
d323 1
a323 1
   formatValidArg (valueText, theFormat, theMsg);
d327 1
a327 4
      validFlag1_ (theArg.validFlag1_),
      validFlag2_ (theArg.validFlag2_),
      testFormat_ (theArg.testFormat_),
      typeName_   (theArg.typeName_)
d333 1
a333 1
   theName = typeName_;
d439 1
a439 2
//    "   Type of argument passed: "   << typeName.c_str()  << "\n"
      "   Type of argument passed: "   << typeName_         << "\n"
d451 2
d467 6
a472 3
//    "   Type of argument passed: "   << typeName.c_str() << "\n"
      "   Type of argument passed: "   << typeName_        << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n";
d474 1
a474 12
   if (validFlag2_ == ' ')
      std::cerr
         << "   The valid format flag for this type of argument is '"
         << validFlag1_
         << "'.\n";
   else
      std::cerr
         << "   The valid format flags for this type of argument are '"
         << validFlag1_
         << "' and '"
         << validFlag2_
         << "'.\n";
d502 5
a506 6
MclBoolArg::MclBoolArg (bool theBool):

      MclArg  ('b', ' ', "%b", "bool"),
      myBool_ (theBool)
   {
   }
d529 5
a533 5
MclIntArg::MclIntArg (int i):
      MclArg ('d', 'b', "%d", "int"),
      i_     (i)
   {
   }
d556 5
a560 5
MclFloatArg::MclFloatArg (float f):
      MclArg ('f', 'g', "%g", "float"),
      f_     (f)
   {
   }
d585 1
a585 1
      MclArg    ('f', 'g', "%.14g", "double"),
d629 6
a634 7
MclStringArg::MclStringArg (const char * s):

      MclArg  ('s', ' ', "%s", "const char *"),
      string_ (s)
   {
   MclFacility::forbidNullArg (s, "s", "MclStringArg::MclStringArg");
   }
d669 1
a669 2

      MclArg  ('m', 's', "%m", "const MclMsgFrag *"),
d721 1
a721 6
MclVectorArg::MclVectorArg (
         int          l,
         char         validFlag1Val,
         char         validFlag2Val,
         const char * testFormatVal,
         const char * typeNameVal):
d723 5
a727 4
      MclArg  (validFlag1Val, validFlag2Val, testFormatVal, typeNameVal),
      length_ (l)
   {
   }
d740 7
d802 7
a808 8
MclBoolVectorArg::MclBoolVectorArg (const bool * v, int l):

      MclVectorArg (l, 'b', ' ', "%b", "vector of type bool"),
      boolVec_     (v)
   {
   if (l > 0)
      MclFacility::forbidNullArg (v, "v", "MclBoolVectorArg::MclBoolVectorArg");
   }
d843 7
a849 8
MclIntVectorArg::MclIntVectorArg(const int * v, int l):

      MclVectorArg (l, 'd', 'b', "%d", "vector of type int"),
      intVec_      (v)
   {
   if (l > 0)
      MclFacility::forbidNullArg (v, "v", "MclIntVectorArg::MclIntVectorArg");
   }
d884 7
a890 11
MclFloatVectorArg::MclFloatVectorArg (const float* v, int l):

      MclVectorArg (l, 'f', 'g', "%g", "vector of type float"),
      floatVec_    (v)
   {
   if (l > 0)
      MclFacility::forbidNullArg (
         v,
         "v",
         "MclFloatVectorArg::MclFloatVectorArg");
   }
d927 1
a927 1
      MclVectorArg (lengthArg, 'f', 'g', "%.14g", "vector of type double"),
d978 3
a980 4
MclStringVectorArg::MclStringVectorArg (const char * const * v, int l):

      MclVectorArg (l, 's', ' ', "%s", "vector of type const char *"),
      strVec_      (v)
@


1.15
log
@[multi-thread]
@
text
@d74 1
a74 1
      if ((validFlag2_ == ' ') or (theFlag != validFlag2_))
@


1.14
log
@WIT Wish List item [multi-threading].
@
text
@a3 2
// Contains the declaration and implementation of class ArgValueType.
//
a35 1
// class ArgValueType.
d37 2
a38 3
// Responsible for some of the behavior of an Arg associated with the type
// of its value, where "value" refers to the scalar value associated with a
// scalar Arg or the scalar value of a single element of a VectorArg.
d41 10
a50 160
class MclArgValueType
   {
   public:

      MclArgValueType (
            const char * nameVal,
            const char * validFlagsVal,
            const char * testFormatVal);
         //
         // Constructor
         //
         // name_       <-- nameVal
         // validFlags_ <-- validFlagsVal
         // testFormat_ <-- testFormatVal

      ~MclArgValueType ();
         //
         // Destructor

      //-----------------------------------------------------------------------
      // Access functions
      //-----------------------------------------------------------------------

      inline const std::string & name       () const
         {
         return                name_;
         }

      inline const std::string & validFlags () const
         {
         return                validFlags_;
         }

      inline const std::string & testFormat     () const
         {
         return                testFormat_;
         }

      //-----------------------------------------------------------------------
      // Each of these functions returns the ArgValueType for the
      // appropriate type.
      //-----------------------------------------------------------------------

      inline static const MclArgValueType & boolType ()
         {
         return derefNonNull (              boolTypePtr_);
         }

      inline static const MclArgValueType & intType ()
         {
         return derefNonNull (              intTypePtr_);
         }

      inline static const MclArgValueType & floatType ()
         {
         return derefNonNull (              floatTypePtr_);
         }

      inline static const MclArgValueType & doubleType ()
         {
         return derefNonNull (              doubleTypePtr_);
         }

      inline static const MclArgValueType & stringType ()
         {
         return derefNonNull (              stringTypePtr_);
         }

      inline static const MclArgValueType & msgFragType ()
         {
         return derefNonNull (              msgFragTypePtr_);
         }

      //-----------------------------------------------------------------------

      static void initialize ();
         //
         // Initializes this class.

      static void shutDown ();
         //
         // Shuts down this class: returns it to an uninitialized state.

   private:

      MclArgValueType             (const MclArgValueType &);
      MclArgValueType & operator= (const MclArgValueType &);
         //
         // Copy ctor and assignment are declared private and not implemented
         // so as to prevent inadvertant copying and assignment.

      inline static const MclArgValueType & derefNonNull (
            const MclArgValueType * theArgValueTypePtr)
         {
         if (theArgValueTypePtr == NULL)
            missingFacility ();

         return * theArgValueTypePtr;
         }

      static void missingFacility ();
         //
         // Issues a client error indicating that a MclArg class constructor
         // was called when no Facility exists.

      //-----------------------------------------------------------------------
      // Data.
      //-----------------------------------------------------------------------

      //-----------------------------------------------------------------------
      // Note: the MclStrings declared here are really const, but have to
      // be declared as non-const in order to avoid a bug in either Rogue
      // Wave or the compiler that caused them to all have the same value.
      //-----------------------------------------------------------------------

      std::string name_;
         //
         // Text identifying this ArgValueType.

      std::string validFlags_;
         //
         // The list of valid output format flags for Args that have this
         // ArgValueType.

      std::string testFormat_;
         //
         // The format to be used for testing purposes.

      static MclArgValueType *    boolTypePtr_;
      static MclArgValueType *     intTypePtr_;
      static MclArgValueType *   floatTypePtr_;
      static MclArgValueType *  doubleTypePtr_;
      static MclArgValueType *  stringTypePtr_;
      static MclArgValueType * msgFragTypePtr_;
         //
         // Type behavior for Args whose values are ints, floats, strings, or
         // MsgFrags.
   };

//---------------------------------------------------------------------------
// Implementation of class MclArgValueType
//---------------------------------------------------------------------------

MclArgValueType * MclArgValueType::   boolTypePtr_ = NULL;
MclArgValueType * MclArgValueType::    intTypePtr_ = NULL;
MclArgValueType * MclArgValueType::  floatTypePtr_ = NULL;
MclArgValueType * MclArgValueType:: doubleTypePtr_ = NULL;
MclArgValueType * MclArgValueType:: stringTypePtr_ = NULL;
MclArgValueType * MclArgValueType::msgFragTypePtr_ = NULL;

//-----------------------------------------------------------------------------

MclArgValueType::MclArgValueType (
         const char * nameVal,
         const char * validFlagsVal,
         const char * testFormatVal):

      name_       (nameVal),
      validFlags_ (validFlagsVal),
      testFormat_ (testFormatVal)
a53 71
//-----------------------------------------------------------------------------

MclArgValueType::~MclArgValueType ()
   {
   }

//-----------------------------------------------------------------------------

void MclArgValueType::initialize ()
   {
   MclFacility::mustBeInitShutDown ("MclArgValueType::initialize");

   assert (intTypePtr_ == NULL);

      boolTypePtr_ = new MclArgValueType ("bool",               "b",  "%b");
       intTypePtr_ = new MclArgValueType ("int",                "db", "%d");
     floatTypePtr_ = new MclArgValueType ("float",              "fg", "%g");
    doubleTypePtr_ = new MclArgValueType ("double",             "fg", "%.14g");
    stringTypePtr_ = new MclArgValueType ("const char *",       "s",  "%s");
   msgFragTypePtr_ = new MclArgValueType ("const MclMsgFrag *", "ms", "%m");
   }

//-----------------------------------------------------------------------------

void MclArgValueType::shutDown ()
   {
   MclFacility::mustBeInitShutDown ("MclArgValueType::shutDown");

   assert (intTypePtr_ != NULL);

   delete    boolTypePtr_;
   delete     intTypePtr_;
   delete   floatTypePtr_;
   delete  doubleTypePtr_;
   delete  stringTypePtr_;
   delete msgFragTypePtr_;

      boolTypePtr_ = NULL;
       intTypePtr_ = NULL;
     floatTypePtr_ = NULL;
    doubleTypePtr_ = NULL;
    stringTypePtr_ = NULL;
   msgFragTypePtr_ = NULL;
   }

//-----------------------------------------------------------------------------

void MclArgValueType::missingFacility ()
   {
   assert (MclFacility::nInstances () == 0);

   std::cerr <<
      "\n\n"
      "MCL CLIENT ERROR:\n\n"
      "   An MclArg class constructor was called "
         "when no MclFacility exists.\n";

   MclFacility::abortMcl ();
   }

//-----------------------------------------------------------------------------
//
// MclArg Implementation
//
//-----------------------------------------------------------------------------

MclArg::MclArg (const MclArgValueType & theValueType):
   myValueType_ (theValueType)
{
}

d73 3
a75 2
   if (myValueType_.validFlags ().find (theFlag) == std::string::npos)
      flagError (theFlag, argNum, theMsg);
d82 1
a82 2
   formatValidArg (valueText, myValueType_.testFormat (), theMsg);
   }
d84 1
a84 3
void MclArg::initialize ()
   {
   MclFacility::mustBeInitShutDown ("MclArg::initialize");
d86 1
a86 8
   MclArgValueType::initialize ();
   }

void MclArg::shutDown ()
   {
   MclFacility::mustBeInitShutDown ("MclArg::shutDown");

   MclArgValueType::shutDown ();
d90 4
a93 1
      myValueType_ (theArg.myValueType_)
d99 1
a99 1
   theName = myValueType_.name ();
d205 2
a206 1
      "   Type of argument passed: "   << typeName.c_str()  << "\n"
a217 2
   std::string validFlags = myValueType_.validFlags ();
   size_t    theIndex;
d232 3
a234 3
      "   Type of argument passed: "   << typeName.c_str() << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n"
      "   The valid format flags for this type of argument are:";
d236 12
a247 4
   for (theIndex = 0; theIndex < validFlags.length (); ++ theIndex) 
      std::cerr << " '"  << validFlags.substr (theIndex, 1).c_str()  << "'";

   std::cerr << "\n";
d275 6
a280 5
MclBoolArg::MclBoolArg(bool theBool):
  MclArg(MclArgValueType::boolType ()),
  myBool_    (theBool)
{
}
d303 5
a307 5
MclIntArg::MclIntArg(int i):
  MclArg(MclArgValueType::intType ()),
  i_    (i)
{
}
d330 5
a334 5
MclFloatArg::MclFloatArg(float f):
  MclArg(MclArgValueType::floatType ()),
  f_    (f)
{
}
d359 1
a359 1
      MclArg    (MclArgValueType::doubleType ()),
d403 7
a409 6
MclStringArg::MclStringArg(const char * s):
  MclArg(MclArgValueType::stringType ()),
   string_(s)
{
MclFacility::forbidNullArg (s, "s", "MclStringArg::MclStringArg");
}
d444 2
a445 1
      MclArg  (MclArgValueType::msgFragType ()),
d497 6
a502 1
MclVectorArg::MclVectorArg (int l, const MclArgValueType & theValueType):
d504 4
a507 5
   MclArg (theValueType),
   length_(l)
{
  // do nothing
}
a519 7
void MclVectorArg::getTypeName (std::string & theName) const
   {
   MclArg::getTypeName (theName);

   theName += " Vector";
   }

d575 8
a582 7
MclBoolVectorArg::MclBoolVectorArg(const bool* v, int l):
   MclVectorArg(l, MclArgValueType::boolType ()),
   boolVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclBoolVectorArg::MclBoolVectorArg");
}
d617 8
a624 7
MclIntVectorArg::MclIntVectorArg(const int* v, int l):
   MclVectorArg(l, MclArgValueType::intType ()),
   intVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclIntVectorArg::MclIntVectorArg");
}
d659 11
a669 7
MclFloatVectorArg::MclFloatVectorArg(const float* v, int l):
   MclVectorArg(l, MclArgValueType::floatType ()),
   floatVec_     (v)
{
if (l > 0)
   MclFacility::forbidNullArg (v, "v", "MclFloatVectorArg::MclFloatVectorArg");
}
d706 1
a706 1
      MclVectorArg (lengthArg, MclArgValueType::doubleType ()),
d757 4
a760 3
MclStringVectorArg::MclStringVectorArg(const char* const * v, int l):
      MclVectorArg(l, MclArgValueType::stringType ()),
      strVec_     (v)
@


1.13
log
@Added code to pass arguments of type "bool" and "const bool *" to a Msg.
@
text
@d4 1
a4 4
// Contains the declaration and implementation of the following classes:
//
// ArgPtrVector
// ArgValueType
@


1.12
log
@Attempt to fix syntax errors from the gcc 3.4.1 compiler.
@
text
@d12 1
d19 1
d91 5
d176 1
d191 1
d225 1
d241 1
d248 1
d498 27
d798 41
d1028 10
a1037 1
DECLSPEC MclIntVectorArg STDCALL MclMakeVec (const int * theIntVector, int length)
d1042 3
a1044 1
DECLSPEC MclFloatVectorArg STDCALL MclMakeVec (const float * theFloatVector, int length)
d1098 7
@


1.11
log
@Added double vector arguments.
@
text
@d996 1
a996 1
// operator<<
d998 5
a1002 6
MclArgList& MclArgList::operator<<(const MclArg & arg)
{
  MclArg * a = arg.clone();
  list_.push_back(a);
  return *this;
}
d1004 2
a1005 4
MclArgList& MclArgList::operator<<(int i)
{
  return (*this) << MclIntArg(i);
}
d1007 3
a1009 4
MclArgList& MclArgList::operator<<(float f)
{
  return (*this) << MclFloatArg(f);
}
d1011 2
a1012 4
MclArgList& MclArgList::operator<<(const char * string)
{
  return (*this) << MclStringArg(string);
}
d1014 1
a1014 1
MclArgList & MclArgList::operator<< (const MclMsgFrag * theFrag)
d1016 3
a1018 1
   return (* this) << MclMsgFragArg (theFrag);
d1021 1
a1021 1
MclArgList & MclArgList::operator<< (const std::string& theFrag)
d1023 17
a1039 2
    const char * string = theFrag.c_str();
   return (* this) << MclStringArg (string);
@


1.10
log
@Adding double precision argument capability.
@
text
@d20 1
d218 1
a218 1
    doubleTypePtr_ = new MclArgValueType ("double",             "fg", "%g");
d837 53
@


1.9
log
@Changes to build on linux
@
text
@d14 1
a36 5

//---------------------------------------------------------------------------
// Rogue Wave Declarations and Implementations
//---------------------------------------------------------------------------

d98 5
d170 1
d184 1
d217 1
d232 1
d238 1
d276 3
a278 3
      MclBoolean        reqVector,
      int               argNum,
      const MclMsg *    theMsg)
d329 2
a330 2
      std::string &         formattedData,
      const std::string &   theFormat,
d358 1
a358 1
      float             theData)
d362 1
a362 1
   sprintf (buffer, theFormat.c_str(), theData);
d370 13
a382 1
      const char *      theData)
d504 1
a504 1
      const MclMsg *    theMsg)
d539 46
d614 2
a615 2
      std::string &         formattedArg,
      const std::string &   theFormat,
d715 1
a715 1
      const MclMsg *    theMsg)
d788 2
a789 2
      std::string &         formattedElem,
      const std::string &   theFormat,
d829 2
a830 2
      std::string &         formattedElem,
      const std::string &   theFormat,
d881 2
a882 2
      std::string &         formattedElem,
      const std::string &   theFormat,
@


1.8
log
@Modified to always include iostream and not iostream.h
@
text
@d26 1
@


1.7
log
@Went to std::cout all the way
@
text
@d33 1
a33 5
#ifdef STD_CPP_LIB
#  include <iostream>
#else
#  include <iostream.h>
#endif
@


1.6
log
@modications to change rogueWave tools.h++ to STL
@
text
@d246 1
a246 1
   cerr <<
d402 1
a402 1
   cerr <<
d431 1
a431 1
   cerr <<
d444 1
a444 1
      cerr << " '"  << validFlags.substr (theIndex, 1).c_str()  << "'";
d446 1
a446 1
   cerr << "\n";
d908 6
@


1.5
log
@Removed a test comment.
@
text
@d31 1
a31 3
#include <rw/cstring.h>
#include <rw/gordvec.h>
#include <rw/regexp.h>
a43 37
typedef MclArg * MclArgPtr;

declare   (RWGVector,        MclArgPtr)
declare   (RWGOrderedVector, MclArgPtr)

implement (RWGVector,        MclArgPtr)
implement (RWGOrderedVector, MclArgPtr)

//-----------------------------------------------------------------------------
// class ArgPtrVector.
//
// Wrapper (by inheritance) for RWGOrderedVector(MclArgPtr).
// The purpose of this class is to avoid the need to #include rw/gordvec.h in
// arg.h. It allows ArgList to use a forward reference to this class, rather
// than a forward reference to class RWGOrderedVector(MclArgPtr), which would
// not be possible, because it is a generic class.
// All Implementation is inline.
//-----------------------------------------------------------------------------

class MclArgPtrVector: public RWGOrderedVector(MclArgPtr)
   {
   public:

      inline MclArgPtrVector (size_t capac):
            RWGOrderedVector(MclArgPtr) (capac)
         {
         }

   private:

      MclArgPtrVector             (const MclArgPtrVector &);
      MclArgPtrVector & operator= (const MclArgPtrVector &);
         //
         // Copy ctor and assignment are declared private and not implemented
         // so as to prevent inadvertant copying and assignment.
   };

d75 1
a75 1
      inline const RWCString & name       () const
d80 1
a80 1
      inline const RWCString & validFlags () const
d85 1
a85 1
      inline const RWCString & testFormat     () const
d152 1
a152 1
      // Note: the RWCStrings declared here are really const, but have to
d157 1
a157 1
      RWCString name_;
d161 1
a161 1
      RWCString validFlags_;
d166 1
a166 1
      RWCString testFormat_;
d271 2
a272 2
      RWCString &       formattedArg,
      const RWCString & theFormat,
d285 1
a285 1
   if (myValueType_.validFlags ().first (theFlag) == RW_NPOS)
d291 1
a291 1
void MclArg::getValueText (RWCString & valueText, const MclMsg * theMsg) const
d315 1
a315 1
void MclArg::getTypeName (RWCString & theName) const
d326 2
a327 2
      RWCString &         formattedData,
      const RWCString &   theFormat,
d333 1
a333 1
      RWCString stringFormat = theFormat;
d346 1
a346 1
        sprintf (buffer, theFormat, theData);
d353 2
a354 2
      RWCString &       formattedData,
      const RWCString & theFormat,
d359 1
a359 1
   sprintf (buffer, theFormat, theData);
d365 2
a366 2
      RWCString &       formattedData,
      const RWCString & theFormat,
d375 1
a375 1
     sprintf (buffer, theFormat, theData);
d380 1
a380 1
char & MclArg::formatFlag (RWCString & theFormat)
d385 1
a385 1
char MclArg::formatFlag (const RWCString & theFormat)
d396 2
a397 2
   RWCString typeName;
   RWCString valueText;
d411 2
a412 2
      "   Type of argument passed: "   << typeName      << "\n"
      "   Argument value:          "   << valueText     << "\n";
d423 1
a423 1
   RWCString validFlags = myValueType_.validFlags ();
d425 2
a426 2
   RWCString typeName;
   RWCString valueText;
d439 2
a440 2
      "   Type of argument passed: "   << typeName      << "\n"
      "   Argument value:          "   << valueText     << "\n"
d444 1
a444 1
      cerr << " '"  << validFlags (theIndex, 1)  << "'";
d451 1
a451 1
int MclArg::getWidth(const RWCString & format)
d453 12
a464 14
  RWCRegexp re("%-?[0-9]+s");
  if (format.index(re) != RW_NPOS)
    {
      RWCRegexp re1("[0-9]");
      RWCRegexp re2("s");
      size_t idx1 = format.index(re1);
      size_t idx2 = format.index(re2);
      size_t len = idx2-idx1;
      const RWCSubString subStr = format(idx1, len);
      RWCString str(subStr);
      int length = atoi(str.data());
      return length;
    }
  return -1;
d487 2
a488 2
      RWCString &       formattedArg,
      const RWCString & theFormat,
d514 2
a515 2
      RWCString &       formattedArg,
      const RWCString & theFormat,
d553 2
a554 2
      RWCString &         formattedArg,
      const RWCString &   theFormat,
d601 2
a602 2
      RWCString &       formattedArg,
      const RWCString & theFormat,
d606 1
a606 1
   RWCString finalFormat = theFormat;
d639 1
a639 1
void MclVectorArg::getTypeName (RWCString & theName) const
d652 2
a653 2
      RWCString &       formattedArg,
      const RWCString & theFormat,
d657 5
a661 5
   RWCString formattedElem;
   int       i;
   int       charsAvail;
   int       charsAvailPerLine;
   RWCString newLineString ("\n");
d663 1
a663 1
   newLineString += RWCString (' ', theMsg->vectorIndent ());
d690 1
a690 1
      formattedArg += formattedElem;
d727 2
a728 2
      RWCString &         formattedElem,
      const RWCString &   theFormat,
d768 2
a769 2
      RWCString &         formattedElem,
      const RWCString &   theFormat,
d820 2
a821 2
      RWCString &         formattedElem,
      const RWCString &   theFormat,
d857 1
a857 2
MclArgList::MclArgList():
   list_ (* new MclArgPtrVector (10))
d865 1
a865 3
  for ( size_t i=0; i<list_.entries(); i++ ) delete list_[i];

  delete & list_;
a867 1

d873 1
a873 1
  return * (list_[i-1]);
d878 1
a878 1
   return list_.entries ();
d886 1
a886 1
  list_.insert(a);
@


1.5.2.1
log
@Removed references to RWCString, RWRegExp, RWSubString
@
text
@d31 1
d114 1
a114 1
      inline const std::string & name       () const
d119 1
a119 1
      inline const std::string & validFlags () const
d124 1
a124 1
      inline const std::string & testFormat     () const
d191 1
a191 1
      // Note: the MclStrings declared here are really const, but have to
d196 1
a196 1
      std::string name_;
d200 1
a200 1
      std::string validFlags_;
d205 1
a205 1
      std::string testFormat_;
d310 2
a311 2
      std::string &       formattedArg,
      const std::string & theFormat,
d324 1
a324 1
   if (myValueType_.validFlags ().find (theFlag) == std::string::npos)
d330 1
a330 1
void MclArg::getValueText (std::string & valueText, const MclMsg * theMsg) const
d354 1
a354 1
void MclArg::getTypeName (std::string & theName) const
d365 2
a366 2
      std::string &         formattedData,
      const std::string &   theFormat,
d372 1
a372 1
      std::string stringFormat = theFormat;
d385 1
a385 1
        sprintf (buffer, theFormat.c_str(), theData);
d392 2
a393 2
      std::string &       formattedData,
      const std::string & theFormat,
d398 1
a398 1
   sprintf (buffer, theFormat.c_str(), theData);
d404 2
a405 2
      std::string &       formattedData,
      const std::string & theFormat,
d414 1
a414 1
     sprintf (buffer, theFormat.c_str(), theData);
d419 1
a419 1
char & MclArg::formatFlag (std::string & theFormat)
d424 1
a424 1
char MclArg::formatFlag (const std::string & theFormat)
d435 2
a436 2
   std::string typeName;
   std::string valueText;
d450 2
a451 2
      "   Type of argument passed: "   << typeName.c_str()  << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n";
d462 1
a462 1
   std::string validFlags = myValueType_.validFlags ();
d464 2
a465 2
   std::string typeName;
   std::string valueText;
d478 2
a479 2
      "   Type of argument passed: "   << typeName.c_str() << "\n"
      "   Argument value:          "   << valueText.c_str()     << "\n"
d483 1
a483 1
      cerr << " '"  << validFlags.substr (theIndex, 1).c_str()  << "'";
d490 1
a490 1
int MclArg::getWidth(const std::string & format)
a491 14
	size_t i = format.find('%');
	if( i < format.length() )
	{
		std::string widthStr;
		if( format[++i] == '-' )
			i++; // if a '-' was following the %, skip it;
		while( isdigit( format[i] ) )
			widthStr += format[i++];
		int length = atoi(widthStr.c_str());
		return length;
	}
	return -1;

/*
d493 1
a493 1
  if (format.index(re) != std::string::npos)
d500 3
a502 2
	  std::string subStr = format.substr(idx1, len);
      int length = atoi(subStr.c_str());
d505 1
a505 1
  return -1; */
d528 2
a529 2
      std::string &       formattedArg,
      const std::string & theFormat,
d555 2
a556 2
      std::string &       formattedArg,
      const std::string & theFormat,
d594 2
a595 2
      std::string &         formattedArg,
      const std::string &   theFormat,
d642 2
a643 2
      std::string &       formattedArg,
      const std::string & theFormat,
d647 1
a647 1
   std::string finalFormat = theFormat;
d680 1
a680 1
void MclVectorArg::getTypeName (std::string & theName) const
d693 2
a694 2
      std::string &       formattedArg,
      const std::string & theFormat,
d698 1
a698 1
   std::string formattedElem;
d702 1
a702 1
   std::string newLineString ("\n");
d704 1
a704 1
   newLineString += std::string (theMsg->vectorIndent(), ' ');
d731 1
a731 1
      formattedArg += formattedElem.c_str();
d768 2
a769 2
      std::string &         formattedElem,
      const std::string &   theFormat,
d809 2
a810 2
      std::string &         formattedElem,
      const std::string &   theFormat,
d861 2
a862 2
      std::string &         formattedElem,
      const std::string &   theFormat,
@


1.5.2.2
log
@Removed references to misc RWVectors, dictionaries, hash, etc
@
text
@d32 1
@


1.5.2.3
log
@Removed references to misc RWGOrdered and related classes and some compiler warnings
@
text
@d31 1
a31 1
#include <vector>
d44 37
d502 15
d710 3
a712 3
   size_t       i;
   size_t       charsAvail;
   size_t       charsAvailPerLine;
d909 2
a910 1
MclArgList::MclArgList()
d918 3
a920 1
  for ( size_t i=0; i<list_.size(); i++ ) delete list_[i];
d923 1
d929 1
a929 1
  return *(list_[i-1]);
d934 1
a934 1
   return list_.size ();
d942 1
a942 1
  list_.push_back(a);
@


1.4
log
@testing cvs commit
@
text
@a23 2
// CVS commit test

@


1.3
log
@Testing cvs
@
text
@d24 2
@


1.2
log
@testing cvs
@
text
@a22 1
// Testing CVS comment
@


1.1
log
@Initial revision
@
text
@d23 1
@


1.1.1.1
log
@MCL Import
@
text
@@

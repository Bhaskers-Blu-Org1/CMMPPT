head	1.30;
access;
symbols
	sce_5_01_20080919:1.23
	latest_sce_4_20_20060523:1.20.0.4
	sce_4_20_20060523:1.20
	latest_sce4_20_OSL:1.20.0.2
	sce_4_20_OSL:1.20
	sce_4_20_20051222:1.20
	sce_4_10_30050426:1.18
	sce_4_05_20040511:1.16
	sce_4_00_20040201:1.14
	nextGenBranch:1.9.0.2
	nextGenRoot:1.9
	sce_3_30_20030627:1.9
	EndRw-branch:1.7.0.6
	Root-of-EndRw:1.7
	EndWitRw-branch:1.7.0.4
	Root-of-EndWitRw:1.7
	RwToStl-branch:1.7.0.2
	Root-of-RwToStl:1.7
	latest_sce_3_10_20010924:1.2.0.2
	sce_3_10_20010924:1.2
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2011.03.22.17.23.05;	author ervolina;	state Exp;
branches;
next	1.29;
deltatype	text;
permissions	644;
commitid	19944d88d9d47ee4;
kopt	kv;
filename	@scenSce.h@;

1.29
date	2011.03.17.18.01.16;	author ervolina;	state Exp;
branches;
next	1.28;
deltatype	text;
permissions	644;
commitid	25bc4d824b6d15ef;
kopt	kv;
filename	@scenSce.h@;

1.28
date	2010.03.26.19.48.25;	author ervolina;	state Exp;
branches;
next	1.27;
deltatype	text;

1.27
date	2010.03.16.17.56.23;	author ervolina;	state Exp;
branches;
next	1.26;
deltatype	text;

1.26
date	2010.03.13.18.53.06;	author ervolina;	state Exp;
branches;
next	1.25;
deltatype	text;

1.25
date	2009.12.08.13.58.36;	author ervolina;	state Exp;
branches;
next	1.24;
deltatype	text;

1.24
date	2009.01.28.14.22.31;	author ervolina;	state Exp;
branches;
next	1.23;
deltatype	text;

1.23
date	2007.03.21.18.03.29;	author ervolina;	state Exp;
branches;
next	1.22;
deltatype	text;

1.22
date	2006.08.09.16.32.18;	author ervolina;	state Exp;
branches;
next	1.21;
deltatype	text;

1.21
date	2006.06.26.15.23.32;	author ervolina;	state Exp;
branches;
next	1.20;
deltatype	text;

1.20
date	2005.11.09.18.32.48;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;

1.19
date	2005.08.10.22.44.53;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2005.02.15.20.45.02;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;

1.17
date	2004.10.08.13.03.44;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2004.03.04.14.19.29;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2004.03.02.04.22.51;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2004.01.31.03.58.43;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2004.01.23.02.59.16;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2004.01.22.02.47.49;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2004.01.10.17.56.12;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2003.08.04.20.54.24;	author dpc;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2003.06.26.23.09.38;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2003.01.15.19.36.58;	author rwToStl;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2002.11.07.19.01.09;	author austel;	state Exp;
branches
	1.7.6.1;
next	1.6;
deltatype	text;

1.6
date	2002.08.08.17.37.44;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2002.07.02.20.20.07;	author ervolina;	state Exp;
branches;
next	1.4;
deltatype	text;

1.4
date	2002.03.28.21.49.43;	author ervolina;	state Exp;
branches;
next	1.3;
deltatype	text;

1.3
date	2001.10.17.22.04.43;	author ervolina;	state Exp;
branches;
next	1.2;
deltatype	text;

1.2
date	2001.09.24.16.38.14;	author ervolina;	state Exp;
branches;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches;
next	;
deltatype	text;

1.7.6.1
date	2003.01.08.17.43.19;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.30
log
@fixed compatability issues between version 5 and 6
@
text
@#ifndef SCENARIOFORSCE_H
#define SCENARIOFORSCE_H

// RW2STL - inserted:
#include <string>
#include <fstream>
// End of RW2STL - inserted includes.

//#include <sce/src/sceErr.h>

#include <scenario/src/scenario.h>
#include <sce/src/sceDefin.h>
#include <sce/src/sceParam.h>
#include <sce/src/mPlantH.h>
#include <sce/src/sceCrtLs.h>
#include <sce/src/fFileMgr.h>
#include <sce/src/aEngMgr.h>

#include <sce/src/scrub.h>

#include <mcl/src/mcl.h>
#include <sce/src/message.h>

#ifdef SCE_ODBC
#include <sce/src/db.h>
#endif

// Set codes.  Not using enums because subclasses can have more sets
// The following were set by the base class
#define LGFR_DEFAULT_SET       0
#define LGFR_UNIVERSAL_SET     1
#define LGFR_INTERPLANT_SET    2



// forward declarations
class LgFrInitialProblemAndParameters;
class SCETokenizer;
class LgFrSceBaseExploder;

// added to avoid syntax error - vra
class LgFrScenarioForSceSmartPointer;

class LgFrScenarioForSce : public LgFrScenario
{

  // friends (need access to scenario-specific set of Parts)
friend class LgFrInitialProblemForSce;
friend class LgFrScenarioForSceSmartPointerToConst;
friend class LgFrScenarioForSceSmartPointer;

  // Friend to allow heuristic engine manager to add demands
friend class LgFrSceHeurEngineMgr;

  public:



// SCE 6.1
int
printAPegFile(WitRun * const theWitRun, 
	      LgFrMultiPlantHelper & mpHelper,
	      LgFrCalendar & theCal,
	      int pegType, 
	      int tinpIndpOrBoth,
	      std::string & pegFileName,
	      int nParts,
	      char ** partList,
	      int nPeriods);


  virtual int GetScenarioType() const { return __LGFRSCENARIOFORSCE; }

  
  void 
  printTotalDemandFile(WitRun * const theWitRun,   // WIT environment
                       LgFrSceBaseExploder * exploder,
                       const int nPeriods,         // Number of periods 
                       const int nParts,           // Number of parts   
                       char ** partList,           // List of part names
                       std::string fileName,
                       LgFrMultiPlantHelper & mpHelper);

// prints a record of a DB Dump file
// returns 1 if printed, 0 if not
int
printDbDumpRec(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const float *  floatVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods, 
    int printIfVectorIsAllZero);

// prints a (boolean) record of a DB Dump file
// returns 1 
int
printDbDumpRecBool(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const witBoolean *  boolVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods);


  
  
  // return a exploder object
  LgFrSceBaseExploder *
  exploder();

  // this is a quick and dirty implementation of exploderFactory
  // Eventually, it should be moved to exploders.h (or something).
  LgFrSceBaseExploder *
  createAppropriateSceExploder(LgFrScenarioForSceSmartPointer sceScenSP);

  void   
  runExplosion(LgFrScenarioForSceSmartPointer scenSceSP);

  void   
  printExplosionResults();
  
  void
  printModelStructureOutputs();

  int
  nStandaloneFeatureArcs()
  const;
  
  void
  nStandaloneFeatureArcs(int nFeats);

  void
  incrementStandaloneFeatureArcs();
  
  int
  nDemandsWithNonZeroMins()
  const;

  void
  nDemandsWithNonZeroMins(int nMins);

  void
  incNDemandsWithNonZeroMins();

  void
  decNDemandsWithNonZeroMins();

  void
  setEngine(const std::string & engine);

  std::string
  getEngine();

  // moving to FFmgr
  //  void 
  //  LgFrScenarioForSce::writeFloatVector(
  // std::ofstream & theStream,   // output stream (already opened)
  // int    vLength,         // lenght of the vector (nPeriods?)
  // float * theVector,      // the vector itself
  // int precision,          // number of digits to the right of the decimal
  // int totalSpace);



  int 
  determineGeoToPdfSourceVector(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & geoPlannerDemandPartName,
    std::string * sourceList);

  void 
  analyzeRunAndPrintResults();
  
  void
  printHumanReadableSupplyPlanSoln(
    WitRun * const theWitRun,   // WIT environment
    const int nPeriods,         // Number of periods
    const int nParts,           // Number of parts
    char ** partList,           // List of part names
    std::string fileName,         // Name of output filename
    LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper);


  void
  printBacklogSchedule(
                       WitRun * const theWitRun,   // WIT environment
                       const int nPeriods,         // Number of periods
                       const int nParts,           // Number of parts
                       char ** partList,           // List of part names
                       std::string fileName,
                       LgFrCalendar & theCal,
                       LgFrMultiPlantHelper & mpHelper);


  void 
  printIndepSupplyPlanSoln(
			   WitRun * const theWitRun,   // WIT environment   
			   const int nPeriods,         // Number of periods 
			   const int nParts,           // Number of parts   
			   char ** partList,           // List of part names
			   std::string fileName,
			   LgFrCalendar & theCal,
			   LgFrMultiPlantHelper & mpHelper);


  void
  printSupplyPlanSoln(
    WitRun * const theWitRun,   // WIT environment
    const int nPeriods,         // Number of periods
    const int nParts,           // Number of parts
    char ** partList,           // List of part names
    const int tinpIndpOrBoth,
    std::string fileName,         // Name of output filename
    LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper);


 void 
setHeuristicSearchIncrement(WitRun * const theWitRun,   
			    std::string greedySearchIncrementMethod, 
			    float anIncValue);
  

  void printBuildSchedule(
         WitRun * const theWitRun,   // WIT environment
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName,
         LgFrCalendar & theCal,
         LgFrMultiPlantHelper & mpHelper);



  //  ---------------------------------------------------------------------
  //  Print Operation Orders File (as determined by implosion)
  //  Prints execVol of operations that are:
  //  (1) explicitely defined by the user in the operation Definition File
  //  (2) SCE-defined generated from parts defined in the part Definition File
  //  --------------------------------------------------------------------- 
  void printOperationOrdersFile(
         WitRun * const theWitRun,   // WIT environment
         const int nPeriods,         // Number of periods
         std::string fileName,
         LgFrMultiPlantHelper & mpHelper);

  //  ---------------------------------------------------------------------
  //  Print Operation Demand File (as determined by explosion)
  //  Prints mrpExecVol of operations that are:
  //  (1) explicitely defined by the user in the operation Definition File
  //  (2) SCE-defined generated from parts defined in the part Definition File
  //  --------------------------------------------------------------------- 
  void 
  printOperationDemandVolFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper);


#ifdef ENABLE_NEGATIVE_DEMANDS
  LgFrTimeVecFloat excessVolAdjustedForNegativeDemands(
    float * witExcessVol,
    float * supplyVol,
    LgFrTimeVecFloat & negDemVol,
    int nPeriods);
#endif

  

  //  ---------------------------------------------------------------------
  //  Print DEBUG version critical parts list ... prints out specialParts 
  //      good for debugging
  //  ---------------------------------------------------------------------
  void  printDebugCriticalList(
			       WitRun * const theWitRun,   // WIT environment
			       std::string engine,
			       const int nPeriods,         // Number of periods
			       const int nParts,           // Number of parts
			       char ** partList,           // List of part names
			       std::string fileName,
			       LgFrCalendar & theCal,
			       LgFrMultiPlantHelper & mpHelper,
			       LgFrSceCritList & theCritList);



  //  ---------------------------------------------------------------------
  //  Print critical parts list
  //  ---------------------------------------------------------------------
  void  printCriticalList(
         WitRun * const theWitRun,   // WIT environment
         std::string engine,
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName,
         LgFrCalendar & theCal,
         LgFrMultiPlantHelper & mpHelper,
         LgFrSceCritList & theCritList);

  //  ---------------------------------------------------------------------
  //  Print pegged critical parts list
  //  ---------------------------------------------------------------------
  void printPeggedCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // only works for heuristic allocation
	 std::string fileNameBox,
	 std::string fileNameIndp,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper);

  // SCE 6.1 for use with multiAttribute.   It prints to one and only one file for both INDP and TINP
  //  ---------------------------------------------------------------------
  //  Print pegged critical parts list
  //  ---------------------------------------------------------------------
  void printPeggedCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // only works for heuristic allocation
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper);





  void 
  printShadowPrices(
		    WitRun * const theWitRun,   // WIT environment   
		    const int nPeriods,         // Number of periods 
		    int nParts,
		    char ** partList,
		    std::string fileName,
		    LgFrMultiPlantHelper & mpHelper);
  




  //  ---------------------------------------------------------------------
  //  Print Interplant Volumes (can be used for imploion or explosion)
  //  --------------------------------------------------------------------- 
  void   printInterplantVolumesFile(
				    WitRun * const theWitRun,
				    const int nPeriods,      
				    int nOps,
				    char ** opList,
				    bool isThisMrp,
				    std::string fileName,
				    LgFrMultiPlantHelper & mpHelper);

//  ---------------------------------------------------------------------
//  Print AlternatePart Volumes (can be used by implosion or explosion)
//  --------------------------------------------------------------------- 
void 
printAlternateDbFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper);



  // two helper methods to retrieve the adjusted  interplant exec Vols
  LgFrTimeVecFloat interplantExecVol(std::string & operationName);
  LgFrTimeVecFloat interplantMrpExecVol(std::string & operationName);

  //  ---------------------------------------------------------------------
  //  initializes the adjusted interplant execVols for mrp (sets to 0 for implosion)
  //  ---------------------------------------------------------------------
  void initializeInterplantOperationsAppData(
					     WitRun * const theWitRun,
					     const int nPeriods,                              
					     const int nOperations,
					     char ** operationList);

  //  ---------------------------------------------------------------------
  //  sets the adjusted interplant execVols for  implosion
  //  ---------------------------------------------------------------------
  void setInterplantOperationsAppDataForImplosion(
						    WitRun * const theWitRun,
						    const int nPeriods,                              
						    const int nOperations,
						    char ** operationList);


  void printCapUsageVolume(WitRun * const theWitRun, 
			   bool isItMrp);


  //  ---------------------------------------------------------------------
  //  Print Substitute Prod vols
  //  ---------------------------------------------------------------------
  void printSubstituteProductionVolume(
    WitRun * const theWitRun,   // WIT environment
    const int nPeriods,         // Number of periods
    const int nParts,           // Number of parts
    char ** partList,           // List of part names
    std::string fileName,
    LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper);

  void printMrpSubstituteProductionVolume(
    WitRun * const theWitRun,   // the main witrun
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName,
    LgFrMultiPlantHelper & mpHelper);

  void printOpSubstituteProductionVolume(
    WitRun * const theWitRun,   // WIT environment
    const int nPeriods,         // Number of periods
    const int nOperations,           // Number of operation
    char ** opList,           // List of operation names
    std::string fileName,
    LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper);


//  ---------------------------------------------------------------------
//  Print Substitute Prod Volumes
//  Generalized procedure: Use it for printing:
//     subUsage, mrpSubUsage, opSubUsage, mrpOpSubUsage
//  As more and more of these sub usage beasts are needed in the future, 
//  keep expanding the boolean types (for example isChildACapacity ...)
//  --------------------------------------------------------------------- 
void 
printSubstituteUsageVolume(
         WitRun * const theWitRun,
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
         const int nPeriods,      
         const int nOperations, 
         char ** opList,        
         std::string fileName,
	 LgFrMultiPlantHelper & mpHelper);

void 
printSubDbDumpFile(
	 WitRun * const theWitRun,
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
	 const int nPeriods,      
	 const int nOperations, 
	 char ** opList,        
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper);

#if 0 
  // obsolete ...  BUILDING_BLOCKS_VIA_MULTI_BOPS
  void printFeatureAnalysisReportViaMultiRoute(
         WitRun * const theWitRun,   // WIT environment
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName,
         LgFrCalendar & theCal,
         LgFrMultiPlantHelper & mpHelper,
         int printDataAsPercentage);
#endif

  void printFeatureAnalysisReportViaProportionalRoute(
	 WitRun * const theWitRun,
	 const int nPeriods,
	 const int nOperations,
	 char ** operationList,
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage);

  void printFeatureAnalysisReport(
         WitRun * const theWitRun,   // WIT environment
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName,
         LgFrCalendar & theCal,
         LgFrMultiPlantHelper & mpHelper,
         int printDataAsPercentage);


  void printStandAloneFeatureAnalysisReport(
         WitRun * const theWitRun,   // WIT environment
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName,
         LgFrCalendar & theCal,
         LgFrMultiPlantHelper & mpHelper,
         int printDataAsPercentage);

  //  Dump Capacity   Information
  void
  printCapacityDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods
    const int nParts,           // Number of parts
    char ** partList,           // List of part names
    std::string fileName);


  //  Dump Operation Information
  void
  printOperationDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods
    std::string fileName);

void 
  printOperationExecDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName);



  //  ---------------------------------------------------------------------
  //  Print MRP Supply Orders File
  //  ---------------------------------------------------------------------
  //  PUD 14's are EMLS Planned Order (supply) transactions (ie, MRP orders for supply).
  //  The key thing is that the supply shows customer PDF and supplier PDF.
  //  If th esupply is created by "build in-house", then the customer and supplier PDF
  //  is the same.
  //
  //  Codes are:
  //  "A" = interplant
  //  "F" = build in-house
  //  "O" = user-defined Operation
  //  "D" = de-aggregation
  //  "E" = external (ie, supplyvol)
  void 
  printMrpSupplyOrdersFile(
                 LgFrMultiPlantHelper & mpHelper,
                 const int nPeriods,         // Number of periods 
                 std::string fileName);


  //  ---------------------------------------------------------------------
  //  Print MRP Demand Orders File
  //  ---------------------------------------------------------------------
  //
  //  Codes are:
  //  "A" = interplant
  //  "F" = build in-house (includes subs, features, and BB's)
  //  "O" = user-defined Operation
  //  "D" = de-aggregation
  //  "E" = external (ie, supplyvol)
  void 
  printMrpDemandOrdersFile(
                 LgFrMultiPlantHelper & mpHelper,
                 const int nPeriods,         // Number of periods 
                 std::string fileName);
  
  
  
  //  ---------------------------------------------------------------------
  //  Print GEO Supply By PDF  Information         
  //  --------------------------------------------------------------------- 
  void 
  printGeoSourceDebugFile(
         WitRun * const theWitRun,   // WIT environment   
         const int nPeriods,         // Number of periods 
         const int nParts,           // Number of parts   
         char ** partList,           // List of part names
         std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper);
  


//  ---------------------------------------------------------------------
//  Print Lowest Level, unconstrained parts (non-pcf)
//  --------------------------------------------------------------------- 
  void 
  printLowestLevelNonPcfParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName);

#ifdef MARK_BOGONS
//  ---------------------------------------------------------------------
//  Print PCF Bogons (parts which were specified as PCF but got rejected due to child parts)
//  --------------------------------------------------------------------- 
void 
printBogonParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName);
#endif

void 
calculateAndPrintValueAddedCosts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string vacFileName,
	 std::string compCostFileName);




  //  Print Overall Problem Statistics
  void
  printOverallProblemStatistics(
         WitRun * const theWitRun,   // WIT environment
         LgFrMultiPlantHelper & mpHelper,
         const int nPeriods,         // Number of periods
         const int nParts,           // Number of parts
         char ** partList,           // List of part names
         std::string fileName);


  void
  printOverallOptimizationValues(
    WitRun * const theWitRun,   // WIT environment
    const int nPeriods,         // Number of periods
    const int nParts,           // Number of parts
    char ** partList,           // List of part names
    std::string & engine,
    std::string fileName);

  void
  runImplosion( LgFrScenarioForSceSmartPointer );

  void
  machineFss();
  
  void
  generalSetFss();
  
  void
  singletonFss();


  void
  loadPIPDataIntoAppData(WitRun * const theWitRun);

  void
  printPIPData(WitRun * const theWitRun, int isItMrp);

  
  LgFrMultiPlantHelper &
  multiPlantHelper();

  LgFrSceCritList &
  sceCritList();

  void 
  printDummyPartDataBaseDumpFile(
                                 WitRun * const theWitRun,   // WIT environment
                                 LgFrMultiPlantHelper & mpHelper,
                                 const int nPeriods,         // Number of periods 
                                 const int nParts,           // Number of parts   
                                 char ** partList,           // List of part names
                                 std::string fileName);
  
  void 
  printPartDataBaseDumpFile(
                            WitRun * const theWitRun,   // WIT environment
                            LgFrMultiPlantHelper & mpHelper,
                            const int nPeriods,         // Number of periods 
                            const int nParts,           // Number of parts   
                            char ** partList,           // List of part names
                            std::string fileName);

  void 
  setWitInformationalMessaging(WitRun * const theWitRun,
                               int onOrOff);

  
  virtual
     isAReturnType
        isA()
           const;

// return the set of paramters 
  LgFrSceSetOfParameters &
  setOfParameters();

// return the flat file manager
  LgFrSceFlatFileMgr &
  flatFileMgr();


  // RW locale
//  virtual
//    void
//        localeSnapshot(
//                   RWLocaleSnapshot * localSnapshotPtr);

  // Return a const setOfParts which belongs to this scenario
  virtual
     const 
        LgFrSetOfParts&
           constSetOfParts(int k = LGFR_DEFAULT_SET)
              const;



#ifdef SCE_ODBC 
    // --------- Adding new methoads for updating DB with the sce output
  
   
  void analyzeRunAndUpdateDB();
  
  void insertDemandSupplyVol(SceDBLink&,                 // to hold supplyVol
                             WitRun * const theWitRun,   // WIT environment
                             const int nPeriods,         // Number of periods
                             const int nParts,           // Number of parts
                             char ** partList,           // List of part names
                             LgFrCalendar & theCal,
                             LgFrMultiPlantHelper & mpHelper);

  void insertDemandBacklogSchedule(SceDBLink&,                 // to hold supplyVol
                             WitRun * const theWitRun,   // WIT environment
                             const int nPeriods,         // Number of periods
                             const int nParts,           // Number of parts
                             char ** partList,           // List of part names
                             LgFrCalendar & theCal,
                             LgFrMultiPlantHelper & mpHelper);

  void insertCapacitySupplyVol(SceDBLink&,             // to hold supplyVol
                               WitRun * const theWitRun,   // WIT environment
                               const int nPeriods,         // Number of periods
                               const int nParts,           // Number of parts
                               char ** partList,           // List of part names
                               LgFrMultiPlantHelper & mpHelper);

  void insertCapacityMrpConsVol(SceDBLink& mrpConsVol,        
                                WitRun * const theWitRun, 
                                const int nPeriods,        
                                const int nParts,      
                                char ** partList,     
                                LgFrMultiPlantHelper & mpHelper);

  void insertCapacityReqVolAndMrpExcessVolAndMrpRequirements(
                                             SceDBLink& reqVol,
                                             SceDBLink& mrpExcessVol,
                                             SceDBLink& mrpReqVol,    
                                             WitRun * const theWitRun, 
                                             const int nPeriods,        
                                             const int nParts,      
                                             char ** partList,     
                                             LgFrMultiPlantHelper & mpHelper);
  
void insertCapacityExcessVol(
                             SceDBLink& excessVol,    
                             WitRun * const theWitRun, 
                             const int nPeriods,        
                             const int nParts,      
                             char ** partList,     
                             LgFrMultiPlantHelper & mpHelper);
  
void insertCapacityScrapVol(
                             SceDBLink& scrapVol,    
                             WitRun * const theWitRun, 
                             const int nPeriods,        
                             const int nParts,      
                             char ** partList,     
                             LgFrMultiPlantHelper & mpHelper);

void insertCapacityConsVol(
                             SceDBLink& consVol,    
                             WitRun * const theWitRun, 
                             const int nPeriods,        
                             const int nParts,      
                             char ** partList,     
                             LgFrMultiPlantHelper & mpHelper);

void insertIPOrders(
                    SceDBLink& ipOrders,  
                    WitRun * const theWitRun,   // WIT environment   
                    const int nPeriods,         // Number of periods 
                    const int nParts,           // Number of parts   
                    char ** partList,           // List of part names
                    LgFrCalendar & theCal,
                    LgFrMultiPlantHelper & mpHelper);

void insertSupplyResponse(
                          SceDBLink& supply,
                          WitRun * const theWitRun,   // WIT environment   
                          const int nPeriods,         // Number of periods 
                          const int nParts,           // Number of parts   
                          char ** partList,           // List of part names
                          LgFrCalendar & theCal,
                          LgFrMultiPlantHelper & mpHelper);

void insertPartPdfTotalDemand(
                         SceDBLink& demand,
                         WitRun * const theWitRun,   // WIT environment
                         LgFrSceBaseExploder * exploder,
                         const int nPeriods,         // Number of periods 
                         const int nParts,           // Number of parts   
                         char ** partList,           // List of part names
                         LgFrMultiPlantHelper & mpHelper);

  
void insertPartPdfProdVol(
                          SceDBLink & prodVol,
                          WitRun * const theWitRun,   // WIT environment   
                          const int nPeriods,         // Number of periods 
                          const int nParts,           // Number of parts   
                          char ** partList,           // List of part names
                          LgFrCalendar & theCal,
                          LgFrMultiPlantHelper & mpHelper);
  
void insertPartPdfSupplyVol(
                     SceDBLink& supplyVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfCycleTime(
                     SceDBLink& cycleTime,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);
  
void insertPartPdfMrpConsVol(
                     SceDBLink& mrpConsVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfReqVolAndMrpExcessVolAndMrpRequirements(
                     SceDBLink& reqVol,
                     SceDBLink& mrpExcessVol,
                     SceDBLink& mrpRequirements,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfMrpProdVol(
                     SceDBLink& mrpProdVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfExcessVol(
                     SceDBLink& excessVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfStockVol(
                     SceDBLink& stockVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

void insertPartPdfScrapVol(
                     SceDBLink& scrapVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);  
  
void insertPartPdfConsVol(
                     SceDBLink& consVol,
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);
  
void updateAttrFromPartDataBaseDump(
                     WitRun * const theWitRun,   
                     const int nPeriods,  
                     const int nParts,    
                     char ** partList,     
                     LgFrMultiPlantHelper & mpHelper);

 
   //--------------------------------------------------------------------------
#endif

  
#if 0
  // Temporary for testing cmrpTest
  LgFrLastProblemSolved &
    lps()
  {
     return LgFrScenario::lastProblemSolved();
  }
#endif

  // Return a const setOfDemands which belongs to this scenario
  virtual
     const
        LgFrSetOfDemands&
           constSetOfDemands(int k = LGFR_DEFAULT_SET)
              const;


  //--------------------------------------------------------------------------
  //   NOTE:  The following are defined in message.C  NOT in scenSce.C
  //   all methods and objects of the LgFrScenarioForSce class related to
  //   messaging are in the message.* files.
  //--------------------------------------------------------------------------

  // return pointer to facility
  MclFacility * getErrFacility();  
  MclFacility * getMsgFacility();

  // initialize the error facility messages to facility
  void initErrFacility(std::string buffername);

  // initialize the non-error messaging facility
  void initMsgFacility(std::string buffername);

  // add messages to a given facilty by reading messages from a file
  int readMessages(MclFacility * theFacil, const char * msgFileName);

  // add default messages to facility
  void loadDefaultMsgs(MclFacility * theFacil, const messageStructure msgArray[], unsigned int upTill);

  //----------------------End of Messaging Methods----------------------------

  // scrubber

  LgFrSceScrubber * scrubber(){ return sceScrub_; }

  // Constructor
  LgFrScenarioForSce ( const LgFrDataInterfaceAbstract&,
		        const LgFrCalendar&);

  // Assignment operator.
  LgFrScenarioForSce&
    operator=(
              const LgFrScenarioForSce& rhs);

  void deleteAppDataAndScenarioObjects();


  // Destructor
  ~LgFrScenarioForSce();


  // Copy constructor
  LgFrScenarioForSce(
               const LgFrScenarioForSce& source);

  // Default Constructor
  LgFrScenarioForSce();

  // Self-test
  static void test();

 protected:


  // Return a non-const setOfParts which belongs to this scenario
  virtual 
     LgFrSetOfParts&
        setOfParts(int k = LGFR_DEFAULT_SET);


  // Return a non-const setOfDemands which belongs to this scenario
  virtual
     LgFrSetOfDemands&
        setOfDemands(int k= LGFR_DEFAULT_SET);
  
 private:

  LgFrSetOfPartsWithMovableParts defaultSOP_;     // Set of default Parts
  LgFrSetOfDemands defaultSOD_;                   // Set of default Demands
  
  LgFrSetOfPartsWithMovableParts interplantSOP_;  // Set of interplant parts
  LgFrMultiPlantHelper multiPlantHelper_;

  LgFrSceCritList critList_;
  LgFrSceSetOfParameters parameterSet_;           // the Sce parameter set
  LgFrSceFlatFileMgr flatFileMgr_;                // flat file utilities

  // the message facilities that allow for error/non-error messaging
  MclFacility * sceErrFacility_;
  MclFacility * sceMsgFacility_;
  MclPrintfOutputDisplayer * sceErrFacDisp_;
  MclPrintfOutputDisplayer * sceMsgFacDisp_;

  // this is to keep track of the number of temporary Error/Msg files
  // created by the copy constructor, so we can avoid conflicts
  static unsigned int numTempFiles_;

  static const messageStructure errorMsgs_[];
  static const messageStructure nonerrMsgs_[];

  // scrubber

  LgFrSceScrubber * sceScrub_;
  
//  RWLocaleSnapshot * localSnapshotPtr_;
  std::string engine_;

   // ID tag for casting smart pointers
  int id_;
  
  int nStandaloneFeatureArcs_;
  int nDemandsWithNonZeroMins_;
  LgFrSceBaseExploder * exploderPtr_;
};

#endif

@


1.29
log
@fix for backward compat to sce5
@
text
@a71 13
// SCE 6.1
int
printAnInterplantPegFile(WitRun * const theWitRun, 
			 LgFrMultiPlantHelper & mpHelper,
			 LgFrCalendar & theCal,
			 int pegType, 
			 int tinpIndpOrBoth,
			 std::string & pegFileName,
			 int nParts,
			 char ** partList,
			 int nPeriods);


@


1.28
log
@more dated fixes
@
text
@d65 1
d78 1
d230 1
@


1.27
log
@pegging and sub enablement for 6.1
@
text
@d285 18
@


1.26
log
@6.1 prep commit ... many things in here
@
text
@a231 10
  void 
  printGeoSupplyByPdf(
         WitRun * const theWitRun,   // WIT environment   
         const int nPeriods,         // Number of periods 
         const int nParts,           // Number of parts   
         char ** partList,           // List of part names
         std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper);

d310 11
@


1.25
log
@more fixes for 6.1
@
text
@d57 26
a178 8
#ifdef MULTI_ATTRIBUTE_DEMAND_CLASS
std::string
customerKeyExpansion(
		     std::string compressedGeo);
#endif


  
@


1.24
log
@some SCE 6 enhancements for 1/23 Beta release
@
text
@a635 4

  int
  allocatedMrp();

d942 3
@


1.23
log
@sce 4.60, scrapCost, stockCost, greedySearchIncrement,pegging in heuristic, removal of optWithLotSizes
@
text
@d299 1
@


1.22
log
@initial changes for sce4.40
@
text
@d223 6
d494 8
@


1.21
log
@Preliminary commit for SCE 5.00
@
text
@d291 2
a292 1
	 std::string fileName,
@


1.20
log
@removed the "binning" stuff which is now obsolete
@
text
@d327 1
a327 1
printAlternatePartVolumesFile(
@


1.19
log
@4.20 commit: global subs, prioritized explode
@
text
@a100 1
#ifdef HEUR_ALLOC_EXPLODE
a105 7
#else
  LgFrSceBaseExploder *
  createAppropriateSceExploder();

  void
  runExplosion();
#endif
a337 17

#ifdef BINNING_OPERATION_TEMP_SOLUTION
  //  ---------------------------------------------------------------------
  //  Print Bin Volumes (can be used for imploion or explosion)
  //  --------------------------------------------------------------------- 
  void   printBinVolumesFile(
				    WitRun * const theWitRun,
				    const int nPeriods,      
				    int nOps,
				    char ** opList,
				    bool isThisMrp,
				    std::string fileName,
				    LgFrMultiPlantHelper & mpHelper);
#endif

  

a360 27
#ifdef BINNING_OPERATION_TEMP_SOLUTION

  // two helper methods to retrieve the adjusted  bin exec Vols
  LgFrTimeVecFloat binExecVol(std::string & operationName);
  LgFrTimeVecFloat binMrpExecVol(std::string & operationName);

  //  ---------------------------------------------------------------------
  //  initializes the adjusted bin execVols for mrp (sets to 0 for implosion)
  //  ---------------------------------------------------------------------
  void initializeBinOperationsAppData(
					     WitRun * const theWitRun,
					     const int nPeriods,                              
					     const int nOperations,
					     char ** operationList);

  //  ---------------------------------------------------------------------
  //  sets the adjusted bin execVols for  implosion
  //  ---------------------------------------------------------------------
  void setBinOperationsAppDataForImplosion(
						    WitRun * const theWitRun,
						    const int nPeriods,                              
						    const int nOperations,
						    char ** operationList);
#endif



@


1.18
log
@preping for release 4.1
@
text
@d17 1
d101 7
a109 1
  
d111 1
a111 1
  void   
d113 1
d331 14
@


1.17
log
@feature sets logic automatically uses proportional routing when engine is NOT optimization.   for optimization, it uses the OLD BBCat modelling trick.
@
text
@d285 11
@


1.16
log
@added subDB output file
@
text
@a455 1
#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
d465 1
a465 1
#else
d475 1
a475 1
#endif
@


1.15
log
@added vac calculation
@
text
@d432 10
@


1.14
log
@capacityUsage and mrpCapacityUsage
@
text
@d578 11
@


1.13
log
@First cut at Selective Features using proportional routing
@
text
@d380 4
@


1.12
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@d429 2
a430 1
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
d440 12
@


1.11
log
@first level of PIP
@
text
@a594 5
  void
  loadPegDataIntoAppData(WitRun * const theWitRun);

  void
  printPegConsVolData(WitRun * const theWitRun, int isItMrp);
@


1.10
log
@Added
int
to a couple of methods for the gcc compiler.
@
text
@d601 5
@


1.9
log
@minor updates for SCE
@
text
@d113 1
a113 1

d122 2
a123 1

@


1.8
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d149 10
@


1.7
log
@

NOTE CONCERNING FOR-SEMANTICS.

In old C++ semantics, this was illegal:
	for (int i=...) { ...}
	for (int i=...) { ...}

because the scope of i extended beyond the first for-loop, making
the second declaration a conflict.

In new C++ semantics, this is illegal:
	for (int i=...) { ...}
	for (i=...) { ...}

because the scope of i extends in the first for-loop, making
the use of "i" in the second loop unbound.

We can't have it both ways.  We could convert the source to be this:
	inti;
	for (i=...) { ...}
	for (i=...) { ...}

but rather than do that, I have opted to just use a special flag
("-qlanglvl=noansifor") to tell vacpp to use the old semantics.
This flag is in config/p_powerVac.mk.
We can always convert these for loops later if we like, and take
out the flag.


Now some notes concerning what I did in the various components.
Hopefully no one will ever have to read this.

CONFIG:
changed config/p_powerVac.mk by copying setting for ds_comp_std_flags
from config/p_power64v5.mk, to suppress error messages concerning
the technique to avoid accidental use of compiler-generated constructors.

WITUTIL:
changed return type of "main" to int in several files.

SCENARIO and SCE:
In many files, some member declarations had (unnecessary) qualifiers:

	class S {
	S::f();
	};

The obvious solution was to just remove the "S::" qualifier.



In some files (such as ipDifT.h), a member declaration using a class
name in a return type caused a syntax error; the compiler complained
about ambiguity.

	class X {
	C f();
	};

Solution:  add "class C" in front.  Should really have no possible problems.

	class C;
	class X {
	C f();
	};



Some classes declared protected members of other classes to be friends:

	class A {
	protected:
	  int mem();
	};

	class B {
	friend int A::mem();
	};

This is evidentally now illegal.  I suppose it makes sense that one
should already have access to the thing that one wants to be a friend of.

My solution was to just drop the "protected" keyword.
This allows everyone access to these members (which is presumably
undesirable), but at least doesn't allow the friend classes access
to the private data of this class (which presumably is desired).

Another alternative would be to keep the "protected" keyword and
add "friend class A" to the friend class.
The situation is now reversed; it would have the drawback of allowing
the friend class access to private data (which presumably isn't desired),
but would disallow non-friends access to these protected members.




attrInfo.h:  typedef declarations for functions types cannot have
default arguments, i.e. this is illegal:

	typedef int (*f)(int x = 1);

Solution:  drop the default argument:

	typedef int (*f)(int x);

(I suppose this makes sense, given that the treatment of default arguments
seems to have gotten a bit complicated - you can add and remove them
using new declarations.)



(THIS NOTE IS OBSOLETE since I ended up leaving these for-loops alone.
However, it may be useful if we ever do convert the source to the
new syntax.
calendar.C, consSS.C, difCmrpF.C, difWit[DR].C:
  added "int" (or size_t, as appropriate) to "for" loops:

was:
	for (int t=...) { ..}
	for (t=...) { ..}

now:
	for (int t=...) { ..}
	for (int t=...) { ..}

This is ok since t is initialized in each loop.

This wasn't possible in one spot in sched.C, in LgFrScheduleFloat::reduceItems.
It also wasn't possible in a spot in sce/ipSce.C.
It had code like this:
	int t;
	... code setting t
	for (...) {
	  for (int t = ...)
		...
	  somevar = t;
	}

According to the old rules, the assignment "somevar = t" refers to the
t in the nested for-loop.  I've changed it to this:

	for (...) {
	  int t;
	  for (t = ...)
		...
	  somevar = t;
	}

Fortunately, in most places the loop was not nested inside some other
construct, which makes it likely that I didn't make any mistakes.

END OBSOLETE NOTE)



demdSchd.C, partSchd.C, scenATP.C, ...:
  apparently, expressions that refer to a pointer-to-member must use "&":
	class C {
	int f();
	};

	g(C::f);	// ILLEGAL
	g(&C::f);	// GOOD BOY!

(maybe this makes parsing easier?)



dfa.C:  changed
	#include "dfa.h"
to
	#include <scenario/src/dfa.h>

so that the depedency generated by makedepend (and that ends up in Makefile)
doesn't cause problems.




lastPrbS.C:  "bool" is now a keyword.  Changed variable "bool" to "Bool".





multDSch.C:

start with this decl:

    LgFrMultiDemandScheduleFloat& msdClone = *msdClonePtr;

and this call:

    const LgFrSortingDemandScheduleFloat& demandSchdClone
      = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );


LgFrMultiDemandScheduleFloat (in multDSch.h) apparently inherits the
declaration of method "schedule" from its baseclass, LgFrMultiScheduleFloat
(in multiSch.h).

  // Return a non-const schedule
  virtual
    LgFrSortingScheduleFloatSmartPointer
     schedule(const LgFrScheduleDescriptor& sd) const;


class LgFrSortingScheduleFloatSmartPointer is defined in sortSchP.h.
Its baseclass is LgFrSortingScheduleFloatSmartPointerToConst,
defined in the same file, and that has no baseclass.

class LgFrSortingDemandScheduleFloatSmartPointer is defined in demdSchP.h,
and looks similar to LgFrSortingScheduleFloatSmartPointer,
probably one was copied from the other and the names were changed.

So, the problematic statement is probably the equivalent of casting a pointer.

This was the code I used instead.
It may just be that one can't cast using "&" anymore.

    LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
    LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
    const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);


This is *probably* ok, since both smartpointers have the same private
data fields (in their basetypes).  The code snippets below give the
general idea.  I imagine that this would all be done with templates
these days (if there isn't already a smartpointer library somewhere).



protected:
    LgFrSortingDemandScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingDemandScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;




protected:
    LgFrSortingScheduleFloat* pointer_; // should make this const but I want to use
                            //  it for the LgFrSortingScheduleFloatSmartPointer class
			    //  (the non-const class) to inherit this member.
			    //  The way it's been set up only const stuff
                            //  is being returned so we're OK.
    LgFrReferenceCount count_;


Dereference is just what it should be:


const LgFrSortingDemandScheduleFloat &
LgFrSortingDemandScheduleFloatSmartPointer::operator*() const
{
    return *pointer_;
}

LgFrSortingScheduleFloat &
LgFrSortingScheduleFloatSmartPointer::operator*()
{
    return *pointer_;
}



SCE:
Created powerVac/Makefile
by copying power64/Makefile and just changine "power64" to "powerVac".





For convenience, here is the output of these commands:

	cvs diff scenario/src
	cvs diff sce/src


Index: scenario/src/attrInfo.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/attrInfo.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 attrInfo.h
17c17,20
< 	       const LgFrDataInterfaceEssentials* difEssenPtr = NULL);
---
>
> 	       // syntax error - typedefs can (no longer) have default args
> 	       const LgFrDataInterfaceEssentials* difEssenPtr /////= NULL
> 	       );
47c50
< LgFrAttributeInformation::LgFrAttributeInformation(const LgFrAttributeInformation& );
---
> LgFrAttributeInformation(const LgFrAttributeInformation& );
Index: scenario/src/backlgSS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/backlgSS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 backlgSS.h
83c83
<   LgFrBacklogScheduleStrategy::contextTest
---
>   contextTest
Index: scenario/src/calendar.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/calendar.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 calendar.h
252c252
<   LgFrCalendar::addMonths(const RWTime& aTime, unsigned numMonthsOut,
---
>   addMonths(const RWTime& aTime, unsigned numMonthsOut,
281c281
<   LgFrCalendar::display()
---
>   display()
Index: scenario/src/demdSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/demdSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 demdSchd.C
273c273
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
288c288
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
452c452
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
475c475
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
496c496
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
514c514
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/dfa.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/dfa.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 dfa.C
14c14,16
< #include "dfa.h"
---
>
> //#include "dfa.h"
> #include <scenario/src/dfa.h>
Index: scenario/src/filtStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/filtStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 filtStrt.h
89c89,90
< protected:
---
>   // see the comment in schdStrt.h.
>   /////protected:
Index: scenario/src/fssCtrl.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/fssCtrl.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 fssCtrl.h
109c109
<         LgFrFocussedShortageScheduleControl::isValid()
---
>         isValid()
117c117
<         LgFrFocussedShortageScheduleControl::focusChanged()
---
>         focusChanged()
151c151
<    LgFrFocussedShortageScheduleControl::LgFrFocussedShortageScheduleControl(
---
>    LgFrFocussedShortageScheduleControl(
Index: scenario/src/ipDifT.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/ipDifT.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 ipDifT.h
10a11,15
>
> // added to avoid syntax error in declaration of difTestingScenario below - vra
> class LgFrScenarioForDifTestingSmartPointer;
>
>
Index: scenario/src/lastPrbS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 lastPrbS.C
98c98
<    witBoolean bool;
---
>    witBoolean Bool;
100,101c100,101
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
248c248
<    witBoolean bool;
---
>    witBoolean Bool;
250,251c250,251
<       witRunVeneer().constWitRun(), &bool );
<    if ( bool ) return TRUE;
---
>       witRunVeneer().constWitRun(), &Bool );
>    if ( Bool ) return TRUE;
Index: scenario/src/lastPrbS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/lastPrbS.h,v
retrieving revision 1.2
diff -r1.2 lastPrbS.h
182c182
<         LgFrLastProblemSolved::focusHorizon(
---
>         focusHorizon(
686c686
<         LgFrLastProblemSolved::cumShipBounds(
---
>         cumShipBounds(
760c760
<         LgFrLastProblemSolved::cumShipSoftLowerBound(
---
>         cumShipSoftLowerBound(
910c910
<       LgFrLastProblemSolved::getPartFloatVecAttribute(
---
>       getPartFloatVecAttribute(
917c917
<        LgFrLastProblemSolved::setPartFloatVecAttribute(
---
>        setPartFloatVecAttribute(
924c924
<       LgFrLastProblemSolved::setPartBoundsAttribute(
---
>       setPartBoundsAttribute(
933c933
<       LgFrLastProblemSolved::getDemandFloatVecAttribute(
---
>       getDemandFloatVecAttribute(
940c940
<       LgFrLastProblemSolved::getDemandSoftLowerBoundAttribute(
---
>       getDemandSoftLowerBoundAttribute(
947c947
<       LgFrLastProblemSolved::setDemandBoundsAttribute(
---
>       setDemandBoundsAttribute(
956c956
<    LgFrLastProblemSolved::writeSchedule(
---
>    writeSchedule(
Index: scenario/src/multDSch.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/multDSch.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 multDSch.C
436,438c436,446
<
<     const LgFrSortingDemandScheduleFloat& demandSchdClone
<       = *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
---
>
>     //// LET'S TRY THIS AGAIN...
>     /////const LgFrSortingDemandScheduleFloat& demandSchdClone
>     /////= *( (LgFrSortingDemandScheduleFloatSmartPointer&)(msdClone.schedule(LGFRDemandVolume)) );
>
>     LgFrSortingScheduleFloatSmartPointer XtmpschX = msdClone.schedule(LGFRDemandVolume);
>     LgFrSortingDemandScheduleFloatSmartPointer &XtmpschX2 = *(LgFrSortingDemandScheduleFloatSmartPointer*)&XtmpschX;
>     const LgFrSortingDemandScheduleFloat& demandSchdClone = *(XtmpschX2);
>
>     ///// DONE
>
Index: scenario/src/outInter.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/outInter.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 outInter.h
43c43
<   static const LgFrSchedulePrintStyle LgFrSolutionOutputInterface::pmTEXT;
---
>   static const LgFrSchedulePrintStyle pmTEXT;
Index: scenario/src/pairComp.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/pairComp.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 pairComp.h
84c84,86
< protected:
---
>   // in scenario.h, class LgFrScenario declares these methods to be "friend".
>   // see the comment in schdStrt.h.
>   //// protected:
Index: scenario/src/partSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/partSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 partSchd.C
261c261
<   LgFrTimeVecFloat::add,rhs);
---
>   &LgFrTimeVecFloat::add,rhs);
276c276
<   LgFrTimeVecFloat::subtract,rhs);
---
>   &LgFrTimeVecFloat::subtract,rhs);
443c443
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
466c466
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
487c487
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
503c503
<   LgFrTimeVecFloat::subtract, rhs );
---
>   &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/scenATP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenATP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenATP.C
484c484
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
513c513
<           LgFrTimeVecFloat::returnRHS, newVol ) );
---
>           &LgFrTimeVecFloat::returnRHS, newVol ) );
Index: scenario/src/scenSnFS.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenSnFS.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenSnFS.h
16c16
<   LgFrScenarioSensitiveFilterStrategy::scenario(
---
>   scenario(
21c21
<   LgFrScenarioSensitiveFilterStrategy::scenarioPtr()
---
>   scenarioPtr()
Index: scenario/src/scenario.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/scenario.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 scenario.h
46a47,54
> // had to add this line in order to avoid syntax error concerning
> // the uses of this class in members below.
> // vacpp complained that is was ambiguous.
> // I don't know why.
> // Perhaps in older versions of the compiler the friend declarations
> // below also implicitly declared the class as well?
> class LgFrScheduleFactory;
>
231c239
<   const LgFrScheduleFactory*
---
>     const LgFrScheduleFactory*
Index: scenario/src/schFCMRP.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFCMRP.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFCMRP.C
82c82
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
184c184
<       sumSS->combiningFunction (LgFrTimeVecFloat::add);
---
>       sumSS->combiningFunction (&LgFrTimeVecFloat::add);
370c370
<       usagePctSS->combiningFunction (LgFrTimeVecFloat::percentageOf);
---
>       usagePctSS->combiningFunction (&LgFrTimeVecFloat::percentageOf);
416c416
<       deltaSS->combiningFunction (LgFrTimeVecFloat::subtract);
---
>       deltaSS->combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schFctry.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schFctry.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schFctry.h
96c96
< friend LgFrScenarioBuilder;
---
> friend class LgFrScenarioBuilder;
Index: scenario/src/schdSnSS.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdSnSS.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdSnSS.C
242c242
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
260c260
<    combiningFunction_(LgFrTimeVecFloat::add),
---
>    combiningFunction_(&LgFrTimeVecFloat::add),
613c613
<       cs1.combiningFunction (LgFrTimeVecFloat::subtract);
---
>       cs1.combiningFunction (&LgFrTimeVecFloat::subtract);
Index: scenario/src/schdStrt.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/schdStrt.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 schdStrt.h
141c141,168
< protected:
---
>   ////??????
>   // in scenario.h, class LgFrScenario declares (most of) the
>   // following methods to be "friend"s.
>   // I (vra) can't see how that would have ever been possible,
>   // given that these are protected methods.
>   // Perhaps the compilers are just more finicky now.
>   // As a hack to get this working right away, I will remove the
>   // protected keyword.
>   //
>   // An an alternative, one could add
>   //    friend class LgFrAttributeScheduleStrategy;
>   // to the classes that need access (such as LgFrScenario)
>   // and make these methods protected again.
>   //
>   // The differences between these two styles is:
>   //	dropping "protected" here allows everyone access,
>   //	(which presumably isn't intended),
>   //	but denies friends (such as LgFrScenario) access to private members
>   //	(which presumably is intended).
>   //
>   //	in contrast, using friend class LgFrAttributeScheduleStrategy
>   //	(and putting back the "protected" keyword here)
>   //	allows the friend classes access to private members
>   //	(presumably not intended),
>   //	but denies everyone else access to protected members
>   //	(presumably intended).
>   //
>   ////// protected:
Index: scenario/src/sched.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.C
578c578
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
585c585
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
594c594
<   return op(LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
---
>   return op(&LgFrTimeVecFloat::maximum,rhs,-FLT_MAX);
716c716
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
734c734
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
750c750
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
761c761
<   diff = lhs.op( LgFrTimeVecFloat::subtract, rhs );
---
>   diff = lhs.op( &LgFrTimeVecFloat::subtract, rhs );
Index: scenario/src/sched.h
===================================================================
RCS file: /u/wit/devbase/scenario/src/sched.h,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sched.h
81c81
<       LgFrScheduleFloat::capacity()
---
>       capacity()
Index: scenario/src/sortSchd.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/sortSchd.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 sortSchd.C
679c679
<   return lhs.op(LgFrTimeVecFloat::add,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::add,rhs);
688c688
<   return lhs.op(LgFrTimeVecFloat::subtract,rhs);
---
>   return lhs.op(&LgFrTimeVecFloat::subtract,rhs);
Index: scenario/src/wrkgProb.C
===================================================================
RCS file: /u/wit/devbase/scenario/src/wrkgProb.C,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 wrkgProb.C
641c641
<                LgFrLastProblemSolved::capitalCost);
---
>                &LgFrLastProblemSolved::capitalCost);
650c650
<                       LgFrLastProblemSolved::capitalCost );
---
>                       &LgFrLastProblemSolved::capitalCost );
660c660
<                LgFrLastProblemSolved::equitability);
---
> 	     &LgFrLastProblemSolved::equitability);
669c669
<                       LgFrLastProblemSolved::equitability );
---
> 		    &LgFrLastProblemSolved::equitability );
679c679
<                LgFrLastProblemSolved::buildAhead);
---
> 		   &LgFrLastProblemSolved::buildAhead);
688c688
<                       LgFrLastProblemSolved::buildAhead );
---
> 			  &LgFrLastProblemSolved::buildAhead );
698c698
<                LgFrLastProblemSolved::computeCriticalList);
---
> 		   &LgFrLastProblemSolved::computeCriticalList);
707c707
<                       LgFrLastProblemSolved::computeCriticalList );
---
> 			  &LgFrLastProblemSolved::computeCriticalList );
717c717
<                LgFrLastProblemSolved::inventoryCost);
---
>                &LgFrLastProblemSolved::inventoryCost);
726c726
<                       LgFrLastProblemSolved::inventoryCost );
---
>                       &LgFrLastProblemSolved::inventoryCost );
736c736
<                LgFrLastProblemSolved::obj2WeightInventory);
---
>                &LgFrLastProblemSolved::obj2WeightInventory);
745c745
<                       LgFrLastProblemSolved::obj2WeightInventory );
---
>                       &LgFrLastProblemSolved::obj2WeightInventory );
755c755
<                LgFrLastProblemSolved::obj2WeightRevenue);
---
>                &LgFrLastProblemSolved::obj2WeightRevenue);
764c764
<                       LgFrLastProblemSolved::obj2WeightRevenue );
---
>                       &LgFrLastProblemSolved::obj2WeightRevenue );
774c774
<                LgFrLastProblemSolved::obj2WeightService);
---
>                &LgFrLastProblemSolved::obj2WeightService);
783c783
<                       LgFrLastProblemSolved::obj2WeightService );
---
>                       &LgFrLastProblemSolved::obj2WeightService );
793c793
<                LgFrLastProblemSolved::obj2WeightSubstitutes);
---
>                &LgFrLastProblemSolved::obj2WeightSubstitutes);
802c802
<                       LgFrLastProblemSolved::obj2WeightSubstitutes );
---
>                       &LgFrLastProblemSolved::obj2WeightSubstitutes );
812c812
<                LgFrLastProblemSolved::weightBounds);
---
>                &LgFrLastProblemSolved::weightBounds);
821c821
<                       LgFrLastProblemSolved::weightBounds );
---
>                       &LgFrLastProblemSolved::weightBounds );




Index: sce/src/aEngMgr.h
===================================================================
RCS file: /u/wit/devbase/sce/src/aEngMgr.h,v
retrieving revision 1.5
diff -r1.5 aEngMgr.h
77c77
< LgFrSceAllocationEngineMgr::sortID();
---
> sortID();
Index: sce/src/scePegging.C
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.C,v
retrieving revision 1.6
diff -r1.6 scePegging.C
121c121
<   virtual RWBoolean SceCollectableDouble::operator==(const SceCollectableDouble& c) const
---
>   virtual RWBoolean operator==(const SceCollectableDouble& c) const
124c124
<   virtual RWBoolean SceCollectableDouble::isEqual(const RWCollectable* c) const
---
>   virtual RWBoolean isEqual(const RWCollectable* c) const
Index: sce/src/scePegging.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scePegging.h,v
retrieving revision 1.4
diff -r1.4 scePegging.h
120c120
<   void ScePegging::computeConsVolAndUpdateConsDict(
---
>   void computeConsVolAndUpdateConsDict(
Index: sce/src/scenSce.h
===================================================================
RCS file: /u/wit/devbase/sce/src/scenSce.h,v
retrieving revision 1.6
diff -r1.6 scenSce.h
35a36,38
> // added to avoid syntax error - vra
> class LgFrScenarioForSceSmartPointer;
>
@
text
@d4 5
d37 1
a37 2
class ofstream;
class RWCTokenizer;
d56 2
d65 1
a65 1
                       RWCString fileName,
d72 2
a73 2
    RWCString & pn, 
    RWCString & pdf, 
d76 1
a76 1
    ofstream & outFile,   // output stream (already opened)
d84 2
a85 2
    RWCString & pn, 
    RWCString & pdf, 
d88 1
a88 1
    ofstream & outFile,   // output stream (already opened)
d136 1
a136 1
  setEngine(const RWCString & engine);
d138 1
a138 1
  RWCString
d144 1
a144 1
  // ofstream & theStream,   // output stream (already opened)
d154 2
a155 2
    const RWCString & geoPlannerDemandPartName,
    RWCString * sourceList);
d166 1
a166 1
    RWCString fileName,         // Name of output filename
d177 1
a177 1
                       RWCString fileName,
d188 1
a188 1
			   RWCString fileName,
d199 1
a199 1
    RWCString fileName,         // Name of output filename
d209 1
a209 1
         RWCString fileName,
d219 1
a219 1
         RWCString fileName,
d234 1
a234 1
         RWCString fileName,
d247 1
a247 1
	 RWCString fileName,
d265 1
a265 1
         RWCString engine,
d269 1
a269 1
         RWCString fileName,
d282 1
a282 1
		    RWCString fileName,
d297 2
a298 2
				    RWBoolean isThisMrp,
				    RWCString fileName,
d312 2
a313 2
				    RWBoolean isThisMrp,
				    RWCString fileName,
d320 2
a321 2
  LgFrTimeVecFloat interplantExecVol(RWCString & operationName);
  LgFrTimeVecFloat interplantMrpExecVol(RWCString & operationName);
d345 2
a346 2
  LgFrTimeVecFloat binExecVol(RWCString & operationName);
  LgFrTimeVecFloat binMrpExecVol(RWCString & operationName);
d377 1
a377 1
    RWCString fileName,
d386 1
a386 1
    RWCString fileName,
d394 1
a394 1
    RWCString fileName,
d409 2
a410 2
	 RWBoolean parentMustBeUserDefinedOperation,
	 RWBoolean engineMustBeImplode,
d414 1
a414 1
         RWCString fileName,
d424 1
a424 1
         RWCString fileName,
d434 1
a434 1
         RWCString fileName,
d445 1
a445 1
         RWCString fileName,
d458 1
a458 1
    RWCString fileName);
d467 1
a467 1
    RWCString fileName);
d488 1
a488 1
                 RWCString fileName);
d505 1
a505 1
                 RWCString fileName);
d518 1
a518 1
         RWCString fileName,
d534 1
a534 1
	 RWCString fileName);
d547 1
a547 1
	 RWCString fileName);
d560 1
a560 1
         RWCString fileName);
d569 2
a570 2
    RWCString & engine,
    RWCString fileName);
d609 1
a609 1
                                 RWCString fileName);
d618 1
a618 1
                            RWCString fileName);
d640 4
a643 4
  virtual
    void
        localeSnapshot(
                   RWLocaleSnapshot * localSnapshotPtr);
d875 1
a875 1
  void initErrFacility(RWCString buffername);
d878 1
a878 1
  void initMsgFacility(RWCString buffername);
d958 2
a959 2
  RWLocaleSnapshot * localSnapshotPtr_;
  RWCString engine_;
@


1.7.6.1
log
@Roguewave is gone
@
text
@a3 5
// RW2STL - inserted:
#include <string>
#include <fstream>
// End of RW2STL - inserted includes.

d32 2
a33 1
class SCETokenizer;
a51 2
  virtual int GetScenarioType() const { return __LGFRSCENARIOFORSCE; }

d59 1
a59 1
                       std::string fileName,
d66 2
a67 2
    std::string & pn, 
    std::string & pdf, 
d70 1
a70 1
    std::ofstream & outFile,   // output stream (already opened)
d78 2
a79 2
    std::string & pn, 
    std::string & pdf, 
d82 1
a82 1
    std::ofstream & outFile,   // output stream (already opened)
d130 1
a130 1
  setEngine(const std::string & engine);
d132 1
a132 1
  std::string
d138 1
a138 1
  // std::ofstream & theStream,   // output stream (already opened)
d148 2
a149 2
    const std::string & geoPlannerDemandPartName,
    std::string * sourceList);
d160 1
a160 1
    std::string fileName,         // Name of output filename
d171 1
a171 1
                       std::string fileName,
d182 1
a182 1
			   std::string fileName,
d193 1
a193 1
    std::string fileName,         // Name of output filename
d203 1
a203 1
         std::string fileName,
d213 1
a213 1
         std::string fileName,
d228 1
a228 1
         std::string fileName,
d241 1
a241 1
	 std::string fileName,
d259 1
a259 1
         std::string engine,
d263 1
a263 1
         std::string fileName,
d276 1
a276 1
		    std::string fileName,
d291 2
a292 2
				    bool isThisMrp,
				    std::string fileName,
d306 2
a307 2
				    bool isThisMrp,
				    std::string fileName,
d314 2
a315 2
  LgFrTimeVecFloat interplantExecVol(std::string & operationName);
  LgFrTimeVecFloat interplantMrpExecVol(std::string & operationName);
d339 2
a340 2
  LgFrTimeVecFloat binExecVol(std::string & operationName);
  LgFrTimeVecFloat binMrpExecVol(std::string & operationName);
d371 1
a371 1
    std::string fileName,
d380 1
a380 1
    std::string fileName,
d388 1
a388 1
    std::string fileName,
d403 2
a404 2
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
d408 1
a408 1
         std::string fileName,
d418 1
a418 1
         std::string fileName,
d428 1
a428 1
         std::string fileName,
d439 1
a439 1
         std::string fileName,
d452 1
a452 1
    std::string fileName);
d461 1
a461 1
    std::string fileName);
d482 1
a482 1
                 std::string fileName);
d499 1
a499 1
                 std::string fileName);
d512 1
a512 1
         std::string fileName,
d528 1
a528 1
	 std::string fileName);
d541 1
a541 1
	 std::string fileName);
d554 1
a554 1
         std::string fileName);
d563 2
a564 2
    std::string & engine,
    std::string fileName);
d603 1
a603 1
                                 std::string fileName);
d612 1
a612 1
                            std::string fileName);
d634 4
a637 4
//  virtual
//    void
//        localeSnapshot(
//                   RWLocaleSnapshot * localSnapshotPtr);
d869 1
a869 1
  void initErrFacility(std::string buffername);
d872 1
a872 1
  void initMsgFacility(std::string buffername);
d952 2
a953 2
//  RWLocaleSnapshot * localSnapshotPtr_;
  std::string engine_;
@


1.6
log
@bogon output, and minor changes
@
text
@d36 3
@


1.5
log
@print lowest level non-pcf files
@
text
@d101 3
d526 14
@


1.4
log
@3.11 commit
@
text
@d511 15
@


1.3
log
@premiminary coomit for release 3.11
@
text
@d264 13
@


1.2
log
@3.10 pegging capability
@
text
@d534 1
a534 1
  printPegConsVolData(WitRun * const theWitRun);
@


1.1
log
@Initial revision
@
text
@d530 8
@


1.1.1.1
log
@Import sce
@
text
@@

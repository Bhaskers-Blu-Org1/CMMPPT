head	1.98;
access;
symbols
	sce_5_01_20080919:1.79
	latest_sce_4_20_20060523:1.65.0.2
	sce_4_20_20060523:1.65
	latest_sce4_20_OSL:1.64.0.2
	sce_4_20_OSL:1.64
	sce_4_20_20051222:1.64
	sce_4_10_30050426:1.54
	sce_4_05_20040511:1.50
	sce_4_00_20040201:1.34
	nextGenBranch:1.27.0.2
	nextGenRoot:1.27
	sce_3_30_20030627:1.27
	EndRw-branch:1.22.0.2
	Root-of-EndRw:1.22
	EndWitRw-branch:1.19.0.4
	Root-of-EndWitRw:1.19
	RwToStl-branch:1.19.0.2
	Root-of-RwToStl:1.19
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.5.0.2
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.3.0.2
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.98
date	2011.03.21.21.35.40;	author ervolina;	state Exp;
branches;
next	1.97;
deltatype	text;
permissions	644;
commitid	b204d87c10c69fa;
kopt	kv;
filename	@ipSce.C@;

1.97
date	2011.03.15.15.35.01;	author ervolina;	state Exp;
branches;
next	1.96;
deltatype	text;
permissions	644;
commitid	256c4d7f865a0a65;
kopt	kv;
filename	@ipSce.C@;

1.96
date	2011.03.15.13.36.18;	author ervolina;	state Exp;
branches;
next	1.95;
deltatype	text;
permissions	644;
commitid	ef44d7f6ae030ab;
kopt	kv;
filename	@ipSce.C@;

1.95
date	2011.03.10.15.29.53;	author ervolina;	state Exp;
branches;
next	1.94;
deltatype	text;
permissions	644;
commitid	14cc4d78ede700a2;
kopt	kv;
filename	@ipSce.C@;

1.94
date	2010.12.15.23.53.23;	author ervolina;	state Exp;
branches;
next	1.93;
deltatype	text;

1.93
date	2010.04.20.14.26.56;	author ervolina;	state Exp;
branches;
next	1.92;
deltatype	text;

1.92
date	2010.04.12.21.27.02;	author ervolina;	state Exp;
branches;
next	1.91;
deltatype	text;

1.91
date	2010.04.07.21.38.17;	author ervolina;	state Exp;
branches;
next	1.90;
deltatype	text;

1.90
date	2010.04.07.16.18.27;	author ervolina;	state Exp;
branches;
next	1.89;
deltatype	text;

1.89
date	2010.03.29.11.54.39;	author ervolina;	state Exp;
branches;
next	1.88;
deltatype	text;

1.88
date	2010.03.26.19.48.24;	author ervolina;	state Exp;
branches;
next	1.87;
deltatype	text;

1.87
date	2010.03.16.17.56.22;	author ervolina;	state Exp;
branches;
next	1.86;
deltatype	text;

1.86
date	2010.03.13.18.53.05;	author ervolina;	state Exp;
branches;
next	1.85;
deltatype	text;

1.85
date	2010.02.10.16.41.46;	author ervolina;	state Exp;
branches;
next	1.84;
deltatype	text;

1.84
date	2010.02.04.15.58.23;	author ervolina;	state Exp;
branches;
next	1.83;
deltatype	text;

1.83
date	2009.12.08.19.21.59;	author ervolina;	state Exp;
branches;
next	1.82;
deltatype	text;

1.82
date	2009.12.08.14.53.06;	author ervolina;	state Exp;
branches;
next	1.81;
deltatype	text;

1.81
date	2009.12.08.13.58.35;	author ervolina;	state Exp;
branches;
next	1.80;
deltatype	text;

1.80
date	2009.09.09.15.41.57;	author ervolina;	state Exp;
branches;
next	1.79;
deltatype	text;

1.79
date	2008.09.19.20.03.48;	author ervolina;	state Exp;
branches;
next	1.78;
deltatype	text;

1.78
date	2008.06.04.16.08.00;	author ervolina;	state Exp;
branches;
next	1.77;
deltatype	text;

1.77
date	2008.06.03.19.33.58;	author ervolina;	state Exp;
branches;
next	1.76;
deltatype	text;

1.76
date	2008.04.30.21.23.11;	author ervolina;	state Exp;
branches;
next	1.75;
deltatype	text;

1.75
date	2008.04.24.14.04.41;	author ervolina;	state Exp;
branches;
next	1.74;
deltatype	text;

1.74
date	2008.03.20.14.52.47;	author ervolina;	state Exp;
branches;
next	1.73;
deltatype	text;

1.73
date	2008.03.14.20.19.39;	author ervolina;	state Exp;
branches;
next	1.72;
deltatype	text;

1.72
date	2007.05.29.20.03.32;	author ervolina;	state Exp;
branches;
next	1.71;
deltatype	text;

1.71
date	2007.03.21.18.03.28;	author ervolina;	state Exp;
branches;
next	1.70;
deltatype	text;

1.70
date	2006.08.17.17.46.55;	author ervolina;	state Exp;
branches;
next	1.69;
deltatype	text;

1.69
date	2006.08.11.19.28.15;	author ervolina;	state Exp;
branches;
next	1.68;
deltatype	text;

1.68
date	2006.08.09.16.32.16;	author ervolina;	state Exp;
branches;
next	1.67;
deltatype	text;

1.67
date	2006.07.13.18.43.57;	author ervolina;	state Exp;
branches;
next	1.66;
deltatype	text;

1.66
date	2006.06.26.15.23.30;	author ervolina;	state Exp;
branches;
next	1.65;
deltatype	text;

1.65
date	2006.05.23.13.03.56;	author ervolina;	state Exp;
branches;
next	1.64;
deltatype	text;

1.64
date	2005.12.22.23.17.56;	author ervolina;	state Exp;
branches;
next	1.63;
deltatype	text;

1.63
date	2005.12.22.22.34.31;	author ervolina;	state Exp;
branches;
next	1.62;
deltatype	text;

1.62
date	2005.11.14.18.26.53;	author ervolina;	state Exp;
branches;
next	1.61;
deltatype	text;

1.61
date	2005.11.11.16.23.33;	author ervolina;	state Exp;
branches;
next	1.60;
deltatype	text;

1.60
date	2005.11.10.13.28.41;	author ervolina;	state Exp;
branches;
next	1.59;
deltatype	text;

1.59
date	2005.11.09.18.32.46;	author ervolina;	state Exp;
branches;
next	1.58;
deltatype	text;

1.58
date	2005.11.03.00.25.38;	author ervolina;	state Exp;
branches;
next	1.57;
deltatype	text;

1.57
date	2005.11.02.18.40.01;	author ervolina;	state Exp;
branches;
next	1.56;
deltatype	text;

1.56
date	2005.09.09.15.30.10;	author ervolina;	state Exp;
branches;
next	1.55;
deltatype	text;

1.55
date	2005.08.10.22.44.52;	author ervolina;	state Exp;
branches;
next	1.54;
deltatype	text;

1.54
date	2005.05.05.20.22.12;	author ervolina;	state Exp;
branches;
next	1.53;
deltatype	text;

1.53
date	2005.02.15.20.45.00;	author ervolina;	state Exp;
branches;
next	1.52;
deltatype	text;

1.52
date	2004.10.08.13.03.43;	author ervolina;	state Exp;
branches;
next	1.51;
deltatype	text;

1.51
date	2004.06.28.16.29.35;	author ervolina;	state Exp;
branches;
next	1.50;
deltatype	text;

1.50
date	2004.05.10.04.16.03;	author ervolina;	state Exp;
branches;
next	1.49;
deltatype	text;

1.49
date	2004.05.07.16.58.10;	author ervolina;	state Exp;
branches;
next	1.48;
deltatype	text;

1.48
date	2004.05.07.03.09.59;	author ervolina;	state Exp;
branches;
next	1.47;
deltatype	text;

1.47
date	2004.05.04.22.58.24;	author ervolina;	state Exp;
branches;
next	1.46;
deltatype	text;

1.46
date	2004.04.06.02.00.11;	author ervolina;	state Exp;
branches;
next	1.45;
deltatype	text;

1.45
date	2004.04.05.21.48.50;	author ervolina;	state Exp;
branches;
next	1.44;
deltatype	text;

1.44
date	2004.04.05.19.47.24;	author ervolina;	state Exp;
branches;
next	1.43;
deltatype	text;

1.43
date	2004.03.04.20.28.11;	author fasano;	state Exp;
branches;
next	1.42;
deltatype	text;

1.42
date	2004.03.02.04.22.50;	author ervolina;	state Exp;
branches;
next	1.41;
deltatype	text;

1.41
date	2004.02.26.16.06.17;	author ervolina;	state Exp;
branches;
next	1.40;
deltatype	text;

1.40
date	2004.02.24.15.51.39;	author ervolina;	state Exp;
branches;
next	1.39;
deltatype	text;

1.39
date	2004.02.12.21.37.47;	author ervolina;	state Exp;
branches;
next	1.38;
deltatype	text;

1.38
date	2004.02.09.16.05.52;	author ervolina;	state Exp;
branches;
next	1.37;
deltatype	text;

1.37
date	2004.02.09.14.37.30;	author ervolina;	state Exp;
branches;
next	1.36;
deltatype	text;

1.36
date	2004.02.06.21.53.47;	author ervolina;	state Exp;
branches;
next	1.35;
deltatype	text;

1.35
date	2004.02.04.22.50.10;	author ervolina;	state Exp;
branches;
next	1.34;
deltatype	text;

1.34
date	2004.01.29.05.08.04;	author ervolina;	state Exp;
branches;
next	1.33;
deltatype	text;

1.33
date	2004.01.23.02.59.16;	author ervolina;	state Exp;
branches;
next	1.32;
deltatype	text;

1.32
date	2004.01.22.02.47.48;	author ervolina;	state Exp;
branches;
next	1.31;
deltatype	text;

1.31
date	2004.01.10.17.56.11;	author ervolina;	state Exp;
branches;
next	1.30;
deltatype	text;

1.30
date	2003.11.24.19.59.45;	author ervolina;	state Exp;
branches;
next	1.29;
deltatype	text;

1.29
date	2003.09.03.02.24.31;	author ervolina;	state Exp;
branches;
next	1.28;
deltatype	text;

1.28
date	2003.08.04.20.48.54;	author dpc;	state Exp;
branches;
next	1.27;
deltatype	text;

1.27
date	2003.06.26.23.09.37;	author ervolina;	state Exp;
branches;
next	1.26;
deltatype	text;

1.26
date	2003.04.08.01.58.49;	author ervolina;	state Exp;
branches;
next	1.25;
deltatype	text;

1.25
date	2003.02.04.19.43.42;	author ervolina;	state Exp;
branches;
next	1.24;
deltatype	text;

1.24
date	2003.01.17.00.53.21;	author ervolina;	state Exp;
branches;
next	1.23;
deltatype	text;

1.23
date	2003.01.15.19.36.55;	author rwToStl;	state Exp;
branches;
next	1.22;
deltatype	text;

1.22
date	2003.01.06.22.12.09;	author ervolina;	state Exp;
branches
	1.22.2.1;
next	1.21;
deltatype	text;

1.21
date	2002.12.05.00.33.29;	author fasano;	state Exp;
branches;
next	1.20;
deltatype	text;

1.20
date	2002.11.26.14.25.30;	author fasano;	state Exp;
branches;
next	1.19;
deltatype	text;

1.19
date	2002.09.06.13.33.08;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2002.08.08.17.37.43;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;

1.17
date	2002.08.06.18.08.17;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2002.07.02.20.20.07;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2002.06.26.20.38.44;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2002.06.18.21.10.27;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2002.04.01.22.39.11;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2002.03.28.21.49.42;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2001.12.21.20.10.31;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2001.12.03.13.38.50;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2001.11.20.22.13.11;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2001.10.11.19.59.21;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2001.09.24.16.38.13;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2001.08.14.21.00.59;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2001.06.01.16.52.05;	author ervolina;	state Exp;
branches;
next	1.4;
deltatype	text;

1.4
date	2001.03.12.15.07.29;	author ervolina;	state Exp;
branches;
next	1.3;
deltatype	text;

1.3
date	2001.02.23.20.11.39;	author ervolina;	state Exp;
branches
	1.3.2.1;
next	1.2;
deltatype	text;

1.2
date	2000.10.04.15.48.38;	author ervolina;	state Exp;
branches
	1.2.2.1;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.51;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.51;	author wit;	state Exp;
branches;
next	;
deltatype	text;

1.2.2.1
date	2001.03.08.15.36.46;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.3.2.1
date	2001.03.12.16.36.16;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.22.2.1
date	2003.01.08.17.43.15;	author rwToStl;	state Exp;
branches;
next	1.22.2.2;
deltatype	text;

1.22.2.2
date	2003.01.09.13.14.32;	author rwToStl;	state Exp;
branches;
next	1.22.2.3;
deltatype	text;

1.22.2.3
date	2003.01.14.19.06.01;	author rwToStl;	state Exp;
branches;
next	1.22.2.4;
deltatype	text;

1.22.2.4
date	2003.01.14.19.10.48;	author ervolina;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.98
log
@fixed test for duplicate record in featratio.dat
@
text
@#include <mcl/src/mdsPragma.h>
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
#include <mcl/src/mcl.h>
#include <sce/src/ipSce.h>
#include <assert.h>
#include <math.h>
#include <wit/src/wit.h>
#include <scenario/src/timeVecs.h>

#include <scenario/src/difEssSc.h>
#include <scenario/src/sOfParts.h>
#include <scenario/src/sOfDemds.h>
#include <scenario/src/generVc.h>
#include <scenario/src/scenario.h>
#include <scenario/src/idnumber.h>

#include <sce/src/scenSce.h>
#include <scenario/src/calendar.h>
#include <sce/src/mPlantH.h>
#include <sce/src/sceCrtLs.h>
#include <sce/src/oEngMgr.h>
#include <sce/src/dDriver.h>
#include <sce/src/hEngMgr.h>
#include <sce/src/priorMgr.h>
#include <sce/src/difSceF.h>
#include <sce/src/dmApData.h>
#include <sce/src/bopAData.h>
#include <sce/src/sceBop.h> 
#include <sce/src/sceParam.h>
#include <sce/src/paramMgr.h>
#include <sce/src/appData.h>

#include <mcl/src/mcl.h>

#define IPSCE_FLT_EPS  0.00001



#ifndef ELIMINATE_OLD_MAIN
// ============================================================
// ========= buildTheWitModelForSce() =========================
// ============================================================
void   
LgFrInitialProblemForSce::buildTheWitModelForSce(
    WitRun * const theWitRun, 
    LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper)
{

    int nPeriods;              // Number of periods in model

    LgFrSceSetOfParameters & setOfParameters =
      this->sceScenario()->setOfParameters();

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    int nPeriodsInCal =  setTheCalendar(theCal);
    if (!theCal.isValid()) {
      // this is an error ... formerly an assertion
      (*theErrFacil)("InvalidCalendar");
    }

    // initialize the multiPlantHelper -- set the default PDF
    std::string defaultPdf = setOfParameters.getString("defaultPdf");
    mpHelper.defaultPdf(defaultPdf);

    // initialize the multiPlantHelper -- set the default PDF separator char
    std::string pdfSeparator = setOfParameters.getString("pdfSeparator");
    mpHelper.pdfSeparator(pdfSeparator);

    // Regardless of the engine, the priorities are loaded 
    // (during optimization, they're used in the hot start). 
    // But the obj1 values are set only if engine=optimization
    // to reduce the SCE footprint.
    //
    // So, new a heurModelHelper regardless of the engine.
    // But, only new a lpModelHelper if need be.
    //
    // Testing if (lpModelHelper != 0) is equivalent
    // to testing if (engine != optimization), and
    // is better that #ifdef's.
    // This "extra layer" is helpful so we don't have to keep
    // searching through the setOfParameters and for collecting
    // model specific functions.
    //
    // But once a design is established for the scheme/sub-schema
    // of current and wish-list implosion option, revisit
    // the modelHelpers...something may make more sense and
    // be more maintainable.
   


    // Define the demandDrivers object.  This object gets instantiated
    // after the model is built
    LgFrSceDemandDriver * myDemandDriver = 0;


    // we new a helper here and delete it in the ip's destructor
    std::string engine = setOfParameters.getString("engine");
    heurModelHelper_ = new LgFrSceHeurModelHelper( setOfParameters );

    if (engine == "optimization")  
      lpModelHelper_ = new LgFrSceLpModelHelper( setOfParameters );

    // Set the wit message file
    std::string scenarioFile = setOfParameters.getString("outputFilePrefix");
    std::string witMsgFileExtension = setOfParameters.getString("witMsgFileExtension");    

    std::string witMesgFileName(scenarioFile + witMsgFileExtension);
    witSetMesgFileAccessMode( theWitRun, WitTRUE, "w" );
    witSetMesgFileName( theWitRun, WitTRUE, witMesgFileName.c_str());

    if (setOfParameters.getBool("printWitMsgFile"))  
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_ON);
    else
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_OFF);
    
    // dated demands
    // multi_attribute_demand_class
    // need to get these parameters and set them in flatFileManager
    LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
    bool useDatedDemands  = setOfParameters.getBool("useDatedDemands");
    bool useMultiAttributeDemand  = setOfParameters.getBool("useMultiAttributeDemand");
    int demandTypeKeyFieldNum  = setOfParameters.getInt("demandTypeKeyFieldNum");
    bool truncOffsetToEol  = setOfParameters.getBool("truncOffsetToEol");
    int  numDemandAttributes  = setOfParameters.getInt("numDemandAttributes");
    std::string multiAttributeDemandSeparator  = setOfParameters.getString("multiAttributeDemandSeparator");
    bool useDemand2OrderINDP  = setOfParameters.getBool("useDemand2OrderINDP");

    flatFileManager.useDatedDemands(useDatedDemands);
    flatFileManager.useMultiAttributeDemand(useMultiAttributeDemand);
    flatFileManager.demandTypeKeyFieldNum(demandTypeKeyFieldNum);
    flatFileManager.numDemandAttributes(numDemandAttributes);
    flatFileManager.multiAttributeDemandSeparator(multiAttributeDemandSeparator);
    //    flatFileManager.useDemand2OrderINDP(useDemand2OrderINDP);

    mpHelper.useMultiAttributeDemand(useMultiAttributeDemand);
    mpHelper.truncOffsetToEol(truncOffsetToEol);
    mpHelper.numDemandAttributes(numDemandAttributes);
    mpHelper.multiAttributeDemandSeparator(multiAttributeDemandSeparator);
    mpHelper.useDemand2OrderINDP(useDemand2OrderINDP);

    witInitialize( theWitRun );
    witSetWit34Compatible( theWitRun, WitTRUE );
    witSetRoundReqVols ( theWitRun, WitTRUE );


    //  2.30: multi-route 
    bool useMultiRouteImplosion = setOfParameters.getBool("useMultiRouteImplosion");
    witSetMultiRoute(theWitRun, useMultiRouteImplosion);

    //  3.00: stock reallocation
    bool useStockReallocation = setOfParameters.getBool("useStockReallocation");
    witSetStockReallocation(theWitRun, useStockReallocation);


    groupSharingViaExecPenalties_ = setOfParameters.getBool("groupSharingViaExecPenalties");
    float groupSharingExecPenaltyThresh = setOfParameters.getFloat("groupSharingExecPenaltyThresh");
    witSetPenExec(theWitRun, groupSharingViaExecPenalties_);
  
    // notes for Pegged Critical List:   After multi-route (with penalized execution) tries everything and fails,
    // it reverts to a single path.   The single path is determined by lowest aversion.   For
    // us to force the critical list to LST in servergroup, we need to set the aversion of LST to 
    // large negative ... TEST!!!!!!!!!!


    //    {
    //      float * memErrorTest = new float[10];
    //      float p = memErrorTest[10];
    //    }



    // 2.30: expCutoffTolerance
    float expCutoffTolerance = setOfParameters.getFloat("expCutoffTolerance");
    witSetExpCutoff(theWitRun, expCutoffTolerance);

    // this really means set buildNSTN true for all parts (as a default)
    bool useLocalBuildAhead = setOfParameters.getBool("useLocalBuildAhead");

    // allow Subs to have offsets different than the parent bom
    witSetIndependentOffsets(theWitRun, WitTRUE);


    // Set the objective choice based on the engine parameter.
    // This gives us a smaller footprint when using the heuristic.
    if ( lpModelHelper_ != 0 )
      witSetObjChoice(theWitRun, 1);
    else 
      witSetObjChoice( theWitRun, 0);
    
    witSetNPeriods(theWitRun, nPeriodsInCal);

    witSetExecEmptyBom(theWitRun, WitTRUE);


    // temp for JP
#if 0
    WitRun * tempWitRun;
    witNewRun(&tempWitRun);
    witInitialize(tempWitRun);
    witReadData(tempWitRun, "wit.dat");
    witHeurImplode(tempWitRun);
#endif

    // Set the equitability factor
    int equitability = setOfParameters.getInt("equitability");
    witSetEquitability(theWitRun, equitability);

    bool heurForceEquit = setOfParameters.getBool("heurForceEquit");
    witSetForcedMultiEq(theWitRun, heurForceEquit);

    bool heurSkipFailures = setOfParameters.getBool("heurSkipFailures");
    witSetSkipFailures(theWitRun, heurSkipFailures);

    std::string siteCustomization = setOfParameters.getString("siteCustomization");

    bool doPegging = setOfParameters.getBool("doPegging");
    if (doPegging) {
      if (engine != "optimization") {
	// for all  engine choices except optimization, we allow use heuristic sequence for PIPing
	witClearPipSeq(theWitRun);
	witSetPipSeqFromHeur(theWitRun, WitTRUE);
      }
    }
    
    // Do we compute criticalList?
    if (setOfParameters.getBool("printCriticalListFile"))
      witSetComputeCriticalList(theWitRun, WitTRUE);

    // Do we compute pegged criticalList?
    if (setOfParameters.getBool("printPeggedCritListFile"))
      witSetPgdCritListMode(theWitRun, WitTRUE);


    // Tell wit to comput shadow prices
    if (setOfParameters.getBool("printShadowPricesFile"))
      witSetCompPrices(theWitRun, WitTRUE);

    // 6.20 MIP mode  
    if (setOfParameters.getBool("mipMode"))   {
      if (setOfParameters.getBool("printCriticalListFile"))      
	(*theErrFacil)("MipModeAndCritListDontMix");
      if (setOfParameters.getBool("printShadowPricesFile"))
	(*theErrFacil)("MipModeAndShadowProcesDontMix");
      witSetMipMode(theWitRun, WitTRUE);
    }
	



    // 4.20 IPIP fix 
    witSetNewPipPggOrder(theWitRun, WitTRUE);

    
    // Get number of periods 
    witGetNPeriods( theWitRun, &nPeriods );
    assert (nPeriods == nPeriodsInCal);


    // ***********************
    // ***  Part Def file  ***
    // ***********************
    std::string partDefFile = setOfParameters.getString("partFile");
    processPartDefinitionFile(theWitRun, partDefFile, mpHelper);


    // ***************************
    // ***  Capacity Def file  ***
    // ***************************
    std::string capacityDefFile = setOfParameters.getString("capFile");
    if (! capacityDefFile.empty())
      processCapacityDefinitionFile( theWitRun, capacityDefFile, mpHelper);


    // ***********************
    // ***  Sourcing File  ***
    // ***********************
    std::string sourceDefFile = setOfParameters.getString("sourceDefFile");
    if (! sourceDefFile.empty())
      processSourceDefFile(theWitRun, theCal, sourceDefFile, mpHelper);


    // *************************
    // ***  Cycle Time file  ***
    // *************************
    std::string cycleTimeFile = setOfParameters.getString("cycleTimeFile");    
    if (! cycleTimeFile.empty())
	processCycleTimeFile(theWitRun, nPeriods, theCal, cycleTimeFile, mpHelper);

    // *************************
    // ***  Yield file  ********
    // *************************
    std::string yieldFile = setOfParameters.getString("yieldFile");    
    if (! yieldFile.empty())
	processYieldFile( theWitRun, nPeriods, theCal, yieldFile, mpHelper);

    
    // *************************
    // *** Min Lot Size file ***
    // *************************
    std::string lotSizeFile = setOfParameters.getString("lotSizeFile");    
    if (! lotSizeFile.empty()) 
	processLotSizeFile( theWitRun, nPeriods, theCal, lotSizeFile, mpHelper);
       

    // ***********************************
    // *** Prod Vol Soft Lower Bounds  ***
    // ***********************************
    std::string prodVolLBFile = setOfParameters.getString("prodVolLBFile");    
    if (! prodVolLBFile.empty()) 
	processProdVolLBFile( theWitRun, nPeriods, prodVolLBFile, mpHelper);

    // ***********************************
    // *** Prod Vol Hard Upper Bounds  ***
    // ***********************************
    std::string prodVolUBFile = setOfParameters.getString("prodVolUBFile");    
    if (! prodVolUBFile.empty()) 
	processProdVolUBFile( theWitRun, nPeriods, prodVolUBFile, mpHelper);

    // *****************************************************
    // *** Set up Operations                   *************
    // *****************************************************
    std::string operationDefFile = setOfParameters.getString("opFile");
    if (! operationDefFile.empty())    
      processOperationDefinitionFile(theWitRun, operationDefFile, mpHelper);
    
    // *****************************************************
    // *** Set Operation ExecPenalty           *************
    // *****************************************************
    std::string operationExecPenaltyFile = setOfParameters.getString("opExecPenaltyFile");
    if (! operationExecPenaltyFile.empty())    
      processOperationExecPenaltyFile( theWitRun, nPeriods, theCal, operationExecPenaltyFile, mpHelper);

    // *****************************************************
    // *** Set Operation ExecCosts             *************
    // *****************************************************
    int sceObjectiveType = setOfParameters.getInt("objectiveType");
    std::string operationExecCostFile = setOfParameters.getString("opExecCostFile");
    if (! operationExecCostFile.empty()) {
      if (sceObjectiveType == 1) {
	(*theErrFacil)("ExecCostInHeurMode");
      }
      else 
	processOperationExecCostFile( theWitRun, nPeriods, theCal, operationExecCostFile, mpHelper);
    }


    // *****************************************************
    // *** Set Operation Lot Sizes             *************
    // *****************************************************
    std::string operationLotSizeFile = setOfParameters.getString("opLotSizeFile");
    if (! operationLotSizeFile.empty())    
      processOperationLotSizeFile( theWitRun, nPeriods, theCal, operationLotSizeFile, mpHelper);
       
    // *****************************************************
    // *** Set up Operation Yields             *************
    // *****************************************************
    std::string operationYieldFile = setOfParameters.getString("opYieldFile");
    if (! operationYieldFile.empty())    
      processOperationYieldFile( theWitRun, nPeriods, theCal, operationYieldFile, mpHelper);

    
    // *****************************************************
    // *** Set up Operation Lower Bounds File  *************
    // *****************************************************
    std::string operationLBFile = setOfParameters.getString("opLowerFile");
    if (! operationLBFile.empty())    
      processOperationLBFile( theWitRun, nPeriods, operationLBFile, mpHelper );    

    // *****************************************************
    // *** Set up Operation Upper Bounds       *************
    // *****************************************************
    std::string operationUBFile = setOfParameters.getString("opUpperFile");
    if (! operationUBFile.empty())    
      processOperationUBFile( theWitRun, nPeriods, operationUBFile, mpHelper );    

    // *****************************************************
    // *** Set up Operation Integer Exec Vols  *************
    // *****************************************************
    std::string operationIntExecFile = setOfParameters.getString("opIntExecFile");
    if (! operationIntExecFile.empty())    
      processOperationIntegerExecFile(theWitRun, nPeriods, theCal,  operationIntExecFile, mpHelper);    



    // *****************************************************
    // *** Set up Operation BOMs               *************
    // *****************************************************
     std::string operationBomFile = setOfParameters.getString("opBomFile");
     if (! operationBomFile.empty())    
       processOperationBomFile( theWitRun, theCal, operationBomFile, mpHelper);    

    // *****************************************************
    // *** Set up Operation BOPs               *************
    // *****************************************************
     std::string operationBopFile = setOfParameters.getString("opBopFile");
     if (! operationBopFile.empty())    
       processOperationBopFile( theWitRun, theCal, operationBopFile, mpHelper );    


    // ******************
    // ***  BOM file  ***
    // ******************
    std::string bomFile = setOfParameters.getString("bomFile");
    processStandardBomFile( theWitRun, theCal, bomFile, mpHelper);


#ifdef MULTI_SITE_BOM
    // ******************
    // ***  BOM file  ***
    // ******************
    std::string multiSiteBomFile = setOfParameters.getString("multiSiteBomFile");
    processMultiSiteBomFile( theWitRun, theCal, multiSiteBomFile, mpHelper);
#endif



    // *************************
    // ***  InterPlant file  ***
    // *************************
    std::string interPlantFile = setOfParameters.getString("interPlantFile");
    if (! interPlantFile.empty())
      processInterPlantFile( theWitRun, theCal, interPlantFile, mpHelper);


    // ******************
    // ***  BOC file  ***
    // ******************
    std::string bocFile = setOfParameters.getString("bocFile");
    if (! bocFile.empty())
      processBillOfCapacitiesFile( theWitRun, theCal, bocFile, mpHelper);

    // ***************************************
    // ***  Operation BOM Substitute file  ***
    // ***************************************
    std::string opSubBomFile = setOfParameters.getString("opSubBomFile");
    if (! opSubBomFile.empty())  {
      processOperationSubBomFile( theWitRun, theCal, opSubBomFile, mpHelper);
    }


    // *****************************
    // ***  BOM Substitute file  ***
    // *****************************
    std::string subBomFile = setOfParameters.getString("subBomFile");
    if (! subBomFile.empty())  {
      processStandardBomSubFile(theWitRun, theCal, subBomFile, mpHelper);
    }

    // *****************************
    // ***  Aggregation File   *****
    // *****************************
    std::string aggregationFile = setOfParameters.getString("aggregationFile");
    if (! aggregationFile.empty())  {
      processAggregationFile( theWitRun, theCal, aggregationFile, mpHelper);
    }

    // ******************************
    // ***  Demand Volume Files *****
    // ******************************
    std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
    std::string geoSourceFile = setOfParameters.getString("geoSourceFile");
    std::string demandVolFile = setOfParameters.getString("demandVolFile");
    // SCE 6.1
    if ( useMultiAttributeDemand) {
      if (! demandVolFile.empty())
	processDemandFile( theWitRun, theCal, nPeriods, demandVolFile, mpHelper);    
    }
    // SCE 5.X
    else {
      if (! independentDemandFile.empty())
	processIndependentDemandFile( theWitRun, theCal, nPeriods, independentDemandFile, mpHelper);    
      if (! geoSourceFile.empty()) {
	processGeoSourceFile( theWitRun, geoSourceFile, theCal, mpHelper);    
      }
      if (! demandVolFile.empty())
	processDemandVolumeFile( theWitRun, nPeriods, demandVolFile, mpHelper);    
    }


    // FINISH_ME:
    // Finish processing of independent Demand Vols
    //  a) check for any negative demands
    //  b) if there are any negative demands, then we need to split parts 
    //     and do some neat trickery.
    preProcessNegativeDemands(theWitRun, mpHelper);



    // *************************************
    // *** Set up the features sets ********
    // *************************************
    std::string topLevelToBBdefFile = setOfParameters.getString("topLevelToBBdefFile");
    std::string topLevelToBBratioFile = setOfParameters.getString("topLevelToBBratioFile");
    if (! topLevelToBBdefFile.empty())   {
      if ( useMultiAttributeDemand) {
	processTopLevelToFeatureSetFile61( theWitRun, theCal, topLevelToBBdefFile, mpHelper);
      }
      else {
	processTopLevelToFeatureSetFile(theWitRun, theCal, topLevelToBBdefFile, mpHelper);
      }
    }
    if (! topLevelToBBratioFile.empty())   {
      if ( useMultiAttributeDemand) {
	processFeatureSetToOptionRatioFile61(theWitRun, theCal, topLevelToBBratioFile, mpHelper);
      }
      else {
	processFeatureSetToOptionRatioFile(theWitRun, theCal, topLevelToBBratioFile, mpHelper);
      }
    }



    // *************************************
    // *** Set up the optional features ****
    // *************************************
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      if ( useMultiAttributeDemand) {
	process61TopLevelToOptionalFeatureFile(theWitRun, theCal, topLevelToOptionFile, mpHelper);
      }
      else {
	processTopLevelToOptionalFeatureFile(theWitRun, theCal, topLevelToOptionFile, mpHelper);
      }
      setOfParameters.setInt("nStandaloneFeatureArcs", sceScenario()->nStandaloneFeatureArcs());
    }


    // *************************************
    // *** Machine -> feature Offsets ****
    // *************************************
    std::string machineFeatureOffsetFile = setOfParameters.getString("machineFeatureOffsetFile");
    if (! machineFeatureOffsetFile.empty()) {
      // we don't use this file in SCE 6.1
      if ( ! useMultiAttributeDemand) {
	processMachineFeatureOffsetFile( theWitRun, theCal, machineFeatureOffsetFile, mpHelper);
      }
    }
    
    
    // *************************************
    // *** Machine -> feature SupplyVols (FEN5) ****
    // *************************************
    std::string machineFeatureSupplyFile = setOfParameters.getString("machineFeatureSupplyFile");
    if (! machineFeatureSupplyFile.empty()) {
      // we don't use this file in SCE 6.1
      if ( ! useMultiAttributeDemand) {
	processMachineFeatureSupplyFile(theWitRun, theCal, machineFeatureSupplyFile, mpHelper);
      }
    }
    
    
    // clean up the bop offsets on GPDs.  these were temporary placeholders for 
    // GPD transitTime and will be double counted if we don't remove them now.
    // this is because the transit time is also applied to gpd bom offsets
    removeGpdBopOffsets(theWitRun, mpHelper);

    

    // *****************************************************
    // *** Set up the Priorities and Objective Function ***
    // *****************************************************
    float periodicInterestRate = setOfParameters.getFloat("periodicInterestRate");
    float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");

    // Heuristic ==> PRIORITY based objective    
    if (sceObjectiveType == 1) {

      // SCE 6.1
      // Priority_Manager
      std::string priorityRulesFile = setOfParameters.getString("priorityRulesFile");
      if (! priorityRulesFile.empty())  {
	LgFrScePriorityMgr * priorityManager = new LgFrScePriorityMgr(sceScenario(), theWitRun, &mpHelper,
								      &(this->sceScenario()->flatFileMgr()), &theCal);
	priorityManager->setPriorities(priorityRulesFile);
	delete priorityManager;
      }

      // SCE 5
      std::string priorityFile = setOfParameters.getString("priorityFile");
      if (! priorityFile.empty())  {
        if ( lpModelHelper_ != 0 ) {
	  (*theErrFacil)("OptEngineAndPriorities");
        }
        processDemandObjectiveFile( theWitRun, nPeriods, priorityFile, mpHelper, periodicInterestRate);    
      }
      
      std::string indepPriorityFile = setOfParameters.getString("indepPriorityFile");
      if ((!independentDemandFile.empty()) && (!indepPriorityFile.empty()))  {
        processIndepDemandObjectiveFile( theWitRun, nPeriods, indepPriorityFile, mpHelper, periodicInterestRate);    
      }
    }


    // Optimization: revenue based objective
    if (sceObjectiveType == 2) {
	std::string revenueFile = setOfParameters.getString("revenueFile");
        if ((! revenueFile.empty()) && (! demandVolFile.empty()))
	processDemandObjectiveFile( theWitRun, nPeriods, revenueFile, mpHelper, periodicInterestRate);
        
        std::string optionRevFile = setOfParameters.getString("optionRevFile");
        if ((! optionRevFile.empty()) && (! demandVolFile.empty()))
          processOptionRevenueFile( theWitRun, theCal, optionRevFile, mpHelper, defaultOptionShipReward, periodicInterestRate);    


        // This one is the revenue per BB/feature option shipped
        std::string featRevFile = setOfParameters.getString("featRevFile");
        if ((! featRevFile.empty())  && (! demandVolFile.empty()))
          processOptionRevenueFile( theWitRun, theCal, featRevFile, mpHelper, defaultOptionShipReward, periodicInterestRate);    

	std::string indepRevenueFile = setOfParameters.getString("indepRevenueFile");
	if ((!independentDemandFile.empty()) && (!indepRevenueFile.empty()))  {
	  processIndepDemandObjectiveFile( theWitRun, nPeriods, indepRevenueFile, mpHelper, periodicInterestRate);    
	}
    }


    // Optimization: profit based objective
    if (sceObjectiveType == 3) {
	std::string profitFile = setOfParameters.getString("profitFile");
	processDemandObjectiveFile( theWitRun, nPeriods, profitFile, mpHelper, periodicInterestRate);

        std::string optionProfitFile = setOfParameters.getString("optionProfitFile");
        if (! optionProfitFile.empty())
          processOptionRevenueFile( theWitRun, theCal, optionProfitFile, mpHelper, defaultOptionShipReward, periodicInterestRate);    

        std::string featProfitFile = setOfParameters.getString("featProfitFile");
        if (! featProfitFile.empty())
          processOptionRevenueFile( theWitRun, theCal, featProfitFile, mpHelper, defaultOptionShipReward, periodicInterestRate);
    }

    // *************************************
    // *** PIP PriorityFiles            ****
    // *************************************
    std::string pipPriorityFile = setOfParameters.getString("pipPriorityFile");
    if (doPegging && (! pipPriorityFile.empty())) {
      processPipPriorityFile( theWitRun, nPeriods, pipPriorityFile, mpHelper);
    }
    std::string pipIndpPriorityFile = setOfParameters.getString("pipIndpPriorityFile");
    if (doPegging && (! pipIndpPriorityFile.empty())) {
      processPipIndpPriorityFile( theWitRun, nPeriods, pipIndpPriorityFile, mpHelper);
    }


    // *************************************
    // *** Set up the Minimum Demand Volumes
    // *************************************
    std::string minDemandVolFile = setOfParameters.getString("minDemandVolFile");
    if (! minDemandVolFile.empty())
	processMinDemandVolFile( theWitRun, nPeriods, minDemandVolFile, mpHelper);    

    // *************************************
    // *** Set up the Independet Minimum Demand Volumes
    // *************************************
    std::string minIndepDemandVolFile = setOfParameters.getString("minIndepDemandVolFile");
    if (! minIndepDemandVolFile.empty())
	processMinIndepDemandVolFile( theWitRun, nPeriods, minIndepDemandVolFile, mpHelper);    


    // *************************************
    // *** Set up the Perishability Values
    // *************************************
    std::string backlogYieldFile = setOfParameters.getString("backlogYieldFile");
    if (! backlogYieldFile.empty())
	processBacklogYieldFile( theWitRun, nPeriods, backlogYieldFile, mpHelper);    

    // *************************************
    // *** Set up the Demand Greedy Search Increments
    // *************************************
    std::string greedySearchIncFile = setOfParameters.getString("greedySearchIncFile");
    if (! greedySearchIncFile.empty())
	processGreedySearchIncFile( theWitRun, nPeriods, greedySearchIncFile, mpHelper);    

    // *************************************
    // *** Set up the Indp demand Greedy Search Increments
    // *************************************
    std::string indpGreedySearchIncFile = setOfParameters.getString("indpGreedySearchIncFile");
    if (! indpGreedySearchIncFile.empty())
	processIndpGreedySearchIncFile( theWitRun, nPeriods, indpGreedySearchIncFile, mpHelper);    

    // *************************************
    // *** Set up Build Ahead rules  *******
    // *************************************
    std::string buildAheadFile = setOfParameters.getString("buildAheadFile");
    if (! buildAheadFile.empty())
      processBuildAheadFile( theWitRun, nPeriods, theCal, buildAheadFile, mpHelper);  
    
    // *************************************
    // *** Set up Scrap Costs    *******
    // *************************************
    std::string scrapCostFile = setOfParameters.getString("scrapCostFile");
    if (! scrapCostFile.empty())
      processScrapCostFile( theWitRun, nPeriods, theCal, scrapCostFile, mpHelper);  

    // *************************************
    // *** Set up Stock Costs    *******
    // *************************************
    std::string stockCostFile = setOfParameters.getString("stockCostFile");
    if (! stockCostFile.empty())
      processStockCostFile( theWitRun, nPeriods, theCal, stockCostFile, mpHelper);  


    // *************************************
    // *** Set up Supply Vols  *************
    // *************************************
    std::string supplyFile = setOfParameters.getString("supplyFile");
    if (useDatedDemands)  {
      processSupplyFile61( theWitRun, theCal, nPeriods, supplyFile, mpHelper);  
    }
    else   {
      processSupplyFile( theWitRun, theCal, nPeriods, supplyFile, mpHelper);  
    }

    // *****************************************************
    // *** Set up Capacity Availability  Vols  *************
    // *****************************************************
    std::string capSupplyFile = setOfParameters.getString("capSupplyFile");
    if (! capSupplyFile.empty())    {
      if (useDatedDemands) 
	processCapacitySupplyFile61( theWitRun, theCal, nPeriods, capSupplyFile, mpHelper);    
      else 
	processCapacitySupplyFile( theWitRun, nPeriods, capSupplyFile, mpHelper);    
    }
    

    
      


    
    // *************************************
    //    "shut off" childless default
    //  operations for parts that have an
    //      an alternate operation
    // NOTE: method should preceed pcf file processing
    //       and multi-bop processing
    // *************************************
    std::cout << "Analyzing SCE model (default operations) ..." << std::endl;    
    scePreProcessDefaultOperations(theWitRun, nPeriods);    
    
    // *************************************
    // *** Read Parts Condition File *******
    // *************************************
    std::string partsConditionFile = setOfParameters.getString("partCondFile");
    if (! partsConditionFile.empty())    
      processPartsConditionFile( theWitRun, theCal, nPeriods, 
				 partsConditionFile, mpHelper);    

    // *************************************
    //  Set Priorities on  Special Feature Demands
    // *************************************
    if (setOfParameters.getInt("nStandaloneFeatureArcs") > 0) {
      std::cout << "Pre-processing feature priorities ..." << std::endl;    
      sceSetPrioritiesForSpecialFeatureDemands(theWitRun, mpHelper);    
    }


    if ( lpModelHelper_ == 0 ) {    
      // NOTE: these functions only need to be used for heuristic modes.
      //  with optimization mode, we DON'T want to use them.
      
      // *****************************************************
      // ***              Split Bops !!!   *******
      // *** Analyze model for parts with multiple Bops
      // *****************************************************
      if (! setOfParameters.getBool("disableSplitBop")) {
	std::cout << "Analyzing SCE model (multiple bop entries) ..." << std::endl;
	scePreProcessMultiBopEntries ( theWitRun, useMultiRouteImplosion );
      }


      // *****************************************************
      // *** Add Interplant Jumper Arcs  ****
      // *****************************************************
      // Multi-sourcing a part from a variety of supplier
      // locations is modeled in SCE as the part being produced 
      // from a variety of "interplant" operations. 
      // 
      // The current heuristic doesn't excercise the alternative
      // ways to build a part when multiple operations exist.
      // To slightly mitigate this drawback until the heuristic
      // is improved, this method adds "jumper arcs" (aka substitutes)
      // from the supplier parts at alternative interplant locations to
      // the supplier part at the preferred interplant location.
      if (! setOfParameters.getBool("disableInterplantJumperArcs")) {
	std::cout << "Analyzing SCE model (multiple interplant entries) ..." << std::endl;
	scePreProcessMultiInterPlantEntries ( theWitRun, mpHelper );
      }
    }

    // ***************************************************
    // *** SCE PreProcess Via MRP
    // ***************************************************
    // Do some pre-processing of the model to set the:
    // optionRatioSupply supplyVols and the
    // demandUpperBound supplyVols

#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
    std::cout << "Pre-Processing SCE model (via  Multi-route  MRP) ..." << std::endl;
    scePreProcessViaMrpViaMultiRoute(theWitRun, nPeriods, theCal, mpHelper);
#else
    std::cout << "Pre-Processing SCE model (via mrp) ..." << std::endl;
    scePreProcessViaMrp(theWitRun, nPeriods, theCal, mpHelper);
#endif

    if (groupSharingViaExecPenalties_) {    
	// this should be done in general case of penalized Exectution
	std::cout << "Checking for illegal sub netAllowed conditions ..." << std::endl;
	checkAndFixIllegalSubNetAllowedCases(theWitRun, mpHelper);
    }

    

    // ***************************************************
    // *** Do some extra Scrubbing PCF and Param files ***
    // ***************************************************
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
    if (myScrubber -> scrubMode())  {
      std::string outputFilePrefix = setOfParameters.getString("outputFilePrefix");
      //      if (sce::find(outputFilePrefix, "/") != sce::badIndex) {
      if (sce::find(outputFilePrefix, "/") != std::string::npos) {
	(*theErrFacil)("QualifiedOutputFilePrefix",MclArgList() 
		       << outputFilePrefix);
      }
      // Print out a scrubbed ParamFile
      std::string parameterFileName = setOfParameters.getString("parameterFileName");
      std::string scrubParamFileName = myScrubber->scrubDir() + parameterFileName;
      if (sce::find(parameterFileName, "/") != std::string::npos) {
	(*theErrFacil)("QualifiedInputFileName",MclArgList() 
		       << parameterFileName);
      }
      setOfParameters.printScrubbedParamFile(scrubParamFileName);

      if (! partsConditionFile.empty())    
	// Print out a scrubbed pcf file
	scrubPartsConditionFile(theWitRun, theCal, nPeriods, 
				partsConditionFile, mpHelper);    

      // Print out a supply availability file
      bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
      if (aggregateSupplyInScrub)
	scrubSupplyAvailabilityFile(theWitRun, theCal, nPeriods, 
				    supplyFile, mpHelper);    


      // Print out a scrubbed demand Volume file
      if (! demandVolFile.empty())
	scrubDemandVolumeFile(theWitRun, theCal, nPeriods, 
			      demandVolFile, mpHelper);    

      // Print out a scrubbed demand Volume file
      if (! minDemandVolFile.empty())
         scrubMinDemandVolumeFile(theWitRun, theCal, nPeriods, 
			    minDemandVolFile, mpHelper);    
    }


    // *************************************
    //  Delete Unnecessary Demand App Data
    // *************************************
    // FINISH_ME:  We should probably not do this if we migrate to 
    //             incHeurAlloc in a big way
    // In order to speed up the rollover heuristic, we delete any
    // demandApp data's that have the backlogYield set to their 
    // default.

    // deleteUnnecessaryDemandAppData(theWitRun, nPeriods, mpHelper);    


    // *************************************
    //  Shut off all Lot-Sizing (if they want to) 
    // *************************************
    if (setOfParameters.getBool("shutOffAllLotSizing")) {
      std::cout << "Shutting off all Lot-sizing ..." << std::endl;    
      shutOffAllLotSizing(theWitRun, nPeriods);    
    }



    // *************************************
    // If SCRUB MODE only, then stop here
    // *************************************
    if (myScrubber->scrubOnly())
      return;
	

    // ******************************************
    // Set up Part Index System via part app data 
    // ******************************************
    // This allows a part to know its index against witGetParts()
    // BTW, Don't even THINK about adding new parts after this!!!
    mpHelper.setAllWitPartIndices(theWitRun);

    // ******************************************
    // Compute the  Demand Drivers File
    // ******************************************
    // WE only build this thing if we are going to print the demand
    // drivers file.  In the future, we could leave it around for other 
    // diagnosis or whatever.
    // NOTE: this needs to happen before hte preProcessViaMrp because
    // it needs to access the maxWithout of standalone features.  The
    // mwo is temporarily stored in supplyVol of the nullSub part AND
    // that supplyVol get overridden in preProcessViaMrp.  This should
    // eventually be cleaned up with a better use of AppData.
    if (setOfParameters.getBool("printDemandDriversFile"))  {
      std::cout << "Computing Demand Drivers  ..." << std::endl;                      
      // demandDrivers will report subs as a default.  To shut it off
      // we need to set netAllowed to False for all subs.  This may
      // also screw up indexing so we reset all wit part indices 
      // after printing, WE MUST turn subs back on (netAllowed to true)
      // UPDATE: we do need to worry about the parameter .... globalSubNetAllowed
      // see the setSubsNetAllowed method ...
      if (! setOfParameters.getBool("demandDriversRespectsSubs")) {
	//	this->setSubsNetAllowed(false, mpHelper, theWitRun);
	mpHelper.setAllWitPartIndices(theWitRun);
      }
      myDemandDriver = new LgFrSceDemandDriver(theWitRun, &mpHelper);
      
      // compute and print as one
      std::cout << "Writing the Demand Drivers file  ..." << std::endl;                      
      std::string demandDriversFileName = setOfParameters.getString("demandDriversFileName");
      myDemandDriver->computeAndPrint(demandDriversFileName, theErrFacil);
      if (! setOfParameters.getBool("demandDriversRespectsSubs")) {
	//    	this->setSubsNetAllowed(true, mpHelper, theWitRun);
	mpHelper.setAllWitPartIndices(theWitRun);
      }
      // FINISH_ME: Does this thing need to be persistent??
      delete myDemandDriver;
    }


    // *************************************
    // Do a witPreprocess before the echo file
    // *************************************
    std::cout << "Pre-Processing for wit  ..." << std::endl;          
    witPreprocess(theWitRun);


    // *************************************
    // Print out an Impact Period Report
    // *************************************
    if (setOfParameters.getBool("printImpactPeriodDiagnosticFile"))  {
      std::cout << "Writing the Impact Period Diagnostic File (Implosion view) ..." << std::endl;                      
      std::string impactPdFile = setOfParameters.getString("impactPeriodDiagFileName");
      printImpactPeriodFile(theWitRun, theCal, nPeriods, 
			    impactPdFile, mpHelper);    
    }




}
// ===============================================================
// ========== End of () ==========================
// ===============================================================







// Turn ON or OFF the subNetAllowed flag of every REAL and DUMMY sub arc or every 
// REAL and DUMMY operation
// NOTE:  
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=false, then this will
// screw it up and we need to use appData!!  
void
LgFrInitialProblemForSce::setSubsNetAllowed(bool subNetAllowed, 
					    LgFrMultiPlantHelper & mpHelper,
					    WitRun * const theWitRun  )
{
  int nOperations;
  char ** opList;

  bool netAllowed = subNetAllowed;
  bool expAllowed = subNetAllowed;
  bool globalSubNetAllowed = this->sceScenario()->setOfParameters().getBool("globalSubNetAllowed");
  // OK, make sure that if globalSubNetAllowed is FALSE, that you 
  // set NetAllowed to FALSE after DemandDrivers is finished.
  // we may need an app data to clean this up

  if (subNetAllowed && !globalSubNetAllowed) {
    netAllowed = FALSE;
  }
	  


  witGetOperations(theWitRun, &nOperations, &opList);
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
    // only deal with operations that have a corresponding REAL part
    if ( ! mpHelper.isPartNormal(theWitRun, opList[o])) {
      //      witFree(opList[o]);
      continue;
    }
    int nBoms;
    witGetOperationNBomEntries(theWitRun, opList[o], &nBoms);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBoms; b++) {
      int nSubBoms;
      witGetBomEntryNSubsBomEntries(theWitRun, opList[o], b, &nSubBoms);
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) {
	char * sub;
	witGetSubsBomEntryConsumedPart(theWitRun, opList[o], b, s, &sub);
	if ( mpHelper.isPartNormal(theWitRun, sub)) {

	  witSetSubsBomEntryNetAllowed(theWitRun, opList[o], b, s, netAllowed);
	  //	  witSetSubsBomEntryExpAllowed(theWitRun, opList[o], b, s, expAllowed);
	}
	witFree(sub);
      }
    }

  }

  // temporary fix of unpreprocessing bug in wit
  float * yieldRate;
  witGetOperationYieldRate(theWitRun, opList[0], &yieldRate);
  witSetOperationYieldRate(theWitRun, opList[0], yieldRate);
  witFree(yieldRate);
			   
  for ( o=0; o<nOperations; o++) 
    witFree(opList[o]);
  witFree(opList);
}


// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::openInputFileAndScrubOutputFile(
    const std::string & fileName,
     std::string fileDescription,
    std::ifstream & inFile,
    std::ofstream & outFile,
    LgFrSceScrubber * myScrubber,
    MclFacility * theErrFacil)
{

  if (myScrubber -> scrubMode())     {
    if (sce::find(fileName, "/") != std::string::npos) {
      (*theErrFacil)("QualifiedInputFileName",MclArgList() 
		     << fileName);
    }
    
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str());
    if (!outFile.good())
      {
	(*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
		     << file);
      }
  }

  inFile.open(fileName.c_str() );//,ios::nocreate);
  if (! inFile)  {
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		   << fileDescription 
		   << fileName 
		   << "");
  }

}


// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processPartDefinitionFile(
    
    WitRun * const theWitRun,   
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

    std::string mfgPartName;
    std::string pdf_PartName;
    std::string pdf;

    LgFrSceFlatFileMgr & flatFileManager =
      this->sceScenario()->flatFileMgr();

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string dataLine;
    int result;


    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    this->openInputFileAndScrubOutputFile(fileName,
					  "Part Definition",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);

    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    bool buildNstn = this->sceScenario()->setOfParameters().getBool("useLocalBuildAhead");
    int  buildAheadLimit = this->sceScenario()->setOfParameters().getInt("buildAheadLimit");
    int * buildAheadUB = new int[nPeriods];
    int t;
    for (t=0; t<nPeriods; t++) 
      buildAheadUB[t] = buildAheadLimit;
      
    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;
    long lineNo = 0;
    while(inFile.peek() != EOF) {
      
      std::getline( inFile, dataLine );
      lineNo++;
      
      //  skip blanks or comments *
      dataLine = sce::strip( dataLine );
      if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
      }
      
      // check if the line contains any illegal characters
      if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	(*theErrFacil)("IllegalCharacter",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << dataLine);
      }
      
      SCETokenizer next(dataLine);
      
      // get the partname
      mfgPartName = flatFileManager.nextQuotedString( next, result, fileName, dataLine, 
						      lineNo, PURELY_OPTIONAL);
      pdf = flatFileManager.nextQuotedString( next, result, fileName, dataLine, lineNo, MANDATORY);
	
      // ===================================
      // == Only Regular parts get read here
      // ===================================
      result = sceAddNormalPart(theWitRun, 
				mfgPartName, 
				pdf, 
				buildNstn,
				buildAheadUB,
				mpHelper, 
				fileName, 
				dataLine,
				lineNo);
      
      if (! result)
	{
	  recCount ++;
	  if (myScrubber -> scrubMode() && outFile.good())
	    {
	      outFile << dataLine << std::endl;
	    }
	}
      
      else
	badCount++;
    }
    
    std::cout << recCount << " records processed." << std::endl;
    inFile.close();
    outFile.close();
    
    // if there is no data in this file .. ie: no good records read .. then error
    if (recCount == 0)
      (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() << "part definition");
    
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
    delete [] buildAheadUB;
}



// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processCapacityDefinitionFile(
    
    WitRun * const theWitRun,   
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

    std::string capacityName;
    std::string pdf_capacityName;
    std::string pdf;

    LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();
    
    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string dataLine;
    int result;

    std::ifstream inFile;    
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    this->openInputFileAndScrubOutputFile(fileName,
					  "Capacity Definition",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);

    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;
    long lineNo = 0;
    while(inFile.peek() != EOF) {

    std::getline( inFile, dataLine );
	lineNo++;

//  skip blanks or comments *
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
	}
// check the line for illegal characters        
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }

        
	SCETokenizer next(dataLine);

// get the capacity name

        capacityName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
                                        lineNo, PURELY_OPTIONAL);
        
        pdf = flatFileManager.nextQuotedString(next, result, fileName,
                               dataLine, lineNo, OPTIONAL_WITH_MESSAGE);


        if (result == -1) {
	  badCount++;
          continue;
        }


	  
	int   mandatoryCapacityFlag = 1;
	result = flatFileManager.nextInt(mandatoryCapacityFlag, next, fileName, dataLine, lineNo, false, 0, 1);


// =============================================
// == Now add the capacity part
// == Only Regular capacity parts get read here
// =============================================
        result = sceAddNormalCapacityPart(theWitRun, 
                                          capacityName, 
                                          pdf, 
					  mandatoryCapacityFlag,
                                          mpHelper, 
                                          fileName, 
                                          dataLine,
                                          lineNo);
	
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }
	else
	    badCount++;
    }

    std::cout << recCount << " records processed." << std::endl;
    inFile.close();
    outFile.close();
    
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processSourceDefFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

    std::string mfgPartName;
    std::string pdf_PartName;
    std::string pdf;
    std::string sourceCode;

    LgFrSceFlatFileMgr & flatFileManager =
      this->sceScenario()->flatFileMgr();

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string dataLine;
    int result;


    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    this->openInputFileAndScrubOutputFile(fileName,
					  "Source Def",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);

    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);

    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;
    long lineNo = 0;
    while(inFile.peek() != EOF) {

	std::getline( inFile, dataLine );
	lineNo++;

	//  skip blanks or comments *
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
	}

	// check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }
        
	SCETokenizer next(dataLine);

	mfgPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
	pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
	
	// FINISH_50

	// The rest of the fields are optional.  
	// Set the defaults, and parse the rest of the line.  
	float pref_cost = 0.0;
	int   early = 0;
	int   late = nPeriods-1;
	
	sourceCode = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);


	// usage rate        
	result = flatFileManager.nextFloat(pref_cost, next, fileName, dataLine, lineNo, false, -FLT_MAX);



	
	// effectivity Dates
	if (result >= 0)
	  result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
	if (result == 1) {
	  badCount++;
	  continue;
	}
	if ((early == nPeriods) || (late < 0)) {
	  (*theErrFacil)("OutOfRange",MclArgList() 
			 << "Effectivity dates" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine 
			 << "SourceDef entry ignored.");
	  badCount++;
	  continue;
	}

	result = sceSetSourcingStructure(theWitRun, 
					 mpHelper,
					 mfgPartName, 
					 pdf, 
					 sourceCode,
					 pref_cost, 
					 early, 
					 late,
					 nPeriods,
					 fileName,
					 dataLine,
					 lineNo);


	
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }
          
	else
	    badCount++;
    }

    std::cout << recCount << " records processed." << std::endl;
    inFile.close();
    outFile.close();

    
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}







// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processStandardBomFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string pdf;
 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();
 
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::string dataLine;

 int nPeriods = theCal.nPeriods();
 int result;


 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "BOM",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }

    
    SCETokenizer next(dataLine);

    // get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    float ut = 0.0;
    int   fallout = 0;
    int   early = 0;
    int   late = nPeriods-1;
    int   mec = 0;
    int   phantomFlag = 0;
    int   removeBillFlag = 0;
    int   propRtgFlag = 0;
    float   propRtgShare = 1.0;

    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // usage time
    if (result >= 0)
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result >= 0)
      result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);

    // mandatory EC
    if (result >= 0)
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, false, 0, 1);

    // phantom Flag
    if (result >= 0)
	result = flatFileManager.nextInt(phantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);

    // remove Flag
    if (result >= 0)
	result = flatFileManager.nextInt(removeBillFlag, next, fileName, dataLine, lineNo, 
			 false, 0, 1);

    // propRtg Flag
    if (result >= 0)
	result = flatFileManager.nextInt(propRtgFlag, next, fileName, dataLine, lineNo, 
			 false, 0, 1);

    // propRtg Share
    if (result >= 0)
	result = flatFileManager.nextFloat(propRtgShare, next, fileName, dataLine, lineNo, 
			 false, 0);


#ifndef  VARIABLE_PERIODS
    // scale the  usage time
    ut = ut / theCal.workUnits(early);
#endif

    result = sceAddNormalBomStructure(theWitRun, 
                                      mpHelper,
				      theCal,
                                      mfgParentPartName, 
                                      pdf, 
                                      mfgChildPartName, 
                                      pdf, 
                                      ur,
                                      ut, 
                                      early, 
                                      late,
                                      fallout,
                                      mec,
                                      phantomFlag,
                                      removeBillFlag,
				      propRtgFlag,
				      propRtgShare,
				      nPeriods,
                                      fileName,
                                      dataLine,
                                      lineNo);
    if (result == 0)
      {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
      }
    else
      badCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 // if no data in input file, then error
 if (recCount == 0)
   (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() << "BOM file");

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

#ifdef MULTI_SITE_BOM
// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processMultiSiteBomFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string ParentPdf;
 std::string ChildPdf;
 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();
 
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::string dataLine;

 int nPeriods = theCal.nPeriods();
 int result;


 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "BOM",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }

    
    SCETokenizer next(dataLine);

    // get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the parent PDF
    ParentPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);




    // get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

    // get the ChildPdf
    ChildPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    float ut = 0.0;
    int   fallout = 0;
    int   early = 0;
    int   late = nPeriods-1;
    int   mec = 0;
    int   phantomFlag = 0;
    int   removeBillFlag = 0;
    int   propRtgFlag = 0;
    float   propRtgShare = 1.0;


    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // usage time
    if (result >= 0)
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int) lineNo 
		     << dataLine 
		     << "BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result >= 0)
      result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);

    // mandatory EC
    if (result >= 0)
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, false, 0, 1);

    // phantom Flag
    if (result >= 0)
	result = flatFileManager.nextInt(phantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);

    // remove Flag
    if (result >= 0)
	result = flatFileManager.nextInt(removeBillFlag, next, fileName, dataLine, lineNo, 
			 false, 0, 1);

    // propRtg Flag
    if (result >= 0)
	result = flatFileManager.nextInt(propRtgFlag, next, fileName, dataLine, lineNo, 
			 false, 0, 1);

    // propRtg Share
    if (result >= 0)
	result = flatFileManager.nextFloat(propRtgShare, next, fileName, dataLine, lineNo, 
			 false, 0);


#ifndef  VARIABLE_PERIODS
    // scale the  usage time
    ut = ut / theCal.workUnits(early);
#endif

    result = sceAddNormalBomStructure(theWitRun, 
                                      mpHelper,
				      theCal,
                                      mfgParentPartName, 
                                      ParentPdf, 
                                      mfgChildPartName, 
                                      ChildPdf, 
                                      ur,
                                      ut, 
                                      early, 
                                      late,
                                      fallout,
                                      mec,
                                      phantomFlag,
                                      removeBillFlag,
				      propRtgFlag,
				      propRtgShare,
				      nPeriods,
                                      fileName,
                                      dataLine,
                                      lineNo);
    if (result == 0)
      {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
      }
    else
      badCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 // if no data in input file, then error
 if (recCount == 0)
   (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() << "BOM file");

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


#endif



// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processBillOfCapacitiesFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string pdf;

 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;


 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "BOC",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 LgFrTimeVecFloat zeroVec(nPeriods, 0.0);
 bool capacityOffsetToZero = this->sceScenario()->setOfParameters().getBool("capacityOffsetToZero"); 
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    float ut = 0.0;
    int   fallout = 0;
    int   early = 0;
    int   late = nPeriods-1;

    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // usage time
    if (result >= 0)
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "");
	badCount++;
	continue;
    }

#ifndef  VARIABLE_PERIODS
    // scale the  usage time
    ut = ut / theCal.workUnits(early);
#endif


    // FINISH: VARIABLE_PERIODS itize this
    result = sceAddNormalBocStructure(theWitRun, 
                                      mpHelper,
				      theCal,
                                      mfgParentPartName, 
                                      pdf, 
                                      mfgChildPartName, 
                                      pdf, 
                                      ur,
                                      ut, 
                                      early, 
                                      late,
				      capacityOffsetToZero,
				      zeroVec,
                                      fileName,
                                      dataLine,
                                      lineNo);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
        outFile << dataLine << std::endl;
      }
    }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processOperationBomFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string consumedPartName;
 std::string operationName;
 std::string pdf;

 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Operations BOM",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo <<  dataLine);
        }


    SCETokenizer next(dataLine);

    // get the operation name 
    operationName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the consumed part name 
    consumedPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    float offset = 0.0;
    int   fallout = 0;
    int   mec = 0;
    int   early = 0;
    int   late = nPeriods-1;

    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // offset
    if (result >= 0)
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "Operation BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result >= 0)
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);

    // mandatory EC
    if (result >= 0)
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, false, 0, 1);


// scale the  usage time
    offset = offset / theCal.workUnits(early);

    result = sceAddNormalOperationBomStructure(theWitRun, 
					       mpHelper,
					       operationName, 
					       pdf, 
					       consumedPartName, 
					       pdf, 
					       ur,
					       offset, 
					       early, 
					       late,
					       fallout,
					       mec,
					       fileName,
					       dataLine,
					       lineNo);
    if (result == 0)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else
      badCount++;
    
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}




// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processOperationBopFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string producedPartName;
 std::string operationName;
 std::string pdf;

 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr(); 

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;
 
 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Operation BOP",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOP line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the produced part name 
    producedPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the Operation Name 
    operationName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float prodRate = 1.0;
    float offset = 0.0;
    int   early = 0;
    int   late = nPeriods-1;
    int   isObjectInEffectForOptExplosion = 1; // default = "in effect"
    float preference = 0.0;  // direct setting on expAversion
    int   expAllowed = 1;   // direct setting on expAllowed
    float pipShare = 1.0;    // float converted to floatVec for pipShare
    
    // Use the right model helper to get the preference info.
    // (seems like we should be able to do this with out testing every time...)
    // FINISH_ME: lp model
    preference = heurModelHelper_->defaultExplicitBopPreference();
    // if ( lpModelHelper_ != 0 )
    //  preference = lpModelHelper_->defaultExplicitBopCost(); ??
    
    // production  rate        
    result = flatFileManager.nextFloat(prodRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // offset
    if (result >= 0) 
      result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);
    
    // effectivity Dates
    if (result >= 0)
	result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int)lineNo << dataLine << "BOP entry ignored.");
	badCount++;
	continue;
    }

    // preference/cost
    if (result >= 0)
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, false, -FLT_MAX); 


    // isObjectInEffectForOptExplosion flag
    if (result >= 0)
      result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1); 

    // expAllowed flag
    if (result >= 0)
      result = flatFileManager.nextInt(expAllowed, next, fileName, dataLine, lineNo, false, 0, 1); 

    // pipShare
    if (result >= 0)
      result = flatFileManager.nextFloat(pipShare, next, fileName, dataLine, lineNo, false, -FLT_MAX); 



    // scale the scalar offset and
    // set the offsetTimeVec based on effectivity dates
    offset = offset / theCal.workUnits(early);

    result = sceAddNormalBopStructure(theWitRun, 
                                      mpHelper,
                                      producedPartName, 
                                      pdf, 
                                      operationName, 
                                      pdf, 
                                      prodRate,
                                      offset, 
                                      early, 
                                      late,
                                      preference,
				      pipShare,
                                      isObjectInEffectForOptExplosion,
				      expAllowed,
                                      fileName,
                                      dataLine,
                                      lineNo);
    
    if (result == 0)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
      else
      badCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

//

void 
LgFrInitialProblemForSce::processAggregationFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  // Aggregation:  The aggregation file is read and both the parent and child
  // parts are created on-the-fly if they are unknown to SCE!!!  Why is this?

 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr(); 

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Aggregation",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }

    
    SCETokenizer next(dataLine);

    // get the mfg part
    std::string mfgPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
                                         lineNo, PURELY_OPTIONAL);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the PDF
    std::string mfgPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
                                        lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the aggregate part name
    std::string aggregatePart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
                                               lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
      badCount++;
      continue;
    }


    // get the aggregate PDF
    std::string aggregatePdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
                                              lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }
    

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    float offset = 0.0;
    float preference = 0.0;
    int isObjectInEffectForOptExplosion = 1;

    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // offset
    if (result == 0)
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // preference
    // Use the right model helper to get the preference info.
    // (seems like we should be able to do this with out testing every time...)
    // FINISH_ME: lp model    
    preference = heurModelHelper_->defaultAggregateBopPreference();
    // else if ( lpModelHelper_ != 0 )
    // preference = lpModelHelper_->defaultAggregateBopCost(); //
    
    if (result == 0)
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // isObjectInEffectForOptExplosion flag
    if (result == 0)
      result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);
 
    // scale the  offset
    offset = offset / theCal.workUnits(0);

    result = sceAddAggregateBomStructure(theWitRun, 
                                         mpHelper,
                                         mfgPart, 
                                         mfgPdf, 
                                         aggregatePart,  
                                         aggregatePdf, 
                                         ur,
                                         offset,
                                         preference,
                                         isObjectInEffectForOptExplosion,
                                         fileName,
                                         dataLine,
                                         lineNo);
    if (result == -1) {
      badCount++;
      continue;
    }
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
        outFile << dataLine << std::endl;
      }
 }

 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processFeatureSetToOptionRatioFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
 std::string plannerTopLevelPart;
 std::string bbCategory;
 std::string geo;
 std::string mfgOptionPart;

 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;

 // Note, we'll be setting negative production costs which
 // causes a Wit warning message. Suppress it.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, 0);
 
 float * featureRatio = new float[nPeriods];

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 std::string engine  = this->sceScenario()->setOfParameters().getString("engine"); 

 this->openInputFileAndScrubOutputFile(fileName,
				       "Feature Set to Option Ratio",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);





 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }

    
    SCETokenizer next(dataLine);

// get the planner Top Level Part Name
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
	badCount++;
	continue;
    }

// get the geo
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

// get the BB category
    bbCategory = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				  lineNo, MANDATORY);

// get the (mfg) Option Part  name
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, MANDATORY);


    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float usageRate;

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
	featureRatio[t] = 0.0;


    // usageRate
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);



    // featureRatio vector
    if (result == 0)  {
	int t = 0; 
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, false, 0.0);
	    if (result != 0)
		break;
	}
    }

   
    if (engine == "optimization") 
      result = sceAddBBtoOptionBomStructure(
					    theWitRun, 
					    mpHelper,
					    theCal,
					    plannerTopLevelPart, 
					    geo,
					    bbCategory,
					    mfgOptionPart,
					    usageRate, 
					    featureRatio,
					    fileName,
					    dataLine,
					    lineNo);
    else
      result = sceAddBBtoOptionBomStructureViaProportionalRoute(
								theWitRun, 
								mpHelper,
								theCal,
								plannerTopLevelPart, 
								geo,
								bbCategory,
								mfgOptionPart,
								usageRate, 
								featureRatio,
								fileName,
								dataLine,
								lineNo);

    if (! result)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else
      badCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close(); 
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 delete [] featureRatio;
 // turn message 605 back on.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, UCHAR_MAX); 

}


// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processFeatureSetToOptionRatioFile61(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
  MclFacility * theErrFacil            = this->sceScenario()->getErrFacility();
  LgFrSceScrubber * myScrubber         = this->sceScenario()->scrubber();
  
  std::ifstream inFile;
  std::ofstream outFile;
  this->openInputFileAndScrubOutputFile(fileName, "Feature Set to Option Ratio", inFile, outFile, myScrubber, theErrFacil);
  
  // attributes to read off file
  std::string dataLine;
  
  std::string plannerTopLevelPart;
  std::string sourceLoc;
  std::string geoPreD20;
  std::string bbCategory;
  std::string mfgOptionPart;
  std::string requestDate;
  float       usageRate;
  float       attachRate;
  float       mwoVal;
  float       mfOffsetVal;
  int         mfoPhantomFlag;
  float       mfSupplyVal;
  int         earlyPeriod;
  int         latePeriod;
  
  
  std::string geo;  
  int requestPeriod;  
  std::string engine  = this->sceScenario()->setOfParameters().getString("engine"); 
  
  int nPeriods = theCal.nPeriods();
  int result;
  
  // Note, we'll be setting negative production costs which causes a Wit warning message. Suppress it.
  witSetMesgTimesPrint(theWitRun, WitTRUE, 605, 0);
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;
  while(inFile.peek() != EOF) {
    std::getline( inFile, dataLine );
    lineNo++;
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }
    SCETokenizer next(dataLine);
    
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    sourceLoc = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    geoPreD20 = flatFileManager.nextQuotedDemandString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    bbCategory = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    if (result == -1) { badCount++; continue; }
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    
    // requestDate and usageRate
    bool dieIfErrorFlag = true;
    result = flatFileManager.readDatedDemandFloatRecord(usageRate, requestDate, dieIfErrorFlag, -FLT_MAX, FLT_MAX,
							next, fileName, dataLine, lineNo, mpHelper, theCal);
    
    
    // Map requestDate to requestPeriod
    //       rule: reject early 
    //       rule: reject late
    requestPeriod = theCal.period(requestDate);  
    if (requestPeriod >= nPeriods)  {
      (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
      badCount++; continue; }
    if (requestPeriod < 0)  {
     (*theErrFacil)("DatedRecordBeforeHorizonStartIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
     badCount++; continue; }
   
   
    // attachRate 
    result = flatFileManager.nextFloat(attachRate, next, fileName, dataLine, lineNo, false, 0.0);
    if (result == -1) { badCount++; continue; }
    // mfOffset
    result = flatFileManager.nextFloat(mfOffsetVal, next, fileName, dataLine, lineNo, false, -FLT_MAX, FLT_MAX);
    if (result == -1) { badCount++; continue; }
    // featurePhantomFlag
    result = flatFileManager.nextInt(mfoPhantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);
    if (result == -1) { badCount++; continue; }
    // mfSupply
    result = flatFileManager.nextFloat(mfSupplyVal, next, fileName, dataLine, lineNo, false, 0, FLT_MAX);
    if (result == -1) { badCount++; continue; }
   
    // effectivity Dates: earlyPeriod, latePeriod
    result = flatFileManager.nextStartEndDates(earlyPeriod, latePeriod, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) { badCount++; continue; }
   
    // FINISH_ME_61: Is this the right rule ??
    if ((earlyPeriod == nPeriods) || (latePeriod < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "Featratio entry ignored.");
      badCount++; continue; }
   
    // D2O: Append the RequestDate onto the demand key to enforce period uniqueness
    geo = mpHelper.expandDemandKeyforD2O(geoPreD20, requestDate, sourceLoc);
   
    if (engine == "optimization") {
      LgFrTimeVecFloat attachRateTV(nPeriods, attachRate);
      result = sceAddBBtoOptionBomStructure(theWitRun, mpHelper, theCal,
					    plannerTopLevelPart, geo, bbCategory, mfgOptionPart,
					    usageRate, attachRateTV.data(),
					    fileName, dataLine, lineNo);
    }
    else {
      result = sceAddBBtoOptionBomStructureViaProportionalRoute61(theWitRun, mpHelper, theCal,
								  plannerTopLevelPart, geo, bbCategory, mfgOptionPart,
								  usageRate, attachRate, mfOffsetVal, mfoPhantomFlag, mfSupplyVal,
								  earlyPeriod, latePeriod, requestPeriod, fileName, dataLine, lineNo);
    }
   
    if (! result)  {
      recCount ++;
      if (myScrubber -> scrubMode() && outFile.good())	{
	outFile << dataLine << std::endl;
      }
    }
    else
      badCount++;
  }
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close(); 
 
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

  // turn message 605 back on.
  witSetMesgTimesPrint(theWitRun, WitTRUE, 605, UCHAR_MAX); 
 
}


// ---------------------------------------------------------
void
LgFrInitialProblemForSce::processOptionRevenueFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper,
    const float defaultOptionShipReward,
    const float periodicInterestRate)
{
 std::string plannerTopLevelPart;
 std::string geo;
 std::string mfgOptionPart;

 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr(); 

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;

 // optional paramter
 float * featureRev = new float[nPeriods];

 // Note, we'll be setting negative production costs which
 // causes a Wit warning message. Suppress it.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, 0);

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Option Revenue",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
       
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

   // read the next BOM line
   std::getline( inFile, dataLine );
   lineNo++;

   //  skip blanks or comments *
   dataLine = sce::strip( dataLine );
   if ((dataLine.empty()) || (dataLine[0] == '*')) {
     commentCount++;
     continue;
   }

   // check if the line contains any illegal characters
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
   }

    
   SCETokenizer next(dataLine);

   // get the planner Top Level Part Name
   plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
   if (result == -1) {
     badCount++;
     continue;
   }

   // get the geo
   geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);


   // get the (mfg) Option Part  name
   mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, MANDATORY);


   // The rest of the fields are optional.  
   // Set the defaults, and parse the rest of the line.  
   
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<nPeriods; t++) {
     featureRev[t] = - defaultOptionShipReward;
   }


   // featureRev vector
   if (result == 0)  {
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++)  {
       result = flatFileManager.nextFloat(featureRev[t],
                                 next, fileName, dataLine, lineNo, false, -FLT_MAX);
       if (result != 0)
         break;
       featureRev[t] = - featureRev[t];
     }
   }
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
   result = sceSetOptionRevenueViaMultiRoute(
                                theWitRun, 
                                mpHelper,
                                plannerTopLevelPart, 
                                geo,
                                mfgOptionPart,
                                featureRev,
                                periodicInterestRate,
                                fileName,
                                dataLine,
                                lineNo);
#else
   result = sceSetOptionRevenue(
                                theWitRun, 
                                mpHelper,
                                plannerTopLevelPart, 
                                geo,
                                mfgOptionPart,
                                featureRev,
                                periodicInterestRate,
                                fileName,
                                dataLine,
                                lineNo);
#endif

   if (! result)
     {
       recCount ++;
       if (myScrubber -> scrubMode() && outFile.good())
         {
           outFile << dataLine << std::endl;
         }
     }
   else
      badCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 delete [] featureRev;
 // turn message 605 back on.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, UCHAR_MAX); 
}






// ---------------------------------------------------------
void
LgFrInitialProblemForSce::processTopLevelToOptionalFeatureFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  // Detect that if a maxWithout is 1.0, then the
  // option is a PURE_OPTION, otherwise it is a GATING_OPTION
  // (aka maxWithout option).
  //
  // For PURE_OPTIONS, set up as a direct bom with substitute
  // to a global NULL_Substitute.
  //
  // For a GATING_OPTION (aka maxWithout option), set up as a
  // direct bom with substitute to a maxWithout null substitute if
  // maxWithout ratio is > 0.0. Otherwise, if maxWithout ratio
  // = 0.0 in all periods, set up as a direct bom with substutite
  // to a "global" maxWithout null substitute.
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string dataLine;

  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();
  int result;

  // Note, we'll be setting negative production costs which
  // causes a Wit warning message. Suppress it.
  witSetMesgTimesPrint(theWitRun, WitTRUE, 605, 0);
  
  float * featureRatio = new float[nPeriods];
  float * maxWithout   = new float[nPeriods];
  
  float * defaultGatingOptionSubPenalty = new float[nPeriods];
  
  LgFrSceSetOfParameters & setOfParameters =
    this->sceScenario()->setOfParameters();
  
  
  float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");
  
  int tt = 0;
  for (tt=0; tt<nPeriods; tt++)
    defaultGatingOptionSubPenalty[tt] = defaultOptionShipReward;

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"Top Level to Optional Feature",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;
  while(inFile.peek() != EOF) {
    
// read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;
    
//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }

    
    SCETokenizer next(dataLine);
    
// get the planner Top Level Part Name
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
	badCount++;
	continue;
    }

// get the geo
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

// get the (mfg) Option Part  name
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float usageRate;

    // First set the feature ratio default to be 0.0
    // Initialize the maxWithout to be 1.0.
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      featureRatio[t] = 0.0;
      maxWithout[t] = 1.0;
    }

    // usageRate
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // featureRatio vector
    if (result == 0)  {
	int t = 0; 
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, false, 0.0);
	    if (result != 0)
		break;
	}
    }

    // maxWithout Ratio vector must be between -1 and +1
    if (result == 0)  {
	int t = 0;
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(maxWithout[t], 
					       next, fileName, dataLine, lineNo, 
					       false, -1.0, 1.0);
	}
    }


    LgFrTimeVecFloat maxWithoutTimeVec( (size_t) nPeriods, maxWithout );

    float maxMWO = maxWithoutTimeVec.max();
    float minMWO = maxWithoutTimeVec.min();


    // Now make sure the maxWithout does not have positive and negative 
    // Numbers.  This is an error.
    if ((minMWO < -IPSCE_FLT_EPS) && (maxMWO > IPSCE_FLT_EPS)) {
	// if there are negative and positive numbers mixed up
	// then complain and  reject.  
	(*theErrFacil)("MwoPosAndNegNotSupported",MclArgList() 
		       << fileName 
		       << (int)lineNo
		       << dataLine
		       << plannerTopLevelPart
		       << geo 
		       << mfgOptionPart);
	badCount++;
	continue;
    }


    // Analyze maxWithout to determine what kind of standalone feature we have:
    // it must be one of:
    //     SCE_FEATURE_TYPE_CUSTOMER_CHOICE
    //     SCE_FEATURE_TYPE_PURELY_OPTIONAL
    //     SCE_FEATURE_TYPE_MANDATORY
    //     SCE_FEATURE_TYPE_MWO
    int featureType;
    if (minMWO < -IPSCE_FLT_EPS) 
      featureType = SCE_FEATURE_TYPE_CUSTOMER_CHOICE;
    else if (minMWO < IPSCE_FLT_EPS)
      featureType = SCE_FEATURE_TYPE_MANDATORY;
    else if (minMWO < 1.0 - IPSCE_FLT_EPS)
      featureType = SCE_FEATURE_TYPE_MWO;
    else
      featureType = SCE_FEATURE_TYPE_PURELY_OPTIONAL;



    if (featureType == SCE_FEATURE_TYPE_CUSTOMER_CHOICE)
      result = sceAddCustChoiceFeatureStructure(theWitRun, 
						mpHelper,
						theCal,
						plannerTopLevelPart, 
						geo,
						mfgOptionPart,
						usageRate, 
						featureRatio,
						defaultGatingOptionSubPenalty,
						fileName,
						dataLine,
						lineNo);
      
  
    else       {
      result = sceAddStdAloneOptionBomStructure(theWitRun, 
						mpHelper,
						plannerTopLevelPart, 
						geo,
						mfgOptionPart,
						usageRate, 
						featureRatio,
						maxWithout,
						defaultGatingOptionSubPenalty,
						featureType,
						fileName,
						dataLine,
						lineNo);
    }


      
    // increment the feature counter 
    if (! result)
      sceScenario()->incrementStandaloneFeatureArcs();


    if (! result)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else
      badCount++;
  }

 std::cout << recCount << " records processed." << std::endl;

 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 delete [] featureRatio;
 delete [] maxWithout;
 delete [] defaultGatingOptionSubPenalty;
 // turn message 605 back on.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, UCHAR_MAX); 
 
}






// ---------------------------------------------------------
void
LgFrInitialProblemForSce::removeGpdBopOffsets(
    WitRun * const theWitRun,
    LgFrMultiPlantHelper & mpHelper)
{
  char ** partList;
  int nParts;
  std::string pp, geo;


  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  float * zeroVec = new float [nPeriods];
  int t = 0; 
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0.0;

  witGetParts ( theWitRun, &nParts, &partList );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i], pp, geo)) {
      witSetBopEntryOffset(theWitRun, partList[i], 0, zeroVec);
    }
  }

  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  delete [] zeroVec;

}

// ---------------------------------------------------------
void
LgFrInitialProblemForSce::processMachineFeatureOffsetFile(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  // Set an offset between a machine and a feature.
  // This would be in ADDITION to:
  //    transit_time (on a geo source)
  //    cycleTime on the machine
  //    cycleTime on the feature
  //
  // This method also allows a phantom flag to be set which
  // nullifies the feature cycleTime.
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  int featurePhantomFlag;
  int start;
  int end;
  
  std::string dataLine;

  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();
  int result;

  
  LgFrSceSetOfParameters & setOfParameters =
    this->sceScenario()->setOfParameters();

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"Machine to Feature Offset File",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);

  
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;
  while(inFile.peek() != EOF) {
    
// read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;
    
//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }

    
    SCETokenizer next(dataLine);

    // set defaults
    featurePhantomFlag = 0;
    start = 0;
    end = nPeriods - 1;
    

    
    // get the planner Top Level Part Name
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
	badCount++;
	continue;
    }

    // get the geo
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

    // get the (mfg) Option Part  name
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

    // offsetVal
    float offsetVal;
    result = flatFileManager.nextFloat(offsetVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);

    if (result == -1) {
	badCount++;
	continue;
    }


    // ++++  Now comes the optional Part of the file +++++
    // featurePhantomFlag
    result = flatFileManager.nextInt(featurePhantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);

    if (result >= 0)
      result = flatFileManager.nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);



    
    if (result == 1) {
       badCount++;        
       continue;
    }


    result = sceSetMachineFeatureOffset(theWitRun, 
					mpHelper,
					theCal,
					plannerTopLevelPart, 
					geo,
					mfgOptionPart,
					offsetVal, 
					featurePhantomFlag,
					start,
					end,
					fileName,
					dataLine,
					lineNo);
    

      
    if (! result) {
      recCount++;
      if (myScrubber -> scrubMode() && outFile.good()) {
	outFile << dataLine << std::endl;
      }
    }
    else
      badCount++;
  }

 std::cout << recCount << " records processed." << std::endl;

 inFile.close();
 outFile.close();

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 
}


// ---------------------------------------------------------
void
LgFrInitialProblemForSce::processMachineFeatureSupplyFile(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  // Provide a supplyVol for the feature but peg it to a machine
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string dataLine;

  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();
  int result;

  
  float * supplyVol = new float[nPeriods];
  
  LgFrSceSetOfParameters & setOfParameters =
    this->sceScenario()->setOfParameters();
  
  
  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"Machine Feature Supply ",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;
  while(inFile.peek() != EOF) {
    
// read the next data line
    std::getline( inFile, dataLine );
    lineNo++;
    
//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }

    
    SCETokenizer next(dataLine);
    
// get the planner Top Level Part Name
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
	badCount++;
	continue;
    }

// get the geo
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

// get the (mfg) Option Part  name
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }


    // Clear the data vector
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      supplyVol[t] = 0.0;
    }




    // supplyVol vector
    if (result == 0)  {
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(supplyVol[t], next, fileName, dataLine, lineNo, false, 0.0);
	    if (result != 0)
		break;
	}
    }



    result = sceAddMachineFeatureSupplyVol(theWitRun, 
					   mpHelper,
					   plannerTopLevelPart, 
					   geo,
					   mfgOptionPart,
					   supplyVol,
					   fileName,
					   dataLine,
					   lineNo);
      


    if (! result)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else
      badCount++;
  }

 std::cout << recCount << " records processed." << std::endl;

 inFile.close();
 outFile.close();
 // flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 delete [] supplyVol;
}






// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processTopLevelToFeatureSetFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
    std::string plannerTopLevelPart;
    std::string geo;
    std::string plannerFeatureSetPart;
    std::string bbCategory;
    std::string dataLine;

    LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();     
    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    int nPeriods = theCal.nPeriods();
    int result;

    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    float * gammaMaxVector = new float[nPeriods];

    std::string engine  = this->sceScenario()->setOfParameters().getString("engine"); 
    
    this->openInputFileAndScrubOutputFile(fileName, "Top Level To Feature Set File", inFile, outFile, myScrubber, theErrFacil);

    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;
    long lineNo = 0;
    while(inFile.peek() != EOF) {
	std::getline( inFile, dataLine );
	lineNo++;
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
	}
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }
	SCETokenizer next(dataLine);

	// get the planner Top Level Part Name
	plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
	if (result == -1) {
	    badCount++;
	    continue;
	}

	// get the geo
	geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

	// get the bbCategory name
	bbCategory = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);


	// The rest of the fields are optional.  
	// Set the defaults, and parse the rest of the line.  
	int early = 0;
	int late = nPeriods-1;
	float gammaMin = 1.0;
	float gammaMax;

	// In new model, the gammaMax is replace with a vector.
	// for proportional split, we use the vector.   For LP model we pick up the first period 
	// as gammaMax scalar.  FINISH_ME is to convert the LP logic to a vector.


	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  gammaMaxVector[t] = 0.0;


	// gammaMax Vector is initiailized back to zero, before re-reading
	if (result == 0)  {
	  int t = 0;
	  for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(gammaMaxVector[t], next, fileName, dataLine, lineNo, false, 0.0);
	    if (result != 0)
	      break;
	  }
	}
	

	if (engine == "optimization" ) {
	  gammaMax = gammaMaxVector[0];
	  result = sceAddBbCategoryPartAndStructure(theWitRun, 
						    mpHelper,
						    plannerTopLevelPart,
						    geo,
						    bbCategory,
						    gammaMax,
						    gammaMin,
						    early, 
						    late,
						    fileName,
						    dataLine,
						    lineNo);
	}
	else {
	  result = sceAddBbCategoryPartAndStructureViaProportionalRoute(theWitRun, 
									mpHelper,
									plannerTopLevelPart,
									geo,
									bbCategory,
									gammaMaxVector,
									gammaMin,
									early, 
									late,
									fileName,
									dataLine,
									lineNo);
	}
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }
	else
	    badCount++;
    }
    std::cout << recCount << " records processed." << std::endl;
    inFile.close();
    outFile.close();

    delete [] gammaMaxVector;
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processTopLevelToFeatureSetFile61(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();     
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  
  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  this->openInputFileAndScrubOutputFile(fileName, "Top Level To Feature Set File", inFile, outFile, myScrubber, theErrFacil);

  int result;  
  int nPeriods = theCal.nPeriods();  
  std::string engine  = this->sceScenario()->setOfParameters().getString("engine"); 
  
  // attributes to read off file
  std::string dataLine;

  std::string plannerTopLevelPart;
  std::string sourceLoc;
  std::string geoPreD20;
  std::string bbCategory;
  std::string requestDate;
  float       gammaMax;

  int         earlyPeriod;
  int         latePeriod;

  float gammaMin = 1.0;  // default  
  
  std::string geo;  
  int requestPeriod;  
  std::string plannerFeatureSetPart;

  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  while(inFile.peek() != EOF) {
    std::getline( inFile, dataLine );
    lineNo++;
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }
    SCETokenizer next(dataLine);
    
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    sourceLoc = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    geoPreD20 = flatFileManager.nextQuotedDemandString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    bbCategory = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    
    // requestDate and gammaMax
    bool dieIfErrorFlag = true;
    result = flatFileManager.readDatedDemandFloatRecord(gammaMax, requestDate, dieIfErrorFlag, 0.0, FLT_MAX,
							next, fileName, dataLine, lineNo, mpHelper, theCal);
    

    // Map requestDate to requestPeriod
    //      rule: reject early 
    //      rule: reject late
    requestPeriod = theCal.period(requestDate);  
    if (requestPeriod >= nPeriods)  {
      (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
      badCount++; continue; }
    if (requestPeriod < 0)  {
      (*theErrFacil)("DatedRecordBeforeHorizonStartIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
      badCount++; continue; }


    
    // effectivity Dates: earlyPeriod, latePeriod
    result = flatFileManager.nextStartEndDates(earlyPeriod, latePeriod, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) { badCount++; continue; }

    // FINISH_ME_61: Is this the right rule ??
    if ((earlyPeriod == nPeriods) || (latePeriod < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "Featratio entry ignored.");
      badCount++; continue; }


    // D2O:  Append the RequestDate onto the demand key to enforce period uniqueness
    geo = mpHelper.expandDemandKeyforD2O(geoPreD20, requestDate, sourceLoc);


    
    if (engine == "optimization" ) {
      result = sceAddBbCategoryPartAndStructure(theWitRun, 
						mpHelper,
						plannerTopLevelPart,
						geo,
						bbCategory,
						gammaMax,
						gammaMin,
						earlyPeriod, 
						latePeriod,
						fileName,
						dataLine,
						lineNo);
    }
    else {
      result = sceAddBbCategoryPartAndStructureViaProportionalRoute61(theWitRun, 
								      mpHelper,
								      plannerTopLevelPart,
								      geo,
								      bbCategory,
								      gammaMax,
								      gammaMin,
								      earlyPeriod, 
								      latePeriod,
								      fileName,
								      dataLine,
								      lineNo);
    }
    if (! result)
      {
	recCount ++;
	if (myScrubber -> scrubMode() && outFile.good())
	  {
	    outFile << dataLine << std::endl;
	  }
      }
    else
      badCount++;
  }
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close();

  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}




// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processInterPlantFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string parentPdf;
 std::string childPdf;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;
 int result2;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "InterPlant",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 long nonUniqueCount = 0;

 while(inFile.peek() != EOF) {

// read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

    SCETokenizer next(dataLine);

// get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

// get the parent PDF
    parentPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				 lineNo, MANDATORY);


// get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

// get the child PDF
    childPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				lineNo, MANDATORY);

// The rest of the fields are optional.  
// Set the defaults, and parse the rest of the line.  
    float transitTime = 0.0;
    int   early = 0;
    int   late = nPeriods-1;
    float minLotSize = 1.0;
    float incLotSize = 1.0;
    float usageRate = 1.0;
    float preference = 0.0; // FINISH_ME: get the fault from the paramMgr...
    int   isObjectInEffectForOptExplosion = 1;
    int   expAllowed = 1;
    float   routingShare = 1.0;
    
    // transitTime  (negative usage time)
    if (result >= 0)
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // effectivity Dates
    if (result >= 0)
	result2 = flatFileManager.nextStartEndDates(early, late, next,
                                    fileName, lineNo, dataLine, theCal);
    if (result2 == 1) {
	badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int)lineNo 
		     << dataLine 
		     << "Interplant entry ignored.");
	badCount++;
	continue;
    }

    // minimum and incremental lot sizes
    // note: ranges and defaults are consitent with those for 
    // manufacturing minLotSize and incLotSize. 
    if (result2 == 0)
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, false, 0.0 );
    
    if ( result == 0 && minLotSize >= 0.0 )
      result = flatFileManager.nextFloat( incLotSize, next, fileName, dataLine,
                           lineNo, false, 1.0);

    // usageRate
    if ( result == 0 )
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // preference
    preference = heurModelHelper_->defaultInterPlantBopPreference();
    // FINISH_ME lp model 
    // if ( lpModelHelper_ != 0 )
    // preference = lpModelHelper_->defaultInterPlantBopCost(); ??
    if ( result == 0 )
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // is ObjectInEffectForOptExplosion
    if ( result == 0 )
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);

    // expAllowed
    if ( result == 0 )
      result = flatFileManager.nextInt( expAllowed, next, fileName, dataLine, lineNo, false, 0, 1);


    if ( result == 0 )
      result = flatFileManager.nextFloat( routingShare, next, fileName, dataLine, lineNo, false, 0.0);

      
    result = addInterPlantBomStructure(
	theWitRun, 
	mpHelper,
	theCal,
	mfgParentPartName, 
	parentPdf,
	mfgChildPartName, 
	childPdf, 
	transitTime, 
	early,
	late,
        minLotSize,
        incLotSize,
        usageRate,
        preference,
        isObjectInEffectForOptExplosion,
        expAllowed,
	routingShare,
	fileName,
	dataLine,
	lineNo);
    
    if (result < 0) // something wrong
      badCount++;
    else {
      if (result == 0)   // good 
        recCount ++;
      else  //  good non-unique
	nonUniqueCount++;

      if (myScrubber -> scrubMode() && outFile.good()) {
	outFile << dataLine << std::endl;
      }
    }
 }

 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount-nonUniqueCount);
}





// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processOperationSubBomFile(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string operationName;
 std::string mfgChildPartName;
 std::string mfgSubPartName;
 std::string pdf;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceSetOfParameters & setOfParameters =
   this->sceScenario()->setOfParameters();
  
  
 bool globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");

 int nPeriods = theCal.nPeriods();
 int result, result2;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Operation Sub Bom",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM Sub line
    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
    }

    
    SCETokenizer next(dataLine);

// get the mfg Parent PartName 
    operationName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
						     lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
	badCount++;
	continue;
    }

// get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
							lineNo, MANDATORY);

// get the mfg Child PartName 
    mfgSubPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
						      lineNo, MANDATORY);

// get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    int   fallout = 0;
    int   early = 0;
    int   late = nPeriods-1;
    float defaultSubPenalty =
           this->sceScenario()->setOfParameters().getFloat("defaultSubPenalty");
    int isObjectInEffectForOptExplosion = 0;
    int isSubstituteBuildable = 0;
    int isNetAllowed = 1;
    int offsetDeltaDays = 0;
    float offsetDelta = 0.0;
    float propRtg_Share = 1.0;
    
    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, 
				       dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	result2 = flatFileManager.nextStartEndDates(early, late, next, 
						    fileName, lineNo, dataLine, theCal);
    // if  dates messed up, then skip this record
    if (result2 == 1)
	continue;
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int)lineNo 
		     << dataLine 
		     << "Operation Substitute BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result2 == 0)
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);

    // sub penalty cost
    if (result == 0)
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // isObjectInEffectForOptExplosion flag
    if (result == 0)
	result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, 
					 dataLine, lineNo, false, 0, 1);    

    // isSubstituteBuildable flag
    if (result == 0)
	result = flatFileManager.nextInt(isSubstituteBuildable, next, fileName, 
					 dataLine, lineNo, false, 0, 1);    

    // netAllowed flag
    if (result == 0)
	result = flatFileManager.nextInt(isNetAllowed, next, fileName, 
					 dataLine, lineNo, false, 0, 1);    

    // offsetDeltaDays
    if (result == 0)
	result = flatFileManager.nextInt(offsetDeltaDays, next, fileName, dataLine, lineNo, false, -INT_MAX, INT_MAX);

    // scale the offsetDelta 
    offsetDelta = offsetDeltaDays / theCal.workUnits(early);

    // proportional routing share
    if (result == 0)
	result = flatFileManager.nextFloat(propRtg_Share, next, fileName, dataLine, lineNo, false, 0);




    // this is method for Operation Sub Bom
// Call the SCE init advanced to add the sub
    bool isParentAnOperation = true;
    result = sceAddSubstitute(
	theWitRun, 
	mpHelper,
	isParentAnOperation,
	operationName, 
	pdf, 
	mfgChildPartName, 
	pdf, 
	mfgSubPartName,
	pdf,
	ur,
	early, 
	late,
	fallout,
	defaultSubPenalty,
	isObjectInEffectForOptExplosion,
	isSubstituteBuildable,
	//	globalSubNetAllowed,
	isNetAllowed,
	0.,
	offsetDelta,
	propRtg_Share,
	fileName,
	dataLine,
	lineNo);
    if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }

    else
	badCount++;


 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,
						 badCount,commentCount,recCount);
}






// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processStandardBomSubFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string mfgSubPartName;
 std::string pdf;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 

 LgFrSceSetOfParameters & setOfParameters =
   this->sceScenario()->setOfParameters();
  
  
 bool globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");
 float groupSharingExecPenaltyThresh = setOfParameters.getFloat("groupSharingExecPenaltyThresh");

 std::string globalSubParentIndString = setOfParameters.getString("globalSubParentIndString");


 int nPeriods = theCal.nPeriods();
 int result, result2;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "BOM Substitute",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM Sub line
    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }

    
    SCETokenizer next(dataLine);

// get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, PURELY_OPTIONAL);
    if (result == -1) {
	badCount++;
	continue;
    }

// get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

// get the mfg Child PartName 
    mfgSubPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				      lineNo, MANDATORY);

// get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float ur = 1.0;
    int   fallout = 0;
    int   early = 0;
    int   late = nPeriods-1;
    float defaultSubPenalty =
           this->sceScenario()->setOfParameters().getFloat("defaultSubPenalty");
    int isObjectInEffectForOptExplosion = 0;
    int isSubstituteBuildable = 0;
    int isNetAllowed = 1;
    float execPenalty = 0.0;
    float propRtg_Share = 1.0;
    
    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);


    // effectivity Dates
    if (result >= 0)
	result2 = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    // if  dates messed up, then skip this record
    if (result2 == 1)
	continue;
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int)lineNo 
		     << dataLine 
		     << "Substitute BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result2 == 0)
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);

    // sub penalty cost
    if (result == 0)
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // isObjectInEffectForOptExplosion flag
    if (result == 0)
	result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);    

    // isSubstituteBuildable flag
    if (result == 0)
	result = flatFileManager.nextInt(isSubstituteBuildable, next, fileName, dataLine, lineNo, false, 0, 1);    

    // isNetAllowed flag
    if (result == 0)
	result = flatFileManager.nextInt(isNetAllowed, next, fileName, 
					 dataLine, lineNo, false, 0, 1);    

    // execPenalty
    if (result == 0)
	result = flatFileManager.nextFloat(execPenalty, next, fileName, 
					 dataLine, lineNo, false, -FLT_MAX);    

    // proportional routing share
    if (result == 0)
	result = flatFileManager.nextFloat(propRtg_Share, next, fileName, dataLine, lineNo, false, 0);


    

    bool isParentAnOperation = false;

    if (mfgParentPartName == globalSubParentIndString) {
      result = sceAddAlternatePartStructure( theWitRun, mpHelper, nPeriods,
					     mfgChildPartName, 
					     pdf, 
					     mfgSubPartName,
					     pdf,
					     ur,
					     early, 
					     late,
					     fallout,
					     defaultSubPenalty,
					     isObjectInEffectForOptExplosion,
					     isSubstituteBuildable,
					     // globalSubNetAllowed,
					     isNetAllowed,
					     // groupSharingExecPenaltyThresh,
					     execPenalty,
					     fileName,
					     dataLine,
					     lineNo);
    }
    else {
      result = sceAddSubstitute( theWitRun, mpHelper,
				 isParentAnOperation,
				 mfgParentPartName, 
				 pdf, 
				 mfgChildPartName, 
				 pdf, 
				 mfgSubPartName,
				 pdf,
				 ur,
				 early, 
				 late,
				 fallout,
				 defaultSubPenalty,
				 isObjectInEffectForOptExplosion,
				 isSubstituteBuildable,
				 // globalSubNetAllowed,
				 isNetAllowed,
				 // groupSharingExecPenaltyThresh,
				 execPenalty,
				 0.0,
				 propRtg_Share,
				 fileName,
				 dataLine,
				 lineNo);
    }
    
    if (! result)
      {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }

    else
	badCount++;


 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}





// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processSupplyFile(
					    WitRun * const theWitRun,   
					    const LgFrCalendar & theCal,
					    const int nPeriods,         
					    const std::string & fileName,
					    LgFrMultiPlantHelper & mpHelper)
{
  
 int nElementsChanged;
 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::ifstream inFile;
 float * supplyVol;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();


 std::ofstream outFile;

 // DATED_DEMANDS
 bool useDatedDemands = setOfParameters.getBool("useDatedDemands");
 float          theDatedSupplyVol = 0.0f;
 int            supplyPeriod = 0;
 std::string    supplyDate;


 bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
 if (! aggregateSupplyInScrub)
   this->openInputFileAndScrubOutputFile(fileName,
				       "Supply",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 else {
   inFile.open(fileName.c_str());
   
   if (! inFile)  {
     (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		    << "Supply" 
		    << fileName 
		    << "");
   }
 }

 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];


 while(inFile.peek() != EOF) {
   int result = 0;

   std::getline( inFile, dataLine );
   lineNo ++;
   dataLine = sce::strip( dataLine );

   //  skip blanks or comments *
   if ((dataLine[0] == '*') || dataLine.empty()) {
     commentCount++;
     continue;
   }
   
   SCETokenizer next(dataLine);

   // check if the line contains any illegal characters
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
   }

 
   // get the partname
   mfgPart =  flatFileManager.nextQuotedString(next, result, fileName, 
					       dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
   if (result < 0)
     continue;
   
   
   // get the pdf
   pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					  lineNo, MANDATORY);
   
   fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);
   
   // test to see that its a valid partName
   if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL))  {
     (*theErrFacil)("UnrecognizedPartWarning",MclArgList() << fullWitPart << fileName << (int)lineNo << dataLine);
     continue;
   }


   // DATED_DEMANDS
   if (useDatedDemands) {
     bool dieIfErrorFlag = true;
     int result = flatFileManager.readDatedDemandFloatRecord( theDatedSupplyVol, supplyDate, 
							      dieIfErrorFlag, 0.0, FLT_MAX,
							      next, fileName, dataLine, lineNo, 
							      mpHelper, theCal);
     // Map supplyDate to supplyPeriod
     // rule: reject if supplyPeriod < 0
     // rule: reject if supplyPeriod >= nPeriods;
     
     // see what period it falls in
     // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
     // NOTE: you can also use roundedPeriod() 
     supplyPeriod = theCal.period(supplyDate);  

     nElementsChanged = result;
   }
   
   // VECTORED_DEMANDS 
   else {
     int t=0;
     for (t = 0; t<nPeriods; t++) {
       int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					      -FLT_MAX, FLT_MAX);
       if (result == -1) 
	 break;
     }
     
     nElementsChanged = t;
   }
   


   if (nElementsChanged == 0 || nElementsChanged == -1) {
     badCount++;
     continue;
   }
   
   
   witGetPartSupplyVol(theWitRun, fullWitPart.c_str(), &supplyVol);
   
   // DATED IO
   if (useDatedDemands) {


    // Map supplyDate to supplyPeriod
    // rule: accept if supplyPeriod < 0, supplyVol[0] += theDatedSupplyVol;
    // rule: ignore if supplyPeriod >= nPeriods;









     if (supplyPeriod < 0) 
       supplyPeriod = 0;
     if (supplyPeriod < nPeriods) 
       supplyVol[supplyPeriod] += theDatedSupplyVol;
   }
   // VECTORED IO
   else {
     int t = 0; 
     for (t=0; t<nElementsChanged; t++) {
       supplyVol[t] += floatVec[t];
     }
   }
   
   
   

   witSetPartSupplyVol(theWitRun, fullWitPart.c_str(), supplyVol);
   witFree(supplyVol);
   //    std::cout << "Updated supply Volume for " << pdf_PartName << "\n";
     
   recCount++;
   
   if (! aggregateSupplyInScrub) {
     if (myScrubber -> scrubMode() && outFile.good())  {
       outFile << dataLine << std::endl;
     }
   }
  
 }
 
 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();


 if (! aggregateSupplyInScrub) {
   outFile.close();
 }

 
 // if no data in input file, then error
 if (recCount == 0)
   (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() << "supply file");

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}





// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processSupplyFile61(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{


 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   

 long lineNo = 0;
 std::string dataLine;

 std::ifstream inFile;
 std::ofstream outFile;
 bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
 if (! aggregateSupplyInScrub) {
   this->openInputFileAndScrubOutputFile(fileName, "Dated Supply", inFile, outFile, myScrubber, theErrFacil);
 }
 else {
   inFile.open(fileName.c_str());
   if (! inFile)  {
     (*theErrFacil)("SevereCannotOpenFile",MclArgList() << "Dated Supply" << fileName << "");
   }
 }

 std::string pdf_PartName;
 int supplyPeriod;
 float * supplyVol;
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float supplyVal;

 while(inFile.peek() != EOF) {
    std::string pdf;
    std::string mfgPartName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;

    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty()){
	commentCount++;
	continue;
    }
    SCETokenizer next(dataLine);

    // check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

    
    // get mfgPartName, pdf
    mfgPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
    
    if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) {
      badCount++;
      continue;
    }
    // FINISH_ME_61: Clean this up using real messages !!
    
    // get supplyVal
    result = flatFileManager.nextFloat(supplyVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);

    if (result < 0) {
      std::cerr << "\nbad supply float\n"  << lineNo << ":" << dataLine << std::endl;
      std::cerr << "ignoring the record\n" << std::endl;

      badCount++;
      continue;
    }
      
    // Now read the date
    std::string token;

    //  if the line is blank then FUTURE is assumed.
    if ((token = next(" \",\n")).empty()) {
      std::cerr << "\nDate is missing from dated supply record\n"  << lineNo << ":" << dataLine << std::endl;
      std::cerr << "putting it in week 1\n" << std::endl;
      badCount++;
      continue;
    }
      
    LgFrDatetime supplyDate(flatFileManager.parseDateString(token, theCal));
    if (! supplyDate.isValid())  {
      (*theErrFacil)("InvalidDate",MclArgList() 
			 << "supply date" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      badCount++;
      continue;
    }
    
    // come here now  


    // Map supplyDate to supplyPeriod
    // rule: reject if supplyPeriod < 0
    // rule: reject if supplyPeriod >= nPeriods;
    supplyPeriod = theCal.period(supplyDate);
    if (supplyPeriod >= nPeriods)  {
      (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
      badCount++;
      continue;
    }
    if (supplyPeriod < 0)  {
      (*theErrFacil)("DatedRecordBeforeHorizonStartAccept",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
      badCount++;
      continue;
    }

    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
    supplyVol[supplyPeriod] += supplyVal;
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);

    witFree(supplyVol);

    recCount++;

    if (! aggregateSupplyInScrub) {
      if (myScrubber -> scrubMode() && outFile.good())  {
	outFile << dataLine << std::endl;
      }
    }
          
 }

 std::cout << recCount << " records processed." << std::endl;
 inFile.close();

 if (! aggregateSupplyInScrub) {
   outFile.close();
 }
 

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processCapacitySupplyFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nElementsChanged;
  std::string pdf_PartName;
  float * supplyVol;
  long lineNo = 0;
  std::string dataLine;

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"Capacity Supply",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

 while(inFile.peek() != EOF) {
    nElementsChanged = flatFileManager.readCsvPartFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_PartName,     // legal pdf_PartName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                        // or OPTIONAL_WITH_MESSAGE
	0.0,              // data lower limits
	FLT_MAX);         // data upper limits


    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
       supplyVol[t] = floatVec[t];
       }
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
    witFree(supplyVol);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
  }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processCapacitySupplyFile61(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   

  bool useDailyCapAvailMethod = setOfParameters.getBool("useDailyCapAvailMethod");
  
  int nElementsChanged;
  std::string pdf_PartName;
  float * supplyVol;
  
  float capAvailQty;
  long lineNo = 0;
  std::string dataLine;
  int result;
  
  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName, "Capacity Supply", inFile, outFile, myScrubber, theErrFacil);
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  char dataDelim[] = " \",\n"; 
  
  float * floatVec = new float[nPeriods];
  
  while(inFile.peek() != EOF) {
    if (useDailyCapAvailMethod)    {    
      //   --- dailyRate  ----
      //      for (t=early, t<=Period, tt++ )
      //          numDays[t] = number of calendar working days for this period, (note, be smart about the interval start and end dates
      //                       that don't start exactly on period start date!!!
      //          supplyVol[t] += capAvailQty * (numDays[t]/workingDays[t])
      //      We use += so that if a DGR chnages mid-period, we do the math right  
      
      std::getline( inFile, dataLine );
      lineNo++;
      dataLine = sce::strip( dataLine );
      if ((dataLine[0] == '*') || dataLine.empty())
	{ commentCount++; continue; }
      
      
      SCETokenizer next(dataLine);
      if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	(*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
	badCount++; continue;
      }
      
      // get the partname, pdf, and pdf_partname
      std::string mfgPartName  = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
      std::string pdf          = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
      std::string pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
      if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	{badCount++; continue; }     
      
      // get capAvailQty
      result = flatFileManager.nextFloat(capAvailQty, next, fileName, dataLine, lineNo, true, 0.0);
      if (result == -1)
	{badCount++; continue; }     
      
      std::string token; 
      if ((token = next(dataDelim)).empty())   {
	(*theErrFacil)("InvalidDate",MclArgList() << "start date" 
		       << fileName << (int) lineNo << dataLine);
	badCount++; continue; 
      }     
      
      
      LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
      if (! startDate.isValid())  {
	(*theErrFacil)("InvalidDate",MclArgList() << "start date" 
		       << fileName << (int) lineNo << dataLine);
	badCount++; continue; 
      }     
      //      int startPeriod = theCal.earlyEffectivePeriod(startDate);
      
      if ((token = next(dataDelim)).empty())   {
	(*theErrFacil)("InvalidDate",MclArgList() << "late effectivity date" << fileName 
		       << (int) lineNo << dataLine);
	badCount++; continue; 
      }     
      
      LgFrDatetime endDate(flatFileManager.parseDateString(token, theCal));
      if (! endDate.isValid())  {
	(*theErrFacil)("InvalidDate",MclArgList() << "late effectivity date" << fileName 
		       << (int) lineNo << dataLine);
	badCount++; continue; 
      }
      //      int endPeriod = theCal.lateEffectivePeriod(endDate);
      
      /*
      if (startDate > endDate) {
	(*theErrFacil)("BadDate",MclArgList() << fileName << (int) lineNo << dataLine);
	badCount++; continue; 
      }
      
      if (startPeriod > endPeriod) {
	(*theErrFacil)("CollapsedEffectiveInterval",MclArgList() << fileName << (int) lineNo << dataLine);
	badCount++; continue; 
      }
      */

      
      witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);      
      int t;
      //      for (t=startPeriod; t<=endPeriod; t++) {
      for (t=0; t<nPeriods; t++) {
	float numWorkingDaysInPeriodOverInterval = theCal.numWorkingDaysInPeriodOverInterval(t, startDate, endDate);
	supplyVol[t] += capAvailQty * numWorkingDaysInPeriodOverInterval;
      }
      witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
      witFree(supplyVol);
      recCount++;

      if (myScrubber -> scrubMode() && outFile.good()) {
	outFile << dataLine << std::endl;
      }
      
    }
    
    else {
      //   --- periodRate ----
      //        this is meant to be "compatible" to SCE5.   
      //        The capAvailQty is assumed to be the supplyVol for the period, 
      //          for t: earlyPeriod <= t <= latePeriod,  supplyVol[t] = capAvailQty
      int startPeriod, endPeriod;
      int result = flatFileManager.readCsvPartFloatDatedRecord(theWitRun, nPeriods, pdf_PartName, theCal, capAvailQty, 
							       startPeriod, endPeriod, inFile, fileName, dataLine, lineNo,mpHelper);
      if (result == 1) { badCount++; continue; }
      if (result == -2) { commentCount++; continue; }
      nElementsChanged = 1;
      
      witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
      
      int t = 0; 
      for (t=startPeriod; t<endPeriod; t++) {
	supplyVol[t] = capAvailQty;
      }
      witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
      witFree(supplyVol);
      recCount++;
      
      if (myScrubber -> scrubMode() && outFile.good())	{
	outFile << dataLine << std::endl;
      }
    }
    
  }    
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close();
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

  
// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processPartsConditionFile(
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;

  std::ifstream inFile;

  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int result;
  int unConstrainedStartPeriod;


  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
#ifdef FORCE_BOGONS
 bool forcePcfBogons = setOfParameters.getBool("forcePcfBogons");
#endif


  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		   << "Parts Condition" 
		   << fileName 
		   << "");
  }

  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;

  long lineNo = 0;
  while(inFile.peek() != EOF) {

    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the partname
    mfgPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
    if (result == -1) {
      badCount++;
      continue;
    }
    // get the pdf
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

    // get the constrainedHorizon End date.  (if line is blank then FUTURE is assumed.)
    std::string token;
    if ((token = next(" \",\n")).empty()) {
      unConstrainedStartPeriod = nPeriods;
    }
    else {
      LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
      if (! startDate.isValid())  {
	(*theErrFacil)("InvalidDataWarning",MclArgList() 
		       << "constraint Horizon End Date specified.\n" 
		       << fileName 
		       << (int)lineNo 
		       << dataLine 
		       << "The date: FUTURE will be assumed.");
        unConstrainedStartPeriod = nPeriods; 
      }
      unConstrainedStartPeriod = theCal.earlyEffectivePeriod(startDate);
    }

    // test to see if the part exists.
    if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, 
                               dataLine, lineNo, PURELY_OPTIONAL))   {
      (*theErrFacil)("InvalidPCFPart",MclArgList() 
		     << mfgPartName 
		     << pdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      badCount++;
      continue;
    }
          

    // OK, we have a valid part anyway.
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);

    // check to see if part is already marked as a PCF part
    if ( mpHelper.isPartPcf(theWitRun, pdf_PartName)) {
      (*theErrFacil)("DuplicatePCFPart",MclArgList() 
		     << mfgPartName 
		     << pdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      badCount++;
      continue;
    }


    // Now check to see if this part can be a PCF part:
    // Conditions:
    // Case 1: default operation has children ==>
    //      Reject the record with Warning.  Do not mark the part as PCF.
    // Case 2)  default operation has no children
    //     a) if no other operations ==> accept
    //     b) if other (non-default) operation exists ==> give warning and reject.

    // assume its OK until proven otherwise ...
    bool didWeRejectTheRecord = false;


    // First find the default operation:
    witBoolean exists;
    witGetOperationExists(theWitRun, pdf_PartName.c_str(), &exists);
    assert(exists == WitTRUE);
    int nBom;
    witGetOperationNBomEntries(theWitRun, pdf_PartName.c_str(), &nBom);
    // if the default operation has  children, then we  reject it
    if (nBom > 0) {
#ifdef FORCE_BOGONS
      if (! forcePcfBogons) {
#endif
	(*theErrFacil)("ExtraPCFPart",MclArgList() 
		       << "it has BOM child components" 
		       << mfgPartName 
		       << pdf 
		       << fileName 
		       << (int)lineNo 
		       << dataLine);
	didWeRejectTheRecord = true;
	// skip to next part. No need to keep checking
	badCount++;
#ifdef FORCE_BOGONS
      }
      else {
	(*theErrFacil)("ExtraPCFPartBogon",MclArgList() 
		       << "it has BOM child components" 
		       << mfgPartName 
		       << pdf 
		       << fileName 
		       << (int)lineNo 
		       << dataLine);


      }
#endif

#ifdef MARK_BOGONS
      // mark the part as a bogon
      LgFrScePartAppData * appDataPtr;
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
	appDataPtr->isPartBogon(1);
	appDataPtr->unConstrainedStartPeriod(unConstrainedStartPeriod);
      }
      else {
	appDataPtr = new LgFrScePartAppData(0, unConstrainedStartPeriod, nPeriods);
	appDataPtr->isPartBogon(1);
      }
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
#endif

#ifndef FORCE_BOGONS
      continue;
#endif
    }

    // FINISH_ME: for forcing_bogons we need to set yieldRate to zero on 
    //            ALL operations which generate a bogon.   I think it's ok as it 
    //            now for ATS calculation

    // At this time, the following is true:
    //    - The default operation has no BOM entries.
    //
    // What remains is to check for non-default operations.  If we find
    // any, then we report a message.  No change to the structure is
    // necessary.
        
    int npBop;
    witGetPartNProducingBopEntries(theWitRun, pdf_PartName.c_str(), &npBop);
    int p = 0; // Pulled out of the for below by RW2STL
    for (p=0; p<npBop; p++) {
      char * opName;
      int o;
      witGetPartProducingBopEntry(theWitRun, pdf_PartName.c_str(), p, &opName, &o);
          
      // If the operation is not the default ...
      if (pdf_PartName.compare(opName)) {

	// first check to see if the producing operation is an Alternate Operation.
	// this case does not override pcf-ness
	std::string primePart;
	std::string primePdf;
	std::string altPart;
	std::string altPdf;
	// and, if the operation is NOT an alternate ...
	if (! mpHelper.isOperationSpecialAlternate(theWitRun, opName,  primePart, primePdf, altPart, altPdf)) {
	  (*theErrFacil)("ExtraPCFPart",MclArgList() 
			 << "it has a producing operation" 
			 << mfgPartName 
			 << pdf 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
	  didWeRejectTheRecord = true;
	  witFree(opName);
	  // exit out of the loop, again, becuase you don't want to generate
	  // multiple error messages per record
	  break;
	}
      }
      witFree(opName);
    }


        
    // skip to next part if you rejected
    if (didWeRejectTheRecord) {
#ifdef MARK_BOGONS
      // mark the part as a bogon
      LgFrScePartAppData * appDataPtr;
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
	appDataPtr->isPartBogon(1);
	appDataPtr->unConstrainedStartPeriod(unConstrainedStartPeriod);
      }
      else {
	appDataPtr = new LgFrScePartAppData(0, unConstrainedStartPeriod, nPeriods);
	appDataPtr->isPartBogon(1);
      }
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
#endif
      badCount++;
      continue;
    }

    // OK at this point we have a PCF record to process.
    // set the yield to 0.0 within the constrained horizon
    // AND mark it via appData
    if (! didWeRejectTheRecord) {

      // first shut down the operation via zero yield
      float * yieldRate;
      witGetOperationYieldRate(theWitRun, pdf_PartName.c_str(), &yieldRate);              
      int t = 0; 
      for (t=0; t<unConstrainedStartPeriod; t++)
        yieldRate[t] = 0;
      witSetOperationYieldRate(theWitRun, pdf_PartName.c_str(), yieldRate);
      witFree(yieldRate);
      
      // set isPartPcf = 1
      LgFrScePartAppData * appDataPtr;
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
	appDataPtr->isPartPcf(1);
	appDataPtr->unConstrainedStartPeriod(unConstrainedStartPeriod);
      }
      else {
	appDataPtr = new LgFrScePartAppData(1, unConstrainedStartPeriod, nPeriods);
      }
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
      recCount++;
     }
  }
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();

  // if there is no data in input file, then error
  if (recCount == 0)
    (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() 
		   << "parts condition file");

  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::scrubPartsConditionFile(
    
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;

  std::ifstream inFile;

  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int result;
  int unConstrainedStartPeriod;



  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		   << "Parts Condition" 
		   << fileName 
		   << "");
  }

  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  if (myScrubber -> scrubMode())       {
      if (sce::find(fileName, "/") != std::string::npos) {
      (*theErrFacil)("QualifiedInputFileName",MclArgList() 
		     << fileName);
    }
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
    if (!outFile.good()) {
      (*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
		     << file);
    }
  }

  
  long lineNo = 0;
  while(inFile.peek() != EOF) {

    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      continue;
    }

    SCETokenizer next(dataLine);

    // get the partname
    mfgPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
    if (result == -1) {
      continue;
    }

    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

    // pick up the constrainedHorizon End date (even though we're not really going
    // to do much with it.
    std::string token;

    //  if the line is blank then FUTURE is assumed.
    if ((token = next(" \",\n")).empty()) {
      unConstrainedStartPeriod = nPeriods;
    }
    else {
      LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
      if (! startDate.isValid())  {
        unConstrainedStartPeriod = nPeriods; 
      }
      unConstrainedStartPeriod = theCal.earlyEffectivePeriod(startDate);
    }

    // test to see if the part exists.
    if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, 
                               dataLine, lineNo, PURELY_OPTIONAL))   {
      continue;
    }
          

    // OK, we have a valid part anyway.
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);

    
    // check to see if part is marked as a PCF part
    if ( mpHelper.isPartPcf(theWitRun, pdf_PartName)) {
      if (outFile.good())  	{
	  outFile << dataLine << std::endl;
	}
    }

  }
  inFile.close();
  outFile.close();

}




// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::printImpactPeriodFile(
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  int nOps;
  char ** opList;

  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();


  std::ofstream outFile(fileName.c_str());
  if (outFile.fail()) {
    (*theErrFacil)("CannotOpenFileForWrite",MclArgList() 
		   << "ImpactPeriod" 
		   << fileName);
  }


  witGetOperations(theWitRun, &nOps, &opList);
  int nBom;
  int op = 0; 
  for (op=0; op<nOps; op++ ) {
    std::string parentPdf, parentOpName, childPartName, childPdf;
    int isItNormalOperation = 0;
    if (mpHelper.isOperationNormal(theWitRun, opList[op], parentPdf, parentOpName)) 
      isItNormalOperation = 1;
    else if (! mpHelper.isOperationSpecialInterplant(
                       theWitRun, opList[op],
                       parentOpName, parentPdf, childPartName, childPdf)) {
      witFree(opList[op]);
      continue;
    }
	
    witGetOperationNBomEntries(theWitRun, opList[op], &nBom);
    int b=0;
    for (b=0; b<nBom; b++) {
      if (isItNormalOperation) {
	char * child;
	witGetBomEntryConsumedPart(theWitRun, opList[op], b, &child);
	childPartName = mpHelper.partname(child);
	childPdf = parentPdf;
	witFree(child);
      }
      
      outFile << "\"" 
	      << parentOpName << "\",\""
	      << parentPdf << "\",\""
	      << childPartName << "\",\""
	      << childPdf << "\",";

      if (isItNormalOperation) 
	outFile << "\"F\"";
      else 
	outFile << "\"A\"";

      int * impactPeriod;
      witGetBomEntryImpactPeriod(theWitRun, opList[op], b, &impactPeriod);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	outFile << "," << impactPeriod[t];
      }
      outFile << "\n";
      witFree(impactPeriod);
    }
      
    witFree(opList[op]);
  }

  witFree(opList);

  outFile.close();
}


// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::scrubSupplyAvailabilityFile(
    
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;


  int nParts;
  char ** partList;

  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();


  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  if (myScrubber -> scrubMode())       {
    if (sce::find(fileName, "/") != std::string::npos) {
      (*theErrFacil)("QualifiedInputFileName",MclArgList() 
		     << fileName);
    }

    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
    if (!outFile.good()) {
      (*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
		     << file);
    }
  }

  witGetParts(theWitRun, &nParts, &partList);

  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    float * supplyVol;
    if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
       witGetPartSupplyVol(theWitRun, partList[i], &supplyVol);
#if 1
       if (mpHelper.doesPartHaveNegativeDemands(theWitRun, partList[i])) {
	 LgFrTimeVecFloat negDemVol = mpHelper.negDemVol(theWitRun, partList[i]);
	 int tt=0;
	 for (tt=0; tt<nPeriods; tt++) 
	   supplyVol[tt] -= negDemVol[tt];
       }
#endif
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
       outFile << "\"" 
               << partname << "\",\"" 
               << pdf << "\"";
       flatFileManager.writeCsvFloatVector(outFile, nPeriods, supplyVol, 0, 15);
       witFree(supplyVol);
       }
    witFree(partList[i]);
   }

  witFree(partList);

  // Now undo any negative demand vol that was added to supply.dat

  outFile.close();

}






// ---------------------------------------------------------------

void 
LgFrInitialProblemForSce::scrubDemandVolumeFile(
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;

  std::string demandName;
  std::ifstream inFile;
  float * demandVol;
  long lineNo = 0;
  std::string dataLine;
  int i, j;
  int result; 

  int nParts;
  char ** partList;
  int nDemands;
  char ** dList;

  LgFrSceDemandAppData * demandAppDataPtr;

  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  witGetParts(theWitRun, &nParts, &partList);

  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  if (myScrubber -> scrubMode())       {
    if (sce::find(fileName, "/") != std::string::npos) {
      (*theErrFacil)("QualifiedInputFileName",MclArgList() 
		     << fileName);
    }
    
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
    if (!outFile.good()) {
      (*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
		     << file);
    }
  }
  
  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		   << "demandVolume (while scrubbing) " 
		   << fileName 
		   << "");
  }
  
  
  
  // ------------
  // Before you do anything, reset all the hasDemandVolBeenSet
  // appData elements to zero
  // Loop once for each part.  
  for (i=0; i<nParts; i++ ) {
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						   plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j=0; j<nDemands; j++)  {
	// get the  demand app data for this demand.  get the hasDemandVolBeenSet
	witGetDemandAppData(theWitRun,
			    partList[i], 
			    dList[j],
			    (void **) &demandAppDataPtr);
	assert(demandAppDataPtr != 0);
	demandAppDataPtr->hasDemandVolBeenSet(0);
        witFree(dList[j]);
      }
      witFree(dList);
    }
  }    


  float * floatVec = new float[nPeriods];
 
  // Now read through the unscrubbed input file and use it to 
  // maintain the sequential order of the scrubbed file.
  while(inFile.peek() != EOF) {
   std::getline( inFile, dataLine );
   lineNo ++;
   dataLine = sce::strip( dataLine );
   if ((dataLine[0] == '*') || dataLine.empty())
     continue;
   SCETokenizer next(dataLine);
   plannerPart = flatFileManager.nextQuotedString(next, result, fileName, 
						  dataLine, lineNo, 
						  PURELY_OPTIONAL);
   if (result == -1) 
     continue;
   
   geo = flatFileManager.nextQuotedString(next, result, fileName, 
					  dataLine, lineNo, 
					  PURELY_OPTIONAL);
   if (result == -1)     
     continue;
   
   geoPlannerDemandPartName = mpHelper.geoPlannerDemandPartName(plannerPart, geo);

   // Check to see if the GPD is valid
   if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
			      dataLine, lineNo, PURELY_OPTIONAL))  
    continue;
  
  if (! doesDemandExist(theWitRun, geoPlannerDemandPartName, geo)) 
    continue;

  // if you get here, then its a valid demandVol rec.
  // now check to see if one has already been added

  // get the  demand app data for this demand.  get the hasDemandVolBeenSet
  witGetDemandAppData(theWitRun,
		      geoPlannerDemandPartName.c_str(),
		      geo.c_str(),
		      (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
  int hasDemandVolBeenSet = demandAppDataPtr->hasDemandVolBeenSet();

  // if demandVol was already set, then for scrubbing purposes, 
  // the demandVol record has already been printed
  if (hasDemandVolBeenSet) 
    continue;

  // otherwise, this is the first occurence of the demandVol key and
  // go and print out the total demandVol and mark it as "hasBeenSet"
  witGetDemandDemandVol(theWitRun, geoPlannerDemandPartName.c_str(), 
			geo.c_str(), &demandVol);
  outFile << "\"" << plannerPart << "\",\"" << geo << "\"";
  flatFileManager.writeCsvFloatVector(outFile, nPeriods, demandVol, 0, 15);
  witFree(demandVol);


  // set the hasDemandVolBeenSet to true
  demandAppDataPtr->hasDemandVolBeenSet(1);
 }


  for (i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);


 delete [] floatVec;
 inFile.close();
 outFile.close();


}

// ---------------------------------------------------------------

void 
LgFrInitialProblemForSce::scrubMinDemandVolumeFile(
    WitRun * const theWitRun,
    const LgFrCalendar & theCal,    
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;

  std::string demandName;
  std::ifstream inFile;
  float * cshlb;
  float * csslb;
  float * cshub;
  long lineNo = 0;
  std::string dataLine;
  int i, j, t;
  int result; 

  int nParts;
  char ** partList;
  int nDemands;
  char ** dList;

  LgFrSceDemandAppData * demandAppDataPtr;

  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  witGetParts(theWitRun, &nParts, &partList);

  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  if (myScrubber -> scrubMode())       {
      if (sce::find(fileName, "/") != std::string::npos) {
      (*theErrFacil)("QualifiedInputFileName",MclArgList() 
		     << fileName);
    }
    
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
    if (!outFile.good()) {
      (*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
		     << file);
    }
  }
  
  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		   << "minDemandVolume (while scrubbing) " 
		   << fileName 
		   << "");
  }
  
  
  
  // ------------
  // Before you do anything, reset all the hasMinDemandVolBeenSet
  // appData elements to zero
  // Loop once for each part.  
  for (i=0; i<nParts; i++ ) {
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						   plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j=0; j<nDemands; j++)  {
	// get the demand app data for this demand.  
        // get the hasMinDemandVolBeenSet
	witGetDemandAppData(theWitRun,
			    partList[i], 
			    dList[j],
			    (void **) &demandAppDataPtr);
	assert(demandAppDataPtr != 0);
	demandAppDataPtr->hasMinDemandVolBeenSet(0);
        witFree(dList[j]);
      }
      witFree(dList);
    }
  }    


  float * minDemandVol = new float[nPeriods];
 
  // Now read through the unscrubbed input file and use it to 
  // maintain the sequential order of the scrubbed file.
  while(inFile.peek() != EOF) {
   std::getline( inFile, dataLine );
   lineNo ++;
   dataLine = sce::strip( dataLine );
   if ((dataLine[0] == '*') || dataLine.empty())
     continue;
   SCETokenizer next(dataLine);
   plannerPart = flatFileManager.nextQuotedString(next, result, fileName, 
						  dataLine, lineNo, 
						  PURELY_OPTIONAL);
   if (result == -1) 
     continue;
   
   geo = flatFileManager.nextQuotedString(next, result, fileName, 
					  dataLine, lineNo, 
					  PURELY_OPTIONAL);
   if (result == -1)     
     continue;
   
   geoPlannerDemandPartName = mpHelper.geoPlannerDemandPartName(plannerPart, geo);

   // Check to see if the GPD is valid
   if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
			      dataLine, lineNo, PURELY_OPTIONAL))  
    continue;
  
  if (! doesDemandExist(theWitRun, geoPlannerDemandPartName, geo)) 
    continue;

  // if you get here, then its a valid minDemandVol rec.
  // now check to see if one has already been added

  // get the  demand app data for this demand.  get the hasMinDemandVolBeenSet
  witGetDemandAppData(theWitRun,
		      geoPlannerDemandPartName.c_str(),
		      geo.c_str(),
		      (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
  int hasMinDemandVolBeenSet = demandAppDataPtr->hasMinDemandVolBeenSet();

  // if minDemandVol was already set, then for scrubbing purposes, 
  // the minDemandVol record has already been printed
  if (hasMinDemandVolBeenSet) 
    continue;

  // otherwise, this is the first occurence of the minDemandVol key 
  // get the cumulative lower bound, un-cumulate it and
  // go and print out the total minDemandVol and mark it as "hasBeenSet"
  witGetDemandCumShipBounds(theWitRun, 
			      geoPlannerDemandPartName.c_str(),
		          geo.c_str(),
			      &cshlb,
			      &csslb,
			      &cshub);

  // now un-cumulate csslb to get the minDemand
  minDemandVol[0] = csslb[0];
  for(t=1; t<nPeriods; t++)
     minDemandVol[t] = csslb[t] - csslb[t-1];

  witFree(cshlb);
  witFree(csslb);
  witFree(cshub);


  outFile << "\"" << plannerPart << "\",\"" << geo << "\"";
  flatFileManager.writeCsvFloatVector(outFile, nPeriods, minDemandVol, 0, 15);



  // set the hasDemandVolBeenSet to true
  demandAppDataPtr->hasMinDemandVolBeenSet(1);
 }


  for (i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);


 delete [] minDemandVol;
 inFile.close();
 outFile.close();


}

//-----------------------------------------------------------

void 
LgFrInitialProblemForSce::deleteUnnecessaryDemandAppData(
    WitRun * const theWitRun,
    const int nPeriods,         
    LgFrMultiPlantHelper & mpHelper)
{
  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;

  int i, j;

  int nParts;
  char ** partList;
  int nDemands;
  char ** dList;

  LgFrSceDemandAppData * demandAppDataPtr;

  witGetParts(theWitRun, &nParts, &partList);

  // ------------
  // so we don't bog down the rollover engine ...
  // delete any dmeand appData's that have backlogYield==1.0
  for (i=0; i<nParts; i++ ) {
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						   plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j=0; j<nDemands; j++)  {
	// get the  demand app data for this demand.  
	witGetDemandAppData(theWitRun, partList[i], dList[j], (void **) &demandAppDataPtr);
	assert(demandAppDataPtr != 0);
	LgFrTimeVecFloat backlogYield = demandAppDataPtr->backlogYield();
	if (backlogYield.min() > 0.9999) {
	  delete demandAppDataPtr;
	  witSetDemandAppData(theWitRun, partList[i], dList[j], (void *) 0);
	}
        witFree(dList[j]);
      }
      witFree(dList);
    }
  }    

  for (i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);
}


//-----------------------------------------------------------

void 
LgFrInitialProblemForSce::shutOffAllLotSizing(
    WitRun * const theWitRun,
    const int nPeriods)
{

  int o;

  LgFrTimeVecFloat zeroVec(nPeriods, 0.0);
  char ** opList;
  int nOperations;

  witGetOperations(theWitRun, &nOperations, &opList);

  for (o=0; o<nOperations; o++ ) {
    witSetOperationMinLotSize(theWitRun, opList[o], zeroVec.data());
    witSetOperationIncLotSize(theWitRun, opList[o], zeroVec.data());
    witFree(opList[o]);
  }
  witFree(opList);
}

// ---------------------------------------------------------------
int 
LgFrInitialProblemForSce::scePreProcessDefaultOperations(
    WitRun * const theWitRun,
    const int nPeriods)
{

  // to allow for error messaging
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // This routine looks through all the parts in the WIT model
  // and for any part with (1) multiple bop entries and 
  // (2) a childless default operation, it
  // "turns off" the effectivity of the default operation. 
  //
  // Why are we bothering to do this?
  // --------------------------------
  // If a part is not in the pcf file, than the default
  // operation essentially produces it from "thin air" (subject
  // to cycle time considerations--FINISH_ME).
  // If the user has specified another means of

  // producing the part (interplant, aggregation(?), co-product
  // gerenation, user-defined op...), than that production method(s)
  // should constrain the part's production...and it won't
  // unless we turn-off the default operation.
  //
  // Can't we just not add the un-needed default operations,
  // in the first place?
  // -----------------------------------------------------------
  // The optExploder needs to have the default operations around
  // (at least in the current implementation). In the case where
  // the optExplodableFlags are set to false on all the non-default
  // operations, the optExploder needs to have the default
  // operation around to be able to build as much of the part as is
  // needed.

  char ** partList;
  int nParts;
  witBoolean defOpExists;

  witGetParts ( theWitRun, &nParts, &partList );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    int  npBops;  // number of bops producing the i-th part
    witGetPartNProducingBopEntries ( theWitRun, partList[i], & npBops );

    if ( npBops <= 1 )  // we only care about the case with multiple bops
      continue;
    
    std::string defaultOperationName (partList[i]);
    witGetOperationExists(theWitRun, defaultOperationName.c_str(), &defOpExists);
    

    //  Capacity parts (and perhaps)
    // some dummy parts (in the future) may have more than one bop and no
    // default op.
    if (! defOpExists) {
      continue;
    }
    
    int nBom;
    witGetOperationNBomEntries(theWitRun, defaultOperationName.c_str(), &nBom);
    // if the default operation is childless, shut off the default bop's effectivity
    if (nBom == 0) {
      // find bopEntryIndex for default operation
      bool didWefindBopEntryForDefaultOperation = false;
      
      int p = 0; // Pulled out of the for below by RW2STL
      for (p=0; p<npBops; p++) { // p = prodIndex
        char * opName;
        int bopEntryIndex;
        witGetPartProducingBopEntry(theWitRun, partList[i], p, &opName, &bopEntryIndex);

        if (defaultOperationName == opName) {
          // Note: at this time there should only be one
          // bop entry for the default part
          assert(didWefindBopEntryForDefaultOperation == false);
          didWefindBopEntryForDefaultOperation = true;
          witSetBopEntryEarliestPeriod(theWitRun, defaultOperationName.c_str(), bopEntryIndex, nPeriods ); 
        }
        witFree(opName);
      }
      // make sure you found a bop entry for default to shut off
      if ( didWefindBopEntryForDefaultOperation != true ){       
	(*theErrFacil)("InternalError6");
      }
    }
  }

  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  
  return 0;
}



// ----------------------------------------------------------------
// FINISH_ME: Create new implementation for dated demand file using local hash dictionary 
//            Invoking wit get/set for each element might be ghastly.
void 
LgFrInitialProblemForSce::processDemandVolumeFile(
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string pdf_PartName;
 std::string demandName;
 std::ifstream inFile;
 float * demandVol;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 inFile.open(fileName.c_str());
 if (! inFile)  {
   (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		  << "demandVolume" 
		  << fileName 
		  << "");
 }


 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

    while(inFile.peek() != EOF) {
       nElementsChanged = readCsvDemandFloatVector(
	   theWitRun,      // WIT environment    
	   nPeriods,       // Number of periods  
	   pdf_PartName,   // pdf_PartName to be returned
	   demandName,     // demandName to be returned
	   floatVec,       // floatVector to be returned
	   inFile,         // An open input stream
	   fileName,       // for messaging
           dataLine,       // a record of file
	   lineNo,         // current line number, for messaging
	   mpHelper,       // The helper object
	   true,           // Are all elements mandatory?
	   0.0,            // data lower limits
	   FLT_MAX,        // data upper limits
	   true);          // Add demand stream to WIT if not there

       if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetDemandDemandVol(theWitRun, pdf_PartName.c_str(), 
			  demandName.c_str(), &demandVol);

    // get the  demand app data for this demand.  get the hasDemandVolBeenSet
    LgFrSceDemandAppData * demandAppDataPtr;
    witGetDemandAppData(theWitRun,
			pdf_PartName.c_str(), 
			demandName.c_str(),
			(void **) &demandAppDataPtr);
    assert(demandAppDataPtr != 0);
    int hasDemandVolBeenSet = demandAppDataPtr->hasDemandVolBeenSet();
    

    // note: duplicate demandVol records are incremental!!
    // print a warning when detected
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      demandVol[t] += floatVec[t];
    }


    if (hasDemandVolBeenSet) {
      std::string pnm = mpHelper.partname(pdf_PartName);
      std::string pdfff = mpHelper.pdf(pdf_PartName);
      (*theErrFacil)("MultipleDemandVolRecs",MclArgList() 
		     << fileName 
		     << (int) lineNo 
		     << pnm 
		     << pdfff);
    }

    witSetDemandDemandVol(theWitRun, pdf_PartName.c_str(), demandName.c_str(), demandVol);
    // set the hasDemandVolBeenSet to true
    demandAppDataPtr->hasDemandVolBeenSet(1);

    witFree(demandVol);
    recCount++;
 }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();

  // if no data in input file, then error
 if (recCount == 0)
   (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() 
		  << "demand volume file");

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processIndependentDemandFile(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::string demandName;
 std::ifstream inFile;
 long lineNo = 0;
 std::string dataLine;
 int t = 0; 
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   

 int defaultIndependentDemandPriority = setOfParameters.getInt("defaultIndependentDemandPriority");
 LgFrTimeVecFloat tvDefaultPriority(nPeriods, (float) (1000000000 - defaultIndependentDemandPriority));

 /*
 // Priority Manager uses default priority of 0 !!
 std::string priorityRulesFile = setOfParameters.getString("priorityRulesFile");
 if (! priorityRulesFile.empty())  {
   LgFrTimeVecFloat zeroVec(nPeriods, (float) (-1));
   tvDefaultPriority = zeroVec;
 }
 */



 int defaultShipLateLimit = heurModelHelper_->defaultShipLateLimit();

 // DATED_DEMANDS
 bool useDatedDemands = setOfParameters.getBool("useDatedDemands");
 float theDatedDemandVol = 0.0f;
 int thePeriod = 0;
 std::string requestDate;
 
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName, "Independent Demand Volume",
				       inFile, outFile, myScrubber, theErrFacil);

 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
   int result = 0;
 
   // Read next line of file
   std::getline( inFile, dataLine );
   lineNo ++;

   dataLine = sce::strip( dataLine );
   
   //  skip blanks or comments '*'
   if ((dataLine[0] == '*') || dataLine.empty()) {
     commentCount++;
     continue;
   }
   
   // construct a tokenizer
   SCETokenizer next(dataLine);
   
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() 
		    << fileName 
		    << (int)lineNo 
		    << dataLine);
   }
  
   // get the partname
   mfgPart = flatFileManager.nextQuotedString(next, result, fileName, 
					      dataLine, lineNo, 
					      OPTIONAL_WITH_MESSAGE);

   // get the pdf
   pdf = flatFileManager.nextQuotedString(next, result, fileName, 
					  dataLine, lineNo, MANDATORY);

#ifdef MULTI_ATTRIBUTE_DEMAND_CLASS
   demandName = flatFileManager.nextQuotedDemandString(next, result, fileName, 
						       dataLine, lineNo, MANDATORY);




#else 

   // get the demandName
   demandName = flatFileManager.nextQuotedString(next, result, fileName, 
						 dataLine, lineNo, MANDATORY);
#endif

   // Get the witPartname
   fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);



  int readCsvMessage = OPTIONAL_WITH_MESSAGE;

  if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
                              dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }

    

  if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
    // regardless of engine, load the priorities and shipLateLimit
    // get the default priority
    witAddDemand( theWitRun, fullWitPart.c_str(), demandName.c_str() );
    // create a demand app data for this demand.  Set the hasDemandVolBeenSet=0
    // init backlogYield to 1.0
    LgFrSceDemandAppData * demandAppDataPtr = new LgFrSceDemandAppData (0, 0, (size_t) nPeriods, 1.0);  
    demandAppDataPtr->pipPriority(tvDefaultPriority);
    //    std::cout << "Adding indp demand with default pipPiority [" 
    //	      << fullWitPart << "," << demandName << "] =" << (int) tvDefaultPriority[2] << std::endl;
    witSetDemandAppData(theWitRun,
			fullWitPart.c_str(), 
			demandName.c_str(), 
			(void *) demandAppDataPtr);
    
    witSetDemandPriority( theWitRun, fullWitPart.c_str(),
			  demandName.c_str(), tvDefaultPriority.intData() );
    witSetDemandShipLateLimit( theWitRun, fullWitPart.c_str(),
			       demandName.c_str(), defaultShipLateLimit );
    
    
    // but only load the obj1 values if we have too      
    if ( lpModelHelper_ != 0 ) {
      // get the default Obj1 Ship Reward
      float defaultObj1ShipReward = lpModelHelper_->defaultObj1ShipReward();
      
      // get the periodic Interest Rate
      float periodicInterestRate = lpModelHelper_->periodicInterestRate();
      
      float * defaultObj1ShipRewardVec = new float[nPeriods];
      float * defaultObj1CumShipRewardVec = new float[nPeriods];
      
      // make time vecs from scalars
      for (t=0; t<nPeriods; t++) {
	defaultObj1ShipRewardVec[t] = defaultObj1ShipReward;
	defaultObj1CumShipRewardVec[t] = defaultObj1ShipReward * 
	  periodicInterestRate;
      }
      
      witSetDemandObj1ShipReward( theWitRun, fullWitPart.c_str(),
				  demandName.c_str(), defaultObj1ShipRewardVec);
      witSetDemandObj1CumShipReward( theWitRun, fullWitPart.c_str(),
				     demandName.c_str(), defaultObj1CumShipRewardVec);
      delete [] defaultObj1ShipRewardVec;
      delete [] defaultObj1CumShipRewardVec;
    }
  }
  

  // IMPORTANT.   We need to go back and set the witDemandVols after all demandVol records are inputted.
  // Also need to deal with MULTI_ATTRIBUTE_DEMAND


 // DATED_DEMANDS
  if (useDatedDemands) {
    bool dieIfErrorFlag = true;
    int result = flatFileManager.readDatedDemandFloatRecord( theDatedDemandVol, requestDate, 
							     dieIfErrorFlag, -FLT_MAX, FLT_MAX,
							     next, fileName, dataLine, lineNo, 
							     mpHelper, theCal);
    // determine which period  it falls in
    // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
    // NOTE: you can also use roundedPeriod() 
    thePeriod = theCal.period(requestDate);  
    

    nElementsChanged = result;
  }

  // VECTORED_DEMANDS 
  else {
    for (t = 0; t<nPeriods; t++) {
      int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					     -FLT_MAX, FLT_MAX);
      if (result == -1) 
	break;
    }
    
    nElementsChanged = t;
  }



  if (nElementsChanged == 0 || nElementsChanged == -1) {
    badCount++;
    continue;
  }




  // get the  demand app data for this demand.  get the hasDemandVolBeenSet
  LgFrSceDemandAppData * demandAppDataPtr;
  witGetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
  LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();
  int hasDemandVolBeenSet = demandAppDataPtr->hasDemandVolBeenSet();


  // DATED_DEMANDS
  if (useDatedDemands) {
    demandVolTVF[thePeriod] += theDatedDemandVol;
  }

  // VECTORED DEMANDS
  else {
    // note: duplicate demandVol records are incremental!!
    // print a warning when duplicate demandVols are detected (default is that they are incremental)
    for ( t=0; t<nElementsChanged; t++) {
      demandVolTVF[t] += floatVec[t];
    }
    
    if (hasDemandVolBeenSet) {
      (*theErrFacil)("MultipleDemandVolRecs",MclArgList() 
		     << fileName 
		     << (int) lineNo 
		     << fullWitPart
		     << demandName);
    }
  }
    

  // set the hasDemandVolBeenSet to true
  demandAppDataPtr->hasDemandVolBeenSet(1);
  // store away the original demandVol (with negatives)
  demandAppDataPtr->demandVol(demandVolTVF);

  // ENABLE_NEGATIVE_DEMANDS
  // strip off the negatives
  // FINISH_ME: How do we detect if multiple demandVol recs remove negatives?
  // Perhaps we should move the setting of doesPartHaveNegativeDemands to a
  // pre processing step
  for ( t=0; t<nPeriods; t++) {
    if (demandVolTVF[t] < 0.0) {
      demandVolTVF[t] = 0.0;
    }
  }

  witSetDemandDemandVol(theWitRun, fullWitPart.c_str(), demandName.c_str(), demandVolTVF.data());

  recCount++;
  if (myScrubber -> scrubMode() && outFile.good())
    {
      outFile << dataLine << std::endl;
    }

 }

 // delete [] defaultPriorityVec;
 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();


 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}





// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processDemandObjectiveFile(
    
    WitRun * const theWitRun,  
    const int nPeriods,        
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper,
    const float periodicInterestRate)
{

 int nElementsChanged;
 std::string pdf_PartName;
 std::string demandName;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Demand Objective Input",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
    	theWitRun,      // WIT environment    
    	nPeriods,       // Number of periods  
    	pdf_PartName,   // pdf_PartName to be returned
    	demandName,     // demandName to be returned
    	floatVec,       // floatVector to be returned
    	inFile,         // An open input stream
    	fileName,       // for messaging
        dataLine,
    	lineNo,         // current line number, for messaging
    	mpHelper,       // The helper object
    	false,          // Are all elements mandatory?
    	0.0,            // data lower limits
	1000000000,        // data upper limits
	false);         // Do NOT Add new demand stream to WIT

    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;	 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }

    if ( lpModelHelper_ != 0 ) {

      float  * rev;
      witGetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &rev);
      
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nElementsChanged; t++) {
        rev[t] =  floatVec[t];
      }
      
      witSetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
      
      // Now set the CumShipReward as a timeValue of Money percentage = .10
      for ( t=0; t<nPeriods; t++) {
        rev[t] *=  periodicInterestRate;
      }
      witSetDemandObj1CumShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
      
      witFree(rev);
    }


    
    // Now set the priority for the heuristic, regardless of the engine.
    // NOTE: We need to have
    // the priorities be "the higer the value, the higher the priority"
    // in SCE, so to make it work in the heuristic we "flip" them around

    int * priority;
    witGetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &priority);
    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      priority[t] = 1000000000 - (int) floatVec[t];
      floatVec[t] = (float) priority[t];
    }
    
    witSetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), priority);
    

    // if doPegging and optimization, then we might store the 
    // priorities in appData because that is where we will look for them
    bool doPegging = this->sceScenario()->setOfParameters().getBool("doPegging");
    if ( lpModelHelper_ != 0  &&  doPegging)  {
      LgFrSceDemandAppData * demandAppDataPtr;
      witGetDemandAppData(theWitRun,
			  pdf_PartName.c_str(), 
			  demandName.c_str(),
			  (void **) &demandAppDataPtr);
      assert ( demandAppDataPtr != 0);
      
      LgFrTimeVecFloat pipPriority(nPeriods, floatVec);
      demandAppDataPtr->pipPriority(pipPriority);
    }


    witFree(priority);
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }
 

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processPipPriorityFile(
    WitRun * const theWitRun,  
    const int nPeriods,        
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  int nElementsChanged;
  std::string pdf_PartName;
  std::string demandName;
  long lineNo = 0;
  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"PIP Demand Priority Sequencer ",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  
  float * floatVec = new float[nPeriods];
  
  while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	floatVec,       // floatVector to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
	dataLine,
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	false,          // Are all elements mandatory?
	0.0,            // data lower limits
	1000000000,        // data upper limits
	false);         // do NOT Add new demand stream to WIT
    
    if (nElementsChanged == 0 || nElementsChanged == -1) {
      badCount++;	 
      continue;
    }
    else if (nElementsChanged == -2) {
      commentCount++;
      continue;
    }
    
    
    // put it in AppData !!
    LgFrSceDemandAppData * demandAppDataPtr;
    witGetDemandAppData(theWitRun,
			pdf_PartName.c_str(), 
			demandName.c_str(),
			(void **) &demandAppDataPtr);
    
    
    assert ( demandAppDataPtr != 0);

    
    LgFrTimeVecFloat pipPriority( demandAppDataPtr->pipPriority() );
    int t = 0; 
    // std::cout << ".....  Read new pipPriorty[" << demandName << "]=";
    for (t=0; t<nElementsChanged; t++) {
      pipPriority[t] = 1000000000 - (int) floatVec[t];
      //      std::cout << (int) floatVec[t] << "," << pipPriority.intData()[t] << "," << (int) pipPriority[t] << "  ,  ";
    }                                    
    //    std::cout << std::endl;

    demandAppDataPtr->pipPriority(pipPriority);
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
	outFile << dataLine << std::endl;
 }
  
  
  delete [] floatVec;
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close();
  
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processPipIndpPriorityFile(
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  int nElementsChanged;
  std::string mfgPart;
  std::string pdf;
  std::string fullWitPart;
  std::string demandName;
  long lineNo = 0;
  std::string dataLine;
  int t;
 
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   


  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
  this->openInputFileAndScrubOutputFile(fileName, "Pip Indpendent Priority ",
					inFile, outFile, myScrubber, theErrFacil);

 
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;

  float * floatVec = new float[nPeriods];
 
  while(inFile.peek() != EOF) {
    int result = 0;
 
    // Read next line of file
    std::getline( inFile, dataLine );
    lineNo ++;

    dataLine = sce::strip( dataLine );
   
    //  skip blanks or comments '*'
    if ((dataLine[0] == '*') || dataLine.empty()) {
      commentCount++;
      continue;
    }
   
    // construct a tokenizer
    SCETokenizer next(dataLine);
   
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
    }

  
    // get the partname
    mfgPart = flatFileManager.nextQuotedString(next, result, fileName, 
					       dataLine, lineNo, 
					       OPTIONAL_WITH_MESSAGE);

    // get the pdf
    pdf = flatFileManager.nextQuotedString(next, result, fileName, 
					   dataLine, lineNo, MANDATORY);

    // get the demandName
    demandName = flatFileManager.nextQuotedString(next, result, fileName, 
						  dataLine, lineNo, MANDATORY);

    // Get the witPartname
    fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);



    int readCsvMessage = OPTIONAL_WITH_MESSAGE;

    if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
				dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		     << mfgPart << pdf << demandName << fileName << (int)lineNo << dataLine);
      continue;
    }

    

    if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
      (*theErrFacil)("IndDemandDoesNotExist",MclArgList() 
		     << mfgPart << pdf << demandName << fileName << (int)lineNo << dataLine);
      continue;
    }
    
    
    // Now get the data
    for (t = 0; t<nPeriods; t++) {
      int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					     -FLT_MAX, FLT_MAX);
      if (result == -1) 
	break;
    }

    nElementsChanged = t;

    if (nElementsChanged == 0 || nElementsChanged == -1) {
      badCount++;
      continue;
    }

    // put it in AppData !!
    LgFrSceDemandAppData * demandAppDataPtr;
    witGetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void **) &demandAppDataPtr);
    
    assert ( demandAppDataPtr != 0);
    
    // If the demandAppDataPtr has been set, see if the pipPriority has been set.
    if (demandAppDataPtr == 0)  {
      demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);  // init backlogYield to 1.0
      witSetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void *) demandAppDataPtr );
    }
    
    LgFrTimeVecFloat pipPriority( demandAppDataPtr->pipPriority() );
    int t = 0; 
    //    std::cout << ".....  Read new pipIndpPriorty[" << demandName << "]=";
    for (t=0; t<nElementsChanged; t++) {
      //      std::cout << floatVec[t] << ",";
      pipPriority[t] = 1000000000 - (int) floatVec[t];
    }                                    
    //    std::cout << std::endl;

    demandAppDataPtr->pipPriority(pipPriority);
    // ++++++++++++++++++++++++
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      outFile << dataLine << std::endl;
     
  }
 
  delete [] floatVec;
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
 

  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}





// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processIndepDemandObjectiveFile(
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper,
    const float periodicInterestRate)
{

 int nElementsChanged;
 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::string demandName;
 long lineNo = 0;
 std::string dataLine;
 int t;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   


 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Indpendent Demand Objective Input",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);





 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
   int result = 0;
 
   // Read next line of file
   std::getline( inFile, dataLine );
   lineNo ++;

   dataLine = sce::strip( dataLine );
   
   //  skip blanks or comments '*'
   if ((dataLine[0] == '*') || dataLine.empty()) {
    commentCount++;
    continue;
   }
   
   // construct a tokenizer
   SCETokenizer next(dataLine);
   
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() 
		    << fileName 
		    << (int)lineNo 
		    << dataLine);
   }

  
   // get the partname
   mfgPart = flatFileManager.nextQuotedString(next, result, fileName, 
					      dataLine, lineNo, 
					      OPTIONAL_WITH_MESSAGE);

   // get the pdf
   pdf = flatFileManager.nextQuotedString(next, result, fileName, 
					  dataLine, lineNo, MANDATORY);

   // get the demandName
   demandName = flatFileManager.nextQuotedString(next, result, fileName, 
						 dataLine, lineNo, MANDATORY);

   // Get the witPartname
   fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);



  int readCsvMessage = OPTIONAL_WITH_MESSAGE;

  if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
                              dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }

    

  if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
    (*theErrFacil)("IndDemandDoesNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }

    
    
  // Now get the data
  for (t = 0; t<nPeriods; t++) {
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					   -FLT_MAX, FLT_MAX);
    if (result == -1) 
      break;
  }

  nElementsChanged = t;

  if (nElementsChanged == 0 || nElementsChanged == -1) {
    badCount++;
    continue;
  }

  if ( lpModelHelper_ != 0 ) {
    float  * rev;
    witGetDemandObj1ShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), &rev);
    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      rev[t] =  floatVec[t];
    }
      
    witSetDemandObj1ShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), rev);
      
    // Now set the CumShipReward as a timeValue of Money percentage = .10
    for ( t=0; t<nPeriods; t++) {
      rev[t] *=  periodicInterestRate;
    }
    witSetDemandObj1CumShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), rev);
    
    witFree(rev);
  }

  // Now set the priority for the heuristic, regardless of the engine.
  // NOTE: We need to have
  // the priorities be "the higer the value, the higher the priority"
  // in SCE, so to make it work in the heuristic we "flip" them around

  int * priority;
  witGetDemandPriority(theWitRun, fullWitPart.c_str(), demandName.c_str(), &priority);
    
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nElementsChanged; t++) {
    priority[t] = 1000000000 - (int) floatVec[t];
    floatVec[t] = (float) priority[t];
  }
    
  witSetDemandPriority(theWitRun, fullWitPart.c_str(), demandName.c_str(), priority);

  // if doPegging and optimization, then we might store the 
  // priorities in appData because that is where we will look for them
  bool doPegging = this->sceScenario()->setOfParameters().getBool("doPegging");
  if ( lpModelHelper_ != 0  &&  doPegging)  {
    LgFrSceDemandAppData * demandAppDataPtr;
    witGetDemandAppData(theWitRun,
			fullWitPart.c_str(), 
			demandName.c_str(),
			(void **) &demandAppDataPtr);
    assert ( demandAppDataPtr != 0);
    
    LgFrTimeVecFloat pipPriority(nPeriods, floatVec);
    demandAppDataPtr->pipPriority(pipPriority);
  }

  witFree(priority);

  recCount++;
  if (myScrubber -> scrubMode() && outFile.good())
    {
      outFile << dataLine << std::endl;
    }

 }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();


 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processMinDemandVolFile(
    
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
 int nElementsChanged;
 std::string pdf_PartName;
 std::string demandName;
 float * cshlb;
 float * csslb;
 float * cshub;
 float * demandVol;
 long lineNo = 0;
 std::string dataLine;
 bool isRecordGood;
 int t;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "MinDemandVol Input",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);


 float * floatVec = new float[nPeriods];

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	floatVec,       // floatVector to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
        dataLine,
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	false,          // Are all elements mandatory?
	0.0,            // data lower limits
	FLT_MAX,        // data upper limits
	false);         // Do NOT Add new demand stream to WIT

    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++; 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }

    witGetDemandCumShipBounds(theWitRun, 
			      pdf_PartName.c_str(), 
			      demandName.c_str(), 
			      &cshlb,
			      &csslb,
			      &cshub);

    witGetDemandDemandVol(theWitRun,
                          pdf_PartName.c_str(),
                          demandName.c_str(),
                          &demandVol);

 

    // make sure the demand exceeds the minDemand, period by period
    isRecordGood = true;
    for(t=0; t<nElementsChanged; t++){
       if ((demandVol[t] + .001) < floatVec[t]){
          // reject this record, call the error routine
          // print out error
          badCount ++;
	  (*theErrFacil)("MinDemandExceedsDemand",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine
			 << t);
          isRecordGood = false;          
          break;
       }
    }
    witFree(demandVol);

    if (isRecordGood){
       // put in some check to see if this minDemand has already been touched
       // get the demand app data for this demand.  
       // get the hasMinDemandVolBeenSet
       LgFrSceDemandAppData * demandAppDataPtr;
       witGetDemandAppData(theWitRun,
			pdf_PartName.c_str(), 
			demandName.c_str(),
			(void **) &demandAppDataPtr);
       assert(demandAppDataPtr != 0);
       int hasMinDemandVolBeenSet = demandAppDataPtr->hasMinDemandVolBeenSet();

       if (hasMinDemandVolBeenSet) {
          badCount ++;
          std::string pnm = mpHelper.partname(pdf_PartName);
          std::string pdfff = mpHelper.pdf(pdf_PartName);
          (*theErrFacil)("MultipleMinDemandVolRecs",MclArgList() 
		     << fileName 
		     << (int) lineNo 
		     << pnm 
		     << pdfff);
       }
       else
          recCount ++;

    // update the demand cumulative ship bounds
    csslb[0] = floatVec[0];
    for(t=1; t<nElementsChanged; t++)
       csslb[t] = csslb[t-1] + floatVec[t];
    // 2.30 fix: don't forget to populate the rest of the mins file
    for(t=nElementsChanged; t<nPeriods; t++)
       csslb[t] = csslb[t-1];
    witSetDemandCumShipBounds(theWitRun, 
                              pdf_PartName.c_str(), 
                              demandName.c_str(), 
                              cshlb,
                              csslb,
                              cshub);
    // increment the nDemandsWithNonZeroMins counter if the last period of 
    // the csslb is greater than 0
    
    if (csslb[nPeriods-1] > 0 && !hasMinDemandVolBeenSet)
        sceScenario()->incNDemandsWithNonZeroMins();

    if (csslb[nPeriods-1] < 0.00001 && hasMinDemandVolBeenSet){
       (*theErrFacil)("ResetMinDemandVolRecs",MclArgList() 
		     << fileName 
		     << (int) lineNo 
                     << dataLine);
        sceScenario()->decNDemandsWithNonZeroMins();
    }
    // set the hasDemandVolBeenSet to true if last period of csslb > 0
    if (csslb[nPeriods-1] > 0) 
      demandAppDataPtr->hasMinDemandVolBeenSet(1);
    else 
      demandAppDataPtr->hasMinDemandVolBeenSet(0);

    witFree(cshlb);
    witFree(csslb);
    witFree(cshub);
  
  
    }

 }

 delete [] floatVec;

 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
  outFile.close();
  
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processMinIndepDemandVolFile(
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  
  int nElementsChanged;
  std::string mfgPart;
  std::string pdf;
  std::string fullWitPart;
  std::string demandName;
  
  int t;
  float * cshlb;
  float * csslb;
  float * cshub;
  float * demandVol;
  bool isRecordGood;
  
  std::ifstream inFile;
  long lineNo = 0;
  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
  
  
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
					"Min Independent Demand Volume",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  
  
 
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  
  float * floatVec = new float[nPeriods];
  
  while(inFile.peek() != EOF) {
    int result = 0;
    
    // Read next line of file
    std::getline( inFile, dataLine );
    lineNo ++;
    
    dataLine = sce::strip( dataLine );
    
    //  skip blanks or comments '*'
    if ((dataLine[0] == '*') || dataLine.empty()) {
      commentCount++;
      continue;
    }
   
    // construct a tokenizer
    SCETokenizer next(dataLine);
    
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }

  
    // get the partname
    mfgPart = flatFileManager.nextQuotedString(next, result, fileName, 
					       dataLine, lineNo, 
					       OPTIONAL_WITH_MESSAGE);
    
    // get the pdf
    pdf = flatFileManager.nextQuotedString(next, result, fileName, 
					   dataLine, lineNo, MANDATORY);
    
    // get the demandName
    demandName = flatFileManager.nextQuotedString(next, result, fileName, 
						  dataLine, lineNo, MANDATORY);
    
    // Get the witPartname
    fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);
    
    
    
    int readCsvMessage = OPTIONAL_WITH_MESSAGE;

    if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
				dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		     << mfgPart 
		     << pdf
		     << demandName
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      continue;
    }
    
    if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
      (*theErrFacil)("IndDemandDoesNotExist",MclArgList() 
		     << mfgPart 
		     << pdf
		     << demandName
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      continue;
    }
    
    
    
    
    
    
    // Now get the data
    bool isMinDemandVolNegative = 0;
    for (t = 0; t<nPeriods; t++) {
      int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					     -FLT_MAX, FLT_MAX);
      if (floatVec[t] < -0.00001)  {
	isMinDemandVolNegative = 1;
	floatVec[t] = 0.0;
      }

      if (result == -1) 
	break;
    }
  
  


    nElementsChanged = t;
    
    if (nElementsChanged == 0 || nElementsChanged == -1) {
      badCount++;
      continue;
    }


    if (isMinDemandVolNegative) {
      (*theErrFacil)("MinIndDemVolIsNegative",MclArgList() 
		     << mfgPart 
		     << pdf
		     << demandName
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }
    





    // ================
    // from minDemandVol
    witGetDemandCumShipBounds(theWitRun, 
			      fullWitPart.c_str(), 
			      demandName.c_str(), 
			      &cshlb,
			      &csslb,
			      &cshub);
    
    witGetDemandDemandVol(theWitRun,
			  fullWitPart.c_str(),
			  demandName.c_str(),
			  &demandVol);
    
    // tomtodo: put an if condition around this.   Only enforce this 
    //          restriction for heuristic engines.   OR, maybe an algorithm!!
    //          Do the same for minDemands as well.
    
    // make sure the demand exceeds the minDemand, period by period
    isRecordGood = true;
    for(t=0; t<nElementsChanged; t++){
      if ((demandVol[t] + .001) < floatVec[t]){
	// reject this record, call the error routine
	badCount ++;
	(*theErrFacil)("MinDemandExceedsDemand",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << dataLine
		       << t);
	isRecordGood = false;          
	break;
      }
    }
    witFree(demandVol);




  
    if (isRecordGood){
      // put in some check to see if this minDemand has already been touched
      // get the demand app data for this demand.  
      // get the hasMinDemandVolBeenSet
      LgFrSceDemandAppData * demandAppDataPtr;
      witGetDemandAppData(theWitRun,
			  fullWitPart.c_str(), 
			  demandName.c_str(),
			  (void **) &demandAppDataPtr);
      assert(demandAppDataPtr != 0);
      int hasMinDemandVolBeenSet = demandAppDataPtr->hasMinDemandVolBeenSet();
      
      if (hasMinDemandVolBeenSet) {
	// finish_me: need new message!! (include demandName)
	badCount ++;
	std::string pnm = mpHelper.partname(fullWitPart);
	std::string pdfff = mpHelper.pdf(fullWitPart);
	(*theErrFacil)("MultipleMinDemandVolRecs",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << pnm 
		       << pdfff);
      }
    
      // update the demand cumulative ship bounds
      csslb[0] = floatVec[0];
      for(t=1; t<nElementsChanged; t++)
	csslb[t] = csslb[t-1] + floatVec[t];
      for(t=nElementsChanged; t<nPeriods; t++)
	csslb[t] = csslb[t-1];
      witSetDemandCumShipBounds(theWitRun, 
				fullWitPart.c_str(), 
				demandName.c_str(), 
				cshlb,
				csslb,
				cshub);
      // increment the nDemandsWithNonZeroMins counter if the last period of 
      // the csslb is greater than 0
      
      if (csslb[nPeriods-1] > 0 && !hasMinDemandVolBeenSet)
	sceScenario()->incNDemandsWithNonZeroMins();
      
      if (csslb[nPeriods-1] < 0.00001 && hasMinDemandVolBeenSet){
	(*theErrFacil)("ResetMinDemandVolRecs",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
	sceScenario()->decNDemandsWithNonZeroMins();
      }
   
      // set the hasDemandVolBeenSet to true if last period of csslb > 0
      if (csslb[nPeriods-1] > 0) 
	demandAppDataPtr->hasMinDemandVolBeenSet(1);
      else 
	demandAppDataPtr->hasMinDemandVolBeenSet(0);
      
      witFree(cshlb);
      witFree(csslb);
      witFree(cshub);

      recCount++;
      if (myScrubber -> scrubMode() && outFile.good())
	{
	  outFile << dataLine << std::endl;
	}
    }

  }

  delete [] floatVec;
  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  
  
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processBacklogYieldFile(
    
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  int nElementsChanged;
  std::string pdf_PartName;
  std::string demandName;
  long lineNo = 0;
  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
				       "backlogYield",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  float * floatVec = new float[nPeriods];
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  
  while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	floatVec,       // floatVector to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
        dataLine,
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	false,          // Are all elements mandatory?
	0.0,            // data lower limits
	1.0,            // data upper limits
	false);         // do NOT add new demand stream to WIT

    if (nElementsChanged == 0 || nElementsChanged == -1) {
      badCount++;
      continue;
    }
    else if (nElementsChanged == -2) {
      commentCount++;
      continue;
    }
        
    LgFrSceDemandAppData * demandAppDataPtr;
    witGetDemandAppData(theWitRun,
			pdf_PartName.c_str(), 
			demandName.c_str(),
			(void **) &demandAppDataPtr);


    
    // If the demandAppDataPtr hasn't been set (i.e., its 0) then "new" one
    // and set the backlogYield_.
    // If the demandAppDataPtr has been set, see if the backlogYield has been set.
    // If it hasn't (i.e. the backlogYield is 0), then set it. Otherwise, do nothing.
    if (demandAppDataPtr == 0)  {
      demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);  // init backlogYield to 1.0
      assert ( demandAppDataPtr != 0);

      witSetDemandAppData(theWitRun,
                          pdf_PartName.c_str(), 
                          demandName.c_str(), 
                          (void *) demandAppDataPtr );
    }

    LgFrTimeVecFloat backlogYield( demandAppDataPtr->backlogYield() );
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      backlogYield[t] = floatVec[t]; 
    }                                          
    
    demandAppDataPtr->backlogYield(backlogYield);


    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
  }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
  outFile.close();
  
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processGreedySearchIncFile(
    
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{
  int nElementsChanged;
  std::string pdf_PartName;
  std::string demandName;
  long lineNo = 0;
  std::string dataLine;
  
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName,
				       "greedySearchInc",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
  
  float greedySearchInc = 1.0;
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  
  while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatScalar(
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	greedySearchInc,       // float to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
        dataLine,
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	OPTIONAL_WITH_MESSAGE,          // Is the element  mandatory?
	0.0,            // data lower limits
	FLT_MAX,            // data upper limits
	false);         // do NOT add new demand stream to WIT

    if (nElementsChanged == 0 || nElementsChanged == -1) {
      badCount++;
      continue;
    }
    else if (nElementsChanged == -2) {
      commentCount++;
      continue;
    }
        
    float gsi;
    witSetDemandSearchInc(theWitRun,
			  pdf_PartName.c_str(), 
			  demandName.c_str(),
			  greedySearchInc);

    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
  }

  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close();
  
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}




// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processIndpGreedySearchIncFile(
    
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::string demandName;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   


 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Indpendent Greedy Search Increment",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);





 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
   int result = 0;
 
   // Read next line of file
   std::getline( inFile, dataLine );
   lineNo ++;

   dataLine = sce::strip( dataLine );
   
   //  skip blanks or comments '*'
   if ((dataLine[0] == '*') || dataLine.empty()) {
    commentCount++;
    continue;
   }
   
   // construct a tokenizer
   SCETokenizer next(dataLine);
   
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() 
		    << fileName 
		    << (int)lineNo 
		    << dataLine);
   }

  
   // get the partname
   mfgPart = flatFileManager.nextQuotedString(next, result, fileName, 
					      dataLine, lineNo, 
					      OPTIONAL_WITH_MESSAGE);

   // get the pdf
   pdf = flatFileManager.nextQuotedString(next, result, fileName, 
					  dataLine, lineNo, MANDATORY);

   // get the demandName
   demandName = flatFileManager.nextQuotedString(next, result, fileName, 
						 dataLine, lineNo, MANDATORY);

   // Get the witPartname
   fullWitPart = mpHelper.pdfPartname(mfgPart, pdf);



  int readCsvMessage = OPTIONAL_WITH_MESSAGE;

  if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, 
                              dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }

    

  if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
    (*theErrFacil)("IndDemandDoesNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }

    
    
  // Now get the data
  float greedySearchInc;
  result = flatFileManager.nextFloat(greedySearchInc, next, fileName, dataLine, lineNo, false,
				     0, FLT_MAX);
  
  if (result == -1) {
    badCount++;
    continue;
  }
  
  
  witSetDemandSearchInc(theWitRun,
			fullWitPart.c_str(), 
			demandName.c_str(),
			greedySearchInc);
  
  recCount++;
  if (myScrubber -> scrubMode() && outFile.good())
    {
      outFile << dataLine << std::endl;
    }
 }
 
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processProdVolLBFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string pdf_PartName;
 float * pvhLB;
 float * pvsLB;
 float * pvhUB;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "prodVolLBFile",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

 while(inFile.peek() != EOF) {
    nElementsChanged = flatFileManager.readCsvPartFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_PartName,     // legal pdf_PartName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                        // or OPTIONAL_WITH_MESSAGE
	0.0,              // data lower limits
	FLT_MAX);         // data upper limits


    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetPartProdBounds(theWitRun, pdf_PartName.c_str(), &pvhLB, &pvsLB, &pvhUB);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
       pvsLB[t] = floatVec[t];
       }
    witSetPartProdBounds(theWitRun, pdf_PartName.c_str(), pvhLB, pvsLB, pvhUB);
    witFree(pvhLB);
    witFree(pvsLB);
    witFree(pvhUB);
//    std::cout << "Updated prodVol Soft Lower Bound  for " << pdf_PartName << "\n";
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processProdVolUBFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string pdf_PartName;
 float * pvhLB;
 float * pvsLB;
 float * pvhUB;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "prodVolUBFile",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

 while(inFile.peek() != EOF) {
    nElementsChanged = flatFileManager.readCsvPartFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_PartName,     // legal pdf_PartName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                        // or OPTIONAL_WITH_MESSAGE
	-FLT_MAX,              // data lower limits
	FLT_MAX);         // data upper limits

    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++; 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetPartProdBounds(theWitRun, pdf_PartName.c_str(), &pvhLB, &pvsLB, &pvhUB);

    int lastPeriodWithUBltLB = -1;
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      if ((floatVec[t] < pvsLB[t]) && (floatVec[t] >= 0.0)) {
	lastPeriodWithUBltLB = t;
	pvhUB[t] = pvsLB[t];
      }
      else {
	pvhUB[t] = floatVec[t];
      }
    }
    if (lastPeriodWithUBltLB > -1) {
      (*theErrFacil)("ConflictingBounds",MclArgList() << "ProdVol" << pdf_PartName << fileName << (int)lineNo << (int)lastPeriodWithUBltLB);
    }
    witSetPartProdBounds(theWitRun, pdf_PartName.c_str(), pvhLB, pvsLB, pvhUB);
    witFree(pvhLB);
    witFree(pvsLB);
    witFree(pvhUB);
//    std::cout << "Updated prodVol Hard Upper Bound  for " << pdf_PartName << "\n";
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
      
    }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
  outFile.close();
  
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processOperationLBFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string pdf_OperationName;
 float * hardLB;
 float * softLB;
 float * hardUB;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "opLBFile",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

 while(inFile.peek() != EOF) {
    nElementsChanged = flatFileManager.readCsvOperationFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_OperationName,// legal pdf_OperationName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                        // or OPTIONAL_WITH_MESSAGE
	0.0,              // data lower limits
	FLT_MAX);         // data upper limits


    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++; 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), &hardLB, &softLB, &hardUB);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
       softLB[t] = floatVec[t];
       }
    witSetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), hardLB, softLB, hardUB);
    witFree(hardLB);
    witFree(softLB);
    witFree(hardUB);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processOperationUBFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string pdf_OperationName;
 float * hardLB;
 float * softLB;
 float * hardUB;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "opUBFile",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];

 while(inFile.peek() != EOF) {
    nElementsChanged = flatFileManager.readCsvOperationFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_OperationName,// legal pdf_OperationName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                  // or OPTIONAL_WITH_MESSAGE
	-FLT_MAX,         // data lower limits
	FLT_MAX);         // data upper limits

    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++; 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), &hardLB, &softLB, &hardUB);

    int lastPeriodWithUBltLB = -1;
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      if ((floatVec[t] < softLB[t]) && (floatVec[t] >= 0.0)) {
	lastPeriodWithUBltLB = t;
	hardUB[t] = softLB[t];
      }
      else {
	hardUB[t] = floatVec[t];
      }
    }
    if (lastPeriodWithUBltLB > -1) {
      (*theErrFacil)("ConflictingBounds",MclArgList() << "Operation ExecutionVol" << pdf_OperationName << fileName << (int)lineNo << lastPeriodWithUBltLB);
    }
    witSetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), hardLB, softLB, hardUB);
    witFree(hardLB);
    witFree(softLB);
    witFree(hardUB);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processBuildAheadFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string partName;
 std::string pdf;
 std::string buildAheadType;

 int result;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "buildAhead",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);



 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the partName 
    partName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);


    // get the buildAheadCode
    buildAheadType = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, PURELY_OPTIONAL);


    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    int buildAheadLimitPeriods = nPeriods-1;
    float buildAheadLimitDays = -1.0;
    int   early = 0;
    int   late = nPeriods-1;

    // buildAheadLimitDays        
    result = flatFileManager.nextFloat(buildAheadLimitDays, next, fileName, dataLine, lineNo, false, -INT_MAX);

    // effectivity Dates
    if (result >= 0)
	flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "");
	badCount++;
	continue;
    }

    // scale the buildAheadUBDays
    buildAheadLimitPeriods = floor(buildAheadLimitDays / theCal.workUnits(early));
    if (buildAheadLimitPeriods < 0)
      buildAheadLimitPeriods = nPeriods - 1;

    if (buildAheadLimitPeriods > nPeriods - 1)
      buildAheadLimitPeriods = nPeriods - 1;


    std::string fullPartName(mpHelper.pdfPartname(partName, pdf));
	
    if (! mpHelper.isPartValid(theWitRun, partName, pdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) {
      	badCount++;
	continue;
    }


    int * buildAheadUB;
    witGetPartBuildAheadUB(theWitRun, fullPartName.c_str(), &buildAheadUB);


#if 0
    std::cout << "Setting buildAheadUB \n    From:\n ";
    std::string blankVector(6, ' ');
    int ttt = 0; 
    for (ttt=0; ttt < nPeriods; ttt++) 
      {
	std::string sNum(sce::stringFrom((float) buildAheadUB[ttt], (int) 1));
	int blankSpace = 6 - sNum.length();
	sNum.insert(0, blankVector.c_str(), blankSpace);
	std::cout << sNum;
      }
    std::cout  << std::endl;
#endif    


    int t;
    for (t=early; t<=late; t++) 
      buildAheadUB[t] = buildAheadLimitPeriods;

#if 0
    std::cout << "      To:\n ";
    std::string blankVector2(6, ' ');
    for (ttt=0; ttt < nPeriods; ttt++) 
      {
	std::string sNum(sce::stringFrom((float) buildAheadUB[ttt], (int) 1));
	int blankSpace = 6 - sNum.length();
	sNum.insert(0, blankVector2.c_str(), blankSpace);
	std::cout << sNum;
      }
    std::cout  << std::endl;
#endif




    if (buildAheadType == "N") {
      witSetPartBuildAsap(theWitRun, fullPartName.c_str(), WitFALSE);
      witSetPartBuildNstn(theWitRun, fullPartName.c_str(), WitTRUE);
      witSetPartBuildAheadUB(theWitRun, fullPartName.c_str(), buildAheadUB);
      witFree(buildAheadUB);
    }

    else if (buildAheadType == "A") {
      witSetPartBuildNstn(theWitRun, fullPartName.c_str(), WitFALSE);
      witSetPartBuildAsap(theWitRun, fullPartName.c_str(), WitTRUE);
      witSetPartBuildAheadUB(theWitRun, fullPartName.c_str(), buildAheadUB);
      witFree(buildAheadUB);
    }

    else {
      (*theErrFacil)("BadBuildAheadCode",MclArgList() << partName 
		     << pdf 
		     << buildAheadType 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      witSetPartBuildNstn(theWitRun, fullPartName.c_str(), WitFALSE);
      witSetPartBuildAsap(theWitRun, fullPartName.c_str(), WitTRUE);
      witFree(buildAheadUB);
    }

    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
        outFile << dataLine << std::endl;
      }
    }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processScrapCostFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string partName;
 std::string pdf;
 std::string buildAheadType;

 int result;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "scrapCost",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 LgFrTimeVecFloat bigM(nPeriods, 99999.9);
 int nParts;
 char ** partList;
 witGetParts( theWitRun, &nParts, &partList );
 int iii;
 for (iii=0; iii<nParts; iii++) 
   witSetPartScrapCost(theWitRun, partList[iii], bigM.data());




 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the partName 
    partName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);




    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float scrapCost = 0.0;
    int   early = 0;
    int   late = nPeriods-1;

    // scrapCost        
    result = flatFileManager.nextFloat(scrapCost, next, fileName, dataLine, lineNo, false, -INT_MAX);

    // effectivity Dates
    if (result >= 0)
	flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "");
	badCount++;
	continue;
    }


    std::string fullPartName(mpHelper.pdfPartname(partName, pdf));
	
    if (! mpHelper.isPartValid(theWitRun, partName, pdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) {
      	badCount++;
	continue;
    }


    float  * scrapCostVol;
    witGetPartScrapCost(theWitRun, fullPartName.c_str(), &scrapCostVol);

    int t;
    for (t=early; t<=late; t++) 
      scrapCostVol[t] = scrapCost;

    witSetPartScrapCost(theWitRun, fullPartName.c_str(), scrapCostVol);
    witFree(scrapCostVol);


    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
        outFile << dataLine << std::endl;
      }
    }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}




// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processStockCostFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string partName;
 std::string pdf;
 std::string buildAheadType;

 int result;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "stockCost",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 LgFrTimeVecFloat bigM(nPeriods, 99999.9);
 int nParts;
 char ** partList;
 witGetParts( theWitRun, &nParts, &partList );
 int iii;
 for (iii=0; iii<nParts; iii++) 
   witSetPartObj1StockCost(theWitRun, partList[iii], bigM.data());




 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next line
    std::getline( inFile, dataLine );
    lineNo++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
        commentCount++;
	continue;
    }

    // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }


    SCETokenizer next(dataLine);

    // get the partName 
    partName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) {
        badCount++;
	continue;
    }

    // get the PDF
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);




    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float stockCost = 0.0;
    int   early = 0;
    int   late = nPeriods-1;

    // scrapCost        
    result = flatFileManager.nextFloat(stockCost, next, fileName, dataLine, lineNo, false, -INT_MAX);

    // effectivity Dates
    if (result >= 0)
	flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "");
	badCount++;
	continue;
    }


    std::string fullPartName(mpHelper.pdfPartname(partName, pdf));
	
    if (! mpHelper.isPartValid(theWitRun, partName, pdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) {
      	badCount++;
	continue;
    }


    float  * stockCostVol;
    witGetPartObj1StockCost(theWitRun, fullPartName.c_str(), &stockCostVol);

    int t;
    for (t=early; t<=late; t++) 
      stockCostVol[t] = stockCost;

    witSetPartObj1StockCost(theWitRun, fullPartName.c_str(), stockCostVol);
    witFree(stockCostVol);


    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
        outFile << dataLine << std::endl;
      }
    }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



#ifdef VARIABLE_PERIODS
// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processCycleTimeFile(
    
     WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_PartName;
 float * ct;
 int result;
 int start, end;
 float theVal;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "cycleTime",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 int t = 0;
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {
   result = flatFileManager.readCsvPartFloatDatedRecord(theWitRun, nPeriods, pdf_PartName, theCal, theVal, 
							start, end, inFile, fileName, dataLine, lineNo,mpHelper);
   if (result == 1) {
     badCount++;        
     continue;
   }
   else if (result == -2) {
     commentCount++;
     continue;
   }
   
   // get the existing cycleTime for this part (it's in app data
   LgFrTimeVecFloat cycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, pdf_PartName);
   LgFrTimeVecFloat cycleTime = mpHelper.getCycleTime(theWitRun, pdf_PartName);

   for (t=start; t<=end; t++) {
      cycleTimeDays[t] = theVal;
      cycleTime[t] = mpHelper.calculateVariableOffset(cycleTimeDays[t], t, theCal, nPeriods);
   }
   
   // Comment this out when ready to ditch wit34
   // witSetPartCycleTime(theWitRun, pdf_PartName.c_str(), ct);

   // set cycleTimeDays and CycleTime in AppData
   mpHelper.setCycleTimeDays(theWitRun, pdf_PartName, cycleTimeDays);
   mpHelper.setCycleTime(theWitRun, pdf_PartName, cycleTime);

#if 0
   std::cout << "CycleTimeDays for [" << pdf_PartName << "] = (";
   for (t=0; t<nPeriods; t++) 
     std::cout << cycleTimeDays[t] << ",";
   std::cout << std::endl;

   std::cout << "CycleTime for [" << pdf_PartName << "] = (";
   for (t=0; t<nPeriods; t++) 
     std::cout << cycleTime[t] << ",";
   std::cout << std::endl;
#endif

   //   witFree(ct);
   recCount++;
   if (myScrubber -> scrubMode() && outFile.good())        {
     outFile << dataLine << std::endl;
   }
 }
 
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}





#else
// the OLD WAY
// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processCycleTimeFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_PartName;
 float * ct;
 int result;
 int start, end;
 float theVal;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "cycleTime",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {
    result = flatFileManager.readCsvPartFloatDatedRecord(
	theWitRun, nPeriods, pdf_PartName, theCal, theVal, 
	start, end, inFile, fileName, dataLine, lineNo,mpHelper);
    if (result == 1) {
       badCount++;        
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    witGetPartCycleTime(theWitRun, pdf_PartName.c_str(), &ct);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
       ct[t] = theVal/theCal.workUnits(t);
       }
    witSetPartCycleTime(theWitRun, pdf_PartName.c_str(), ct);
    witFree(ct);
//    std::cout << "Updated cycleTimes for " << pdf_PartName << "\n";
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }


 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}
#endif

//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processYieldFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_PartName;

 // YIELD_RATE
 //   int * yield;
 float * yieldRate;
 int result;
 int start, end;
 float theVal;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "yield",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

    result = flatFileManager.readCsvPartFloatDatedRecord(
	theWitRun, nPeriods, pdf_PartName, theCal, theVal, 
	start, end, inFile, fileName, dataLine, lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }
    
    // YIELD_RATE
    witGetOperationYieldRate(theWitRun, pdf_PartName.c_str(), &yieldRate);
    //    witGetPartYield(theWitRun, pdf_PartName.c_str(), &yield);

    int t = 0;
    for (t=start; t<=end; t++) {
      // YIELD_RATE
       yieldRate[t] = theVal/100.0;
       //       yield[t] = theVal;
    }
    witSetOperationYieldRate(theWitRun, pdf_PartName.c_str(), yieldRate);
    //    witSetPartYield(theWitRun, pdf_PartName.c_str(), yield);

    //    witFree(yield);
    witFree(yieldRate);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 inFile.close();
 outFile.close();
 
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationYieldFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_OperationName;
 //   int * yield;
 float * yieldRate;
 int result;
 int start, end;
 float theVal;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "operation yield",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

    result = flatFileManager.readCsvOperationFloatDatedRecord(
	theWitRun, nPeriods, pdf_OperationName, theCal, theVal, 
	start, end, inFile, fileName, dataLine,lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    //    witGetOperationYield(theWitRun, pdf_OperationName.c_str(), &yield);
    witGetOperationYieldRate(theWitRun, pdf_OperationName.c_str(), &yieldRate);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
      // yield[t] = (int) theVal;
      yieldRate[t] = theVal/100.0;
    }
    //    witSetOperationYield(theWitRun, pdf_OperationName.c_str(), yield);
    witSetOperationYieldRate(theWitRun, pdf_OperationName.c_str(), yieldRate);
    //    witFree(yield);
    witFree(yieldRate);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
      
    }

 inFile.close();
 outFile.close();
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processLotSizeFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_PartName;
 float * minLotSize;
 float * incLotSize;
 int result;
 int start, end;
 float theVal, theVal2;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "lot size",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

    result = flatFileManager.readCsvPart2FloatsDatedRecord(
	theWitRun, nPeriods, pdf_PartName, theCal, theVal, theVal2, 
	start, end, inFile, fileName, dataLine,lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    witGetPartMinLotSize(theWitRun, pdf_PartName.c_str(), &minLotSize);
    witGetPartIncLotSize(theWitRun, pdf_PartName.c_str(), &incLotSize);
    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
       minLotSize[t] = theVal;
       incLotSize[t] = theVal2;
       }
    witSetPartMinLotSize(theWitRun, pdf_PartName.c_str(), minLotSize);
    witSetPartIncLotSize(theWitRun, pdf_PartName.c_str(), incLotSize);
    witFree(minLotSize);
    witFree(incLotSize);
//    std::cout << "Updated lot sizes for " << pdf_PartName << "\n";
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
      
    }

 inFile.close();
  outFile.close();
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationLotSizeFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_OperationName;
 float * minLotSize;
 float * incLotSize;
 int result;
 int start, end;
 float theVal, theVal2;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "operation lot size",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

    result = flatFileManager.readCsvOperation2FloatsDatedRecord(
	theWitRun, nPeriods, pdf_OperationName, theCal, theVal, theVal2, 
	start, end, inFile, fileName, dataLine, lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    witGetOperationMinLotSize(theWitRun, pdf_OperationName.c_str(), &minLotSize);
    witGetOperationIncLotSize(theWitRun, pdf_OperationName.c_str(), &incLotSize);
    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
       minLotSize[t] = theVal;
       incLotSize[t] = theVal2;
       }
    witSetOperationMinLotSize(theWitRun, pdf_OperationName.c_str(), minLotSize);
    witSetOperationIncLotSize(theWitRun, pdf_OperationName.c_str(), incLotSize);
    witFree(minLotSize);
    witFree(incLotSize);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 inFile.close();
  outFile.close();
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}



//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationExecPenaltyFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_OperationName;
 float execPenalty;
 int result;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "operation exec penalty",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

   execPenalty = 0.0;

    result = flatFileManager.readCsvOperationFloatRecord(
	theWitRun, nPeriods, pdf_OperationName, theCal, execPenalty,
	inFile, fileName, dataLine, lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    witSetOperationExecPenalty(theWitRun, pdf_OperationName.c_str(), execPenalty);
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }

 inFile.close();
  outFile.close();
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationIntegerExecFile(
							  WitRun * const theWitRun,   
							  const int nPeriods,         
							  const LgFrCalendar & theCal,
							  const std::string & fileName,
							  LgFrMultiPlantHelper & mpHelper)
{
 std::string pdf_OperationName;
 float integerExecVal;
 int result;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "operation integer exec vols",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

   integerExecVal = 0.0;

   result = flatFileManager.readCsvOperationFloatRecord(
							theWitRun, nPeriods, pdf_OperationName, theCal, integerExecVal,
							inFile, fileName, dataLine, lineNo, mpHelper);
   
    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    if (integerExecVal > 0.50)
      witSetOperationIntExecVols(theWitRun, pdf_OperationName.c_str(), WitTRUE);
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
	outFile << dataLine << std::endl;
      }
 }
 
 inFile.close();
 outFile.close();
 std::cout << recCount << " records processed." << std::endl;
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationExecCostFile(
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string pdf_OperationName;
 float * execCost;
 int result;
 int start, end;
 float theVal;
 long lineNo = 0;
 std::string dataLine;
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "operation execCost",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);

 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 while(inFile.peek() != EOF) {

    result = flatFileManager.readCsvOperationFloatDatedRecord(
	theWitRun, nPeriods, pdf_OperationName, theCal, theVal, 
	start, end, inFile, fileName, dataLine,lineNo, mpHelper);

    if (result == 1) {
       badCount++; 
       continue;
    }
    else if (result == -2) {
       commentCount++;
       continue;
    }

    witGetOperationObj1ExecCost(theWitRun, pdf_OperationName.c_str(), &execCost);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
       execCost[t] = theVal;
       }
    witSetOperationObj1ExecCost(theWitRun, pdf_OperationName.c_str(), execCost);
    witFree(execCost);
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
      
    }

 inFile.close();
 outFile.close();
 std::cout << recCount << " records processed." << std::endl;

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


// -----------------------------------------------------------------
int 
LgFrInitialProblemForSce::setTheCalendar(
    LgFrCalendar & theCal)

{
    int numPeriods;
    int period;
    long pd;

    double wu;
    char dataDelim[] = " \",\n";  

    LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    numPeriods = setOfParameters.getInt("numPeriods");

    std::string fileName = setOfParameters.getString("calendarFile");

    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    this->openInputFileAndScrubOutputFile(fileName,
					  "Calendar file",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);

    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;
    long lineNo = 0;
   
    int t = 0;
    while(inFile.peek() != EOF) {

	std::string dataLine;
	std::string token;


	std::getline( inFile, dataLine );
	lineNo++;

        //  skip blanks or comments *
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
        }

        // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }

        
	SCETokenizer next(dataLine);

        // get the period
	token = next(dataDelim);

        // make sure period number is valid
    if (! sce::fromString(token, pd))  {
	  (*theErrFacil)("CalendarPeriod",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "Invalid period number in the calendar file.");
	}
	period = (int) pd;

	if (period != t) {
	  (*theErrFacil)("CalendarPeriod",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "The periods are out of sequence.");
	}

// Note: you must specifiy a "startDate" for the numPeriods bucket.
// This essentially gives us an ending date for bucket numPeriods-1
	if (period > numPeriods) {
	  (*theErrFacil)("CalendarPeriod",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "Too many periods. Check the 'numPeriods' parameter in the parameter file.");
	}

// read the period start date and make sure its ok
	if ((token = next(dataDelim)).empty())    {
	  (*theErrFacil)("InvalidDataWarning",MclArgList() 
			 << "calendar record" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "The date is missing.");
	}


	LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
	if (! startDate.isValid())  {
	  // error
	  (*theErrFacil)("InvalidCalendarDate",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
	}
	
// Set the period start date in the calendar
	if (period < numPeriods)
	  theCal.periodStart(period, startDate);
	else 
	  theCal.horizonEnd(startDate);

// Test the sequential-ness of the calendar now
	if (period > 0  && period < numPeriods
	    && (theCal.periodStart(period-1) >= theCal.periodStart(period))) {
	  (*theErrFacil)("InvalidDataWarning",MclArgList() 
			 << "period start date in Calendar File" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "Date is out of sequence with previous period.");
	}

// increment the period counter 
// we want to enforce that they enter every period
	t++;

// read the workUnits field.  
        // If this is the last Period, then skip it.
	if (period == numPeriods) {
	    recCount++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          
	    continue;
	}

	// see if workunits is there
	if ((token = next(dataDelim)).empty())    {
	    theCal.workUnits(period, 20.0);
	    (*theErrFacil)("CalendarWorkUnits",MclArgList() 
			   << period 
			   << fileName 
			   << (int)lineNo 
			   << dataLine);
	}

	// is it a valid number
	else if (! sce::fromString(token, wu))  {
	  (*theErrFacil)("InvalidDataWarning",MclArgList() 
			 << "workUnits field in Calendar File" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "Default of 20.0 will be used");
	  theCal.workUnits(period, 20.0);
	}

	else if (wu <= -0.0001) {
	  (*theErrFacil)("InvalidDataWarning",MclArgList() 
			 << "workUnits field in Calendar File" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "Default of 20.0 will be used.");
	    theCal.workUnits(period, 20.0);
	}

	else if (wu < 0.0001) {
	  (*theErrFacil)("InvalidDataWarning",MclArgList() 
			 << "workingDays is zero. in Calendar File" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "This is informational message.  Zero will be used but possibly may cause unexpected behavior.");
	    theCal.workUnits(period, 0.0);
	}


	else 
	    theCal.workUnits(period, (float) wu);
    

	recCount++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
          
    }

    if (period < numPeriods) {
      (*theErrFacil)("CalendarPeriod",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << "\n"
		     <<  "Not enough periods specified. Remember to specify a start date for\n period numPeriods (this is the end date of the last period).");
	}

    inFile.close();
    outFile.close();
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

    return numPeriods;
}


// tommy come here


// ====================================
// SCE 6.1: 
// ====================================
// Finish Me:   For now we will assume that records are DATED   
// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processDemandFile(
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 std::string partNumber; //mfgPart;
 std::string sourceLoc; // pdf
 std::string fullWitPart;
 std::string demandName;
 std::ifstream inFile;
 long lineNo = 0;
 std::string dataLine;
 int t = 0; 
 
 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   

 int defaultIndependentDemandPriority = setOfParameters.getInt("defaultIndependentDemandPriority");
 LgFrTimeVecFloat tvDefaultPriority(nPeriods, (float) (1000000000 - defaultIndependentDemandPriority));

 int demandTypeKeyFieldNum = setOfParameters.getInt("demandTypeKeyFieldNum");
 bool useDatedDemands = setOfParameters.getBool("useDatedDemands");
 float theDatedDemandVol = 0.0f;
 int thePeriod = 0;
 std::string requestDate;

 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName, "Demand Volume",
				       inFile, outFile, myScrubber, theErrFacil);

 
 std::cout << "Processing (6.1) " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
   int result = 0;
   std::getline( inFile, dataLine );
   lineNo ++;
   dataLine = sce::strip( dataLine );
   if ((dataLine[0] == '*') || dataLine.empty()) { commentCount++; continue; }
   SCETokenizer next(dataLine);
   if ( flatFileManager.containsIllegalCharacters( dataLine )) {
     (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
   }
  
   // get the partname
   partNumber = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);

   // get the sourceLoc (pdf)
   sourceLoc = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

   // get the demandName
   demandName = flatFileManager.nextQuotedDemandString(next, result, fileName, dataLine, lineNo, MANDATORY);

   // get the demandQty and requestPeriod (need requestDate perhaps??)


   int requestPeriod = 0;
   float demandQty = 0.0;
   bool dieIfErrorFlag = true;
   result = flatFileManager.readDatedDemandFloatRecord( demandQty, requestDate, 
							dieIfErrorFlag, -FLT_MAX, FLT_MAX,
							next, fileName, dataLine, lineNo, 
							mpHelper, theCal);
   

  


   // determine Demand_Type ... must be one of: DEMAND_TYPE_ERROR, DEMAND_TYPE_INDP, DEMAND_TYPE_TINP 
   int Demand_Type = flatFileManager.demandType(demandName);


   // **** TINP ****
   if (Demand_Type == DEMAND_TYPE_TINP) {
     addGeoSourceAndDemandVolFromTINP(theWitRun, dataLine, 
				      partNumber, demandName, sourceLoc, requestDate, demandQty, 
				      fileName, lineNo, theCal, mpHelper);
   }
   
   else if  (Demand_Type == DEMAND_TYPE_INDP) { 
     addDemandVolFromINDP(theWitRun, dataLine, nPeriods,
			  partNumber, demandName, sourceLoc, requestDate, demandQty, 
			  fileName, lineNo, theCal, mpHelper);
   }
   
   // **** INDP ****
   else if  (Demand_Type == DEMAND_TYPE_ERROR) { 
       ;
     // print a message and reject or assume INDP(?)
   }

   else {
     // should never come here
     assert(Demand_Type == DEMAND_TYPE_ERROR);
   }

   recCount++;
   if (myScrubber -> scrubMode() && outFile.good())
     {
       outFile << dataLine << std::endl;
     }
 }
 
 // delete [] defaultPriorityVec;
 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 
 
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

// --------------------------------------------------------------------- 
// SCE 6.1
int 
LgFrInitialProblemForSce::addDemandVolFromINDP(WitRun * const theWitRun,
					       const std::string &  dataLine,
					       const int nPeriods,
					       const std::string &  partNumber,
					       const std::string &  demandName,
					       const std::string &  sourceLoc,
					       const std::string & requestDate,
					       float demandQty,
					       const std::string & fileName,
					       const long  lineNo,
					       const LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{

  std::string fullWitPart;
  int t = 0; 
 
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
  int defaultIndependentDemandPriority = setOfParameters.getInt("defaultIndependentDemandPriority");
  LgFrTimeVecFloat tvDefaultPriority(nPeriods, (float) (1000000000 - defaultIndependentDemandPriority));
  int defaultShipLateLimit = heurModelHelper_->defaultShipLateLimit();
 
  // create a witPartname
  fullWitPart = mpHelper.pdfPartname(partNumber, sourceLoc);
 
  int readCsvMessage = OPTIONAL_WITH_MESSAGE;
  if (! mpHelper.isPartValid( theWitRun, fullWitPart, fileName, dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("IndDemandedPartNotExist",MclArgList() 
		   << partNumber << sourceLoc << demandName << fileName << (int)lineNo << dataLine);
    return 0;
  }


  // see what period it falls in
  // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
  // NOTE: you can also use roundedPeriod() 
  int requestPeriod = theCal.period(requestDate);  
  if (requestPeriod >= nPeriods)  {
    (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() 
		   << fileName << (int)lineNo << dataLine);
    return 0;
  }
  if (requestPeriod < 0)  {
    (*theErrFacil)("DatedRecordBeforeHorizonStartAccept",MclArgList() 
		   << fileName << (int)lineNo << dataLine);
    requestPeriod = 0;
  }
    
  
  
  if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
    // regardless of engine, load the priorities and shipLateLimit
    // get the default priority
    witAddDemand( theWitRun, fullWitPart.c_str(), demandName.c_str() );
    // create a demand app data for this demand.  Set the hasDemandVolBeenSet=0
    // init backlogYield to 1.0
    LgFrSceDemandAppData * demandAppDataPtr = new LgFrSceDemandAppData (0, 0, (size_t) nPeriods, 1.0);  
    demandAppDataPtr->pipPriority(tvDefaultPriority);
    //    std::cout << "Adding indp demand with default pipPiority [" 
    //	      << fullWitPart << "," << demandName << "] =" << (int) tvDefaultPriority[2] << std::endl;
    witSetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void *) demandAppDataPtr);
    
    witSetDemandPriority(theWitRun, fullWitPart.c_str(),
			 demandName.c_str(), tvDefaultPriority.intData() );
    witSetDemandShipLateLimit(theWitRun, fullWitPart.c_str(),
			      demandName.c_str(), defaultShipLateLimit );
    
    
    // but only load the obj1 values if we have too      
    if ( lpModelHelper_ != 0 ) {
      // get the default Obj1 Ship Reward
      float defaultObj1ShipReward = lpModelHelper_->defaultObj1ShipReward();
      
      // get the periodic Interest Rate
      float periodicInterestRate = lpModelHelper_->periodicInterestRate();
      
      float * defaultObj1ShipRewardVec = new float[nPeriods];
      float * defaultObj1CumShipRewardVec = new float[nPeriods];
      
      // make time vecs from scalars
      for (t=0; t<nPeriods; t++) {
	defaultObj1ShipRewardVec[t] = defaultObj1ShipReward;
	defaultObj1CumShipRewardVec[t] = defaultObj1ShipReward * 
	  periodicInterestRate;
      }
      
      witSetDemandObj1ShipReward( theWitRun, fullWitPart.c_str(),
				  demandName.c_str(), defaultObj1ShipRewardVec);
      witSetDemandObj1CumShipReward( theWitRun, fullWitPart.c_str(),
				     demandName.c_str(), defaultObj1CumShipRewardVec);
      delete [] defaultObj1ShipRewardVec;
      delete [] defaultObj1CumShipRewardVec;
    }
  }
  

  LgFrSceDemandAppData * demandAppDataPtr;
  witGetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
  LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();
  int hasDemandVolBeenSet = demandAppDataPtr->hasDemandVolBeenSet();

  // increment the demandVol timeVec for wit
  demandVolTVF[requestPeriod] += demandQty;


  // store away the original demandVol (with negatives)
  demandAppDataPtr->demandVol(demandVolTVF);
  demandAppDataPtr->hasDemandVolBeenSet(1);

  // DEMAND2ORDER
  // save the request date
  demandAppDataPtr->requestDate(requestDate);
  



  // ENABLE_NEGATIVE_DEMANDS
  // must strip out any negative demandVol qty's before feeding to WIT
  // FINISH_ME: we can be smarter here.  Directly interrogate the qty as we get it.
  //            if it's negative do something with it directly. ?!?!?
  // FINISH_ME: How do we detect if multiple demandVol recs remove negatives?
  // Perhaps we should move the setting of doesPartHaveNegativeDemands to a
  // pre processing step
  for ( t=0; t<nPeriods; t++) {
    if (demandVolTVF[t] < 0.0) {
      demandVolTVF[t] = 0.0;
    }
  }
  witSetDemandDemandVol(theWitRun, fullWitPart.c_str(), demandName.c_str(), demandVolTVF.data());

  return 1;
}
 

// --------------------------------------------------------------------- 
// time for the big Merge ... come here when you detect a TINP demand Vol
// this sets up the GPD bom structure
int 
LgFrInitialProblemForSce::addGeoSourceAndDemandVolFromTINP(
					       WitRun * const theWitRun,
					       const std::string &  dataLine,
					       const std::string &  plannerPartName,
					       const std::string &  geoPreD20,
					       const std::string &  pdf,
					       const std::string & requestDate,
					       float demandQty,
					       const std::string & fileName,
					       const long  lineNo,
					       const LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();

  LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();   

  std::string engine = setOfParameters.getString("engine");
    
  long numAddedParts = 0; // this is the return value

  int early = 0;
  int late = nPeriods - 1;
  float transitTime = 0.0;
  int result = 0;

  float * demandVol;

  
  // see what period it falls in
  // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
  // NOTE: you can also use roundedPeriod() 

  // ++++ >>>  Let's see, how many ways can we read a date?
  //  - Straight from calendar.   Maybe we need an SCE calendar manager who sets it up.
  //  - 
  // 
  

  //            ==============================
  //            !!!!  DATE CONSOLIDATION   !!! 
  //            ==============================
  // Things to think about when reading dates:
  //   1. which period do you map it to when it's in the middle somewhere (deal with this in BOM)
  //   2. Dates that fall earlier/later than horizon.
  //   3. LgFrDateTime might be good object to use ... can it be portable to granularity less than days??
  //   4. 
  // SCE Date Methods: 
  //       int requestPeriod = theCal.period(requestDate);  
  //            used by: processSupplyFile


  // see what period it falls in
  // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
  // NOTE: you can also use roundedPeriod() 
  int requestPeriod = theCal.period(requestDate);  
  if (requestPeriod >= nPeriods)  {
    (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() 
		   << fileName << (int)lineNo << dataLine);
    return 0;
  }
  if (requestPeriod < 0)  {
    (*theErrFacil)("DatedRecordBeforeHorizonStartIgnore",MclArgList() 
		   << fileName << (int)lineNo << dataLine);
    return 0;
  }



  // D2O 
  // Append the RequestDate onto the demand key to enforce period uniqueness
  std::string geo = mpHelper.expandDemandKeyforD2O(geoPreD20, requestDate, pdf);
  
  
  // make valid wit part numbers for these dudes
  std::string geoPlannerDemandPartName = mpHelper.geoPlannerDemandPartName(plannerPartName, geo);
  std::string pdfPartname = mpHelper.pdfPartname(plannerPartName, pdf);
  
  // first check to see if the child exists  
  // Note this routine need s to be finished and extended to
  // allow for DEFAULT  sourcing rules
  if (! mpHelper.isPartValid(theWitRun, pdfPartname, 
			     fileName, dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("UnknownMfgPartPDFPair",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    return 0;
  }


  
  
  // Now analyze the Demand,GEO.  
  // If a "part" already exists then ok,
  // otherwise, create a part and add it to the WIT Run.
  int geoPlannerPartAlreadyExist = mpHelper.isPartValid(theWitRun, 
							geoPlannerDemandPartName, 
							fileName, dataLine, lineNo, PURELY_OPTIONAL);
  
  if (! geoPlannerPartAlreadyExist)  {
    result = sceAddPartToRepresentDemand(theWitRun, geoPlannerDemandPartName, mpHelper, 
					 fileName, dataLine, lineNo);
    numAddedParts++;
    
    if (engine == "optimization") {
      // Only need to do this when using optimization          
      std::string geoPlannerDemandUbPartName = mpHelper.geoPlannerDemandUbPartName(geoPlannerDemandPartName, geo);
      
      result = sceAddPartToRepresentDemandUpperBound(theWitRun, geoPlannerDemandUbPartName, mpHelper, 
						     fileName, dataLine, lineNo);
      
      result = sceAddDemandUbBomStructure(theWitRun, mpHelper,
					  geoPlannerDemandPartName, geoPlannerDemandUbPartName,
					  fileName, dataLine, lineNo);
    }
    
  }
  
  // Now add a bill record from the the dummy demand part 
  // to the real part
  // taking into account the effectivity
  sceAddDemandBomStructure(theWitRun, mpHelper, theCal,
			   geoPlannerDemandPartName, pdfPartname,
			   early, late, transitTime,
			   fileName, dataLine, lineNo);


  // +++++++++++++++++++++
  int doesTheGpd_DEMAND_Exist = doesDemandExist(theWitRun, geoPlannerDemandPartName, geo);

  if (! doesTheGpd_DEMAND_Exist) {
    // regardless of engine, load the priorities and shipLateLimit
    // get the default priority
    int defaultPriority = heurModelHelper_->defaultPriority();
    int   * defaultPriorityVec = new int[nPeriods];
    int t=0;
    for (t=0; t<nPeriods; t++) {
      defaultPriorityVec[t] = 1000000000 - (int) defaultPriority;
    }
    // get the default shipLateLimit
    int defaultShipLateLimit = heurModelHelper_->defaultShipLateLimit();
    witAddDemand( theWitRun, geoPlannerDemandPartName.c_str(), geo.c_str() );
    // create a default demand app data for this demand, with  hasDemandVolBeenSet=0 and  backlogYield= 1.0
    LgFrSceDemandAppData * demandAppDataPtr = new LgFrSceDemandAppData (0, 0, (size_t) nPeriods, 1.0);  
    witSetDemandAppData(theWitRun,
			geoPlannerDemandPartName.c_str(), 
			geo.c_str(), 
			(void *) demandAppDataPtr);
    
    witSetDemandPriority( theWitRun, geoPlannerDemandPartName.c_str(),
			  geo.c_str(), defaultPriorityVec );
    witSetDemandShipLateLimit( theWitRun, geoPlannerDemandPartName.c_str(),
			       geo.c_str(), defaultShipLateLimit );
    delete [] defaultPriorityVec;
    
    // but only load the obj1 values if we have too      
    if ( lpModelHelper_ != 0 ) {
      // get the default Obj1 Ship Reward
      float defaultObj1ShipReward = lpModelHelper_->defaultObj1ShipReward();
      
      // get the periodic Interest Rate
      float periodicInterestRate = lpModelHelper_->periodicInterestRate();
      
      float * defaultObj1ShipRewardVec = new float[nPeriods];
      float * defaultObj1CumShipRewardVec = new float[nPeriods];
      
      // make time vecs from scalars
      for (t=0; t<nPeriods; t++) {
	defaultObj1ShipRewardVec[t] = defaultObj1ShipReward;
	defaultObj1CumShipRewardVec[t] = defaultObj1ShipReward * 
	  periodicInterestRate;
      }
      
      witSetDemandObj1ShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                    geo.c_str(), defaultObj1ShipRewardVec);
      witSetDemandObj1CumShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
				     geo.c_str(), defaultObj1CumShipRewardVec);
      delete [] defaultObj1ShipRewardVec;
      delete [] defaultObj1CumShipRewardVec;
    }
  }
  // +++++++++++++++++++++
    
  witGetDemandDemandVol(theWitRun, geoPlannerDemandPartName.c_str(), 
			geo.c_str(), &demandVol);

  // get the  demand app data for this demand.  get the hasDemandVolBeenSet
  LgFrSceDemandAppData * demandAppDataPtr;
  witGetDemandAppData(theWitRun,
		      geoPlannerDemandPartName.c_str(), 
		      geo.c_str(),
		      (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
  int hasDemandVolBeenSet = demandAppDataPtr->hasDemandVolBeenSet();
  
  
  // note: duplicate demandVol records are incremental!!
  // print a warning when detected
  demandVol[requestPeriod] += demandQty;


  if (hasDemandVolBeenSet) {
    std::string pnm = mpHelper.partname(geoPlannerDemandPartName);
    std::string pdfff = mpHelper.pdf(geoPlannerDemandPartName);
    (*theErrFacil)("MultipleDemandVolRecs",MclArgList() 
		   << fileName 
		   << (int) lineNo 
		   << pnm 
		   << pdfff);
  }
  
  witSetDemandDemandVol(theWitRun, geoPlannerDemandPartName.c_str(), geo.c_str(), demandVol);
  // set the hasDemandVolBeenSet to true
  demandAppDataPtr->hasDemandVolBeenSet(1);

  // DEMAND2ORDER
  // save the request date
  demandAppDataPtr->requestDate(requestDate);
  
  witFree(demandVol);

  return 1;

}






// ---------------------------------------------------------
void
LgFrInitialProblemForSce::process61TopLevelToOptionalFeatureFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  // This method just reads the file and passes all logic to either
  LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();
  int result;

  // Note, we'll be setting negative production costs which
  // causes a Wit warning message. Suppress it.
  witSetMesgTimesPrint(theWitRun, WitTRUE, 605, 0);


  // attributes to read off file
  std::string dataLine;

  std::string plannerTopLevelPart;
  std::string sourceLoc;
  std::string geoPreD20;
  std::string mfgOptionPart;
  std::string requestDate;
  float       usageRate;
  float       attachRate;
  float       mwoVal;
  float       mfOffsetVal;
  int         mfoPhantomFlag;
  float       mfSupplyVal;
  int         earlyPeriod;
  int         latePeriod;
  
  
  std::string geo;  
  int requestPeriod;  
  
  float * defaultGatingOptionSubPenalty = new float[nPeriods];
  
  LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();
    
  float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");
  
  int tt = 0;
  for (tt=0; tt<nPeriods; tt++)
    defaultGatingOptionSubPenalty[tt] = defaultOptionShipReward;

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
  
  this->openInputFileAndScrubOutputFile(fileName, "Top Level to Optional Feature", inFile, outFile, myScrubber, theErrFacil);
  
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;
  long lineNo = 0;

  while(inFile.peek() != EOF) {

    // read the next record
    std::getline( inFile, dataLine );
    lineNo++;
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }
    SCETokenizer next(dataLine);

    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    sourceLoc = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    geoPreD20 = flatFileManager.nextQuotedDemandString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
    if (result == -1) { badCount++; continue; }

    // requestDate and usageRate
    bool dieIfErrorFlag = true;
    result = flatFileManager.readDatedDemandFloatRecord(usageRate, requestDate, dieIfErrorFlag, -FLT_MAX, FLT_MAX,
							next, fileName, dataLine, lineNo, mpHelper, theCal);
    

    // Map requestDate to requestPeriod
    // rule: reject early 
    // rule: reject late
    requestPeriod = theCal.period(requestDate);  
    if (requestPeriod >= nPeriods)  {
      (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
      badCount++; continue; }
    if (requestPeriod < 0)  {
      (*theErrFacil)("DatedRecordBeforeHorizonStartIgnore",MclArgList() << fileName << (int)lineNo << dataLine);
      badCount++; continue; }


    // attachRate 
    result = flatFileManager.nextFloat(attachRate, next, fileName, dataLine, lineNo, false, 0.0);
    if (result == -1) { badCount++; continue; }
    // maxWithOut Value must  be between -1 and +1
    result = flatFileManager.nextFloat(mwoVal, next, fileName, dataLine, lineNo, false, -1.0, 1.0);
    if (result == -1) { badCount++; continue; }
    // mfOffset
    result = flatFileManager.nextFloat(mfOffsetVal, next, fileName, dataLine, lineNo, false, -FLT_MAX, FLT_MAX);
    if (result == -1) { badCount++; continue; }
    // featurePhantomFlag
    result = flatFileManager.nextInt(mfoPhantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);
    if (result == -1) { badCount++; continue; }
    // mfSupply
    result = flatFileManager.nextFloat(mfSupplyVal, next, fileName, dataLine, lineNo, false, 0, FLT_MAX);
    if (result == -1) { badCount++; continue; }
    
    // effectivity Dates: earlyPeriod, latePeriod
    result = flatFileManager.nextStartEndDates(earlyPeriod, latePeriod, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) { badCount++; continue; }

    // FINISH_ME_61: Is this the right rule ??
    if ((earlyPeriod == nPeriods) || (latePeriod < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "Featratio entry ignored.");
      badCount++; continue; }


    // D2O 
    // Append the RequestDate onto the demand key to enforce period uniqueness
    geo = mpHelper.expandDemandKeyforD2O(geoPreD20, requestDate, sourceLoc);




    // Analyze maxWithout to determine what kind of standalone feature we have:
    // it must be one of:
    //     SCE_FEATURE_TYPE_CUSTOMER_CHOICE
    //     SCE_FEATURE_TYPE_PURELY_OPTIONAL
    //     SCE_FEATURE_TYPE_MANDATORY
    //     SCE_FEATURE_TYPE_MWO
    int featureType;
    if (mwoVal < -IPSCE_FLT_EPS) 
      featureType = SCE_FEATURE_TYPE_CUSTOMER_CHOICE;
    else if (mwoVal < IPSCE_FLT_EPS)
      featureType = SCE_FEATURE_TYPE_MANDATORY;
    else if (mwoVal < 1.0 - IPSCE_FLT_EPS)
      featureType = SCE_FEATURE_TYPE_MWO;
    else
      featureType = SCE_FEATURE_TYPE_PURELY_OPTIONAL;



    if (featureType == SCE_FEATURE_TYPE_CUSTOMER_CHOICE)
      result = sceAddCustChoiceFeatureStructure61(theWitRun, mpHelper, theCal,
						  plannerTopLevelPart, geo, mfgOptionPart,
						  usageRate, attachRate, 
						  mfOffsetVal, mfoPhantomFlag, mfSupplyVal,
						  earlyPeriod, latePeriod,
						  defaultGatingOptionSubPenalty, fileName, dataLine, lineNo);
      
  
    else       
      result = sceAddStdAloneOptionBomStructure61(theWitRun, mpHelper, theCal,
						  plannerTopLevelPart, geo, mfgOptionPart,
						  usageRate, attachRate, mwoVal,
						  mfOffsetVal, mfoPhantomFlag, mfSupplyVal,
						  defaultGatingOptionSubPenalty, 
						  earlyPeriod, latePeriod, featureType,
						  fileName, dataLine, lineNo);
   


      
    // increment the feature counter 
    if (! result)
      sceScenario()->incrementStandaloneFeatureArcs();


    if (! result)
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else
      badCount++;
  }

 std::cout << recCount << " records processed." << std::endl;

 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);

 delete [] defaultGatingOptionSubPenalty;
 // turn message 605 back on.
 witSetMesgTimesPrint(theWitRun, WitTRUE, 605, UCHAR_MAX); 
 
}







// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processGeoSourceFile(
					       WitRun * const theWitRun,
					       const std::string & geoSourceFile,
					       const LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  int nPeriods = theCal.nPeriods();
  // read source file 
  
  long lineNo = 0;

  LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();   
  // get the engine
  std::string engine = setOfParameters.getString("engine");
    
  std::string fileName(geoSourceFile);

  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("WarningCannotOpenFile",MclArgList() 
		   << "geoSourceFile" 
		   << fileName 
		   << "Will attempt to source parts to the default PDF.");
    return;
  }
  inFile.close();
    
  this->openInputFileAndScrubOutputFile(fileName,
					"geo source file",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);

  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;    
  long numAddedParts = 0; // this is to count parts added to wit run





  std::string dataLine;
  std::string plannerPartName;
  std::string geo;
  std::string partName;
  std::string pdf;
  int early = 0;
  int late = nPeriods - 1;
  float transitTime = 0.0;


 
  while(inFile.peek() != EOF) {
    int result = 0;
 
    // Read next line of file
    std::getline( inFile, dataLine );
    lineNo ++;

    //  skip blanks or comments '*'
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }

    // check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }
        
    // construct a tokenizer
    SCETokenizer next(dataLine);

    // get the plannerPartName
    plannerPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
    if (result < 0) {
      badCount++;
      continue;
    }

    // get the geo 
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

    // get the partName
    partName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

    // get the pdf
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

    // now get the effectivity dates
    result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int)lineNo << dataLine << "entry ignored.");
      badCount++;
      continue;
    }

    // this is where i am



    flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);

#ifndef VARIABLE_PERIODS
    // scale the transit time ... (leave it unscaled with Variable Periods
    transitTime = transitTime / theCal.workUnits(early);
#endif
	
    // make valid wit part numbers for these dudes
    std::string geoPlannerDemandPartName = 
      mpHelper.geoPlannerDemandPartName(plannerPartName, geo);
    std::string pdfPartname = mpHelper.pdfPartname(partName, pdf);
	
    // first check to see if the child exists  
    // Note this routine need s to be finished and extended to
    // allow for DEFAULT  sourcing rules
    if (! mpHelper.isPartValid(theWitRun, pdfPartname, 
			       fileName, dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("UnknownMfgPartPDFPair",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      badCount++;
      continue;
    }
    

    // Now analyze the Demand,GEO.  
    // If a "part" already exists then ok,
    // otherwise, create a part and add it to the WIT Run.

    int geoPlannerPartAlreadyExist = mpHelper.isPartValid(theWitRun, 
							  geoPlannerDemandPartName, 
							  fileName, dataLine, lineNo, PURELY_OPTIONAL);
    
    if (! geoPlannerPartAlreadyExist)  {
      result = sceAddPartToRepresentDemand(theWitRun, geoPlannerDemandPartName, mpHelper, 
					   fileName, dataLine, lineNo);
      numAddedParts++;

      if (engine == "optimization") {
	// Only need to do this when using optimization          
	std::string geoPlannerDemandUbPartName = mpHelper.geoPlannerDemandUbPartName(plannerPartName, geo);
            
	result = sceAddPartToRepresentDemandUpperBound(theWitRun, geoPlannerDemandUbPartName, mpHelper, 
						       fileName, dataLine, lineNo);
            
	result = sceAddDemandUbBomStructure(theWitRun, mpHelper,
					    geoPlannerDemandPartName, geoPlannerDemandUbPartName,
					    fileName, dataLine, lineNo);
      }
	  
    }
	
    // Now add a bill record from the the dummy demand part 
    // to the real part
    // taking into account the effectivity
    sceAddDemandBomStructure(theWitRun, mpHelper, theCal,
			     geoPlannerDemandPartName, pdfPartname,
			     early, late, transitTime,
			     fileName, dataLine, lineNo);
	
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
	outFile << dataLine << std::endl;
  }

  inFile.close();
  outFile.close();
  std::cout << recCount << " records processed." << std::endl;

  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,numAddedParts);
}




// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processOperationDefinitionFile(
    
    WitRun * const theWitRun,   
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

    std::string operationName;
    std::string pdf;
    std::string dataLine;

    LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();
    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    int result;

    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();

    this->openInputFileAndScrubOutputFile(fileName,
					  "operation definition",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);

    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;

    long lineNo = 0;
    while(inFile.peek() != EOF) {
	std::getline( inFile, dataLine );
	lineNo++;

//  skip blanks or comments *
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
	}

// check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
        }

        
	SCETokenizer next(dataLine);

// get the operation name
        operationName = flatFileManager.nextQuotedString(
                next, result, fileName, dataLine, 
		lineNo, PURELY_OPTIONAL);
	pdf = flatFileManager.nextQuotedString(
	        next, result, fileName, dataLine, lineNo, MANDATORY);



// =======================
// Now add the operation
// =======================

// ===================================
// == Only User-defined operations get read here
// ===================================
        result = sceAddNormalOperation(theWitRun, 
                                 operationName, 
                                 pdf, 
                                 mpHelper, 
                                 fileName, 
                                 dataLine,
                                 lineNo);
	
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }

	else
	    badCount++;
    }

    std::cout << recCount << " records processed." << std::endl;
    inFile.close();
    outFile.close();
    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}


//  ---------------------------------------------------------------
int  
LgFrInitialProblemForSce::readCsvDemandFloatVector(
                     WitRun * const theWitRun,         // WIT environment    
                     const int nPeriods,               // Number of periods  
                     std::string & geoPlannerDemandPartName,   // special partname for  this demand
                     std::string & geo,                  // demandName to be returned
                     float *  floatVec,                // floatVector to be returned
                     std::ifstream & inFile,                 // An open stream
                     const std::string & fileName,       // for messaging
                     std::string & dataLine,
                     long & lineNo,
                     LgFrMultiPlantHelper & mpHelper,
                     bool Mandatory,              // Are all elements mandatory?
                     float lowerLimit,                 // data lower limits
                     float upperLimit,                 // data upper limits
                     bool addDemandIfFound)       // Add demand stream if not there
{
  std::string plannerPartName;
  int t = 0;
  int result = 0;
 
  // Read next line of file
  std::getline( inFile, dataLine );
  lineNo ++;

  dataLine = sce::strip( dataLine );

  //  skip blanks or comments '*'
  if ((dataLine[0] == '*') || dataLine.empty())
    return -2;


  // construct a tokenizer
  SCETokenizer next(dataLine);
  
  // get a reference to the flat file manager and 
  // check if the line contains any illegal characters
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  if ( flatFileManager.containsIllegalCharacters( dataLine )) {
    (*theErrFacil)("IllegalCharacter",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
  }

  
  // get the partname
  plannerPartName = flatFileManager.nextQuotedString(next, result, fileName, 
                                     dataLine, lineNo, 
                                     OPTIONAL_WITH_MESSAGE);

  // get the geo
  geo = flatFileManager.nextQuotedString(next, result, fileName, 
                         dataLine, lineNo, MANDATORY);

  // Get the unique special geoPlannerDemandPartName for this pair
  geoPlannerDemandPartName = mpHelper.geoPlannerDemandPartName(plannerPartName, geo);


  // If the  specialgeoPlannerDemandPart name is not a WIT part 
  // (ie, the source for this GEO is not known), then attempt to source
  // it to a pdf_PartName as follows:
  //         Set:      mfgPartName = plannerPartName
  //                   pdf         = defaultPdf

  int readCsvMessage = OPTIONAL_WITH_MESSAGE;
  if (addDemandIfFound)
    readCsvMessage = PURELY_OPTIONAL;

  int doesTheGpd_PART_Exist = mpHelper.isPartValid(theWitRun, 
						   geoPlannerDemandPartName, 
						   fileName, dataLine, lineNo, PURELY_OPTIONAL);
  
  if (! doesTheGpd_PART_Exist)  {
    (*theErrFacil)("CannotSourceDemandRecord",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerPartName 
		   << geo 
		   << geoPlannerDemandPartName  
		   << dataLine);
    return 0;
  }

  int doesTheGpd_DEMAND_Exist = doesDemandExist(theWitRun, geoPlannerDemandPartName, geo);

  if (! doesTheGpd_DEMAND_Exist) {
    if (addDemandIfFound){
      // regardless of engine, load the priorities and shipLateLimit
      // get the default priority
      int defaultPriority = heurModelHelper_->defaultPriority();
      int   * defaultPriorityVec = new int[nPeriods];
      for (t=0; t<nPeriods; t++) {
	defaultPriorityVec[t] = 1000000000 - (int) defaultPriority;
      }
      // get the default shipLateLimit
      int defaultShipLateLimit = heurModelHelper_->defaultShipLateLimit();
      witAddDemand( theWitRun, geoPlannerDemandPartName.c_str(), geo.c_str() );
      // create a default demand app data for this demand, with  hasDemandVolBeenSet=0 and  backlogYield= 1.0
      LgFrSceDemandAppData * demandAppDataPtr = new LgFrSceDemandAppData (0, 0, (size_t) nPeriods, 1.0);  
      witSetDemandAppData(theWitRun,
                          geoPlannerDemandPartName.c_str(), 
                          geo.c_str(), 
                          (void *) demandAppDataPtr);

      witSetDemandPriority( theWitRun, geoPlannerDemandPartName.c_str(),
                            geo.c_str(), defaultPriorityVec );
      witSetDemandShipLateLimit( theWitRun, geoPlannerDemandPartName.c_str(),
                                 geo.c_str(), defaultShipLateLimit );
      delete [] defaultPriorityVec;

      // but only load the obj1 values if we have too      
      if ( lpModelHelper_ != 0 ) {
        // get the default Obj1 Ship Reward
        float defaultObj1ShipReward = lpModelHelper_->defaultObj1ShipReward();

        // get the periodic Interest Rate
        float periodicInterestRate = lpModelHelper_->periodicInterestRate();

        float * defaultObj1ShipRewardVec = new float[nPeriods];
        float * defaultObj1CumShipRewardVec = new float[nPeriods];

        // make time vecs from scalars
        for (t=0; t<nPeriods; t++) {
          defaultObj1ShipRewardVec[t] = defaultObj1ShipReward;
          defaultObj1CumShipRewardVec[t] = defaultObj1ShipReward * 
            periodicInterestRate;
        }

        witSetDemandObj1ShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                    geo.c_str(), defaultObj1ShipRewardVec);
        witSetDemandObj1CumShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                       geo.c_str(), defaultObj1CumShipRewardVec);
        delete [] defaultObj1ShipRewardVec;
        delete [] defaultObj1CumShipRewardVec;
      }

    }
    else  {
      (*theErrFacil)("CannotSourceDemandRecord",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerPartName 
		     << geo 
		     << geoPlannerDemandPartName
		     << dataLine);
      return 0;
    }

  }


  // Now get the data
  for (t = 0; t<nPeriods; t++) {
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false);
    if (result == -1) 
      return t;
  }

  return t;

}

//  ---------------------------------------------------------------
int  
LgFrInitialProblemForSce::readCsvDemandFloatScalar(
                     WitRun * const theWitRun,         // WIT environment    
                     const int nPeriods,               // Number of periods  
                     std::string & geoPlannerDemandPartName,   // special partname for  this demand
                     std::string & geo,                  // demandName to be returned
                     float theValue,                // float to be returned
                     std::ifstream & inFile,                 // An open stream
                     const std::string & fileName,       // for messaging
                     std::string & dataLine,
                     long & lineNo,
                     LgFrMultiPlantHelper & mpHelper,
                     bool Mandatory,              // Are all elements mandatory?
                     float lowerLimit,                 // data lower limits
                     float upperLimit,                 // data upper limits
                     bool addDemandIfFound)       // Add demand stream if not there
{
  std::string plannerPartName;
  int t = 0;
  int result = 0;
 
  // Read next line of file
  std::getline( inFile, dataLine );
  lineNo ++;

  dataLine = sce::strip( dataLine );

  //  skip blanks or comments '*'
  if ((dataLine[0] == '*') || dataLine.empty())
    return -2;


  // construct a tokenizer
  SCETokenizer next(dataLine);
  
  // get a reference to the flat file manager and 
  // check if the line contains any illegal characters
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  if ( flatFileManager.containsIllegalCharacters( dataLine )) {
    (*theErrFacil)("IllegalCharacter",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
  }

  
  // get the partname
  plannerPartName = flatFileManager.nextQuotedString(next, result, fileName, 
                                     dataLine, lineNo, 
                                     OPTIONAL_WITH_MESSAGE);

  // get the geo
  geo = flatFileManager.nextQuotedString(next, result, fileName, 
                         dataLine, lineNo, MANDATORY);

  // Get the unique special geoPlannerDemandPartName for this pair
  geoPlannerDemandPartName = mpHelper.geoPlannerDemandPartName(plannerPartName, geo);


  // If the  specialgeoPlannerDemandPart name is not a WIT part 
  // (ie, the source for this GEO is not known), then attempt to source
  // it to a pdf_PartName as follows:
  //         Set:      mfgPartName = plannerPartName
  //                   pdf         = defaultPdf

  int readCsvMessage = OPTIONAL_WITH_MESSAGE;
  if (addDemandIfFound)
    readCsvMessage = PURELY_OPTIONAL;

  int doesTheGpd_PART_Exist = mpHelper.isPartValid(theWitRun, 
						   geoPlannerDemandPartName, 
						   fileName, dataLine, lineNo, PURELY_OPTIONAL);
  
  if (! doesTheGpd_PART_Exist)  {
    (*theErrFacil)("CannotSourceDemandRecord",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerPartName 
		   << geo 
		   << geoPlannerDemandPartName  
		   << dataLine);
    return 0;
  }

  int doesTheGpd_DEMAND_Exist = doesDemandExist(theWitRun, geoPlannerDemandPartName, geo);

  if (! doesTheGpd_DEMAND_Exist) {
    if (addDemandIfFound){
      // regardless of engine, load the priorities and shipLateLimit
      // get the default priority
      int defaultPriority = heurModelHelper_->defaultPriority();
      int   * defaultPriorityVec = new int[nPeriods];
      for (t=0; t<nPeriods; t++) {
	defaultPriorityVec[t] = 1000000000 - (int) defaultPriority;
      }
      // get the default shipLateLimit
      int defaultShipLateLimit = heurModelHelper_->defaultShipLateLimit();
      witAddDemand( theWitRun, geoPlannerDemandPartName.c_str(), geo.c_str() );
      // create a default demand app data for this demand, with  hasDemandVolBeenSet=0 and  backlogYield= 1.0
      LgFrSceDemandAppData * demandAppDataPtr = new LgFrSceDemandAppData (0, 0, (size_t) nPeriods, 1.0);  
      witSetDemandAppData(theWitRun,
                          geoPlannerDemandPartName.c_str(), 
                          geo.c_str(), 
                          (void *) demandAppDataPtr);

      witSetDemandPriority( theWitRun, geoPlannerDemandPartName.c_str(),
                            geo.c_str(), defaultPriorityVec );
      witSetDemandShipLateLimit( theWitRun, geoPlannerDemandPartName.c_str(),
                                 geo.c_str(), defaultShipLateLimit );
      delete [] defaultPriorityVec;

      // but only load the obj1 values if we have too      
      if ( lpModelHelper_ != 0 ) {
        // get the default Obj1 Ship Reward
        float defaultObj1ShipReward = lpModelHelper_->defaultObj1ShipReward();

        // get the periodic Interest Rate
        float periodicInterestRate = lpModelHelper_->periodicInterestRate();

        float * defaultObj1ShipRewardVec = new float[nPeriods];
        float * defaultObj1CumShipRewardVec = new float[nPeriods];

        // make time vecs from scalars
        for (t=0; t<nPeriods; t++) {
          defaultObj1ShipRewardVec[t] = defaultObj1ShipReward;
          defaultObj1CumShipRewardVec[t] = defaultObj1ShipReward * 
            periodicInterestRate;
        }

        witSetDemandObj1ShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                    geo.c_str(), defaultObj1ShipRewardVec);
        witSetDemandObj1CumShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                       geo.c_str(), defaultObj1CumShipRewardVec);
        delete [] defaultObj1ShipRewardVec;
        delete [] defaultObj1CumShipRewardVec;
      }

    }
    else  {
      (*theErrFacil)("CannotSourceDemandRecord",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerPartName 
		     << geo 
		     << geoPlannerDemandPartName
		     << dataLine);
      return 0;
    }

  }


  // Now get the data
  result = flatFileManager.nextFloat(theValue, next, fileName, dataLine, lineNo, false);
  if (result == -1) 
    return 0;
  
  
  return 1;

}




// ---------------------------------------------------------------
bool
LgFrInitialProblemForSce::doesInputFileExist(
    const std::string & targetFile)
{
    std::ifstream inFile;

    inFile.open(targetFile.c_str());

    if (inFile)  {
	inFile.close();
	return true;
    }

    return false;
}


// --------------------------------------------------------------- 
//           Test to see if a PART,DEMAND pair exists              
// ---------------------------------------------------------------
int 
LgFrInitialProblemForSce::doesDemandExist(
    WitRun * const theWitRun,       
    const std::string &  partName,
    const std::string &  demandName)

{
  int nDemands;                         // Number of demands on part
  char ** demandList;                   // List of demands on part  
  int j;
  witBoolean exists;
  int result;

  witGetPartExists(theWitRun, partName.c_str(), &exists);
  if (exists == WitFALSE)  
    return 0;

  //  Get list of demands defined for part. 
  witGetPartDemands(theWitRun, partName.c_str(), &nDemands, &demandList);

  // Loop thru this parts demands until we find one that 
  // matches demandName 
  result = 0;
  for ( j=0; j<nDemands; j++ ) {
    if (demandName != demandList[j])
      continue;
    result = 1;
    break;
  }
 
  // free demand list storage   
  for (j=0; j<nDemands; j++)  
    witFree(demandList[j]);
  witFree(demandList);

  return result;
}


// ============================================================
// ============================================================
// =========(this is sceInitAdvanced.C ========================


// Add part and any attributes to wit for NORMAL parts
// Return --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddNormalPart(
    WitRun * const theWitRun, 
    const std::string & part, 
    const std::string & pdf,
    const bool buildNstn,
    const int * buildAheadUB,
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string partName = mpHelper.pdfPartname(part, pdf);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    // check to see if the part has already been defined
    if (mpHelper.isPartValid(theWitRun, partName, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("AlreadyDefined",MclArgList() 
		     << partName 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      return -1;
    }
    
    // put a small prodCost in for every part that is slightly
    // decreasing over time.  It's a FINISH_ME to both implement
    // a better (ie, exponential) curve, and, a more efficient method
    // so that we don't have to new and delete a vector for every part.
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    
    witAddPartWithOperation(theWitRun, partName.c_str());
    
    // regardless of engine, load the BopAppData with the preference
    float preference = heurModelHelper_->defaultDefaultBopPreference ();
    LgFrSceBopAppData * myBadPtr; // my "b"op "a"pp "d"ata ptr
    myBadPtr = new LgFrSceBopAppData (preference, 1, 0);  
    assert ( myBadPtr != 0 );
    witSetBopEntryAppData( theWitRun, partName.c_str(), 0, (void *) myBadPtr );
    
    
    // set default inc and min lot sizes to 1.0.
    float * vecOfOnes = new float[nPeriods];
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
      vecOfOnes[t] = 1.0;
    
    witSetOperationIncLotSize(theWitRun, partName.c_str(), vecOfOnes);
    witSetOperationMinLotSize(theWitRun, partName.c_str(), vecOfOnes);
    delete [] vecOfOnes;
    
    // but only set LP coeficients only if engine = optimization
    // Multi-critera note:  why not move this to lpModelHelper 
    if (lpModelHelper_ != 0) {
      // we'll reuse this generic cost vector
      float * obj1CostVec = new float[nPeriods];

      // set the default Exec Cost on default operations
      float defaultObj1ProdCostRealParts = lpModelHelper_->defaultObj1ProdCostRealParts();
      float obj1ProdCostDiscRateRealParts = lpModelHelper_->obj1ProdCostDiscRateRealParts();      
      obj1CostVec[0] = defaultObj1ProdCostRealParts;
      int t = 0; 
      for (t=1; t<nPeriods; t++)
        obj1CostVec[t] = obj1CostVec[t-1] - obj1ProdCostDiscRateRealParts;
      witSetOperationObj1ExecCost(theWitRun, partName.c_str(), obj1CostVec);

      // this is really only used for GPS.   They set it really high and it blocks all stock.
      float obj1DefaultStockCostRealParts = lpModelHelper_->obj1DefaultStockCostRealParts();      
      for (t=0; t<nPeriods; t++)      
        obj1CostVec[t] = obj1DefaultStockCostRealParts;
      witSetPartStockCost(theWitRun, partName.c_str(), obj1CostVec);
      
      delete [] obj1CostVec;
    }
    
    
    // now set buildahead things
    // fix for 4.30.   This is legacy.   
    // In 4.30, user's can set by partnumber, and, can set to either NSTN or ASAP
    // SCE6.0 fix this.   either get rid of NSTN or override with ASAP/NSTN by guildAhead.
    witSetPartBuildNstn(theWitRun, partName.c_str(), buildNstn);
    if (buildNstn) 
      witSetPartBuildAheadUB(theWitRun, partName.c_str(), buildAheadUB);

    return 0;
}



// Add part and any attributes to wit for NORMAL parts
// Return --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddNormalCapacityPart(
    WitRun * const theWitRun, 
    const std::string & capacity, 
    const std::string & pdf,
    const int & mandatoryCapacityFlag,
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string capacityName = mpHelper.pdfPartname(capacity, pdf);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

// check to see if the part has already been defined
    if (mpHelper.isPartValid(theWitRun, capacityName, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("AlreadyDefined",MclArgList() << capacityName << fileName << (int)lineNo << dataLine);

	return -1;
    }
    
    witAddPart(theWitRun, capacityName.c_str(), WitCAPACITY);

    // Add the operation to Generate Capacity (regardless of whether it's mandatory or not)
    std::string capGeneratorOperationName = mpHelper.operationForCapacityGeneration(capacityName.c_str());
    witAddOperation(theWitRun, capGeneratorOperationName.c_str());
    if (mandatoryCapacityFlag) {
      int nPeriods;
      witGetNPeriods(theWitRun, &nPeriods);
      LgFrTimeVecFloat zeroYieldRate(nPeriods, 0.0);
      witSetOperationYieldRate(theWitRun, capGeneratorOperationName.c_str(), zeroYieldRate.data());
    }

    witAddBopEntry(theWitRun, capGeneratorOperationName.c_str(), capacityName.c_str());
    // for VCM
    witSetBopEntryExpAversion(theWitRun, capGeneratorOperationName.c_str(), 0, 9999999.9);

    return 0;
}


// Add operation and any default attributes
// to wit for NORMAL operation
// Return --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddNormalOperation(
    WitRun * const theWitRun, 
    const std::string & operationName, 
    const std::string & pdf,
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string pdfOperationName = mpHelper.pdfOperationName(operationName, pdf);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    // check to see if the operation has already been defined
    if (mpHelper.isOperationValid(theWitRun, pdfOperationName, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("AlreadyDefined",MclArgList() << operationName << fileName << (int)lineNo << dataLine);

	return -1;
    }

    // check to see if a pdf-part was given the same name as this pdf-operation
    if (!  mpHelper.isPdfOperationUnique(theWitRun, pdfOperationName, fileName, 
                                         dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("DuplicatePartPDFPairWarning",MclArgList() << pdfOperationName << fileName << (int)lineNo << dataLine);
        return -1;
    }
        
    // put a small execCost in for every part that is slightly
    // decreasing over time.  It's a FINISH_ME to both implement
    // a better (ie, exponential) curve, and, a more efficient method
    // so that we don't have to new and delete a vector for every part.
    // FINISH_ME: set up the LP cost model for operations
    witAddOperation(theWitRun, pdfOperationName.c_str());

    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    // set default lot sizes to 1.0.
    float * vecOfOnes = new float[nPeriods];
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
      vecOfOnes[t] = 1.0;
    witSetOperationMinLotSize(theWitRun, pdfOperationName.c_str(), vecOfOnes);
    witSetOperationIncLotSize(theWitRun, pdfOperationName.c_str(), vecOfOnes);
    delete [] vecOfOnes;
    
    if (lpModelHelper_ != 0) {
      float defaultObj1ExecCostRealOperations =
        lpModelHelper_->defaultObj1ExecCostRealOperations();
    
      float obj1ExecCostDiscRateRealOperations =
        lpModelHelper_->obj1ExecCostDiscRateRealOperations();      

      float * obj1ExecCost = new float[nPeriods];
      obj1ExecCost[0] = defaultObj1ExecCostRealOperations;
      
      for (t=1; t<nPeriods; t++)
        obj1ExecCost[t] = obj1ExecCost[t-1] - obj1ExecCostDiscRateRealOperations;

      witSetOperationObj1ExecCost(theWitRun, pdfOperationName.c_str(), obj1ExecCost);
 
      delete [] obj1ExecCost;
    }

    return 0;
}


// Add BOP entries and any default attributes
// to wit for NORMAL BOPs
// Return --->  0  if succesful
//             -1  if un-succesful with warning
//             +1  if un-sucessful & input record should be ignored
int
LgFrInitialProblemForSce::sceAddNormalBopStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & producedPart, 
    const std::string & producedPartPdf,
    const std::string & operation, 
    const std::string & operationPdf, 
    float prodRate,
    float offset,
    int early,
    int late,
    float pref,
    int isObjectInEffectForOptExplosion,
    int expAllowed,
    float pipShare,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    LgFrSceBopAppData * myBadPtr; // my "b"op "a"pp "d"ata ptr

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string pdfProducedPartName( mpHelper.pdfPartname(producedPart, producedPartPdf) );
    std::string pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );

    if (! mpHelper.isPartValid(theWitRun, producedPart, producedPartPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) 
      return 1;
    
    if (! mpHelper.isOperationValid(theWitRun, pdfOperationName, 
                                    fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) 
      return 1;




    int bopEntryIndex;
    witGetOperationNBopEntries( theWitRun, pdfOperationName.c_str(), &bopEntryIndex);

    
    // check to see if this operation is already "connected" to the produced part
    // we only do this to possibly increment the partAppdata for the pdfProducedPArt
    bool isOperationAlreadyUsedbyProducedPart = false;
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<bopEntryIndex; b++) {
      char * ppName;
      witGetBopEntryProducedPart(theWitRun, pdfOperationName.c_str(), b, &ppName);
      if (ppName == pdfProducedPartName) {
        isOperationAlreadyUsedbyProducedPart = true;
        witFree(ppName);
        break;
      }
      witFree(ppName);
    }
    // If this is a new User-defined Operation for the customer loc, increment
    // the nUserDefinedOps counter in the CustLoc Parts appdata.  (Being careful,
    // of course, to ensure the non-null-ness of the appDataPtr for the part
    if (! isOperationAlreadyUsedbyProducedPart) {
      LgFrScePartAppData * custPartAppData;
      witGetPartAppData(theWitRun, pdfProducedPartName.c_str(), (void **) &custPartAppData);
      if (custPartAppData == 0) {
	int nPeriods;
	witGetNPeriods(theWitRun, &nPeriods);
        custPartAppData = new LgFrScePartAppData(0, nPeriods, nPeriods);
        custPartAppData->nUserDefinedOps(1);
        witSetPartAppData(theWitRun, pdfProducedPartName.c_str(), (void *) custPartAppData);
      }
      else 
        custPartAppData->nUserDefinedOps(custPartAppData->nUserDefinedOps() + 1);
    }

    

      
    witAddBopEntry( theWitRun, pdfOperationName.c_str(), pdfProducedPartName.c_str() );
    witSetBopEntryProdRate( theWitRun, pdfOperationName.c_str(), bopEntryIndex, prodRate );

    float * offsetTimeVec;
    witGetBopEntryOffset( theWitRun, pdfOperationName.c_str(), bopEntryIndex, &offsetTimeVec );
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=early; i<=late; i++)
      offsetTimeVec[i] = offset;
    witSetBopEntryOffset( theWitRun, pdfOperationName.c_str(), bopEntryIndex, offsetTimeVec );
    witFree(offsetTimeVec);
    witSetBopEntryEarliestPeriod( theWitRun, pdfOperationName.c_str(), bopEntryIndex, early );
    witSetBopEntryLatestPeriod( theWitRun, pdfOperationName.c_str(), bopEntryIndex, late );

    // Put the preference/cost and explosion flag 
    // information into bopDemandAppData
    // bopAppVoidPtr should NOT be set in WIT -- double checking, just to be safe.
    // New some bopAppData calling the preferred constructor with the pref parameter.
    // Note: In the calling member function, pref is initialized with the
    // defaultExplicitBopPreferenence from the setOfParameters and
    // the explosionFlag is set to the default off.
    // FINISH_ME: set the explosionFlag default in the setOfParameters
    // FINISH_ME: see if the design can be improved so (1) we don't have to search for the 
    // default each and every time and (2) we can encapsulate/organize the LP vs Heur setup
    // and "helper" routines.
    
    witGetBopEntryAppData( theWitRun, pdfOperationName.c_str(), bopEntryIndex, (void **) &myBadPtr );
    if ( myBadPtr != 0 ) {
      (*theErrFacil)("InternalError2",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << producedPart 
		     << producedPartPdf 
		     << operation 
		     << dataLine);
    }
    
    myBadPtr = new LgFrSceBopAppData (pref, isObjectInEffectForOptExplosion, 0);  
    assert ( myBadPtr != 0 );
    witSetBopEntryAppData( theWitRun,
                           pdfOperationName.c_str(),
                           bopEntryIndex,
                           (void *) myBadPtr );

    // Added for 2.30
    //   witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, WitTRUE);
    // as of sce 3.11, this is now user setabble
    witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, expAllowed);
    witSetBopEntryExpAversion(theWitRun, pdfOperationName.c_str(), bopEntryIndex, pref);
    
#if 0 
    // pipshare is obsolete ... should remove everywhere 
    float * pipShareVec;
    witGetBopEntryPipShare( theWitRun, pdfOperationName.c_str(), bopEntryIndex, &pipShareVec );
    for (i=early; i<=late; i++)
      pipShareVec[i] = pipShare;
    witSetBopEntryPipShare( theWitRun, pdfOperationName.c_str(), bopEntryIndex, pipShareVec );
    witFree(pipShareVec);
#endif    


    
    return 0;
}

// Add Operation BOM entries and any default attributes
// to wit for NORMAL Operation BOMs
// Return --->  0  if succesful
//             -1  if un-succesful with warning
//             +1  if un-sucessful & input record should be ignored
int
LgFrInitialProblemForSce::sceAddNormalOperationBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & operation, 
    const std::string & operationPdf,
    const std::string & consumedPart, 
    const std::string & consumedPartPdf, 
    float usageRate,
    float offset,
    int early,
    int late,
    int fallout,
    int mec,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string pdfConsumedPartName( mpHelper.pdfPartname(consumedPart, consumedPartPdf) );
    std::string pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );

    if (! mpHelper.isPartValid(theWitRun, consumedPart, consumedPartPdf,
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) 
      return 1;
    
    if (! mpHelper.isOperationValid(theWitRun, pdfOperationName, 
                                    fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE)) 
      return 1;

      
    int bomEntryIndex;
    witGetOperationNBomEntries( theWitRun, pdfOperationName.c_str(), &bomEntryIndex);
    witAddBomEntry( theWitRun, pdfOperationName.c_str(), pdfConsumedPartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, pdfOperationName.c_str(), bomEntryIndex, usageRate );

#ifdef VARIABLE_PERIODS
    // FINISH_ME: adust offsets for userDefined operations
#endif
    float * offsetTimeVec;
    witGetBomEntryOffset( theWitRun, pdfOperationName.c_str(), bomEntryIndex, &offsetTimeVec );
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=early; i<=late; i++)
      offsetTimeVec[i] = offset;
    witSetBomEntryOffset( theWitRun, pdfOperationName.c_str(), bomEntryIndex, offsetTimeVec );
    witSetBomEntryEarliestPeriod( theWitRun, pdfOperationName.c_str(), bomEntryIndex, early );
    witSetBomEntryLatestPeriod( theWitRun, pdfOperationName.c_str(), bomEntryIndex, late );
    float falloutRate = (float) fallout/100.f;
    witSetBomEntryFalloutRate( theWitRun, pdfOperationName.c_str(), bomEntryIndex, falloutRate );
    witBoolean mandEC = WitFALSE;
    if (mec == 1) {
      mandEC = WitTRUE;
      std::cout << "gotta mandEC at " << pdfOperationName << " bomEntryIndex=" << bomEntryIndex << std::endl;
    }
    witSetBomEntryMandEC( theWitRun, pdfOperationName.c_str(), bomEntryIndex, mec );
    witFree(offsetTimeVec);

    return 0;
}

//--------------------------------------------------------------------
// Add part(s) and any structure to wit for SCE partType=2 (aggregation)
// REturn --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddAggregatePart(
    WitRun * const theWitRun, 
    const std::string & part, 
    const std::string & pdf,
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::cerr << "sceAddAggregatePart() not implemented yet\n\n";
    return -1;
}

int
LgFrInitialProblemForSce::sceAddPartToRepresentDemand(
    WitRun * const theWitRun, 
    const std::string & fullPartname, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    witAddPartWithOperation(theWitRun, fullPartname.c_str());

    return 0;
}





int
LgFrInitialProblemForSce::sceAddPartToRepresentDemandUpperBound(
    WitRun * const theWitRun, 
    const std::string & fullPartname, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    witAddPart(theWitRun, fullPartname.c_str(), WitRAW);

    LgFrSetOfParts & univSOP = sceScenario()->setOfParts(LGFR_UNIVERSAL_SET);
    LgFrPart partToBeAdded   = univSOP . newPart ( fullPartname );
    LgFrSetOfParts & defSOP  = sceScenario()->setOfParts(LGFR_DEFAULT_SET);
    if ( !defSOP.contains( partToBeAdded ) )
      defSOP.insert(partToBeAdded);

    LgFrSetOfParts & intrPlant = sceScenario()->setOfParts(LGFR_INTERPLANT_SET);
    if ( !intrPlant.contains( partToBeAdded ) )
      intrPlant.insert(partToBeAdded);

    return 0;
}


// ---------------------------------------------------------------
//  return values: -1=ERROR; 0=GOOD/ADDED; 1=GOOD/ALREADY_EXISTED
// ---------------------------------------------------------------
// + About: Interplant Structure
// +
// + - Exactly ONE SpecialInterplant Operation (SIO) per
// +            (destPart_Pdf,sourcePart_Pdf) pair
// +    - Lot size: set as per user on SIO (set over effective periods only)
// +            (can change over time via multiple records)
// + - Exactly ONE BOM entry from SIO to sourcePart_Pdf
// +    - early=0,late=nPeriods regardless of true ip effectivity
// +    - bom offset = transitTime (set over effective periods only)
// +            (can change over time via multiple records)
// +    - bom usageRate set as per user input.  Usage rate not allowed
// +            to change over time!
// +            (can change over time via multiple records)
// + - BOP Entries:  Multiple BOPS per (destPart_Pdf,sourcePart_Pdf) pair OK
// +           - One per each valid record
// +           - INVALID if effectivity overlaps with existing BOP
// +           - INVALID if usageRate is different than existing usageRate
// +    - early,late set to effectivity of record
// +
// + - APP DATA:
// +        PART: destinationPart_Pdf: keep count of nInterplantBops
// +        BOP:  contains bop preference, isInEffectForExplosionFlag, and expAllowed
int
LgFrInitialProblemForSce::addInterPlantBomStructure(
                                                    WitRun * const theWitRun, 
                                                    LgFrMultiPlantHelper & mpHelper,
                                                    const LgFrCalendar & theCal,
                                                    const std::string & destinationPart,
                                                    const std::string & destinationPdf,
                                                    const std::string & sourcePart, 
                                                    const std::string & sourcePdf,
                                                    float transitTime,
                                                    int early,
                                                    int late,
                                                    float minLotSize,
                                                    float incLotSize,
                                                    float usageRate,
                                                    float preference,
                                                    int isObjectInEffectForOptExplosionFlag,
                                                    int expAllowed,
						    float routingShare,
                                                    const std::string & fileName,
                                                    const std::string & dataLine,
                                                    long lineNo)
{

  witBoolean isUnique = true;
  int t;
  witBoolean exists;
  int nPeriods = theCal.nPeriods();    

  std::string fullDestinationPartName(mpHelper.pdfPartname(destinationPart, destinationPdf));
  std::string fullSourcePartName( mpHelper.pdfPartname(sourcePart,  sourcePdf));
    
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // check to see if destinationPartpart is valid
  if (! mpHelper.isPartValid(theWitRun, destinationPart, destinationPdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;



  // check to see if sourcePartPart is valid
  if (! mpHelper.isPartValid(theWitRun, sourcePart, sourcePdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;



  // SCE 5.00 ... check to see if destinationPart and Source Part are the same
  //  if so, then check to see if propRtg is true on the parent

  // first make sure source code is OK
  std::string sourceCode("AF");
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun, fullDestinationPartName.c_str(), (void **) &appDataPtr);
  if (appDataPtr != 0) {
    sourceCode = appDataPtr->sourceCode();
  }


  if (fullDestinationPartName == fullSourcePartName) {

    // if sourceCode != AFP then this record is not relevant
    if (sourceCode != "AFP") {
      (*theErrFacil)("InterplantToMyselfWithoutMultiSourcing",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << destinationPart 
		     << destinationPdf 
		     << sourceCode
		     << dataLine);
      return (-1);
    }

    // FINISH_ME 5.00  (we need to address sourcing that changes over time)

    // OK, you have a valid attempt to set a RoutingShare on the default operation
    int npBops;
    witGetPartNProducingBopEntries(theWitRun, fullDestinationPartName.c_str(), &npBops);
    if ( npBops == 0 ) {
      std::cout << "attempting to set a  RoutingShare on default operation when npBops=0\n"
		<< "part: " << fullDestinationPartName 
		<< "continueing"  << std::endl;
      return (0);
    }

    // OK, we need to deal with Routing Share of Zero.
    float effectiveProdRate = 1.0;
    float effectiveRoutingShare = routingShare;
    if (routingShare < 1.0) {
      effectiveRoutingShare = 1.0;
      effectiveProdRate = 0.0;
    }


    // now loop through bops looking for default operation.  
    // when you find it, set yield to whatever it should be, and set routingShare appropriately
    char * opName;
    int bopIndex;
    int bp = 0;
    for (bp=0; bp < npBops; bp++) {
      witGetPartProducingBopEntry ( theWitRun, fullDestinationPartName.c_str(), bp, &opName, &bopIndex);
      // NOTE: a bit of a shortcut.  We check the operation to see if it is the same as normal part.
      //       if so, this is the default operation.   
      //   FINISH_ME: 5.00 .. 
      //   (1) there is no way to set routingShare on bops that are produced by userDefined ops.
      //   (2) We keep looping, which enables the possibility that there are multiple bops that lead
      //       to defaultOp (maybe with diffenrt effectivities.  It is a finishme in genreal to deal with
      //       routing shares varying over time.
      if (mpHelper.isPartNormal(theWitRun, opName)) {
	//	LgFrTimeVecFloat routingShareVec(nPeriods, routingShare);
	float * routingShareVec;
	float * productRateVec;
	witGetBopEntryRoutingShare(theWitRun, opName, bopIndex, &routingShareVec);
	witGetBopEntryProductRate(theWitRun, opName, bopIndex, &productRateVec);
	int tbt = early;
	for (tbt=early; tbt<=late; tbt++) {
	  routingShareVec[tbt] = effectiveRoutingShare;
	  productRateVec[tbt] = effectiveProdRate;
	}
	witSetBopEntryRoutingShare(theWitRun, opName, bopIndex, routingShareVec);
	witSetBopEntryProductRate(theWitRun, opName, bopIndex, productRateVec);

	witFree (routingShareVec);
	witFree (productRateVec);
      }
      witFree ( opName );   
    }
      
    // good job, you can now return successfully
    return (0);


  }

  // ==== if you got here, it is a normal interplant arc

  // IF AFP and routingShare is zero or less than 1, then
  //   we basically return without entering any interplant BOP. 
  //   if it's zero we, return quietly, if it's between (0,1) we complain mildly  
  if ((sourceCode == "AFP") && (routingShare < 1.0))  {
    if (routingShare > 1.00001)  
      (*theErrFacil)("RoutingShareOfZero",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << destinationPart 
		     << destinationPdf 
		     << sourcePart 
		     << sourcePdf 
		     << sourceCode
		     << routingShare
		     << dataLine);
    return (0);
  }




  std::string interPlantOperationName =
    mpHelper.interPlantOperationName(destinationPart, destinationPdf, sourcePart, sourcePdf);
	
  // test to see if the interplant operation already exists
  witGetOperationExists(theWitRun, interPlantOperationName.c_str(), &exists);


  // if the interplant operation does NOT exist, then add it along with the
  // bom record to the source part, and set some defaults.
  //
  // if the interplant operation DOES exists, check to see if this record is a
  // "legal duplicate". To be legal it has to satisfy 2 conditions:
  //   (1) it the same usage rate as the previous records (which is mapped
  //       to the usage rate on the one and only bom for this interplant
  //       operation 
  //   (2) the effectivity dates are disjoint from the effectivity
  //       dates on all the other bops for this interplant operation
  //   If either (1) or (2) does not hold, reject the record and print an
  //   error message.

  if ( ! exists ) {
    // we initialize the default lot sizes on the dummy interplant part.
    // we will update it later.
    float * defaultLotSize = new float[nPeriods];
    for (t=0; t<nPeriods; t++) {
      defaultLotSize[t] = 1.0;
    }

    // add the dummy interplant operation and the source part bom entry to WIT
    witAddOperation( theWitRun, interPlantOperationName.c_str() );
    witSetOperationMinLotSize( theWitRun, interPlantOperationName.c_str(), defaultLotSize );
    witSetOperationIncLotSize( theWitRun, interPlantOperationName.c_str(), defaultLotSize );
    witAddBomEntry( theWitRun, interPlantOperationName.c_str(), fullSourcePartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, interPlantOperationName.c_str(), 0, usageRate );
    // In our model, there is one and only bom hanging off the interplant operation.
    // In our model, the bom is effective through out the entire planning horizon.
    witSetBomEntryEarliestPeriod( theWitRun, interPlantOperationName.c_str(), 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, interPlantOperationName.c_str(), 0, nPeriods-1 );
    if (groupSharingViaExecPenalties_) {
      witSetBomEntryExecPenalty(theWitRun, interPlantOperationName.c_str(), 0, preference);
    }

    // Since this is a new interplant Operation for the customer loc, increment
    // the nInterplantOps counter in the CustLoc Parts appdata.  (Being careful,
    // of course, to ensure the non-null-ness of the appDataPtr for the part
    LgFrScePartAppData * custPartAppData;
    witGetPartAppData(theWitRun, fullDestinationPartName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
      custPartAppData = new LgFrScePartAppData(0, nPeriods, nPeriods);
      custPartAppData->nInterplantOps(1);
      witSetPartAppData(theWitRun, fullDestinationPartName.c_str(), (void *) custPartAppData);
    }
    else 
      custPartAppData->nInterplantOps(custPartAppData->nInterplantOps() + 1);      

    delete [] defaultLotSize;
  }

  if ( exists ) {
    // set unique flag = false
    isUnique = false;

    if ( ! mpHelper.isDuplicateInterplantRecordUsageRateValid(
                     theWitRun, fullSourcePartName, interPlantOperationName,
                     usageRate)) {
      (*theErrFacil)("ConflictingInterplantRecordsUR",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << destinationPart 
		     << destinationPdf 
		     << sourcePart 
		     << sourcePdf 
		     << dataLine);
      return (-1);
    }
    
    if ( ! mpHelper.isDuplicateInterplantRecordEffectivityDatesValid(
                      theWitRun, interPlantOperationName, early, late )) {
      (*theErrFacil)("ConflictingInterplantRecordsED",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << destinationPart 
		     << destinationPdf 
		     << sourcePart 
		     << sourcePdf 
		     << dataLine);
      return (-1);
    }
  }


  // do a sanity check ... THERE MUST BE ONE AND ONLY ONE BOM
  int nBom;
  witGetOperationNBomEntries(theWitRun, interPlantOperationName.c_str(), &nBom);
  assert(nBom == 1);

  // if we made it here, we either have a "valid duplicate" interplant
  // record or a new one. In either case, we now create a bop entry
  // between destination part and interplant operation,
  // with effectivity = (early, late)
  int nbBop;
  witGetOperationNBopEntries( theWitRun, interPlantOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, interPlantOperationName.c_str(), fullDestinationPartName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, interPlantOperationName.c_str(),
                                nbBop, early );      
  witSetBopEntryLatestPeriod( theWitRun, interPlantOperationName.c_str(),
                              nbBop, late );

  // SCE 5.00 ... set the routing share
  LgFrTimeVecFloat routingShareVec(nPeriods, routingShare);
  witSetBopEntryRoutingShare(theWitRun, interPlantOperationName.c_str(), 
			     nbBop, routingShareVec.data());


#ifdef VARIABLE_PERIODS
  // FINISH_ME: interplant transit times
#endif

  // Now set the transitTime using bom offset.  
  // the effectivity range are left as they were.
  float * offset;
  witGetBomEntryOffset(theWitRun, interPlantOperationName.c_str(), 0, &offset);
  for (t=early; t<=late; t++)
      offset[t] = transitTime / theCal.workUnits(t);
  witSetBomEntryOffset(theWitRun, interPlantOperationName.c_str(), 0, offset);
  witFree(offset);
  
  // Set the minLotSize and incLotSize on the  interplant operation.
  // Note that the min/incLotSize size is only set in the effective range.
  // The values outside the effectivity range are left as they were.
  float * interPlantMinLotSize;
  float * interPlantIncLotSize;
  witGetOperationMinLotSize( theWitRun, interPlantOperationName.c_str(), &interPlantMinLotSize );
  witGetOperationIncLotSize( theWitRun, interPlantOperationName.c_str(), &interPlantIncLotSize );
  
  for (t=early; t<=late; t++) {
    interPlantMinLotSize[t] = minLotSize ;
    interPlantIncLotSize[t] = incLotSize ;    
  }
  
  witSetOperationMinLotSize(theWitRun, interPlantOperationName.c_str(), interPlantMinLotSize);
  witSetOperationIncLotSize(theWitRun, interPlantOperationName.c_str(), interPlantIncLotSize);
  witFree(interPlantMinLotSize);
  witFree(interPlantIncLotSize);


  // Add an app data for the bop preference and explosion flag
  
  void * bopAppVoidPtr;
  LgFrSceBopAppData * myBopAppDataPtr; 
  witGetBopEntryAppData( theWitRun, interPlantOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
    (*theErrFacil)("InternalError3",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << destinationPart 
		   << destinationPdf 
		   << sourcePart 
		   << sourcePdf 
		   << dataLine);
  }
  myBopAppDataPtr = new LgFrSceBopAppData (preference, 
					   isObjectInEffectForOptExplosionFlag, 
					   expAllowed);  
  assert ( myBopAppDataPtr != 0 );
  witSetBopEntryAppData( theWitRun, interPlantOperationName.c_str(),
                         nbBop, (void *) myBopAppDataPtr );


  // 2.30 Note:
  //  we don't set expAllowed or expAversion yet.  It will be done in the split bop.
  // FINISH_ME 2.31:  WHY,??  I'm going to set it
  witSetBopEntryExpAllowed(theWitRun, interPlantOperationName.c_str(), nbBop, expAllowed);
  witSetBopEntryExpAversion(theWitRun, interPlantOperationName.c_str(), nbBop, preference);

  if ( lpModelHelper_ != 0 ) {    
    float * opExecCost;
    witGetOperationObj1ExecCost(theWitRun, interPlantOperationName.c_str(), &opExecCost);
    for (t=early; t<=late; t++)
      opExecCost[t] = preference;
    witSetOperationObj1ExecCost(theWitRun, interPlantOperationName.c_str(), opExecCost);
    witFree(opExecCost);
  }


  if (isUnique)
    return 0;
  else
    return 1;
}




// --------------------------------------------------------------------------

// Add part(s) and any structure to wit for BB Category parts (BB/feature set)
// REturn --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddBbCategoryPartAndStructureViaProportionalRoute(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const float * gammaMaxVector,
    float gammaMin,
    int early,
    int late,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;

    witGetNPeriods(theWitRun, &nPeriods);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    // get a unique part name for the bbCategory
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
							       bbCategory);

    // Now check to see if the  bbCategory does not already exist
    if (mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("BBCategoryAlreadyDefined",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << bbCategory 
		     << fullBbCategoryPart 
		     << dataLine);
	return -1;
    }


    // make sure the plannerTopLevel Special Demand Part exists
    std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
    if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL))   {
      (*theErrFacil)("PartDoesNotExist",MclArgList() 
		     << plannerTopLevelPart 
		     << geo 
		     << fileName 
		     << bbCategory 
		     << (int)lineNo 
		     << dataLine);
      return -1;
    }

    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
   
    // get the default stock and scrap penalty for featureSet part
    float featureSetStockPenalty = setOfParameters.getFloat("featureSetStockPenalty");
    float featureSetScrapPenalty = setOfParameters.getFloat("featureSetScrapPenalty");    


    float * featureSetStockPenaltyVec = new float[nPeriods];
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)  
	featureSetStockPenaltyVec[t] = featureSetStockPenalty;

    float * featureSetScrapPenaltyVec = new float[nPeriods];
    for (t=0; t<nPeriods; t++)  
	featureSetScrapPenaltyVec[t] = featureSetScrapPenalty;


    // Add the BB category  part and operation 
    // We'll use the default operation for MRP purposes only
    // NOW_FINISH_ME: should this be a capacity part??
    witAddPart( theWitRun, fullBbCategoryPart.c_str(), WitMATERIAL);
    witSetPartPropRouting(theWitRun, fullBbCategoryPart.c_str(), WitTRUE);
    //    witSetBopEntryExpAversion(theWitRun, fullBbCategoryPart.c_str(), 0, -999999.0);
    if ( lpModelHelper_ != 0) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart.c_str(), featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart.c_str(), featureSetScrapPenaltyVec );
    }


    delete [] featureSetScrapPenaltyVec;
    delete [] featureSetStockPenaltyVec;

    // BOM structure between gpd and bbCategory
    int nBomGPD;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBomGPD);
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), fullBbCategoryPart.c_str());
    witSetBomEntryConsRate(theWitRun, geoPlannerDemandPart.c_str(), nBomGPD, gammaMaxVector);
    // NOW_FINISH_ME: what to do about gammaMin??
    


    return 0;
}


// --------------------------------------------------------------------------
// SCE 6.1
// Add part(s) and any structure to wit for BB Category parts (BB/feature set)
// REturn --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddBbCategoryPartAndStructureViaProportionalRoute61(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const float gammaMax,
    float gammaMin,
    int earlyPeriod,
    int latePeriod,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;
    int t = 0; 

    witGetNPeriods(theWitRun, &nPeriods);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, bbCategory);
    if (mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("BBCategoryAlreadyDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo 
		     << bbCategory << fullBbCategoryPart << dataLine); 
      return -1;
    }


    std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
    if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, dataLine, lineNo, PURELY_OPTIONAL))   {
      (*theErrFacil)("PartDoesNotExist",MclArgList() << plannerTopLevelPart << geo << fileName << bbCategory << (int)lineNo << dataLine);
      return -1;
    }

    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
   
    
    // Add the BB category  part and operation 
    // We'll use the default operation for MRP purposes only
    //   ... should this be a capacity part??
    witAddPart( theWitRun, fullBbCategoryPart.c_str(), WitMATERIAL);
    witSetPartPropRouting(theWitRun, fullBbCategoryPart.c_str(), WitTRUE);
    //    witSetBopEntryExpAversion(theWitRun, fullBbCategoryPart.c_str(), 0, -999999.0);

    if ( lpModelHelper_ != 0) {
      float featureSetStockPenalty = setOfParameters.getFloat("featureSetStockPenalty");
      float featureSetScrapPenalty = setOfParameters.getFloat("featureSetScrapPenalty");    
      float * featureSetStockPenaltyVec = new float[nPeriods];
      float * featureSetScrapPenaltyVec = new float[nPeriods];
      for (t=0; t<nPeriods; t++)  {
	featureSetStockPenaltyVec[t] = featureSetStockPenalty;
	featureSetScrapPenaltyVec[t] = featureSetScrapPenalty;
      }
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart.c_str(), featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart.c_str(), featureSetScrapPenaltyVec );
      delete [] featureSetScrapPenaltyVec;
      delete [] featureSetStockPenaltyVec;
    }

    // BOM structure between gpd and bbCategory
    int nBomGPD;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBomGPD);
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), fullBbCategoryPart.c_str());

    float * gammaMaxVector;
    witGetBomEntryConsRate(theWitRun, geoPlannerDemandPart.c_str(), nBomGPD, &gammaMaxVector);
    for (t=earlyPeriod; t<latePeriod; t++)  {
      gammaMaxVector[t] = gammaMax;
    }
    witSetBomEntryConsRate(theWitRun, geoPlannerDemandPart.c_str(), nBomGPD, gammaMaxVector);
    witFree(gammaMaxVector);
    
    // No use for gammaMin in the proportional split mode

    return 0;
}



// --------------------------------------------------------------------------

// Add part(s) and any structure to wit for BB Category parts (BB/feature set)
// REturn --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddBbCategoryPartAndStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    float gammaMax,
    float gammaMin,
    int early,
    int late,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;

    witGetNPeriods(theWitRun, &nPeriods);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    // get a unique part name for the bbCategory
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
							       bbCategory);

    // Now check to see if the  bbCategory does not already exist
    if (mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("BBCategoryAlreadyDefined",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << bbCategory 
		     << fullBbCategoryPart 
		     << dataLine);
	return -1;
    }


    // make sure the plannerTopLevel Special Demand Part exists
    std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
    if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL))   {
      (*theErrFacil)("PartDoesNotExist",MclArgList() 
		     << plannerTopLevelPart 
		     << geo 
		     << fileName 
		     << bbCategory 
		     << (int)lineNo 
		     << dataLine);
      return -1;
    }

    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
   
    // get the default stock and scrap penalty for featureSet part
    float featureSetStockPenalty = setOfParameters.getFloat("featureSetStockPenalty");
    float featureSetScrapPenalty = setOfParameters.getFloat("featureSetScrapPenalty");    


    float * featureSetStockPenaltyVec = new float[nPeriods];
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)  
	featureSetStockPenaltyVec[t] = featureSetStockPenalty;

    float * featureSetScrapPenaltyVec = new float[nPeriods];
    for (t=0; t<nPeriods; t++)  
	featureSetScrapPenaltyVec[t] = featureSetScrapPenalty;


    // Add the BB category  part to WIT
    witAddPartWithOperation( theWitRun, fullBbCategoryPart.c_str() );
    if ( lpModelHelper_ != 0) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart.c_str(), featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart.c_str(), featureSetScrapPenaltyVec );
    }


    delete [] featureSetScrapPenaltyVec;
    delete [] featureSetStockPenaltyVec;

    // Now add the BOM structure between topLevelPart and bbCategory
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), fullBbCategoryPart.c_str());

    

    // Add the LT and GT capacity parts to WIT (they shouldn't already exist)
    std::string LTbbCapacityPartName = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
								   bbCategory);
    std::string GTbbCapacityPartName = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
								   bbCategory);
    assert (! mpHelper.isPartValid(theWitRun, LTbbCapacityPartName, fileName, 
				   dataLine, lineNo, PURELY_OPTIONAL));
    assert (! mpHelper.isPartValid(theWitRun, GTbbCapacityPartName, fileName, 
				   dataLine, lineNo, PURELY_OPTIONAL));

    float bigFloat = 1000000000000.0;
    float * infiniteCapacity = new float[nPeriods];
    for (t=0; t<nPeriods; t++)
      infiniteCapacity[t] = bigFloat;
    

    witAddPart(theWitRun, LTbbCapacityPartName.c_str(), WitCAPACITY);
    witAddPart(theWitRun, GTbbCapacityPartName.c_str(), WitCAPACITY);

    witSetPartSupplyVol(theWitRun, GTbbCapacityPartName.c_str(), infiniteCapacity);
    witSetPartSupplyVol(theWitRun, LTbbCapacityPartName.c_str(), infiniteCapacity);

    delete [] infiniteCapacity;    


    // add the BOM structure between the featureSetPart and LT and GT

    float * gammaVec = new float[nPeriods];
    witAddBomEntry(theWitRun, fullBbCategoryPart.c_str(), LTbbCapacityPartName.c_str());

    for (t=0; t<nPeriods; t++)  
	gammaVec[t] = gammaMin;

    witSetBomEntryConsRate(theWitRun, fullBbCategoryPart.c_str(), 0, gammaVec);

    witAddBomEntry(theWitRun, fullBbCategoryPart.c_str(), GTbbCapacityPartName.c_str());

    for (t=0; t<nPeriods; t++)  
	gammaVec[t] = -gammaMax;

    witSetBomEntryConsRate(theWitRun, fullBbCategoryPart.c_str(), 1, gammaVec);

    delete [] gammaVec;





    return 0;
}



//  FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
// this is what is used for engine not = optimization
#ifdef VARIABLE_PERIODS

// FINISH_ME: for variable periods, need to address all instances of MFO
#endif
int
LgFrInitialProblemForSce::sceAddBBtoOptionBomStructureViaProportionalRoute(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const std::string & mfgOptionPart, 
    float usageRate,
    float * featureRatio,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();        
    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();

    // determine if the option is real or is a nullOption
    bool nullOption = false;
    if (0 == sce::compareStringsCaseIns( mfgOptionPart, "nullOption" ))
      nullOption = true;
    
    // get the full wit name for the bbCategory
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
							       bbCategory);

    // Now make sure that the bbCategory part already exists
    if (! mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("BBCategoryNotDefined",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo
		     << bbCategory
		     << mfgOptionPart
		     << fullBbCategoryPart
		     << dataLine);
      return -1;
    }

    //  Determine the first period that has non-Zero Ratio.
    int firstPeriodWithRatio = nPeriods;
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
	if (featureRatio[t] > 0.0)  {
	    firstPeriodWithRatio = t;
	    break;
	}

    if (firstPeriodWithRatio == nPeriods)  {
      (*theErrFacil)("OptionAllZeroRatios",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << bbCategory 
		     << mfgOptionPart 
		     << fullBbCategoryPart 
		     << dataLine);

	return -1;
    }
	    
	    
    // get a unique name for the SOD (Special Option Dummy) operation
    std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
							 bbCategory, mfgOptionPart);


    // see if SOD operation already exists
    if ( mpHelper.isOperationValid(theWitRun, optionDummy, fileName, 
			      dataLine, lineNo, PURELY_OPTIONAL))     {
      (*theErrFacil)("OptionRatiosAlreadySpecified",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo << bbCategory 
		     << mfgOptionPart 
		     << fullBbCategoryPart 
		     << dataLine);
      return -1;
    }



    // -------------------------++++++++++++++++++
    // NOTE: We assume that GPD's are single sourced (this is true for Server Group
    // determine the PDF and then the mfgOptionPart that the feature sources to.

    int sourceBeginPeriod = firstPeriodWithRatio;
    int sourceEndPeriod = nPeriods - 1;


    // derive the mfg part for the option (the real part)
#ifdef VARIABLE_PERIODS

    LgFrTimeVecFloat transitTimeOffsetTV(nPeriods, 0.0);
    std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
							plannerTopLevelPart,
							geo,
							sourceBeginPeriod,
							sourceEndPeriod,
							transitTimeOffsetTV,
							fileName,
							dataLine,
							lineNo,
							MANDATORY);
#else
    float transitTimeScaled;
    std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
						      plannerTopLevelPart,
						      geo,
						      sourceBeginPeriod,
						      sourceEndPeriod,
						      transitTimeScaled,
						      fileName,
						      dataLine,
						      lineNo,
						      MANDATORY);
#endif



    // determine the pdf for this source
    std::string pdf(mpHelper.pdf(mfgTopLevelPart));
    
    // get the full wit name for the real option part
    std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
// -------------------------++++++++++++++++++

    
    // test to see if the real option part exists at the pdf.  IF NOT,
    // then we can't just ignore the record because we've already created
    // half the structure.  Hence, we bow out gracefully and treat this
    // particular pdf source as if it were a nullOption (ie, always
    // meetable from thin air).  
    if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL))  {

      (*theErrFacil)("CannotSourceFeature",MclArgList() 
		     << fileName
		     << (int)lineNo
		     << plannerTopLevelPart
		     << geo
		     << mfgTopLevelPart
		     << bbCategory
		     << mfgOptionPart
		     << pdf
		     << mfgOptionPart
		     << sourceBeginPeriod
		     << sourceEndPeriod
		     << dataLine);
      return -1;
    }

    

   
    // -----------------------------------
    // add OPERATION:   SOD 
    // -----------------------------------
    witAddOperation(theWitRun, optionDummy.c_str());

    if (! nullOption) {
      // Set the execCost as the option reward
      if ( lpModelHelper_ != 0 )  {
        // setup the default option Revenue

        float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");

        float * optionDummyExecCost = new float[nPeriods];
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)  
            optionDummyExecCost[t] = -defaultOptionShipReward;
        witSetOperationObj1ExecCost( theWitRun, optionDummy.c_str(), optionDummyExecCost );
        delete [] optionDummyExecCost;
      }
    }
    
    // -------------------------
    // add BOP: BBCat --> SOD
    // -------------------------
    int nBopSOD;
    witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBopSOD);
    witAddBopEntry(theWitRun, optionDummy.c_str(), fullBbCategoryPart.c_str());

    LgFrTimeVecFloat routingShare(nPeriods, featureRatio);
    LgFrTimeVecFloat scaledRoutingShare(routingShare * 1000.0);
    float * sodYieldRate;
    witGetOperationYieldRate(theWitRun, optionDummy.c_str(), &sodYieldRate);
    // Note: Adjustment for periods with ratio=zero
    //     Make yieldRate(SOD)[t] = 0 and routingShare=1
    for (t=0; t<nPeriods; t++) {
      if (scaledRoutingShare[t] < 1.0) {
	sodYieldRate[t] = 0.0;
	scaledRoutingShare[t] = 1.0;
      }
    }

    witSetBopEntryRoutingShare(theWitRun, optionDummy.c_str(), nBopSOD, scaledRoutingShare.data());
    witSetOperationYieldRate(theWitRun, optionDummy.c_str(), sodYieldRate);
    witFree(sodYieldRate);


    // --------------------
    // add Bom: SOD -> Real Option part
    // --------------------
    int nBomSOD;
    witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBomSOD);
    witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
    LgFrTimeVecFloat usageRateVector(nPeriods, usageRate);
    //    witSetBomEntryUsageRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRate);
    witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRateVector.data());


    // ------------------------------------------------------------------------
    // Compute Bom Offsets: transitTime(pdf->geoSource) + cycleTime(mfgTopLevelPart)
    // ------------------------------------------------------------------------
#ifdef VARIABLE_PERIODS
    LgFrTimeVecFloat mfgTopLevelCycleTime = mpHelper.getCycleTime(theWitRun, mfgTopLevelPart);
    LgFrTimeVecFloat optionOffset(nPeriods, 0.0);
    int ttt = 0;
    for (ttt=0; ttt<nPeriods; ttt++) {
      optionOffset[ttt] = mfgTopLevelCycleTime[ttt] - transitTimeOffsetTV[ttt];
    }
    witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffset.data());
#else
    float * mfgTopLevelCycleTime;
    witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);
    int ttt = 0;
    for (ttt=0; ttt<nPeriods; ttt++) {
      mfgTopLevelCycleTime[ttt] -= transitTimeScaled;
    }
    //    witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, mfgTopLevelCycleTime);
    witFree(mfgTopLevelCycleTime);
#endif
    return 0;
}



//  SCE 6.1
int
LgFrInitialProblemForSce::sceAddBBtoOptionBomStructureViaProportionalRoute61(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string  & plannerTopLevelPart, 
    const std::string  & geo,
    const std::string  & bbCategory, 
    const std::string  & mfgOptionPart, 
    float                usageRate,
    float                attachRate,
    float                mfOffsetVal,
    int                  mfoPhantomFlag,
    float                mfSupplyVal,
    int                  earlyPeriod,
    int                  latePeriod,
    int                  requestPeriod,
    const std::string  & fileName,
    const std::string  & dataLine,
    long                 lineNo)
{
  int t;
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();        
  LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
  
  // determine if the option is real or is a nullOption
  bool nullOption = false;
  if (0 == sce::compareStringsCaseIns( mfgOptionPart, "nullOption" ))
    nullOption = true;
    

  std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, bbCategory);
  if (! mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
    (*theErrFacil)("BBCategoryNotDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo
		   << bbCategory << mfgOptionPart << fullBbCategoryPart << dataLine);
    return -1;
  }

  std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, bbCategory, mfgOptionPart);
  if ( mpHelper.isOperationValid(theWitRun, optionDummy, fileName, dataLine, lineNo, PURELY_OPTIONAL))     {
    (*theErrFacil)("OptionRatiosAlreadySpecified",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart 
		   << geo << bbCategory << mfgOptionPart << fullBbCategoryPart << dataLine);
    return -1;
  }

  std::string sourceLocPdf;
  // determine the full wit name for the Box at the sourceLocPdf
  std::string mfgBoxPartName = mpHelper.mfgTopPartForGpd(theWitRun, plannerTopLevelPart, geo, sourceLocPdf);
    
  std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, sourceLocPdf));
  if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("CannotSourceFeature",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgBoxPartName 
		   << bbCategory << mfgOptionPart << sourceLocPdf << mfgOptionPart << earlyPeriod << latePeriod << dataLine);
    return -1;
  }

  // -----------------------------------
  // add OPERATION:   SOD 
  // -----------------------------------
  witAddOperation(theWitRun, optionDummy.c_str());

  if (! nullOption) {
    // Set the execCost as the option reward
    if ( lpModelHelper_ != 0 )  {
      float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");
      float * optionDummyExecCost = new float[nPeriods];
      int t = 0; 
      for (t=0; t<nPeriods; t++)  
	optionDummyExecCost[t] = -defaultOptionShipReward;
      witSetOperationObj1ExecCost( theWitRun, optionDummy.c_str(), optionDummyExecCost );
      delete [] optionDummyExecCost;
    }
  }
    
  // -------------------------
  // add BOP: BBCat --> SOD
  // -------------------------
  int nBopSOD;
  witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBopSOD);
  witAddBopEntry(theWitRun, optionDummy.c_str(), fullBbCategoryPart.c_str());

  LgFrTimeVecFloat routingShare(nPeriods, attachRate);
  LgFrTimeVecFloat scaledRoutingShare(routingShare * 1000.0);
  float * sodYieldRate;
  witGetOperationYieldRate(theWitRun, optionDummy.c_str(), &sodYieldRate);
  // Note: Adjustment for periods with ratio=zero
  //     Make yieldRate(SOD)[t] = 0 and routingShare=1
  for (t=0; t<nPeriods; t++) {
    if (scaledRoutingShare[t] < 1.0) {
      sodYieldRate[t] = 0.0;
      scaledRoutingShare[t] = 1.0;
    }
  }
  witSetBopEntryRoutingShare(theWitRun, optionDummy.c_str(), nBopSOD, scaledRoutingShare.data());
  witSetOperationYieldRate(theWitRun, optionDummy.c_str(), sodYieldRate);
  witFree(sodYieldRate);

  // --------------------
  // add Bom: SOD -> Real Option part
  // --------------------
  int nBomSOD;
  witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBomSOD);
  witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
  float * consRate;
  witGetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBomSOD, &consRate);
  for (t=earlyPeriod; t<=latePeriod; t++)
    consRate[t] = usageRate;
  witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBomSOD, consRate);
  witFree(consRate);

  // -------------------------------------------------
  // MFSupply:  supplyVol(optionDummy)  += mfSupplyVal
  // -------------------------------------------------
  // FINISH_ME_61:  we need a SOD part to add supply on, this modelling trick only has an SOD operation. 
#if 0  
  if (mfSupplyVal > 0.0) {
    float * mfSupplyVec;
    witGetPartSupplyVol(theWitRun, optionDummy.c_str(), &mfSupplyVec);
    mfSupplyVec[requestPeriod] += mfSupplyVal;
    witSetPartSupplyVol(theWitRun, optionDummy.c_str(), mfSupplyVec);
    witFree(mfSupplyVec);
  }
#endif
    

  // ------------------------------------------------------------------------
  // Bom Offset(optionDummy->fullOptionPart)  = mfgBoxCycleTimeDays + mfOffset - (mfoPhantomFlag * mfgOptionPartCycleTimeDays)
  // ------------------------------------------------------------------------
  // FINISH_ME_61: doesn't work for duplicate records
  LgFrTimeVecFloat offsetTV(nPeriods, 0.0);
  LgFrTimeVecFloat mfgBoxCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, mfgBoxPartName);
  if (mfoPhantomFlag) {
    LgFrTimeVecFloat optionCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullOptionPartName);
    for (t=earlyPeriod; t<=latePeriod; t++) {
      offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal - optionCycleTimeDays[t], t, theCal, nPeriods);
    }
  }
  else   {
    for (t=earlyPeriod; t<=latePeriod; t++) {
      offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal, t, theCal, nPeriods);
    }
  }
  witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, offsetTV.data());

  return 0;
}




// ==============================================================
//
// This method is used for engine=optimization 
//
// FINISH_ME: add modification for VARIABLE_PERIODS
// 
// Add the feature to a BB SET and set up the ratio logic
//
//  This routine takes plannerTopLevelPart, a geo, a bbCategory, and a
//  optionPart (which is assumed to be a mfgPart)
//  and creates some dummy parts and structure:
//     -- a dummy part (the option dummy) is created for the optionPart
//     -- the real optionPart part hangs off of this option dummy
//     -- there may be multiple option parts if the geoPlannerPart is
//        multiply sourced.
//     -- another dummy part is created to represent the option ratio supply
//     -- the option ratio supply part also hangs off the option dummy
//     -- the LT and GT capacity parts (which are assocaited with the
//        bbCategory for this plannerTopLevel/geo, and, which should already
//        have been created)  also hang off the option dummy
//
//   NOTE:  If the mfgOptionPart is "nullOption"  (case-insensitive), then
//          we do not source the part.  (ie, we do not try to find a real
//          pdf,part called nullOption.  Instead we just leave the option dummy
//          with one child.)  In this case, we also do not give any "reward"
//          for the production of a nullOption.
int
LgFrInitialProblemForSce::sceAddBBtoOptionBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const std::string & mfgOptionPart, 
    float usageRate,
    const float * featureRatio,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    // determine if the option is real or is a nullOption
    bool nullOption = false;
    if (0 == sce::compareStringsCaseIns( mfgOptionPart, "nullOption" ))
      nullOption = true;
    
    // get the full wit name for the bbCategory
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
							       bbCategory);

    // Now make sure that the bbCategory part already exists
    if (! mpHelper.isPartValid(theWitRun, fullBbCategoryPart, fileName, 
			       dataLine, lineNo, PURELY_OPTIONAL)) {
      (*theErrFacil)("BBCategoryNotDefined",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo
		     << bbCategory
		     << mfgOptionPart
		     << fullBbCategoryPart
		     << dataLine);
      return -1;
    }


    //  Determine the first period that has non-Zero Ratio.
    int firstPeriodWithRatio = nPeriods;
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
	if (featureRatio[t] > 0.0)  {
	    firstPeriodWithRatio = t;
	    break;
	}

    if (firstPeriodWithRatio == nPeriods)  {
      (*theErrFacil)("OptionAllZeroRatios",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << bbCategory 
		     << mfgOptionPart 
		     << fullBbCategoryPart 
		     << dataLine);

	return -1;
    }


    LgFrTimeVecFloat usageRateVector(nPeriods, usageRate);
	    
    // get a unique name for the option dummy  part
    std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
							 bbCategory, mfgOptionPart);

    // get a unique name for the option Ratio Supply part
    std::string optionRatioSupply = 
	mpHelper.optionRatioSupplyPartName(plannerTopLevelPart, geo,
					   bbCategory, mfgOptionPart);

    // see if option dummy already exists
    if ( mpHelper.isPartValid(theWitRun, optionDummy, fileName, 
			      dataLine, lineNo, PURELY_OPTIONAL))     {
      (*theErrFacil)("OptionRatiosAlreadySpecified",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo << bbCategory 
		     << mfgOptionPart 
		     << fullBbCategoryPart 
		     << dataLine);
      return -1;
    }


    // if the option dummy does not exist, then we must create the initial
    // structures in WIT.  Otherwise, we can skip over and just reset some 
    // ratios.

    // since the option dummy and the option ratio supply are created as
    // a pair, assert that the option ratio dummy doesn't already exist
    assert(! mpHelper.isPartValid(theWitRun, optionRatioSupply, fileName, 
				  dataLine, lineNo, PURELY_OPTIONAL));

    // create the option dummy part in WIT.  If its a nullOption
    // then we let the default prodCost of zero happen.  Otherwise
    // get the default prodReward for shipping this option
    if (nullOption) {
      witAddPartWithOperation(theWitRun, optionDummy.c_str());
    }
    else {
      LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
      float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");
      
      float * optionDummyProdCost = new float[nPeriods];
      for (t=0; t<nPeriods; t++)  
	optionDummyProdCost[t] = -defaultOptionShipReward;
      
    
      // create the option dummy part in WIT
      witAddPartWithOperation( theWitRun, optionDummy.c_str() );

      // in wit4.0+ land, the old prod costs have been reborn as exec costs
      if ( lpModelHelper_ != 0 )
        witSetOperationObj1ExecCost( theWitRun, optionDummy.c_str(), optionDummyProdCost );


      delete [] optionDummyProdCost;
    }



    // now add a bom entry from bbCategory part to the optionDummy
    // this is done solely for making the structure  work in MRP
    // mode and heuristic mode.  In optimization mode, these bom
    // arcs invalidate the model.  We get around this in the routine
    // called reStructureForOptimization(), where these bom usage
    // rates are set to 0.0.

    // The strategy is to set the usage rates on these bom entries to
    // the feature ratio. 
    int nBom;
    witGetOperationNBomEntries(theWitRun, fullBbCategoryPart.c_str(), &nBom);
    witAddBomEntry(theWitRun, fullBbCategoryPart.c_str(), optionDummy.c_str());
    witSetBomEntryConsRate(theWitRun, fullBbCategoryPart.c_str(), nBom, featureRatio);
       
    // get the stock cost for this part
    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
    float optionRatioSupplyStockPenalty =
      setOfParameters.getFloat("optionRatioSupplyStockPenalty");
    

    // create the option ratio supply  part in WIT
    //      1) set up a stock cost using the default
    //      2) set the supplyVec to be the feature ratio over
    //         the effective periods.  NOTE: later on we'll do 
    //         an mrp to explode the demand and populate the final
    //         supplyVols
    float * optionRatioSupplyStockPenaltyVec = new float[nPeriods];
    for (t=0; t<nPeriods; t++)  
	optionRatioSupplyStockPenaltyVec[t] = optionRatioSupplyStockPenalty;
    
    witAddPart( theWitRun, optionRatioSupply.c_str(), WitMATERIAL );
    //     witAddPartWithOperation( theWitRun, optionRatioSupply.c_str() );
    if ( lpModelHelper_ != 0 )
      witSetPartObj1StockCost( theWitRun, optionRatioSupply.c_str(),
                               optionRatioSupplyStockPenaltyVec );


    delete [] optionRatioSupplyStockPenaltyVec;

    
    // add Bom: from optionDummy ---> optionRatioSupply
    witAddBomEntry(theWitRun, optionDummy.c_str(), optionRatioSupply.c_str());


    // add Bom:  optionDummy -->  Real Option Part, FOR EACH GE0-->PDF source!!
    // This operation is NOT done for nullOption.
    // NOTE:  The usage time must "equal" the cumulative lead time
    // associated with the pdf->geo transit time and the cycleTime
    // on the mfgTopLevelPart.  
     
    if (! nullOption) {
      int sourceBeginPeriod = firstPeriodWithRatio;
      int sourceEndPeriod = nPeriods - 1;
#ifdef VARIABLE_PERIODS
      LgFrTimeVecFloat transitTimeOffsetTV(nPeriods, 0.0);
#else
      float transitTimeScaled;
#endif
      while (sourceBeginPeriod < nPeriods) {
#ifdef VARIABLE_PERIODS
        std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
							    plannerTopLevelPart,
							    geo,
							    sourceBeginPeriod,
							    sourceEndPeriod,
							    transitTimeOffsetTV,
							    fileName,
							    dataLine,
							    lineNo,
							    MANDATORY);
#else
        std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
							    plannerTopLevelPart,
							    geo,
							    sourceBeginPeriod,
							    sourceEndPeriod,
							    transitTimeScaled,
							    fileName,
							    dataLine,
							    lineNo,
							    MANDATORY);
#endif
        // determine the pdf for this source
        std::string pdf(mpHelper.pdf(mfgTopLevelPart));
	
        // get the full wit name for the real option part
        std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
	
        // test to see if the real option part exists at the pdf.  IF NOT,
        // then we can't just ignore the record because we've already created
        // half the structure.  Hence, we bow out gracefully and treat this
        // particular pdf source as if it were a nullOption (ie, always
        // meetable from thin air).  
        if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, 
                                   dataLine, lineNo, PURELY_OPTIONAL))  {
	  
	  (*theErrFacil)("CannotSourceFeature",MclArgList() 
			 << fileName
			 << (int)lineNo
			 << plannerTopLevelPart
			 << geo
			 << mfgTopLevelPart
			 << bbCategory
			 << mfgOptionPart
			 << pdf
			 << mfgOptionPart
			 << sourceBeginPeriod
			 << sourceEndPeriod
			 << dataLine);
          sourceBeginPeriod = sourceEndPeriod + 1;
          continue;
        }

        std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);

	int nBom;
	witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBom);
	witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
	witSetBomEntryEarliestPeriod(theWitRun, optionDummy.c_str(), nBom, sourceBeginPeriod);
	witSetBomEntryLatestPeriod(theWitRun, optionDummy.c_str(), nBom, sourceEndPeriod);
	witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBom, usageRateVector.data());
	witSetBomEntryMandEC(theWitRun, optionDummy.c_str(), nBom, WitTRUE);
	// now compute offset
#ifdef VARIABLE_PERIODS
	LgFrTimeVecFloat mfgTopLevelCycleTime = mpHelper.getCycleTime(theWitRun, mfgTopLevelPart);
	LgFrTimeVecFloat optionOffset(nPeriods, 0.0);
	int ttt = 0;
	for (ttt=0; ttt<nPeriods; ttt++) {
	  optionOffset[t] = mfgTopLevelCycleTime[t] - transitTimeOffsetTV[t];
	}
	witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBom, optionOffset.data());
#else
        float * mfgTopLevelCycleTime;
        witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);
	int ttt = 0;
	for (ttt=0; ttt<nPeriods; ttt++) {
	  mfgTopLevelCycleTime[ttt] -= transitTimeScaled;
	}
	witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBom, mfgTopLevelCycleTime);
        witFree(mfgTopLevelCycleTime);
#endif
        // Now reset the sourceBeginPeriod to bb the period after the  sourceEndPeriod
        sourceBeginPeriod = sourceEndPeriod + 1;
      }
    }


    // add the Bom from optionDummy to the LT and GT FeatureSetCapacity
    // parts.  Remember that the LT gets a negative usage rate!
    std::string myLTpart = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
						       bbCategory);
    
    std::string myGTpart = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
						       bbCategory);

    float * vecOfOnes = new float[nPeriods];
    int ttt = 0;

    witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBom);

    witAddBomEntry(theWitRun, optionDummy.c_str(), myLTpart.c_str());
    for (ttt=0; ttt<nPeriods; ttt++) 
      vecOfOnes[ttt] = -1.0;
    witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBom, vecOfOnes);
    

    witAddBomEntry(theWitRun, optionDummy.c_str(), myGTpart.c_str());
    for (ttt=0; ttt<nPeriods; ttt++) 
      vecOfOnes[ttt] = 1.0;
    witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBom+1, vecOfOnes);

    delete [] vecOfOnes;

    //   Set the OptionRatioSupply Vols
    //      Re-set the supplyVol to be the feature ratio over
    //         the effective periods.  NOTE: later on we'll do 
    //         an mrp to explode the demand and populate the final
    //         supplyVols

    witSetPartSupplyVol(theWitRun, optionRatioSupply.c_str(), featureRatio);    
    return 0;
}


#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
int
LgFrInitialProblemForSce::sceSetOptionRevenueViaMultiRoute(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
    float * featureRev,
    float periodicInterestRate,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
  // FINISH_ME:  detect if the option is a PURE_OPTION, or if it
  // is a GATING_OPTION.  If its a PURE_OPTION, then put the
  // option revenue, on the substitute arc to NULL_Substitute
  
  int result;
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  bool foundMatch = false;
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // make sure the GPD plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isOperationValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    return -1;
  }

  // Look for the BBCat operation that calls the right option dummy
  int nBom;
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBom; j++) {
    char * child;
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &child);
    std::string pp, g, bb;
    if (mpHelper.isPartSpecialBbCategory(theWitRun, child, pp, g, bb)) {
      // now plug in the mfgOptionPart and create an optionDummy partname
      std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
                                                           bb, mfgOptionPart);
      if (mpHelper.isOperationValid(theWitRun, optionDummy, fileName,
                               dataLine, lineNo, PURELY_OPTIONAL))   {
        if ( lpModelHelper_ != 0) 
          witSetOperationObj1ExecCost(theWitRun, optionDummy.c_str(), featureRev);
	witSetBopEntryExpAversion(theWitRun, optionDummy.c_str(), 0, -featureRev[0]);
        witFree(child);
        return 0;
      }
    }

    // otherwise, check to see if the child is a PURE Option.  That is, if the
    // bom entry has a substitute to a specialNullSubstitute part, then it is
    // a pure option.  The featureRev vector is applied to the obj1SubCost for
    // this subEntry.  Note, there may be multiple bom arcs associated with
    // this option (for featureRatio changes and for pdf source changes).  Therefore
    // don't immediately return after you find one.
    else if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, child)) {      
      std::string childPart = mpHelper.partname(child);
      int nSubs;
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), j, &nSubs);
      if (nSubs == 1) {
        // note: feature revenue is negative.  Need to set it back to positive.
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)
          featureRev[t] = - featureRev[t];
        if (lpModelHelper_ != 0) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), j, 0, featureRev);
        foundMatch = true;  
      }
    }
    
    witFree(child);

  }

  if (! foundMatch) {
    (*theErrFacil)("MissingMfgOptionPart",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << dataLine);
    return -1;
  }
  return 0;
}
#else
int
LgFrInitialProblemForSce::sceSetOptionRevenue(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
    float * featureRev,
    float periodicInterestRate,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
  // FINISH_ME:  detect if the option is a PURE_OPTION, or if it
  // is a GATING_OPTION.  If its a PURE_OPTION, then put the
  // option revenue, on the substitute arc to NULL_Substitute
  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  bool foundMatch = false;
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // make sure the plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    return -1;
  }

  // figure out a unique bbCategory name
  // use the nBom of the topLevel Planner Part
  // bbCategory name is:   STANDALONE:n
  // where n is the current number of BOM entries, NOTE that
  // the optional bbCategory parts will not necessarily be
  // sequential, nor will they start at 0.  But who cares.
  int nBom;
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBom; j++) {
    char * child;
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &child);
    std::string pp, g, bb;
    if (mpHelper.isPartSpecialBbCategory(theWitRun, child, pp, g, bb)) {
      // now plug in the mfgOptionPart and create an optionDummy partname
      std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
                                                           bb, mfgOptionPart);
      if (mpHelper.isPartValid(theWitRun, optionDummy, fileName,
                               dataLine, lineNo, PURELY_OPTIONAL))   {
        if ( lpModelHelper_ != 0) 
          witSetPartObj1ProdCost(theWitRun, optionDummy.c_str(), featureRev);
        witFree(child);
        return 0;
      }
    }

    // otherwise, check to see if the child is a PURE Option.  That is, if the
    // bom entry has a substitute to a specialNullSubstitute part, then it is
    // a pure option.  The featureRev vector is applied to the obj1SubCost for
    // this subEntry.  Note, there may be multiple bom arcs associated with
    // this option (for featureRatio changes and for pdf source changes).  Therefore
    // don't immediately return after you find one.
    else if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, child)) {      
      std::string childPart = mpHelper.partname(child);
      int nSubs;
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), j, &nSubs);
      if (nSubs == 1) {
        // note: feature revenue is negative.  Need to set it back to positive.
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)
          featureRev[t] = - featureRev[t];
        if (lpModelHelper_ != 0) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), j, 0, featureRev);
        foundMatch = true;  
      }
    }
    
    witFree(child);

  }

  if (! foundMatch) {
    (*theErrFacil)("MissingMfgOptionPart",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << dataLine);
    return -1;
  }
  return 0;
}
#endif
      
// ------------------------------------------------------------------
int
LgFrInitialProblemForSce::sceAddMachineFeatureSupplyVol(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
    float *  supplyVol,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{


  // + See comments on ::sceAddStdAloneOptionBomStructure for feature model
  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  // make sure the plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart =
        mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << fileName 
		   << (int)lineNo
		   << dataLine);
    return -1;
  }



  // determine demand sources (pdf's) (hopefully its single sourced)

  int start=0;
  int late=-1;
  while (start < nPeriods) {
    float offset; // not used but needed in method call
    std::string mfgTopLevelBuild = mpHelper.demandSource(theWitRun, 
						       plannerTopLevelPart,
						       geo,
						       start,
						       late,
						       offset,
						       fileName, 
						       dataLine, 
						       lineNo, 
						       PURELY_OPTIONAL);
    std::string pdf = mpHelper.pdf(mfgTopLevelBuild);


    // Now create a specialFeaturePartName of type Customer Choice and check its existence
    // Return a unique standalone Feature Part Name
    std::string specialFeaturePartName;
    
    specialFeaturePartName = mpHelper.custChoiceFeaturePartName(plannerTopLevelPart,
								geo,
								mfgOptionPart,
								pdf);
    witBoolean exists;
    witGetPartExists(theWitRun, specialFeaturePartName.c_str(), &exists);
    // if it doesn't exist, then try for a normal standalone 
    if (! exists) {
      // Now create a specialFeaturePartName of type Standalone and check its existence
      // Return a unique standalone Feature Part Name
      specialFeaturePartName = mpHelper.standaloneFeaturePartName(plannerTopLevelPart,
								  geo,
								  mfgOptionPart,
								  pdf);

      witGetPartExists(theWitRun, specialFeaturePartName.c_str(), &exists);
      if (! exists) {
	(*theErrFacil)("CannotFindFeatureRel",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << plannerTopLevelPart 
		       << geo 
		       << mfgOptionPart 
		       << dataLine);
	return -1;
      }
    }

    // if you get to here, then the part exists and we go ahead and
    // set the feature supply vol (incrementally).  Note: for type
    // customerChoice, we will have to come back later and spread it!
    float * supVol;
    witGetPartSupplyVol(theWitRun, specialFeaturePartName.c_str(), &supVol);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=late; t++) {
      supVol[t] += supplyVol[t];
    }
    witSetPartSupplyVol(theWitRun, specialFeaturePartName.c_str(), supVol);
    witFree(supVol);

    start = late+1;
  }      

  return 0;

}


// ------------------------------------------------------------------
int
LgFrInitialProblemForSce::sceSetMachineFeatureOffset(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
    float offsetVal,
    int featurePhantomFlag,
    int start,
    int end,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{


  // + See comments on ::sceAddStdAloneOptionBomStructure for feature model
  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  // make sure the plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart =
        mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << fileName 
		   << (int)lineNo
		   << dataLine);
    return -1;
  }
  

  int nBomEntries;
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );

  // Now find any bom arcs of fof the GPD that correspond to this 
  // machine feature record.  Note also the the overlaps of effectivities
  // and report errors/warning if necessary.

  bool didWeFindAValidFeatureRelationship = false;
  std::string pdf;
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBomEntries; j++) {
    char * specialFeaturePartName;
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &specialFeaturePartName);
    std::string mfgop;

    // if its NOT a  special feature part then continue
    std::string gg, mm;
    // Returns 1 if operation is EITHER:
    //     special Standalone Feature, 
    //  OR  special Customer Choice Feature,
    if (! mpHelper.isOperationSpecialFeature(theWitRun, specialFeaturePartName, gg, mm, pdf, mfgop)) {
      witFree(specialFeaturePartName);
      continue;
    }

    // Now check to see that the mfgOptionPart of the record matches the 
    // mfgOptionPart of the specialFeaturePart.  IF it doesn't then continue.
    if (mfgop != mfgOptionPart) {
      witFree(specialFeaturePartName);
      continue;
    }
 
    // at this point you have a match with plannerPart.c_str(),geo.c_str(),mfgOptionPart.
    didWeFindAValidFeatureRelationship = true;


    // OVerride the bom offset between specialFeature PArt and the realFeaturePart 
    // but only over the effectivity  specified on the record.  

    float * offset;
    witGetBomEntryOffset(theWitRun, specialFeaturePartName, 0, &offset);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
      offset[t] = offsetVal/theCal.workUnits(t);
    }

    // Now apply a phantome adjustment to the offset
    if (featurePhantomFlag) {
      std::string realFeaturePartName = mpHelper.pdfPartname(mfgop, pdf);
      witBoolean exists;
      witGetPartExists(theWitRun, realFeaturePartName.c_str(), &exists);
      assert(exists);
      float * realFeatureCycleTime;
      witGetPartCycleTime(theWitRun, realFeaturePartName.c_str(), &realFeatureCycleTime);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=start; t<=end; t++) {
	offset[t] -= realFeatureCycleTime[t];
	// FINISH_ME: adjust for VARIABLE_PERIODS
      }
      witFree(realFeatureCycleTime);
    }
    witSetBomEntryOffset(theWitRun, specialFeaturePartName, 0, offset);

    witFree(offset);
    witFree(specialFeaturePartName);

  }

  // What to do if you can't find a valid Feature Relationship?
  if (! didWeFindAValidFeatureRelationship)   {
    (*theErrFacil)("CannotFindFeatureRel",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << dataLine);
    return -1;
  }



  return 0;

}


// This is current solution for SCE 5.X
// ------------------------------------------------------------------
int
LgFrInitialProblemForSce::sceAddCustChoiceFeatureStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & featurePart, 
    float usageRate,
    float * featureRatio,
    float * defaultGatingOptionSubPenalty,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{

  // + -------------------------------------------------
  // + SCE's CUstomer Choice Feature Model is as follows:
  // + -------------------------------------------------
  // + For each cust choice feature record with
  // +     plannerPart, geo, featurePart, f1,f2,...,fNp-1
  // +
  // + 0) We detect customer choice features as a special case of standalone features if the
  // +    maxWithout vector contains an element < 0.  It's kludgy, but hey.
  // +     a) if there  are positive and negative elements to this vector, then it is an error.  
  // +        Furthermore, SCE uses +1.0 as the default for maxwithout.  Therefore, if the 
  // +        feature record is to be a custChoice, then you must fully populate the record.  
  // +     b) For custchoice features, we must have 0.0 <= featratio[t] <= 1.0 for all periods t.
  // + 1) Add specialCustChoiceFeaturePart (one and only one dummy part per machine-feature relationship
  // + 2) Figure out what the realWitFeaturePart is by tracing the geoSource to a realWitMachine
  // +    part to get the PDF and then using the mpHelper to catenate featurePart and PDF.
  // +    This realWitFeaturePart must already exist.
  // +    NOTE: We currently do NOT support the customer choice feature model for Machines that have
  // +    more than one geo source (this is true even if the multiple geo source is changing over time).
  // +    This makes the implementation much easier (although its still pretty intense).
  // + 3) Add bom entry from specialFeaturePart to realWitFeaturePart
  // + 4) Add bom entry between GPD part and specialFeaturePart 
  // +    Set usageRate=1.0 (regardless of featureRatio).  
  // +    Store featureRatio vector in bomAppdata for this bom entry (gpd->sfp)
  // + 5) Add/Locate the custChoiceNullSubstitute part
  // +    If the nullSub part doesn't exist, then create it
  // + 6) Create a subBomEntry between the bom entry for GPD->specialFeaturePart.  Sub part is the
  // +    nullSubPart defined in step 5.
  // +    a) set supplyVol(custChoiceNullSubstitute) = (1-featratio) * mrpProdVol(GPD).
  // +       i) this is done by temporarily storing featratio as the supplyVol of the nullSub
  // +          and then doing an mrp after the model is built.  then we do the arithmetic and
  // +          reset the supplyVol in a method called scePreProcessViaMrp().
  // +    (Note that the featratio gets "stored" in two places during the building of the
  // +    model.  This is simply for convenience so that we don't have to go searching up and
  // +    down through structure to find it.  The storage in bomAppData(gpd->sfp) is permanent
  // +    and needed later in the processing of explosion, second pass implosion,  and reporting.)
  // +    Store featureRatio vector in bomAppdata for this bom entry (gpd->sfp)
  // + 7) Offsets:
  // +    Offsetting is the same for customer choice features and standalone features.
  // +    a)The geo source transit time is applied first:
  // +       bomOffset(GPD->realWitMachine) = geoSourcetransitTime
  // +       bomOffset(GPD->specialFeaturePart) = geoSourceTransitTime
  // +       subBomOffset(GPD->specialFeaturePart,custChoiceNullSubstitute) = geoSourceTransitTime
  // +    b) Now, since features are essentially disconnected from machines, we must ensure
  // +       that the features are subject to the machineCycleTime (in addition to any
  // +       geoSourceTransitTime):
  // +          bomOffset(specialFeaturePart->realWitFeaturePart) = machineCycleTime
  // +    c) Any machine-feature offset (set in a subsequent input file) 
  // +       is an override to the bom offset determined by machineCycleTime.  
  // +          bomOffset(specialFeaturePart->realWitFeaturePart) = machineFeatureOffset
  // +       Note: we do NOT let the mahcineFeatureOffset override the machineCycleTime 
  // +       (perhaps we should).
  // +    d) a phantom flag (set via machine-feature offset file) will cause the
  // +       offset between specialFeaturePart and realFeaturePart to be adjusted 
  // +       so that it cancels out the cycleTime on the real feature part.  
  // +          if (phantomFlag)
  // +             bomOffset(specialFeaturePart->realWitFeaturePart) -= cycleTime(realWitFeaturePart)
  // +    e) Note: the structure of specialFeaturePart and above is "above" the machine 
  // +       cycleTime and feature offsets.  This means that the featureRatio constraint
  // +       mechanism applies to the shipment of product out of the PDF (prior to 
  // +       geoSourceTransitTime).
  // +    f) (IBM NOTE) CycleTime on the topLevelMfgPart (machine at PDF) should not be used for ETIS type
  // +       feeds.  This is because the MTM,PDF will have no bom content, yet the cycleTime 
  // +       will gate anyway.  Plus, the ESAT extract will strictly feed all machine offset
  // +       via machine-feature offset. 
  // + 8) Add a demand to the specialFeaturePart.  This is for the two-pass heuristic. 
  // +    The demandVol is 0.0 for the first pass of heuristic.
  // +    The priority is copied over from the priority of the Machine demand in a later 
  // +    post-processing step.
  // + 9) This model does not work for MRP, so we make an adjustment in the exploder witRun.  
  // +    Namely, since the usageRate along the gpd->specialFeaturePart->realWitFeaturepart chain
  // +    of boms is 1.0 (regardless of featratio), we will be exploding too much demand.  So, to
  // +    remedy this, we add a dummy supply onto the specialFeaturePart.  This supply gets netted
  // +    at the top and explodes the right qty down the structure.  (note: we could have adjusted
  // +    the usageRate on the bom within the exploder witRun, but since feature ratio's can change
  // +    over time, this would have required multiple arcs -- yuck!!!).
  // +      supplyVol(exploderWitRun, specialFeaturePart) += (1-featureRatio) * mrpProdVol(GPD)
  // +    Note that we += this in as supply because there may already be supplyVol of the 
  // +    specialFeaturePart due to MachineFeature supply.
  // + 10) Compute Second Pass Feature Demand Vol:
  // +       Note: this is done after the "first pass" implosion run, in preperation for the second
  // +             pass (feature) implosion.
  // +             a) tiedBackExecVol(GPD): roll the execVol(GPD) (ie, first pass machine ships) back
  // +                                      to the period in which the demand was due.  We do this for
  // +                                      cases where the featureRatio changes over time.
  // +             b) featuresNeeded  = tiedBackExecVol(GPD) * featureRatio (this is the total features
  // +                                  that need to be shipped based on machine commits).
  // +             c) featuresShipped = consVol(specialFeaturePart) + excessVol(specialFeaturePart)
  // +             d) secondPassDemandVol = featuresNeeded - featuresShipped 
  // +             e) "Roll" secondPassDemandVol to carry negatives forward (can happen due to machine
  // +                 feature supply fen5, or weird offset problems).
  // + 
  // + 11) How to calculate OptionRatio output (ie, features shipped):  
  // +       optionRatio = consVol(specialFeaturePart) 
  // +                     + shipVol(specialFeaturePartDemand) 
  // +                     + excessVol(specialFeaturePart)
  // + 
  // + 12) The FSS model for this is, as yet, not implemented.  
  // +
  // + Additional Comments:
  // +   a) Base model is implemented and working.  
  // +   b) There are many special cases to be tested.  Further, these cases can work in a "unit"
  // +      test environment but not work when they occur together.  
  // +     1) ratio's changing over time
  // +     2) feature is primary  gating part
  // +     3) feature is short, but not primary gate.
  // +     4) offsets: transittime, machine cycleTime, mach->feat offset, fature cycletime, feature phantom
  // +   c) This model is similar to standalone features.  Major differences are:
  // +        1) this model can have ratio's change over time and not have to split the bill
  // +        2) we restrict multiple sourcing on the machines for these mach->feature records -- this is 
  // +           not the case for stdAlone features.
  // +        3) because of 1 and 2 above, we assert that there's one and only one:
  // +             gpd->sfp bom
  // +             gpd->sfp, nullSub subBom arc

  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
   
  // make sure the plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart =
        mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() << plannerTopLevelPart << geo << featurePart << fileName << (int)lineNo << dataLine);
    return -1;
  }

  // FINISH_ME: look for any multiple souce opportunities for the GPD.
  // This is not supported and can screw things up later.  Thus we will
  // reject it the feature record here.
  

  // check to see if this record is a duplicate. If there's any 
  // relationship between the geoPlannerDemandPart and
  // a specialFeaturePart whose partName token is the featurePart,
  // then we reject the record.

  int nBomEntries;
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
  char * child;
  
  int j = 0; 
  for (j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
    // Note check against ANY types of feature records
    if ( (featurePart == mpHelper.partname(child)) && mpHelper.isPartSpecialFeature(theWitRun, child)) {
      //    if ( mpHelper.isPartSpecialFeature(theWitRun, child)) {
      // uh-oh, we've got a duplicate record
      (*theErrFacil)("OptionAlreadyDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << featurePart << dataLine);
      witFree ( child );
      return -1;
    }
    witFree ( child );    
  }    

  
  LgFrTimeVecFloat frTVF(nPeriods, featureRatio);

  if (frTVF.max() < 0.00001)  {
    (*theErrFacil)("OptionAllZeroRatiosPO",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << featurePart << dataLine);
    return -1;
  }

  if (frTVF.max() > 1.0)  {
    (*theErrFacil)("CustChoiceFeatRatioGreaterThanOne",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << featurePart << dataLine);
    return -1;
  }

   

  // add Bom:  geoPlannerDemand -->  Real Option Part, FOR EACH GE0-->PDF source!!
  // NOTE:  The usageTime must "equal" the cumulative lead time
  // associated with the pdf->geo transit time and the machineCycleTime
  
  //  We must add a bom record , along with a
  // subBom entry to a maxW/o null part

  // FINISH_ME: for now we are assuming single source gpd.  We must search
  // over the interval and probably put a while loop in that starts at
  // period zero and moves along
  int intervalStartPeriod = 0;
  // changed 03_15_2011
  int geoSourceIntervalEndPeriod = nPeriods - 1;

#ifdef VARIABLE_PERIODS
  LgFrTimeVecFloat transitTimeOffsetTV(nPeriods, 0.0);
  std::string machineFullWitPart = mpHelper.demandSource(theWitRun, plannerTopLevelPart, geo, intervalStartPeriod, geoSourceIntervalEndPeriod,
							 transitTimeOffsetTV,
							 fileName, dataLine, lineNo, MANDATORY);
#else
  float transitTimeScaled;
  std::string machineFullWitPart = mpHelper.demandSource(theWitRun, plannerTopLevelPart, geo, intervalStartPeriod, geoSourceIntervalEndPeriod,
							 transitTimeScaled,
							 fileName, dataLine, lineNo, MANDATORY);
#endif

  // determine the pdf for this source
  std::string pdf(mpHelper.pdf(machineFullWitPart));
  
  // get the full wit name for the real option part
  std::string fullFeaturePart(mpHelper.pdfPartname(featurePart, pdf));
    
  
  // test to see if the real feature part exists at the pdf.  IF NOT,
  // then print a warning and ignore the record 
  if (! mpHelper.isPartValid(theWitRun, fullFeaturePart, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("CannotSourcePureOption",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart 
		   << geo << machineFullWitPart << featurePart << pdf << featurePart << intervalStartPeriod 
		   << geoSourceIntervalEndPeriod << dataLine);
    return -1;
  }


    
  // get the name of the specialFeature part
  std::string specialCCFeaturePartName(mpHelper.custChoiceFeaturePartName(plannerTopLevelPart, 
									geo, 
									featurePart, 
									pdf));
  
  // Add the part and bom structure connecting specialFeature to real feature.
  // This is only done if the part does not already exist
  if (! mpHelper.isPartValid(theWitRun, specialCCFeaturePartName, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL))  {
    
    // Add the part as a product (everything is at its default)
    witAddPartWithOperation(theWitRun, specialCCFeaturePartName.c_str());
    
    // Add the bom entry from special-->real (use default attributes)
    witAddBomEntry(theWitRun, specialCCFeaturePartName.c_str(), fullFeaturePart.c_str());
  }  
  


  // bomIndex = The bom entry number of GPD->SpecialCustChoiceFeatPart
  //      The bom is added here and can be used below
  int bomIndex;
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &bomIndex );
  witAddBomEntry( theWitRun, geoPlannerDemandPart.c_str(), specialCCFeaturePartName.c_str());
  witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, usageRate);
  witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, WitFALSE );
  // store the feature ratio in two places (one is temporary).
  // First store in the bomAppData of the GPD->SCCF bom (this is permanent)
  LgFrSceCustChoiceBomAppData * bomAppDataPtr = new LgFrSceCustChoiceBomAppData(frTVF);
  witSetBomEntryAppData(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, (void *) bomAppDataPtr);
  // Further down, we will store featratio in the  supplyVol of the nullsub

  
  // Set the offsets for the feature structure

  // transit time is applied as a bomOffset between GPD and specialFeaturePart.
  // this transittime qty is stored for our convenience as a BOP entry offset
  // beteen gpd part and gpd operation.  Later this bop offset will be reset to 0.
  // VARIABLE_PERIODS note: transitTimeOffset has already been adjusted for Var Periods
  float * transitTimeOffset;
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, &transitTimeOffset);

  // this is where I am ...

  // The cycleTime of the machine (ie, the topLevelPDF Part for which this feature
  // is associated must be applied as the default machine-feature offset.  
  float * machineCycleTime;
  witGetPartCycleTime(theWitRun, machineFullWitPart.c_str(), &machineCycleTime);


  // machine cycletime is applied to bomOffset between specialCCFeature and featurePart.
  // This will be overridden later possibly by specific machine->feature offset file.
  witSetBomEntryOffset(theWitRun, specialCCFeaturePartName.c_str(), 0, machineCycleTime);
  // transit time gets applied to the bom offset between GPD and specialFeaturePart
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, transitTimeOffset);


  // Now work on adding a substitute arc to the geoPlannerDemandOperation to featurePart BOM entry.

  // First see if a null substitute exists for this
  // geo_plannerDemand_featurePart combination (if not then create one
  // NOTE: for CC features, the nullSub and sccf parts are one to one!

  std::string ccNullSubstitute;
  ccNullSubstitute = mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, featurePart);
  assert(0 == mpHelper.isPartValid(theWitRun, ccNullSubstitute, fileName, 
			     dataLine, lineNo, PURELY_OPTIONAL));

  // FINISH_ME: verify that this nullSub should be a  material instead of capacity
  witAddPart(theWitRun, ccNullSubstitute.c_str(), WitMATERIAL);

  // store the feature ratio in the supplyVol as a temporary means.  Later in a 
  // sce-preprocessing step we will do an explode and set the supplyVol to
  // (1-featratio) * demandVol
  witSetPartSupplyVol(theWitRun, ccNullSubstitute.c_str(), featureRatio);

  // Now add sub arc: (GPD->sCCF)->NullSub. 
  //
  // The defaultGatingOptionSubPenalty is the optionShipReward.  In
  // this case it is put on the sub arc as a cost.  ie, the cost of
  // substituting null, is the lost reward for shipping the option
  int nSubBom;
  witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, &nSubBom);
  witAddSubsBomEntry( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, ccNullSubstitute.c_str() );
  // FINISH_ME: wha is the effectivity of the custchoice sub arcs?
  // we are assuming tha they are full.
  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, transitTimeOffset);

  // 2.30: we must shut off the expAllowed flag
  witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, WitFALSE);

  // if using the lp engine, then set the obj1 sub cost
  if ( lpModelHelper_ != 0 )
    witSetSubsBomEntryObj1SubCost ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom,
				    defaultGatingOptionSubPenalty );
  


  witFree(machineCycleTime);
  witFree(transitTimeOffset);
    
  // Add exactly one demand on the option for every unique geoPlannerDemandPart--option pair.
  // When the heuristic engine implodes, it uses the null substitute before building the feature.
  // To figure out the amount of features that can be built, the
  // hEngMgr or aEngMgr loads the demands on the features and does an additional implosion.
  std::string returnedPlannerTopLevelPart;
  std::string returnedGeo;
  std::string demandName = mpHelper.custChoiceFeatureDemandName( geoPlannerDemandPart );
  if (!( mpHelper.isDemandSpecialCustChoiceFeature(theWitRun,
						   specialCCFeaturePartName,
						   demandName,
						   returnedPlannerTopLevelPart,
						   returnedGeo))) {
    witAddDemand ( theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str() );


  }

  return 0;

}


  // + -------------------------------------------------
  // + ----------- SCE 6.1 -----------------------------
  // + -------------------------------------------------
  // + SCE's CUstomer Choice Feature Model is as follows:
  // + -------------------------------------------------
  // + For each cust choice feature record with
  // +     plannerPart, geo, featurePart, f1,f2,...,fNp-1
  // +
  // + 0) We detect customer choice features as a special case of standalone features if the
  // +    maxWithout vector contains an element < 0.  It's kludgy, but hey.
  // +     a) if there  are positive and negative elements to this vector, then it is an error.  
  // +        Furthermore, SCE uses +1.0 as the default for maxwithout.  Therefore, if the 
  // +        feature record is to be a custChoice, then you must fully populate the record.  
  // +     b) For custchoice features, we must have 0.0 <= featratio[t] <= 1.0 for all periods t.
  // + 1) Add specialCustChoiceFeaturePart (one and only one dummy part per machine-feature relationship
  // + 2) Figure out what the realWitFeaturePart is by tracing the geoSource to a realWitMachine
  // +    part to get the PDF and then using the mpHelper to catenate featurePart and PDF.
  // +    This realWitFeaturePart must already exist.
  // +    NOTE: We currently do NOT support the customer choice feature model for Machines that have
  // +    more than one geo source (this is true even if the multiple geo source is changing over time).
  // +    This makes the implementation much easier (although its still pretty intense).
  // + 3) Add bom entry from specialFeaturePart to realWitFeaturePart
  // + 4) Add bom entry between GPD part and specialFeaturePart 
  // +    Set usageRate=1.0 (regardless of featureRatio).  
  // +    Store featureRatio vector in bomAppdata for this bom entry (gpd->sfp)
  // + 5) Add/Locate the custChoiceNullSubstitute part
  // +    If the nullSub part doesn't exist, then create it
  // + 6) Create a subBomEntry between the bom entry for GPD->specialFeaturePart.  Sub part is the
  // +    nullSubPart defined in step 5.
  // +    a) set supplyVol(custChoiceNullSubstitute) = (1-featratio) * mrpProdVol(GPD).
  // +       i) this is done by temporarily storing featratio as the supplyVol of the nullSub
  // +          and then doing an mrp after the model is built.  then we do the arithmetic and
  // +          reset the supplyVol in a method called scePreProcessViaMrp().
  // +    (Note that the featratio gets "stored" in two places during the building of the
  // +    model.  This is simply for convenience so that we don't have to go searching up and
  // +    down through structure to find it.  The storage in bomAppData(gpd->sfp) is permanent
  // +    and needed later in the processing of explosion, second pass implosion,  and reporting.)
  // +    Store featureRatio vector in bomAppdata for this bom entry (gpd->sfp)
  // + 7) Offsets:
  // +    Offsetting is the same for customer choice features and standalone features.
  // +    a)The geo source transit time is applied first:
  // +       bomOffset(GPD->realWitMachine) = geoSourcetransitTime
  // +       bomOffset(GPD->specialFeaturePart) = geoSourceTransitTime
  // +       subBomOffset(GPD->specialFeaturePart,custChoiceNullSubstitute) = geoSourceTransitTime
  // +    b) Now, since features are essentially disconnected from machines, we must ensure
  // +       that the features are subject to the machineCycleTime (in addition to any
  // +       geoSourceTransitTime):
  // +          bomOffset(specialFeaturePart->realWitFeaturePart) = machineCycleTime
  // +    c) Any machine-feature offset (set in a subsequent input file) 
  // +       is an override to the bom offset determined by machineCycleTime.  
  // +          bomOffset(specialFeaturePart->realWitFeaturePart) = machineFeatureOffset
  // +       Note: we do NOT let the mahcineFeatureOffset override the machineCycleTime 
  // +       (perhaps we should).
  // +    d) a phantom flag (set via machine-feature offset file) will cause the
  // +       offset between specialFeaturePart and realFeaturePart to be adjusted 
  // +       so that it cancels out the cycleTime on the real feature part.  
  // +          if (phantomFlag)
  // +             bomOffset(specialFeaturePart->realWitFeaturePart) -= cycleTime(realWitFeaturePart)
  // +    e) Note: the structure of specialFeaturePart and above is "above" the machine 
  // +       cycleTime and feature offsets.  This means that the featureRatio constraint
  // +       mechanism applies to the shipment of product out of the PDF (prior to 
  // +       geoSourceTransitTime).
  // +    f) (IBM NOTE) CycleTime on the topLevelMfgPart (machine at PDF) should not be used for ETIS type
  // +       feeds.  This is because the MTM,PDF will have no bom content, yet the cycleTime 
  // +       will gate anyway.  Plus, the ESAT extract will strictly feed all machine offset
  // +       via machine-feature offset. 
  // + 8) Add a demand to the specialFeaturePart.  This is for the two-pass heuristic. 
  // +    The demandVol is 0.0 for the first pass of heuristic.
  // +    The priority is copied over from the priority of the Machine demand in a later 
  // +    post-processing step.
  // + 9) This model does not work for MRP, so we make an adjustment in the exploder witRun.  
  // +    Namely, since the usageRate along the gpd->specialFeaturePart->realWitFeaturepart chain
  // +    of boms is 1.0 (regardless of featratio), we will be exploding too much demand.  So, to
  // +    remedy this, we add a dummy supply onto the specialFeaturePart.  This supply gets netted
  // +    at the top and explodes the right qty down the structure.  (note: we could have adjusted
  // +    the usageRate on the bom within the exploder witRun, but since feature ratio's can change
  // +    over time, this would have required multiple arcs -- yuck!!!).
  // +      supplyVol(exploderWitRun, specialFeaturePart) += (1-featureRatio) * mrpProdVol(GPD)
  // +    Note that we += this in as supply because there may already be supplyVol of the 
  // +    specialFeaturePart due to MachineFeature supply.
  // + 10) Compute Second Pass Feature Demand Vol:
  // +       Note: this is done after the "first pass" implosion run, in preperation for the second
  // +             pass (feature) implosion.
  // +             a) tiedBackExecVol(GPD): roll the execVol(GPD) (ie, first pass machine ships) back
  // +                                      to the period in which the demand was due.  We do this for
  // +                                      cases where the featureRatio changes over time.
  // +             b) featuresNeeded  = tiedBackExecVol(GPD) * featureRatio (this is the total features
  // +                                  that need to be shipped based on machine commits).
  // +             c) featuresShipped = consVol(specialFeaturePart) + excessVol(specialFeaturePart)
  // +             d) secondPassDemandVol = featuresNeeded - featuresShipped 
  // +             e) "Roll" secondPassDemandVol to carry negatives forward (can happen due to machine
  // +                 feature supply fen5, or weird offset problems).
  // + 
  // + 11) How to calculate OptionRatio output (ie, features shipped):  
  // +       optionRatio = consVol(specialFeaturePart) 
  // +                     + shipVol(specialFeaturePartDemand) 
  // +                     + excessVol(specialFeaturePart)
  // + 
  // + 12) The FSS model for this is, as yet, not implemented.  
  // +
  // + Additional Comments:
  // +   a) Base model is implemented and working.  
  // +   b) There are many special cases to be tested.  Further, these cases can work in a "unit"
  // +      test environment but not work when they occur together.  
  // +     1) ratio's changing over time
  // +     2) feature is primary  gating part
  // +     3) feature is short, but not primary gate.
  // +     4) offsets: transittime, machine cycleTime, mach->feat offset, fature cycletime, feature phantom
  // +   c) This model is similar to standalone features.  Major differences are:
  // +        1) this model can have ratio's change over time and not have to split the bill
  // +        2) we restrict multiple sourcing on the machines for these mach->feature records -- this is 
  // +           not the case for stdAlone features.
  // +        3) because of 1 and 2 above, we assert that there's one and only one:
  // +             gpd->sfp bom
  // +             gpd->sfp, nullSub subBom arc
// ------------------------------------------------------------------

int
LgFrInitialProblemForSce::sceAddCustChoiceFeatureStructure61(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar   & theCal,
    const std::string    & plannerTopLevelPart, 
    const std::string    & geo,
    const std::string    & mfgOptionPart, 
    float                  usageRate,
    float                  attachRate,
    float                  mfOffsetVal,
    int                    mfoPhantomFlag,
    float                  mfSupplyVol,
    int                    earlyPeriod,
    int                    latePeriod,
    float                * defaultGatingOptionSubPenalty,
    const std::string    & fileName,
    const std::string    & dataLine,
    long                   lineNo)
{

  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);
  int t;

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // Determine the GPD part name ... and see if it exists   
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() << plannerTopLevelPart << geo << mfgOptionPart << fileName << (int)lineNo << dataLine);
    return -1;
  }

  // reject if attachRate=0.0, unless we need to set it for effectivity reasons
  if (attachRate < 0.00001)  {
    (*theErrFacil)("OptionAllZeroRatiosPO",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
    return -1;
  }

  if (attachRate > 1.0)  {
    (*theErrFacil)("CustChoiceFeatRatioGreaterThanOne",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
    return -1;
  }


  // FINISH_ME_61: D2O guarantees no multi-source right ???? Can we get rid of these checks ???



  // check to see if this record is a duplicate. If there's any 
  // relationship between the geoPlannerDemandPart and
  // a specialFeaturePart whose partName token is the mfgOptionPart,
  // then we reject the record.
  int nBomEntries;
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
  char * child;
  
  // Duplicate records:  For now we reject if there is already a GPD->specialFeature relationship.  
  //  We need to be smarter.  
  //     -- compare horizons, and modify/etc.  this is a FINISH_ME_61
  int j = 0; 
  for (j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
    // Note check against ANY types of feature records.  Reject if match
    if ( (mfgOptionPart == mpHelper.partname(child)) && mpHelper.isPartSpecialFeature(theWitRun, child)) {
      (*theErrFacil)("OptionAlreadyDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
      witFree ( child );
      return -1;
    }
    witFree ( child );    
  }    


  std::string sourceLocPdf;
  // determine the full wit name for the Box at the sourceLocPdf
  std::string mfgBoxPartName = mpHelper.mfgTopPartForGpd(theWitRun, plannerTopLevelPart, geo, sourceLocPdf);

  // get the full wit name for the real option part
  std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, sourceLocPdf));
  
    
  
  // test to see if the real feature part exists at the pdf.  IF NOT,
  // then print a warning and ignore the record 
  if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("CannotSourcePureOption",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart 
		   << geo << mfgBoxPartName << mfgOptionPart << sourceLocPdf << mfgOptionPart << earlyPeriod 
		   << latePeriod << dataLine);
    return -1;
  }
  

  // determine  name of specialCCFeaturePart
  std::string specialCCFeaturePartName(mpHelper.custChoiceFeaturePartName(plannerTopLevelPart, geo, mfgOptionPart, sourceLocPdf));
  int doesSpecialCCFeaturePartAlreadyExist = mpHelper.isPartValid(theWitRun, specialCCFeaturePartName, fileName, dataLine, lineNo, PURELY_OPTIONAL);
    

  // Easy Case !!  create new part/structure
  if (! doesSpecialCCFeaturePartAlreadyExist)  {
    witAddPartWithOperation(theWitRun, specialCCFeaturePartName.c_str());
    witAddBomEntry(theWitRun, specialCCFeaturePartName.c_str(), fullOptionPartName.c_str());
    
    
    // ==> Add BOM entry   connecting GPD->SpecialCustChoiceFeatPart
    //              bomIndex = The bom entry number of GPD->SpecialCustChoiceFeatPart
    int bomIndex;
    witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &bomIndex );
    witAddBomEntry( theWitRun, geoPlannerDemandPart.c_str(), specialCCFeaturePartName.c_str());
    LgFrTimeVecFloat consRate(nPeriods, usageRate);
    witSetBomEntryConsRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, consRate.data());
    witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, WitFALSE );
    
    // store the feature ratio in two places (one is temporary).
    // for legacy reasons, we store it as a timeVec.
    // First store in the bomAppData of the GPD->SCCF bom (this is permanent)
    // Further down, we will store featratio in the  supplyVol of the nullsub
    LgFrTimeVecFloat frTVF(nPeriods, attachRate);
    LgFrSceCustChoiceBomAppData * bomAppDataPtr = new LgFrSceCustChoiceBomAppData(frTVF);
    witSetBomEntryAppData(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, (void *) bomAppDataPtr);


    // Set Offsets on specialFeaturePartName
    //       ... function of (mfgBoxCycleTimeDays, mfOffset, mfoPhantomFlag, mfgOptionPartCycleTimeDays)
    LgFrTimeVecFloat offsetTV(nPeriods, 0.0);
    LgFrTimeVecFloat mfgBoxCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, mfgBoxPartName);

    // mfoPhantom bills get a cycleTimeDays that is offset of mfgOptionPart's cycleTime.  
    if (mfoPhantomFlag) {
      LgFrTimeVecFloat optionCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullOptionPartName);
      for (t=earlyPeriod; t<=latePeriod; t++) {
	offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal - optionCycleTimeDays[t], t, theCal, nPeriods);
      }
    }
    else   {
      for (t=earlyPeriod; t<=latePeriod; t++) {
	offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal, t, theCal, nPeriods);
      }
    }
    witSetBomEntryOffset(theWitRun, specialCCFeaturePartName.c_str(), 0, offsetTV.data());
    

    // Now work on adding a substitute arc to the geoPlannerDemandOperation to mfgOptionPart BOM entry.
    
    // First see if a null substitute exists for this
    // geo_plannerDemand_mfgOptionPart combination (if not then create one
    // NOTE: for CC features, the nullSub and sccf parts are one to one!
    std::string ccNullSubstitute = mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart);
    assert(0 == mpHelper.isPartValid(theWitRun, ccNullSubstitute, fileName, dataLine, lineNo, PURELY_OPTIONAL));
    
    // FINISH_ME: verify that this nullSub should be a  material instead of capacity
    witAddPart(theWitRun, ccNullSubstitute.c_str(), WitMATERIAL);
    
    // store the feature ratio in the supplyVol as a temporary means.  Later in a 
    // sce-preprocessing step we will do an explode and set the supplyVol to
    // (1-featratio) * demandVol
    witSetPartSupplyVol(theWitRun, ccNullSubstitute.c_str(), frTVF.data());
    
    // Now add sub arc: (GPD->sCCF)->NullSub. 
    //
    // The defaultGatingOptionSubPenalty is the optionShipReward.  In
    // this case it is put on the sub arc as a cost.  ie, the cost of
    // substituting null, is the lost reward for shipping the option
    int nSubBom;
    witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, &nSubBom);
    witAddSubsBomEntry( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, ccNullSubstitute.c_str() );
    // FINISH_ME: what is the effectivity of the custchoice sub arcs?
    //            we are assuming that they are full.
    // confirm that subBomOffset is zero (used to be transitTime on GPD)
    //  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, offsetTV.data());
    
    // Shut off the expAllowed flag
    // NOte that offest on the subBom to ccNullSub should be zero
    // witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, WitFALSE);
    
    // if using the lp engine, then set the obj1 sub cost
    if ( lpModelHelper_ != 0 )
      witSetSubsBomEntryObj1SubCost (theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, defaultGatingOptionSubPenalty );
    
    
    // Add exactly one demand on the option for every unique geoPlannerDemandPart--option pair.
    // When the heuristic engine implodes, it uses the null substitute before building the feature.
    // To figure out the amount of features that can be built, the
    // hEngMgr or aEngMgr loads the demands on the features and does an additional implosion.
    std::string returnedPlannerTopLevelPart;
    std::string returnedGeo;
    std::string demandName = mpHelper.custChoiceFeatureDemandName( geoPlannerDemandPart );
    if (!( mpHelper.isDemandSpecialCustChoiceFeature(theWitRun, specialCCFeaturePartName, demandName, returnedPlannerTopLevelPart, returnedGeo))) {
      witAddDemand ( theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str() );
    }
    
  }
  
  // harder case, what to do if part already exists ...
  if (doesSpecialCCFeaturePartAlreadyExist)  {
    
  }

  return 0;

}








// ------------------------------------------------------------------
int
LgFrInitialProblemForSce::sceAddStdAloneOptionBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
    float usageRate,
    float * featureRatio,
    float * maxWithout,
    float * defaultGatingOptionSubPenalty,
    int   featureType,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{

  // FINISH_ME:  we can now use wit's consRate (timeVec) instead of usageRate (scalar) to possibly 
  //             simplify this model!!

  // + SCE's Feature Model is as follows:
  // + For each feature record with
  // +     plannerPart, geo, mfgOptionPart, f1,f2,...,fNp-1,mwo1,mwo2,...,mwoNp-1
  // +
  // + 1) Add specialFeaturePart (one and only one dummy part per machine-feature relationship
  // +    NOte: this is in test, its a bigger model but fixes some issues with feature offsets
  // + 2) Figure out what the mfgOptionPart is by tracing the geoSource to a mfgTopLevel
  // +    part to get the PDF.  Then create a mfgOptionPart using mfgOptionPart and PDF.
  // +    Hence mfgOptionPart is a full Wit part name
  // + 3) Add bom entry from specialFeaturePart to mfgOptionPart
  // + 4) Add bom entry between specialGPD part and specialFeaturePart (featureRatio determines
  // +    usageRate.  Also, usageTime must be set specially ... see note below)
  // + 5) Add/Locate a NullSubstitute part
  // +    i) determine what type of nullSub to use:
  // +         if (the option is NOT GATING (ie, mwo=1 for all periods))
  // +         then use a globalNullSubstitute 
  // +         else if (the option is GATING AND MANDATORY (ie, mwo=0 for all periods))
  // +         then use a globalMaxWithoutNullSubstitute 
  // +         else (the option is GATING AND NON-MANDATORY (ie, 0<mwo<1 in some period))
  // +         then use a maxWithoutNullSubstitute
  // +       Note: that for Gating and Non-Mandatory, a dummy part is created for each record,
  // +             whereas a global one is used for the other two cases.
  // +    ii) If the nullSub part doesn't exist, then create it
  // + 6) Create a subBomEntry between the bom entry for GPD->specialFeaturePart.  Sub part is the
  // +    nullSubPart defined in step 5.
  // +    a) subBom offset is the transitTime 
  // + 7) Offsets:
  // +    a) TransitTime is set via BOM offset between GPD operation and  TopLevelPart (machine).
  // +       TransitTime is also set via BOM offset between GPD operation and  special Feature part.
  // +       TransitTime is also set via SubBOM offset between GPD, specialFeaturePart, and NullSub.
  // +    b) topLevelPartPDF cycleTime is set as the bom offset between  special feature part and
  // +       the real feature part.
  // +    c) Any machine-feature offset is an override to the bom offset between
  // +       specialFeaturePart and the real feature part.  (ie, it overides the machine offset
  // +       default that was previosuly set).  
  // +    d) a phantom flag (set via machine-feature offset file) will cause the
  // +       offset between specialFeaturePart and realFeaturePart to be adjusted 
  // +       so that it cancels out the cycleTime on the real feature part.  
  // + 8) Additional gotcha's and bugginess.
  // +    a) Feature ratios can change over time and this must be mapped to multiple
  // +       bom arcs with effective intervals
  // + 9) CycleTime on the topLevelMfgPart (machine at PDF) should not be used for ETIS type
  // +    feeds.  This is because the MTM,PDF will have no bom content, yet the cycleTime 
  // +    will gate anyway.  Plus, the ESAT extract will strictly feed all machine offset
  // +    via machine-feature offset. 
  // + 10) A specific machine->feature supplyVol is added (accumulated) at the specialFeaturePart
  // +    This allows the user to "adjust" machine content/ratio's (in IBM this applies to 
  // +    TYPE 5 front end netting (FEN(5))
  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  // make sure the plannerTopLevel Special Demand Part exists
  std::string geoPlannerDemandPart =
        mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, 
                             dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << fileName 
		   << (int)lineNo
		   << dataLine);
    return -1;
  }
  

  // check to see if this record is a duplicate. If there's any 
  // relationship between the geoPlannerDemandPart and
  // a specialFeaturePart whose partName token is the mfgOptionPart,
  // then we reject the record.
  int nBomEntries;
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
  char * child;
  int j = 0; 
  for (j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
    std::string pdf;
    std::string childFeaturePart;
    std::string gg, mm;
    if ( mpHelper.isPartSpecialStandaloneFeature(theWitRun, child, gg, mm, pdf, childFeaturePart) ) {
      //    if ( mpHelper.isPartSpecialStandaloneFeature(theWitRun, child, gg, mm, pdf, mfgOptionPart) ) {
      if (childFeaturePart == mfgOptionPart) {
        // uh-oh, we've got a duplicate record
	(*theErrFacil)("OptionAlreadyDefined",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << plannerTopLevelPart 
		       << geo 
		       << mfgOptionPart 
		       << dataLine);
        witFree ( child );
        return -1;
      }
    }
    witFree ( child );    
  }    



  
  
  //  Determine the first period that has non-Zero Ratio.
  //  Note: the logic of this method does NOT maintain independence
  //        between the feature ratios and the maxWithOut ratios.

  int firstPeriodWithRatio = nPeriods;
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
    if (featureRatio[t] > 0.0)  {
      firstPeriodWithRatio = t;
      break;
    }

  if (firstPeriodWithRatio == nPeriods)  {
    (*theErrFacil)("OptionAllZeroRatiosPO",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << mfgOptionPart 
		   << dataLine);
    return -1;
  }

  // The strategy is to set the usage rates on these bom entries to
  // the feature ratio.  One blip is that the ratio's are input as
  // vectors, and now must be mapped to scalars.  This is done with
  // multiple arcs -- yukk!
  int intervalStartPeriod = firstPeriodWithRatio;
  int intervalEndPeriod;
  int ratioIntervalEndPeriod;

  while (intervalStartPeriod < nPeriods) {

    // first compute the interval End period based on ratios.  We  will
    // also check for a tighter interval end period based on geo sourcing
    // later in this loop
    ratioIntervalEndPeriod = nPeriods - 1;
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=intervalStartPeriod; t<nPeriods; t++) {
      if (fabs(featureRatio[intervalStartPeriod] - featureRatio[t]) > 0.0001) {
        ratioIntervalEndPeriod = t-1;
        assert(intervalStartPeriod <= ratioIntervalEndPeriod);
        break;
      }
    }

    // add Bom:  geoPlannerDemand -->  Real Option Part, FOR EACH GE0-->PDF source!!
    // NOTE:  The usageTime must "equal" the cumulative lead time
    // associated with the pdf->geo transit time and the cycleTime
    // on the mfgTopLevelPart.

    // OK, We now have identified an interval where the feature ratio is
    // constant.  We must add a bom record for each interval, along with a
    // subBom entry to a maxW/o null part
    int geoSourceIntervalEndPeriod = nPeriods - 1;
    float transitTimeScaled;
    std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
                                                      plannerTopLevelPart,
                                                      geo,
                                                      intervalStartPeriod,
                                                      geoSourceIntervalEndPeriod,
                                                      transitTimeScaled,
                                                      fileName,
                                                      dataLine,
                                                      lineNo,
                                                      MANDATORY);

    // the interval end is the min of the ratio end and the geo source end
    intervalEndPeriod = (ratioIntervalEndPeriod < geoSourceIntervalEndPeriod)
      ? ratioIntervalEndPeriod : geoSourceIntervalEndPeriod;


    // determine the pdf for this source
    std::string pdf(mpHelper.pdf(mfgTopLevelPart));
    
    // get the full wit name for the real option part
    std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
    

    // test to see if the real option part exists at the pdf.  IF NOT,
    // then print a warning and ignore the record 
    if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, 
                               dataLine, lineNo, PURELY_OPTIONAL))  {
      (*theErrFacil)("CannotSourcePureOption",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << mfgTopLevelPart 
		     << mfgOptionPart 
		     << pdf 
		     << mfgOptionPart 
		     << intervalStartPeriod 
		     << geoSourceIntervalEndPeriod 
		     << dataLine);
      intervalStartPeriod = intervalEndPeriod + 1;
      return -1;
    }


    
    // get the name of the specialFeature part
    std::string specialFeaturePartName(mpHelper.standaloneFeaturePartName(plannerTopLevelPart, 
									geo, 
									mfgOptionPart, 
									pdf));
    
    // Add the part and bom structure connecting specialFeature to real feature.
    // This is only done if the part does not already exist
    if (! mpHelper.isPartValid(theWitRun, specialFeaturePartName, fileName, 
                               dataLine, lineNo, PURELY_OPTIONAL))  {
      // Add the part as a product (everything is at its default)
      witAddPartWithOperation(theWitRun, specialFeaturePartName.c_str());

#if 0
      // Lotsizing of Features ... This needs to be thought about some more ...
      int nPeriods;
      witGetNPeriods(theWitRun, &nPeriods);
      LgFrTimeVecFloat nonIntLotSize(nPeriods, 0.01);
      witSetOperationMinLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());
      witSetOperationIncLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());
#endif

      // Add the bom entry from special-->real (use default attributes)
      witAddBomEntry(theWitRun, specialFeaturePartName.c_str(), fullOptionPartName.c_str());
    }  
    


    int bomIndex;
    witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &bomIndex );
    witAddBomEntry( theWitRun, geoPlannerDemandPart.c_str(), specialFeaturePartName.c_str());
    witSetBomEntryEarliestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  intervalStartPeriod );
    witSetBomEntryLatestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  intervalEndPeriod );
    float finalUsageRate = usageRate * featureRatio[intervalStartPeriod];
    witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, finalUsageRate );
    witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, WitFALSE );


    // Set the offsets for the feature structure

    // transit time is applied as a bomOffset between GPD and specialFeaturePart.
    // this transittime qty is stored for our convenience as a BOP entry offset
    // beteen gpd part and gpd operation.  Later this bop offset will be reset to 
    // 0.
    float * transitTimeOffset;
    witGetBopEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, &transitTimeOffset);
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, transitTimeOffset);

    // The cycleTime of the machine (ie, the topLevelPDF Part for which this feature
    // is associated must be applied as the default machine-feature offset.  
    float * mfgTopLevelCycleTime;
    witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);


    // machine cycletime is applied to bomOffset between specialFeature and mfgOptionPart.
    // This will be overridden later possibly by specific machine->feature offset file.
    witSetBomEntryOffset(theWitRun, specialFeaturePartName.c_str(), 0, mfgTopLevelCycleTime);
    // transit time gets applied to the bom offset between GPD and specialFeaturePart
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, transitTimeOffset);


    // Now work on adding a substitute arc to the geoPlannerDemandPart to mfgOptionPart BOM entry.
    //
    // Pick the right kind of nullSub to substitute: either a globalMaxWithoutNullSubstitute,
    //   a maxWithoutNullSubstitute, or a globalNullSubstitute.
    //
    // If featureType=SCE_FEATURE_TYPE_MANDATORY,       use a globalMaxWithoutNullSubstitute.
    // If featureType=SCE_FEATURE_TYPE_MWO,             use a maxWithoutNullSubstitute.
    // If featureType=SCE_FEATURE_TYPE_PURELY_OPTIONAL, use a globalNullSubstitute.
    //

    std::string nullSubstitute;
    if (featureType == SCE_FEATURE_TYPE_MANDATORY) {
      nullSubstitute = mpHelper.globalMaxWithoutNullSubstitute(pdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, 
				 dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_MWO) {
      nullSubstitute = mpHelper.maxWithoutNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, 
				 dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	// Sneak the maxWithout into the supplyVol of the maxWithoutNullSubstitite
	// unless its a very small number
	if (finalUsageRate > IPSCE_FLT_EPS) 
	  witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), maxWithout);
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_PURELY_OPTIONAL) {
      nullSubstitute = mpHelper.globalNullSubstitute(pdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, 
                                 dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
	witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), bigMsupply.data());
      }
    }

    else {
      std::cerr << "About to die: featureType =" << featureType << "\n";
      assert(featureType == -500);
    }

    // store the maxWithout in the appdata of the SpecialFeaturePart
    LgFrScePartAppData * appDataPtr;
    LgFrTimeVecFloat maxWithoutTV(nPeriods, maxWithout);
    witGetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void **) &appDataPtr);
    if (appDataPtr == 0) {
      appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      appDataPtr->maxWithout(maxWithoutTV);
      witSetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void *) appDataPtr);
    }
    else 
      appDataPtr->maxWithout(maxWithoutTV);      
    


    // Regardless of featureType:
    // now add the sub arc.  You must get the bom number of the bom
    // to be subbed off of.  Fortunately, you can get it easily.
    // How?, You just added the "last" bom entry and now you want
    // to sub off it.  So the bom entry number is nBom - 1.
    //
    // The defaultGatingOptionSubPenalty is the optionShipReward.  In
    // this case it is put on the sub arc as a cost.  ie, the cost of
    // substituting null, is the lost reward for shipping the option
    int nBom;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
    assert(nBom > 0);
    int nSubBom;
    witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, &nSubBom);
    witAddSubsBomEntry(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nullSubstitute.c_str());
    // 2.30: must shutt off expAllowed
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, WitFALSE);
    witSetSubsBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalStartPeriod);
    witSetSubsBomEntryLatestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalEndPeriod);
    witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, transitTimeOffset);
    // if using the lp engine, then set the obj1 sub cost
    if (lpModelHelper_ != 0)
      witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, defaultGatingOptionSubPenalty);


    witFree(mfgTopLevelCycleTime);
    witFree(transitTimeOffset);
    
    // Add exactly one demand on the option for every unique geoPlannerDemandPart--option pair.
    // When the heuristic engine implodes, it uses the null substitute before building the feature.
    // To figure out the amount of features that can be built, the
    // hEngMgr or aEngMgr loads the demands on the features and does an additional implosion.
    std::string returnedPlannerTopLevelPart;
    std::string returnedGeo;
    std::string demandName = mpHelper.pureOptionBuildDemandName( geoPlannerDemandPart );
    if (!( mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun,
                                                           specialFeaturePartName,
                                                           demandName,
                                                           returnedPlannerTopLevelPart,
                                                           returnedGeo))) {
      witAddDemand(theWitRun, specialFeaturePartName.c_str(), demandName.c_str() );

    }
    
    intervalStartPeriod = intervalEndPeriod + 1;
  }

  return 0;

}






// ------------------------------------------------------------------
int
LgFrInitialProblemForSce::sceAddStdAloneOptionBomStructure61(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar   & theCal,
    const std::string    & plannerTopLevelPart, 
    const std::string    & geo,
    const std::string    & mfgOptionPart, 
    float                  usageRate,
    float                  attachRate,
    float                  maxWithout,
    float                  mfOffsetVal,
    int                    mfoPhantomFlag,
    float                  mfSupplyVal,
    float                * defaultGatingOptionSubPenalty,
    int                    earlyPeriod,
    int                    latePeriod,
    int                    featureType,
    const std::string    & fileName,
    const std::string    & dataLine,
    long                   lineNo)
{

  // + SCE's Feature Model is as follows:
  // + For each feature record with
  // +     plannerPart, geo, mfgOptionPart, f1,f2,...,fNp-1,mwo1,mwo2,...,mwoNp-1
  // +
  // + 1) Add specialFeaturePart (one and only one dummy part per machine-feature relationship
  // +    NOte: this is in test, its a bigger model but fixes some issues with feature offsets
  // + 2) Figure out what the mfgOptionPart is by tracing the geoSource to a mfgTopLevel
  // +    part to get the PDF.  Then create a mfgOptionPart using mfgOptionPart and PDF.
  // +    Hence mfgOptionPart is a full Wit part name
  // + 3) Add bom entry from specialFeaturePart to mfgOptionPart
  // + 4) Add bom entry between specialGPD part and specialFeaturePart (featureRatio determines
  // +    usageRate.  Also, usageTime must be set specially ... see note below)
  // + 5) Add/Locate a NullSubstitute part
  // +    i) determine what type of nullSub to use:
  // +         if (the option is NOT GATING (ie, mwo=1 for all periods))
  // +         then use a globalNullSubstitute 
  // +         else if (the option is GATING AND MANDATORY (ie, mwo=0 for all periods))
  // +         then use a globalMaxWithoutNullSubstitute 
  // +         else (the option is GATING AND NON-MANDATORY (ie, 0<mwo<1 in some period))
  // +         then use a maxWithoutNullSubstitute
  // +       Note: that for Gating and Non-Mandatory, a dummy part is created for each record,
  // +             whereas a global one is used for the other two cases.
  // +    ii) If the nullSub part doesn't exist, then create it
  // + 6) Create a subBomEntry between the bom entry for GPD->specialFeaturePart.  Sub part is the
  // +    nullSubPart defined in step 5.
  // +    a) subBom offset is the transitTime 
  // + 7) Offsets:
  // +    a) TransitTime is set via BOM offset between GPD operation and  TopLevelPart (machine).
  // +       TransitTime is also set via BOM offset between GPD operation and  special Feature part.
  // +       TransitTime is also set via SubBOM offset between GPD, specialFeaturePart, and NullSub.
  // +    b) topLevelPartPDF cycleTime is set as the bom offset between  special feature part and
  // +       the real feature part.
  // +    c) Any machine-feature offset is an override to the bom offset between
  // +       specialFeaturePart and the real feature part.  (ie, it overides the machine offset
  // +       default that was previosuly set).  
  // +    d) a phantom flag (set via machine-feature offset file) will cause the
  // +       offset between specialFeaturePart and realFeaturePart to be adjusted 
  // +       so that it cancels out the cycleTime on the real feature part.  
  // + 8) Additional gotcha's and bugginess.
  // +    a) Feature ratios can change over time and this must be mapped to multiple
  // +       bom arcs with effective intervals
  // + 9) CycleTime on the topLevelMfgPart (machine at PDF) should not be used for ETIS type
  // +    feeds.  This is because the MTM,PDF will have no bom content, yet the cycleTime 
  // +    will gate anyway.  Plus, the ESAT extract will strictly feed all machine offset
  // +    via machine-feature offset. 
  // + 10) A specific machine->feature supplyVol is added (accumulated) at the specialFeaturePart
  // +    This allows the user to "adjust" machine content/ratio's (in IBM this applies to 
  // +    TYPE 5 front end netting (FEN(5))
  
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);
  int t;

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  // Determine the GPD part name ... and see if it exists
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
  if (! mpHelper.isPartValid(theWitRun, geoPlannerDemandPart, fileName, dataLine, lineNo, PURELY_OPTIONAL))   {
    (*theErrFacil)("PartDoesNotExistb",MclArgList() << plannerTopLevelPart << geo << mfgOptionPart << fileName << (int)lineNo << dataLine);
    return -1;
  }
  
  
  // reject if attachRate=0.0, unless we need to set it for effectivity reasons
  if (attachRate == 0.0)  {
    (*theErrFacil)("OptionAllZeroRatiosPO",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
    return -1;
  }

  std::string sourceLocPdf;
  // determine the full wit name for the Box at the sourceLocPdf
  std::string mfgBoxPartName = mpHelper.mfgTopPartForGpd(theWitRun, plannerTopLevelPart, geo, sourceLocPdf);
  
  std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, sourceLocPdf));
  if (! mpHelper.isPartValid(theWitRun, fullOptionPartName, fileName, dataLine, lineNo, PURELY_OPTIONAL))  {
    (*theErrFacil)("CannotSourcePureOption",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgBoxPartName 
		   << mfgOptionPart << sourceLocPdf << mfgOptionPart << earlyPeriod << latePeriod << dataLine);
    return -1;
  }
  
  // determine  name of specialFeaturePart
  std::string specialFeaturePartName(mpHelper.standaloneFeaturePartName(plannerTopLevelPart, geo, mfgOptionPart, sourceLocPdf));
  int doesSpecialFeaturePartAlreadyExist = mpHelper.isPartValid(theWitRun, specialFeaturePartName, fileName, dataLine, lineNo, PURELY_OPTIONAL);


  // Easy Case !!  create new part/structure
  if (! doesSpecialFeaturePartAlreadyExist)  {

    // Add specialFeaturePart 
    witAddPartWithOperation(theWitRun, specialFeaturePartName.c_str());
    // Add BOM specialFeaturePart ==> realFeaturePart
    witAddBomEntry(theWitRun, specialFeaturePartName.c_str(), fullOptionPartName.c_str());

    // Add BOM ... GPD==>specialFeaturePart
    int bomIndexGpdToSfp;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &bomIndexGpdToSfp);
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), specialFeaturePartName.c_str());
    
    // FINISH_ME_61:
    //   I think effectivity should always be (0,nPeriods-1)
    //   the date sensitive changes should be managed by consRate and offset vectors (????
    //    witSetBomEntryEarliestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp,  earlyPeriod );
    //    witSetBomEntryLatestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp,  latePeriod );


    // set the consRate as adjusted featratio*usageRate
    // FINISH_ME_61
    // that's wrong, isn't it?  usageRate should apply after attachRate ?? on the bomEntry to mfgOptionPart??

    // gpdSfpConsRate = (0,0,aR,aR,...,aR,0,0);  (over effectity interval).   Default is 0.0 outside effectivity
    LgFrTimeVecFloat  gpdSfpConsRate(nPeriods, 0.0);
    //    witGetBomEntryConsRate(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, &gpdSfpConsRate );
    //        we don't use the witGetConsRate becuase that will default to 1.0 

    for (t=earlyPeriod; t<=latePeriod; t++) 
      gpdSfpConsRate[t] = usageRate * attachRate;
    witSetBomEntryConsRate(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, gpdSfpConsRate.data());


    // Set Offsets on specialFeaturePartName
    //       ... function of (mfgBoxCycleTimeDays, mfOffset, mfoPhantomFlag, mfgOptionPartCycleTimeDays)
    LgFrTimeVecFloat offsetTV(nPeriods, 0.0);
    LgFrTimeVecFloat mfgBoxCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, mfgBoxPartName);

    // mfoPhantom bills get a cycleTimeDays that is offset of mfgOptionPart's cycleTime.  
    if (mfoPhantomFlag) {
      LgFrTimeVecFloat optionCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullOptionPartName);
      for (t=earlyPeriod; t<=latePeriod; t++) {
	offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal - optionCycleTimeDays[t], t, theCal, nPeriods);
      }
    }
    else   {
      for (t=earlyPeriod; t<=latePeriod; t++) {
	offsetTV[t] = mpHelper.calculateVariableOffset(mfgBoxCycleTimeDays[t] + mfOffsetVal, t, theCal, nPeriods);
      }
    }
    witSetBomEntryOffset(theWitRun, specialFeaturePartName.c_str(), 0, offsetTV.data());

    // Lotsizing of Features ... This needs to be thought about some more ...
    //    LgFrTimeVecFloat nonIntLotSize(nPeriods, 0.01);
    //    witSetOperationMinLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());
    //    witSetOperationIncLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());


    // store the maxWithout in the appdata of the SpecialFeaturePart
    LgFrScePartAppData * appDataPtr;
    LgFrTimeVecFloat maxWithoutTV(nPeriods, maxWithout);
    witGetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void **) &appDataPtr);
    if (appDataPtr == 0) {
      appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      appDataPtr->maxWithout(maxWithoutTV);
      witSetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void *) appDataPtr);
    }
    else 
      appDataPtr->maxWithout(maxWithoutTV);      


    


    // Add "nullSub" part and structure to the geoPlannerDemandPart to mfgOptionPart BOM entry.
    //    If featureType=SCE_FEATURE_TYPE_MANDATORY,       use a globalMaxWithoutNullSubstitute.
    //    If featureType=SCE_FEATURE_TYPE_MWO,             use a maxWithoutNullSubstitute.
    //    If featureType=SCE_FEATURE_TYPE_PURELY_OPTIONAL, use a globalNullSubstitute.
    std::string nullSubstitute;
    if (featureType == SCE_FEATURE_TYPE_MANDATORY) {
      nullSubstitute = mpHelper.globalMaxWithoutNullSubstitute(sourceLocPdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, 
				 dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_MWO) {
      nullSubstitute = mpHelper.maxWithoutNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	// Sneak the maxWithout into the supplyVol of the maxWithoutNullSubstitite
	// unless its a very small number
	// FINISH_ME_61: does this option still work ????????    check!!
	if ((attachRate * usageRate) > IPSCE_FLT_EPS) 
	  witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), maxWithoutTV.data());
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_PURELY_OPTIONAL) {
      nullSubstitute = mpHelper.globalNullSubstitute(sourceLocPdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
	witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), bigMsupply.data());
      }
    }
    
    else {
      std::cerr << "About to die: featureType =" << featureType << "\n";
      assert(featureType == -500);
    }
    
    
    
    
    // Add subBom GPD ==> specialFeaturePart => nullSub
    int nSubBom;
    witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, &nSubBom);
    witAddSubsBomEntry(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, nullSubstitute.c_str());
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, nSubBom, WitFALSE);
    //    witSetSubsBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, nSubBom, intervalStartPeriod);
    //    witSetSubsBomEntryLatestPeriod(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, nSubBom, intervalEndPeriod);
    // if using the lp engine, then set the obj1 sub cost
    if (lpModelHelper_ != 0)
      witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), bomIndexGpdToSfp, nSubBom, defaultGatingOptionSubPenalty);
    
    
    // Add demand on specialFeaturePart, if not already there
    std::string returnedPlannerTopLevelPart;
    std::string returnedGeo;
    std::string demandName = mpHelper.pureOptionBuildDemandName( geoPlannerDemandPart );
    if (!( mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun, specialFeaturePartName, demandName, returnedPlannerTopLevelPart, returnedGeo))) {
      witAddDemand(theWitRun, specialFeaturePartName.c_str(), demandName.c_str());
    }


  }  
  
  
  // if this is a duplicate ... then we need to think a bit.   FINISH_ME_61
  if (doesSpecialFeaturePartAlreadyExist)  {

#if 0
    // FINISH_ME_61: Now we reject duplicate: GPD, FeaturePart records
    //               Need to support EC's
    // Duplicate Records rules: can we get rid of multiple arcs??????
    //     Can't switch between mwo values !!
    //     OK to change attachRates?   yes, but won't support changes 
    
    // two ways to do this ... 
    //           1:   loop thru gpd boms looking for a match 
    //           2:   create the specialFeaturePArt and test for existence 
    //                     check for cc or sfo.   Can't mix mwo's!!
    // ===> Choice 1
    int nBomEntries;
    witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
    char * child;
    int j = 0; 
    for (j=0; j<nBomEntries; j++)  {
      witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
      std::string pdf, mfgOptionPart, gg, mm;
      if ( mpHelper.isPartSpecialStandaloneFeature(theWitRun, child, gg, mm, pdf, mfgOptionPart) ) {
	if (mfgOptionPart == mfgOptionPart) {
	  (*theErrFacil)("OptionAlreadyDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
        witFree ( child );
        return -1;
      }
      }
      witFree ( child );    
    }    
    // ===> Choice 2
    //           2:   create the specialFeaturePArt and test for existence 
    //                     check for cc or sfo.   Can't mix mwo's!!
#endif



    
    (*theErrFacil)("OptionAlreadyDefined",MclArgList() << fileName << (int)lineNo << plannerTopLevelPart << geo << mfgOptionPart << dataLine);
    return -1;


    /*
    // find the one and only one bom entry
    int bomIndex;
    //    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &bomIndex);
    
    witSetBomEntryEarliestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  earlyPeriod );
    witSetBomEntryLatestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  latePeriod );
    LgFrTimeVecFloat gpdConsRate finalUsageRate = usageRate * featureRatio[intervalStartPeriod];
    witGetBomSetBomConsRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, &consRate );
    int tt;
    for (tt=earlyPeriod; tt<=latePeriod; tt++) 
      consRate[tt] = usageRate + attachRate;
    witSetBomEntryConsRate(theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, consRate );
  
  
    // FINISH_ME_61: convert for VARIABLE_PERIODS, deal with mfo and mfoPhantomFlag
    float * mfgTopLevelCycleTime;
    witGetPartCycleTime(theWitRun, mfgBoxPartName.c_str(), &mfgTopLevelCycleTime);
    witSetBomEntryOffset(theWitRun, specialFeaturePartName.c_str(), 0, mfgTopLevelCycleTime);
  
 
    // Add "nullSub" part and structure to the geoPlannerDemandPart to mfgOptionPart BOM entry.
    //
    // If featureType=SCE_FEATURE_TYPE_MANDATORY,       use a globalMaxWithoutNullSubstitute.
    // If featureType=SCE_FEATURE_TYPE_MWO,             use a maxWithoutNullSubstitute.
    // If featureType=SCE_FEATURE_TYPE_PURELY_OPTIONAL, use a globalNullSubstitute.
    //
    
    std::string nullSubstitute;
    if (featureType == SCE_FEATURE_TYPE_MANDATORY) {
      nullSubstitute = mpHelper.globalMaxWithoutNullSubstitute(pdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, 
				 dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_MWO) {
      nullSubstitute = mpHelper.maxWithoutNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	// Sneak the maxWithout into the supplyVol of the maxWithoutNullSubstitite
	// unless its a very small number
	if (finalUsageRate > IPSCE_FLT_EPS) 
	  witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), maxWithout);
      }
    }
    else if (featureType == SCE_FEATURE_TYPE_PURELY_OPTIONAL) {
      nullSubstitute = mpHelper.globalNullSubstitute(pdf);
      if (! mpHelper.isPartValid(theWitRun, nullSubstitute, fileName, dataLine, lineNo, PURELY_OPTIONAL)) {
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
	LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
	witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), bigMsupply.data());
      }
    }
    
    else {
      std::cerr << "About to die: featureType =" << featureType << "\n";
      assert(featureType == -500);
    }
    
    // store the maxWithout in the appdata of the SpecialFeaturePart
    LgFrScePartAppData * appDataPtr;
    LgFrTimeVecFloat maxWithoutTV(nPeriods, maxWithout);
    witGetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void **) &appDataPtr);
    if (appDataPtr == 0) {
      appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      appDataPtr->maxWithout(maxWithoutTV);
      witSetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void *) appDataPtr);
    }
    else 
      appDataPtr->maxWithout(maxWithoutTV);      
    
    
    
    // Add subBom GPD ==> specialFeaturePart => nullSub
    int nBom;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
    assert(nBom > 0);
    int nSubBom;
    witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, &nSubBom);
    witAddSubsBomEntry(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nullSubstitute.c_str());
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, WitFALSE);
    witSetSubsBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalStartPeriod);
    witSetSubsBomEntryLatestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalEndPeriod);
    // if using the lp engine, then set the obj1 sub cost
    if (lpModelHelper_ != 0)
      witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, defaultGatingOptionSubPenalty);
    
    witFree(mfgTopLevelCycleTime);
    
    // Add demand on specialFeaturePart, if not already there
    std::string returnedPlannerTopLevelPart;
    std::string returnedGeo;
    std::string demandName = mpHelper.pureOptionBuildDemandName( geoPlannerDemandPart );
    if (!( mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun, specialFeaturePartName, demandName, returnedPlannerTopLevelPart, returnedGeo))) {
      witAddDemand(theWitRun, specialFeaturePartName.c_str(), demandName.c_str());
    }
    */
  }
    
  return 0;
  
}
























  // copy over the priorities from the GPD to all the specialFeatureDemands
  // associated with this gpd.  
int 
LgFrInitialProblemForSce::sceSetPrioritiesForSpecialFeatureDemands(
    WitRun * const theWitRun,
    LgFrMultiPlantHelper & mpHelper)
{
  int nPeriods;
  int nParts;  
  char ** partList; 

  witGetParts( theWitRun, &nParts, &partList );
  witGetNPeriods(theWitRun, &nPeriods);
  

  std::string ppForGpd;
  std::string geoForGpd;

  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++)  { 
    std::string geoPlannerDemandPart(partList[i]);
      
    // Skip this one if its not a GPD
    if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, geoPlannerDemandPart, ppForGpd, geoForGpd))
      continue;

    int * priority;        
    // first get the priority of the GPD 
    int gpdNdemands;
    char ** gpdDlist;
    witGetPartDemands(theWitRun, geoPlannerDemandPart.c_str(),  &gpdNdemands, &gpdDlist);

    if (gpdNdemands == 0)
      continue;

    // assert that there is at most one demand per gpd part
    assert(gpdNdemands == 1);
    witGetDemandPriority ( theWitRun, geoPlannerDemandPart.c_str(), gpdDlist[0], &priority );

    int nBoms;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBoms);
    
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++) {
      char * specialFeaturePartName;
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &specialFeaturePartName);
      // if the part is not a special customer choice feature, then skip it

      std::string pp;
      std::string geo;
      std::string pdf;
      std::string mfgOptionPart;

      int nDemandsSFP;
      char ** dListSFP;

      if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, specialFeaturePartName,
						    geo, pp, pdf, mfgOptionPart)) {
    	witGetPartDemands(theWitRun, specialFeaturePartName,  &nDemandsSFP, &dListSFP);
	    int jSFP = 0; // Pulled out of the for below by RW2STL
	    for (jSFP=0; jSFP<nDemandsSFP; jSFP++) {
	        if ((pp == ppForGpd) && (geo == geoForGpd)) {
	            witSetDemandPriority(theWitRun, specialFeaturePartName, dListSFP[jSFP], priority);
	        } 
	        witFree(dListSFP[jSFP]);
	    }
	    witFree(dListSFP);
      } 

      if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, specialFeaturePartName,
    						  geo, pp, pdf, mfgOptionPart)) {
	    witGetPartDemands(theWitRun, specialFeaturePartName,  &nDemandsSFP, &dListSFP);
	    int jSFP = 0; // Pulled out of the for below by RW2STL
	    for (jSFP=0; jSFP<nDemandsSFP; jSFP++) {
	        if ((pp == ppForGpd) && (geo == geoForGpd)) {
	            witSetDemandPriority(theWitRun, specialFeaturePartName, dListSFP[jSFP], priority);
	        }
	        witFree(dListSFP[jSFP]);
	    }
	    witFree(dListSFP);
      }
      witFree(specialFeaturePartName);
    }

    witFree(priority);
    witFree(gpdDlist[0]);
    witFree(gpdDlist);

  }

  // Cleanup memory
  for ( i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree( partList );

  return 0;
}




int
LgFrInitialProblemForSce::preProcessNegativeDemands (
 WitRun * const theWitRun,
 LgFrMultiPlantHelper & mpHelper )

{
  char ** partList;
  int nParts, nPeriods;
  int i;

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  witGetParts ( theWitRun, &nParts, &partList );
  witGetNPeriods ( theWitRun, &nPeriods );

  std::string ptlpDummy;
  std::string geoDummy;
  // loop throught the parts
  for (i=0; i<nParts; i++) {
    std::string partName (partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, partName))
      continue;
    char ** dList;
    int nDemands;


    witGetPartDemands(theWitRun, partName.c_str(), &nDemands, &dList);
    int doesPartHaveNegativeDemands = 0;
    int didWeAlreadyAdjustSupplyVolForNegativeDemandVols = 0;

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {

	
      // skip special feature demands
      if (mpHelper.isDemandSpecialPureOptionBuildDemand(theWitRun, partName, dList[j], ptlpDummy, geoDummy)) {
	witFree(dList[j]);
	continue;
      }

      // get the  demand app data for this demand.  get the demandVol
      LgFrSceDemandAppData * demandAppDataPtr;
      witGetDemandAppData(theWitRun, partName.c_str(), dList[j], (void **) &demandAppDataPtr);
      assert(demandAppDataPtr != 0);
      LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();

      
      if (demandVolTVF.min() < -0.001) {

	demandAppDataPtr->doesDemandHaveNegativeValues(1);

	// fix for SCE 5, 20080919 ... bug was: overadjusting of supplyVol when
	// there are multiple negative demand vol streams for a single part
	// fix: once you find one negative demand, skip the others
	if (! didWeAlreadyAdjustSupplyVolForNegativeDemandVols) {
	  mpHelper.setDoesPartHaveNegativeDemands(theWitRun, partName, 1);
	  // adjust the supplyVol 
	  // negDemVol = demandVol - appDataDemandVol;
	  // supplyVol += negDemVol
	  
	  LgFrTimeVecFloat negDemVol(mpHelper.negDemVol(theWitRun, partName));
	  float * supplyVol;
	  witGetPartSupplyVol(theWitRun, partName.c_str(), &supplyVol);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
	    supplyVol[t] += negDemVol[t];
	  }
	  witSetPartSupplyVol(theWitRun, partName.c_str(), supplyVol);
	  witFree(supplyVol);
	  didWeAlreadyAdjustSupplyVolForNegativeDemandVols = 1;
	}
      }
      witFree(dList[j]);
      continue;
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);

  return 0;
}								   



// preprocess multiple bop entries
// This routine looks through all the parts in the WIT model
// and for any part with multiple bop entries "turns on" the lowest
// preference bop in the appropriate effectivity period and
// "turns off" all the other bops.
int
LgFrInitialProblemForSce::scePreProcessMultiBopEntries (
 WitRun * const theWitRun,
 bool useMultiRouteImplosion)

{
  char ** partList;
  int nParts;
  int nPeriods;
  int i; // the part index
  
  // FINISH_ME: 2.31 TEST, TEST, TEST  
  // need to figure out what the ramification is of this now in release 4.0
  if (useMultiRouteImplosion) {
    std::cout << "    .... multi-bop OK (using multi-route implosion) ..." << std::endl;
    return 0;
  }


  witGetParts ( theWitRun, &nParts, &partList );
  witGetNPeriods ( theWitRun, &nPeriods );


  
  for (i=0; i<nParts; i++) {
    // A 2.30 fix for useMultiRouteImplosion ONLY ...
    // For 2.30, if the user has specified UseMultiRouteImplosion, then we
    // want to only do splitBop on parts that are produced by interplants.  This
    // is because the interplant logic is based on multiBop's AND subs where we 
    // want the sub logic to be used (ie, net primary, net sub, explode primary,
    // explode sub) rather than the straight multiRoute bop logic (ie, net primary
    // explode primary, net sub, explode sub).
    //
    // So as a quick fix for MD (what else is new), we'll only do this splitbop
    // thing for parts which have at least one bop from an inpterplant operation.
    // This will cause parts which are "build or buy" to go through the splitbop and
    // they won't be handled smartly through multiRoute  (ie, only the primary route 
    // will be available).
    // 
    // get the number of interplant operations producing this part
    // if there aren't multiple, then there's nothing to process
    // go on to the next part
    if (useMultiRouteImplosion) {
      LgFrScePartAppData * appDataPtr;
      witGetPartAppData(theWitRun, partList[i], (void **) &appDataPtr);
      
      if ( appDataPtr == 0) // if there's no appData, than no interplants..
	continue;
      int nInterplantOps = appDataPtr->nInterplantOps();
      if ( nInterplantOps < 1)
	continue;
    }


    
    int  npBops;  // number of bops producing the i-th part
    witGetPartNProducingBopEntries ( theWitRun, partList[i], & npBops );

    if ( npBops == 0 )
      continue;

    else if ( npBops == 1 ) {
      // be safe and set expAllowed=true (though this is the default and it should
      // already be set as such)
      char * opName;
      int bopIndex;
      witGetPartProducingBopEntry ( theWitRun, partList[i], 0, &opName, &bopIndex);
      witSetBopEntryExpAllowed ( theWitRun, opName, bopIndex, WitTRUE );
      witFree ( opName );   
    }

    else { // npBops > 1
      std::string partName (partList[i]);
      LgFrScePartSetOfBops setOfBops(theWitRun, partName);

      // initialize with all bops "turned off" throughout time...
      bool * bopOnInPeriod = new bool[nPeriods];
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
        bopOnInPeriod[t] = false; 
      
      // loop through the bop entries in order of increasing preference value...
      int p = 0; // Pulled out of the for below by RW2STL
      for (p=0; p<npBops; p++) {
        LgFrSceBop & myBop = setOfBops[p];

        // if the bop is not effective, then the bop is "turned off". go to the next bop.
        if ( myBop.early () > myBop.late() ) 
          witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(), myBop.bopIndex(), WitFALSE );

        // else bop is effective.
        //      find the first and last periods of a time segment that this bop
        //      can be "turned on", if they exist.
        else {
          int first;  // first period of segment where bop is lowest priority
          int last;   // last period consecutive from first, where bop is lowest priority
          first = myBop.early();
          last = - 1;

          // while you haven't looked at every period this bop is effective, keep going...
          while ( last < myBop.late() ) {
            
            // find the "first" period this bop has lowest priority
            while ( first <= myBop.late() ) {
              if ( bopOnInPeriod[first] != true )
                break;
              first++;
            }
            
            // if we couldn't find a "first" period to turn on the bop,
            // then it's not explodeable. Go on to the next bop.
            if (first > myBop.late() ) {
              witSetBopEntryExpAllowed( theWitRun,
                                       myBop.opName().c_str(),
                                       myBop.bopIndex(),
                                       WitFALSE );
              break; 
            }
            
            // find the "last" period consecutive from the first that this bop is effective.
            // we know that there is at least one (namely period "first").
            last = first;
            while ( last <= myBop.late() ) {
              if ( bopOnInPeriod[last] != false )
                break;
              last++;
            }
            last = last - 1;
          
            // if you got here, you have a segment of time from "first" to "last"
            // where this bop is effective and has lowest priority.
            // turn the bop on in the periods from first to last...
            int t = 0; // Pulled out of the for below by RW2STL
            for (t=first; t<=last; t++)
              bopOnInPeriod[t] = true;
            
            // Now, it is one of 4 possible cases.
            // Case 1: first-last is the whole effectivity range.
            //         (The nicest case) Turn "on" the bop for the whole range.
            //         Process the byProduct flag in WIT and be done.
            // Case 2: first-last is the latter part of the effectivity range
            //         (almost as nice) 
            //         Split the bop into 2 parts.
            //         The first part is "off", the last part is "on".
            //         Process the byProduct flags in WIT and be done.
            // Case 3: first-last is the early part of the effectivity range
            //         Split the bop into 2 parts.
            //         The first part is "on", the last part still needs to be looked at.
            //         Process the first parts' byProduct flag in WIT, and
            //         set up the latter part to be looked at in the next iteration.
            // Case 4: first-last is strictly contained in the effectivity range
            //         This is the messiest case.
            //         Split the bop into 3 parts.
            //         The first part is "off", the middle part is "on", and
            //         the last part still needs to be looked at.
            //         Process the byProduct flags of the first and middle parts in WIT.
            //         Then, set up the latter part to be looked at in the next iteration.

            // Case 1: first-last is the whole effectivity range
            if (( first == myBop.early() ) && ( last == myBop.late() )) 
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
                                         myBop.bopIndex(),
                                         WitTRUE );
            // Case 2: first-last is the latter part of the effectivity range
            if (( first > myBop.early() ) && ( last == myBop.late() )) {
              LgFrSceBop newBop = myBop.splitBop( theWitRun, first-1);
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
                                        myBop.bopIndex(),
                                        WitFALSE );
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName().c_str(),
                                        newBop.bopIndex(),
                                        WitTRUE );
            }
            // Case 3: first-last is the early part of the effectivity range
            if (( first == myBop.early() ) && ( last < myBop.late() )) {
              LgFrSceBop newBop = myBop.splitBop( theWitRun, last );
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
                                        myBop.bopIndex(),
                                        WitTRUE );
              
              // myBop becomes "newBop" (RLH: there's got to be a cleaner way....)
              myBop.early(newBop.early());
              myBop.late(newBop.late());
              myBop.bopIndex(newBop.bopIndex());
              // still have to process the rest of the effectivity periods....
              first = myBop.early();
            }
            // Case 4: first-last is strictly contained in the effectivity range         
            if (( first > myBop.early() ) && ( last < myBop.late() )) {
              LgFrSceBop newBop = myBop.splitBop( theWitRun, first-1);
              LgFrSceBop newerBop = newBop.splitBop( theWitRun, last );
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
                                        myBop.bopIndex(),
                                        WitFALSE );
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName().c_str(),
                                        newBop.bopIndex(),
                                        WitTRUE );
              // myBop becomes newerBop 
              myBop.early(newerBop.early());
              myBop.late(newerBop.late());
              myBop.bopIndex(newerBop.bopIndex());
              // still have to process the rest of the effectivity periods...
              first = myBop.early();
            }
            
          } // end while loop
          
        } // end "else bop is effective"
        
      } //  end "p loop over npBops for part i"
      
      delete []  bopOnInPeriod;
      
    } // end "else npBops > 1"
  } // end  "i loop over parts"

  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);
    
  return (0); 
}



// preprocess multiple interplant entries

// RLH: note
// A part can be produced by many interplantOps
// and there can be multiple bops b/t the part
// and any given interplantOp. But each interplantOp
// -------- has only bom ---------------------
//
// This routine looks through all the parts in the WIT model
// for those produced from multiple interplant operations.
// If multiple interplant operations exist, then the
// supplier part at alternative
// interplant locations are made substitutes for the 
// supplier part at the preferred interplant location.
//
// Note: the 2.0 implementation of this method makes
// some strong assumptions about the input 
// data into SCE:
// - that the transit time for alternative interplants is equal
// to the transit time of the preferred interplant (not valid for ECA
// but currently offsets on subBomEntries are not available in WIT).
int
LgFrInitialProblemForSce::scePreProcessMultiInterPlantEntries (
 WitRun * const theWitRun,
 LgFrMultiPlantHelper & mpHelper )

{
  char ** partList;
  int nParts;
  int i; // the part index
  int p; // the "bops producing the ith-part" index

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  witGetParts ( theWitRun, &nParts, &partList );

  // loop throught the parts
  for (i=0; i<nParts; i++) {
    std::string partName (partList[i]);
    
    // get the number of interplant operations producing this part
    // if there aren't multiple, then there's nothing to process
    // go on to the next part
    LgFrScePartAppData * appDataPtr;
    witGetPartAppData(theWitRun, partName.c_str(), (void **) &appDataPtr);

    if ( appDataPtr == 0) // if there's no appData, than no interplants..
      continue;

    // SCE 5.00
    // We need to disableJumperArcs for cases where the part uses proportional sourcing
    if (appDataPtr->sourceCode() == "AFP")
      continue;

    int nInterplantOps = appDataPtr->nInterplantOps();
    if ( nInterplantOps <= 1)
      continue;

    // ok, we have a winner. This part has multiple interplant
    // operations that produce it
    int  npBops;  // number of bops producing the i-th part
    witGetPartNProducingBopEntries ( theWitRun, partName.c_str(), & npBops );
    assert ( npBops > 1 ); // can't have multiInterplant without multiBops!

    LgFrScePartSetOfBops setOfBops(theWitRun, partName);

    // we're going to have to working with the interplant operations for
    // this part. so create an vector of them, no duplicates allowed.
    // (FINISH_ME: It's be nice to have a new class, something like
    // "LgFrScePartSetOfInterplantOps"
    // where each member of the class would know the interplant
    // operation name and the fullWitPartName for the source part
    // but this is only needed for the jumperArcs so...maybe not.

    std::string * setOfInterplantOps = new std::string[nInterplantOps];
    int interplantOpIndex=0;
    for (p=0; p<npBops; p++) {
      LgFrSceBop producingBop = setOfBops[p];
      std::string interplantOpName = producingBop.opName();
      // if the operation isn't an interplant op, then we're not
      // interested in it
      std::string dPart;
      std::string dPdf;
      std::string sPart;
      std::string sPdf;
      if (! mpHelper.isOperationSpecialInterplant(
                       theWitRun, interplantOpName.c_str(),
                       dPart, dPdf, sPart, sPdf))
        continue;
      // otherwise if it's not in our list, add it
      int isADuplicate = 0;
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nInterplantOps; k++) {
        if (0 == interplantOpName.compare(setOfInterplantOps[k])) {
          isADuplicate = 1;
          break;
        }
      }
      if ( ! isADuplicate ) {
        setOfInterplantOps[interplantOpIndex] = interplantOpName;
        interplantOpIndex++;
      }
    } // ok, we've got our set of interplant ops for this part.
    // there should be multiple interplant operations
    assert (interplantOpIndex > 1);
    assert (interplantOpIndex == nInterplantOps);
    
    // loop through the bops in order of increasing preference
    // note: the lower the preference, the more "preferred" it is.
    // looking for bops to interplantOperations that have expAllowed=false.
    for (p=0; p<npBops; p++) {
      LgFrSceBop & currentBop = setOfBops[p];
      std::string currentInterplantOp = currentBop.opName();
      int currentInterplantBopIndex = currentBop.bopIndex();
      
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;
      std::string sourcePdf;
        
      if (! mpHelper.isOperationSpecialInterplant(
                       theWitRun, currentInterplantOp.data(),
                       destPart, destPdf, sourcePart, sourcePdf))
        continue;
      
      witBoolean expAllowed;
      witGetBopEntryExpAllowed( theWitRun, currentInterplantOp.c_str(),
                               currentInterplantBopIndex, &expAllowed);

      // FINISH_ME: 2.31 THIS IS A TEST!!!!!!
      //      if ( expAllowed )
      //        continue;

      // the currentInterplantOp is a winner!
      // we've found an interplant operation with a bop that's "off"
      // (i.e. expAllowed = false)
      // Make the source part for this interplant operation a sub
      // for the source parts at every other interplant location.
      // (actually, you'd only have to make it a sub for the source
      //  that's at the location which is in effect...but
      //  finding that bugger would be more work than we want to do
      //  right now...)

      // 2.30: Ok, look at the bopAppData and if the expAllowed flag
      // is true, then we will need to make the sub arc explodeable 
      
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nInterplantOps; k++) {
        // avoid self-substitution
        if (0 == currentInterplantOp.compare(setOfInterplantOps[k]))
          continue;

        std::string sourcePdfPartName;
        mpHelper.interplantSourcePdfPartName( theWitRun, currentInterplantOp.c_str(),
                                              sourcePdfPartName );
        
        std::string primaryInterplantOp = setOfInterplantOps[k];
        int nBomEntries;        
        witGetOperationNBomEntries( theWitRun,
                                    primaryInterplantOp.c_str(), &nBomEntries );
        // by construction ea interplant
        // op has exactly one bom, but just to be safe...
        if ( nBomEntries != 1 ) {
	  (*theErrFacil)("InterplantOperationBomError");
        }

        int subBomEntryIndex ;
        witGetBomEntryNSubsBomEntries( theWitRun, primaryInterplantOp.c_str(),
                                       0, &subBomEntryIndex );
        witAddSubsBomEntry( theWitRun, primaryInterplantOp.c_str(), 0,
                            sourcePdfPartName.c_str() );
        
        // the usageRate from the interplant record has since become the usage rate
        // on the BOM b/t the current interplant operation and sourcePdfPart. Get this
        // value and set the usageRate of the substitute equal to this value.
        float usageRate;
        witGetBomEntryUsageRate( theWitRun, currentInterplantOp.c_str(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryInterplantOp.c_str(), 0,
                                     subBomEntryIndex, usageRate );

	// 2.30:  We must shut all expAllowed off as a default.  We'll turn them back
	//   on later for those that qualify.
        witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.c_str(), 0,
                                     subBomEntryIndex, WitFALSE );


        // the earliest/latest periods from the interplant record have since
        // become the earliest/latest period attributes on the current
        // interplant bop. Get these
        // values and set the earliest/latest periods of the substitue equal to these
        // values.
        int early = currentBop.early();
        int late = currentBop.late();      
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryInterplantOp.c_str(),
                                          0, subBomEntryIndex, early );
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryInterplantOp.c_str(),
                                        0, subBomEntryIndex, late );

        // the SUB BOM offset (transitTime), must be set to the existing BOM offset
        // for the subbed interplant arc
        float * offset;
        witGetBomEntryOffset( theWitRun, currentInterplantOp.c_str(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryInterplantOp.c_str(), 0,
                                     subBomEntryIndex, offset );
        witFree(offset);
        

        // get the "explodable" flag for the alternative interplant bop
        // and use it to set the "explodable" flag for the new sub
        LgFrSceBopAppData * currentBopAppDataPtr;
        witGetBopEntryAppData( theWitRun, currentInterplantOp.c_str(), currentInterplantBopIndex,
                                (void **) &currentBopAppDataPtr );
        assert( currentBopAppDataPtr != 0 );
        

	int expAllowed = currentBopAppDataPtr->expAllowed();
	if (expAllowed) {
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.c_str(), 0, subBomEntryIndex, 
					expAllowed);
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryInterplantOp.c_str(), 0, subBomEntryIndex, 
					    currentBop.preference());
	}

        // the app data new'd here get's cleaned up in the scenario destructor
        LgFrSceSubBomAppData * subBomAppDataPtr =
          new LgFrSceSubBomAppData( currentBop.preference(),
                                    currentBopAppDataPtr->isObjectInEffectForOptExplosion() );
        assert (subBomAppDataPtr != 0 );
        witSetSubsBomEntryAppData( theWitRun, primaryInterplantOp.c_str(), 0,
                                   subBomEntryIndex, (void *) subBomAppDataPtr );

      } // end k-loop over nInterplantOps
      
    }  // end p-loop over npBops

    delete [] setOfInterplantOps;
    
  } // loop over nParts

  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  
  return 0;
}




#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
// This routine uses MRP to explode the demand vols down to 
// the featureSetPart
int 
LgFrInitialProblemForSce::scePreProcessViaMrpViaMultiRoute(
    WitRun * const theWitRun, 
    int nperiods,
    const LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper)
{

  int nPeriods;
  int nParts;  
  char ** partList; 
  int i;            
  int nOperations;  
  char ** opList; 
  int o;
  
  witGetParts( theWitRun, &nParts, &partList );
  nPeriods = theCal.nPeriods();




  
  // run MRP
  std::cout << "    ... running witMrp() ..." << std::endl;    
  witSetTruncOffsets(theWitRun, WitTRUE);
  witMrp(theWitRun);
  witSetTruncOffsets(theWitRun, WitFALSE);
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string bbCategory;
  std::string mfgOptionPart;
  
  float * mrpProdVol;

  float * supplyVol;

  // Loop thru every part, looking for optionRatioSupply parts OR demandUpperBound parts
  // or maxWithoutNullSubstitutes
  std::cout << "    ... scanning partlist ..." << std::endl;        
  for (i=0; i<nParts; i++)  { 
    std::string fullWitPartname(partList[i]);

    // This is what you do for OptionRatioSupply parts
    if (mpHelper.isPartSpecialOptionRatioSupply(theWitRun, fullWitPartname, plannerTopLevelPart,
					  geo, bbCategory, mfgOptionPart))   {

      std::cout << "    ... ..... found specialOptionRatioSupply ..." << std::endl;        
      
      // get the reqVol for the OptionRatioSupply part.  This is equivalent to 
      // the exploded demand for the BB option.  Set the supplyVol of the 
      // OptionRatioSupply part to the reqVol and we're done!
      float * reqVol;
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
      
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
      witFree(reqVol);
    }
    
    // This is what you do for Demand UpperBound Parts
    if (mpHelper.isPartSpecialGeoPlannerDemandUbPart(theWitRun, fullWitPartname,
						     plannerTopLevelPart,
						     geo))   {
      float * reqVol;
      // get the reqVol for this DemandUB Part.  
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
      
      // And just to make life more complicated, we need to pick up any
      // reqVol for the parent part which is the Special Demand part
      std::string demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
							       geo);
      float * reqVolParent;
      witGetPartReqVol(theWitRun, demandPart.c_str(), &reqVolParent);
      
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	reqVol[t] += reqVolParent[t];
      
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
      witFree(reqVol);
      witFree(reqVolParent);
    }
    
    // This is what you do for maxWithoutNullSubstitues
    if (mpHelper.isPartSpecialMaxWithoutNullSubstitute(theWitRun, fullWitPartname, geo,
						       plannerTopLevelPart,
						       mfgOptionPart))   {
      std::string maxWithoutNullSubPart(fullWitPartname);
      
      // get the mrpProdVol for the geoPlannerDemandPart.
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo);
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
      
      // get the supplyVol for the maxWithoutNullSubstitute part
      // which is temporarily holding the maxWithout ratio
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), &supplyVol);
      
      // Now multiply the demand for the geoPlannerDemandPart by the maxWithout
      // ratio for the feature and stuff that back in as the supplyVol for the
      // maxWithoutNullSubPart.
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
	supplyVol[t] *= mrpProdVol[t];
      
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), supplyVol);
      witFree(mrpProdVol);
      witFree(supplyVol);
    }
    
    // CUSTOMER_CHOICE_FEATURES
    // This is what you do for customer choice features
    std::string pppdf;
    if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, fullWitPartname, geo,
						plannerTopLevelPart, pppdf,
						mfgOptionPart))   {
      // HOT
      // Find the name of nullSub for this cc feature
      std::string ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));

      // get the mrpProdVol for the geoPlannerDemandPart.
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo);
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
      
      // get the supplyVol for the maxWithoutNullSubstitute part
      // which is temporarily holding the featureRatio
      witGetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), &supplyVol);
      
      // Now multiply the demand for the geoPlannerDemandPart by the complement
      // of the feature ratio  and stuff that back in as the supplyVol for the
      // ccNullSubPart.
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
	supplyVol[t] = (1.0 - supplyVol[t]) * mrpProdVol[t];
      
      witSetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), supplyVol);

      // Now set this supplyVol away for future use in MRP
      LgFrTimeVecFloat suppTVF(nPeriods, supplyVol);
      mpHelper.custChoiceDummySupplyVolForMrpAdjustment(theWitRun, fullWitPartname, suppTVF);

      witFree(mrpProdVol);
      witFree(supplyVol);
    }

  }

  std::cout << "    ... finished SCE pre-processing ..." << std::endl;        
  
  // Cleanup memory
  for ( i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree( partList );

  
  return 0;
}

#else
// This routine uses MRP to explode the demand vols down to 
// the featureSetPart
int 
LgFrInitialProblemForSce::scePreProcessViaMrp(
    WitRun * const theWitRun, 
    int nperiods,
    const LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper)
{

  int nPeriods;
  int nParts;  
  char ** partList; 
  int i;            
  
  witGetParts( theWitRun, &nParts, &partList );
  nPeriods = theCal.nPeriods();
  
  // run MRP
  std::cout << "    ... running witMrp() ..." << std::endl;    
  witSetTruncOffsets(theWitRun, WitTRUE);
  witMrp(theWitRun);
  witSetTruncOffsets(theWitRun, WitFALSE);
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string bbCategory;
  std::string mfgOptionPart;
  
  float * mrpProdVol;
  float * supplyVol;

  // Loop thru every part, looking for optionDummy parts OR demandUpperBound parts
  // or maxWithoutNullSubstitutes
  std::cout << "    ... scanning partlist ..." << std::endl;        
  for (i=0; i<nParts; i++)  { 
    std::string fullWitPartname(partList[i]);

    // This is what you do for OptionDummy's
    if (mpHelper.isPartSpecialOptionDummy(theWitRun, fullWitPartname, plannerTopLevelPart,
					  geo, bbCategory, mfgOptionPart))   {
      
      // figure out the full BB category part  for which this option is part of
      std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart,
								 geo, bbCategory);



      // get the mrpProdVol for the bbCategoryPart.  This is equivalent to 
      // the demand for the featureSet
      witGetPartMrpProdVol(theWitRun, fullBbCategoryPart.c_str(), &mrpProdVol);
      
      // get the unique optionRatioSupply partname for this option
      std::string optionRatioSupplyPart = mpHelper.optionRatioSupplyPartName(
									   plannerTopLevelPart, geo, bbCategory, mfgOptionPart);
      
      // get the supplyVol for this part which is temporarily being used 
      // as a placeholder for the option ratio
      witGetPartSupplyVol(theWitRun, optionRatioSupplyPart.c_str(), &supplyVol);
      
      // Now multiply the demand for the feature by the ratio for the
      // option and stuff that back in as the supplyVol for the
      // optionRatioSupplyPart.
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
	supplyVol[t] *= mrpProdVol[t];
      
      witSetPartSupplyVol(theWitRun, optionRatioSupplyPart.c_str(), supplyVol);
      witFree(mrpProdVol);
      witFree(supplyVol);
    }
    
    // This is what you do for Demand UpperBound Parts
    if (mpHelper.isPartSpecialGeoPlannerDemandUbPart(theWitRun, fullWitPartname,
						     plannerTopLevelPart,
						     geo))   {
      
      float * reqVol;
      // get the reqVol for this DemandUB Part.  
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
      
      // And just to make life more complicated, we need to pick up any
      // reqVol for the parent part which is the Special Demand part
      std::string demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
							       geo);
      float * reqVolParent;
      witGetPartReqVol(theWitRun, demandPart.c_str(), &reqVolParent);
      
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	reqVol[t] += reqVolParent[t];
      
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
      witFree(reqVol);
      witFree(reqVolParent);
    }
    
    // This is what you do for maxWithoutNullSubstitues
    if (mpHelper.isPartSpecialMaxWithoutNullSubstitute(theWitRun, fullWitPartname, geo,
						       plannerTopLevelPart,
						       mfgOptionPart))   {
      std::string maxWithoutNullSubPart(fullWitPartname);
      
      // get the mrpProdVol for the geoPlannerDemandPart.
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo);
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
      
      // get the supplyVol for the maxWithoutNullSubstitute part
      // which is temporarily holding the maxWithout ratio
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), &supplyVol);
      
      // Now multiply the demand for the geoPlannerDemandPart by the maxWithout
      // ratio for the feature and stuff that back in as the supplyVol for the
      // maxWithoutNullSubPart.
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
	supplyVol[t] *= mrpProdVol[t];
      
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), supplyVol);
      witFree(mrpProdVol);
      witFree(supplyVol);
    }
    
    // CUSTOMER_CHOICE_FEATURES
    // This is what you do for customer choice features
    std::string pppdf;
    if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, fullWitPartname, geo,
						plannerTopLevelPart, pppdf,
						mfgOptionPart))   {
      // HOT
      // Find the name of nullSub for this cc feature
      std::string ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));

      // get the mrpProdVol for the geoPlannerDemandPart.
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo);
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
      
      // get the supplyVol for the maxWithoutNullSubstitute part
      // which is temporarily holding the featureRatio
      witGetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), &supplyVol);
      
      // Now multiply the demand for the geoPlannerDemandPart by the complement
      // of the feature ratio  and stuff that back in as the supplyVol for the
      // ccNullSubPart.
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  {
	//	std::cout << "fr(ccNullSub,"         << t << "," << ccNullSubPart << " = " << supplyVol[t] << std::endl;
	//	std::cout << "mrpProdVol(ccNullSub," << t << "," << ccNullSubPart << " = " << mrpProdVol[t] << std::endl;
    	supplyVol[t] = (1.0f - supplyVol[t]) * mrpProdVol[t];
	//	std::cout << "supplyVol(ccNullSub," << ccNullSubPart << " = " << supplyVol[t] << std::endl;
      }
      
      witSetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), supplyVol);

      // Now set this supplyVol away for future use in MRP
      LgFrTimeVecFloat suppTVF(nPeriods, supplyVol);
      mpHelper.custChoiceDummySupplyVolForMrpAdjustment(theWitRun, fullWitPartname, suppTVF);

      witFree(mrpProdVol);
      witFree(supplyVol);
    }

  }

  std::cout << "    ... finished SCE pre-processing ..." << std::endl;        
  
  // Cleanup memory
  for ( i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree( partList );
  
  return 0;
}
#endif


// This routine uses MRP to explode the demand vols down to 
// the featureSetPart
int 
LgFrInitialProblemForSce::checkAndFixIllegalSubNetAllowedCases(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper)
{

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
   


  witAttr objItrState;
  witResetObjItr(theWitRun);
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);

      // we are looking for case where sub has netAllowed=T and execPen>0 on the bomEntry or any Subs, then we
      // force the netAllowed==>FALSE
      witBoolean netAllowed;
      witGetSubsBomEntryNetAllowed(theWitRun, opName, b, s, &netAllowed);

      witBoolean doWeNeedToForceNetAllowedToZero = WitFALSE;
      if (netAllowed) {
	// first test if the subExecPen>0
	float thisSubExecPen;
	witGetSubsBomEntryExecPenalty(theWitRun, opName, b, s, &thisSubExecPen);
	if (thisSubExecPen > 0.0)
	  doWeNeedToForceNetAllowedToZero = WitTRUE;
	else {
	  // now test for bomExecPen>0
	  float bomExecPenalty;
	  witGetBomEntryExecPenalty(theWitRun, opName, b, &bomExecPenalty);
	  if (bomExecPenalty > 0.0) {
	    doWeNeedToForceNetAllowedToZero = WitTRUE;
	  }
	  else {
	    // now check all the other subs execPen > 0
	    int nSubsBomEntries;
	    witGetBomEntryNSubsBomEntries(theWitRun, opName, b, &nSubsBomEntries);
	    int sb;
	    for (sb=0; sb<nSubsBomEntries; sb++) {
	      float otherSubExecPen;
	      witGetSubsBomEntryExecPenalty(theWitRun, opName, b, sb, &otherSubExecPen);
	      if (otherSubExecPen > 0.0) {
		doWeNeedToForceNetAllowedToZero=WitTRUE;
		break;
	      }
	    }
	  }
	}
	if (doWeNeedToForceNetAllowedToZero) {
	  witSetSubsBomEntryNetAllowed(theWitRun, opName, b, s, WitFALSE);

	  
	  std::string parent = mpHelper.partname(opName);
	  std::string pdf = mpHelper.pdf(opName);
	  char * primary;
	  witGetBomEntryConsumedPart(theWitRun, opName, b, &primary);
	  char * sub;
	  witGetSubsBomEntryConsumedPart(theWitRun, opName, b, s, &sub);
	  (*theErrFacil)("ForcingSubNetAllowedFalse",MclArgList() 
			 << parent
			 << primary
			 << sub 
			 << pdf );
	  witFree(sub);
	  witFree(primary);
	}

      }
      witFree(opName);
    }
    
    if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }
    
  }
  return 0;
}












// Add a substitute BOM record:  
// Note: you must set the flag isParentAnOperation to true or false
int
LgFrInitialProblemForSce::sceAddSubstitute(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    bool isParentAnOperation,
    const std::string & mfgParentPartName, 
    const std::string & parentPdf, 
    const std::string & mfgChildPartName, 
    const std::string & childPdf, 
    const std::string & mfgSubPartName,
    const std::string & subPdf,
    float usageRate,
    int  early, 
    int late,
    int fallout,
    float subCost,
    int isObjectInEffectForOptExplosionFlag,
    int isSubstituteBuildable,
    bool subNetAllowed,
    //    float groupSharingExecPenaltyThresh,
    float execPenalty,
    float   offsetDelta,
    float propRtg_Share,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{

    int nBomEntries;
    char * child;

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string fullParentName(mpHelper.pdfPartname(mfgParentPartName, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(mfgChildPartName,  childPdf));
    std::string fullSubName( mpHelper.pdfPartname(mfgSubPartName,  subPdf));
    

    // first make sure the parts/operations are valid based on what they were 
    // supposed to be.  NOTE: its a FINISH_ME for future release to let the 
    // op sub bom subs and children be anything.
    int isParentValidPart = mpHelper.isPartValid(theWitRun, mfgParentPartName, parentPdf, 
						 fileName, dataLine, lineNo, PURELY_OPTIONAL);
    int isParentValidOperation = mpHelper.isOperationValid(theWitRun, mfgParentPartName, parentPdf, 
							   fileName, dataLine, lineNo, PURELY_OPTIONAL);

    // The first case is for Records where the parent is supposed to be an Operation
    if (isParentAnOperation && (isParentValidPart || !isParentValidOperation)) {
      (*theErrFacil)("UnrecognizedOperationPdfWarning",MclArgList() 
		     << mfgParentPartName 
		     << parentPdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      return -1;	
    }

    // The second case is for Records where the parent is supposed to be a Part
    if (!isParentAnOperation && !isParentValidPart) {
      (*theErrFacil)("UnrecognizedOperationPdfWarning",MclArgList() 
		     << mfgParentPartName 
		     << parentPdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      return -1;	
    }
	

    // AT this time we only support the children and subs to be parts.  In the
    // future we'll allow any combination of subbability
    if (! mpHelper.isPartValid(theWitRun, mfgChildPartName, childPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;

    if (! mpHelper.isPartValid(theWitRun, mfgSubPartName, subPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;


    witGetOperationNBomEntries(theWitRun, fullParentName.c_str(), &nBomEntries);
    // Now loop through the BOM of the parent and stop when you find a child match
    int foundChild = 0;
    int bestMatchingBomEntry;
    int bestOverlap = -1;
    int candidateEarly;
    int candidateLate;
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBomEntries; j++)  {
	witGetBomEntryConsumedPart(theWitRun, fullParentName.c_str(), j, &child);
	if (child == fullChildName)  {
	    // OK, we found a candidate match.  
            // Now compute the overlap of their effectivity ranges.
	    witGetBomEntryEarliestPeriod(theWitRun, fullParentName.c_str(), j, &candidateEarly);
	    witGetBomEntryLatestPeriod(theWitRun, fullParentName.c_str(), j, &candidateLate);
	    int candidateOverlap =    (late > candidateLate ? candidateLate : late )
		                    - (early < candidateEarly ? candidateEarly : early )
                       		    + 1;
	    // Now determine if the candidate is the BEST match so far
	    if ((! foundChild) || (foundChild && (candidateOverlap > bestOverlap))) {
		bestMatchingBomEntry = j;	    
		bestOverlap = candidateOverlap;
	    }
	    foundChild = 1;

	    
	    // Now, if the candidateOverlap is positive, then we need to add a sub record 
	    // for this bomentry.  This fix means that there may be multiple subBoms per sub record.
	    // the old way used a bestOverlap mechnaism to find at most one match between sub record
	    // and bom.

	    if (candidateOverlap > 0) {

	      // make subCost(/preference) into a vector
	      int nPeriods;
	      witGetNPeriods(theWitRun, &nPeriods);
	      float * obj1SubCost = new float[nPeriods];
    
	      int t = 0; // Pulled out of the for below by RW2STL
	      for (t=0; t<nPeriods; t++)
		obj1SubCost[t] = subCost;

	      // note that in 4.0 mode, "fullParentName" is these API calls is the operation name
	      int nSubBoms;
	      witGetBomEntryNSubsBomEntries( theWitRun, fullParentName.c_str(), j, & nSubBoms);
	      float * offset;
	      witGetBomEntryOffset(theWitRun, fullParentName.c_str(), j, &offset);

	      for (t=0; t<nPeriods; t++)
		offset[t] += offsetDelta;

	      witAddSubsBomEntry( theWitRun, fullParentName.c_str(), j, fullSubName.c_str());
	      witSetSubsBomEntryEarliestPeriod( theWitRun, fullParentName.c_str(), j, nSubBoms, early);
	      witSetSubsBomEntryLatestPeriod( theWitRun, fullParentName.c_str(), j, nSubBoms, late);
	      witSetSubsBomEntryOffset(theWitRun, fullParentName.c_str(), j, nSubBoms, offset);
	      witSetSubsBomEntryExpNetAversion(theWitRun, fullParentName.c_str(), j, nSubBoms, subCost);
	      witFree(offset);


	      if (groupSharingViaExecPenalties_) {
		witSetSubsBomEntryExecPenalty(theWitRun, fullParentName.c_str(), j, 
					      nSubBoms, execPenalty);
	      }


	      // 4.10: explicitly set netAllowed as part of the subBom input file.   
	      // the DK should re-generate the subpn.dat file and set netAllowed=F if childPart is pcf
	      // default for netallowed is true



	      // 2.30: can you net  it?
	      if (subNetAllowed)
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitTRUE);
	      else
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitFALSE);

	      // 2.30: can you build it?
	      if (isSubstituteBuildable)
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitTRUE);
	      else
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitFALSE);

	      witSetSubsBomEntryFallout( theWitRun, fullParentName.c_str(), j, nSubBoms, fallout);
	      witSetSubsBomEntryUsageRate( theWitRun, fullParentName.c_str(), j, nSubBoms, usageRate);
	      // only set the obj1SubCost if we're dealing with the lp engine
	      if ( lpModelHelper_ != 0 )
		witSetSubsBomEntryObj1SubCost( theWitRun, fullParentName.c_str(), j, nSubBoms, obj1SubCost);
	      delete [] obj1SubCost;



	      float * prShare;
	      witGetSubsBomEntryRoutingShare(theWitRun, fullParentName.c_str(), j, nSubBoms, &prShare);
	      int ttt;
	      for (ttt=early; ttt <= late; ttt++) {
		prShare[ttt] = propRtg_Share;
	      }
	      witSetSubsBomEntryRoutingShare(theWitRun, fullParentName.c_str(), j, nSubBoms, prShare);
	      witFree(prShare);
	      




	      // store "preference" and OptExplosionFlag in the subBom app data
	      void * subBomAppVoidPtr;
	      LgFrSceSubBomAppData * mySubBomAppDataPtr;

	      witGetSubsBomEntryAppData( theWitRun, fullParentName.c_str(), j, nSubBoms, &subBomAppVoidPtr );
	      if ( subBomAppVoidPtr != 0 ) {
		(*theErrFacil)("InternalError4",MclArgList() 
			       << mfgParentPartName 
			       << parentPdf 
			       << mfgChildPartName 
			       << childPdf 
			       << fileName 
			       << (int)lineNo 
			       << dataLine);
	      }

	      mySubBomAppDataPtr = new LgFrSceSubBomAppData (subCost, isObjectInEffectForOptExplosionFlag);  
	      assert ( mySubBomAppDataPtr != 0 );
	      witSetSubsBomEntryAppData( theWitRun,
					 fullParentName.c_str(),
					 j,
					 nSubBoms,
					 (void *) mySubBomAppDataPtr );



	    }

	}
	witFree(child);
    }


    if (! foundChild) {
      (*theErrFacil)("MissingBillRecord",MclArgList() 
		     << mfgParentPartName 
		     << parentPdf 
		     << mfgChildPartName 
		     << childPdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      return -1;
    }
    if ((foundChild) && (bestOverlap < 1)) {
      (*theErrFacil)("MissingBOMMatch",MclArgList() 
		     << mfgParentPartName 
		     << parentPdf 
		     << mfgChildPartName 
		     << childPdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      return -1;
    }

    return 0;
}




#ifdef ALTERNATE_AS_SUB
// *************************************************
// Add  Alternate Part Operation and structure As SUBSTITUTE
// **************************************************

int
LgFrInitialProblemForSce::sceAddAlternatePartStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    int nPeriods,
    const std::string & primePart, 
    const std::string & primePdf, 
    const std::string & altPart,
    const std::string & altPdf,
    float usageRate,
    int  early, 
    int late,
    int fallout,
    float preference,
    int isObjectInEffectForOptExplosionFlag,
    int isExpAllowed,
    bool subNetAllowed, // not used
    float groupSharingExecPenaltyThresh,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{


  witBoolean isUnique = true;
  witBoolean exists;
  
  
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  
  std::string fullPrimeName( mpHelper.pdfPartname(primePart,  primePdf));
  std::string fullAltName( mpHelper.pdfPartname(altPart,  altPdf));
  
  
  // first make sure the parts are valid
  if (! mpHelper.isPartValid(theWitRun, primePart, primePdf, 
			     fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
  
  if (! mpHelper.isPartValid(theWitRun, altPart, altPdf, 
			     fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
  
  
  
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  // const std::string & destinationPart == primePart
  // const std::string & destinationPdf == primePdf
  // const std::string & sourcePart == altPart
  // const std::string & sourcePdf == altPdf
  
  
  std::string alternatePartOperationName =
    mpHelper.alternatePartOperationName(primePart, primePdf, altPart, altPdf);

  std::string globalAltDummyPartName =
    mpHelper.globalAltDummyPartName(primePdf);


  
  // test to see if the alternatePart operation already exists
  witGetOperationExists(theWitRun, alternatePartOperationName.c_str(), &exists);
  
  
  // if the alternatePart operation does NOT exist, 
  //    add the operation
  // bom record to the source part, and set some defaults.
  //
  // if the alternatePart operation DOES exists, check to see if this record is a
  // "legal duplicate". To be legal it has to satisfy 2 conditions:
  //   (1) it the same usage rate as the previous records (which is mapped
  //       to the usage rate on the one and only bom for this alternatePart
  //       operation 
  //   (2) the effectivity dates are disjoint from the effectivity
  //       dates on all the other bops for this alternatePart operation
  //   If either (1) or (2) does not hold, reject the record and print an
  //   error message.
  
  if ( ! exists ) {
    // add the dummy alternatePart operation and the source part bom entry to WIT
    witAddOperation( theWitRun, alternatePartOperationName.c_str() );

    witBoolean doesGlobalAltDummyExist;    
    witGetPartExists(theWitRun, globalAltDummyPartName.c_str(), &doesGlobalAltDummyExist);
    if (! doesGlobalAltDummyExist)
      witAddPart(theWitRun, globalAltDummyPartName.c_str(), WitCAPACITY);

    witAddBomEntry( theWitRun, alternatePartOperationName.c_str(), globalAltDummyPartName.c_str() );
    witSetBomEntryEarliestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, early);
    witSetBomEntryLatestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, late);

    witAddSubsBomEntry(theWitRun, alternatePartOperationName.c_str(), 0, fullAltName.c_str());
    witSetSubsBomEntryUsageRate( theWitRun, alternatePartOperationName.c_str(), 0, 0, usageRate );
    float falloutRate = (float) fallout/100.f;
    witSetSubsBomEntryFalloutRate( theWitRun, alternatePartOperationName.c_str(), 0, 0, falloutRate );
    // In our model, there is one and only bom hanging off the alternatePart operation.
    // In our model, the bom is effective through out the entire planning horizon.
    witSetSubsBomEntryEarliestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, 0, early );
    witSetSubsBomEntryLatestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, 0, late );
    witSetSubsBomEntryExpAllowed(theWitRun, alternatePartOperationName.c_str(), 0, 0, isExpAllowed);
    witSetSubsBomEntryExpNetAversion(theWitRun, alternatePartOperationName.c_str(), 0, 0, preference);
    if (groupSharingViaExecPenalties_) {
      witSetSubsBomEntryExecPenalty(theWitRun, alternatePartOperationName.c_str(), 0, 0, preference);
    }

    // Since this is a new alternatePart Operation for the customer loc, increment
    // the nAlternatePartOps counter in the CustLoc Parts appdata.  (Being careful,
    // of course, to ensure the non-null-ness of the appDataPtr for the part
    LgFrScePartAppData * custPartAppData;
    witGetPartAppData(theWitRun, fullPrimeName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
      custPartAppData = new LgFrScePartAppData(0, nPeriods, nPeriods);
      custPartAppData->nAlternatePartOps(1);
      witSetPartAppData(theWitRun, fullPrimeName.c_str(), (void *) custPartAppData);
    }
    else 
      custPartAppData->nAlternatePartOps(custPartAppData->nAlternatePartOps() + 1);      

  }

  if ( exists ) {
    // set unique flag = false
    isUnique = false;

    if ( ! mpHelper.isDuplicateAlternatePartRecordUsageRateValid(
                     theWitRun, fullAltName, alternatePartOperationName,
                     usageRate)) {
      (*theErrFacil)("ConflictingAlternatePartRecordsUR",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << primePart 
		     << primePdf 
		     << altPart 
		     << altPdf 
		     << dataLine);
      return (-1);
    }
    
    if ( ! mpHelper.isDuplicateAlternatePartRecordEffectivityDatesValid(
                      theWitRun, alternatePartOperationName, early, late )) {
      (*theErrFacil)("ConflictingAlternatePartRecordsED",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << primePart 
		     << primePdf 
		     << altPart 
		     << altPdf 
		     << dataLine);
      return (-1);
    }
  }


  // do a sanity check ... THERE MUST BE ONE AND ONLY ONE BOM
  int nBom;
  witGetOperationNBomEntries(theWitRun, alternatePartOperationName.c_str(), &nBom);
  assert(nBom == 1);

  // if we made it here, we either have a "valid duplicate" alternatePart
  // record or a new one. In either case, we now create a bop entry
  // between destination part and alternatePart operation,
  // with effectivity = (early, late)
  int nbBop;
  witGetOperationNBopEntries( theWitRun, alternatePartOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, alternatePartOperationName.c_str(), fullPrimeName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, alternatePartOperationName.c_str(),
                                nbBop, early );      
  witSetBopEntryLatestPeriod( theWitRun, alternatePartOperationName.c_str(),
                              nbBop, late );

  

  // Add an app data for the bop preference and explosion flag
  
  void * bopAppVoidPtr;
  LgFrSceBopAppData * myBopAppDataPtr; 
  witGetBopEntryAppData( theWitRun, alternatePartOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
    (*theErrFacil)("InternalError3",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << primePart 
		   << primePdf 
		   << altPart 
		   << altPdf 
		   << dataLine);
  }
  myBopAppDataPtr = new LgFrSceBopAppData (preference, 
					   isObjectInEffectForOptExplosionFlag, 
					   isExpAllowed);  
  assert ( myBopAppDataPtr != 0 );
  witSetBopEntryAppData( theWitRun, alternatePartOperationName.c_str(),
                         nbBop, (void *) myBopAppDataPtr );


  witSetBopEntryExpAllowed(theWitRun, alternatePartOperationName.c_str(), nbBop, isExpAllowed);
  witSetBopEntryExpAversion(theWitRun, alternatePartOperationName.c_str(), nbBop, preference);

  if ( lpModelHelper_ != 0 ) {    
    float * opExecCost;
    witGetOperationObj1ExecCost(theWitRun, alternatePartOperationName.c_str(), &opExecCost);
    int t=0;
    for (t=early; t<=late; t++)
      opExecCost[t] = preference;
    witSetOperationObj1ExecCost(theWitRun, alternatePartOperationName.c_str(), opExecCost);
    witFree(opExecCost);
  }


  if (isUnique)
    return 0;
  else
    return 1;


    return 0;
}
#else
// *************************************************
// Add  Alternate Part Operation and structure As OPERATION
// **************************************************
int
LgFrInitialProblemForSce::sceAddAlternatePartStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    int nPeriods,
    const std::string & primePart, 
    const std::string & primePdf, 
    const std::string & altPart,
    const std::string & altPdf,
    float usageRate,
    int  early, 
    int late,
    int fallout,
    float preference,
    int isObjectInEffectForOptExplosionFlag,
    int isExpAllowed,
    bool subNetAllowed, // not used
    float groupSharingExecPenaltyThresh,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{


    witBoolean isUnique = true;
    witBoolean exists;


    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

    std::string fullPrimeName( mpHelper.pdfPartname(primePart,  primePdf));
    std::string fullAltName( mpHelper.pdfPartname(altPart,  altPdf));
    

    // first make sure the parts are valid
    if (! mpHelper.isPartValid(theWitRun, primePart, primePdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;

    if (! mpHelper.isPartValid(theWitRun, altPart, altPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;



    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // const std::string & destinationPart == primePart
    // const std::string & destinationPdf == primePdf
    // const std::string & sourcePart == altPart
    // const std::string & sourcePdf == altPdf


    std::string alternatePartOperationName =
      mpHelper.alternatePartOperationName(primePart, primePdf, altPart, altPdf);
	
    // test to see if the alternatePart operation already exists
    witGetOperationExists(theWitRun, alternatePartOperationName.c_str(), &exists);


  // if the alternatePart operation does NOT exist, then add it along with the
  // bom record to the source part, and set some defaults.
  //
  // if the alternatePart operation DOES exists, check to see if this record is a
  // "legal duplicate". To be legal it has to satisfy 2 conditions:
  //   (1) it the same usage rate as the previous records (which is mapped
  //       to the usage rate on the one and only bom for this alternatePart
  //       operation 
  //   (2) the effectivity dates are disjoint from the effectivity
  //       dates on all the other bops for this alternatePart operation
  //   If either (1) or (2) does not hold, reject the record and print an
  //   error message.

  if ( ! exists ) {

    // add the dummy alternatePart operation and the source part bom entry to WIT
    witAddOperation( theWitRun, alternatePartOperationName.c_str() );
    witAddBomEntry( theWitRun, alternatePartOperationName.c_str(), fullAltName.c_str() );
    witSetBomEntryUsageRate( theWitRun, alternatePartOperationName.c_str(), 0, usageRate );
    float falloutRate = (float) fallout/100.f;
    witSetBomEntryFalloutRate( theWitRun, alternatePartOperationName.c_str(), 0, falloutRate );
    // In our model, there is one and only bom hanging off the alternatePart operation.
    // In our model, the bom is effective through out the entire planning horizon.
    witSetBomEntryEarliestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, alternatePartOperationName.c_str(), 0, nPeriods-1 );
    if (groupSharingViaExecPenalties_) {
      witSetBomEntryExecPenalty(theWitRun, alternatePartOperationName.c_str(), 0, preference);
    }

    // Since this is a new alternatePart Operation for the customer loc, increment
    // the nAlternatePartOps counter in the CustLoc Parts appdata.  (Being careful,
    // of course, to ensure the non-null-ness of the appDataPtr for the part
    LgFrScePartAppData * custPartAppData;
    witGetPartAppData(theWitRun, fullPrimeName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
      custPartAppData = new LgFrScePartAppData(0, nPeriods, nPeriods);
      custPartAppData->nAlternatePartOps(1);
      witSetPartAppData(theWitRun, fullPrimeName.c_str(), (void *) custPartAppData);
    }
    else 
      custPartAppData->nAlternatePartOps(custPartAppData->nAlternatePartOps() + 1);      

  }

  if ( exists ) {
    // set unique flag = false
    isUnique = false;

    if ( ! mpHelper.isDuplicateAlternatePartRecordUsageRateValid(
                     theWitRun, fullAltName, alternatePartOperationName,
                     usageRate)) {
      (*theErrFacil)("ConflictingAlternatePartRecordsUR",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << primePart 
		     << primePdf 
		     << altPart 
		     << altPdf 
		     << dataLine);
      return (-1);
    }
    
    if ( ! mpHelper.isDuplicateAlternatePartRecordEffectivityDatesValid(
                      theWitRun, alternatePartOperationName, early, late )) {
      (*theErrFacil)("ConflictingAlternatePartRecordsED",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << primePart 
		     << primePdf 
		     << altPart 
		     << altPdf 
		     << dataLine);
      return (-1);
    }
  }


  // do a sanity check ... THERE MUST BE ONE AND ONLY ONE BOM
  int nBom;
  witGetOperationNBomEntries(theWitRun, alternatePartOperationName.c_str(), &nBom);
  assert(nBom == 1);

  // if we made it here, we either have a "valid duplicate" alternatePart
  // record or a new one. In either case, we now create a bop entry
  // between destination part and alternatePart operation,
  // with effectivity = (early, late)
  int nbBop;
  witGetOperationNBopEntries( theWitRun, alternatePartOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, alternatePartOperationName.c_str(), fullPrimeName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, alternatePartOperationName.c_str(),
                                nbBop, early );      
  witSetBopEntryLatestPeriod( theWitRun, alternatePartOperationName.c_str(),
                              nbBop, late );

  

  // Add an app data for the bop preference and explosion flag
  
  void * bopAppVoidPtr;
  LgFrSceBopAppData * myBopAppDataPtr; 
  witGetBopEntryAppData( theWitRun, alternatePartOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
    (*theErrFacil)("InternalError3",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << primePart 
		   << primePdf 
		   << altPart 
		   << altPdf 
		   << dataLine);
  }
  myBopAppDataPtr = new LgFrSceBopAppData (preference, 
					   isObjectInEffectForOptExplosionFlag, 
					   isExpAllowed);  
  assert ( myBopAppDataPtr != 0 );
  witSetBopEntryAppData( theWitRun, alternatePartOperationName.c_str(),
                         nbBop, (void *) myBopAppDataPtr );


  witSetBopEntryExpAllowed(theWitRun, alternatePartOperationName.c_str(), nbBop, isExpAllowed);
  witSetBopEntryExpAversion(theWitRun, alternatePartOperationName.c_str(), nbBop, preference);

  if ( lpModelHelper_ != 0 ) {    
    float * opExecCost;
    witGetOperationObj1ExecCost(theWitRun, alternatePartOperationName.c_str(), &opExecCost);
    int t=0;
    for (t=early; t<=late; t++)
      opExecCost[t] = preference;
    witSetOperationObj1ExecCost(theWitRun, alternatePartOperationName.c_str(), opExecCost);
    witFree(opExecCost);
  }


  if (isUnique)
    return 0;
  else
    return 1;


    return 0;
}

#endif



// Set the Part Sourcing Structure (SCE 5.00)
int
LgFrInitialProblemForSce::sceSetSourcingStructure(
						  WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & part, 
    const std::string & pdf,
    const std::string & sourceCode, 
    float pref_cost,
    int early,
    int late,
    int nPeriods,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  std::string fullPartName(mpHelper.pdfPartname(part, pdf));


  if (! mpHelper.isPartValid(theWitRun, part, pdf, 
			     fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
  
  // parse the sourceCode
  
  //  A-sourced means can buy through interplant
  //  F-sourced means can Fabricate (build) in house using default operation
  //  P-sourced means it uses proportional routing
  //  S-sourced means it is single-sourced in the WIT sense

  // P-sourced and S-sourced are mutually exclusive
  size_t A_sourced = (sourceCode.find_first_of("A") == sourceCode.npos) ? 0 : 1;
  size_t F_sourced = (sourceCode.find_first_of("F") == sourceCode.npos) ? 0 : 1;
  size_t S_sourced = (sourceCode.find_first_of("S") == sourceCode.npos) ? 0 : 1;
  size_t P_sourced = (sourceCode.find_first_of("P") == sourceCode.npos) ? 0 : 1;
  
  
  
  if (P_sourced) {
    witSetPartPropRouting(theWitRun, fullPartName.c_str(), WitTRUE);
  }
  
  // if not P-sourced , then check for S-sourced
  else {
    witSetPartPropRouting(theWitRun, fullPartName.c_str(), WitFALSE);
    if (S_sourced) {
      witSetPartSingleSource(theWitRun, fullPartName.c_str(), WitTRUE);
    }
  }
  



  if  (!P_sourced  && !A_sourced && !P_sourced && !S_sourced)  {
    (*theErrFacil)("UnrecognizedSourceCode",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << part
		   << pdf
		   << dataLine);
  }




  /*
  if (sourceCode == "AFP") {
     witSetPartPropRouting(theWitRun, fullPartName.c_str(), WitTRUE);
   }
  else if (sourceCode == "AF") {
    witSetPartPropRouting(theWitRun, fullPartName.c_str(), WitFALSE);
  }
  else {
    (*theErrFacil)("UnrecognizedSourceCode",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << part
		   << pdf
		   << dataLine);
  }
  */



  


  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
  if (appDataPtr != 0) {
    appDataPtr->sourceCode(sourceCode);
  }
  else {
    appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
    appDataPtr->sourceCode(sourceCode);
  }
  witSetPartAppData(theWitRun, fullPartName.c_str(), appDataPtr);


//  if (sourceCode == "AFP") { 
  if (A_sourced && F_sourced && P_sourced) {
    // shut prodRate to 0 on bop to default operation
    // whenever we get an interplant, we turn it back on 
    witBoolean exists;
    witGetOperationExists(theWitRun, fullPartName.c_str(), &exists);
    if (exists) {
      int nBopEntries;
      witGetOperationNBopEntries(theWitRun, fullPartName.c_str(), &nBopEntries);
      assert(nBopEntries == 1);
      LgFrTimeVecFloat zeroVec(nPeriods, 0.0);
      witSetBopEntryProductRate(theWitRun, fullPartName.c_str(), 0, zeroVec.data());
    }
  }
   

    
  return 0;
}


#ifdef VARIABLE_PERIODS
// Normal BOM entry 
int
LgFrInitialProblemForSce::sceAddNormalBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
    float usageRate,
    float usageTime,
    int early,
    int late,
    int fallout,
    int mec,
    int phantomFlag,
    int removeBillFlag,
    int propRtgFlag,
    float propRtgShare,
    int nPeriods,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
  std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
  std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));
  
  // remove bills get usage negated
  if (removeBillFlag)  
    usageRate = -usageRate;
  
  if (! mpHelper.isPartValid(theWitRun, parent, parentPdf, 
			     fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
  if (! mpHelper.isPartValid(theWitRun, child, childPdf,
			     fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
  
  int t = 0;
  
  // Need to convert cycleTime and (usageTime (in days, over effective interval))  ==> offset timeVec
  // Notes: cycleTime can be positive or negative
  //
  // 
  LgFrTimeVecFloat offsetTV(nPeriods, 0.0);
  LgFrTimeVecFloat parentCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullParentName);

  // phantom bills get a usage time that is equal to the cycle Time of the child.  
  if (phantomFlag) {
    LgFrTimeVecFloat childCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullChildName);
      for (t=early; t<=late; t++) {
      offsetTV[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime - childCycleTimeDays[t], t, theCal, nPeriods);
    }
  }
  else   {
    for (t=early; t<=late; t++) {
      offsetTV[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime, t, theCal, nPeriods);
    }
  }
  
  
  LgFrTimeVecFloat consRate(nPeriods, usageRate);
  int nBom;
  witGetOperationNBomEntries(theWitRun, fullParentName.c_str(), &nBom);
  witAddBomEntry(theWitRun, fullParentName.c_str(), fullChildName.c_str());
  witSetBomEntryConsRate(theWitRun, fullParentName.c_str(), nBom, consRate.data());
  witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, offsetTV.data());
  //  witSetBomEntryUsageTime(theWitRun, fullParentName.c_str(), nBom, usageTime);
  float falloutRate = (float) fallout / 100.f;
  witSetBomEntryFalloutRate(theWitRun, fullParentName.c_str(), nBom, falloutRate);
  witSetBomEntryEarliestPeriod(theWitRun, fullParentName.c_str(), nBom, early);
  witSetBomEntryLatestPeriod(theWitRun, fullParentName.c_str(), nBom, late);
  witSetBomEntryMandEC(theWitRun, fullParentName.c_str(), nBom, mec);
  if (propRtgFlag) {
    witBoolean * prFlag;
    float * prShare;
    witGetBomEntryPropRtg(theWitRun, fullParentName.c_str(), nBom, &prFlag);
    witGetBomEntryRoutingShare(theWitRun, fullParentName.c_str(), nBom, &prShare);
    int ttt;
    for (ttt=0; ttt<nPeriods; ttt++) {
      prFlag[ttt] = WitTRUE;
      prShare[ttt] = propRtgShare;
    }
    witSetBomEntryPropRtg(theWitRun, fullParentName.c_str(), nBom, prFlag);
    witSetBomEntryRoutingShare(theWitRun, fullParentName.c_str(), nBom, prShare);
    witFree(prFlag);
    witFree(prShare);
  }
#if 0
  std::cout << "Bom offset for [" << fullParentName << "->" << fullChildName << "] = (";
  for (t=0; t<nPeriods; t++) 
    std::cout << offsetTV[t] << ",";
  std::cout << std::endl;
#endif
  
  return 0;
}

#else
// the OLD WAY 
// Normal BOM entry (mandatory)
int
LgFrInitialProblemForSce::sceAddNormalBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
    float usageRate,
    float usageTime,
    int early,
    int late,
    int fallout,
    int mec,
    int phantomFlag,
    int removeBillFlag,
    int propRtgFlag,
    float propRtgShare,
    int nPeriods,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));

	
    // remove bills get usage negated
    if (removeBillFlag)  
	usageRate = -usageRate;


	
    if (! mpHelper.isPartValid(theWitRun, parent, parentPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;

    if (! mpHelper.isPartValid(theWitRun, child, childPdf,
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;






#if 0
    // OLD attempt to convert usageTime to offsets
    // Need to convert from cycleTime ==> offset
    float * offset;
    int t=0;

    witGetPartCycleTime(theWitRun, fullParentName.c_str(), &offset);
    for (t=0; t<nPeriods; t++) 
      offset[t] -= usageTime;

    if (phantomFlag) {
      float * childCycleTime;
      witGetPartCycleTime(theWitRun, fullChildName.c_str(), &childCycleTime);
      for (t=0; t<nPeriods; t++) 
	offset[t] = - childCycleTime[t];
      witFree(childCycleTime);
    }
#endif


    // phantom bills get a usage time that is equal to the cycle Time
    // of the child.  The implementation is to set the usage time (a scalar)
    // to the cycleTime that is in effect for  period=early.   When WIT 4.0
    // gets implemented, we'll simply set the offset to be vector equal to the
    // negative of the childs cycleTime.  For now this is a FINISH_ME.
    if (phantomFlag) {
	int nPeriods;
	witGetNPeriods(theWitRun, &nPeriods);
	float * cycleTime;
	witGetPartCycleTime(theWitRun, fullChildName.c_str(), &cycleTime);
	usageTime = cycleTime[early];
	witFree(cycleTime);
    }
    // #endif


    LgFrTimeVecFloat consRate(nPeriods, usageRate);
    int nBom;
    witGetOperationNBomEntries(theWitRun, fullParentName.c_str(), &nBom);
    witAddBomEntry(theWitRun, fullParentName.c_str(), fullChildName.c_str());
    witSetBomEntryConsRate(theWitRun, fullParentName.c_str(), nBom, consRate.data());
    //    witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, offset);
    witSetBomEntryUsageTime(theWitRun, fullParentName.c_str(), nBom, usageTime);

    float falloutRate = (float) fallout / 100.f;
    witSetBomEntryFalloutRate(theWitRun, fullParentName.c_str(), nBom, falloutRate);
    witSetBomEntryEarliestPeriod(theWitRun, fullParentName.c_str(), nBom, early);
    witSetBomEntryLatestPeriod(theWitRun, fullParentName.c_str(), nBom, late);
    witSetBomEntryMandEC(theWitRun, fullParentName.c_str(), nBom, mec);
    if (propRtgFlag) {
      witBoolean * prFlag;
      float * prShare;
      witGetBomEntryPropRtg(theWitRun, fullParentName.c_str(), nBom, &prFlag);
      witGetBomEntryRoutingShare(theWitRun, fullParentName.c_str(), nBom, &prShare);
      int ttt;
      for (ttt=0; ttt<nPeriods; ttt++) {
	prFlag[ttt] = WitTRUE;
	prShare[ttt] = propRtgShare;
      }
      witSetBomEntryPropRtg(theWitRun, fullParentName.c_str(), nBom, prFlag);
      witSetBomEntryRoutingShare(theWitRun, fullParentName.c_str(), nBom, prShare);
      witFree(prFlag);
      witFree(prShare);
    }


    //    witFree(offset);


    return 0;
}

#endif






// Normal BOC entry (mandatory)
int
LgFrInitialProblemForSce::sceAddNormalBocStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
    float usageRate,
    float usageTime,
    int early,
    int late,
    bool capacityOffsetToZero,
    const LgFrTimeVecFloat & zeroVec,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));

	
    if (! mpHelper.isPartValid(theWitRun, parent, parentPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;

    if (! mpHelper.isPartValid(theWitRun, child, childPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;


    int nBom;
    witGetOperationNBomEntries(theWitRun, fullParentName.c_str(), &nBom);
    witAddBomEntry(theWitRun, fullParentName.c_str(), fullChildName.c_str());
    // witSetBomEntryUsageRate(theWitRun, fullParentName.c_str(), nBom, usageRate);
    float * consRate;
    witGetBomEntryConsRate(theWitRun, fullParentName.c_str(), nBom, &consRate);
    int t;

    int nPeriods = theCal.nPeriods();
    LgFrTimeVecFloat offset(nPeriods, 0.0);
    
    if (! capacityOffsetToZero)   {
#ifdef VARIABLE_PERIODS
      LgFrTimeVecFloat parentCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullParentName);
#endif
      
      for (t=early; t<=late; t++)  {
#ifdef VARIABLE_PERIODS
	//       offset[t] = mpHelper.calculateVariableOffset(usageTime, t, theCal, nPeriods);
	offset[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime, t, theCal, nPeriods);
#else
	offset[t] = usageTime;
#endif
      }
    }
    
    
    for (t=early; t<=late; t++)   {
      consRate[t] = usageRate;
      // come here
    }
    witSetBomEntryConsRate(theWitRun, fullParentName.c_str(), nBom, consRate);
    witFree(consRate);
    witSetBomEntryEarliestPeriod(theWitRun, fullParentName.c_str(), nBom, early);
    witSetBomEntryLatestPeriod(theWitRun, fullParentName.c_str(), nBom, late);

    witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, offset.data());


    return 0;
}



// Add aggregation part
int
LgFrInitialProblemForSce::sceAddAggregateBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & mfgPart, 
    const std::string & mfgPdf,
    const std::string & aggregatePart, 
    const std::string & aggregatePdf, 
    float usageRate,
    float offset,
    float preference,
    int isObjectInEffectForOptExplosionFlag,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{

  // Add an aggregation operation 
  witBoolean exists;

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  std::string fullMfgPart(mpHelper.pdfPartname(mfgPart, mfgPdf));
  std::string fullAggregatePart(mpHelper.pdfPartname(aggregatePart,  aggregatePdf));
 
  // if the parent part does not already exist, then reject the record!
  if (! mpHelper.isPartValid(theWitRun, mfgPart, mfgPdf,
                             fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;

  // if the child part does not already exist, then complain and reject!!!
  if (! mpHelper.isPartValid(theWitRun, aggregatePart, aggregatePdf, 
                             fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;


  std::string aggOpName(mpHelper.aggregationOperationName(mfgPart, mfgPdf,
                                                        aggregatePart, aggregatePdf));

  // if the agg operation already exists, then reject it.  No duplicates allowed
  // NOTE: We do allow multiple aggregation operations for a given real part,
  // i.e. it is now ok to multiply aggregate a single part
  witGetOperationExists(theWitRun, aggOpName.c_str(), &exists);
  if (exists) {
    (*theErrFacil)("DuplicateAggRecord",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    return -1;
  }

  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);
  float * offsetVec = new float[nPeriods];
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
    offsetVec[t] = offset;
    
  witAddOperation(theWitRun, aggOpName.c_str());

  witAddBopEntry(theWitRun, aggOpName.c_str(), fullMfgPart.c_str());
  // FINISH_ME:  How do we set preference on Aggregation and explosion flag
  LgFrSceBopAppData * appDataPtr = new LgFrSceBopAppData(preference, isObjectInEffectForOptExplosionFlag, 0);
  witSetBopEntryAppData(theWitRun, aggOpName.c_str(), 0, (void *) appDataPtr);

    
  witAddBomEntry(theWitRun, aggOpName.c_str(), fullAggregatePart.c_str());
  witSetBomEntryUsageRate(theWitRun, aggOpName.c_str(), 0, usageRate);
  witSetBomEntryOffset(theWitRun, aggOpName.c_str(), 0, offsetVec);
  delete [] offsetVec;

  // Since this is a new aggregation Operation for the customer loc, increment
  // the nAggregationOps counter in the CustLoc Parts appdata.  (Being careful,
  // of course, to ensure the non-null-ness of the appDataPtr for the part
  LgFrScePartAppData * custPartAppData;
  witGetPartAppData(theWitRun, fullMfgPart.c_str(), (void **) &custPartAppData);
  if (custPartAppData == 0) {
    custPartAppData = new LgFrScePartAppData(0, nPeriods, nPeriods);
    custPartAppData->nAggregationOps(1);
    witSetPartAppData(theWitRun, fullMfgPart.c_str(), (void *) custPartAppData);
  }
  else 
    custPartAppData->nAggregationOps(custPartAppData->nAggregationOps() + 1);      

  

  return 0;
}


// Add BOM entry for a GeoPlannerDemandPart --> to a Real Part
int 
LgFrInitialProblemForSce::sceAddDemandBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const LgFrCalendar & theCal,
    const std::string & geoPlannerDemandPartName,
    const std::string & pdf_PartName,
    int early,
    int late,
    float transitTime,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{

  // Test to see that you are not trying to set up a multiple source demand DURING
  // the same period.  To do this, we look at every BOM entry off of the
  // geoPlannerDemandPartName and map the effectivity ranges onto a vector.
  // Then we check to see if we've overlapping the effectivity with the new
  // Source effectivity range.

  int nBom;
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);

  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  int t = 0;

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // if there are no BOM's then there's no conflict
  if (nBom > 0) {
    int * effectRange = new int[nPeriods];
    int t = 0;
    for (t=0; t<nPeriods; t++)
      effectRange[t] = 0;
    
    // first set the effectRange vector for the new source record
    for (t=early; t<=late; t++)
      effectRange[t] = 1;

    // Now check this with the other source boms already in the system
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++ ) {

      // we need only consider Normal parts since any special parts
      // hanging off the GPD are not "sources"
      char * child;
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      if (! mpHelper.isPartNormal(theWitRun, child)) {
        witFree(child);
        continue;
      }

      
      int bomEarly;
      int bomLate;
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEarly);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomLate);
      for (t=bomEarly; t<=bomLate; t++) {
        if (effectRange[t] == 1) {
          // Aha! we've found a demand being sourced to two locations at the
          // same time (you dirty scoundrel).  Bad user. Bad. Bad. Bad.
          std::string geo;
          std::string plannerPart;
          assert (1 == mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
                                                                  geoPlannerDemandPartName,
                                                                  plannerPart,
                                                                  geo));
	  (*theErrFacil)("MultipleSourceAttempt",MclArgList() 
			 << geo 
			 << plannerPart 
			 << mpHelper.pdf(pdf_PartName) 
			 << mpHelper.partname(pdf_PartName) 
			 << mpHelper.pdf(child) 
			 << mpHelper.partname(child) 
			 << t 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
          witFree(child);
          delete [] effectRange;
          return -1;
        }
        else
          effectRange[t] = 1;
      }
      witFree(child);
    }
    delete [] effectRange;
  }



  witAddBomEntry(theWitRun, geoPlannerDemandPartName.c_str(), pdf_PartName.c_str());
  witSetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), nBom, early);
  witSetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), nBom, late);

  // the transit time goes on the BOM offset
  float * bomOffset;
  witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), nBom, &bomOffset);

  for (t=early; t<=late; t++)  {
#ifdef VARIABLE_PERIODS
    bomOffset[t] = mpHelper.calculateVariableOffset(transitTime, t, theCal, nPeriods);
#else
    bomOffset[t] = transitTime;
#endif
  }
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), nBom, bomOffset);
  witFree(bomOffset);


  // NOTE: TEMPORARILY set the transit time as a BOP Offset also.
  // This makes it easier to add it to feature offsets later.  Remember
  // to shut these off later.
  float * bopOffset;
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), 0, &bopOffset);
  for ( t=early; t<=late; t++)
    bopOffset[t] = transitTime;
  witSetBopEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), 0, bopOffset);
  witFree(bopOffset);
  
  return 0;
}

  // Add BOM entry for a DemandPart --> to a Demand UpperBound Part
int 
LgFrInitialProblemForSce::sceAddDemandUbBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & demandPart,
    const std::string & demandUpperBoundPart, 
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
  witAddBomEntry(theWitRun, demandPart.c_str(), demandUpperBoundPart.c_str());

  return 0;
}


// ============================================================
// ============================================================
// =========(this is sceReslt.C ===============================


//  ---------------------------------------------------------------------
//  Print Heuristic data
//  --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::printOverallHeuristicValues(
         WitRun * const theWitRun,   // WIT environment   
         const int nPeriods,         // Number of periods 
         const int nParts,           // Number of parts   
         char ** partList,           // List of part names
         std::string fileName)
{

   std::string partName;

   std::ofstream outFile(fileName.c_str());//, ios::out);

   int *   priority;
   float * shipVol;
   float * demandVol;
   float cumpts = 0.0;
   float cumblog = 0.0;
   int nDemands;
   char ** dList;
   float cumdvol = 0.0;
   float newBlog;
   int i, j, t;

   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {

       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
       for (j =0; j<nDemands; j++)  {
	   witGetDemandPriority(theWitRun, partList[i], dList[j], &priority);
	   witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	   witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	   for (t=0; t<nPeriods; t++) {
	       cumpts += (shipVol[t] * priority[t]);
	       newBlog = (demandVol[t] > shipVol[t]) ? demandVol[t] - shipVol[t] : 0.0f;
	       cumblog += newBlog;
	       cumdvol += demandVol[t];
	   }
	   witFree(dList[j]);
	   witFree(priority);
	   witFree(shipVol);
	   witFree(demandVol);
       }
       witFree(dList);

   }

   outFile << " Cum OBJ*Ship = " << cumpts << "\n";
   if (cumdvol > 0.0001) 
     outFile << " Cum Serv = " << 1.0 - (cumblog/cumdvol) << "\n";
   else 
     outFile << " Cum Serv = "
             << "uncomputable ... There are NO demand vols\n";     

   outFile.close();

}




// One stop WIT messaging control
void 
LgFrInitialProblemForSce::setWitInformationalMessaging(WitRun * const theWitRun,   
                                                       int onOrOff)
{
  this->sceScenario()->setWitInformationalMessaging(theWitRun, onOrOff);
}








#endif


// Create a copy of the *this on the heap and return a pointer to it
// Even thought this returns a LgFrInitialProblemAndParameters*, the pointer
// must point to a LgFrInitialProblemForSce.
LgFrInitialProblemAndParameters*
LgFrInitialProblemForSce::clone ()
     const
{
  return new LgFrInitialProblemForSce(*this);
}

// Make scenario clone copy of object
LgFrInitialProblemAndParameters *
LgFrInitialProblemForSce::clone(
   LgFrScenarioSmartPointer newScenario)
const
{
  LgFrInitialProblemAndParameters* newInst =
      new LgFrInitialProblemForSce(newScenario);
  return (newInst);
}



LgFrInitialProblemForSce::~LgFrInitialProblemForSce()
{
  // Nothing to do, so do nothing but return
  delete heurModelHelper_;
  delete lpModelHelper_;
}

// Assignment operator.
LgFrInitialProblemForSce&
LgFrInitialProblemForSce::operator=(
            const LgFrInitialProblemForSce& rhs)
{
  
  return *new LgFrInitialProblemForSce(rhs.scenario());
}

// Copy constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce(
            const LgFrInitialProblemForSce& source)
:
   LgFrInitialProblemAndParameters(source.scenario()),
   implementSmartFeatures_(source.implementSmartFeatures_),

   heurModelHelper_(source.heurModelHelper_),
   lpModelHelper_(source.lpModelHelper_),
  groupSharingViaExecPenalties_(source.groupSharingViaExecPenalties_)
{
  // All the work is done in the initialization part
  // except this
}

// Default Constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce()
:
    LgFrInitialProblemAndParameters(
       LgFrScenarioSmartPointer::nullScenarioSmartPointer),
       implementSmartFeatures_(true),

    heurModelHelper_(0),
    lpModelHelper_(0),
    groupSharingViaExecPenalties_(FALSE)
{
  // All the work is done in the initialization part
}

// the preferred Constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce(LgFrScenarioSmartPointer scenario)
:
    LgFrInitialProblemAndParameters(scenario),
    implementSmartFeatures_(true),

    heurModelHelper_(0),
    lpModelHelper_(0),
    groupSharingViaExecPenalties_(false)
{
  // All the work is done in the initialization part
}

// Returns a description of the problem that is suitable for use as a
// window heading. This can not be used to set the title; only to query
// it.
std::string
LgFrInitialProblemForSce::title(const LgFrDataInterfaceEssentials* difEssenPtr)
     const
{
  std::string theTitle("Supply Capability Engine: ");
  //  theTitle.append(dataInterfacePtr()->title(difEssenPtr));
  theTitle.append(sceScenario()->dataInterface()->title(difEssenPtr));  
  return theTitle;
}


// get the scenario
LgFrScenarioForSceSmartPointer
LgFrInitialProblemForSce::sceScenario()
     const
{
    if (scenario()->GetScenarioType() != __LGFRSCENARIOFORSCE)  {
        std::cerr << "the object is not a SCE scenario and it is supposed to be"
             << std::endl;
        exit(8);
    }

    return LgFrScenarioForSceSmartPointer(scenario());
}


// Populates the WitRun's data structures 
void
LgFrInitialProblemForSce::feedInto(
				     LgFrLastProblemSolved & lps)
{
  LgFrDataInterface * dif  =
    (LgFrDataInterface*) (sceScenario()->dataInterface());
  LgFrCalendar&     calendar   = sceScenario()->calendar();
  
  assert( dif->dataInterfaceImplementation()->GetDIIType() ==
          __LGFRDATAINTERFACEIMPLEMENTATIONFROMSCEFILES );
  LgFrDataInterfaceImplementationFromSceFiles *difSceF    = 
      (LgFrDataInterfaceImplementationFromSceFiles *) dif->dataInterfaceImplementation();

  

//  std::cout << "\nLgFrInitialProblemForSce::feedinto() ---> " 
//       << this->title() << "\n";
    
  // Get sce file name
  std::string parameterFilename = difSceF->filename();

  // get the witRun pointer from lps
  WitRun * theWitRun = lps.witRun();

  // **********************************
  // Now populate the wit run and sets of parts and demands
  // **********************************

#ifndef ELIMINATE_OLD_MAIN  
  completeTheInitialization(parameterFilename, calendar, theWitRun);
#endif

}


#ifndef ELIMINATE_OLD_MAIN

// ============================================================
// ========= completeTheInitialization() ======================
// ============================================================
void 
LgFrInitialProblemForSce::completeTheInitialization (
    std::string & parameterFileName,
    LgFrCalendar & theCal,
    WitRun * theWitRun)
{
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();


  if (! doesInputFileExist(parameterFileName))  {
    // Error
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() << "Parameter" << parameterFileName << "");
  }

   // get the global soParms from scenario.
   LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
  
   LgFrSceParameterManager myParamMgr;
   // this shares the scenario's error with the parameter manager
   myParamMgr.setErrFacility(theErrFacil);
   myParamMgr.initializeSetOfParameters(parameterFileName, setOfParameters);

   // initialize the set of illegal characters in the flat file manager
   LgFrSceFlatFileMgr & myFlatFileMgr = this->sceScenario()->flatFileMgr();
   myFlatFileMgr.appendToTheSetOfIllegalCharacters( setOfParameters.getString("pdfSeparator"));
   if (setOfParameters.getBool("useMultiAttributeDemand"))
     myFlatFileMgr.appendToTheSetOfIllegalCharacters( setOfParameters.getString("multiAttributeDemandSeparator"));

   myFlatFileMgr.sceIOLogManager().copySetOfParams(this->sceScenario()->setOfParameters());
   
   // reset the IO log
   myFlatFileMgr.sceIOLogManager().resetInputLog();
   myFlatFileMgr.sceIOLogManager().resetOutputLog();

   // also get give paramMgr a handle for iolog manager
   myParamMgr.setIOLogMgr(&(myFlatFileMgr.sceIOLogManager()));


   // Read the calendarFormat code and set it in the flatFileMgr
   std::string calendarFormat = setOfParameters.getString("calendarFormat");
   myFlatFileMgr.setGlobalCalendarFormat(calendarFormat);

   // set variable engine
   sceScenario()->setEngine(setOfParameters.getString("engine"));

#ifndef SCE_OPT_IMPLODE
   if (setOfParameters.getString("engine") == "optimization") {
     (*theErrFacil)("OptEngineNotSupported");
     // this will exit
   }
#endif


   theCal.nPeriods(setOfParameters.getInt("numPeriods"));
   
   // create a multiPlantHelper Object
   LgFrMultiPlantHelper & mpHelper = sceScenario()->multiPlantHelper();


   // Call the API program to read all the datafiles and populate theWitRun
   buildTheWitModelForSce(
       theWitRun, 
       theCal,
       mpHelper);
}

#endif
@


1.97
log
@temp fix to build without Variable_periods
@
text
@a14452 1

d14456 1
a14456 2
  
  int j = 0; // Pulled out of the for below by RW2STL
d14460 1
a14460 1
    std::string mfgOptionPart;
d14462 3
a14464 2
    if ( mpHelper.isPartSpecialStandaloneFeature(theWitRun, child, gg, mm, pdf, mfgOptionPart) ) {
      if (mfgOptionPart == mfgOptionPart) {
d14479 2
@


1.96
log
@fixed memory bug in variable_periods logic for featratio file input processing
@
text
@d17365 1
d17367 1
@


1.95
log
@cplex, and some cleanup
@
text
@d13874 2
a13875 1
  int geoSourceIntervalEndPeriod;
@


1.94
log
@6.2 latest commits to old repository
@
text
@d244 10
a253 3
    // MIP or LP ??   AS of SCE 4.50, this function no longer available in WIT
    //    if (setOfParameters.getBool("optWithLotSizes"))
    //      witSetOptWithLotSizes(theWitRun, WitTRUE);
d382 8
d713 1
a713 1
      processSupplyFile( theWitRun, theCal, nPeriods, supplyFile, mpHelper);  
d716 1
a716 1
      processSupplyFile61( theWitRun, theCal, nPeriods, supplyFile, mpHelper);  
d9496 37
d9534 28
@


1.93
log
@convert capacity datamodel to dated intervals
@
text
@d198 1
a198 1
    witSetBuildWhenEmpty(theWitRun, WitTRUE);
d13296 1
a13296 1
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
d13751 1
a13751 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d14123 1
a14123 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d14374 1
a14374 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d14632 1
a14632 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
d14942 1
a14942 1
    witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d15045 1
a15045 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
d15136 1
a15136 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBoms);
@


1.92
log
@selective Sets is working under 6.1
@
text
@d550 3
a552 3
    // *************************************
    // *** Set up the objective function ***
    // *************************************
d556 1
a556 10
    
    // PRIORITY BASED OBJECTIVE
    //    Set both the obj1Cumship rewards and the heuristic prioities
    //    to be the same thing.  The documented use of SCE is that the
    //    optimizer is used and that the higher the priority value, the
    //    greater the reward.  ADVANCED users can use the heuristic,
    //    provided that there are no features, but must be sure that they
    //    reset the priorities to the conventional heuristic where lower
    //    numbers represent higher priorities.

d559 2
a560 1
      // PRIORITY_MANAGER
d563 2
a564 8
	
	LgFrScePriorityMgr * priorityManager = new LgFrScePriorityMgr(sceScenario(),
								      theWitRun,
								      &mpHelper,
								      &(this->sceScenario()->flatFileMgr()),
								      &theCal);

	
a565 1
	
d569 1
a569 1

a571 2
        // give a warning if the optimization engine is being invoked
        // with prioirites.
d575 1
a575 5

        processDemandObjectiveFile( theWitRun, nPeriods, 
				    priorityFile, mpHelper, 
				    periodicInterestRate);    

a577 1
      
d580 1
a580 4
	
        processIndepDemandObjectiveFile( theWitRun, nPeriods, 
					 indepPriorityFile, mpHelper, 
					 periodicInterestRate);    
a581 1

d585 1
a585 1
    // revenue based objective
d589 1
a589 3
	processDemandObjectiveFile( theWitRun, nPeriods, 
				 revenueFile, mpHelper, 
				 periodicInterestRate);
d593 1
a593 4
          processOptionRevenueFile( theWitRun, theCal, 
				   optionRevFile, mpHelper,
                                   defaultOptionShipReward, 
				   periodicInterestRate);    
d599 1
a599 4
          processOptionRevenueFile( theWitRun, theCal, 
				    featRevFile, mpHelper,
				    defaultOptionShipReward, 
				    periodicInterestRate);    
d603 1
a603 3
	  processIndepDemandObjectiveFile( theWitRun, nPeriods, 
					   indepRevenueFile, mpHelper, 
					   periodicInterestRate);    
a604 4


        
        
d608 1
a608 1
    // profit based objective
d611 1
a611 4
	// processDemandPriorityFile( theWitRun, nPeriods, profitFile, mpHelper);
	processDemandObjectiveFile( theWitRun, nPeriods, 
					profitFile, mpHelper, 
					periodicInterestRate);
d615 1
a615 4
          processOptionRevenueFile( theWitRun, theCal, 
				   optionProfitFile, mpHelper,
                                   defaultOptionShipReward, 
				   periodicInterestRate);    
d619 1
a619 4
          processOptionRevenueFile( theWitRun, theCal, 
				   featProfitFile, mpHelper,
                                   defaultOptionShipReward, 
				   periodicInterestRate);
d627 1
a627 2
      processPipPriorityFile( theWitRun, nPeriods, 
			      pipPriorityFile, mpHelper);
d631 1
a631 2
      processPipIndpPriorityFile( theWitRun, nPeriods, 
				  pipIndpPriorityFile, mpHelper);
d640 1
a640 2
	processMinDemandVolFile( theWitRun, nPeriods, 
				minDemandVolFile, mpHelper);    
d647 1
a647 2
	processMinIndepDemandVolFile( theWitRun, nPeriods, 
				minIndepDemandVolFile, mpHelper);    
d655 1
a655 2
	processBacklogYieldFile( theWitRun, nPeriods, 
				backlogYieldFile, mpHelper);    
d662 1
a662 2
	processGreedySearchIncFile( theWitRun, nPeriods, 
				greedySearchIncFile, mpHelper);    
d669 1
a669 2
	processIndpGreedySearchIncFile( theWitRun, nPeriods, 
					indpGreedySearchIncFile, mpHelper);    
d697 6
a702 7
    processSupplyFile( theWitRun, theCal, nPeriods, supplyFile, mpHelper);  

#ifdef DATED_SUPPLY_FILE
    std::string datedSupplyFile = setOfParameters.getString("datedSupplyFile");
    if (! datedSupplyFile.empty())
      processDatedSupplyFile( theWitRun, theCal, nPeriods, datedSupplyFile, mpHelper);  
#endif
d708 7
a714 4
    if (! capSupplyFile.empty())    
      processCapacitySupplyFile( theWitRun, nPeriods, 
				capSupplyFile, mpHelper);    

d716 2
d4718 1
a4718 1
#ifdef DATED_SUPPLY_FILE
d4721 1
a4721 1
LgFrInitialProblemForSce::processDatedSupplyFile(
a4729 6
 std::string pdf_PartName;
 std::ifstream inFile;
 float * supplyVol;
 long lineNo = 0;
 std::string dataLine;
 int supplyPeriod;
a4731 1

d4733 2
d4736 2
d4739 1
a4740 2
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
a4741 1

d4743 1
a4743 2
   this->openInputFileAndScrubOutputFile(fileName,
					 "Dated Supply", inFile, outFile, myScrubber, theErrFacil);
a4746 1
   
d4752 3
a4754 2


a4763 1

a4770 1
    //  skip blanks or comments *
a4775 1

d4793 1
a4793 1
    
a4874 1
#endif
d4963 168
a9834 2
 
   // Read next line of file
a9836 1

d9838 1
a9838 8
   
   //  skip blanks or comments '*'
   if ((dataLine[0] == '*') || dataLine.empty()) {
     commentCount++;
     continue;
   }
   
   // construct a tokenizer
a9839 1
   
d9841 1
a9841 2
     (*theErrFacil)("IllegalCharacter",MclArgList() 
		    << fileName << (int)lineNo << dataLine);
a12755 1

@


1.91
log
@mfo fix take two
@
text
@d485 16
a500 4
    if (! topLevelToBBdefFile.empty())
      processTopLevelToFeatureSetFile( theWitRun, theCal, topLevelToBBdefFile, mpHelper);
    if (! topLevelToBBratioFile.empty())
      processFeatureSetToOptionRatioFile(theWitRun, theCal, topLevelToBBratioFile, mpHelper);
d2286 1
a2286 2
      result = flatFileManager.nextInt(isObjectInEffectForOptExplosion,
                       next, fileName, dataLine, lineNo, false, 0, 1); 
d2290 1
a2290 2
      result = flatFileManager.nextInt(expAllowed,
                       next, fileName, dataLine, lineNo, false, 0, 1); 
d2671 155
d3646 1
a3646 6
    this->openInputFileAndScrubOutputFile(fileName,
					  "Top Level To Feature Set File",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);
a3653 2
	
	// read the next BOM line
a3655 2

//  skip blanks or comments *
a3660 2

// check if the line contains any illegal characters
a3663 2

        
d3666 2
a3667 3
// get the planner Top Level Part Name
	plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
d3673 2
a3674 3
// get the geo
	geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			       lineNo, MANDATORY);
d3676 2
a3677 3
// get the bbCategory name
	bbCategory = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				      lineNo, MANDATORY);
d3756 152
d10275 1
a10275 2
    
    // get the planner Top Level Part Name
d10277 1
a10277 6
    if (result == -1) {
	badCount++;
	continue;
    }

    // get the sourceLoc (we don't use it, it will get rediscovered in next engine flow downstream
d10279 1
a10279 2

    // get the geo
d10281 1
a10281 8
    if (result == -1) {
	badCount++;
	continue;
    }



    // get the mfgOptionPart
d10283 1
a10283 5
    if (result == -1) {
	badCount++;
	continue;
    }

d10297 1
a10297 3
      badCount++;
      continue;
    }
d10300 1
a10300 3
      badCount++;
      continue;
    }
d10305 1
a10305 5
    if (result == -1) {
      badCount++;
      continue;
    }
    
d10308 1
a10308 5
    if (result == -1) {
      badCount++;
      continue;
    }

d10311 1
a10311 5
    if (result == -1) {
      badCount++;
      continue;
    }

d10314 1
a10314 5
    if (result == -1) {
      badCount++;
      continue;
    }

d10317 1
a10317 4
    if (result == -1) {
      badCount++;
      continue;
    }
d10321 2
a10322 4
    if (result == 1) {
      badCount++;
      continue;
    }
d10326 1
a10326 3
      badCount++;
      continue;
    }
d12074 88
d12560 155
d12752 1
a12752 1
    float * featureRatio,
a14681 1
  // get the full wit name for the real option part
a14682 4
  
  
  // test to see if the real option part exists at the pdf.  IF NOT,
  // then print a warning and ignore the record 
@


1.90
log
@mfo is folded into featratio file
@
text
@d13644 2
a13645 1
    witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, offsetTV.data());
d13648 2
a13649 1
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, WitFALSE);
d15486 3
a15488 1
      for (t=0; t<nPeriods; t++)  
d15490 2
@


1.89
log
@fixed array bounds checks
@
text
@d262 1
a262 4
    processPartDefinitionFile(
			      theWitRun, 
			      partDefFile, 
			      mpHelper);
d270 1
a270 4
      processCapacityDefinitionFile(
				  theWitRun, 
                                  capacityDefFile,
                                  mpHelper);
d278 1
a278 5
      processSourceDefFile(
			  theWitRun, 
			  theCal,
			  sourceDefFile,
			  mpHelper);
d286 1
a286 2
	processCycleTimeFile( theWitRun, nPeriods, theCal, 
			     cycleTimeFile, mpHelper);
d293 1
a293 2
	processYieldFile( theWitRun, nPeriods, theCal, 
			 yieldFile, mpHelper);
d301 1
a301 2
	processLotSizeFile( theWitRun, nPeriods, theCal, 
			     lotSizeFile, mpHelper);
d309 1
a309 2
	processProdVolLBFile( theWitRun, nPeriods,
				prodVolLBFile, mpHelper);
a317 2


d323 1
a323 4
      processOperationDefinitionFile(
			      theWitRun,
                              operationDefFile, 
    			      mpHelper);
a324 1

d330 1
a330 2
      processOperationExecPenaltyFile( theWitRun, nPeriods, theCal, 
			     operationExecPenaltyFile, mpHelper);
d342 1
a342 2
	processOperationExecCostFile( theWitRun, nPeriods, theCal, 
				      operationExecCostFile, mpHelper);
d351 1
a351 2
      processOperationLotSizeFile( theWitRun, nPeriods, theCal, 
			     operationLotSizeFile, mpHelper);
d358 1
a358 2
      processOperationYieldFile( theWitRun, nPeriods, theCal, 
			 operationYieldFile, mpHelper);
d366 1
a366 2
      processOperationLBFile( theWitRun, nPeriods,
                              operationLBFile, mpHelper );    
d373 1
a373 2
      processOperationUBFile( theWitRun, nPeriods,
                              operationUBFile, mpHelper );    
d381 1
a381 3
       processOperationBomFile( theWitRun, theCal,
                               operationBomFile,
                               mpHelper);    
d388 1
a388 3
       processOperationBopFile( theWitRun, theCal,
                               operationBopFile,
                               mpHelper );    
d413 1
a413 2
      processInterPlantFile( theWitRun, theCal, 
			     interPlantFile, mpHelper);
d421 1
a421 2
      processBillOfCapacitiesFile( theWitRun, theCal, 
				bocFile, mpHelper);
d428 1
a428 2
      processOperationSubBomFile( theWitRun, theCal, 
				  opSubBomFile, mpHelper);
d437 1
a437 2
	    processStandardBomSubFile( theWitRun, theCal, 
					subBomFile, mpHelper);
a439 1

d445 1
a445 2
      processAggregationFile( theWitRun, theCal, 
				aggregationFile, mpHelper);
a447 1

d451 4
a454 3
      std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
      std::string geoSourceFile = setOfParameters.getString("geoSourceFile");
      std::string demandVolFile = setOfParameters.getString("demandVolFile");
d459 1
a462 1

d484 1
d486 1
a486 5
      processTopLevelToFeatureSetFile( theWitRun, theCal, 
                                      topLevelToBBdefFile, mpHelper);
    
    std::string topLevelToBBratioFile = setOfParameters.getString("topLevelToBBratioFile");

d488 1
a488 5
      processFeatureSetToOptionRatioFile(
					 theWitRun,   
                                         theCal,
                                         topLevelToBBratioFile,
                                         mpHelper);
a495 2


d498 1
a498 2
	process61TopLevelToOptionalFeatureFile(theWitRun, theCal, 
					       topLevelToOptionFile, mpHelper);
a499 1
      
d501 1
a501 2
	processTopLevelToOptionalFeatureFile(theWitRun, theCal, 
					     topLevelToOptionFile, mpHelper);
d512 4
a515 2
      processMachineFeatureOffsetFile( theWitRun, theCal, 
				       machineFeatureOffsetFile, mpHelper);
d524 4
a527 2
      processMachineFeatureSupplyFile( theWitRun, theCal, 
				       machineFeatureSupplyFile, mpHelper);
d1570 1
a1570 6
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int) lineNo 
		     << dataLine 
		     << "BOM entry ignored.");
d4286 3
a4288 3
 float theDatedDemandVol = 0.0f;
 int thePeriod = 0;
 std::string requestDate;
d4364 1
a4364 1
     int result = flatFileManager.readDatedDemandFloatRecord( theDatedDemandVol, requestDate, 
d4368 4
d4375 1
a4375 1
     thePeriod = theCal.period(requestDate);  
d4405 18
a4422 4
     if (thePeriod < 0) 
       thePeriod++;
     if (thePeriod < nPeriods) 
       supplyVol[thePeriod] += theDatedDemandVol;
d4500 1
a4500 5
					 "Dated Supply",
					 inFile,
					 outFile,
					 myScrubber,
					 theErrFacil);
d4506 1
a4506 4
     (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		    << "Dated Supply" 
		    << fileName 
		    << "");
d4529 1
a4529 1
//  skip blanks or comments *
d4538 1
a4538 1
// check if the line contains any illegal characters
d4544 3
a4546 5
// get the pdf partname
    mfgPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				   lineNo, MANDATORY);
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);
d4549 1
a4549 7
    if (! mpHelper.isPartValid(theWitRun, 
			       mfgPartName, 
			       pdf,
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE)) {
d4555 1
a4555 1
    
d4587 7
a4593 1
      
d4595 6
a4600 2

    // if dates were messed up, then skip the record
d4602 2
a4603 8
      std::cerr << "\nsupply period in the PAST\n" << lineNo << ":" << dataLine << std::endl;
      std::cerr << "putting it in week 1\n" << std::endl;
      supplyPeriod = 0;
    }

    if (supplyPeriod == nPeriods)  {
      std::cerr << "\nsupply period in the FUTURE\n" << lineNo << ":" << dataLine << std::endl;
      std::cerr << "ignoring !!\n" << std::endl;
a4607 1

d9905 1
a9905 19
  // Detect that if a maxWithout is 1.0, then the
  // option is a PURE_OPTION, otherwise it is a GATING_OPTION
  // (aka maxWithout option).
  //
  // For PURE_OPTIONS, set up as a direct bom with substitute
  // to a global NULL_Substitute.
  //
  // For a GATING_OPTION (aka maxWithout option), set up as a
  // direct bom with substitute to a maxWithout null substitute if
  // maxWithout ratio is > 0.0. Otherwise, if maxWithout ratio
  // = 0.0 in all periods, set up as a direct bom with substutite
  // to a "global" maxWithout null substitute.
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string geoPreD20;
  std::string mfgOptionPart;
  std::string dataLine;

d9916 8
d9925 9
a9933 3
  int requestPeriod;
  float attachRate;
  float mwoVal;
d9935 2
a9936 2
  float * featureRatio = new float[nPeriods];
  float * maxWithout   = new float[nPeriods];
d9940 2
a9941 4
  LgFrSceSetOfParameters & setOfParameters =
    this->sceScenario()->setOfParameters();
  
  
d9952 1
a9952 6
  this->openInputFileAndScrubOutputFile(fileName,
					"Top Level to Optional Feature",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
d9959 1
d9961 2
a9962 2
    
// read the next BOM line
a9964 2
    
//  skip blanks or comments *
a9969 2

// check if the line contains any illegal characters
d9971 1
a9971 4
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
a9972 2

    
d9975 2
a9976 3
// get the planner Top Level Part Name
    plannerTopLevelPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, OPTIONAL_WITH_MESSAGE);
d9982 2
d9985 2
a9986 9
// get the sourceLoc (we don't use it, it will get rediscovered in next engine flow downstream
    std::string sourceLoc = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
							     lineNo, OPTIONAL_WITH_MESSAGE);
    


// get the geo
    geoPreD20 = flatFileManager.nextQuotedDemandString(next, result, fileName, dataLine, 
						       lineNo, OPTIONAL_WITH_MESSAGE);
d9994 2
a9995 4
// get the (mfg) Option Part  name
    mfgOptionPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				     lineNo, OPTIONAL_WITH_MESSAGE);

a10000 11
    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    float usageRate;

    // First set the feature ratio default to be 0.0
    // Initialize the maxWithout to be 1.0.
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      featureRatio[t] = 0.0;
      maxWithout[t] = 1.0;
    }
d10002 1
a10002 1
    // usageRate ... get the requestDate and the usageRate here
d10004 3
a10006 5
    result = flatFileManager.readDatedDemandFloatRecord( usageRate, requestDate, 
							 dieIfErrorFlag, -FLT_MAX, FLT_MAX,
							 next, fileName, dataLine, lineNo, 
							 mpHelper, theCal);

d10008 4
a10011 2
    // reject if before or after
    int requestPeriod = theCal.period(requestDate);  
d10013 1
a10013 2
      (*theErrFacil)("DatedRecordBeyondHorizonEndIgnore",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
d10018 1
a10018 2
      (*theErrFacil)("DatedRecordBeforeHorizonStartIgnore",MclArgList() 
		     << fileName << (int)lineNo << dataLine);
a10022 4
    
    

    //     result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d10024 1
a10024 1
    // featureRatio 
d10026 3
a10028 7
    if (result == 0)  {
      int t = 0; 
      for (t=0; t<nPeriods; t++)  {
	featureRatio[t] = attachRate;
	if (result != 0)
	  break;
      }
d10031 5
a10035 10
    // maxWithout Ratio vector must be between -1 and +1
    if (result == 0)  {
      result = flatFileManager.nextFloat(mwoVal,
					 next, fileName, dataLine, lineNo, 
					 false, -1.0, 1.0);
      
      int t = 0;
      for (t=0; t<nPeriods; t++)  {
	maxWithout[t] = mwoVal;
      }
d10038 6
d10045 6
d10052 6
a10057 6
    // BIGGIE !!!!
    // D2O 
    // Append the RequestDate onto the demand key to enforce period uniqueness
    std::string geo = mpHelper.expandDemandKeyforD2O(geoPreD20, requestDate, sourceLoc);
    
    
d10059 12
a10071 1
    LgFrTimeVecFloat maxWithoutTimeVec( (size_t) nPeriods, maxWithout );
d10073 3
a10075 2
    float maxMWO = maxWithoutTimeVec.max();
    float minMWO = maxWithoutTimeVec.min();
a10077 15
    // Now make sure the maxWithout does not have positive and negative 
    // Numbers.  This is an error.
    if ((minMWO < -IPSCE_FLT_EPS) && (maxMWO > IPSCE_FLT_EPS)) {
	// if there are negative and positive numbers mixed up
	// then complain and  reject.  
	(*theErrFacil)("MwoPosAndNegNotSupported",MclArgList() 
		       << fileName 
		       << (int)lineNo
		       << dataLine
		       << plannerTopLevelPart
		       << geo 
		       << mfgOptionPart);
	badCount++;
	continue;
    }
d10087 1
a10087 1
    if (minMWO < -IPSCE_FLT_EPS) 
d10089 1
a10089 1
    else if (minMWO < IPSCE_FLT_EPS)
d10091 1
a10091 1
    else if (minMWO < 1.0 - IPSCE_FLT_EPS)
d10099 17
a10115 29
      result = sceAddCustChoiceFeatureStructure(theWitRun, 
						mpHelper,
						theCal,
						plannerTopLevelPart, 
						geo,
						mfgOptionPart,
						usageRate, 
						featureRatio,
						defaultGatingOptionSubPenalty,
						fileName,
						dataLine,
						lineNo);
      
  
    else       {
      result = sceAddStdAloneOptionBomStructure(theWitRun, 
						mpHelper,
						plannerTopLevelPart, 
						geo,
						mfgOptionPart,
						usageRate, 
						featureRatio,
						maxWithout,
						defaultGatingOptionSubPenalty,
						featureType,
						fileName,
						dataLine,
						lineNo);
    }
a10141 2
 delete [] featureRatio;
 delete [] maxWithout;
d12945 1
a12945 1

d13001 1
a13001 1

d13144 1
a13144 7
    (*theErrFacil)("PartDoesNotExistb",MclArgList() 
		   << plannerTopLevelPart 
		   << geo 
		   << featurePart 
		   << fileName 
		   << (int)lineNo
		   << dataLine);
d13169 1
a13169 7
      (*theErrFacil)("OptionAlreadyDefined",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerTopLevelPart 
		     << geo 
		     << featurePart 
		     << dataLine);
d13180 2
a13181 8
    (*theErrFacil)("OptionAllZeroRatiosPO",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << featurePart 
		   << dataLine);
    return -1;
d13185 1
a13185 7
    (*theErrFacil)("CustChoiceFeatRatioGreaterThanOne",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << featurePart 
		   << dataLine);
d13227 3
a13229 12
    (*theErrFacil)("CannotSourcePureOption",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << plannerTopLevelPart 
		   << geo 
		   << machineFullWitPart
		   << featurePart 
		   << pdf 
		   << featurePart 
		   << intervalStartPeriod 
		   << geoSourceIntervalEndPeriod 
		   << dataLine);
d13358 325
d13706 1
a13706 1
  // +     plannerPart, geo, featurePart, f1,f2,...,fNp-1,mwo1,mwo2,...,mwoNp-1
d13711 1
a13711 1
  // +    part to get the PDF.  Then create a mfgOptionPart using featurePart and PDF.
d13787 1
a13787 1
    std::string featurePart;
d13789 2
a13790 2
    if ( mpHelper.isPartSpecialStandaloneFeature(theWitRun, child, gg, mm, pdf, featurePart) ) {
      if (featurePart == mfgOptionPart) {
d13963 1
a13963 1
    // machine cycletime is applied to bomOffset between specialFeature and featurePart.
d13970 1
a13970 1
    // Now work on adding a substitute arc to the geoPlannerDemandPart to featurePart BOM entry.
d14079 428
d14558 1
a14558 1
      std::string featurePart;
d14564 1
a14564 1
						    geo, pp, pdf, featurePart)) {
d14577 1
a14577 1
    						  geo, pp, pdf, featurePart)) {
d14643 1
a14643 5
      if (mpHelper.isDemandSpecialPureOptionBuildDemand(theWitRun,
							partName,
							dList[j],
							ptlpDummy,
							geoDummy)) {
@


1.88
log
@more dated fixes
@
text
@d8541 1
a8541 1
    WitRun * const theWitRun,   
d9603 1
a9603 1
    (*theErrFacil)("DatedRecordBeyondHorizonEnd",MclArgList() 
d9608 1
a9608 1
    (*theErrFacil)("DatedRecordBeforeHorizonStart",MclArgList() 
d9610 1
a9610 1
    return 0;
d9735 40
a9775 1
  // BIGGIE !!!!
a9797 4
  // see what period it falls in
  // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
  // NOTE: you can also use roundedPeriod() 
  int requestPeriod = theCal.period(requestDate);  
d10089 17
@


1.87
log
@pegging and sub enablement for 6.1
@
text
@d5902 16
a5917 16
 while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	floatVec,       // floatVector to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
        dataLine,       // a record of file
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	true,           // Are all elements mandatory?
	0.0,            // data lower limits
	FLT_MAX,        // data upper limits
	true);          // Add demand stream to WIT if not there
d5919 1
a5919 1
    if (nElementsChanged == 0 || nElementsChanged == -1) {
d9602 11
@


1.86
log
@6.1 prep commit ... many things in here
@
text
@d492 2
a493 2
      if (! independentDemandFile.empty())
	processDemandFile( theWitRun, theCal, nPeriods, independentDemandFile, mpHelper);    
d8605 1
a8605 1
#if 1
d15829 1
a15829 1
#if 1
@


1.85
log
@more 6.1 changes
@
text
@d128 1
d132 1
d136 1
d139 1
d145 1
d441 4
a444 4
	std::string interPlantFile = setOfParameters.getString("interPlantFile");
	if (! interPlantFile.empty())
	    processInterPlantFile( theWitRun, theCal, 
				interPlantFile, mpHelper);
d485 21
a505 9
    // ****************************
    // ***  Independent DEMANDS *****
    // ****************************

    // Load INDEPENDENT Demands ... No GPD part!!
    std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (! independentDemandFile.empty())
      processIndependentDemandFile( theWitRun, theCal, nPeriods, independentDemandFile, 
				      mpHelper);    
a506 1
#ifdef ENABLE_NEGATIVE_DEMANDS
a512 1
#endif
a513 23
    // ****************************
    // ***  Geo Source File  *****
    // ****************************


    // Read the source file.  Create Special demand parts and special 
    // BOM entries from these parts to the real parts.
    std::string geoSourceFile = setOfParameters.getString("geoSourceFile");
    if (! geoSourceFile.empty()) {
      processGeoSourceFile( theWitRun, geoSourceFile, 
			    theCal, mpHelper);    
    }

    // ****************************
    // ***  Demand Volume File  *****
    // ****************************

    // Read demand volumes:  - Create the actual Demands in WIT.  
    // And then set the initial volumes.
    std::string demandVolFile = setOfParameters.getString("demandVolFile");
    if (! demandVolFile.empty())
      processDemandVolumeFile( theWitRun, nPeriods, 
			       demandVolFile, mpHelper);    
d539 2
d542 9
a550 2
      processTopLevelToOptionalFeatureFile(theWitRun, theCal, 
                                           topLevelToOptionFile, mpHelper);
d4337 1
d4409 1
a4409 1
   
d4413 1
a4413 1
     int result = flatFileManager.readDatedDemandFloatRecord( theDatedDemandVol, thePeriod, 
d4417 5
d5868 2
a5869 3
    
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
d5882 1
a5882 3
 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();   

a5885 1

d6025 1
d6166 1
a6166 1
    int result = flatFileManager.readDatedDemandFloatRecord( theDatedDemandVol, thePeriod, 
d6170 6
d6237 1
a6237 1
#ifdef ENABLE_NEGATIVE_DEMANDS
a6246 1
#endif
d9415 16
d9432 13
d9446 2
d9449 5
d9455 5
d9461 5
a9465 11
// --------------------------------------------------------------------- 
void 
LgFrInitialProblemForSce::processGeoSourceFile(
    
					       WitRun * const theWitRun,
					       const std::string & geoSourceFile,
					       const LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{
  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenario()->flatFileMgr();   
d9467 8
a9474 1
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
d9476 15
a9490 2
  int nPeriods = theCal.nPeriods();
  // read source file 
d9492 5
a9496 1
  long lineNo = 0;
d9498 2
a9499 5
  LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();   
  // get the engine
  std::string engine = setOfParameters.getString("engine");
    
  std::string fileName(geoSourceFile);
d9501 1
a9501 3
  std::ifstream inFile;
  std::ofstream outFile;
  LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
a9502 16
  inFile.open(fileName.c_str());
  if (! inFile)  {
    (*theErrFacil)("WarningCannotOpenFile",MclArgList() 
		   << "geoSourceFile" 
		   << fileName 
		   << "Will attempt to source parts to the default PDF.");
    return;
  }
  inFile.close();
    
  this->openInputFileAndScrubOutputFile(fileName,
					"geo source file",
					inFile,
					outFile,
					myScrubber,
					theErrFacil);
d9504 8
a9511 5
  std::cout << "Processing " << fileName << ":\t" << std::flush;
  long recCount = 0;
  long badCount = 0;
  long commentCount = 0;    
  long numAddedParts = 0; // this is to count parts added to wit run
d9513 1
d9516 2
d9520 18
a9537 8
  std::string dataLine;
  std::string plannerPartName;
  std::string geo;
  std::string partName;
  std::string pdf;
  int early = 0;
  int late = nPeriods - 1;
  float transitTime = 0.0;
d9539 4
d9544 11
a9555 2
  while(inFile.peek() != EOF) {
    int result = 0;
d9557 19
a9575 3
    // Read next line of file
    std::getline( inFile, dataLine );
    lineNo ++;
d9577 19
a9595 5
    //  skip blanks or comments '*'
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentCount++;
      continue;
    }
a9596 10
    // check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
    }
        
    // construct a tokenizer
    SCETokenizer next(dataLine);
d9598 48
a9645 5
    // get the plannerPartName
    plannerPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
    if (result < 0) {
      badCount++;
      continue;
d9647 2
d9650 5
a9654 2
    // get the geo 
    geo = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
d9656 2
a9657 2
    // get the partName
    partName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
d9659 638
a10296 2
    // get the pdf
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
a11342 11
#if 0
    LgFrSetOfParts & univSOP = sceScenario()->setOfParts(LGFR_UNIVERSAL_SET);
    LgFrPart partToBeAdded   = univSOP . newPart ( fullPartname );
    LgFrSetOfParts & defSOP  = sceScenario()->setOfParts(LGFR_DEFAULT_SET);
    if ( !defSOP.contains( partToBeAdded ) )
      defSOP.push_back(partToBeAdded);

    LgFrSetOfParts & intrPlant = sceScenario()->setOfParts(LGFR_INTERPLANT_SET);
    if ( !intrPlant.contains( partToBeAdded ) )
      intrPlant.push_back(partToBeAdded);
#endif
d13925 1
a13925 1
#ifdef ENABLE_NEGATIVE_DEMANDS
a14011 1
#endif
a15785 1
  // LgFrTimeVecFloat parentCycleTime = mpHelper.getCycleTime(theWitRun, fullParentName);
@


1.84
log
@committing latest development of sce 6.1
@
text
@d15244 5
a15248 4
    LgFrTimeVecFloat parentCycleTimeDays = mpHelper.getCycleTimeDays(theWitRun, fullParentName);


    for (t=early; t<=late; t++)  {
d15250 2
a15251 2
      //       offset[t] = mpHelper.calculateVariableOffset(usageTime, t, theCal, nPeriods);
      offset[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime, t, theCal, nPeriods);
d15253 1
a15253 1
      offset[t] = usageTime;
d15255 1
d15257 2
a15258 2


d15268 1
a15268 4
    
    if (capacityOffsetToZero) {
      std::cout << "Setting capacity offset to zero" << std::endl;
      witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, zeroVec.data());
a15269 6
    }
    else {
      //      witSetBomEntryUsageTime(theWitRun, fullParentName.c_str(), nBom, usageTime);
      witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, offset.data());
      //      std::cout << "Setting capacity UsageTime to zero" << std::endl;
    }
@


1.83
log
@bug fixing with variable offsets
@
text
@d128 1
d138 1
d5857 2
d8580 1
a8580 2
   // get the existing cycleTime for this part (get in two places for now ... 
   // eventually we will get rid of wit34 comaptible  cycleTimes altogether
a8582 1
   //   witGetPartCycleTime(theWitRun, pdf_PartName.c_str(), &ct);
d8596 1
a8596 1
#if 0
d9357 1
a9357 1
	else if (wu <= 0.0001) {
d9367 11
a11461 1
    // NOW_FINISH_ME:   Need to figure out all the offsetting ... BOX, Mach/Feature
d11483 3
d15062 1
a15062 1
#if 0
d15782 2
d15786 1
a15786 1

@


1.82
log
@created preferred appData constructor and made old preferred private
@
text
@d11327 1
a11327 1
    LgFrTimeVecFloat transitTimeOffsetTV;
d11329 9
a11337 9
						      plannerTopLevelPart,
						      geo,
						      sourceBeginPeriod,
						      sourceEndPeriod,
						      transitTimeOffsetTV,
						      fileName,
						      dataLine,
						      lineNo,
						      MANDATORY);
d11452 1
a11452 1
    LgFrTimeVecFloat optionOffset(0.0, nPeriods);
d11455 1
a11455 1
      optionOffset[t] = mfgTopLevelCycleTime[t] - transitTimeOffsetTV[t];
d11683 1
a11683 1
      LgFrTimeVecFloat transitTimeOffsetTV;
d11754 1
a11754 1
	LgFrTimeVecFloat optionOffset(0.0, nPeriods);
d12483 1
a12483 1
  LgFrTimeVecFloat transitTimeOffsetTV;
@


1.81
log
@more fixes for 6.1
@
text
@d15047 1
a15047 1

d15052 1
@


1.80
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@a54 1
    int fileFormatType = SCE_STANDARD_FILE_FORMAT;
a66 5
    std::string fileFormatTypeS = setOfParameters.getString("fileFormatType");
    if (fileFormatTypeS == "epps")
	fileFormatType = SCE_EPPS_FILE_FORMAT;


d175 1
a175 1
    // this really means set buildNstn true for all parts
a176 2
    //    witSetLocalBuildAhead( theWitRun, useLocalBuildAhead );

a202 4




d258 1
a258 2
			      mpHelper, 
			      fileFormatType);
d290 1
a290 1
			     cycleTimeFile, mpHelper, fileFormatType);
d298 1
a298 1
			 yieldFile, mpHelper, fileFormatType);
d307 1
a307 1
			     lotSizeFile, mpHelper, fileFormatType);
a505 1
      bool createMfgPart = false;
d507 1
a507 1
			    theCal, mpHelper, createMfgPart);    
d1144 1
a1144 2
    LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
a1179 2


d1186 46
a1231 9

	std::getline( inFile, dataLine );
	lineNo++;

//  skip blanks or comments *
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
d1233 3
a1235 58

// check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }
        
	SCETokenizer next(dataLine);

// get the partname
	if (fileFormatType == SCE_EPPS_FILE_FORMAT) {
	    pdf_PartName = flatFileManager.nextQuotedString(
		next, result, fileName, dataLine, 
		lineNo, PURELY_OPTIONAL);

	    mfgPartName = mpHelper.partname(pdf_PartName);
	    pdf  = mpHelper.pdf(pdf_PartName);
	}
	else {
 	    mfgPartName = flatFileManager.nextQuotedString(
		next, result, fileName, dataLine, 
		lineNo, PURELY_OPTIONAL);
	    pdf = flatFileManager.nextQuotedString(
		next, result, fileName, dataLine, lineNo,
                MANDATORY);
	}


// =======================
// Now add the part
// =======================

// ===================================
// == Only Regular parts get read here
// ===================================
        result = sceAddNormalPart(theWitRun, 
				  mfgPartName, 
				  pdf, 
				  buildNstn,
				  buildAheadUB,
				  mpHelper, 
				  fileName, 
				  dataLine,
				  lineNo);
	
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << std::endl;
              }
          }
          
	else
	    badCount++;
d1237 1
a1237 1

d1241 1
a1241 1

d1850 2
a1851 3


// scale the  usage time
d1853 1
d2012 2
a2013 1
// scale the  usage time
d2015 2
d2018 1
d2021 1
d4942 1
a4942 1
	appDataPtr = new LgFrScePartAppData(0, unConstrainedStartPeriod);
d5013 1
a5013 1
	appDataPtr = new LgFrScePartAppData(0, unConstrainedStartPeriod);
d5044 1
a5044 1
	appDataPtr = new LgFrScePartAppData(1, unConstrainedStartPeriod);
d8532 1
a8532 2
    LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
a8557 4
 LgFrTimeVecFloat workingDays(nPeriods, 0.0);
 for (t=0; t < nPeriods; t++) {
   workingDays[t] = theCal.workUnits(t);
 }
d8566 1
a8566 1
							start, end, inFile, fileName, dataLine, lineNo,mpHelper, fileFormatType);
d8584 1
a8584 1
      cycleTime[t] = mpHelper.calculateVariableOffset(cycleTimeDays[t], t, workingDays, nPeriods);
d8594 1
d8604 1
a8604 1

d8634 1
a8634 2
    LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
d8667 1
a8667 1
	start, end, inFile, fileName, dataLine, lineNo,mpHelper, fileFormatType);
d8710 1
a8710 2
    LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
d8747 1
a8747 1
	start, end, inFile, fileName, dataLine, lineNo, mpHelper, fileFormatType);
d8879 1
a8879 2
    LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
d8914 1
a8914 1
	start, end, inFile, fileName, dataLine,lineNo, mpHelper, fileFormatType);
d9405 1
a9405 2
					       LgFrMultiPlantHelper & mpHelper,
					       bool createMfgPart)
d9534 6
a9539 28
	  
	  
      // if createMfgPart is true, then we want to create the child
      // part when it doesn't exist.  This thread is only used when
      // using the utility MakeDemandFileForEPPS().
      if (createMfgPart)  {
	bool buildNstn = this->sceScenario()->setOfParameters().getBool("useLocalBuildAhead");
	int  buildAheadLimit = this->sceScenario()->setOfParameters().getInt("buildAheadLimit");
	int * buildAheadUB = new int[nPeriods];
	int t;
	for (t=0; t<nPeriods; t++) 
	  buildAheadUB[t] = buildAheadLimit;

	sceAddNormalPart(theWitRun, partName, pdf, buildNstn, buildAheadUB, mpHelper, fileName,
			 dataLine, lineNo);
	delete [] buildAheadUB;
	numAddedParts++;
      }


      else {
	(*theErrFacil)("UnknownMfgPartPDFPair",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << dataLine);
	badCount++;
	continue;
      }
d9541 1
a9541 1

d10114 1
a10114 1
// check to see if the part has already been defined
d10122 1
a10122 1
	return -1;
d10124 1
a10124 1

d10131 1
a10131 1

d10133 1
a10133 1

d10140 1
a10140 1

d10151 1
a10151 1

d10153 1
d10155 2
a10156 5
      float defaultObj1ProdCostRealParts =
        lpModelHelper_->defaultObj1ProdCostRealParts();
    
      float obj1ProdCostDiscRateRealParts =
        lpModelHelper_->obj1ProdCostDiscRateRealParts();      
d10158 5
a10162 4
      float * obj1ProdCost = new float[nPeriods];
      obj1ProdCost[0] = defaultObj1ProdCostRealParts;

      int t = 0; // Pulled out of the for below by RW2STL
d10164 2
a10165 7
        obj1ProdCost[t] = obj1ProdCost[t-1] - obj1ProdCostDiscRateRealParts;

      witSetOperationObj1ExecCost(theWitRun, partName.c_str(), obj1ProdCost);

      float obj1DefaultStockCostRealParts =
        lpModelHelper_->obj1DefaultStockCostRealParts();      

d10168 1
d10170 4
a10173 4
        obj1ProdCost[t] = obj1DefaultStockCostRealParts;
      witSetPartStockCost(theWitRun, partName.c_str(), obj1ProdCost);

      delete [] obj1ProdCost;
d10175 2
a10176 2
     

d10178 3
a10180 1
    // fix for 4.30.   This is legacy.   In 4.30, user's can set by partnumber, and, can set to either NSTN or ASAP
a10184 2


d10379 3
a10381 1
        custPartAppData = new LgFrScePartAppData;
d10824 1
a10824 1
      custPartAppData = new LgFrScePartAppData;
d12981 1
a12981 1
      appDataPtr = new LgFrScePartAppData;
d14518 1
a14518 1
      custPartAppData = new LgFrScePartAppData;
d14723 1
a14723 1
      custPartAppData = new LgFrScePartAppData;
d14929 1
a14929 1
    appDataPtr = new LgFrScePartAppData(0, nPeriods);
a14996 6
  LgFrTimeVecFloat workingDays(nPeriods, 0.0);
  for (t=0; t < nPeriods; t++) {
    workingDays[t] = theCal.workUnits(t);
  }
  
  
d15010 1
a15010 1
      offsetTV[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime - childCycleTimeDays[t], t, workingDays, nPeriods);
d15015 1
a15015 1
      offsetTV[t] = mpHelper.calculateVariableOffset(parentCycleTimeDays[t] - usageTime, t, workingDays, nPeriods);
d15190 1
d15221 26
a15246 1
    witSetBomEntryUsageRate(theWitRun, fullParentName.c_str(), nBom, usageRate);
d15252 1
d15254 1
a15254 1
      //      std::cout << "Setting capacity offset to zero" << std::endl;
d15257 2
a15258 1
      witSetBomEntryUsageTime(theWitRun, fullParentName.c_str(), nBom, usageTime);
d15345 1
a15345 1
    custPartAppData = new LgFrScePartAppData;
a15386 6
#ifdef VARIABLE_PERIODS
  LgFrTimeVecFloat workingDays(nPeriods, 0.0);
  for (t=0; t < nPeriods; t++) {
    workingDays[t] = theCal.workUnits(t);
  }
#endif
d15464 1
a15464 1
    bomOffset[t] = mpHelper.calculateVariableOffset(transitTime, t, workingDays, nPeriods);
@


1.79
log
@fixed bug processing multple negativeVol demand streams
@
text
@d1684 2
a1685 2

// scale the  usage time
d1687 1
d1691 1
d1892 1
d2676 1
a2676 1
	int t = 0; // Pulled out of the for below by RW2STL
d2689 1
d2703 1
d2946 1
a2946 1
  int tt = 0; // Pulled out of the for below by RW2STL
d3022 1
a3022 1
    int t = 0; // Pulled out of the for below by RW2STL
a3027 1

a3030 2


d3033 1
a3033 1
	int t = 0; // Pulled out of the for below by RW2STL
a3040 1

d3043 1
a3043 1
	int t = 0; // Pulled out of the for below by RW2STL
a3048 1
              
a3051 1

a3057 2


d3091 2
d3096 1
a3106 1

d3177 1
a3177 1
  int t = 0; // Pulled out of the for below by RW2STL
d4858 1
a4858 2
    mfgPartName = flatFileManager.nextQuotedString(
                                   next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
d4863 2
d4866 1
a4866 4
    pdf = flatFileManager.nextQuotedString(
                           next, result, fileName, dataLine, lineNo, MANDATORY);

    // pick up the constrainedHorizon End date.  
a4867 2

    //  if the line is blank then FUTURE is assumed.
d5060 1
a5060 1
      int t = 0; // Pulled out of the for below by RW2STL
a5064 1

d5066 1
a5066 1
      // mark the part as in PCF
d8553 1
a8553 1

d8588 5
d8600 24
d8625 75
a8702 1

d8728 1
d8735 1
a8735 1

d8750 4
a8753 1
 int * yield;
d8794 3
a8796 1
    witGetPartYield(theWitRun, pdf_PartName.c_str(), &yield);
d8798 1
a8798 1
    int t = 0; // Pulled out of the for below by RW2STL
d8800 9
a8808 5
       yield[t] = (int) theVal;
       }
    witSetPartYield(theWitRun, pdf_PartName.c_str(), yield);
    witFree(yield);
//    std::cout << "Updated yields for " << pdf_PartName << "\n";
d8836 2
a8837 1
 int * yield;
d8878 2
a8879 1
    witGetOperationYield(theWitRun, pdf_OperationName.c_str(), &yield);
d8883 7
a8889 4
       yield[t] = (int) theVal;
       }
    witSetOperationYield(theWitRun, pdf_OperationName.c_str(), yield);
    witFree(yield);
d9489 3
a9503 1

d9528 1
a9528 2
    plannerPartName = flatFileManager.nextQuotedString(
						       next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
d9535 1
a9535 3
    geo = flatFileManager.nextQuotedString(
					   next, result, fileName, dataLine, lineNo, MANDATORY);
	    
d9538 1
a9538 2
    partName = flatFileManager.nextQuotedString(
						next, result, fileName, dataLine, lineNo, MANDATORY);
d9541 1
a9541 3
    pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					   lineNo, MANDATORY);

d9546 1
a9546 6
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int)lineNo 
		     << dataLine 
		     << "entry ignored.");
d9550 5
a9554 1
	
d9556 3
a9558 1
    // scale the  usage time
d9560 1
d9633 1
a9633 1
    sceAddDemandBomStructure(theWitRun, mpHelper,
d10559 3
d10953 4
d11284 5
d11293 1
d11382 1
a11382 1
    float transitTimeScaled;
d11388 15
d11413 3
a11497 13
    // ------------------------------------------------------------------------
    // Compute Offsets: transitTime(pdf->geoSource) + cycleTime(mfgTopLevelPart)
    // ------------------------------------------------------------------------
    float * optionOffsets;
    witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &optionOffsets);
    int tt = 0; // Pulled out of the for below by RW2STL
    for (tt=0; tt<nPeriods; tt++)
        optionOffsets[tt] += transitTimeScaled;

    // NOW_FINISH_ME:   Need to figure out all the offsetting ... BOX, Mach/Feature

    
    
d11504 27
a11530 5
    witSetBomEntryUsageRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRate);
    //     witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffsets);
    
    witFree(optionOffsets);
      
d11534 6
a11539 1

d11564 1
a11700 32

#if 0
    // One blip is that the  ratio's are input as
    // vectors, and now must be mapped to scalars.  this is done with
    // multiple arcs -- yukk!
    float currentRatio = featureRatio[firstPeriodWithRatio];
    int ratioBeginPeriod = firstPeriodWithRatio;
    int ratioEndPeriod = nPeriods - 1;
    while (ratioBeginPeriod < nPeriods) {
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=ratioBeginPeriod; t<nPeriods; t++) {
        if (currentRatio != featureRatio[t]) {
          ratioEndPeriod = t-1;
          assert(ratioEndPeriod >= 0);
          break;
        }
      }
      // found an interval with a constant ratio.  Add a bom entry
      witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), optionDummy.c_str(),
                       WitNusageRate,      currentRatio,
                       WitNearliestPeriod, ratioBeginPeriod,
                       WitNlatestPeriod,   ratioEndPeriod,
                       0);

      // setup to find the next interval
      ratioBeginPeriod = t;
      ratioEndPeriod = nPeriods-1;
      if (ratioBeginPeriod < nPeriods)
        currentRatio = featureRatio[ratioBeginPeriod];

    }
#else
a11704 2
#endif

d11745 3
d11749 1
d11751 12
d11764 10
a11773 10
                                                          plannerTopLevelPart,
                                                          geo,
                                                          sourceBeginPeriod,
                                                          sourceEndPeriod,
                                                          transitTimeScaled,
                                                          fileName,
                                                          dataLine,
                                                          lineNo,
                                                          MANDATORY);

d11776 1
a11776 1
    
d11779 1
a11779 1
    
d11787 1
a11787 1

a11804 4
#if 0	
        // now get the offsets: cycletime of the mfgTopLevelPart, and "shipping" transit time
        float * mfgTopLevelCycleTime;
        witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);
a11805 2
        float usageTime = transitTimeScaled - mfgTopLevelCycleTime[sourceEndPeriod]; 
        witFree(mfgTopLevelCycleTime);
d11807 16
a11822 7
        witAddBomEntryVa(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str(),
                         WitNearliestPeriod, sourceBeginPeriod,
                         WitNlatestPeriod,   sourceEndPeriod,
                         WitNusageRate,      usageRate,
                         WitNusageTime,      usageTime,
                         WitNmandEC,         WitTRUE,
                         0);
a11825 1
        std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
a11829 7

	int nBom;
	witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBom);
	witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
	witSetBomEntryEarliestPeriod(theWitRun, optionDummy.c_str(), nBom, sourceBeginPeriod);
	witSetBomEntryLatestPeriod(theWitRun, optionDummy.c_str(), nBom, sourceEndPeriod);
	witSetBomEntryConsRate(theWitRun, optionDummy.c_str(), nBom, usageRateVector.data());
a11830 2
	witSetBomEntryMandEC(theWitRun, optionDummy.c_str(), nBom, WitTRUE);

a11832 1
      
a11834 1

a11870 2


a11871 1

a12246 3


#if 1
a12255 11

#else


    std::string gg, mm;
    if (! mpHelper.isPartSpecialStandaloneFeature(theWitRun, specialFeaturePartName, gg, mm, pdf, mfgop)) {
      witFree(specialFeaturePartName);
      continue;
    }
#endif

d12288 1
d12324 1
d12485 1
a12485 1
  int j = 0; // Pulled out of the for below by RW2STL
d12544 7
d12552 4
a12555 11
  std::string machineFullWitPart = mpHelper.demandSource(theWitRun,
						       plannerTopLevelPart,
						       geo,
						       intervalStartPeriod,
						       geoSourceIntervalEndPeriod,
						       transitTimeScaled,
						       fileName,
						       dataLine,
						       lineNo,
						       MANDATORY);
  
d12559 1
a12559 1
    
d12616 1
a12616 1
  // Further down, we will store featratoi in the  supplyVol of the nullsub
d12623 2
a12624 2
  // beteen gpd part and gpd operation.  Later this bop offset will be reset to 
  // 0.
d12628 2
d15019 105
d15125 2
d15132 1
a15173 22
#if 0
    // phantom bills get a usage time that is equal to the cycle Time
    // of the child.  The implementation is to set the usage time (a scalar)
    // to the cycleTime that is in effect for  period=early.   When WIT 4.0
    // gets implemented, we'll simply set the offset to be vector equal to the
    // negative of the childs cycleTime.  For now this is a FINISH_ME.
    if (phantomFlag) {
	float * cycleTime;
	witGetPartCycleTime(theWitRun, fullChildName.c_str(), &cycleTime);
	usageTime = cycleTime[early];
	witFree(cycleTime);
    }

    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
		     WitNusageRate,      usageRate,
		     WitNusageTime,      usageTime,
		     WitNfallout,        fallout,
		     WitNearliestPeriod, early,
		     WitNlatestPeriod,   late,
		     WitNmandEC,         mec,
		     0);
#endif
d15176 1
a15176 1

a15184 1

a15191 1
    
d15194 1
d15208 1
a15208 4




a15211 2


d15218 1
d15247 6
d15404 1
d15427 7
d15440 1
a15440 1
    int t = 0; // Pulled out of the for below by RW2STL
d15508 5
a15512 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=early; t<=late; t++)
d15514 2
@


1.78
log
@first pass at maxImpliedCommitForATP
@
text
@a1022 25
    // *************************************    
    // Dump the heur version of the echo file
    // *************************************
    if (setOfParameters.getBool("printHeurEchoFile"))  {
      std::cout << "Writing the echo file  ..." << std::endl;                
      std::string echoFileName = setOfParameters.getString("heurEchoFileName");
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_ON);
      witDisplayData( theWitRun, echoFileName.c_str());
      if (! setOfParameters.getBool("printWitMsgFile"))   {
        setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_OFF);          
      }

    }
    // *************************************
    // Dump the heur version of the wit.data file
    // *************************************
    if (setOfParameters.getBool("printHeurWitDataFile"))  {
      std::cout << "Writing the (heur) wit data file ..." << std::endl;                      
      std::string witDataFileName = setOfParameters.getString("heurWitDataFileName");
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_ON);
      witWriteData(theWitRun, witDataFileName.c_str());
      if (! setOfParameters.getBool("printWitMsgFile"))   {
        setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_OFF);          
      }
    }
d1047 1
d8186 2
d13117 2
d13121 2
d13132 1
d13138 2
d13141 1
d13143 20
a13162 11
	mpHelper.setDoesPartHaveNegativeDemands(theWitRun, partName, 1);
	// adjust the supplyVol 
	// negDemVol = demandVol - appDataDemandVol;
	// supplyVol += negDemVol

	LgFrTimeVecFloat negDemVol(mpHelper.negDemVol(theWitRun, partName));
	float * supplyVol;
	witGetPartSupplyVol(theWitRun, partName.c_str(), &supplyVol);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
	  supplyVol[t] += negDemVol[t];
a13163 2
	witSetPartSupplyVol(theWitRun, partName.c_str(), supplyVol);
	witFree(supplyVol);
a13169 1
    
@


1.77
log
@greedySearchInc was not initialized
@
text
@a12761 11
#if 0
  // FINISH_ME: What is this?
  // when the feature ratio is 0, we set the maxWithout ratio to be 0.
  if ( (firstPeriodWithRatio == 0) && (gatingOption) ) {
    int t = 0; // Pulled out of the for below by RW2STL
    for (t= 0; t<firstPeriodWithRatio; t++) {
      maxWithout[t] = 0.0;
    }
  }
#endif
   
@


1.76
log
@removed obsoltete priority manager code in ipSCE
@
text
@d7515 1
a7515 1
  float greedySearchInc;
@


1.75
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@a6316 143
#ifdef PRIORITY_MANAGER

// -----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processPriorityRulesFile(
    
    WitRun * const theWitRun,  
    const int nPeriods,        
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper,
    const float periodicInterestRate)
{

 int nElementsChanged;
 std::string pdf_PartName;
 std::string demandName;
 long lineNo = 0;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Demand Objective Input",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;

 float * floatVec = new float[nPeriods];
 
 while(inFile.peek() != EOF) {
    nElementsChanged = readCsvDemandFloatVector(
    	theWitRun,      // WIT environment    
    	nPeriods,       // Number of periods  
    	pdf_PartName,   // pdf_PartName to be returned
    	demandName,     // demandName to be returned
    	floatVec,       // floatVector to be returned
    	inFile,         // An open input stream
    	fileName,       // for messaging
        dataLine,
    	lineNo,         // current line number, for messaging
    	mpHelper,       // The helper object
    	false,          // Are all elements mandatory?
    	0.0,            // data lower limits
	1000000000,        // data upper limits
	false);         // Do NOT Add new demand stream to WIT

    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;	 
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }

    if ( lpModelHelper_ != 0 ) {

      float  * rev;
      witGetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &rev);
      
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nElementsChanged; t++) {
        rev[t] =  floatVec[t];
      }
      
      witSetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
      
      // Now set the CumShipReward as a timeValue of Money percentage = .10
      for ( t=0; t<nPeriods; t++) {
        rev[t] *=  periodicInterestRate;
      }
      witSetDemandObj1CumShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
      
      witFree(rev);
    }


    
    // Now set the priority for the heuristic, regardless of the engine.
    // NOTE: We need to have
    // the priorities be "the higer the value, the higher the priority"
    // in SCE, so to make it work in the heuristic we "flip" them around

    int * priority;
    witGetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &priority);
    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
      priority[t] = 1000000000 - (int) floatVec[t];
      floatVec[t] = (float) priority[t];
    }
    
    witSetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), priority);
    

    // if doPegging and optimization, then we might store the 
    // priorities in appData because that is where we will look for them
    bool doPegging = this->sceScenario()->setOfParameters().getBool("doPegging");
    if ( lpModelHelper_ != 0  &&  doPegging)  {
      LgFrSceDemandAppData * demandAppDataPtr;
      witGetDemandAppData(theWitRun,
			  pdf_PartName.c_str(), 
			  demandName.c_str(),
			  (void **) &demandAppDataPtr);
      assert ( demandAppDataPtr != 0);
      
      LgFrTimeVecFloat pipPriority(nPeriods, floatVec);
      demandAppDataPtr->pipPriority(pipPriority);
    }


    witFree(priority);
    
    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
 }
 

 delete [] floatVec;
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}

#endif

@


1.74
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d28 1
d610 18
d637 3
a639 2
                                   priorityFile, mpHelper, 
                                   periodicInterestRate);    
d641 2
a642 2


d645 1
a645 1

d6061 11
d6317 57
d6375 84
a7723 1
 int nElementsChanged;
a7729 1
 int t;
d7835 1
a7835 1
					   0, FLT_MAX);
a7836 2
  nElementsChanged = t;

d7841 2
a7842 2

        
a7846 11

    recCount++;
    if (myScrubber -> scrubMode() && outFile.good())
      {
                outFile << dataLine << std::endl;
      }
  }

  std::cout << recCount << " records processed." << std::endl;
  inFile.close();
  outFile.close();
d7848 12
a7859 1
  flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
@


1.73
log
@Version 5.  initial commit
@
text
@d127 18
d497 1
a497 1
	processIndependentDemandFile( theWitRun, nPeriods, independentDemandFile, 
d776 1
a776 1
    processSupplyFile( theWitRun, nPeriods, supplyFile, mpHelper);  
d4341 5
a4345 5
    
    WitRun * const theWitRun,   
    const int nPeriods,         
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
d4347 1
a4347 1

d4349 3
a4351 1
 std::string pdf_PartName;
d4357 2
d4360 1
a4361 1
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
d4365 5
a4370 2
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();   
a4371 1

d4398 1
d4400 39
a4438 14
    nElementsChanged = flatFileManager.readCsvPartFloatVector(
	theWitRun,        // WIT environment    
	nPeriods,         // Number of periods  
	pdf_PartName,     // legal pdf_PartName to be returned
	floatVec,         // floatVector to be returned
	inFile,           // An open stream
	fileName,         // for messaging
        dataLine,
	lineNo,           // for messaging
	mpHelper,         // The helper
	OPTIONAL_WITH_MESSAGE,  // Use one of MANDATORY, PURELY_OPTIONAL
	                        // or OPTIONAL_WITH_MESSAGE
	0.0,              // data lower limits
	FLT_MAX);         // data upper limits
d4440 24
a4464 10
    if (nElementsChanged == 0 || nElementsChanged == -1) {
       badCount++;	
       continue;
    }
    else if (nElementsChanged == -2) {
       commentCount++;
       continue;
    }
    
    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
d4466 19
a4484 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d4486 5
a4490 4
       }
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
    witFree(supplyVol);
//    std::cout << "Updated supply Volume for " << pdf_PartName << "\n";
d4492 12
a4503 8
    recCount++;

    if (! aggregateSupplyInScrub) {
      if (myScrubber -> scrubMode() && outFile.good())  {
	outFile << dataLine << std::endl;
      }
    }
          
d4505 1
a4505 1

d6017 3
a6019 2
    WitRun * const theWitRun,   // 
    const int nPeriods,         //
d6043 5
d6073 2
a6074 2
    commentCount++;
    continue;
a6085 1

d6096 8
a6103 3
   // MULTI_ATTRIBUTE_DEMAND_CLASS:
   //   demandName = flatFileManager.nextMultiAttributeDemandQuotedStrings(next, result, fileName, dataLine, lineNo, MANDATORY);
   //  This method will create the compressedKey with some suitable seperatorKey
d6108 1
a6108 4

   // This code sample uses a TEST capability to allow for Multi-Attribute demand classes
   // demandName = flatFileManager.nextQuotedCustomerString(next, result, fileName, 
   // 						 dataLine, lineNo, MANDATORY);
d6179 1
a6179 8
  // Now get the data
  // DATED_DEMAND_RECORDS: easy to implement, but slower for dense demandVols.   Because each record is for 
  // one period only and we need to find the relevant period and update jus that witPeriod.   No biggie.   make it 
  // additive as well.   
  //
  // Solution Approach: Use appDataPtr's exclusively to set and get the current demandVol as you read it in.   This way
  // we don't need to worry about negative demands being loaded into witDemandVol.
  //
d6184 9
d6194 10
a6203 5
  for (t = 0; t<nPeriods; t++) {
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
					   -FLT_MAX, FLT_MAX);
    if (result == -1) 
      break;
d6206 1
a6206 1
  nElementsChanged = t;
d6222 5
a6226 5
  
  // note: duplicate demandVol records are incremental!!
  // print a warning when detected
  for ( t=0; t<nElementsChanged; t++) {
    demandVolTVF[t] += floatVec[t];
d6229 15
a6243 6
  if (hasDemandVolBeenSet) {
    (*theErrFacil)("MultipleDemandVolRecs",MclArgList() 
		   << fileName 
		   << (int) lineNo 
		   << fullWitPart
		   << demandName);
d6245 1
a6245 1

@


1.72
log
@added function to report interplantPeg from perspective of supplier location.   basically, this shifts the interplant peg earlier to accomodate interplant lead-times
@
text
@d151 4
d717 16
d1613 2
d1659 11
d1688 2
d1811 3
d1858 12
d1888 2
d3967 1
d4022 6
d4053 1
d4189 1
d4238 6
d4289 1
d6005 4
d6087 12
d7348 238
d9697 168
d14008 1
d14122 2
d14154 16
d14195 2
a14196 2
	      witFree(offset);
	      delete [] obj1SubCost;
d14669 1
a14669 1
    WitRun * const theWitRun, 
d14690 28
d14721 7
a14727 4
  // check for a valid sourceCode
  
  if (sourceCode == "AFP") {
    witSetPartPropRouting(theWitRun, fullPartName.c_str(), WitTRUE);
d14730 7
a14739 2


d14748 4
d14767 2
a14768 1
  if (sourceCode == "AFP") { 
d14782 1
d14806 2
d14912 16
@


1.71
log
@sce 4.60, scrapCost, stockCost, greedySearchIncrement,pegging in heuristic, removal of optWithLotSizes
@
text
@d2090 1
d2119 5
d2128 14
a2141 13
                                      mpHelper,
                                      operationName, 
                                      pdf, 
                                      consumedPartName, 
                                      pdf, 
                                      ur,
                                      offset, 
                                      early, 
                                      late,
                                      fallout,
                                       fileName,
                                      dataLine,
                                      lineNo);
d3913 2
d3962 8
d3993 1
d4221 1
d7768 16
d7788 16
d9825 1
d9857 6
d13517 1
d13622 4
@


1.70
log
@added function to print WIT impact period
@
text
@d226 3
a228 3
    // MIP or LP ??
    if (setOfParameters.getBool("optWithLotSizes"))
      witSetOptWithLotSizes(theWitRun, WitTRUE);
a310 2
    // Note: Check in here depends on LBFile being processed first 

a378 1
    // Note: check in here depends on LBFile being processed first
d719 14
d7791 281
@


1.69
log
@enabled buildAheadFile function
@
text
@d980 9
d5033 85
d5195 3
@


1.68
log
@initial changes for sce4.40
@
text
@d7607 1
a7607 1
    result = flatFileManager.nextFloat(buildAheadLimitDays, next, fileName, dataLine, lineNo, false, 0.0);
@


1.67
log
@SCE 4.30 (backed off from calling sce 5.00) has multi-source and Gpip
@
text
@a205 1
      witSetGroupPipMode(theWitRun, WitTRUE);
d715 6
d7520 166
d9076 10
d9091 1
d9352 2
d9360 1
a9360 1

@


1.66
log
@Preliminary commit for SCE 5.00
@
text
@d206 1
@


1.65
log
@set to use witSetNewPipPggOrder
@
text
@d178 14
d262 11
d414 10
d1335 139
d1654 187
d3679 1
d3734 4
d3756 1
d4814 22
a4835 12
	(*theErrFacil)("ExtraPCFPart",MclArgList() 
		       << "it has a producing operation" 
		       << mfgPartName 
		       << pdf 
		       << fileName 
		       << (int)lineNo 
		       << dataLine);
        didWeRejectTheRecord = true;
        witFree(opName);
        // exit out of the loop, again, becuase you don't want to generate
        // multiple error messages per record
        break;
d8960 2
d9352 1
d9363 105
a9467 4
  std::string fullDestinationPartName(mpHelper.pdfPartname(destinationPart, destinationPdf));
  std::string fullSourcePartName( mpHelper.pdfPartname(sourcePart,  sourcePdf));
    
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
d9469 1
a9469 4
  // check to see if destinationPartpart is valid
  if (! mpHelper.isPartValid(theWitRun, destinationPart, destinationPdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
d9471 17
a9489 4
  // check to see if sourcePartPart is valid
  if (! mpHelper.isPartValid(theWitRun, sourcePart, sourcePdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;
d9600 6
d12220 6
d13087 220
d13308 6
a13313 1
// Add  Alternate Part Operation and structure
d13393 2
d13516 63
d13581 17
@


1.64
log
@changed banner for release
@
text
@d215 4
a218 1
    
@


1.63
log
@put in check for forcing netAllowed=FALSE when illegal penalized exectuion situations
@
text
@d12315 1
a12315 1
	  witSetSubsBomEntryNetAllowed(theWitRun, opName, b, s, WitTRUE);
@


1.62
log
@exec penalties were not being set corectly
@
text
@d777 7
a3435 3
 // bool relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");
 bool relaxedSubbingRulesAllowed = false;

a3563 1
	relaxedSubbingRulesAllowed,
a3633 3
 // bool relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");


a3764 1
    bool relaxedSubbingRulesAllowed = false;
a3767 1
					     relaxedSubbingRulesAllowed,
a3789 1
				 relaxedSubbingRulesAllowed,
d12254 100
a12362 1
    bool relaxedSubbingRulesAllowed,
a12587 1
    bool relaxedSubbingRulesAllowed,
@


1.61
log
@bug converting from usageTime to offset.   Also bug fix: need to disable subBom for all subs with noApp data
@
text
@d3781 4
a3784 2
					     globalSubNetAllowed,
					     groupSharingExecPenaltyThresh,
d3806 4
a3809 2
				 globalSubNetAllowed,
				 groupSharingExecPenaltyThresh,
@


1.60
log
@removed the obsolete pathCounting parameter
@
text
@d12756 1
a12756 1

d12775 1
d12777 13
a12789 1

d12803 2
a12804 2
    witSetBomEntryOffset(theWitRun, fullParentName.c_str(), nBom, offset);
    // witSetBomEntryUsageTime(theWitRun, fullParentName.c_str(), nBom, usageTime);
d12811 1
a12811 1
    witFree(offset);
@


1.59
log
@removed the "binning" stuff which is now obsolete
@
text
@a140 3
    bool pathCounting = setOfParameters.getBool("pathCounting");
    //    witSetPathCounting(theWitRun, pathCounting);

@


1.58
log
@incorrectly mapped fallout to falloutRate when we got rid of witAddxxxVa
@
text
@a397 11
#ifdef BINNING_OPERATION_TEMP_SOLUTION
        // *************************
        // ***  Binning  file  ***
        // *************************
	std::string binFile = setOfParameters.getString("binFile");
	if (! binFile.empty())
	    processBinFile( theWitRun, theCal, 
				binFile, mpHelper);
#endif


d411 2
a412 2
	    processOperationSubBomFile( theWitRun, theCal, 
					opSubBomFile, mpHelper);
a763 23
      

#ifdef BINNING_OPERATION_TEMP_SOLUTION
      // *****************************************************
      // *** Analyze model for parts with multiple bin
      // ***                 operations
      // *****************************************************
      // Multi-sourcing a part from a variety of supplier
      // locations is modeled in SCE as the part being produced 
      // from a variety of "bin" operations. 
      // 
      // The current heuristic doesn't excercise the alternative
      // ways to build a part when multiple operations exist.
      // To slightly mitigate this drawback until the heuristic
      // is improved, this method adds "jumper arcs" (aka substitutes)
      // from the supplier parts at alternative bin locations to
      // the supplier part at the preferred bin location.
      std::cout << "Analyzing SCE model (multiple bin entries) ..." << std::endl;
      if (useMultiRouteImplosion) 
	std::cout << "    .... multi-bin OK (using multi-route implosion) ..." << std::endl;
      else
	scePreProcessMultiBinEntries ( theWitRun, mpHelper );
#endif
d1847 1
a1847 1
    int   isBuildable = 1;   // direct setting on expAllowed
d1883 1
a1883 1
    // isBuildable flag
d1885 1
a1885 1
      result = flatFileManager.nextInt(isBuildable,
d1911 1
a1911 1
				      isBuildable,
d3310 1
a3310 1
    int   isInterplantExplodeableAsSubstitute = 1;
d3361 1
a3361 1
    // isInterplantExplodeableAsSubstitute
d3363 1
a3363 1
      result = flatFileManager.nextInt( isInterplantExplodeableAsSubstitute, next, fileName, dataLine, lineNo, false, 0, 1);
d3382 1
a3382 1
        isInterplantExplodeableAsSubstitute,
a3407 198
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// ----------------------------------------------------------------
void 
LgFrInitialProblemForSce::processBinFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string parentPdf;
 std::string childPdf;
 std::string dataLine;

 LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();   
 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;
 int result2;

 std::ifstream inFile;
 std::ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Bin",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 
 std::cout << "Processing " << fileName << ":\t" << std::flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 long nonUniqueCount = 0;

 while(inFile.peek() != EOF) {

// read the next BOM line
    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
	commentCount++;
	continue;
    }

// check if the line contains any illegal characters
    if ( flatFileManager.containsIllegalCharacters( dataLine )) {
      (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

    SCETokenizer next(dataLine);

// get the mfg Parent PartName 
    mfgParentPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					 lineNo, OPTIONAL_WITH_MESSAGE);

    if (result == -1) {
	badCount++;
	continue;
    }

// get the parent PDF
    parentPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				 lineNo, MANDATORY);


// get the mfg Child PartName 
    mfgChildPartName = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);

// get the child PDF
    childPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
				lineNo, MANDATORY);

// The rest of the fields are optional.  
// Set the defaults, and parse the rest of the line.  
    float transitTime = 0.0;
    int   early = 0;
    int   late = nPeriods-1;
    float minLotSize = 1.0;
    float incLotSize = 1.0;
    float usageRate = 1.0;
    float preference = 0.0; // FINISH_ME: get the fault from the paramMgr...
    int   isObjectInEffectForOptExplosion = 1;
    int   isBinExplodeableAsSubstitute = 0;
    
    // transitTime  (negative usage time)
    if (result >= 0)
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // effectivity Dates
    if (result >= 0)
	result2 = flatFileManager.nextStartEndDates(early, late, next,
                                    fileName, lineNo, dataLine, theCal);
    if (result2 == 1) {
	badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() 
		     << "Effectivity dates" 
		     << fileName 
		     << (int)lineNo 
		     << dataLine 
		     << "Bin entry ignored.");
	badCount++;
	continue;
    }

    // minimum and incremental lot sizes
    // note: ranges and defaults are consitent with those for 
    // manufacturing minLotSize and incLotSize. 
    if (result2 == 0)
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, false, 0.0 );
    
    if ( result == 0 && minLotSize >= 0.0 )
      result = flatFileManager.nextFloat( incLotSize, next, fileName, dataLine,
                           lineNo, false, 1.0);

    // usageRate
    if ( result == 0 )
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // preference
    preference = heurModelHelper_->defaultBinBopPreference();
    // FINISH_ME lp model 
    // if ( lpModelHelper_ != 0 )
    // preference = lpModelHelper_->defaultBinBopCost(); ??
    if ( result == 0 )
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);

    // is ObjectInEffectForOptExplosion
    if ( result == 0 )
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);

    // isBinExplodeableAsSubstitute
    if ( result == 0 )
      result = flatFileManager.nextInt( isBinExplodeableAsSubstitute, next, fileName, dataLine, lineNo, false, 0, 1);

      
    result = addBinBomStructure(
	theWitRun, 
	mpHelper,
	theCal,
	mfgParentPartName, 
	parentPdf,
	mfgChildPartName, 
	childPdf, 
	transitTime, 
	early,
	late,
        minLotSize,
        incLotSize,
        usageRate,
        preference,
        isObjectInEffectForOptExplosion,
        isBinExplodeableAsSubstitute,
	fileName,
	dataLine,
	lineNo);
    
    if (result < 0) // something wrong
      badCount++;
    else if (result == 0) // good 
      {
        recCount ++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
      }
    else  // this was good but may have already existed
      nonUniqueCount++;
 }
 std::cout << recCount << " records processed." << std::endl;
 inFile.close();
 outFile.close();
 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount-nonUniqueCount);
}

#endif







a5193 5
      //      int lastPeriod = nPeriods -1;
      // if the nPeriods = 1, this doesn't work...but one period problems aren't plausible.
      //      if (nPeriods == 1) {
      //	(*theErrFacil)("InternalError5");
      //      }
a5208 1
          witSetBopEntryLatestPeriod(theWitRun, defaultOperationName.c_str(), bopEntryIndex, 0 );
d8680 1
a8680 1
    int isBuildable,
d8786 1
a8786 1
    witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, isBuildable);
d8953 1
a8953 1
// +        BOP:  contains bop preference, isInEffectForExplosionFlag, and isInterplantExplodeableAsSubstitute
d8971 1
a8971 1
                                                    int isInterplantExplodeableAsSubstitute,
d9153 1
a9153 1
					   isInterplantExplodeableAsSubstitute);  
d9162 1
a9162 1
  witSetBopEntryExpAllowed(theWitRun, interPlantOperationName.c_str(), nbBop, isInterplantExplodeableAsSubstitute);
d9182 8
a9189 27
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// ---------------------------------------------------------------
//  return values: -1=ERROR; 0=GOOD/ADDED; 1=GOOD/ALREADY_EXISTED
// ---------------------------------------------------------------
// + About: Bin Structure
// +
// + - Exactly ONE SpecialBin Operation (SBO) per
// +            (markedPart_Pdf,unmarkedPart_Pdf) pair
// +    - Lot size: set as per user on SBO (set over effective periods only)
// +            (can change over time via multiple records)
// + - Exactly ONE BOM entry from SBO to unmarkedPart_Pdf
// +    - early=0,late=nPeriods regardless of true ip effectivity
// +    - bom offset = transitTime (set over effective periods only)
// +            (can change over time via multiple records)
// +    - bom usageRate set as per user input.  Usage rate not allowed
// +            to change over time!
// +            (can change over time via multiple records)
// + - BOP Entries:  Multiple BOPS per (destPart_Pdf,sourcePart_Pdf) pair OK
// +           - One per each valid record
// +           - INVALID if effectivity overlaps with existing BOP
// +           - INVALID if usageRate is different than existing usageRate
// +    - early,late set to effectivity of record
// +
// + - APP DATA:
// +        PART: destinationPart_Pdf: keep count of nBinBops
// +        BOP:  contains bop preference, isInEffectForExplosionFlag,  isInterplantExplodeableAsSubstitute,
// +              isBinExplodeableAsSubstitute
d9191 13
a9203 20
LgFrInitialProblemForSce::addBinBomStructure(
                                                    WitRun * const theWitRun, 
                                                    LgFrMultiPlantHelper & mpHelper,
                                                    const LgFrCalendar & theCal,
                                                    const std::string & markedPart,
                                                    const std::string & markedPdf,
                                                    const std::string & unmarkedPart, 
                                                    const std::string & unmarkedPdf,
                                                    float transitTime,
                                                    int early,
                                                    int late,
                                                    float minLotSize,
                                                    float incLotSize,
                                                    float usageRate,
                                                    float preference,
                                                    int isObjectInEffectForOptExplosionFlag,
                                                    int isBinExplodeableAsSubstitute,
                                                    const std::string & fileName,
                                                    const std::string & dataLine,
                                                    long lineNo)
d9205 3
a9207 222

  witBoolean isUnique = true;
  int t;
  witBoolean exists;
  int nPeriods = theCal.nPeriods();    

  std::string fullmarkedPartName(mpHelper.pdfPartname(markedPart, markedPdf));
  std::string fullunmarkedPartName( mpHelper.pdfPartname(unmarkedPart,  unmarkedPdf));
    
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

  // check to see if markedPartpart is valid
  if (! mpHelper.isPartValid(theWitRun, markedPart, markedPdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;



  // check to see if unmarkedPartPart is valid
  if (! mpHelper.isPartValid(theWitRun, unmarkedPart, unmarkedPdf, fileName, 
                             dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
    return -1;


  std::string binOperationName =
    mpHelper.binOperationName(markedPart, markedPdf, unmarkedPart, unmarkedPdf);
	
  // test to see if the bin operation already exists
  witGetOperationExists(theWitRun, binOperationName.c_str(), &exists);


  // if the bin operation does NOT exist, then add it along with the
  // bom record to the source part, and set some defaults.
  //
  // if the bin operation DOES exists, check to see if this record is a
  // "legal duplicate". To be legal it has to satisfy 2 conditions:
  //   (1) it the same usage rate as the previous records (which is mapped
  //       to the usage rate on the one and only bom for this bin
  //       operation 
  //   (2) the effectivity dates are disjoint from the effectivity
  //       dates on all the other bops for this bin operation
  //   If either (1) or (2) does not hold, reject the record and print an
  //   error message.

  if ( ! exists ) {
    // we initialize the default lot sizes on the dummy bin part.
    // we will update it later.
    float * defaultLotSize = new float[nPeriods];
    for (t=0; t<nPeriods; t++) {
      defaultLotSize[t] = 1.0;
    }

    // add the dummy bin operation and the source part bom entry to WIT
    witAddOperation( theWitRun, binOperationName.c_str() );
    witSetOperationMinLotSize( theWitRun, binOperationName.c_str(), defaultLotSize );
    witSetOperationIncLotSize( theWitRun, binOperationName.c_str(), defaultLotSize );
    witAddBomEntry( theWitRun, binOperationName.c_str(), fullunmarkedPartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, binOperationName.c_str(), 0, usageRate );
    // In our model, there is one and only bom hanging off the bin operation.
    // In our model, the bom is effective through out the entire planning horizon.
    witSetBomEntryEarliestPeriod( theWitRun, binOperationName.c_str(), 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, binOperationName.c_str(), 0, nPeriods-1 );

    // Since this is a new bin Operation for the customer loc, increment
    // the nBinOps counter in the CustLoc Parts appdata.  (Being careful,
    // of course, to ensure the non-null-ness of the appDataPtr for the part
    LgFrScePartAppData * custPartAppData;
    witGetPartAppData(theWitRun, fullmarkedPartName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
      custPartAppData = new LgFrScePartAppData;
      custPartAppData->nBinOps(1);
      witSetPartAppData(theWitRun, fullmarkedPartName.c_str(), (void *) custPartAppData);
    }
    else 
      custPartAppData->nBinOps(custPartAppData->nBinOps() + 1);      

    delete [] defaultLotSize;
  }

  if ( exists ) {
    // set unique flag = false
    isUnique = false;

    if ( ! mpHelper.isDuplicateBinRecordUsageRateValid(
                     theWitRun, fullunmarkedPartName, binOperationName,
                     usageRate)) {
      (*theErrFacil)("ConflictingBinRecordsUR",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << markedPart 
		     << markedPdf 
		     << unmarkedPart 
		     << unmarkedPdf 
		     << dataLine);
      return (-1);
    }
    
    if ( ! mpHelper.isDuplicateBinRecordEffectivityDatesValid(
                      theWitRun, binOperationName, early, late )) {
      (*theErrFacil)("ConflictingBinRecordsED",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << markedPart 
		     << markedPdf 
		     << unmarkedPart 
		     << unmarkedPdf 
		     << dataLine);
      return (-1);
    }
  }


  // do a sanity check ... THERE MUST BE ONE AND ONLY ONE BOM
  int nBom;
  witGetOperationNBomEntries(theWitRun, binOperationName.c_str(), &nBom);
  assert(nBom == 1);

  // if we made it here, we either have a "valid duplicate" bin
  // record or a new one. In either case, we now create a bop entry
  // between destination part and bin operation,
  // with effectivity = (early, late)
  int nbBop;
  witGetOperationNBopEntries( theWitRun, binOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, binOperationName.c_str(), fullmarkedPartName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, binOperationName.c_str(),
                                nbBop, early );      
  witSetBopEntryLatestPeriod( theWitRun, binOperationName.c_str(),
                              nbBop, late );

  // Now set the transitTime using bom offset.  
  // the effectivity range are left as they were.
  float * offset;
  witGetBomEntryOffset(theWitRun, binOperationName.c_str(), 0, &offset);
  for (t=early; t<=late; t++)
      offset[t] = transitTime / theCal.workUnits(t);
  witSetBomEntryOffset(theWitRun, binOperationName.c_str(), 0, offset);
  witFree(offset);
  
  // Set the minLotSize and incLotSize on the  bin operation.
  // Note that the min/incLotSize size is only set in the effective range.
  // The values outside the effectivity range are left as they were.
  float * binMinLotSize;
  float * binIncLotSize;
  witGetOperationMinLotSize( theWitRun, binOperationName.c_str(), &binMinLotSize );
  witGetOperationIncLotSize( theWitRun, binOperationName.c_str(), &binIncLotSize );
  
  for (t=early; t<=late; t++) {
    binMinLotSize[t] = minLotSize ;
    binIncLotSize[t] = incLotSize ;    
  }
  
  witSetOperationMinLotSize(theWitRun, binOperationName.c_str(), binMinLotSize);
  witSetOperationIncLotSize(theWitRun, binOperationName.c_str(), binIncLotSize);
  witFree(binMinLotSize);
  witFree(binIncLotSize);


  // Add an app data for the bop preference and explosion flag
  
  void * bopAppVoidPtr;
  LgFrSceBopAppData * myBopAppDataPtr; 
  witGetBopEntryAppData( theWitRun, binOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
    (*theErrFacil)("InternalError3",MclArgList() 
		   << fileName 
		   << (int)lineNo 
		   << markedPart 
		   << markedPdf 
		   << unmarkedPart 
		   << unmarkedPdf 
		   << dataLine);
  }
  myBopAppDataPtr = new LgFrSceBopAppData (preference, 
					   isObjectInEffectForOptExplosionFlag, 
					   0);  
  // set the flag in the bop app data pointer
  myBopAppDataPtr->isBinExplodeableAsSubstitute(isBinExplodeableAsSubstitute);
  assert ( myBopAppDataPtr != 0 );
  witSetBopEntryAppData( theWitRun, binOperationName.c_str(),
                         nbBop, (void *) myBopAppDataPtr );


  // 2.30 Note:
  //  we don't set expAllowed or expAversion yet.  It will be done in the split bop.
  // FINISH_ME 2.31:  WHY,??  I'm going to set it
  witSetBopEntryExpAllowed(theWitRun, binOperationName.c_str(), nbBop, isBinExplodeableAsSubstitute);
  witSetBopEntryExpAversion(theWitRun, binOperationName.c_str(), nbBop, preference);


  if (isUnique)
    return 0;
  else
    return 1;
}

#endif


// --------------------------------------------------------------------------

// Add part(s) and any structure to wit for BB Category parts (BB/feature set)
// REturn --->  0  if succesful
//             -1  if un-succesful with warning
//             >0  if Severe error
int
LgFrInitialProblemForSce::sceAddBbCategoryPartAndStructureViaProportionalRoute(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const float * gammaMaxVector,
    float gammaMin,
    int early,
    int late,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    int nPeriods;

    witGetNPeriods(theWitRun, &nPeriods);
d10842 1
a10842 1
  // hEngMgr loads the demands on the features and does an additional implosion.
a10852 18
    // SCE 3.10 Quick Development Shortcut

    //    -- set the DemandVols to big M for incHeurAlloc
    LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();
    std::string engine = setOfParameters.getString("calendarFormat");
    
    if (engine == "heuralloc") {
      float * bigMdemandVol;
      witGetDemandDemandVol(theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str(), &bigMdemandVol);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	bigMdemandVol[t] = 98765.431;
      witSetDemandDemandVol(theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str(), bigMdemandVol);
      witFree(bigMdemandVol);
    }
    
    

d11247 1
a11247 1
    // hEngMgr loads the demands on the features and does an additional implosion.
a11257 17


      // SCE 3.10 Quick Development Shortcut

      //    -- set the DemandVols to big M for incHeurAlloc
      LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();
      std::string engine = setOfParameters.getString("calendarFormat");

      if (engine == "heuralloc") {
	float * bigMdemandVol;
	witGetDemandDemandVol(theWitRun, specialFeaturePartName.c_str(), demandName.c_str(), &bigMdemandVol);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  bigMdemandVol[t] = 98765.431;
	witSetDemandDemandVol(theWitRun, specialFeaturePartName.c_str(), demandName.c_str(), bigMdemandVol);
	witFree(bigMdemandVol);
      }
a11499 5
#ifdef BINNING_OPERATION_TEMP_SOLUTION
      int nBinOps = appDataPtr->nBinOps();
      if ( nBinOps < 1)
	continue;
#endif      
d11811 1
a11811 1
      // 2.30: Ok, look at the bopAppData and if the isInterplantExplodeableAsSubstitute flag
d11883 2
a11884 2
	int isInterplantExplodeableAsSubstitute = currentBopAppDataPtr->isInterplantExplodeableAsSubstitute();
	if (isInterplantExplodeableAsSubstitute) {
d11886 1
a11886 1
					isInterplantExplodeableAsSubstitute);
a11916 244
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// preprocess multiple binOp entries

// TRE: note
// A part can be produced by many binOps
// and there can be multiple bops b/t the part
// and any given binOp. But each binOp
// -------- has only bom ---------------------
//
// This routine looks through all the parts in the WIT model
// for those produced from multiple bin operations.
// If multiple bin operations exist, then the
// supplier part at alternative
// bin locations are made substitutes for the 
// supplier part at the preferred bin location.
//
// Note: the 2.0 implementation of this method makes
// some strong assumptions about the input 
// data into SCE:
// - that the transit time for alternative bins is equal
// to the transit time of the preferred bin (not valid for ECA
// but currently offsets on subBomEntries are not available in WIT).
int
LgFrInitialProblemForSce::scePreProcessMultiBinEntries (
 WitRun * const theWitRun,
 LgFrMultiPlantHelper & mpHelper )

{
  char ** partList;
  int nParts;
  int i; // the part index
  int p; // the "bops producing the ith-part" index

  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
  


  witGetParts ( theWitRun, &nParts, &partList );

  // loop throught the parts
  for (i=0; i<nParts; i++) {
    std::string partName (partList[i]);
    
    // get the number of bin operations producing this part
    // if there aren't multiple, then there's nothing to process
    // go on to the next part
    LgFrScePartAppData * appDataPtr;
    witGetPartAppData(theWitRun, partName.c_str(), (void **) &appDataPtr);

    if ( appDataPtr == 0) // if there's no appData, than no bins..
      continue;
    int nBinOps = appDataPtr->nBinOps();
    if ( nBinOps <= 1)
      continue;

    // ok, we have a winner. This part has multiple bin
    // operations that produce it
    int  npBops;  // number of bops producing the i-th part
    witGetPartNProducingBopEntries ( theWitRun, partName.c_str(), & npBops );
    assert ( npBops > 1 ); // can't have multiBin without multiBops!

    LgFrScePartSetOfBops setOfBops(theWitRun, partName);

    // we're going to have to working with the bin operations for
    // this part. so create an vector of them, no duplicates allowed.
    // (FINISH_ME: It's be nice to have a new class, something like
    // "LgFrScePartSetOfBinOps"
    // where each member of the class would know the bin
    // operation name and the fullWitPartName for the source part
    // but this is only needed for the jumperArcs so...maybe not.

    std::string * setOfBinOps = new std::string[nBinOps];
    int binOpIndex=0;
    for (p=0; p<npBops; p++) {
      LgFrSceBop producingBop = setOfBops[p];
      std::string binOpName = producingBop.opName();
      // if the operation isn't an bin op, then we're not
      // interested in it
      std::string dPart;
      std::string dPdf;
      std::string sPart;
      std::string sPdf;
      if (! mpHelper.isOperationSpecialBin(
                       theWitRun, binOpName.c_str(),
                       dPart, dPdf, sPart, sPdf))
        continue;
      // otherwise if it's not in our list, add it
      int isADuplicate = 0;
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nBinOps; k++) {
        if (0 == binOpName.compare(setOfBinOps[k])) {
          isADuplicate = 1;
          break;
        }
      }
      if ( ! isADuplicate ) {
        setOfBinOps[binOpIndex] = binOpName;
        binOpIndex++;
      }
    } // ok, we've got our set of bin ops for this part.
    // there should be multiple bin operations
    assert (binOpIndex > 1);
    assert (binOpIndex == nBinOps);
    
    // loop through the bops in order of increasing preference
    // note: the lower the preference, the more "preferred" it is.
    // looking for bops to binOperations that have byProduct=true.
    for (p=0; p<npBops; p++) {
      LgFrSceBop & currentBop = setOfBops[p];
      std::string currentBinOp = currentBop.opName();
      int currentBinBopIndex = currentBop.bopIndex();
      
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;
      std::string sourcePdf;
        
      if (! mpHelper.isOperationSpecialBin(
                       theWitRun, currentBinOp.c_str(),
                       destPart, destPdf, sourcePart, sourcePdf))
        continue;
      
      witBoolean expAllowed;
      witGetBopEntryExpAllowed( theWitRun, currentBinOp.c_str(),
                               currentBinBopIndex, &expAllowed);

      if ( expAllowed)
        continue;

      // the currentBinOp is a winner!
      // we've found an bin operation with a bop that's "off"
      // (i.e. byProduct = true)
      // Make the source part for this bin operation a sub
      // for the source parts at every other bin location.
      // (actually, you'd only have to make it a sub for the source
      //  that's at the location which is in effect...but
      //  finding that bugger would be more work than we want to do
      //  right now...)

      // 2.30: Ok, look at the bopAppData and if the isBinExplodeableAsSubstitute flag
      // is true, then we will need to make the sub arc explodeable 
      
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nBinOps; k++) {
        // avoid self-substitution
        if (0 == currentBinOp.compare(setOfBinOps[k]))
          continue;

        std::string sourcePdfPartName;
        mpHelper.binSourcePdfPartName( theWitRun, currentBinOp.c_str(),
                                              sourcePdfPartName );
        
        std::string primaryBinOp = setOfBinOps[k];
        int nBomEntries;        
        witGetOperationNBomEntries( theWitRun,
                                    primaryBinOp.c_str(), &nBomEntries );
        // by construction ea bin
        // op has exactly one bom, but just to be safe...
        if ( nBomEntries != 1 ) {
	  (*theErrFacil)("BinOperationBomError");
        }

        int subBomEntryIndex ;
        witGetBomEntryNSubsBomEntries( theWitRun, primaryBinOp.c_str(),
                                       0, &subBomEntryIndex );
        witAddSubsBomEntry( theWitRun, primaryBinOp.c_str(), 0,
                            sourcePdfPartName.c_str() );
        
        // the usageRate from the bin record has since become the usage rate
        // on the BOM b/t the current bin operation and sourcePdfPart. Get this
        // value and set the usageRate of the substitute equal to this value.
        float usageRate;
        witGetBomEntryUsageRate( theWitRun, currentBinOp.c_str(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryBinOp.c_str(), 0,
                                     subBomEntryIndex, usageRate );

	// 2.30:  We must shut all expAllowed off as a default.  We'll turn them back
	//   on later for those that qualify.
        witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.c_str(), 0,
                                     subBomEntryIndex, WitFALSE );


        // the earliest/latest periods from the bin record have since
        // become the earliest/latest period attributes on the current
        // bin bop. Get these
        // values and set the earliest/latest periods of the substitue equal to these
        // values.
        int early = currentBop.early();
        int late = currentBop.late();      
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryBinOp.c_str(),
                                          0, subBomEntryIndex, early );
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryBinOp.c_str(),
                                        0, subBomEntryIndex, late );

        // the SUB BOM offset (transitTime), must be set to the existing BOM offset
        // for the subbed bin arc
        float * offset;
        witGetBomEntryOffset( theWitRun, currentBinOp.c_str(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryBinOp.c_str(), 0,
                                     subBomEntryIndex, offset );
        witFree(offset);
        

        // get the "explodable" flag for the alternative bin bop
        // and use it to set the "explodable" flag for the new sub
        LgFrSceBopAppData * currentBopAppDataPtr;
        witGetBopEntryAppData( theWitRun, currentBinOp.c_str(), currentBinBopIndex,
                                (void **) &currentBopAppDataPtr );
        assert( currentBopAppDataPtr != 0 );
        

	int isBinExplodeableAsSubstitute = currentBopAppDataPtr->isBinExplodeableAsSubstitute();
	if (isBinExplodeableAsSubstitute) {
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.c_str(), 0, subBomEntryIndex, 
					isBinExplodeableAsSubstitute);
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryBinOp.c_str(), 0, subBomEntryIndex, 
					    currentBop.preference());
	}

        // the app data new'd here get's cleaned up in the scenario destructor
        LgFrSceSubBomAppData * subBomAppDataPtr =
          new LgFrSceSubBomAppData( currentBop.preference(),
                                    currentBopAppDataPtr->isObjectInEffectForOptExplosion() );
        assert (subBomAppDataPtr != 0 );
        witSetSubsBomEntryAppData( theWitRun, primaryBinOp.c_str(), 0,
                                   subBomEntryIndex, (void *) subBomAppDataPtr );

      } // end k-loop over nBinOps
      
    }  // end p-loop over npBops

    delete [] setOfBinOps;
    
  } // loop over nParts

  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  
  return 0;
}

#endif
@


1.57
log
@First pass at sce 4.20 function.
@
text
@d9087 2
a9088 1
    witSetBomEntryFallout( theWitRun, pdfOperationName.c_str(), bomEntryIndex, fallout );
d13562 1
a13562 1
    float falloutRate = (float) fallout;
@


1.56
log
@got rid of witAddXXXVa
@
text
@d206 1
a206 1
    // Do we compute criticalList?
@


1.55
log
@4.20 commit: global subs, prioritized explode
@
text
@d1482 1
d9888 21
a9909 7
    // add the BOM structure between the featureSetPart and LT and GT
    witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), LTbbCapacityPartName.c_str(),
		     WitNusageRate,       gammaMin,
		     0);
    witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), GTbbCapacityPartName.c_str(),
		     WitNusageRate,      -gammaMax,
		     0);
d10221 3
a10223 1
	    
d10262 1
a10262 2
      witAddPartVa(theWitRun, optionDummy.data(), WitPRODUCT,
                   0);
d10284 2
d10294 4
a10297 1
    // the feature ratio.  One blip is that the  ratio's are input as
a10299 1

d10326 6
d10417 1
d10432 20
d10468 15
a10482 3
    witAddBomEntryVa(theWitRun, optionDummy.c_str(), myLTpart.c_str(),
		     WitNusageRate, -1.0,
		     0);
d10484 1
a10484 3
    witAddBomEntryVa(theWitRun, optionDummy.c_str(), myGTpart.c_str(),
		     WitNusageRate,  1.0,
		     0);
d10492 2
d10495 1
a10495 1
    
a13020 50
// Pure options (NOT part of a SET)
int
LgFrInitialProblemForSce::sceAddPureOptionAsFixedBomStructure(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
    float usageRate,
    float usageTime,
    int early,
    int late,
    int fallout,
    float featureRatio,
    float maxWithoutRatio,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo)
{
    // first implement as a regular BOM arc


    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));

	
    if (! mpHelper.isPartValid(theWitRun, parent, parentPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;

    if (! mpHelper.isPartValid(theWitRun, child, childPdf, 
			       fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
	return -1;


    usageRate *= featureRatio;

    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
		     WitNusageRate,      usageRate,
		     WitNusageTime,      usageTime,
		     WitNearliestPeriod, early,
		     WitNlatestPeriod,   late,
		     WitNfallout,        fallout,
		     0);


    return 0;

}
d13475 1
d13500 3
a13508 2
	int nPeriods;
	witGetNPeriods(theWitRun, &nPeriods);
d13523 45
d13851 2
a13852 2
  witAddBomEntryVa(theWitRun, demandPart.c_str(), demandUpperBoundPart.c_str(),
                   0);
@


1.54
log
@sce4.10 changes
@
text
@d1027 1
a1027 1
	  witSetSubsBomEntryExpAllowed(theWitRun, opList[o], b, s, expAllowed);
d3871 2
d3919 1
a3919 1
					 lineNo, OPTIONAL_WITH_MESSAGE);
d4001 44
a4044 27
//  add the sub
    result = sceAddSubstitute(
	theWitRun, 
	mpHelper,
	isParentAnOperation,
	relaxedSubbingRulesAllowed,
	mfgParentPartName, 
	pdf, 
	mfgChildPartName, 
	pdf, 
	mfgSubPartName,
	pdf,
	ur,
	early, 
	late,
	fallout,
	defaultSubPenalty,
        isObjectInEffectForOptExplosion,
        isSubstituteBuildable,
	// globalSubNetAllowed,
	isNetAllowed,
	//	groupSharingExecPenaltyThresh,
	execPenalty,
	fileName,
	dataLine,
	lineNo);

d4046 1
a4046 1
          {
d13240 209
a13549 9
#if 0
    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
		     WitNusageRate,      usageRate,
		     WitNusageTime,      usageTime,
		     WitNearliestPeriod, early,
		     WitNlatestPeriod,   late,
		     0);
#endif

d13590 1
a13590 2
  // Add an aggregation operation even if there are other operations!!!!
  // FINISH_ME: create an aggreagation outtput file
@


1.53
log
@preping for release 4.1
@
text
@a887 31
    // *************************************
    // Do a witPreprocess before the echo file
    // *************************************
    std::cout << "Pre-Processing for wit  ..." << std::endl;          
    witPreprocess(theWitRun);

    // *************************************    
    // Dump the heur version of the echo file
    // *************************************
    if (setOfParameters.getBool("printHeurEchoFile"))  {
      std::cout << "Writing the echo file  ..." << std::endl;                
      std::string echoFileName = setOfParameters.getString("heurEchoFileName");
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_ON);
      witDisplayData( theWitRun, echoFileName.c_str());
      if (! setOfParameters.getBool("printWitMsgFile"))   {
        setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_OFF);          
      }

    }
    // *************************************
    // Dump the heur version of the wit.data file
    // *************************************
    if (setOfParameters.getBool("printHeurWitDataFile"))  {
      std::cout << "Writing the (heur) wit data file ..." << std::endl;                      
      std::string witDataFileName = setOfParameters.getString("heurWitDataFileName");
      setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_ON);
      witWriteData(theWitRun, witDataFileName.c_str());
      if (! setOfParameters.getBool("printWitMsgFile"))   {
        setWitInformationalMessaging(theWitRun, SCE_WIT_MESSAGING_OFF);          
      }
    }
d916 1
a916 1
	this->setSubsNetAllowed(false, mpHelper, theWitRun);
d926 2
a927 2
    	this->setSubsNetAllowed(true, mpHelper, theWitRun);
	    mpHelper.setAllWitPartIndices(theWitRun);
d932 38
d3739 1
d3782 4
d3787 1
d3808 2
a3809 1
	globalSubNetAllowed,
d3945 2
d3985 11
d4018 4
a4021 2
	globalSubNetAllowed,
	groupSharingExecPenaltyThresh,
d13018 2
a13019 1
    float groupSharingExecPenaltyThresh,
d13132 1
a13132 1
					      nSubBoms, subCost + groupSharingExecPenaltyThresh);
d13135 7
@


1.52
log
@feature sets logic automatically uses proportional routing when engine is NOT optimization.   for optimization, it uses the OLD BBCat modelling trick.
@
text
@d147 8
d206 5
d320 1
a320 1
	(*theErrFacil)("ExecCostInHeurMode",MclArgList());
d1874 1
d1914 3
d1935 1
d8870 1
d8972 1
a8972 1
  // Added for 2.30
d8975 2
a8976 2
  witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, isBuildable);
  witSetBopEntryExpAversion(theWitRun, pdfOperationName.c_str(), bopEntryIndex, pref);
d8978 9
@


1.51
log
@filename parsing was a bit messed up for Windows backslashes
@
text
@d2134 2
d2143 4
a2220 30
    

#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
    result = sceAddBBtoOptionBomStructureViaProportionalRoute(
	    theWitRun, 
	    mpHelper,
	    plannerTopLevelPart, 
	    geo,
	    bbCategory,
	    mfgOptionPart,
	    usageRate, 
	    featureRatio,
	    fileName,
	    dataLine,
	    lineNo);
#else
    result = sceAddBBtoOptionBomStructure(
	    theWitRun, 
	    mpHelper,
	    plannerTopLevelPart, 
	    geo,
	    bbCategory,
	    mfgOptionPart,
	    usageRate, 
	    featureRatio,
	    fileName,
	    dataLine,
	    lineNo);

#endif
d2222 27
d3096 2
d3177 29
a3205 28
#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
	result = sceAddBbCategoryPartAndStructureViaProportionalRoute(theWitRun, 
							       mpHelper,
							       plannerTopLevelPart,
							       geo,
							       bbCategory,
							       gammaMaxVector,
							       gammaMin,
							       early, 
							       late,
							       fileName,
							       dataLine,
							       lineNo);
#else
	gammaMax = gammaMaxVector[0];
	result = sceAddBbCategoryPartAndStructure(theWitRun, 
						  mpHelper,
						  plannerTopLevelPart,
						  geo,
						  bbCategory,
						  gammaMax,
						  gammaMin,
						  early, 
						  late,
						  fileName,
						  dataLine,
						  lineNo);
#endif
a9588 13












#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
d9692 1
a9692 1
#else
a9822 1
#endif
d9825 1
a9825 10
#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
// BUILDING_BLOCKS_VIA_MULTI_BOPS
// Add the feature to a BB SET and set up the ratio logic
//  -- IN DEVELOPMENT --
//
//   NOTE:  If the mfgOptionPart is "nullOption"  (case-insensitive), then
//          we do not source the part.  (ie, we do not try to find a real
//          pdf,part called nullOption.  Instead we just leave the option dummy
//          with one child.)  In this case, we also do not give any "reward"
//          for the production of a nullOption.
d10042 2
a10043 1
#else
a10363 1
#endif
a12760 3
      std::cout << "in scePreProcess and shouldn't be" << std::endl;


d13276 1
a13276 1
      std::cout << "Setting capacity offset to zero" << std::endl;
d13280 1
a13280 1
      std::cout << "Setting capacity UsageTime to zero" << std::endl;
@


1.50
log
@more memory testing
@
text
@d809 2
a810 1
      if (sce::find(outputFilePrefix, "/") != sce::badIndex) {
d817 1
a817 1
      if (sce::find(parameterFileName, "/") != sce::badIndex) {
d1039 1
a1039 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d4723 1
a4723 1
      if (sce::find(fileName, "/") != sce::badIndex) {
d4826 1
a4826 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d4914 1
a4914 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d5075 1
a5075 1
      if (sce::find(fileName, "/") != sce::badIndex) {
@


1.49
log
@more memory fixes
@
text
@d780 4
a783 1
      scePreProcessMultiBinEntries ( theWitRun, mpHelper );
d793 1
a793 1
    std::cout << "Pre-Processing SCE model ..." << std::endl;
d795 1
d798 1
d11858 8
a11868 4
  // FINISH_ME: 2.31 TEST, TEST, TEST
  if (useMultiRouteImplosion) {
    return 0;
  }
d12355 2
d12615 2
d12774 5
@


1.48
log
@more memory fixes
@
text
@d9682 1
a9682 1
    // BOM structure between topLevelPart and bbCategory
@


1.47
log
@fixed some bad memory management ... was freeing insted of deleting
@
text
@d985 1
a985 1
      //      portableFree(opList[o]);
d1003 1
a1003 1
	portableFree(sub);
d1013 1
a1013 1
  portableFree(yieldRate);
d1016 2
a1017 2
    portableFree(opList[o]);
  portableFree(opList);
d2723 2
a2724 2
    portableFree(partList[i]);
  portableFree(partList);
d4079 1
a4079 1
    portableFree(supplyVol);
d4267 1
a4267 1
    portableFree(supplyVol);
d4363 1
a4363 1
    portableFree(supplyVol);
d4607 1
a4607 1
        portableFree(opName);
d4612 1
a4612 1
      portableFree(opName);
d4649 1
a4649 1
      portableFree(yieldRate);
d4855 1
a4855 1
       portableFree(supplyVol);
d4857 1
a4857 1
    portableFree(partList[i]);
d4860 1
a4860 1
  portableFree(partList);
d4947 1
a4947 1
        portableFree(dList[j]);
d4949 1
a4949 1
      portableFree(dList);
d5009 1
a5009 1
  portableFree(demandVol);
d5018 2
a5019 2
    portableFree(partList[i]);
  portableFree(partList);
d5109 1
a5109 1
        portableFree(dList[j]);
d5111 1
a5111 1
      portableFree(dList);
d5180 3
a5182 3
  portableFree(cshlb);
  portableFree(csslb);
  portableFree(cshub);
d5196 2
a5197 2
    portableFree(partList[i]);
  portableFree(partList);
d5246 1
a5246 1
        portableFree(dList[j]);
d5248 1
a5248 1
      portableFree(dList);
d5253 2
a5254 2
    portableFree(partList[i]);
  portableFree(partList);
d5277 1
a5277 1
    portableFree(opList[o]);
d5279 1
a5279 1
  portableFree(opList);
d5369 1
a5369 1
        portableFree(opName);
d5379 2
a5380 2
    portableFree(partList[i]);
  portableFree(partList);
d5490 1
a5490 1
    portableFree(demandVol);
d5827 1
a5827 1
      portableFree(rev);
d5865 1
a5865 1
    portableFree(priority);
d6292 1
a6292 1
    portableFree(rev);
d6326 1
a6326 1
  portableFree(priority);
d6445 1
a6445 1
    portableFree(demandVol);
d6504 3
a6506 3
    portableFree(cshlb);
    portableFree(csslb);
    portableFree(cshub);
d6720 1
a6720 1
    portableFree(demandVol);
d6782 3
a6784 3
      portableFree(cshlb);
      portableFree(csslb);
      portableFree(cshub);
d6985 3
a6987 3
    portableFree(pvhLB);
    portableFree(pvsLB);
    portableFree(pvhUB);
d7085 3
a7087 3
    portableFree(pvhLB);
    portableFree(pvsLB);
    portableFree(pvhUB);
d7177 3
a7179 3
    portableFree(hardLB);
    portableFree(softLB);
    portableFree(hardUB);
d7276 3
a7278 3
    portableFree(hardLB);
    portableFree(softLB);
    portableFree(hardUB);
d7357 1
a7357 1
    portableFree(ct);
d7435 1
a7435 1
    portableFree(yield);
d7512 1
a7512 1
    portableFree(yield);
d7595 2
a7596 2
    portableFree(minLotSize);
    portableFree(incLotSize);
d7679 2
a7680 2
    portableFree(minLotSize);
    portableFree(incLotSize);
d7828 1
a7828 1
    portableFree(execCost);
d8599 2
a8600 2
    portableFree(demandList[j]);
  portableFree(demandList);
d8875 1
a8875 1
        portableFree(ppName);
d8878 1
a8878 1
      portableFree(ppName);
d8907 1
a8907 1
    portableFree(offsetTimeVec);
d8999 1
a8999 1
    portableFree(offsetTimeVec);
d9263 1
a9263 1
  portableFree(offset);
d9280 2
a9281 2
  portableFree(interPlantMinLotSize);
  portableFree(interPlantIncLotSize);
d9319 1
a9319 1
    portableFree(opExecCost);
d9515 1
a9515 1
  portableFree(offset);
d9532 2
a9533 2
  portableFree(binMinLotSize);
  portableFree(binIncLotSize);
d10024 1
a10024 1
    portableFree(sodYieldRate);
d10049 1
a10049 1
    portableFree(optionOffsets);
d10330 1
a10330 1
        portableFree(mfgTopLevelCycleTime);
d10433 1
a10433 1
        portableFree(child);
d10459 1
a10459 1
    portableFree(child);
d10535 1
a10535 1
        portableFree(child);
d10561 1
a10561 1
    portableFree(child);
d10679 1
a10679 1
    portableFree(supVol);
d10755 1
a10755 1
      portableFree(specialFeaturePartName);
d10765 1
a10765 1
      portableFree(specialFeaturePartName);
d10773 1
a10773 1
      portableFree(specialFeaturePartName);
d10803 1
a10803 1
      portableFree(realFeatureCycleTime);
d10807 2
a10808 2
    portableFree(offset);
    portableFree(specialFeaturePartName);
d11011 1
a11011 1
      portableFree ( child );
d11014 1
a11014 1
    portableFree ( child );    
d11194 2
a11195 2
  portableFree(machineCycleTime);
  portableFree(transitTimeOffset);
d11224 1
a11224 1
      portableFree(bigMdemandVol);
d11352 1
a11352 1
        portableFree ( child );
d11356 1
a11356 1
    portableFree ( child );    
d11617 2
a11618 2
    portableFree(mfgTopLevelCycleTime);
    portableFree(transitTimeOffset);
d11649 1
a11649 1
	portableFree(bigMdemandVol);
d11724 1
a11724 1
	        portableFree(dListSFP[jSFP]);
d11726 1
a11726 1
	    portableFree(dListSFP);
d11737 1
a11737 1
	        portableFree(dListSFP[jSFP]);
d11739 1
a11739 1
	    portableFree(dListSFP);
d11741 1
a11741 1
      portableFree(specialFeaturePartName);
d11744 3
a11746 3
    portableFree(priority);
    portableFree(gpdDlist[0]);
    portableFree(gpdDlist);
d11752 2
a11753 2
    portableFree(partList[i]);
  portableFree( partList );
d11797 1
a11797 1
	portableFree(dList[j]);
d11820 1
a11820 1
	portableFree(supplyVol);
d11822 1
a11822 1
      portableFree(dList[j]);
d11825 1
a11825 1
    portableFree(dList);
d11911 1
a11911 1
      portableFree ( opName );   
d12060 2
a12061 2
    portableFree(partList[i]);
  portableFree(partList);
d12266 1
a12266 1
        portableFree(offset);
d12302 2
a12303 2
    portableFree(partList[i]);
  portableFree(partList);
d12509 1
a12509 1
        portableFree(offset);
d12545 2
a12546 2
    portableFree(partList[i]);
  portableFree(partList);
d12612 1
a12612 1
      portableFree(reqVol);
d12635 2
a12636 2
      portableFree(reqVol);
      portableFree(reqVolParent);
d12662 2
a12663 2
      portableFree(mrpProdVol);
      portableFree(supplyVol);
d12698 2
a12699 2
      portableFree(mrpProdVol);
      portableFree(supplyVol);
d12708 2
a12709 2
    portableFree(partList[i]);
  portableFree( partList );
d12782 2
a12783 2
      portableFree(mrpProdVol);
      portableFree(supplyVol);
d12807 2
a12808 2
      portableFree(reqVol);
      portableFree(reqVolParent);
d12834 2
a12835 2
      portableFree(mrpProdVol);
      portableFree(supplyVol);
d12870 2
a12871 2
      portableFree(mrpProdVol);
      portableFree(supplyVol);
d12880 2
a12881 2
    portableFree(partList[i]);
  portableFree( partList );
d13120 1
a13120 1
	      portableFree(offset);
d13125 1
a13125 1
	portableFree(child);
d13209 1
a13209 1
	portableFree(cycleTime);
d13431 1
a13431 1
        portableFree(child);
d13461 1
a13461 1
          portableFree(child);
d13468 1
a13468 1
      portableFree(child);
d13486 1
a13486 1
  portableFree(bomOffset);
d13497 1
a13497 1
  portableFree(bopOffset);
d13565 4
a13568 4
	   portableFree(dList[j]);
	   portableFree(priority);
	   portableFree(shipVol);
	   portableFree(demandVol);
d13570 1
a13570 1
       portableFree(dList);
@


1.46
log
@fixed issue with scrubber when no dmeandVol file
@
text
@d1186 1
a1186 1

d1188 1
a1188 1
    portableFree(buildAheadUB);
d3209 1
a3209 1
    portableFree(gammaMaxVector);
d8212 1
d11826 1
a11826 1
    portableFree(partList[i]);
d11829 1
a11829 1
  portableFree(partList);
@


1.45
log
@made demandVol file optional (fixed scrubber)
@
text
@d478 1
d551 1
a551 1
    
d566 1
d581 1
d587 1
a587 1
        if (! optionRevFile.empty())
d596 1
a596 1
        if (! featRevFile.empty())
d598 3
a600 3
				   featRevFile, mpHelper,
                                   defaultOptionShipReward, 
				   periodicInterestRate);    
d828 1
d833 1
@


1.44
log
@made demandVol file optional
@
text
@d826 3
a828 2
      scrubDemandVolumeFile(theWitRun, theCal, nPeriods, 
			    demandVolFile, mpHelper);    
@


1.43
log
@Modified to reduce microsoft compiler warning messages
@
text
@d474 3
a476 2
    processDemandVolumeFile( theWitRun, nPeriods, 
				demandVolFile, mpHelper);    
@


1.42
log
@added vac calculation
@
text
@d1 1
a1 1

@


1.41
log
@changed zero ratio selectiveSet to use zero Yield rate instead of zero prodRate
@
text
@d187 2
a188 6
      if (engine == "optimization") {
	std::cout << "Pegging is not available in  Optimization Mode" << std::endl;
      }
      else {
	// for all other engine choices, we allow use heuristic sequence for PIPing
	//	witSetPip(theWitRun, WitTRUE);    
d854 2
a5248 2


@


1.40
log
@set product rate to 0 when selSetRatio is zero
@
text
@d10007 4
a10010 2
    LgFrTimeVecFloat productRate(nPeriods, 1.0);
    // adjust for periods with zero ratio: Make prodRate=0 and routingShare=1
d10013 1
a10013 1
	productRate[t] = 0.0;
d10019 2
a10020 2
    witSetBopEntryProductRate(theWitRun, optionDummy.c_str(), nBopSOD, productRate.data());

@


1.39
log
@removed complaints about 1 period LP models
@
text
@d10007 8
a10014 1

d10017 1
@


1.38
log
@trying to keep numerical stability with  pipPriority
@
text
@d5344 1
a5344 1
      int lastPeriod = nPeriods -1;
d5346 3
a5348 3
      if (nPeriods == 1) {
	(*theErrFacil)("InternalError5");
      }
d5363 1
a5363 1
          witSetBopEntryEarliestPeriod(theWitRun, defaultOperationName.c_str(), bopEntryIndex, lastPeriod ); 
@


1.37
log
@tweaking to get pipPriority settings to work
@
text
@d5529 1
a5529 1
 LgFrTimeVecFloat tvDefaultPriority(nPeriods, (float) (1000000000 -defaultIndependentDemandPriority));
d5620 1
a5620 1
    //      << fullWitPart << "," << demandName << "] =" << tvDefaultPriority[0]<< std::endl;
d5958 1
a5958 1
    //    std::cout << ".....  Read new pipPriorty[" << demandName << "]=";
a5959 1
      //      std::cout << floatVec[t] << ",";
d5961 1
@


1.36
log
@pip for LP engine
@
text
@a536 9
    // *************************************
    // *** PIP PriorityFiles            ****
    // *************************************
    std::string pipPriorityFile = setOfParameters.getString("pipPriorityFile");
    if (doPegging && (! pipPriorityFile.empty())) {
      processPipPriorityFile( theWitRun, nPeriods, 
			      pipPriorityFile, mpHelper);
    }

d639 15
d5522 1
d5529 2
a5530 6
 int   * defaultPriorityVec = new int[nPeriods];
 int t = 0; // Pulled out of the for below by RW2STL
 for (t=0; t<nPeriods; t++) {
   defaultPriorityVec[t] = INT_MAX - defaultIndependentDemandPriority;
 }
 // get the default shipLateLimit
d5618 3
d5627 1
a5627 1
			  demandName.c_str(), defaultPriorityVec );
d5726 1
a5726 1
 delete [] defaultPriorityVec;
d5794 1
a5794 1
	INT_MAX,        // data upper limits
d5839 2
a5840 1
      priority[t] = INT_MAX - (int) floatVec[t];
d5844 18
d5932 1
a5932 1
	INT_MAX,        // data upper limits
a5955 13
    // If the demandAppDataPtr has been set, see if the pipPriority has been set.
    // If it hasn't (i.e. the backlogYield is 0), then set it. Otherwise, do nothing.
    if (demandAppDataPtr == 0)  {
      demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);  // init backlogYield to 1.0
      

      
      witSetDemandAppData(theWitRun,
                          pdf_PartName.c_str(), 
                          demandName.c_str(), 
                          (void *) demandAppDataPtr );
    }
    
d5958 1
a5958 1
    std::cout << ".....  Read new pipPriorty[" << demandName << "]=";
d5960 2
a5961 2
      std::cout << floatVec[t] << ",";
      pipPriority[t] = INT_MAX - floatVec[t];
d5963 1
a5963 1
    std::cout << std::endl;
d5982 151
d6302 2
a6303 1
    priority[t] = INT_MAX - (int) floatVec[t];
a6306 1
  portableFree(priority);
d6308 14
d6323 1
d8470 1
a8470 1
        defaultPriorityVec[t] = INT_MAX - (int) defaultPriority;
@


1.35
log
@fixed demandDrives so it respects selectiveFeatures
remove usage of witSetPip
@
text
@d187 1
a187 1
      if (engine == "optization") {
d465 5
a469 3
    if (! geoSourceFile.empty())
	processGeoSourceFile( theWitRun, geoSourceFile, 
				theCal, mpHelper);    
d519 2
a520 2


d529 2
a530 2


d536 10
a549 3


    
d840 2
a841 1
    deleteUnnecessaryDemandAppData(theWitRun, nPeriods, mpHelper);    
d5419 1
a5419 1
 
d5533 2
a5534 8
 this->openInputFileAndScrubOutputFile(fileName,
				       "Independent Demand Volume",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);


d5788 2
a5789 2
	    INT_MAX,        // data upper limits
	    false);         // Add demand stream to WIT if not there
d5856 117
d6223 1
a6223 1
	false);         // Add demand stream to WIT if not there
d6674 1
a6674 1
	false);         // Add demand stream to WIT if not there
d7881 5
a7885 5
    WitRun * const theWitRun,
    const std::string & geoSourceFile,
    const LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper,
    bool createMfgPart)
d7895 1
a7895 1
    long lineNo = 0;
d7897 3
a7899 3
    LgFrSceSetOfParameters & setOfParameters = this->sceScenario()->setOfParameters();   
    // get the engine
    std::string engine = setOfParameters.getString("engine");
d7901 1
a7901 1
    std::string fileName(geoSourceFile);
d7903 3
a7905 3
    std::ifstream inFile;
    std::ofstream outFile;
    LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
d7907 9
a7915 9
    inFile.open(fileName.c_str());
    if (! inFile)  {
      (*theErrFacil)("WarningCannotOpenFile",MclArgList() 
		     << "geoSourceFile" 
		     << fileName 
		     << "Will attempt to source parts to the default PDF.");
      return;
    }
    inFile.close();
d7917 6
a7922 6
    this->openInputFileAndScrubOutputFile(fileName,
					  "geo source file",
					  inFile,
					  outFile,
					  myScrubber,
					  theErrFacil);
d7924 5
a7928 5
    std::cout << "Processing " << fileName << ":\t" << std::flush;
    long recCount = 0;
    long badCount = 0;
    long commentCount = 0;    
    long numAddedParts = 0; // this is to count parts added to wit run
d7931 8
a7938 8
    std::string dataLine;
    std::string plannerPartName;
    std::string geo;
    std::string partName;
    std::string pdf;
    int early = 0;
    int late = nPeriods - 1;
    float transitTime = 0.0;
d7942 1
a7942 1
    while(inFile.peek() != EOF) {
d7944 1
a7944 1
	int result = 0;
d7946 3
a7948 3
	// Read next line of file
	std::getline( inFile, dataLine );
	lineNo ++;
d7950 5
a7954 5
        //  skip blanks or comments '*'
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
	    commentCount++;
	    continue;
	}
d7956 7
a7962 7
        // check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
        }
d7964 2
a7965 2
	// construct a tokenizer
	SCETokenizer next(dataLine);
d7967 7
a7973 7
	// get the plannerPartName
	plannerPartName = flatFileManager.nextQuotedString(
	    next, result, fileName, dataLine, lineNo, PURELY_OPTIONAL);
	if (result < 0) {
	    badCount++;
	    continue;
	}
d7975 4
a7978 3
	// get the geo
	geo = flatFileManager.nextQuotedString(
	    next, result, fileName, dataLine, lineNo, MANDATORY);
d7980 3
d7984 3
a7986 3
	// get the partName
	partName = flatFileManager.nextQuotedString(
	    next, result, fileName, dataLine, lineNo, MANDATORY);
a7987 3
	// get the pdf
	pdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			       lineNo, MANDATORY);
d7989 44
a8033 49
	// now get the effectivity dates
	result = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
	if ((early == nPeriods) || (late < 0)) {
	  (*theErrFacil)("OutOfRange",MclArgList() 
			 << "Effectivity dates" 
			 << fileName 
			 << (int)lineNo 
			 << dataLine 
			 << "entry ignored.");
	    badCount++;
	    continue;
	}

	flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);
	// scale the  usage time
	transitTime = transitTime / theCal.workUnits(early);

	// make valid wit part numbers for these dudes
	std::string geoPlannerDemandPartName = 
	    mpHelper.geoPlannerDemandPartName(plannerPartName, geo);
	std::string pdfPartname = mpHelper.pdfPartname(partName, pdf);

	// first check to see if the child exists  
        // Note this routine need s to be finished and extended to
        // allow for DEFAULT  sourcing rules
	if (! mpHelper.isPartValid(theWitRun, 
				   pdfPartname, 
				   fileName, 
				   dataLine, lineNo, PURELY_OPTIONAL))  {


	    // if createMfgPart is true, then we want to create the child
            // part when it doesn't exist.  This thread is only used when
            // using the utility MakeDemandFileForEPPS().
	    if (createMfgPart)  {
	      bool buildNstn = this->sceScenario()->setOfParameters().getBool("useLocalBuildAhead");
	      int  buildAheadLimit = this->sceScenario()->setOfParameters().getInt("buildAheadLimit");
	      int * buildAheadUB = new int[nPeriods];
	      int t;
	      for (t=0; t<nPeriods; t++) 
		buildAheadUB[t] = buildAheadLimit;



	      
	      sceAddNormalPart(theWitRun, partName, pdf, buildNstn, buildAheadUB, mpHelper, fileName,
			       dataLine, lineNo);
	      numAddedParts++;
	    }
d8035 9
a8043 10

	    else {
	      (*theErrFacil)("UnknownMfgPartPDFPair",MclArgList() 
			     << fileName 
			     << (int)lineNo 
			     << dataLine);
		badCount++;
                continue;
	    }
	}
d8046 16
a8061 27
	// Now analyze the Demand,GEO.  
	// If a "part" already exists then ok,
	// otherwise, create a part and add it to the WIT Run.

	int geoPlannerPartAlreadyExist =  
	    mpHelper.isPartValid(theWitRun, 
				 geoPlannerDemandPartName, 
				 fileName, 
				 dataLine, 
				 lineNo, 
				 PURELY_OPTIONAL);

	if (! geoPlannerPartAlreadyExist)  {
          result = sceAddPartToRepresentDemand(
                                               theWitRun, 
                                               geoPlannerDemandPartName, 
                                               mpHelper, 
                                               fileName, 
                                               dataLine,
                                               lineNo);

	  numAddedParts++;

          if (engine == "optimization") {
            // Only need to do this when using optimization          
            std::string geoPlannerDemandUbPartName =
              mpHelper.geoPlannerDemandUbPartName(plannerPartName, geo);
d8063 2
a8064 7
            result = sceAddPartToRepresentDemandUpperBound(
                                                           theWitRun, 
                                                           geoPlannerDemandUbPartName, 
                                                           mpHelper, 
                                                           fileName, 
                                                           dataLine,
                                                           lineNo);
d8066 5
a8070 32
            result = sceAddDemandUbBomStructure(theWitRun,
                                                mpHelper,
                                                geoPlannerDemandPartName,
                                                geoPlannerDemandUbPartName,
                                                fileName,
                                                dataLine,
                                                lineNo);
          }

	}
						   
// Now add a bill record from the the dummy demand part 
// to the real part
// taking into account the effectivity
	sceAddDemandBomStructure(
	    theWitRun,
	    mpHelper,
	    geoPlannerDemandPartName,
	    pdfPartname,
	    early,
	    late,
	    transitTime,
	    fileName,
	    dataLine,
	    lineNo);

        recCount++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
          
d8072 13
d8086 3
d8090 1
a8090 5
    inFile.close();
     outFile.close();
    std::cout << recCount << " records processed." << std::endl;

    flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,numAddedParts);
d8268 13
a8280 74
  if (! mpHelper.isPartValid( theWitRun, geoPlannerDemandPartName, fileName, 
                              dataLine, lineNo, PURELY_OPTIONAL))  {
    std::string pdfPartname = mpHelper.pdfPartname(plannerPartName, 
                                                 mpHelper.defaultPdf());
    int doesThePdfPartExist = 
      mpHelper.isPartValid(theWitRun, pdfPartname, fileName,
                           dataLine, lineNo, PURELY_OPTIONAL);

    if (addDemandIfFound) {
      // Before you choke, check to see if we can map it to the 
      // default PDF

      // if there is a real part to source it to, then lets 
      // create the geoPlannerPart now.
      if (doesThePdfPartExist)  {
        sceAddPartToRepresentDemand(
                                    theWitRun, 
                                    geoPlannerDemandPartName, 
                                    mpHelper, 
                                    fileName, 
                                    dataLine,
                                    lineNo);

        // Now add a bill record from the the dummy demand 
        // part to the real part taking into account the 
        // effectivity
        sceAddDemandBomStructure(
                                 theWitRun,
                                 mpHelper,
                                 geoPlannerDemandPartName,
                                 pdfPartname,
                                 0,
                                 nPeriods-1,
                                 0,
                                 fileName,
                                 dataLine,
                                 lineNo);

      }
      else {
	(*theErrFacil)("MissingSourceAndPart",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << plannerPartName 
		       << geo 
		       << dataLine);
	return 0;
      }

    }


    // If you are not in "add" mode, 
    // then the geoPartName MUST be there already
    else {
      (*theErrFacil)("CannotSourceDemandRecord",MclArgList() 
		     << fileName 
		     << (int)lineNo 
		     << plannerPartName 
		     << geo 
		     << geoPlannerDemandPartName  
		     << dataLine);

      if (doesThePdfPartExist) 
	// OK, this is a natural condition for priority or revenue files
	//	(*theErrFacil)("InternalError1",MclArgList() 
	//		       << fileName 
	//		       << (int)lineNo 
	//		       << plannerPartName 
	//		       << geoPlannerDemandPartName 
	//		       << pdfPartname 
	//		       << dataLine);
      return 0;
    }
d8283 1
a8283 1
    
d8285 1
a8285 1
  if (! doesDemandExist(theWitRun, geoPlannerDemandPartName, geo)) {
d8297 1
a8297 2
      // create a demand app data for this demand.  Set the hasDemandVolBeenSet=0
      // init backlogYield to 1.0
a13282 1

a13307 1

@


1.34
log
@mand/opt capacity, new selective sets
@
text
@d186 11
a196 2
    if (doPegging)
      witSetPip(theWitRun, WitTRUE);    
@


1.33
log
@First cut at Selective Features using proportional routing
@
text
@d138 1
a138 1
    witSetStockRealloc(theWitRun, useStockReallocation);
d153 1
d155 2
a156 1
    witSetLocalBuildAhead( theWitRun, useLocalBuildAhead );
d1062 9
d1127 8
a1134 6
                                 mfgPartName, 
                                 pdf, 
                                 mpHelper, 
                                 fileName, 
                                 dataLine,
                                 lineNo);
d1158 1
d1233 6
d1246 1
d1481 1
a1481 1
				       "BOM",
d1486 3
d1574 2
d3055 2
d3115 9
a3123 2
	// gamma Max (upper bound)
	result = flatFileManager.nextFloat(gammaMax, next, fileName, dataLine, lineNo, false, 1.0);
d3125 10
d3142 1
a3142 1
							       gammaMax,
d3150 1
d3178 2
a3179 1
    
d7894 13
a7906 3
		sceAddNormalPart(theWitRun, partName, pdf, mpHelper, fileName,
				dataLine, lineNo);
		numAddedParts++;
d8406 2
d8475 7
d8496 1
d8513 14
a8527 2
    witAddPart(theWitRun, capacityName.c_str(), WitCAPACITY);
    
d9389 1
a9389 1
    float gammaMax,
d9472 1
a9472 2
    witSetBomEntryUsageRate(theWitRun, geoPlannerDemandPart.c_str(), nBomGPD, gammaMax);
    // NOW_FINISH_ME: convert gammaMax usageRate into a consRate vector
d13015 2
d13034 1
d13041 1
d13043 16
@


1.32
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@d2155 2
a2156 2
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
    result = sceAddBBtoOptionBomStructureViaMultiRoute(
d3091 2
a3092 2
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
	result = sceAddBbCategoryPartAndStructureViaMultiRoute(theWitRun, 
d9296 1
a9296 1
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
d9304 1
a9304 1
LgFrInitialProblemForSce::sceAddBbCategoryPartAndStructureViaMultiRoute(
d9376 4
a9379 3
    // FINISH_ME: should this be a capacity part??
    witAddPartWithOperation( theWitRun, fullBbCategoryPart.c_str());
    witSetBopEntryExpAversion(theWitRun, fullBbCategoryPart.c_str(), 0, -999999.0);
d9389 3
a9391 2
    // Now add the BOM structure between topLevelPart and bbCategory

d9393 3
a9395 1

d9535 2
a9536 1
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
d9546 1
a9546 1
LgFrInitialProblemForSce::sceAddBBtoOptionBomStructureViaMultiRoute(
d9613 1
a9613 1
    // get a unique name for the SOD (Special Option Dummy) operation and part
a9616 4
    // get a unique name for the ORS (Option Ratio Supply) part
    std::string optionRatioSupply = 
	mpHelper.optionRatioSupplyPartName(plannerTopLevelPart, geo,
					   bbCategory, mfgOptionPart);
a9631 13
    // FINISH ME:  expAversion is a scalar and since revenues can change
    // over time, we need to have multiple bops for each time the 
    // the option revenue  changes.

    // if the option dummy does not exist, then we must create the initial
    // structures in WIT.  Otherwise, we can skip over and just reset some 
    // ratios.

    // since the option dummy and the option ratio supply are created as
    // a pair, assert that the optionRatioSupply dummy doesn't already exist
    assert(! mpHelper.isPartValid(theWitRun, optionRatioSupply, fileName, 
				  dataLine, lineNo, PURELY_OPTIONAL));

d9635 2
a9636 4
    // Deal with Multi-Sourcing
    // determine the PDF and then the mfgOptionPart that the feature 
    // sources to.
    // FINISH_ME: Need to loop over each source ... for now let's assume it's single source!!
d9690 1
a9690 1
    // create the SOD (Special Option Dummy) part and operation
d9692 1
a9692 4
    // If its a nullOption
    // then we let the default prodCost of zero happen.  Otherwise
    // get the default prodReward for shipping this option
    witAddPartWithOperation(theWitRun, optionDummy.c_str());
d9711 1
a9711 1
    // add BOM: BBCat --> SOD
d9713 3
a9715 7
    // UsageRate = featureRatio  ... soon to be vectorized!
    int nBomBBCat;
    witGetOperationNBomEntries(theWitRun, fullBbCategoryPart.c_str(), &nBomBBCat);
    witAddBomEntry(theWitRun, fullBbCategoryPart.c_str(), optionDummy.c_str());      
    // FINISH_ME: use vector Usage Rates when they are available
    witSetBomEntryUsageRate(theWitRun, fullBbCategoryPart.c_str(), nBomBBCat, featureRatio[0]);
    
d9717 2
a9719 11
    // ------------------------------------------
    // create the ORS (Option Ratio Supply)  Part
    // ------------------------------------------
    //      1) (LP only) set up a stock cost using the default
    //      2) set the supplyVec to be the feature ratio over
    //         the effective periods.  NOTE: later on we'll do 
    //         an mrp to explode the demand and populate the final
    //         supplyVols
    //       3) FINISH_ME: do we need the ORS if it's a null option?
    
    witAddPart( theWitRun, optionRatioSupply.c_str(), WitMATERIAL );
d9721 1
a9721 2
    if ( lpModelHelper_ != 0 )   {
        float optionRatioSupplyStockPenalty = setOfParameters.getFloat("optionRatioSupplyStockPenalty");
a9722 8
        float * optionRatioSupplyStockPenaltyVec = new float[nPeriods];
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)  
	        optionRatioSupplyStockPenaltyVec[t] = optionRatioSupplyStockPenalty;
        witSetPartObj1StockCost( theWitRun, optionRatioSupply.c_str(),
                               optionRatioSupplyStockPenaltyVec );
        delete [] optionRatioSupplyStockPenaltyVec;
    }
d9734 1
a9734 12
    // --------------------
    // add Bom: SOD -> ORS
    // --------------------
    witAddBomEntry(theWitRun, optionDummy.c_str(), optionRatioSupply.c_str());

    // NOTES: 
    //  - add one bom for each Geo->Pdf source
    //  - NOT done for nullOption.
    //  - offset = optionOffsets
    //  - usageRate = usageRate on bbRatio input record
    // FINISH_ME: deal with multi-sourcing at the GEOSource.  
    //            for now, we assume that there's only one source.
a9735 8
    int nBomSOD;
    if (! nullOption) {
      witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBomSOD);
      witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
      witSetBomEntryUsageRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRate);
      witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffsets);
      witSetBomEntryMandEC(theWitRun, optionDummy.c_str(), nBomSOD, WitTRUE);
    }
d9741 2
a9743 2
    nBomSOD++;

d9745 1
a9745 4
    witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffsets);
    // FINISH_ME: for now we assume single source ...
    // witSetBomEntryEarliestPeriod(theWitRun, optionDummy.c_str(), nBomSOD, sourceBeginPeriod);
    // witSetBomEntryLatestPeriod(theWitRun, optionDummy.c_str(), nBomSOD, sourceEndPeriod);
@


1.31
log
@first level of PIP
@
text
@a182 1
#ifdef PEGGING_ENABLED
a184 5
      witSetPerfPegging(theWitRun, WitTRUE);    


    bool doPIP = setOfParameters.getBool("doPIP");
    if (doPIP)     
a185 2

#endif
@


1.30
log
@make InternalError1 an ok condition when reading prioirty file
@
text
@d187 6
@


1.29
log
@backout the negative demandVols that are applied to supplyVol when scrubbing.
And size_t initialize to large number.
@
text
@d8183 8
a8190 7
	(*theErrFacil)("InternalError1",MclArgList() 
		       << fileName 
		       << (int)lineNo 
		       << plannerPartName 
		       << geoPlannerDemandPartName 
		       << pdfPartname 
		       << dataLine);
@


1.28
log
@Needed to add
int
to several method calls (for the gcc compiler)
@
text
@d4766 8
d4786 3
a4788 1
  
@


1.27
log
@minor updates for SCE
@
text
@d8523 1
d8654 1
@


1.26
log
@optWithLotSizes allows MIP and fix of machineFeatureOffsets to enable for CustomerChoice
@
text
@d694 3
a696 2
    processPartsConditionFile( theWitRun, theCal, nPeriods, 
			      partsConditionFile, mpHelper);    
d792 6
a797 3
      // Print out a scrubbed pcf file
      scrubPartsConditionFile(theWitRun, theCal, nPeriods, 
			      partsConditionFile, mpHelper);    
d5515 4
d6286 1
a6286 1
      if (floatVec[t] < 0.00001)  {
@


1.25
log
@scrubber fix for interplant files
@
text
@d197 4
a200 1

d2752 7
d2803 2
d10487 16
d10508 1
@


1.24
log
@parameter and logic to set Exec Penalties on subBoms so that Group Sharing Logic will sub before share
@
text
@d3294 2
a3295 2
    else if (result == 0) // good 
      {
d3297 5
a3301 4
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << std::endl;
          }
d3303 1
a3303 2
    else  // this was good but may have already existed
      nonUniqueCount++;
d3305 1
@


1.23
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d145 1
d3671 1
a3671 1
    isObjectInEffectForOptExplosion,
d3674 1
d3733 1
a3733 1

d3870 1
d11278 1
a11278 1
    LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
d12672 1
d12784 2
a12785 1
		witSetSubsBomEntryExecPenalty(theWitRun, fullParentName.c_str(), j, nSubBoms, subCost);
@


1.22
log
@latest SCE updates for group sharing
@
text
@d1 6
a10 3
#include <rw/ctoken.h>
#include <rw/locale.h>
#include <rw/regexp.h>
d67 1
a67 1
    RWCString fileFormatTypeS = setOfParameters.getString("fileFormatType");
d73 1
a73 1
    RWCString defaultPdf = setOfParameters.getString("defaultPdf");
d77 1
a77 1
    RWCString pdfSeparator = setOfParameters.getString("pdfSeparator");
d88 1
a88 1
    // Testing if (lpModelHelper != NULL) is equivalent
d104 1
a104 1
    LgFrSceDemandDriver * myDemandDriver = NULL;
d108 1
a108 1
    RWCString engine = setOfParameters.getString("engine");
d115 2
a116 2
    RWCString scenarioFile = setOfParameters.getString("outputFilePrefix");
    RWCString witMsgFileExtension = setOfParameters.getString("witMsgFileExtension");    
d118 1
a118 1
    RWCString witMesgFileName(scenarioFile + witMsgFileExtension);
d120 1
a120 1
    witSetMesgFileName( theWitRun, WitTRUE, witMesgFileName);
d133 1
a133 1
    RWBoolean useMultiRouteImplosion = setOfParameters.getBool("useMultiRouteImplosion");
d137 1
a137 1
    RWBoolean useStockReallocation = setOfParameters.getBool("useStockReallocation");
d141 1
a141 1
    RWBoolean pathCounting = setOfParameters.getBool("pathCounting");
d152 1
a152 1
    RWBoolean useLocalBuildAhead = setOfParameters.getBool("useLocalBuildAhead");
d161 1
a161 1
    if ( lpModelHelper_ != NULL )
d174 1
a174 1
    RWBoolean heurForceEquit = setOfParameters.getBool("heurForceEquit");
d177 1
a177 1
    RWBoolean heurSkipFailures = setOfParameters.getBool("heurSkipFailures");
d180 1
a180 1
    RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d183 1
a183 1
    RWBoolean doPegging = setOfParameters.getBool("doPegging");
d207 1
a207 1
    RWCString partDefFile = setOfParameters.getString("partFile");
d218 2
a219 2
    RWCString capacityDefFile = setOfParameters.getString("capFile");
    if (! capacityDefFile.isNull())
d230 2
a231 2
    RWCString cycleTimeFile = setOfParameters.getString("cycleTimeFile");    
    if (! cycleTimeFile.isNull())
d238 2
a239 2
    RWCString yieldFile = setOfParameters.getString("yieldFile");    
    if (! yieldFile.isNull())
d247 2
a248 2
    RWCString lotSizeFile = setOfParameters.getString("lotSizeFile");    
    if (! lotSizeFile.isNull()) 
d256 2
a257 2
    RWCString prodVolLBFile = setOfParameters.getString("prodVolLBFile");    
    if (! prodVolLBFile.isNull()) 
d266 2
a267 2
    RWCString prodVolUBFile = setOfParameters.getString("prodVolUBFile");    
    if (! prodVolUBFile.isNull()) 
d275 2
a276 2
    RWCString operationDefFile = setOfParameters.getString("opFile");
    if (! operationDefFile.isNull())    
d286 2
a287 2
    RWCString operationExecPenaltyFile = setOfParameters.getString("opExecPenaltyFile");
    if (! operationExecPenaltyFile.isNull())    
d295 2
a296 2
    RWCString operationExecCostFile = setOfParameters.getString("opExecCostFile");
    if (! operationExecCostFile.isNull()) {
d309 2
a310 2
    RWCString operationLotSizeFile = setOfParameters.getString("opLotSizeFile");
    if (! operationLotSizeFile.isNull())    
d317 2
a318 2
    RWCString operationYieldFile = setOfParameters.getString("opYieldFile");
    if (! operationYieldFile.isNull())    
d326 2
a327 2
    RWCString operationLBFile = setOfParameters.getString("opLowerFile");
    if (! operationLBFile.isNull())    
d335 2
a336 2
    RWCString operationUBFile = setOfParameters.getString("opUpperFile");
    if (! operationUBFile.isNull())    
d344 2
a345 2
     RWCString operationBomFile = setOfParameters.getString("opBomFile");
     if (! operationBomFile.isNull())    
d353 2
a354 2
     RWCString operationBopFile = setOfParameters.getString("opBopFile");
     if (! operationBopFile.isNull())    
d363 1
a363 1
    RWCString bomFile = setOfParameters.getString("bomFile");
d370 2
a371 2
	RWCString interPlantFile = setOfParameters.getString("interPlantFile");
	if (! interPlantFile.isNull())
d380 2
a381 2
	RWCString binFile = setOfParameters.getString("binFile");
	if (! binFile.isNull())
d390 2
a391 2
    RWCString bocFile = setOfParameters.getString("bocFile");
    if (! bocFile.isNull())
d398 2
a399 2
    RWCString opSubBomFile = setOfParameters.getString("opSubBomFile");
    if (! opSubBomFile.isNull())  {
d408 2
a409 2
    RWCString subBomFile = setOfParameters.getString("subBomFile");
    if (! subBomFile.isNull())  {
d418 2
a419 2
    RWCString aggregationFile = setOfParameters.getString("aggregationFile");
    if (! aggregationFile.isNull())  {
d430 2
a431 2
    RWCString independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (! independentDemandFile.isNull())
d451 2
a452 2
    RWCString geoSourceFile = setOfParameters.getString("geoSourceFile");
    if (! geoSourceFile.isNull())
d462 1
a462 1
    RWCString demandVolFile = setOfParameters.getString("demandVolFile");
d469 2
a470 2
    RWCString topLevelToBBdefFile = setOfParameters.getString("topLevelToBBdefFile");
    if (! topLevelToBBdefFile.isNull())
d474 1
a474 1
    RWCString topLevelToBBratioFile = setOfParameters.getString("topLevelToBBratioFile");
d476 1
a476 1
    if (! topLevelToBBratioFile.isNull())
d488 2
a489 2
    RWCString topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.isNull()) {
d499 2
a500 2
    RWCString machineFeatureOffsetFile = setOfParameters.getString("machineFeatureOffsetFile");
    if (! machineFeatureOffsetFile.isNull()) {
d509 2
a510 2
    RWCString machineFeatureSupplyFile = setOfParameters.getString("machineFeatureSupplyFile");
    if (! machineFeatureSupplyFile.isNull()) {
d542 2
a543 2
      RWCString priorityFile = setOfParameters.getString("priorityFile");
      if (! priorityFile.isNull())  {
d546 1
a546 1
        if ( lpModelHelper_ != NULL ) {
d555 2
a556 2
      RWCString indepPriorityFile = setOfParameters.getString("indepPriorityFile");
      if ((!independentDemandFile.isNull()) && (!indepPriorityFile.isNull()))  {
d568 1
a568 1
	RWCString revenueFile = setOfParameters.getString("revenueFile");
d573 2
a574 2
        RWCString optionRevFile = setOfParameters.getString("optionRevFile");
        if (! optionRevFile.isNull())
d582 2
a583 2
        RWCString featRevFile = setOfParameters.getString("featRevFile");
        if (! featRevFile.isNull())
d589 2
a590 2
	RWCString indepRevenueFile = setOfParameters.getString("indepRevenueFile");
	if ((!independentDemandFile.isNull()) && (!indepRevenueFile.isNull()))  {
d604 1
a604 1
	RWCString profitFile = setOfParameters.getString("profitFile");
d610 2
a611 2
        RWCString optionProfitFile = setOfParameters.getString("optionProfitFile");
        if (! optionProfitFile.isNull())
d617 2
a618 2
        RWCString featProfitFile = setOfParameters.getString("featProfitFile");
        if (! featProfitFile.isNull())
d628 2
a629 2
    RWCString minDemandVolFile = setOfParameters.getString("minDemandVolFile");
    if (! minDemandVolFile.isNull())
d636 2
a637 2
    RWCString minIndepDemandVolFile = setOfParameters.getString("minIndepDemandVolFile");
    if (! minIndepDemandVolFile.isNull())
d645 2
a646 2
    RWCString backlogYieldFile = setOfParameters.getString("backlogYieldFile");
    if (! backlogYieldFile.isNull())
d655 1
a655 1
    RWCString supplyFile = setOfParameters.getString("supplyFile");
d659 2
a660 2
    RWCString datedSupplyFile = setOfParameters.getString("datedSupplyFile");
    if (! datedSupplyFile.isNull())
d667 2
a668 2
    RWCString capSupplyFile = setOfParameters.getString("capSupplyFile");
    if (! capSupplyFile.isNull())    
d683 1
a683 1
    cout << "Analyzing SCE model (default operations) ..." << endl;    
d689 1
a689 1
    RWCString partsConditionFile = setOfParameters.getString("partCondFile");
d697 1
a697 1
      cout << "Pre-processing feature priorities ..." << endl;    
d702 1
a702 1
    if ( lpModelHelper_ == NULL ) {    
d711 1
a711 1
	cout << "Analyzing SCE model (multiple bop entries) ..." << endl;
d730 1
a730 1
	cout << "Analyzing SCE model (multiple interplant entries) ..." << endl;
d750 1
a750 1
      cout << "Analyzing SCE model (multiple bin entries) ..." << endl;
d761 1
a761 1
    cout << "Pre-Processing SCE model ..." << endl;
d774 2
a775 2
      RWCString outputFilePrefix = setOfParameters.getString("outputFilePrefix");
      if (outputFilePrefix.index("/") != RW_NPOS) {
d780 3
a782 3
      RWCString parameterFileName = setOfParameters.getString("parameterFileName");
      RWCString scrubParamFileName = myScrubber->scrubDir() + parameterFileName;
      if (parameterFileName.index("/") != RW_NPOS) {
d791 1
a791 1
      RWBoolean aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d800 1
a800 1
      if (! minDemandVolFile.isNull())
d821 1
a821 1
      cout << "Shutting off all Lot-sizing ..." << endl;    
d834 1
a834 1
    cout << "Pre-Processing for wit  ..." << endl;          
d841 2
a842 2
      cout << "Writing the echo file  ..." << endl;                
      RWCString echoFileName = setOfParameters.getString("heurEchoFileName");
d844 1
a844 1
      witDisplayData( theWitRun, echoFileName);
d854 2
a855 2
      cout << "Writing the (heur) wit data file ..." << endl;                      
      RWCString witDataFileName = setOfParameters.getString("heurWitDataFileName");
d857 1
a857 1
      witWriteData(theWitRun, witDataFileName);
d882 1
a882 1
      cout << "Computing Demand Drivers  ..." << endl;                      
d886 1
a886 1
      // after printing, WE MUST turn subs back on (netAllowed to TRUE)
d890 1
a890 1
	this->setSubsNetAllowed(FALSE, mpHelper, theWitRun);
d896 2
a897 2
      cout << "Writing the Demand Drivers file  ..." << endl;                      
      RWCString demandDriversFileName = setOfParameters.getString("demandDriversFileName");
d900 2
a901 2
    	this->setSubsNetAllowed(TRUE, mpHelper, theWitRun);
	mpHelper.setAllWitPartIndices(theWitRun);
d919 1
a919 1
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=FALSE, then this will
d922 1
a922 1
LgFrInitialProblemForSce::setSubsNetAllowed(RWBoolean subNetAllowed, 
d929 3
a931 3
  RWBoolean netAllowed = subNetAllowed;
  RWBoolean expAllowed = subNetAllowed;
  RWBoolean globalSubNetAllowed = this->sceScenario()->setOfParameters().getBool("globalSubNetAllowed");
d943 2
a944 1
  for (int o=0; o<nOperations; o++) {
d952 2
a953 1
    for (int b=0; b<nBoms; b++) {
d956 2
a957 1
      for (int s=0; s<nSubBoms; s++) {
d986 4
a989 4
    const RWCString & fileName,
     RWCString fileDescription,
    ifstream & inFile,
    ofstream & outFile,
d995 1
a995 1
    if (fileName.index("/") != RW_NPOS) {
d1000 2
a1001 2
    RWCString file = myScrubber -> scrubDir() + fileName;
    outFile.open(file, ios::out);
d1009 1
a1009 1
  inFile.open(fileName, ios::in,ios::nocreate);
d1025 1
a1025 1
    const RWCString & fileName,
d1030 3
a1032 3
    RWCString mfgPartName;
    RWCString pdf_PartName;
    RWCString pdf;
d1039 1
a1039 1
    RWCString dataLine;
d1043 2
a1044 2
    ifstream inFile;
    ofstream outFile;
d1056 1
a1056 1
    cout << "Processing " << fileName << ":\t" << flush;
d1063 1
a1063 1
	dataLine.readToDelim(inFile);
d1067 2
a1068 2
	dataLine = dataLine.strip(RWCString::both);
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1081 1
a1081 1
	RWCTokenizer next(dataLine);
d1122 1
a1122 1
                outFile << dataLine << endl;
d1130 1
a1130 1
    cout << recCount << " records processed." << endl;
d1148 1
a1148 1
    const RWCString & fileName,
d1152 3
a1154 3
    RWCString capacityName;
    RWCString pdf_capacityName;
    RWCString pdf;
d1161 1
a1161 1
    RWCString dataLine;
d1164 2
a1165 2
    ifstream inFile;    
    ofstream outFile;
d1175 1
a1175 1
    cout << "Processing " << fileName << ":\t" << flush;
d1182 1
a1182 1
	dataLine.readToDelim(inFile);
d1186 2
a1187 2
	dataLine = dataLine.strip(RWCString::both);
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1197 1
a1197 1
	RWCTokenizer next(dataLine);
d1230 1
a1230 1
                outFile << dataLine << endl;
d1237 1
a1237 1
    cout << recCount << " records processed." << endl;
d1256 1
a1256 1
    const RWCString & fileName,
d1260 3
a1262 3
 RWCString mfgParentPartName;
 RWCString mfgChildPartName;
 RWCString pdf;
d1268 1
a1268 1
 RWCString dataLine;
d1274 2
a1275 2
 ifstream inFile;
 ofstream outFile;
d1285 1
a1285 1
 cout << "Processing " << fileName << ":\t" << flush;
d1293 1
a1293 1
    dataLine.readToDelim(inFile);
d1297 2
a1298 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1309 1
a1309 1
    RWCTokenizer next(dataLine);
d1339 1
a1339 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1343 1
a1343 1
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1366 1
a1366 1
      result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);
d1370 1
a1370 1
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d1374 1
a1374 1
	result = flatFileManager.nextInt(phantomFlag, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d1379 1
a1379 1
			 FALSE, 0, 1);
d1407 1
a1407 1
                outFile << dataLine << endl;
d1413 1
a1413 1
 cout << recCount << " records processed." << endl;
d1430 1
a1430 1
    const RWCString & fileName,
d1434 3
a1436 3
 RWCString mfgParentPartName;
 RWCString mfgChildPartName;
 RWCString pdf;
d1438 1
a1438 1
 RWCString dataLine;
d1449 2
a1450 2
 ifstream inFile;
 ofstream outFile;
d1460 1
a1460 1
 cout << "Processing " << fileName << ":\t" << flush;
d1468 1
a1468 1
    dataLine.readToDelim(inFile);
d1472 2
a1473 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1484 1
a1484 1
    RWCTokenizer next(dataLine);
d1511 1
a1511 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1515 1
a1515 1
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1550 1
a1550 1
        outFile << dataLine << endl;
d1553 1
a1553 1
 cout << recCount << " records processed." << endl;
d1565 1
a1565 1
    const RWCString & fileName,
d1569 3
a1571 3
 RWCString consumedPartName;
 RWCString operationName;
 RWCString pdf;
d1573 1
a1573 1
 RWCString dataLine;
d1583 2
a1584 2
 ifstream inFile;
 ofstream outFile;
d1594 1
a1594 1
 cout << "Processing " << fileName << ":\t" << flush;
d1602 1
a1602 1
    dataLine.readToDelim(inFile);
d1606 2
a1607 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1618 1
a1618 1
    RWCTokenizer next(dataLine);
d1645 1
a1645 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1649 1
a1649 1
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1667 1
a1667 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);
d1691 1
a1691 1
            outFile << dataLine << endl;
d1698 1
a1698 1
 cout << recCount << " records processed." << endl;
d1713 1
a1713 1
    const RWCString & fileName,
d1717 3
a1719 3
 RWCString producedPartName;
 RWCString operationName;
 RWCString pdf;
d1721 1
a1721 1
 RWCString dataLine;
d1731 2
a1732 2
 ifstream inFile;
 ofstream outFile;
d1742 1
a1742 1
 cout << "Processing " << fileName << ":\t" << flush;
d1750 1
a1750 1
    dataLine.readToDelim(inFile);
d1754 2
a1755 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1766 1
a1766 1
    RWCTokenizer next(dataLine);
d1798 1
a1798 1
    // if ( lpModelHelper_ != NULL )
d1802 1
a1802 1
    result = flatFileManager.nextFloat(prodRate, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1806 1
a1806 1
      result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1819 1
a1819 1
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX); 
d1825 1
a1825 1
                       next, fileName, dataLine, lineNo, FALSE, 0, 1); 
d1830 1
a1830 1
                       next, fileName, dataLine, lineNo, FALSE, 0, 1); 
d1861 1
a1861 1
            outFile << dataLine << endl;
d1867 1
a1867 1
 cout << recCount << " records processed." << endl;
d1880 1
a1880 1
    const RWCString & fileName,
d1886 1
a1886 1
 RWCString dataLine;
d1896 2
a1897 2
 ifstream inFile;
 ofstream outFile;
d1907 1
a1907 1
 cout << "Processing " << fileName << ":\t" << flush;
d1915 1
a1915 1
    dataLine.readToDelim(inFile);
d1919 2
a1920 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1931 1
a1931 1
    RWCTokenizer next(dataLine);
d1934 1
a1934 1
    RWCString mfgPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1942 1
a1942 1
    RWCString mfgPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1950 1
a1950 1
    RWCString aggregatePart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1959 1
a1959 1
    RWCString aggregatePdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1975 1
a1975 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1979 1
a1979 1
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1986 1
a1986 1
    // else if ( lpModelHelper_ != NULL )
d1990 1
a1990 1
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d1994 1
a1994 1
      result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d2019 1
a2019 1
        outFile << dataLine << endl;
d2023 1
a2023 1
 cout << recCount << " records processed." << endl;
d2038 1
a2038 1
    const RWCString & fileName,
d2041 4
a2044 4
 RWCString plannerTopLevelPart;
 RWCString bbCategory;
 RWCString geo;
 RWCString mfgOptionPart;
d2046 1
a2046 1
 RWCString dataLine;
d2062 2
a2063 2
 ifstream inFile;
 ofstream outFile;
d2074 1
a2074 1
 cout << "Processing " << fileName << ":\t" << flush;
d2082 1
a2082 1
    dataLine.readToDelim(inFile);
d2086 2
a2087 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d2101 1
a2101 1
    RWCTokenizer next(dataLine);
d2128 2
a2129 1
    for (int t=0; t<nPeriods; t++)
d2134 1
a2134 1
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d2140 3
a2142 2
	for (int t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, FALSE, 0.0);
d2184 1
a2184 1
            outFile << dataLine << endl;
d2190 1
a2190 1
 cout << recCount << " records processed." << endl;
d2208 1
a2208 1
    const RWCString & fileName,
d2213 3
a2215 3
 RWCString plannerTopLevelPart;
 RWCString geo;
 RWCString mfgOptionPart;
d2217 1
a2217 1
 RWCString dataLine;
d2234 2
a2235 2
 ifstream inFile;
 ofstream outFile;
d2246 1
a2246 1
 cout << "Processing " << fileName << ":\t" << flush;
d2254 1
a2254 1
   dataLine.readToDelim(inFile);
d2258 2
a2259 2
   dataLine = dataLine.strip(RWCString::both);
   if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d2270 1
a2270 1
   RWCTokenizer next(dataLine);
d2293 2
a2294 1
   for (int t=0; t<nPeriods; t++) {
d2301 2
a2302 1
     for (int t=0; t<nPeriods; t++)  {
d2304 1
a2304 1
                                 next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d2341 1
a2341 1
           outFile << dataLine << endl;
d2347 1
a2347 1
 cout << recCount << " records processed." << endl;
d2368 1
a2368 1
    const RWCString & fileName,
d2385 4
a2388 4
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString mfgOptionPart;
  RWCString dataLine;
d2411 2
a2412 1
  for (int tt=0; tt<nPeriods; tt++)
d2415 2
a2416 2
  ifstream inFile;
  ofstream outFile;
d2426 1
a2426 1
  cout << "Processing " << fileName << ":\t" << flush;
d2434 1
a2434 1
    dataLine.readToDelim(inFile);
d2438 2
a2439 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d2453 1
a2453 1
    RWCTokenizer next(dataLine);
d2487 2
a2488 1
    for (int t=0; t<nPeriods; t++) {
d2495 1
a2495 1
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d2501 3
a2503 2
	for (int t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, FALSE, 0.0);
d2512 2
a2513 1
	for (int t=0; t<nPeriods; t++)  {
d2516 1
a2516 1
					       FALSE, -1.0, 1.0);
d2607 1
a2607 1
            outFile << dataLine << endl;
d2614 1
a2614 1
 cout << recCount << " records processed." << endl;
d2641 1
a2641 1
  RWCString pp, geo;
d2648 2
a2649 1
  for (int t=0; t<nPeriods; t++)
d2653 2
a2654 1
  for (int i=0; i<nParts; i++) {
d2673 1
a2673 1
    const RWCString & fileName,
d2686 3
a2688 3
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString mfgOptionPart;
d2693 1
a2693 1
  RWCString dataLine;
d2707 2
a2708 2
  ifstream inFile;
  ofstream outFile;
d2720 1
a2720 1
  cout << "Processing " << fileName << ":\t" << flush;
d2728 1
a2728 1
    dataLine.readToDelim(inFile);
d2732 2
a2733 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d2747 1
a2747 1
    RWCTokenizer next(dataLine);
d2777 1
a2777 1
    result = flatFileManager.nextFloat(offsetVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d2787 1
a2787 1
    result = flatFileManager.nextInt(featurePhantomFlag, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d2818 1
a2818 1
	outFile << dataLine << endl;
d2825 1
a2825 1
 cout << recCount << " records processed." << endl;
d2841 1
a2841 1
    const RWCString & fileName,
d2846 4
a2849 4
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString mfgOptionPart;
  RWCString dataLine;
d2864 2
a2865 2
  ifstream inFile;
  ofstream outFile;
d2875 1
a2875 1
  cout << "Processing " << fileName << ":\t" << flush;
d2883 1
a2883 1
    dataLine.readToDelim(inFile);
d2887 2
a2888 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d2902 1
a2902 1
    RWCTokenizer next(dataLine);
d2932 2
a2933 1
    for (int t=0; t<nPeriods; t++) {
d2942 3
a2944 2
	for (int t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(supplyVol[t], next, fileName, dataLine, lineNo, FALSE, 0.0);
d2969 1
a2969 1
            outFile << dataLine << endl;
d2976 1
a2976 1
 cout << recCount << " records processed." << endl;
d2996 1
a2996 1
    const RWCString & fileName,
d2999 5
a3003 5
    RWCString plannerTopLevelPart;
    RWCString geo;
    RWCString plannerFeatureSetPart;
    RWCString bbCategory;
    RWCString dataLine;
d3011 2
a3012 2
    ifstream inFile;
    ofstream outFile;
d3022 1
a3022 1
    cout << "Processing " << fileName << ":\t" << flush;
d3030 1
a3030 1
	dataLine.readToDelim(inFile);
d3034 2
a3035 2
	dataLine = dataLine.strip(RWCString::both);
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d3046 1
a3046 1
	RWCTokenizer next(dataLine);
d3073 1
a3073 1
	result = flatFileManager.nextFloat(gammaMax, next, fileName, dataLine, lineNo, FALSE, 1.0);
d3108 1
a3108 1
                outFile << dataLine << endl;
d3114 1
a3114 1
    cout << recCount << " records processed." << endl;
d3127 1
a3127 1
    const RWCString & fileName,
d3131 5
a3135 5
 RWCString mfgParentPartName;
 RWCString mfgChildPartName;
 RWCString parentPdf;
 RWCString childPdf;
 RWCString dataLine;
d3144 2
a3145 2
 ifstream inFile;
 ofstream outFile;
d3155 1
a3155 1
 cout << "Processing " << fileName << ":\t" << flush;
d3165 1
a3165 1
    dataLine.readToDelim(inFile);
d3169 2
a3170 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d3180 1
a3180 1
    RWCTokenizer next(dataLine);
d3218 1
a3218 1
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3243 1
a3243 1
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, FALSE, 0.0 );
d3247 1
a3247 1
                           lineNo, FALSE, 1.0);
d3251 1
a3251 1
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3256 1
a3256 1
    // if ( lpModelHelper_ != NULL )
d3259 1
a3259 1
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3263 1
a3263 1
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d3267 1
a3267 1
      result = flatFileManager.nextInt( isInterplantExplodeableAsSubstitute, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d3298 1
a3298 1
            outFile << dataLine << endl;
d3304 1
a3304 1
 cout << recCount << " records processed." << endl;
d3318 1
a3318 1
    const RWCString & fileName,
d3322 5
a3326 5
 RWCString mfgParentPartName;
 RWCString mfgChildPartName;
 RWCString parentPdf;
 RWCString childPdf;
 RWCString dataLine;
d3335 2
a3336 2
 ifstream inFile;
 ofstream outFile;
d3346 1
a3346 1
 cout << "Processing " << fileName << ":\t" << flush;
d3356 1
a3356 1
    dataLine.readToDelim(inFile);
d3360 2
a3361 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d3371 1
a3371 1
    RWCTokenizer next(dataLine);
d3409 1
a3409 1
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3434 1
a3434 1
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, FALSE, 0.0 );
d3438 1
a3438 1
                           lineNo, FALSE, 1.0);
d3442 1
a3442 1
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3447 1
a3447 1
    // if ( lpModelHelper_ != NULL )
d3450 1
a3450 1
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3454 1
a3454 1
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d3458 1
a3458 1
      result = flatFileManager.nextInt( isBinExplodeableAsSubstitute, next, fileName, dataLine, lineNo, FALSE, 0, 1);
d3489 1
a3489 1
            outFile << dataLine << endl;
d3495 1
a3495 1
 cout << recCount << " records processed." << endl;
d3517 1
a3517 1
    const RWCString & fileName,
d3521 5
a3525 5
 RWCString operationName;
 RWCString mfgChildPartName;
 RWCString mfgSubPartName;
 RWCString pdf;
 RWCString dataLine;
d3533 2
a3534 2
 // RWBoolean relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");
 RWBoolean relaxedSubbingRulesAllowed = FALSE;
d3536 1
a3536 1
RWBoolean globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");
a3537 1
 
d3541 2
a3542 2
 ifstream inFile;
 ofstream outFile;
d3552 1
a3552 1
 cout << "Processing " << fileName << ":\t" << flush;
d3560 1
a3560 1
    dataLine.readToDelim(inFile);
d3564 2
a3565 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d3577 1
a3577 1
    RWCTokenizer next(dataLine);
d3612 1
a3612 1
				       dataLine, lineNo, FALSE, -FLT_MAX);
d3635 1
a3635 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);
d3639 1
a3639 1
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3644 1
a3644 1
					 dataLine, lineNo, FALSE, 0, 1);    
d3649 1
a3649 1
					 dataLine, lineNo, FALSE, 0, 1);    
d3653 1
a3653 1
    RWBoolean isParentAnOperation = TRUE;
d3670 1
a3670 1
        isObjectInEffectForOptExplosion,
d3681 1
a3681 1
                outFile << dataLine << endl;
d3690 1
a3690 1
 cout << recCount << " records processed." << endl;
d3709 1
a3709 1
    const RWCString & fileName,
d3713 5
a3717 5
 RWCString mfgParentPartName;
 RWCString mfgChildPartName;
 RWCString mfgSubPartName;
 RWCString pdf;
 RWCString dataLine;
d3727 1
a3727 1
 // RWBoolean relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");
d3730 1
a3730 1
 RWBoolean globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");
d3737 2
a3738 2
 ifstream inFile;
 ofstream outFile;
d3748 1
a3748 1
 cout << "Processing " << fileName << ":\t" << flush;
d3756 1
a3756 1
    dataLine.readToDelim(inFile);
d3760 2
a3761 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d3775 1
a3775 1
    RWCTokenizer next(dataLine);
d3809 1
a3809 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3831 1
a3831 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);
d3835 1
a3835 1
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d3839 1
a3839 1
	result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, FALSE, 0, 1);    
d3843 1
a3843 1
	result = flatFileManager.nextInt(isSubstituteBuildable, next, fileName, dataLine, lineNo, FALSE, 0, 1);    
d3845 2
a3846 2
    RWBoolean isParentAnOperation = FALSE;
    RWBoolean relaxedSubbingRulesAllowed = FALSE;
d3877 1
a3877 1
                outFile << dataLine << endl;
d3886 1
a3886 1
 cout << recCount << " records processed." << endl;
d3903 1
a3903 1
    const RWCString & fileName,
d3908 2
a3909 2
 RWCString pdf_PartName;
 ifstream inFile;
d3912 1
a3912 1
 RWCString dataLine;
d3918 1
a3918 1
 ofstream outFile;
d3923 1
a3923 1
 RWBoolean aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d3933 1
a3933 1
   inFile.open(fileName, ios::in);
d3944 1
a3944 1
 cout << "Processing " << fileName << ":\t" << flush;
d3977 1
a3977 1
    witGetPartSupplyVol(theWitRun, pdf_PartName.data(), &supplyVol);
d3979 2
a3980 1
    for (int t=0; t<nElementsChanged; t++) {
d3983 1
a3983 1
    witSetPartSupplyVol(theWitRun, pdf_PartName, supplyVol);
d3985 1
a3985 1
//    cout << "Updated supply Volume for " << pdf_PartName << "\n";
d3991 1
a3991 1
	outFile << dataLine << endl;
d3998 1
a3998 1
 cout << recCount << " records processed." << endl;
d4025 1
a4025 1
    const RWCString & fileName,
d4029 2
a4030 2
 RWCString pdf_PartName;
 ifstream inFile;
d4033 1
a4033 1
 RWCString dataLine;
d4041 1
a4041 1
 ofstream outFile;
d4044 1
a4044 1
 RWBoolean aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d4055 1
a4055 1
   inFile.open(fileName, ios::in);
d4068 1
a4068 1
 cout << "Processing " << fileName << ":\t" << flush;
d4077 2
a4078 2
    RWCString pdf;
    RWCString mfgPartName;
d4081 1
a4081 1
    dataLine.readToDelim(inFile);
d4085 2
a4086 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull()){
d4091 1
a4091 1
    RWCTokenizer next(dataLine);
d4119 1
a4119 1
    result = flatFileManager.nextFloat(supplyVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d4122 2
a4123 2
      cerr << "\nbad supply float\n"  << lineNo << ":" << dataLine << endl;
      cerr << "ignoring the record\n" << endl;
d4130 1
a4130 1
    RWCString token;
d4133 3
a4135 3
    if ((token = next(" \",\n")).isNull()) {
      cerr << "\nDate is missing from dated supply record\n"  << lineNo << ":" << dataLine << endl;
      cerr << "putting it in week 1\n" << endl;
d4140 1
a4140 1
    RWDate supplyDate(flatFileManager.parseDateString(token, theCal));
d4155 2
a4156 2
      cerr << "\nsupply period in the PAST\n" << lineNo << ":" << dataLine << endl;
      cerr << "putting it in week 1\n" << endl;
d4161 2
a4162 2
      cerr << "\nsupply period in the FUTURE\n" << lineNo << ":" << dataLine << endl;
      cerr << "ignoring !!\n" << endl;
d4168 1
a4168 1
    witGetPartSupplyVol(theWitRun, pdf_PartName.data(), &supplyVol);
d4170 1
a4170 1
    witSetPartSupplyVol(theWitRun, pdf_PartName, supplyVol);
d4178 1
a4178 1
	outFile << dataLine << endl;
d4184 1
a4184 1
 cout << recCount << " records processed." << endl;
d4203 1
a4203 1
    const RWCString & fileName,
d4211 1
a4211 1
  RWCString pdf_PartName;
d4214 1
a4214 1
  RWCString dataLine;
d4216 2
a4217 2
  ifstream inFile;
  ofstream outFile;
d4228 1
a4228 1
 cout << "Processing " << fileName << ":\t" << flush;
d4261 1
a4261 1
    witGetPartSupplyVol(theWitRun, pdf_PartName, &supplyVol);
d4263 2
a4264 1
    for (int t=0; t<nElementsChanged; t++) {
d4267 1
a4267 1
    witSetPartSupplyVol(theWitRun, pdf_PartName, supplyVol);
d4272 1
a4272 1
                outFile << dataLine << endl;
d4277 1
a4277 1
 cout << recCount << " records processed." << endl;
d4290 1
a4290 1
    const RWCString & fileName,
d4293 3
a4295 3
  RWCString mfgPartName;
  RWCString pdf_PartName;
  RWCString pdf;
d4297 1
a4297 1
  ifstream inFile;
d4299 1
a4299 1
  RWCString dataLine;
d4312 1
a4312 1
 RWBoolean forcePcfBogons = setOfParameters.getBool("forcePcfBogons");
d4316 1
a4316 1
  inFile.open(fileName, ios::in);
d4324 1
a4324 1
  cout << "Processing " << fileName << ":\t" << flush;
d4332 1
a4332 1
    dataLine.readToDelim(inFile);
d4336 2
a4337 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d4351 1
a4351 1
    RWCTokenizer next(dataLine);
d4365 1
a4365 1
    RWCString token;
d4368 1
a4368 1
    if ((token = next(" \",\n")).isNull()) {
d4372 1
a4372 1
      RWDate startDate(flatFileManager.parseDateString(token, theCal));
d4424 1
a4424 1
    RWBoolean didWeRejectTheRecord = FALSE;
d4429 1
a4429 1
    witGetOperationExists(theWitRun, pdf_PartName, &exists);
d4432 1
a4432 1
    witGetOperationNBomEntries(theWitRun, pdf_PartName, &nBom);
d4445 1
a4445 1
	didWeRejectTheRecord = TRUE;
d4466 2
a4467 2
      witGetPartAppData(theWitRun, pdf_PartName, (void **) &appDataPtr);
      if (appDataPtr != NULL) {
d4475 1
a4475 1
      witSetPartAppData(theWitRun, pdf_PartName, appDataPtr);
d4495 3
a4497 2
    witGetPartNProducingBopEntries(theWitRun, pdf_PartName, &npBop);
    for (int p=0; p<npBop; p++) {
d4500 1
a4500 1
      witGetPartProducingBopEntry(theWitRun, pdf_PartName, p, &opName, &o);
d4503 1
a4503 1
      if (pdf_PartName.compareTo(opName)) {
d4511 1
a4511 1
        didWeRejectTheRecord = TRUE;
d4527 2
a4528 2
      witGetPartAppData(theWitRun, pdf_PartName, (void **) &appDataPtr);
      if (appDataPtr != NULL) {
d4536 1
a4536 1
      witSetPartAppData(theWitRun, pdf_PartName, appDataPtr);
d4549 3
a4551 2
      witGetOperationYieldRate(theWitRun, pdf_PartName, &yieldRate);              
      for (int t=0; t<unConstrainedStartPeriod; t++)
d4553 1
a4553 1
      witSetOperationYieldRate(theWitRun, pdf_PartName, yieldRate);
d4559 2
a4560 2
      witGetPartAppData(theWitRun, pdf_PartName, (void **) &appDataPtr);
      if (appDataPtr != NULL) {
d4567 1
a4567 1
      witSetPartAppData(theWitRun, pdf_PartName, appDataPtr);
d4571 1
a4571 1
  cout << recCount << " records processed." << endl;
d4590 1
a4590 1
    const RWCString & fileName,
d4593 3
a4595 3
  RWCString mfgPartName;
  RWCString pdf_PartName;
  RWCString pdf;
d4597 1
a4597 1
  ifstream inFile;
d4599 1
a4599 1
  RWCString dataLine;
d4611 1
a4611 1
  inFile.open(fileName, ios::in);
d4619 1
a4619 1
  ofstream outFile;
d4622 1
a4622 1
    if (fileName.index("/") != RW_NPOS) {
d4626 2
a4627 2
    RWCString file = myScrubber -> scrubDir() + fileName;
    outFile.open(file, ios::out);
d4638 1
a4638 1
    dataLine.readToDelim(inFile);
d4642 2
a4643 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d4647 1
a4647 1
    RWCTokenizer next(dataLine);
d4659 1
a4659 1
    RWCString token;
d4662 1
a4662 1
    if ((token = next(" \",\n")).isNull()) {
d4666 1
a4666 1
      RWDate startDate(flatFileManager.parseDateString(token, theCal));
d4687 1
a4687 1
	  outFile << dataLine << endl;
d4705 1
a4705 1
    const RWCString & fileName,
d4708 3
a4710 3
  RWCString mfgPartName;
  RWCString pdf_PartName;
  RWCString pdf;
d4722 1
a4722 1
  ofstream outFile;
d4725 1
a4725 1
    if (fileName.index("/") != RW_NPOS) {
d4730 2
a4731 2
    RWCString file = myScrubber -> scrubDir() + fileName;
    outFile.open(file, ios::out);
d4741 2
a4742 1
  for (int i=0; i<nParts; i++ ) {
d4746 2
a4747 2
       RWCString partname = mpHelper.partname(partList[i]);
       RWCString pdf = mpHelper.pdf(partList[i]);
d4772 1
a4772 1
    const RWCString & fileName,
d4776 3
a4778 3
  RWCString plannerPart;
  RWCString geo;
  RWCString geoPlannerDemandPartName;
d4780 2
a4781 2
  RWCString demandName;
  ifstream inFile;
d4784 1
a4784 1
  RWCString dataLine;
d4800 1
a4800 1
  ofstream outFile;
d4803 1
a4803 1
    if (fileName.index("/") != RW_NPOS) {
d4808 2
a4809 2
    RWCString file = myScrubber -> scrubDir() + fileName;
    outFile.open(file, ios::out);
d4816 1
a4816 1
  inFile.open(fileName, ios::in);
d4840 1
a4840 1
	assert(demandAppDataPtr != NULL);
d4854 1
a4854 1
   dataLine.readToDelim(inFile);
d4856 2
a4857 2
   dataLine = dataLine.strip(RWCString::both);
   if ((dataLine.index("*") == 0) || dataLine.isNull())
d4859 1
a4859 1
   RWCTokenizer next(dataLine);
d4887 2
a4888 2
		      geoPlannerDemandPartName,
		      geo,
d4890 1
a4890 1
  assert(demandAppDataPtr != NULL);
d4900 2
a4901 2
  witGetDemandDemandVol(theWitRun, geoPlannerDemandPartName, 
			geo, &demandVol);
d4931 1
a4931 1
    const RWCString & fileName,
d4935 3
a4937 3
  RWCString plannerPart;
  RWCString geo;
  RWCString geoPlannerDemandPartName;
d4939 2
a4940 2
  RWCString demandName;
  ifstream inFile;
d4945 1
a4945 1
  RWCString dataLine;
d4961 1
a4961 1
  ofstream outFile;
d4964 1
a4964 1
    if (fileName.index("/") != RW_NPOS) {
d4969 2
a4970 2
    RWCString file = myScrubber -> scrubDir() + fileName;
    outFile.open(file, ios::out);
d4977 1
a4977 1
  inFile.open(fileName, ios::in);
d5002 1
a5002 1
	assert(demandAppDataPtr != NULL);
d5016 1
a5016 1
   dataLine.readToDelim(inFile);
d5018 2
a5019 2
   dataLine = dataLine.strip(RWCString::both);
   if ((dataLine.index("*") == 0) || dataLine.isNull())
d5021 1
a5021 1
   RWCTokenizer next(dataLine);
d5049 2
a5050 2
		      geoPlannerDemandPartName,
		      geo,
d5052 1
a5052 1
  assert(demandAppDataPtr != NULL);
d5064 2
a5065 2
			      geoPlannerDemandPartName,
		              geo,
d5110 3
a5112 3
  RWCString plannerPart;
  RWCString geo;
  RWCString geoPlannerDemandPartName;
d5135 1
a5135 1
	assert(demandAppDataPtr != NULL);
d5139 1
a5139 1
	  witSetDemandAppData(theWitRun, partList[i], dList[j], (void *) NULL);
d5211 1
a5211 1
  // the optExplodableFlags are set to FALSE on all the non-default
d5221 2
a5222 1
  for (int i=0; i<nParts; i++) {
d5229 2
a5230 2
    RWCString defaultOperationName (partList[i]);
    witGetOperationExists(theWitRun, defaultOperationName, &defOpExists);
d5241 1
a5241 1
    witGetOperationNBomEntries(theWitRun, defaultOperationName, &nBom);
d5250 1
a5250 1
      witBoolean didWefindBopEntryForDefaultOperation = FALSE;
d5252 2
a5253 1
      for (int p=0; p<npBops; p++) { // p = prodIndex
d5261 4
a5264 4
          assert(didWefindBopEntryForDefaultOperation == FALSE);
          didWefindBopEntryForDefaultOperation = TRUE;
          witSetBopEntryEarliestPeriod(theWitRun, defaultOperationName.data(), bopEntryIndex, lastPeriod ); 
          witSetBopEntryLatestPeriod(theWitRun, defaultOperationName.data(), bopEntryIndex, 0 );
d5269 1
a5269 1
      if ( didWefindBopEntryForDefaultOperation != TRUE ){       
d5291 1
a5291 1
    const RWCString & fileName,
d5296 3
a5298 3
 RWCString pdf_PartName;
 RWCString demandName;
 ifstream inFile;
d5301 1
a5301 1
 RWCString dataLine;
d5308 1
a5308 1
 inFile.open(fileName, ios::in);
d5319 1
a5319 1
 cout << "Processing " << fileName << ":\t" << flush;
d5338 1
a5338 1
	TRUE,           // Are all elements mandatory?
d5341 1
a5341 1
	TRUE);          // Add demand stream to WIT if not there
d5352 2
a5353 2
    witGetDemandDemandVol(theWitRun, pdf_PartName.data(), 
			  demandName.data(), &demandVol);
d5358 2
a5359 2
			pdf_PartName.data(), 
			demandName.data(),
d5361 1
a5361 1
    assert(demandAppDataPtr != NULL);
d5367 2
a5368 1
    for (int t=0; t<nElementsChanged; t++) {
d5374 2
a5375 2
      RWCString pnm = mpHelper.partname(pdf_PartName);
      RWCString pdfff = mpHelper.pdf(pdf_PartName);
d5383 1
a5383 1
    witSetDemandDemandVol(theWitRun, pdf_PartName, demandName, demandVol);
d5392 1
a5392 1
 cout << recCount << " records processed." << endl;
d5410 1
a5410 1
    const RWCString & fileName,
d5415 5
a5419 5
 RWCString mfgPart;
 RWCString pdf;
 RWCString fullWitPart;
 RWCString demandName;
 ifstream inFile;
d5421 1
a5421 1
 RWCString dataLine;
d5429 2
a5430 1
 for (int t=0; t<nPeriods; t++) {
d5436 1
a5436 1
 ofstream outFile;
d5449 1
a5449 1
 cout << "Processing " << fileName << ":\t" << flush;
d5460 1
a5460 1
   dataLine.readToDelim(inFile);
d5463 1
a5463 1
   dataLine = dataLine.strip(RWCString::both);
d5466 1
a5466 1
   if ((dataLine.index("*") == 0) || dataLine.isNull()) {
d5472 1
a5472 1
   RWCTokenizer next(dataLine);
d5519 1
a5519 1
    witAddDemand( theWitRun, fullWitPart, demandName );
d5524 2
a5525 2
			fullWitPart, 
			demandName, 
d5528 4
a5531 4
    witSetDemandPriority( theWitRun, fullWitPart,
			  demandName, defaultPriorityVec );
    witSetDemandShipLateLimit( theWitRun, fullWitPart,
			       demandName, defaultShipLateLimit );
d5535 1
a5535 1
    if ( lpModelHelper_ != NULL ) {
d5552 4
a5555 4
      witSetDemandObj1ShipReward( theWitRun, fullWitPart,
				  demandName, defaultObj1ShipRewardVec);
      witSetDemandObj1CumShipReward( theWitRun, fullWitPart,
				     demandName, defaultObj1CumShipRewardVec);
d5563 1
a5563 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, FALSE,
d5581 2
a5582 2
  witGetDemandAppData(theWitRun, fullWitPart, demandName, (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != NULL);
d5618 1
a5618 1
  witSetDemandDemandVol(theWitRun, fullWitPart, demandName, demandVolTVF.data());
d5623 1
a5623 1
      outFile << dataLine << endl;
d5630 1
a5630 1
 cout << recCount << " records processed." << endl;
d5649 1
a5649 1
    const RWCString & fileName,
d5655 2
a5656 2
 RWCString pdf_PartName;
 RWCString demandName;
d5658 1
a5658 1
 RWCString dataLine;
d5663 2
a5664 2
 ifstream inFile;
 ofstream outFile;
d5675 1
a5675 1
 cout << "Processing " << fileName << ":\t" << flush;
d5694 1
a5694 1
    	FALSE,          // Are all elements mandatory?
d5696 2
a5697 2
	INT_MAX,        // data upper limits
	FALSE);         // Add demand stream to WIT if not there
d5708 1
a5708 1
    if ( lpModelHelper_ != NULL ) {
d5711 1
a5711 1
      witGetDemandObj1ShipReward(theWitRun, pdf_PartName, demandName, &rev);
d5713 2
a5714 1
      for (int t=0; t<nElementsChanged; t++) {
d5718 1
a5718 1
      witSetDemandObj1ShipReward(theWitRun, pdf_PartName, demandName, rev);
d5724 1
a5724 1
      witSetDemandObj1CumShipReward(theWitRun, pdf_PartName, demandName, rev);
d5737 1
a5737 1
    witGetDemandPriority(theWitRun, pdf_PartName, demandName, &priority);
d5739 2
a5740 1
    for (int t=0; t<nElementsChanged; t++) {
d5744 1
a5744 1
    witSetDemandPriority(theWitRun, pdf_PartName, demandName, priority);
d5750 1
a5750 1
                outFile << dataLine << endl;
d5756 1
a5756 1
 cout << recCount << " records processed." << endl;
d5770 1
a5770 1
    const RWCString & fileName,
d5776 4
a5779 4
 RWCString mfgPart;
 RWCString pdf;
 RWCString fullWitPart;
 RWCString demandName;
d5781 1
a5781 1
 RWCString dataLine;
d5789 2
a5790 2
 ifstream inFile;
 ofstream outFile;
d5805 1
a5805 1
 cout << "Processing " << fileName << ":\t" << flush;
d5816 1
a5816 1
   dataLine.readToDelim(inFile);
d5819 1
a5819 1
   dataLine = dataLine.strip(RWCString::both);
d5822 1
a5822 1
   if ((dataLine.index("*") == 0) || dataLine.isNull()) {
d5828 1
a5828 1
   RWCTokenizer next(dataLine);
d5887 1
a5887 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, FALSE,
d5900 1
a5900 1
  if ( lpModelHelper_ != NULL ) {
d5902 1
a5902 1
    witGetDemandObj1ShipReward(theWitRun, fullWitPart, demandName, &rev);
d5904 2
a5905 1
    for (int t=0; t<nElementsChanged; t++) {
d5909 1
a5909 1
    witSetDemandObj1ShipReward(theWitRun, fullWitPart, demandName, rev);
d5915 1
a5915 1
    witSetDemandObj1CumShipReward(theWitRun, fullWitPart, demandName, rev);
d5926 1
a5926 1
  witGetDemandPriority(theWitRun, fullWitPart, demandName, &priority);
d5928 2
a5929 1
  for (int t=0; t<nElementsChanged; t++) {
d5933 1
a5933 1
  witSetDemandPriority(theWitRun, fullWitPart, demandName, priority);
d5941 1
a5941 1
      outFile << dataLine << endl;
d5947 1
a5947 1
 cout << recCount << " records processed." << endl;
d5962 1
a5962 1
    const RWCString & fileName,
d5966 2
a5967 2
 RWCString pdf_PartName;
 RWCString demandName;
d5973 2
a5974 2
 RWCString dataLine;
 RWBoolean isRecordGood;
d5980 2
a5981 2
 ifstream inFile;
 ofstream outFile;
d5994 1
a5994 1
 cout << "Processing " << fileName << ":\t" << flush;
d6011 1
a6011 1
	FALSE,          // Are all elements mandatory?
d6014 1
a6014 1
	FALSE);         // Add demand stream to WIT if not there
d6026 2
a6027 2
			      pdf_PartName.data(), 
			      demandName.data(), 
d6033 2
a6034 2
                          pdf_PartName.data(),
                          demandName.data(),
d6040 1
a6040 1
    isRecordGood = TRUE;
d6051 1
a6051 1
          isRecordGood = FALSE;          
d6063 2
a6064 2
			pdf_PartName.data(), 
			demandName.data(),
d6066 1
a6066 1
       assert(demandAppDataPtr != NULL);
d6071 2
a6072 2
          RWCString pnm = mpHelper.partname(pdf_PartName);
          RWCString pdfff = mpHelper.pdf(pdf_PartName);
d6090 2
a6091 2
                              pdf_PartName, 
                              demandName, 
d6125 1
a6125 1
 cout << recCount << " records processed." << endl;
d6137 1
a6137 1
    const RWCString & fileName,
d6142 4
a6145 4
  RWCString mfgPart;
  RWCString pdf;
  RWCString fullWitPart;
  RWCString demandName;
d6152 1
a6152 1
  RWBoolean isRecordGood;
d6154 1
a6154 1
  ifstream inFile;
d6156 1
a6156 1
  RWCString dataLine;
d6163 1
a6163 1
  ofstream outFile;
d6176 1
a6176 1
  cout << "Processing " << fileName << ":\t" << flush;
d6187 1
a6187 1
    dataLine.readToDelim(inFile);
d6190 1
a6190 1
    dataLine = dataLine.strip(RWCString::both);
d6193 1
a6193 1
    if ((dataLine.index("*") == 0) || dataLine.isNull()) {
d6199 1
a6199 1
    RWCTokenizer next(dataLine);
d6258 1
a6258 1
    RWBoolean isMinDemandVolNegative = 0;
d6260 1
a6260 1
      int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, FALSE,
d6300 2
a6301 2
			      fullWitPart, 
			      demandName, 
d6307 2
a6308 2
			  fullWitPart,
			  demandName,
d6316 1
a6316 1
    isRecordGood = TRUE;
d6326 1
a6326 1
	isRecordGood = FALSE;          
d6342 2
a6343 2
			  fullWitPart, 
			  demandName,
d6345 1
a6345 1
      assert(demandAppDataPtr != NULL);
d6351 2
a6352 2
	RWCString pnm = mpHelper.partname(fullWitPart);
	RWCString pdfff = mpHelper.pdf(fullWitPart);
d6367 2
a6368 2
				fullWitPart, 
				demandName, 
d6399 1
a6399 1
	  outFile << dataLine << endl;
d6406 1
a6406 1
  cout << recCount << " records processed." << endl;
d6420 1
a6420 1
    const RWCString & fileName,
d6424 2
a6425 2
  RWCString pdf_PartName;
  RWCString demandName;
d6427 1
a6427 1
  RWCString dataLine;
d6432 2
a6433 2
  ifstream inFile;
  ofstream outFile;
d6445 1
a6445 1
  cout << "Processing " << fileName << ":\t" << flush;
d6462 1
a6462 1
	FALSE,          // Are all elements mandatory?
d6465 1
a6465 1
	FALSE);         // Add demand stream to WIT if not there
d6478 2
a6479 2
			pdf_PartName, 
			demandName,
d6484 1
a6484 1
    // If the demandAppDataPtr hasn't been set (i.e., its NULL) then "new" one
d6487 2
a6488 2
    // If it hasn't (i.e. the backlogYield is NULL), then set it. Otherwise, do nothing.
    if (demandAppDataPtr == NULL)  {
d6490 1
a6490 1
      assert ( demandAppDataPtr != NULL);
d6493 2
a6494 2
                          pdf_PartName, 
                          demandName, 
d6499 2
a6500 1
    for (int t=0; t<nElementsChanged; t++) {
d6510 1
a6510 1
                outFile << dataLine << endl;
d6515 1
a6515 1
 cout << recCount << " records processed." << endl;
d6529 1
a6529 1
    const RWCString & fileName,
d6534 1
a6534 1
 RWCString pdf_PartName;
d6539 1
a6539 1
 RWCString dataLine;
d6544 2
a6545 2
 ifstream inFile;
 ofstream outFile;
d6555 1
a6555 1
 cout << "Processing " << fileName << ":\t" << flush;
d6588 1
a6588 1
    witGetPartProdBounds(theWitRun, pdf_PartName, &pvhLB, &pvsLB, &pvhUB);
d6590 2
a6591 1
    for (int t=0; t<nElementsChanged; t++) {
d6594 1
a6594 1
    witSetPartProdBounds(theWitRun, pdf_PartName, pvhLB, pvsLB, pvhUB);
d6598 1
a6598 1
//    cout << "Updated prodVol Soft Lower Bound  for " << pdf_PartName << "\n";
d6602 1
a6602 1
                outFile << dataLine << endl;
d6607 1
a6607 1
 cout << recCount << " records processed." << endl;
d6620 1
a6620 1
    const RWCString & fileName,
d6625 1
a6625 1
 RWCString pdf_PartName;
d6630 1
a6630 1
 RWCString dataLine;
d6635 2
a6636 2
 ifstream inFile;
 ofstream outFile;
d6646 1
a6646 1
 cout << "Processing " << fileName << ":\t" << flush;
d6678 1
a6678 1
    witGetPartProdBounds(theWitRun, pdf_PartName, &pvhLB, &pvsLB, &pvhUB);
d6681 2
a6682 1
    for (int t=0; t<nElementsChanged; t++) {
d6694 1
a6694 1
    witSetPartProdBounds(theWitRun, pdf_PartName, pvhLB, pvsLB, pvhUB);
d6698 1
a6698 1
//    cout << "Updated prodVol Hard Upper Bound  for " << pdf_PartName << "\n";
d6702 1
a6702 1
                outFile << dataLine << endl;
d6708 1
a6708 1
 cout << recCount << " records processed." << endl;
d6721 1
a6721 1
    const RWCString & fileName,
d6726 1
a6726 1
 RWCString pdf_OperationName;
d6731 1
a6731 1
 RWCString dataLine;
d6736 2
a6737 2
 ifstream inFile;
 ofstream outFile;
d6747 1
a6747 1
 cout << "Processing " << fileName << ":\t" << flush;
d6780 1
a6780 1
    witGetOperationExecBounds(theWitRun, pdf_OperationName, &hardLB, &softLB, &hardUB);
d6782 2
a6783 1
    for (int t=0; t<nElementsChanged; t++) {
d6786 1
a6786 1
    witSetOperationExecBounds(theWitRun, pdf_OperationName, hardLB, softLB, hardUB);
d6793 1
a6793 1
                outFile << dataLine << endl;
d6798 1
a6798 1
 cout << recCount << " records processed." << endl;
d6811 1
a6811 1
    const RWCString & fileName,
d6816 1
a6816 1
 RWCString pdf_OperationName;
d6821 1
a6821 1
 RWCString dataLine;
d6826 2
a6827 2
 ifstream inFile;
 ofstream outFile;
d6837 1
a6837 1
 cout << "Processing " << fileName << ":\t" << flush;
d6869 1
a6869 1
    witGetOperationExecBounds(theWitRun, pdf_OperationName, &hardLB, &softLB, &hardUB);
d6872 2
a6873 1
    for (int t=0; t<nElementsChanged; t++) {
d6885 1
a6885 1
    witSetOperationExecBounds(theWitRun, pdf_OperationName, hardLB, softLB, hardUB);
d6892 1
a6892 1
                outFile << dataLine << endl;
d6897 1
a6897 1
 cout << recCount << " records processed." << endl;
d6912 1
a6912 1
    const RWCString & fileName,
d6917 1
a6917 1
 RWCString pdf_PartName;
d6923 1
a6923 1
 RWCString dataLine;
d6928 2
a6929 2
 ifstream inFile;
 ofstream outFile;
d6940 1
a6940 1
 cout << "Processing " << fileName << ":\t" << flush;
d6960 1
a6960 1
    witGetPartCycleTime(theWitRun, pdf_PartName.data(), &ct);
d6962 2
a6963 1
    for (int t=start; t<=end; t++) {
d6966 1
a6966 1
    witSetPartCycleTime(theWitRun, pdf_PartName, ct);
d6968 1
a6968 1
//    cout << "Updated cycleTimes for " << pdf_PartName << "\n";
d6972 1
a6972 1
                outFile << dataLine << endl;
d6976 1
a6976 1
 cout << recCount << " records processed." << endl;
d6991 1
a6991 1
    const RWCString & fileName,
d6996 1
a6996 1
 RWCString pdf_PartName;
d7002 1
a7002 1
 RWCString dataLine;
d7007 2
a7008 2
 ifstream inFile;
 ofstream outFile;
d7018 1
a7018 1
 cout << "Processing " << fileName << ":\t" << flush;
d7038 1
a7038 1
    witGetPartYield(theWitRun, pdf_PartName.data(), &yield);
d7040 2
a7041 1
    for (int t=start; t<=end; t++) {
d7044 1
a7044 1
    witSetPartYield(theWitRun, pdf_PartName, yield);
d7046 1
a7046 1
//    cout << "Updated yields for " << pdf_PartName << "\n";
d7050 1
a7050 1
                outFile << dataLine << endl;
d7057 1
a7057 1
 cout << recCount << " records processed." << endl;
d7069 1
a7069 1
    const RWCString & fileName,
d7073 1
a7073 1
 RWCString pdf_OperationName;
d7079 1
a7079 1
 RWCString dataLine;
d7084 2
a7085 2
 ifstream inFile;
 ofstream outFile;
d7095 1
a7095 1
 cout << "Processing " << fileName << ":\t" << flush;
d7115 1
a7115 1
    witGetOperationYield(theWitRun, pdf_OperationName.data(), &yield);
d7117 2
a7118 1
    for (int t=start; t<=end; t++) {
d7121 1
a7121 1
    witSetOperationYield(theWitRun, pdf_OperationName, yield);
d7126 1
a7126 1
                outFile << dataLine << endl;
d7133 1
a7133 1
 cout << recCount << " records processed." << endl;
d7147 1
a7147 1
    const RWCString & fileName,
d7152 1
a7152 1
 RWCString pdf_PartName;
d7159 1
a7159 1
 RWCString dataLine;
d7164 2
a7165 2
 ifstream inFile;
 ofstream outFile;
d7175 1
a7175 1
 cout << "Processing " << fileName << ":\t" << flush;
d7195 2
a7196 2
    witGetPartMinLotSize(theWitRun, pdf_PartName.data(), &minLotSize);
    witGetPartIncLotSize(theWitRun, pdf_PartName.data(), &incLotSize);
d7198 2
a7199 1
    for (int t=start; t<=end; t++) {
d7203 2
a7204 2
    witSetPartMinLotSize(theWitRun, pdf_PartName, minLotSize);
    witSetPartIncLotSize(theWitRun, pdf_PartName, incLotSize);
d7207 1
a7207 1
//    cout << "Updated lot sizes for " << pdf_PartName << "\n";
d7211 1
a7211 1
                outFile << dataLine << endl;
d7218 1
a7218 1
 cout << recCount << " records processed." << endl;
d7232 1
a7232 1
    const RWCString & fileName,
d7236 1
a7236 1
 RWCString pdf_OperationName;
d7243 1
a7243 1
 RWCString dataLine;
d7248 2
a7249 2
 ifstream inFile;
 ofstream outFile;
d7259 1
a7259 1
 cout << "Processing " << fileName << ":\t" << flush;
d7279 2
a7280 2
    witGetOperationMinLotSize(theWitRun, pdf_OperationName.data(), &minLotSize);
    witGetOperationIncLotSize(theWitRun, pdf_OperationName.data(), &incLotSize);
d7282 2
a7283 1
    for (int t=start; t<=end; t++) {
d7287 2
a7288 2
    witSetOperationMinLotSize(theWitRun, pdf_OperationName, minLotSize);
    witSetOperationIncLotSize(theWitRun, pdf_OperationName, incLotSize);
d7294 1
a7294 1
                outFile << dataLine << endl;
d7300 1
a7300 1
 cout << recCount << " records processed." << endl;
d7314 1
a7314 1
    const RWCString & fileName,
d7318 1
a7318 1
 RWCString pdf_OperationName;
d7322 1
a7322 1
 RWCString dataLine;
d7327 2
a7328 2
 ifstream inFile;
 ofstream outFile;
d7338 1
a7338 1
 cout << "Processing " << fileName << ":\t" << flush;
d7360 1
a7360 1
    witSetOperationExecPenalty(theWitRun, pdf_OperationName.data(), execPenalty);
d7365 1
a7365 1
                outFile << dataLine << endl;
d7371 1
a7371 1
 cout << recCount << " records processed." << endl;
d7385 1
a7385 1
    const RWCString & fileName,
d7389 1
a7389 1
 RWCString pdf_OperationName;
d7395 1
a7395 1
 RWCString dataLine;
d7400 2
a7401 2
 ifstream inFile;
 ofstream outFile;
d7411 1
a7411 1
 cout << "Processing " << fileName << ":\t" << flush;
d7431 1
a7431 1
    witGetOperationObj1ExecCost(theWitRun, pdf_OperationName.data(), &execCost);
d7433 2
a7434 1
    for (int t=start; t<=end; t++) {
d7437 1
a7437 1
    witSetOperationObj1ExecCost(theWitRun, pdf_OperationName, execCost);
d7442 1
a7442 1
                outFile << dataLine << endl;
d7449 1
a7449 1
 cout << recCount << " records processed." << endl;
d7474 1
a7474 1
    RWCString fileName = setOfParameters.getString("calendarFile");
d7476 2
a7477 2
    ifstream inFile;
    ofstream outFile;
d7481 1
a7481 1
					  "geo source file",
d7495 2
a7496 2
	RWCString dataLine;
	RWCString token;
d7499 1
a7499 1
	dataLine.readToDelim(inFile);
d7503 2
a7504 2
	dataLine = dataLine.strip(RWCString::both);
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d7518 1
a7518 1
	RWCTokenizer next(dataLine);
d7524 1
a7524 1
	if (! RWLocale::global().stringToNum(token, &pd))  {
d7552 1
a7552 1
	if ((token = next(dataDelim)).isNull())    {
d7562 1
a7562 2
	RWDate theStartDate(flatFileManager.parseDateString(token, theCal));
	RWTime startDate(theStartDate);
d7598 1
a7598 1
                outFile << dataLine << endl;
d7605 1
a7605 1
	if ((token = next(dataDelim)).isNull())    {
d7615 1
a7615 1
	else if (! RWLocale::global().stringToNum(token, &wu))  {
d7642 1
a7642 1
            outFile << dataLine << endl;
d7673 1
a7673 1
    const RWCString & geoSourceFile,
d7676 1
a7676 1
    RWBoolean createMfgPart)
d7690 1
a7690 1
    RWCString engine = setOfParameters.getString("engine");
d7692 1
a7692 1
    RWCString fileName(geoSourceFile);
d7694 2
a7695 2
    ifstream inFile;
    ofstream outFile;
d7698 1
a7698 1
    inFile.open(fileName, ios::in);
d7715 1
a7715 1
    cout << "Processing " << fileName << ":\t" << flush;
d7722 5
a7726 5
    RWCString dataLine;
    RWCString plannerPartName;
    RWCString geo;
    RWCString partName;
    RWCString pdf;
d7738 1
a7738 1
	dataLine.readToDelim(inFile);
d7742 1
a7742 1
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d7756 1
a7756 1
	RWCTokenizer next(dataLine);
d7793 1
a7793 1
	flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
d7798 1
a7798 1
	RWCString geoPlannerDemandPartName = 
d7800 1
a7800 1
	RWCString pdfPartname = mpHelper.pdfPartname(partName, pdf);
d7811 1
a7811 1
	    // if createMfgPart is TRUE, then we want to create the child
d7857 1
a7857 1
            RWCString geoPlannerDemandUbPartName =
d7897 1
a7897 1
            outFile << dataLine << endl;
d7905 1
a7905 1
    cout << recCount << " records processed." << endl;
d7918 1
a7918 1
    const RWCString & fileName,
d7922 3
a7924 3
    RWCString operationName;
    RWCString pdf;
    RWCString dataLine;
d7931 2
a7932 2
    ifstream inFile;
    ofstream outFile;
d7942 1
a7942 1
    cout << "Processing " << fileName << ":\t" << flush;
d7949 1
a7949 1
	dataLine.readToDelim(inFile);
d7953 2
a7954 2
	dataLine = dataLine.strip(RWCString::both);
	if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d7965 1
a7965 1
	RWCTokenizer next(dataLine);
d7996 1
a7996 1
                outFile << dataLine << endl;
d8004 1
a8004 1
    cout << recCount << " records processed." << endl;
d8016 2
a8017 2
                     RWCString & geoPlannerDemandPartName,   // special partname for  this demand
                     RWCString & geo,                  // demandName to be returned
d8019 3
a8021 3
                     istream & inFile,                 // An open stream
                     const RWCString & fileName,       // for messaging
                     RWCString & dataLine,
d8024 1
a8024 1
                     RWBoolean Mandatory,              // Are all elements mandatory?
d8027 1
a8027 1
                     RWBoolean addDemandIfFound)       // Add demand stream if not there
d8029 1
a8029 1
  RWCString plannerPartName;
d8034 1
a8034 1
  dataLine.readToDelim(inFile);
d8037 1
a8037 1
  dataLine = dataLine.strip(RWCString::both);
d8040 1
a8040 1
  if ((dataLine.index("*") == 0) || dataLine.isNull())
d8045 1
a8045 1
  RWCTokenizer next(dataLine);
d8087 1
a8087 1
    RWCString pdfPartname = mpHelper.pdfPartname(plannerPartName, 
d8173 1
a8173 1
      witAddDemand( theWitRun, geoPlannerDemandPartName, geo );
d8178 2
a8179 2
                          geoPlannerDemandPartName, 
                          geo, 
d8182 4
a8185 4
      witSetDemandPriority( theWitRun, geoPlannerDemandPartName,
                            geo, defaultPriorityVec );
      witSetDemandShipLateLimit( theWitRun, geoPlannerDemandPartName,
                                 geo, defaultShipLateLimit );
d8189 1
a8189 1
      if ( lpModelHelper_ != NULL ) {
d8206 4
a8209 4
        witSetDemandObj1ShipReward( theWitRun, geoPlannerDemandPartName,
                                    geo, defaultObj1ShipRewardVec);
        witSetDemandObj1CumShipReward( theWitRun, geoPlannerDemandPartName,
                                       geo, defaultObj1CumShipRewardVec);
d8231 1
a8231 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, FALSE);
d8243 1
a8243 1
RWBoolean
d8245 1
a8245 1
    const RWCString & targetFile)
d8247 1
a8247 1
    ifstream inFile;
d8249 1
a8249 1
    inFile.open(targetFile, ios::in);
d8253 1
a8253 1
	return TRUE;
d8256 1
a8256 1
    return FALSE;
d8266 2
a8267 2
    const RWCString &  partName,
    const RWCString &  demandName)
d8276 1
a8276 1
  witGetPartExists(theWitRun, partName, &exists);
d8281 1
a8281 1
  witGetPartDemands(theWitRun, partName, &nDemands, &demandList);
d8314 2
a8315 2
    const RWCString & part, 
    const RWCString & pdf,
d8317 2
a8318 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8321 1
a8321 1
    RWCString partName = mpHelper.pdfPartname(part, pdf);
d8343 1
a8343 1
    witAddPartWithOperation(theWitRun, partName);
d8350 1
a8350 1
    witSetBopEntryAppData( theWitRun, partName, 0, (void *) myBadPtr );
d8355 2
a8356 1
    for (int t=0; t<nPeriods; t++)
d8359 2
a8360 2
    witSetOperationIncLotSize(theWitRun, partName, vecOfOnes);
    witSetOperationMinLotSize(theWitRun, partName, vecOfOnes);
d8364 1
a8364 1
    if (lpModelHelper_ != NULL) {
d8374 2
a8375 1
      for (int t=1; t<nPeriods; t++)
d8378 1
a8378 1
      witSetOperationObj1ExecCost(theWitRun, partName, obj1ProdCost);
d8395 2
a8396 2
    const RWCString & capacity, 
    const RWCString & pdf,
d8398 2
a8399 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8402 1
a8402 1
    RWCString capacityName = mpHelper.pdfPartname(capacity, pdf);
d8414 1
a8414 1
    witAddPart(theWitRun, capacityName, WitCAPACITY);
d8428 2
a8429 2
    const RWCString & operationName, 
    const RWCString & pdf,
d8431 2
a8432 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8435 1
a8435 1
    RWCString pdfOperationName = mpHelper.pdfOperationName(operationName, pdf);
d8459 1
a8459 1
    witAddOperation(theWitRun, pdfOperationName.data());
d8465 2
a8466 1
    for (int t=0; t<nPeriods; t++)
d8468 2
a8469 2
    witSetOperationMinLotSize(theWitRun, pdfOperationName.data(), vecOfOnes);
    witSetOperationIncLotSize(theWitRun, pdfOperationName.data(), vecOfOnes);
d8472 1
a8472 1
    if (lpModelHelper_ != NULL) {
d8485 1
a8485 1
      witSetOperationObj1ExecCost(theWitRun, pdfOperationName.data(), obj1ExecCost);
d8502 4
a8505 4
    const RWCString & producedPart, 
    const RWCString & producedPartPdf,
    const RWCString & operation, 
    const RWCString & operationPdf, 
d8513 2
a8514 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8521 2
a8522 2
    RWCString pdfProducedPartName( mpHelper.pdfPartname(producedPart, producedPartPdf) );
    RWCString pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );
d8536 1
a8536 1
    witGetOperationNBopEntries( theWitRun, pdfOperationName, &bopEntryIndex);
d8541 3
a8543 2
    RWBoolean isOperationAlreadyUsedbyProducedPart = FALSE;
    for (int b=0; b<bopEntryIndex; b++) {
d8545 1
a8545 1
      witGetBopEntryProducedPart(theWitRun, pdfOperationName, b, &ppName);
d8547 1
a8547 1
        isOperationAlreadyUsedbyProducedPart = TRUE;
d8558 2
a8559 2
      witGetPartAppData(theWitRun, pdfProducedPartName, (void **) &custPartAppData);
      if (custPartAppData == NULL) {
d8562 1
a8562 1
        witSetPartAppData(theWitRun, pdfProducedPartName, (void *) custPartAppData);
d8571 2
a8572 2
    witAddBopEntry( theWitRun, pdfOperationName, pdfProducedPartName );
    witSetBopEntryProdRate( theWitRun, pdfOperationName, bopEntryIndex, prodRate );
d8575 3
a8577 2
    witGetBopEntryOffset( theWitRun, pdfOperationName, bopEntryIndex, &offsetTimeVec );
    for (int i=early; i<=late; i++)
d8579 1
a8579 1
    witSetBopEntryOffset( theWitRun, pdfOperationName, bopEntryIndex, offsetTimeVec );
d8581 2
a8582 2
    witSetBopEntryEarliestPeriod( theWitRun, pdfOperationName, bopEntryIndex, early );
    witSetBopEntryLatestPeriod( theWitRun, pdfOperationName, bopEntryIndex, late );
d8596 2
a8597 2
    witGetBopEntryAppData( theWitRun, pdfOperationName, bopEntryIndex, (void **) &myBadPtr );
    if ( myBadPtr != NULL ) {
d8610 1
a8610 1
                           pdfOperationName,
d8615 1
a8615 1
    //   witSetBopEntryExpAllowed(theWitRun, pdfOperationName, bopEntryIndex, WitTRUE);
d8617 2
a8618 2
  witSetBopEntryExpAllowed(theWitRun, pdfOperationName, bopEntryIndex, isBuildable);
  witSetBopEntryExpAversion(theWitRun, pdfOperationName, bopEntryIndex, pref);
d8632 4
a8635 4
    const RWCString & operation, 
    const RWCString & operationPdf,
    const RWCString & consumedPart, 
    const RWCString & consumedPartPdf, 
d8641 2
a8642 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8645 2
a8646 2
    RWCString pdfConsumedPartName( mpHelper.pdfPartname(consumedPart, consumedPartPdf) );
    RWCString pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );
d8658 3
a8660 3
    witGetOperationNBomEntries( theWitRun, pdfOperationName, &bomEntryIndex);
    witAddBomEntry( theWitRun, pdfOperationName, pdfConsumedPartName );
    witSetBomEntryUsageRate( theWitRun, pdfOperationName, bomEntryIndex, usageRate );
d8663 3
a8665 2
    witGetBomEntryOffset( theWitRun, pdfOperationName, bomEntryIndex, &offsetTimeVec );
    for (int i=early; i<=late; i++)
d8667 4
a8670 4
    witSetBomEntryOffset( theWitRun, pdfOperationName, bomEntryIndex, offsetTimeVec );
    witSetBomEntryEarliestPeriod( theWitRun, pdfOperationName, bomEntryIndex, early );
    witSetBomEntryLatestPeriod( theWitRun, pdfOperationName, bomEntryIndex, late );
    witSetBomEntryFallout( theWitRun, pdfOperationName, bomEntryIndex, fallout );
d8684 2
a8685 2
    const RWCString & part, 
    const RWCString & pdf,
d8687 2
a8688 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8691 1
a8691 1
    cerr << "sceAddAggregatePart() not implemented yet\n\n";
d8698 1
a8698 1
    const RWCString & fullPartname, 
d8700 2
a8701 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8704 1
a8704 1
    witAddPartWithOperation(theWitRun, fullPartname);
d8711 1
a8711 1
      defSOP.insert(partToBeAdded);
d8715 1
a8715 1
      intrPlant.insert(partToBeAdded);
d8727 1
a8727 1
    const RWCString & fullPartname, 
d8729 2
a8730 2
    const RWCString & fileName,
    const RWCString & dataLine,
d8733 1
a8733 1
    witAddPart(theWitRun, fullPartname, WitRAW);
d8779 4
a8782 4
                                                    const RWCString & destinationPart,
                                                    const RWCString & destinationPdf,
                                                    const RWCString & sourcePart, 
                                                    const RWCString & sourcePdf,
d8792 2
a8793 2
                                                    const RWCString & fileName,
                                                    const RWCString & dataLine,
d8797 1
a8797 1
  witBoolean isUnique = TRUE;
d8802 2
a8803 2
  RWCString fullDestinationPartName(mpHelper.pdfPartname(destinationPart, destinationPdf));
  RWCString fullSourcePartName( mpHelper.pdfPartname(sourcePart,  sourcePdf));
d8820 1
a8820 1
  RWCString interPlantOperationName =
d8824 1
a8824 1
  witGetOperationExists(theWitRun, interPlantOperationName, &exists);
d8849 5
a8853 5
    witAddOperation( theWitRun, interPlantOperationName );
    witSetOperationMinLotSize( theWitRun, interPlantOperationName, defaultLotSize );
    witSetOperationIncLotSize( theWitRun, interPlantOperationName, defaultLotSize );
    witAddBomEntry( theWitRun, interPlantOperationName, fullSourcePartName );
    witSetBomEntryUsageRate( theWitRun, interPlantOperationName, 0, usageRate );
d8856 2
a8857 2
    witSetBomEntryEarliestPeriod( theWitRun, interPlantOperationName, 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, interPlantOperationName, 0, nPeriods-1 );
d8859 1
a8859 1
      witSetBomEntryExecPenalty(theWitRun, interPlantOperationName, 0, preference);
d8866 2
a8867 2
    witGetPartAppData(theWitRun, fullDestinationPartName, (void **) &custPartAppData);
    if (custPartAppData == NULL) {
d8870 1
a8870 1
      witSetPartAppData(theWitRun, fullDestinationPartName, (void *) custPartAppData);
d8879 2
a8880 2
    // set unique flag = FALSE
    isUnique = FALSE;
d8913 1
a8913 1
  witGetOperationNBomEntries(theWitRun, interPlantOperationName, &nBom);
d8921 3
a8923 3
  witGetOperationNBopEntries( theWitRun, interPlantOperationName, &nbBop );      
  witAddBopEntry( theWitRun, interPlantOperationName, fullDestinationPartName );
  witSetBopEntryEarliestPeriod( theWitRun, interPlantOperationName,
d8925 1
a8925 1
  witSetBopEntryLatestPeriod( theWitRun, interPlantOperationName,
d8931 1
a8931 1
  witGetBomEntryOffset(theWitRun, interPlantOperationName, 0, &offset);
d8934 1
a8934 1
  witSetBomEntryOffset(theWitRun, interPlantOperationName, 0, offset);
d8942 2
a8943 2
  witGetOperationMinLotSize( theWitRun, interPlantOperationName, &interPlantMinLotSize );
  witGetOperationIncLotSize( theWitRun, interPlantOperationName, &interPlantIncLotSize );
d8950 2
a8951 2
  witSetOperationMinLotSize(theWitRun, interPlantOperationName, interPlantMinLotSize);
  witSetOperationIncLotSize(theWitRun, interPlantOperationName, interPlantIncLotSize);
d8960 2
a8961 2
  witGetBopEntryAppData( theWitRun, interPlantOperationName, nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != NULL ) {
d8975 1
a8975 1
  witSetBopEntryAppData( theWitRun, interPlantOperationName,
d8982 2
a8983 2
  witSetBopEntryExpAllowed(theWitRun, interPlantOperationName, nbBop, isInterplantExplodeableAsSubstitute);
  witSetBopEntryExpAversion(theWitRun, interPlantOperationName, nbBop, preference);
d8985 1
a8985 1
  if ( lpModelHelper_ != NULL ) {    
d8987 1
a8987 1
    witGetOperationObj1ExecCost(theWitRun, interPlantOperationName, &opExecCost);
d8990 1
a8990 1
    witSetOperationObj1ExecCost(theWitRun, interPlantOperationName, opExecCost);
d9034 4
a9037 4
                                                    const RWCString & markedPart,
                                                    const RWCString & markedPdf,
                                                    const RWCString & unmarkedPart, 
                                                    const RWCString & unmarkedPdf,
d9047 2
a9048 2
                                                    const RWCString & fileName,
                                                    const RWCString & dataLine,
d9052 1
a9052 1
  witBoolean isUnique = TRUE;
d9057 2
a9058 2
  RWCString fullmarkedPartName(mpHelper.pdfPartname(markedPart, markedPdf));
  RWCString fullunmarkedPartName( mpHelper.pdfPartname(unmarkedPart,  unmarkedPdf));
d9075 1
a9075 1
  RWCString binOperationName =
d9079 1
a9079 1
  witGetOperationExists(theWitRun, binOperationName, &exists);
d9104 5
a9108 5
    witAddOperation( theWitRun, binOperationName );
    witSetOperationMinLotSize( theWitRun, binOperationName, defaultLotSize );
    witSetOperationIncLotSize( theWitRun, binOperationName, defaultLotSize );
    witAddBomEntry( theWitRun, binOperationName, fullunmarkedPartName );
    witSetBomEntryUsageRate( theWitRun, binOperationName, 0, usageRate );
d9111 2
a9112 2
    witSetBomEntryEarliestPeriod( theWitRun, binOperationName, 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, binOperationName, 0, nPeriods-1 );
d9118 2
a9119 2
    witGetPartAppData(theWitRun, fullmarkedPartName, (void **) &custPartAppData);
    if (custPartAppData == NULL) {
d9122 1
a9122 1
      witSetPartAppData(theWitRun, fullmarkedPartName, (void *) custPartAppData);
d9131 2
a9132 2
    // set unique flag = FALSE
    isUnique = FALSE;
d9165 1
a9165 1
  witGetOperationNBomEntries(theWitRun, binOperationName, &nBom);
d9173 3
a9175 3
  witGetOperationNBopEntries( theWitRun, binOperationName, &nbBop );      
  witAddBopEntry( theWitRun, binOperationName, fullmarkedPartName );
  witSetBopEntryEarliestPeriod( theWitRun, binOperationName,
d9177 1
a9177 1
  witSetBopEntryLatestPeriod( theWitRun, binOperationName,
d9183 1
a9183 1
  witGetBomEntryOffset(theWitRun, binOperationName, 0, &offset);
d9186 1
a9186 1
  witSetBomEntryOffset(theWitRun, binOperationName, 0, offset);
d9194 2
a9195 2
  witGetOperationMinLotSize( theWitRun, binOperationName, &binMinLotSize );
  witGetOperationIncLotSize( theWitRun, binOperationName, &binIncLotSize );
d9202 2
a9203 2
  witSetOperationMinLotSize(theWitRun, binOperationName, binMinLotSize);
  witSetOperationIncLotSize(theWitRun, binOperationName, binIncLotSize);
d9212 2
a9213 2
  witGetBopEntryAppData( theWitRun, binOperationName, nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != NULL ) {
d9229 1
a9229 1
  witSetBopEntryAppData( theWitRun, binOperationName,
d9236 2
a9237 2
  witSetBopEntryExpAllowed(theWitRun, binOperationName, nbBop, isBinExplodeableAsSubstitute);
  witSetBopEntryExpAversion(theWitRun, binOperationName, nbBop, preference);
d9272 3
a9274 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & bbCategory, 
d9279 2
a9280 2
    const RWCString & fileName,
    const RWCString & dataLine,
d9290 1
a9290 1
    RWCString fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
d9309 1
a9309 1
    RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d9330 2
a9331 1
    for (int t=0; t<nPeriods; t++)  
d9342 5
a9346 5
    witAddPartWithOperation( theWitRun, fullBbCategoryPart);
    witSetBopEntryExpAversion(theWitRun, fullBbCategoryPart, 0, -999999.0);
    if ( lpModelHelper_ != NULL) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart, featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart, featureSetScrapPenaltyVec );
d9355 1
a9355 1
    witAddBomEntry(theWitRun, geoPlannerDemandPart, fullBbCategoryPart);
d9373 3
a9375 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & bbCategory, 
d9380 2
a9381 2
    const RWCString & fileName,
    const RWCString & dataLine,
d9391 1
a9391 1
    RWCString fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
d9410 1
a9410 1
    RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d9431 2
a9432 1
    for (int t=0; t<nPeriods; t++)  
d9441 4
a9444 4
    witAddPartWithOperation( theWitRun, fullBbCategoryPart );
    if ( lpModelHelper_ != NULL) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart, featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart, featureSetScrapPenaltyVec );
d9452 1
a9452 1
    witAddBomEntry(theWitRun, geoPlannerDemandPart, fullBbCategoryPart);
d9457 1
a9457 1
    RWCString LTbbCapacityPartName = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
d9459 1
a9459 1
    RWCString GTbbCapacityPartName = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
d9472 2
a9473 2
    witAddPart(theWitRun, LTbbCapacityPartName, WitCAPACITY);
    witAddPart(theWitRun, GTbbCapacityPartName, WitCAPACITY);
d9475 2
a9476 2
    witSetPartSupplyVol(theWitRun, GTbbCapacityPartName, infiniteCapacity);
    witSetPartSupplyVol(theWitRun, LTbbCapacityPartName, infiniteCapacity);
d9483 1
a9483 1
    witAddBomEntryVa(theWitRun, fullBbCategoryPart, LTbbCapacityPartName,
d9485 2
a9486 2
		     NULL);
    witAddBomEntryVa(theWitRun, fullBbCategoryPart, GTbbCapacityPartName,
d9488 1
a9488 1
		     NULL);
d9509 4
a9512 4
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & bbCategory, 
    const RWCString & mfgOptionPart, 
d9515 2
a9516 2
    const RWCString & fileName,
    const RWCString & dataLine,
d9526 3
a9528 3
    RWBoolean nullOption = FALSE;
    if (0 == mfgOptionPart.compareTo("nullOption", RWCString::ignoreCase))
      nullOption = TRUE;
d9531 1
a9531 1
    RWCString fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
d9551 2
a9552 1
    for (int t=0; t<nPeriods; t++)
d9574 1
a9574 1
    RWCString optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
d9578 1
a9578 1
    RWCString optionRatioSupply = 
d9622 1
a9622 1
    RWCString mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d9634 1
a9634 1
    RWCString pdf(mpHelper.pdf(mfgTopLevelPart));
d9637 1
a9637 1
    RWCString fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d9674 1
a9674 1
    witAddPartWithOperation(theWitRun, optionDummy);
d9678 1
a9678 1
      if ( lpModelHelper_ != NULL )  {
d9684 2
a9685 1
        for (int t=0; t<nPeriods; t++)  
d9687 1
a9687 1
        witSetOperationObj1ExecCost( theWitRun, optionDummy, optionDummyExecCost );
d9697 2
a9698 2
    witGetOperationNBomEntries(theWitRun, fullBbCategoryPart, &nBomBBCat);
    witAddBomEntry(theWitRun, fullBbCategoryPart, optionDummy);      
d9700 1
a9700 1
    witSetBomEntryUsageRate(theWitRun, fullBbCategoryPart, nBomBBCat, featureRatio[0]);
d9714 1
a9714 1
    witAddPart( theWitRun, optionRatioSupply, WitMATERIAL );
d9716 1
a9716 1
    if ( lpModelHelper_ != NULL )   {
d9720 2
a9721 1
        for (int t=0; t<nPeriods; t++)  
d9723 1
a9723 1
        witSetPartObj1StockCost( theWitRun, optionRatioSupply,
d9733 3
a9735 2
    witGetPartCycleTime(theWitRun, mfgTopLevelPart, &optionOffsets);
    for (int tt=0; tt<nPeriods; tt++)
d9741 1
a9741 1
    witAddBomEntry(theWitRun, optionDummy, optionRatioSupply);
d9753 5
a9757 5
      witGetOperationNBomEntries(theWitRun, optionDummy, &nBomSOD);
      witAddBomEntry(theWitRun, optionDummy, fullOptionPartName);
      witSetBomEntryUsageRate(theWitRun, optionDummy, nBomSOD, usageRate);
      witSetBomEntryOffset(theWitRun, optionDummy, nBomSOD, optionOffsets);
      witSetBomEntryMandEC(theWitRun, optionDummy, nBomSOD, WitTRUE);
d9764 1
a9764 1
    witAddBomEntry(theWitRun, optionDummy, fullOptionPartName);
d9767 2
a9768 2
    witSetBomEntryUsageRate(theWitRun, optionDummy, nBomSOD, usageRate);
    witSetBomEntryOffset(theWitRun, optionDummy, nBomSOD, optionOffsets);
d9770 2
a9771 2
    // witSetBomEntryEarliestPeriod(theWitRun, optionDummy, nBomSOD, sourceBeginPeriod);
    // witSetBomEntryLatestPeriod(theWitRun, optionDummy, nBomSOD, sourceEndPeriod);
d9802 4
a9805 4
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & bbCategory, 
    const RWCString & mfgOptionPart, 
d9808 2
a9809 2
    const RWCString & fileName,
    const RWCString & dataLine,
d9818 3
a9820 3
    RWBoolean nullOption = FALSE;
    if (0 == mfgOptionPart.compareTo("nullOption", RWCString::ignoreCase))
      nullOption = TRUE;
d9823 1
a9823 1
    RWCString fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
d9844 2
a9845 1
    for (int t=0; t<nPeriods; t++)
d9867 1
a9867 1
    RWCString optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
d9871 1
a9871 1
    RWCString optionRatioSupply = 
d9904 1
a9904 1
                   NULL);
d9916 1
a9916 1
      witAddPartWithOperation( theWitRun, optionDummy );
d9919 2
a9920 2
      if ( lpModelHelper_ != NULL )
        witSetOperationObj1ExecCost( theWitRun, optionDummy, optionDummyProdCost );
d9942 2
a9943 1
      for (int t=ratioBeginPeriod; t<nPeriods; t++) {
d9951 1
a9951 1
      witAddBomEntryVa(theWitRun, fullBbCategoryPart, optionDummy,
d9955 1
a9955 1
                       NULL);
d9982 4
a9985 4
    witAddPart( theWitRun, optionRatioSupply, WitMATERIAL );
    //     witAddPartWithOperation( theWitRun, optionRatioSupply );
    if ( lpModelHelper_ != NULL )
      witSetPartObj1StockCost( theWitRun, optionRatioSupply,
d9993 1
a9993 1
    witAddBomEntry(theWitRun, optionDummy, optionRatioSupply);
d10007 1
a10007 1
        RWCString mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d10019 1
a10019 1
        RWCString pdf(mpHelper.pdf(mfgTopLevelPart));
d10022 1
a10022 1
        RWCString fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d10051 2
a10052 2
        witGetPartCycleTime(theWitRun, mfgTopLevelPart, &mfgTopLevelCycleTime);
        RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10056 1
a10056 1
        witAddBomEntryVa(theWitRun, optionDummy, fullOptionPartName,
d10062 1
a10062 1
                         NULL);
d10073 1
a10073 1
    RWCString myLTpart = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
d10076 1
a10076 1
    RWCString myGTpart = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
d10079 1
a10079 1
    witAddBomEntryVa(theWitRun, optionDummy, myLTpart,
d10081 1
a10081 1
		     NULL);
d10083 1
a10083 1
    witAddBomEntryVa(theWitRun, optionDummy, myGTpart,
d10085 1
a10085 1
		     NULL);
d10093 1
a10093 1
    witSetPartSupplyVol(theWitRun, optionRatioSupply, featureRatio);    
d10105 3
a10107 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & mfgOptionPart, 
d10110 2
a10111 2
    const RWCString & fileName,
    const RWCString & dataLine,
d10122 1
a10122 1
  RWBoolean foundMatch = FALSE;
d10127 1
a10127 1
  RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10142 3
a10144 2
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart, &nBom);
  for (int j=0; j<nBom; j++) {
d10146 2
a10147 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart, j, &child);
    RWCString pp, g, bb;
d10150 1
a10150 1
      RWCString optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
d10154 3
a10156 3
        if ( lpModelHelper_ != NULL) 
          witSetOperationObj1ExecCost(theWitRun, optionDummy, featureRev);
	witSetBopEntryExpAversion(theWitRun, optionDummy, 0, -featureRev[0]);
d10169 1
a10169 1
      RWCString childPart = mpHelper.partname(child);
d10171 1
a10171 1
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart, j, &nSubs);
d10174 2
a10175 1
        for (int t=0; t<nPeriods; t++)
d10177 3
a10179 3
        if (lpModelHelper_ != NULL) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart, j, 0, featureRev);
        foundMatch = TRUE;  
d10204 3
a10206 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & mfgOptionPart, 
d10209 2
a10210 2
    const RWCString & fileName,
    const RWCString & dataLine,
d10220 1
a10220 1
  RWBoolean foundMatch = FALSE;
d10225 1
a10225 1
  RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10245 3
a10247 2
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPart, &nBom);
  for (int j=0; j<nBom; j++) {
d10249 2
a10250 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart, j, &child);
    RWCString pp, g, bb;
d10253 1
a10253 1
      RWCString optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
d10257 2
a10258 2
        if ( lpModelHelper_ != NULL) 
          witSetPartObj1ProdCost(theWitRun, optionDummy, featureRev);
d10271 1
a10271 1
      RWCString childPart = mpHelper.partname(child);
d10273 1
a10273 1
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart, j, &nSubs);
d10276 2
a10277 1
        for (int t=0; t<nPeriods; t++)
d10279 3
a10281 3
        if (lpModelHelper_ != NULL) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart, j, 0, featureRev);
        foundMatch = TRUE;  
d10308 3
a10310 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & mfgOptionPart, 
d10312 2
a10313 2
    const RWCString & fileName,
    const RWCString & dataLine,
d10326 1
a10326 1
  RWCString geoPlannerDemandPart =
d10348 1
a10348 1
    RWCString mfgTopLevelBuild = mpHelper.demandSource(theWitRun, 
d10358 1
a10358 1
    RWCString pdf = mpHelper.pdf(mfgTopLevelBuild);
d10363 1
a10363 1
    RWCString specialFeaturePartName;
d10370 1
a10370 1
    witGetPartExists(theWitRun, specialFeaturePartName, &exists);
d10380 1
a10380 1
      witGetPartExists(theWitRun, specialFeaturePartName, &exists);
d10397 3
a10399 2
    witGetPartSupplyVol(theWitRun, specialFeaturePartName, &supVol);
    for (int t=start; t<=late; t++) {
d10402 1
a10402 1
    witSetPartSupplyVol(theWitRun, specialFeaturePartName, supVol);
d10419 3
a10421 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & mfgOptionPart, 
d10426 2
a10427 2
    const RWCString & fileName,
    const RWCString & dataLine,
d10440 1
a10440 1
  RWCString geoPlannerDemandPart =
d10456 1
a10456 1
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart, &nBomEntries );
d10462 4
a10465 3
  RWBoolean didWeFindAValidFeatureRelationship = FALSE;
  RWCString pdf;
  for (int j=0; j<nBomEntries; j++) {
d10467 2
a10468 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart, j, &specialFeaturePartName);
    RWCString mfgop;
d10471 1
a10471 1
    RWCString gg, mm;
d10484 2
a10485 2
    // at this point you have a match with plannerPart,geo,mfgOptionPart.
    didWeFindAValidFeatureRelationship = TRUE;
d10493 2
a10494 1
    for (int t=start; t<=end; t++) {
d10500 1
a10500 1
      RWCString realFeaturePartName = mpHelper.pdfPartname(mfgop, pdf);
d10502 1
a10502 1
      witGetPartExists(theWitRun, realFeaturePartName, &exists);
d10505 3
a10507 2
      witGetPartCycleTime(theWitRun, realFeaturePartName, &realFeatureCycleTime);
      for (int t=start; t<=end; t++) {
d10544 3
a10546 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & featurePart, 
d10550 2
a10551 2
    const RWCString & fileName,
    const RWCString & dataLine,
d10676 1
a10676 1
  RWCString geoPlannerDemandPart =
d10701 1
a10701 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart, &nBomEntries );
d10704 3
a10706 2
  for (int j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart, j, &child );
d10764 1
a10764 1
  RWCString machineFullWitPart = mpHelper.demandSource(theWitRun,
d10777 1
a10777 1
  RWCString pdf(mpHelper.pdf(machineFullWitPart));
d10780 1
a10780 1
  RWCString fullFeaturePart(mpHelper.pdfPartname(featurePart, pdf));
d10805 1
a10805 1
  RWCString specialCCFeaturePartName(mpHelper.custChoiceFeaturePartName(plannerTopLevelPart, 
d10816 1
a10816 1
    witAddPartWithOperation(theWitRun, specialCCFeaturePartName);
d10819 1
a10819 1
    witAddBomEntry(theWitRun, specialCCFeaturePartName, fullFeaturePart);
d10827 4
a10830 4
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart, &bomIndex );
  witAddBomEntry( theWitRun, geoPlannerDemandPart, specialCCFeaturePartName);
  witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart, bomIndex, usageRate);
  witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart, bomIndex, WitFALSE );
d10834 1
a10834 1
  witSetBomEntryAppData(theWitRun, geoPlannerDemandPart, bomIndex, (void *) bomAppDataPtr);
d10845 1
a10845 1
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPart, 0, &transitTimeOffset);
d10850 1
a10850 1
  witGetPartCycleTime(theWitRun, machineFullWitPart, &machineCycleTime);
d10855 1
a10855 1
  witSetBomEntryOffset(theWitRun, specialCCFeaturePartName, 0, machineCycleTime);
d10857 1
a10857 1
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPart, bomIndex, transitTimeOffset);
d10866 1
a10866 1
  RWCString ccNullSubstitute;
d10872 1
a10872 1
  witAddPart(theWitRun, ccNullSubstitute, WitMATERIAL);
d10877 1
a10877 1
  witSetPartSupplyVol(theWitRun, ccNullSubstitute, featureRatio);
d10885 2
a10886 2
  witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart, bomIndex, &nSubBom);
  witAddSubsBomEntry( theWitRun, geoPlannerDemandPart, bomIndex, ccNullSubstitute );
d10889 1
a10889 1
  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart, bomIndex, nSubBom, transitTimeOffset);
d10892 1
a10892 1
  witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart, bomIndex, nSubBom, WitFALSE);
d10895 2
a10896 2
  if ( lpModelHelper_ != NULL )
    witSetSubsBomEntryObj1SubCost ( theWitRun, geoPlannerDemandPart, bomIndex, nSubBom,
d10908 3
a10910 3
  RWCString returnedPlannerTopLevelPart;
  RWCString returnedGeo;
  RWCString demandName = mpHelper.custChoiceFeatureDemandName( geoPlannerDemandPart );
d10916 1
a10916 1
    witAddDemand ( theWitRun, specialCCFeaturePartName, demandName );
d10922 1
a10922 1
    RWCString engine = setOfParameters.getString("calendarFormat");
d10926 3
a10928 2
      witGetDemandDemandVol(theWitRun, specialCCFeaturePartName, demandName, &bigMdemandVol);
      for (int t=0; t<nPeriods; t++)
d10930 1
a10930 1
      witSetDemandDemandVol(theWitRun, specialCCFeaturePartName, demandName, bigMdemandVol);
d10948 3
a10950 3
    const RWCString & plannerTopLevelPart, 
    const RWCString & geo,
    const RWCString & mfgOptionPart, 
d10956 2
a10957 2
    const RWCString & fileName,
    const RWCString & dataLine,
d11019 1
a11019 1
  RWCString geoPlannerDemandPart =
d11040 1
a11040 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart, &nBomEntries );
d11043 6
a11048 5
  for (int j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart, j, &child );
    RWCString pdf;
    RWCString featurePart;
    RWCString gg, mm;
d11073 2
a11074 1
  for (int t=0; t<nPeriods; t++)
d11095 2
a11096 1
    for (int t= 0; t<firstPeriodWithRatio; t++) {
d11116 2
a11117 1
    for (int t=intervalStartPeriod; t<nPeriods; t++) {
d11135 1
a11135 1
    RWCString mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d11152 1
a11152 1
    RWCString pdf(mpHelper.pdf(mfgTopLevelPart));
d11155 1
a11155 1
    RWCString fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d11181 1
a11181 1
    RWCString specialFeaturePartName(mpHelper.standaloneFeaturePartName(plannerTopLevelPart, 
d11191 1
a11191 1
      witAddPartWithOperation(theWitRun, specialFeaturePartName);
d11198 2
a11199 2
      witSetOperationMinLotSize(theWitRun, specialFeaturePartName, nonIntLotSize.data());
      witSetOperationIncLotSize(theWitRun, specialFeaturePartName, nonIntLotSize.data());
d11203 1
a11203 1
      witAddBomEntry(theWitRun, specialFeaturePartName, fullOptionPartName);
d11209 4
a11212 4
    witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart, &bomIndex );
    witAddBomEntry( theWitRun, geoPlannerDemandPart, specialFeaturePartName);
    witSetBomEntryEarliestPeriod ( theWitRun, geoPlannerDemandPart, bomIndex,  intervalStartPeriod );
    witSetBomEntryLatestPeriod ( theWitRun, geoPlannerDemandPart, bomIndex,  intervalEndPeriod );
d11214 2
a11215 2
    witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart, bomIndex, finalUsageRate );
    witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart, bomIndex, WitFALSE );
d11225 2
a11226 2
    witGetBopEntryOffset(theWitRun, geoPlannerDemandPart, 0, &transitTimeOffset);
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart, 0, transitTimeOffset);
d11231 1
a11231 1
    witGetPartCycleTime(theWitRun, mfgTopLevelPart, &mfgTopLevelCycleTime);
d11236 1
a11236 1
    witSetBomEntryOffset(theWitRun, specialFeaturePartName, 0, mfgTopLevelCycleTime);
d11238 1
a11238 1
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart, bomIndex, transitTimeOffset);
d11251 1
a11251 1
    RWCString nullSubstitute;
d11256 1
a11256 1
	witAddPart(theWitRun, nullSubstitute, WitMATERIAL);
d11263 1
a11263 1
	witAddPart(theWitRun, nullSubstitute, WitMATERIAL);
d11267 1
a11267 1
	  witSetPartSupplyVol(theWitRun, nullSubstitute, maxWithout);
d11274 3
a11276 3
	witAddPart(theWitRun, nullSubstitute, WitMATERIAL);
	LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
	witSetPartSupplyVol(theWitRun, nullSubstitute, bigMsupply.data());
d11281 1
a11281 1
      cerr << "About to die: featureType =" << featureType << "\n";
d11288 2
a11289 2
    witGetPartAppData(theWitRun, specialFeaturePartName, (void **) &appDataPtr);
    if (appDataPtr == NULL) {
d11292 1
a11292 1
      witSetPartAppData(theWitRun, specialFeaturePartName, (void *) appDataPtr);
d11309 1
a11309 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart, &nBom);
d11312 2
a11313 2
    witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart, nBom-1, &nSubBom);
    witAddSubsBomEntry(theWitRun, geoPlannerDemandPart, nBom-1, nullSubstitute);
d11315 4
a11318 4
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, WitFALSE);
    witSetSubsBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, intervalStartPeriod);
    witSetSubsBomEntryLatestPeriod(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, intervalEndPeriod);
    witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, transitTimeOffset);
d11320 2
a11321 2
    if (lpModelHelper_ != NULL)
      witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, defaultGatingOptionSubPenalty);
d11331 3
a11333 3
    RWCString returnedPlannerTopLevelPart;
    RWCString returnedGeo;
    RWCString demandName = mpHelper.pureOptionBuildDemandName( geoPlannerDemandPart );
d11339 1
a11339 1
      witAddDemand(theWitRun, specialFeaturePartName, demandName );
d11347 1
a11347 1
      RWCString engine = setOfParameters.getString("calendarFormat");
d11351 3
a11353 2
	witGetDemandDemandVol(theWitRun, specialFeaturePartName, demandName, &bigMdemandVol);
	for (int t=0; t<nPeriods; t++)
d11355 1
a11355 1
	witSetDemandDemandVol(theWitRun, specialFeaturePartName, demandName, bigMdemandVol);
d11382 2
a11383 2
  RWCString ppForGpd;
  RWCString geoForGpd;
d11385 3
a11387 2
  for (int i=0; i<nParts; i++)  { 
    RWCString geoPlannerDemandPart(partList[i]);
d11397 1
a11397 1
    witGetPartDemands(theWitRun, geoPlannerDemandPart,  &gpdNdemands, &gpdDlist);
d11404 1
a11404 1
    witGetDemandPriority ( theWitRun, geoPlannerDemandPart, gpdDlist[0], &priority );
d11407 1
a11407 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart, &nBoms);
d11409 2
a11410 1
    for (int j=0; j<nBoms; j++) {
d11412 1
a11412 1
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart, j, &specialFeaturePartName);
d11415 4
a11418 4
      RWCString pp;
      RWCString geo;
      RWCString pdf;
      RWCString featurePart;
d11426 2
a11427 1
	    for (int jSFP=0; jSFP<nDemandsSFP; jSFP++) {
d11439 2
a11440 1
	    for (int jSFP=0; jSFP<nDemandsSFP; jSFP++) {
d11483 2
a11484 2
  RWCString ptlpDummy;
  RWCString geoDummy;
d11487 1
a11487 1
    RWCString partName (partList[i]);
d11494 1
a11494 1
    witGetPartDemands(theWitRun, partName, &nDemands, &dList);
d11496 2
a11497 1
    for (int j=0; j<nDemands; j++) {
d11509 2
a11510 2
      witGetDemandAppData(theWitRun, partName, dList[j], (void **) &demandAppDataPtr);
      assert(demandAppDataPtr != NULL);
d11521 3
a11523 2
	witGetPartSupplyVol(theWitRun, partName, &supplyVol);
	for (int t=0; t<nPeriods; t++) {
d11526 1
a11526 1
	witSetPartSupplyVol(theWitRun, partName, supplyVol);
d11552 1
a11552 1
 RWBoolean useMultiRouteImplosion)
d11591 1
a11591 1
      if ( appDataPtr == NULL) // if there's no appData, than no interplants..
d11612 1
a11612 1
      // be safe and set expAllowed=TRUE (though this is the default and it should
d11622 1
a11622 1
      RWCString partName (partList[i]);
d11626 4
a11629 3
      witBoolean * bopOnInPeriod = new witBoolean[nPeriods];
      for (int t=0; t<nPeriods; t++)
        bopOnInPeriod[t] = FALSE; 
d11632 2
a11633 1
      for (int p=0; p<npBops; p++) {
d11638 1
a11638 1
          witSetBopEntryExpAllowed ( theWitRun, myBop.opName(), myBop.bopIndex(), WitFALSE );
d11654 1
a11654 1
              if ( bopOnInPeriod[first] != TRUE )
d11663 1
a11663 1
                                       myBop.opName(),
d11673 1
a11673 1
              if ( bopOnInPeriod[last] != FALSE )
d11682 3
a11684 2
            for (int t=first; t<=last; t++)
              bopOnInPeriod[t] = TRUE;
d11710 1
a11710 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName(),
d11716 1
a11716 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName(),
d11719 1
a11719 1
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName(),
d11726 1
a11726 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName(),
d11741 1
a11741 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName(),
d11744 1
a11744 1
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName(),
d11813 1
a11813 1
    RWCString partName (partList[i]);
d11819 1
a11819 1
    witGetPartAppData(theWitRun, partName.data(), (void **) &appDataPtr);
d11821 1
a11821 1
    if ( appDataPtr == NULL) // if there's no appData, than no interplants..
d11830 1
a11830 1
    witGetPartNProducingBopEntries ( theWitRun, partName.data(), & npBops );
d11843 1
a11843 1
    RWCString * setOfInterplantOps = new RWCString[nInterplantOps];
d11847 1
a11847 1
      RWCString interplantOpName = producingBop.opName();
d11850 4
a11853 4
      RWCString dPart;
      RWCString dPdf;
      RWCString sPart;
      RWCString sPdf;
d11855 1
a11855 1
                       theWitRun, interplantOpName.data(),
d11860 3
a11862 2
      for (int k=0; k<nInterplantOps; k++) {
        if (0 == interplantOpName.compareTo(setOfInterplantOps[k])) {
d11878 1
a11878 1
    // looking for bops to interplantOperations that have expAllowed=FALSE.
d11881 1
a11881 1
      RWCString currentInterplantOp = currentBop.opName();
d11884 4
a11887 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;
      RWCString sourcePdf;
d11895 1
a11895 1
      witGetBopEntryExpAllowed( theWitRun, currentInterplantOp.data(),
d11904 1
a11904 1
      // (i.e. expAllowed = FALSE)
d11913 1
a11913 1
      // is TRUE, then we will need to make the sub arc explodeable 
d11915 2
a11916 1
      for (int k=0; k<nInterplantOps; k++) {
d11918 1
a11918 1
        if (0 == currentInterplantOp.compareTo(setOfInterplantOps[k]))
d11921 2
a11922 2
        RWCString sourcePdfPartName;
        mpHelper.interplantSourcePdfPartName( theWitRun, currentInterplantOp.data(),
d11925 1
a11925 1
        RWCString primaryInterplantOp = setOfInterplantOps[k];
d11928 1
a11928 1
                                    primaryInterplantOp.data(), &nBomEntries );
d11936 1
a11936 1
        witGetBomEntryNSubsBomEntries( theWitRun, primaryInterplantOp.data(),
d11938 2
a11939 2
        witAddSubsBomEntry( theWitRun, primaryInterplantOp.data(), 0,
                            sourcePdfPartName.data() );
d11945 2
a11946 2
        witGetBomEntryUsageRate( theWitRun, currentInterplantOp.data(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryInterplantOp.data(), 0,
d11951 1
a11951 1
        witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.data(), 0,
d11962 1
a11962 1
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryInterplantOp.data(),
d11964 1
a11964 1
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryInterplantOp.data(),
d11970 2
a11971 2
        witGetBomEntryOffset( theWitRun, currentInterplantOp.data(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryInterplantOp.data(), 0,
d11979 1
a11979 1
        witGetBopEntryAppData( theWitRun, currentInterplantOp.data(), currentInterplantBopIndex,
d11981 1
a11981 1
        assert( currentBopAppDataPtr != NULL );
d11986 1
a11986 1
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.data(), 0, subBomEntryIndex, 
d11988 1
a11988 1
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryInterplantOp.data(), 0, subBomEntryIndex, 
d11996 2
a11997 2
        assert (subBomAppDataPtr != NULL );
        witSetSubsBomEntryAppData( theWitRun, primaryInterplantOp.data(), 0,
d12057 1
a12057 1
    RWCString partName (partList[i]);
d12063 1
a12063 1
    witGetPartAppData(theWitRun, partName.data(), (void **) &appDataPtr);
d12065 1
a12065 1
    if ( appDataPtr == NULL) // if there's no appData, than no bins..
d12074 1
a12074 1
    witGetPartNProducingBopEntries ( theWitRun, partName.data(), & npBops );
d12087 1
a12087 1
    RWCString * setOfBinOps = new RWCString[nBinOps];
d12091 1
a12091 1
      RWCString binOpName = producingBop.opName();
d12094 4
a12097 4
      RWCString dPart;
      RWCString dPdf;
      RWCString sPart;
      RWCString sPdf;
d12099 1
a12099 1
                       theWitRun, binOpName.data(),
d12104 3
a12106 2
      for (int k=0; k<nBinOps; k++) {
        if (0 == binOpName.compareTo(setOfBinOps[k])) {
d12122 1
a12122 1
    // looking for bops to binOperations that have byProduct=TRUE.
d12125 1
a12125 1
      RWCString currentBinOp = currentBop.opName();
d12128 4
a12131 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;
      RWCString sourcePdf;
d12134 1
a12134 1
                       theWitRun, currentBinOp.data(),
d12139 1
a12139 1
      witGetBopEntryExpAllowed( theWitRun, currentBinOp.data(),
d12147 1
a12147 1
      // (i.e. byProduct = TRUE)
d12156 1
a12156 1
      // is TRUE, then we will need to make the sub arc explodeable 
d12158 2
a12159 1
      for (int k=0; k<nBinOps; k++) {
d12161 1
a12161 1
        if (0 == currentBinOp.compareTo(setOfBinOps[k]))
d12164 2
a12165 2
        RWCString sourcePdfPartName;
        mpHelper.binSourcePdfPartName( theWitRun, currentBinOp.data(),
d12168 1
a12168 1
        RWCString primaryBinOp = setOfBinOps[k];
d12171 1
a12171 1
                                    primaryBinOp.data(), &nBomEntries );
d12179 1
a12179 1
        witGetBomEntryNSubsBomEntries( theWitRun, primaryBinOp.data(),
d12181 2
a12182 2
        witAddSubsBomEntry( theWitRun, primaryBinOp.data(), 0,
                            sourcePdfPartName.data() );
d12188 2
a12189 2
        witGetBomEntryUsageRate( theWitRun, currentBinOp.data(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryBinOp.data(), 0,
d12194 1
a12194 1
        witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.data(), 0,
d12205 1
a12205 1
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryBinOp.data(),
d12207 1
a12207 1
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryBinOp.data(),
d12213 2
a12214 2
        witGetBomEntryOffset( theWitRun, currentBinOp.data(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryBinOp.data(), 0,
d12222 1
a12222 1
        witGetBopEntryAppData( theWitRun, currentBinOp.data(), currentBinBopIndex,
d12224 1
a12224 1
        assert( currentBopAppDataPtr != NULL );
d12229 1
a12229 1
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.data(), 0, subBomEntryIndex, 
d12231 1
a12231 1
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryBinOp.data(), 0, subBomEntryIndex, 
d12239 2
a12240 2
        assert (subBomAppDataPtr != NULL );
        witSetSubsBomEntryAppData( theWitRun, primaryBinOp.data(), 0,
d12288 1
a12288 1
  cout << "    ... running witMrp() ..." << endl;    
d12293 4
a12296 4
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString bbCategory;
  RWCString mfgOptionPart;
d12304 1
a12304 1
  cout << "    ... scanning partlist ..." << endl;        
d12306 1
a12306 1
    RWCString fullWitPartname(partList[i]);
d12316 1
a12316 1
      witGetPartReqVol(theWitRun, fullWitPartname, &reqVol);
d12318 1
a12318 1
      witSetPartSupplyVol(theWitRun, fullWitPartname, reqVol);
d12328 1
a12328 1
      witGetPartReqVol(theWitRun, fullWitPartname, &reqVol);
d12332 1
a12332 1
      RWCString demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
d12335 1
a12335 1
      witGetPartReqVol(theWitRun, demandPart, &reqVolParent);
d12337 2
a12338 1
      for (int t=0; t<nPeriods; t++)
d12341 1
a12341 1
      witSetPartSupplyVol(theWitRun, fullWitPartname, reqVol);
d12350 1
a12350 1
      RWCString maxWithoutNullSubPart(fullWitPartname);
d12353 1
a12353 1
      RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12355 1
a12355 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart, &mrpProdVol);
d12359 1
a12359 1
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart, &supplyVol);
d12364 2
a12365 1
      for (int t=0; t<nPeriods; t++)  
d12368 1
a12368 1
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart, supplyVol);
d12375 1
a12375 1
    RWCString pppdf;
d12381 1
a12381 1
      RWCString ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));
d12384 1
a12384 1
      RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12386 1
a12386 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart, &mrpProdVol);
d12390 1
a12390 1
      witGetPartSupplyVol(theWitRun, ccNullSubPart, &supplyVol);
d12395 2
a12396 1
      for (int t=0; t<nPeriods; t++)  
d12399 1
a12399 1
      witSetPartSupplyVol(theWitRun, ccNullSubPart, supplyVol);
d12411 1
a12411 1
  cout << "    ... finished SCE pre-processing ..." << endl;        
d12442 1
a12442 1
  cout << "    ... running witMrp() ..." << endl;    
d12447 4
a12450 4
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString bbCategory;
  RWCString mfgOptionPart;
d12457 1
a12457 1
  cout << "    ... scanning partlist ..." << endl;        
d12459 1
a12459 1
    RWCString fullWitPartname(partList[i]);
d12466 1
a12466 1
      RWCString fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart,
d12471 1
a12471 1
      witGetPartMrpProdVol(theWitRun, fullBbCategoryPart, &mrpProdVol);
d12474 1
a12474 1
      RWCString optionRatioSupplyPart = mpHelper.optionRatioSupplyPartName(
d12479 1
a12479 1
      witGetPartSupplyVol(theWitRun, optionRatioSupplyPart, &supplyVol);
d12484 2
a12485 1
      for (int t=0; t<nPeriods; t++)  
d12488 1
a12488 1
      witSetPartSupplyVol(theWitRun, optionRatioSupplyPart, supplyVol);
d12500 1
a12500 1
      witGetPartReqVol(theWitRun, fullWitPartname, &reqVol);
d12504 1
a12504 1
      RWCString demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
d12507 1
a12507 1
      witGetPartReqVol(theWitRun, demandPart, &reqVolParent);
d12509 2
a12510 1
      for (int t=0; t<nPeriods; t++)
d12513 1
a12513 1
      witSetPartSupplyVol(theWitRun, fullWitPartname, reqVol);
d12522 1
a12522 1
      RWCString maxWithoutNullSubPart(fullWitPartname);
d12525 1
a12525 1
      RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12527 1
a12527 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart, &mrpProdVol);
d12531 1
a12531 1
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart, &supplyVol);
d12536 2
a12537 1
      for (int t=0; t<nPeriods; t++)  
d12540 1
a12540 1
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart, supplyVol);
d12547 1
a12547 1
    RWCString pppdf;
d12553 1
a12553 1
      RWCString ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));
d12556 1
a12556 1
      RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12558 1
a12558 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart, &mrpProdVol);
d12562 1
a12562 1
      witGetPartSupplyVol(theWitRun, ccNullSubPart, &supplyVol);
d12567 2
a12568 1
      for (int t=0; t<nPeriods; t++)  
d12571 1
a12571 1
      witSetPartSupplyVol(theWitRun, ccNullSubPart, supplyVol);
d12583 1
a12583 1
  cout << "    ... finished SCE pre-processing ..." << endl;        
d12599 4
a12602 4
    const RWCString & parent, 
    const RWCString & parentPdf,
    const RWCString & child, 
    const RWCString & childPdf, 
d12610 2
a12611 2
    const RWCString & fileName,
    const RWCString & dataLine,
d12617 2
a12618 2
    RWCString fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    RWCString fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12632 1
a12632 1
    witAddBomEntryVa(theWitRun, fullParentName, fullChildName,
d12638 1
a12638 1
		     NULL);
d12648 1
a12648 1
// Note: you must set the flag isParentAnOperation to TRUE or FALSE
d12653 8
a12660 8
    RWBoolean isParentAnOperation,
    RWBoolean relaxedSubbingRulesAllowed,
    const RWCString & mfgParentPartName, 
    const RWCString & parentPdf, 
    const RWCString & mfgChildPartName, 
    const RWCString & childPdf, 
    const RWCString & mfgSubPartName,
    const RWCString & subPdf,
d12668 3
a12670 3
    RWBoolean subNetAllowed,
    const RWCString & fileName,
    const RWCString & dataLine,
d12679 3
a12681 3
    RWCString fullParentName(mpHelper.pdfPartname(mfgParentPartName, parentPdf));
    RWCString fullChildName( mpHelper.pdfPartname(mfgChildPartName,  childPdf));
    RWCString fullSubName( mpHelper.pdfPartname(mfgSubPartName,  subPdf));
d12726 1
a12726 1
    witGetOperationNBomEntries(theWitRun, fullParentName, &nBomEntries);
d12733 3
a12735 2
    for (int j=0; j<nBomEntries; j++)  {
	witGetBomEntryConsumedPart(theWitRun, fullParentName.data(), j, &child);
d12739 2
a12740 2
	    witGetBomEntryEarliestPeriod(theWitRun, fullParentName.data(), j, &candidateEarly);
	    witGetBomEntryLatestPeriod(theWitRun, fullParentName.data(), j, &candidateLate);
d12764 2
a12765 1
	      for (int t=0; t<nPeriods; t++)
d12770 1
a12770 1
	      witGetBomEntryNSubsBomEntries( theWitRun, fullParentName, j, & nSubBoms);
d12772 6
a12777 6
	      witGetBomEntryOffset(theWitRun, fullParentName, j, &offset);
	      witAddSubsBomEntry( theWitRun, fullParentName, j, fullSubName);
	      witSetSubsBomEntryEarliestPeriod( theWitRun, fullParentName, j, nSubBoms, early);
	      witSetSubsBomEntryLatestPeriod( theWitRun, fullParentName, j, nSubBoms, late);
	      witSetSubsBomEntryOffset(theWitRun, fullParentName, j, nSubBoms, offset);
	      witSetSubsBomEntryExpNetAversion(theWitRun, fullParentName, j, nSubBoms, subCost);
d12780 1
a12780 1
		witSetSubsBomEntryExecPenalty(theWitRun, fullParentName, j, nSubBoms, subCost);
a12782 1

d12785 1
a12785 1
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName, j, nSubBoms, WitTRUE);
d12787 1
a12787 1
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName, j, nSubBoms, WitFALSE);
d12791 1
a12791 1
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName, j, nSubBoms, WitTRUE);
d12793 1
a12793 1
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName, j, nSubBoms, WitFALSE);
d12795 2
a12796 2
	      witSetSubsBomEntryFallout( theWitRun, fullParentName, j, nSubBoms, fallout);
	      witSetSubsBomEntryUsageRate( theWitRun, fullParentName, j, nSubBoms, usageRate);
d12798 2
a12799 2
	      if ( lpModelHelper_ != NULL )
		witSetSubsBomEntryObj1SubCost( theWitRun, fullParentName, j, nSubBoms, obj1SubCost);
d12805 2
a12806 2
	      witGetSubsBomEntryAppData( theWitRun, fullParentName, j, nSubBoms, &subBomAppVoidPtr );
	      if ( subBomAppVoidPtr != NULL ) {
d12820 1
a12820 1
					 fullParentName,
d12867 4
a12870 4
    const RWCString & parent, 
    const RWCString & parentPdf,
    const RWCString & child, 
    const RWCString & childPdf, 
d12879 2
a12880 2
    const RWCString & fileName,
    const RWCString & dataLine,
d12883 2
a12884 2
    RWCString fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    RWCString fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12912 1
a12912 1
	witGetPartCycleTime(theWitRun, fullChildName, &cycleTime);
d12917 1
a12917 1
    witAddBomEntryVa(theWitRun, fullParentName, fullChildName,
d12924 1
a12924 1
		     NULL);
d12936 4
a12939 4
    const RWCString & parent, 
    const RWCString & parentPdf,
    const RWCString & child, 
    const RWCString & childPdf, 
d12944 2
a12945 2
    const RWCString & fileName,
    const RWCString & dataLine,
d12948 2
a12949 2
    RWCString fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    RWCString fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12961 1
a12961 1
    witAddBomEntryVa(theWitRun, fullParentName, fullChildName,
d12966 1
a12966 1
		     NULL);
d12979 4
a12982 4
    const RWCString & mfgPart, 
    const RWCString & mfgPdf,
    const RWCString & aggregatePart, 
    const RWCString & aggregatePdf, 
d12987 2
a12988 2
    const RWCString & fileName,
    const RWCString & dataLine,
d12998 2
a12999 2
  RWCString fullMfgPart(mpHelper.pdfPartname(mfgPart, mfgPdf));
  RWCString fullAggregatePart(mpHelper.pdfPartname(aggregatePart,  aggregatePdf));
d13012 1
a13012 1
  RWCString aggOpName(mpHelper.aggregationOperationName(mfgPart, mfgPdf,
d13018 1
a13018 1
  witGetOperationExists(theWitRun, aggOpName, &exists);
d13030 2
a13031 1
  for (int t=0; t<nPeriods; t++)
d13034 1
a13034 1
  witAddOperation(theWitRun, aggOpName);
d13036 1
a13036 1
  witAddBopEntry(theWitRun, aggOpName, fullMfgPart);
d13039 1
a13039 1
  witSetBopEntryAppData(theWitRun, aggOpName, 0, (void *) appDataPtr);
d13042 3
a13044 3
  witAddBomEntry(theWitRun, aggOpName, fullAggregatePart);
  witSetBomEntryUsageRate(theWitRun, aggOpName, 0, usageRate);
  witSetBomEntryOffset(theWitRun, aggOpName, 0, offsetVec);
d13051 2
a13052 2
  witGetPartAppData(theWitRun, fullMfgPart, (void **) &custPartAppData);
  if (custPartAppData == NULL) {
d13055 1
a13055 1
    witSetPartAppData(theWitRun, fullMfgPart, (void *) custPartAppData);
d13071 2
a13072 2
    const RWCString & geoPlannerDemandPartName,
    const RWCString & pdf_PartName,
d13076 2
a13077 2
    const RWCString & fileName,
    const RWCString & dataLine,
d13088 1
a13088 1
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName, &nBom);
d13099 2
a13100 1
    for (int t=0; t<nPeriods; t++)
d13108 2
a13109 1
    for (int j=0; j<nBom; j++ ) {
d13114 1
a13114 1
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName, j, &child);
d13123 2
a13124 2
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName, j, &bomEarly);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName, j, &bomLate);
d13129 2
a13130 2
          RWCString geo;
          RWCString plannerPart;
d13161 3
a13163 3
  witAddBomEntry(theWitRun, geoPlannerDemandPartName, pdf_PartName);
  witSetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName, nBom, early);
  witSetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName, nBom, late);
d13167 3
a13169 2
  witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName, nBom, &bomOffset);
  for (int t=early; t<=late; t++)
d13171 1
a13171 1
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPartName, nBom, bomOffset);
d13179 1
a13179 1
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPartName, 0, &bopOffset);
d13182 1
a13182 1
  witSetBopEntryOffset(theWitRun, geoPlannerDemandPartName, 0, bopOffset);
d13194 4
a13197 4
    const RWCString & demandPart,
    const RWCString & demandUpperBoundPart, 
    const RWCString & fileName,
    const RWCString & dataLine,
d13200 2
a13201 2
  witAddBomEntryVa(theWitRun, demandPart, demandUpperBoundPart,
                   NULL);
d13220 1
a13220 1
         RWCString fileName)
d13223 1
a13223 1
   RWCString partName;
d13225 1
a13225 1
   ofstream outFile(fileName, ios::out);
d13336 5
a13340 4
  LgFrInitialProblemAndParameters(source.scenario()),
  implementSmartFeatures_(source.implementSmartFeatures_),
  heurModelHelper_(source.heurModelHelper_),
  lpModelHelper_(source.lpModelHelper_),
d13350 7
a13356 6
  LgFrInitialProblemAndParameters(
				  LgFrScenarioSmartPointer::nullScenarioSmartPointer),
  implementSmartFeatures_(TRUE),
  heurModelHelper_(NULL),
  lpModelHelper_(NULL),
  groupSharingViaExecPenalties_(FALSE)
d13364 6
a13369 5
  LgFrInitialProblemAndParameters(scenario),
  implementSmartFeatures_(TRUE),
  heurModelHelper_(NULL),
  lpModelHelper_(NULL),
  groupSharingViaExecPenalties_(FALSE)
d13377 1
a13377 1
RWCString
d13381 1
a13381 1
  RWCString theTitle("Supply Capability Engine: ");
d13393 3
a13395 3
    if (scenario()->isA() != __LGFRSCENARIOFORSCE)  {
        cerr << "the object is not a SCE scenario and it is supposed to be"
             << endl;
d13412 1
a13412 1
  assert( dif->dataInterfaceImplementation()->isA() ==
d13419 1
a13419 1
//  cout << "\nLgFrInitialProblemForSce::feedinto() ---> " 
d13423 1
a13423 1
  RWCString parameterFilename = difSceF->filename();
d13446 1
a13446 1
    RWCString & parameterFileName,
d13481 1
a13481 1
   RWCString calendarFormat = setOfParameters.getString("calendarFormat");
a13508 7


#ifndef WIN32
implement (RWGVector, float)
implement (RWGVector, int)
#endif

@


1.22.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d5 3
d64 1
a64 1
    std::string fileFormatTypeS = setOfParameters.getString("fileFormatType");
d70 1
a70 1
    std::string defaultPdf = setOfParameters.getString("defaultPdf");
d74 1
a74 1
    std::string pdfSeparator = setOfParameters.getString("pdfSeparator");
d85 1
a85 1
    // Testing if (lpModelHelper != 0) is equivalent
d101 1
a101 1
    LgFrSceDemandDriver * myDemandDriver = 0;
d105 1
a105 1
    std::string engine = setOfParameters.getString("engine");
d112 2
a113 2
    std::string scenarioFile = setOfParameters.getString("outputFilePrefix");
    std::string witMsgFileExtension = setOfParameters.getString("witMsgFileExtension");    
d115 1
a115 1
    std::string witMesgFileName(scenarioFile + witMsgFileExtension);
d117 1
a117 1
    witSetMesgFileName( theWitRun, WitTRUE, witMesgFileName.c_str());
d130 1
a130 1
    bool useMultiRouteImplosion = setOfParameters.getBool("useMultiRouteImplosion");
d134 1
a134 1
    bool useStockReallocation = setOfParameters.getBool("useStockReallocation");
d138 1
a138 1
    bool pathCounting = setOfParameters.getBool("pathCounting");
d149 1
a149 1
    bool useLocalBuildAhead = setOfParameters.getBool("useLocalBuildAhead");
d158 1
a158 1
    if ( lpModelHelper_ != 0 )
d171 1
a171 1
    bool heurForceEquit = setOfParameters.getBool("heurForceEquit");
d174 1
a174 1
    bool heurSkipFailures = setOfParameters.getBool("heurSkipFailures");
d177 1
a177 1
    std::string siteCustomization = setOfParameters.getString("siteCustomization");
d180 1
a180 1
    bool doPegging = setOfParameters.getBool("doPegging");
d204 1
a204 1
    std::string partDefFile = setOfParameters.getString("partFile");
d215 2
a216 2
    std::string capacityDefFile = setOfParameters.getString("capFile");
    if (! capacityDefFile.empty())
d227 2
a228 2
    std::string cycleTimeFile = setOfParameters.getString("cycleTimeFile");    
    if (! cycleTimeFile.empty())
d235 2
a236 2
    std::string yieldFile = setOfParameters.getString("yieldFile");    
    if (! yieldFile.empty())
d244 2
a245 2
    std::string lotSizeFile = setOfParameters.getString("lotSizeFile");    
    if (! lotSizeFile.empty()) 
d253 2
a254 2
    std::string prodVolLBFile = setOfParameters.getString("prodVolLBFile");    
    if (! prodVolLBFile.empty()) 
d263 2
a264 2
    std::string prodVolUBFile = setOfParameters.getString("prodVolUBFile");    
    if (! prodVolUBFile.empty()) 
d272 2
a273 2
    std::string operationDefFile = setOfParameters.getString("opFile");
    if (! operationDefFile.empty())    
d283 2
a284 2
    std::string operationExecPenaltyFile = setOfParameters.getString("opExecPenaltyFile");
    if (! operationExecPenaltyFile.empty())    
d292 2
a293 2
    std::string operationExecCostFile = setOfParameters.getString("opExecCostFile");
    if (! operationExecCostFile.empty()) {
d306 2
a307 2
    std::string operationLotSizeFile = setOfParameters.getString("opLotSizeFile");
    if (! operationLotSizeFile.empty())    
d314 2
a315 2
    std::string operationYieldFile = setOfParameters.getString("opYieldFile");
    if (! operationYieldFile.empty())    
d323 2
a324 2
    std::string operationLBFile = setOfParameters.getString("opLowerFile");
    if (! operationLBFile.empty())    
d332 2
a333 2
    std::string operationUBFile = setOfParameters.getString("opUpperFile");
    if (! operationUBFile.empty())    
d341 2
a342 2
     std::string operationBomFile = setOfParameters.getString("opBomFile");
     if (! operationBomFile.empty())    
d350 2
a351 2
     std::string operationBopFile = setOfParameters.getString("opBopFile");
     if (! operationBopFile.empty())    
d360 1
a360 1
    std::string bomFile = setOfParameters.getString("bomFile");
d367 2
a368 2
	std::string interPlantFile = setOfParameters.getString("interPlantFile");
	if (! interPlantFile.empty())
d377 2
a378 2
	std::string binFile = setOfParameters.getString("binFile");
	if (! binFile.empty())
d387 2
a388 2
    std::string bocFile = setOfParameters.getString("bocFile");
    if (! bocFile.empty())
d395 2
a396 2
    std::string opSubBomFile = setOfParameters.getString("opSubBomFile");
    if (! opSubBomFile.empty())  {
d405 2
a406 2
    std::string subBomFile = setOfParameters.getString("subBomFile");
    if (! subBomFile.empty())  {
d415 2
a416 2
    std::string aggregationFile = setOfParameters.getString("aggregationFile");
    if (! aggregationFile.empty())  {
d427 2
a428 2
    std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (! independentDemandFile.empty())
d448 2
a449 2
    std::string geoSourceFile = setOfParameters.getString("geoSourceFile");
    if (! geoSourceFile.empty())
d459 1
a459 1
    std::string demandVolFile = setOfParameters.getString("demandVolFile");
d466 2
a467 2
    std::string topLevelToBBdefFile = setOfParameters.getString("topLevelToBBdefFile");
    if (! topLevelToBBdefFile.empty())
d471 1
a471 1
    std::string topLevelToBBratioFile = setOfParameters.getString("topLevelToBBratioFile");
d473 1
a473 1
    if (! topLevelToBBratioFile.empty())
d485 2
a486 2
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
d496 2
a497 2
    std::string machineFeatureOffsetFile = setOfParameters.getString("machineFeatureOffsetFile");
    if (! machineFeatureOffsetFile.empty()) {
d506 2
a507 2
    std::string machineFeatureSupplyFile = setOfParameters.getString("machineFeatureSupplyFile");
    if (! machineFeatureSupplyFile.empty()) {
d539 2
a540 2
      std::string priorityFile = setOfParameters.getString("priorityFile");
      if (! priorityFile.empty())  {
d543 1
a543 1
        if ( lpModelHelper_ != 0 ) {
d552 2
a553 2
      std::string indepPriorityFile = setOfParameters.getString("indepPriorityFile");
      if ((!independentDemandFile.empty()) && (!indepPriorityFile.empty()))  {
d565 1
a565 1
	std::string revenueFile = setOfParameters.getString("revenueFile");
d570 2
a571 2
        std::string optionRevFile = setOfParameters.getString("optionRevFile");
        if (! optionRevFile.empty())
d579 2
a580 2
        std::string featRevFile = setOfParameters.getString("featRevFile");
        if (! featRevFile.empty())
d586 2
a587 2
	std::string indepRevenueFile = setOfParameters.getString("indepRevenueFile");
	if ((!independentDemandFile.empty()) && (!indepRevenueFile.empty()))  {
d601 1
a601 1
	std::string profitFile = setOfParameters.getString("profitFile");
d607 2
a608 2
        std::string optionProfitFile = setOfParameters.getString("optionProfitFile");
        if (! optionProfitFile.empty())
d614 2
a615 2
        std::string featProfitFile = setOfParameters.getString("featProfitFile");
        if (! featProfitFile.empty())
d625 2
a626 2
    std::string minDemandVolFile = setOfParameters.getString("minDemandVolFile");
    if (! minDemandVolFile.empty())
d633 2
a634 2
    std::string minIndepDemandVolFile = setOfParameters.getString("minIndepDemandVolFile");
    if (! minIndepDemandVolFile.empty())
d642 2
a643 2
    std::string backlogYieldFile = setOfParameters.getString("backlogYieldFile");
    if (! backlogYieldFile.empty())
d652 1
a652 1
    std::string supplyFile = setOfParameters.getString("supplyFile");
d656 2
a657 2
    std::string datedSupplyFile = setOfParameters.getString("datedSupplyFile");
    if (! datedSupplyFile.empty())
d664 2
a665 2
    std::string capSupplyFile = setOfParameters.getString("capSupplyFile");
    if (! capSupplyFile.empty())    
d686 1
a686 1
    std::string partsConditionFile = setOfParameters.getString("partCondFile");
d699 1
a699 1
    if ( lpModelHelper_ == 0 ) {    
d771 2
a772 2
      std::string outputFilePrefix = setOfParameters.getString("outputFilePrefix");
      if (sce::find(outputFilePrefix, "/") != sce::badIndex) {
d777 3
a779 3
      std::string parameterFileName = setOfParameters.getString("parameterFileName");
      std::string scrubParamFileName = myScrubber->scrubDir() + parameterFileName;
      if (sce::find(parameterFileName, "/") != sce::badIndex) {
d788 1
a788 1
      bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d797 1
a797 1
      if (! minDemandVolFile.empty())
d839 1
a839 1
      std::string echoFileName = setOfParameters.getString("heurEchoFileName");
d841 1
a841 1
      witDisplayData( theWitRun, echoFileName.c_str());
d852 1
a852 1
      std::string witDataFileName = setOfParameters.getString("heurWitDataFileName");
d854 1
a854 1
      witWriteData(theWitRun, witDataFileName.c_str());
d883 1
a883 1
      // after printing, WE MUST turn subs back on (netAllowed to true)
d887 1
a887 1
	this->setSubsNetAllowed(false, mpHelper, theWitRun);
d894 1
a894 1
      std::string demandDriversFileName = setOfParameters.getString("demandDriversFileName");
d897 2
a898 2
    	this->setSubsNetAllowed(true, mpHelper, theWitRun);
	    mpHelper.setAllWitPartIndices(theWitRun);
d916 1
a916 1
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=false, then this will
d919 1
a919 1
LgFrInitialProblemForSce::setSubsNetAllowed(bool subNetAllowed, 
d926 3
a928 3
  bool netAllowed = subNetAllowed;
  bool expAllowed = subNetAllowed;
  bool globalSubNetAllowed = this->sceScenario()->setOfParameters().getBool("globalSubNetAllowed");
d940 1
a940 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
d948 1
a948 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBoms; b++) {
d951 1
a951 2
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) {
d980 4
a983 4
    const std::string & fileName,
     std::string fileDescription,
    std::ifstream & inFile,
    std::ofstream & outFile,
d989 1
a989 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d994 2
a995 2
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str());
d1003 1
a1003 1
  inFile.open(fileName.c_str() );//,ios::nocreate);
d1019 1
a1019 1
    const std::string & fileName,
d1024 3
a1026 3
    std::string mfgPartName;
    std::string pdf_PartName;
    std::string pdf;
d1033 1
a1033 1
    std::string dataLine;
d1037 2
a1038 2
    std::ifstream inFile;
    std::ofstream outFile;
d1057 1
a1057 1
	std::getline( inFile, dataLine );
d1061 2
a1062 2
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1075 1
a1075 1
	SCETokenizer next(dataLine);
d1142 1
a1142 1
    const std::string & fileName,
d1146 3
a1148 3
    std::string capacityName;
    std::string pdf_capacityName;
    std::string pdf;
d1155 1
a1155 1
    std::string dataLine;
d1158 2
a1159 2
    std::ifstream inFile;    
    std::ofstream outFile;
d1176 1
a1176 1
    std::getline( inFile, dataLine );
d1180 2
a1181 2
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1191 1
a1191 1
	SCETokenizer next(dataLine);
d1250 1
a1250 1
    const std::string & fileName,
d1254 3
a1256 3
 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string pdf;
d1262 1
a1262 1
 std::string dataLine;
d1268 2
a1269 2
 std::ifstream inFile;
 std::ofstream outFile;
d1287 1
a1287 1
    std::getline( inFile, dataLine );
d1291 2
a1292 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1303 1
a1303 1
    SCETokenizer next(dataLine);
d1333 1
a1333 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1337 1
a1337 1
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1360 1
a1360 1
      result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);
d1364 1
a1364 1
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, false, 0, 1);
d1368 1
a1368 1
	result = flatFileManager.nextInt(phantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);
d1373 1
a1373 1
			 false, 0, 1);
d1424 1
a1424 1
    const std::string & fileName,
d1428 3
a1430 3
 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string pdf;
d1432 1
a1432 1
 std::string dataLine;
d1443 2
a1444 2
 std::ifstream inFile;
 std::ofstream outFile;
d1462 1
a1462 1
    std::getline( inFile, dataLine );
d1466 2
a1467 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1478 1
a1478 1
    SCETokenizer next(dataLine);
d1505 1
a1505 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1509 1
a1509 1
	result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1559 1
a1559 1
    const std::string & fileName,
d1563 3
a1565 3
 std::string consumedPartName;
 std::string operationName;
 std::string pdf;
d1567 1
a1567 1
 std::string dataLine;
d1577 2
a1578 2
 std::ifstream inFile;
 std::ofstream outFile;
d1596 1
a1596 1
    std::getline( inFile, dataLine );
d1600 2
a1601 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1612 1
a1612 1
    SCETokenizer next(dataLine);
d1639 1
a1639 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1643 1
a1643 1
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1661 1
a1661 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);
d1707 1
a1707 1
    const std::string & fileName,
d1711 3
a1713 3
 std::string producedPartName;
 std::string operationName;
 std::string pdf;
d1715 1
a1715 1
 std::string dataLine;
d1725 2
a1726 2
 std::ifstream inFile;
 std::ofstream outFile;
d1744 1
a1744 1
    std::getline( inFile, dataLine );
d1748 2
a1749 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1760 1
a1760 1
    SCETokenizer next(dataLine);
d1792 1
a1792 1
    // if ( lpModelHelper_ != 0 )
d1796 1
a1796 1
    result = flatFileManager.nextFloat(prodRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1800 1
a1800 1
      result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1813 1
a1813 1
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, false, -FLT_MAX); 
d1819 1
a1819 1
                       next, fileName, dataLine, lineNo, false, 0, 1); 
d1824 1
a1824 1
                       next, fileName, dataLine, lineNo, false, 0, 1); 
d1874 1
a1874 1
    const std::string & fileName,
d1880 1
a1880 1
 std::string dataLine;
d1890 2
a1891 2
 std::ifstream inFile;
 std::ofstream outFile;
d1909 1
a1909 1
    std::getline( inFile, dataLine );
d1913 2
a1914 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d1925 1
a1925 1
    SCETokenizer next(dataLine);
d1928 1
a1928 1
    std::string mfgPart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1936 1
a1936 1
    std::string mfgPdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1944 1
a1944 1
    std::string aggregatePart = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1953 1
a1953 1
    std::string aggregatePdf = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
d1969 1
a1969 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1973 1
a1973 1
	result = flatFileManager.nextFloat(offset, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1980 1
a1980 1
    // else if ( lpModelHelper_ != 0 )
d1984 1
a1984 1
      result = flatFileManager.nextFloat(preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d1988 1
a1988 1
      result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);
d2032 1
a2032 1
    const std::string & fileName,
d2035 4
a2038 4
 std::string plannerTopLevelPart;
 std::string bbCategory;
 std::string geo;
 std::string mfgOptionPart;
d2040 1
a2040 1
 std::string dataLine;
d2056 2
a2057 2
 std::ifstream inFile;
 std::ofstream outFile;
d2076 1
a2076 1
    std::getline( inFile, dataLine );
d2080 2
a2081 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d2095 1
a2095 1
    SCETokenizer next(dataLine);
d2122 1
a2122 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d2127 1
a2127 1
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d2133 2
a2134 3
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, false, 0.0);
d2200 1
a2200 1
    const std::string & fileName,
d2205 3
a2207 3
 std::string plannerTopLevelPart;
 std::string geo;
 std::string mfgOptionPart;
d2209 1
a2209 1
 std::string dataLine;
d2226 2
a2227 2
 std::ifstream inFile;
 std::ofstream outFile;
d2246 1
a2246 1
   std::getline( inFile, dataLine );
d2250 2
a2251 2
   dataLine = sce::strip( dataLine );
   if ((dataLine.empty()) || (dataLine[0] == '*')) {
d2262 1
a2262 1
   SCETokenizer next(dataLine);
d2285 1
a2285 2
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<nPeriods; t++) {
d2292 1
a2292 2
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++)  {
d2294 1
a2294 1
                                 next, fileName, dataLine, lineNo, false, -FLT_MAX);
d2358 1
a2358 1
    const std::string & fileName,
d2375 4
a2378 4
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string dataLine;
d2401 1
a2401 2
  int tt = 0; // Pulled out of the for below by RW2STL
  for (tt=0; tt<nPeriods; tt++)
d2404 2
a2405 2
  std::ifstream inFile;
  std::ofstream outFile;
d2423 1
a2423 1
    std::getline( inFile, dataLine );
d2427 2
a2428 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d2442 1
a2442 1
    SCETokenizer next(dataLine);
d2476 1
a2476 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d2483 1
a2483 1
    result = flatFileManager.nextFloat(usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d2489 2
a2490 3
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(featureRatio[t], next, fileName, dataLine, lineNo, false, 0.0);
d2499 1
a2499 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  {
d2502 1
a2502 1
					       false, -1.0, 1.0);
d2627 1
a2627 1
  std::string pp, geo;
d2634 1
a2634 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d2638 1
a2638 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d2657 1
a2657 1
    const std::string & fileName,
d2670 3
a2672 3
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
d2677 1
a2677 1
  std::string dataLine;
d2691 2
a2692 2
  std::ifstream inFile;
  std::ofstream outFile;
d2712 1
a2712 1
    std::getline( inFile, dataLine );
d2716 2
a2717 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d2731 1
a2731 1
    SCETokenizer next(dataLine);
d2761 1
a2761 1
    result = flatFileManager.nextFloat(offsetVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d2771 1
a2771 1
    result = flatFileManager.nextInt(featurePhantomFlag, next, fileName, dataLine, lineNo, false, 0, 1);
d2825 1
a2825 1
    const std::string & fileName,
d2830 4
a2833 4
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string dataLine;
d2848 2
a2849 2
  std::ifstream inFile;
  std::ofstream outFile;
d2867 1
a2867 1
    std::getline( inFile, dataLine );
d2871 2
a2872 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d2886 1
a2886 1
    SCETokenizer next(dataLine);
d2916 1
a2916 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d2925 2
a2926 3
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  {
	    result = flatFileManager.nextFloat(supplyVol[t], next, fileName, dataLine, lineNo, false, 0.0);
d2978 1
a2978 1
    const std::string & fileName,
d2981 5
a2985 5
    std::string plannerTopLevelPart;
    std::string geo;
    std::string plannerFeatureSetPart;
    std::string bbCategory;
    std::string dataLine;
d2993 2
a2994 2
    std::ifstream inFile;
    std::ofstream outFile;
d3012 1
a3012 1
	std::getline( inFile, dataLine );
d3016 2
a3017 2
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d3028 1
a3028 1
	SCETokenizer next(dataLine);
d3055 1
a3055 1
	result = flatFileManager.nextFloat(gammaMax, next, fileName, dataLine, lineNo, false, 1.0);
d3109 1
a3109 1
    const std::string & fileName,
d3113 5
a3117 5
 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string parentPdf;
 std::string childPdf;
 std::string dataLine;
d3126 2
a3127 2
 std::ifstream inFile;
 std::ofstream outFile;
d3147 1
a3147 1
    std::getline( inFile, dataLine );
d3151 2
a3152 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d3162 1
a3162 1
    SCETokenizer next(dataLine);
d3200 1
a3200 1
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3225 1
a3225 1
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, false, 0.0 );
d3229 1
a3229 1
                           lineNo, false, 1.0);
d3233 1
a3233 1
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3238 1
a3238 1
    // if ( lpModelHelper_ != 0 )
d3241 1
a3241 1
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3245 1
a3245 1
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);
d3249 1
a3249 1
      result = flatFileManager.nextInt( isInterplantExplodeableAsSubstitute, next, fileName, dataLine, lineNo, false, 0, 1);
d3300 1
a3300 1
    const std::string & fileName,
d3304 5
a3308 5
 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string parentPdf;
 std::string childPdf;
 std::string dataLine;
d3317 2
a3318 2
 std::ifstream inFile;
 std::ofstream outFile;
d3338 1
a3338 1
    std::getline( inFile, dataLine );
d3342 2
a3343 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d3353 1
a3353 1
    SCETokenizer next(dataLine);
d3391 1
a3391 1
	result = flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3416 1
a3416 1
      result =  flatFileManager.nextFloat( minLotSize, next, fileName, dataLine, lineNo, false, 0.0 );
d3420 1
a3420 1
                           lineNo, false, 1.0);
d3424 1
a3424 1
      result = flatFileManager.nextFloat( usageRate, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3429 1
a3429 1
    // if ( lpModelHelper_ != 0 )
d3432 1
a3432 1
      result = flatFileManager.nextFloat( preference, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3436 1
a3436 1
      result = flatFileManager.nextInt( isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);
d3440 1
a3440 1
      result = flatFileManager.nextInt( isBinExplodeableAsSubstitute, next, fileName, dataLine, lineNo, false, 0, 1);
d3499 1
a3499 1
    const std::string & fileName,
d3503 5
a3507 5
 std::string operationName;
 std::string mfgChildPartName;
 std::string mfgSubPartName;
 std::string pdf;
 std::string dataLine;
d3515 2
a3516 2
 // bool relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");
 bool relaxedSubbingRulesAllowed = false;
d3518 1
a3518 1
 bool globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");
d3520 1
d3524 2
a3525 2
 std::ifstream inFile;
 std::ofstream outFile;
d3543 1
a3543 1
    std::getline( inFile, dataLine );
d3547 2
a3548 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d3560 1
a3560 1
    SCETokenizer next(dataLine);
d3595 1
a3595 1
				       dataLine, lineNo, false, -FLT_MAX);
d3618 1
a3618 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);
d3622 1
a3622 1
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3627 1
a3627 1
					 dataLine, lineNo, false, 0, 1);    
d3632 1
a3632 1
					 dataLine, lineNo, false, 0, 1);    
d3636 1
a3636 1
    bool isParentAnOperation = true;
d3653 1
a3653 1
    isObjectInEffectForOptExplosion,
d3692 1
a3692 1
    const std::string & fileName,
d3696 5
a3700 5
 std::string mfgParentPartName;
 std::string mfgChildPartName;
 std::string mfgSubPartName;
 std::string pdf;
 std::string dataLine;
d3710 1
a3710 1
 // bool relaxedSubbingRulesAllowed = setOfParameters.getFloat("relaxedSubbingRulesAllowed");
d3713 1
a3713 1
 bool globalSubNetAllowed = setOfParameters.getBool("globalSubNetAllowed");
d3720 2
a3721 2
 std::ifstream inFile;
 std::ofstream outFile;
d3739 1
a3739 1
    std::getline( inFile, dataLine );
d3743 2
a3744 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d3758 1
a3758 1
    SCETokenizer next(dataLine);
d3792 1
a3792 1
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3814 1
a3814 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, false, 0, 100);
d3818 1
a3818 1
	result = flatFileManager.nextFloat(defaultSubPenalty, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d3822 1
a3822 1
	result = flatFileManager.nextInt(isObjectInEffectForOptExplosion, next, fileName, dataLine, lineNo, false, 0, 1);    
d3826 1
a3826 1
	result = flatFileManager.nextInt(isSubstituteBuildable, next, fileName, dataLine, lineNo, false, 0, 1);    
d3828 2
a3829 2
    bool isParentAnOperation = false;
    bool relaxedSubbingRulesAllowed = false;
d3886 1
a3886 1
    const std::string & fileName,
d3891 2
a3892 2
 std::string pdf_PartName;
 std::ifstream inFile;
d3895 1
a3895 1
 std::string dataLine;
d3901 1
a3901 1
 std::ofstream outFile;
d3906 1
a3906 1
 bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d3916 1
a3916 1
   inFile.open(fileName.c_str());
d3960 1
a3960 1
    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
d3962 1
a3962 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d3965 1
a3965 1
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
d4007 1
a4007 1
    const std::string & fileName,
d4011 2
a4012 2
 std::string pdf_PartName;
 std::ifstream inFile;
d4015 1
a4015 1
 std::string dataLine;
d4023 1
a4023 1
 std::ofstream outFile;
d4026 1
a4026 1
 bool aggregateSupplyInScrub = setOfParameters.getBool("aggregateSupplyInScrub");
d4037 1
a4037 1
   inFile.open(fileName.c_str());
d4059 2
a4060 2
    std::string pdf;
    std::string mfgPartName;
d4063 1
a4063 1
    std::getline( inFile, dataLine );
d4067 2
a4068 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty()){
d4073 1
a4073 1
    SCETokenizer next(dataLine);
d4101 1
a4101 1
    result = flatFileManager.nextFloat(supplyVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d4112 1
a4112 1
    std::string token;
d4115 1
a4115 1
    if ((token = next(" \",\n")).empty()) {
d4122 1
a4122 1
    SCEDate supplyDate(flatFileManager.parseDateString(token, theCal));
d4150 1
a4150 1
    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
d4152 1
a4152 1
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
d4185 1
a4185 1
    const std::string & fileName,
d4193 1
a4193 1
  std::string pdf_PartName;
d4196 1
a4196 1
  std::string dataLine;
d4198 2
a4199 2
  std::ifstream inFile;
  std::ofstream outFile;
d4243 1
a4243 1
    witGetPartSupplyVol(theWitRun, pdf_PartName.c_str(), &supplyVol);
d4245 1
a4245 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d4248 1
a4248 1
    witSetPartSupplyVol(theWitRun, pdf_PartName.c_str(), supplyVol);
d4271 1
a4271 1
    const std::string & fileName,
d4274 3
a4276 3
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;
d4278 1
a4278 1
  std::ifstream inFile;
d4280 1
a4280 1
  std::string dataLine;
d4293 1
a4293 1
 bool forcePcfBogons = setOfParameters.getBool("forcePcfBogons");
d4297 1
a4297 1
  inFile.open(fileName.c_str());
d4313 1
a4313 1
    std::getline( inFile, dataLine );
d4317 2
a4318 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d4332 1
a4332 1
    SCETokenizer next(dataLine);
d4346 1
a4346 1
    std::string token;
d4349 1
a4349 1
    if ((token = next(" \",\n")).empty()) {
d4353 1
a4353 1
      SCEDate startDate(flatFileManager.parseDateString(token, theCal));
d4405 1
a4405 1
    bool didWeRejectTheRecord = false;
d4410 1
a4410 1
    witGetOperationExists(theWitRun, pdf_PartName.c_str(), &exists);
d4413 1
a4413 1
    witGetOperationNBomEntries(theWitRun, pdf_PartName.c_str(), &nBom);
d4426 1
a4426 1
	didWeRejectTheRecord = true;
d4447 2
a4448 2
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
d4456 1
a4456 1
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
d4476 2
a4477 3
    witGetPartNProducingBopEntries(theWitRun, pdf_PartName.c_str(), &npBop);
    int p = 0; // Pulled out of the for below by RW2STL
    for (p=0; p<npBop; p++) {
d4480 1
a4480 1
      witGetPartProducingBopEntry(theWitRun, pdf_PartName.c_str(), p, &opName, &o);
d4483 1
a4483 1
      if (pdf_PartName.compare(opName)) {
d4491 1
a4491 1
        didWeRejectTheRecord = true;
d4507 2
a4508 2
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
d4516 1
a4516 1
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
d4529 2
a4530 3
      witGetOperationYieldRate(theWitRun, pdf_PartName.c_str(), &yieldRate);              
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<unConstrainedStartPeriod; t++)
d4532 1
a4532 1
      witSetOperationYieldRate(theWitRun, pdf_PartName.c_str(), yieldRate);
d4538 2
a4539 2
      witGetPartAppData(theWitRun, pdf_PartName.c_str(), (void **) &appDataPtr);
      if (appDataPtr != 0) {
d4546 1
a4546 1
      witSetPartAppData(theWitRun, pdf_PartName.c_str(), appDataPtr);
d4569 1
a4569 1
    const std::string & fileName,
d4572 3
a4574 3
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;
d4576 1
a4576 1
  std::ifstream inFile;
d4578 1
a4578 1
  std::string dataLine;
d4590 1
a4590 1
  inFile.open(fileName.c_str());
d4598 1
a4598 1
  std::ofstream outFile;
d4601 1
a4601 1
      if (sce::find(fileName, "/") != sce::badIndex) {
d4605 2
a4606 2
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
d4617 1
a4617 1
    std::getline( inFile, dataLine );
d4621 2
a4622 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d4626 1
a4626 1
    SCETokenizer next(dataLine);
d4638 1
a4638 1
    std::string token;
d4641 1
a4641 1
    if ((token = next(" \",\n")).empty()) {
d4645 1
a4645 1
      SCEDate startDate(flatFileManager.parseDateString(token, theCal));
d4684 1
a4684 1
    const std::string & fileName,
d4687 3
a4689 3
  std::string mfgPartName;
  std::string pdf_PartName;
  std::string pdf;
d4701 1
a4701 1
  std::ofstream outFile;
d4704 1
a4704 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d4709 2
a4710 2
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
d4720 1
a4720 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d4724 2
a4725 2
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
d4750 1
a4750 1
    const std::string & fileName,
d4754 3
a4756 3
  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;
d4758 2
a4759 2
  std::string demandName;
  std::ifstream inFile;
d4762 1
a4762 1
  std::string dataLine;
d4778 1
a4778 1
  std::ofstream outFile;
d4781 1
a4781 1
    if (sce::find(fileName, "/") != sce::badIndex) {
d4786 2
a4787 2
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
d4794 1
a4794 1
  inFile.open(fileName.c_str());
d4818 1
a4818 1
	assert(demandAppDataPtr != 0);
d4832 1
a4832 1
   std::getline( inFile, dataLine );
d4834 2
a4835 2
   dataLine = sce::strip( dataLine );
   if ((dataLine[0] == '*') || dataLine.empty())
d4837 1
a4837 1
   SCETokenizer next(dataLine);
d4865 2
a4866 2
		      geoPlannerDemandPartName.c_str(),
		      geo.c_str(),
d4868 1
a4868 1
  assert(demandAppDataPtr != 0);
d4878 2
a4879 2
  witGetDemandDemandVol(theWitRun, geoPlannerDemandPartName.c_str(), 
			geo.c_str(), &demandVol);
d4909 1
a4909 1
    const std::string & fileName,
d4913 3
a4915 3
  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;
d4917 2
a4918 2
  std::string demandName;
  std::ifstream inFile;
d4923 1
a4923 1
  std::string dataLine;
d4939 1
a4939 1
  std::ofstream outFile;
d4942 1
a4942 1
      if (sce::find(fileName, "/") != sce::badIndex) {
d4947 2
a4948 2
    std::string file = myScrubber -> scrubDir() + fileName;
    outFile.open(file.c_str(), std::ofstream::out);
d4955 1
a4955 1
  inFile.open(fileName.c_str());
d4980 1
a4980 1
	assert(demandAppDataPtr != 0);
d4994 1
a4994 1
   std::getline( inFile, dataLine );
d4996 2
a4997 2
   dataLine = sce::strip( dataLine );
   if ((dataLine[0] == '*') || dataLine.empty())
d4999 1
a4999 1
   SCETokenizer next(dataLine);
d5027 2
a5028 2
		      geoPlannerDemandPartName.c_str(),
		      geo.c_str(),
d5030 1
a5030 1
  assert(demandAppDataPtr != 0);
d5042 2
a5043 2
			      geoPlannerDemandPartName.c_str(),
		          geo.c_str(),
d5088 3
a5090 3
  std::string plannerPart;
  std::string geo;
  std::string geoPlannerDemandPartName;
d5113 1
a5113 1
	assert(demandAppDataPtr != 0);
d5117 1
a5117 1
	  witSetDemandAppData(theWitRun, partList[i], dList[j], (void *) 0);
d5189 1
a5189 1
  // the optExplodableFlags are set to false on all the non-default
d5199 1
a5199 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d5206 2
a5207 2
    std::string defaultOperationName (partList[i]);
    witGetOperationExists(theWitRun, defaultOperationName.c_str(), &defOpExists);
d5218 1
a5218 1
    witGetOperationNBomEntries(theWitRun, defaultOperationName.c_str(), &nBom);
d5227 1
a5227 1
      bool didWefindBopEntryForDefaultOperation = false;
d5229 1
a5229 2
      int p = 0; // Pulled out of the for below by RW2STL
      for (p=0; p<npBops; p++) { // p = prodIndex
d5237 4
a5240 4
          assert(didWefindBopEntryForDefaultOperation == false);
          didWefindBopEntryForDefaultOperation = true;
          witSetBopEntryEarliestPeriod(theWitRun, defaultOperationName.c_str(), bopEntryIndex, lastPeriod ); 
          witSetBopEntryLatestPeriod(theWitRun, defaultOperationName.c_str(), bopEntryIndex, 0 );
d5245 1
a5245 1
      if ( didWefindBopEntryForDefaultOperation != true ){       
d5267 1
a5267 1
    const std::string & fileName,
d5272 3
a5274 3
 std::string pdf_PartName;
 std::string demandName;
 std::ifstream inFile;
d5277 1
a5277 1
 std::string dataLine;
d5284 1
a5284 1
 inFile.open(fileName.c_str());
d5314 1
a5314 1
	true,           // Are all elements mandatory?
d5317 1
a5317 1
	true);          // Add demand stream to WIT if not there
d5328 2
a5329 2
    witGetDemandDemandVol(theWitRun, pdf_PartName.c_str(), 
			  demandName.c_str(), &demandVol);
d5334 2
a5335 2
			pdf_PartName.c_str(), 
			demandName.c_str(),
d5337 1
a5337 1
    assert(demandAppDataPtr != 0);
d5343 1
a5343 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d5349 2
a5350 2
      std::string pnm = mpHelper.partname(pdf_PartName);
      std::string pdfff = mpHelper.pdf(pdf_PartName);
d5358 1
a5358 1
    witSetDemandDemandVol(theWitRun, pdf_PartName.c_str(), demandName.c_str(), demandVol);
d5385 1
a5385 1
    const std::string & fileName,
d5390 5
a5394 5
 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::string demandName;
 std::ifstream inFile;
d5396 1
a5396 1
 std::string dataLine;
d5404 1
a5404 2
 int t = 0; // Pulled out of the for below by RW2STL
 for (t=0; t<nPeriods; t++) {
d5410 1
a5410 1
 std::ofstream outFile;
d5434 1
a5434 1
   std::getline( inFile, dataLine );
d5437 1
a5437 1
   dataLine = sce::strip( dataLine );
d5440 1
a5440 1
   if ((dataLine[0] == '*') || dataLine.empty()) {
d5446 1
a5446 1
   SCETokenizer next(dataLine);
d5493 1
a5493 1
    witAddDemand( theWitRun, fullWitPart.c_str(), demandName.c_str() );
d5498 2
a5499 2
			fullWitPart.c_str(), 
			demandName.c_str(), 
d5502 4
a5505 4
    witSetDemandPriority( theWitRun, fullWitPart.c_str(),
			  demandName.c_str(), defaultPriorityVec );
    witSetDemandShipLateLimit( theWitRun, fullWitPart.c_str(),
			       demandName.c_str(), defaultShipLateLimit );
d5509 1
a5509 1
    if ( lpModelHelper_ != 0 ) {
d5526 4
a5529 4
      witSetDemandObj1ShipReward( theWitRun, fullWitPart.c_str(),
				  demandName.c_str(), defaultObj1ShipRewardVec);
      witSetDemandObj1CumShipReward( theWitRun, fullWitPart.c_str(),
				     demandName.c_str(), defaultObj1CumShipRewardVec);
d5537 1
a5537 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
d5555 2
a5556 2
  witGetDemandAppData(theWitRun, fullWitPart.c_str(), demandName.c_str(), (void **) &demandAppDataPtr);
  assert(demandAppDataPtr != 0);
d5592 1
a5592 1
  witSetDemandDemandVol(theWitRun, fullWitPart.c_str(), demandName.c_str(), demandVolTVF.data());
d5623 1
a5623 1
    const std::string & fileName,
d5629 2
a5630 2
 std::string pdf_PartName;
 std::string demandName;
d5632 1
a5632 1
 std::string dataLine;
d5637 2
a5638 2
 std::ifstream inFile;
 std::ofstream outFile;
d5668 1
a5668 1
    	false,          // Are all elements mandatory?
d5670 2
a5671 2
	    INT_MAX,        // data upper limits
	    false);         // Add demand stream to WIT if not there
d5682 1
a5682 1
    if ( lpModelHelper_ != 0 ) {
d5685 1
a5685 1
      witGetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &rev);
d5687 1
a5687 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nElementsChanged; t++) {
d5691 1
a5691 1
      witSetDemandObj1ShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
d5697 1
a5697 1
      witSetDemandObj1CumShipReward(theWitRun, pdf_PartName.c_str(), demandName.c_str(), rev);
d5710 1
a5710 1
    witGetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), &priority);
d5712 1
a5712 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d5716 1
a5716 1
    witSetDemandPriority(theWitRun, pdf_PartName.c_str(), demandName.c_str(), priority);
d5742 1
a5742 1
    const std::string & fileName,
d5748 4
a5751 4
 std::string mfgPart;
 std::string pdf;
 std::string fullWitPart;
 std::string demandName;
d5753 1
a5753 1
 std::string dataLine;
d5761 2
a5762 2
 std::ifstream inFile;
 std::ofstream outFile;
d5788 1
a5788 1
   std::getline( inFile, dataLine );
d5791 1
a5791 1
   dataLine = sce::strip( dataLine );
d5794 1
a5794 1
   if ((dataLine[0] == '*') || dataLine.empty()) {
d5800 1
a5800 1
   SCETokenizer next(dataLine);
d5859 1
a5859 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
d5872 1
a5872 1
  if ( lpModelHelper_ != 0 ) {
d5874 1
a5874 1
    witGetDemandObj1ShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), &rev);
d5876 1
a5876 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d5880 1
a5880 1
    witSetDemandObj1ShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), rev);
d5886 1
a5886 1
    witSetDemandObj1CumShipReward(theWitRun, fullWitPart.c_str(), demandName.c_str(), rev);
d5897 1
a5897 1
  witGetDemandPriority(theWitRun, fullWitPart.c_str(), demandName.c_str(), &priority);
d5899 1
a5899 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nElementsChanged; t++) {
d5903 1
a5903 1
  witSetDemandPriority(theWitRun, fullWitPart.c_str(), demandName.c_str(), priority);
d5932 1
a5932 1
    const std::string & fileName,
d5936 2
a5937 2
 std::string pdf_PartName;
 std::string demandName;
d5943 2
a5944 2
 std::string dataLine;
 bool isRecordGood;
d5950 2
a5951 2
 std::ifstream inFile;
 std::ofstream outFile;
d5981 1
a5981 1
	false,          // Are all elements mandatory?
d5984 1
a5984 1
	false);         // Add demand stream to WIT if not there
d5996 2
a5997 2
			      pdf_PartName.c_str(), 
			      demandName.c_str(), 
d6003 2
a6004 2
                          pdf_PartName.c_str(),
                          demandName.c_str(),
d6010 1
a6010 1
    isRecordGood = true;
d6021 1
a6021 1
          isRecordGood = false;          
d6033 2
a6034 2
			pdf_PartName.c_str(), 
			demandName.c_str(),
d6036 1
a6036 1
       assert(demandAppDataPtr != 0);
d6041 2
a6042 2
          std::string pnm = mpHelper.partname(pdf_PartName);
          std::string pdfff = mpHelper.pdf(pdf_PartName);
d6060 2
a6061 2
                              pdf_PartName.c_str(), 
                              demandName.c_str(), 
d6107 1
a6107 1
    const std::string & fileName,
d6112 4
a6115 4
  std::string mfgPart;
  std::string pdf;
  std::string fullWitPart;
  std::string demandName;
d6122 1
a6122 1
  bool isRecordGood;
d6124 1
a6124 1
  std::ifstream inFile;
d6126 1
a6126 1
  std::string dataLine;
d6133 1
a6133 1
  std::ofstream outFile;
d6157 1
a6157 1
    std::getline( inFile, dataLine );
d6160 1
a6160 1
    dataLine = sce::strip( dataLine );
d6163 1
a6163 1
    if ((dataLine[0] == '*') || dataLine.empty()) {
d6169 1
a6169 1
    SCETokenizer next(dataLine);
d6228 1
a6228 1
    bool isMinDemandVolNegative = 0;
d6230 1
a6230 1
      int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false,
d6270 2
a6271 2
			      fullWitPart.c_str(), 
			      demandName.c_str(), 
d6277 2
a6278 2
			  fullWitPart.c_str(),
			  demandName.c_str(),
d6286 1
a6286 1
    isRecordGood = true;
d6296 1
a6296 1
	isRecordGood = false;          
d6312 2
a6313 2
			  fullWitPart.c_str(), 
			  demandName.c_str(),
d6315 1
a6315 1
      assert(demandAppDataPtr != 0);
d6321 2
a6322 2
	std::string pnm = mpHelper.partname(fullWitPart);
	std::string pdfff = mpHelper.pdf(fullWitPart);
d6337 2
a6338 2
				fullWitPart.c_str(), 
				demandName.c_str(), 
d6390 1
a6390 1
    const std::string & fileName,
d6394 2
a6395 2
  std::string pdf_PartName;
  std::string demandName;
d6397 1
a6397 1
  std::string dataLine;
d6402 2
a6403 2
  std::ifstream inFile;
  std::ofstream outFile;
d6432 1
a6432 1
	false,          // Are all elements mandatory?
d6435 1
a6435 1
	false);         // Add demand stream to WIT if not there
d6448 2
a6449 2
			pdf_PartName.c_str(), 
			demandName.c_str(),
d6454 1
a6454 1
    // If the demandAppDataPtr hasn't been set (i.e., its 0) then "new" one
d6457 2
a6458 2
    // If it hasn't (i.e. the backlogYield is 0), then set it. Otherwise, do nothing.
    if (demandAppDataPtr == 0)  {
d6460 1
a6460 1
      assert ( demandAppDataPtr != 0);
d6463 2
a6464 2
                          pdf_PartName.c_str(), 
                          demandName.c_str(), 
d6469 1
a6469 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d6498 1
a6498 1
    const std::string & fileName,
d6503 1
a6503 1
 std::string pdf_PartName;
d6508 1
a6508 1
 std::string dataLine;
d6513 2
a6514 2
 std::ifstream inFile;
 std::ofstream outFile;
d6557 1
a6557 1
    witGetPartProdBounds(theWitRun, pdf_PartName.c_str(), &pvhLB, &pvsLB, &pvhUB);
d6559 1
a6559 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d6562 1
a6562 1
    witSetPartProdBounds(theWitRun, pdf_PartName.c_str(), pvhLB, pvsLB, pvhUB);
d6588 1
a6588 1
    const std::string & fileName,
d6593 1
a6593 1
 std::string pdf_PartName;
d6598 1
a6598 1
 std::string dataLine;
d6603 2
a6604 2
 std::ifstream inFile;
 std::ofstream outFile;
d6646 1
a6646 1
    witGetPartProdBounds(theWitRun, pdf_PartName.c_str(), &pvhLB, &pvsLB, &pvhUB);
d6649 1
a6649 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d6661 1
a6661 1
    witSetPartProdBounds(theWitRun, pdf_PartName.c_str(), pvhLB, pvsLB, pvhUB);
d6688 1
a6688 1
    const std::string & fileName,
d6693 1
a6693 1
 std::string pdf_OperationName;
d6698 1
a6698 1
 std::string dataLine;
d6703 2
a6704 2
 std::ifstream inFile;
 std::ofstream outFile;
d6747 1
a6747 1
    witGetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), &hardLB, &softLB, &hardUB);
d6749 1
a6749 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d6752 1
a6752 1
    witSetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), hardLB, softLB, hardUB);
d6777 1
a6777 1
    const std::string & fileName,
d6782 1
a6782 1
 std::string pdf_OperationName;
d6787 1
a6787 1
 std::string dataLine;
d6792 2
a6793 2
 std::ifstream inFile;
 std::ofstream outFile;
d6835 1
a6835 1
    witGetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), &hardLB, &softLB, &hardUB);
d6838 1
a6838 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nElementsChanged; t++) {
d6850 1
a6850 1
    witSetOperationExecBounds(theWitRun, pdf_OperationName.c_str(), hardLB, softLB, hardUB);
d6877 1
a6877 1
    const std::string & fileName,
d6882 1
a6882 1
 std::string pdf_PartName;
d6888 1
a6888 1
 std::string dataLine;
d6893 2
a6894 2
 std::ifstream inFile;
 std::ofstream outFile;
d6925 1
a6925 1
    witGetPartCycleTime(theWitRun, pdf_PartName.c_str(), &ct);
d6927 1
a6927 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d6930 1
a6930 1
    witSetPartCycleTime(theWitRun, pdf_PartName.c_str(), ct);
d6955 1
a6955 1
    const std::string & fileName,
d6960 1
a6960 1
 std::string pdf_PartName;
d6966 1
a6966 1
 std::string dataLine;
d6971 2
a6972 2
 std::ifstream inFile;
 std::ofstream outFile;
d7002 1
a7002 1
    witGetPartYield(theWitRun, pdf_PartName.c_str(), &yield);
d7004 1
a7004 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d7007 1
a7007 1
    witSetPartYield(theWitRun, pdf_PartName.c_str(), yield);
d7032 1
a7032 1
    const std::string & fileName,
d7036 1
a7036 1
 std::string pdf_OperationName;
d7042 1
a7042 1
 std::string dataLine;
d7047 2
a7048 2
 std::ifstream inFile;
 std::ofstream outFile;
d7078 1
a7078 1
    witGetOperationYield(theWitRun, pdf_OperationName.c_str(), &yield);
d7080 1
a7080 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d7083 1
a7083 1
    witSetOperationYield(theWitRun, pdf_OperationName.c_str(), yield);
d7109 1
a7109 1
    const std::string & fileName,
d7114 1
a7114 1
 std::string pdf_PartName;
d7121 1
a7121 1
 std::string dataLine;
d7126 2
a7127 2
 std::ifstream inFile;
 std::ofstream outFile;
d7157 2
a7158 2
    witGetPartMinLotSize(theWitRun, pdf_PartName.c_str(), &minLotSize);
    witGetPartIncLotSize(theWitRun, pdf_PartName.c_str(), &incLotSize);
d7160 1
a7160 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d7164 2
a7165 2
    witSetPartMinLotSize(theWitRun, pdf_PartName.c_str(), minLotSize);
    witSetPartIncLotSize(theWitRun, pdf_PartName.c_str(), incLotSize);
d7193 1
a7193 1
    const std::string & fileName,
d7197 1
a7197 1
 std::string pdf_OperationName;
d7204 1
a7204 1
 std::string dataLine;
d7209 2
a7210 2
 std::ifstream inFile;
 std::ofstream outFile;
d7240 2
a7241 2
    witGetOperationMinLotSize(theWitRun, pdf_OperationName.c_str(), &minLotSize);
    witGetOperationIncLotSize(theWitRun, pdf_OperationName.c_str(), &incLotSize);
d7243 1
a7243 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d7247 2
a7248 2
    witSetOperationMinLotSize(theWitRun, pdf_OperationName.c_str(), minLotSize);
    witSetOperationIncLotSize(theWitRun, pdf_OperationName.c_str(), incLotSize);
d7274 1
a7274 1
    const std::string & fileName,
d7278 1
a7278 1
 std::string pdf_OperationName;
d7282 1
a7282 1
 std::string dataLine;
d7287 2
a7288 2
 std::ifstream inFile;
 std::ofstream outFile;
d7320 1
a7320 1
    witSetOperationExecPenalty(theWitRun, pdf_OperationName.c_str(), execPenalty);
d7345 1
a7345 1
    const std::string & fileName,
d7349 1
a7349 1
 std::string pdf_OperationName;
d7355 1
a7355 1
 std::string dataLine;
d7360 2
a7361 2
 std::ifstream inFile;
 std::ofstream outFile;
d7391 1
a7391 1
    witGetOperationObj1ExecCost(theWitRun, pdf_OperationName.c_str(), &execCost);
d7393 1
a7393 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d7396 1
a7396 1
    witSetOperationObj1ExecCost(theWitRun, pdf_OperationName.c_str(), execCost);
d7433 1
a7433 1
    std::string fileName = setOfParameters.getString("calendarFile");
d7435 2
a7436 2
    std::ifstream inFile;
    std::ofstream outFile;
d7454 2
a7455 2
	std::string dataLine;
	std::string token;
d7458 1
a7458 1
	std::getline( inFile, dataLine );
d7462 2
a7463 2
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d7477 1
a7477 1
	SCETokenizer next(dataLine);
d7483 1
a7483 1
    if (! sce::fromString(token, pd))  {
d7511 1
a7511 1
	if ((token = next(dataDelim)).empty())    {
d7521 2
a7522 2
	SCEDate theStartDate(flatFileManager.parseDateString(token, theCal));
	SCETime startDate(theStartDate);
d7565 1
a7565 1
	if ((token = next(dataDelim)).empty())    {
d7575 1
a7575 1
	else if (! sce::fromString(token, wu))  {
d7633 1
a7633 1
    const std::string & geoSourceFile,
d7636 1
a7636 1
    bool createMfgPart)
d7650 1
a7650 1
    std::string engine = setOfParameters.getString("engine");
d7652 1
a7652 1
    std::string fileName(geoSourceFile);
d7654 2
a7655 2
    std::ifstream inFile;
    std::ofstream outFile;
d7658 1
a7658 1
    inFile.open(fileName.c_str());
d7682 5
a7686 5
    std::string dataLine;
    std::string plannerPartName;
    std::string geo;
    std::string partName;
    std::string pdf;
d7698 1
a7698 1
	std::getline( inFile, dataLine );
d7702 1
a7702 1
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d7716 1
a7716 1
	SCETokenizer next(dataLine);
d7753 1
a7753 1
	flatFileManager.nextFloat(transitTime, next, fileName, dataLine, lineNo, false, -FLT_MAX);
d7758 1
a7758 1
	std::string geoPlannerDemandPartName = 
d7760 1
a7760 1
	std::string pdfPartname = mpHelper.pdfPartname(partName, pdf);
d7771 1
a7771 1
	    // if createMfgPart is true, then we want to create the child
d7817 1
a7817 1
            std::string geoPlannerDemandUbPartName =
d7878 1
a7878 1
    const std::string & fileName,
d7882 3
a7884 3
    std::string operationName;
    std::string pdf;
    std::string dataLine;
d7891 2
a7892 2
    std::ifstream inFile;
    std::ofstream outFile;
d7909 1
a7909 1
	std::getline( inFile, dataLine );
d7913 2
a7914 2
	dataLine = sce::strip( dataLine );
	if ((dataLine.empty()) || (dataLine[0] == '*')) {
d7925 1
a7925 1
	SCETokenizer next(dataLine);
d7976 2
a7977 2
                     std::string & geoPlannerDemandPartName,   // special partname for  this demand
                     std::string & geo,                  // demandName to be returned
d7979 3
a7981 3
                     std::ifstream & inFile,                 // An open stream
                     const std::string & fileName,       // for messaging
                     std::string & dataLine,
d7984 1
a7984 1
                     bool Mandatory,              // Are all elements mandatory?
d7987 1
a7987 1
                     bool addDemandIfFound)       // Add demand stream if not there
d7989 1
a7989 1
  std::string plannerPartName;
d7994 1
a7994 1
  std::getline( inFile, dataLine );
d7997 1
a7997 1
  dataLine = sce::strip( dataLine );
d8000 1
a8000 1
  if ((dataLine[0] == '*') || dataLine.empty())
d8005 1
a8005 1
  SCETokenizer next(dataLine);
d8047 1
a8047 1
    std::string pdfPartname = mpHelper.pdfPartname(plannerPartName, 
d8133 1
a8133 1
      witAddDemand( theWitRun, geoPlannerDemandPartName.c_str(), geo.c_str() );
d8138 2
a8139 2
                          geoPlannerDemandPartName.c_str(), 
                          geo.c_str(), 
d8142 4
a8145 4
      witSetDemandPriority( theWitRun, geoPlannerDemandPartName.c_str(),
                            geo.c_str(), defaultPriorityVec );
      witSetDemandShipLateLimit( theWitRun, geoPlannerDemandPartName.c_str(),
                                 geo.c_str(), defaultShipLateLimit );
d8149 1
a8149 1
      if ( lpModelHelper_ != 0 ) {
d8166 4
a8169 4
        witSetDemandObj1ShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                    geo.c_str(), defaultObj1ShipRewardVec);
        witSetDemandObj1CumShipReward( theWitRun, geoPlannerDemandPartName.c_str(),
                                       geo.c_str(), defaultObj1CumShipRewardVec);
d8191 1
a8191 1
    int result = flatFileManager.nextFloat(floatVec[t], next, fileName, dataLine, lineNo, false);
d8203 1
a8203 1
bool
d8205 1
a8205 1
    const std::string & targetFile)
d8207 1
a8207 1
    std::ifstream inFile;
d8209 1
a8209 1
    inFile.open(targetFile.c_str());
d8213 1
a8213 1
	return true;
d8216 1
a8216 1
    return false;
d8226 2
a8227 2
    const std::string &  partName,
    const std::string &  demandName)
d8236 1
a8236 1
  witGetPartExists(theWitRun, partName.c_str(), &exists);
d8241 1
a8241 1
  witGetPartDemands(theWitRun, partName.c_str(), &nDemands, &demandList);
d8274 2
a8275 2
    const std::string & part, 
    const std::string & pdf,
d8277 2
a8278 2
    const std::string & fileName,
    const std::string & dataLine,
d8281 1
a8281 1
    std::string partName = mpHelper.pdfPartname(part, pdf);
d8303 1
a8303 1
    witAddPartWithOperation(theWitRun, partName.c_str());
d8310 1
a8310 1
    witSetBopEntryAppData( theWitRun, partName.c_str(), 0, (void *) myBadPtr );
d8315 1
a8315 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d8318 2
a8319 2
    witSetOperationIncLotSize(theWitRun, partName.c_str(), vecOfOnes);
    witSetOperationMinLotSize(theWitRun, partName.c_str(), vecOfOnes);
d8323 1
a8323 1
    if (lpModelHelper_ != 0) {
d8333 1
a8333 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=1; t<nPeriods; t++)
d8336 1
a8336 1
      witSetOperationObj1ExecCost(theWitRun, partName.c_str(), obj1ProdCost);
d8353 2
a8354 2
    const std::string & capacity, 
    const std::string & pdf,
d8356 2
a8357 2
    const std::string & fileName,
    const std::string & dataLine,
d8360 1
a8360 1
    std::string capacityName = mpHelper.pdfPartname(capacity, pdf);
d8372 1
a8372 1
    witAddPart(theWitRun, capacityName.c_str(), WitCAPACITY);
d8386 2
a8387 2
    const std::string & operationName, 
    const std::string & pdf,
d8389 2
a8390 2
    const std::string & fileName,
    const std::string & dataLine,
d8393 1
a8393 1
    std::string pdfOperationName = mpHelper.pdfOperationName(operationName, pdf);
d8417 1
a8417 1
    witAddOperation(theWitRun, pdfOperationName.c_str());
d8423 1
a8423 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d8425 2
a8426 2
    witSetOperationMinLotSize(theWitRun, pdfOperationName.c_str(), vecOfOnes);
    witSetOperationIncLotSize(theWitRun, pdfOperationName.c_str(), vecOfOnes);
d8429 1
a8429 1
    if (lpModelHelper_ != 0) {
d8442 1
a8442 1
      witSetOperationObj1ExecCost(theWitRun, pdfOperationName.c_str(), obj1ExecCost);
d8459 4
a8462 4
    const std::string & producedPart, 
    const std::string & producedPartPdf,
    const std::string & operation, 
    const std::string & operationPdf, 
d8470 2
a8471 2
    const std::string & fileName,
    const std::string & dataLine,
d8478 2
a8479 2
    std::string pdfProducedPartName( mpHelper.pdfPartname(producedPart, producedPartPdf) );
    std::string pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );
d8493 1
a8493 1
    witGetOperationNBopEntries( theWitRun, pdfOperationName.c_str(), &bopEntryIndex);
d8498 2
a8499 3
    bool isOperationAlreadyUsedbyProducedPart = false;
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<bopEntryIndex; b++) {
d8501 1
a8501 1
      witGetBopEntryProducedPart(theWitRun, pdfOperationName.c_str(), b, &ppName);
d8503 1
a8503 1
        isOperationAlreadyUsedbyProducedPart = true;
d8514 2
a8515 2
      witGetPartAppData(theWitRun, pdfProducedPartName.c_str(), (void **) &custPartAppData);
      if (custPartAppData == 0) {
d8518 1
a8518 1
        witSetPartAppData(theWitRun, pdfProducedPartName.c_str(), (void *) custPartAppData);
d8527 2
a8528 2
    witAddBopEntry( theWitRun, pdfOperationName.c_str(), pdfProducedPartName.c_str() );
    witSetBopEntryProdRate( theWitRun, pdfOperationName.c_str(), bopEntryIndex, prodRate );
d8531 2
a8532 3
    witGetBopEntryOffset( theWitRun, pdfOperationName.c_str(), bopEntryIndex, &offsetTimeVec );
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=early; i<=late; i++)
d8534 1
a8534 1
    witSetBopEntryOffset( theWitRun, pdfOperationName.c_str(), bopEntryIndex, offsetTimeVec );
d8536 2
a8537 2
    witSetBopEntryEarliestPeriod( theWitRun, pdfOperationName.c_str(), bopEntryIndex, early );
    witSetBopEntryLatestPeriod( theWitRun, pdfOperationName.c_str(), bopEntryIndex, late );
d8551 2
a8552 2
    witGetBopEntryAppData( theWitRun, pdfOperationName.c_str(), bopEntryIndex, (void **) &myBadPtr );
    if ( myBadPtr != 0 ) {
d8565 1
a8565 1
                           pdfOperationName.c_str(),
d8570 1
a8570 1
    //   witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, WitTRUE);
d8572 2
a8573 2
  witSetBopEntryExpAllowed(theWitRun, pdfOperationName.c_str(), bopEntryIndex, isBuildable);
  witSetBopEntryExpAversion(theWitRun, pdfOperationName.c_str(), bopEntryIndex, pref);
d8587 4
a8590 4
    const std::string & operation, 
    const std::string & operationPdf,
    const std::string & consumedPart, 
    const std::string & consumedPartPdf, 
d8596 2
a8597 2
    const std::string & fileName,
    const std::string & dataLine,
d8600 2
a8601 2
    std::string pdfConsumedPartName( mpHelper.pdfPartname(consumedPart, consumedPartPdf) );
    std::string pdfOperationName( mpHelper.pdfOperationName(operation, operationPdf)  );
d8613 3
a8615 3
    witGetOperationNBomEntries( theWitRun, pdfOperationName.c_str(), &bomEntryIndex);
    witAddBomEntry( theWitRun, pdfOperationName.c_str(), pdfConsumedPartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, pdfOperationName.c_str(), bomEntryIndex, usageRate );
d8618 2
a8619 3
    witGetBomEntryOffset( theWitRun, pdfOperationName.c_str(), bomEntryIndex, &offsetTimeVec );
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=early; i<=late; i++)
d8621 4
a8624 4
    witSetBomEntryOffset( theWitRun, pdfOperationName.c_str(), bomEntryIndex, offsetTimeVec );
    witSetBomEntryEarliestPeriod( theWitRun, pdfOperationName.c_str(), bomEntryIndex, early );
    witSetBomEntryLatestPeriod( theWitRun, pdfOperationName.c_str(), bomEntryIndex, late );
    witSetBomEntryFallout( theWitRun, pdfOperationName.c_str(), bomEntryIndex, fallout );
d8638 2
a8639 2
    const std::string & part, 
    const std::string & pdf,
d8641 2
a8642 2
    const std::string & fileName,
    const std::string & dataLine,
d8652 1
a8652 1
    const std::string & fullPartname, 
d8654 2
a8655 2
    const std::string & fileName,
    const std::string & dataLine,
d8658 1
a8658 1
    witAddPartWithOperation(theWitRun, fullPartname.c_str());
d8665 1
a8665 1
      defSOP.push_back(partToBeAdded);
d8669 1
a8669 1
      intrPlant.push_back(partToBeAdded);
d8681 1
a8681 1
    const std::string & fullPartname, 
d8683 2
a8684 2
    const std::string & fileName,
    const std::string & dataLine,
d8687 1
a8687 1
    witAddPart(theWitRun, fullPartname.c_str(), WitRAW);
d8733 4
a8736 4
                                                    const std::string & destinationPart,
                                                    const std::string & destinationPdf,
                                                    const std::string & sourcePart, 
                                                    const std::string & sourcePdf,
d8746 2
a8747 2
                                                    const std::string & fileName,
                                                    const std::string & dataLine,
d8751 1
a8751 1
  witBoolean isUnique = true;
d8756 2
a8757 2
  std::string fullDestinationPartName(mpHelper.pdfPartname(destinationPart, destinationPdf));
  std::string fullSourcePartName( mpHelper.pdfPartname(sourcePart,  sourcePdf));
d8774 1
a8774 1
  std::string interPlantOperationName =
d8778 1
a8778 1
  witGetOperationExists(theWitRun, interPlantOperationName.c_str(), &exists);
d8803 5
a8807 5
    witAddOperation( theWitRun, interPlantOperationName.c_str() );
    witSetOperationMinLotSize( theWitRun, interPlantOperationName.c_str(), defaultLotSize );
    witSetOperationIncLotSize( theWitRun, interPlantOperationName.c_str(), defaultLotSize );
    witAddBomEntry( theWitRun, interPlantOperationName.c_str(), fullSourcePartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, interPlantOperationName.c_str(), 0, usageRate );
d8810 2
a8811 2
    witSetBomEntryEarliestPeriod( theWitRun, interPlantOperationName.c_str(), 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, interPlantOperationName.c_str(), 0, nPeriods-1 );
d8813 1
a8813 1
      witSetBomEntryExecPenalty(theWitRun, interPlantOperationName.c_str(), 0, preference);
d8820 2
a8821 2
    witGetPartAppData(theWitRun, fullDestinationPartName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
d8824 1
a8824 1
      witSetPartAppData(theWitRun, fullDestinationPartName.c_str(), (void *) custPartAppData);
d8833 2
a8834 2
    // set unique flag = false
    isUnique = false;
d8867 1
a8867 1
  witGetOperationNBomEntries(theWitRun, interPlantOperationName.c_str(), &nBom);
d8875 3
a8877 3
  witGetOperationNBopEntries( theWitRun, interPlantOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, interPlantOperationName.c_str(), fullDestinationPartName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, interPlantOperationName.c_str(),
d8879 1
a8879 1
  witSetBopEntryLatestPeriod( theWitRun, interPlantOperationName.c_str(),
d8885 1
a8885 1
  witGetBomEntryOffset(theWitRun, interPlantOperationName.c_str(), 0, &offset);
d8888 1
a8888 1
  witSetBomEntryOffset(theWitRun, interPlantOperationName.c_str(), 0, offset);
d8896 2
a8897 2
  witGetOperationMinLotSize( theWitRun, interPlantOperationName.c_str(), &interPlantMinLotSize );
  witGetOperationIncLotSize( theWitRun, interPlantOperationName.c_str(), &interPlantIncLotSize );
d8904 2
a8905 2
  witSetOperationMinLotSize(theWitRun, interPlantOperationName.c_str(), interPlantMinLotSize);
  witSetOperationIncLotSize(theWitRun, interPlantOperationName.c_str(), interPlantIncLotSize);
d8914 2
a8915 2
  witGetBopEntryAppData( theWitRun, interPlantOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
d8929 1
a8929 1
  witSetBopEntryAppData( theWitRun, interPlantOperationName.c_str(),
d8936 2
a8937 2
  witSetBopEntryExpAllowed(theWitRun, interPlantOperationName.c_str(), nbBop, isInterplantExplodeableAsSubstitute);
  witSetBopEntryExpAversion(theWitRun, interPlantOperationName.c_str(), nbBop, preference);
d8939 1
a8939 1
  if ( lpModelHelper_ != 0 ) {    
d8941 1
a8941 1
    witGetOperationObj1ExecCost(theWitRun, interPlantOperationName.c_str(), &opExecCost);
d8944 1
a8944 1
    witSetOperationObj1ExecCost(theWitRun, interPlantOperationName.c_str(), opExecCost);
d8988 4
a8991 4
                                                    const std::string & markedPart,
                                                    const std::string & markedPdf,
                                                    const std::string & unmarkedPart, 
                                                    const std::string & unmarkedPdf,
d9001 2
a9002 2
                                                    const std::string & fileName,
                                                    const std::string & dataLine,
d9006 1
a9006 1
  witBoolean isUnique = true;
d9011 2
a9012 2
  std::string fullmarkedPartName(mpHelper.pdfPartname(markedPart, markedPdf));
  std::string fullunmarkedPartName( mpHelper.pdfPartname(unmarkedPart,  unmarkedPdf));
d9029 1
a9029 1
  std::string binOperationName =
d9033 1
a9033 1
  witGetOperationExists(theWitRun, binOperationName.c_str(), &exists);
d9058 5
a9062 5
    witAddOperation( theWitRun, binOperationName.c_str() );
    witSetOperationMinLotSize( theWitRun, binOperationName.c_str(), defaultLotSize );
    witSetOperationIncLotSize( theWitRun, binOperationName.c_str(), defaultLotSize );
    witAddBomEntry( theWitRun, binOperationName.c_str(), fullunmarkedPartName.c_str() );
    witSetBomEntryUsageRate( theWitRun, binOperationName.c_str(), 0, usageRate );
d9065 2
a9066 2
    witSetBomEntryEarliestPeriod( theWitRun, binOperationName.c_str(), 0, 0 );
    witSetBomEntryLatestPeriod( theWitRun, binOperationName.c_str(), 0, nPeriods-1 );
d9072 2
a9073 2
    witGetPartAppData(theWitRun, fullmarkedPartName.c_str(), (void **) &custPartAppData);
    if (custPartAppData == 0) {
d9076 1
a9076 1
      witSetPartAppData(theWitRun, fullmarkedPartName.c_str(), (void *) custPartAppData);
d9085 2
a9086 2
    // set unique flag = false
    isUnique = false;
d9119 1
a9119 1
  witGetOperationNBomEntries(theWitRun, binOperationName.c_str(), &nBom);
d9127 3
a9129 3
  witGetOperationNBopEntries( theWitRun, binOperationName.c_str(), &nbBop );      
  witAddBopEntry( theWitRun, binOperationName.c_str(), fullmarkedPartName.c_str() );
  witSetBopEntryEarliestPeriod( theWitRun, binOperationName.c_str(),
d9131 1
a9131 1
  witSetBopEntryLatestPeriod( theWitRun, binOperationName.c_str(),
d9137 1
a9137 1
  witGetBomEntryOffset(theWitRun, binOperationName.c_str(), 0, &offset);
d9140 1
a9140 1
  witSetBomEntryOffset(theWitRun, binOperationName.c_str(), 0, offset);
d9148 2
a9149 2
  witGetOperationMinLotSize( theWitRun, binOperationName.c_str(), &binMinLotSize );
  witGetOperationIncLotSize( theWitRun, binOperationName.c_str(), &binIncLotSize );
d9156 2
a9157 2
  witSetOperationMinLotSize(theWitRun, binOperationName.c_str(), binMinLotSize);
  witSetOperationIncLotSize(theWitRun, binOperationName.c_str(), binIncLotSize);
d9166 2
a9167 2
  witGetBopEntryAppData( theWitRun, binOperationName.c_str(), nbBop, &bopAppVoidPtr );
  if ( bopAppVoidPtr != 0 ) {
d9183 1
a9183 1
  witSetBopEntryAppData( theWitRun, binOperationName.c_str(),
d9190 2
a9191 2
  witSetBopEntryExpAllowed(theWitRun, binOperationName.c_str(), nbBop, isBinExplodeableAsSubstitute);
  witSetBopEntryExpAversion(theWitRun, binOperationName.c_str(), nbBop, preference);
d9226 3
a9228 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
d9233 2
a9234 2
    const std::string & fileName,
    const std::string & dataLine,
d9244 1
a9244 1
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
d9263 1
a9263 1
    std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d9284 1
a9284 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)  
d9295 5
a9299 5
    witAddPartWithOperation( theWitRun, fullBbCategoryPart.c_str());
    witSetBopEntryExpAversion(theWitRun, fullBbCategoryPart.c_str(), 0, -999999.0);
    if ( lpModelHelper_ != 0) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart.c_str(), featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart.c_str(), featureSetScrapPenaltyVec );
d9308 1
a9308 1
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), fullBbCategoryPart.c_str());
d9326 3
a9328 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
d9333 2
a9334 2
    const std::string & fileName,
    const std::string & dataLine,
d9344 1
a9344 1
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo,
d9363 1
a9363 1
    std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d9384 1
a9384 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)  
d9393 4
a9396 4
    witAddPartWithOperation( theWitRun, fullBbCategoryPart.c_str() );
    if ( lpModelHelper_ != 0) {
      witSetPartObj1StockCost( theWitRun, fullBbCategoryPart.c_str(), featureSetStockPenaltyVec );
      witSetPartObj1ScrapCost( theWitRun, fullBbCategoryPart.c_str(), featureSetScrapPenaltyVec );
d9404 1
a9404 1
    witAddBomEntry(theWitRun, geoPlannerDemandPart.c_str(), fullBbCategoryPart.c_str());
d9409 1
a9409 1
    std::string LTbbCapacityPartName = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
d9411 1
a9411 1
    std::string GTbbCapacityPartName = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
d9424 2
a9425 2
    witAddPart(theWitRun, LTbbCapacityPartName.c_str(), WitCAPACITY);
    witAddPart(theWitRun, GTbbCapacityPartName.c_str(), WitCAPACITY);
d9427 2
a9428 2
    witSetPartSupplyVol(theWitRun, GTbbCapacityPartName.c_str(), infiniteCapacity);
    witSetPartSupplyVol(theWitRun, LTbbCapacityPartName.c_str(), infiniteCapacity);
d9435 1
a9435 1
    witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), LTbbCapacityPartName.c_str(),
d9437 2
a9438 2
		     0);
    witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), GTbbCapacityPartName.c_str(),
d9440 1
a9440 1
		     0);
d9461 4
a9464 4
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const std::string & mfgOptionPart, 
d9467 2
a9468 2
    const std::string & fileName,
    const std::string & dataLine,
d9478 3
a9480 3
    bool nullOption = false;
    if (0 == sce::compareStringsCaseIns( mfgOptionPart, "nullOption" ))
      nullOption = true;
d9483 1
a9483 1
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
d9503 1
a9503 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d9525 1
a9525 1
    std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
d9529 1
a9529 1
    std::string optionRatioSupply = 
d9573 1
a9573 1
    std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d9585 1
a9585 1
    std::string pdf(mpHelper.pdf(mfgTopLevelPart));
d9588 1
a9588 1
    std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d9625 1
a9625 1
    witAddPartWithOperation(theWitRun, optionDummy.c_str());
d9629 1
a9629 1
      if ( lpModelHelper_ != 0 )  {
d9635 1
a9635 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)  
d9637 1
a9637 1
        witSetOperationObj1ExecCost( theWitRun, optionDummy.c_str(), optionDummyExecCost );
d9647 2
a9648 2
    witGetOperationNBomEntries(theWitRun, fullBbCategoryPart.c_str(), &nBomBBCat);
    witAddBomEntry(theWitRun, fullBbCategoryPart.c_str(), optionDummy.c_str());      
d9650 1
a9650 1
    witSetBomEntryUsageRate(theWitRun, fullBbCategoryPart.c_str(), nBomBBCat, featureRatio[0]);
d9664 1
a9664 1
    witAddPart( theWitRun, optionRatioSupply.c_str(), WitMATERIAL );
d9666 1
a9666 1
    if ( lpModelHelper_ != 0 )   {
d9670 1
a9670 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)  
d9672 1
a9672 1
        witSetPartObj1StockCost( theWitRun, optionRatioSupply.c_str(),
d9682 2
a9683 3
    witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &optionOffsets);
    int tt = 0; // Pulled out of the for below by RW2STL
    for (tt=0; tt<nPeriods; tt++)
d9689 1
a9689 1
    witAddBomEntry(theWitRun, optionDummy.c_str(), optionRatioSupply.c_str());
d9701 5
a9705 5
      witGetOperationNBomEntries(theWitRun, optionDummy.c_str(), &nBomSOD);
      witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
      witSetBomEntryUsageRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRate);
      witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffsets);
      witSetBomEntryMandEC(theWitRun, optionDummy.c_str(), nBomSOD, WitTRUE);
d9712 1
a9712 1
    witAddBomEntry(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str());
d9715 2
a9716 2
    witSetBomEntryUsageRate(theWitRun, optionDummy.c_str(), nBomSOD, usageRate);
    witSetBomEntryOffset(theWitRun, optionDummy.c_str(), nBomSOD, optionOffsets);
d9718 2
a9719 2
    // witSetBomEntryEarliestPeriod(theWitRun, optionDummy.c_str(), nBomSOD, sourceBeginPeriod);
    // witSetBomEntryLatestPeriod(theWitRun, optionDummy.c_str(), nBomSOD, sourceEndPeriod);
d9750 4
a9753 4
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & bbCategory, 
    const std::string & mfgOptionPart, 
d9756 2
a9757 2
    const std::string & fileName,
    const std::string & dataLine,
d9766 3
a9768 3
    bool nullOption = false;
    if (0 == sce::compareStringsCaseIns( mfgOptionPart, "nullOption" ))
      nullOption = true;
d9771 1
a9771 1
    std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart, geo, 
d9792 1
a9792 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d9814 1
a9814 1
    std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo,
d9818 1
a9818 1
    std::string optionRatioSupply = 
d9851 1
a9851 1
                   0);
d9863 1
a9863 1
      witAddPartWithOperation( theWitRun, optionDummy.c_str() );
d9866 2
a9867 2
      if ( lpModelHelper_ != 0 )
        witSetOperationObj1ExecCost( theWitRun, optionDummy.c_str(), optionDummyProdCost );
d9889 1
a9889 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=ratioBeginPeriod; t<nPeriods; t++) {
d9897 1
a9897 1
      witAddBomEntryVa(theWitRun, fullBbCategoryPart.c_str(), optionDummy.c_str(),
d9901 1
a9901 1
                       0);
d9928 4
a9931 4
    witAddPart( theWitRun, optionRatioSupply.c_str(), WitMATERIAL );
    //     witAddPartWithOperation( theWitRun, optionRatioSupply.c_str() );
    if ( lpModelHelper_ != 0 )
      witSetPartObj1StockCost( theWitRun, optionRatioSupply.c_str(),
d9939 1
a9939 1
    witAddBomEntry(theWitRun, optionDummy.c_str(), optionRatioSupply.c_str());
d9953 1
a9953 1
        std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d9965 1
a9965 1
        std::string pdf(mpHelper.pdf(mfgTopLevelPart));
d9968 1
a9968 1
        std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d9997 2
a9998 2
        witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);
        std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10002 1
a10002 1
        witAddBomEntryVa(theWitRun, optionDummy.c_str(), fullOptionPartName.c_str(),
d10008 1
a10008 1
                         0);
d10019 1
a10019 1
    std::string myLTpart = mpHelper.LTbbCapacityPartName(plannerTopLevelPart, geo,
d10022 1
a10022 1
    std::string myGTpart = mpHelper.GTbbCapacityPartName(plannerTopLevelPart, geo,
d10025 1
a10025 1
    witAddBomEntryVa(theWitRun, optionDummy.c_str(), myLTpart.c_str(),
d10027 1
a10027 1
		     0);
d10029 1
a10029 1
    witAddBomEntryVa(theWitRun, optionDummy.c_str(), myGTpart.c_str(),
d10031 1
a10031 1
		     0);
d10039 1
a10039 1
    witSetPartSupplyVol(theWitRun, optionRatioSupply.c_str(), featureRatio);    
d10051 3
a10053 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
d10056 2
a10057 2
    const std::string & fileName,
    const std::string & dataLine,
d10068 1
a10068 1
  bool foundMatch = false;
d10073 1
a10073 1
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10088 2
a10089 3
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBom; j++) {
d10091 2
a10092 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &child);
    std::string pp, g, bb;
d10095 1
a10095 1
      std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
d10099 3
a10101 3
        if ( lpModelHelper_ != 0) 
          witSetOperationObj1ExecCost(theWitRun, optionDummy.c_str(), featureRev);
	witSetBopEntryExpAversion(theWitRun, optionDummy.c_str(), 0, -featureRev[0]);
d10114 1
a10114 1
      std::string childPart = mpHelper.partname(child);
d10116 1
a10116 1
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), j, &nSubs);
d10119 1
a10119 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)
d10121 3
a10123 3
        if (lpModelHelper_ != 0) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), j, 0, featureRev);
        foundMatch = true;  
d10148 3
a10150 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
d10153 2
a10154 2
    const std::string & fileName,
    const std::string & dataLine,
d10164 1
a10164 1
  bool foundMatch = false;
d10169 1
a10169 1
  std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
d10189 2
a10190 3
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBom; j++) {
d10192 2
a10193 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &child);
    std::string pp, g, bb;
d10196 1
a10196 1
      std::string optionDummy = mpHelper.optionDummyPartName(plannerTopLevelPart, geo, 
d10200 2
a10201 2
        if ( lpModelHelper_ != 0) 
          witSetPartObj1ProdCost(theWitRun, optionDummy.c_str(), featureRev);
d10214 1
a10214 1
      std::string childPart = mpHelper.partname(child);
d10216 1
a10216 1
      witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), j, &nSubs);
d10219 1
a10219 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++)
d10221 3
a10223 3
        if (lpModelHelper_ != 0) 
          witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), j, 0, featureRev);
        foundMatch = true;  
d10250 3
a10252 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
d10254 2
a10255 2
    const std::string & fileName,
    const std::string & dataLine,
d10268 1
a10268 1
  std::string geoPlannerDemandPart =
d10290 1
a10290 1
    std::string mfgTopLevelBuild = mpHelper.demandSource(theWitRun, 
d10300 1
a10300 1
    std::string pdf = mpHelper.pdf(mfgTopLevelBuild);
d10305 1
a10305 1
    std::string specialFeaturePartName;
d10312 1
a10312 1
    witGetPartExists(theWitRun, specialFeaturePartName.c_str(), &exists);
d10322 1
a10322 1
      witGetPartExists(theWitRun, specialFeaturePartName.c_str(), &exists);
d10339 2
a10340 3
    witGetPartSupplyVol(theWitRun, specialFeaturePartName.c_str(), &supVol);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=late; t++) {
d10343 1
a10343 1
    witSetPartSupplyVol(theWitRun, specialFeaturePartName.c_str(), supVol);
d10360 3
a10362 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
d10367 2
a10368 2
    const std::string & fileName,
    const std::string & dataLine,
d10381 1
a10381 1
  std::string geoPlannerDemandPart =
d10397 1
a10397 1
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d10403 3
a10405 4
  bool didWeFindAValidFeatureRelationship = false;
  std::string pdf;
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBomEntries; j++) {
d10407 2
a10408 2
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &specialFeaturePartName);
    std::string mfgop;
d10411 1
a10411 1
    std::string gg, mm;
d10424 2
a10425 2
    // at this point you have a match with plannerPart.c_str(),geo.c_str(),mfgOptionPart.
    didWeFindAValidFeatureRelationship = true;
d10433 1
a10433 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=start; t<=end; t++) {
d10439 1
a10439 1
      std::string realFeaturePartName = mpHelper.pdfPartname(mfgop, pdf);
d10441 1
a10441 1
      witGetPartExists(theWitRun, realFeaturePartName.c_str(), &exists);
d10444 2
a10445 3
      witGetPartCycleTime(theWitRun, realFeaturePartName.c_str(), &realFeatureCycleTime);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=start; t<=end; t++) {
d10482 3
a10484 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & featurePart, 
d10488 2
a10489 2
    const std::string & fileName,
    const std::string & dataLine,
d10614 1
a10614 1
  std::string geoPlannerDemandPart =
d10639 1
a10639 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d10642 2
a10643 3
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
d10701 1
a10701 1
  std::string machineFullWitPart = mpHelper.demandSource(theWitRun,
d10714 1
a10714 1
  std::string pdf(mpHelper.pdf(machineFullWitPart));
d10717 1
a10717 1
  std::string fullFeaturePart(mpHelper.pdfPartname(featurePart, pdf));
d10742 1
a10742 1
  std::string specialCCFeaturePartName(mpHelper.custChoiceFeaturePartName(plannerTopLevelPart, 
d10753 1
a10753 1
    witAddPartWithOperation(theWitRun, specialCCFeaturePartName.c_str());
d10756 1
a10756 1
    witAddBomEntry(theWitRun, specialCCFeaturePartName.c_str(), fullFeaturePart.c_str());
d10764 4
a10767 4
  witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &bomIndex );
  witAddBomEntry( theWitRun, geoPlannerDemandPart.c_str(), specialCCFeaturePartName.c_str());
  witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, usageRate);
  witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, WitFALSE );
d10771 1
a10771 1
  witSetBomEntryAppData(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, (void *) bomAppDataPtr);
d10782 1
a10782 1
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, &transitTimeOffset);
d10787 1
a10787 1
  witGetPartCycleTime(theWitRun, machineFullWitPart.c_str(), &machineCycleTime);
d10792 1
a10792 1
  witSetBomEntryOffset(theWitRun, specialCCFeaturePartName.c_str(), 0, machineCycleTime);
d10794 1
a10794 1
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, transitTimeOffset);
d10803 1
a10803 1
  std::string ccNullSubstitute;
d10809 1
a10809 1
  witAddPart(theWitRun, ccNullSubstitute.c_str(), WitMATERIAL);
d10814 1
a10814 1
  witSetPartSupplyVol(theWitRun, ccNullSubstitute.c_str(), featureRatio);
d10822 2
a10823 2
  witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, &nSubBom);
  witAddSubsBomEntry( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, ccNullSubstitute.c_str() );
d10826 1
a10826 1
  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, transitTimeOffset);
d10829 1
a10829 1
  witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom, WitFALSE);
d10832 2
a10833 2
  if ( lpModelHelper_ != 0 )
    witSetSubsBomEntryObj1SubCost ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex, nSubBom,
d10845 3
a10847 3
  std::string returnedPlannerTopLevelPart;
  std::string returnedGeo;
  std::string demandName = mpHelper.custChoiceFeatureDemandName( geoPlannerDemandPart );
d10853 1
a10853 1
    witAddDemand ( theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str() );
d10859 1
a10859 1
    std::string engine = setOfParameters.getString("calendarFormat");
d10863 2
a10864 3
      witGetDemandDemandVol(theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str(), &bigMdemandVol);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d10866 1
a10866 1
      witSetDemandDemandVol(theWitRun, specialCCFeaturePartName.c_str(), demandName.c_str(), bigMdemandVol);
d10884 3
a10886 3
    const std::string & plannerTopLevelPart, 
    const std::string & geo,
    const std::string & mfgOptionPart, 
d10892 2
a10893 2
    const std::string & fileName,
    const std::string & dataLine,
d10955 1
a10955 1
  std::string geoPlannerDemandPart =
d10976 1
a10976 1
  witGetPartNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &nBomEntries );
d10979 5
a10983 6
  int j = 0; // Pulled out of the for below by RW2STL
  for (j=0; j<nBomEntries; j++)  {
    witGetBomEntryConsumedPart( theWitRun, geoPlannerDemandPart.c_str(), j, &child );
    std::string pdf;
    std::string featurePart;
    std::string gg, mm;
d11008 1
a11008 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d11029 1
a11029 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t= 0; t<firstPeriodWithRatio; t++) {
d11049 1
a11049 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=intervalStartPeriod; t<nPeriods; t++) {
d11067 1
a11067 1
    std::string mfgTopLevelPart = mpHelper.demandSource(theWitRun,
d11084 1
a11084 1
    std::string pdf(mpHelper.pdf(mfgTopLevelPart));
d11087 1
a11087 1
    std::string fullOptionPartName(mpHelper.pdfPartname(mfgOptionPart, pdf));
d11113 1
a11113 1
    std::string specialFeaturePartName(mpHelper.standaloneFeaturePartName(plannerTopLevelPart, 
d11123 1
a11123 1
      witAddPartWithOperation(theWitRun, specialFeaturePartName.c_str());
d11130 2
a11131 2
      witSetOperationMinLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());
      witSetOperationIncLotSize(theWitRun, specialFeaturePartName.c_str(), nonIntLotSize.data());
d11135 1
a11135 1
      witAddBomEntry(theWitRun, specialFeaturePartName.c_str(), fullOptionPartName.c_str());
d11141 4
a11144 4
    witGetOperationNBomEntries( theWitRun, geoPlannerDemandPart.c_str(), &bomIndex );
    witAddBomEntry( theWitRun, geoPlannerDemandPart.c_str(), specialFeaturePartName.c_str());
    witSetBomEntryEarliestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  intervalStartPeriod );
    witSetBomEntryLatestPeriod ( theWitRun, geoPlannerDemandPart.c_str(), bomIndex,  intervalEndPeriod );
d11146 2
a11147 2
    witSetBomEntryUsageRate( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, finalUsageRate );
    witSetBomEntryMandEC( theWitRun,  geoPlannerDemandPart.c_str(), bomIndex, WitFALSE );
d11157 2
a11158 2
    witGetBopEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, &transitTimeOffset);
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), 0, transitTimeOffset);
d11163 1
a11163 1
    witGetPartCycleTime(theWitRun, mfgTopLevelPart.c_str(), &mfgTopLevelCycleTime);
d11168 1
a11168 1
    witSetBomEntryOffset(theWitRun, specialFeaturePartName.c_str(), 0, mfgTopLevelCycleTime);
d11170 1
a11170 1
    witSetBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), bomIndex, transitTimeOffset);
d11183 1
a11183 1
    std::string nullSubstitute;
d11188 1
a11188 1
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
d11195 1
a11195 1
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
d11199 1
a11199 1
	  witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), maxWithout);
d11206 3
a11208 3
	witAddPart(theWitRun, nullSubstitute.c_str(), WitMATERIAL);
    LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
	witSetPartSupplyVol(theWitRun, nullSubstitute.c_str(), bigMsupply.data());
d11220 2
a11221 2
    witGetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void **) &appDataPtr);
    if (appDataPtr == 0) {
d11224 1
a11224 1
      witSetPartAppData(theWitRun, specialFeaturePartName.c_str(), (void *) appDataPtr);
d11241 1
a11241 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBom);
d11244 2
a11245 2
    witGetBomEntryNSubsBomEntries(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, &nSubBom);
    witAddSubsBomEntry(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nullSubstitute.c_str());
d11247 4
a11250 4
    witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, WitFALSE);
    witSetSubsBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalStartPeriod);
    witSetSubsBomEntryLatestPeriod(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, intervalEndPeriod);
    witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, transitTimeOffset);
d11252 2
a11253 2
    if (lpModelHelper_ != 0)
      witSetSubsBomEntryObj1SubCost(theWitRun, geoPlannerDemandPart.c_str(), nBom-1, nSubBom, defaultGatingOptionSubPenalty);
d11263 3
a11265 3
    std::string returnedPlannerTopLevelPart;
    std::string returnedGeo;
    std::string demandName = mpHelper.pureOptionBuildDemandName( geoPlannerDemandPart );
d11271 1
a11271 1
      witAddDemand(theWitRun, specialFeaturePartName.c_str(), demandName.c_str() );
d11279 1
a11279 1
      std::string engine = setOfParameters.getString("calendarFormat");
d11283 2
a11284 3
	witGetDemandDemandVol(theWitRun, specialFeaturePartName.c_str(), demandName.c_str(), &bigMdemandVol);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
d11286 1
a11286 1
	witSetDemandDemandVol(theWitRun, specialFeaturePartName.c_str(), demandName.c_str(), bigMdemandVol);
d11313 2
a11314 2
  std::string ppForGpd;
  std::string geoForGpd;
d11316 2
a11317 3
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++)  { 
    std::string geoPlannerDemandPart(partList[i]);
d11327 1
a11327 1
    witGetPartDemands(theWitRun, geoPlannerDemandPart.c_str(),  &gpdNdemands, &gpdDlist);
d11334 1
a11334 1
    witGetDemandPriority ( theWitRun, geoPlannerDemandPart.c_str(), gpdDlist[0], &priority );
d11337 1
a11337 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPart.c_str(), &nBoms);
d11339 1
a11339 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++) {
d11341 1
a11341 1
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPart.c_str(), j, &specialFeaturePartName);
d11344 4
a11347 4
      std::string pp;
      std::string geo;
      std::string pdf;
      std::string featurePart;
d11355 1
a11355 2
	    int jSFP = 0; // Pulled out of the for below by RW2STL
	    for (jSFP=0; jSFP<nDemandsSFP; jSFP++) {
d11367 1
a11367 2
	    int jSFP = 0; // Pulled out of the for below by RW2STL
	    for (jSFP=0; jSFP<nDemandsSFP; jSFP++) {
d11410 2
a11411 2
  std::string ptlpDummy;
  std::string geoDummy;
d11414 1
a11414 1
    std::string partName (partList[i]);
d11421 1
a11421 1
    witGetPartDemands(theWitRun, partName.c_str(), &nDemands, &dList);
d11423 1
a11423 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
d11435 2
a11436 2
      witGetDemandAppData(theWitRun, partName.c_str(), dList[j], (void **) &demandAppDataPtr);
      assert(demandAppDataPtr != 0);
d11447 2
a11448 3
	witGetPartSupplyVol(theWitRun, partName.c_str(), &supplyVol);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
d11451 1
a11451 1
	witSetPartSupplyVol(theWitRun, partName.c_str(), supplyVol);
d11477 1
a11477 1
 bool useMultiRouteImplosion)
d11516 1
a11516 1
      if ( appDataPtr == 0) // if there's no appData, than no interplants..
d11537 1
a11537 1
      // be safe and set expAllowed=true (though this is the default and it should
d11547 1
a11547 1
      std::string partName (partList[i]);
d11551 3
a11553 4
      bool * bopOnInPeriod = new bool[nPeriods];
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
        bopOnInPeriod[t] = false; 
d11556 1
a11556 2
      int p = 0; // Pulled out of the for below by RW2STL
      for (p=0; p<npBops; p++) {
d11561 1
a11561 1
          witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(), myBop.bopIndex(), WitFALSE );
d11577 1
a11577 1
              if ( bopOnInPeriod[first] != true )
d11586 1
a11586 1
                                       myBop.opName().c_str(),
d11596 1
a11596 1
              if ( bopOnInPeriod[last] != false )
d11605 2
a11606 3
            int t = 0; // Pulled out of the for below by RW2STL
            for (t=first; t<=last; t++)
              bopOnInPeriod[t] = true;
d11632 1
a11632 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
d11638 1
a11638 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
d11641 1
a11641 1
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName().c_str(),
d11648 1
a11648 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
d11663 1
a11663 1
              witSetBopEntryExpAllowed ( theWitRun, myBop.opName().c_str(),
d11666 1
a11666 1
              witSetBopEntryExpAllowed ( theWitRun, newBop.opName().c_str(),
d11735 1
a11735 1
    std::string partName (partList[i]);
d11741 1
a11741 1
    witGetPartAppData(theWitRun, partName.c_str(), (void **) &appDataPtr);
d11743 1
a11743 1
    if ( appDataPtr == 0) // if there's no appData, than no interplants..
d11752 1
a11752 1
    witGetPartNProducingBopEntries ( theWitRun, partName.c_str(), & npBops );
d11765 1
a11765 1
    std::string * setOfInterplantOps = new std::string[nInterplantOps];
d11769 1
a11769 1
      std::string interplantOpName = producingBop.opName();
d11772 4
a11775 4
      std::string dPart;
      std::string dPdf;
      std::string sPart;
      std::string sPdf;
d11777 1
a11777 1
                       theWitRun, interplantOpName.c_str(),
d11782 2
a11783 3
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nInterplantOps; k++) {
        if (0 == interplantOpName.compare(setOfInterplantOps[k])) {
d11799 1
a11799 1
    // looking for bops to interplantOperations that have expAllowed=false.
d11802 1
a11802 1
      std::string currentInterplantOp = currentBop.opName();
d11805 4
a11808 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;
      std::string sourcePdf;
d11816 1
a11816 1
      witGetBopEntryExpAllowed( theWitRun, currentInterplantOp.c_str(),
d11825 1
a11825 1
      // (i.e. expAllowed = false)
d11834 1
a11834 1
      // is true, then we will need to make the sub arc explodeable 
d11836 1
a11836 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nInterplantOps; k++) {
d11838 1
a11838 1
        if (0 == currentInterplantOp.compare(setOfInterplantOps[k]))
d11841 2
a11842 2
        std::string sourcePdfPartName;
        mpHelper.interplantSourcePdfPartName( theWitRun, currentInterplantOp.c_str(),
d11845 1
a11845 1
        std::string primaryInterplantOp = setOfInterplantOps[k];
d11848 1
a11848 1
                                    primaryInterplantOp.c_str(), &nBomEntries );
d11856 1
a11856 1
        witGetBomEntryNSubsBomEntries( theWitRun, primaryInterplantOp.c_str(),
d11858 2
a11859 2
        witAddSubsBomEntry( theWitRun, primaryInterplantOp.c_str(), 0,
                            sourcePdfPartName.c_str() );
d11865 2
a11866 2
        witGetBomEntryUsageRate( theWitRun, currentInterplantOp.c_str(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryInterplantOp.c_str(), 0,
d11871 1
a11871 1
        witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.c_str(), 0,
d11882 1
a11882 1
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryInterplantOp.c_str(),
d11884 1
a11884 1
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryInterplantOp.c_str(),
d11890 2
a11891 2
        witGetBomEntryOffset( theWitRun, currentInterplantOp.c_str(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryInterplantOp.c_str(), 0,
d11899 1
a11899 1
        witGetBopEntryAppData( theWitRun, currentInterplantOp.c_str(), currentInterplantBopIndex,
d11901 1
a11901 1
        assert( currentBopAppDataPtr != 0 );
d11906 1
a11906 1
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryInterplantOp.c_str(), 0, subBomEntryIndex, 
d11908 1
a11908 1
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryInterplantOp.c_str(), 0, subBomEntryIndex, 
d11916 2
a11917 2
        assert (subBomAppDataPtr != 0 );
        witSetSubsBomEntryAppData( theWitRun, primaryInterplantOp.c_str(), 0,
d11977 1
a11977 1
    std::string partName (partList[i]);
d11983 1
a11983 1
    witGetPartAppData(theWitRun, partName.c_str(), (void **) &appDataPtr);
d11985 1
a11985 1
    if ( appDataPtr == 0) // if there's no appData, than no bins..
d11994 1
a11994 1
    witGetPartNProducingBopEntries ( theWitRun, partName.c_str(), & npBops );
d12007 1
a12007 1
    std::string * setOfBinOps = new std::string[nBinOps];
d12011 1
a12011 1
      std::string binOpName = producingBop.opName();
d12014 4
a12017 4
      std::string dPart;
      std::string dPdf;
      std::string sPart;
      std::string sPdf;
d12019 1
a12019 1
                       theWitRun, binOpName.c_str(),
d12024 2
a12025 3
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nBinOps; k++) {
        if (0 == binOpName.compare(setOfBinOps[k])) {
d12041 1
a12041 1
    // looking for bops to binOperations that have byProduct=true.
d12044 1
a12044 1
      std::string currentBinOp = currentBop.opName();
d12047 4
a12050 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;
      std::string sourcePdf;
d12053 1
a12053 1
                       theWitRun, currentBinOp.c_str(),
d12058 1
a12058 1
      witGetBopEntryExpAllowed( theWitRun, currentBinOp.c_str(),
d12066 1
a12066 1
      // (i.e. byProduct = true)
d12075 1
a12075 1
      // is true, then we will need to make the sub arc explodeable 
d12077 1
a12077 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nBinOps; k++) {
d12079 1
a12079 1
        if (0 == currentBinOp.compare(setOfBinOps[k]))
d12082 2
a12083 2
        std::string sourcePdfPartName;
        mpHelper.binSourcePdfPartName( theWitRun, currentBinOp.c_str(),
d12086 1
a12086 1
        std::string primaryBinOp = setOfBinOps[k];
d12089 1
a12089 1
                                    primaryBinOp.c_str(), &nBomEntries );
d12097 1
a12097 1
        witGetBomEntryNSubsBomEntries( theWitRun, primaryBinOp.c_str(),
d12099 2
a12100 2
        witAddSubsBomEntry( theWitRun, primaryBinOp.c_str(), 0,
                            sourcePdfPartName.c_str() );
d12106 2
a12107 2
        witGetBomEntryUsageRate( theWitRun, currentBinOp.c_str(), 0, &usageRate );
        witSetSubsBomEntryUsageRate( theWitRun, primaryBinOp.c_str(), 0,
d12112 1
a12112 1
        witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.c_str(), 0,
d12123 1
a12123 1
        witSetSubsBomEntryEarliestPeriod( theWitRun, primaryBinOp.c_str(),
d12125 1
a12125 1
        witSetSubsBomEntryLatestPeriod( theWitRun, primaryBinOp.c_str(),
d12131 2
a12132 2
        witGetBomEntryOffset( theWitRun, currentBinOp.c_str(), 0, &offset );
        witSetSubsBomEntryOffset( theWitRun, primaryBinOp.c_str(), 0,
d12140 1
a12140 1
        witGetBopEntryAppData( theWitRun, currentBinOp.c_str(), currentBinBopIndex,
d12142 1
a12142 1
        assert( currentBopAppDataPtr != 0 );
d12147 1
a12147 1
	  witSetSubsBomEntryExpAllowed( theWitRun, primaryBinOp.c_str(), 0, subBomEntryIndex, 
d12149 1
a12149 1
	  witSetSubsBomEntryExpNetAversion( theWitRun, primaryBinOp.c_str(), 0, subBomEntryIndex, 
d12157 2
a12158 2
        assert (subBomAppDataPtr != 0 );
        witSetSubsBomEntryAppData( theWitRun, primaryBinOp.c_str(), 0,
d12211 4
a12214 4
  std::string plannerTopLevelPart;
  std::string geo;
  std::string bbCategory;
  std::string mfgOptionPart;
d12224 1
a12224 1
    std::string fullWitPartname(partList[i]);
d12234 1
a12234 1
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
d12236 1
a12236 1
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
d12246 1
a12246 1
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
d12250 1
a12250 1
      std::string demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
d12253 1
a12253 1
      witGetPartReqVol(theWitRun, demandPart.c_str(), &reqVolParent);
d12255 1
a12255 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d12258 1
a12258 1
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
d12267 1
a12267 1
      std::string maxWithoutNullSubPart(fullWitPartname);
d12270 1
a12270 1
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12272 1
a12272 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
d12276 1
a12276 1
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), &supplyVol);
d12281 1
a12281 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
d12284 1
a12284 1
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), supplyVol);
d12291 1
a12291 1
    std::string pppdf;
d12297 1
a12297 1
      std::string ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));
d12300 1
a12300 1
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12302 1
a12302 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
d12306 1
a12306 1
      witGetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), &supplyVol);
d12311 1
a12311 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
d12314 1
a12314 1
      witSetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), supplyVol);
d12362 4
a12365 4
  std::string plannerTopLevelPart;
  std::string geo;
  std::string bbCategory;
  std::string mfgOptionPart;
d12374 1
a12374 1
    std::string fullWitPartname(partList[i]);
d12381 1
a12381 1
      std::string fullBbCategoryPart = mpHelper.bbCategoryPartName(plannerTopLevelPart,
d12386 1
a12386 1
      witGetPartMrpProdVol(theWitRun, fullBbCategoryPart.c_str(), &mrpProdVol);
d12389 1
a12389 1
      std::string optionRatioSupplyPart = mpHelper.optionRatioSupplyPartName(
d12394 1
a12394 1
      witGetPartSupplyVol(theWitRun, optionRatioSupplyPart.c_str(), &supplyVol);
d12399 1
a12399 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
d12402 1
a12402 1
      witSetPartSupplyVol(theWitRun, optionRatioSupplyPart.c_str(), supplyVol);
d12414 1
a12414 1
      witGetPartReqVol(theWitRun, fullWitPartname.c_str(), &reqVol);
d12418 1
a12418 1
      std::string demandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart,
d12421 1
a12421 1
      witGetPartReqVol(theWitRun, demandPart.c_str(), &reqVolParent);
d12423 1
a12423 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d12426 1
a12426 1
      witSetPartSupplyVol(theWitRun, fullWitPartname.c_str(), reqVol);
d12435 1
a12435 1
      std::string maxWithoutNullSubPart(fullWitPartname);
d12438 1
a12438 1
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12440 1
a12440 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
d12444 1
a12444 1
      witGetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), &supplyVol);
d12449 1
a12449 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
d12452 1
a12452 1
      witSetPartSupplyVol(theWitRun, maxWithoutNullSubPart.c_str(), supplyVol);
d12459 1
a12459 1
    std::string pppdf;
d12465 1
a12465 1
      std::string ccNullSubPart(mpHelper.custChoiceNullSubstitute(geo, plannerTopLevelPart, mfgOptionPart));
d12468 1
a12468 1
      std::string geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(
d12470 1
a12470 1
      witGetPartMrpProdVol(theWitRun, geoPlannerDemandPart.c_str(), &mrpProdVol);
d12474 1
a12474 1
      witGetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), &supplyVol);
d12479 1
a12479 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)  
d12482 1
a12482 1
      witSetPartSupplyVol(theWitRun, ccNullSubPart.c_str(), supplyVol);
d12510 4
a12513 4
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
d12521 2
a12522 2
    const std::string & fileName,
    const std::string & dataLine,
d12528 2
a12529 2
    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12543 1
a12543 1
    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
d12549 1
a12549 1
		     0);
d12559 1
a12559 1
// Note: you must set the flag isParentAnOperation to true or false
d12564 8
a12571 8
    bool isParentAnOperation,
    bool relaxedSubbingRulesAllowed,
    const std::string & mfgParentPartName, 
    const std::string & parentPdf, 
    const std::string & mfgChildPartName, 
    const std::string & childPdf, 
    const std::string & mfgSubPartName,
    const std::string & subPdf,
d12579 3
a12581 3
    bool subNetAllowed,
    const std::string & fileName,
    const std::string & dataLine,
d12590 3
a12592 3
    std::string fullParentName(mpHelper.pdfPartname(mfgParentPartName, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(mfgChildPartName,  childPdf));
    std::string fullSubName( mpHelper.pdfPartname(mfgSubPartName,  subPdf));
d12637 1
a12637 1
    witGetOperationNBomEntries(theWitRun, fullParentName.c_str(), &nBomEntries);
d12644 2
a12645 3
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBomEntries; j++)  {
	witGetBomEntryConsumedPart(theWitRun, fullParentName.c_str(), j, &child);
d12649 2
a12650 2
	    witGetBomEntryEarliestPeriod(theWitRun, fullParentName.c_str(), j, &candidateEarly);
	    witGetBomEntryLatestPeriod(theWitRun, fullParentName.c_str(), j, &candidateLate);
d12674 1
a12674 2
	      int t = 0; // Pulled out of the for below by RW2STL
	      for (t=0; t<nPeriods; t++)
d12679 1
a12679 1
	      witGetBomEntryNSubsBomEntries( theWitRun, fullParentName.c_str(), j, & nSubBoms);
d12681 6
a12686 6
	      witGetBomEntryOffset(theWitRun, fullParentName.c_str(), j, &offset);
	      witAddSubsBomEntry( theWitRun, fullParentName.c_str(), j, fullSubName.c_str());
	      witSetSubsBomEntryEarliestPeriod( theWitRun, fullParentName.c_str(), j, nSubBoms, early);
	      witSetSubsBomEntryLatestPeriod( theWitRun, fullParentName.c_str(), j, nSubBoms, late);
	      witSetSubsBomEntryOffset(theWitRun, fullParentName.c_str(), j, nSubBoms, offset);
	      witSetSubsBomEntryExpNetAversion(theWitRun, fullParentName.c_str(), j, nSubBoms, subCost);
d12689 1
a12689 1
		witSetSubsBomEntryExecPenalty(theWitRun, fullParentName.c_str(), j, nSubBoms, subCost);
d12692 1
d12695 1
a12695 1
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitTRUE);
d12697 1
a12697 1
		witSetSubsBomEntryNetAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitFALSE);
d12701 1
a12701 1
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitTRUE);
d12703 1
a12703 1
		witSetSubsBomEntryExpAllowed(theWitRun, fullParentName.c_str(), j, nSubBoms, WitFALSE);
d12705 2
a12706 2
	      witSetSubsBomEntryFallout( theWitRun, fullParentName.c_str(), j, nSubBoms, fallout);
	      witSetSubsBomEntryUsageRate( theWitRun, fullParentName.c_str(), j, nSubBoms, usageRate);
d12708 2
a12709 2
	      if ( lpModelHelper_ != 0 )
		witSetSubsBomEntryObj1SubCost( theWitRun, fullParentName.c_str(), j, nSubBoms, obj1SubCost);
d12715 2
a12716 2
	      witGetSubsBomEntryAppData( theWitRun, fullParentName.c_str(), j, nSubBoms, &subBomAppVoidPtr );
	      if ( subBomAppVoidPtr != 0 ) {
d12730 1
a12730 1
					 fullParentName.c_str(),
d12777 4
a12780 4
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
d12789 2
a12790 2
    const std::string & fileName,
    const std::string & dataLine,
d12793 2
a12794 2
    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12822 1
a12822 1
	witGetPartCycleTime(theWitRun, fullChildName.c_str(), &cycleTime);
d12827 1
a12827 1
    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
d12834 1
a12834 1
		     0);
d12846 4
a12849 4
    const std::string & parent, 
    const std::string & parentPdf,
    const std::string & child, 
    const std::string & childPdf, 
d12854 2
a12855 2
    const std::string & fileName,
    const std::string & dataLine,
d12858 2
a12859 2
    std::string fullParentName(mpHelper.pdfPartname(parent, parentPdf));
    std::string fullChildName( mpHelper.pdfPartname(child,  childPdf));
d12871 1
a12871 1
    witAddBomEntryVa(theWitRun, fullParentName.c_str(), fullChildName.c_str(),
d12876 1
a12876 1
		     0);
d12889 4
a12892 4
    const std::string & mfgPart, 
    const std::string & mfgPdf,
    const std::string & aggregatePart, 
    const std::string & aggregatePdf, 
d12897 2
a12898 2
    const std::string & fileName,
    const std::string & dataLine,
d12908 2
a12909 2
  std::string fullMfgPart(mpHelper.pdfPartname(mfgPart, mfgPdf));
  std::string fullAggregatePart(mpHelper.pdfPartname(aggregatePart,  aggregatePdf));
d12922 1
a12922 1
  std::string aggOpName(mpHelper.aggregationOperationName(mfgPart, mfgPdf,
d12928 1
a12928 1
  witGetOperationExists(theWitRun, aggOpName.c_str(), &exists);
d12940 1
a12940 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d12943 1
a12943 1
  witAddOperation(theWitRun, aggOpName.c_str());
d12945 1
a12945 1
  witAddBopEntry(theWitRun, aggOpName.c_str(), fullMfgPart.c_str());
d12948 1
a12948 1
  witSetBopEntryAppData(theWitRun, aggOpName.c_str(), 0, (void *) appDataPtr);
d12951 3
a12953 3
  witAddBomEntry(theWitRun, aggOpName.c_str(), fullAggregatePart.c_str());
  witSetBomEntryUsageRate(theWitRun, aggOpName.c_str(), 0, usageRate);
  witSetBomEntryOffset(theWitRun, aggOpName.c_str(), 0, offsetVec);
d12960 2
a12961 2
  witGetPartAppData(theWitRun, fullMfgPart.c_str(), (void **) &custPartAppData);
  if (custPartAppData == 0) {
d12964 1
a12964 1
    witSetPartAppData(theWitRun, fullMfgPart.c_str(), (void *) custPartAppData);
d12980 2
a12981 2
    const std::string & geoPlannerDemandPartName,
    const std::string & pdf_PartName,
d12985 2
a12986 2
    const std::string & fileName,
    const std::string & dataLine,
d12997 1
a12997 1
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d13008 1
a13008 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++)
d13016 1
a13016 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++ ) {
d13021 1
a13021 1
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
d13030 2
a13031 2
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEarly);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomLate);
d13036 2
a13037 2
          std::string geo;
          std::string plannerPart;
d13068 3
a13070 3
  witAddBomEntry(theWitRun, geoPlannerDemandPartName.c_str(), pdf_PartName.c_str());
  witSetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), nBom, early);
  witSetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), nBom, late);
d13074 2
a13075 3
  witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), nBom, &bomOffset);
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=early; t<=late; t++)
d13077 1
a13077 1
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), nBom, bomOffset);
d13085 1
a13085 1
  witGetBopEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), 0, &bopOffset);
d13088 1
a13088 1
  witSetBopEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), 0, bopOffset);
d13100 4
a13103 4
    const std::string & demandPart,
    const std::string & demandUpperBoundPart, 
    const std::string & fileName,
    const std::string & dataLine,
d13106 2
a13107 2
  witAddBomEntryVa(theWitRun, demandPart.c_str(), demandUpperBoundPart.c_str(),
                   0);
d13126 1
a13126 1
         std::string fileName)
d13129 1
a13129 1
   std::string partName;
d13131 1
a13131 1
   std::ofstream outFile(fileName.c_str());//, ios::out);
d13242 4
a13245 5
   LgFrInitialProblemAndParameters(source.scenario()),
   implementSmartFeatures_(source.implementSmartFeatures_),

   heurModelHelper_(source.heurModelHelper_),
   lpModelHelper_(source.lpModelHelper_),
d13255 6
a13260 7
    LgFrInitialProblemAndParameters(
       LgFrScenarioSmartPointer::nullScenarioSmartPointer),
       implementSmartFeatures_(true),

    heurModelHelper_(0),
    lpModelHelper_(0),
    groupSharingViaExecPenalties_(FALSE)
d13268 5
a13272 6
    LgFrInitialProblemAndParameters(scenario),
    implementSmartFeatures_(true),

    heurModelHelper_(0),
    lpModelHelper_(0),
    groupSharingViaExecPenalties_(false)
d13280 1
a13280 1
std::string
d13284 1
a13284 1
  std::string theTitle("Supply Capability Engine: ");
d13296 1
a13296 1
    if (scenario()->GetScenarioType() != __LGFRSCENARIOFORSCE)  {
d13315 1
a13315 1
  assert( dif->dataInterfaceImplementation()->GetDIIType() ==
d13326 1
a13326 1
  std::string parameterFilename = difSceF->filename();
d13349 1
a13349 1
    std::string & parameterFileName,
d13384 1
a13384 1
   std::string calendarFormat = setOfParameters.getString("calendarFormat");
d13411 8
a13418 1
#endif@


1.22.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d683 1
a683 1
    std::cout << "Analyzing SCE model (default operations) ..." << std::endl;    
d697 1
a697 1
      std::cout << "Pre-processing feature priorities ..." << std::endl;    
d711 1
a711 1
	std::cout << "Analyzing SCE model (multiple bop entries) ..." << std::endl;
d730 1
a730 1
	std::cout << "Analyzing SCE model (multiple interplant entries) ..." << std::endl;
d750 1
a750 1
      std::cout << "Analyzing SCE model (multiple bin entries) ..." << std::endl;
d761 1
a761 1
    std::cout << "Pre-Processing SCE model ..." << std::endl;
d821 1
a821 1
      std::cout << "Shutting off all Lot-sizing ..." << std::endl;    
d834 1
a834 1
    std::cout << "Pre-Processing for wit  ..." << std::endl;          
d841 1
a841 1
      std::cout << "Writing the echo file  ..." << std::endl;                
d854 1
a854 1
      std::cout << "Writing the (heur) wit data file ..." << std::endl;                      
d882 1
a882 1
      std::cout << "Computing Demand Drivers  ..." << std::endl;                      
d896 1
a896 1
      std::cout << "Writing the Demand Drivers file  ..." << std::endl;                      
d1056 1
a1056 1
    std::cout << "Processing " << fileName << ":\t" << std::flush;
d1122 1
a1122 1
                outFile << dataLine << std::endl;
d1130 1
a1130 1
    std::cout << recCount << " records processed." << std::endl;
d1175 1
a1175 1
    std::cout << "Processing " << fileName << ":\t" << std::flush;
d1230 1
a1230 1
                outFile << dataLine << std::endl;
d1237 1
a1237 1
    std::cout << recCount << " records processed." << std::endl;
d1285 1
a1285 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d1407 1
a1407 1
                outFile << dataLine << std::endl;
d1413 1
a1413 1
 std::cout << recCount << " records processed." << std::endl;
d1460 1
a1460 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d1550 1
a1550 1
        outFile << dataLine << std::endl;
d1553 1
a1553 1
 std::cout << recCount << " records processed." << std::endl;
d1594 1
a1594 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d1691 1
a1691 1
            outFile << dataLine << std::endl;
d1698 1
a1698 1
 std::cout << recCount << " records processed." << std::endl;
d1742 1
a1742 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d1861 1
a1861 1
            outFile << dataLine << std::endl;
d1867 1
a1867 1
 std::cout << recCount << " records processed." << std::endl;
d1907 1
a1907 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d2019 1
a2019 1
        outFile << dataLine << std::endl;
d2023 1
a2023 1
 std::cout << recCount << " records processed." << std::endl;
d2074 1
a2074 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d2184 1
a2184 1
            outFile << dataLine << std::endl;
d2190 1
a2190 1
 std::cout << recCount << " records processed." << std::endl;
d2246 1
a2246 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d2341 1
a2341 1
           outFile << dataLine << std::endl;
d2347 1
a2347 1
 std::cout << recCount << " records processed." << std::endl;
d2426 1
a2426 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d2607 1
a2607 1
            outFile << dataLine << std::endl;
d2614 1
a2614 1
 std::cout << recCount << " records processed." << std::endl;
d2720 1
a2720 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d2818 1
a2818 1
	outFile << dataLine << std::endl;
d2825 1
a2825 1
 std::cout << recCount << " records processed." << std::endl;
d2875 1
a2875 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d2969 1
a2969 1
            outFile << dataLine << std::endl;
d2976 1
a2976 1
 std::cout << recCount << " records processed." << std::endl;
d3022 1
a3022 1
    std::cout << "Processing " << fileName << ":\t" << std::flush;
d3108 1
a3108 1
                outFile << dataLine << std::endl;
d3114 1
a3114 1
    std::cout << recCount << " records processed." << std::endl;
d3155 1
a3155 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d3298 1
a3298 1
            outFile << dataLine << std::endl;
d3304 1
a3304 1
 std::cout << recCount << " records processed." << std::endl;
d3346 1
a3346 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d3489 1
a3489 1
            outFile << dataLine << std::endl;
d3495 1
a3495 1
 std::cout << recCount << " records processed." << std::endl;
d3552 1
a3552 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d3681 1
a3681 1
                outFile << dataLine << std::endl;
d3690 1
a3690 1
 std::cout << recCount << " records processed." << std::endl;
d3748 1
a3748 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d3877 1
a3877 1
                outFile << dataLine << std::endl;
d3886 1
a3886 1
 std::cout << recCount << " records processed." << std::endl;
d3944 1
a3944 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d3985 1
a3985 1
//    std::cout << "Updated supply Volume for " << pdf_PartName << "\n";
d3991 1
a3991 1
	outFile << dataLine << std::endl;
d3998 1
a3998 1
 std::cout << recCount << " records processed." << std::endl;
d4068 1
a4068 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d4122 2
a4123 2
      std::cerr << "\nbad supply float\n"  << lineNo << ":" << dataLine << std::endl;
      std::cerr << "ignoring the record\n" << std::endl;
d4134 2
a4135 2
      std::cerr << "\nDate is missing from dated supply record\n"  << lineNo << ":" << dataLine << std::endl;
      std::cerr << "putting it in week 1\n" << std::endl;
d4155 2
a4156 2
      std::cerr << "\nsupply period in the PAST\n" << lineNo << ":" << dataLine << std::endl;
      std::cerr << "putting it in week 1\n" << std::endl;
d4161 2
a4162 2
      std::cerr << "\nsupply period in the FUTURE\n" << lineNo << ":" << dataLine << std::endl;
      std::cerr << "ignoring !!\n" << std::endl;
d4178 1
a4178 1
	outFile << dataLine << std::endl;
d4184 1
a4184 1
 std::cout << recCount << " records processed." << std::endl;
d4228 1
a4228 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d4272 1
a4272 1
                outFile << dataLine << std::endl;
d4277 1
a4277 1
 std::cout << recCount << " records processed." << std::endl;
d4324 1
a4324 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d4571 1
a4571 1
  std::cout << recCount << " records processed." << std::endl;
d4687 1
a4687 1
	  outFile << dataLine << std::endl;
d5319 1
a5319 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d5392 1
a5392 1
 std::cout << recCount << " records processed." << std::endl;
d5449 1
a5449 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d5623 1
a5623 1
      outFile << dataLine << std::endl;
d5630 1
a5630 1
 std::cout << recCount << " records processed." << std::endl;
d5675 1
a5675 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d5750 1
a5750 1
                outFile << dataLine << std::endl;
d5756 1
a5756 1
 std::cout << recCount << " records processed." << std::endl;
d5805 1
a5805 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d5941 1
a5941 1
      outFile << dataLine << std::endl;
d5947 1
a5947 1
 std::cout << recCount << " records processed." << std::endl;
d5994 1
a5994 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6125 1
a6125 1
 std::cout << recCount << " records processed." << std::endl;
d6176 1
a6176 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d6399 1
a6399 1
	  outFile << dataLine << std::endl;
d6406 1
a6406 1
  std::cout << recCount << " records processed." << std::endl;
d6445 1
a6445 1
  std::cout << "Processing " << fileName << ":\t" << std::flush;
d6510 1
a6510 1
                outFile << dataLine << std::endl;
d6515 1
a6515 1
 std::cout << recCount << " records processed." << std::endl;
d6555 1
a6555 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6598 1
a6598 1
//    std::cout << "Updated prodVol Soft Lower Bound  for " << pdf_PartName << "\n";
d6602 1
a6602 1
                outFile << dataLine << std::endl;
d6607 1
a6607 1
 std::cout << recCount << " records processed." << std::endl;
d6646 1
a6646 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6698 1
a6698 1
//    std::cout << "Updated prodVol Hard Upper Bound  for " << pdf_PartName << "\n";
d6702 1
a6702 1
                outFile << dataLine << std::endl;
d6708 1
a6708 1
 std::cout << recCount << " records processed." << std::endl;
d6747 1
a6747 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6793 1
a6793 1
                outFile << dataLine << std::endl;
d6798 1
a6798 1
 std::cout << recCount << " records processed." << std::endl;
d6837 1
a6837 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6892 1
a6892 1
                outFile << dataLine << std::endl;
d6897 1
a6897 1
 std::cout << recCount << " records processed." << std::endl;
d6940 1
a6940 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d6968 1
a6968 1
//    std::cout << "Updated cycleTimes for " << pdf_PartName << "\n";
d6972 1
a6972 1
                outFile << dataLine << std::endl;
d6976 1
a6976 1
 std::cout << recCount << " records processed." << std::endl;
d7018 1
a7018 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7046 1
a7046 1
//    std::cout << "Updated yields for " << pdf_PartName << "\n";
d7050 1
a7050 1
                outFile << dataLine << std::endl;
d7057 1
a7057 1
 std::cout << recCount << " records processed." << std::endl;
d7095 1
a7095 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7126 1
a7126 1
                outFile << dataLine << std::endl;
d7133 1
a7133 1
 std::cout << recCount << " records processed." << std::endl;
d7175 1
a7175 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7207 1
a7207 1
//    std::cout << "Updated lot sizes for " << pdf_PartName << "\n";
d7211 1
a7211 1
                outFile << dataLine << std::endl;
d7218 1
a7218 1
 std::cout << recCount << " records processed." << std::endl;
d7259 1
a7259 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7294 1
a7294 1
                outFile << dataLine << std::endl;
d7300 1
a7300 1
 std::cout << recCount << " records processed." << std::endl;
d7338 1
a7338 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7365 1
a7365 1
                outFile << dataLine << std::endl;
d7371 1
a7371 1
 std::cout << recCount << " records processed." << std::endl;
d7411 1
a7411 1
 std::cout << "Processing " << fileName << ":\t" << std::flush;
d7442 1
a7442 1
                outFile << dataLine << std::endl;
d7449 1
a7449 1
 std::cout << recCount << " records processed." << std::endl;
d7599 1
a7599 1
                outFile << dataLine << std::endl;
d7643 1
a7643 1
            outFile << dataLine << std::endl;
d7716 1
a7716 1
    std::cout << "Processing " << fileName << ":\t" << std::flush;
d7898 1
a7898 1
            outFile << dataLine << std::endl;
d7906 1
a7906 1
    std::cout << recCount << " records processed." << std::endl;
d7943 1
a7943 1
    std::cout << "Processing " << fileName << ":\t" << std::flush;
d7997 1
a7997 1
                outFile << dataLine << std::endl;
d8005 1
a8005 1
    std::cout << recCount << " records processed." << std::endl;
d8692 1
a8692 1
    std::cerr << "sceAddAggregatePart() not implemented yet\n\n";
d11282 1
a11282 1
      std::cerr << "About to die: featureType =" << featureType << "\n";
d12289 1
a12289 1
  std::cout << "    ... running witMrp() ..." << std::endl;    
d12305 1
a12305 1
  std::cout << "    ... scanning partlist ..." << std::endl;        
d12412 1
a12412 1
  std::cout << "    ... finished SCE pre-processing ..." << std::endl;        
d12443 1
a12443 1
  std::cout << "    ... running witMrp() ..." << std::endl;    
d12458 1
a12458 1
  std::cout << "    ... scanning partlist ..." << std::endl;        
d12584 1
a12584 1
  std::cout << "    ... finished SCE pre-processing ..." << std::endl;        
d13395 2
a13396 2
        std::cerr << "the object is not a SCE scenario and it is supposed to be"
             << std::endl;
d13420 1
a13420 1
//  std::cout << "\nLgFrInitialProblemForSce::feedinto() ---> " 
@


1.22.2.3
log
@New LgFrDatetime class
@
text
@d4140 1
a4140 1
    LgFrDatetime supplyDate(flatFileManager.parseDateString(token, theCal));
d4372 1
a4372 1
      LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
d4666 1
a4666 1
      LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
d7562 2
a7563 1
	LgFrDatetime startDate(flatFileManager.parseDateString(token, theCal));
@


1.22.2.4
log
@minor typo
@
text
@d7481 1
a7481 1
					  "Calendar file",
d13508 1
a13508 1
#endif
@


1.21
log
@Modified to build on windows
@
text
@d141 4
d884 2
d898 1
a898 1
	    mpHelper.setAllWitPartIndices(theWitRun);
d926 13
d955 3
a957 2
	  witSetSubsBomEntryNetAllowed(theWitRun, opList[o], b, s, subNetAllowed);
	  witSetSubsBomEntryExpAllowed(theWitRun, opList[o], b, s, subNetAllowed);
d3518 2
d3655 1
d3705 12
d3850 1
a4010 1
 int nElementsChanged;
d5670 2
a5671 2
	    INT_MAX,        // data upper limits
	    FALSE);         // Add demand stream to WIT if not there
d8812 3
d11207 1
a11207 1
    LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
d12579 1
d12688 11
d13242 5
a13246 4
   LgFrInitialProblemAndParameters(source.scenario()),
   implementSmartFeatures_(source.implementSmartFeatures_),
   heurModelHelper_(source.heurModelHelper_),
   lpModelHelper_(source.lpModelHelper_)
d13255 6
a13260 5
    LgFrInitialProblemAndParameters(
       LgFrScenarioSmartPointer::nullScenarioSmartPointer),
    implementSmartFeatures_(TRUE),
    heurModelHelper_(NULL),
    lpModelHelper_(NULL)
d13268 5
a13272 4
    LgFrInitialProblemAndParameters(scenario),
    implementSmartFeatures_(TRUE),
    heurModelHelper_(NULL),
    lpModelHelper_(NULL)
@


1.20
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d13360 2
d13364 1
@


1.19
log
@added prodVolPegging for ats and forcePcfBogons (experimental)
@
text
@d1 1
d13359 4
@


1.18
log
@bogon output, and minor changes
@
text
@d4254 7
d4380 28
a4407 10
      (*theErrFacil)("ExtraPCFPart",MclArgList() 
		     << "it has BOM child components" 
		     << mfgPartName 
		     << pdf 
		     << fileName 
		     << (int)lineNo 
		     << dataLine);
      didWeRejectTheRecord = TRUE;
      // skip to next part. No need to keep checking
      badCount++;
d4423 1
d4425 1
d4428 3
@


1.17
log
@added indepDemandRevenueFile
@
text
@a34 158
// making this a parameter ...
// #define STRAIGHT_SCRUB_OFSUPPLY_FILE
#if 0
// get the scenario


LgFrScenarioForSceSmartPointer
LgFrInitialProblemForSce::SCEscenario()
     const
{
    if (scenario()->isA() != __LGFRSCENARIOFORSCE)  {
      cerr << "the object is not a SCEscenario and it is supposed to be" << endl;
        assert(0);
    }
  
  return LgFrScenarioForSceSmartPointer(scenario());
}
#endif


// Returns a description of the problem that is suitable for use as a
// window heading. This can not be used to set the title; only to query
// it.
RWCString
LgFrInitialProblemForSce::title(const LgFrDataInterfaceEssentials* difEssenPtr)
     const
{
  RWCString theTitle("Supply Capability Engine: ");
  //  theTitle.append(dataInterfacePtr()->title(difEssenPtr));
  theTitle.append(sceScenario()->dataInterface()->title(difEssenPtr));  
  return theTitle;
}


// get the scenario
LgFrScenarioForSceSmartPointer
LgFrInitialProblemForSce::sceScenario()
     const
{
    if (scenario()->isA() != __LGFRSCENARIOFORSCE)  {
        cerr << "the object is not a SCE scenario and it is supposed to be"
             << endl;
        exit(8);
    }

    return LgFrScenarioForSceSmartPointer(scenario());
}

// Populates the WitRun's data structures 
void
LgFrInitialProblemForSce::feedInto(
				     LgFrLastProblemSolved & lps)
{
  LgFrDataInterface * dif  =
    (LgFrDataInterface*) (sceScenario()->dataInterface());
  LgFrCalendar&     calendar   = sceScenario()->calendar();
  
  assert( dif->dataInterfaceImplementation()->isA() ==
          __LGFRDATAINTERFACEIMPLEMENTATIONFROMSCEFILES );
  LgFrDataInterfaceImplementationFromSceFiles *difSceF    = 
      (LgFrDataInterfaceImplementationFromSceFiles *) dif->dataInterfaceImplementation();

  

//  cout << "\nLgFrInitialProblemForSce::feedinto() ---> " 
//       << this->title() << "\n";
    
  // Get sce file name
  RWCString parameterFilename = difSceF->filename();

  // get the witRun pointer from lps
  WitRun * theWitRun = lps.witRun();

  // **********************************
  // Now populate the wit run and sets of parts and demands
  // **********************************

#ifndef ELIMINATE_OLD_MAIN  
  oldMain(parameterFilename, calendar, theWitRun);
#endif

}


// Create a copy of the *this on the heap and return a pointer to it
// Even thought this returns a LgFrInitialProblemAndParameters*, the pointer
// must point to a LgFrInitialProblemForSce.
LgFrInitialProblemAndParameters*
LgFrInitialProblemForSce::clone ()
     const
{
  return new LgFrInitialProblemForSce(*this);
}

// Make scenario clone copy of object
LgFrInitialProblemAndParameters *
LgFrInitialProblemForSce::clone(
   LgFrScenarioSmartPointer newScenario)
const
{
  LgFrInitialProblemAndParameters* newInst =
      new LgFrInitialProblemForSce(newScenario);
  return (newInst);
}



LgFrInitialProblemForSce::~LgFrInitialProblemForSce()
{
  // Nothing to do, so do nothing but return
  delete heurModelHelper_;
  delete lpModelHelper_;
}

// Assignment operator.
LgFrInitialProblemForSce&
LgFrInitialProblemForSce::operator=(
            const LgFrInitialProblemForSce& rhs)
{
  
  return *new LgFrInitialProblemForSce(rhs.scenario());
}

// Copy constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce(
            const LgFrInitialProblemForSce& source)
:
   LgFrInitialProblemAndParameters(source.scenario()),
   implementSmartFeatures_(source.implementSmartFeatures_),
   heurModelHelper_(source.heurModelHelper_),
   lpModelHelper_(source.lpModelHelper_)
{
  // All the work is done in the initialization part
  // except this
}

// Default Constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce()
:
    LgFrInitialProblemAndParameters(
       LgFrScenarioSmartPointer::nullScenarioSmartPointer),
    implementSmartFeatures_(TRUE),
    heurModelHelper_(NULL),
    lpModelHelper_(NULL)
{
  // All the work is done in the initialization part
}

// the preferred Constructor
LgFrInitialProblemForSce::LgFrInitialProblemForSce(LgFrScenarioSmartPointer scenario)
:
    LgFrInitialProblemAndParameters(scenario),
    implementSmartFeatures_(TRUE),
    heurModelHelper_(NULL),
    lpModelHelper_(NULL)
{
  // All the work is done in the initialization part
}
a38 86

// ============================================================
// ============================================================
// ============================================================
// ============================================================
// Here's all the SCE stuff that's been crammed into
// ipSCE


// ============================================================
// ============================================================
// =========(this is sceMain.C  ================================


// ****************************************************************************
// The OLD Main Program                                                   
// The name of the SCE parameter file  must be specified on command line.
// ****************************************************************************

void 
LgFrInitialProblemForSce::oldMain (
    RWCString & parameterFileName,
    LgFrCalendar & theCal,
    WitRun * theWitRun)
{
  MclFacility * theErrFacil = this->sceScenario()->getErrFacility();


  if (! doesInputFileExist(parameterFileName))  {
    // Error
    (*theErrFacil)("SevereCannotOpenFile",MclArgList() << "Parameter" << parameterFileName << "");
  }

   // get the global soParms from scenario.
   LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
  
   LgFrSceParameterManager myParamMgr;
   // this shares the scenario's error with the parameter manager
   myParamMgr.setErrFacility(theErrFacil);
   myParamMgr.initializeSetOfParameters(parameterFileName, setOfParameters);

   // initialize the set of illegal characters in the flat file manager
   LgFrSceFlatFileMgr & myFlatFileMgr = this->sceScenario()->flatFileMgr();
   myFlatFileMgr.appendToTheSetOfIllegalCharacters( setOfParameters.getString("pdfSeparator"));

   myFlatFileMgr.sceIOLogManager().copySetOfParams(this->sceScenario()->setOfParameters());

   // reset the IO log
   myFlatFileMgr.sceIOLogManager().resetInputLog();
   myFlatFileMgr.sceIOLogManager().resetOutputLog();

   // also get give paramMgr a handle for iolog manager
   myParamMgr.setIOLogMgr(&(myFlatFileMgr.sceIOLogManager()));


   // Read the calendarFormat code and set it in the flatFileMgr
   RWCString calendarFormat = setOfParameters.getString("calendarFormat");
   myFlatFileMgr.setGlobalCalendarFormat(calendarFormat);

   // set variable engine
   sceScenario()->setEngine(setOfParameters.getString("engine"));

#ifndef SCE_OPT_IMPLODE
   if (setOfParameters.getString("engine") == "optimization") {
     (*theErrFacil)("OptEngineNotSupported");
     // this will exit
   }
#endif


   theCal.nPeriods(setOfParameters.getInt("numPeriods"));
   
   // create a multiPlantHelper Object
   LgFrMultiPlantHelper & mpHelper = sceScenario()->multiPlantHelper();


   // Call the API program to read all the datafiles and populate theWitRun
   initializeTheWitRunForSCE(
       theWitRun, 
       theCal,
       mpHelper);

}



d40 1
a41 3
// =========(this is sceInit.C ================================


d43 1
a43 1
LgFrInitialProblemForSce::initializeTheWitRunForSCE(
a282 1
#ifdef EXEC_COSTS
d286 1
d288 9
a296 4
    if (! operationExecCostFile.isNull())    
      processOperationExecCostFile( theWitRun, nPeriods, theCal, 
			     operationExecCostFile, mpHelper);
#endif
d517 1
a517 1
    int objType = setOfParameters.getInt("objectiveType");
d533 1
a533 1
    if (objType == 1) {
d559 1
a559 1
    if (objType == 2) {
d595 1
a595 1
    if (objType == 3) {
d817 3
a819 5

      

    // If you are doing scrub mode only, then do not print out 
    // these diagnostic files
d823 1
a823 1

d825 1
d829 1
a829 1
    
d831 1
d842 1
d844 1
d855 3
a857 2

    // Set up a part index system via part app data 
d862 1
d864 1
a872 36



    // ifdef'd out this memory intesnsive approach.   Experimenting with 
    // more efficient approach below
#if 0
    if (setOfParameters.getBool("printDemandDriversFile"))  {
      cout << "Computing Demand Drivers  ..." << endl;                      
      // demandDrivers will report subs as a default.  To shut it off
      // we need to set netAllowed to False for all subs.  This may
      // also screw up indexing so we reset all wit part indices 
      // after printing, WE MUST turn subs back on (netAllowed to TRUE)
      if (! setOfParameters.getBool("demandDriversRespectsSubs")) {
	this->setSubsNetAllowed(FALSE, mpHelper, theWitRun);
	mpHelper.setAllWitPartIndices(theWitRun);
      }
      myDemandDriver = new LgFrSceDemandDriver(theWitRun, &mpHelper);
      myDemandDriver->compute();
    }


    // Print Demand Drivers File
    if (setOfParameters.getBool("printDemandDriversFile"))  {
      cout << "Writing the Demand Drivers file  ..." << endl;                      
      RWCString demandDriversFileName = setOfParameters.getString("demandDriversFileName");
      myDemandDriver->print(demandDriversFileName, theErrFacil);
      if (! setOfParameters.getBool("demandDriversRespectsSubs")) {
    	this->setSubsNetAllowed(TRUE, mpHelper, theWitRun);
	    mpHelper.setAllWitPartIndices(theWitRun);
      }
      // FINISH_ME: Does this thing need to be persistent??
      delete myDemandDriver;
    }
#else
    // a better way

d896 7
a903 1
#endif
a904 1
}
d4383 15
d4438 14
d7271 1
a7271 1
#ifdef EXEC_COSTS
a7345 1
#endif
d13118 210
@


1.16
log
@print lowest level non-pcf files
@
text
@d821 9
@


1.15
log
@new param ... aggregateSupplyInScrub needed by ATS
@
text
@d6391 1
d6394 6
a6399 1
					     0.0, FLT_MAX);
d6403 3
d6413 15
@


1.14
log
@pegging now picks up negative usage rates and minor message
@
text
@d35 2
a36 1
#define STRAIGHT_SCRUB_OFSUPPLY_FILE
d1015 5
a1019 4
#ifndef STRAIGHT_SCRUB_OFSUPPLY_FILE
      scrubSupplyAvailabilityFile(theWitRun, theCal, nPeriods, 
				  supplyFile, mpHelper);    
#endif
a4121 1
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
d4123 2
d4126 5
a4130 1
  this->openInputFileAndScrubOutputFile(fileName,
d4136 9
a4144 8
#else
 inFile.open(fileName, ios::in);

 if (! inFile)  {
   (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		  << "Supply" 
		  << fileName 
		  << "");
a4145 1
#endif
d4192 4
a4195 3
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
    if (myScrubber -> scrubMode() && outFile.good())  {
      outFile << dataLine << endl;
a4196 1
#endif
d4204 5
a4208 3
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
 outFile.close();
#endif
a4244 1
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
d4247 2
a4248 8
  this->openInputFileAndScrubOutputFile(fileName,
				       "Dated Supply",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
#else
 inFile.open(fileName, ios::in);
d4250 17
a4266 5
 if (! inFile)  {
   (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		  << "Dated Supply" 
		  << fileName 
		  << "");
d4268 1
a4268 1
#endif
d4380 4
a4383 3
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
    if (myScrubber -> scrubMode() && outFile.good())  {
      outFile << dataLine << endl;
a4384 1
#endif
d4391 3
a4393 3
#ifdef STRAIGHT_SCRUB_OFSUPPLY_FILE
 outFile.close();
#endif
@


1.13
log
@was double counting goodRecord count for minIndepDemand
@
text
@d1595 1
a1595 1
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);
@


1.12
log
@3.11 commit
@
text
@d6360 16
a6375 16
  if (! doesDemandExist(theWitRun, fullWitPart, demandName)) {
    (*theErrFacil)("IndDemandDoesNotExist",MclArgList() 
		   << mfgPart 
		   << pdf
		   << demandName
		   << fileName 
		   << (int)lineNo 
		   << dataLine);
    continue;
  }





  
d6385 1
a6385 1

a6453 2
      else
	recCount ++;
@


1.11
log
@file cleaning ... more pegging ... parameters ...
@
text
@d35 1
a35 1

d352 1
a352 1
    if (engine == "optimization")
d429 6
d856 8
d881 5
a885 1

d1014 1
d1017 1
d4120 10
d4138 1
a4138 1

d4185 5
d4196 4
d4209 178
d5290 1
a5290 1
  int o,t;
d5761 5
d6168 2
a6169 1
			 << dataLine);
d6251 258
@


1.10
log
@yet another fix for setPureOptionBuild.
New parameter: shutOffAllLotSizing ... which does just that
@
text
@d899 1
a899 2
    //    go back to special feature demands and
    //  set their priorities
d912 1
d915 4
a918 2
      cout << "Analyzing SCE model (multiple bop entries) ..." << endl;
      scePreProcessMultiBopEntries ( theWitRun, useMultiRouteImplosion );
d922 1
a922 2
      // *** Analyze model for parts with multiple interplant
      // ***                 operations
d934 4
a937 2
      cout << "Analyzing SCE model (multiple interplant entries) ..." << endl;
      scePreProcessMultiInterPlantEntries ( theWitRun, mpHelper );
d960 3
a972 3
    // Do a witPreprocess before the echo file
    cout << "Pre-Processing for wit  ..." << endl;          
    witPreprocess(theWitRun);
d974 1
a974 3


    // *************************************
d976 1
a976 1
    // *************************************
a978 1

a983 1
      
a991 1

a994 1

a997 1

a1000 1

a1004 1

d1008 3
d1036 4
a3410 1
    // FINISH_ME: 2.31 SET The default as buildable!!
a3411 1
    //    int   isInterplantExplodeableAsSubstitute = 0;
@


1.9
log
@commit for 3.103
@
text
@d652 1
a652 1
    // ***  Setup the DEMANDS *****
d670 4
d682 3
d1021 10
d5063 27
d5111 1
@


1.8
log
@added access to BOP explodable flag for user defined operations
also added message for JP
@
text
@d1060 6
d1093 28
@


1.7
log
@3.10 pegging capability
@
text
@d1948 2
a1949 1
    float preference = 0.0;
d1984 8
d2008 1
d8038 1
d8139 3
a8141 1
  witSetBopEntryExpAllowed(theWitRun, pdfOperationName, bopEntryIndex, WitTRUE);
@


1.6
log
@Preliminary Commit for release 3.10 ... still in development!!!!
@
text
@d418 6
d1166 1
a1166 1
  inFile.open(fileName, ios::in);
@


1.5
log
@changes for Release 3.00
@
text
@d1000 3
d4977 1
a4977 1
	// get the  demand app data for this demand.  get the hasDemandVolBeenSet
a5947 2
  void * demandAppVoidPtr;
  LgFrSceDemandAppData * madPtr;  // "M"y  "A"pp  "D"ata  Ptr
d5998 2
a5999 1
    witGetDemandAppData(theWitRun, 
d6001 4
a6004 4
			demandName, 
			&demandAppVoidPtr);
    
    // check to see if the demandAppVoidPtr has been set yet in WIT.
d6006 1
a6006 3
    // If it's set, then it must be a LgFrSceDemandAppData *
    // Anyway, cast it to LgFrSceDemandAppData * and call it demandAppVoidPtr.
    // If the dmdAppDataPtr hasn't been set (i.e., its NULL) then "new" one
d6008 1
a6008 1
    // If the dmdAppDataPtr has been set, see if the backlogYield has been set.
d6010 3
a6012 3
    if (demandAppVoidPtr == NULL)  {
      madPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);  // init backlogYield to 1.0
      assert ( madPtr != 0);
d6017 1
a6017 4
                          (void *) madPtr );
    }
    else  {
      madPtr = ((LgFrSceDemandAppData *) demandAppVoidPtr);
d6020 1
a6020 1
    LgFrTimeVecFloat backlogYield( madPtr->backlogYield() );
d6025 1
a6025 1
    madPtr->backlogYield(backlogYield);
d10401 19
d10444 2
d10819 17
@


1.4
log
@Fixed memory bug in Customer Choice Feature logic
@
text
@d377 5
d516 9
a524 1

d895 28
a922 25
    
    // *****************************************************
    // *** Analyze model for parts with multiple Bops
    // *****************************************************
    cout << "Analyzing SCE model (multiple bop entries) ..." << endl;
    scePreProcessMultiBopEntries ( theWitRun, useMultiRouteImplosion );


    // *****************************************************
    // *** Analyze model for parts with multiple interplant
    // ***                 operations
    // *****************************************************
    // Multi-sourcing a part from a variety of supplier
    // locations is modeled in SCE as the part being produced 
    // from a variety of "interplant" operations. 
    // 
    // The current heuristic doesn't excercise the alternative
    // ways to build a part when multiple operations exist.
    // To slightly mitigate this drawback until the heuristic
    // is improved, this method adds "jumper arcs" (aka substitutes)
    // from the supplier parts at alternative interplant locations to
    // the supplier part at the preferred interplant location.
    cout << "Analyzing SCE model (multiple interplant entries) ..." << endl;
    scePreProcessMultiInterPlantEntries ( theWitRun, mpHelper );

d925 16
a940 16
    // *****************************************************
    // *** Analyze model for parts with multiple bin
    // ***                 operations
    // *****************************************************
    // Multi-sourcing a part from a variety of supplier
    // locations is modeled in SCE as the part being produced 
    // from a variety of "bin" operations. 
    // 
    // The current heuristic doesn't excercise the alternative
    // ways to build a part when multiple operations exist.
    // To slightly mitigate this drawback until the heuristic
    // is improved, this method adds "jumper arcs" (aka substitutes)
    // from the supplier parts at alternative bin locations to
    // the supplier part at the preferred bin location.
    cout << "Analyzing SCE model (multiple bin entries) ..." << endl;
    scePreProcessMultiBinEntries ( theWitRun, mpHelper );
d942 1
d6892 72
d6965 3
d8488 9
@


1.3
log
@ADded indpendent demand file to scrubber list.
Fixed bug in feature ratio check for all zero (it was reporting any zero
condition as all zero)
@
text
@d10210 2
a10211 1

a10231 1
  witSetBomEntryOffset(theWitRun, geoPlannerDemandPart, 0, transitTimeOffset);
d10239 1
a10239 1
  // machine cycletime is applied to bomOffset between specialFeature and featurePart.
d10246 1
a10246 1
  // Now work on adding a substitute arc to the geoPlannerDemandPart to featurePart BOM entry.
d10249 1
a10249 1
  // geo_plannerPart_featurePart combination (if not then create one
d10265 1
a10265 4
  // now add the sub arc.  You must get the bom number of the bom
  // to be subbed off of.  Fortunately, you can get it easily.
  // How?, You just added the "last" bom entry and now you want
  // to sub off it.  So the bom entry number is nBom - 1.
a10269 3
  int nBom;
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPart, &nBom);
  assert(nBom > 0);
d10271 2
a10272 2
  witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart, nBom-1, &nSubBom);
  witAddSubsBomEntry( theWitRun, geoPlannerDemandPart, nBom-1, ccNullSubstitute );
d10275 1
a10275 1
  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, transitTimeOffset);
d10278 1
a10278 1
  witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart, nBom-1, nSubBom, WitFALSE);
d10282 1
a10282 1
    witSetSubsBomEntryObj1SubCost ( theWitRun, geoPlannerDemandPart, nBom-1, nSubBom,
@


1.3.2.1
log
@Customer Choice bug fix and memory leak patch.
@
text
@d10210 1
a10210 2
  // bomIndex = The bom entry number of GPD->SpecialCustChoiceFeatPart
  //      The bom is added here and can be used below
d10231 1
d10239 1
a10239 1
  // machine cycletime is applied to bomOffset between specialCCFeature and featurePart.
d10246 1
a10246 1
  // Now work on adding a substitute arc to the geoPlannerDemandOperation to featurePart BOM entry.
d10249 1
a10249 1
  // geo_plannerDemand_featurePart combination (if not then create one
d10265 4
a10268 1
  // Now add sub arc: (GPD->sCCF)->NullSub. 
d10273 3
d10277 2
a10278 2
  witGetBomEntryNSubsBomEntries( theWitRun, geoPlannerDemandPart, bomIndex, &nSubBom);
  witAddSubsBomEntry( theWitRun, geoPlannerDemandPart, bomIndex, ccNullSubstitute );
d10281 1
a10281 1
  witSetSubsBomEntryOffset(theWitRun, geoPlannerDemandPart, bomIndex, nSubBom, transitTimeOffset);
d10284 1
a10284 1
  witSetSubsBomEntryExpAllowed(theWitRun, geoPlannerDemandPart, bomIndex, nSubBom, WitFALSE);
d10288 1
a10288 1
    witSetSubsBomEntryObj1SubCost ( theWitRun, geoPlannerDemandPart, bomIndex, nSubBom,
@


1.2
log
@modifications for sce 2.31
@
text
@d5228 9
a5237 8
 inFile.open(fileName, ios::in);

 if (! inFile)  {
   (*theErrFacil)("SevereCannotOpenFile",MclArgList() 
		  << "demandVolume" 
		  << fileName 
		  << "");
 }
d5413 5
d10113 1
a10113 1
  if (frTVF.min() < IPSCE_FLT_EPS)  {
@


1.2.2.1
log
@manual merge of bug fixes
@
text
@a5227 9
 ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "Independent Demand Volume",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
d5229 8
a5411 5
  if (myScrubber -> scrubMode() && outFile.good())
    {
      outFile << dataLine << endl;
    }

d10107 1
a10107 1
  if (frTVF.max() < 0.00001)  {
@


1.1
log
@Initial revision
@
text
@d76 1
a76 1
        abort;
a265 23
   // Set up the locale   
#ifdef SUN4
   (*theErrFacil)("CalendarFormat");
#else     

   cout << "Using default Locale ..." << endl;
#if 0
   RWLocaleSnapshot * myLocalePtr;
   if (myFlatFileMgr.getGlobalCalendarFormat() == "E") {
     myLocalePtr = new RWLocaleSnapshot("En_GB");
   }
   else {
     cout << "new-ing an en_US RWLocale\n" << endl;
     myLocalePtr = new RWLocaleSnapshot("en_US");
     cout << "done new-ing a RWLocale" << endl ;
   }
   sceScenario()->localeSnapshot (myLocalePtr);
#endif

#endif   

   

a269 5
   //

   RWBoolean prepForEpps = setOfParameters.getBool("prepForEpps");
   if (prepForEpps)
    (*theErrFacil)("EppsObsolete");
d276 1
a276 2
       mpHelper,
       prepForEpps);
d291 1
a291 2
    LgFrMultiPlantHelper & mpHelper,
    const RWBoolean prepForEpps)
a294 1
    int i;                     // Loop index     
a389 22
    // make a demand File for EPPS (maybe) and EXIT -- we'll be back
    if (prepForEpps)  {
	RWCString demandVolFile = setOfParameters.getString("demandVolFile");
	RWCString geoSourceFile = setOfParameters.getString("geoSourceFile");

        // RLH: if the EPPS option is selected, then the code does a quick
        // explode and returns. No implosion is done, so for now (5/14/97)
        // leave objChoice = 1 and use obj vectors as data holding places.
	witSetObjChoice(theWitRun, 1);
	witSetNPeriods(theWitRun, nPeriodsInCal);

	witSetBuildWhenEmpty(theWitRun, WitFALSE);

	makeDemandFileForEpps(
			      theWitRun,
			      demandVolFile, 
			      geoSourceFile,
			      theCal,
			      mpHelper);    

	return;
    }
d571 1
a572 4
    // Read EPPS formatted BOM file
    if ( fileFormatType == SCE_EPPS_FILE_FORMAT) {
	processEPPSBomFile( theWitRun, theCal, bomFile, mpHelper);
    }
d574 3
a576 9
    // Read STANDARD formatted BomFile
    else {
	processStandardBomFile( theWitRun, theCal, 
				bomFile, mpHelper);


        // *************************
        // ***  InterPlant file  ***
        // *************************
a593 7



    }



d1055 2
a1056 2
	this->setSubsNetAllowed(TRUE, mpHelper, theWitRun);
	mpHelper.setAllWitPartIndices(theWitRun);
a1375 182
// ---------------------------------------------------------------
void 
LgFrInitialProblemForSce::processEPPSBomFile(
    
    WitRun * const theWitRun,   
    const LgFrCalendar & theCal,
    const RWCString & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

 int nElementsChanged;
 RWCString fullParent;
 RWCString fullChild;
 RWCString parent;
 RWCString child;

 RWCString dataLine;

 MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

 int nPeriods = theCal.nPeriods();
 int result;
 int result2;

 float  ur     = 1.0;
 float  ut     = 0.0;
 int    fallout = 0;
 int    early = 0;
 int    late = nPeriods-1;
 int    mec = 0;
 int    phantomFlag = 0;
 int    removeBillFlag = 0;
 int    mandatoryOptionFlag = 1;
 float  featureRatio = 1.0;
 float  maxWithoutRatio = 1.0;
 float  minLotSize = 0.0;
 float  incLotSize = 0.0;

 LgFrSceFlatFileMgr & flatFileManager =
   this->sceScenario()->flatFileMgr();


 ifstream inFile;
 ofstream outFile;
 LgFrSceScrubber * myScrubber = this->sceScenario()->scrubber();
 
 this->openInputFileAndScrubOutputFile(fileName,
				       "EPPS BOM",
				       inFile,
				       outFile,
				       myScrubber,
				       theErrFacil);
 


 cout << "Processing " << fileName << ":\t" << flush;
 long recCount = 0;
 long badCount = 0;
 long commentCount = 0;
 long lineNo = 0;
 while(inFile.peek() != EOF) {

     // read the next BOM line
    dataLine.readToDelim(inFile);
    lineNo++;

//  skip blanks or comments *
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
        commentCount++;
	continue;
    }

// check if the line contains any illegal characters
        if ( flatFileManager.containsIllegalCharacters( dataLine )) {
	  (*theErrFacil)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine); 
        }

    
    RWCTokenizer next(dataLine);

// get the parent part
    fullParent = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			      lineNo, OPTIONAL_WITH_MESSAGE);


// get the child part
    fullChild = flatFileManager.nextQuotedString(next, result, fileName, dataLine, 
			     lineNo, OPTIONAL_WITH_MESSAGE);


    if (result == -1) {
        badCount++;
	continue;
    }

    // The rest of the fields are optional.  
    // Set the defaults, and parse the rest of the line.  
    ur = 1.0;
    ut = 0.0;
    fallout = 0;
    early = 0;
    late = nPeriods-1;
    mec = 0;
    phantomFlag = 0;
    removeBillFlag = 0;
    mandatoryOptionFlag = 1;
    featureRatio = 1.0;
    maxWithoutRatio = 1.0;

    // FINISH_ME: we probably should just bag this format,
    //            but here are defaults for new parameters anyway.
    float usageRate = 1.0;
    float preference = 1.0;
    int isObjectInEffectForOptExplosion = 0.0;

    // usage rate        
    result = flatFileManager.nextFloat(ur, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
    if (result == -1) {
        badCount++;
	continue;
    }

    // usage time
    if (result >= 0)
    result = flatFileManager.nextFloat(ut, next, fileName, dataLine, lineNo, FALSE, -FLT_MAX);
    if (result == -1) {
        badCount++;
	continue;
    }

    // effectivity Dates
    if (result >= 0)
	result2 = flatFileManager.nextStartEndDates(early, late, next, fileName, lineNo, dataLine, theCal);
    if (result == 1) {
        badCount++;
	continue;
    }
    if ((early == nPeriods) || (late < 0)) {
      (*theErrFacil)("OutOfRange",MclArgList() << "Effectivity dates" << fileName << (int) lineNo << dataLine << "BOM entry ignored.");
	badCount++;
	continue;
    }

    // fallout
    if (result2 >= 0)
	result = flatFileManager.nextInt(fallout, next, fileName, dataLine, lineNo, FALSE, 0, 100);

    // mandatory EC
    if (result >= 0)
	result = flatFileManager.nextInt(mec, next, fileName, dataLine, lineNo, FALSE, 0, 1);

    // phantom Flag
    if (result >= 0)
	result = flatFileManager.nextInt(phantomFlag, next, fileName, dataLine, lineNo, FALSE, 0, 1);


    // remove Flag
    if (result >= 0)
	result = flatFileManager.nextInt(removeBillFlag, next, fileName, dataLine, lineNo, 
			 FALSE, 0, 1);



    // mandatoryOptionFlag
    if (result >= 0)
	result = flatFileManager.nextInt(mandatoryOptionFlag, next, fileName, dataLine, lineNo, 
			 FALSE, 0, 1);


    // featureRatio
    if (result >= 0)
	result = flatFileManager.nextFloat(featureRatio, next, fileName, dataLine, lineNo, FALSE);


    // maxWithoutRatio
    result = flatFileManager.nextFloat(maxWithoutRatio, next, fileName, dataLine, lineNo, FALSE, 0.0);



// scale the  usage time
    ut = ut / theCal.workUnits(early);
a1376 111
    RWCString parentPdf = mpHelper.pdf(fullParent);
    RWCString childPdf  = mpHelper.pdf(fullChild);
    RWCString parent = mpHelper.partname(fullParent);
    RWCString child  = mpHelper.partname(fullChild);


// PDF's are different ===> InterPlant 
    if (parentPdf != childPdf)   {
	result = addInterPlantBomStructure(
	    theWitRun, 
	    mpHelper,
	    theCal,
	    parent, 
	    parentPdf, 
	    child, 
	    childPdf, 
	    ut, 
	    early, 
	    late,
            minLotSize,
            incLotSize,
            usageRate,
            preference,
            isObjectInEffectForOptExplosion,
            0,
	    fileName,
	    dataLine,
	    lineNo);
	recCount++;
        if (myScrubber -> scrubMode() && outFile.good())
          {
            outFile << dataLine << endl;
          }
    }


// mandatoryOptionFlag = FALSE ====> A Pure Option     
    else if (! mandatoryOptionFlag)  {
	result = sceAddPureOptionAsFixedBomStructure(
	    theWitRun, 
	    mpHelper,
	    parent, 
	    parentPdf, 
	    child, 
	    childPdf, 
	    ur,
	    ut, 
	    early, 
	    late,
	    fallout,
	    featureRatio,
	    maxWithoutRatio,
	    fileName,
	    dataLine,
	    lineNo);
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << endl;
              }
          }
	else
	    badCount++;
    }

// Normal BOM entry.  Note: EPPS already fixes phantom's 
    else  {
	result = sceAddNormalBomStructure(
	    theWitRun, 
	    mpHelper,
	    parent, 
	    parentPdf, 
	    child, 
	    childPdf, 
	    ur,
	    ut, 
	    early, 
	    late,
	    fallout,
	    mec,
	    0,        // phantom is  being fixed  by EPPS
	    removeBillFlag,
	    fileName,
	    dataLine,
	    lineNo);
	if (! result)
          {
	    recCount ++;
            if (myScrubber -> scrubMode() && outFile.good())
              {
                outFile << dataLine << endl;
              }
          }

	else
	    badCount++;
    }


 }
 cout << recCount << " records processed." << endl;
 inFile.close();
 outFile.close();
 // if no data in input file, then error
 if (recCount == 0)
   (*theErrFacil)("DatalessMandatoryInputFile",MclArgList() << "BOM file");

 flatFileManager.sceIOLogManager().printInputLog(fileName,lineNo,recCount,badCount,commentCount,recCount);
}
a1390 1
 int nElementsChanged;
a1564 1
 int nElementsChanged;
a1699 1
 int nElementsChanged;
a1847 1
 int nElementsChanged;
a1860 2
 int result2;

a2005 1
 int nElementsChanged;
a2161 1
 int nElementsChanged;
d2267 1
a2331 1
 int nElementsChanged;
d2474 5
a2501 1
  int nElementsChanged;
a2796 1
  int nElementsChanged;
a2799 1
  float offsetVal;
a2802 1
  float * offset;
a2956 1
  int nElementsChanged;
a3107 1
    int nElementsChanged;
a3239 1
 int nElementsChanged;
a3432 1
 int nElementsChanged;
a3631 1
 int nElementsChanged;
a3821 1
 int nElementsChanged;
d4193 1
a4193 1
  int unConstrainedStartPeriod, late;
d4385 7
a4391 2
      assert(appDataPtr == NULL);
      appDataPtr = new LgFrScePartAppData(1, unConstrainedStartPeriod);
d4432 1
a4432 1
  int unConstrainedStartPeriod, late;
d4609 1
a4609 1
  int i, j, t;
a4937 1
  float * demandVol;
a5212 1
 float * demandVol;
a5248 2
   float * sr;

d5465 7
a5471 7
	theWitRun,      // WIT environment    
	nPeriods,       // Number of periods  
	pdf_PartName,   // pdf_PartName to be returned
	demandName,     // demandName to be returned
	floatVec,       // floatVector to be returned
	inFile,         // An open input stream
	fileName,       // for messaging
d5473 6
a5478 6
	lineNo,         // current line number, for messaging
	mpHelper,       // The helper object
	FALSE,          // Are all elements mandatory?
	0.0,            // data lower limits
	INT_MAX,        // data upper limits
	FALSE);         // Add demand stream to WIT if not there
a5558 1
 float * demandVol;
a5592 2
   float * sr;

a5921 1
  float * backlogYield;
a6812 1
 float theVal;
d6880 1
a6880 1
    long np, pd;
a7081 157
// -----------------------------------------------------------------
// makeDemandFileForEpps
// ---------------------
//
//  This is a standAlone utility that is only run upon request.  This routine
//  reads the demandVolumeFile and the geoSouceFile and creates a "demand" file
//  by (mfgPartNumber, PDF).  This is needed because EPPS does not know about
//  (plannerPartNumber, GEO).  Since the geoSourceFile is the mapping between
//  (mfgPartNumber,PDF) and (plannerPartNumber, GEO), we use it here again.
//
//  We use a witRun as our data structure.  We create a witPart to represent the
//  the (plannerPartNumber, GEO) and a witPart to represent the (mfgPartNumber,PDF).
//  We then create BOM arcs to represent the mapping.  The reason we did not use
//  a simpler data structure is that the mapping can be 1::N  (at this time, 
//  the mapping is 1::1 in any given period but you can "re-map" the demand over
//  time -- via effectivities).

void
LgFrInitialProblemForSce::makeDemandFileForEpps(
    
    WitRun * const theWitRun,
    const RWCString & demandVolFile, 
    const RWCString & geoSourceFile,
    const LgFrCalendar & theCal,
    LgFrMultiPlantHelper & mpHelper) 
{

    int i, t;
    int nParts;
    char ** partList;

    witReturnCode rc;

    RWCString eppsDemandFile("./eppsDemand.file");

    int nPeriods = theCal.nPeriods();

    LgFrSceFlatFileMgr & flatFileManager = this->sceScenario()->flatFileMgr();

    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();

// First we coordinate the SCE calendar with the EPPS calendar.  
// EPPS expects the demand volume file to be:
//      1) MONTHLY
//      2) exactly 28 buckets 
//      3) bucket 0 corresponding to January of the CURRENT year.
// Hence we need to pad the SCE demand volume timeVecs with 0's on both
// the front and back of the vector (depending on how the calendars
// overlap.)
// Use the calendar to figure it all out.

    // today's date
    RWDate today;
    
    // start date of first bucket
    RWDate horizonStart(theCal.periodStart(0));

    unsigned startYear = today.year();
    RWDate firstDayOfThisYear(1, 1, startYear);

    if (horizonStart < firstDayOfThisYear )  {
      (*theErrFacil)("CalendarNotUpToDate");
    }
    
    unsigned horizonStartYear = horizonStart.year();
    unsigned horizonStartMonth = horizonStart.month();


    int leadingZeros = ((horizonStartYear - startYear) * 12) + horizonStartMonth - 1;

    if (leadingZeros > 27) {
      (*theErrFacil)("CalendarLateStartDate");
    }

    int trailingZeros = 28 - nPeriods - leadingZeros;
    if (trailingZeros < 0) 
	trailingZeros = 0;

    int printingPeriods = nPeriods;
    if (leadingZeros + nPeriods > 28)
	printingPeriods = 28 - leadingZeros;


    RWCString stringOfLeadingZeros;
    RWCString stringOfTrailingZeros;

    for (t=0; t<leadingZeros; t++)
	stringOfLeadingZeros.append(",0");

    for (t=0; t<trailingZeros; t++)
	stringOfTrailingZeros.append(",0");


//  use processGeoSourceFile() with one caveat, set the flag
//  createMfgPart = TRUE.  This means that when sourcing, if you find
//  a mfgPart,PDF that doesn't exist, then create one in theWitRun.
//  Normally, this would cause a warning.  But in this case, we don't
//  have a partDefinitionfile yet.  Indeed, the purpose of this routine
//  is to help EPPS create a partDefinitionFile for us.
    if (! geoSourceFile.isNull())
	processGeoSourceFile( theWitRun, geoSourceFile, theCal,
			     mpHelper, TRUE);

    else {
      (*theErrFacil)("SevereCannotOpenFile",MclArgList() << "geoSourceFile" << "-NO NAME-" << "This file is necessary for the makeDemandFileForEPPS utility.");
    }

//  Now load the Demand Volumes into the WitRun
    processDemandVolumeFile( theWitRun, nPeriods, demandVolFile, mpHelper);    

//  these are needed to pass by reference later on
    RWCString plannerPart;
    RWCString geo;

// Now do a witMrp() to explode demand to the mfg parts
    witMrp(theWitRun);


// Now pick up the reqVol and report it as the demand Vol
    ofstream outFile(eppsDemandFile, ios::out);

    float * mrpReqVol;

    // Loop once for each part.  
    witGetParts( theWitRun, &nParts, &partList );
    for (i=0; i<nParts; i++ ) {
	if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i], 
						       plannerPart, geo)
            ||
            mpHelper.isPartSpecialGeoPlannerDemandUbPart(theWitRun, partList[i], 
						       plannerPart, geo)) 
          continue;
	
	RWCString mfgPartName = mpHelper.partname(partList[i]);
	RWCString pdf         = mpHelper.pdf(partList[i]);
	
	outFile << "\"" 
		<< mfgPartName << "\",\"" 
		<< pdf << "\"" 
		<< stringOfLeadingZeros;
	
	witGetPartReqVol(theWitRun, partList[i], &mrpReqVol);
	
	for (t=0; t<printingPeriods; t++)
	    outFile << "," << mrpReqVol[t];
	
	outFile << stringOfTrailingZeros << "\n";
	
	portableFree(mrpReqVol); 
    }
    
    outFile.close();

    for (i=0; i<nParts; i++)
	portableFree(partList[i]);
    portableFree(partList);
}
a7449 2
  float * sr;

a7631 11
#if 0      
      LgFrSetOfDemands & univSOD = sceScenario()->setOfDemands(LGFR_UNIVERSAL_SET);
      LgFrSetOfParts & univSOP = sceScenario()->setOfParts(LGFR_UNIVERSAL_SET);

      const LgFrPart * dpnPtr = univSOP.findValue( geoPlannerDemandPartName );

      LgFrDemand demandToBeAdded   = univSOD . newDemand ( geo, dpnPtr );
      LgFrSetOfDemands & defSOD  = sceScenario()->setOfDemands(LGFR_DEFAULT_SET);
      if ( !defSOD.contains( demandToBeAdded ) )
        defSOD.insert( demandToBeAdded );
#endif
a7658 18
// ============================================================
// ============================================================
// =========(this is sceFileUtils.C ===========================

#if 0
void
LgFrInitialProblemForSce::setEngine(const RWCString & engine)
{
    engine_ = toLower(engine);
}

RWCString 
LgFrInitialProblemForSce::getEngine()
{
    return engine_;
}
#endif

a7738 1
    witBoolean  exists;
a7796 7
    

    LgFrSetOfParts & univSOP = sceScenario()->setOfParts(LGFR_UNIVERSAL_SET);
    LgFrPart partToBeAdded   = univSOP . newPart ( partName.data() );
    LgFrSetOfParts & defSOP  = sceScenario()->setOfParts(LGFR_DEFAULT_SET);
    if ( !defSOP.contains( partToBeAdded ) )
      defSOP.insert(partToBeAdded);
a7817 1
    witBoolean  exists;
a7831 6
    LgFrSetOfParts & univSOP = sceScenario()->setOfParts(LGFR_UNIVERSAL_SET);
    LgFrPart partToBeAdded   = univSOP . newPart ( capacityName );
    LgFrSetOfParts & defSOP  = sceScenario()->setOfParts(LGFR_DEFAULT_SET);
    if ( !defSOP.contains( partToBeAdded ) )
      defSOP.insert(partToBeAdded);

a7850 1
    witBoolean  exists;
a7930 1
    witBoolean exists;
a8054 2
    witBoolean exists;

a8208 1
  int nBomEntries;
a8451 1
  int nBomEntries;
d8653 5
d8893 1
a8893 13
//
//  This routine takes plannerTopLevelPart, a geo, a bbCategory, and a
//  optionPart (which is assumed to be a mfgPart)
//  and creates some dummy parts and structure:
//     -- a dummy part (the option dummy) is created for the optionPart
//     -- the real optionPart part hangs off of this option dummy
//     -- there may be multiple option parts if the geoPlannerPart is
//        multiply sourced.
//     -- another dummy part is created to represent the option ratio supply
//     -- the option ratio supply part also hangs off the option dummy
//     -- the LT and GT capacity parts (which are assocaited with the
//        bbCategory for this plannerTopLevel/geo, and, which should already
//        have been created)  also hang off the option dummy
d8917 2
a8918 1
    MclFacility * theErrFacil = this->sceScenario()->getErrFacility();
a8943 1

d8967 1
a8967 1
    // get a unique name for the option dummy operation
d8971 1
a8971 1
    // get a unique name for the option Ratio Supply part
d8976 1
a8976 1
    // see if option dummy operation already exists
d8989 1
d9004 3
d9009 1
d9032 2
d9061 5
a9065 11
    // setup the default option Revenue
    LgFrSceSetOfParameters & setOfParameters =  this->sceScenario()->setOfParameters();
    float defaultOptionShipReward = setOfParameters.getFloat("defaultOptionShipReward");

    float * optionDummyExecCost = new float[nPeriods];
    for (t=0; t<nPeriods; t++)  
      optionDummyExecCost[t] = -defaultOptionShipReward;



    // create the option dummy part in WIT.  If its a nullOption
d9068 1
a9068 1
    witAddOperation(theWitRun, optionDummy);
d9072 8
a9079 1
      if ( lpModelHelper_ != NULL )
d9081 2
d9084 11
a9094 14

    // now add BOP from OD to BBcat ....
    // Assumptions:
    //   1) one bop per op.  This may be bad, because we want the expAversion
    //      to be the negative of the optionRevenue which can change over time.
    //      for now, we'll take the first period of optionRevenue and use it
    //      as scalar for expAversion.
    witAddBopEntry(theWitRun, optionDummy, fullBbCategoryPart);


    // Now add the optionRatioSupply Part ...
    // get the stock cost for this part
    float optionRatioSupplyStockPenalty =
      setOfParameters.getFloat("optionRatioSupplyStockPenalty");
d9097 4
a9100 2
    // create the option ratio supply  part in WIT
    //      1) set up a stock cost using the default
d9105 1
a9105 3
    float * optionRatioSupplyStockPenaltyVec = new float[nPeriods];
    for (t=0; t<nPeriods; t++)  
	optionRatioSupplyStockPenaltyVec[t] = optionRatioSupplyStockPenalty;
a9107 3
    if ( lpModelHelper_ != NULL )
      witSetPartObj1StockCost( theWitRun, optionRatioSupply,
                               optionRatioSupplyStockPenaltyVec );
d9109 2
d9112 7
a9118 1
    delete [] optionRatioSupplyStockPenaltyVec;
d9121 7
d9129 3
a9131 1
    // add Bom: from optionDummy ---> optionRatioSupply
d9134 7
a9140 19
    // add Bom:  optionDummy -->  Real Option Part, FOR EACH GE0-->PDF source!!

    // This operation is NOT done for nullOption.
    // NOTE:  The usage time must "equal" the cumulative lead time
    // associated with the pdf->geo transit time and the cycleTime
    // on the mfgTopLevelPart.  

    // Note: We need to forget about multi sourcing at the GEOSOurce
    // level.  Hence we assume that there's only one source.



    // now get the offsets: cycletime of the mfgTopLevelPart, and "shipping" transit time
    float * mfgTopLevelCycleTime;
    witGetPartCycleTime(theWitRun, mfgTopLevelPart, &mfgTopLevelCycleTime);
    RWCString geoPlannerDemandPart = mpHelper.geoPlannerDemandPartName(plannerTopLevelPart, geo);
    float usageTime = transitTimeScaled - mfgTopLevelCycleTime[sourceEndPeriod]; 
    portableFree(mfgTopLevelCycleTime);
    int nBomOD;
d9142 1
d9144 1
a9144 1
      witGetOperationNBomEntries(theWitRun, optionDummy, &nBomOD);
d9146 3
a9148 5
      witSetBomEntryEarliestPeriod(theWitRun, optionDummy, nBomOD, sourceBeginPeriod);
      witSetBomEntryLatestPeriod(theWitRun, optionDummy, nBomOD, sourceEndPeriod);
      witSetBomEntryUsageRate(theWitRun, optionDummy, nBomOD, usageRate);
      witSetBomEntryUsageTime(theWitRun, optionDummy, nBomOD, usageTime);
      witSetBomEntryMandEC(theWitRun, optionDummy, nBomOD, WitTRUE);
d9150 7
d9158 5
a9162 52


    // Add BOMs:
    //        BBcat -> ORS (usageRate=featureRatio)
    //        BBcat -> real option part (usageRate=featureRatio * currentRatio)
    // One blip is that the  ratio's are input as
    // vectors, and now must be mapped to scalars.  this is done with
    // multiple arcs -- yukk!

    float currentRatio = featureRatio[firstPeriodWithRatio];
    int ratioBeginPeriod = firstPeriodWithRatio;
    int ratioEndPeriod = nPeriods - 1;
    while (ratioBeginPeriod < nPeriods) {
      for (int t=ratioBeginPeriod; t<nPeriods; t++) {
        if (currentRatio != featureRatio[t]) {
          ratioEndPeriod = t-1;
          assert(ratioEndPeriod >= 0);
          break;
        }
      }

      // found an interval with a constant ratio.

      // Add bom entry:  bbCategory --> optionRatioSupply
      int nBomBbCat;

      witGetOperationNBomEntries(theWitRun, fullBbCategoryPart,&nBomBbCat);
      witAddBomEntry(theWitRun, fullBbCategoryPart, optionRatioSupply);
      witSetBomEntryUsageRate(theWitRun, fullBbCategoryPart, nBomBbCat, currentRatio);
      witSetBomEntryEarliestPeriod(theWitRun, fullBbCategoryPart, nBomBbCat, ratioBeginPeriod);
      witSetBomEntryLatestPeriod(theWitRun, fullBbCategoryPart, nBomBbCat, ratioEndPeriod);

      // add Bom:  bbCat -->  Real Option Part
      nBomBbCat++;
      witAddBomEntry(theWitRun, fullBbCategoryPart, fullOptionPartName);
      witSetBomEntryUsageRate(theWitRun, fullBbCategoryPart, nBomBbCat, currentRatio*usageRate);
      witSetBomEntryEarliestPeriod(theWitRun, fullBbCategoryPart, nBomBbCat, ratioBeginPeriod);
      witSetBomEntryLatestPeriod(theWitRun, fullBbCategoryPart, nBomBbCat, ratioEndPeriod);
      witSetBomEntryUsageTime(theWitRun, fullBbCategoryPart, nBomBbCat, usageTime);
      witSetBomEntryMandEC(theWitRun, fullBbCategoryPart, nBomBbCat, WitTRUE);
 

      // setup to find the next interval
      ratioBeginPeriod = t;
      ratioEndPeriod = nPeriods-1;
      if (ratioBeginPeriod < nPeriods)
        currentRatio = featureRatio[ratioBeginPeriod];

    }


    delete [] optionDummyExecCost;
d9164 2
d9515 1
a9515 1
  // make sure the plannerTopLevel Special Demand Part exists
d9529 1
a9529 6
  // find a BBCAT part/operation that calls the correct option Dummy
  // use the nBom of the topLevel Planner Part
  // bbCategory name is:   STANDALONE:n
  // where n is the current number of BOM entries, NOTE that
  // the optional bbCategory parts will not necessarily be
  // sequential, nor will they start at 0.  But who cares.
a9603 1
  int result;
a9704 1
  int result;
a9817 1
  int result;
a10050 1
  int result;
a10376 1
  int result;
d10635 1
a10635 1
        LgFrTimeVecFloat bigMsupply(nPeriods, 1000000000000.0);
a10761 2
      int jSFP;

d10765 9
a10773 9
	witGetPartDemands(theWitRun, specialFeaturePartName,  &nDemandsSFP, &dListSFP);
	for (int jSFP=0; jSFP<nDemandsSFP; jSFP++) {
	  if ((pp == ppForGpd) && (geo == geoForGpd)) {
	    witSetDemandPriority(theWitRun, specialFeaturePartName, dListSFP[jSFP], priority);
	  }
	  portableFree(dListSFP[jSFP]);
	}
	portableFree(dListSFP);
      }
d10776 9
a10784 9
						  geo, pp, pdf, featurePart)) {
	witGetPartDemands(theWitRun, specialFeaturePartName,  &nDemandsSFP, &dListSFP);
	for (int jSFP=0; jSFP<nDemandsSFP; jSFP++) {
	  if ((pp == ppForGpd) && (geo == geoForGpd)) {
	    witSetDemandPriority(theWitRun, specialFeaturePartName, dListSFP[jSFP], priority);
	  }
	  portableFree(dListSFP[jSFP]);
	}
	portableFree(dListSFP);
d10814 1
a10814 1
  int i,t;
d10849 1
a10849 1
      if (demandVolTVF.min() < 0.001) {
a10894 1
  int p; // the "bops producing the ith-part" index
d10967 1
a10967 1
      for (size_t p=0; p<npBops; p++) {
d11193 1
a11193 1
      for (size_t k=0; k<nInterplantOps; k++) {
d11247 1
a11247 1
      for (size_t k=0; k<nInterplantOps; k++) {
d11435 1
a11435 1
      for (size_t k=0; k<nBinOps; k++) {
d11488 1
a11488 1
      for (size_t k=0; k<nBinOps; k++) {
a11612 8
  // FINISH_ME:
  // need to normalize the usageRates on the BBCAT children
  witGetOperations( theWitRun, &nOperations, &opList );
  for (o=0; o<nOperations; o++) {
    RWCString pp, g, bbCat;
    if (mpHelper.isPartSpecialBbCategory(theWitRun, opList[o], pp, g, bb)) {
      RWCString fullBBCatPart(opList[o]);
      
a11614 5
    }
  }

  
  
a11743 5
  // Cleanup memory
  for ( o=0; o<nOperations; o++) 
    portableFree(opList[o]);
  portableFree( opList );

d11891 1
a11891 1
	supplyVol[t] = (1.0 - supplyVol[t]) * mrpProdVol[t];
a11937 1
    witBoolean exists;
a12053 1
    int candidateOverlap;
a12191 2
    witBoolean exists;

a12256 2
    witBoolean exists;

d12553 1
a12553 1
	       newBlog = (demandVol[t] > shipVol[t]) ? demandVol[t] - shipVol[t] : 0.0;
@


1.1.1.1
log
@Import sce
@
text
@@

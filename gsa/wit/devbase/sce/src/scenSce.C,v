head	1.77;
access;
symbols
	sce_5_01_20080919:1.61
	latest_sce_4_20_20060523:1.49.0.4
	sce_4_20_20060523:1.49
	latest_sce4_20_OSL:1.49.0.2
	sce_4_20_OSL:1.49
	sce_4_20_20051222:1.49
	sce_4_10_30050426:1.45
	sce_4_05_20040511:1.41
	sce_4_00_20040201:1.29
	nextGenBranch:1.23.0.2
	nextGenRoot:1.23
	sce_3_30_20030627:1.23
	EndRw-branch:1.18.0.2
	Root-of-EndRw:1.18
	EndWitRw-branch:1.16.0.4
	Root-of-EndWitRw:1.16
	RwToStl-branch:1.16.0.2
	Root-of-RwToStl:1.16
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.4.0.2
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.2.0.2
	sce_2_31_20010308:1.2
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.77
date	2011.04.06.21.50.12;	author ervolina;	state Exp;
branches;
next	1.76;
deltatype	text;
permissions	644;
commitid	19bc4d9cdf5560a1;
kopt	kv;
filename	@scenSce.C@;

1.76
date	2011.03.25.21.04.03;	author ervolina;	state Exp;
branches;
next	1.75;
deltatype	text;
permissions	644;
commitid	18f84d8d033615fb;
kopt	kv;
filename	@scenSce.C@;

1.75
date	2011.03.23.02.09.30;	author ervolina;	state Exp;
branches;
next	1.74;
deltatype	text;
permissions	644;
commitid	24e04d8955c713a8;
kopt	kv;
filename	@scenSce.C@;

1.74
date	2011.03.22.17.21.28;	author ervolina;	state Exp;
branches;
next	1.73;
deltatype	text;
permissions	644;
commitid	19944d88d9d47ee4;
kopt	kv;
filename	@scenSce.C@;

1.73
date	2011.03.17.17.59.49;	author ervolina;	state Exp;
branches;
next	1.72;
deltatype	text;
permissions	644;
commitid	25bc4d824b6d15ef;
kopt	kv;
filename	@scenSce.C@;

1.72
date	2010.12.15.23.53.24;	author ervolina;	state Exp;
branches;
next	1.71;
deltatype	text;

1.71
date	2010.04.15.17.46.41;	author ervolina;	state Exp;
branches;
next	1.70;
deltatype	text;

1.70
date	2010.04.13.19.50.31;	author ervolina;	state Exp;
branches;
next	1.69;
deltatype	text;

1.69
date	2010.04.12.21.27.03;	author ervolina;	state Exp;
branches;
next	1.68;
deltatype	text;

1.68
date	2010.04.07.16.18.28;	author ervolina;	state Exp;
branches;
next	1.67;
deltatype	text;

1.67
date	2010.03.26.19.48.25;	author ervolina;	state Exp;
branches;
next	1.66;
deltatype	text;

1.66
date	2010.03.16.17.56.23;	author ervolina;	state Exp;
branches;
next	1.65;
deltatype	text;

1.65
date	2010.03.13.18.53.06;	author ervolina;	state Exp;
branches;
next	1.64;
deltatype	text;

1.64
date	2009.12.08.13.58.36;	author ervolina;	state Exp;
branches;
next	1.63;
deltatype	text;

1.63
date	2009.09.09.15.41.57;	author ervolina;	state Exp;
branches;
next	1.62;
deltatype	text;

1.62
date	2009.01.28.14.22.31;	author ervolina;	state Exp;
branches;
next	1.61;
deltatype	text;

1.61
date	2008.06.23.19.07.12;	author ervolina;	state Exp;
branches;
next	1.60;
deltatype	text;

1.60
date	2008.04.24.14.04.43;	author ervolina;	state Exp;
branches;
next	1.59;
deltatype	text;

1.59
date	2008.03.20.14.52.49;	author ervolina;	state Exp;
branches;
next	1.58;
deltatype	text;

1.58
date	2008.03.14.20.19.40;	author ervolina;	state Exp;
branches;
next	1.57;
deltatype	text;

1.57
date	2007.05.29.20.03.33;	author ervolina;	state Exp;
branches;
next	1.56;
deltatype	text;

1.56
date	2007.03.21.18.03.29;	author ervolina;	state Exp;
branches;
next	1.55;
deltatype	text;

1.55
date	2006.08.17.13.12.45;	author ervolina;	state Exp;
branches;
next	1.54;
deltatype	text;

1.54
date	2006.08.11.17.39.50;	author ervolina;	state Exp;
branches;
next	1.53;
deltatype	text;

1.53
date	2006.08.11.16.43.18;	author ervolina;	state Exp;
branches;
next	1.52;
deltatype	text;

1.52
date	2006.08.11.15.55.39;	author ervolina;	state Exp;
branches;
next	1.51;
deltatype	text;

1.51
date	2006.08.09.16.32.18;	author ervolina;	state Exp;
branches;
next	1.50;
deltatype	text;

1.50
date	2006.06.26.15.23.31;	author ervolina;	state Exp;
branches;
next	1.49;
deltatype	text;

1.49
date	2005.12.01.16.44.22;	author ervolina;	state Exp;
branches;
next	1.48;
deltatype	text;

1.48
date	2005.11.09.18.32.47;	author ervolina;	state Exp;
branches;
next	1.47;
deltatype	text;

1.47
date	2005.11.02.18.40.01;	author ervolina;	state Exp;
branches;
next	1.46;
deltatype	text;

1.46
date	2005.08.10.22.44.41;	author ervolina;	state Exp;
branches;
next	1.45;
deltatype	text;

1.45
date	2005.08.10.22.09.12;	author ervolina;	state Exp;
branches;
next	1.44;
deltatype	text;

1.44
date	2005.05.05.20.22.12;	author ervolina;	state Exp;
branches;
next	1.43;
deltatype	text;

1.43
date	2005.02.15.20.45.01;	author ervolina;	state Exp;
branches;
next	1.42;
deltatype	text;

1.42
date	2004.10.08.13.03.44;	author ervolina;	state Exp;
branches;
next	1.41;
deltatype	text;

1.41
date	2004.05.12.01.26.43;	author ervolina;	state Exp;
branches;
next	1.40;
deltatype	text;

1.40
date	2004.05.11.23.59.18;	author ervolina;	state Exp;
branches;
next	1.39;
deltatype	text;

1.39
date	2004.05.06.17.43.06;	author ervolina;	state Exp;
branches;
next	1.38;
deltatype	text;

1.38
date	2004.05.04.23.10.19;	author ervolina;	state Exp;
branches;
next	1.37;
deltatype	text;

1.37
date	2004.04.12.20.47.35;	author ervolina;	state Exp;
branches;
next	1.36;
deltatype	text;

1.36
date	2004.04.07.21.48.42;	author ervolina;	state Exp;
branches;
next	1.35;
deltatype	text;

1.35
date	2004.04.07.19.58.33;	author ervolina;	state Exp;
branches;
next	1.34;
deltatype	text;

1.34
date	2004.04.05.22.23.25;	author ervolina;	state Exp;
branches;
next	1.33;
deltatype	text;

1.33
date	2004.03.04.23.45.24;	author ervolina;	state Exp;
branches;
next	1.32;
deltatype	text;

1.32
date	2004.03.04.14.19.29;	author ervolina;	state Exp;
branches;
next	1.31;
deltatype	text;

1.31
date	2004.03.02.04.22.51;	author ervolina;	state Exp;
branches;
next	1.30;
deltatype	text;

1.30
date	2004.02.06.21.53.47;	author ervolina;	state Exp;
branches;
next	1.29;
deltatype	text;

1.29
date	2004.02.02.03.34.48;	author ervolina;	state Exp;
branches;
next	1.28;
deltatype	text;

1.28
date	2004.01.31.03.58.42;	author ervolina;	state Exp;
branches;
next	1.27;
deltatype	text;

1.27
date	2004.01.29.05.08.05;	author ervolina;	state Exp;
branches;
next	1.26;
deltatype	text;

1.26
date	2004.01.23.02.59.16;	author ervolina;	state Exp;
branches;
next	1.25;
deltatype	text;

1.25
date	2004.01.22.02.47.49;	author ervolina;	state Exp;
branches;
next	1.24;
deltatype	text;

1.24
date	2004.01.10.17.56.11;	author ervolina;	state Exp;
branches;
next	1.23;
deltatype	text;

1.23
date	2003.07.03.15.50.41;	author ervolina;	state Exp;
branches;
next	1.22;
deltatype	text;

1.22
date	2003.06.26.23.09.38;	author ervolina;	state Exp;
branches;
next	1.21;
deltatype	text;

1.21
date	2003.01.31.22.59.14;	author ervolina;	state Exp;
branches;
next	1.20;
deltatype	text;

1.20
date	2003.01.21.17.41.14;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;

1.19
date	2003.01.15.19.36.58;	author rwToStl;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2003.01.06.22.12.10;	author ervolina;	state Exp;
branches
	1.18.2.1;
next	1.17;
deltatype	text;

1.17
date	2002.11.26.14.25.33;	author fasano;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2002.09.06.13.33.08;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2002.08.08.17.37.44;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2002.07.02.20.20.07;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2002.03.29.14.18.13;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2002.03.28.21.49.43;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2001.12.21.20.10.33;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2001.12.18.17.01.51;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2001.12.18.16.58.12;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2001.10.18.23.18.09;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2001.10.17.22.04.42;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2001.10.11.19.59.19;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2001.09.24.16.38.14;	author ervolina;	state Exp;
branches;
next	1.4;
deltatype	text;

1.4
date	2001.06.01.16.52.06;	author ervolina;	state Exp;
branches;
next	1.3;
deltatype	text;

1.3
date	2001.03.12.15.07.30;	author ervolina;	state Exp;
branches;
next	1.2;
deltatype	text;

1.2
date	2000.11.14.17.19.35;	author ervolina;	state Exp;
branches
	1.2.2.1;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches
	1.1.1.1.2.1;
next	;
deltatype	text;

1.1.1.1.2.1
date	2001.03.08.15.36.47;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.2.2.1
date	2001.03.12.16.36.18;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.18.2.1
date	2003.01.08.17.43.18;	author rwToStl;	state Exp;
branches;
next	1.18.2.2;
deltatype	text;

1.18.2.2
date	2003.01.09.13.14.30;	author rwToStl;	state Exp;
branches;
next	1.18.2.3;
deltatype	text;

1.18.2.3
date	2003.01.14.19.06.02;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.77
log
@fixed formatting error in printing iPegCrit
@
text
@
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.

#include <stdlib.h>

#include <mcl/src/mcl.h>


#include <scenario/src/calendar.h>
#include <scenario/src/dif.h>
#include <scenario/src/difPWcmr.h>
//#include <scenario/src/difPWatp.h>
#include <scenario/src/scenDrct.h>
#include <scenario/src/schFCMRP.h>
#include <scenario/src/schdDeSt.h>
#include <scenario/src/timeVecs.h>

#include <scenario/src/part.h>
#include <scenario/src/partSchd.h>
#include <scenario/src/pairComp.h>
#include <sce/src/scePegging.h>



#include <sce/src/ipSce.h>
#include <sce/src/dmApData.h>
#include <sce/src/bopAData.h>
#include <sce/src/appData.h> 
#include <sce/src/exploders.h>
#include <sce/src/scBdSce.h>
#include <sce/src/scenSce.h>
#include <sce/src/sceFssMg.h>
#include <sce/src/hEngMgr.h>
#include <sce/src/oEngMgr.h>
#include <sce/src/aEngMgr.h>
#include <sce/src/sceBop.h>



// forward declarations
class LgFrSetOfParts; 
class LgFrSetOfDemands;

#define SCENARIOSCE_FLT_EPS  0.00001
#define DEMAND_PEGGING
// #define SHADOW_PRICE_DEBUG
// #define CRIT_PEG_DEBUG




void 
LgFrScenarioForSce::analyzeRunAndPrintResults()
{

    int nPeriods;                         //  Number of periods in model  
    int nParts;                           //  Number of parts in model     
    char ** partList;                     //  List of parts in model       
    int i;                                //  Loop index                  
    int nOperations;
    char ** opList;                     //  List of parts in model       


    WitRun * const theWitRun = lastProblemSolved().witRun();
    LgFrCalendar & theCal = calendar();
    LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
    LgFrSceCritList & theCritList = sceCritList();
      
    witGetParts( theWitRun, &nParts, &partList );
    witGetOperations( theWitRun, &nOperations, &opList );
    nPeriods = theCal.nPeriods();

    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();

    std::string siteCustomization = setOfParameters.getString("siteCustomization");
    bool useMultiAttributeDemand = setOfParameters.getBool("useMultiAttributeDemand");


    // VERY IMPORTANT!!  This step sets App data for Interplant
    // operations in the primary witRun!!  It must be done before any interplant
    // execVols can be accessed (in either mrp or implosion witRuns). The app data
    // is actually store in the priamry witRun.  At this point the appdata's 
    // should ahve been created during the printExplosion results and here we are
    // merely going to set the implosion values (which were initialized to zero)
    if (siteCustomization != "skipTheCrapola") {
      setInterplantOperationsAppDataForImplosion(theWitRun,
						 nPeriods,
						 nOperations,
						 opList);
    }


    // Geo Source Debug File: optional file
    if (setOfParameters.getBool("printGeoSourceDebugFile"))  {    
      std::string geoSourceDebugFileName =
	setOfParameters.getString("geoSourceDebugFileName");
      printGeoSourceDebugFile(theWitRun, nPeriods, nParts, partList,
			      geoSourceDebugFileName, theCal, mpHelper);
    }
    
    
    
    // Formatted Supply Response Report File: optional file
    if (setOfParameters.getBool("printFormattedSupplyReportFile"))  {    
      std::string formattedSupplyReportFileName =
	setOfParameters.getString("formattedSupplyReportFileName");
      printHumanReadableSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
				       formattedSupplyReportFileName,
				       theCal, mpHelper);
    }

    // Supply Response  File: 
    // 6.1: Supply Response legacy (sce 5 and earlier) prints two commit files, one for TIMP/GPD 
    //      and the oter fir INDP demands.   In SCE 6.1, and specifically with, multiAttributeDemand,
    //      a single supply response file is printed
    if (setOfParameters.getBool("useMultiAttributeDemand"))  {
      int tinpIndpOrBoth = 3;
      
      if (setOfParameters.getBool("printSupplyResponseFile"))  {
	std::string supplyResponseFileName = setOfParameters.getString("supplyResponseFileName");
	printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList, tinpIndpOrBoth,
			    supplyResponseFileName, theCal, mpHelper);
      }
    }
    
    else    {
      int tinpIndpOrBoth = 1;
      if (setOfParameters.getBool("printSupplyResponseFile"))  {
	std::string supplyResponseFileName = setOfParameters.getString("supplyResponseFileName");
	printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList, tinpIndpOrBoth,
			    supplyResponseFileName, theCal, mpHelper);
      }

      tinpIndpOrBoth = 2;      
      // Independent Supply Response  File
      // 6.1 temporary function ... need more flexibility to support legacy
      std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
      if (setOfParameters.getBool("printIndpSupplyResponseFile") && ! independentDemandFile.empty())   {
	std::string indepSupplyResponseFileName =	setOfParameters.getString("indepSupplyResponseFileName");
	printIndepSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
				 indepSupplyResponseFileName, theCal, mpHelper);
      
      }
    }
      
      
    // Backlog Response File
    if (setOfParameters.getBool("printBacklogResponseFile") && (siteCustomization != "skipTheCrapola")) {  
      std::string backlogResponseFileName = setOfParameters.getString("backlogResponseFileName");
      printBacklogSchedule(theWitRun, nPeriods, nParts, partList,
			   backlogResponseFileName, theCal, mpHelper);
    }

    

    // Critical List
    if (setOfParameters.getBool("printCriticalListFile"))  {    
      std::string criticalListFileName = setOfParameters.getString("criticalListFileName");
      std::string engine = setOfParameters.getString( "engine");
      this->printCriticalList(theWitRun, engine, nPeriods, nParts, partList,
			      criticalListFileName, theCal, mpHelper, theCritList);
    }

    // Pegged Critical List
    if (useMultiAttributeDemand)  {
      // SCE 6.1: for multi-attribute demand, we must combine both pegged critLists into one file
      if (setOfParameters.getBool("printPeggedCritListFile"))  {    
	std::string peggedCriticalListFileName  = setOfParameters.getString("peggedCritListFileName");
	std::string engine = setOfParameters.getString( "engine");
	this->printPeggedCriticalList(theWitRun, engine, peggedCriticalListFileName, theCal, mpHelper);
      }
    }
    // else, for non-multi-attribute, we print the two pegged critLists as separate files (this is SCE 5)
    else {
      if (setOfParameters.getBool("printPeggedCritListFile"))  {    
	std::string peggedCriticalListFileName  = setOfParameters.getString("peggedCritListFileName");
	std::string iPeggedCriticalListFileName =	setOfParameters.getString("iPeggedCritListFileName");
	std::string engine = setOfParameters.getString( "engine");
	this->printPeggedCriticalList(theWitRun, engine, peggedCriticalListFileName, iPeggedCriticalListFileName, theCal, mpHelper);
      }
    }


      // Build Schedule  File
    if (setOfParameters.getBool("printBuildSchedFile") && (siteCustomization != "skipTheCrapola")) {
      std::string buildSchedFileName =
	setOfParameters.getString("buildSchedFileName");
      printBuildSchedule(theWitRun, nPeriods, nParts, partList, buildSchedFileName, theCal, mpHelper);
    }


    // Interplant Order File
    if (setOfParameters.getBool("printInterplantOrdersFile") && (siteCustomization != "skipTheCrapola")) {
      std::string interPlantFile = setOfParameters.getString("interPlantFile");
      if (! interPlantFile.empty())   {
	std::string interplantOrdersFileName = setOfParameters.getString("interplantOrdersFileName");
	bool isThisMrp = false;
	printInterplantVolumesFile(theWitRun, nPeriods, 
				   nOperations, opList,
				   isThisMrp,
				   interplantOrdersFileName,
				   mpHelper);
      }
    }


    // Print Alternate DB File
    bool printAltDbFile = setOfParameters.getBool("printAltDbFile");
    if (printAltDbFile )   {
      std::string altDbFileName = setOfParameters.getString("altDbFileName");
      bool isThisMrp = false;
      printAlternateDbFile(theWitRun, nPeriods,
		     nOperations, opList,
		     isThisMrp,
		     altDbFileName,
		     mpHelper);
    }

    // Print Shadow Price File: optional file (3.11)
    // prints only when asked for AND if engine="optimization"
    bool printShadowPricesFile = setOfParameters.getBool("printShadowPricesFile");
    std::string engine = this->getEngine();
    if ((! engine.compare("optimization")) && printShadowPricesFile) {
      std::string shadowPricesFileName = setOfParameters.getString("shadowPricesFileName");
      printShadowPrices(theWitRun, nPeriods, 
			nParts, partList,
			shadowPricesFileName,
			mpHelper);
    }
    



    // Operation Orders File: mandatory file
    // Prints execVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
    if (setOfParameters.getBool("printOperationOrdersFile") && (siteCustomization != "skipTheCrapola")) {
      std::string operationOrdersFileName =
	setOfParameters.getString("operationOrdersFileName");
      printOperationOrdersFile(theWitRun, nPeriods,
				    operationOrdersFileName,
				    mpHelper);
    }




    // Capacity Usage Volume File: optional file
    if (setOfParameters.getBool("printCapacityUsageFile"))   {
      bool isItMrp = false;
      printCapUsageVolume(theWitRun,isItMrp); 
    }
    

    // Sub DB File
    // (prints only when there is substitute  input data)
    std::string subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.empty() && setOfParameters.getBool("printSubDbFile"))   {
      bool parentMustBeUserDefinedOperation = false;
      bool engineMustBeImplode = true;
      std::string subDbFileName = setOfParameters.getString("subDbFileName");
      printSubDbDumpFile(theWitRun, 
			 parentMustBeUserDefinedOperation,
			 engineMustBeImplode,
			 nPeriods, nOperations, opList,
			 subDbFileName,
			 mpHelper);
    }


    // Substitute Usage Volume File
    // (prints only when there is substitute  input data)
    if (setOfParameters.getBool("printSubUsageFile") && ! subBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = false;
      bool engineMustBeImplode = true;
      std::string subUsageFileName = setOfParameters.getString("subUsageFileName");
      printSubstituteUsageVolume(theWitRun, parentMustBeUserDefinedOperation,
				 engineMustBeImplode,
				 nPeriods, nOperations, opList, subUsageFileName,
				 mpHelper);
    }

    // Operation Substitute Usage Volume File: 
    std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
    if (setOfParameters.getBool("printOpSubUsageFile") && ! opSubBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = true;
      bool engineMustBeImplode = true;
      std::string opSubUsageFileName = setOfParameters.getString("opSubUsageFileName");
      printSubstituteUsageVolume(theWitRun, 
				 parentMustBeUserDefinedOperation,
				 engineMustBeImplode,
				 nPeriods, nOperations, opList,
				 opSubUsageFileName,
				 mpHelper);
    }



    
    // -----------------------------------------
    // ----- Print Feature Attach Volumes ---------
    // -----------------------------------------    
    std::string featureFileOutputFormat =
      setOfParameters.getString("featureFileOutputFormat");

    // see what format the user wants his feature outputs as
    int printDataAsPercentage = 0;
    if (featureFileOutputFormat == "percentage")
      printDataAsPercentage = 1;
    
    
    // Standalone Feature Attach Volume File
    // (prints only when there is optional feature  input data)
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      std::string optionalFeatRatioFileName = setOfParameters.getString("optionalFeatRatioFileName");
      printStandAloneFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
					   optionalFeatRatioFileName,
					   theCal, mpHelper, printDataAsPercentage);
    }

    // Selective Set Feature Attach Volume File
    std::string topLevelToBBratioFile = setOfParameters.getString("topLevelToBBratioFile");
    if (! topLevelToBBratioFile.empty()) {
      std::string selFeatBBratioFileName = setOfParameters.getString("selFeatBBratioFileName");

      if (engine == "optimization")
	printFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
				   selFeatBBratioFileName,
				   theCal, mpHelper, printDataAsPercentage);
      else
	printFeatureAnalysisReportViaProportionalRoute(theWitRun, nPeriods, nOperations, opList,
						       selFeatBBratioFileName,
						       theCal, mpHelper, printDataAsPercentage);
    }


    // Part Database Dump File
    if (setOfParameters.getBool("printPartDBFile"))  {
      std::string partDBFileName = setOfParameters.getString("partDBFileName");
      printPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				partList, partDBFileName);
    }

    // Capacity Database Dump File: optional file    
    if (setOfParameters.getBool("printCapacityDBFile"))  {
      std::string capacityDBFileName = setOfParameters.getString("capacityDBFileName");
      printCapacityDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				    partList, capacityDBFileName);
    }


    // Operation Database Dump File: optional file
    if (setOfParameters.getBool("printOperationDBFile"))  {
      std::string operationDBFileName =	setOfParameters.getString("operationDBFileName");
      printOperationDataBaseDumpFile(theWitRun, mpHelper, nPeriods, 
				     operationDBFileName);
    }

    // Operation ExecVol  Dump File: optional file
    if (setOfParameters.getBool("printOperationExecFile"))  {
      std::string operationExecFileName = setOfParameters.getString("operationExecFileName");
      printOperationExecDumpFile(theWitRun, mpHelper, nPeriods, operationExecFileName);
    }

    
    // Debug Dump File (internal SCE parts)
    if (setOfParameters.getBool("printDebugFile"))  {
      std::string debugFileName = setOfParameters.getString("debugFileName");
      printDummyPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				     partList, debugFileName);
    }
    
    // Problem Statistics Summary File
    if (setOfParameters.getBool("printProblemStatsFile"))  {
      std::string problemStatisticsFileName = setOfParameters.getString("problemStatisticsFileName");
      printOverallProblemStatistics(theWitRun, mpHelper, nPeriods, nParts, partList,
				    problemStatisticsFileName);
    }


    // Objective Summary Report
    if (setOfParameters.getBool("printObjectiveSummaryFile"))  {
      std::string objectiveSummaryFileName = setOfParameters.getString("objectiveSummaryFileName");
      printOverallOptimizationValues(theWitRun, nPeriods, nParts, partList, engine,
				     objectiveSummaryFileName);
    }
    
    // Cleanup memory
    for ( i=0; i<nParts; i++) 
      witFree(partList[i]);
    witFree( partList );
    
    int o = 0; // Pulled out of the for below by RW2STL
    for (o=0; o<nOperations; o++) 
      witFree(opList[o]);
    witFree( opList );

}






// SCE 6.1
int
LgFrScenarioForSce::printAPegFile(WitRun * const theWitRun, 
				  LgFrMultiPlantHelper & mpHelper,
				  LgFrCalendar & theCal,
				  int pegType,
				  int tinpIndpOrBoth,
				  std::string & pegFileName,
				  int nParts,
				  char ** partList,
				  int nPeriods)
{

  std::ofstream dPIPFile;
  dPIPFile.open(pegFileName.c_str(), std::ofstream::out);
  if (dPIPFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << pegFileName << pegFileName);
  }

  int goodRec = 0;
  int printIfZero = 0;
  
  char * fullWitDemandedPartName;
  char * demandName;
  int isDemandedPartGPD;

  std::string pn1,customerPdf,pn2,supplierPdf;
  
  // Loop over parts to get demands
  int i = 0;
  for(i=0; i<nParts; i++){
    fullWitDemandedPartName = partList[i];
    std::string plannerPart, geo;
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitDemandedPartName, plannerPart, geo)) 
      isDemandedPartGPD = TRUE;
    else 
      isDemandedPartGPD = FALSE;


    // If you only want INDP type demands, and this one is a GPD, then skip
    if (isDemandedPartGPD == TRUE && tinpIndpOrBoth == 2 )  {
      continue;
    }

    // If you only want GPD type demands, and this one is NOT a GPD, then skip
    if (isDemandedPartGPD == FALSE && tinpIndpOrBoth == 1)  {
      continue;
    }

    
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, fullWitDemandedPartName, &nDemands, &dList);
    
    // For GPD demands, can assert there's at most one demand. (get rid of this at some point)
    if (isDemandedPartGPD)   
      assert(nDemands < 2);
    
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];
      
      // get the demandAppData, if none exists, then skip it
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
      witGetDemandAppData( theWitRun, fullWitDemandedPartName, demandName, (void **) &demandAppDataPtr );
      if ( demandAppDataPtr == 0 ) {
	witFree (dList[j]);
	continue;
      }
      
      // Get const references to the correct PIP  schedules stored in app data
      const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSched(pegType);
      
      // Loop over each consumed part
      int nConsumedParts = PIPSched.size();
      int cp = 0; 
      for ( cp=0; cp<nConsumedParts; cp++ ) {
	// get part
	const LgFrPart & consumedPart = PIPSched.part(cp);
	
	if (pegType != PEG_TYPE_INTERPLANT)  {
	  // for all other pegTypes, we only report for normal pegged-to parts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	}
	else {
	  // for pegType=interplant, report only for interplant operations

	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, consumedPart.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	}
	
	LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	
	// for non-interplant  peg types do ...
	if (pegType != PEG_TYPE_INTERPLANT) {
	  if (isDemandedPartGPD)   {
	    flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					   plannerPart, geo, mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					   PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	    goodRec++;
	  }
	  else   {
	    flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					    mpHelper.partname(fullWitDemandedPartName), mpHelper.pdf(fullWitDemandedPartName), demandName,
					    mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					    PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	    goodRec++;
	  }
	}
	// for interplant  peg types do ...
	else {
	  if (isDemandedPartGPD)   {
	    flatFileMgr_.writeGpdInterplantPegRecord(theCal, mpHelper, 
						     plannerPart, geo, 
						     pn1, customerPdf, pn2, supplierPdf,
						     PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	    goodRec++;
	  }
	  else   {
	    flatFileMgr_.writeIndpInterplantPegRecord(theCal, mpHelper, 
						      mpHelper.partname(fullWitDemandedPartName), mpHelper.pdf(fullWitDemandedPartName), demandName,
						      pn1, customerPdf, pn2, supplierPdf,
						      PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	    goodRec++;
	  }
	}	
      }
      
      witFree(dList[j]);
    }
    witFree(dList);
  }
  
  dPIPFile.close();
  return goodRec;
}



// SCE 6 version
//   - SCE 6 combines the INDP and TINP pegging files into a single one
//  -     - this is possible because of MultiAttributeDemand
//     SCE 6 allows for dated output records
//     this function must support SCE 5 back compatibility
void
LgFrScenarioForSce::printPIPData(WitRun * const theWitRun, int isItMrp)
{


  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrCalendar & theCal = calendar();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();


  int nonZeroOnly = 0;
  int alwaysPrint = 1;
  

  bool useMultiAttributeDemand = setOfParameters.getBool("useMultiAttributeDemand");
  int tinpIndpOrBoth;

  
  bool printSupplyPegFile = setOfParameters.getBool("printSupplyPegFile");
  std::string supplyPegFileName = setOfParameters.getString("supplyPegFileName");
  bool printIndpSupplyPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpSupplyPegFile");
  std::string indpSupplyPegFileName = setOfParameters.getString("indpSupplyPegFileName");


  bool printDemandConsPegFile = setOfParameters.getBool("printDemandConsPegFile");
  std::string demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
  bool printIndpDemandConsPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpDemandConsPegFile");
  std::string indpDemandConsPegFileName = setOfParameters.getString("indpDemandConsPegFileName");
  
  bool printInterplantPegFile = setOfParameters.getBool("printInterplantPegFile");
  std::string interplantPegFileName = setOfParameters.getString("interplantPegFileName");
  bool printIndpInterplantPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpInterplantPegFile");
  std::string indpInterplantPegFileName = setOfParameters.getString("indpInterplantPegFileName");

  //  bool printExecVolPegFile = setOfParameters.getBool("printExecVolPegFile");
  //  std::string execVolPegFileName = setOfParameters.getString("execVolPegFileName");
  //  bool printIndpExecVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpExecVolPegFile");
  //  std::string indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");

  bool printProdVolPegFile = setOfParameters.getBool("printProdVolPegFile");
  std::string prodVolPegFileName = setOfParameters.getString("prodVolPegFileName");
  bool printIndpProdVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpProdVolPegFile");
  std::string indpProdVolPegFileName = setOfParameters.getString("indpProdVolPegFileName");

  bool printPfProdVolPegFile = setOfParameters.getBool("printPfProdVolPegFile");
  std::string pfProdVolPegFileName = setOfParameters.getString("pfProdVolPegFileName");
  bool printIndpPfProdVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpPfProdVolPegFile");
  std::string indpPfProdVolPegFileName = setOfParameters.getString("indpPfProdVolPegFileName");

  bool printSideVolPegFile = setOfParameters.getBool("printSideVolPegFile");
  std::string sideVolPegFileName = setOfParameters.getString("sideVolPegFileName");
  bool printIndpSideVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printIndpSideVolPegFile");
  std::string indpSideVolPegFileName = setOfParameters.getString("indpSideVolPegFileName");


  if (isItMrp) {
    printSupplyPegFile = setOfParameters.getBool("printMrpSupplyPegFile");
    supplyPegFileName = setOfParameters.getString("mrpSupplyPegFileName");
    printIndpSupplyPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpSupplyPegFile");
    indpSupplyPegFileName = setOfParameters.getString("mrpIndpSupplyPegFileName");

    printDemandConsPegFile = setOfParameters.getBool("printMrpDemandConsPegFile");
    demandConsPegFileName = setOfParameters.getString("mrpDemandConsPegFileName");
    printIndpDemandConsPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpDemandConsPegFile");
    indpDemandConsPegFileName = setOfParameters.getString("mrpIndpDemandConsPegFileName");

    printInterplantPegFile = setOfParameters.getBool("printMrpInterplantPegFile");
    interplantPegFileName = setOfParameters.getString("mrpInterplantPegFileName");    
    printIndpInterplantPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpInterplantPegFile");
    indpInterplantPegFileName = setOfParameters.getString("mrpIndpInterplantPegFileName");


    //    printExecVolPegFile = setOfParameters.getBool("printMrpExecVolPegFile");
    //    execVolPegFileName = setOfParameters.getString("mrpExecVolPegFileName");    
    //    printIndpExecVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpExecVolPegFile");
    //    indpExecVolPegFileName = setOfParameters.getString("mrpIndpExecVolPegFileName");


    printProdVolPegFile = setOfParameters.getBool("printMrpProdVolPegFile");
    prodVolPegFileName = setOfParameters.getString("mrpProdVolPegFileName");
    printIndpProdVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpProdVolPegFile");
    indpProdVolPegFileName = setOfParameters.getString("mrpIndpProdVolPegFileName");


    printPfProdVolPegFile = setOfParameters.getBool("printMrpPfProdVolPegFile");
    pfProdVolPegFileName = setOfParameters.getString("mrpPfProdVolPegFileName");
    printIndpPfProdVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpPfProdVolPegFile");
    indpPfProdVolPegFileName = setOfParameters.getString("mrpIndpPfProdVolPegFileName");


    printSideVolPegFile = setOfParameters.getBool("printMrpSideVolPegFile");
    sideVolPegFileName = setOfParameters.getString("mrpSideVolPegFileName");
    printIndpSideVolPegFile = (1 - useMultiAttributeDemand) * setOfParameters.getBool("printMrpIndpSideVolPegFile");
    indpSideVolPegFileName = setOfParameters.getString("mrpIndpSideVolPegFileName");

  }

  std::cout << "Writing Pegging information..." << std::endl;    

  int goodRec = 0;  
  int nPeriods;  
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  // if useMultiAttributeDemand is true then we print BOTH tinp and indp demands in the same file, 
  if (useMultiAttributeDemand)    {
    tinpIndpOrBoth = 3;
    if (printSupplyPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SUPPLY, tinpIndpOrBoth, supplyPegFileName, nParts, partList, nPeriods);
    if (printDemandConsPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_CONSVOL, tinpIndpOrBoth, demandConsPegFileName, nParts, partList, nPeriods);
    if (printPfProdVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_PRODVOL, tinpIndpOrBoth, pfProdVolPegFileName, nParts, partList, nPeriods);
    if (printSideVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SIDEVOL, tinpIndpOrBoth, sideVolPegFileName, nParts, partList, nPeriods);
    if (printProdVolPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_EXECVOL, tinpIndpOrBoth, prodVolPegFileName, nParts, partList, nPeriods);
    if (printInterplantPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, tinpIndpOrBoth, interplantPegFileName, nParts, partList, nPeriods);
  }

  // otherwise, we need to print two files for each Peg attribute, one for TINP, the other for INDP
  else {
    // first write the TINP files
    tinpIndpOrBoth = 1;
  
    if (printSupplyPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SUPPLY, tinpIndpOrBoth, supplyPegFileName, nParts, partList, nPeriods);
    if (printDemandConsPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_CONSVOL, tinpIndpOrBoth, demandConsPegFileName, nParts, partList, nPeriods);
    if (printPfProdVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_PRODVOL, tinpIndpOrBoth, pfProdVolPegFileName, nParts, partList, nPeriods);
    if (printSideVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SIDEVOL, tinpIndpOrBoth, sideVolPegFileName, nParts, partList, nPeriods);
    if (printProdVolPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_EXECVOL, tinpIndpOrBoth, prodVolPegFileName, nParts, partList, nPeriods);
    if (printInterplantPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, tinpIndpOrBoth, interplantPegFileName, nParts, partList, nPeriods);
    
    // second write the INDP files
    tinpIndpOrBoth = 2;
    if (printIndpSupplyPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SUPPLY, tinpIndpOrBoth, indpSupplyPegFileName, nParts, partList, nPeriods);
    if (printIndpDemandConsPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_CONSVOL, tinpIndpOrBoth, indpDemandConsPegFileName, nParts, partList, nPeriods);
    if (printIndpPfProdVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_PRODVOL, tinpIndpOrBoth, indpPfProdVolPegFileName, nParts, partList, nPeriods);
    if (printIndpSideVolPegFile) 
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SIDEVOL, tinpIndpOrBoth, indpSideVolPegFileName, nParts, partList, nPeriods);
    if (printIndpProdVolPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_EXECVOL, tinpIndpOrBoth, indpProdVolPegFileName, nParts, partList, nPeriods);
    if (printIndpInterplantPegFile)  
      goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, tinpIndpOrBoth, indpInterplantPegFileName, nParts, partList, nPeriods);
  }
  
  int i = 0; 
  for(i=0; i<nParts; i++) {
    witFree(partList[i]);
  }
  witFree(partList);
}    



// ---------------------------------------------------------------------------
LgFrSceBaseExploder *
LgFrScenarioForSce::createAppropriateSceExploder(
						 LgFrScenarioForSceSmartPointer scenSceSP)
{
  WitRun * const theWitRun        = lastProblemSolved().witRun();
  
  // FINISH_ME: implement new parameter scheme and then modify this 
  std::string engine = setOfParameters().getString("engine");
  bool useFullExplodeUtility = setOfParameters().getBool("useFullExplodeUtility");
  bool fssFlag = setOfParameters().getBool("fssFlag");
  bool useSmartExplodeUtility = setOfParameters().getBool("useSmartExplodeUtility");
  bool usePrioritizedExplodeUtility = setOfParameters().getBool("usePrioritizedExplodeUtility");
  
  LgFrSceBaseExploder             * theConcreteExploder;
  LgFrSceFullExploderDecorator    * theFullDecorator;
  LgFrSceSmartExploderDecorator   * theSmartDecorator;
  LgFrSceFssableExploderDecorator * theFssDecorator;
  LgFrSceBaseExploder             * theCurrentExploder;  
   

  // First create the concrete Exploder
  // Its going to be a 
  if ( (useFullExplodeUtility)
       || (useSmartExplodeUtility)
       || (usePrioritizedExplodeUtility)
       || (fssFlag) ) {
    theConcreteExploder = new LgFrSceExploder(lastProblemSolved().witRun(),
					      &(multiPlantHelper()),
					      &(setOfParameters()));
    theCurrentExploder = theConcreteExploder;
  }
  else {
    theConcreteExploder = new LgFrSceBaseExploder(lastProblemSolved().witRun(),
						  &(multiPlantHelper()),
						  &(setOfParameters()));
    return theConcreteExploder;
  }
  
  
  // now see if you want a SMART decorator
  if (useSmartExplodeUtility || usePrioritizedExplodeUtility) {

    theSmartDecorator = new LgFrSceSmartExploderDecorator(theCurrentExploder,
							  scenSceSP,
							  &(multiPlantHelper()));
    theCurrentExploder = theSmartDecorator;
  }
  
  // now see if you want a FULL decorator
  if (useFullExplodeUtility) {
    if (! usePrioritizedExplodeUtility) {
      theFullDecorator = new LgFrSceFullExploderDecorator(theCurrentExploder);
      theCurrentExploder = theFullDecorator;
    }
  }
  // now see if you want a FSS decorator
  if (fssFlag) {
    theFssDecorator = new LgFrSceFssableExploderDecorator(theCurrentExploder);
    theCurrentExploder = theFssDecorator;
  }
  
  return theCurrentExploder;
  
}

// ---------------------------------------------------------------------------
void 
LgFrScenarioForSce::setHeuristicSearchIncrement(WitRun * const theWitRun,   
						std::string greedySearchIncrementMethod, 
						float anIncValue) 
{
  int nParts;
  int nDemands;
  char ** partList;
  char ** demandList;
  int nPeriods;
  
  float searchInc;
  
  witGetNPeriods(theWitRun, &nPeriods);
  witGetParts(theWitRun, &nParts, &partList);
  witBoolean isItAbosluteInc =  (sce::compareStringsCaseIns(greedySearchIncrementMethod, "autoScale")) ? WitTRUE : WitFALSE;
  
  //  std::cout << "HeuristicSearchIncrement: isItAbosluteInc=" << isItAbosluteInc << std::endl;

  int i = 0; 
  for (i=0; i<nParts; i++ ) {
    
    // get demands on the part. 
    witGetPartDemands(theWitRun, partList[i], &nDemands, &demandList);
    
    int j = 0; 
    for (j=0; j<nDemands; j++) {
      if (isItAbosluteInc) {
	witSetDemandSearchInc(theWitRun, partList[i], demandList[j], anIncValue);
      }
      else {
	float * demandVol;
	witGetDemandDemandVol(theWitRun, partList[i], demandList[j], &demandVol);
	int t = 0; 
	float	 maxVol=0.0;
	float minVol= 9999999.9;
	for (t=0; t<nPeriods; t++) {
	  maxVol = (demandVol[t] > maxVol) ? demandVol[t] : maxVol;
	  if (demandVol[t] > 0) {
	    minVol = (demandVol[t] < minVol) ? demandVol[t] :  maxVol;
	  }
	}
	
	witFree(demandVol);
	
	if (maxVol > 0) {
	  searchInc = (maxVol / anIncValue > 0.001) ? maxVol/anIncValue : 0.001;
	  witSetDemandSearchInc(theWitRun, partList[i], demandList[j], searchInc);
	  std::cout << "HeuristicSearchIncrement: searchInc=" << searchInc << std::endl;
	}
      }
      witFree(demandList[j]);

    }
    witFree(demandList);
    witFree(partList[i]);
    
  }
  witFree(partList);
    
}

// ---------------------------------------------------------------------------
//  -------------------
//  Print Total Demand 
//  -------------------
void 
LgFrScenarioForSce::printTotalDemandFile(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrSceBaseExploder * exploder,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{

  LgFrCalendar theCal = this->calendar();

   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Total Demand" 
			<< fileName);
   }

   bool useDatedDemands = setOfParameters().getBool("useDatedDemands");
   int printIfZero;
   if (useDatedDemands)
     printIfZero = 0;
   else 
     printIfZero = 1;

   long numRecords = 0;  // keep track of number of records
   int nDemands;
   char ** dList;

#ifdef ENABLE_NEGATIVE_DEMANDS
   LgFrTimeVecFloat negDemVol;
#endif

   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     // Compute :=======> mrpConsVol
     float * mrpConsVol;
     if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
       exploder->mrpConsVol(partList[i], &mrpConsVol);

       // Now add in direct demand vol
       // get demands on the part.  These are needed for direct demands
       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);

       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<nDemands; j++) {
	 float * indepDemandVol;
	 witGetDemandDemandVol(theWitRun, partList[i], dList[j], &indepDemandVol);
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
	   mrpConsVol[tt] += indepDemandVol[tt];
	 }
	 witFree(indepDemandVol);
	 witFree(dList[j]);
       }
       witFree(dList);

#ifdef ENABLE_NEGATIVE_DEMANDS
       // Compute :=======> negDemVol
       int doesPartHaveNegativeDemands = mpHelper.doesPartHaveNegativeDemands(theWitRun, partList[i]);
       if (doesPartHaveNegativeDemands) {
	 negDemVol = mpHelper.negDemVol(theWitRun, partList[i]);

	 LgFrTimeVecFloat witMrpConsVol((size_t) nPeriods, mrpConsVol);
	 LgFrTimeVecFloat negDemMrpConsVol((size_t) nPeriods, 0.0);

	 float rolledNegDemVol = 0.0;
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
	   rolledNegDemVol += negDemVol[tt];
	   if (mrpConsVol[tt] > rolledNegDemVol) {
	     mrpConsVol[tt] -= rolledNegDemVol;
	     negDemMrpConsVol[tt] += rolledNegDemVol;
	     rolledNegDemVol = 0.0;
	   }
	   else {
	     // Note: if mrpConsVol < 0 then there are negative usage rates
	     // these can realy screw up our calculation
	     if (mrpConsVol[tt] > 0) {
	       rolledNegDemVol -= mrpConsVol[tt];
	       negDemMrpConsVol[tt] += mrpConsVol[tt];
	       mrpConsVol[tt] = 0.0;
	     }
	   }
	 }
       }
#endif


       std::string leadingString = "\"" 
	 + mpHelper.partname(partList[i]) + "\",\"" 
	 + mpHelper.pdf(partList[i]) + "\"";
       flatFileMgr_.writeFloatVecToStream(theCal, outFile, nPeriods, printIfZero, leadingString, mrpConsVol); 


       witFree(mrpConsVol);
       numRecords++;
     }
   }
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
   
   
}


// return a exploder object
LgFrSceBaseExploder *
LgFrScenarioForSce::exploder()
{
  if (exploderPtr_ == 0) {
    assert(exploderPtr_ != 0);
  }
  return exploderPtr_;    
}

// ---------------------------------------------------------------------------
void   
LgFrScenarioForSce::runExplosion( LgFrScenarioForSceSmartPointer scenSceSP )
{

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  
  //this is the first time an exploder is created!!
  if (exploderPtr_ == 0) {
    exploderPtr_ = this->createAppropriateSceExploder(scenSceSP);
  }
  else {
    std::cerr << "trying to access an exploder for first time and it is non-null\n "
	      << std::endl;
    exit (1);
  }


  LgFrSceBaseExploder * myExploder = this->exploder();

  WitRun * const theExplodeWitRun        = myExploder->localWitRun();  


  // Dump the explode version of the echo file
  if (setOfParameters.getBool("printExplodeEchoFile"))  {
    std::cout << "Writing the Explode echo file  ..." << std::endl;                
    std::string explodeEchoFileName = setOfParameters.getString("explodeEchoFileName");
    setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_ON);
    witDisplayData( theExplodeWitRun, explodeEchoFileName.c_str());
    if (! setOfParameters.getBool("printWitExplodeMsgFile"))   {
      setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_OFF);          
    }
  }

  // Dump the explode version of the wit.data file
  if (setOfParameters.getBool("printExplodeWitDataFile"))  {
    std::cout << "Writing the (Explode) wit data file ..." << std::endl;                      
    std::string explodeWitDataFileName = setOfParameters.getString("explodeWitDataFileName");
    setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_ON);
    witWriteData(theExplodeWitRun, explodeWitDataFileName.c_str());
    if (! setOfParameters.getBool("printWitExplodeMsgFile"))   {
      setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_OFF);          
    }
  }




  std::cout << "Executing explosion engine using (" << myExploder->title() << ") scheme  ..." << std::endl;  


  // run the explosion engine !!
  myExploder->explode();

  bool doPegging = setOfParameters.getBool("doPegging");

  // MRP TESTING ... print the Critical List 

  // need a flag for whtether it's mrp or implosion PIP
  if (doPegging) {
    printPIPData(theExplodeWitRun, 1);
  }
    
}
// ---------------------------------------------------------------------------
void   
LgFrScenarioForSce::printExplosionResults()
{
  int      nPeriods;
  int      nParts;
  char  ** partList;
  int      nOperations;
  char  ** opList;


  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  // WitRun * const theWitRun        = this->exploder()->localWitRun();
  WitRun * const theWitRun        = lastProblemSolved().witRun();
  LgFrSceBaseExploder * myExploder = this->exploder();
  
  std::cout << "Writing explosion output results  ..." << std::endl;  

  witGetNPeriods(theWitRun, &nPeriods);
  witGetParts(theWitRun, &nParts, &partList);
  witGetOperations(theWitRun, &nOperations, &opList);

  // Adjust Interplant execVols for Jumper ARCS
  // this is done via operation App data.

  // VERY IMPORTANT!!  This step initializes App data for Interplant
  // operations in the primary witRun!!  It must be done before any interplant
  // execVols can be accessed (in either mrp or implosion witRuns). The app data
  // is actually store in the priamry witRun

  // NOTE: to get an interplant (mrp)execVol, use scenario's helper function
  // interplantExecVol(opName, execVol &)
  // interplantMrpExecVol(opName, mrpExecVol &)
  initializeInterplantOperationsAppData(theWitRun,
					nPeriods,
					nOperations,
					opList);


  bool printTotalDemandReport =
    setOfParameters.getBool("printTotalDemandReport");

  if (printTotalDemandReport) {
    std::string totalDemandReportFileName = setOfParameters.getString("totalDemandReportFileName");
   printTotalDemandFile(theWitRun,  myExploder,
			nPeriods, nParts, partList,
			totalDemandReportFileName,
			mpHelper);
  }



  // Operations Demand File: optional file (new 2.31)
  // prints only when asked for 
  // prints BOTH userDefined Operations and Default Operations

  bool printOperationDemandFile = setOfParameters.getBool("printOperationDemandFile");
  if (printOperationDemandFile )   {
    std::string operationDemandFileName = setOfParameters.getString("operationDemandFileName");
    printOperationDemandVolFile(theWitRun, 
			     nPeriods, 
			     operationDemandFileName,
			     mpHelper);
  }


  

  // Interplant Demand File: optional file (new 2.00)
  // prints only when asked for and there are interplant records

  bool printInterplantDemandFile = setOfParameters.getBool("printInterplantDemandFile");
  std::string interPlantFile = setOfParameters.getString("interPlantFile");
  if ((! interPlantFile.empty()) && printInterplantDemandFile )   {
    std::string interplantDemandFileName =
      setOfParameters.getString("interplantDemandFileName");
    bool isThisMrp = true;
    printInterplantVolumesFile(theWitRun, nPeriods, 
			       nOperations, opList,
			       isThisMrp,
			       interplantDemandFileName,
			       mpHelper);
  }



  // Capacity Usage Volume File: optional file
  // (prints only when there is substitute  input data)
  bool printMrpCapacityUsageFile = setOfParameters.getBool("printMrpCapacityUsageFile");    
  if (printMrpCapacityUsageFile)   {
    bool isItMrp = true;
    printCapUsageVolume(myExploder->localWitRun(), isItMrp); 
  }
  

  
  // Mrp Substitute Usage Volume File
  // (prints only when (1) usingSmartExplode and (2) there is substitute  input data)
  bool printMrpSubUsageFile = setOfParameters.getBool("printMrpSubUsageFile");    
  bool useSmartExplodeUtility = setOfParameters.getBool("useSmartExplodeUtility");
  std::string subBomFile = setOfParameters.getString("subBomFile");    
  if (printMrpSubUsageFile && useSmartExplodeUtility && (! subBomFile.empty()))   {
    std::string mrpSubUsageFileName = setOfParameters.getString("mrpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = false;
    bool engineMustBeImplode = false;
    printSubstituteUsageVolume(theWitRun, 
			       parentMustBeUserDefinedOperation,
			       engineMustBeImplode,
			       nPeriods, nOperations, opList,
			       mrpSubUsageFileName, mpHelper);
  }



  // Mrp Operation Substitute Usage Volume File
  // (prints only when (1) usingSmartExplode and (2) there is operation substitute  input data)
 
  bool printMrpOpSubUsageFile = setOfParameters.getBool("printMrpOpSubUsageFile");    
  std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
  if (printMrpOpSubUsageFile && useSmartExplodeUtility && (! opSubBomFile.empty()))   {
    std::string mrpOpSubUsageFileName = setOfParameters.getString("mrpOpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = true;
    bool engineMustBeImplode = false;
    printSubstituteUsageVolume(theWitRun, 
			       parentMustBeUserDefinedOperation,
			       engineMustBeImplode,
			       nPeriods, nOperations, opList,
			       mrpOpSubUsageFileName, mpHelper);
  }


  // Print the MRP Supply Orders File
  if (setOfParameters.getBool("printMrpSupplyOrdersFile"))  {
    std::string mrpSupplyOrdersFileName = setOfParameters.getString("mrpSupplyOrdersFileName");
    printMrpSupplyOrdersFile(mpHelper, nPeriods, mrpSupplyOrdersFileName);
  }
  
  // Print the MRP Demand Orders File
  if (setOfParameters.getBool("printMrpDemandOrdersFile"))  {
    std::string mrpDemandOrdersFileName = setOfParameters.getString("mrpDemandOrdersFileName");
    printMrpDemandOrdersFile(mpHelper, nPeriods, mrpDemandOrdersFileName);
  }

  // MRP Critical List   EXPERIMENTAL
  if (setOfParameters.getBool("printMrpCriticalListFile"))  {    
    std::string criticalListFileName = "tomout.mrpCritList";
    std::string engine = setOfParameters.getString( "engine");
    LgFrCalendar theCal = this->calendar();
    LgFrSceCritList & theCritList = sceCritList();
    this->printDebugCriticalList(theWitRun, engine, nPeriods, nParts, partList,
				 criticalListFileName, theCal, mpHelper, theCritList);
  }
  
  

  // Note: if we are not doing an implosion, then we must still write the
  // Dump files.
  bool doImplode = setOfParameters.getBool("doImplode");
  if (! doImplode) {
    // Part Database Dump File:  optional file
    if (setOfParameters.getBool("printPartDBFile"))  {
      std::string partDBFileName = setOfParameters.getString("partDBFileName");
      printPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				partList, partDBFileName);
    }
    // Capacity Database Dump File: optional file    
    if (setOfParameters.getBool("printCapacityDBFile"))  {
      std::string capacityDBFileName =
	setOfParameters.getString("capacityDBFileName");
      printCapacityDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				    partList, capacityDBFileName);
    }


    // Operation Database Dump File
    if (setOfParameters.getBool("printOperationDBFile"))  {
      std::string operationDBFileName =
	setOfParameters.getString("operationDBFileName");
      printOperationDataBaseDumpFile(theWitRun, mpHelper, nPeriods, 
	    operationDBFileName);
    }




    
  }

  // free the parts 
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++)  
    witFree(partList[i]);
  witFree(partList);

  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++)  
    witFree(opList[o]);
  witFree(opList);
}




// *********************************************************************************

int
LgFrScenarioForSce::nDemandsWithNonZeroMins()
const
{
  return nDemandsWithNonZeroMins_;
}

void
LgFrScenarioForSce::nDemandsWithNonZeroMins(int nMins)
{
  nDemandsWithNonZeroMins_ = nMins;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::incNDemandsWithNonZeroMins()
{
  nDemandsWithNonZeroMins_++;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::decNDemandsWithNonZeroMins()
{
  nDemandsWithNonZeroMins_--;
}

// ---------------------------------------------------------------------------
int
LgFrScenarioForSce::nStandaloneFeatureArcs()
const
{
  return nStandaloneFeatureArcs_;
}  
// ---------------------------------------------------------------------------  
void
LgFrScenarioForSce::nStandaloneFeatureArcs(int nFeats)
{
  nStandaloneFeatureArcs_ = nFeats;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::incrementStandaloneFeatureArcs()
{
  nStandaloneFeatureArcs_++;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::setEngine(const std::string & engine)
{
    engine_ = engine;
    sce::toLower( engine_ );
}

// ---------------------------------------------------------------------------
std::string 
LgFrScenarioForSce::getEngine()
{
    return engine_;
}

// ---------------------------------------------------------------------------
// generate a GeoDemand vectorized SOURCE record for one particular demand
// Returns period number in which there is a "hole".  -1 if no holes
int 
LgFrScenarioForSce::determineGeoToPdfSourceVector(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & geoPlannerDemandPartName,
    std::string * sourceList)
{
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;

  

  int t;
  int nBom;
  int b;
  char * child;
  int early, late;

  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);

  assert(mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						    geoPlannerDemandPartName,
						    plannerPart, geo));

  std::string unknownPdf("???");
  std::string unknownMfgPart("??????");
  std::string unknownPartPdf = mpHelper.pdfPartname(unknownMfgPart, unknownPdf);

  
  // initialize the vector with all unknown Part,PDF for this GPD part
  for (t=0; t<nPeriods; t++) {
    sourceList[t] = unknownPartPdf;
  }
     
  // We need to check the children of this geoPlannerDemand part.
  // The non-normal children can be skipped.  The remaining children
  // represent mfgPart,pdf that are true suppliers of the demanded part.
  // When we find a normal child, we pcik up the effectivity interval of
  // the BOM record.  For that interval, any demand that is shipped to the
  // geo must have been sourced from that pdf-part.  
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
  for (b=0; b<nBom; b++) {
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), b, &child);
    if (! mpHelper.isPartNormal(theWitRun, child)) {
      witFree(child);
      continue;
    }

    witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &early);
    witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &late);
    // now set the indicator vector and set the vector geoByPdfSupplyVol
    for (t=early; t<=late; t++) {
      sourceList[t] = child;
    }

    witFree(child);
  }

  // now check to see if anything is unsourced
  int unsourcedPeriod = -1;
  for (t=0; t<nPeriods; t++) {
    if (sourceList[t] == unknownPartPdf) {
      unsourcedPeriod = t;
      break;
    }
  }
  return unsourcedPeriod;
}

//  ---------------------------------------------------------------------
//  Print Overall Problem Statistics
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOverallProblemStatistics(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Problem Statistics" << fileName);
  }


   long numRecords = 0;  // for counting output lines

   int i, t, o;
   int nBom;
   int nOps;
   int npBops;
   int nBopTot = 0;
   int nBomTot = 0;
   int nNormalParts = 0;
   int nNormalCapacityParts = 0;
   int nPcfParts = 0;
   int nGeoPlannerDemandParts = 0;
   int nGeoPlannerDemandUBParts = 0;
   int nOptionRatioSupplyParts = 0;
   int nOptionDummyParts = 0;
   int nOptionDummyOperations = 0;
   int nBbCategoryParts = 0;
   int nInterplantOperations = 0;
   int nAggregationOperations = 0;   
   int nUserSpecifiedOperations = 0;
   int nLtGtParts = 0;
   int nGlobalNullSubParts = 0;
   int nGlobalMaxWithoutNullSubParts = 0;
   int nMaxWithoutNullSubParts = 0;
   int nStandaloneFeatureParts = 0;
   int nCustChoiceFeatureParts = 0;
   int nPartsBuildableFromThinAir = 0;
   int nWaifs = 0;
   int nPureOptionBuildDemands = 0;
   int nCustChoiceOptionBuildDemands = 0;

   int * buildableFromThinAir = new int[nParts];
  
   
   std::string d1, d2, d3, d4;

   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     buildableFromThinAir[i] = 0;
     int constrained = 0;
     std::string thePart = partList[i];

     // count how many bop arcs in total
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     nBopTot += npBops;

     if (mpHelper.isPartNormalCapacity(theWitRun, thePart)) {
       nNormalCapacityParts++;
     }
     else if (mpHelper.isPartNormal(theWitRun, thePart)) {
       nNormalParts++;
       if (mpHelper.isPartPcf(theWitRun, thePart))
	 nPcfParts++;
     }
     else if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, thePart, d1, d2)) {
       nGeoPlannerDemandParts++;
     }
     else if (mpHelper.isPartSpecialGeoPlannerDemandUbPart(theWitRun, thePart, d1, d2)) {
       nGeoPlannerDemandUBParts++;
     }
     else if (mpHelper.isPartSpecialGlobalNullSubstitute(theWitRun, thePart, d1)) {
       nGlobalNullSubParts++;
     }
     else if (mpHelper.isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun, thePart, d1)) {
       nGlobalMaxWithoutNullSubParts++;
     }     
     else if (mpHelper.isPartSpecialMaxWithoutNullSubstitute(theWitRun, thePart, d1, d2, d3)) {
       nMaxWithoutNullSubParts++;
     }
     else if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, thePart)) {
       nStandaloneFeatureParts++;
     }
     else if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, thePart)) {
       nCustChoiceFeatureParts++;
     }
     
#if 0
     else if (mpHelper.isPartSpecialPhantom(theWitRun, thePart)) {
       nPhantomParts++;
     }
#endif
     else if (mpHelper.isPartSpecialBbCategory(theWitRun, thePart, d1, d2, d3)) {
       nBbCategoryParts++;
     }
     else if (mpHelper.isPartSpecialLTbbCapacity(theWitRun, thePart, d1, d2, d3)) {
       nLtGtParts++;
     }
     else if (mpHelper.isPartSpecialGTbbCapacity(theWitRun, thePart, d1, d2, d3)) {
       nLtGtParts++;
     }
     else if (mpHelper.isPartSpecialOptionDummy(theWitRun, thePart, d1, d2, d3,d4)) {
       nOptionDummyParts++;
     }
     else if (mpHelper.isPartSpecialOptionRatioSupply(theWitRun, thePart, d1, d2, d3,d4)) {
       nOptionRatioSupplyParts++;
     }
   }

   char ** opList;
   witGetOperations(theWitRun, &nOps, &opList);
   for (o=0; o<nOps; o++) {
     std::string theOperation(opList[o]);
     // count total BOM entries in model
     witGetOperationNBomEntries(theWitRun, theOperation.c_str(), &nBom);
     nBomTot += nBom;

     if (mpHelper.isOperationSpecialInterplant(theWitRun, theOperation, d1, d2, d3, d4)) {
       nInterplantOperations++;
     }

     else if (mpHelper.isOperationSpecialOptionDummy(theWitRun, theOperation, d1, d2, d3,d4)) {
       nOptionDummyOperations++;
     }


     else if (mpHelper.isOperationSpecialAggregation(theWitRun, theOperation, d1, d2, d3, d4)) {
       nAggregationOperations++;
     }
     else {
       witBoolean exists;
       witGetPartExists(theWitRun, theOperation.c_str(), &exists);
       if (! exists)
	 nUserSpecifiedOperations++;
     }
     witFree(opList[o]);
   }
   witFree(opList);


   // CUSTOMER_CHOICE_FEATURES
   // compute the number of Customer Choice OptionBuildDemands ... this should equal the number
   // of feature ratio records accepted?
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitFeaturePartName(partList[i]);
     if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, fullWitFeaturePartName)) {
       int lenDemandList;
       char ** demandList;
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
	 if ( mpHelper.isDemandSpecialCustChoiceFeature( theWitRun, fullWitFeaturePartName,
							 fullWitGeoPlannerDemandName,
							 plannerPart, geo ))
	   nCustChoiceOptionBuildDemands++;
	 witFree(demandList[j]);
       }
       witFree(demandList);
     }
   }


   // compute the number of PureOptionBuildDemands ... this should equal the number
   // of feature ratio records accepted?
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitFeaturePartName(partList[i]);
     if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, fullWitFeaturePartName)) {
       int lenDemandList;
       char ** demandList;
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
	 if ( mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun, fullWitFeaturePartName,
							     fullWitGeoPlannerDemandName,
							     plannerPart, geo ))
	   nPureOptionBuildDemands++;
	 witFree(demandList[j]);
       }
       witFree(demandList);
     }
   }




   // Look for unconstrained and constrained waif parts
   // A waif part is:
   //    - Only have one bop entry
   //    - Only have a default operation
   // An unconstrained waif (unc-waif)
   //    - yield(defaultOp) > 0.0 for all periods
   // A constrained waif has
   //    - yield(defaultOp) = 0.0 in at least one period
   for ( i=0; i<nParts; i++ ) {
     buildableFromThinAir[i] = 0;
     // only consider normal parts
     std::string thePart = partList[i];
     if (! mpHelper.isPartNormal(theWitRun, thePart))
       continue;
     witBoolean exists;
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     // if it doesn't have exactly one part then its not a unc-waif
     if (npBops != 1)
       continue;
     // if default operation does not exist, then skip it .. its not a unc-waif
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
     if (! exists)
       continue;
     // if default operation has any bom entries then its not an unc-waif
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
     if (nBom > 0)
       continue;
     // if the part is a PCF then its not an unc-waif
     if (mpHelper.isPartPcf(theWitRun, thePart))
       continue;
     // OK the part is a waif
     nWaifs++;
     // now see if its an unc-waif
     float * yieldRate;
     witGetOperationYieldRate(theWitRun, thePart.c_str(), &yieldRate);
     bool uncWaif=true;
     for (t=0; t<nPeriods; t++) {
       if (yieldRate[t] = 0.0) {
	 uncWaif = false;
	 break;
       }
     }
     if (uncWaif) {
       nPartsBuildableFromThinAir++;
       buildableFromThinAir[i] = 1;
     }
     witFree(yieldRate);
   }

   
     
   
   outFile << " Problem Size Statistics\n\n";
   outFile << " Number of Real parts: = " << nNormalParts << "\n";
   outFile << " Number of Capacities: = " << nNormalCapacityParts << "\n";
   outFile << " Number of Operations: = " << nOps << "\n";
   outFile << " Number of Artificial (interplant) \"operations\": = " << nInterplantOperations << "\n";
   outFile << " Number of Artificial (aggregation) \"operations\": = " << nAggregationOperations << "\n";      
   outFile << " Number of User-Defined Operations: = " << nUserSpecifiedOperations << "\n";
   outFile << " Number of lowest level, non-pcf, lead-time constrained real parts : = " << nWaifs - nPartsBuildableFromThinAir << "\n";
   outFile << " Number of lowest level, non-pcf, unconstrained real parts : = " << nPartsBuildableFromThinAir << "\n";
   outFile << " Number of Artificial (GPD demand) \"parts\": = " << nGeoPlannerDemandParts << "\n";
   outFile << " Number of Artificial (demandUB) \"parts\": = " << nGeoPlannerDemandUBParts << "\n";
   outFile << " Number of Artificial (bbCategory) \"parts\": = " << nBbCategoryParts << "\n";
   outFile << " Number of Artificial (SOD) \"parts\": = " << nOptionDummyParts << "\n";
   outFile << " Number of Artificial (SOD) \"operations\": = " << nOptionDummyOperations << "\n";
   outFile << " Number of Artificial (ORS) \"parts\": = " << nOptionRatioSupplyParts << "\n";
   outFile << " Number of Artificial (LT/GT) \"parts\": = " << nLtGtParts << "\n";
   outFile << " Number of Artificial (pureOption build ) \"demands\": = " << nPureOptionBuildDemands << "\n";
   outFile << " Number of Artificial (custChoice build ) \"demands\": = " << nCustChoiceOptionBuildDemands << "\n";
   outFile << " Number of Artificial (global nullSub) \"parts\": = " << nGlobalNullSubParts << "\n";
   outFile << " Number of Artificial (global mwo nullSub) \"parts\": = " << nGlobalMaxWithoutNullSubParts << "\n";
   outFile << " Number of Artificial (mwo nullSub) \"parts\": = " << nMaxWithoutNullSubParts << "\n";
   outFile << " Number of Artificial (custChoice feature) \"parts\": = " << nCustChoiceFeatureParts << "\n";
   outFile << " Number of Artificial (standAlone feature) \"parts\": = " << nStandaloneFeatureParts << "\n";
   outFile << " Total \"Parts\" in SCE model: = " << nParts << "\n";
   outFile << " Total \"Bop Arcs\" in SCE model: = " << nBopTot << "\n";   
   outFile << " Total \"Bom Arcs\" in SCE model: = " << nBomTot << "\n\n\n";

   // Note: for now, since the above print statements are hard-coded, if 
   //       someone changes these in this file, then later on in the
   //       output log, the number of output lines will be inconsistent with
   //       the number actual output lines....so change the following line:
   numRecords = 23;

   outFile << " Unconstrained, lowest level, non-pcf  Parts List:\n";

   for ( i=0; i<nParts; i++ ) {
     if (buildableFromThinAir[i]) {
       outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	       << mpHelper.pdf(partList[i]) << "\"\n";
       numRecords++;
     }
   }
   
   outFile.close();
   delete [] buildableFromThinAir;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }



//  ---------------------------------------------------------------------
//  Print Lowest Level, unconstrained parts (non-pcf)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printLowestLevelNonPcfParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Lowest Level, Non-pcf" << fileName);
  }


   long numRecords = 0;  // for counting output lines

   int i;
   int nBom;
   int npBops;
   witBoolean exists;  
   

   // Look for Lowest Level, non-pcf parts:
   //    - Only have one bop entry
   //    - Only have a default operation
   //    - not a pcf part
   for (i=0; i<nParts; i++ ) {
     // only consider normal parts
     std::string thePart = partList[i];
     if (! mpHelper.isPartNormal(theWitRun, thePart))
       continue;

     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     // if it doesn't have exactly one part then its not lowest-level-non-pcf
     if (npBops != 1)
       continue;
     // if default operation does not exist, then skip it .. its not lowest-level-non-pcf
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
     if (! exists)
       continue;
     // if default operation has any bom entries then its not lowest-level-non-pcf
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
     if (nBom > 0)
       continue;
     // if the part is a PCF then its not lowest-level-non-pcf
     if (mpHelper.isPartPcf(theWitRun, thePart))
       continue;
     // OK the part is lowest-level, non-pcf
     outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	     << mpHelper.pdf(partList[i]) << "\"\n";
     numRecords++;
   }

   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }


#ifdef MARK_BOGONS
//  ---------------------------------------------------------------------
//  Print PCF Bogons (parts which were specified as PCF but got rejected due to child parts)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBogonParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Bogon List" << fileName);
  }


   long numRecords = 0;  // for counting output lines

   int i;
   // Look for Lowest Level, non-pcf parts:
   //    - Only have one bop entry
   //    - Only have a default operation
   //    - not a pcf part
   for (i=0; i<nParts; i++ ) {
     std::string thePart = partList[i];
     if (! mpHelper.isPartBogon(theWitRun, thePart))
       continue;
     outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	     << mpHelper.pdf(partList[i]) << "\"\n";
     numRecords++;
   }

   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }
#endif



//  ---------------------------------------------------------------------
//  Calculate and Print Value Added Costs
//  --------------------------------------------------------------------- 
//  calculation of vac is limited to default operations only.   that means that
//  VAc and compCost will be based on in-plant mfg cost or rawCost at that site.
//
void 
LgFrScenarioForSce::calculateAndPrintValueAddedCosts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string vacFileName,
	 std::string compCostFileName)
{
  std::ofstream vacFile(vacFileName.c_str());//, ios::out, 0666);
  if (vacFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Value Added Cost" << vacFileName);
  }

  std::ofstream compCostFile(compCostFileName.c_str());//, ios::out, 0666);
  if (compCostFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Comp cost " << compCostFileName);
  }

   long numRecords = 0;  // for counting output lines

   std::string leadingString;

   int i, t;

   std::cout << "   ... number of parts to process: " << nParts << std::endl;                

  //input: rawCost of each part
  //output: vacCost of each part
  //        compCost of each part

  // loop over parts in sorted list 
  //   get next part on list: part-x (if no more parts, then DONE)
  //   if Part-x has No children then  {
  //         vacCost(part-x) = rawCost(part-x)
  //         compCost(x) = 0
  //   if Part-x has children then {
  //      initialize: vacCost(x) = rawCost(x)
  //      initialize: compCost(x) = 0
  //      for each child of Part-x:    {
  //           compCost(x) += (compCost(child) + vacCost(child))  * usageRate / ((1-fallout) * yield(x))
  //
  //      }
  //      vacCost(x) = max{0, rawCost(x) - compCost(x)
  //   }

   int kParts, lastK;
   lastK=0;

   for (i=0; i<nParts; i++ ) {
     std::string thePart = partList[i];

     kParts = i/10;
     if (kParts > lastK) {
       lastK = kParts;
       //       std::cout << "   ... processed " << i << " parts out of " << nParts << std::endl;                
     }


     LgFrTimeVecFloat vacCost(nPeriods, 0.0);
     LgFrTimeVecFloat compCost(nPeriods, 0.0);

     witBoolean exists;
     witGetOperationExists(theWitRun, partList[i], &exists);
     if (exists) {
       float * rawCost;
       witGetOperationObj1ExecCost(theWitRun, partList[i], &rawCost);
       for (t=0; t<nPeriods; t++)
	 vacCost[t] = rawCost[t];

       int nBom;
       witGetOperationNBomEntries(theWitRun, partList[i], &nBom);
       
       float * yieldRate;
       witGetOperationYieldRate(theWitRun, partList[i], &yieldRate);

       
       int b;
       for (b=0; b<nBom; b++) {
	 char * child;
	 witGetBomEntryConsumedPart(theWitRun, partList[i], b, &child);
	 float * consRate;
	 witGetBomEntryConsRate(theWitRun, partList[i], b, &consRate);
	 float falloutRate;
	 witGetBomEntryFalloutRate(theWitRun, partList[i], b, &falloutRate);
	 int * impactPeriod;
	 witGetBomEntryImpactPeriod(theWitRun, partList[i], b, &impactPeriod);
	 

	 LgFrScePartAppData * childAppDataPtr;    
	 witGetPartAppData(theWitRun, child, (void **) &childAppDataPtr);

	 // child MUST have been seen alrady, and hence has an appData
	 assert (childAppDataPtr != 0);

	 LgFrTimeVecFloat childVac = childAppDataPtr->vac();
	 LgFrTimeVecFloat childCompCost = childAppDataPtr->compCost();


	 for (t=0; t<nPeriods; t++) {
	   if ( (yieldRate[t] > 0.0) && (impactPeriod[t] > -1) ) {
	     compCost[t] += 
	       ((childCompCost[impactPeriod[t]] + childVac[impactPeriod[t]]) * consRate[t] )
	       / ((1.0 - falloutRate) * yieldRate[t]);
	   }
	 }

	 witFree(child);
	 witFree(consRate);
	 witFree(impactPeriod);
       }

       for (t=0; t<nPeriods; t++)
	 vacCost[t] =  (rawCost[t] - compCost[t] > 0.0) ? rawCost[t] - compCost[t] : 0.0f;


       witFree(yieldRate);
       witFree(rawCost);
     }

     LgFrScePartAppData * appDataPtr;    
     witGetPartAppData(theWitRun, partList[i], (void **) &appDataPtr);
     if (appDataPtr == 0) {
       appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
       appDataPtr->vac(vacCost);
       appDataPtr->compCost(compCost);
       witSetPartAppData(theWitRun, partList[i], (void *) appDataPtr);
     }
     else {
       appDataPtr->vac(vacCost);
       appDataPtr->compCost(compCost);
     }


     // only write the NORMAL records,
     if (mpHelper.isPartNormal(theWitRun, partList[i])) {
       leadingString = "\""
	 + mpHelper.partname(partList[i]) + "\",\""
	 + mpHelper.pdf(partList[i]) + "\"";
       flatFileMgr_.writeFloatVecToStream(this->calendar(), vacFile, nPeriods, 0, leadingString, vacCost.data());
       
       leadingString = "\""
	 + mpHelper.partname(partList[i]) + "\",\""
	 + mpHelper.pdf(partList[i]) + "\"";
       flatFileMgr_.writeFloatVecToStream(this->calendar(), compCostFile, nPeriods, 0, leadingString, compCost.data());
       numRecords++;
     }
   }

   vacFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(vacFileName,numRecords,000,numRecords);
   compCostFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(compCostFileName,numRecords,000,numRecords);

 }

//  ---------------------------------------------------------------------
//  Print Optimization data
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOverallOptimizationValues(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string & engine,
	 std::string fileName)
{

  std::string partName;

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Overall Optimization Values" << fileName);
  }


   long numRecords = 0;

   float * obj1Reward;
   float * obj1CSReward;
   int   * priority;
   float cumShipVol;
   float * shipVol;
   float * demandVol;
   float cumpts = 0.0;
   float cumblog = 0.0;
   int nDemands;
   char ** dList;
   float cumDemVol = 0.0;
   float newBlog;
   float onTimeServ = 0.0;
   float cumInt = 0.0;
   int i, j, t;
   float cumShipOnTime = 0.0;
   float cumTotalDemVol = 0.0;
   float shipToDemThisPeriod;
   float objValue;
   float boundsValue;


   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {

       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
       for (j =0; j<nDemands; j++)  {
	 if (! sce::compareStringsCaseIns( engine, "optimization" )) {
	   witGetDemandObj1ShipReward(theWitRun, partList[i], dList[j], &obj1Reward);
	   witGetDemandObj1CumShipReward(theWitRun, partList[i], dList[j], &obj1CSReward);
	 }
	 else {
	   witGetDemandPriority(theWitRun, partList[i], dList[j], &priority);
	 }
	 witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	 witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	 cumShipVol = 0.0;
	 cumDemVol = 0.0;
	 for (t=0; t<nPeriods; t++) {
	   cumShipVol += shipVol[t];
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
	     cumpts += (shipVol[t] * obj1Reward[t]);
	     cumInt += (cumShipVol * obj1CSReward[t]);
	   }
	   else
	       cumpts += (shipVol[t] * priority[t]);             
	   newBlog = (demandVol[t] > shipVol[t]) ? demandVol[t] - shipVol[t] : 0.0f;
	   shipToDemThisPeriod = (cumShipVol > cumDemVol) ? cumShipVol - cumDemVol : 0.0f;
	   cumShipOnTime += shipToDemThisPeriod;
				      
	   cumblog += newBlog;
	       cumDemVol += demandVol[t];
	       cumTotalDemVol += demandVol[t];
	   }
	   witFree(dList[j]);
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {           
	     witFree(obj1Reward);
	     witFree(obj1CSReward);
	   }
	   else 
	     witFree(priority);           
	   witFree(shipVol);
	   witFree(demandVol);
       }
       witFree(dList);
   }
   if (cumTotalDemVol > 0.0001)
     onTimeServ = cumShipOnTime / cumTotalDemVol;
#ifdef SCE_OPT_IMPLODE   
   witGetObjValues(theWitRun, &objValue, &boundsValue);
#endif
   
   outFile << "SCE Optimization Summary Report:\n";
   outFile << "  - Engine used:" << engine <<"\n";   
   
   outFile << "  - Primary  objective value: = " << cumpts << "\n";
   numRecords += 2;

   if (cumTotalDemVol > 0.0001)   
     outFile << "  - On time serviceability: = " << onTimeServ << "\n";
   else
     outFile << "  - On time serviceability: = ERROR all demands have ZERO volume\n";
   numRecords++;

   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
     outFile << "  - Additional interest reward : = " << cumInt << "\n";
     numRecords++;

#ifdef SCE_OPT_IMPLODE        
     outFile << "  - Total WIT optimization objective value: = " << objValue << "\n";
     outFile << "  - Penalty for violating Min Demand Volumes: = " << boundsValue << "\n";
     numRecords += 2;
#endif     
     // outFile << " Additional cost due to Substitutes = " << 0 << "\n";     
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}

//  ---------------------------------------------------------------------
//  Print Capacity   Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printCapacityDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Capacity Database Dump" << fileName);
  }

  LgFrCalendar & theCal = calendar();

  long numRecords = 0;
  long numUniquePairs = 0;

  float * witVector;
  float * reqVol;
  float * mrpExcessVol;      

  int i, p, b, npBops;

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  bool doImplode = setOfParameters.getBool("doImplode");

  int nonZeroOnly = 0;
  int alwaysPrint = 1;

  //  - userOpVol, mrpUserOpVol  
  bool anyUserDefinedOperations = false;
  float * userOpVol;
  float * mrpUserOpVol;    

  if (! setOfParameters.getString("opFile").empty()) {
    anyUserDefinedOperations = true;
    userOpVol = new float[nPeriods];
    mrpUserOpVol = new float[nPeriods];    
  }


  //  float * bldVol = new float[nPeriods];
  //  float * mrpBldVol = new float[nPeriods];    


   
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
     
    std::string pn(mpHelper.partname(fullPartName));
    std::string pdf(mpHelper.pdf(fullPartName));

     
    // supplyVol
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
    //    numRecords += printDbDumpRec(pn, pdf, "supplyVol", witVector, outFile, nPeriods, alwaysPrint);
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "supplyVol", witVector, outFile, nPeriods, alwaysPrint);
    witFree(witVector);
     

       
    // mrpConsVol
    myExploder->mrpConsVol(partList[i], &witVector);
    numRecords += printDbDumpRec(pn, pdf, "mrpConsVol", witVector, outFile, nPeriods, nonZeroOnly);
    witFree(witVector);

    // reqVol
    myExploder->reqVol(partList[i], &reqVol);
    numRecords += printDbDumpRec(pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);

    // mrpExcessVol
    myExploder->mrpExcessVol(partList[i], &mrpExcessVol);
    numRecords += printDbDumpRec(pn, pdf, "mrpExcessVol", mrpExcessVol, outFile, nPeriods, nonZeroOnly);

    // mrpRequirements
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      reqVol[t] -= mrpExcessVol[t];
    }
    numRecords += printDbDumpRec(pn, pdf, "mrpRequirements", reqVol, outFile, nPeriods, nonZeroOnly);
    witFree(reqVol);
    witFree(mrpExcessVol);
       

    // Use nBops instead of partCategory
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    // Now report on all the execVol types:
    // MRP -------->  mrpUserOpVol
    // Implosion -->  userOpVol
    
    if (npBops > 0) {
      // first intialize the vectors to zero
      if (anyUserDefinedOperations) {
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
	  userOpVol[t] = 0;
	  mrpUserOpVol[t] = 0;
	}
      }

      // loop through each of the bop entries and get the execVol once for each
      // bop entry (this is a bit inefficient, but too bad).
      for (p=0; p<npBops; p++) {
	bool foundOpCategory = false;          
	  
	std::string cp1, pdf1, sp2, pdf2;
	int early, late;
	float  prodRate;
	char * witOperationName;
	float * tempExecVol;
	float * tempMrpExecVol;
	float * yieldRate;
	float * mrpYieldRate;        
	  
	witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
	std::string operationName(witOperationName);
	witGetBopEntryProdRate(theWitRun, witOperationName, b, &prodRate);
	witGetBopEntryEarliestPeriod(theWitRun, witOperationName, b, &early);
	witGetBopEntryLatestPeriod(theWitRun, witOperationName, b, &late);
	myExploder->mrpExecVol(witOperationName, &tempMrpExecVol);          
	if (doImplode) {
	  witGetOperationExecVol(theWitRun, witOperationName, &tempExecVol);
	}
	witGetOperationYieldRate(theWitRun, witOperationName, &yieldRate);
	witGetOperationYieldRate(myExploder->localWitRun(), witOperationName, &mrpYieldRate);        

#if 0
	// Is it the default Operation
	std::string cp1, pdf1;
	if ( mpHelper.isOperationForCapacityGeneration(theWitRun, witOperationName, cp1, pdf1)) {
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    if (doImplode) {
	      bldVol[t]     += yieldRate[t] * tempExecVol[t];
	    }
	    mrpBldVol[t]  += mrpYieldRate[t] * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
#endif

	// is it a UserDefined Operation (it must be, at this point)
	if (! foundOpCategory
	    && anyUserDefinedOperations) {
	  int * impactPeriod;
	  int * mrpImpactPeriod;          
	  witGetBopEntryImpactPeriod(theWitRun, witOperationName, b, &impactPeriod);
	  witGetBopEntryImpactPeriod(myExploder->localWitRun(), witOperationName, b, &mrpImpactPeriod);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (impactPeriod[t] > -1)
	      if (doImplode) {
		userOpVol[impactPeriod[t]]       += yieldRate[t] * prodRate * tempExecVol[t];
	      }
	    if (mrpImpactPeriod[t] > -1)            
	      mrpUserOpVol[mrpImpactPeriod[t]] += mrpYieldRate[t] * prodRate * tempMrpExecVol[t];
	  }
	
	  witFree(impactPeriod);
	  witFree(mrpImpactPeriod);
	  foundOpCategory = true;
	}

	// Now assert that the operation resolved into exactly one of the types!!
	//	assert(foundOpCategory);

	// clean-up the memory for this bop
	witFree(witOperationName);
	if (doImplode) {
	  witFree(tempExecVol);
	}
	witFree(tempMrpExecVol);
	witFree(yieldRate);
	witFree(mrpYieldRate);        
      }
	
      // print userOpVol and mrpUserOpVol
      if (anyUserDefinedOperations) {
	numRecords += printDbDumpRec(pn, pdf, "mrpUserOpVol", mrpUserOpVol, outFile, nPeriods, nonZeroOnly);
      }

      if (doImplode) {        
	if (anyUserDefinedOperations) {
	  numRecords += printDbDumpRec(pn, pdf, "userOpVol", userOpVol, outFile, nPeriods, nonZeroOnly);
	}
      }
    }
    


    if (doImplode) {
       
      // ExcessVol
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
      numRecords += printDbDumpRec(pn, pdf, "excessVol", witVector, outFile, nPeriods, nonZeroOnly);
      witFree(witVector);

      // scrapVol
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
      numRecords += printDbDumpRec(pn, pdf, "scrapVol", witVector, outFile, nPeriods, nonZeroOnly);
      witFree(witVector);

      // consVol
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
      numRecords += printDbDumpRec(pn, pdf, "consVol", witVector, outFile, nPeriods, nonZeroOnly);
      witFree(witVector);

    }

    numUniquePairs++;
  }

  //  - userOpVol, mrpUserOpVol  
  if (anyUserDefinedOperations) {
    if (doImplode) {
      delete [] userOpVol;
    }
    delete [] mrpUserOpVol; 
  }
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numUniquePairs);
}

void 
LgFrScenarioForSce::printStandAloneFeatureAnalysisReport(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
  std::string partName;

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Feasible Optional Feature Ratio" << fileName);
  }


  long numRecords = 0;

  int t, i;

  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string bbCategory;

  float * feasibleFeatureRatio = new float[nPeriods];

  std::string leadingString;  

  // -----------------------------------------------------------------
  // Now look at CUSTOMER_CHOICE_ FEATURES
  // -----------------------------------------------------------------
  for ( i=0; i<nParts; i++ ) {
    std::string custChoiceFeaturePart(partList[i]);
    std::string featurePart;
    std::string ppp;
    std::string mmm, ggg;
    if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, custChoiceFeaturePart, ggg, mmm, ppp, featurePart)) {
      int lenDemandList;
      char ** demandList;
      witGetPartDemands( theWitRun, custChoiceFeaturePart.c_str(), &lenDemandList, &demandList);
      if ( lenDemandList == 0) {
	witFree (demandList);  
	continue;
      }
	
      int j = 0; 
      for (j=0; j<lenDemandList; j++) {
	std::string custChoiceDemandName(demandList[j]);
	std::string plannerPart;
	std::string geo;
	if (! mpHelper.isDemandSpecialCustChoiceFeature( theWitRun, custChoiceFeaturePart, custChoiceDemandName, plannerPart, geo ))
	  continue;

	// We've found a stand-alone option and planner part pair.
	// The option comes from the custChoiceFeaturePart and the planner part comes 
	// from the fullWitDemandName
	// There's only one "build demand" for this pair, but there may be many BOM arc each with subs
	// to account for.

	int ncbe;
	witGetPartNConsumingBomEntries(theWitRun, custChoiceFeaturePart.c_str(), &ncbe);
	assert(ncbe == 1);
	char * gpdWitPartName;
	int bomIndex;
	witGetPartConsumingBomEntry(theWitRun, custChoiceFeaturePart.c_str(), 0, &gpdWitPartName, &bomIndex);

	// what is the gpd exec Vol?
	float * gpdExecVol;
	witGetOperationExecVol(theWitRun, gpdWitPartName, &gpdExecVol);

	// What was the usageRate on the bom entry
	float usageRate;
	witGetBomEntryUsageRate(theWitRun, gpdWitPartName, bomIndex, &usageRate);

	float * sfpSupplyVol;
	witGetPartSupplyVol(theWitRun, custChoiceFeaturePart.c_str(), &sfpSupplyVol);

	// get  execVol  of the specal feature part
	float * sfpExecVol;
	witGetOperationExecVol(theWitRun, custChoiceFeaturePart.c_str(), &sfpExecVol);

	int t = 0; 
	for (t=0; t<nPeriods; t++)  
	  feasibleFeatureRatio[t] = sfpExecVol[t] + sfpSupplyVol[t];

	// get  consVol of the specal feature part
	float * featureConsVol;
	witGetPartConsVol(theWitRun, custChoiceFeaturePart.c_str(), &featureConsVol);

	// Pick up any excessVol of the custChoiceFeaturePart.  This would be 
	// generated from Machine Feature Supply (ie, FEN5) 
	float * ccfeatureExcessVol;
	witGetPartExcessVol(theWitRun, custChoiceFeaturePart.c_str(), &ccfeatureExcessVol);
	
	// Account for the amount of feature we built (i.e. ship to the PureOptionBuildDemand)
	// Initialize feasibleFeatureRatio using shipped amount, then incremently add to it
	float * shipVol = 0;
	witGetDemandShipVol( theWitRun, custChoiceFeaturePart.c_str(), custChoiceDemandName.c_str(), &shipVol);

	// okay TOTAL CONS VOL of the FEATURE PART (post usageRate) is
	for (t=0; t<nPeriods; t++)  
	  featureConsVol[t] += (ccfeatureExcessVol[t] + shipVol[t]);

	// and now divide by the usageRate to get the pre usageRate
	if (usageRate > .001)
	  for ( t=0; t<nPeriods; t++) 
	    featureConsVol[t] /= usageRate;
	
	witFree (shipVol);
	witFree(gpdExecVol);
	witFree(featureConsVol);
	witFree(ccfeatureExcessVol);
	witFree(sfpExecVol);
	witFree(sfpSupplyVol);
	witFree(gpdWitPartName);

	mpHelper.populateLeadingStringGPD(plannerPart, geo, leadingString);
	leadingString += ",\"" 	  + featurePart + "\"";
	flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, feasibleFeatureRatio);

	numRecords++;
      }
      
      for (j=0; j<lenDemandList; j++)
	witFree (demandList[j]);
      witFree (demandList);
    }
  }



  // -----------------------------------------------------------------
  // Now look at STANDALONE OPTIONS modeled via 0 SUBSTITUTE !!
  // -----------------------------------------------------------------

  // Loop once for each part, looking for stand alone options
  // Here we are going to take into account the 2-passes of implosions needed to "build features"
  for ( i=0; i<nParts; i++ ) {
    std::string fullWitFeaturePartName(partList[i]);
    std::string featurePart;
    std::string ppp;
    std::string mmm, ggg;
    if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, 
						fullWitFeaturePartName, 
						ggg, 
						mmm, 
						ppp, 
						featurePart)) {
      int lenDemandList;
      char ** demandList;
      witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
      if ( lenDemandList == 0) {
	witFree (demandList);  
	continue;
      }
	
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<lenDemandList; j++) {
	std::string fullWitStandaloneFeatureDemandName(demandList[j]);
	std::string plannerPart;
	std::string geo;
	if (! mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun, fullWitFeaturePartName,
							     fullWitStandaloneFeatureDemandName,
							     plannerPart, geo ))
	  continue;
	// We've found a stand-alone option and planner part pair.
	// The option comes from the fullWitPartName and the planner part comes from the fullWitDemandName
	// There's only one "build demand" for this pair, but there may be many BOM arc each with subs
	// to account for.

	std::string plannerTopLevelPart = mpHelper.geoPlannerDemandPartName(plannerPart, geo);
	
	// What was the total production on the geoPlannerDemandPart? 
	float * gpdProdVol;
	witGetPartProdVol(theWitRun, plannerTopLevelPart.c_str(), &gpdProdVol);
	
	// Account for the amount of feature we built (i.e. ship to the PureOptionBuildDemand)
	// Initialize feasibleFeatureRatio using:
	//  shipped amount and the machine Feature supply (fen5) amount, then incremently add to it
	float * shipVol;
	witGetDemandShipVol( theWitRun, fullWitFeaturePartName.c_str(), fullWitStandaloneFeatureDemandName.c_str(), &shipVol);
	float * fen5supplyVol;
	witGetPartSupplyVol(theWitRun, fullWitFeaturePartName.c_str(), &fen5supplyVol);
	
	
	if (printDataAsPercentage) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
	    if (gpdProdVol[t] < 0.01) 
	      feasibleFeatureRatio[t] = 0.0;
	    else 
	      feasibleFeatureRatio[t] = shipVol[t]/gpdProdVol[t];
	  }
	}
	else {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
	    feasibleFeatureRatio[t] = shipVol[t] + fen5supplyVol[t];
	  }
	}
	witFree (shipVol);
	witFree(fen5supplyVol);

	// Account for the amount of feature that was in supply...
	int nBom;
	witGetOperationNBomEntries(theWitRun, plannerTopLevelPart.c_str(), &nBom);
	int k = 0; // Pulled out of the for below by RW2STL
	for (k=0; k<nBom; k++)  {
	  char * child;
	  witGetBomEntryConsumedPart(theWitRun, plannerTopLevelPart.c_str(), k, &child);
	  std::string childPart(child);
	  if ( !(childPart == fullWitFeaturePartName)){
	    witFree( child);
	    continue;
	  }

	  // We've got a BOM arc between the plannerTopLevelPart and the option
	  // Now, consider all the substitues...
	  int nSubBom;
	  witGetBomEntryNSubsBomEntries(theWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
	  int sj = 0; // Pulled out of the for below by RW2STL
	  for (sj=0; sj<nSubBom; sj++)  {
	    char * sub;
	    float * subProdVol;
	    witGetSubsBomEntryConsumedPart(theWitRun, plannerTopLevelPart.c_str(), k, sj, &sub);
	    // if the subPart is NOT a nullSubstitute then forget it
	    if (! mpHelper.isPartSpecialNullSubstitute(theWitRun, sub)) {
	      witFree(sub);
	      continue;
	    }
	    witGetSubsBomEntryProdVol(theWitRun, plannerTopLevelPart.c_str(), k, sj, &subProdVol);
	    
	    float usageRatio;
	    witGetBomEntryUsageRate(theWitRun, plannerTopLevelPart.c_str(), k, &usageRatio);
	    int early, late;
	    witGetBomEntryEarliestPeriod(theWitRun, plannerTopLevelPart.c_str(), k, &early);
	    witGetBomEntryLatestPeriod(theWitRun, plannerTopLevelPart.c_str(), k, &late);            
	      
	    if (printDataAsPercentage) {
	      for (t=early; t<=late; t++)   {
		if (gpdProdVol[t] > 0.01) 
		  feasibleFeatureRatio[t] += usageRatio * (gpdProdVol[t] - subProdVol[t])/gpdProdVol[t];
	      }
	    }
	    else {
	      for (t=early; t<=late; t++)   {
		feasibleFeatureRatio[t] += usageRatio * (gpdProdVol[t] - subProdVol[t]);
	      }
	    }
	    witFree(sub);
	    witFree(subProdVol);
	  }
	  witFree(child);
	}
	witFree(gpdProdVol);


	mpHelper.populateLeadingStringGPD(plannerPart, geo, leadingString);
	leadingString += ",\"" 	  + featurePart + "\"";
	flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, feasibleFeatureRatio);
	numRecords++;
      }
      
      for (j=0; j<lenDemandList; j++)
	witFree (demandList[j]);
      witFree (demandList);
    }
  }
  delete [] feasibleFeatureRatio;

  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}

  //***ended





#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS

// THIS IS OBSOLTETE, code left around for possible re-use
  // this method writes FEATURE SET report  
void 
LgFrScenarioForSce::printFeatureAnalysisReportViaMultiRoute(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
   std::string partName;

   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Selective Feature/Building Block Ratio" 
		       << fileName);
  }


   long numRecords = 0;

   int t, i;

   std::string plannerTopLevelPart;
   std::string geo;
   std::string mfgOptionPart;
   std::string bbCategory;

   float * feasibleFeatureRatio = new float[nPeriods];


   // Loop once for each part, looking for specialOptionDummy's.  
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitPartName(partList[i]);
     if (mpHelper.isPartSpecialOptionRatioSupply(theWitRun, fullWitPartName, plannerTopLevelPart, 
						 geo, bbCategory, mfgOptionPart))   {
       if (bbCategory.contains("STANDALONE:", std::string::ignoreCase))
	 continue;

       // find the consVol of the specialOptionRatioSupply
       float * orsConsVol;
       witGetPartConsVol(theWitRun, fullWitPartName.c_str(), &orsConsVol);


      // if the user wants data as a percentage of geoPlanner ship vol,
      // then we must get that and do the math.
       if (printDataAsPercentage) {
	 // find the build volume of the geoPLannerDemandPart
	 std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
									  plannerTopLevelPart, geo));
	 float * gpdExecVol;
	 witGetOperationExecVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdExecVol);

	 for (t=0; t<nPeriods; t++)   {
	   if (gpdExecVol[t] < 0.01) 
	     feasibleFeatureRatio[t] = 0.0;
	   else 
	     feasibleFeatureRatio[t] = orsConsVol[t]/gpdExecVol[t];
	 }
	 witFree(gpdExecVol);
       }

       // first print the preamble of the record
       outFile << "\"" << plannerTopLevelPart << "\",\"" << geo 
	       << "\",\"" << mfgOptionPart << "\"";

       if (printDataAsPercentage) 
	 flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);
       else
	 flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, orsConsVol, 4, 15);      
       numRecords++;
       witFree(orsConsVol);      
       }
   }

   delete [] feasibleFeatureRatio;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
#endif




  // this method writes FEATURE SET report  when using Proportional routing approach
void 
LgFrScenarioForSce::printFeatureAnalysisReportViaProportionalRoute(
	 WitRun * const theWitRun,
	 const int nPeriods,
	 const int nOperations,
	 char ** operationList,
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Feasible Selective Feature/Building Block Ratio" << fileName);
  }
  
  
  long numRecords = 0;
  
  int t;
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string bbCategory;
  
  std::string leadingString;  

  int o = 0; 
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitSodName(operationList[o]);
    if (! mpHelper.isOperationSpecialOptionDummy(theWitRun, fullWitSodName, plannerTopLevelPart, geo, bbCategory, mfgOptionPart)) {
      continue;
    }

    // find the execVol of the SOD
    float * sodExecVol;
    witGetOperationExecVol(theWitRun, fullWitSodName.c_str(), &sodExecVol);

    mpHelper.populateLeadingStringGPD(plannerTopLevelPart, geo, leadingString);
    leadingString += ",\""  + bbCategory + "\",\"" + mfgOptionPart + "\"";
    flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, sodExecVol);
    numRecords++;
    witFree(sodExecVol);    
  }
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



  // this method writes FEATURE SET report  when using LP approach
void 
LgFrScenarioForSce::printFeatureAnalysisReport(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
   std::string partName;

   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Selective Feature/Building Block Ratio" 
		       << fileName);
  }


   long numRecords = 0;

   int t, i;

   std::string plannerTopLevelPart;
   std::string geo;
   std::string mfgOptionPart;
   std::string bbCategory;

   float * feasibleFeatureRatio = new float[nPeriods];

   std::string leadingString;

   // Loop once for each part, looking for specialOptionDummy's.  
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitPartName(partList[i]);
     if (mpHelper.isPartSpecialOptionDummy(theWitRun, fullWitPartName, plannerTopLevelPart, 
					   geo, bbCategory, mfgOptionPart))   {
       //         if (sce::findCaseIns(bbCategory, "STANDALONE:") != sce::badIndex)
       //	 continue;

       // find the buildVolume of the specialOptionDummy
       float * sodProdVol;
       witGetPartProdVol(theWitRun, fullWitPartName.c_str(), &sodProdVol);


      // if the user wants data as a percentage of geoPlanner ship vol,
      // then we must get that and do the math.
       if (printDataAsPercentage) {
	 // find the build volume of the geoPLannerDemandPart
	 std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
									  plannerTopLevelPart, geo));
	 float * gpdProdVol;
	 witGetPartProdVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdProdVol);

	 for (t=0; t<nPeriods; t++)   {
	   if (gpdProdVol[t] < 0.01) 
	     feasibleFeatureRatio[t] = 0.0;
	   else 
	     feasibleFeatureRatio[t] = sodProdVol[t]/gpdProdVol[t];
	 }
	 witFree(gpdProdVol);
       }

       // first print the preamble of the record
       leadingString = "\"" 
	 + plannerTopLevelPart + "\",\"" 
	 + geo + "\",\"" 
	 + mfgOptionPart + "\"";


       if (printDataAsPercentage) 
	 flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, feasibleFeatureRatio);
       else
	 flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, sodProdVol);
       numRecords++;
       witFree(sodProdVol);      
       }
   }

   delete [] feasibleFeatureRatio;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



//  ---------------------------------------------------------------------
//  Print Substitute Usage Volumes
//  Generalized procedure: Use it for printing:
//     subUsage, mrpSubUsage, opSubUsage, mrpOpSubUsage
//  As more and more of these sub usage beasts are needed in the future, 
//  keep expanding the boolean arguments (for example isChildACapacity ...)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSubstituteUsageVolume(
	 WitRun * const theWitRun,
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
	 const int nPeriods,      
	 const int nOperations, 
	 char ** opList,        
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "<one of the>  Substitute Usage files" 
		       << fileName);
  }

  // declare an exploder, but define it only if you are looking for a 
  // an MRP based sub usage info.
  LgFrSceBaseExploder * myExploder;
  if (! engineMustBeImplode)
    myExploder = this->exploder();

  // use the correct witRun for all the wit api calling ....
  WitRun *  theRightWitRun;

  if (engineMustBeImplode)
    theRightWitRun = theWitRun;
  else
    theRightWitRun = myExploder->localWitRun();

  std::string subUsageReportMode =  this->setOfParameters().getString("subUsageReportMode");
  bool isDataTransformNecessary =  ( sce::compareStringsCaseIns( subUsageReportMode, "parentprod" ) != 0 );  
  bool transformToPrimary = TRUE;
  if (isDataTransformNecessary) {
    transformToPrimary = ( sce::compareStringsCaseIns( subUsageReportMode ,"primaryCoverage" ) == 0 );  
  }

  long numRecords = 0;
  std::string parentOperationName;
  std::string pdf;

  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];

    // For OpSubUsage and mrpOpSubUsage, we only consider "user-defined" operations
    if (parentMustBeUserDefinedOperation) {
      if (! mpHelper.isOperationUserDefined(theRightWitRun, 
					    fullWitOperationName, 
					    pdf, 
					    parentOperationName))
	continue;
    }

    // Otherwise, for subUsage and mrpSubUsage, we only consider normal part
    else {
      if (! (mpHelper.isOperationNormal(theRightWitRun, 
					fullWitOperationName, 
					pdf, 
					parentOperationName)
	     &&
	     mpHelper.isPartNormal(theRightWitRun,
				   fullWitOperationName))
	  )
	continue;
    }

    float * yieldRate;
    witGetOperationYieldRate(theRightWitRun, fullWitOperationName.c_str(), &yieldRate);

    
    int nBom;
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName.c_str(), &nBom);

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  float * subProdVol;
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, sj, &sub);
	  if (! mpHelper.isPartNormal(theRightWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  std::string subPartname =  mpHelper.partname(sub);
		   
	  if (engineMustBeImplode)
	    witGetSubsBomEntrySubVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
	  else
	    myExploder->subUsageVol(fullWitOperationName, j, sj, &subProdVol);      


	  // transform if necessary 
	  // initialize transformed vector to subProdVol
	  LgFrTimeVecFloat transformedTimeVec( (size_t) nPeriods, subProdVol );
	  if (isDataTransformNecessary) {
	    // we'll need to get consRate, falloutRate and impactPeriods to calculate the
	    // part usage.  IF we transformToPrimary, then we get these attributes off the 
	    // bom entry.   Otherwise, if we transform to sub, we get them off the sub bom entry
	    transformedTimeVec = 0.0;
	    float * consRate;
	    float falloutRate;
	    int * impactPeriod;
	    if (transformToPrimary) {
	      // get bom consumption rate
	      witGetBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, &consRate);
	      // get bom fallout rate
	      witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, &falloutRate);
	      // get bom impact periods
	      witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, &impactPeriod);
	    }
	    else {
	      // get sub bom consumption rate
	      witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &consRate);
	      // get sub bom fallout rate
	      witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &falloutRate);
	      // get sub bom impact periods
	      witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, sj, &impactPeriod);
	    }
	    int t;
	    for(t=0; t<nPeriods; t++) {	      
	      if (impactPeriod[t] != -1 ) {
		transformedTimeVec[impactPeriod[t]] += subProdVol[t] * 
		  consRate[t]/(1.0-falloutRate);
	      }
	    }
	    
	    witFree(impactPeriod);
	    witFree(consRate);
	  }
	  else {   
	    int t;
	    for(t=0; t<nPeriods; t++) {	      
	      transformedTimeVec[t] *= yieldRate[t];
	    }
	  }

	  /*
	  outFile << "\"" << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\"";
	  */
	  std::string leadingString = "\"" 
	    + parentOperationName + "\",\"" 
	    + childPartname + "\",\""
	    + subPartname + "\",\""
	    + pdf  + "\"";
	  int printIfZero = 1;
	  flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, printIfZero, leadingString, transformedTimeVec.data());
	  numRecords++;
	  witFree(sub);
	  witFree(subProdVol);
	}
	witFree(child);
      }
    }
    witFree(yieldRate);
  }

  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



//  ---------------------------------------------------------------------
//  Print Sub DB Dump File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSubDbDumpFile(
	 WitRun * const theWitRun,
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
	 const int nPeriods,      
	 const int nOperations, 
	 char ** opList,        
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "<one of the>  Sub DB Dump" 
		       << fileName);
  }

  // declare an exploder, but define it only if you are looking for a 
  // an MRP based sub usage info.
  LgFrSceBaseExploder * myExploder;
  if (! engineMustBeImplode)
    myExploder = this->exploder();

  // use the correct witRun for all the wit api calling ....
  WitRun *  theRightWitRun;

  if (engineMustBeImplode)
    theRightWitRun = theWitRun;
  else
    theRightWitRun = myExploder->localWitRun();


  long numRecords = 0;
  std::string parentOperationName;
  std::string pdf;

  // Loop once for each operation
  int o = 0; 
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];

    // For OpSubUsage and mrpOpSubUsage, we only consider "user-defined" operations
    if (parentMustBeUserDefinedOperation) {
      if (! mpHelper.isOperationUserDefined(theRightWitRun, 
					    fullWitOperationName, 
					    pdf, 
					    parentOperationName))
	continue;
    }

    // Otherwise, for subUsage and mrpSubUsage, we only consider normal part
    else {
      if (! (mpHelper.isOperationNormal(theRightWitRun, 
					fullWitOperationName, 
					pdf, 
					parentOperationName)
	     &&
	     mpHelper.isPartNormal(theRightWitRun,
				   fullWitOperationName))
	  )
	continue;
    }


    /*  NOTE: 
       Assume that: 
       1)  the operation has one and only one BOP and that the triplets: 
       2)  there is a unique subBomEntry for parent, primary, sub 
    */



    float * yieldRate;
    witGetOperationYieldRate(theRightWitRun, fullWitOperationName.c_str(), &yieldRate);
    
    int nBom;
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName.c_str(), &nBom);

    int j = 0; 
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; 
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, sj, &sub);
	  if (! mpHelper.isPartNormal(theRightWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  
	  std::string subPartname =  mpHelper.partname(sub);
	  
	  // Note that we use subProdVol rather than subVol 
	  float * subVol;
	  if (engineMustBeImplode)
	    witGetSubsBomEntrySubVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subVol);
	  else
	    myExploder->subUsageVol(fullWitOperationName, j, sj, &subVol);      
	  
	  // Initialize all three to subVol
	  LgFrTimeVecFloat parentProd(nPeriods, 0.0);
	  LgFrTimeVecFloat primaryCov(nPeriods, 0.0);
	  LgFrTimeVecFloat subConsumed(nPeriods, 0.0);
	  
	  // Step 1: parentProd
	  //     Done!!   For now, directly use subVol (should finish me on this)
	  
	  
	  float * consRate;
	  float falloutRate;
	  int * impactPeriod;
	  float * subConsRate;
	  float subFalloutRate;
	  int * subImpactPeriod;
	  // get bom consumption rate
	  witGetBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, &consRate);
	  // get bom fallout rate
	  witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, &falloutRate);
	  // get bom impact periods
	  witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, &impactPeriod);
	  // get sub bom consumption rate
	  witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subConsRate);
	  // get sub bom fallout rate
	  witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subFalloutRate);
	  // get sub bom impact periods
	  witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subImpactPeriod);
	  
	  int t;
	  for(t=0; t<nPeriods; t++) {	      
	    parentProd[t] += subVol[t] * yieldRate[t];

	    if (impactPeriod[t] != -1 ) {
	      primaryCov[impactPeriod[t]] += subVol[t] * consRate[t] / (1.0-falloutRate);
	    }
	    
	    if (subImpactPeriod[t] != -1 ) {
	      subConsumed[subImpactPeriod[t]] += subVol[t] * subConsRate[t] / (1.0-subFalloutRate);
	    }
	  }
	  
	  witFree(impactPeriod);
	  witFree(consRate);
	  witFree(subImpactPeriod);
	  witFree(subConsRate);


	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "parentProd\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, parentProd.data(), 0, 15);

	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "primaryCov\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, primaryCov.data(), 0, 15);

	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "subConsumed\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subConsumed.data(), 0, 15);
	  
	  numRecords++;
	  witFree(sub);
	  witFree(subVol);
	}
	witFree(child);
      }
    }
    witFree(yieldRate);
  }
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}








//  ---------------------------------------------------------------------
//  Print Optimization Shadow Prices 
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printShadowPrices(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nParts,
	 char ** partList,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Shadow Prices File" 
		       << fileName);
  }



   long numRecords = 0; 
   long numZeroVec = 0;

   float * shadowPrice;

   // Loop once for each part
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
#ifndef SHADOW_PRICE_DEBUG
     if (! mpHelper.isPartNormal(theWitRun, partList[i]))
       continue;
#endif
     std::string part = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);


     // get the shadowPrice
     witGetPartShadowPrice (theWitRun, partList[i], &shadowPrice);


#if 0
     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (shadowPrice[t] > 0.0001) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       continue;
     }
#endif
	
#ifndef SHADOW_PRICE_DEBUG 
     outFile << "\"" 
	     << part << "\",\"" 
	     << pdf << "\""; 
#else
     outFile << "\"" 
	     << partList[i] << "\""; 
#endif

     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shadowPrice, 0, 15);
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}



//  ---------------------------------------------------------------------
//  Print Interplant Volumes (can be used by implosion or explosion)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printInterplantVolumesFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    if (isThisMrp) {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Interplant Demand File" 
			 << fileName);
    }
    else {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Interplant Orders" 
			 << fileName);
    }

  }



   long numRecords = 0; 
   long numZeroVec = 0;

   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;

   LgFrTimeVecFloat execVol;

   // Loop once for each operation
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
     if (! mpHelper.isOperationSpecialInterplant(theWitRun, opList[o], destination, 
						 destinationPdf, source, sourcePdf))
       continue;

     std::string operationName(opList[o]);

     // get the execVol
     if (isThisMrp)
       execVol = this->interplantMrpExecVol(operationName);
     else
       execVol = this->interplantExecVol(operationName);

     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       continue;
     }
	 
     outFile << "\"" 
	     << destination << "\",\"" 
	     << destinationPdf << "\",\"" 
	     << source    << "\",\"" 
	     << sourcePdf << "\""; 

     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol.data(), 0, 15);
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}



//  ---------------------------------------------------------------------
//  Print AlternatePart Volumes (can be used by implosion or explosion)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printAlternateDbFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    if (isThisMrp) {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Alternate Part (explode) File" 
			 << fileName);
    }
    else {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Alternate Part (implode) File" 
			 << fileName);
    }

  }



   long numRecords = 0; 
   long numZeroVec = 0;

   std::string primePart;
   std::string primePdf;
   std::string altPart;
   std::string altPdf;


   // Loop once for each operation
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
     if (! mpHelper.isOperationSpecialAlternate(theWitRun, opList[o], primePart, 
						    primePdf, altPart, altPdf))
       continue;
     
     std::string operationName(opList[o]);

     // get the execVol
     float * execVol;
     witGetOperationExecVol(theWitRun, opList[o], &execVol);
     
     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       witFree(execVol);
       continue;
     }


     LgFrTimeVecFloat altConsumed(nPeriods, 0.0);


     // should be one and only one bom entry 
     int nbom;
     witGetOperationNBomEntries(theWitRun, opList[o], &nbom);
     assert(nbom == 1);


     // should be one and only one subbom entry 
     int nSubBom;
     witGetBomEntryNSubsBomEntries(theWitRun, opList[o], 0, &nSubBom);
     assert(nSubBom == 1);

     float * consRate;
     float falloutRate;
     // get bom consumption rate
     witGetSubsBomEntryConsRate(theWitRun, opList[o], 0, 0, &consRate);
     // get bom fallout rate
     witGetSubsBomEntryFalloutRate(theWitRun, opList[o], 0, 0, &falloutRate);
	  
     for(t=0; t<nPeriods; t++) {	      
       altConsumed[t] += execVol[t] * consRate[t] / (1.0-falloutRate);
     }
     
     witFree(consRate);
     
     outFile << "\"" 
	     << primePart  << "\",\"" 
	     << primePdf   << "\",\"" 
	     << altPart    << "\",\"" 
	     << altPdf     << "\",\""
	     << "primaryCov\"";
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);

     witFree(execVol);

     outFile << "\"" 
	     << primePart  << "\",\"" 
	     << primePdf   << "\",\"" 
	     << altPart    << "\",\"" 
	     << altPdf     << "\",\""
	     << "altConsumed\"";
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, altConsumed.data(), 0, 15);
     
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}






  //  ---------------------------------------------------------------------
  //  sets the adjusted interplant execVols for  implosion
  //  ---------------------------------------------------------------------
void 
LgFrScenarioForSce::setInterplantOperationsAppDataForImplosion(
							       WitRun * const theWitRun,
							       const int nPeriods,                              
							       const int nOperations,
							       char ** operationList)
{
  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();
  
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have an interplant operation.
    // there should only be one BOM hanging off the ip operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS268E: Interplant operations"
	       << operationName
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the interplant operation's working execVol
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );

    // NOTE: this assert assumes that the mrp has already created the 
    // the appdata.  
    assert ( operationAppDataPtr != 0 );

    float * execVol;
    witGetOperationExecVol(theWitRun, operationName.c_str(), &execVol);

    // now set the execVol
    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, execVol );
    operationAppDataPtr->execVol(workingExecVolTimeVec);

    witFree( execVol ); 
  } 


  // second loop we compute them
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);

    // if the operation isn't an interplant op, then we're not
    // interested in it
    std::string dPart;
    std::string dPdf;
    std::string sPart;
    std::string sPdf;
    if (! mpHelper.isOperationSpecialInterplant(
		       theWitRun, operationName,
		       dPart, dPdf, sPart, sPdf))
      continue;

    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			      (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat execVol = operationAppDataPtr->execVol();
    
    // the only subs on this bom should be to alternative interplant locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s,
				      &subPdfPart );

      // break the subPdfPart name into it's pdf and part pieces
      // to get the interplant operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
					 dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialInterplant( theWitRun, subIpOp,
						    destPart, destPdf,
						    sourcePart, sourcePdf) ) {
	(*sceErrFacility_)("JumperArcError",MclArgList() << operationName << subPdfPart);
      }

      
      // get the execVol of the substitute interplant operation
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpExecVol = subIpOpAppDataPtr->execVol();
      
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the sub vol
      float * subVol;
      witGetSubsBomEntrySubVol( theWitRun, operationName.c_str(), 0, s, &subVol );
      
      // adjust the execVol of the current interplant operation
      // and the execVol of the substitute
      // interplant operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	execVol[t] -= subVol[t];
	subIpOpExecVol[t] += subVol[t] * subUsageRate;
      } // end t
      
      // set substitute interplant operation's adjusted exec vol in
      // the substitute interplant operations appData
      subIpOpAppDataPtr->execVol(subIpOpExecVol);
      
      witFree ( subVol );
      witFree ( subPdfPart );
	
    } // end for s


    // set interplant operation's adjusted exec vol in
    // the interplant operations appData
    operationAppDataPtr->execVol(execVol);
    
  } // end for o

}



LgFrTimeVecFloat
LgFrScenarioForSce::interplantExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );

  return operationAppDataPtr->execVol();
}

LgFrTimeVecFloat
LgFrScenarioForSce::interplantMrpExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );

  return operationAppDataPtr->mrpExecVol();
}



// intiialize the app data's with straight execVols, and then compute them.
void
LgFrScenarioForSce::initializeInterplantOperationsAppData(
							  WitRun * const theWitRun,
							  const int nPeriods,                              
							  const int nOperations,
							  char ** operationList)
{
  LgFrSceBaseExploder * myExploder = myExploder = this->exploder();

  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();

  // first loop we initialize them
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have an interplant operation.
    // there should only be one BOM hanging off the ip operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS269E: Interplant operations"
	       << operationName.c_str()
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the interplant operation's working mrpExecVol
    // to be the operation's mrp exec vol.
    // Store it for further mucking
    // in the interplant operation's app data
    // Caller needs to clean up the appData.
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr == 0 );
    float * mrpExecVol;
    myExploder->mrpExecVol(operationName, &mrpExecVol);

    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, mrpExecVol );
    operationAppDataPtr = new LgFrSceInterplantOpAppData (workingExecVolTimeVec);
    witSetOperationAppData( theWitRun, operationName.c_str(), (void *) operationAppDataPtr );
    witFree( mrpExecVol ); 
  } 



  // second loop we compute them
  for (o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);

    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have an interplant operation.
    // Get the operation's working mrpExecVol
    
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(), (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat mrpExecVol = operationAppDataPtr->mrpExecVol();
    
    // the only subs on this bom should be to alternative interplant locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );

    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s, &subPdfPart );
      
      // break the subPdfPart name into it's pdf and part pieces
      // to get the interplant operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
				     dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialInterplant( theWitRun, subIpOp,
						      destPart, destPdf,
						      sourcePart, sourcePdf) ) {
	std::cerr << "\nJumper Arc Error: Interplant operation "
	     <<  operationName.c_str()
	     << " has a substitute "
	     << subPdfPart
	     << " that is not valid. Contact SCE Support\n" << std::endl;
	exit (1);
	}

      // get the execVol of the substitute interplant operation, subIpOp
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpMrpExecVol = subIpOpAppDataPtr->mrpExecVol();
	
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the sub vol
      float * subUsageVol;
      myExploder->subUsageVol(operationName, 0, s, &subUsageVol );
      
      // adjust the mrpExecVol of the current interplant operation
      // and the mrpExecVol of the substitute
      // interplant operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	mrpExecVol[t] -= subUsageVol[t];
	subIpOpMrpExecVol[t] += subUsageVol[t] * subUsageRate;
      } // end t

      // set substitute interplant operation's adjusted mrp exec vol in
      // the substitute interplant operations appData
      subIpOpAppDataPtr->mrpExecVol(subIpOpMrpExecVol);
      witFree ( subUsageVol );
      witFree ( subPdfPart );
      
    } // end for s


    // set interplant operation's adjusted mrp exec vol in
    // the interplant operations appData
    operationAppDataPtr->mrpExecVol(mrpExecVol);

  } // end for o

}





//  ---------------------------------------------------------------------
//  Print Operation Execution Volume (as determined by implosion)
    // Prints execVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOperationOrdersFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Operation Execution Volume" 
			<< fileName);
   }

   long numRecords = 0;
   long numZeroVec = 0;
   // we're also gonna keep track of the number of unprinted zeroVectors
   // for reconciling the number of input vs output records later.

   // Loop once for each operation
   int nOperations;
   char ** operationList;
   witGetOperations(theWitRun, &nOperations, &operationList);
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
     if (! mpHelper.isOperationNormal(theWitRun, operationList[o], thePdf, theOperation))
	   continue;
     // get the execVol
     float * execVol;
     witGetOperationExecVol(theWitRun, operationList[o], &execVol);
     
     // if the execVol is a Zero vector,
     // then don't print it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       witFree(execVol);
       numZeroVec++;
       continue;
     }
     
     outFile << "\"" 
	     << theOperation << "\",\"" 
	     << thePdf << "\""; 
     
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
     numRecords++;
     witFree(execVol); 
   }
   
   for (o=0; o<nOperations; o++ ) 
     witFree(operationList[o]);
   witFree(operationList);
   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec);
}




//  ---------------------------------------------------------------------
//  Print Operation Demand File (as determined by explosion)
    // Prints mrpExecVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOperationDemandVolFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Operation Demand " 
			<< fileName);
   }

   LgFrSceBaseExploder * myExploder = this->exploder();          

   long numRecords = 0;
   long numZeroVec = 0;
   // we're also gonna keep track of the number of unprinted zeroVectors
   // for reconciling the number of input vs output records later.

   // Loop once for each operation
   int nOperations;
   char ** operationList;
   witGetOperations(theWitRun, &nOperations, &operationList);
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
     if (! mpHelper.isOperationNormal(theWitRun, operationList[o], thePdf, theOperation))
	   continue;
     // get the execVol
     float * mrpExecVol;
     myExploder->mrpExecVol(operationList[o], &mrpExecVol);
     
     // if the execVol is a Zero vector,
     // then don't print it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (mrpExecVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       witFree(mrpExecVol);
       numZeroVec++;
       continue;
     }
     
     outFile << "\"" 
	     << theOperation << "\",\"" 
	     << thePdf << "\""; 
     
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpExecVol, 0, 15);
     numRecords++;
     witFree(mrpExecVol); 
   }
   
   for (o=0; o<nOperations; o++ ) 
     witFree(operationList[o]);
   witFree(operationList);
   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec);
}




//  ---------------------------------------------------------------------
//  Print Backlog schedule         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBacklogSchedule(
					       WitRun * const theWitRun,   // WIT environment   
					       const int nPeriods,         // Number of periods 
					       const int nParts,           // Number of parts   
					       char ** partList,           // List of part names
					       std::string fileName,
					       LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Backlog Response" 
		       << fileName);
  }

  long numRecords = 0;

  float * shipVol;
  float * demandVol;
  float blog;
  int i, t;

  int nDemands;
  char ** dList;
  int j;


  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string partname = mpHelper.partname(partList[i]);
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
	
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	// demandVol
	witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	// backlogVol
	blog = 0.0;
	for (t=0; t<nPeriods; t++)    {
	  blog += (demandVol[t] - shipVol[t]);
	  shipVol[t] = blog;
	}
	
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
	witFree(shipVol);
	witFree(demandVol);
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
}


//  ---------------------------------------------------------------------
//  Print Supply Response File 
// SCE 6.1: this method can be called with integer flag tinpIndpOrBoth set to 1,2, or 3
// tinpIndpOrBoth Flag => 1 means TINP only, 2 means INDP only, 3 means both
//    with multiAttribute demands, use 3 which means TINP and INDP are printed together in one file (6.1)
//    for sce5 back compatibility, call this method twice, once for TINP and the other for INDP
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 int  tinpIndpOrBoth,        // Flag => 1 means TINP only, 2 means INDP only, 3 means both
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  
  std::ofstream outFile(fileName.c_str());
  if (outFile.fail()) 
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Supply Response" << fileName);


  long numRecords = 0;
  float * shipVol;
  int i;
  int nDemands;
  char ** dList;
  int j;
  
  // for both indp and tinp/gpd outputs, we will always print zero records for vectors, never print zero's for dated
  bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");  
  bool printIfZero;
  if (useDatedDemands) 
    printIfZero = false;
  else
    printIfZero = true;

  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;


    // TINP (ie, GPD) demands
    if ( (tinpIndpOrBoth == 1) || (tinpIndpOrBoth == 3))   {
      if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i], plannerPart, geo)) {
	std::string partname = mpHelper.partname(partList[i]);
	witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
	for (j =0; j<nDemands; j++)  {
	  witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	  flatFileMgr_.writeGpdDemandRecord(outFile, mpHelper, theCal, partname, dList[j], nPeriods, shipVol, printIfZero, 0, 15);
	  witFree(shipVol); 
	  witFree(dList[j]);
	  numRecords++;
	}
	witFree(dList);
      }
    }

    // INDP demands
    if ( (tinpIndpOrBoth == 2) || (tinpIndpOrBoth == 3))   {   
      if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
	std::string partname = mpHelper.partname(partList[i]);
	std::string pdf = mpHelper.pdf(partList[i]);
	witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
	for (j =0; j<nDemands; j++)  {
	  witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	  
#ifdef ENABLE_NEGATIVE_DEMANDS
	  // adjust shipVol for negative demand
	  LgFrSceDemandAppData * demandAppDataPtr;
	  witGetDemandAppData(theWitRun, partList[i], dList[j], (void **) &demandAppDataPtr);
	  if (demandAppDataPtr->doesDemandHaveNegativeValues()) {
	    LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();
	    int t = 0;
	    for (t=0; t<nPeriods; t++) {
	      if (demandVolTVF[t] < 0) {
		shipVol[t] += demandVolTVF[t];
	      }
	    }
	  }
#endif
	  

	  flatFileMgr_.writeDemandRecordINDP(outFile, mpHelper, theCal, partname, pdf, dList[j], nPeriods, shipVol, printIfZero, 0, 15);
	  witFree(shipVol); 
	  witFree(dList[j]);
	  numRecords++;
	}
	witFree(dList);
      }
    }
  }
    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}


// this is the old way for backup
#ifdef SCE5 
void 
LgFrScenarioForSce::printSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Supply Response" 
		       << fileName);
  }

  long numRecords = 0;
  
  float * shipVol;
  int i;
  
  int nDemands;
  char ** dList;
  int j;
  
  
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      std::string partname = mpHelper.partname(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
	
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
	witFree(shipVol); 
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
#endif



// SCE5

//  ---------------------------------------------------------------------
//  Print Part Shipment Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printIndepSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Independent Supply Response" 
		       << fileName);
  }

  long numRecords = 0;
  
  float * shipVol;
  int i;
  
  int nDemands;
  char ** dList;
  int j;
  
  
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
      std::string partname = mpHelper.partname(partList[i]);
      std::string pdf = mpHelper.pdf(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);

#ifdef ENABLE_NEGATIVE_DEMANDS
	// adjust shipVOl for negative demand
	LgFrSceDemandAppData * demandAppDataPtr;
	witGetDemandAppData(theWitRun, partList[i], dList[j], (void **) &demandAppDataPtr);
	if (demandAppDataPtr->doesDemandHaveNegativeValues()) {
	  LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    if (demandVolTVF[t] < 0) {
	      shipVol[t] += demandVolTVF[t];
	    }
	  }
	}
#endif

	// for both indp and tinp/gpd outputs, we will always print zero records for vectors, never print zero's for dated
	bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");  
	bool printIfZero;
	if (useDatedDemands) 
	  printIfZero = false;
	else
	  printIfZero = true;

	flatFileMgr_.writeDemandRecord(outFile, mpHelper, theCal, partname, pdf, dList[j], nPeriods, shipVol, printIfZero, 0, 15);


	witFree(shipVol); 
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}




//  ---------------------------------------------------------------------
//  Print Part Shipment Information in human readable format        
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printHumanReadableSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Formatted Output" 
		       << fileName);
  }

   long numRecords = 0;
   float * witVector;
   float * witVector1;
   float   blog;
   int i, t;
   std::string demandName("WW");
   int nDemands;
   char ** dList;
   int j;

// print some dates

   outFile << "             ";
   for (t=0; t<nPeriods; t++)  {
       LgFrDatetime thisDate(theCal.periodStart(t));
       std::string theDate("    " + thisDate.getDateAsString() + "   ");
       outFile << theDate;
   }
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
       std::string parti(partList[i]);
       std::string partname = mpHelper.partname(parti);
       std::string plannerPart;
       std::string geo;
       if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						       plannerPart, geo)) {
	 witGetPartDemands(theWitRun, parti.c_str(), &nDemands, &dList);
	 for (j =0; j<nDemands; j++)  {
	   
	   outFile << "\n" << partname << " - " << dList[j] << ":\n";
	   
// demand Vol
	   outFile << "    Demand";
	   witGetDemandDemandVol(theWitRun, parti.data(), dList[j], &witVector);
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector, 0, 15);
	   numRecords++;

// shipVol
	   outFile << "    Supply";
	   witGetDemandShipVol(theWitRun, parti.c_str(), dList[j], &witVector1);
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector1, 0, 15);
	   numRecords++;

// backlogVol
	   blog = 0.0;
	   outFile << "     Delta";
	   for (t=0; t<nPeriods; t++)    {
	     blog += (witVector1[t] - witVector[t]);
	     witVector[t] = blog;
	   }
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector, 0, 15);
	   numRecords++;

	   witFree(witVector); 
	   
	   witFree(witVector1); 
	   witFree(dList[j]);
	   
	 }
	 witFree(dList);
       }
   }
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}

//  ---------------------------------------------------------------------
//  Print GEO Supply By PDF  Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printGeoSourceDebugFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
   std::string geo;
   std::string plannerPart;

   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Geo Source Debug" 
		       << fileName);
  }

   long numRecords = 0;

   int i;
   std::string * sourceList = new std::string[nPeriods];


   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     // only look at geoPlannerDemandParts
     if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						      partList[i], plannerPart, geo))
       continue;

     int periodWithNoSource = determineGeoToPdfSourceVector(theWitRun, 
							    mpHelper,
							    partList[i],
							    sourceList);
     

     outFile << "\"" << plannerPart << "\",\"" << geo << "\"";
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++)
       outFile << ",\"" << sourceList[t]     << "\"";
     outFile << "\n";
     numRecords++;

     if (periodWithNoSource > -1) {
       // error
       (*sceErrFacility_)("GeoDemandNotSourced",MclArgList() << geo << plannerPart << periodWithNoSource);
     }
   }
   delete [] sourceList;

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
}

//  ---------------------------------------------------------------------
//  Print Part Build Schedule 
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBuildSchedule(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Build Schedule" 
		       << fileName);
  }

   long numRecords = 0; 
   float * execVol;

   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     if (! mpHelper.isPartBuildable(theWitRun, partList[i]))
       continue;
     std::string partname = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
     outFile << "\"" 
	     << partname << "\",\"" 
	     << pdf << "\"";

     // note: the opeation is guaranteed to exist
     // by definition of isPartBuildable
     witGetOperationExecVol(theWitRun, partList[i], &execVol);
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
     witFree(execVol); 
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);

}



//  ---------------------------------------------------------------------
//  Print critical parts list
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printDebugCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // rollover handled differently
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 LgFrSceCritList & theCritList)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Critical Parts List" 
		       << fileName);
  }

  bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");

  long numRecords = 0;
  
  // Loop once for each part.  
  int i = 0; 
  for (i=0; i<theCritList.getLength(); i++ ) {
    std::string part = theCritList.getPart(i);
    int pd = theCritList.getPeriod(i);
    if (! mpHelper.isPartNormal(theWitRun, part))   {
      outFile << "\"" 
	      << part << "\",\"-----\",";
      
    }
    else {
      std::string partname = mpHelper.partname(part);
      std::string pdf = mpHelper.pdf(part);
      outFile << "\"" 
	      << partname << "\",\"" 
	      << pdf << "\",";
    }

    if (useDatedDemands) {
      outFile << theCal.yyyymmdd(theCal.periodStart(pd)) << ","
	      << i << "\n";
    }
    else {
      outFile << pd << ","
	      << i << "\n";
    }
    numRecords++;
  }
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
}




//  ---------------------------------------------------------------------
//  Print critical parts list
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // rollover handled differently
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 LgFrSceCritList & theCritList)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Critical Parts List" 
		       << fileName);
  }

  bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");

  long numRecords = 0;
  
  // Loop once for each part.  
  int i = 0; 
  for (i=0; i<theCritList.getLength(); i++ ) {
    std::string part = theCritList.getPart(i);
    int pd = theCritList.getPeriod(i);
    if (! mpHelper.isPartNormal(theWitRun, part))
      continue;
    // comeback

    std::string partname = mpHelper.partname(part);
    std::string pdf = mpHelper.pdf(part);
    outFile << "\"" 
	    << partname << "\",\"" 
	    << pdf << "\",";

    if (useDatedDemands) {
      outFile << theCal.yyyymmdd(theCal.periodStart(pd)) << ","
	      << i << "\n";
    }
    else {
      outFile << pd << ","
	      << i << "\n";
    }
    numRecords++;
  }
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
}






//  ---------------------------------------------------------------------
//  Print pegged critical parts list
//  --------------------------------------------------------------------- 
// SCE 6.1 Version: prints indp and tinp to a common file.   Must also derive GPD from Special Feature Demands.
// Note we could report a different attribute ??? For pegging purposes (???)   Especially if coming from a feature.
// Why not give the feature number too ... can put it in partClass (?)
void 
LgFrScenarioForSce::printPeggedCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // only works for heuristic allocation
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Pegged Critical Parts List" 
		       << fileName);
  }


#ifdef CRIT_PEG_DEBUG
  std::ofstream outFilePCDump("pegCritDump.out");
  if (outFilePCDump.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Pegged Critical Parts List DEBUG_DUMP" 
		       << "pegCritDump.out");
  }
#endif



  long numRecords = 0;

  // Loop once for each part.  
  
  // PEG_CRIT_LIST
  int      lenLists;
  char **  critPartNameList;
  int *    critPerList;
  char **  demPartNameList;
  char **  demandNameList;
  int *    shipPerList;
  
  witGetPgdCritList (theWitRun,
		     &lenLists,
		     &critPartNameList,
		     &critPerList,
		     &demPartNameList,
		     &demandNameList,
		     &shipPerList);

  bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");
  std::string plannerPart;

  int i = 0; 
  for (i=0; i<lenLists; i++ ) {
    
    if (! mpHelper.isPartNormal(theWitRun, critPartNameList[i])) {
#ifdef CRIT_PEG_DEBUG
      outFilePCDump << (int) 99 << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif
      witFree(critPartNameList[i]);
      witFree(demPartNameList[i]);
      witFree(demandNameList[i]);
      continue;
    }

    std::string critPartName = mpHelper.partname(critPartNameList[i]);
    std::string critPdf = mpHelper.pdf(critPartNameList[i]);


    // figure out how to write demand name
    // Use LeadingString functions from mpHelper
    
    std::string witPartName = demPartNameList[i];
    std::string witDemandName = demandNameList[i]; 
    std::string leadingString; 
    
    // Case 1: normal independend demand
    if (mpHelper.isPartNormal(theWitRun, demPartNameList[i])) {
      std::string demandedPartName = mpHelper.partname(demPartNameList[i]);
      std::string demandedPdf      = mpHelper.pdf(demPartNameList[i]);
      mpHelper.populateLeadingStringINDP(demandedPartName, demandedPdf, witDemandName, leadingString);
      if (useDatedDemands)  {
	std::string demandDate = theCal.yyyymmdd(theCal.periodStart(shipPerList[i]));
	leadingString += "," + demandDate;
      }
    }
    
    // Case 2: normal GPD  demand
    else if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, 
							demPartNameList[i],
							plannerPart, 
							witDemandName)) {
      mpHelper.populateLeadingStringGPD(plannerPart, witDemandName, leadingString);
    }
    
    // Case 3: special Feature Demand
    else {
      std::string featurePart, plannerPart, demandedPdf;
      if (mpHelper.isOperationSpecialFeature(theWitRun, 
					     demPartNameList[i],
					     witDemandName,    
					     plannerPart,    
					     demandedPdf,    
					     featurePart)) {

	mpHelper.populateLeadingStringGPD(plannerPart, witDemandName, leadingString);	
      }
    }


    // Regardless of demand type, append on the critPart and critPdf to leadingString
    leadingString +=  ",\"" 
      + critPartName + "\",\"" 
      + critPdf + "\"";

    if (useDatedDemands)  {
      // convert pds to dates
      //      shipPerList[i];  critPerList[i];
      std::string demandDate = theCal.yyyymmdd(theCal.periodStart(shipPerList[i]));
      std::string critDate = theCal.yyyymmdd(theCal.periodStart(critPerList[i]));
      outFile << leadingString << "," << demandDate << "," << critDate << "," << i << "\n";
    }
    else {
      outFile << leadingString << "," << shipPerList[i] << "," << critPerList[i] << "," << i << "\n";
    }



#ifdef CRIT_PEG_DEBUG
      outFilePCDump << isItBox << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif

    witFree(critPartNameList[i]);
    witFree(demPartNameList[i]);
    witFree(demandNameList[i]);
  }

  witFree(critPartNameList);
  witFree(critPerList);
  witFree(demPartNameList);
  witFree(demandNameList);
  witFree(shipPerList);

  outFile.close();

#ifdef CRIT_PEG_DEBUG
  outFilePCDump.close();
#endif
  
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName, numRecords,000,numRecords); 
}






//  ---------------------------------------------------------------------
//  Print pegged critical parts list
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printPeggedCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // only works for heuristic allocation
	 std::string fileNameBox,
	 std::string fileNameIndp,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFileBox(fileNameBox.c_str());//, ios::out, 0666);
  if (outFileBox.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Pegged Critical Parts List" 
		       << fileNameBox);
  }

  std::ofstream outFileIndp(fileNameIndp.c_str());//, ios::out, 0666);
  if (outFileIndp.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Independent Pegged Critical Parts List" 
		       << fileNameIndp);
  }

#ifdef CRIT_PEG_DEBUG
  std::ofstream outFilePCDump("pegCritDump.out");
  if (outFilePCDump.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Pegged Critical Parts List DEBUG_DUMP" 
		       << "pegCritDump.out");
  }
#endif



  long numRecordsBox = 0;
  long numRecordsIndp = 0;

  // Loop once for each part.  
  
  // PEG_CRIT_LIST
  int      lenLists;
  char **  critPartNameList;
  int *    critPerList;
  char **  demPartNameList;
  char **  demandNameList;
  int *    shipPerList;
  
  witGetPgdCritList (theWitRun,
		     &lenLists,
		     &critPartNameList,
		     &critPerList,
		     &demPartNameList,
		     &demandNameList,
		     &shipPerList);

  int i = 0; 
  for (i=0; i<lenLists; i++ ) {
    
    if (! mpHelper.isPartNormal(theWitRun, critPartNameList[i])) {
#ifdef CRIT_PEG_DEBUG
      outFilePCDump << (int) 99 << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif
      witFree(critPartNameList[i]);
      witFree(demPartNameList[i]);
      witFree(demandNameList[i]);
      continue;
    }

    std::string critpartname = mpHelper.partname(critPartNameList[i]);
    std::string critpdf = mpHelper.pdf(critPartNameList[i]);


    // figure out how to write demand name
    // if it's normal independend demand (non-GPD, non-special), then print part, pdf, demandID
    // if it's GPD, then print plannerpart, demandSourcePdf, geo
    // if it's special feature part, then map it to a GPD and print plannerpart, demandSourcePdf, geo


    std::string demandedPartName = demPartNameList[i];
    std::string demandedPdf = "";
    std::string demandedCust = demandNameList[i];

    bool isItBox = 0;

    // Case 1: normal independend demand
    if (mpHelper.isPartNormal(theWitRun, demPartNameList[i])) {
      demandedPartName = mpHelper.partname(demPartNameList[i]);
      demandedPdf      = mpHelper.pdf(demPartNameList[i]);
      isItBox = 0;
    }

    // Case 2: normal GPD  demand
    else if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, 
							demPartNameList[i],
							demandedPartName, 
							demandedCust)) {
      int late;
      float offset;
      std::string fName="internal operation: printPeggedCriticalList";
      std::string dLine="noLine";
      long lineNo = 0;

      std::string demandedPartPdf = mpHelper.demandSource( theWitRun, 
							   demandedPartName,
							   demandedCust,
							   shipPerList[i],
							   late,
							   offset,
							   fName, 
							   dLine, 
							   lineNo, 
							   OPTIONAL_WITH_MESSAGE);
      demandedPartName = mpHelper.partname(demandedPartPdf);
      demandedPdf      = mpHelper.pdf(demandedPartPdf);
      isItBox = 1;
    }

    // Case 3: special Feature Demand
    else {
      std::string featurePart;
      if (mpHelper.isOperationSpecialFeature(theWitRun, 
					     demPartNameList[i],
					     demandedCust,    
					     demandedPartName,    
					     demandedPdf,    
					     featurePart)) {
	
	//	demandedPartName = demPartNameList[i];
	//	demandedPdf = "";
	//	demandedCust = demandNameList[i];
	//	demandedPdf = "";
	//	demandedCust = demandNameList[i];
	isItBox = 1;
      }
    }

    if (isItBox) {
      outFileBox << "\"" << demandedPartName << "\","
		 << "\"" << demandedCust << "\","
		 << "\"" << critpartname << "\","		 << "\"" << critpdf << "\","
		 << shipPerList[i] << ","
		 << critPerList[i] << ","
		 << i << "\n";
      numRecordsBox++;
    }
    else {
      // do it in flatfileMgr!

      flatFileMgr_.writePegCritListRecord(outFileIndp, mpHelper, theCal,
					  demandedPartName,
					  demandedPdf,
					  demandedCust,
					  critpartname,
					  critpdf,
					  shipPerList[i], 
					  critPerList[i], 
					  i);

      //      outFileIndp << "\"" << demandedPartName << "\","
      //	  << "\"" << demandedPdf << "\","
      //	  << "\"" << demandedCust << "\","
      //	  << "\"" << critpartname << "\","
      //	  << "\"" << critpdf << "\","
      //	  << shipPerList[i] << ","
      //	  << critPerList[i] << ","
      //	  << i << "\n";
      numRecordsIndp++;
    }


#ifdef CRIT_PEG_DEBUG
      outFilePCDump << isItBox << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif

    witFree(critPartNameList[i]);
    witFree(demPartNameList[i]);
    witFree(demandNameList[i]);
  }

  witFree(critPartNameList);
  witFree(critPerList);
  witFree(demPartNameList);
  witFree(demandNameList);
  witFree(shipPerList);

  outFileBox.close();
  outFileIndp.close();
#ifdef CRIT_PEG_DEBUG
  outFilePCDump.close();
#endif
  
  flatFileMgr_.sceIOLogManager().printOutputLog(fileNameBox, numRecordsBox,000,numRecordsBox); 
  flatFileMgr_.sceIOLogManager().printOutputLog(fileNameIndp, numRecordsIndp,000,numRecordsIndp); 
}






void
LgFrScenarioForSce::printModelStructureOutputs()
{
    int nPeriods;                         //  Number of periods in model  
    int nParts;                           //  Number of parts in model     
    char ** partList;                     //  List of parts in model       
    int i;                                //  Loop index                  
    //    int nOperations;
    //    char ** opList;                     //  List of parts in model       


    WitRun * const theWitRun = lastProblemSolved().witRun();
    LgFrCalendar & theCal = calendar();
    LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
      
    witGetParts( theWitRun, &nParts, &partList );
    //    witGetOperations( theWitRun, &nOperations, &opList );
    nPeriods = theCal.nPeriods();

    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();

   // Lowest Level Non Pcf File: optional
   if (setOfParameters.getBool("printLowestLevelNonPcfFile"))  {
     std::string lowestLevelNonPcfFileName =
       setOfParameters.getString("lowestLevelNonPcfFileName");
     printLowestLevelNonPcfParts(theWitRun, mpHelper, nPeriods, nParts, partList,
				 lowestLevelNonPcfFileName);
   }


   // PCF Bogons File: optional
   if (setOfParameters.getBool("printPcfBogonsFile"))  {
     std::string pcfBogonsFileName =
       setOfParameters.getString("pcfBogonsFileName");
     printBogonParts(theWitRun, mpHelper, nPeriods, nParts, partList,
		     pcfBogonsFileName);
   }


   // *************************************    
   // Calculate Value Add Costs 
   // *************************************
   if (setOfParameters.getBool("calculateVac"))  {
     std::cout << "Calculating Value Added Costs  ..." << std::endl;                
     std::string vacFileName = setOfParameters.getString("vacFileName");
     std::string compCostFileName = setOfParameters.getString("compCostFileName");
     calculateAndPrintValueAddedCosts(theWitRun, mpHelper, nPeriods, nParts, partList,
				      vacFileName, compCostFileName);
   }
   






   // Cleanup memory
   for ( i=0; i<nParts; i++) 
      witFree(partList[i]);
   witFree( partList );

   //   for (int o=0; o<nOperations; o++) 
   //      witFree(opList[o]);
   //   witFree( opList );
}



void
LgFrScenarioForSce::runImplosion(
				 LgFrScenarioForSceSmartPointer scenSceSP
				 )
{
  // Set up the critical list data
  LgFrSceCritList & theCritList = sceCritList();
  WitRun * theWitRun = lastProblemSolved().witRun();
  LgFrCalendar * theCal = &calendar();
  LgFrMultiPlantHelper * mpHelper = &multiPlantHelper();
  const std::string & engine = getEngine();

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  bool doPegging = setOfParameters.getBool("doPegging");
   
  if (engine == "heuristic" || engine == "rollover" ) {

    LgFrSceHeurEngineMgr heurEngineMgr(
				       scenSceSP,
				       theWitRun, 
				       theCal,
				       mpHelper,
				       engine);
    
    heurEngineMgr.implode(theCritList);
    if (doPegging)
      printPIPData(theWitRun,0);
  }

  if (engine == "heuralloc" ) {

    std::string usageName("implosion");
    LgFrSceAllocationEngineMgr allocEngineMgr(
					 scenSceSP,
					 theWitRun, 
					 mpHelper,
					 usageName);
    allocEngineMgr.implode(theCritList);

    if (doPegging)
      printPIPData(theWitRun,0);
  }
     
   // ===================================
   // === Run the Optimization engine ===
   // ===================================
  if (engine == "optimization" ) {
    LgFrSceOptEngineMgr optEngineMgr(theWitRun,
				     theCal,
				     mpHelper,
				     scenSceSP);
     
     optEngineMgr.implode(theCritList);
     if (doPegging)
       printPIPData(theWitRun,0);
  }
}

void
LgFrScenarioForSce::machineFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);
  fssMgr.machineFss();
}



void
LgFrScenarioForSce::generalSetFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);

  fssMgr.generalSetFss();

}


void
LgFrScenarioForSce::singletonFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);
  fssMgr.singletonFss();    
}



// ===============================
// ====== Capacity Usage Schedule ====
// ===============================
void
LgFrScenarioForSce::printCapUsageVolume(WitRun * const theWitRun, bool isItMrp)
{
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();

  std::string  capacityUsageFileName = setOfParameters.getString("capacityUsageFileName");
  int goodRec = 0;

  if (isItMrp) {
    capacityUsageFileName = setOfParameters.getString("mrpCapacityUsageFileName");
  }

  std::string leadingString;

  int nPeriods;

  if (isItMrp) 
    std::cout << "... printing MRP capacity Usage data ..." << std::endl;    
  else
    std::cout << "... printing capacity Usage data ..." << std::endl;    

    
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  char * capName;


  std::ofstream cUsFile;
  
  // Now open the capUsage OUTPUT file
  cUsFile.open(capacityUsageFileName.c_str(), std::ofstream::out);
  if (cUsFile.fail()) {
    std::string fileErrorString("Capacity Usage File");
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << fileErrorString 
		       << capacityUsageFileName);
  }
  



  // Loop over parts to find capacity
  int i = 0;
  for(i=0; i<nParts; i++){
    capName = partList[i];

    if (! mpHelper.isPartNormalCapacity(theWitRun, capName))  {
      witFree(partList[i]);
      continue;
    }
    
    int nCbom;
    witGetPartNConsumingBomEntries(theWitRun, capName, &nCbom);
    int b,c;
    char * operation;
    for (c=0; c<nCbom; c++) {
      witGetPartConsumingBomEntry(theWitRun, capName, c, &operation, &b);

      float * execVol;
      float * consRate;
      //      float * yieldRate;
      int * impactPeriod;
      float falloutRate;
      witGetOperationExecVol ( theWitRun, operation,&execVol );
      //      witGetOperationYieldRate ( theWitRun, operation,&yieldRate );
      witGetBomEntryConsRate ( theWitRun, operation, b, &consRate );
      witGetBomEntryFalloutRate ( theWitRun, operation, b, &falloutRate );
      witGetBomEntryImpactPeriod ( theWitRun, operation, b, &impactPeriod );
      LgFrTimeVecFloat capUsageVol(nPeriods, 0.0);
      int execPeriod;
      for (execPeriod=0; execPeriod<nPeriods; execPeriod++) {
	int consPeriod = impactPeriod[execPeriod];
	if ( consPeriod == -1 ) 
	  continue;

	capUsageVol[consPeriod] += execVol[execPeriod] * consRate[execPeriod]/(1.0-falloutRate);
      }

      leadingString = "\""
	+ mpHelper.partname(operation) + "\",\""
	+ mpHelper.partname(capName) + "\",\""
	+ mpHelper.pdf(capName) + "\"";
      flatFileMgr_.writeFloatVecToStream(this->calendar(), cUsFile, nPeriods, 0, leadingString, capUsageVol.data());


      goodRec++;
      
      witFree(execVol);
      witFree(consRate);
      witFree(impactPeriod);
      //      witFree(yieldRate);
      witFree(operation);
    }
    witFree(partList[i]);
  }
  witFree(partList);

  cUsFile.close();
}
    






// ===============================
// ====== PIP  Utilitiies ====
// ===============================
void
LgFrScenarioForSce::loadPIPDataIntoAppData(WitRun * const theWitRun)
{
  int nPeriods;
  char  *partName, *demandName;

  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();

  std::cout << "... collecting PIP information ..." << std::endl;    
    
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;

  bool PegSubUsageToPrimary = this->setOfParameters().getBool("PegSubUsageToPrimary");
  bool supplierPerspectiveInterplantPeg = this->setOfParameters().getBool("supplierPerspectiveInterplantPeg");

  // Loop over parts to get demands
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      // Now for some fancy trickery !!!
      // if the part is a special feature part, then we must map the consVol over to 
      //     the GPD appData
      int isDemandSpecial = 0;
      isDemandSpecial = mpHelper.isDemandSpecialPureOptionBuildDemand(theWitRun, partName, demandName, pp, geo);
      if (! isDemandSpecial) {
	isDemandSpecial = mpHelper.isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
      }
 

      // get teh demandAppData, or create a new one if it doesn't exist.
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;

      // if the demand is a specialFeaturePart then get the gpd's appdata
      if (isDemandSpecial) {
	// get a witPartName for the GPD
	fullWitGPDPartName = mpHelper.geoPlannerDemandPartName(pp, geo);

	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
			   (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
			       (void *) demandAppDataPtr );
	}
      }
      else {
	witGetDemandAppData( theWitRun, partName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, partName, demandName,  
			       (void *) demandAppDataPtr );
	}
      }

#ifdef DEBUG_DUMP_FOR_PEGGING
      
      if (isDemandSpecial) {
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "PIP supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
      }
      
      std::cout << "(before)PIPConsVolSched (" << partList[i] << "," << dList[j] << std::endl;
      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << "(before)PIPSupplyVolSched (" << partList[i] << "," << dList[j] << std::endl;
      demandAppDataPtr->PIPSupplyVolSched().print();

      std::cout << std::endl;

#endif

      // Get demands PIP consVol and directly store in appData
      ScePIP::getDemandConsVolPIP(theWitRun,
				  partList[i],
				  dList[j],
				  0,
				  nPeriods-1,
				  demandAppDataPtr->PIPConsVolSched(),
				  WitTRUE,
				  PegSubUsageToPrimary);

      // Get  PIP supplyVol and directly store in appData
      ScePIP::getSupplyVolPIP(theWitRun,
			      partList[i],
			      dList[j],
			      0,
			      nPeriods-1,
			      demandAppDataPtr->PIPSupplyVolSched());

      // Get demands PIP prodVol and directly store in appData
      ScePIP::getProdVolPIP(theWitRun,
			    partList[i],
			    dList[j],
			    0,
			    nPeriods-1,
			    demandAppDataPtr->PIPProdVolSched());


      // Get PIP sideVol  and directly store in appData
      ScePIP::getSideVolPIP(theWitRun,
			    partList[i],
			    dList[j],
			    0,
			    nPeriods-1,
			    demandAppDataPtr->PIPSideVolSched());



      // Get demands PIP  execVol and directly store in appData
      ScePIP::getDemandExecVolPIP(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->PIPExecVolSched());

      ScePIP::getDemandInterplantVolPIP(theWitRun,
					&mpHelper,
					partList[i],
					dList[j],
					0,
					nPeriods-1,
					demandAppDataPtr->PIPInterplantVolSched(),
					supplierPerspectiveInterplantPeg);



#ifdef DEBUG_DUMP_FOR_PEGGING
      std::cout << "ConsVolPIP(after) JP's Get" << std::endl;
      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << "SupplyVolPIP(after) JP's Get" << std::endl;
      demandAppDataPtr->PIPSupplyVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif

      witFree(dList[j]);
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);

}




LgFrMultiPlantHelper&
LgFrScenarioForSce::multiPlantHelper()
{
  return multiPlantHelper_;
}

LgFrSceCritList &
LgFrScenarioForSce::sceCritList()
{
  return critList_;
}


//  ---------------------------------------------------------------------
//  Print Part Component  Information
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printDummyPartDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Debug" 
		       << fileName);
  }

  LgFrCalendar theCal = this->calendar();
  
  long numRecords = 0;
  
  float * supplyVol;
  float * cycleTime;
  witBoolean * execFlag;
  float * mrpConsVol;
  
  float * reqVol;
  float * mrpExcessVol;      
  float * mrpResidualVol;      
  
  float * excessVol;      
  float * residualVol;      
  float * stockVol;      
  float * scrapVol;      
  float * consVol;      
  float * prodVol;
  
   witAttr category;
   witBoolean operationExists;

   int i;

  int nonZeroOnly = 0;
  int alwaysPrint = 1;

   LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
   LgFrSceBaseExploder * myExploder = this->exploder();
   bool doImplode = setOfParameters.getBool("doImplode");
   
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {

     std::string fullPartName(partList[i]);
     // this time, exclude the real parts
     if (mpHelper.isPartNormal(theWitRun, fullPartName))
       continue;

     witGetPartCategory(theWitRun, fullPartName.c_str(), &category);

     witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVol);

     if (category == WitPRODUCT)
       witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);

     witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
     if (operationExists) 
       witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);

     myExploder->mrpConsVol(partList[i], &mrpConsVol);
     myExploder->reqVol(partList[i], &reqVol);
     myExploder->mrpExcessVol(partList[i], &mrpExcessVol);
     myExploder->mrpResidualVol(partList[i], &mrpResidualVol);

     if (doImplode) {
       witGetPartExcessVol(theWitRun, fullPartName.c_str(), &excessVol);
       witGetPartResidualVol(theWitRun, fullPartName.c_str(), &residualVol);
       if (category != WitCAPACITY) 
	 witGetPartStockVol(theWitRun, fullPartName.c_str(), &stockVol);
       witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);
       witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
       if (category == WitPRODUCT)
	 witGetPartProdVol(theWitRun, fullPartName.c_str(),  &prodVol);
     }
       
     // ==========================
     // PRINT everything down here
     // ==========================
     std::string pn(fullPartName);
     std::string pdf(mpHelper.pdf(fullPartName));
     
     numRecords += printDbDumpRec(pn, pdf, "supplyVol", supplyVol, outFile, nPeriods, nonZeroOnly);
     if (category == WitPRODUCT)
       numRecords += printDbDumpRec(pn, pdf, "cycleTime", cycleTime, outFile, nPeriods, nonZeroOnly);
     if (operationExists)
       numRecords += printDbDumpRecBool(pn, pdf, "execFlag", execFlag, outFile, nPeriods);
     numRecords += printDbDumpRec(pn, pdf, "mrpConsVol", mrpConsVol, outFile, nPeriods, alwaysPrint);
     numRecords += printDbDumpRec(pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);
     numRecords += printDbDumpRec(pn, pdf, "mrpExcessVol", mrpExcessVol, outFile, nPeriods, nonZeroOnly);
     numRecords += printDbDumpRec(pn, pdf, "mrpResidualVol", mrpResidualVol, outFile, nPeriods, nonZeroOnly);

     if (doImplode) {
       //       numRecords += printDbDumpRec(pn, pdf, "excessVol", excessVol, outFile, nPeriods, nonZeroOnly);
       numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "excessVol", excessVol, outFile, nPeriods, nonZeroOnly);
       numRecords += printDbDumpRec(pn, pdf, "residualVol", residualVol, outFile, nPeriods, nonZeroOnly);
       if (category != WitCAPACITY) 
	 numRecords += printDbDumpRec(pn, pdf, "stockVol", stockVol, outFile, nPeriods, nonZeroOnly);	 
       numRecords += printDbDumpRec(pn, pdf, "scrapVol", scrapVol, outFile, nPeriods, nonZeroOnly);	 
       //       numRecords += printDbDumpRec(pn, pdf, "consVol", consVol, outFile, nPeriods, nonZeroOnly);	 
       flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "consVol", consVol, outFile, nPeriods, nonZeroOnly);
       if (category == WitPRODUCT)
	 numRecords += printDbDumpRec(pn, pdf, "prodVol", prodVol, outFile, nPeriods, nonZeroOnly);	 
     }

     witFree(supplyVol);
     if (category == WitPRODUCT)
       witFree(cycleTime);
     if (operationExists)
       witFree(execFlag);
     witFree(reqVol);
     witFree(mrpExcessVol);
     witFree(mrpResidualVol);
     if (doImplode) {       
       witFree(excessVol);
       witFree(residualVol);
       if (category != WitCAPACITY)
	 witFree(stockVol);
       witFree(scrapVol);
       witFree(consVol);
       if (category == WitPRODUCT) 
	 witFree(prodVol);
     }

   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}

//  ---------------------------------------------------------------------
//  Print Part DB Dump File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printPartDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Part Database Dump" 
		       << fileName);
  }


  LgFrCalendar theCal = this->calendar();

  long numRecords = 0;
  long numUniquePairs = 0;
  // we must check this against the number of records in the partDef file


  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  bool doImplode =         setOfParameters.getBool("doImplode");
  std::string siteCustomization = setOfParameters.getString("siteCustomization");

  witAttr category;
  witBoolean operationExists;

  int i,t, p, b, npBops;


  //  - all the execVol stuff...
  float * prodVol      = new float[nPeriods];  
  float * mrpProdVol   = new float[nPeriods];  
  float * bldVol       = new float[nPeriods];  
  float * mrpBldVol    = new float[nPeriods];    
  float * userOpVol    = new float[nPeriods];
  float * mrpUserOpVol = new float[nPeriods];    
  float * intPlVol     = new float[nPeriods];
  float * mrpIntPlVol  = new float[nPeriods];   
  float * altVol       = new float[nPeriods];
  float * mrpAltVol    = new float[nPeriods];    
 
  float * deAggVol     = new float[nPeriods];
  float * mrpDeAggVol  = new float[nPeriods];    

  float * supplyVolSpecifiedByUser;
  float * witStockVol;
  float * cycleTime;
  float * yieldRate;
  witBoolean * execFlag;
  float * witExcessVol;
  float * witResidualVol;
  float * scrapVol;
  float * consVol;
  float * reqVol;
  float * witMrpExcessVol;      
  float * witMrpResidualVol;      

  LgFrTimeVecFloat excessVol((size_t) nPeriods, 0.0);
  LgFrTimeVecFloat residualVol((size_t) nPeriods, 0.0);



  int nDemands;
  char ** dList;

#ifdef ENABLE_NEGATIVE_DEMANDS
  LgFrTimeVecFloat negDemVol;
#endif

  int nonZeroOnly = 0;
  int alwaysPrint = 1;
  
  int alwaysPrintForECAonly = (sce::compareStringsCaseIns( siteCustomization, "eca" ) ? 0 : 1);
  bool combineCapacityIntoPartDB = setOfParameters.getBool("combineCapacityIntoPartDB");

  
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {

    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;

    if (! combineCapacityIntoPartDB) {
      if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
	continue;
    }

    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);


    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    

    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    

    // get demands on the part.  These are needed for direct demands
    witGetPartDemands(theWitRun, fullPartName.c_str(), &nDemands, &dList);

#ifdef ENABLE_NEGATIVE_DEMANDS
    // Compute :=======> negDemVol
    int doesPartHaveNegativeDemands = mpHelper.doesPartHaveNegativeDemands(theWitRun, fullPartName);
    if (doesPartHaveNegativeDemands) {
      negDemVol = mpHelper.negDemVol(theWitRun, fullPartName);
    }
#endif     


    // Compute :=======> supplyVol
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVolSpecifiedByUser);
#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat witSupplyVol((size_t) nPeriods, supplyVolSpecifiedByUser);
    // adjust the supplyVol by removing any dummy supply due to  negative demands 
    if (doesPartHaveNegativeDemands) {
      for (t=0; t<nPeriods; t++) {
	supplyVolSpecifiedByUser[t] -= negDemVol[t];
      }
    }
#endif     



    // Compute :======> CycleTime
    if (category == WitPRODUCT) {
      // FINISH_ME: This si a temprorary stopgap for maintaining
      // backward compatability.  In 1.30/1.31, the (eca) user's only
      // way of finding out what were true PCF parts was via
      // cycleTime=-1.  This needs to be worked out, but is OK for now.

      // get the "real" cycleTime in any case
      witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);

#ifndef VARIABLE_PERIODS
      // don't do this for variable periods. 
      // 
      // if the part is a PCF, then use partAppData and
      // unConstrainedStartPeriod to set those periods to -1,
      // after that pick up the cycleTime vector for real
      // eventually, we need to get rid of cycleTime altogether
      // or use an appData for it.
      if (mpHelper.isPartPcf(theWitRun, fullPartName)) {
	LgFrScePartAppData * appDataPtr;
	witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
	assert(appDataPtr != 0);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
	  cycleTime[tt] = -1.0;
      }
#endif
    }



    // Compute :=======> mrpConsVol
    float * mrpConsVol;
    myExploder->mrpConsVol(fullPartName, &mrpConsVol);
    // add in direct demand vol
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      float * indepDemandVol;
      witGetDemandDemandVol(theWitRun, fullPartName.c_str(), dList[j], &indepDemandVol);
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
	mrpConsVol[tt] += indepDemandVol[tt];
      }
      witFree(indepDemandVol);
    }
    //    int matt = 0; // Pulled out of the for below by RW2STL
    //    for (matt=0; matt<nPeriods; matt++) {
    //      mrpConsVol[matt] -= mrpAltVol[matt];
    //    }
    




#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat witMrpConsVol((size_t) nPeriods, mrpConsVol);
    LgFrTimeVecFloat negDemMrpConsVol((size_t) nPeriods, 0.0);
    if (doesPartHaveNegativeDemands) {
      float rolledNegDemVol = 0.0;
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
	rolledNegDemVol += negDemVol[tt];
	if (mrpConsVol[tt] > rolledNegDemVol) {
	  mrpConsVol[tt] -= rolledNegDemVol;
	  negDemMrpConsVol[tt] += rolledNegDemVol;
	  rolledNegDemVol = 0.0;
	}
	else {
	  // Note: if mrpConsVol < 0 then there are negative usage rates
	  // these can realy screw up our calculation
	  if (mrpConsVol[tt] > 0) {
	    rolledNegDemVol -= mrpConsVol[tt];
	    negDemMrpConsVol[tt] += mrpConsVol[tt];
	    mrpConsVol[tt] = 0.0;
	  }
	}
      }
    }
#endif
      
    // Compute :======> reqVol
    myExploder->reqVol(partList[i], &reqVol);

    // Compute :======> execFlag
    if (operationExists) {
      witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);

      // Compute :======> yieldRate
      witGetOperationYieldRate(theWitRun, fullPartName.c_str(), &yieldRate);
    }

    // Now compute all the execVol types:
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpAltVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, altVol, deAggVol, userOpVol
    if (npBops > 0) {
      // first intialize the vectors to zero
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	prodVol[t] = 0.0;
	mrpProdVol[t] = 0.0;
	bldVol[t] = 0.0;
	mrpBldVol[t] = 0.0;
	altVol[t] = 0.0;
	mrpAltVol[t] = 0.0;

	if (nUserDefinedOps) {
	  userOpVol[t] = 0;
	  mrpUserOpVol[t] = 0;
	}
	if (nInterplantOps) {
	  intPlVol[t] = 0.0;
	  mrpIntPlVol[t] = 0.0;
	}
	if (nAggregationOps) {
	  deAggVol[t] = 0.0;
	  mrpDeAggVol[t] = 0.0;
	}
      }

      // loop through each of the bop entries and get the execVol once for each
      // bop entry (this is a bit inefficient, but too bad).
      for (p=0; p<npBops; p++) {
	bool foundOpCategory = false;          
	std::string cp1, pdf1, sp2, pdf2;
	int early, late;
	float  prodRate;
	char * witOperationName;
	float * tempExecVol;
	float * tempMrpExecVol;
	float * yieldRate;
	float * mrpYieldRate;        
	  
	witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
	std::string operationName(witOperationName);
	witGetBopEntryProdRate(theWitRun, witOperationName, b, &prodRate);
	witGetBopEntryEarliestPeriod(theWitRun, witOperationName, b, &early);
	witGetBopEntryLatestPeriod(theWitRun, witOperationName, b, &late);
	myExploder->mrpExecVol(witOperationName, &tempMrpExecVol);          
	if (doImplode) {
	  witGetOperationExecVol(theWitRun, witOperationName, &tempExecVol);
	}
	witGetOperationYieldRate(theWitRun, witOperationName, &yieldRate);
	witGetOperationYieldRate(myExploder->localWitRun(), witOperationName, &mrpYieldRate);        

	
	// Is it the default Operation
	if (operationName == fullPartName 
	    || mpHelper.isOperationForCapacityGeneration(theWitRun, operationName, cp1, pdf1)) {
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    if (doImplode) {
	      bldVol[t]     += yieldRate[t] * tempExecVol[t];
	    }
	    mrpBldVol[t]  += mrpYieldRate[t] * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
	  
	// is it an Interplant Operation ?
	if (! foundOpCategory
	    && nInterplantOps
	    && mpHelper.isOperationSpecialInterplant(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  LgFrTimeVecFloat newExecVol = this->interplantExecVol(operationName);
	  LgFrTimeVecFloat newMrpExecVol = this->interplantMrpExecVol(operationName);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {
	      intPlVol[t]    += prodRate * newExecVol[t];
	    }
	    mrpIntPlVol[t] += prodRate * newMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}

	// is it an Alternate Operation ?
	if (! foundOpCategory
	    && mpHelper.isOperationSpecialAlternate(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {
	      altVol[t]    += prodRate * tempExecVol[t];
	    }
	    mrpAltVol[t] += prodRate * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}





	// is it an Aggreration Operation ?
	if (! foundOpCategory
	    && nAggregationOps
	    && mpHelper.isOperationSpecialAggregation(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {	  
	      deAggVol[t]    += prodRate * yieldRate[t] * tempExecVol[t];
	    }
	    mrpDeAggVol[t] += prodRate * mrpYieldRate[t] * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}

	// is it a UserDefined Operation (it must be, at this point)
	if (! foundOpCategory
	    && nUserDefinedOps) {
	  int * impactPeriod;
	  int * mrpImpactPeriod;          
	  witGetBopEntryImpactPeriod(theWitRun, witOperationName, b, &impactPeriod);
	  witGetBopEntryImpactPeriod(myExploder->localWitRun(), witOperationName, b, &mrpImpactPeriod);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (impactPeriod[t] > -1)
	      if (doImplode) {	  
		userOpVol[impactPeriod[t]]       += yieldRate[t] * prodRate * tempExecVol[t];
	      }
	    if (mrpImpactPeriod[t] > -1)            
	      mrpUserOpVol[mrpImpactPeriod[t]] += mrpYieldRate[t] * prodRate * tempMrpExecVol[t];
	  }
	  witFree(impactPeriod);
	  witFree(mrpImpactPeriod);
	  foundOpCategory = true;
	}

	// Now assert that the operation resolved into exactly one of the types!!
	if (! foundOpCategory) {
	  std::cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<std::endl;
	}
	assert(foundOpCategory);

	// clean-up the memory for this bop
	witFree(witOperationName);
	if (doImplode) {	
	  witFree(tempExecVol);
	}
	witFree(tempMrpExecVol);
	witFree(yieldRate);
	witFree(mrpYieldRate);        
      }

      for (t=0; t<nPeriods; t++) {
	if (doImplode) {	  
	  prodVol[t] = bldVol[t];
	}
	mrpProdVol[t] = mrpBldVol[t];
	if (nUserDefinedOps) {
	  mrpProdVol[t] += mrpUserOpVol[t];
	  if (doImplode) {	  
	    prodVol[t] += userOpVol[t];
	  }
	}
	if (nInterplantOps) {
	  mrpProdVol[t] += mrpIntPlVol[t];
	  if (doImplode) {	  
	    prodVol[t] += intPlVol[t];
	  }
	}
	if (nAggregationOps) {
	  mrpProdVol[t] += mrpDeAggVol[t];
	  if (doImplode) {	  
	    prodVol[t] += deAggVol[t];
	  }
	}
      }
    }
    
     
    LgFrTimeVecFloat stockVol((size_t) nPeriods, 0.0);
    if (doImplode) {


      // Compute :======> scrapVol
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);

      // Compute :======> consVol
      // FINISH_ME: temporary fix we always print consvol
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
      // add in direct demand vol
      for (j=0; j<nDemands; j++) {
	float * indepShipVol;
	witGetDemandShipVol(theWitRun, fullPartName.c_str(), dList[j], &indepShipVol);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
	  consVol[tt] += indepShipVol[tt];
	}
	witFree(indepShipVol);
      }
      int att = 0; // Pulled out of the for below by RW2STL
      for (att=0; att<nPeriods; att++) {
	consVol[att] -= altVol[att];
      }
      

#ifdef ENABLE_NEGATIVE_DEMANDS
      LgFrTimeVecFloat witConsVol((size_t) nPeriods, consVol);
      LgFrTimeVecFloat negDemConsVol((size_t) nPeriods, 0.0);
      if (doesPartHaveNegativeDemands) {
	float rolledNegDemVol = 0.0;
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
	  rolledNegDemVol += negDemVol[tt];
	  if (consVol[tt] > rolledNegDemVol) {
	    consVol[tt] -= rolledNegDemVol;
	    negDemConsVol[tt] += rolledNegDemVol;
	    rolledNegDemVol = 0.0;
	  }
	  else {
	    // Note: if consVol < 0 then there are negative usage rates
	    // these can realy screw up our calculation
	    if (consVol[tt] > 0) {
	      rolledNegDemVol -= consVol[tt];
	      negDemConsVol[tt] += consVol[tt];
	      consVol[tt] = 0.0;
	    }
	  }
	}
      }
#endif



      // Compute :======> StockVol, ExcessVol, ResidualVol
      if (category == WitCAPACITY) {
	witStockVol = new float[nPeriods];
	int t=0;
	for (t=0; t<nPeriods; t++)
	  witStockVol[t] = 0.0;
      }
      else {
	witGetPartStockVol(theWitRun, fullPartName.c_str(), &witStockVol);
      }

      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witExcessVol);
      witGetPartResidualVol(theWitRun, fullPartName.c_str(), &witResidualVol);
      int ttt = 0; // Pulled out of the for below by RW2STL
      for (ttt=0; ttt<nPeriods; ttt++) {
	if (category != WitCAPACITY) {
	  stockVol[ttt] = witStockVol[ttt];
	}
	excessVol[ttt] = witExcessVol[ttt];
	residualVol[ttt] = witResidualVol[ttt];
      }
#ifdef ENABLE_NEGATIVE_DEMANDS
      LgFrTimeVecFloat negDemandStockVol((size_t) nPeriods, 0.0);
      if (doesPartHaveNegativeDemands) {
	// strategy: 
	// 1) compute witStockVol (ie, wrt the witRun including dummy supply)
	// 2) compute mrpNegDemandStockVol.  This is an abstract sort of thing that
	//              represents the amount of stockVol that is due to negDemand.
	//              its computed from negDemVol and negDemConsVol with a sort
	//              or material balance equation
	// 3) compute stockVol (ie, stockVol if you remove dummy supply)
	// 4) compute residualVol.  We have to manually calculate this.
	// 5) compute excessVol by truncating mrpResidualVol at the supplyVol level
      
	// 1) compute witStockVol 
	//     ....  We already have this from wit ....
	// 2) compute negDemandStockVol.  
	negDemandStockVol[0]  = negDemVol[0] - negDemConsVol[0];
	for (t=1; t<nPeriods; t++) {
	  negDemandStockVol[t] = negDemandStockVol[t-1] + negDemVol[t] - negDemConsVol[t];
	}

	// 3) compute stockVol
	for (t=0; t<nPeriods; t++) 
	  stockVol[t] = witStockVol[t] - negDemandStockVol[t];

	// 4) compute residualVol.  
	// the amount of excess can be at most the ending stock
	float potentialToExcess = stockVol[nPeriods-1];
	// walk backwards in time and look for an increasing stockVol from 
	// period t-1 to 1
	float stockIncrementThisPeriod;
	for (t=nPeriods-1; t>0; t--) {
	  stockIncrementThisPeriod = stockVol[t] - stockVol[t-1];
	  if (stockIncrementThisPeriod > 0.0) {
	    if (stockIncrementThisPeriod > potentialToExcess) {
	      residualVol[t] = potentialToExcess;
	      potentialToExcess = 0.0;
	    }
	    else {
	      residualVol[t] = stockIncrementThisPeriod;
	      potentialToExcess -= stockIncrementThisPeriod;
	    }
	  }
	}
	// now check period 0
	stockIncrementThisPeriod = stockVol[0];
	if (stockIncrementThisPeriod > 0.0) {
	  if (stockIncrementThisPeriod > potentialToExcess) {
	    residualVol[0] = potentialToExcess;
	    potentialToExcess = 0.0;
	  }
	  else {
	    residualVol[0] = stockIncrementThisPeriod;
	    potentialToExcess -= stockIncrementThisPeriod;
	  }
	}


	// 5) compute excessVol by truncating residualVol at the supplyVol level
	for (t=0; t<nPeriods; t++) {
	  if (residualVol[t] > supplyVolSpecifiedByUser[t])
	    excessVol[t] = supplyVolSpecifiedByUser[t];
	  else
	    excessVol[t] = residualVol[t];
      }
    }


#endif
  


    }

    // Compute :======> mrpExcessVol
    myExploder->mrpExcessVol(partList[i], &witMrpExcessVol);
    myExploder->mrpResidualVol(partList[i], &witMrpResidualVol);
    LgFrTimeVecFloat mrpExcessVol((size_t) nPeriods, witMrpExcessVol);
    LgFrTimeVecFloat mrpResidualVol((size_t) nPeriods, witMrpResidualVol);
#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat mrpNegDemandStockVol((size_t) nPeriods, 0.0);
    LgFrTimeVecFloat witMrpStockVol((size_t) nPeriods, 0.0);
    LgFrTimeVecFloat mrpStockVol(witMrpStockVol);
    if (doesPartHaveNegativeDemands) {
      // strategy: 
      // 1) compute witMrpStockVol (ie, wrt the witRun including dummy supply)
      // 2) compute mrpNegDemandStockVol.  This is an abstract sort of thing that
      //              represents the amount of stockVol that is due to negDemand.
      //              its computed from negDemVol and negDemMrpConsVol with a sort
      //              or material balance equation
      // 3) compute mrpStockVol (ie, stockVol if you remove dummy supply)
      // 4) compute mrpResidualVol.  We have to manually calculate this.
      // 5) compute mrpExcessVol by truncating mrpResidualVol at the supplyVol level
      
      // 1) compute witMrpStockVol 
      witMrpStockVol[0] = witSupplyVol[0] + mrpProdVol[0] - witMrpConsVol[0];
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=1; t<nPeriods; t++) {
	witMrpStockVol[t] = witMrpStockVol[t-1] + witSupplyVol[t] + mrpProdVol[t] - witMrpConsVol[t];
      }

      // 2) compute mrpNegDemandStockVol.  
      mrpNegDemandStockVol[0]  = negDemVol[0] - negDemMrpConsVol[0];
      for (t=1; t<nPeriods; t++) {
	mrpNegDemandStockVol[t] = mrpNegDemandStockVol[t-1] + negDemVol[t] - negDemMrpConsVol[t];
      }

      // 3) compute mrpStockVol
      mrpStockVol = witMrpStockVol - mrpNegDemandStockVol;

      // 4) compute mrpResidualVol.  
      // the amount of excess can be at most the ending stock
      float potentialToExcess = mrpStockVol[nPeriods-1];
      // walk backwards in time and look for an increasing stockVol from 
      // period t-1 to 1
      float stockIncrementThisPeriod;
      for (t=nPeriods-1; t>0; t--) {
	stockIncrementThisPeriod = mrpStockVol[t] - mrpStockVol[t-1];
	if (stockIncrementThisPeriod > 0.0) {
	  if (stockIncrementThisPeriod > potentialToExcess) {
	    mrpResidualVol[t] = potentialToExcess;
	    potentialToExcess = 0.0;
	  }
	  else {
	    mrpResidualVol[t] = stockIncrementThisPeriod;
	    potentialToExcess -= stockIncrementThisPeriod;
	  }
	}
      }
      // now check period 0
      stockIncrementThisPeriod = mrpStockVol[0];
      if (stockIncrementThisPeriod > 0.0) {
	if (stockIncrementThisPeriod > potentialToExcess) {
	  mrpResidualVol[0] = potentialToExcess;
	  potentialToExcess = 0.0;
	}
	else {
	  mrpResidualVol[0] = stockIncrementThisPeriod;
	  potentialToExcess -= stockIncrementThisPeriod;
	}
      }


      // 5) compute mrpExcessVol by truncating mrpResidualVol at the supplyVol level
      for (t=0; t<nPeriods; t++) {
	if (mrpResidualVol[t] > supplyVolSpecifiedByUser[t])
	  mrpExcessVol[t] = supplyVolSpecifiedByUser[t];
	else
	  mrpExcessVol[t] = mrpResidualVol[t];
      }
    }
#endif



    // Compute :======> mrpRequirements
    LgFrTimeVecFloat mrpRequirementsVol((size_t) nPeriods, reqVol);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      mrpRequirementsVol[t] -= mrpExcessVol[t];
    }


    // ==========================
    // PRINT everything down here
    // ==========================
    std::string pn(mpHelper.partname(fullPartName));
    std::string pdf(mpHelper.pdf(fullPartName));


#ifdef ENABLE_NEGATIVE_DEMANDS
#if 0
    // for debug use only !!!
    if (doesPartHaveNegativeDemands) {
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpNegDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);

      //      printDbDumpRec(pn, pdf, "negDemConsVol", negDemConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);

    }
#endif
#endif


    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "supplyVol", supplyVolSpecifiedByUser, outFile, nPeriods, nonZeroOnly);
#ifdef ENABLE_NEGATIVE_DEMANDS
    if (doesPartHaveNegativeDemands) 
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemVol", negDemVol.data(), outFile, nPeriods, nonZeroOnly);
#endif     
    if (category == WitPRODUCT) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "cycleTime", cycleTime, outFile, nPeriods, nonZeroOnly);
    }
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpConsVol", mrpConsVol, outFile, nPeriods, nonZeroOnly);
#ifdef ENABLE_NEGATIVE_DEMANDS
    if (doesPartHaveNegativeDemands) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemMrpConsVol", negDemMrpConsVol.data(), outFile, nPeriods, nonZeroOnly);
    }
#endif     

    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpExcessVol", mrpExcessVol.data(), outFile, nPeriods, nonZeroOnly);
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpResidualVol", mrpResidualVol.data(), outFile, nPeriods, nonZeroOnly);
    if (category != WitCAPACITY) 
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpStockVol", mrpStockVol.data(), outFile, nPeriods, nonZeroOnly);

    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpRequirements", mrpRequirementsVol.data(), outFile, nPeriods, nonZeroOnly);

    if (operationExists) {
      //      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "yield", yieldRate, outFile, nPeriods, alwaysPrint);
    }

    // Now print all the execVol types:
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, deAggVol, userOpVol
    if (npBops > 0) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpProdVol", mrpProdVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpBldVol", mrpBldVol, outFile, nPeriods, nonZeroOnly);
      if (nInterplantOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpIntPlVol", mrpIntPlVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpAltVol", mrpAltVol, outFile, nPeriods, nonZeroOnly);
      if (nAggregationOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpDeAggVol", mrpDeAggVol, outFile, nPeriods, nonZeroOnly);
      if (nUserDefinedOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpUserOpVol", mrpUserOpVol, outFile, nPeriods, nonZeroOnly);

      if (doImplode) {        
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "prodVol", prodVol, outFile, nPeriods, nonZeroOnly);
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "bldVol", bldVol, outFile, nPeriods, nonZeroOnly);
	if (nInterplantOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "intPlVol", intPlVol, outFile, nPeriods, nonZeroOnly);
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "altVol", altVol, outFile, nPeriods, nonZeroOnly);
	if (nAggregationOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "deAggVol", deAggVol, outFile, nPeriods, nonZeroOnly);
	if (nUserDefinedOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "userOpVol", userOpVol, outFile, nPeriods, nonZeroOnly);
      }
    }

    if (doImplode) {        
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "excessVol", excessVol.data(), outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "residualVol", residualVol.data(), outFile, nPeriods, nonZeroOnly);
      if (category != WitCAPACITY) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "stockVol", stockVol.data(), outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "scrapVol", scrapVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "consVol", consVol, outFile, nPeriods, nonZeroOnly);
    }


    if (category == WitPRODUCT)
      witFree(cycleTime);
    witFree(reqVol);
    witFree(witMrpExcessVol);
    witFree(witMrpResidualVol);
    witFree(mrpConsVol);
    if (operationExists) {
      witFree(execFlag);
      witFree(yieldRate);
    }
    if (doImplode) {        
      witFree(witExcessVol);
      witFree(witResidualVol);
      if (category == WitCAPACITY) 
	delete [] witStockVol;
      else
	witFree(witStockVol);
      witFree(scrapVol);
      witFree(consVol);
    }


    // free up the direct demands 
    for (j=0; j<nDemands; j++) {
      witFree(dList[j]);
    }
    witFree(dList);

    witFree(supplyVolSpecifiedByUser);
    numUniquePairs++;
  }
     


  delete [] prodVol;
  delete [] mrpProdVol;
  delete [] mrpBldVol;
  delete [] bldVol;  
  delete [] userOpVol;
  delete [] mrpUserOpVol; 
  delete [] intPlVol;
  delete [] mrpIntPlVol;
  delete [] altVol;
  delete [] mrpAltVol;
  delete [] deAggVol;
  delete [] mrpDeAggVol;
  
    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numUniquePairs);
}




// prints a record of a DB Dump file
// returns 1 if printed, 0 if not
int
LgFrScenarioForSce::printDbDumpRec(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const float *  floatVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods, 
    int printIfVectorIsAllZero)
{
    if ((printIfVectorIsAllZero) || (this->flatFileMgr_.isFloatVecNonZero(floatVec, nPeriods))) {
      outFile << "\"" << pn << "\",\""
	      << pdf << "\",";
      outFile << "\"" << vecID << "\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, floatVec, 0, 15);
      return 1;
    }
    
    return 0;
}

// prints a (boolean) record of a DB Dump file
// returns 1 
int
LgFrScenarioForSce::printDbDumpRecBool(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const witBoolean *  boolVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods)
{
  outFile << "\"" << pn << "\",\""
	  << pdf << "\",";
  outFile << "\"" << vecID << "\"";
  flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, boolVec);
  return 1;
}


// compute an adjusted excessVol due to negative demands (works for mrp or implosion)
LgFrTimeVecFloat 
LgFrScenarioForSce::excessVolAdjustedForNegativeDemands(
    float * witExcessVol,
    float * supplyVol,
    LgFrTimeVecFloat & negDemVol,
    int nPeriods)
{
 LgFrTimeVecFloat adjustedExcessVol((size_t) nPeriods, witExcessVol);

 // ok now do something
 return adjustedExcessVol;
 
}



//  ---------------------------------------------------------------------
//  Print Operation Dump File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOperationDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Operation Database Dump" 
		       << fileName);
  }

  long numRecords = 0;

  float * witVector;

  int nOps;
  char ** opList;
  witGetOperations(theWitRun, &nOps, &opList);

  int o;
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  LgFrSceBaseExploder * myExploder = this->exploder();          

  bool doImplode = setOfParameters.getBool("doImplode");


  
  // Loop once for each operation
  for ( o=0; o<nOps; o++ ) {

    std::string operation(opList[o]);
    std::string op, p;
    if (! mpHelper.isOperationNormal(theWitRun, operation, p, op))
      continue;

    // this file does not report on default-operations!!  Only the userDefined ones.
    if (mpHelper.isPartNormal(theWitRun, operation))
      continue;

    
    // ----------------------------
    // INPUT type of parameters     
    // ----------------------------

    // execFlag
    witBoolean * witBoolVec;
    witGetOperationExecutable(theWitRun, operation.c_str(), &witBoolVec);
    outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	    << mpHelper.pdf(operation) << "\",";
    outFile << "\"execFlag\"";
    flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, witBoolVec);
    witFree(witBoolVec);
    numRecords++;

    // yieldRate
    witGetOperationYieldRate(theWitRun, operation.c_str(), &witVector);
    outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	    << mpHelper.pdf(operation) << "\",";
    outFile << "\"yield\"";
    flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
    witFree(witVector);
    numRecords++;
     
    // ----------------------
    // MRP type of parameters     
    // ----------------------

    // mrpExecVol
    myExploder->mrpExecVol(operation, &witVector);
    if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	      << mpHelper.pdf(operation) << "\",";
      outFile << "\"mrpExecVol\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
      numRecords++;
    }
    witFree(witVector);

       
    // ----------------------------
    // IMPLOSION type of parameters     
    // ----------------------------
    if (doImplode) {
      // execVol
      witGetOperationExecVol(theWitRun, operation.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	outFile << "\"" << mpHelper.operationName(operation) << "\",\""
		<< mpHelper.pdf(operation) << "\",";
	outFile << "\"execVol\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
	numRecords++;
      }
      witFree(witVector);

    }
     

  }
 
  outFile.close();

  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);

  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}


//  ---------------------------------------------------------------------
//  Print Operation Dump File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOperationExecDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Operation Exec Dump" 
		       << fileName);
  }

  std::string leadingString;

  long numRecords = 0;

  float * witVector;

  int nOps;
  char ** opList;
  witGetOperations(theWitRun, &nOps, &opList);

  int o;
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  bool doImplode = setOfParameters.getBool("doImplode");

  
  // Loop once for each operation
  for ( o=0; o<nOps; o++ ) {

    std::string operation(opList[o]);
    std::string op, p;

    // execFlag
    witBoolean * witBoolVec;
    witGetOperationExecutable(theWitRun, opList[o], &witBoolVec);
    outFile << "\"" << opList[o]<< "\",\",";
    outFile << "\"execFlag\"";
    flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, witBoolVec);

    witFree(witBoolVec);
    numRecords++;

    // yieldRate
    witGetOperationYieldRate(theWitRun, opList[o], &witVector);
    leadingString = "\"" 
      + (std::string) opList[o] + "\",\","
      +  "\"yieldRate\"";
    //     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);


    flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, witVector);
    witFree(witVector);
    numRecords++;
     
    // ----------------------
    // MRP type of parameters     
    // ----------------------

    // mrpExecVol
    myExploder->mrpExecVol(operation, &witVector);
    if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      leadingString = "\"" 
	+ (std::string) opList[o] + "\",\","
	+ "\"mrpExecVol\"";
      flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, witVector);
      numRecords++;
    }
    witFree(witVector);

       
    // ----------------------------
    // IMPLOSION type of parameters     
    // ----------------------------
    if (doImplode) {
      // execVol
      witGetOperationExecVol(theWitRun, operation.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	leadingString = "\"" 
	  + (std::string) opList[o] + "\",\","
	  +  "\"execVol\"";
	flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, witVector);
	numRecords++;
      }
      witFree(witVector);

    }

  }
 
  outFile.close();

  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);

  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}








//  ---------------------------------------------------------------------
//  Print MRP Supply Orders File
//  ---------------------------------------------------------------------
//  PUD 14's are EMLS Planned Order (supply) transactions (ie, MRP orders for supply).
//  The key thing is that the supply shows customer PDF and supplier PDF.
//  If th esupply is created by "build in-house", then the customer and supplier PDF
//  is the same.
//
//  Codes are:
//  "A" = interplant
//  "B" = bin
//  "F" = build in-house
//  "O" = user-defined Operation
//  "D" = de-aggregation
//  "E" = External supply (ie, supplyVol)
void 
LgFrScenarioForSce::printMrpSupplyOrdersFile(
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "MRP Supply Orders" 
		       << fileName);
  }


  long numRecords = 0;

  float * supplyOrderQty = new float [nPeriods];  

  std::string leadingString;

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  WitRun *  exploderWitRun = myExploder->localWitRun();

  int nOps;
  char ** opList;
  witGetOperations(exploderWitRun, &nOps, &opList);
  
  
  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {

    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2;
    std::string PUD14SourceCode;
    std::string supplierPdf, customerPdf, producedPart;



    // IF the operation is normal, then its either a  "F" source (ie, build in-house)
    //                                     OR a user-defined operation
    if (mpHelper.isOperationNormal(exploderWitRun, fullWitOperation, p, op)) {
      supplierPdf = p;
      customerPdf = p;      
      // if the part exists, then the operation is a build-inhouse
      if (mpHelper.isPartNormal(exploderWitRun, fullWitOperation)) 
	PUD14SourceCode = "F";
      else 
	PUD14SourceCode = "O";
    }

    else if (mpHelper.isOperationSpecialInterplant(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      supplierPdf = pdf2;
      customerPdf = pdf1;      
      PUD14SourceCode = "A";
    }

    else if (mpHelper.isOperationSpecialAggregation(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      supplierPdf = pdf2;
      customerPdf = pdf1;      
      PUD14SourceCode = "D";
    }

    else
      continue;

    // regardless of what this thing is, compute how much supply it created for the
    // Produced part

    int nBops;
    witGetOperationNBopEntries(exploderWitRun, fullWitOperation.c_str(), &nBops);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBops; b++) {
      int * impactPeriod;
      float * mrpExecVol;
      float prodRate;
      float * yieldRate;
      int early, late;
      char * producedPart;
      
      
      witGetBopEntryProducedPart(exploderWitRun, fullWitOperation.c_str(), b, &producedPart);
      // if its an operation that produces capacity, then skip it.
      witAttr category;      
      witGetPartCategory(exploderWitRun, producedPart, &category);
      if (category == WitCAPACITY) {
	witFree(producedPart);
	continue;
      }
      witGetBopEntryProdRate(exploderWitRun, fullWitOperation.c_str(), b, &prodRate);
      witGetBopEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &early);
      witGetBopEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &late);
      myExploder->mrpExecVol(fullWitOperation, &mrpExecVol);          
      // note: do a switcheroo to get the real interplant execVol a'la jumper arcs
      if (PUD14SourceCode == "A") {
	LgFrTimeVecFloat realMrpExecVol = this->interplantMrpExecVol(fullWitOperation);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  mrpExecVol[t] = realMrpExecVol[t];
      }


      witGetOperationYieldRate(exploderWitRun, fullWitOperation.c_str(), &yieldRate);

      witGetBopEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), b, &impactPeriod);

      // first initialize the vector and the total to Zero
      float recordTotal = 0.0;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	supplyOrderQty[t] = 0.0;

      for (t=early; t<=late; t++) {
	if (impactPeriod[t] > -1) {
	  supplyOrderQty[impactPeriod[t]] = yieldRate[t] * prodRate * mrpExecVol[t];
	  recordTotal += supplyOrderQty[impactPeriod[t]];
	}
      }

      witFree(mrpExecVol);
      witFree(yieldRate);
      witFree(impactPeriod);

      // only print a record if its a non-zero vector.
      if (recordTotal > 0.0001) {
	    leadingString = "\""
	      + mpHelper.partname(producedPart) + "\",\""
	      + supplierPdf + "\",\""
	      + customerPdf + "\",\""          
	      + PUD14SourceCode + "\"";
	flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, supplyOrderQty);

	numRecords++;        
      }
      witFree(producedPart);

    }
     

  }



  int nParts;
  char ** partList;
  witGetParts(exploderWitRun, &nParts, &partList);


  // at this point all supply records will be E source.
  std::string PUD14SourceCode = "E";
  // Loop once for each operation
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPart(partList[i]);
    std::string partName, customerPdf;
    float * supplyVol;

    // IF the part is normal, then get its supply Vol and report
    if (mpHelper.isPartNormal(exploderWitRun, fullWitPart)) {
      witGetPartSupplyVol(exploderWitRun, fullWitPart.c_str(), &supplyVol);
      float recordTotal = 0.0;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t< nPeriods; t++) {
	recordTotal += supplyVol[t];
      }

      customerPdf = mpHelper.pdf(fullWitPart);
      // only print a record if its a non-zero vector.
      if (recordTotal > 0.0001) {
	leadingString = "\"" 
	  + mpHelper.partname(fullWitPart) + "\",\""
	  + customerPdf + "\",\""
	  + customerPdf + "\",\""          
	  + PUD14SourceCode + "\"";
	flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, supplyVol);
	numRecords++;        
      }
      witFree(supplyVol);
    }
  
  }
  
  delete [] supplyOrderQty;
  
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);

  for ( i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}


//  ---------------------------------------------------------------------
//  Print MRP Demand Orders File
//  ---------------------------------------------------------------------
//
//  Codes are:
//  "A" = interplant
//  "B" = bin
//  "F" = build in-house (includes features, subs, BB's)
//  "O" = user-defined Operation
//  "D" = de-aggregation
//  "E" = External demand (ie, demandVol)
void 
LgFrScenarioForSce::printMrpDemandOrdersFile(
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "MRP Demand Orders" 
		       << fileName);
  }

  long numRecords = 0;

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  WitRun *  exploderWitRun = myExploder->localWitRun();

  float * demandOrderQty = new float [nPeriods];
  float * subDemandOrderQty = new float [nPeriods];  

  std::string leadingString;
  
  int nOps;
  char ** opList;
  witGetOperations(exploderWitRun, &nOps, &opList);

  int nParts;
  char ** partList;
  witGetParts(exploderWitRun, &nParts, &partList);

  // For F source and O source, we need to accumulate the demands into an
  // array.  For the others, we report as we find them.
  // malloc vectors to be a vector of floatVecs
  float ** FsourceDemand = (float **) malloc (nParts * sizeof(float *));
  assert(FsourceDemand != 0);
  float ** OsourceDemand = (float **) malloc (nParts * sizeof(float *));
  assert(OsourceDemand != 0);

  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    FsourceDemand[i] = (float *) malloc (nPeriods * sizeof(float));
    assert(FsourceDemand[i] != 0);    
    OsourceDemand[i] = (float *) malloc (nPeriods * sizeof(float));
    assert(OsourceDemand[i] != 0);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      FsourceDemand[i][t] = 0.0;
      OsourceDemand[i][t] = 0.0;
    }
    
    // set the index's for these parts using appData.  We need to do this
    // because there will be lots of part searching going on.
    LgFrScePartAppData * appDataPtr;    
    witGetPartAppData(exploderWitRun, partList[i], (void **) &appDataPtr);
    if (appDataPtr == 0) {
      appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      appDataPtr->index(i);
      witSetPartAppData(exploderWitRun, partList[i], (void *) appDataPtr);
    }
    else
      appDataPtr->index(i);
  }

  

  
  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {

    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2, geo, plannerPart;
    std::string sourceCode;
    std::string supplierPdf, customerPdf;
    std::string gg, mm;


    // IF the operation is normal, then its either a  "F" source (ie, build in-house)
    //                                     OR a user-defined operation
    if (mpHelper.isOperationNormal(exploderWitRun, fullWitOperation, p, op)) {
      customerPdf = p;      
      // if the part exists, then the operation is a build-inhouse
      if (mpHelper.isPartNormal(exploderWitRun, fullWitOperation)) 
	sourceCode = "F";
      else 
	sourceCode = "O";
    }

    // if the operation is a specialStandaloneFeature then we pick this up as a
    // feature demand
    else if (mpHelper.isOperationSpecialStandaloneFeature(exploderWitRun, 
							  fullWitOperation, 
							  mm, 
							  gg, 
							  pn1, 
							  pdf1)) {
      sourceCode = "F";
    }
    

    else if (mpHelper.isOperationSpecialInterplant(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      customerPdf = pdf1;      
      sourceCode = "A";
    }

    else if (mpHelper.isOperationSpecialAggregation(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      customerPdf = pdf1;      
      sourceCode = "D";
    }
    else if (mpHelper.isOperationSpecialGeoPlannerDemand(exploderWitRun, fullWitOperation,
							 plannerPart, geo)) {
      customerPdf = geo;      
      sourceCode = "E";
    }

    else
      continue;

    // regardless of what this thing is, compute how much demand it 
    // generated on each of its children

    int nBoms;
    witGetOperationNBomEntries(exploderWitRun, fullWitOperation.c_str(), &nBoms);
    int k = 0; // Pulled out of the for below by RW2STL
    for (k=0; k<nBoms; k++) {
      int * impactPeriod;
      float * mrpExecVol;
      float usageRate;
      int fallout;
      int early, late;
      char * consumedPart;
      
      witGetBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, &consumedPart);

      // ignore capacity
      witAttr category;      
      witGetPartCategory(exploderWitRun, consumedPart, &category);
      if (category == WitCAPACITY) {
	witFree(consumedPart);
	continue;
      }
      
      // check the child part. If its not normal, then skip it
      if (! mpHelper.isPartNormal(exploderWitRun, consumedPart)) {
	witFree(consumedPart);        
	continue;
      }
      
      witGetBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, &usageRate);
      witGetBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &early);
      witGetBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &late);
      witGetBomEntryFallout(exploderWitRun, fullWitOperation.c_str(), k, &fallout);      
      myExploder->mrpExecVol(fullWitOperation, &mrpExecVol);          
      witGetBomEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), k, &impactPeriod);

      // Now consider subs (this is a pain in the ass)
      // if the bom entry has subs, then we must pick that demand up and make
      // sure to report it on the sub part.
      // FINISH_ME: use impactPeriod from bom entry.  See BOB about an impact period
      // for subs given that there's seperate offsets for subs.
      // This *should* only occur for real subs and not for any dummies
      int nSubs;
      witGetBomEntryNSubsBomEntries(exploderWitRun, fullWitOperation.c_str(), k, &nSubs);
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubs; s++) {
	float subUsageRate;
	int subEarly;
	int subLate;
	float subFalloutRate;
	char * subConsumedPart;
	float * subVol;
	witGetSubsBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subUsageRate);
	witGetSubsBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subEarly);
	witGetSubsBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subLate);
	witGetSubsBomEntryFalloutRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subFalloutRate);
	witGetSubsBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, s, &subConsumedPart);
	myExploder->subUsageVol(fullWitOperation, k, s, &subVol);
	// zero out the subDemandOrderQty vector first
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  subDemandOrderQty[t] = 0.0;
	for (t=subEarly; t<=subLate; t++) {
	  // decrement mrpExecVol by subVol
	  mrpExecVol[t] -= subVol[t];
	  // now compute the demand on the sub
	  if (impactPeriod[t] > -1) {
	    subDemandOrderQty[impactPeriod[t]] = subVol[t]
				 * subUsageRate / (1.0 - subFalloutRate);
	  }
	}
	// if its a sub off an interplant, then its a jumper arc
	if (sourceCode == "A") {
	  // only print a record if its a non-zero vector.
	  if (flatFileMgr_.isFloatVecNonZero(subDemandOrderQty, nPeriods)) {                      
	    leadingString = "\"" + 
	      mpHelper.partname(subConsumedPart) + "\",\""
	      + mpHelper.pdf(subConsumedPart) + "\",\""
	      + customerPdf + "\",\""          
	      + sourceCode + "\"";
	    flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, subDemandOrderQty);

	    numRecords++;        
	  }
	}

	else if (sourceCode == "F") {
	  LgFrScePartAppData * myAppDataPtr;
	  witGetPartAppData(exploderWitRun, subConsumedPart, (void **) &myAppDataPtr);
	  assert(myAppDataPtr != 0);
	  int index = myAppDataPtr->index();
	  for (t=0; t<nPeriods; t++) 
	    FsourceDemand[index][t] += subDemandOrderQty[t];
	}
	else if (sourceCode == "O") {
	  LgFrScePartAppData * myAppDataPtr;
	  witGetPartAppData(exploderWitRun, subConsumedPart, (void **) &myAppDataPtr);
	  assert(myAppDataPtr != 0);
	  int index = myAppDataPtr->index();
	  for (t=0; t<nPeriods; t++) 
	    OsourceDemand[index][t] += subDemandOrderQty[t];
	}
	// if its a sub off an aggregation or a GPD, then its an error
	else {
	  assert(1 == 0);
	}
	witFree(subConsumedPart);
	witFree(subVol);
      }  // this is the end of analysis for subs

      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	demandOrderQty[t] = 0.0;
      
      for ( t=early; t<=late; t++) {
	if (impactPeriod[t] > -1) {
	  demandOrderQty[impactPeriod[t]] = mrpExecVol[t] * usageRate * 100.0 / (float) (100 - fallout);
	}
      }

      witFree(mrpExecVol);
      witFree(impactPeriod);

      LgFrScePartAppData * myAppDataPtr;
      witGetPartAppData(exploderWitRun, consumedPart, (void **) &myAppDataPtr);
      assert(myAppDataPtr != 0);
      int index = myAppDataPtr->index();

      // interplants, bins, indep demand,  and de-aggs are the same
      if (sourceCode == "A" || sourceCode == "D" || sourceCode == "E" || sourceCode == "B") {
	// only print a record if its a non-zero vector.
	if (flatFileMgr_.isFloatVecNonZero(demandOrderQty, nPeriods)) {                      
	  leadingString = "\"" 
	    + mpHelper.partname(consumedPart) + "\",\""
	    + customerPdf + "\",\""
	    + mpHelper.pdf(consumedPart) + "\",\""          
	    + sourceCode + "\"";
	  flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, demandOrderQty);

	  numRecords++;        
	}
      }
      else if (sourceCode == "F") {
	for (t=0; t<nPeriods; t++) 
	  FsourceDemand[index][t] += demandOrderQty[t];
      }
      else if (sourceCode == "O") {
	for (t=0; t<nPeriods; t++) 
	  OsourceDemand[index][t] += demandOrderQty[t];
      }
      // You should never get here
      else {
	assert(1 == 0);
      }

      witFree(consumedPart);

    }

  }

  // OK, now print the F and O source  
  for ( i=0; i<nParts; i++ ) {
    std::string thePart(partList[i]);
    // if its not normal then skip it
    if (! mpHelper.isPartNormal(exploderWitRun, thePart)) {
      continue;
    }
    if (flatFileMgr_.isFloatVecNonZero(FsourceDemand[i], nPeriods)) {              
      std::string thePdf(mpHelper.pdf(thePart));
      leadingString = "\"" 
	+ mpHelper.partname(thePart) + "\",\""
	+ thePdf + "\",\""
	+ thePdf + "\",\""          
	+ "F" + "\"";
      flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, FsourceDemand[i]);

      numRecords++;
    }

    // as long as you find one period that is non-zero, then print it
    if (flatFileMgr_.isFloatVecNonZero(OsourceDemand[i], nPeriods)) {        
      std::string thePdf(mpHelper.pdf(thePart));
      leadingString =  "\"" 
	+ mpHelper.partname(thePart) + "\",\""
	+ thePdf + "\",\""
	+ thePdf + "\",\""          
	+ "O" + "\"";
      flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, OsourceDemand[i]);

      numRecords++;
    }
    
  }

  
  for (i=0; i<nParts; i++) {
    free(FsourceDemand[i]);
    free(OsourceDemand[i]);
  }
  free(FsourceDemand);
  free(OsourceDemand);  
  
  
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);

  for ( i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);

  delete [] demandOrderQty;
  delete [] subDemandOrderQty;  
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



// ---------------------------------------------------------------
// One stop WIT messaging control
void 
LgFrScenarioForSce::setWitInformationalMessaging(WitRun * const theWitRun,   
						       int onOrOff)
{
  // if they want it off
  if (onOrOff == 0) {
    // shut off ALL info messages
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
    // Let ANY warning message come out once
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, 1);    
    // Suppress a few WARNING messages that we already know about
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 446, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);        
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);        
    witSetMesgTimesPrint(theWitRun, WitTRUE, 745, 0);        
  }     
  else {
    // turn all INFO on
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, UCHAR_MAX);
    // turn all WARNINGS on 
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, UCHAR_MAX);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);           
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);         
    witSetMesgTimesPrint(theWitRun, WitTRUE, 745, 0);         
  }
}


// return the set of paramters 
LgFrSceSetOfParameters&
LgFrScenarioForSce::setOfParameters()
{
  return parameterSet_;
}

// return the flat file manager
LgFrSceFlatFileMgr&
LgFrScenarioForSce::flatFileMgr()
{
  return flatFileMgr_;
}


/*void
LgFrScenarioForSce::localeSnapshot(
				   RWLocaleSnapshot * localSnapshotPtr)
{
  delete localSnapshotPtr_;
  localSnapshotPtr_ = localSnapshotPtr;
  RWLocale::global(localSnapshotPtr_);
}*/

LgFrSetOfParts&
LgFrScenarioForSce::setOfParts(int k)
{
  // OK to cast away const. This is non-const member function
  return (LgFrSetOfParts &) constSetOfParts(k);
}

const
LgFrSetOfParts&
LgFrScenarioForSce::constSetOfParts(int k)
const
{
  assert (k >= LGFR_DEFAULT_SET && k <= LGFR_INTERPLANT_SET );
  switch (k) {
  case LGFR_DEFAULT_SET:
    return defaultSOP_;
  case LGFR_UNIVERSAL_SET:
    return LgFrScenario::constSetOfParts(LGFR_UNIVERSAL_SET);
  case LGFR_INTERPLANT_SET:
    return interplantSOP_;
  default:
    assert(1==0);
  }
  return defaultSOP_;
}


LgFrSetOfDemands&
LgFrScenarioForSce::setOfDemands(int k)
{
  // OK to cast away const. This is non-const member function
  return (LgFrSetOfDemands &) constSetOfDemands(k);
}

const
LgFrSetOfDemands&
LgFrScenarioForSce::constSetOfDemands(int k)
const
{
  assert (k >= LGFR_DEFAULT_SET && k <= LGFR_UNIVERSAL_SET );
  switch (k) {
    case LGFR_DEFAULT_SET:
       return defaultSOD_;
    case LGFR_UNIVERSAL_SET:
       return LgFrScenario::constSetOfDemands(LGFR_UNIVERSAL_SET);
    default:
       assert(1==0);
     }
  return defaultSOD_;
}

isAReturnType
LgFrScenarioForSce::isA() const
{
    return id_;
}

// Constructor
LgFrScenarioForSce::LgFrScenarioForSce(const LgFrDataInterfaceAbstract&    dif,
					 const LgFrCalendar&         calendar)
:LgFrScenario(dif, calendar),
 defaultSOP_(0),
 defaultSOD_(0),
 interplantSOP_(0),
 multiPlantHelper_(),
 critList_(),
 parameterSet_(),
 flatFileMgr_(),
 nStandaloneFeatureArcs_(0),
 nDemandsWithNonZeroMins_(0),
// localSnapshotPtr_(0),
 engine_("heuristic"),
 id_(__LGFRSCENARIOFORSCE),
 exploderPtr_(0),
 sceErrFacDisp_(0),
 sceMsgFacDisp_(0),
 sceErrFacility_(0),
 sceMsgFacility_(0),
 sceScrub_(new LgFrSceScrubber())
{
  // builder does the rest
}


// Destructor 
LgFrScenarioForSce::~LgFrScenarioForSce()
{
  LgFrSetOfDemands & univSod = this->setOfDemands();
  WitRun * theWitRun  = this->lastProblemSolved().witRun();

  // Use WIT Object Iteration to delete all the AppData's

  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    std::cout << "Deleting scenario's witRun, AppData Clones:   ogjItrState is not WitINACTIVE.   Resetting ObjItr" << std::endl;
    witResetObjItr(theWitRun);
  }

  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }

    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

    else 
      assert(1 == 0);
      
  }
  //  std::cout << "Done deleting appData from scenario's witrun" << std::endl;

  //  delete  exploderPtr_;
  //  std::cout << "Done deleting appData from exploder's witrun" << std::endl;
  
  delete  sceErrFacDisp_;
  delete  sceMsgFacDisp_;
  delete  sceErrFacility_;
  delete  sceMsgFacility_;
  
  delete  sceScrub_;

}



void
LgFrScenarioForSce::deleteAppDataAndScenarioObjects()
{
  WitRun * theWitRun  = this->lastProblemSolved().witRun();

  delete  exploderPtr_;  

  return;



  // Use WIT Object Iteration to delete all the AppData's

  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    witResetObjItr(theWitRun);
  }

  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }

    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

    else 
      assert(1 == 0);
      
  }






  //  delete  sceErrFacDisp_;
  //  delete  sceMsgFacDisp_;
  //  delete  sceErrFacility_;
  //  delete  sceMsgFacility_;
  //  delete  sceScrub_;



}






#if 0
void
LgFrScenarioForSce::deleteAppDataAndScenarioObjects()
{
  WitRun * theWitRun  = this->lastProblemSolved().witRun();

  std::cout << "Deleting Scenario objects including WIT AppData ... " << std::endl;

  // Use WIT Object Iteration to delete all the AppData's

  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    witResetObjItr(theWitRun);
  }

  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }

    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

    else 
      assert(1 == 0);
      
  }


  delete  exploderPtr_;
  
  delete  sceErrFacDisp_;
  delete  sceMsgFacDisp_;
  delete  sceErrFacility_;
  delete  sceMsgFacility_;
  
  delete  sceScrub_;
}
#endif




// Assignment operator.
LgFrScenarioForSce&
LgFrScenarioForSce::operator=(
   const LgFrScenarioForSce& rhs)
{
  // error
  (*sceErrFacility_)("sceLgFr");

/*
   if (this != &rhs) {           // Check for assignment to self
     (this->LgFrScenario::operator= ) (rhs);
     defaultSOP_ = rhs.defaultSOP_;
     defaultSOD_ = rhs.defaultSOD_;
   }
*/
   return *this;
}


// Customized copy constructor
LgFrScenarioForSce::LgFrScenarioForSce(
   const LgFrScenarioForSce& source )
: LgFrScenario( source ),
  defaultSOP_(source.defaultSOP_),
  defaultSOD_(source.defaultSOD_),
  interplantSOP_(source.interplantSOP_),
  multiPlantHelper_(source.multiPlantHelper_),
  nStandaloneFeatureArcs_(source.nStandaloneFeatureArcs_),
  nDemandsWithNonZeroMins_(source.nDemandsWithNonZeroMins_),
  critList_(source.critList_),
  parameterSet_(source.parameterSet_),
  flatFileMgr_(source.flatFileMgr_),
//  localSnapshotPtr_( source.localSnapshotPtr_ ),
  engine_(source.engine_),
  id_(__LGFRSCENARIOFORSCE),
  exploderPtr_(source.exploderPtr_),
  sceScrub_(new LgFrSceScrubber())
{
  // i don't know when the copy constructor is called, so not sure if this 
  // works... the reason i didn't assign copy error facility ptr to the 
  // original error facility ptr is because that might cause errors later
  // if one were to be destroyed...and the common facility along with it.

  // this is to create a suitable message file name
  // to this we will append a number (the integer count of the number
  // of such temporary log files are created)
  // Note: numTempFiles_ is a static data member of LgFrScenarioForSce class
  std::ifstream temp1;
  std::ifstream temp2;

  std::string errFileName = "errorLog" + numTempFiles_;
  std::string msgFileName = "messageLog" + numTempFiles_;

  temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
  temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);

  while (temp1.good() || temp2.good()) {   // this means that file exists!
    numTempFiles_++;  // maintain uniqueness among pairs of output files
    errFileName = "errorLog" + numTempFiles_;
    msgFileName = "messageLog" + numTempFiles_;
    temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
    temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);
  }

  numTempFiles_++; // need to increment since curr val is used now

  // create display and facility
  sceErrFacDisp_ = new MclPrintfOutputDisplayer(errFileName.c_str(),"w+");
  sceErrFacility_ = new MclFacility("SCE",*sceErrFacDisp_);
  sceErrFacility_->minErrOutLevel(MclLevel::error ());

  sceMsgFacDisp_ = new MclPrintfOutputDisplayer(msgFileName.c_str(),"w+");
  sceMsgFacility_ = new MclFacility("SCE",*sceMsgFacDisp_);
  sceMsgFacility_->minErrOutLevel(MclLevel::error ());
}

// Default constructor
LgFrScenarioForSce::LgFrScenarioForSce()
: LgFrScenario(),
  defaultSOP_(0),
  defaultSOD_(0),
  interplantSOP_(0),
  multiPlantHelper_(),
  critList_(),
  parameterSet_(),
  flatFileMgr_(),
  nStandaloneFeatureArcs_(0),
  nDemandsWithNonZeroMins_(0),
//  localSnapshotPtr_(0),
  engine_("heuristic"),
  id_(__LGFRSCENARIOFORSCE),
  exploderPtr_(0),
  sceErrFacDisp_(0),
  sceMsgFacDisp_(0),
  sceErrFacility_(0),
  sceMsgFacility_(0),
  sceScrub_(new LgFrSceScrubber())
{
  // Nothing to do here
}





#if 0

#ifdef NDEBUG
#undef NDEBUG
#endif

void
LgFrScenarioForSce::test()
{


  
  // Check the LgFrTestDataInterface
  // ===============================  
  LgFrCalendar calendar3;
  LgFrTestDataInterface protoDif3;              // The DIF that is copied into
					// the scenarios
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder3;
  LgFrScenarioDirector director3(&builder3);  
  director3.construct(protoDif3, calendar3);
  LgFrScenarioForSceSmartPointer testScenarioPtr3 = builder3.getScenario();

  // Test the deep copy constructor
  LgFrScenarioForSceSmartPointer testScenarioDupPtr3
		 = testScenarioPtr3.deepCopy();
  
  assert(testScenarioDupPtr3->title() != testScenarioPtr3->title());
  assert(testScenarioDupPtr3->dataInterface().isA() == __LGFRTESTDATAINTERFACE);
  assert(testScenarioDupPtr3->setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(testScenarioDupPtr3->setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(testScenarioDupPtr3->setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(testScenarioDupPtr3->setOfDemands(LGFR_DEFAULT_SET).size() == 2);

  // Test the assignment operator
  LgFrScenarioForSceSmartPointer assignee;
  assignee = testScenarioPtr3;
  
  assert(assignee.title() != testScenarioPtr3->title());
  assert(assignee.dataInterface().isA() == __LGFRTESTDATAINTERFACE);
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).size() == 2);




  // Make another deep copy
  LgFrScenarioForSceSmartPointer yetAnotherScenarioPtr
		 = testScenarioDupPtr3.deepCopy();

  // Do some downcasts
  LgFrDataInterface * tsDifPtr3 = &(testScenarioPtr3->dataInterface());
  assert (tsDifPtr3 != 0
	  &&  tsDifPtr3->isA() == __LGFRTESTDATAINTERFACE);
  LgFrTestDataInterface * tsTestDifPtr3 = (LgFrTestDataInterface *) tsDifPtr3;
	  
  LgFrDataInterface * tsDupDifPtr3 = &(testScenarioDupPtr3->dataInterface());
  assert (tsDupDifPtr3 != 0
	  &&  tsDupDifPtr3->isA() == __LGFRTESTDATAINTERFACE);
  LgFrTestDataInterface * tsDupTestDifPtr3
    = (LgFrTestDataInterface *) tsDupDifPtr3;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtr3 != tsDupTestDifPtr3);

  // And test the test dif
  LgFrTestDataInterface::contextTest
    (*testScenarioPtr3, testScenarioPtr3->lastProblemSolved(),
     *tsTestDifPtr3,
     testScenarioPtr3->setOfParts (LGFR_UNIVERSAL_SET),
     testScenarioPtr3->setOfDemands (LGFR_UNIVERSAL_SET),
     *testScenarioDupPtr3, *tsDupTestDifPtr3
     );

  // clean up all the junk that was created.


  // Test the LgFrDataInterfaceFromThinAir 
  // ===================================== 
  LgFrCalendar calendar2(8, SCETime(SCEDate("7/15/94")));
  LgFrDataInterfaceFromThinAir protoDif2; // The DIF that is copied into
					// the scenarios
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder2;
  LgFrScenarioDirector director2(&builder2);  
  director2.construct(protoDif2, calendar2);
  LgFrScenarioForSceSmartPointer testScenarioPtr2 = builder2.getScenario();

  // Shouldn't have to downcast.  Add a method in scenCMRP to get the ippCMRP
  LgFrInitialProblemForSce * testIpp2 = (LgFrInitialProblemForSce *)
			&(testScenarioPtr2->initialProblemAndParameters());
 
  // Make a copy of it
  LgFrScenarioForSceSmartPointer testScenarioDupPtr2
    = testScenarioPtr2.deepCopy();

  // Do some downcasts
  LgFrDataInterface * tsDifPtr2 = &(testScenarioPtr2->dataInterface());
  assert (tsDifPtr2 != 0
	  &&  tsDifPtr2->isA() == __LGFRDATAINTERFACEFROMTHINAIR);
  LgFrDataInterfaceFromThinAir * tsTestDifPtr2
    = (LgFrDataInterfaceFromThinAir *) tsDifPtr2;
	  
  LgFrDataInterface * tsDupDifPtr2 = &(testScenarioDupPtr2->dataInterface());
  assert (tsDupDifPtr2 != 0
	  &&  tsDupDifPtr2->isA() == __LGFRDATAINTERFACEFROMTHINAIR);
  LgFrDataInterfaceFromThinAir * tsDupTestDifPtr2
    = (LgFrDataInterfaceFromThinAir *) tsDupDifPtr2;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtr2 != tsDupTestDifPtr2);

  // Check LgFrTestDataInterface
  LgFrDataInterfaceFromThinAir::contextTest
    (*testScenarioPtr2, testScenarioPtr2->lastProblemSolved(),
     *tsTestDifPtr2,
     testScenarioPtr2->setOfParts (LGFR_UNIVERSAL_SET),
     testScenarioPtr2->setOfDemands (LGFR_UNIVERSAL_SET),
     *testScenarioDupPtr2, *tsDupTestDifPtr2
     );
  

  // Test the second Thin Air, LgFrDataInterfaceFromThinAir2
  // ===================================== 
  LgFrCalendar calendarAir2(8, SCETime(SCEDate("7/15/94")));
  LgFrDataInterfaceFromThinAir2 protoDifAir2; // The DIF that is copied into
					// the scenarios
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builderAir2;
  LgFrScenarioDirector directorAir2(&builderAir2);  
  directorAir2.construct(protoDifAir2, calendarAir2);
  LgFrScenarioForSceSmartPointer testScenarioPtrAir2 = builderAir2.getScenario();

  // Shouldn't have to downcast.  Add a method in scenCMRP to get the ippCMRP
  LgFrInitialProblemForSce * testIppAir2 = (LgFrInitialProblemForSce *)
			&(testScenarioPtrAir2->initialProblemAndParameters());
 
  // Make a deep copy of it
  LgFrScenarioForSceSmartPoitner testScenarioDupPtrAir2
    = testScenarioPtrAir2.deepCopy();  
  // Do some downcasts
  LgFrDataInterface * tsDifPtrAir2 = &(testScenarioPtrAir2->dataInterface());
  assert (tsDifPtrAir2 != 0
	  &&  tsDifPtrAir2->isA() == __LGFRDATAINTERFACEFROMTHINAIR2);
  LgFrDataInterfaceFromThinAir2 * tsTestDifPtrAir2
    = (LgFrDataInterfaceFromThinAir2 *) tsDifPtrAir2;
	  
  LgFrDataInterface * tsDupDifPtrAir2 = &(testScenarioDupPtrAir2->dataInterface());
  assert (tsDupDifPtrAir2 != 0
	  &&  tsDupDifPtrAir2->isA() == __LGFRDATAINTERFACEFROMTHINAIR2);
  LgFrDataInterfaceFromThinAir2 * tsDupTestDifPtrAir2
    = (LgFrDataInterfaceFromThinAir2 *) tsDupDifPtrAir2;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtrAir2 != tsDupTestDifPtrAir2);

  // Check LgFrTestDataInterface
  LgFrDataInterfaceFromThinAir2::contextTest
    (*testScenarioPtrAir2, testScenarioPtrAir2->lastProblemSolved(),
     *tsTestDifPtrAir2,
     testScenarioPtrAir2->setOfParts (LGFR_UNIVERSAL_SET),
     testScenarioPtrAir2->setOfDemands (LGFR_UNIVERSAL_SET),
     *testScenarioDupPtrAir2, *tsDupTestDifPtrAir2
     );
  
  
  // Check LgFrInitialProblemForSce
  // ===============================
  // Must re-create the scenario's because the dif's contextTest() methods
  // mucked around with  the witRun's.
  LgFrCalendar calendar4;
  LgFrTestDataInterface protoDif4;           
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder4;
  LgFrScenarioDirector director4(&builder4);  
  director4.construct(protoDif4, calendar4);
  LgFrScenarioForSceSmartPointer testScenarioPtr4 = builder4.getScenario();
  LgFrInitialProblemForSce * testIpp4 = (LgFrInitialProblemForSce *)
			&(testScenarioPtr4->initialProblemAndParameters());
  // Make a deep copy of it
  LgFrScenarioForSceSmartPointer testScenarioDupPtr4
    = testScenarioPtr4.deepCopy();

  // Do some downcasts
  LgFrDataInterface * tsDifPtr4 = &(testScenarioPtr4->dataInterface());


  assert (tsDifPtr4 != 0
	  &&  tsDifPtr4->isA() == __LGFRTESTDATAINTERFACE);
  LgFrTestDataInterface * tsTestDifPtr4
    = (LgFrTestDataInterface *) tsDifPtr4;
	  
  LgFrDataInterface * tsDupDifPtr4 = &(testScenarioDupPtr4->dataInterface());
  assert (tsDupDifPtr4 != 0
	  &&  tsDupDifPtr4->isA() == __LGFRTESTDATAINTERFACE);
  LgFrTestDataInterface * tsDupTestDifPtr4
    = (LgFrTestDataInterface *) tsDupDifPtr4;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtr4 != tsDupTestDifPtr4);
 

  LgFrCalendar calendar5(8, SCETime(SCEDate("7/15/94")));
  LgFrDataInterfaceFromThinAir protoDif5; // The DIF that is copied into
					// the scenarios
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder5;
  LgFrScenarioDirector director5(&builder5);  
  director5.construct(protoDif5, calendar5);
  LgFrScenarioForSceSmartPointer testScenarioPtr5 = builder5.getScenario();

  LgFrInitialProblemForSce * testIpp5 = (LgFrInitialProblemForSce *)
			&(testScenarioPtr5->initialProblemAndParameters());
   // Make a deep copy of it
  LgFrScenarioForSceSmartPointer testScenarioDupPtr5
    = testScenarioPtr5.deepCopy();

  // Do some downcasts
  LgFrDataInterface * tsDifPtr5 = &(testScenarioPtr5->dataInterface());
  assert (tsDifPtr5 != 0
	  &&  tsDifPtr5->isA() == __LGFRDATAINTERFACEFROMTHINAIR);
  LgFrDataInterfaceFromThinAir * tsTestDifPtr5
    = (LgFrDataInterfaceFromThinAir *) tsDifPtr5;
	  
  LgFrDataInterface * tsDupDifPtr5 = &(testScenarioDupPtr5->dataInterface());
  assert (tsDupDifPtr5 != 0
	  &&  tsDupDifPtr5->isA() == __LGFRDATAINTERFACEFROMTHINAIR);
  LgFrDataInterfaceFromThinAir * tsDupTestDifPtr5
    = (LgFrDataInterfaceFromThinAir *) tsDupDifPtr5;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtr5 != tsDupTestDifPtr5);
 


 LgFrCalendar calendar6(8, SCETime(SCEDate("7/15/94")));
  LgFrDataInterfaceFromThinAir2 protoDif6; // The DIF that is copied into
					// the scenarios
  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder6;
  LgFrScenarioDirector director6(&builder6);  
  director6.construct(protoDif6, calendar6);
  LgFrScenarioForSceSmartPointer testScenarioPtr6 = builder6.getScenario();

  LgFrInitialProblemForSce * testIpp6 = (LgFrInitialProblemForSce *)
			&(testScenarioPtr6->initialProblemAndParameters());
   // Make a deep copy of it
  LgFrScenarioForSceSmartPointer testScenarioDupPtr6
    = testScenarioPtr6.deepCopy();

  // Do some downcasts
  LgFrDataInterface * tsDifPtr6 = &(testScenarioPtr6->dataInterface());
  assert (tsDifPtr6 != 0
	  &&  tsDifPtr6->isA() == __LGFRDATAINTERFACEFROMTHINAIR2);
  LgFrDataInterfaceFromThinAir2 * tsTestDifPtr6
    = (LgFrDataInterfaceFromThinAir2 *) tsDifPtr6;
	  
  LgFrDataInterface * tsDupDifPtr6 = &(testScenarioDupPtr6->dataInterface());
  assert (tsDupDifPtr6 != 0
	  &&  tsDupDifPtr6->isA() == __LGFRDATAINTERFACEFROMTHINAIR2);
  LgFrDataInterfaceFromThinAir2 * tsDupTestDifPtr6
    = (LgFrDataInterfaceFromThinAir2 *) tsDupDifPtr6;


  // Check for typo's in the downcasting code
  assert (tsTestDifPtr6 != tsDupTestDifPtr6);
  
  LgFrInitialProblemForSce::contextTest
    (*testIpp4, *tsTestDifPtr4, *testIpp5, *tsTestDifPtr5, *testIpp6, *tsTestDifPtr6 );

  // Test LgFrScheduleFactoryForSce
  LgFrScheduleFactoryForSce::contextTest ( * (testScenarioDupPtr5
					       ->scheduleFactory())  );

  // Test LgFrInitialProblemForScewithPrioritesFromDif
  {
  LgFrDataInterfaceFromCmrpFiles difWithPriorities("../../cmrpData/difTest");
  LgFrCalendar calendar7( 3,SCETime(SCEDate(10,4,1995)),LgFrDay);
  LgFrScenarioBuilderForSce builder7;
  LgFrScenarioDirector director7(&builder7);  
  director7.construct(difWithPriorities, calendar7);
  LgFrScenarioForSceSmartPointer testScenarioPtr7 = builder7.getScenario();
  LgFrInitialProblemForScewithPrioritiesFromDif * testIpp7 = 
			(LgFrInitialProblemForScewithPrioritiesFromDif *)
			&(testScenarioPtr7->initialProblemAndParameters());
  LgFrDataInterface * tsDifPtr7 = &(testScenarioPtr7->dataInterface());
  assert (tsDifPtr7 != 0
	  &&  tsDifPtr7->isA() == __LGFRDATAINTERFACEFROMCMRPFILES);
  LgFrDataInterfaceFromCmrpFiles * tsTestDifPtr7 = 
	 (LgFrDataInterfaceFromCmrpFiles *) tsDifPtr7;
  LgFrInitialProblemForScewithPrioritiesFromDif::contextTest( 
     *testIpp7,
     *tsTestDifPtr7); 
  }

  // Now that source/rhs (testScenarioDupPtr3) has been deleted, 
  // retest the assignee and yetAnotherScenarioPtr

  assert(assignee.title() != testScenarioPtr3->title());
  assert(assignee.dataInterface().isA() == __LGFRTESTDATAINTERFACE);
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).size() == 2);

  assert(yetAnotherScenarioPtr->title() != testScenarioPtr3->title());
  assert(yetAnotherScenarioPtr->dataInterface().isA() == __LGFRTESTDATAINTERFACE);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(yetAnotherScenarioPtr->setOfDemands(LGFR_DEFAULT_SET).size() == 2);


}


 
#endif

@


1.76
log
@fixed some formatting errors in indpInterplantPegging
@
text
@d877 6
a882 1
   int printIfZero = 1;
d952 2
a953 2
       flatFileMgr_.writeFloatVecToStream(theCal, outFile, nPeriods, 0, leadingString, mrpConsVol); 
       //        flatFileMgr_.writePartPdfRecord(theCal, partname, pdf, mrpConsVol, outFile, nPeriods, nonZeroOnly);
@


1.75
log
@printIfzero modified for indSupResp
@
text
@d2983 2
a2984 1
	  flatFileMgr_.writeFloatVecToStream(this->calendar(), outFile, nPeriods, 0, leadingString, transformedTimeVec.data());
@


1.74
log
@fixed compatability issues between version 5 and 6
@
text
@d4256 1
a4256 1
	  int t = 0; // Pulled out of the for below by RW2STL
d4265 8
a4272 2
	bool printIfZero = false;
	// SCE 6.1
@


1.73
log
@fix for backward compat to sce5
@
text
@d170 1
a170 1
      // SCE 6.1 
a172 1
	std::string iPeggedCriticalListFileName =	setOfParameters.getString("iPeggedCritListFileName");
d176 8
a183 8
      // pre 6.1
      else {
	if (setOfParameters.getBool("printPeggedCritListFile"))  {    
	  std::string peggedCriticalListFileName  = setOfParameters.getString("peggedCritListFileName");
	  std::string iPeggedCriticalListFileName =	setOfParameters.getString("iPeggedCritListFileName");
	  std::string engine = setOfParameters.getString( "engine");
	  this->printPeggedCriticalList(theWitRun, engine, peggedCriticalListFileName, iPeggedCriticalListFileName, theCal, mpHelper);
	}
d187 1
a253 1
    // (prints only when there is substitute  input data)
a406 110
// SCE 6.1
int
LgFrScenarioForSce::printAnInterplantPegFile(WitRun * const theWitRun, 
					     LgFrMultiPlantHelper & mpHelper,
					     LgFrCalendar & theCal,
					     int pegType,
					     int tinpIndpOrBoth, 
					     std::string & pegFileName,
					     int nParts,
					     char ** partList,
					     int nPeriods)
{
  std::ofstream dPIPFile;
  dPIPFile.open(pegFileName.c_str(), std::ofstream::out);
  if (dPIPFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << pegFileName << pegFileName);
  }

  int goodRec = 0;
  int printIfZero = 0;
  
  char * fullWitDemandedPartName;
  char * demandName;
  int isDemandedPartGPD;
  
  // Loop over parts to get demands
  int i = 0;
  for(i=0; i<nParts; i++){
    fullWitDemandedPartName = partList[i];
    std::string plannerPart, geo;
    if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitDemandedPartName, plannerPart, geo)) 
      isDemandedPartGPD = TRUE;
    else {
      isDemandedPartGPD = FALSE;
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPartName)) {
	continue;
      }
    }
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, fullWitDemandedPartName, &nDemands, &dList);
    
    // For GPD demands, can assert there's at most one demand. (get rid of this at some point)
    if (isDemandedPartGPD)   
      assert(nDemands < 2);
    
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];
      
      // get the demandAppData, if none exists, then skip it
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
      witGetDemandAppData( theWitRun, fullWitDemandedPartName, demandName, (void **) &demandAppDataPtr );
      if ( demandAppDataPtr == 0 ) {
	witFree (dList[j]);
	continue;
      }
      
      // Get const references to the consVol PIP  schedules stored in app data
      // get the correct PIPSched
      const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSched(pegType);
      
      // Loop over each consumed part
      int nConsumedParts = PIPSched.size();
      int cp = 0; 
      for ( cp=0; cp<nConsumedParts; cp++ ) {
	// get part
	const LgFrPart & consumedPart = PIPSched.part(cp);


	// report only for interplant operations
	std::string pn1,customerPdf,pn2,supplierPdf;
	if (! mpHelper.isOperationSpecialInterplant(theWitRun, consumedPart.name(), pn1, customerPdf, pn2, supplierPdf)) {
	  continue;
	}
	
	
	// Get this  PIP timeVec
	LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	
	if (isDemandedPartGPD)   {
	  flatFileMgr_.writeGpdInterplantPegRecord(theCal, mpHelper, 
						   plannerPart, geo, 
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	  goodRec++;
	}
	else   {
	  flatFileMgr_.writeIndpInterplantPegRecord(theCal, mpHelper, 
						    mpHelper.partname(fullWitDemandedPartName), mpHelper.pdf(fullWitDemandedPartName), demandName,
						    pn1, customerPdf, pn2, supplierPdf,
						    PIPTV.data(), dPIPFile, nPeriods, printIfZero);

	  goodRec++;
	}
      }
      
      
      witFree(dList[j]);
    }
    witFree(dList);
  }
  
  dPIPFile.close();
  return goodRec;
}



d423 1
d436 2
d481 1
a481 3
      // Get const references to the consVol PIP  schedules stored in app data

      // get the correct PIPSched
d491 12
a502 3
	// only report for normal pegged-to parts
	if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	  continue;
a504 1
	// Get this  PIP timeVec
d507 15
a521 13
	if (isDemandedPartGPD)   {
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	  goodRec++;
	}
	else   {
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPartName), mpHelper.pdf(fullWitDemandedPartName), demandName,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), dPIPFile, nPeriods, printIfZero);
	  
	  goodRec++;
d523 17
a541 1
      
d665 1
a665 2
  //  otherwise, we print each seperately.  for now set it to jsut tinp
  if (useMultiAttributeDemand)
d667 17
a683 1
  else 
d686 14
a699 15
  if (printSupplyPegFile) 
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SUPPLY, tinpIndpOrBoth, supplyPegFileName, nParts, partList, nPeriods);
  if (printDemandConsPegFile)  
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_CONSVOL, tinpIndpOrBoth, demandConsPegFileName, nParts, partList, nPeriods);
  if (printPfProdVolPegFile) 
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_PRODVOL, tinpIndpOrBoth, pfProdVolPegFileName, nParts, partList, nPeriods);
  if (printSideVolPegFile) 
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SIDEVOL, tinpIndpOrBoth, sideVolPegFileName, nParts, partList, nPeriods);
  if (printProdVolPegFile)  
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_EXECVOL, tinpIndpOrBoth, prodVolPegFileName, nParts, partList, nPeriods);
  if (printInterplantPegFile)  
    goodRec += printAnInterplantPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, tinpIndpOrBoth, interplantPegFileName, nParts, partList, nPeriods);


  if (useMultiAttributeDemand) {
a700 1

d712 1
a712 1
      goodRec += printAnInterplantPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, tinpIndpOrBoth, indpInterplantPegFileName, nParts, partList, nPeriods);
d714 1
a714 1

d4062 4
a4065 6
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Supply Response" 
		       << fileName);
  }
a4067 1
  
a4069 1
  
d4074 8
a4081 1
  
a4093 2
	  //	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
	  
a4094 5
	  
	  bool printIfZero = false;
	  // SCE 6.1
	  //	flatFileMgr_.writeDemandRecord(outFile, mpHelper, theCal, partname, pdf, dList[j], nPeriods, shipVol, printIfZero, 0, 15);
	  
a4095 2
	  
	  //	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
d4114 1
a4114 1
	  // adjust shipVOl for negative demand
d4128 1
a4128 2
	  bool printIfZero = false;
	  // SCE 6.1
a4129 1
	  
a4136 1
      
a5150 1302
#ifdef SCE5

void
LgFrScenarioForSce::printPIPData(WitRun * const theWitRun, int isItMrp)
{


  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrCalendar & theCal = calendar();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();


  int nonZeroOnly = 0;
  int alwaysPrint = 1;


  // supply pegging ...
  bool printSupplyPegFile = setOfParameters.getBool("printSupplyPegFile");
  bool printIndpSupplyPegFile = setOfParameters.getBool("printIndpSupplyPegFile");

  std::string supplyPegFileName = setOfParameters.getString("supplyPegFileName");
  std::string indpSupplyPegFileName = setOfParameters.getString("indpSupplyPegFileName");




  bool printDemandConsPegFile = setOfParameters.getBool("printDemandConsPegFile");
  bool printIndpDemandConsPegFile = setOfParameters.getBool("printIndpDemandConsPegFile");

  std::string demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
  std::string indpDemandConsPegFileName = setOfParameters.getString("indpDemandConsPegFileName");
  
  bool printInterplantPegFile = setOfParameters.getBool("printInterplantPegFile");
  bool printIndpInterplantPegFile = setOfParameters.getBool("printIndpInterplantPegFile");
  
  std::string interplantPegFileName = setOfParameters.getString("interplantPegFileName");
  std::string indpInterplantPegFileName = setOfParameters.getString("indpInterplantPegFileName");

  bool printExecVolPegFile = setOfParameters.getBool("printExecVolPegFile");
  bool printIndpExecVolPegFile = setOfParameters.getBool("printIndpExecVolPegFile");

  std::string execVolPegFileName = setOfParameters.getString("execVolPegFileName");
  std::string indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");

  bool printProdVolPegFile = setOfParameters.getBool("printProdVolPegFile");
  std::string prodVolPegFileName = setOfParameters.getString("prodVolPegFileName");

  bool printIndpProdVolPegFile = setOfParameters.getBool("printIndpProdVolPegFile");
  std::string indpProdVolPegFileName = setOfParameters.getString("indpProdVolPegFileName");

  bool printPfProdVolPegFile = setOfParameters.getBool("printPfProdVolPegFile");
  std::string pfProdVolPegFileName = setOfParameters.getString("pfProdVolPegFileName");

  bool printIndpPfProdVolPegFile = setOfParameters.getBool("printIndpPfProdVolPegFile");
  std::string indpPfProdVolPegFileName = setOfParameters.getString("indpPfProdVolPegFileName");

  bool printSideVolPegFile = setOfParameters.getBool("printSideVolPegFile");
  std::string sideVolPegFileName = setOfParameters.getString("sideVolPegFileName");

  bool printIndpSideVolPegFile = setOfParameters.getBool("printIndpSideVolPegFile");
  std::string indpSideVolPegFileName = setOfParameters.getString("indpSideVolPegFileName");

  if (isItMrp) {
    printSupplyPegFile = setOfParameters.getBool("printMrpSupplyPegFile");
    printIndpSupplyPegFile = setOfParameters.getBool("printMrpIndpSupplyPegFile");
    
    indpSupplyPegFileName = setOfParameters.getString("mrpIndpSupplyPegFileName");
    supplyPegFileName = setOfParameters.getString("mrpSupplyPegFileName");

    printDemandConsPegFile = setOfParameters.getBool("printMrpDemandConsPegFile");
    printIndpDemandConsPegFile = setOfParameters.getBool("printMrpIndpDemandConsPegFile");
    
    indpDemandConsPegFileName = setOfParameters.getString("mrpIndpDemandConsPegFileName");
    demandConsPegFileName = setOfParameters.getString("mrpDemandConsPegFileName");

    printInterplantPegFile = setOfParameters.getBool("printMrpInterplantPegFile");
    printIndpInterplantPegFile = setOfParameters.getBool("printMrpIndpInterplantPegFile");

    interplantPegFileName = setOfParameters.getString("mrpInterplantPegFileName");    
    indpInterplantPegFileName = setOfParameters.getString("mrpIndpInterplantPegFileName");

    printExecVolPegFile = setOfParameters.getBool("printMrpExecVolPegFile");
    printIndpExecVolPegFile = setOfParameters.getBool("printMrpIndpExecVolPegFile");

    execVolPegFileName = setOfParameters.getString("mrpExecVolPegFileName");    
    indpExecVolPegFileName = setOfParameters.getString("mrpIndpExecVolPegFileName");

    printProdVolPegFile = setOfParameters.getBool("printMrpProdVolPegFile");
    prodVolPegFileName = setOfParameters.getString("mrpProdVolPegFileName");

    printIndpProdVolPegFile = setOfParameters.getBool("printMrpIndpProdVolPegFile");
    indpProdVolPegFileName = setOfParameters.getString("mrpIndpProdVolPegFileName");

    printPfProdVolPegFile = setOfParameters.getBool("printMrpPfProdVolPegFile");
    pfProdVolPegFileName = setOfParameters.getString("mrpPfProdVolPegFileName");

    printIndpPfProdVolPegFile = setOfParameters.getBool("printMrpIndpPfProdVolPegFile");
    indpPfProdVolPegFileName = setOfParameters.getString("mrpIndpPfProdVolPegFileName");

    printSideVolPegFile = setOfParameters.getBool("printMrpSideVolPegFile");
    sideVolPegFileName = setOfParameters.getString("mrpSideVolPegFileName");

    printIndpSideVolPegFile = setOfParameters.getBool("printMrpIndpSideVolPegFile");
    indpSideVolPegFileName = setOfParameters.getString("mrpIndpSideVolPegFileName");


  }

  int nPeriods;
  char  *demandName, *fullWitGPDPartName;
  
  int goodRec = 0;
  
  std::cout << "Writing PIP (Pegging) information..." << std::endl;    
  
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);
  
  
  std::string plannerPart, geo;


  // --------------------------
  // SupplyConsPegFile 
  // --------------------------
  if (printSupplyPegFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand Peg OUTPUT file
    dPIPFile.open(supplyPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Supply PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << supplyPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }
	  
	  // Get this  PIPsupplyVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();

	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpDemandSupplyPegFile 
  // --------------------------
  if (printIndpSupplyPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Supply PIP OUTPUT file
    idPIPFile.open(indpSupplyPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Supply PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpSupplyPegFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }






  // --------------------------
  // DemandConsPIPFile 
  // --------------------------
  if (printDemandConsPegFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(demandConsPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Demand PIP Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << demandConsPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; 
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }

	  
	  // Get this  PIPconsVol timeVec

	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpDemandConsPIPFile 
  // --------------------------
  if (printIndpDemandConsPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpDemandConsPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Demand PIPging Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpDemandConsPegFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }


  // --------------------------
  // ProdVolPIPFile  from ProdVol !!!
  // --------------------------
  if (printPfProdVolPegFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(pfProdVolPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("ProdVol (from ProdVol) PIP Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << pfProdVolPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPProdVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }

	  
	  // Get this  PIPconsVol timeVec

	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpProdVolPIPFile  (from ProdVol)
  // --------------------------
  if (printIndpPfProdVolPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpPfProdVolPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent PfProdVol PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpPfProdVolPegFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPProdVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }

  // ++++++++++++++++++
  // --------------------------
  // SideVolPIPFile
  // --------------------------
  if (printSideVolPegFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(sideVolPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("SideVol PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << sideVolPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the  PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSideVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }

	  
	  // Get this  PIPconsVol timeVec

	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpSideVolPIPFile
  // --------------------------
  if (printIndpSideVolPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpSideVolPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent SideVol PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpSideVolPegFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSideVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }

  // ++++++++++++++++++



  // --------------------------
  // ExecVolPIPFile  (diagnostic)
  // --------------------------
  if (printExecVolPegFile)  {
    std::ofstream evPIPFile;
  
    // Now open the ExecVol Demand PIP OUTPUT file
    evPIPFile.open(execVolPegFileName.c_str());
    if (evPIPFile.fail()) {
      std::string fileErrorString("ExecVol PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << execVolPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & operation = PIPSched.part(cp);


	  // report ALL Operations
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the total Demand due to Focus: FSSReq
	  evPIPFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\",\""
		    << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(evPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    evPIPFile.close();
  }

  // ----------------------------------
  // ProdVolPIPFile  FROM EXEC VOL !!!!
  // ----------------------------------
  if (printProdVolPegFile)  {
    std::ofstream pvPIPFile;
  
    // Now open the ExecVol Demand PIP OUTPUT file
    pvPIPFile.open(prodVolPegFileName.c_str());
    if (pvPIPFile.fail()) {
      std::string fileErrorString("ProdVol PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << prodVolPegFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	


	// TOMMY HERE
	// Loop over each operation
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  // get operation
	  const LgFrPart & operation = PIPSched.part(cp);
	  
	  
	  // only report on DEFAULT Operations  
	  if (! mpHelper.isPartNormal(theWitRun,
				      operation.name())) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(operation.name()), mpHelper.pdf(operation.name()), 
					 PIPTV.data(), pvPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    pvPIPFile.close();
  }






  // xxxxxxxxxxxxxx
  // --------------------------
  // indpProdVolPegFile
  // --------------------------
  if (printIndpProdVolPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent ProdVol PIP OUTPUT file
    idPIPFile.open(indpProdVolPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent ProdVol PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpProdVolPegFileName);
    }


    // stop here
    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();


	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }


  // --------------------------
  // indpExecVolPIPFile (diagnostic)
  // --------------------------
  if (printIndpExecVolPegFile)  {

    std::ofstream idEvPIPFile;
  
    // Now open the Independent  Demand ExecVol  PIP OUTPUT file
    idEvPIPFile.open(indpExecVolPegFileName.c_str());
    if (idEvPIPFile.fail()) {
      std::string fileErrorString("Independent Demand ExecVol PIPging  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpExecVolPegFileName);
    }
  

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	
	// Loop over each operation
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  // get part
	  const LgFrPart & operation = PIPSched.part(cp);


	  // report ALL Operations
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIP vector
	  idEvPIPFile << "\""
		      << mpHelper.partname(fullWitDemandedPart) << "\",\""
		      << mpHelper.pdf(fullWitDemandedPart) << "\","
		      << demandId << "\",\""
		      << mpHelper.partname(operation.name()) << "\",\""
		      << mpHelper.pdf(operation.name()) << "\",\""
		      << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(idEvPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
    idEvPIPFile.close();
  }


  // --------------------------
  // InterplantPIPFile
  // --------------------------
  if (printInterplantPegFile)  {

    std::ofstream ipPIPFile;
  
    // Now open the Interplant Demand PIP OUTPUT file
    ipPIPFile.open(interplantPegFileName.c_str());
    if (ipPIPFile.fail()) {
      std::string fileErrorString("Interplant PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << interplantPegFileName);
    }
  

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; 
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the interplant PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  const LgFrPart & part = PIPSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, part.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeGpdInterplantPegRecord(theCal, mpHelper, 
						   plannerPart, geo, 
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), ipPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    ipPIPFile.close();
  }

  // --------------------------
  // indpInterplantPIPFile
  // --------------------------
  if (printIndpInterplantPegFile)  {

    std::ofstream idIpPIPFile;
  
    // Now open the Independent Interplant Demand PIP OUTPUT file
    idIpPIPFile.open(indpInterplantPegFileName.c_str());
    if (idIpPIPFile.fail()) {
      std::string fileErrorString("Independent Interplant Demand PIPging  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpInterplantPegFileName);
    }
  

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
	
	// Loop over each consumed part
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  const LgFrPart & operation = PIPSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, operation.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();

	  flatFileMgr_.writeIndpInterplantPegRecord(theCal, mpHelper, 
						   mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), idIpPIPFile, nPeriods, nonZeroOnly);



	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
    idIpPIPFile.close();
  }


  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++) {
    witFree(partList[i]);
  }
  witFree(partList);


}    

#endif
@


1.72
log
@6.2 latest commits to old repository
@
text
@d117 11
a127 4
    if (setOfParameters.getBool("printSupplyResponseFile"))  {
      std::string supplyResponseFileName = setOfParameters.getString("supplyResponseFileName");
      printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
			supplyResponseFileName, theCal, mpHelper);
d129 8
d138 3
a140 3
    // Independent Supply Response  File
    // 6.1 temporary function ... need more flexibility to support legacy
    if (! setOfParameters.getBool("useMultiAttributeDemand")) {
d146 1
d149 2
a150 2


d411 8
a418 7
					   LgFrMultiPlantHelper & mpHelper,
					   LgFrCalendar & theCal,
					   int pegType, 
					   std::string & pegFileName,
					   int nParts,
					   char ** partList,
					   int nPeriods)
d527 2
a528 1
				  int pegType, 
d556 12
d637 5
a641 1

d654 1
d656 2
d659 1
a659 1
  // supply pegging ...
d662 3
d668 2
d673 2
d678 2
d683 2
d688 2
d693 2
d700 2
d705 2
d710 3
d716 3
d722 3
d728 3
d734 3
d748 7
a754 1

d756 1
a756 1
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SUPPLY, supplyPegFileName, nParts, partList, nPeriods);
d758 1
a758 1
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_CONSVOL, demandConsPegFileName, nParts, partList, nPeriods);
d760 1
a760 1
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_PRODVOL, pfProdVolPegFileName, nParts, partList, nPeriods);
d762 1
a762 1
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_SIDEVOL, sideVolPegFileName, nParts, partList, nPeriods);
d764 1
a764 1
    goodRec += printAPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_EXECVOL, prodVolPegFileName, nParts, partList, nPeriods);
d766 2
a767 1
    goodRec += printAnInterplantPegFile(theWitRun, mpHelper, theCal, PEG_TYPE_INTERPLANT, interplantPegFileName, nParts, partList, nPeriods);
d769 16
d4115 4
a4118 1
// SCE 6.1
d4126 1
d4136 1
a4136 1
		       << "6.1 Supply Response" 
a4154 1
    // Determine if it's a TINP or INDP type of demand (we do this inside the engine based on wit objects)
d4156 22
a4177 20
    // *****   The TINP case
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      std::string partname = mpHelper.partname(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	//	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
	
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);

	bool printIfZero = false;
	// SCE 6.1
	//	flatFileMgr_.writeDemandRecord(outFile, mpHelper, theCal, partname, pdf, dList[j], nPeriods, shipVol, printIfZero, 0, 15);

	flatFileMgr_.writeGpdDemandRecord(outFile, mpHelper, theCal, partname, dList[j], nPeriods, shipVol, printIfZero, 0, 15);

	//	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
	witFree(shipVol); 
	witFree(dList[j]);
	numRecords++;
a4178 1
      witFree(dList);
d4181 2
a4182 3

    // ***** The INDP case
    else   {
d4204 1
a4204 1

d4215 1
d4217 2
a4218 2
    }
  }    
d4225 1
a4225 1
#if 0 
a4258 2
    //    int x = mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
    //                                                plannerPart, geo);
d4283 1
@


1.71
log
@only print non-zero values in partDB
@
text
@d1323 1
a1323 1
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d2492 1
a2492 1
	witGetPartNBomEntries(theWitRun, plannerTopLevelPart.c_str(), &nBom);
@


1.70
log
@fixed some logging stuff
@
text
@a6951 1
  //   int alwaysPrintForECAonly = (siteCustomization == "eca" ? 1 : 0);
d7541 1
a7541 1
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "supplyVol", supplyVolSpecifiedByUser, outFile, nPeriods, alwaysPrintForECAonly);
d7544 1
a7544 1
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemVol", negDemVol.data(), outFile, nPeriods, alwaysPrint);
d7552 1
a7552 1
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemMrpConsVol", negDemMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
d7560 1
a7560 1
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpStockVol", mrpStockVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
d7565 1
a7565 2
      //      numRecords += flatFileMgr_.writeDbDumpRecordBool(theCal, pn, pdf, "execFlag", execFlag, outFile, nPeriods);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "yield", yieldRate, outFile, nPeriods, alwaysPrint);
d7596 1
a7596 1
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "excessVol", excessVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
d7599 1
a7599 1
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "stockVol", stockVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
d7601 1
a7601 1
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "consVol", consVol, outFile, nPeriods, alwaysPrint);
@


1.69
log
@selective Sets is working under 6.1
@
text
@d2298 1
a2298 3
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Optional Feature Ratio" 
		       << fileName);
a2317 3

  // Loop once for each part, looking for stand alone options
  // Here we are going to take into account the 2-passes of implosions needed to "build features"
d2323 1
a2323 6
    if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, 
						custChoiceFeaturePart, 
						ggg, 
						mmm, 
						ppp, 
						featurePart)) {
d2332 1
a2332 1
      int j = 0; // Pulled out of the for below by RW2STL
d2337 1
a2337 3
	if (! mpHelper.isDemandSpecialCustChoiceFeature( theWitRun, custChoiceFeaturePart,
							 custChoiceDemandName,
							 plannerPart, geo ))
a2360 3
#if 1 
	// THE NEW WAY
	// What was the supplyVol of the specal feature part
d2364 1
a2364 1
	// What was the execVol  of the specal feature part
d2368 1
a2368 1
	int t = 0; // Pulled out of the for below by RW2STL
a2370 3
	

#endif
d2372 1
a2372 1
	// What was the consVol of the specal feature part
a2394 17
	if (printDataAsPercentage) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
	    if (gpdExecVol[t] < 0.01) 
	      feasibleFeatureRatio[t] = 0.0;
	    else 
	      feasibleFeatureRatio[t] = featureConsVol[t]/gpdExecVol[t];
	  }
	}
#if 0
	else {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
	    feasibleFeatureRatio[t] = featureConsVol[t];
	  }
	}
#endif
a2402 1

a2406 1

d2670 1
a2670 3
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Selective Feature/Building Block Ratio" 
		       << fileName);
d2683 2
a2684 2
  float * feasibleFeatureRatio = new float[nPeriods];
  
d2688 1
a2688 4
    //    std::cout << "Looping thru operations ..." << std::endl;;
    if (! mpHelper.isOperationSpecialOptionDummy(theWitRun, fullWitSodName, plannerTopLevelPart, 
					    geo, bbCategory, mfgOptionPart)) {
      //      std::cout << " ... skipping Operation: " << fullWitSodName << std::endl;
a2690 1
    //    std::cout << " ... processing SOD Operation: " << fullWitSodName << std::endl;
d2695 4
a2698 29
    
    // if the user wants data as a percentage of geoPlanner ship vol,
    // then we must get that and do the math.
    if (printDataAsPercentage) {
      // find the build volume of the geoPLannerDemandPart
      std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo));
      float * gpdExecVol;
      witGetOperationExecVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdExecVol);
      
      for (t=0; t<nPeriods; t++)   {
	if (gpdExecVol[t] < 0.01) 
	  feasibleFeatureRatio[t] = 0.0;
	else 
	  feasibleFeatureRatio[t] = sodExecVol[t]/gpdExecVol[t];
      }
      witFree(gpdExecVol);
    }
     
    // first print the preamble of the record
    outFile << "\"" << plannerTopLevelPart 
	    << "\",\"" << geo 
	    << "\",\"" << bbCategory 
	    << "\",\"" << mfgOptionPart << "\"";
    
    if (printDataAsPercentage) 
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);
    else
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, sodExecVol, 4, 15);      
a2701 2
  
  delete [] feasibleFeatureRatio;
d2706 1
@


1.68
log
@mfo is folded into featratio file
@
text
@d924 1
a924 1
       flatFileMgr_.writeFloatVecToStream(theCal, outFile, nPeriods, printIfZero, leadingString, mrpConsVol); 
@


1.67
log
@more dated fixes
@
text
@d2438 3
a2440 4
	leadingString = "\"" 
	  + plannerPart + "\",\"" 
	  + geo + "\",\"" 
	  + featurePart + "\"";
d2580 3
a2582 4
	leadingString = "\"" 
	  + plannerPart + "\",\"" 
	  + geo + "\",\"" 
	  + featurePart + "\"";
@


1.66
log
@pegging and sub enablement for 6.1
@
text
@d1004 2
d1155 10
d4533 63
d4653 3
@


1.65
log
@6.1 prep commit ... many things in here
@
text
@d80 1
d116 4
a119 4
    // Supply Response  File: mandatory file
    std::string supplyResponseFileName = setOfParameters.getString("supplyResponseFileName");

    printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
d121 1
d123 2
a124 2
    // Independent Supply Response  File: optional
    // 6.1 temporary function ... need more felxibility to support legacy
d135 1
a135 9

    // Supply Response By PDF  File: optional file
    if (setOfParameters.getBool("printGeoSupplyByPdfFile"))  {
      std::string geoSupplyByPdfFileName = setOfParameters.getString("geoSupplyByPdfFileName");
      printGeoSupplyByPdf(theWitRun, nPeriods, nParts, partList,
			  geoSupplyByPdfFileName, theCal, mpHelper);
    }

    // Backlog Response File: optional file
d144 1
a144 1
    // Critical List: optional file
d152 18
a169 10
    // Pegged Critical List: optional file
    if (setOfParameters.getBool("printPeggedCritListFile"))  {    
      std::string peggedCriticalListFileName  = setOfParameters.getString("peggedCritListFileName");
      std::string iPeggedCriticalListFileName =	setOfParameters.getString("iPeggedCritListFileName");
      std::string engine = setOfParameters.getString( "engine");
      this->printPeggedCriticalList(theWitRun, engine, 
				    peggedCriticalListFileName, 
				    iPeggedCriticalListFileName, 
				    theCal,
				    mpHelper);
d172 1
a172 2

    
a173 1
      // Build Schedule  File: mandatory file
d176 1
a176 3
      printBuildSchedule(theWitRun, nPeriods, nParts, partList,
			 buildSchedFileName,
			 theCal, mpHelper);
a206 2


d267 1
a267 2
      printSubstituteUsageVolume(theWitRun, 
				 parentMustBeUserDefinedOperation,
d269 1
a269 2
				 nPeriods, nOperations, opList,
				 subUsageFileName,
d668 4
a671 7
  int nPeriods;
  char  *demandName, *fullWitGPDPartName, *fullWitDemandedPartName;
  bool isDemandedPartGPD;
  int goodRec = 0;
  
  std::cout << "Writing PIP (Pegging) information..." << std::endl;    
  
a675 3
  
  
  std::string plannerPart, geo;
d692 1
a692 175


  // THIS_IS_WHERE+IM_AT  
#if 0

  // --------------------------
  // InterplantPIPFile
  // --------------------------
  if (printInterplantPegFile)  {

    std::ofstream ipPIPFile;
  
    // Now open the Interplant Demand PIP OUTPUT file
    ipPIPFile.open(interplantPegFileName.c_str());
    if (ipPIPFile.fail()) {
      std::string fileErrorString("Interplant PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << interplantPegFileName);
    }
  

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; 
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the interplant PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  const LgFrPart & part = PIPSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, part.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeGpdInterplantPegRecord(theCal, mpHelper, 
						   plannerPart, geo, 
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), ipPIPFile, nPeriods, nonZeroOnly);

	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    ipPIPFile.close();
  }


  // --------------------------
  // indpInterplantPIPFile
  // --------------------------
  if (printIndpInterplantPegFile)  {

    std::ofstream idIpPIPFile;
  
    // Now open the Independent Interplant Demand PIP OUTPUT file
    idIpPIPFile.open(indpInterplantPegFileName.c_str());
    if (idIpPIPFile.fail()) {
      std::string fileErrorString("Independent Interplant Demand PIPging  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpInterplantPegFileName);
    }
  

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
	
	// Loop over each consumed part
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  const LgFrPart & operation = PIPSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, operation.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();

	  flatFileMgr_.writeIndpInterplantPegRecord(theCal, mpHelper, 
						   mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), idIpPIPFile, nPeriods, nonZeroOnly);



	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
    idIpPIPFile.close();
  }

#endif


  int i = 0; // Pulled out of the for below by RW2STL
a696 2


a700 44












































d3008 1
d3013 7
a3019 1
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, transformedTimeVec.data(), 0, 15);
a4076 112
//  ---------------------------------------------------------------------
//  Print GEO Supply By PDF  Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printGeoSupplyByPdf(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
   
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Supply Response by PDF" 
		       << fileName);
  }

   long numRecords = 0; 
   int i, t, tt, ttt;
   float * gpdProdVol;
   int * totalGeoToPdfSourceIndicator = new int[nPeriods];
   int * geoToPdfSourceIndicator = new int[nPeriods];
   float * geoByPdfSupplyVol = new float[nPeriods];
   std::string * sourceList = new std::string[nPeriods];


   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     // only look at geoPlannerDemandParts
     if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						      partList[i], plannerPart, geo))
       continue;

     // initialize the total indicator vector to 0 for this GPD part
     for (t=0; t<nPeriods; t++) {
       totalGeoToPdfSourceIndicator[t] = 0;
     }

     // get the GeoSource Vector rule
     determineGeoToPdfSourceVector(theWitRun, 
				   mpHelper,
				   partList[i],
				   sourceList);
     
     
     // prodVol of the GPD part is equivalent to the shipVol (we hope)
     witGetPartProdVol(theWitRun, partList[i], &gpdProdVol);

     // now try to write out one vector for each possible geo->Pdf combo
     for (t=0; t<nPeriods; t++) {
       // if the total indicator vector is 1, then we've already reported this source
       if (totalGeoToPdfSourceIndicator[t] == 1)
	 continue;
       // otherwise, we found an unreported source

       // init the indicator vector for this part,pdf
       for (tt=0; tt<nPeriods; tt++)
	 geoToPdfSourceIndicator[tt] = 0;

       // mark period t as true for this source
       geoToPdfSourceIndicator[t] = 1;
       totalGeoToPdfSourceIndicator[t] = 1;

       // now loop over the rest of the horizon to see if
       // any other periods are sourced the same as period t.
       // mark each tt in both the total indicator and the local
       // one.
       for (tt=t+1; tt<nPeriods; tt++) {
	 if ((totalGeoToPdfSourceIndicator[tt] == 0) && (sourceList[tt] == sourceList[t])) {
	   totalGeoToPdfSourceIndicator[tt] = 1;
	   geoToPdfSourceIndicator[tt] = 1;
	 }
       }

       // ok, at this point the entire geoToPdfSourceIndicator vector
       // should be "populated".  So now we can report on the current
       // source.  (Note the source is sourceList[t] still.)
       mfgPart = mpHelper.partname(sourceList[t]);
       pdf = mpHelper.pdf(sourceList[t]);


       // multiply the total gpdProdVol by the indicator vector to get
       // the amount from this particular PDF.
       for (ttt=0; ttt<nPeriods; ttt++)       
	 geoByPdfSupplyVol[ttt] = gpdProdVol[ttt] * geoToPdfSourceIndicator[ttt];

       // Now you can print this record.  
       outFile << "\"" << plannerPart << "\",\"" << geo << "\","
	       << "\"" << mfgPart     << "\",\"" << pdf << "\"";

       flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, geoByPdfSupplyVol, 0, 15);
       numRecords++;
     }
     witFree(gpdProdVol);

   }
   delete [] geoByPdfSupplyVol;
   delete [] totalGeoToPdfSourceIndicator;
   delete [] geoToPdfSourceIndicator;
   delete [] sourceList;

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d4577 174
d4899 1
a4899 2
		 << "\"" << critpartname << "\","
		 << "\"" << critpdf << "\","
@


1.64
log
@more fixes for 6.1
@
text
@d55 3
a57 4
// ---------------------------------------------------------------------------
LgFrSceBaseExploder *
LgFrScenarioForSce::createAppropriateSceExploder(
						 LgFrScenarioForSceSmartPointer scenSceSP)
a58 15
  WitRun * const theWitRun        = lastProblemSolved().witRun();
  
  // FINISH_ME: implement new parameter scheme and then modify this 
  std::string engine = setOfParameters().getString("engine");
  bool useFullExplodeUtility = setOfParameters().getBool("useFullExplodeUtility");
  bool fssFlag = setOfParameters().getBool("fssFlag");
  bool useSmartExplodeUtility = setOfParameters().getBool("useSmartExplodeUtility");
  bool usePrioritizedExplodeUtility = setOfParameters().getBool("usePrioritizedExplodeUtility");
  
  LgFrSceBaseExploder             * theConcreteExploder;
  LgFrSceFullExploderDecorator    * theFullDecorator;
  LgFrSceSmartExploderDecorator   * theSmartDecorator;
  LgFrSceFssableExploderDecorator * theFssDecorator;
  LgFrSceBaseExploder             * theCurrentExploder;  
   
d60 21
a80 21
  // First create the concrete Exploder
  // Its going to be a 
  if ( (useFullExplodeUtility)
       || (useSmartExplodeUtility)
       || (usePrioritizedExplodeUtility)
       || (fssFlag) ) {
    theConcreteExploder = new LgFrSceExploder(lastProblemSolved().witRun(),
					      &(multiPlantHelper()),
					      &(setOfParameters()));
    theCurrentExploder = theConcreteExploder;
  }
  else {
    theConcreteExploder = new LgFrSceBaseExploder(lastProblemSolved().witRun(),
						  &(multiPlantHelper()),
						  &(setOfParameters()));
    return theConcreteExploder;
  }
  
  
  // now see if you want a SMART decorator
  if (useSmartExplodeUtility || usePrioritizedExplodeUtility) {
d82 11
a92 11
    theSmartDecorator = new LgFrSceSmartExploderDecorator(theCurrentExploder,
							  scenSceSP,
							  &(multiPlantHelper()));
    theCurrentExploder = theSmartDecorator;
  }
  
  // now see if you want a FULL decorator
  if (useFullExplodeUtility) {
    if (! usePrioritizedExplodeUtility) {
      theFullDecorator = new LgFrSceFullExploderDecorator(theCurrentExploder);
      theCurrentExploder = theFullDecorator;
a93 10
  }
  // now see if you want a FSS decorator
  if (fssFlag) {
    theFssDecorator = new LgFrSceFssableExploderDecorator(theCurrentExploder);
    theCurrentExploder = theFssDecorator;
  }
  
  return theCurrentExploder;
  
}
a94 19
// ---------------------------------------------------------------------------
void 
LgFrScenarioForSce::setHeuristicSearchIncrement(WitRun * const theWitRun,   
						std::string greedySearchIncrementMethod, 
						float anIncValue) 
{
  int nParts;
  int nDemands;
  char ** partList;
  char ** demandList;
  int nPeriods;
  
  float searchInc;
  
  witGetNPeriods(theWitRun, &nPeriods);
  witGetParts(theWitRun, &nParts, &partList);
  witBoolean isItAbosluteInc =  (sce::compareStringsCaseIns(greedySearchIncrementMethod, "autoScale")) ? WitTRUE : WitFALSE;
  
  //  std::cout << "HeuristicSearchIncrement: isItAbosluteInc=" << isItAbosluteInc << std::endl;
d96 8
a103 2
  int i = 0; 
  for (i=0; i<nParts; i++ ) {
a104 2
    // get demands on the part. 
    witGetPartDemands(theWitRun, partList[i], &nDemands, &demandList);
d106 23
a128 4
    int j = 0; 
    for (j=0; j<nDemands; j++) {
      if (isItAbosluteInc) {
	witSetDemandSearchInc(theWitRun, partList[i], demandList[j], anIncValue);
d130 3
a132 22
      else {
	float * demandVol;
	witGetDemandDemandVol(theWitRun, partList[i], demandList[j], &demandVol);
	int t = 0; 
	float	 maxVol=0.0;
	float minVol= 9999999.9;
	for (t=0; t<nPeriods; t++) {
	  maxVol = (demandVol[t] > maxVol) ? demandVol[t] : maxVol;
	  if (demandVol[t] > 0) {
	    minVol = (demandVol[t] < minVol) ? demandVol[t] :  maxVol;
	  }
	}
	
	witFree(demandVol);
	
	if (maxVol > 0) {
	  searchInc = (maxVol / anIncValue > 0.001) ? maxVol/anIncValue : 0.001;
	  witSetDemandSearchInc(theWitRun, partList[i], demandList[j], searchInc);
	  std::cout << "HeuristicSearchIncrement: searchInc=" << searchInc << std::endl;
	}
      }
      witFree(demandList[j]);
d134 5
a139 7
    witFree(demandList);
    witFree(partList[i]);
    
  }
  witFree(partList);
    
}
d141 6
a146 14
// ---------------------------------------------------------------------------
//  -------------------
//  Print Total Demand 
//  -------------------
void 
LgFrScenarioForSce::printTotalDemandFile(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrSceBaseExploder * exploder,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
d148 1
a148 1
  LgFrCalendar theCal = this->calendar();
d150 7
a156 6
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Total Demand" 
			<< fileName);
   }
d158 11
a168 2
   int alwaysPrint = 1;
   int nonZeroOnly = 0;
a169 3
   long numRecords = 0;  // keep track of number of records
   int nDemands;
   char ** dList;
d171 9
a179 3
#ifdef ENABLE_NEGATIVE_DEMANDS
   LgFrTimeVecFloat negDemVol;
#endif
a180 7
   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     // Compute :=======> mrpConsVol
     float * mrpConsVol;
     if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
       exploder->mrpConsVol(partList[i], &mrpConsVol);
d182 26
a207 3
       // Now add in direct demand vol
       // get demands on the part.  These are needed for direct demands
       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
a208 12
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<nDemands; j++) {
	 float * indepDemandVol;
	 witGetDemandDemandVol(theWitRun, partList[i], dList[j], &indepDemandVol);
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
	   mrpConsVol[tt] += indepDemandVol[tt];
	 }
	 witFree(indepDemandVol);
	 witFree(dList[j]);
       }
       witFree(dList);
a209 5
#ifdef ENABLE_NEGATIVE_DEMANDS
       // Compute :=======> negDemVol
       int doesPartHaveNegativeDemands = mpHelper.doesPartHaveNegativeDemands(theWitRun, partList[i]);
       if (doesPartHaveNegativeDemands) {
	 negDemVol = mpHelper.negDemVol(theWitRun, partList[i]);
d211 12
a222 2
	 LgFrTimeVecFloat witMrpConsVol((size_t) nPeriods, mrpConsVol);
	 LgFrTimeVecFloat negDemMrpConsVol((size_t) nPeriods, 0.0);
a223 21
	 float rolledNegDemVol = 0.0;
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
	   rolledNegDemVol += negDemVol[tt];
	   if (mrpConsVol[tt] > rolledNegDemVol) {
	     mrpConsVol[tt] -= rolledNegDemVol;
	     negDemMrpConsVol[tt] += rolledNegDemVol;
	     rolledNegDemVol = 0.0;
	   }
	   else {
	     // Note: if mrpConsVol < 0 then there are negative usage rates
	     // these can realy screw up our calculation
	     if (mrpConsVol[tt] > 0) {
	       rolledNegDemVol -= mrpConsVol[tt];
	       negDemMrpConsVol[tt] += mrpConsVol[tt];
	       mrpConsVol[tt] = 0.0;
	     }
	   }
	 }
       }
#endif
d226 11
a236 3
       // change_me_now
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
a237 1
       flatFileMgr_.writePartPdfRecord(theCal, partname, pdf, mrpConsVol, outFile, nPeriods, nonZeroOnly);
a238 1
       witFree(mrpConsVol);
a239 8
       numRecords++;
     }
   }
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
   
   
}
d241 7
d249 14
a262 9
// return a exploder object
LgFrSceBaseExploder *
LgFrScenarioForSce::exploder()
{
  if (exploderPtr_ == 0) {
    assert(exploderPtr_ != 0);
  }
  return exploderPtr_;    
}
a263 4
// ---------------------------------------------------------------------------
void   
LgFrScenarioForSce::runExplosion( LgFrScenarioForSceSmartPointer scenSceSP )
{
d265 13
a277 11
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  
  //this is the first time an exploder is created!!
  if (exploderPtr_ == 0) {
    exploderPtr_ = this->createAppropriateSceExploder(scenSceSP);
  }
  else {
    std::cerr << "trying to access an exploder for first time and it is non-null\n "
	      << std::endl;
    exit (1);
  }
d279 13
a292 1
  LgFrSceBaseExploder * myExploder = this->exploder();
a293 1
  WitRun * const theExplodeWitRun        = myExploder->localWitRun();  
d295 6
d302 14
a315 8
  // Dump the explode version of the echo file
  if (setOfParameters.getBool("printExplodeEchoFile"))  {
    std::cout << "Writing the Explode echo file  ..." << std::endl;                
    std::string explodeEchoFileName = setOfParameters.getString("explodeEchoFileName");
    setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_ON);
    witDisplayData( theExplodeWitRun, explodeEchoFileName.c_str());
    if (! setOfParameters.getBool("printWitExplodeMsgFile"))   {
      setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_OFF);          
a316 1
  }
d318 13
a330 8
  // Dump the explode version of the wit.data file
  if (setOfParameters.getBool("printExplodeWitDataFile"))  {
    std::cout << "Writing the (Explode) wit data file ..." << std::endl;                      
    std::string explodeWitDataFileName = setOfParameters.getString("explodeWitDataFileName");
    setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_ON);
    witWriteData(theExplodeWitRun, explodeWitDataFileName.c_str());
    if (! setOfParameters.getBool("printWitExplodeMsgFile"))   {
      setWitInformationalMessaging(theExplodeWitRun, SCE_WIT_MESSAGING_OFF);          
a331 1
  }
d334 13
d349 6
a354 1
  std::cout << "Executing explosion engine using (" << myExploder->title() << ") scheme  ..." << std::endl;  
d356 5
d362 14
a375 2
  // run the explosion engine !!
  myExploder->explode();
a376 1
  bool doPegging = setOfParameters.getBool("doPegging");
d378 35
a412 3
  // need a flag for whtether it's mrp or implosion PIP
  if (doPegging) {
    printPIPData(theExplodeWitRun, 1);
d414 29
d444 23
a466 10
}
// ---------------------------------------------------------------------------
void   
LgFrScenarioForSce::printExplosionResults()
{
  int      nPeriods;
  int      nParts;
  char  ** partList;
  int      nOperations;
  char  ** opList;
d468 22
d491 9
a499 5
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  // WitRun * const theWitRun        = this->exploder()->localWitRun();
  WitRun * const theWitRun        = lastProblemSolved().witRun();
  LgFrSceBaseExploder * myExploder = this->exploder();
d501 3
a503 1
  std::cout << "Writing explosion output results  ..." << std::endl;  
a504 3
  witGetNPeriods(theWitRun, &nPeriods);
  witGetParts(theWitRun, &nParts, &partList);
  witGetOperations(theWitRun, &nOperations, &opList);
a505 2
  // Adjust Interplant execVols for Jumper ARCS
  // this is done via operation App data.
a506 4
  // VERY IMPORTANT!!  This step initializes App data for Interplant
  // operations in the primary witRun!!  It must be done before any interplant
  // execVols can be accessed (in either mrp or implosion witRuns). The app data
  // is actually store in the priamry witRun
a507 7
  // NOTE: to get an interplant (mrp)execVol, use scneario's helper function
  // interplantExecVol(opName, execVol &)
  // interplantMrpExecVol(opName, mrpExecVol &)
  initializeInterplantOperationsAppData(theWitRun,
					nPeriods,
					nOperations,
					opList);
a509 2
  bool printTotalDemandReport =
    setOfParameters.getBool("printTotalDemandReport");
d511 15
a525 6
  if (printTotalDemandReport) {
    std::string totalDemandReportFileName = setOfParameters.getString("totalDemandReportFileName");
   printTotalDemandFile(theWitRun,  myExploder,
			nPeriods, nParts, partList,
			totalDemandReportFileName,
			mpHelper);
a526 1
#ifdef SCE_ODBC
d528 38
a565 4
    //------------- updating PartPdf TotalDemand -------
  {
    ScePartPdfDB tbl;
    SceDBLink demand(tbl);
d567 38
a604 8
    insertPartPdfTotalDemand(demand,
			     theWitRun,
			     myExploder,
			     nPeriods,
			     nParts,
			     partList,
			     mpHelper);
    demand.update("totalDemand");
d606 12
a617 1
#endif
d619 3
d624 2
a625 3
  // Operations Demand File: optional file (new 2.31)
  // prints only when asked for 
  // prints BOTH userDefined Operations and Default Operations
a626 8
  bool printOperationDemandFile = setOfParameters.getBool("printOperationDemandFile");
  if (printOperationDemandFile )   {
    std::string operationDemandFileName = setOfParameters.getString("operationDemandFileName");
    printOperationDemandVolFile(theWitRun, 
			     nPeriods, 
			     operationDemandFileName,
			     mpHelper);
  }
d628 3
d632 2
d635 5
d641 2
a642 2
  // Interplant Demand File: optional file (new 2.00)
  // prints only when asked for and there are interplant records
d644 2
a645 12
  bool printInterplantDemandFile = setOfParameters.getBool("printInterplantDemandFile");
  std::string interPlantFile = setOfParameters.getString("interPlantFile");
  if ((! interPlantFile.empty()) && printInterplantDemandFile )   {
    std::string interplantDemandFileName =
      setOfParameters.getString("interplantDemandFileName");
    bool isThisMrp = true;
    printInterplantVolumesFile(theWitRun, nPeriods, 
			       nOperations, opList,
			       isThisMrp,
			       interplantDemandFileName,
			       mpHelper);
  }
d647 2
d651 3
a653 8
  // Capacity Usage Volume File: optional file
  // (prints only when there is substitute  input data)
  bool printMrpCapacityUsageFile = setOfParameters.getBool("printMrpCapacityUsageFile");    
  if (printMrpCapacityUsageFile)   {
    bool isItMrp = true;
    printCapUsageVolume(myExploder->localWitRun(), isItMrp); 
  }
  
d655 2
a656 16
  
  // Mrp Substitute Usage Volume File
  // (prints only when (1) usingSmartExplode and (2) there is substitute  input data)
  bool printMrpSubUsageFile = setOfParameters.getBool("printMrpSubUsageFile");    
  bool useSmartExplodeUtility = setOfParameters.getBool("useSmartExplodeUtility");
  std::string subBomFile = setOfParameters.getString("subBomFile");    
  if (printMrpSubUsageFile && useSmartExplodeUtility && (! subBomFile.empty()))   {
    std::string mrpSubUsageFileName = setOfParameters.getString("mrpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = false;
    bool engineMustBeImplode = false;
    printSubstituteUsageVolume(theWitRun, 
			       parentMustBeUserDefinedOperation,
			       engineMustBeImplode,
			       nPeriods, nOperations, opList,
			       mrpSubUsageFileName, mpHelper);
  }
d658 2
d661 2
d664 2
a665 15
  // Mrp Operation Substitute Usage Volume File
  // (prints only when (1) usingSmartExplode and (2) there is operation substitute  input data)
 
  bool printMrpOpSubUsageFile = setOfParameters.getBool("printMrpOpSubUsageFile");    
  std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
  if (printMrpOpSubUsageFile && useSmartExplodeUtility && (! opSubBomFile.empty()))   {
    std::string mrpOpSubUsageFileName = setOfParameters.getString("mrpOpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = true;
    bool engineMustBeImplode = false;
    printSubstituteUsageVolume(theWitRun, 
			       parentMustBeUserDefinedOperation,
			       engineMustBeImplode,
			       nPeriods, nOperations, opList,
			       mrpOpSubUsageFileName, mpHelper);
  }
d667 2
d670 2
a671 4
  // Print the MRP Supply Orders File
  if (setOfParameters.getBool("printMrpSupplyOrdersFile"))  {
    std::string mrpSupplyOrdersFileName = setOfParameters.getString("mrpSupplyOrdersFileName");
    printMrpSupplyOrdersFile(mpHelper, nPeriods, mrpSupplyOrdersFileName);
d673 7
d681 4
a684 5
  // Print the MRP Demand Orders File
  if (setOfParameters.getBool("printMrpDemandOrdersFile"))  {
    std::string mrpDemandOrdersFileName = setOfParameters.getString("mrpDemandOrdersFileName");
    printMrpDemandOrdersFile(mpHelper, nPeriods, mrpDemandOrdersFileName);
  }
d687 2
d690 33
a722 9
  // Note: if we are not doing an implosion, then we must still write the
  // Dump files.
  bool doImplode = setOfParameters.getBool("doImplode");
  if (! doImplode) {
    // Part Database Dump File:  optional file
    if (setOfParameters.getBool("printPartDBFile"))  {
      std::string partDBFileName = setOfParameters.getString("partDBFileName");
      printPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				partList, partDBFileName);
d724 63
a786 6
    // Capacity Database Dump File: optional file    
    if (setOfParameters.getBool("printCapacityDBFile"))  {
      std::string capacityDBFileName =
	setOfParameters.getString("capacityDBFileName");
      printCapacityDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				    partList, capacityDBFileName);
d789 8
d798 9
a806 6
    // Operation Database Dump File
    if (setOfParameters.getBool("printOperationDBFile"))  {
      std::string operationDBFileName =
	setOfParameters.getString("operationDBFileName");
      printOperationDataBaseDumpFile(theWitRun, mpHelper, nPeriods, 
	    operationDBFileName);
d808 50
d859 4
d866 7
a872 1
    
d875 3
a877 1
  // free the parts 
d879 1
a879 1
  for (i=0; i<nParts; i++)  
d881 1
d884 35
a918 5
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++)  
    witFree(opList[o]);
  witFree(opList);
}
a922 1
// *********************************************************************************
a923 6
int
LgFrScenarioForSce::nDemandsWithNonZeroMins()
const
{
  return nDemandsWithNonZeroMins_;
}
a924 17
void
LgFrScenarioForSce::nDemandsWithNonZeroMins(int nMins)
{
  nDemandsWithNonZeroMins_ = nMins;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::incNDemandsWithNonZeroMins()
{
  nDemandsWithNonZeroMins_++;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::decNDemandsWithNonZeroMins()
{
  nDemandsWithNonZeroMins_--;
}
a925 26
// ---------------------------------------------------------------------------
int
LgFrScenarioForSce::nStandaloneFeatureArcs()
const
{
  return nStandaloneFeatureArcs_;
}  
// ---------------------------------------------------------------------------  
void
LgFrScenarioForSce::nStandaloneFeatureArcs(int nFeats)
{
  nStandaloneFeatureArcs_ = nFeats;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::incrementStandaloneFeatureArcs()
{
  nStandaloneFeatureArcs_++;
}
// ---------------------------------------------------------------------------
void
LgFrScenarioForSce::setEngine(const std::string & engine)
{
    engine_ = engine;
    sce::toLower( engine_ );
}
a926 6
// ---------------------------------------------------------------------------
std::string 
LgFrScenarioForSce::getEngine()
{
    return engine_;
}
a927 14
// ---------------------------------------------------------------------------
// generate a GeoDemand vectorized SOURCE record for one particular demand
// Returns period number in which there is a "hole".  -1 if no holes
int 
LgFrScenarioForSce::determineGeoToPdfSourceVector(
    WitRun * const theWitRun, 
    LgFrMultiPlantHelper & mpHelper,
    const std::string & geoPlannerDemandPartName,
    std::string * sourceList)
{
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
a928 1
  
a929 5
  int t;
  int nBom;
  int b;
  char * child;
  int early, late;
a930 2
  int nPeriods;
  witGetNPeriods(theWitRun, &nPeriods);
a931 3
  assert(mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						    geoPlannerDemandPartName,
						    plannerPart, geo));
d933 20
a952 3
  std::string unknownPdf("???");
  std::string unknownMfgPart("??????");
  std::string unknownPartPdf = mpHelper.pdfPartname(unknownMfgPart, unknownPdf);
d954 18
d973 7
a979 3
  // initialize the vector with all unknown Part,PDF for this GPD part
  for (t=0; t<nPeriods; t++) {
    sourceList[t] = unknownPartPdf;
d981 6
a986 13
     
  // We need to check the children of this geoPlannerDemand part.
  // The non-normal children can be skipped.  The remaining children
  // represent mfgPart,pdf that are true suppliers of the demanded part.
  // When we find a normal child, we pcik up the effectivity interval of
  // the BOM record.  For that interval, any demand that is shipped to the
  // geo must have been sourced from that pdf-part.  
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
  for (b=0; b<nBom; b++) {
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), b, &child);
    if (! mpHelper.isPartNormal(theWitRun, child)) {
      witFree(child);
      continue;
d988 10
d999 19
a1017 6
    witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &early);
    witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &late);
    // now set the indicator vector and set the vector geoByPdfSupplyVol
    for (t=early; t<=late; t++) {
      sourceList[t] = child;
    }
d1019 33
a1051 2
    witFree(child);
  }
a1052 6
  // now check to see if anything is unsourced
  int unsourcedPeriod = -1;
  for (t=0; t<nPeriods; t++) {
    if (sourceList[t] == unknownPartPdf) {
      unsourcedPeriod = t;
      break;
d1054 3
d1058 2
a1059 1
  return unsourcedPeriod;
d1062 4
a1065 3
//  ---------------------------------------------------------------------
//  Print Overall Problem Statistics
//  --------------------------------------------------------------------- 
d1067 1
a1067 1
LgFrScenarioForSce::printOverallProblemStatistics(
d1069 1
a1069 1
	 LgFrMultiPlantHelper & mpHelper,
d1073 2
a1074 1
	 std::string fileName)
a1075 4
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Problem Statistics" << fileName);
  }
d1077 10
d1088 3
a1090 1
   long numRecords = 0;  // for counting output lines
d1092 15
a1106 28
   int i, t, o;
   int nBom;
   int nOps;
   int npBops;
   int nBopTot = 0;
   int nBomTot = 0;
   int nNormalParts = 0;
   int nNormalCapacityParts = 0;
   int nPcfParts = 0;
   int nGeoPlannerDemandParts = 0;
   int nGeoPlannerDemandUBParts = 0;
   int nOptionRatioSupplyParts = 0;
   int nOptionDummyParts = 0;
   int nOptionDummyOperations = 0;
   int nBbCategoryParts = 0;
   int nInterplantOperations = 0;
   int nAggregationOperations = 0;   
   int nUserSpecifiedOperations = 0;
   int nLtGtParts = 0;
   int nGlobalNullSubParts = 0;
   int nGlobalMaxWithoutNullSubParts = 0;
   int nMaxWithoutNullSubParts = 0;
   int nStandaloneFeatureParts = 0;
   int nCustChoiceFeatureParts = 0;
   int nPartsBuildableFromThinAir = 0;
   int nWaifs = 0;
   int nPureOptionBuildDemands = 0;
   int nCustChoiceOptionBuildDemands = 0;
d1108 12
a1119 4
   int * buildableFromThinAir = new int[nParts];
  
   
   std::string d1, d2, d3, d4;
d1121 5
a1125 5
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     buildableFromThinAir[i] = 0;
     int constrained = 0;
     std::string thePart = partList[i];
d1127 2
a1128 3
     // count how many bop arcs in total
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     nBopTot += npBops;
d1130 20
a1149 34
     if (mpHelper.isPartNormalCapacity(theWitRun, thePart)) {
       nNormalCapacityParts++;
     }
     else if (mpHelper.isPartNormal(theWitRun, thePart)) {
       nNormalParts++;
       if (mpHelper.isPartPcf(theWitRun, thePart))
	 nPcfParts++;
     }
     else if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, thePart, d1, d2)) {
       nGeoPlannerDemandParts++;
     }
     else if (mpHelper.isPartSpecialGeoPlannerDemandUbPart(theWitRun, thePart, d1, d2)) {
       nGeoPlannerDemandUBParts++;
     }
     else if (mpHelper.isPartSpecialGlobalNullSubstitute(theWitRun, thePart, d1)) {
       nGlobalNullSubParts++;
     }
     else if (mpHelper.isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun, thePart, d1)) {
       nGlobalMaxWithoutNullSubParts++;
     }     
     else if (mpHelper.isPartSpecialMaxWithoutNullSubstitute(theWitRun, thePart, d1, d2, d3)) {
       nMaxWithoutNullSubParts++;
     }
     else if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, thePart)) {
       nStandaloneFeatureParts++;
     }
     else if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, thePart)) {
       nCustChoiceFeatureParts++;
     }
     
#if 0
     else if (mpHelper.isPartSpecialPhantom(theWitRun, thePart)) {
       nPhantomParts++;
     }
a1150 16
     else if (mpHelper.isPartSpecialBbCategory(theWitRun, thePart, d1, d2, d3)) {
       nBbCategoryParts++;
     }
     else if (mpHelper.isPartSpecialLTbbCapacity(theWitRun, thePart, d1, d2, d3)) {
       nLtGtParts++;
     }
     else if (mpHelper.isPartSpecialGTbbCapacity(theWitRun, thePart, d1, d2, d3)) {
       nLtGtParts++;
     }
     else if (mpHelper.isPartSpecialOptionDummy(theWitRun, thePart, d1, d2, d3,d4)) {
       nOptionDummyParts++;
     }
     else if (mpHelper.isPartSpecialOptionRatioSupply(theWitRun, thePart, d1, d2, d3,d4)) {
       nOptionRatioSupplyParts++;
     }
   }
a1151 7
   char ** opList;
   witGetOperations(theWitRun, &nOps, &opList);
   for (o=0; o<nOps; o++) {
     std::string theOperation(opList[o]);
     // count total BOM entries in model
     witGetOperationNBomEntries(theWitRun, theOperation.c_str(), &nBom);
     nBomTot += nBom;
d1153 5
a1157 3
     if (mpHelper.isOperationSpecialInterplant(theWitRun, theOperation, d1, d2, d3, d4)) {
       nInterplantOperations++;
     }
d1159 2
a1160 2
     else if (mpHelper.isOperationSpecialOptionDummy(theWitRun, theOperation, d1, d2, d3,d4)) {
       nOptionDummyOperations++;
d1162 6
d1170 9
a1178 12
     else if (mpHelper.isOperationSpecialAggregation(theWitRun, theOperation, d1, d2, d3, d4)) {
       nAggregationOperations++;
     }
     else {
       witBoolean exists;
       witGetPartExists(theWitRun, theOperation.c_str(), &exists);
       if (! exists)
	 nUserSpecifiedOperations++;
     }
     witFree(opList[o]);
   }
   witFree(opList);
d1180 4
d1185 11
a1195 23
   // CUSTOMER_CHOICE_FEATURES
   // compute the number of Customer Choice OptionBuildDemands ... this should equal the number
   // of feature ratio records accepted?
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitFeaturePartName(partList[i]);
     if (mpHelper.isPartSpecialCustChoiceFeature(theWitRun, fullWitFeaturePartName)) {
       int lenDemandList;
       char ** demandList;
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
	 if ( mpHelper.isDemandSpecialCustChoiceFeature( theWitRun, fullWitFeaturePartName,
							 fullWitGeoPlannerDemandName,
							 plannerPart, geo ))
	   nCustChoiceOptionBuildDemands++;
	 witFree(demandList[j]);
       }
       witFree(demandList);
     }
   }
d1198 1
a1198 22
   // compute the number of PureOptionBuildDemands ... this should equal the number
   // of feature ratio records accepted?
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitFeaturePartName(partList[i]);
     if (mpHelper.isPartSpecialStandaloneFeature(theWitRun, fullWitFeaturePartName)) {
       int lenDemandList;
       char ** demandList;
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
	 if ( mpHelper.isDemandSpecialPureOptionBuildDemand( theWitRun, fullWitFeaturePartName,
							     fullWitGeoPlannerDemandName,
							     plannerPart, geo ))
	   nPureOptionBuildDemands++;
	 witFree(demandList[j]);
       }
       witFree(demandList);
     }
   }
d1200 1
d1203 21
a1224 48
   // Look for unconstrained and constrained waif parts
   // A waif part is:
   //    - Only have one bop entry
   //    - Only have a default operation
   // An unconstrained waif (unc-waif)
   //    - yield(defaultOp) > 0.0 for all periods
   // A constrained waif has
   //    - yield(defaultOp) = 0.0 in at least one period
   for ( i=0; i<nParts; i++ ) {
     buildableFromThinAir[i] = 0;
     // only consider normal parts
     std::string thePart = partList[i];
     if (! mpHelper.isPartNormal(theWitRun, thePart))
       continue;
     witBoolean exists;
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     // if it doesn't have exactly one part then its not a unc-waif
     if (npBops != 1)
       continue;
     // if default operation does not exist, then skip it .. its not a unc-waif
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
     if (! exists)
       continue;
     // if default operation has any bom entries then its not an unc-waif
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
     if (nBom > 0)
       continue;
     // if the part is a PCF then its not an unc-waif
     if (mpHelper.isPartPcf(theWitRun, thePart))
       continue;
     // OK the part is a waif
     nWaifs++;
     // now see if its an unc-waif
     float * yieldRate;
     witGetOperationYieldRate(theWitRun, thePart.c_str(), &yieldRate);
     bool uncWaif=true;
     for (t=0; t<nPeriods; t++) {
       if (yieldRate[t] = 0.0) {
	 uncWaif = false;
	 break;
       }
     }
     if (uncWaif) {
       nPartsBuildableFromThinAir++;
       buildableFromThinAir[i] = 1;
     }
     witFree(yieldRate);
   }
a1225 29
   
     
   
   outFile << " Problem Size Statistics\n\n";
   outFile << " Number of Real parts: = " << nNormalParts << "\n";
   outFile << " Number of Capacities: = " << nNormalCapacityParts << "\n";
   outFile << " Number of Operations: = " << nOps << "\n";
   outFile << " Number of Artificial (interplant) \"operations\": = " << nInterplantOperations << "\n";
   outFile << " Number of Artificial (aggregation) \"operations\": = " << nAggregationOperations << "\n";      
   outFile << " Number of User-Defined Operations: = " << nUserSpecifiedOperations << "\n";
   outFile << " Number of lowest level, non-pcf, lead-time constrained real parts : = " << nWaifs - nPartsBuildableFromThinAir << "\n";
   outFile << " Number of lowest level, non-pcf, unconstrained real parts : = " << nPartsBuildableFromThinAir << "\n";
   outFile << " Number of Artificial (GPD demand) \"parts\": = " << nGeoPlannerDemandParts << "\n";
   outFile << " Number of Artificial (demandUB) \"parts\": = " << nGeoPlannerDemandUBParts << "\n";
   outFile << " Number of Artificial (bbCategory) \"parts\": = " << nBbCategoryParts << "\n";
   outFile << " Number of Artificial (SOD) \"parts\": = " << nOptionDummyParts << "\n";
   outFile << " Number of Artificial (SOD) \"operations\": = " << nOptionDummyOperations << "\n";
   outFile << " Number of Artificial (ORS) \"parts\": = " << nOptionRatioSupplyParts << "\n";
   outFile << " Number of Artificial (LT/GT) \"parts\": = " << nLtGtParts << "\n";
   outFile << " Number of Artificial (pureOption build ) \"demands\": = " << nPureOptionBuildDemands << "\n";
   outFile << " Number of Artificial (custChoice build ) \"demands\": = " << nCustChoiceOptionBuildDemands << "\n";
   outFile << " Number of Artificial (global nullSub) \"parts\": = " << nGlobalNullSubParts << "\n";
   outFile << " Number of Artificial (global mwo nullSub) \"parts\": = " << nGlobalMaxWithoutNullSubParts << "\n";
   outFile << " Number of Artificial (mwo nullSub) \"parts\": = " << nMaxWithoutNullSubParts << "\n";
   outFile << " Number of Artificial (custChoice feature) \"parts\": = " << nCustChoiceFeatureParts << "\n";
   outFile << " Number of Artificial (standAlone feature) \"parts\": = " << nStandaloneFeatureParts << "\n";
   outFile << " Total \"Parts\" in SCE model: = " << nParts << "\n";
   outFile << " Total \"Bop Arcs\" in SCE model: = " << nBopTot << "\n";   
   outFile << " Total \"Bom Arcs\" in SCE model: = " << nBomTot << "\n\n\n";
a1226 5
   // Note: for now, since the above print statements are hard-coded, if 
   //       someone changes these in this file, then later on in the
   //       output log, the number of output lines will be inconsistent with
   //       the number actual output lines....so change the following line:
   numRecords = 23;
d1228 1
a1228 1
   outFile << " Unconstrained, lowest level, non-pcf  Parts List:\n";
a1229 12
   for ( i=0; i<nParts; i++ ) {
     if (buildableFromThinAir[i]) {
       outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	       << mpHelper.pdf(partList[i]) << "\"\n";
       numRecords++;
     }
   }
   
   outFile.close();
   delete [] buildableFromThinAir;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }
d1231 2
d1234 1
d1236 9
a1244 11
//  ---------------------------------------------------------------------
//  Print Lowest Level, unconstrained parts (non-pcf)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printLowestLevelNonPcfParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName)
d1246 6
a1251 4
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Lowest Level, Non-pcf" << fileName);
  }
d1253 7
d1261 3
a1263 1
   long numRecords = 0;  // for counting output lines
d1265 2
a1266 5
   int i;
   int nBom;
   int npBops;
   witBoolean exists;  
   
d1268 4
a1271 9
   // Look for Lowest Level, non-pcf parts:
   //    - Only have one bop entry
   //    - Only have a default operation
   //    - not a pcf part
   for (i=0; i<nParts; i++ ) {
     // only consider normal parts
     std::string thePart = partList[i];
     if (! mpHelper.isPartNormal(theWitRun, thePart))
       continue;
d1273 7
a1279 20
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
     // if it doesn't have exactly one part then its not lowest-level-non-pcf
     if (npBops != 1)
       continue;
     // if default operation does not exist, then skip it .. its not lowest-level-non-pcf
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
     if (! exists)
       continue;
     // if default operation has any bom entries then its not lowest-level-non-pcf
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
     if (nBom > 0)
       continue;
     // if the part is a PCF then its not lowest-level-non-pcf
     if (mpHelper.isPartPcf(theWitRun, thePart))
       continue;
     // OK the part is lowest-level, non-pcf
     outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	     << mpHelper.pdf(partList[i]) << "\"\n";
     numRecords++;
   }
a1280 4
   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }
d1282 2
d1285 6
a1290 16
#ifdef MARK_BOGONS
//  ---------------------------------------------------------------------
//  Print PCF Bogons (parts which were specified as PCF but got rejected due to child parts)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBogonParts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Bogon List" << fileName);
a1293 1
   long numRecords = 0;  // for counting output lines
d1295 3
a1297 13
   int i;
   // Look for Lowest Level, non-pcf parts:
   //    - Only have one bop entry
   //    - Only have a default operation
   //    - not a pcf part
   for (i=0; i<nParts; i++ ) {
     std::string thePart = partList[i];
     if (! mpHelper.isPartBogon(theWitRun, thePart))
       continue;
     outFile << "\"" << mpHelper.partname(partList[i]) << "\",\""
	     << mpHelper.pdf(partList[i]) << "\"\n";
     numRecords++;
   }
d1299 8
a1306 5
   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
 }
#endif
d1309 1
d1311 2
a1312 20
//  ---------------------------------------------------------------------
//  Calculate and Print Value Added Costs
//  --------------------------------------------------------------------- 
//  calculation of vac is limited to default operations only.   that means that
//  VAc and compCost will be based on in-plant mfg cost or rawCost at that site.
//
void 
LgFrScenarioForSce::calculateAndPrintValueAddedCosts(
	 WitRun * const theWitRun,   // WIT environment
	 LgFrMultiPlantHelper & mpHelper,
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string vacFileName,
	 std::string compCostFileName)
{
  std::ofstream vacFile(vacFileName.c_str());//, ios::out, 0666);
  if (vacFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Value Added Cost" << vacFileName);
  }
d1314 11
a1324 3
  std::ofstream compCostFile(compCostFileName.c_str());//, ios::out, 0666);
  if (compCostFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() << "Comp cost " << compCostFileName);
a1326 1
   long numRecords = 0;  // for counting output lines
a1327 1
   int i, t;
d1329 8
a1336 1
   std::cout << "   ... number of parts to process: " << nParts << std::endl;                
d1338 16
a1353 3
  //input: rawCost of each part
  //output: vacCost of each part
  //        compCost of each part
a1354 14
  // loop over parts in sorted list 
  //   get next part on list: part-x (if no more parts, then DONE)
  //   if Part-x has No children then  {
  //         vacCost(part-x) = rawCost(part-x)
  //         compCost(x) = 0
  //   if Part-x has children then {
  //      initialize: vacCost(x) = rawCost(x)
  //      initialize: compCost(x) = 0
  //      for each child of Part-x:    {
  //           compCost(x) += (compCost(child) + vacCost(child))  * usageRate / ((1-fallout) * yield(x))
  //
  //      }
  //      vacCost(x) = max{0, rawCost(x) - compCost(x)
  //   }
a1355 2
   int kParts, lastK;
   lastK=0;
d1357 15
a1371 2
   for (i=0; i<nParts; i++ ) {
     std::string thePart = partList[i];
a1372 5
     kParts = i/10;
     if (kParts > lastK) {
       lastK = kParts;
       //       std::cout << "   ... processed " << i << " parts out of " << nParts << std::endl;                
     }
d1374 13
d1388 17
a1404 2
     LgFrTimeVecFloat vacCost(nPeriods, 0.0);
     LgFrTimeVecFloat compCost(nPeriods, 0.0);
a1405 7
     witBoolean exists;
     witGetOperationExists(theWitRun, partList[i], &exists);
     if (exists) {
       float * rawCost;
       witGetOperationObj1ExecCost(theWitRun, partList[i], &rawCost);
       for (t=0; t<nPeriods; t++)
	 vacCost[t] = rawCost[t];
d1407 7
a1413 5
       int nBom;
       witGetOperationNBomEntries(theWitRun, partList[i], &nBom);
       
       float * yieldRate;
       witGetOperationYieldRate(theWitRun, partList[i], &yieldRate);
a1414 12
       
       int b;
       for (b=0; b<nBom; b++) {
	 char * child;
	 witGetBomEntryConsumedPart(theWitRun, partList[i], b, &child);
	 float * consRate;
	 witGetBomEntryConsRate(theWitRun, partList[i], b, &consRate);
	 float falloutRate;
	 witGetBomEntryFalloutRate(theWitRun, partList[i], b, &falloutRate);
	 int * impactPeriod;
	 witGetBomEntryImpactPeriod(theWitRun, partList[i], b, &impactPeriod);
	 
a1415 2
	 LgFrScePartAppData * childAppDataPtr;    
	 witGetPartAppData(theWitRun, child, (void **) &childAppDataPtr);
a1416 2
	 // child MUST have been seen alrady, and hence has an appData
	 assert (childAppDataPtr != 0);
d1418 2
a1419 2
	 LgFrTimeVecFloat childVac = childAppDataPtr->vac();
	 LgFrTimeVecFloat childCompCost = childAppDataPtr->compCost();
d1421 5
d1427 5
a1431 7
	 for (t=0; t<nPeriods; t++) {
	   if ( (yieldRate[t] > 0.0) && (impactPeriod[t] > -1) ) {
	     compCost[t] += 
	       ((childCompCost[impactPeriod[t]] + childVac[impactPeriod[t]]) * consRate[t] )
	       / ((1.0 - falloutRate) * yieldRate[t]);
	   }
	 }
a1432 4
	 witFree(child);
	 witFree(consRate);
	 witFree(impactPeriod);
       }
a1433 2
       for (t=0; t<nPeriods; t++)
	 vacCost[t] =  (rawCost[t] - compCost[t] > 0.0) ? rawCost[t] - compCost[t] : 0.0f;
d1436 1
a1436 3
       witFree(yieldRate);
       witFree(rawCost);
     }
d1438 6
a1443 12
     LgFrScePartAppData * appDataPtr;    
     witGetPartAppData(theWitRun, partList[i], (void **) &appDataPtr);
     if (appDataPtr == 0) {
       appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
       appDataPtr->vac(vacCost);
       appDataPtr->compCost(compCost);
       witSetPartAppData(theWitRun, partList[i], (void *) appDataPtr);
     }
     else {
       appDataPtr->vac(vacCost);
       appDataPtr->compCost(compCost);
     }
d1445 17
d1463 26
a1488 16
     // only write the NORMAL records,
     if (mpHelper.isPartNormal(theWitRun, partList[i])) {
       //  write the vac TimeVec data
       vacFile << "\""
	       << mpHelper.partname(partList[i]) << "\",\""
	       << mpHelper.pdf(partList[i]) << "\"";
       flatFileMgr_.writeCsvFloatVector(vacFile, nPeriods, vacCost.data(), 0, 15);
       
       //  write the vac TimeVec data
       compCostFile << "\""
		    << mpHelper.partname(partList[i]) << "\",\""
		    << mpHelper.pdf(partList[i]) << "\"";
       flatFileMgr_.writeCsvFloatVector(compCostFile, nPeriods, compCost.data(), 0, 15);
       numRecords++;
     }
   }
d1490 6
a1495 5
   
   vacFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(vacFileName,numRecords,000,numRecords);
   compCostFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(compCostFileName,numRecords,000,numRecords);
d1497 9
a1505 13
 }

//  ---------------------------------------------------------------------
//  Print Optimization data
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOverallOptimizationValues(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string & engine,
	 std::string fileName)
d1507 4
d1512 1
a1512 1
  std::string partName;
d1514 5
a1518 5
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Overall Optimization Values" << fileName);
  }
d1520 2
d1523 3
a1525 1
   long numRecords = 0;
d1527 3
a1529 20
   float * obj1Reward;
   float * obj1CSReward;
   int   * priority;
   float cumShipVol;
   float * shipVol;
   float * demandVol;
   float cumpts = 0.0;
   float cumblog = 0.0;
   int nDemands;
   char ** dList;
   float cumDemVol = 0.0;
   float newBlog;
   float onTimeServ = 0.0;
   float cumInt = 0.0;
   int i, j, t;
   float cumShipOnTime = 0.0;
   float cumTotalDemVol = 0.0;
   float shipToDemThisPeriod;
   float objValue;
   float boundsValue;
d1531 19
d1551 6
a1556 2
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
d1558 2
a1559 52
       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
       for (j =0; j<nDemands; j++)  {
	 if (! sce::compareStringsCaseIns( engine, "optimization" )) {
	   witGetDemandObj1ShipReward(theWitRun, partList[i], dList[j], &obj1Reward);
	   witGetDemandObj1CumShipReward(theWitRun, partList[i], dList[j], &obj1CSReward);
	 }
	 else {
	   witGetDemandPriority(theWitRun, partList[i], dList[j], &priority);
	 }
	 witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	 witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	 cumShipVol = 0.0;
	 cumDemVol = 0.0;
	 for (t=0; t<nPeriods; t++) {
	   cumShipVol += shipVol[t];
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
	     cumpts += (shipVol[t] * obj1Reward[t]);
	     cumInt += (cumShipVol * obj1CSReward[t]);
	   }
	   else
	       cumpts += (shipVol[t] * priority[t]);             
	   newBlog = (demandVol[t] > shipVol[t]) ? demandVol[t] - shipVol[t] : 0.0f;
	   shipToDemThisPeriod = (cumShipVol > cumDemVol) ? cumShipVol - cumDemVol : 0.0f;
	   cumShipOnTime += shipToDemThisPeriod;
				      
	   cumblog += newBlog;
	       cumDemVol += demandVol[t];
	       cumTotalDemVol += demandVol[t];
	   }
	   witFree(dList[j]);
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {           
	     witFree(obj1Reward);
	     witFree(obj1CSReward);
	   }
	   else 
	     witFree(priority);           
	   witFree(shipVol);
	   witFree(demandVol);
       }
       witFree(dList);
   }
   if (cumTotalDemVol > 0.0001)
     onTimeServ = cumShipOnTime / cumTotalDemVol;
#ifdef SCE_OPT_IMPLODE   
   witGetObjValues(theWitRun, &objValue, &boundsValue);
#endif
   
   outFile << "SCE Optimization Summary Report:\n";
   outFile << "  - Engine used:" << engine <<"\n";   
   
   outFile << "  - Primary  objective value: = " << cumpts << "\n";
   numRecords += 2;
d1561 9
a1569 21
   if (cumTotalDemVol > 0.0001)   
     outFile << "  - On time serviceability: = " << onTimeServ << "\n";
   else
     outFile << "  - On time serviceability: = ERROR all demands have ZERO volume\n";
   numRecords++;

   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
     outFile << "  - Additional interest reward : = " << cumInt << "\n";
     numRecords++;

#ifdef SCE_OPT_IMPLODE        
     outFile << "  - Total WIT optimization objective value: = " << objValue << "\n";
     outFile << "  - Penalty for violating Min Demand Volumes: = " << boundsValue << "\n";
     numRecords += 2;
#endif     
     // outFile << " Additional cost due to Substitutes = " << 0 << "\n";     
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
d1573 1
a1573 1
//  Print Capacity   Information         
d1576 7
a1582 7
LgFrScenarioForSce::printCapacityDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
a1583 1

d1586 1
a1586 2
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Capacity Database Dump" << fileName);
d1590 1
a1590 2
  long numRecords = 0;
  long numUniquePairs = 0;
d1592 701
a2292 3
  float * witVector;
  float * reqVol;
  float * mrpExcessVol;      
d2334 2
a2335 1
    numRecords += printDbDumpRec(pn, pdf, "supplyVol", witVector, outFile, nPeriods, alwaysPrint);
d2535 1
a2535 1
  
d2658 7
a2664 3
	outFile << "\"" << plannerPart << "\",\"" << geo 
		<< "\",\"" << featurePart << "\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);            
a2799 153
	outFile << "\"" << plannerPart << "\",\"" << geo 
		<< "\",\"" << featurePart << "\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);            
	numRecords++;
      }
      
      for (j=0; j<lenDemandList; j++)
	witFree (demandList[j]);
      witFree (demandList);
    }
  }
  delete [] feasibleFeatureRatio;

  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}

  //***ended





#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS

// THIS IS OBSOLTETE, code left around for possible re-use
  // this method writes FEATURE SET report  
void 
LgFrScenarioForSce::printFeatureAnalysisReportViaMultiRoute(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
   std::string partName;

   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Selective Feature/Building Block Ratio" 
		       << fileName);
  }


   long numRecords = 0;

   int t, i;

   std::string plannerTopLevelPart;
   std::string geo;
   std::string mfgOptionPart;
   std::string bbCategory;

   float * feasibleFeatureRatio = new float[nPeriods];


   // Loop once for each part, looking for specialOptionDummy's.  
   for ( i=0; i<nParts; i++ ) {
     std::string fullWitPartName(partList[i]);
     if (mpHelper.isPartSpecialOptionRatioSupply(theWitRun, fullWitPartName, plannerTopLevelPart, 
						 geo, bbCategory, mfgOptionPart))   {
       if (bbCategory.contains("STANDALONE:", std::string::ignoreCase))
	 continue;

       // find the consVol of the specialOptionRatioSupply
       float * orsConsVol;
       witGetPartConsVol(theWitRun, fullWitPartName.c_str(), &orsConsVol);


      // if the user wants data as a percentage of geoPlanner ship vol,
      // then we must get that and do the math.
       if (printDataAsPercentage) {
	 // find the build volume of the geoPLannerDemandPart
	 std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
									  plannerTopLevelPart, geo));
	 float * gpdExecVol;
	 witGetOperationExecVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdExecVol);

	 for (t=0; t<nPeriods; t++)   {
	   if (gpdExecVol[t] < 0.01) 
	     feasibleFeatureRatio[t] = 0.0;
	   else 
	     feasibleFeatureRatio[t] = orsConsVol[t]/gpdExecVol[t];
	 }
	 witFree(gpdExecVol);
       }

       // first print the preamble of the record
       outFile << "\"" << plannerTopLevelPart << "\",\"" << geo 
	       << "\",\"" << mfgOptionPart << "\"";

       if (printDataAsPercentage) 
	 flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);
       else
	 flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, orsConsVol, 4, 15);      
       numRecords++;
       witFree(orsConsVol);      
       }
   }

   delete [] feasibleFeatureRatio;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
#endif




  // this method writes FEATURE SET report  when using Proportional routing approach
void 
LgFrScenarioForSce::printFeatureAnalysisReportViaProportionalRoute(
	 WitRun * const theWitRun,
	 const int nPeriods,
	 const int nOperations,
	 char ** operationList,
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 int printDataAsPercentage)
{
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Feasible Selective Feature/Building Block Ratio" 
		       << fileName);
  }
  
  
  long numRecords = 0;
  
  int t;
  
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string bbCategory;
  
  float * feasibleFeatureRatio = new float[nPeriods];
  
  int o = 0; 
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitSodName(operationList[o]);
    //    std::cout << "Looping thru operations ..." << std::endl;;
    if (! mpHelper.isOperationSpecialOptionDummy(theWitRun, fullWitSodName, plannerTopLevelPart, 
					    geo, bbCategory, mfgOptionPart)) {
      //      std::cout << " ... skipping Operation: " << fullWitSodName << std::endl;
      continue;
    }
    //    std::cout << " ... processing SOD Operation: " << fullWitSodName << std::endl;
d2801 7
a2807 12
    // find the execVol of the SOD
    float * sodExecVol;
    witGetOperationExecVol(theWitRun, fullWitSodName.c_str(), &sodExecVol);
    
    // if the user wants data as a percentage of geoPlanner ship vol,
    // then we must get that and do the math.
    if (printDataAsPercentage) {
      // find the build volume of the geoPLannerDemandPart
      std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
									 plannerTopLevelPart, geo));
      float * gpdExecVol;
      witGetOperationExecVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdExecVol);
d2809 3
a2811 7
      for (t=0; t<nPeriods; t++)   {
	if (gpdExecVol[t] < 0.01) 
	  feasibleFeatureRatio[t] = 0.0;
	else 
	  feasibleFeatureRatio[t] = sodExecVol[t]/gpdExecVol[t];
      }
      witFree(gpdExecVol);
a2812 13
     
    // first print the preamble of the record
    outFile << "\"" << plannerTopLevelPart 
	    << "\",\"" << geo 
	    << "\",\"" << bbCategory 
	    << "\",\"" << mfgOptionPart << "\"";
    
    if (printDataAsPercentage) 
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, feasibleFeatureRatio, 4, 15);
    else
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, sodExecVol, 4, 15);      
    numRecords++;
    witFree(sodExecVol);    
a2813 1
  
d2815 1
d2819 5
d2825 4
a2828 1
  // this method writes FEATURE SET report  when using LP approach
d2830 1
a2830 1
LgFrScenarioForSce::printFeatureAnalysisReport(
d2865 4
a2868 4
     if (mpHelper.isPartSpecialOptionDummy(theWitRun, fullWitPartName, plannerTopLevelPart, 
					   geo, bbCategory, mfgOptionPart))   {
       //         if (sce::findCaseIns(bbCategory, "STANDALONE:") != sce::badIndex)
       //	 continue;
d2870 3
a2872 3
       // find the buildVolume of the specialOptionDummy
       float * sodProdVol;
       witGetPartProdVol(theWitRun, fullWitPartName.c_str(), &sodProdVol);
d2881 2
a2882 2
	 float * gpdProdVol;
	 witGetPartProdVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdProdVol);
d2885 1
a2885 1
	   if (gpdProdVol[t] < 0.01) 
d2888 1
a2888 1
	     feasibleFeatureRatio[t] = sodProdVol[t]/gpdProdVol[t];
d2890 1
a2890 1
	 witFree(gpdProdVol);
d2900 1
a2900 1
	 flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, sodProdVol, 4, 15);      
d2902 1
a2902 1
       witFree(sodProdVol);      
d2906 4
a2909 174
   delete [] feasibleFeatureRatio;
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



//  ---------------------------------------------------------------------
//  Print Substitute Usage Volumes
//  Generalized procedure: Use it for printing:
//     subUsage, mrpSubUsage, opSubUsage, mrpOpSubUsage
//  As more and more of these sub usage beasts are needed in the future, 
//  keep expanding the boolean arguments (for example isChildACapacity ...)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSubstituteUsageVolume(
	 WitRun * const theWitRun,
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
	 const int nPeriods,      
	 const int nOperations, 
	 char ** opList,        
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "<one of the>  Substitute Usage files" 
		       << fileName);
  }

  // declare an exploder, but define it only if you are looking for a 
  // an MRP based sub usage info.
  LgFrSceBaseExploder * myExploder;
  if (! engineMustBeImplode)
    myExploder = this->exploder();

  // use the correct witRun for all the wit api calling ....
  WitRun *  theRightWitRun;

  if (engineMustBeImplode)
    theRightWitRun = theWitRun;
  else
    theRightWitRun = myExploder->localWitRun();

  std::string subUsageReportMode =  this->setOfParameters().getString("subUsageReportMode");
  bool isDataTransformNecessary =  ( sce::compareStringsCaseIns( subUsageReportMode, "parentprod" ) != 0 );  
  bool transformToPrimary = TRUE;
  if (isDataTransformNecessary) {
    transformToPrimary = ( sce::compareStringsCaseIns( subUsageReportMode ,"primaryCoverage" ) == 0 );  
  }

  long numRecords = 0;
  std::string parentOperationName;
  std::string pdf;

  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];

    // For OpSubUsage and mrpOpSubUsage, we only consider "user-defined" operations
    if (parentMustBeUserDefinedOperation) {
      if (! mpHelper.isOperationUserDefined(theRightWitRun, 
					    fullWitOperationName, 
					    pdf, 
					    parentOperationName))
	continue;
    }

    // Otherwise, for subUsage and mrpSubUsage, we only consider normal part
    else {
      if (! (mpHelper.isOperationNormal(theRightWitRun, 
					fullWitOperationName, 
					pdf, 
					parentOperationName)
	     &&
	     mpHelper.isPartNormal(theRightWitRun,
				   fullWitOperationName))
	  )
	continue;
    }

    float * yieldRate;
    witGetOperationYieldRate(theRightWitRun, fullWitOperationName.c_str(), &yieldRate);

    
    int nBom;
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName.c_str(), &nBom);

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  float * subProdVol;
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, sj, &sub);
	  if (! mpHelper.isPartNormal(theRightWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  std::string subPartname =  mpHelper.partname(sub);
		   
	  if (engineMustBeImplode)
	    witGetSubsBomEntrySubVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
	  else
	    myExploder->subUsageVol(fullWitOperationName, j, sj, &subProdVol);      


	  // transform if necessary 
	  // initialize transformed vector to subProdVol
	  LgFrTimeVecFloat transformedTimeVec( (size_t) nPeriods, subProdVol );
	  if (isDataTransformNecessary) {
	    // we'll need to get consRate, falloutRate and impactPeriods to calculate the
	    // part usage.  IF we transformToPrimary, then we get these attributes off the 
	    // bom entry.   Otherwise, if we transform to sub, we get them off the sub bom entry
	    transformedTimeVec = 0.0;
	    float * consRate;
	    float falloutRate;
	    int * impactPeriod;
	    if (transformToPrimary) {
	      // get bom consumption rate
	      witGetBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, &consRate);
	      // get bom fallout rate
	      witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, &falloutRate);
	      // get bom impact periods
	      witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, &impactPeriod);
	    }
	    else {
	      // get sub bom consumption rate
	      witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &consRate);
	      // get sub bom fallout rate
	      witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &falloutRate);
	      // get sub bom impact periods
	      witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, sj, &impactPeriod);
	    }
	    int t;
	    for(t=0; t<nPeriods; t++) {	      
	      if (impactPeriod[t] != -1 ) {
		transformedTimeVec[impactPeriod[t]] += subProdVol[t] * 
		  consRate[t]/(1.0-falloutRate);
	      }
	    }
	    
	    witFree(impactPeriod);
	    witFree(consRate);
	  }
	  else {   
	    int t;
	    for(t=0; t<nPeriods; t++) {	      
	      transformedTimeVec[t] *= yieldRate[t];
	    }
	  }

	  outFile << "\"" << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, transformedTimeVec.data(), 0, 15);
	  numRecords++;
	  witFree(sub);
	  witFree(subProdVol);
	}
	witFree(child);
      }
    }
    witFree(yieldRate);
  }
a2910 3
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d2914 1
a2914 3
//  ---------------------------------------------------------------------
//  Print Sub DB Dump File
//  --------------------------------------------------------------------- 
d2916 1
a2916 1
LgFrScenarioForSce::printSubDbDumpFile(
d2918 3
a2920 5
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
	 const int nPeriods,      
	 const int nOperations, 
	 char ** opList,        
d2922 3
a2924 1
	 LgFrMultiPlantHelper & mpHelper)
d2926 1
d2930 1
a2930 1
		       << "<one of the>  Sub DB Dump" 
d2933 2
a2934 16

  // declare an exploder, but define it only if you are looking for a 
  // an MRP based sub usage info.
  LgFrSceBaseExploder * myExploder;
  if (! engineMustBeImplode)
    myExploder = this->exploder();

  // use the correct witRun for all the wit api calling ....
  WitRun *  theRightWitRun;

  if (engineMustBeImplode)
    theRightWitRun = theWitRun;
  else
    theRightWitRun = myExploder->localWitRun();


d2936 10
a2945 4
  std::string parentOperationName;
  std::string pdf;

  // Loop once for each operation
d2948 6
a2953 9
    std::string fullWitOperationName = opList[o];

    // For OpSubUsage and mrpOpSubUsage, we only consider "user-defined" operations
    if (parentMustBeUserDefinedOperation) {
      if (! mpHelper.isOperationUserDefined(theRightWitRun, 
					    fullWitOperationName, 
					    pdf, 
					    parentOperationName))
	continue;
d2955 1
d2957 3
a2959 24
    // Otherwise, for subUsage and mrpSubUsage, we only consider normal part
    else {
      if (! (mpHelper.isOperationNormal(theRightWitRun, 
					fullWitOperationName, 
					pdf, 
					parentOperationName)
	     &&
	     mpHelper.isPartNormal(theRightWitRun,
				   fullWitOperationName))
	  )
	continue;
    }


    /*  NOTE: 
       Assume that: 
       1)  the operation has one and only one BOP and that the triplets: 
       2)  there is a unique subBomEntry for parent, primary, sub 
    */



    float * yieldRate;
    witGetOperationYieldRate(theRightWitRun, fullWitOperationName.c_str(), &yieldRate);
d2961 14
a2974 105
    int nBom;
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName.c_str(), &nBom);

    int j = 0; 
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; 
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, sj, &sub);
	  if (! mpHelper.isPartNormal(theRightWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  
	  std::string subPartname =  mpHelper.partname(sub);
	  
	  // Note that we use subProdVol rather than subVol 
	  float * subVol;
	  if (engineMustBeImplode)
	    witGetSubsBomEntrySubVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subVol);
	  else
	    myExploder->subUsageVol(fullWitOperationName, j, sj, &subVol);      
	  
	  // Initialize all three to subVol
	  LgFrTimeVecFloat parentProd(nPeriods, 0.0);
	  LgFrTimeVecFloat primaryCov(nPeriods, 0.0);
	  LgFrTimeVecFloat subConsumed(nPeriods, 0.0);
	  
	  // Step 1: parentProd
	  //     Done!!   For now, directly use subVol (should finish me on this)
	  
	  
	  float * consRate;
	  float falloutRate;
	  int * impactPeriod;
	  float * subConsRate;
	  float subFalloutRate;
	  int * subImpactPeriod;
	  // get bom consumption rate
	  witGetBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, &consRate);
	  // get bom fallout rate
	  witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, &falloutRate);
	  // get bom impact periods
	  witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, &impactPeriod);
	  // get sub bom consumption rate
	  witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subConsRate);
	  // get sub bom fallout rate
	  witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subFalloutRate);
	  // get sub bom impact periods
	  witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subImpactPeriod);
	  
	  int t;
	  for(t=0; t<nPeriods; t++) {	      
	    parentProd[t] += subVol[t] * yieldRate[t];

	    if (impactPeriod[t] != -1 ) {
	      primaryCov[impactPeriod[t]] += subVol[t] * consRate[t] / (1.0-falloutRate);
	    }
	    
	    if (subImpactPeriod[t] != -1 ) {
	      subConsumed[subImpactPeriod[t]] += subVol[t] * subConsRate[t] / (1.0-subFalloutRate);
	    }
	  }
	  
	  witFree(impactPeriod);
	  witFree(consRate);
	  witFree(subImpactPeriod);
	  witFree(subConsRate);


	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "parentProd\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, parentProd.data(), 0, 15);

	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "primaryCov\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, primaryCov.data(), 0, 15);

	  outFile << "\"" 
		  << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\",\""
		  << "subConsumed\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subConsumed.data(), 0, 15);
	  
	  numRecords++;
	  witFree(sub);
	  witFree(subVol);
	}
	witFree(child);
d2976 1
d2978 13
a2990 1
    witFree(yieldRate);
d2993 1
a2993 1
  outFile.close();
d2998 1
a2998 9






//  ---------------------------------------------------------------------
//  Print Optimization Shadow Prices 
//  --------------------------------------------------------------------- 
d3000 1
a3000 1
LgFrScenarioForSce::printShadowPrices(
d3003 2
a3004 2
	 int nParts,
	 char ** partList,
d3006 3
a3008 1
	 LgFrMultiPlantHelper & mpHelper)
d3010 3
a3012 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3015 1
a3015 1
		       << "Shadow Prices File" 
d3020 1
d3022 1
a3022 2
   long numRecords = 0; 
   long numZeroVec = 0;
d3024 4
a3027 1
   float * shadowPrice;
d3029 1
a3029 9
   // Loop once for each part
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
#ifndef SHADOW_PRICE_DEBUG
     if (! mpHelper.isPartNormal(theWitRun, partList[i]))
       continue;
#endif
     std::string part = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
d3031 1
d3033 7
a3039 2
     // get the shadowPrice
     witGetPartShadowPrice (theWitRun, partList[i], &shadowPrice);
d3041 3
a3044 25
#if 0
     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (shadowPrice[t] > 0.0001) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       continue;
     }
#endif
	
#ifndef SHADOW_PRICE_DEBUG 
     outFile << "\"" 
	     << part << "\",\"" 
	     << pdf << "\""; 
#else
     outFile << "\"" 
	     << partList[i] << "\""; 
#endif
d3046 8
a3053 3
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shadowPrice, 0, 15);
     numRecords++;
   }
d3055 8
a3062 3
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}
d3064 5
d3071 6
a3076 63
//  ---------------------------------------------------------------------
//  Print Interplant Volumes (can be used by implosion or explosion)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printInterplantVolumesFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    if (isThisMrp) {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Interplant Demand File" 
			 << fileName);
    }
    else {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Interplant Orders" 
			 << fileName);
    }

  }



   long numRecords = 0; 
   long numZeroVec = 0;

   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;

   LgFrTimeVecFloat execVol;

   // Loop once for each operation
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
     if (! mpHelper.isOperationSpecialInterplant(theWitRun, opList[o], destination, 
						 destinationPdf, source, sourcePdf))
       continue;

     std::string operationName(opList[o]);

     // get the execVol
     if (isThisMrp)
       execVol = this->interplantMrpExecVol(operationName);
     else
       execVol = this->interplantExecVol(operationName);

     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
a3077 14
     }
     if (! isVecNonZero) {
       numZeroVec++;
       continue;
     }
	 
     outFile << "\"" 
	     << destination << "\",\"" 
	     << destinationPdf << "\",\"" 
	     << source    << "\",\"" 
	     << sourcePdf << "\""; 

     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol.data(), 0, 15);
     numRecords++;
d3080 2
a3081 2
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
d3087 5
a3091 1
//  Print AlternatePart Volumes (can be used by implosion or explosion)
d3094 7
a3100 6
LgFrScenarioForSce::printAlternateDbFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
d3106 3
a3108 11
    if (isThisMrp) {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Alternate Part (explode) File" 
			 << fileName);
    }
    else {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Alternate Part (implode) File" 
			 << fileName);
    }

d3111 5
d3117 2
d3120 4
a3123 38
   long numRecords = 0; 
   long numZeroVec = 0;

   std::string primePart;
   std::string primePdf;
   std::string altPart;
   std::string altPdf;


   // Loop once for each operation
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
     if (! mpHelper.isOperationSpecialAlternate(theWitRun, opList[o], primePart, 
						    primePdf, altPart, altPdf))
       continue;
     
     std::string operationName(opList[o]);

     // get the execVol
     float * execVol;
     witGetOperationExecVol(theWitRun, opList[o], &execVol);
     
     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       witFree(execVol);
       continue;
     }

d3125 6
a3130 1
     LgFrTimeVecFloat altConsumed(nPeriods, 0.0);
d3132 3
d3136 4
a3139 4
     // should be one and only one bom entry 
     int nbom;
     witGetOperationNBomEntries(theWitRun, opList[o], &nbom);
     assert(nbom == 1);
d3141 8
d3150 12
a3161 4
     // should be one and only one subbom entry 
     int nSubBom;
     witGetBomEntryNSubsBomEntries(theWitRun, opList[o], 0, &nSubBom);
     assert(nSubBom == 1);
d3163 2
a3164 20
     float * consRate;
     float falloutRate;
     // get bom consumption rate
     witGetSubsBomEntryConsRate(theWitRun, opList[o], 0, 0, &consRate);
     // get bom fallout rate
     witGetSubsBomEntryFalloutRate(theWitRun, opList[o], 0, 0, &falloutRate);
	  
     for(t=0; t<nPeriods; t++) {	      
       altConsumed[t] += execVol[t] * consRate[t] / (1.0-falloutRate);
     }
     
     witFree(consRate);
     
     outFile << "\"" 
	     << primePart  << "\",\"" 
	     << primePdf   << "\",\"" 
	     << altPart    << "\",\"" 
	     << altPdf     << "\",\""
	     << "primaryCov\"";
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
d3166 3
a3168 1
     witFree(execVol);
d3170 23
a3192 10
     outFile << "\"" 
	     << primePart  << "\",\"" 
	     << primePdf   << "\",\"" 
	     << altPart    << "\",\"" 
	     << altPdf     << "\",\""
	     << "altConsumed\"";
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, altConsumed.data(), 0, 15);
     
     numRecords++;
   }
a3193 3
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}
d3195 44
d3240 14
d3255 3
d3261 3
a3263 3
  //  ---------------------------------------------------------------------
  //  sets the adjusted interplant execVols for  implosion
  //  ---------------------------------------------------------------------
d3265 9
a3273 5
LgFrScenarioForSce::setInterplantOperationsAppDataForImplosion(
							       WitRun * const theWitRun,
							       const int nPeriods,                              
							       const int nOperations,
							       char ** operationList)
d3275 6
a3280 13
  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();
  
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;
d3282 5
a3286 15
    // if we're here, we have an interplant operation.
    // there should only be one BOM hanging off the ip operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS268E: Interplant operations"
	       << operationName
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the interplant operation's working execVol
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );
d3288 2
a3289 3
    // NOTE: this assert assumes that the mrp has already created the 
    // the appdata.  
    assert ( operationAppDataPtr != 0 );
d3291 4
a3294 2
    float * execVol;
    witGetOperationExecVol(theWitRun, operationName.c_str(), &execVol);
a3295 3
    // now set the execVol
    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, execVol );
    operationAppDataPtr->execVol(workingExecVolTimeVec);
d3297 3
a3299 2
    witFree( execVol ); 
  } 
d3301 4
d3306 8
a3313 3
  // second loop we compute them
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
d3315 12
a3326 10
    // if the operation isn't an interplant op, then we're not
    // interested in it
    std::string dPart;
    std::string dPdf;
    std::string sPart;
    std::string sPdf;
    if (! mpHelper.isOperationSpecialInterplant(
		       theWitRun, operationName,
		       dPart, dPdf, sPart, sPdf))
      continue;
a3327 17
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			      (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat execVol = operationAppDataPtr->execVol();
    
    // the only subs on this bom should be to alternative interplant locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s,
				      &subPdfPart );
d3329 5
a3333 16
      // break the subPdfPart name into it's pdf and part pieces
      // to get the interplant operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
					 dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialInterplant( theWitRun, subIpOp,
						    destPart, destPdf,
						    sourcePart, sourcePdf) ) {
	(*sceErrFacility_)("JumperArcError",MclArgList() << operationName << subPdfPart);
      }
a3334 33
      
      // get the execVol of the substitute interplant operation
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpExecVol = subIpOpAppDataPtr->execVol();
      
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the sub vol
      float * subVol;
      witGetSubsBomEntrySubVol( theWitRun, operationName.c_str(), 0, s, &subVol );
      
      // adjust the execVol of the current interplant operation
      // and the execVol of the substitute
      // interplant operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	execVol[t] -= subVol[t];
	subIpOpExecVol[t] += subVol[t] * subUsageRate;
      } // end t
      
      // set substitute interplant operation's adjusted exec vol in
      // the substitute interplant operations appData
      subIpOpAppDataPtr->execVol(subIpOpExecVol);
      
      witFree ( subVol );
      witFree ( subPdfPart );
	
    } // end for s
d3337 2
a3338 3
    // set interplant operation's adjusted exec vol in
    // the interplant operations appData
    operationAppDataPtr->execVol(execVol);
d3340 2
a3341 1
  } // end for o
d3343 57
a3399 1
}
d3401 13
d3416 7
a3422 8
LgFrTimeVecFloat
LgFrScenarioForSce::interplantExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );
d3424 7
a3430 2
  return operationAppDataPtr->execVol();
}
d3432 20
a3451 10
LgFrTimeVecFloat
LgFrScenarioForSce::interplantMrpExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );

  return operationAppDataPtr->mrpExecVol();
a3455 24
// intiialize the app data's with straight execVols, and then compute them.
void
LgFrScenarioForSce::initializeInterplantOperationsAppData(
							  WitRun * const theWitRun,
							  const int nPeriods,                              
							  const int nOperations,
							  char ** operationList)
{
  LgFrSceBaseExploder * myExploder = myExploder = this->exploder();

  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();

  // first loop we initialize them
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;
a3456 22
    // if we're here, we have an interplant operation.
    // there should only be one BOM hanging off the ip operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS269E: Interplant operations"
	       << operationName.c_str()
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the interplant operation's working mrpExecVol
    // to be the operation's mrp exec vol.
    // Store it for further mucking
    // in the interplant operation's app data
    // Caller needs to clean up the appData.
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr == 0 );
    float * mrpExecVol;
    myExploder->mrpExecVol(operationName, &mrpExecVol);
a3457 5
    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, mrpExecVol );
    operationAppDataPtr = new LgFrSceInterplantOpAppData (workingExecVolTimeVec);
    witSetOperationAppData( theWitRun, operationName.c_str(), (void *) operationAppDataPtr );
    witFree( mrpExecVol ); 
  } 
d3461 18
a3478 3
  // second loop we compute them
  for (o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
a3479 8
    // if it's not an interplant operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialInterplant( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;
a3480 13
    // if we're here, we have an interplant operation.
    // Get the operation's working mrpExecVol
    
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(), (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat mrpExecVol = operationAppDataPtr->mrpExecVol();
    
    // the only subs on this bom should be to alternative interplant locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
d3482 2
a3483 27
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s, &subPdfPart );
      
      // break the subPdfPart name into it's pdf and part pieces
      // to get the interplant operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
				     dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialInterplant( theWitRun, subIpOp,
						      destPart, destPdf,
						      sourcePart, sourcePdf) ) {
	std::cerr << "\nJumper Arc Error: Interplant operation "
	     <<  operationName.c_str()
	     << " has a substitute "
	     << subPdfPart
	     << " that is not valid. Contact SCE Support\n" << std::endl;
	exit (1);
	}
d3485 1
a3485 23
      // get the execVol of the substitute interplant operation, subIpOp
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpMrpExecVol = subIpOpAppDataPtr->mrpExecVol();
	
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the sub vol
      float * subUsageVol;
      myExploder->subUsageVol(operationName, 0, s, &subUsageVol );
      
      // adjust the mrpExecVol of the current interplant operation
      // and the mrpExecVol of the substitute
      // interplant operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	mrpExecVol[t] -= subUsageVol[t];
	subIpOpMrpExecVol[t] += subUsageVol[t] * subUsageRate;
      } // end t
d3487 9
a3495 7
      // set substitute interplant operation's adjusted mrp exec vol in
      // the substitute interplant operations appData
      subIpOpAppDataPtr->mrpExecVol(subIpOpMrpExecVol);
      witFree ( subUsageVol );
      witFree ( subPdfPart );
      
    } // end for s
d3498 2
a3499 3
    // set interplant operation's adjusted mrp exec vol in
    // the interplant operations appData
    operationAppDataPtr->mrpExecVol(mrpExecVol);
a3500 1
  } // end for o
d3502 25
a3526 1
}
d3528 3
d3532 3
d3539 1
a3539 4
//  Print Operation Execution Volume (as determined by implosion)
    // Prints execVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
d3542 1
a3542 1
LgFrScenarioForSce::printOperationOrdersFile(
d3545 3
d3551 16
a3566 6
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Operation Execution Volume" 
			<< fileName);
   }
d3568 1
a3568 1
   long numRecords = 0;
d3570 7
a3576 2
   // we're also gonna keep track of the number of unprinted zeroVectors
   // for reconciling the number of input vs output records later.
a3578 3
   int nOperations;
   char ** operationList;
   witGetOperations(theWitRun, &nOperations, &operationList);
d3580 15
a3594 11
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
     if (! mpHelper.isOperationNormal(theWitRun, operationList[o], thePdf, theOperation))
	   continue;
     // get the execVol
     float * execVol;
     witGetOperationExecVol(theWitRun, operationList[o], &execVol);
     
     // if the execVol is a Zero vector,
     // then don't print it.
a3603 1
       witFree(execVol);
d3607 1
a3607 1
     
d3609 6
a3614 4
	     << theOperation << "\",\"" 
	     << thePdf << "\""; 
     
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
a3615 1
     witFree(execVol); 
d3617 1
a3617 5
   
   for (o=0; o<nOperations; o++ ) 
     witFree(operationList[o]);
   witFree(operationList);
   
d3619 1
a3619 1
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec);
a3623 1

d3625 1
a3625 4
//  Print Operation Demand File (as determined by explosion)
    // Prints mrpExecVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
d3628 1
a3628 1
LgFrScenarioForSce::printOperationDemandVolFile(
d3631 3
d3637 15
a3651 6
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
   if (outFile.fail()) {
     (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			<< "Operation Demand " 
			<< fileName);
   }
a3652 1
   LgFrSceBaseExploder * myExploder = this->exploder();          
d3654 1
a3654 1
   long numRecords = 0;
d3656 6
a3661 2
   // we're also gonna keep track of the number of unprinted zeroVectors
   // for reconciling the number of input vs output records later.
a3663 3
   int nOperations;
   char ** operationList;
   witGetOperations(theWitRun, &nOperations, &operationList);
d3665 7
a3671 5
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
     if (! mpHelper.isOperationNormal(theWitRun, operationList[o], thePdf, theOperation))
	   continue;
d3673 2
a3674 2
     float * mrpExecVol;
     myExploder->mrpExecVol(operationList[o], &mrpExecVol);
d3676 2
a3677 2
     // if the execVol is a Zero vector,
     // then don't print it.
d3681 1
a3681 1
       if (mrpExecVol[t] > 0.01) {
a3686 1
       witFree(mrpExecVol);
d3688 1
a3690 17
     
     outFile << "\"" 
	     << theOperation << "\",\"" 
	     << thePdf << "\""; 
     
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpExecVol, 0, 15);
     numRecords++;
     witFree(mrpExecVol); 
   }
   
   for (o=0; o<nOperations; o++ ) 
     witFree(operationList[o]);
   witFree(operationList);
   
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec);
}
d3693 1
d3696 4
a3699 14
//  ---------------------------------------------------------------------
//  Print Backlog schedule         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBacklogSchedule(
					       WitRun * const theWitRun,   // WIT environment   
					       const int nPeriods,         // Number of periods 
					       const int nParts,           // Number of parts   
					       char ** partList,           // List of part names
					       std::string fileName,
					       LgFrCalendar & theCal,
					       LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
a3700 6
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Backlog Response" 
		       << fileName);
  }
d3702 4
a3705 1
  long numRecords = 0;
d3707 20
a3726 4
  float * shipVol;
  float * demandVol;
  float blog;
  int i, t;
d3728 1
a3728 3
  int nDemands;
  char ** dList;
  int j;
d3730 10
d3741 2
a3742 32
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string partname = mpHelper.partname(partList[i]);
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
	
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	// demandVol
	witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	// backlogVol
	blog = 0.0;
	for (t=0; t<nPeriods; t++)    {
	  blog += (demandVol[t] - shipVol[t]);
	  shipVol[t] = blog;
	}
	
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
	witFree(shipVol);
	witFree(demandVol);
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
a3744 33
//  ---------------------------------------------------------------------
//  Print GEO Supply By PDF  Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printGeoSupplyByPdf(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
   
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Supply Response by PDF" 
		       << fileName);
  }

   long numRecords = 0; 
   int i, t, tt, ttt;
   float * gpdProdVol;
   int * totalGeoToPdfSourceIndicator = new int[nPeriods];
   int * geoToPdfSourceIndicator = new int[nPeriods];
   float * geoByPdfSupplyVol = new float[nPeriods];
   std::string * sourceList = new std::string[nPeriods];

a3745 6
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     // only look at geoPlannerDemandParts
     if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						      partList[i], plannerPart, geo))
       continue;
a3746 4
     // initialize the total indicator vector to 0 for this GPD part
     for (t=0; t<nPeriods; t++) {
       totalGeoToPdfSourceIndicator[t] = 0;
     }
a3747 9
     // get the GeoSource Vector rule
     determineGeoToPdfSourceVector(theWitRun, 
				   mpHelper,
				   partList[i],
				   sourceList);
     
     
     // prodVol of the GPD part is equivalent to the shipVol (we hope)
     witGetPartProdVol(theWitRun, partList[i], &gpdProdVol);
a3748 6
     // now try to write out one vector for each possible geo->Pdf combo
     for (t=0; t<nPeriods; t++) {
       // if the total indicator vector is 1, then we've already reported this source
       if (totalGeoToPdfSourceIndicator[t] == 1)
	 continue;
       // otherwise, we found an unreported source
d3750 23
a3772 3
       // init the indicator vector for this part,pdf
       for (tt=0; tt<nPeriods; tt++)
	 geoToPdfSourceIndicator[tt] = 0;
d3774 15
a3788 3
       // mark period t as true for this source
       geoToPdfSourceIndicator[t] = 1;
       totalGeoToPdfSourceIndicator[t] = 1;
d3790 3
a3792 10
       // now loop over the rest of the horizon to see if
       // any other periods are sourced the same as period t.
       // mark each tt in both the total indicator and the local
       // one.
       for (tt=t+1; tt<nPeriods; tt++) {
	 if ((totalGeoToPdfSourceIndicator[tt] == 0) && (sourceList[tt] == sourceList[t])) {
	   totalGeoToPdfSourceIndicator[tt] = 1;
	   geoToPdfSourceIndicator[tt] = 1;
	 }
       }
d3794 2
a3795 5
       // ok, at this point the entire geoToPdfSourceIndicator vector
       // should be "populated".  So now we can report on the current
       // source.  (Note the source is sourceList[t] still.)
       mfgPart = mpHelper.partname(sourceList[t]);
       pdf = mpHelper.pdf(sourceList[t]);
d3797 3
d3801 2
a3802 4
       // multiply the total gpdProdVol by the indicator vector to get
       // the amount from this particular PDF.
       for (ttt=0; ttt<nPeriods; ttt++)       
	 geoByPdfSupplyVol[ttt] = gpdProdVol[ttt] * geoToPdfSourceIndicator[ttt];
a3803 3
       // Now you can print this record.  
       outFile << "\"" << plannerPart << "\",\"" << geo << "\","
	       << "\"" << mfgPart     << "\",\"" << pdf << "\"";
d3805 3
a3807 4
       flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, geoByPdfSupplyVol, 0, 15);
       numRecords++;
     }
     witFree(gpdProdVol);
d3809 10
a3818 5
   }
   delete [] geoByPdfSupplyVol;
   delete [] totalGeoToPdfSourceIndicator;
   delete [] geoToPdfSourceIndicator;
   delete [] sourceList;
d3820 17
a3836 3
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d3838 16
a3853 21
//  ---------------------------------------------------------------------
//  Print Part Shipment Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Supply Response" 
		       << fileName);
  }
d3855 31
a3885 22
  long numRecords = 0;
  
  float * shipVol;
  int i;
  
  int nDemands;
  char ** dList;
  int j;
  
  
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;
    //    int x = mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
    //                                                plannerPart, geo);
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      std::string partname = mpHelper.partname(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	outFile << "\"" << partname << "\",\"" << dList[j] << "\"";
d3887 2
a3888 13
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
	witFree(shipVol); 
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d3890 5
a3894 21
//  ---------------------------------------------------------------------
//  Print Part Shipment Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printIndepSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Independent Supply Response" 
		       << fileName);
  }
d3896 1
a3896 22
  long numRecords = 0;
  
  float * shipVol;
  int i;
  
  int nDemands;
  char ** dList;
  int j;
  
  
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
      std::string partname = mpHelper.partname(partList[i]);
      std::string pdf = mpHelper.pdf(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
a3897 14
#ifdef ENABLE_NEGATIVE_DEMANDS
	// adjust shipVOl for negative demand
	LgFrSceDemandAppData * demandAppDataPtr;
	witGetDemandAppData(theWitRun, partList[i], dList[j], (void **) &demandAppDataPtr);
	if (demandAppDataPtr->doesDemandHaveNegativeValues()) {
	  LgFrTimeVecFloat demandVolTVF = demandAppDataPtr->demandVol();
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
	    if (demandVolTVF[t] < 0) {
	      shipVol[t] += demandVolTVF[t];
	    }
	  }
	}
#endif
a3898 2
	bool printIfZero = false;
	flatFileMgr_.writeDemandRecord(outFile, mpHelper, theCal, partname, pdf, dList[j], nPeriods, shipVol, printIfZero, 0, 15);
d3900 8
d3909 1
a3909 9
	witFree(shipVol); 
	witFree(dList[j]);
	numRecords++;
      }
      witFree(dList);
    }
  }    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
d3912 8
d3921 2
a3923 5
#ifdef MULTI_ATTRIBUTE_DEMAND_CLASS
std::string
LgFrScenarioForSce::customerKeyExpansion(
					 std::string compressedGeo)
{
a3924 2
  std::string geoSeparator = ";";
  int numCustomerAttr = 4;  
d3926 9
d3936 1
a3936 2
  SCETokenizer next(compressedGeo);
  int tokenCount = 0;
d3938 12
a3949 4
  std::string returnString = "";
  std::string token = "";
  for (tokenCount = 0; tokenCount<numCustomerAttr; tokenCount++) {
    
d3951 9
a3959 4
    token =  next(geoSeparator.c_str());
    if (token.empty()) {
      std::cerr << "tokenization of COmpressed Geo key failed\n";
      exit(8);
d3962 18
a3979 5
    if (tokenCount == 0) 
      returnString += token;
    else
      returnString += "\",\"" + token;
  }
a3980 1
  return returnString;
d3982 3
a3984 1
}
d3986 8
a3993 1
#endif
d3995 13
a4007 14
//  ---------------------------------------------------------------------
//  Print Part Shipment Information in human readable format        
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printHumanReadableSupplyPlanSoln(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
d4009 27
a4035 6
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Formatted Output" 
		       << fileName);
  }
d4037 23
a4059 9
   long numRecords = 0;
   float * witVector;
   float * witVector1;
   float   blog;
   int i, t;
   std::string demandName("WW");
   int nDemands;
   char ** dList;
   int j;
d4061 7
a4067 1
// print some dates
a4068 24
   outFile << "             ";
   for (t=0; t<nPeriods; t++)  {
       LgFrDatetime thisDate(theCal.periodStart(t));
       std::string theDate("    " + thisDate.getDateAsString() + "   ");
       outFile << theDate;
   }
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
       std::string parti(partList[i]);
       std::string partname = mpHelper.partname(parti);
       std::string plannerPart;
       std::string geo;
       if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						       plannerPart, geo)) {
	 witGetPartDemands(theWitRun, parti.c_str(), &nDemands, &dList);
	 for (j =0; j<nDemands; j++)  {
	   
	   outFile << "\n" << partname << " - " << dList[j] << ":\n";
	   
// demand Vol
	   outFile << "    Demand";
	   witGetDemandDemandVol(theWitRun, parti.data(), dList[j], &witVector);
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector, 0, 15);
	   numRecords++;
d4070 3
a4072 5
// shipVol
	   outFile << "    Supply";
	   witGetDemandShipVol(theWitRun, parti.c_str(), dList[j], &witVector1);
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector1, 0, 15);
	   numRecords++;
d4074 1
a4074 9
// backlogVol
	   blog = 0.0;
	   outFile << "     Delta";
	   for (t=0; t<nPeriods; t++)    {
	     blog += (witVector1[t] - witVector[t]);
	     witVector[t] = blog;
	   }
	   flatFileMgr_.writeFloatVector(outFile, nPeriods, witVector, 0, 15);
	   numRecords++;
a4075 11
	   witFree(witVector); 
	   
	   witFree(witVector1); 
	   witFree(dList[j]);
	   
	 }
	 witFree(dList);
       }
   }
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
d4078 4
d4083 4
a4086 1
//  Print GEO Supply By PDF  Information         
d4089 1
a4089 1
LgFrScenarioForSce::printGeoSourceDebugFile(
a4091 2
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
a4092 1
	 LgFrCalendar & theCal,
a4094 3
   std::string geo;
   std::string plannerPart;

d4096 5
a4100 5
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Geo Source Debug" 
		       << fileName);
  }
d4103 3
d4107 27
a4133 9
   int i;
   std::string * sourceList = new std::string[nPeriods];


   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     // only look at geoPlannerDemandParts
     if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						      partList[i], plannerPart, geo))
d4135 5
a4139 5

     int periodWithNoSource = determineGeoToPdfSourceVector(theWitRun, 
							    mpHelper,
							    partList[i],
							    sourceList);
d4141 1
a4141 6

     outFile << "\"" << plannerPart << "\",\"" << geo << "\"";
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++)
       outFile << ",\"" << sourceList[t]     << "\"";
     outFile << "\n";
d4143 1
a4143 5

     if (periodWithNoSource > -1) {
       // error
       (*sceErrFacility_)("GeoDemandNotSourced",MclArgList() << geo << plannerPart << periodWithNoSource);
     }
d4145 5
a4149 2
   delete [] sourceList;

d4151 1
a4151 1
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
d4154 3
d4158 4
a4161 1
//  Print Part Build Schedule 
d4164 1
a4164 1
LgFrScenarioForSce::printBuildSchedule(
a4166 2
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
a4167 1
	 LgFrCalendar & theCal,
d4171 7
a4177 5
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Build Schedule" 
		       << fileName);
  }
d4179 4
a4182 2
   long numRecords = 0; 
   float * execVol;
d4184 27
a4210 4
   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     if (! mpHelper.isPartBuildable(theWitRun, partList[i]))
d4212 2
a4213 2
     std::string partname = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
d4215 4
a4218 8
	     << partname << "\",\"" 
	     << pdf << "\"";

     // note: the opeation is guaranteed to exist
     // by definition of isPartBuildable
     witGetOperationExecVol(theWitRun, partList[i], &execVol);
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
     witFree(execVol); 
d4220 1
d4222 9
a4231 2
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
a4232 1
}
d4235 1
a4235 1
//  Print critical parts list
d4238 8
a4245 10
LgFrScenarioForSce::printCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // rollover handled differently
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper,
	 LgFrSceCritList & theCritList)
d4247 2
d4252 1
a4252 1
		       << "Critical Parts List" 
d4256 6
a4261 1
  bool useDatedDemands = this->setOfParameters().getBool("useDatedDemands");
d4263 3
a4265 10
  long numRecords = 0;
  
  // Loop once for each part.  
  int i = 0; 
  for (i=0; i<theCritList.getLength(); i++ ) {
    std::string part = theCritList.getPart(i);
    int pd = theCritList.getPeriod(i);
    if (! mpHelper.isPartNormal(theWitRun, part))
      continue;
    // comeback
a4266 5
    std::string partname = mpHelper.partname(part);
    std::string pdf = mpHelper.pdf(part);
    outFile << "\"" 
	    << partname << "\",\"" 
	    << pdf << "\",";
d4268 29
a4296 3
    if (useDatedDemands) {
      outFile << theCal.yyyymmdd(theCal.periodStart(pd)) << ","
	      << i << "\n";
d4298 1
a4298 7
    else {
      outFile << pd << ","
	      << i << "\n";
    }
    numRecords++;
  }
  outFile.close();
a4301 1

d4303 1
a4303 1
//  Print pegged critical parts list
d4306 6
a4311 5
LgFrScenarioForSce::printPeggedCriticalList(
	 WitRun * const theWitRun,   // WIT environment
	 std::string engine,            // only works for heuristic allocation
	 std::string fileNameBox,
	 std::string fileNameIndp,
d4315 7
a4321 2
  std::ofstream outFileBox(fileNameBox.c_str());//, ios::out, 0666);
  if (outFileBox.fail()) {
d4323 2
a4324 2
		       << "Pegged Critical Parts List" 
		       << fileNameBox);
d4327 7
a4333 6
  std::ofstream outFileIndp(fileNameIndp.c_str());//, ios::out, 0666);
  if (outFileIndp.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Independent Pegged Critical Parts List" 
		       << fileNameIndp);
  }
a4334 8
#ifdef CRIT_PEG_DEBUG
  std::ofstream outFilePCDump("pegCritDump.out");
  if (outFilePCDump.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Pegged Critical Parts List DEBUG_DUMP" 
		       << "pegCritDump.out");
  }
#endif
d4336 6
d4343 4
d4348 9
a4356 130
  long numRecordsBox = 0;
  long numRecordsIndp = 0;

  // Loop once for each part.  
  
  // PEG_CRIT_LIST
  int      lenLists;
  char **  critPartNameList;
  int *    critPerList;
  char **  demPartNameList;
  char **  demandNameList;
  int *    shipPerList;
  
  witGetPgdCritList (theWitRun,
		     &lenLists,
		     &critPartNameList,
		     &critPerList,
		     &demPartNameList,
		     &demandNameList,
		     &shipPerList);

  int i = 0; 
  for (i=0; i<lenLists; i++ ) {
    
    if (! mpHelper.isPartNormal(theWitRun, critPartNameList[i])) {
#ifdef CRIT_PEG_DEBUG
      outFilePCDump << (int) 99 << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif
      witFree(critPartNameList[i]);
      witFree(demPartNameList[i]);
      witFree(demandNameList[i]);
      continue;
    }

    std::string critpartname = mpHelper.partname(critPartNameList[i]);
    std::string critpdf = mpHelper.pdf(critPartNameList[i]);


    // figure out how to write demand name
    // if it's normal independend demand (non-GPD, non-special), then print part, pdf, demandID
    // if it's GPD, then print plannerpart, demandSourcePdf, geo
    // if it's special feature part, then map it to a GPD and print plannerpart, demandSourcePdf, geo


    std::string demandedPartName = demPartNameList[i];
    std::string demandedPdf = "";
    std::string demandedCust = demandNameList[i];

    bool isItBox = 0;

    // Case 1: normal independend demand
    if (mpHelper.isPartNormal(theWitRun, demPartNameList[i])) {
      demandedPartName = mpHelper.partname(demPartNameList[i]);
      demandedPdf      = mpHelper.pdf(demPartNameList[i]);
      isItBox = 0;
    }

    // Case 2: normal GPD  demand
    else if (mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, 
							demPartNameList[i],
							demandedPartName, 
							demandedCust)) {
      int late;
      float offset;
      std::string fName="internal operation: printPeggedCriticalList";
      std::string dLine="noLine";
      long lineNo = 0;

      std::string demandedPartPdf = mpHelper.demandSource( theWitRun, 
							   demandedPartName,
							   demandedCust,
							   shipPerList[i],
							   late,
							   offset,
							   fName, 
							   dLine, 
							   lineNo, 
							   OPTIONAL_WITH_MESSAGE);
      demandedPartName = mpHelper.partname(demandedPartPdf);
      demandedPdf      = mpHelper.pdf(demandedPartPdf);
      isItBox = 1;
    }

    // Case 3: special Feature Demand
    else {
      std::string featurePart;
      if (mpHelper.isOperationSpecialFeature(theWitRun, 
					     demPartNameList[i],
					     demandedCust,    
					     demandedPartName,    
					     demandedPdf,    
					     featurePart)) {
	
	//	demandedPartName = demPartNameList[i];
	//	demandedPdf = "";
	//	demandedCust = demandNameList[i];
	//	demandedPdf = "";
	//	demandedCust = demandNameList[i];
	isItBox = 1;
      }
    }

    if (isItBox) {
      outFileBox << "\"" << demandedPartName << "\","
		 << "\"" << demandedCust << "\","
		 << "\"" << critpartname << "\","
		 << "\"" << critpdf << "\","
		 << shipPerList[i] << ","
		 << critPerList[i] << ","
		 << i << "\n";
      numRecordsBox++;
    }
    else {
      // do it in flatfileMgr!

      flatFileMgr_.writePegCritListRecord(outFileIndp, mpHelper, theCal,
					  demandedPartName,
					  demandedPdf,
					  demandedCust,
					  critpartname,
					  critpdf,
					  shipPerList[i], 
					  critPerList[i], 
					  i);
d4358 6
a4363 10
      //      outFileIndp << "\"" << demandedPartName << "\","
      //	  << "\"" << demandedPdf << "\","
      //	  << "\"" << demandedCust << "\","
      //	  << "\"" << critpartname << "\","
      //	  << "\"" << critpdf << "\","
      //	  << shipPerList[i] << ","
      //	  << critPerList[i] << ","
      //	  << i << "\n";
      numRecordsIndp++;
    }
d4365 3
d4369 3
a4371 9
#ifdef CRIT_PEG_DEBUG
      outFilePCDump << isItBox << ","
		    << "\"" << demPartNameList[i] << "\","
		    << "\"" << demandNameList[i] << "\","
		    << "\"" << critPartNameList[i] << "\","
		    << shipPerList[i] << ","
		    << critPerList[i] << ","
		    << i << "\n";
#endif
d4373 10
a4382 4
    witFree(critPartNameList[i]);
    witFree(demPartNameList[i]);
    witFree(demandNameList[i]);
  }
d4384 5
a4388 5
  witFree(critPartNameList);
  witFree(critPerList);
  witFree(demPartNameList);
  witFree(demandNameList);
  witFree(shipPerList);
a4389 9
  outFileBox.close();
  outFileIndp.close();
#ifdef CRIT_PEG_DEBUG
  outFilePCDump.close();
#endif
  
  flatFileMgr_.sceIOLogManager().printOutputLog(fileNameBox, numRecordsBox,000,numRecordsBox); 
  flatFileMgr_.sceIOLogManager().printOutputLog(fileNameIndp, numRecordsIndp,000,numRecordsIndp); 
}
d4391 4
d4396 3
d4400 4
d4405 5
d4411 3
d4415 13
a4427 2
void
LgFrScenarioForSce::printModelStructureOutputs()
d4429 8
a4436 6
    int nPeriods;                         //  Number of periods in model  
    int nParts;                           //  Number of parts in model     
    char ** partList;                     //  List of parts in model       
    int i;                                //  Loop index                  
    //    int nOperations;
    //    char ** opList;                     //  List of parts in model       
d4438 14
d4453 1
a4453 7
    WitRun * const theWitRun = lastProblemSolved().witRun();
    LgFrCalendar & theCal = calendar();
    LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
      
    witGetParts( theWitRun, &nParts, &partList );
    //    witGetOperations( theWitRun, &nOperations, &opList );
    nPeriods = theCal.nPeriods();
d4455 9
a4463 1
    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
d4465 3
a4467 7
   // Lowest Level Non Pcf File: optional
   if (setOfParameters.getBool("printLowestLevelNonPcfFile"))  {
     std::string lowestLevelNonPcfFileName =
       setOfParameters.getString("lowestLevelNonPcfFileName");
     printLowestLevelNonPcfParts(theWitRun, mpHelper, nPeriods, nParts, partList,
				 lowestLevelNonPcfFileName);
   }
d4469 1
d4471 7
a4477 7
   // PCF Bogons File: optional
   if (setOfParameters.getBool("printPcfBogonsFile"))  {
     std::string pcfBogonsFileName =
       setOfParameters.getString("pcfBogonsFileName");
     printBogonParts(theWitRun, mpHelper, nPeriods, nParts, partList,
		     pcfBogonsFileName);
   }
d4480 23
a4502 12
   // *************************************    
   // Calculate Value Add Costs 
   // *************************************
   if (setOfParameters.getBool("calculateVac"))  {
     std::cout << "Calculating Value Added Costs  ..." << std::endl;                
     std::string vacFileName = setOfParameters.getString("vacFileName");
     std::string compCostFileName = setOfParameters.getString("compCostFileName");
     calculateAndPrintValueAddedCosts(theWitRun, mpHelper, nPeriods, nParts, partList,
				      vacFileName, compCostFileName);
   }
   

d4504 16
d4522 20
d4543 37
a4580 4
   // Cleanup memory
   for ( i=0; i<nParts; i++) 
      witFree(partList[i]);
   witFree( partList );
a4581 4
   //   for (int o=0; o<nOperations; o++) 
   //      witFree(opList[o]);
   //   witFree( opList );
}
d4584 3
d4588 8
a4595 1
LgFrScenarioForSce::analyzeRunAndPrintResults()
d4597 8
d4606 22
a4627 6
    int nPeriods;                         //  Number of periods in model  
    int nParts;                           //  Number of parts in model     
    char ** partList;                     //  List of parts in model       
    int i;                                //  Loop index                  
    int nOperations;
    char ** opList;                     //  List of parts in model       
d4629 14
d4644 3
a4646 8
    WitRun * const theWitRun = lastProblemSolved().witRun();
    LgFrCalendar & theCal = calendar();
    LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
    LgFrSceCritList & theCritList = sceCritList();
      
    witGetParts( theWitRun, &nParts, &partList );
    witGetOperations( theWitRun, &nOperations, &opList );
    nPeriods = theCal.nPeriods();
a4647 1
    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
d4649 5
a4653 14
    std::string siteCustomization = setOfParameters.getString("siteCustomization");


    // VERY IMPORTANT!!  This step sets App data for Interplant
    // operations in the primary witRun!!  It must be done before any interplant
    // execVols can be accessed (in either mrp or implosion witRuns). The app data
    // is actually store in the priamry witRun.  At this point the appdata's 
    // should ahve been created during the printExplosion results and here we are
    // merely going to set the implosion values (which were initialized to zero)
    if (siteCustomization != "skipTheCrapola") {
      setInterplantOperationsAppDataForImplosion(theWitRun,
						 nPeriods,
						 nOperations,
						 opList);
d4655 4
a4660 18
    // Geo Source Debug File: optional file
    if (setOfParameters.getBool("printGeoSourceDebugFile"))  {    
      std::string geoSourceDebugFileName =
	setOfParameters.getString("geoSourceDebugFileName");
      printGeoSourceDebugFile(theWitRun, nPeriods, nParts, partList,
			      geoSourceDebugFileName, theCal, mpHelper);
    }
    
    
    
    // Formatted Supply Response Report File: optional file
    if (setOfParameters.getBool("printFormattedSupplyReportFile"))  {    
      std::string formattedSupplyReportFileName =
	setOfParameters.getString("formattedSupplyReportFileName");
      printHumanReadableSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
				       formattedSupplyReportFileName,
				       theCal, mpHelper);
    }
a4661 5
    // Supply Response  File: mandatory file
    std::string supplyResponseFileName =
      setOfParameters.getString("supplyResponseFileName");
    printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
			supplyResponseFileName, theCal, mpHelper);
d4663 14
a4676 7
    // Independent Supply Response  File: optional
    std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (setOfParameters.getBool("printIndpSupplyResponseFile") && ! independentDemandFile.empty())   {
      std::string indepSupplyResponseFileName =	setOfParameters.getString("indepSupplyResponseFileName");
      printIndepSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
			  indepSupplyResponseFileName, theCal, mpHelper);
    }
d4678 6
d4685 9
a4693 6
    // Supply Response By PDF  File: optional file
    if (setOfParameters.getBool("printGeoSupplyByPdfFile"))  {
      std::string geoSupplyByPdfFileName = setOfParameters.getString("geoSupplyByPdfFileName");
      printGeoSupplyByPdf(theWitRun, nPeriods, nParts, partList,
			  geoSupplyByPdfFileName, theCal, mpHelper);
    }
d4695 1
a4695 6
    // Backlog Response File: optional file
    if (setOfParameters.getBool("printBacklogResponseFile") && (siteCustomization != "skipTheCrapola")) {  
      std::string backlogResponseFileName = setOfParameters.getString("backlogResponseFileName");
      printBacklogSchedule(theWitRun, nPeriods, nParts, partList,
			   backlogResponseFileName, theCal, mpHelper);
    }
d4697 24
a4720 1
    
d4722 5
a4726 7
    // Critical List: optional file
    if (setOfParameters.getBool("printCriticalListFile"))  {    
      std::string criticalListFileName = setOfParameters.getString("criticalListFileName");
      std::string engine = setOfParameters.getString( "engine");
      this->printCriticalList(theWitRun, engine, nPeriods, nParts, partList,
			      criticalListFileName, theCal, mpHelper, theCritList);
    }
d4728 9
a4736 50
    // Pegged Critical List: optional file
    if (setOfParameters.getBool("printPeggedCritListFile"))  {    
      std::string peggedCriticalListFileName  = setOfParameters.getString("peggedCritListFileName");
      std::string iPeggedCriticalListFileName =	setOfParameters.getString("iPeggedCritListFileName");
      std::string engine = setOfParameters.getString( "engine");
      this->printPeggedCriticalList(theWitRun, engine, 
				    peggedCriticalListFileName, 
				    iPeggedCriticalListFileName, 
				    theCal,
				    mpHelper);
    }


    
    if (setOfParameters.getBool("printBuildSchedFile") && (siteCustomization != "skipTheCrapola")) {
      // Build Schedule  File: mandatory file
      std::string buildSchedFileName =
	setOfParameters.getString("buildSchedFileName");
      printBuildSchedule(theWitRun, nPeriods, nParts, partList,
			 buildSchedFileName,
			 theCal, mpHelper);
    }


    // Interplant Order File
    if (setOfParameters.getBool("printInterplantOrdersFile") && (siteCustomization != "skipTheCrapola")) {
      std::string interPlantFile = setOfParameters.getString("interPlantFile");
      if (! interPlantFile.empty())   {
	std::string interplantOrdersFileName = setOfParameters.getString("interplantOrdersFileName");
	bool isThisMrp = false;
	printInterplantVolumesFile(theWitRun, nPeriods, 
				   nOperations, opList,
				   isThisMrp,
				   interplantOrdersFileName,
				   mpHelper);
      }
    }


    // Print Alternate DB File
    bool printAltDbFile = setOfParameters.getBool("printAltDbFile");
    if (printAltDbFile )   {
      std::string altDbFileName = setOfParameters.getString("altDbFileName");
      bool isThisMrp = false;
      printAlternateDbFile(theWitRun, nPeriods,
		     nOperations, opList,
		     isThisMrp,
		     altDbFileName,
		     mpHelper);
    }
d4738 12
d4751 15
d4767 6
a4772 12
    // Print Shadow Price File: optional file (3.11)
    // prints only when asked for AND if engine="optimization"
    bool printShadowPricesFile = setOfParameters.getBool("printShadowPricesFile");
    std::string engine = this->getEngine();
    if ((! engine.compare("optimization")) && printShadowPricesFile) {
      std::string shadowPricesFileName = setOfParameters.getString("shadowPricesFileName");
      printShadowPrices(theWitRun, nPeriods, 
			nParts, partList,
			shadowPricesFileName,
			mpHelper);
    }
    
d4774 1
d4776 2
a4778 11
    // Operation Orders File: mandatory file
    // Prints execVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
    if (setOfParameters.getBool("printOperationOrdersFile") && (siteCustomization != "skipTheCrapola")) {
      std::string operationOrdersFileName =
	setOfParameters.getString("operationOrdersFileName");
      printOperationOrdersFile(theWitRun, nPeriods,
				    operationOrdersFileName,
				    mpHelper);
    }
d4780 6
d4787 5
d4793 6
d4800 6
a4805 7
    // Capacity Usage Volume File: optional file
    // (prints only when there is substitute  input data)
    if (setOfParameters.getBool("printCapacityUsageFile"))   {
      bool isItMrp = false;
      printCapUsageVolume(theWitRun,isItMrp); 
    }
    
d4807 3
a4809 14
    // Sub DB File
    // (prints only when there is substitute  input data)
    std::string subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.empty() && setOfParameters.getBool("printSubDbFile"))   {
      bool parentMustBeUserDefinedOperation = false;
      bool engineMustBeImplode = true;
      std::string subDbFileName = setOfParameters.getString("subDbFileName");
      printSubDbDumpFile(theWitRun, 
			 parentMustBeUserDefinedOperation,
			 engineMustBeImplode,
			 nPeriods, nOperations, opList,
			 subDbFileName,
			 mpHelper);
    }
d4811 19
d4831 2
a4832 13
    // Substitute Usage Volume File
    // (prints only when there is substitute  input data)
    if (setOfParameters.getBool("printSubUsageFile") && ! subBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = false;
      bool engineMustBeImplode = true;
      std::string subUsageFileName = setOfParameters.getString("subUsageFileName");
      printSubstituteUsageVolume(theWitRun, 
				 parentMustBeUserDefinedOperation,
				 engineMustBeImplode,
				 nPeriods, nOperations, opList,
				 subUsageFileName,
				 mpHelper);
    }
d4834 10
a4843 13
    // Operation Substitute Usage Volume File: 
    std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
    if (setOfParameters.getBool("printOpSubUsageFile") && ! opSubBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = true;
      bool engineMustBeImplode = true;
      std::string opSubUsageFileName = setOfParameters.getString("opSubUsageFileName");
      printSubstituteUsageVolume(theWitRun, 
				 parentMustBeUserDefinedOperation,
				 engineMustBeImplode,
				 nPeriods, nOperations, opList,
				 opSubUsageFileName,
				 mpHelper);
    }
d4845 7
d4853 2
d4856 1
a4856 6
    
    // -----------------------------------------
    // ----- Print Feature Ratio Stuff ---------
    // -----------------------------------------    
    std::string featureFileOutputFormat =
      setOfParameters.getString("featureFileOutputFormat");
d4858 21
a4878 16
    // see what format the user wants his feature outputs as
    int printDataAsPercentage = 0;
    if (featureFileOutputFormat == "percentage")
      printDataAsPercentage = 1;
    
    
    // Feasible Optional Feature Ratio File: mandatory file
    // (prints only when there is optional feature  input data)
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      std::string optionalFeatRatioFileName =
	setOfParameters.getString("optionalFeatRatioFileName");
      printStandAloneFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
					   optionalFeatRatioFileName,
					   theCal, mpHelper, printDataAsPercentage);
    }
d4880 1
a4880 13
    // Feasible Selective Feature/Building Block Ratio File: mandatory file
    // (prints only when there is BBratio input data)
    std::string topLevelToBBratioFile =
      setOfParameters.getString("topLevelToBBratioFile");
    if (! topLevelToBBratioFile.empty()) {
      std::string selFeatBBratioFileName =
	setOfParameters.getString("selFeatBBratioFileName");
#if 0
      // this is obsolete ... BUILDING_BLOCKS_VIA_MULTI_BOPS
      printFeatureAnalysisReportViaMultiRoute(theWitRun, nPeriods, nParts, partList,
					      selFeatBBratioFileName,
					      theCal, mpHelper, printDataAsPercentage);
#endif
d4882 10
a4891 26
      if (engine == "optimization")
	printFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
				   selFeatBBratioFileName,
				   theCal, mpHelper, printDataAsPercentage);
      else
	printFeatureAnalysisReportViaProportionalRoute(theWitRun, nPeriods, nOperations, opList,
						       selFeatBBratioFileName,
						       theCal, mpHelper, printDataAsPercentage);
    }


    // Part Database Dump File:  optional file
    if (setOfParameters.getBool("printPartDBFile"))  {
      std::string
	partDBFileName = setOfParameters.getString("partDBFileName");
      printPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				partList, partDBFileName);
    }

    // Capacity Database Dump File: optional file    
    if (setOfParameters.getBool("printCapacityDBFile"))  {
      std::string capacityDBFileName =
	setOfParameters.getString("capacityDBFileName");
      printCapacityDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				    partList, capacityDBFileName);
    }
d4893 5
d4899 3
a4901 6
    // Operation Database Dump File: optional file
    if (setOfParameters.getBool("printOperationDBFile"))  {
      std::string operationDBFileName =
	setOfParameters.getString("operationDBFileName");
      printOperationDataBaseDumpFile(theWitRun, mpHelper, nPeriods, 
				     operationDBFileName);
d4903 3
a4905 7

    // Operation ExecVol  Dump File: optional file
    if (setOfParameters.getBool("printOperationExecFile"))  {
      std::string operationExecFileName =
	setOfParameters.getString("operationExecFileName");
      printOperationExecDumpFile(theWitRun, mpHelper, nPeriods, 
				     operationExecFileName);
d4907 5
a4912 16
    
    // Debug Dump File (internal SCE parts)
    if (setOfParameters.getBool("printDebugFile"))  {
      std::string debugFileName =
	setOfParameters.getString("debugFileName");
      printDummyPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				     partList, debugFileName);
    }
    
    // Problem Statistics Summary File
    if (setOfParameters.getBool("printProblemStatsFile"))  {
      std::string problemStatisticsFileName =
	setOfParameters.getString("problemStatisticsFileName");
      printOverallProblemStatistics(theWitRun, mpHelper, nPeriods, nParts, partList,
				    problemStatisticsFileName);
    }
d4914 18
d4933 6
a4938 17
    // Objective Summary Report
    if (setOfParameters.getBool("printObjectiveSummaryFile"))  {
      std::string objectiveSummaryFileName =
	setOfParameters.getString("objectiveSummaryFileName");
      printOverallOptimizationValues(theWitRun, nPeriods, nParts, partList, engine,
				     objectiveSummaryFileName);
    }
    
    // Cleanup memory
    for ( i=0; i<nParts; i++) 
      witFree(partList[i]);
    witFree( partList );
    
    int o = 0; // Pulled out of the for below by RW2STL
    for (o=0; o<nOperations; o++) 
      witFree(opList[o]);
    witFree( opList );
d4940 8
a4947 1
}
a4948 11
void
LgFrScenarioForSce::runImplosion(
				 LgFrScenarioForSceSmartPointer scenSceSP
				 )
{
  // Set up the critical list data
  LgFrSceCritList & theCritList = sceCritList();
  WitRun * theWitRun = lastProblemSolved().witRun();
  LgFrCalendar * theCal = &calendar();
  LgFrMultiPlantHelper * mpHelper = &multiPlantHelper();
  const std::string & engine = getEngine();
a4949 4
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  bool doPegging = setOfParameters.getBool("doPegging");
   
  if (engine == "heuristic" || engine == "rollover" ) {
d4951 2
a4952 11
    LgFrSceHeurEngineMgr heurEngineMgr(
				       scenSceSP,
				       theWitRun, 
				       theCal,
				       mpHelper,
				       engine);
    
    heurEngineMgr.implode(theCritList);
    if (doPegging)
      printPIPData(theWitRun,0);
  }
d4954 17
a4970 1
  if (engine == "heuralloc" ) {
d4972 18
a4989 7
    std::string usageName("implosion");
    LgFrSceAllocationEngineMgr allocEngineMgr(
					 scenSceSP,
					 theWitRun, 
					 mpHelper,
					 usageName);
    allocEngineMgr.implode(theCritList);
d4991 2
a4992 18
    if (doPegging)
      printPIPData(theWitRun,0);
  }
     
   // ===================================
   // === Run the Optimization engine ===
   // ===================================
  if (engine == "optimization" ) {
    LgFrSceOptEngineMgr optEngineMgr(theWitRun,
				     theCal,
				     mpHelper,
				     scenSceSP);
     
     optEngineMgr.implode(theCritList);
     if (doPegging)
       printPIPData(theWitRun,0);
  }
}
a4993 9
void
LgFrScenarioForSce::machineFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);
  fssMgr.machineFss();
}
d4995 4
d5001 3
a5003 7
void
LgFrScenarioForSce::generalSetFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);
d5005 1
a5005 1
  fssMgr.generalSetFss();
d5007 6
a5012 1
}
d5014 10
d5025 14
a5038 9
void
LgFrScenarioForSce::singletonFss()
{
  LgFrSceFssMgr fssMgr(lastProblemSolved().witRun(), 
		       &calendar(),
		       &multiPlantHelper(),
		       this);
  fssMgr.singletonFss();    
}
d5040 18
a5057 3
void
LgFrScenarioForSce::printPIPData(WitRun * const theWitRun, int isItMrp)
{
d5059 12
d5072 9
a5080 3
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrCalendar & theCal = calendar();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
d5082 10
a5092 2
  int nonZeroOnly = 0;
  int alwaysPrint = 1;
d5094 9
d5104 4
a5107 3
  // supply pegging ...
  bool printSupplyPegFile = setOfParameters.getBool("printSupplyPegFile");
  bool printIndpSupplyPegFile = setOfParameters.getBool("printIndpSupplyPegFile");
d5109 5
a5113 2
  std::string supplyPegFileName = setOfParameters.getString("supplyPegFileName");
  std::string indpSupplyPegFileName = setOfParameters.getString("indpSupplyPegFileName");
d5115 5
a5119 8



  bool printDemandConsPegFile = setOfParameters.getBool("printDemandConsPegFile");
  bool printIndpDemandConsPegFile = setOfParameters.getBool("printIndpDemandConsPegFile");

  std::string demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
  std::string indpDemandConsPegFileName = setOfParameters.getString("indpDemandConsPegFileName");
d5121 3
a5123 5
  bool printInterplantPegFile = setOfParameters.getBool("printInterplantPegFile");
  bool printIndpInterplantPegFile = setOfParameters.getBool("printIndpInterplantPegFile");
  
  std::string interplantPegFileName = setOfParameters.getString("interplantPegFileName");
  std::string indpInterplantPegFileName = setOfParameters.getString("indpInterplantPegFileName");
a5124 2
  bool printExecVolPegFile = setOfParameters.getBool("printExecVolPegFile");
  bool printIndpExecVolPegFile = setOfParameters.getBool("printIndpExecVolPegFile");
a5125 2
  std::string execVolPegFileName = setOfParameters.getString("execVolPegFileName");
  std::string indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");
a5126 2
  bool printProdVolPegFile = setOfParameters.getBool("printProdVolPegFile");
  std::string prodVolPegFileName = setOfParameters.getString("prodVolPegFileName");
a5127 2
  bool printIndpProdVolPegFile = setOfParameters.getBool("printIndpProdVolPegFile");
  std::string indpProdVolPegFileName = setOfParameters.getString("indpProdVolPegFileName");
a5128 2
  bool printPfProdVolPegFile = setOfParameters.getBool("printPfProdVolPegFile");
  std::string pfProdVolPegFileName = setOfParameters.getString("pfProdVolPegFileName");
d5130 9
a5138 2
  bool printIndpPfProdVolPegFile = setOfParameters.getBool("printIndpPfProdVolPegFile");
  std::string indpPfProdVolPegFileName = setOfParameters.getString("indpPfProdVolPegFileName");
a5139 2
  bool printSideVolPegFile = setOfParameters.getBool("printSideVolPegFile");
  std::string sideVolPegFileName = setOfParameters.getString("sideVolPegFileName");
d5141 7
a5147 2
  bool printIndpSideVolPegFile = setOfParameters.getBool("printIndpSideVolPegFile");
  std::string indpSideVolPegFileName = setOfParameters.getString("indpSideVolPegFileName");
d5149 1
a5149 6
  if (isItMrp) {
    printSupplyPegFile = setOfParameters.getBool("printMrpSupplyPegFile");
    printIndpSupplyPegFile = setOfParameters.getBool("printMrpIndpSupplyPegFile");
    
    indpSupplyPegFileName = setOfParameters.getString("mrpIndpSupplyPegFileName");
    supplyPegFileName = setOfParameters.getString("mrpSupplyPegFileName");
d5151 7
a5157 5
    printDemandConsPegFile = setOfParameters.getBool("printMrpDemandConsPegFile");
    printIndpDemandConsPegFile = setOfParameters.getBool("printMrpIndpDemandConsPegFile");
    
    indpDemandConsPegFileName = setOfParameters.getString("mrpIndpDemandConsPegFileName");
    demandConsPegFileName = setOfParameters.getString("mrpDemandConsPegFileName");
a5158 2
    printInterplantPegFile = setOfParameters.getBool("printMrpInterplantPegFile");
    printIndpInterplantPegFile = setOfParameters.getBool("printMrpIndpInterplantPegFile");
d5160 7
a5166 5
    interplantPegFileName = setOfParameters.getString("mrpInterplantPegFileName");    
    indpInterplantPegFileName = setOfParameters.getString("mrpIndpInterplantPegFileName");

    printExecVolPegFile = setOfParameters.getBool("printMrpExecVolPegFile");
    printIndpExecVolPegFile = setOfParameters.getBool("printMrpIndpExecVolPegFile");
a5167 2
    execVolPegFileName = setOfParameters.getString("mrpExecVolPegFileName");    
    indpExecVolPegFileName = setOfParameters.getString("mrpIndpExecVolPegFileName");
d5169 11
a5179 2
    printProdVolPegFile = setOfParameters.getBool("printMrpProdVolPegFile");
    prodVolPegFileName = setOfParameters.getString("mrpProdVolPegFileName");
a5180 2
    printIndpProdVolPegFile = setOfParameters.getBool("printMrpIndpProdVolPegFile");
    indpProdVolPegFileName = setOfParameters.getString("mrpIndpProdVolPegFileName");
a5181 2
    printPfProdVolPegFile = setOfParameters.getBool("printMrpPfProdVolPegFile");
    pfProdVolPegFileName = setOfParameters.getString("mrpPfProdVolPegFileName");
a5182 2
    printIndpPfProdVolPegFile = setOfParameters.getBool("printMrpIndpPfProdVolPegFile");
    indpPfProdVolPegFileName = setOfParameters.getString("mrpIndpPfProdVolPegFileName");
a5183 2
    printSideVolPegFile = setOfParameters.getBool("printMrpSideVolPegFile");
    sideVolPegFileName = setOfParameters.getString("mrpSideVolPegFileName");
a5184 2
    printIndpSideVolPegFile = setOfParameters.getBool("printMrpIndpSideVolPegFile");
    indpSideVolPegFileName = setOfParameters.getString("mrpIndpSideVolPegFileName");
d5186 4
d5191 4
a5194 1
  }
a5195 14
  int nPeriods;
  char  *demandName, *fullWitGPDPartName;
  
  int goodRec = 0;
  
  std::cout << "Writing PIP (Pegging) information..." << std::endl;    
  
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);
  
  
  std::string plannerPart, geo;
d5198 11
a5208 4
  // --------------------------
  // SupplyConsPegFile 
  // --------------------------
  if (printSupplyPegFile)  {
d5210 4
a5213 10
    std::ofstream dPIPFile;
  
    // Now open the Demand Peg OUTPUT file
    dPIPFile.open(supplyPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Supply PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << supplyPegFileName);
    }
d5215 6
a5220 4
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
d5222 4
a5225 35
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);
d5227 1
a5227 7
	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }
	  
	  // Get this  PIPsupplyVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
d5229 7
a5235 11
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }
d5237 16
a5252 1
    dPIPFile.close();
d5254 1
a5254 6
  
  
  // --------------------------
  // indpDemandSupplyPegFile 
  // --------------------------
  if (printIndpSupplyPegFile)  {
d5256 9
a5264 10
    std::ofstream idPIPFile;
  
    // Now open the Independent Supply PIP OUTPUT file
    idPIPFile.open(indpSupplyPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Supply PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpSupplyPegFileName);
    }
a5265 11
    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }
a5266 4
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      
d5268 7
a5274 23
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);
d5276 1
a5276 22
	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  /*
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  */
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
d5278 1
a5278 6
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
a5279 2
    idPIPFile.close();
  }
d5281 9
d5291 1
d5293 3
d5298 3
a5301 4
  // --------------------------
  // DemandConsPIPFile 
  // --------------------------
  if (printDemandConsPegFile)  {
d5303 2
a5304 10
    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(demandConsPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Demand PIP Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << demandConsPegFileName);
    }
a5305 10
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }
d5307 3
a5309 6
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);
d5311 2
a5312 22
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);
a5313 4
	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }
a5314 2
	  
	  // Get this  PIPconsVol timeVec
a5315 5
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);
d5317 2
a5318 8
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }
d5320 2
a5321 2
    dPIPFile.close();
  }
d5323 2
d5326 2
a5327 15
  // --------------------------
  // indpDemandConsPIPFile 
  // --------------------------
  if (printIndpDemandConsPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpDemandConsPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Demand PIPging Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpDemandConsPegFileName);
    }
d5329 2
a5330 11
    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }
d5332 2
a5333 4
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      
d5335 2
a5336 23
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);
d5338 2
a5339 17
	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
d5341 2
a5342 2
    idPIPFile.close();
  }
d5344 2
d5347 2
a5348 4
  // --------------------------
  // ProdVolPIPFile  from ProdVol !!!
  // --------------------------
  if (printPfProdVolPegFile)  {
d5350 2
a5351 10
    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(pfProdVolPegFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("ProdVol (from ProdVol) PIP Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << pfProdVolPegFileName);
    }
d5353 3
a5355 4
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
d5357 2
a5358 5
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }
d5360 5
a5364 6
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);
d5366 2
a5367 22
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPProdVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);
d5369 2
a5370 4
	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }
d5372 2
a5373 2
	  
	  // Get this  PIPconsVol timeVec
d5375 2
a5376 5
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(part.name()), mpHelper.pdf(part.name()), 
					 PIPTV.data(), dPIPFile, nPeriods, nonZeroOnly);
d5378 2
a5379 8
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }
d5381 2
a5382 8
    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpProdVolPIPFile  (from ProdVol)
  // --------------------------
  if (printIndpPfProdVolPegFile)  {
d5384 2
a5385 10
    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpPfProdVolPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent PfProdVol PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpPfProdVolPegFileName);
    }
d5387 2
a5388 11
    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }
d5390 2
a5391 4
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      
d5393 2
a5394 23
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPProdVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);
a5395 19
	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
a5396 1
    idPIPFile.close();
d5399 16
a5414 1
  // ++++++++++++++++++
d5416 1
a5416 1
  // SideVolPIPFile
d5418 1
a5418 1
  if (printSideVolPegFile)  {
d5422 2
a5423 2
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(sideVolPegFileName.c_str(), std::ofstream::out);
d5425 1
a5425 1
      std::string fileErrorString("SideVol PIP  File");
d5428 1
a5428 1
			 << sideVolPegFileName);
d5462 2
a5463 2
	// Get const references to the  PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSideVolSched();
a5475 1

d5477 2
a5478 1
	  // Get this  PIPconsVol timeVec
a5479 2
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
a5482 1

d5497 1
a5497 1
  // indpSideVolPIPFile
d5499 1
a5499 1
  if (printIndpSideVolPegFile)  {
d5503 2
a5504 2
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpSideVolPegFileName.c_str());
d5506 1
a5506 1
      std::string fileErrorString("Independent SideVol PIP File");
d5509 1
a5509 1
			 << indpSideVolPegFileName);
d5544 1
a5544 1
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSideVolSched();
d5561 1
d5577 2
a5578 1
  // ++++++++++++++++++
d5583 1
a5583 1
  // ExecVolPIPFile  (diagnostic)
d5585 1
a5585 11
  if (printExecVolPegFile)  {
    std::ofstream evPIPFile;
  
    // Now open the ExecVol Demand PIP OUTPUT file
    evPIPFile.open(execVolPegFileName.c_str());
    if (evPIPFile.fail()) {
      std::string fileErrorString("ExecVol PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << execVolPegFileName);
    }
d5587 1
a5587 73
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & operation = PIPSched.part(cp);


	  // report ALL Operations
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the total Demand due to Focus: FSSReq
	  evPIPFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\",\""
		    << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(evPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    evPIPFile.close();
  }

  // ----------------------------------
  // ProdVolPIPFile  FROM EXEC VOL !!!!
  // ----------------------------------
  if (printProdVolPegFile)  {
    std::ofstream pvPIPFile;
d5589 4
a5592 4
    // Now open the ExecVol Demand PIP OUTPUT file
    pvPIPFile.open(prodVolPegFileName.c_str());
    if (pvPIPFile.fail()) {
      std::string fileErrorString("ProdVol PIPging File");
d5595 1
a5595 1
			 << prodVolPegFileName);
d5616 1
a5616 93
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	


	// TOMMY HERE
	// Loop over each operation
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  // get operation
	  const LgFrPart & operation = PIPSched.part(cp);
	  
	  
	  // only report on DEFAULT Operations  
	  if (! mpHelper.isPartNormal(theWitRun,
				      operation.name())) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  flatFileMgr_.writeGpdPegRecord(theCal, mpHelper, 
					 plannerPart, geo, mpHelper.partname(operation.name()), mpHelper.pdf(operation.name()), 
					 PIPTV.data(), pvPIPFile, nPeriods, nonZeroOnly);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    pvPIPFile.close();
  }






  // xxxxxxxxxxxxxx
  // --------------------------
  // indpProdVolPegFile
  // --------------------------
  if (printIndpProdVolPegFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent ProdVol PIP OUTPUT file
    idPIPFile.open(indpProdVolPegFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent ProdVol PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpProdVolPegFileName);
    }


    // stop here
    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
d5618 1
a5618 1
	demandId = dList[j];
d5622 1
a5622 1
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
d5629 2
a5631 4
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();


d5637 1
a5637 1
	  const LgFrPart & consumedPart = PIPSched.part(cp);
d5639 2
a5640 2
	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
d5643 1
d5646 1
d5649 4
a5652 4
	  flatFileMgr_.writeIndpPegRecord(theCal, mpHelper, 
					  mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
					  mpHelper.partname(consumedPart.name()), mpHelper.pdf(consumedPart.name()), 
					  PIPTV.data(), idPIPFile, nPeriods, nonZeroOnly);
d5655 2
d5662 1
a5662 1
    idPIPFile.close();
d5664 2
a5665 2


d5667 1
a5667 1
  // indpExecVolPIPFile (diagnostic)
d5669 1
a5669 1
  if (printIndpExecVolPegFile)  {
d5671 1
a5671 1
    std::ofstream idEvPIPFile;
d5673 4
a5676 4
    // Now open the Independent  Demand ExecVol  PIP OUTPUT file
    idEvPIPFile.open(indpExecVolPegFileName.c_str());
    if (idEvPIPFile.fail()) {
      std::string fileErrorString("Independent Demand ExecVol PIPging  File");
d5679 1
a5679 1
			 << indpExecVolPegFileName);
a5680 1
  
d5714 1
a5714 1
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
d5716 2
a5717 2
	// Loop over each operation
	int nOperations = PIPSched.size();
d5719 1
a5719 1
	for ( cp=0; cp<nOperations; cp++ ) {
d5721 1
a5721 1
	  const LgFrPart & operation = PIPSched.part(cp);
d5723 4
a5726 2

	  // report ALL Operations
d5728 1
a5728 1
	  // Get this  PIPExecVol timeVec
d5730 4
a5733 10
	  
	  //  write the PIP vector
	  idEvPIPFile << "\""
		      << mpHelper.partname(fullWitDemandedPart) << "\",\""
		      << mpHelper.pdf(fullWitDemandedPart) << "\","
		      << demandId << "\",\""
		      << mpHelper.partname(operation.name()) << "\",\""
		      << mpHelper.pdf(operation.name()) << "\",\""
		      << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(idEvPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5740 2
a5741 1
    idEvPIPFile.close();
d5746 1
a5746 1
  // InterplantPIPFile
d5748 1
a5748 1
  if (printInterplantPegFile)  {
d5750 1
a5750 1
    std::ofstream ipPIPFile;
d5752 4
a5755 4
    // Now open the Interplant Demand PIP OUTPUT file
    ipPIPFile.open(interplantPegFileName.c_str());
    if (ipPIPFile.fail()) {
      std::string fileErrorString("Interplant PIPging File");
d5758 1
a5758 1
			 << interplantPegFileName);
a5759 1
  
d5779 1
a5779 1
      int j = 0; 
d5792 2
a5793 3
	
	// Get const references to the interplant PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
d5799 1
d5802 2
a5803 3
	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, part.name(), pn1, customerPdf, pn2, supplierPdf)) {
d5806 1
d5808 2
a5809 1
	  // Get this  PIPExecVol timeVec
d5811 4
a5814 14
	  /*
	  ipPIPFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << pn1 << "\",\""
		    << customerPdf << "\",\""
		    << pn2 << "\",\""
		    << supplierPdf << "\"";
	  flatFileMgr_.writeCsvFloatVector(ipPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  */
	  flatFileMgr_.writeGpdInterplantPegRecord(theCal, mpHelper, 
						   plannerPart, geo, 
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), ipPIPFile, nPeriods, nonZeroOnly);
d5825 1
a5825 1
    ipPIPFile.close();
d5827 2
a5828 1

d5830 1
a5830 1
  // indpInterplantPIPFile
d5832 1
a5832 1
  if (printIndpInterplantPegFile)  {
d5834 1
a5834 1
    std::ofstream idIpPIPFile;
d5836 4
a5839 4
    // Now open the Independent Interplant Demand PIP OUTPUT file
    idIpPIPFile.open(indpInterplantPegFileName.c_str());
    if (idIpPIPFile.fail()) {
      std::string fileErrorString("Independent Interplant Demand PIPging  File");
d5842 1
a5842 1
			 << indpInterplantPegFileName);
a5843 1
  
d5877 1
a5877 1
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPInterplantVolSched();
d5880 1
a5880 1
	int nOperations = PIPSched.size();
d5882 3
a5884 2
	for ( cp=0; cp<nOperations; cp++ ) {
	  const LgFrPart & operation = PIPSched.part(cp);
d5886 2
a5887 3
	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, operation.name(), pn1, customerPdf, pn2, supplierPdf)) {
d5891 1
a5891 1
	  // Get this  PIPExecVol timeVec
d5893 6
a5898 8

	  flatFileMgr_.writeIndpInterplantPegRecord(theCal, mpHelper, 
						   mpHelper.partname(fullWitDemandedPart), mpHelper.pdf(fullWitDemandedPart), demandId,
						   pn1, customerPdf, pn2, supplierPdf,
						   PIPTV.data(), idIpPIPFile, nPeriods, nonZeroOnly);



a5904 80
    idIpPIPFile.close();
  }


  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++) {
    witFree(partList[i]);
  }
  witFree(partList);


}    




// ===============================
// ====== Capacity Usage Schedule ====
// NOW_FINISH_ME
// ===============================
void
LgFrScenarioForSce::printCapUsageVolume(WitRun * const theWitRun, bool isItMrp)
{
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();

  std::string  capacityUsageFileName = setOfParameters.getString("capacityUsageFileName");
  int goodRec = 0;

  if (isItMrp) {
    capacityUsageFileName = setOfParameters.getString("mrpCapacityUsageFileName");
  }


  int nPeriods;

  if (isItMrp) 
    std::cout << "... printing MRP capacity Usage data ..." << std::endl;    
  else
    std::cout << "... printing capacity Usage data ..." << std::endl;    

    
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  char * capName;


  std::ofstream cUsFile;
  
  // Now open the capUsage OUTPUT file
  cUsFile.open(capacityUsageFileName.c_str(), std::ofstream::out);
  if (cUsFile.fail()) {
    std::string fileErrorString("Capacity Usage File");
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << fileErrorString 
		       << capacityUsageFileName);
  }
  



  // Loop over parts to find capacity
  int i = 0;
  for(i=0; i<nParts; i++){
    capName = partList[i];

    if (! mpHelper.isPartNormalCapacity(theWitRun, capName))  {
      witFree(partList[i]);
      continue;
    }
    
    int nCbom;
    witGetPartNConsumingBomEntries(theWitRun, capName, &nCbom);
    int b,c;
    char * operation;
    for (c=0; c<nCbom; c++) {
      witGetPartConsumingBomEntry(theWitRun, capName, c, &operation, &b);
d5906 2
a5907 16
      float * execVol;
      float * consRate;
      //      float * yieldRate;
      int * impactPeriod;
      float falloutRate;
      witGetOperationExecVol ( theWitRun, operation,&execVol );
      //      witGetOperationYieldRate ( theWitRun, operation,&yieldRate );
      witGetBomEntryConsRate ( theWitRun, operation, b, &consRate );
      witGetBomEntryFalloutRate ( theWitRun, operation, b, &falloutRate );
      witGetBomEntryImpactPeriod ( theWitRun, operation, b, &impactPeriod );
      LgFrTimeVecFloat capUsageVol(nPeriods, 0.0);
      int execPeriod;
      for (execPeriod=0; execPeriod<nPeriods; execPeriod++) {
	int consPeriod = impactPeriod[execPeriod];
	if ( consPeriod == -1 ) 
	  continue;
d5909 5
a5913 2
	capUsageVol[consPeriod] += execVol[execPeriod] * consRate[execPeriod]/(1.0-falloutRate);
      }
d5915 9
a5923 13
      //  write the TimeVec data
      cUsFile << "\""
	      << mpHelper.partname(operation) << "\",\""
	      << mpHelper.partname(capName) << "\",\""
	      << mpHelper.pdf(capName) << "\"";
      flatFileMgr_.writeCsvFloatVector(cUsFile, nPeriods, capUsageVol.data(), 0, 15);
      goodRec++;
      
      witFree(execVol);
      witFree(consRate);
      witFree(impactPeriod);
      //      witFree(yieldRate);
      witFree(operation);
a5924 3
    witFree(partList[i]);
  }
  witFree(partList);
d5926 4
a5929 2
  cUsFile.close();
}
d5931 12
d5944 22
d5967 4
d5972 2
d5975 5
d5981 8
d5990 8
a5997 8
// ===============================
// ====== PIP  Utilitiies ====
// ===============================
void
LgFrScenarioForSce::loadPIPDataIntoAppData(WitRun * const theWitRun)
{
  int nPeriods;
  char  *partName, *demandName;
d5999 10
a6008 1
  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
d6010 6
a6015 1
  std::cout << "... collecting PIP information ..." << std::endl;    
d6017 3
a6019 29
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;

  bool PegSubUsageToPrimary = this->setOfParameters().getBool("PegSubUsageToPrimary");
  bool supplierPerspectiveInterplantPeg = this->setOfParameters().getBool("supplierPerspectiveInterplantPeg");

  // Loop over parts to get demands
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      // Now for some fancy trickery !!!
      // if the part is a special feature part, then we must map the consVol over to 
      //     the GPD appData
      int isDemandSpecial = 0;
      isDemandSpecial = mpHelper.isDemandSpecialPureOptionBuildDemand(theWitRun, partName, demandName, pp, geo);
      if (! isDemandSpecial) {
	isDemandSpecial = mpHelper.isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
a6020 1
 
d6022 4
a6025 2
      // get teh demandAppData, or create a new one if it doesn't exist.
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d6027 7
a6033 16
      // if the demand is a specialFeaturePart then get the gpd's appdata
      if (isDemandSpecial) {
	// get a witPartName for the GPD
	fullWitGPDPartName = mpHelper.geoPlannerDemandPartName(pp, geo);

	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
			   (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
			       (void *) demandAppDataPtr );
	}
      }
      else {
	witGetDemandAppData( theWitRun, partName, demandName,
d6036 2
a6037 4
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, partName, demandName,  
			       (void *) demandAppDataPtr );
d6039 11
a6049 36
      }

#ifdef DEBUG_DUMP_FOR_PEGGING
      
      if (isDemandSpecial) {
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "PIP supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
      }
      
      std::cout << "(before)PIPConsVolSched (" << partList[i] << "," << dList[j] << std::endl;
      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << "(before)PIPSupplyVolSched (" << partList[i] << "," << dList[j] << std::endl;
      demandAppDataPtr->PIPSupplyVolSched().print();

      std::cout << std::endl;

#endif

      // Get demands PIP consVol and directly store in appData
      ScePIP::getDemandConsVolPIP(theWitRun,
				  partList[i],
				  dList[j],
				  0,
				  nPeriods-1,
				  demandAppDataPtr->PIPConsVolSched(),
				  WitTRUE,
				  PegSubUsageToPrimary);

      // Get  PIP supplyVol and directly store in appData
      ScePIP::getSupplyVolPIP(theWitRun,
			      partList[i],
			      dList[j],
			      0,
			      nPeriods-1,
			      demandAppDataPtr->PIPSupplyVolSched());
d6051 12
a6062 7
      // Get demands PIP prodVol and directly store in appData
      ScePIP::getProdVolPIP(theWitRun,
			    partList[i],
			    dList[j],
			    0,
			    nPeriods-1,
			    demandAppDataPtr->PIPProdVolSched());
d6064 6
d6071 2
a6072 7
      // Get PIP sideVol  and directly store in appData
      ScePIP::getSideVolPIP(theWitRun,
			    partList[i],
			    dList[j],
			    0,
			    nPeriods-1,
			    demandAppDataPtr->PIPSideVolSched());
d6074 1
a6076 7
      // Get demands PIP  execVol and directly store in appData
      ScePIP::getDemandExecVolPIP(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->PIPExecVolSched());
d6078 13
a6090 20
      ScePIP::getDemandInterplantVolPIP(theWitRun,
					&mpHelper,
					partList[i],
					dList[j],
					0,
					nPeriods-1,
					demandAppDataPtr->PIPInterplantVolSched(),
					supplierPerspectiveInterplantPeg);



#ifdef DEBUG_DUMP_FOR_PEGGING
      std::cout << "ConsVolPIP(after) JP's Get" << std::endl;
      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << "SupplyVolPIP(after) JP's Get" << std::endl;
      demandAppDataPtr->PIPSupplyVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif

      witFree(dList[j]);
a6091 4
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);
d6093 10
a6102 1
}
d6104 6
d6111 23
d6136 21
a6156 5
LgFrMultiPlantHelper&
LgFrScenarioForSce::multiPlantHelper()
{
  return multiPlantHelper_;
}
d6158 1
a6158 24
LgFrSceCritList &
LgFrScenarioForSce::sceCritList()
{
  return critList_;
}


//  ---------------------------------------------------------------------
//  Print Part Component  Information
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printDummyPartDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Debug" 
		       << fileName);
d6161 14
a6174 1
   long numRecords = 0;
d6176 10
d6187 6
a6192 15
   float * supplyVol;
   float * cycleTime;
   witBoolean * execFlag;
   float * mrpConsVol;

   float * reqVol;
   float * mrpExcessVol;      
   float * mrpResidualVol;      

   float * excessVol;      
   float * residualVol;      
   float * stockVol;      
   float * scrapVol;      
   float * consVol;      
   float * prodVol;
d6194 17
a6210 4
   witAttr category;
   witBoolean operationExists;

   int i;
a6211 2
  int nonZeroOnly = 0;
  int alwaysPrint = 1;
d6213 28
a6240 6
   LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
   LgFrSceBaseExploder * myExploder = this->exploder();
   bool doImplode = setOfParameters.getBool("doImplode");
   
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
d6242 2
a6243 4
     std::string fullPartName(partList[i]);
     // this time, exclude the real parts
     if (mpHelper.isPartNormal(theWitRun, fullPartName))
       continue;
a6244 1
     witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
a6245 1
     witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVol);
a6246 2
     if (category == WitPRODUCT)
       witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);
a6247 3
     witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
     if (operationExists) 
       witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);
a6248 4
     myExploder->mrpConsVol(partList[i], &mrpConsVol);
     myExploder->reqVol(partList[i], &reqVol);
     myExploder->mrpExcessVol(partList[i], &mrpExcessVol);
     myExploder->mrpResidualVol(partList[i], &mrpResidualVol);
d6250 5
a6254 26
     if (doImplode) {
       witGetPartExcessVol(theWitRun, fullPartName.c_str(), &excessVol);
       witGetPartResidualVol(theWitRun, fullPartName.c_str(), &residualVol);
       if (category != WitCAPACITY) 
	 witGetPartStockVol(theWitRun, fullPartName.c_str(), &stockVol);
       witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);
       witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
       if (category == WitPRODUCT)
	 witGetPartProdVol(theWitRun, fullPartName.c_str(),  &prodVol);
     }
       
     // ==========================
     // PRINT everything down here
     // ==========================
     std::string pn(fullPartName);
     std::string pdf(mpHelper.pdf(fullPartName));
     
     numRecords += printDbDumpRec(pn, pdf, "supplyVol", supplyVol, outFile, nPeriods, nonZeroOnly);
     if (category == WitPRODUCT)
       numRecords += printDbDumpRec(pn, pdf, "cycleTime", cycleTime, outFile, nPeriods, nonZeroOnly);
     if (operationExists)
       numRecords += printDbDumpRecBool(pn, pdf, "execFlag", execFlag, outFile, nPeriods);
     numRecords += printDbDumpRec(pn, pdf, "mrpConsVol", mrpConsVol, outFile, nPeriods, alwaysPrint);
     numRecords += printDbDumpRec(pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);
     numRecords += printDbDumpRec(pn, pdf, "mrpExcessVol", mrpExcessVol, outFile, nPeriods, nonZeroOnly);
     numRecords += printDbDumpRec(pn, pdf, "mrpResidualVol", mrpResidualVol, outFile, nPeriods, nonZeroOnly);
d6256 10
a6265 10
     if (doImplode) {
       numRecords += printDbDumpRec(pn, pdf, "excessVol", excessVol, outFile, nPeriods, nonZeroOnly);
       numRecords += printDbDumpRec(pn, pdf, "residualVol", residualVol, outFile, nPeriods, nonZeroOnly);
       if (category != WitCAPACITY) 
	 numRecords += printDbDumpRec(pn, pdf, "stockVol", stockVol, outFile, nPeriods, nonZeroOnly);	 
       numRecords += printDbDumpRec(pn, pdf, "scrapVol", scrapVol, outFile, nPeriods, nonZeroOnly);	 
       numRecords += printDbDumpRec(pn, pdf, "consVol", consVol, outFile, nPeriods, nonZeroOnly);	 
       if (category == WitPRODUCT)
	 numRecords += printDbDumpRec(pn, pdf, "prodVol", prodVol, outFile, nPeriods, nonZeroOnly);	 
     }
a6266 18
     witFree(supplyVol);
     if (category == WitPRODUCT)
       witFree(cycleTime);
     if (operationExists)
       witFree(execFlag);
     witFree(reqVol);
     witFree(mrpExcessVol);
     witFree(mrpResidualVol);
     if (doImplode) {       
       witFree(excessVol);
       witFree(residualVol);
       if (category != WitCAPACITY)
	 witFree(stockVol);
       witFree(scrapVol);
       witFree(consVol);
       if (category == WitPRODUCT) 
	 witFree(prodVol);
     }
d6268 12
a6279 1
   }
d6281 4
a6284 3
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d6286 16
a6301 18
//  ---------------------------------------------------------------------
//  Print Part Component  Information         
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printPartDataBaseDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    const int nParts,           // Number of parts   
    char ** partList,           // List of part names
    std::string fileName)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Part Database Dump" 
		       << fileName);
  }
d6304 6
a6309 1
  LgFrCalendar theCal = this->calendar();
d6311 18
a6328 3
  long numRecords = 0;
  long numUniquePairs = 0;
  // we must check this against the number of records in the partDef file
d6330 2
a6332 2
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          
d6334 4
a6337 2
  bool doImplode =         setOfParameters.getBool("doImplode");
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d6339 11
a6349 2
  witAttr category;
  witBoolean operationExists;
d6351 11
a6361 1
  int i,t, p, b, npBops;
d6363 4
d6368 23
a6390 27
  //  - all the execVol stuff...
  float * prodVol      = new float[nPeriods];  
  float * mrpProdVol   = new float[nPeriods];  
  float * bldVol       = new float[nPeriods];  
  float * mrpBldVol    = new float[nPeriods];    
  float * userOpVol    = new float[nPeriods];
  float * mrpUserOpVol = new float[nPeriods];    
  float * intPlVol     = new float[nPeriods];
  float * mrpIntPlVol  = new float[nPeriods];   
  float * altVol       = new float[nPeriods];
  float * mrpAltVol    = new float[nPeriods];    
 
  float * deAggVol     = new float[nPeriods];
  float * mrpDeAggVol  = new float[nPeriods];    

  float * supplyVolSpecifiedByUser;
  float * witStockVol;
  float * cycleTime;
  float * yieldRate;
  witBoolean * execFlag;
  float * witExcessVol;
  float * witResidualVol;
  float * scrapVol;
  float * consVol;
  float * reqVol;
  float * witMrpExcessVol;      
  float * witMrpResidualVol;      
a6391 2
  LgFrTimeVecFloat excessVol((size_t) nPeriods, 0.0);
  LgFrTimeVecFloat residualVol((size_t) nPeriods, 0.0);
d6393 22
d6417 4
a6420 2
  int nDemands;
  char ** dList;
d6422 1
a6422 6
#ifdef ENABLE_NEGATIVE_DEMANDS
  LgFrTimeVecFloat negDemVol;
#endif

  int nonZeroOnly = 0;
  int alwaysPrint = 1;
d6424 8
a6431 4
  //   int alwaysPrintForECAonly = (siteCustomization == "eca" ? 1 : 0);
  int alwaysPrintForECAonly = (sce::compareStringsCaseIns( siteCustomization, "eca" ) ? 0 : 1);
  bool combineCapacityIntoPartDB = setOfParameters.getBool("combineCapacityIntoPartDB");

a6432 2
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
d6434 10
a6443 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d6445 6
a6450 4
    if (! combineCapacityIntoPartDB) {
      if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
	continue;
    }
d6452 22
a6473 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d6475 12
d6488 8
a6495 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
d6497 2
a6498 2
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d6500 4
a6503 2
    // get demands on the part.  These are needed for direct demands
    witGetPartDemands(theWitRun, fullPartName.c_str(), &nDemands, &dList);
d6505 9
a6513 5
#ifdef ENABLE_NEGATIVE_DEMANDS
    // Compute :=======> negDemVol
    int doesPartHaveNegativeDemands = mpHelper.doesPartHaveNegativeDemands(theWitRun, fullPartName);
    if (doesPartHaveNegativeDemands) {
      negDemVol = mpHelper.negDemVol(theWitRun, fullPartName);
d6515 1
a6515 1
#endif     
d6517 10
a6526 9

    // Compute :=======> supplyVol
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVolSpecifiedByUser);
#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat witSupplyVol((size_t) nPeriods, supplyVolSpecifiedByUser);
    // adjust the supplyVol by removing any dummy supply due to  negative demands 
    if (doesPartHaveNegativeDemands) {
      for (t=0; t<nPeriods; t++) {
	supplyVolSpecifiedByUser[t] -= negDemVol[t];
a6527 2
    }
#endif     
d6529 4
d6534 22
d6557 8
a6564 6
    // Compute :======> CycleTime
    if (category == WitPRODUCT) {
      // FINISH_ME: This si a temprorary stopgap for maintaining
      // backward compatability.  In 1.30/1.31, the (eca) user's only
      // way of finding out what were true PCF parts was via
      // cycleTime=-1.  This needs to be worked out, but is OK for now.
d6566 4
a6569 21
      // get the "real" cycleTime in any case
      witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);

#ifndef VARIABLE_PERIODS
      // don't do this for variable periods. 
      // 
      // if the part is a PCF, then use partAppData and
      // unConstrainedStartPeriod to set those periods to -1,
      // after that pick up the cycleTime vector for real
      // eventually, we need to get rid of cycleTime altogether
      // or use an appData for it.
      if (mpHelper.isPartPcf(theWitRun, fullPartName)) {
	LgFrScePartAppData * appDataPtr;
	witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
	assert(appDataPtr != 0);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
	  cycleTime[tt] = -1.0;
      }
#endif
    }
d6573 3
a6575 11
    // Compute :=======> mrpConsVol
    float * mrpConsVol;
    myExploder->mrpConsVol(fullPartName, &mrpConsVol);
    // add in direct demand vol
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      float * indepDemandVol;
      witGetDemandDemandVol(theWitRun, fullPartName.c_str(), dList[j], &indepDemandVol);
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
	mrpConsVol[tt] += indepDemandVol[tt];
d6577 1
a6577 1
      witFree(indepDemandVol);
d6579 3
a6581 5
    //    int matt = 0; // Pulled out of the for below by RW2STL
    //    for (matt=0; matt<nPeriods; matt++) {
    //      mrpConsVol[matt] -= mrpAltVol[matt];
    //    }
    
d6583 5
d6590 1
a6591 24
#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat witMrpConsVol((size_t) nPeriods, mrpConsVol);
    LgFrTimeVecFloat negDemMrpConsVol((size_t) nPeriods, 0.0);
    if (doesPartHaveNegativeDemands) {
      float rolledNegDemVol = 0.0;
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
	rolledNegDemVol += negDemVol[tt];
	if (mrpConsVol[tt] > rolledNegDemVol) {
	  mrpConsVol[tt] -= rolledNegDemVol;
	  negDemMrpConsVol[tt] += rolledNegDemVol;
	  rolledNegDemVol = 0.0;
	}
	else {
	  // Note: if mrpConsVol < 0 then there are negative usage rates
	  // these can realy screw up our calculation
	  if (mrpConsVol[tt] > 0) {
	    rolledNegDemVol -= mrpConsVol[tt];
	    negDemMrpConsVol[tt] += mrpConsVol[tt];
	    mrpConsVol[tt] = 0.0;
	  }
	}
      }
    }
a6592 3
      
    // Compute :======> reqVol
    myExploder->reqVol(partList[i], &reqVol);
a6593 3
    // Compute :======> execFlag
    if (operationExists) {
      witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);
d6595 11
a6605 3
      // Compute :======> yieldRate
      witGetOperationYieldRate(theWitRun, fullPartName.c_str(), &yieldRate);
    }
d6607 3
a6609 13
    // Now compute all the execVol types:
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpAltVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, altVol, deAggVol, userOpVol
    if (npBops > 0) {
      // first intialize the vectors to zero
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	prodVol[t] = 0.0;
	mrpProdVol[t] = 0.0;
	bldVol[t] = 0.0;
	mrpBldVol[t] = 0.0;
	altVol[t] = 0.0;
	mrpAltVol[t] = 0.0;
d6611 1
a6611 13
	if (nUserDefinedOps) {
	  userOpVol[t] = 0;
	  mrpUserOpVol[t] = 0;
	}
	if (nInterplantOps) {
	  intPlVol[t] = 0.0;
	  mrpIntPlVol[t] = 0.0;
	}
	if (nAggregationOps) {
	  deAggVol[t] = 0.0;
	  mrpDeAggVol[t] = 0.0;
	}
      }
d6613 1
a6613 24
      // loop through each of the bop entries and get the execVol once for each
      // bop entry (this is a bit inefficient, but too bad).
      for (p=0; p<npBops; p++) {
	bool foundOpCategory = false;          
	std::string cp1, pdf1, sp2, pdf2;
	int early, late;
	float  prodRate;
	char * witOperationName;
	float * tempExecVol;
	float * tempMrpExecVol;
	float * yieldRate;
	float * mrpYieldRate;        
	  
	witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
	std::string operationName(witOperationName);
	witGetBopEntryProdRate(theWitRun, witOperationName, b, &prodRate);
	witGetBopEntryEarliestPeriod(theWitRun, witOperationName, b, &early);
	witGetBopEntryLatestPeriod(theWitRun, witOperationName, b, &late);
	myExploder->mrpExecVol(witOperationName, &tempMrpExecVol);          
	if (doImplode) {
	  witGetOperationExecVol(theWitRun, witOperationName, &tempExecVol);
	}
	witGetOperationYieldRate(theWitRun, witOperationName, &yieldRate);
	witGetOperationYieldRate(myExploder->localWitRun(), witOperationName, &mrpYieldRate);        
d6615 4
a6618 29
	
	// Is it the default Operation
	if (operationName == fullPartName 
	    || mpHelper.isOperationForCapacityGeneration(theWitRun, operationName, cp1, pdf1)) {
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    if (doImplode) {
	      bldVol[t]     += yieldRate[t] * tempExecVol[t];
	    }
	    mrpBldVol[t]  += mrpYieldRate[t] * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
	  
	// is it an Interplant Operation ?
	if (! foundOpCategory
	    && nInterplantOps
	    && mpHelper.isOperationSpecialInterplant(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  LgFrTimeVecFloat newExecVol = this->interplantExecVol(operationName);
	  LgFrTimeVecFloat newMrpExecVol = this->interplantMrpExecVol(operationName);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {
	      intPlVol[t]    += prodRate * newExecVol[t];
	    }
	    mrpIntPlVol[t] += prodRate * newMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
d6620 5
a6624 12
	// is it an Alternate Operation ?
	if (! foundOpCategory
	    && mpHelper.isOperationSpecialAlternate(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {
	      altVol[t]    += prodRate * tempExecVol[t];
	    }
	    mrpAltVol[t] += prodRate * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
d6626 1
d6629 11
a6641 13
	// is it an Aggreration Operation ?
	if (! foundOpCategory
	    && nAggregationOps
	    && mpHelper.isOperationSpecialAggregation(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {	  
	      deAggVol[t]    += prodRate * yieldRate[t] * tempExecVol[t];
	    }
	    mrpDeAggVol[t] += prodRate * mrpYieldRate[t] * tempMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
d6643 4
a6646 20
	// is it a UserDefined Operation (it must be, at this point)
	if (! foundOpCategory
	    && nUserDefinedOps) {
	  int * impactPeriod;
	  int * mrpImpactPeriod;          
	  witGetBopEntryImpactPeriod(theWitRun, witOperationName, b, &impactPeriod);
	  witGetBopEntryImpactPeriod(myExploder->localWitRun(), witOperationName, b, &mrpImpactPeriod);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (impactPeriod[t] > -1)
	      if (doImplode) {	  
		userOpVol[impactPeriod[t]]       += yieldRate[t] * prodRate * tempExecVol[t];
	      }
	    if (mrpImpactPeriod[t] > -1)            
	      mrpUserOpVol[mrpImpactPeriod[t]] += mrpYieldRate[t] * prodRate * tempMrpExecVol[t];
	  }
	  witFree(impactPeriod);
	  witFree(mrpImpactPeriod);
	  foundOpCategory = true;
	}
d6648 11
a6658 6
	// Now assert that the operation resolved into exactly one of the types!!
	if (! foundOpCategory) {
	  std::cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<std::endl;
	}
	assert(foundOpCategory);
d6660 16
a6675 9
	// clean-up the memory for this bop
	witFree(witOperationName);
	if (doImplode) {	
	  witFree(tempExecVol);
	}
	witFree(tempMrpExecVol);
	witFree(yieldRate);
	witFree(mrpYieldRate);        
      }
d6677 1
a6677 23
      for (t=0; t<nPeriods; t++) {
	if (doImplode) {	  
	  prodVol[t] = bldVol[t];
	}
	mrpProdVol[t] = mrpBldVol[t];
	if (nUserDefinedOps) {
	  mrpProdVol[t] += mrpUserOpVol[t];
	  if (doImplode) {	  
	    prodVol[t] += userOpVol[t];
	  }
	}
	if (nInterplantOps) {
	  mrpProdVol[t] += mrpIntPlVol[t];
	  if (doImplode) {	  
	    prodVol[t] += intPlVol[t];
	  }
	}
	if (nAggregationOps) {
	  mrpProdVol[t] += mrpDeAggVol[t];
	  if (doImplode) {	  
	    prodVol[t] += deAggVol[t];
	  }
	}
a6678 5
    }
    
     
    LgFrTimeVecFloat stockVol((size_t) nPeriods, 0.0);
    if (doImplode) {
d6680 5
a6685 2
      // Compute :======> scrapVol
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);
d6687 1
a6687 17
      // Compute :======> consVol
      // FINISH_ME: temporary fix we always print consvol
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
      // add in direct demand vol
      for (j=0; j<nDemands; j++) {
	float * indepShipVol;
	witGetDemandShipVol(theWitRun, fullPartName.c_str(), dList[j], &indepShipVol);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
	  consVol[tt] += indepShipVol[tt];
	}
	witFree(indepShipVol);
      }
      int att = 0; // Pulled out of the for below by RW2STL
      for (att=0; att<nPeriods; att++) {
	consVol[att] -= altVol[att];
      }
d6689 9
d6699 3
a6701 25
#ifdef ENABLE_NEGATIVE_DEMANDS
      LgFrTimeVecFloat witConsVol((size_t) nPeriods, consVol);
      LgFrTimeVecFloat negDemConsVol((size_t) nPeriods, 0.0);
      if (doesPartHaveNegativeDemands) {
	float rolledNegDemVol = 0.0;
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
	  rolledNegDemVol += negDemVol[tt];
	  if (consVol[tt] > rolledNegDemVol) {
	    consVol[tt] -= rolledNegDemVol;
	    negDemConsVol[tt] += rolledNegDemVol;
	    rolledNegDemVol = 0.0;
	  }
	  else {
	    // Note: if consVol < 0 then there are negative usage rates
	    // these can realy screw up our calculation
	    if (consVol[tt] > 0) {
	      rolledNegDemVol -= consVol[tt];
	      negDemConsVol[tt] += consVol[tt];
	      consVol[tt] = 0.0;
	    }
	  }
	}
      }
#endif
a6704 10
      // Compute :======> StockVol, ExcessVol, ResidualVol
      if (category == WitCAPACITY) {
	witStockVol = new float[nPeriods];
	int t=0;
	for (t=0; t<nPeriods; t++)
	  witStockVol[t] = 0.0;
      }
      else {
	witGetPartStockVol(theWitRun, fullPartName.c_str(), &witStockVol);
      }
a6705 30
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witExcessVol);
      witGetPartResidualVol(theWitRun, fullPartName.c_str(), &witResidualVol);
      int ttt = 0; // Pulled out of the for below by RW2STL
      for (ttt=0; ttt<nPeriods; ttt++) {
	if (category != WitCAPACITY) {
	  stockVol[ttt] = witStockVol[ttt];
	}
	excessVol[ttt] = witExcessVol[ttt];
	residualVol[ttt] = witResidualVol[ttt];
      }
#ifdef ENABLE_NEGATIVE_DEMANDS
      LgFrTimeVecFloat negDemandStockVol((size_t) nPeriods, 0.0);
      if (doesPartHaveNegativeDemands) {
	// strategy: 
	// 1) compute witStockVol (ie, wrt the witRun including dummy supply)
	// 2) compute mrpNegDemandStockVol.  This is an abstract sort of thing that
	//              represents the amount of stockVol that is due to negDemand.
	//              its computed from negDemVol and negDemConsVol with a sort
	//              or material balance equation
	// 3) compute stockVol (ie, stockVol if you remove dummy supply)
	// 4) compute residualVol.  We have to manually calculate this.
	// 5) compute excessVol by truncating mrpResidualVol at the supplyVol level
      
	// 1) compute witStockVol 
	//     ....  We already have this from wit ....
	// 2) compute negDemandStockVol.  
	negDemandStockVol[0]  = negDemVol[0] - negDemConsVol[0];
	for (t=1; t<nPeriods; t++) {
	  negDemandStockVol[t] = negDemandStockVol[t-1] + negDemVol[t] - negDemConsVol[t];
	}
a6706 3
	// 3) compute stockVol
	for (t=0; t<nPeriods; t++) 
	  stockVol[t] = witStockVol[t] - negDemandStockVol[t];
d6708 8
a6715 31
	// 4) compute residualVol.  
	// the amount of excess can be at most the ending stock
	float potentialToExcess = stockVol[nPeriods-1];
	// walk backwards in time and look for an increasing stockVol from 
	// period t-1 to 1
	float stockIncrementThisPeriod;
	for (t=nPeriods-1; t>0; t--) {
	  stockIncrementThisPeriod = stockVol[t] - stockVol[t-1];
	  if (stockIncrementThisPeriod > 0.0) {
	    if (stockIncrementThisPeriod > potentialToExcess) {
	      residualVol[t] = potentialToExcess;
	      potentialToExcess = 0.0;
	    }
	    else {
	      residualVol[t] = stockIncrementThisPeriod;
	      potentialToExcess -= stockIncrementThisPeriod;
	    }
	  }
	}
	// now check period 0
	stockIncrementThisPeriod = stockVol[0];
	if (stockIncrementThisPeriod > 0.0) {
	  if (stockIncrementThisPeriod > potentialToExcess) {
	    residualVol[0] = potentialToExcess;
	    potentialToExcess = 0.0;
	  }
	  else {
	    residualVol[0] = stockIncrementThisPeriod;
	    potentialToExcess -= stockIncrementThisPeriod;
	  }
	}
d6717 1
d6719 6
a6724 8
	// 5) compute excessVol by truncating residualVol at the supplyVol level
	for (t=0; t<nPeriods; t++) {
	  if (residualVol[t] > supplyVolSpecifiedByUser[t])
	    excessVol[t] = supplyVolSpecifiedByUser[t];
	  else
	    excessVol[t] = residualVol[t];
      }
    }
d6726 2
d6729 2
a6730 2
#endif
  
d6732 10
d6743 7
a6749 27
    }

    // Compute :======> mrpExcessVol
    myExploder->mrpExcessVol(partList[i], &witMrpExcessVol);
    myExploder->mrpResidualVol(partList[i], &witMrpResidualVol);
    LgFrTimeVecFloat mrpExcessVol((size_t) nPeriods, witMrpExcessVol);
    LgFrTimeVecFloat mrpResidualVol((size_t) nPeriods, witMrpResidualVol);
#ifdef ENABLE_NEGATIVE_DEMANDS
    LgFrTimeVecFloat mrpNegDemandStockVol((size_t) nPeriods, 0.0);
    LgFrTimeVecFloat witMrpStockVol((size_t) nPeriods, 0.0);
    LgFrTimeVecFloat mrpStockVol(witMrpStockVol);
    if (doesPartHaveNegativeDemands) {
      // strategy: 
      // 1) compute witMrpStockVol (ie, wrt the witRun including dummy supply)
      // 2) compute mrpNegDemandStockVol.  This is an abstract sort of thing that
      //              represents the amount of stockVol that is due to negDemand.
      //              its computed from negDemVol and negDemMrpConsVol with a sort
      //              or material balance equation
      // 3) compute mrpStockVol (ie, stockVol if you remove dummy supply)
      // 4) compute mrpResidualVol.  We have to manually calculate this.
      // 5) compute mrpExcessVol by truncating mrpResidualVol at the supplyVol level
      
      // 1) compute witMrpStockVol 
      witMrpStockVol[0] = witSupplyVol[0] + mrpProdVol[0] - witMrpConsVol[0];
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=1; t<nPeriods; t++) {
	witMrpStockVol[t] = witMrpStockVol[t-1] + witSupplyVol[t] + mrpProdVol[t] - witMrpConsVol[t];
d6751 1
d6753 2
a6754 5
      // 2) compute mrpNegDemandStockVol.  
      mrpNegDemandStockVol[0]  = negDemVol[0] - negDemMrpConsVol[0];
      for (t=1; t<nPeriods; t++) {
	mrpNegDemandStockVol[t] = mrpNegDemandStockVol[t-1] + negDemVol[t] - negDemMrpConsVol[t];
      }
d6756 4
a6759 2
      // 3) compute mrpStockVol
      mrpStockVol = witMrpStockVol - mrpNegDemandStockVol;
d6761 7
a6767 17
      // 4) compute mrpResidualVol.  
      // the amount of excess can be at most the ending stock
      float potentialToExcess = mrpStockVol[nPeriods-1];
      // walk backwards in time and look for an increasing stockVol from 
      // period t-1 to 1
      float stockIncrementThisPeriod;
      for (t=nPeriods-1; t>0; t--) {
	stockIncrementThisPeriod = mrpStockVol[t] - mrpStockVol[t-1];
	if (stockIncrementThisPeriod > 0.0) {
	  if (stockIncrementThisPeriod > potentialToExcess) {
	    mrpResidualVol[t] = potentialToExcess;
	    potentialToExcess = 0.0;
	  }
	  else {
	    mrpResidualVol[t] = stockIncrementThisPeriod;
	    potentialToExcess -= stockIncrementThisPeriod;
	  }
d6770 8
a6777 10
      // now check period 0
      stockIncrementThisPeriod = mrpStockVol[0];
      if (stockIncrementThisPeriod > 0.0) {
	if (stockIncrementThisPeriod > potentialToExcess) {
	  mrpResidualVol[0] = potentialToExcess;
	  potentialToExcess = 0.0;
	}
	else {
	  mrpResidualVol[0] = stockIncrementThisPeriod;
	  potentialToExcess -= stockIncrementThisPeriod;
d6781 6
a6786 7

      // 5) compute mrpExcessVol by truncating mrpResidualVol at the supplyVol level
      for (t=0; t<nPeriods; t++) {
	if (mrpResidualVol[t] > supplyVolSpecifiedByUser[t])
	  mrpExcessVol[t] = supplyVolSpecifiedByUser[t];
	else
	  mrpExcessVol[t] = mrpResidualVol[t];
d6788 5
a6792 2
    }
#endif
d6794 1
d6796 1
d6798 9
a6806 6
    // Compute :======> mrpRequirements
    LgFrTimeVecFloat mrpRequirementsVol((size_t) nPeriods, reqVol);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      mrpRequirementsVol[t] -= mrpExcessVol[t];
    }
d6808 7
d6816 7
a6822 5
    // ==========================
    // PRINT everything down here
    // ==========================
    std::string pn(mpHelper.partname(fullPartName));
    std::string pdf(mpHelper.pdf(fullPartName));
d6825 7
a6831 8
#ifdef ENABLE_NEGATIVE_DEMANDS
#if 0
    // for debug use only !!!
    if (doesPartHaveNegativeDemands) {
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpNegDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witMrpExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);
a6832 5
      //      printDbDumpRec(pn, pdf, "negDemConsVol", negDemConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "witExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);
a6833 3
    }
#endif
#endif
d6835 7
d6843 8
a6850 14
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "supplyVol", supplyVolSpecifiedByUser, outFile, nPeriods, alwaysPrintForECAonly);
#ifdef ENABLE_NEGATIVE_DEMANDS
    if (doesPartHaveNegativeDemands) 
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemVol", negDemVol.data(), outFile, nPeriods, alwaysPrint);
#endif     
    if (category == WitPRODUCT) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "cycleTime", cycleTime, outFile, nPeriods, nonZeroOnly);
    }
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpConsVol", mrpConsVol, outFile, nPeriods, nonZeroOnly);
#ifdef ENABLE_NEGATIVE_DEMANDS
    if (doesPartHaveNegativeDemands) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "negDemMrpConsVol", negDemMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
    }
#endif     
a6851 5
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpExcessVol", mrpExcessVol.data(), outFile, nPeriods, nonZeroOnly);
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpResidualVol", mrpResidualVol.data(), outFile, nPeriods, nonZeroOnly);
    if (category != WitCAPACITY) 
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpStockVol", mrpStockVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
a6852 1
    numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpRequirements", mrpRequirementsVol.data(), outFile, nPeriods, nonZeroOnly);
d6854 7
a6860 62
    if (operationExists) {
      //      numRecords += flatFileMgr_.writeDbDumpRecordBool(theCal, pn, pdf, "execFlag", execFlag, outFile, nPeriods);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "yield", yieldRate, outFile, nPeriods, alwaysPrint);
    }

    // Now print all the execVol types:
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, deAggVol, userOpVol
    if (npBops > 0) {
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpProdVol", mrpProdVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpBldVol", mrpBldVol, outFile, nPeriods, nonZeroOnly);
      if (nInterplantOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpIntPlVol", mrpIntPlVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpAltVol", mrpAltVol, outFile, nPeriods, nonZeroOnly);
      if (nAggregationOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpDeAggVol", mrpDeAggVol, outFile, nPeriods, nonZeroOnly);
      if (nUserDefinedOps) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpUserOpVol", mrpUserOpVol, outFile, nPeriods, nonZeroOnly);

      if (doImplode) {        
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "prodVol", prodVol, outFile, nPeriods, nonZeroOnly);
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "bldVol", bldVol, outFile, nPeriods, nonZeroOnly);
	if (nInterplantOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "intPlVol", intPlVol, outFile, nPeriods, nonZeroOnly);
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "altVol", altVol, outFile, nPeriods, nonZeroOnly);
	if (nAggregationOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "deAggVol", deAggVol, outFile, nPeriods, nonZeroOnly);
	if (nUserDefinedOps) 
	  numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "userOpVol", userOpVol, outFile, nPeriods, nonZeroOnly);
      }
    }

    if (doImplode) {        
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "excessVol", excessVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "residualVol", residualVol.data(), outFile, nPeriods, nonZeroOnly);
      if (category != WitCAPACITY) 
	numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "stockVol", stockVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "scrapVol", scrapVol, outFile, nPeriods, nonZeroOnly);
      numRecords += flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "consVol", consVol, outFile, nPeriods, alwaysPrint);
    }


    if (category == WitPRODUCT)
      witFree(cycleTime);
    witFree(reqVol);
    witFree(witMrpExcessVol);
    witFree(witMrpResidualVol);
    witFree(mrpConsVol);
    if (operationExists) {
      witFree(execFlag);
      witFree(yieldRate);
    }
    if (doImplode) {        
      witFree(witExcessVol);
      witFree(witResidualVol);
      if (category == WitCAPACITY) 
	delete [] witStockVol;
      else
	witFree(witStockVol);
      witFree(scrapVol);
      witFree(consVol);
    }
a6861 3

    // free up the direct demands 
    for (j=0; j<nDemands; j++) {
d6865 1
a6865 3

    witFree(supplyVolSpecifiedByUser);
    numUniquePairs++;
d6867 1
a6867 22
     


  delete [] prodVol;
  delete [] mrpProdVol;
  delete [] mrpBldVol;
  delete [] bldVol;  
  delete [] userOpVol;
  delete [] mrpUserOpVol; 
  delete [] intPlVol;
  delete [] mrpIntPlVol;
  delete [] altVol;
  delete [] mrpAltVol;
  delete [] deAggVol;
  delete [] mrpDeAggVol;
  
    
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numUniquePairs);
}


a6868 22

// prints a record of a DB Dump file
// returns 1 if printed, 0 if not
int
LgFrScenarioForSce::printDbDumpRec(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const float *  floatVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods, 
    int printIfVectorIsAllZero)
{
    if ((printIfVectorIsAllZero) || (this->flatFileMgr_.isFloatVecNonZero(floatVec, nPeriods))) {
      outFile << "\"" << pn << "\",\""
	      << pdf << "\",";
      outFile << "\"" << vecID << "\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, floatVec, 0, 15);
      return 1;
    }
    
    return 0;
d6871 5
a6875 10
// prints a (boolean) record of a DB Dump file
// returns 1 
int
LgFrScenarioForSce::printDbDumpRecBool(
    std::string & pn, 
    std::string & pdf, 
    const char * vecID,
    const witBoolean *  boolVec,
    std::ofstream & outFile,   // output stream (already opened)
    int nPeriods)
d6877 1
a6877 5
  outFile << "\"" << pn << "\",\""
	  << pdf << "\",";
  outFile << "\"" << vecID << "\"";
  flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, boolVec);
  return 1;
d6880 2
a6881 8

// compute an adjusted excessVol due to negative demands (works for mrp or implosion)
LgFrTimeVecFloat 
LgFrScenarioForSce::excessVolAdjustedForNegativeDemands(
    float * witExcessVol,
    float * supplyVol,
    LgFrTimeVecFloat & negDemVol,
    int nPeriods)
d6883 1
a6883 5
 LgFrTimeVecFloat adjustedExcessVol((size_t) nPeriods, witExcessVol);

 // ok now do something
 return adjustedExcessVol;
 
a6886 1

d6888 1
a6888 1
//  Print Operation Dump File
d6891 1
a6891 1
LgFrScenarioForSce::printOperationDataBaseDumpFile(
d6895 2
a6898 1

d6902 1
a6902 1
		       << "Operation Database Dump" 
d6906 2
d6909 19
d6929 1
a6929 1
  float * witVector;
d6931 2
a6932 3
  int nOps;
  char ** opList;
  witGetOperations(theWitRun, &nOps, &opList);
d6934 6
a6939 4
  int o;
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  LgFrSceBaseExploder * myExploder = this->exploder();          
d6941 4
a6944 1
  bool doImplode = setOfParameters.getBool("doImplode");
d6946 1
d6948 1
a6948 3
  
  // Loop once for each operation
  for ( o=0; o<nOps; o++ ) {
d6950 2
a6951 4
    std::string operation(opList[o]);
    std::string op, p;
    if (! mpHelper.isOperationNormal(theWitRun, operation, p, op))
      continue;
d6953 3
a6955 3
    // this file does not report on default-operations!!  Only the userDefined ones.
    if (mpHelper.isPartNormal(theWitRun, operation))
      continue;
d6957 4
a6960 4
    
    // ----------------------------
    // INPUT type of parameters     
    // ----------------------------
d6962 26
a6987 9
    // execFlag
    witBoolean * witBoolVec;
    witGetOperationExecutable(theWitRun, operation.c_str(), &witBoolVec);
    outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	    << mpHelper.pdf(operation) << "\",";
    outFile << "\"execFlag\"";
    flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, witBoolVec);
    witFree(witBoolVec);
    numRecords++;
d6989 12
a7000 12
    // yieldRate
    witGetOperationYieldRate(theWitRun, operation.c_str(), &witVector);
    outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	    << mpHelper.pdf(operation) << "\",";
    outFile << "\"yield\"";
    flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
    witFree(witVector);
    numRecords++;
     
    // ----------------------
    // MRP type of parameters     
    // ----------------------
d7002 18
a7019 10
    // mrpExecVol
    myExploder->mrpExecVol(operation, &witVector);
    if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      outFile << "\"" << mpHelper.operationName(operation) << "\",\""
	      << mpHelper.pdf(operation) << "\",";
      outFile << "\"mrpExecVol\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
      numRecords++;
    }
    witFree(witVector);
d7021 1
a7021 15
       
    // ----------------------------
    // IMPLOSION type of parameters     
    // ----------------------------
    if (doImplode) {
      // execVol
      witGetOperationExecVol(theWitRun, operation.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	outFile << "\"" << mpHelper.operationName(operation) << "\",\""
		<< mpHelper.pdf(operation) << "\",";
	outFile << "\"execVol\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
	numRecords++;
      }
      witFree(witVector);
d7023 3
a7025 2
    }
     
d7027 17
a7044 2
 
  outFile.close();
a7045 3
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);
d7047 17
a7063 2
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d7066 14
a7079 10
//  ---------------------------------------------------------------------
//  Print Operation Dump File
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOperationExecDumpFile(
    WitRun * const theWitRun,   // WIT environment
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{
d7081 12
a7092 6
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Operation Exec Dump" 
		       << fileName);
  }
d7094 2
a7095 1
  long numRecords = 0;
a7096 1
  float * witVector;
a7097 3
  int nOps;
  char ** opList;
  witGetOperations(theWitRun, &nOps, &opList);
d7099 2
a7100 3
  int o;
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          
d7102 3
a7104 1
  bool doImplode = setOfParameters.getBool("doImplode");
d7106 2
d7109 3
a7111 2
  // Loop once for each operation
  for ( o=0; o<nOps; o++ ) {
d7113 3
a7115 2
    std::string operation(opList[o]);
    std::string op, p;
d7117 3
a7119 8
    // execFlag
    witBoolean * witBoolVec;
    witGetOperationExecutable(theWitRun, opList[o], &witBoolVec);
    outFile << "\"" << opList[o]<< "\",\",";
    outFile << "\"execFlag\"";
    flatFileMgr_.writeCsvBoolVector(outFile, nPeriods, witBoolVec);
    witFree(witBoolVec);
    numRecords++;
d7121 3
a7123 19
    // yieldRate
    witGetOperationYieldRate(theWitRun, opList[o], &witVector);
    outFile << "\"" << opList[o]<< "\",\",";
    outFile << "\"yieldRate\"";
    flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
    witFree(witVector);
    numRecords++;
     
    // ----------------------
    // MRP type of parameters     
    // ----------------------

    // mrpExecVol
    myExploder->mrpExecVol(operation, &witVector);
    if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      outFile << "\"" << opList[o]<< "\",\",";
      outFile << "\"mrpExecVol\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
      numRecords++;
a7124 1
    witFree(witVector);
d7126 1
a7126 14
       
    // ----------------------------
    // IMPLOSION type of parameters     
    // ----------------------------
    if (doImplode) {
      // execVol
      witGetOperationExecVol(theWitRun, operation.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	outFile << "\"" << opList[o]<< "\",\",";
	outFile << "\"execVol\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
	numRecords++;
      }
      witFree(witVector);
a7127 2
    }
     
d7129 5
a7133 3
  }
 
  outFile.close();
d7135 2
a7136 3
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);
d7138 2
a7139 2
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d7141 7
d7150 11
d7164 6
d7171 2
d7174 18
a7191 21
//  ---------------------------------------------------------------------
//  Print MRP Supply Orders File
//  ---------------------------------------------------------------------
//  PUD 14's are EMLS Planned Order (supply) transactions (ie, MRP orders for supply).
//  The key thing is that the supply shows customer PDF and supplier PDF.
//  If th esupply is created by "build in-house", then the customer and supplier PDF
//  is the same.
//
//  Codes are:
//  "A" = interplant
//  "B" = bin
//  "F" = build in-house
//  "O" = user-defined Operation
//  "D" = de-aggregation
//  "E" = External supply (ie, supplyVol)
void 
LgFrScenarioForSce::printMrpSupplyOrdersFile(
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{
a7192 6
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "MRP Supply Orders" 
		       << fileName);
  }
d7195 19
a7213 1
  long numRecords = 0;
a7214 1
  float * supplyOrderQty = new float [nPeriods];  
d7218 28
a7245 2
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          
d7247 3
a7249 1
  WitRun *  exploderWitRun = myExploder->localWitRun();
d7251 3
a7253 8
  int nOps;
  char ** opList;
  witGetOperations(exploderWitRun, &nOps, &opList);
  
  
  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {
d7255 13
a7267 4
    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2;
    std::string PUD14SourceCode;
    std::string supplierPdf, customerPdf, producedPart;
d7269 13
d7283 24
d7308 29
a7336 11
    // IF the operation is normal, then its either a  "F" source (ie, build in-house)
    //                                     OR a user-defined operation
    if (mpHelper.isOperationNormal(exploderWitRun, fullWitOperation, p, op)) {
      supplierPdf = p;
      customerPdf = p;      
      // if the part exists, then the operation is a build-inhouse
      if (mpHelper.isPartNormal(exploderWitRun, fullWitOperation)) 
	PUD14SourceCode = "F";
      else 
	PUD14SourceCode = "O";
    }
d7338 12
a7349 6
    else if (mpHelper.isOperationSpecialInterplant(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      supplierPdf = pdf2;
      customerPdf = pdf1;      
      PUD14SourceCode = "A";
    }
a7350 5
    else if (mpHelper.isOperationSpecialAggregation(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      supplierPdf = pdf2;
      customerPdf = pdf1;      
      PUD14SourceCode = "D";
    }
a7351 2
    else
      continue;
a7352 2
    // regardless of what this thing is, compute how much supply it created for the
    // Produced part
a7353 31
    int nBops;
    witGetOperationNBopEntries(exploderWitRun, fullWitOperation.c_str(), &nBops);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBops; b++) {
      int * impactPeriod;
      float * mrpExecVol;
      float prodRate;
      float * yieldRate;
      int early, late;
      char * producedPart;
      
      
      witGetBopEntryProducedPart(exploderWitRun, fullWitOperation.c_str(), b, &producedPart);
      // if its an operation that produces capacity, then skip it.
      witAttr category;      
      witGetPartCategory(exploderWitRun, producedPart, &category);
      if (category == WitCAPACITY) {
	witFree(producedPart);
	continue;
      }
      witGetBopEntryProdRate(exploderWitRun, fullWitOperation.c_str(), b, &prodRate);
      witGetBopEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &early);
      witGetBopEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &late);
      myExploder->mrpExecVol(fullWitOperation, &mrpExecVol);          
      // note: do a switcheroo to get the real interplant execVol a'la jumper arcs
      if (PUD14SourceCode == "A") {
	LgFrTimeVecFloat realMrpExecVol = this->interplantMrpExecVol(fullWitOperation);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  mrpExecVol[t] = realMrpExecVol[t];
      }
d7355 13
d7369 20
a7388 1
      witGetOperationYieldRate(exploderWitRun, fullWitOperation.c_str(), &yieldRate);
d7390 6
a7395 1
      witGetBopEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), b, &impactPeriod);
d7397 4
a7400 10
      // first initialize the vector and the total to Zero
      float recordTotal = 0.0;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	supplyOrderQty[t] = 0.0;

      for (t=early; t<=late; t++) {
	if (impactPeriod[t] > -1) {
	  supplyOrderQty[impactPeriod[t]] = yieldRate[t] * prodRate * mrpExecVol[t];
	  recordTotal += supplyOrderQty[impactPeriod[t]];
d7402 3
d7407 23
a7429 12
      witFree(mrpExecVol);
      witFree(yieldRate);
      witFree(impactPeriod);

      // only print a record if its a non-zero vector.
      if (recordTotal > 0.0001) {
	outFile << "\"" << mpHelper.partname(producedPart) << "\",\""
		<< supplierPdf << "\",\""
		<< customerPdf << "\",\""          
		<< PUD14SourceCode << "\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, supplyOrderQty, 0, 15);
	numRecords++;        
a7430 2
      witFree(producedPart);

d7432 1
d7434 2
a7436 1
  }
d7438 2
d7441 18
d7460 25
a7484 3
  int nParts;
  char ** partList;
  witGetParts(exploderWitRun, &nParts, &partList);
a7486 8
  // at this point all supply records will be E source.
  std::string PUD14SourceCode = "E";
  // Loop once for each operation
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPart(partList[i]);
    std::string partName, customerPdf;
    float * supplyVol;
d7488 9
a7496 7
    // IF the part is normal, then get its supply Vol and report
    if (mpHelper.isPartNormal(exploderWitRun, fullWitPart)) {
      witGetPartSupplyVol(exploderWitRun, fullWitPart.c_str(), &supplyVol);
      float recordTotal = 0.0;
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t< nPeriods; t++) {
	recordTotal += supplyVol[t];
d7499 9
a7507 9
      customerPdf = mpHelper.pdf(fullWitPart);
      // only print a record if its a non-zero vector.
      if (recordTotal > 0.0001) {
	outFile << "\"" << mpHelper.partname(fullWitPart) << "\",\""
		<< customerPdf << "\",\""
		<< customerPdf << "\",\""          
		<< PUD14SourceCode << "\"";
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, supplyVol, 0, 15);
	numRecords++;        
d7509 20
a7528 10
      witFree(supplyVol);
    }
  
  }
  
  delete [] supplyOrderQty;
  
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);
d7530 3
a7532 7
  for ( i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d7534 31
a7565 102
//  ---------------------------------------------------------------------
//  Print MRP Demand Orders File
//  ---------------------------------------------------------------------
//
//  Codes are:
//  "A" = interplant
//  "B" = bin
//  "F" = build in-house (includes features, subs, BB's)
//  "O" = user-defined Operation
//  "D" = de-aggregation
//  "E" = External demand (ie, demandVol)
void 
LgFrScenarioForSce::printMrpDemandOrdersFile(
    LgFrMultiPlantHelper & mpHelper,
    const int nPeriods,         // Number of periods 
    std::string fileName)
{

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "MRP Demand Orders" 
		       << fileName);
  }

  long numRecords = 0;

  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          

  WitRun *  exploderWitRun = myExploder->localWitRun();

  float * demandOrderQty = new float [nPeriods];
  float * subDemandOrderQty = new float [nPeriods];  
  
  int nOps;
  char ** opList;
  witGetOperations(exploderWitRun, &nOps, &opList);

  int nParts;
  char ** partList;
  witGetParts(exploderWitRun, &nParts, &partList);

  // For F source and O source, we need to accumulate the demands into an
  // array.  For the others, we report as we find them.
  // malloc vectors to be a vector of floatVecs
  float ** FsourceDemand = (float **) malloc (nParts * sizeof(float *));
  assert(FsourceDemand != 0);
  float ** OsourceDemand = (float **) malloc (nParts * sizeof(float *));
  assert(OsourceDemand != 0);

  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    FsourceDemand[i] = (float *) malloc (nPeriods * sizeof(float));
    assert(FsourceDemand[i] != 0);    
    OsourceDemand[i] = (float *) malloc (nPeriods * sizeof(float));
    assert(OsourceDemand[i] != 0);

    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      FsourceDemand[i][t] = 0.0;
      OsourceDemand[i][t] = 0.0;
    }
    
    // set the index's for these parts using appData.  We need to do this
    // because there will be lots of part searching going on.
    LgFrScePartAppData * appDataPtr;    
    witGetPartAppData(exploderWitRun, partList[i], (void **) &appDataPtr);
    if (appDataPtr == 0) {
      appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      appDataPtr->index(i);
      witSetPartAppData(exploderWitRun, partList[i], (void *) appDataPtr);
    }
    else
      appDataPtr->index(i);
  }

  

  
  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {

    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2, geo, plannerPart;
    std::string sourceCode;
    std::string supplierPdf, customerPdf;
    std::string gg, mm;


    // IF the operation is normal, then its either a  "F" source (ie, build in-house)
    //                                     OR a user-defined operation
    if (mpHelper.isOperationNormal(exploderWitRun, fullWitOperation, p, op)) {
      customerPdf = p;      
      // if the part exists, then the operation is a build-inhouse
      if (mpHelper.isPartNormal(exploderWitRun, fullWitOperation)) 
	sourceCode = "F";
      else 
	sourceCode = "O";
    }
d7567 7
a7573 9
    // if the operation is a specialStandaloneFeature then we pick this up as a
    // feature demand
    else if (mpHelper.isOperationSpecialStandaloneFeature(exploderWitRun, 
							  fullWitOperation, 
							  mm, 
							  gg, 
							  pn1, 
							  pdf1)) {
      sourceCode = "F";
a7574 1
    
a7575 5
    else if (mpHelper.isOperationSpecialInterplant(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      customerPdf = pdf1;      
      sourceCode = "A";
    }
d7577 2
a7578 9
    else if (mpHelper.isOperationSpecialAggregation(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      customerPdf = pdf1;      
      sourceCode = "D";
    }
    else if (mpHelper.isOperationSpecialGeoPlannerDemand(exploderWitRun, fullWitOperation,
							 plannerPart, geo)) {
      customerPdf = geo;      
      sourceCode = "E";
    }
a7579 2
    else
      continue;
d7581 1
a7581 2
    // regardless of what this thing is, compute how much demand it 
    // generated on each of its children
d7583 19
a7601 10
    int nBoms;
    witGetOperationNBomEntries(exploderWitRun, fullWitOperation.c_str(), &nBoms);
    int k = 0; // Pulled out of the for below by RW2STL
    for (k=0; k<nBoms; k++) {
      int * impactPeriod;
      float * mrpExecVol;
      float usageRate;
      int fallout;
      int early, late;
      char * consumedPart;
d7603 6
a7608 1
      witGetBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, &consumedPart);
d7610 4
a7613 6
      // ignore capacity
      witAttr category;      
      witGetPartCategory(exploderWitRun, consumedPart, &category);
      if (category == WitCAPACITY) {
	witFree(consumedPart);
	continue;
a7614 13
      
      // check the child part. If its not normal, then skip it
      if (! mpHelper.isPartNormal(exploderWitRun, consumedPart)) {
	witFree(consumedPart);        
	continue;
      }
      
      witGetBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, &usageRate);
      witGetBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &early);
      witGetBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &late);
      witGetBomEntryFallout(exploderWitRun, fullWitOperation.c_str(), k, &fallout);      
      myExploder->mrpExecVol(fullWitOperation, &mrpExecVol);          
      witGetBomEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), k, &impactPeriod);
d7616 15
a7630 33
      // Now consider subs (this is a pain in the ass)
      // if the bom entry has subs, then we must pick that demand up and make
      // sure to report it on the sub part.
      // FINISH_ME: use impactPeriod from bom entry.  See BOB about an impact period
      // for subs given that there's seperate offsets for subs.
      // This *should* only occur for real subs and not for any dummies
      int nSubs;
      witGetBomEntryNSubsBomEntries(exploderWitRun, fullWitOperation.c_str(), k, &nSubs);
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubs; s++) {
	float subUsageRate;
	int subEarly;
	int subLate;
	float subFalloutRate;
	char * subConsumedPart;
	float * subVol;
	witGetSubsBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subUsageRate);
	witGetSubsBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subEarly);
	witGetSubsBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subLate);
	witGetSubsBomEntryFalloutRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subFalloutRate);
	witGetSubsBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, s, &subConsumedPart);
	myExploder->subUsageVol(fullWitOperation, k, s, &subVol);
	// zero out the subDemandOrderQty vector first
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  subDemandOrderQty[t] = 0.0;
	for (t=subEarly; t<=subLate; t++) {
	  // decrement mrpExecVol by subVol
	  mrpExecVol[t] -= subVol[t];
	  // now compute the demand on the sub
	  if (impactPeriod[t] > -1) {
	    subDemandOrderQty[impactPeriod[t]] = subVol[t]
				 * subUsageRate / (1.0 - subFalloutRate);
d7632 3
a7634 11
	}
	// if its a sub off an interplant, then its a jumper arc
	if (sourceCode == "A") {
	  // only print a record if its a non-zero vector.
	  if (flatFileMgr_.isFloatVecNonZero(subDemandOrderQty, nPeriods)) {                      
	    outFile << "\"" << mpHelper.partname(subConsumedPart) << "\",\""
		    << mpHelper.pdf(subConsumedPart) << "\",\""
		    << customerPdf << "\",\""          
		    << sourceCode << "\"";
	    flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subDemandOrderQty, 0, 15);
	    numRecords++;        
d7637 7
a7643 16

	else if (sourceCode == "F") {
	  LgFrScePartAppData * myAppDataPtr;
	  witGetPartAppData(exploderWitRun, subConsumedPart, (void **) &myAppDataPtr);
	  assert(myAppDataPtr != 0);
	  int index = myAppDataPtr->index();
	  for (t=0; t<nPeriods; t++) 
	    FsourceDemand[index][t] += subDemandOrderQty[t];
	}
	else if (sourceCode == "O") {
	  LgFrScePartAppData * myAppDataPtr;
	  witGetPartAppData(exploderWitRun, subConsumedPart, (void **) &myAppDataPtr);
	  assert(myAppDataPtr != 0);
	  int index = myAppDataPtr->index();
	  for (t=0; t<nPeriods; t++) 
	    OsourceDemand[index][t] += subDemandOrderQty[t];
a7644 1
	// if its a sub off an aggregation or a GPD, then its an error
d7646 2
a7647 34
	  assert(1 == 0);
	}
	witFree(subConsumedPart);
	witFree(subVol);
      }  // this is the end of analysis for subs

      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
	demandOrderQty[t] = 0.0;
      
      for ( t=early; t<=late; t++) {
	if (impactPeriod[t] > -1) {
	  demandOrderQty[impactPeriod[t]] = mrpExecVol[t] * usageRate * 100.0 / (float) (100 - fallout);
	}
      }

      witFree(mrpExecVol);
      witFree(impactPeriod);

      LgFrScePartAppData * myAppDataPtr;
      witGetPartAppData(exploderWitRun, consumedPart, (void **) &myAppDataPtr);
      assert(myAppDataPtr != 0);
      int index = myAppDataPtr->index();

      // interplants, bins, indep demand,  and de-aggs are the same
      if (sourceCode == "A" || sourceCode == "D" || sourceCode == "E" || sourceCode == "B") {
	// only print a record if its a non-zero vector.
	if (flatFileMgr_.isFloatVecNonZero(demandOrderQty, nPeriods)) {                      
	  outFile << "\"" << mpHelper.partname(consumedPart) << "\",\""
		  << customerPdf << "\",\""
		  << mpHelper.pdf(consumedPart) << "\",\""          
		  << sourceCode << "\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, demandOrderQty, 0, 15);
	  numRecords++;        
a7649 48
      else if (sourceCode == "F") {
	for (t=0; t<nPeriods; t++) 
	  FsourceDemand[index][t] += demandOrderQty[t];
      }
      else if (sourceCode == "O") {
	for (t=0; t<nPeriods; t++) 
	  OsourceDemand[index][t] += demandOrderQty[t];
      }
      // You should never get here
      else {
	assert(1 == 0);
      }

      witFree(consumedPart);

    }

  }

  // OK, now print the F and O source  
  for ( i=0; i<nParts; i++ ) {
    std::string thePart(partList[i]);
    // if its not normal then skip it
    if (! mpHelper.isPartNormal(exploderWitRun, thePart)) {
      continue;
    }
    if (flatFileMgr_.isFloatVecNonZero(FsourceDemand[i], nPeriods)) {              
      std::string thePdf(mpHelper.pdf(thePart));
      outFile << "\"" << mpHelper.partname(thePart) << "\",\""
	      << thePdf << "\",\""
	      << thePdf << "\",\""          
	      << "F" << "\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, FsourceDemand[i], 0, 15);
      numRecords++;
    }

    // as long as you find one period that is non-zero, then print it
    if (flatFileMgr_.isFloatVecNonZero(OsourceDemand[i], nPeriods)) {        
      std::string thePdf(mpHelper.pdf(thePart));
      outFile << "\"" << mpHelper.partname(thePart) << "\",\""
	      << thePdf << "\",\""
	      << thePdf << "\",\""          
	      << "O" << "\"";
      flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, OsourceDemand[i], 0, 15);
      numRecords++;
    }
    
  }
a7650 12
  
  for (i=0; i<nParts; i++) {
    free(FsourceDemand[i]);
    free(OsourceDemand[i]);
  }
  free(FsourceDemand);
  free(OsourceDemand);  
  
  
  for ( o=0; o<nOps; o++ ) 
    witFree(opList[o]);
  witFree(opList);
d7652 9
a7660 3
  for ( i=0; i<nParts; i++ ) 
    witFree(partList[i]);
  witFree(partList);
a7661 6
  delete [] demandOrderQty;
  delete [] subDemandOrderQty;  
  
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
d7664 6
a7670 30
// ---------------------------------------------------------------
// One stop WIT messaging control
void 
LgFrScenarioForSce::setWitInformationalMessaging(WitRun * const theWitRun,   
						       int onOrOff)
{
  // if they want it off
  if (onOrOff == 0) {
    // shut off ALL info messages
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
    // Let ANY warning message come out once
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, 1);    
    // Suppress a few WARNING messages that we already know about
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 446, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);        
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);        
    witSetMesgTimesPrint(theWitRun, WitTRUE, 745, 0);        
  }     
  else {
    // turn all INFO on
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, UCHAR_MAX);
    // turn all WARNINGS on 
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, UCHAR_MAX);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);           
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);         
    witSetMesgTimesPrint(theWitRun, WitTRUE, 745, 0);         
  }
}
d7672 5
a7677 6
// return the set of paramters 
LgFrSceSetOfParameters&
LgFrScenarioForSce::setOfParameters()
{
  return parameterSet_;
}
d7679 8
a7686 6
// return the flat file manager
LgFrSceFlatFileMgr&
LgFrScenarioForSce::flatFileMgr()
{
  return flatFileMgr_;
}
d7688 5
d7694 3
a7696 8
/*void
LgFrScenarioForSce::localeSnapshot(
				   RWLocaleSnapshot * localSnapshotPtr)
{
  delete localSnapshotPtr_;
  localSnapshotPtr_ = localSnapshotPtr;
  RWLocale::global(localSnapshotPtr_);
}*/
a7697 6
LgFrSetOfParts&
LgFrScenarioForSce::setOfParts(int k)
{
  // OK to cast away const. This is non-const member function
  return (LgFrSetOfParts &) constSetOfParts(k);
}
d7699 14
a7712 18
const
LgFrSetOfParts&
LgFrScenarioForSce::constSetOfParts(int k)
const
{
  assert (k >= LGFR_DEFAULT_SET && k <= LGFR_INTERPLANT_SET );
  switch (k) {
  case LGFR_DEFAULT_SET:
    return defaultSOP_;
  case LGFR_UNIVERSAL_SET:
    return LgFrScenario::constSetOfParts(LGFR_UNIVERSAL_SET);
  case LGFR_INTERPLANT_SET:
    return interplantSOP_;
  default:
    assert(1==0);
  }
  return defaultSOP_;
}
d7714 5
d7720 1
a7720 6
LgFrSetOfDemands&
LgFrScenarioForSce::setOfDemands(int k)
{
  // OK to cast away const. This is non-const member function
  return (LgFrSetOfDemands &) constSetOfDemands(k);
}
d7722 4
a7725 16
const
LgFrSetOfDemands&
LgFrScenarioForSce::constSetOfDemands(int k)
const
{
  assert (k >= LGFR_DEFAULT_SET && k <= LGFR_UNIVERSAL_SET );
  switch (k) {
    case LGFR_DEFAULT_SET:
       return defaultSOD_;
    case LGFR_UNIVERSAL_SET:
       return LgFrScenario::constSetOfDemands(LGFR_UNIVERSAL_SET);
    default:
       assert(1==0);
     }
  return defaultSOD_;
}
d7727 13
a7739 5
isAReturnType
LgFrScenarioForSce::isA() const
{
    return id_;
}
d7741 11
a7751 58
// Constructor
LgFrScenarioForSce::LgFrScenarioForSce(const LgFrDataInterfaceAbstract&    dif,
					 const LgFrCalendar&         calendar)
:LgFrScenario(dif, calendar),
 defaultSOP_(0),
 defaultSOD_(0),
 interplantSOP_(0),
 multiPlantHelper_(),
 critList_(),
 parameterSet_(),
 flatFileMgr_(),
 nStandaloneFeatureArcs_(0),
 nDemandsWithNonZeroMins_(0),
// localSnapshotPtr_(0),
 engine_("heuristic"),
 id_(__LGFRSCENARIOFORSCE),
 exploderPtr_(0),
 sceErrFacDisp_(0),
 sceMsgFacDisp_(0),
 sceErrFacility_(0),
 sceMsgFacility_(0),
 sceScrub_(new LgFrSceScrubber())
{
  // builder does the rest
}


// Destructor 
LgFrScenarioForSce::~LgFrScenarioForSce()
{
  LgFrSetOfDemands & univSod = this->setOfDemands();
  WitRun * theWitRun  = this->lastProblemSolved().witRun();

  // Use WIT Object Iteration to delete all the AppData's

  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    std::cout << "Deleting scenario's witRun, AppData Clones:   ogjItrState is not WitINACTIVE.   Resetting ObjItr" << std::endl;
    witResetObjItr(theWitRun);
  }

  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
d7754 7
a7760 8
    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
d7762 11
a7772 7
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
d7774 9
a7782 8

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
d7786 3
a7788 7
    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
d7790 1
d7792 4
a7795 12
    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }
a7796 5
    else 
      assert(1 == 0);
      
  }
  //  std::cout << "Done deleting appData from scenario's witrun" << std::endl;
d7798 12
a7809 2
  //  delete  exploderPtr_;
  //  std::cout << "Done deleting appData from exploder's witrun" << std::endl;
d7811 4
a7814 6
  delete  sceErrFacDisp_;
  delete  sceMsgFacDisp_;
  delete  sceErrFacility_;
  delete  sceMsgFacility_;
  
  delete  sceScrub_;
a7815 1
}
d7819 11
a7829 2
void
LgFrScenarioForSce::deleteAppDataAndScenarioObjects()
d7831 10
a7840 1
  WitRun * theWitRun  = this->lastProblemSolved().witRun();
d7842 17
a7858 1
  delete  exploderPtr_;  
a7859 1
  return;
d7861 9
d7871 4
a7875 1
  // Use WIT Object Iteration to delete all the AppData's
a7876 6
  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    witResetObjItr(theWitRun);
  }
d7878 10
a7887 16
  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }
d7889 5
a7893 53
    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

    else 
      assert(1 == 0);
      
d7896 1
d7898 1
d7900 3
d7904 4
d7909 1
a7910 5
  //  delete  sceErrFacDisp_;
  //  delete  sceMsgFacDisp_;
  //  delete  sceErrFacility_;
  //  delete  sceMsgFacility_;
  //  delete  sceScrub_;
d7912 3
d7916 4
d7921 3
a7923 1
}
d7925 4
d7930 9
d7940 12
d7953 10
d7964 15
d7980 2
a7981 9
#if 0
void
LgFrScenarioForSce::deleteAppDataAndScenarioObjects()
{
  WitRun * theWitRun  = this->lastProblemSolved().witRun();

  std::cout << "Deleting Scenario objects including WIT AppData ... " << std::endl;

  // Use WIT Object Iteration to delete all the AppData's
a7982 5
  witAttr objItrState;
  
  witGetObjItrState(theWitRun, &objItrState);
  if (objItrState != WitINACTIVE) {
    witResetObjItr(theWitRun);
d7984 2
d7987 3
a7989 16
  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(theWitRun);
    
    witGetObjItrState(theWitRun, &objItrState);
    
    if (objItrState ==  WitAT_PART) {   
      char * partName;
      witGetObjItrPart(theWitRun, &partName);
      witGetPartAppData(theWitRun, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }
d7991 2
a7992 17
    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(theWitRun, &partName, &demandName);
      witGetDemandAppData(theWitRun, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }
	
    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(theWitRun, &opName);
      witGetOperationAppData(theWitRun, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
a7993 8
    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(theWitRun, &opName, &b);
      witGetBomEntryAppData(theWitRun, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
d7995 10
d8006 6
a8011 8
    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(theWitRun, &opName, &b, &s);
      witGetSubsBomEntryAppData(theWitRun, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
d8013 1
a8013 12
    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(theWitRun, &opName, &bp);
      witGetBopEntryAppData(theWitRun, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }
      
    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }
d8015 1
a8015 4
    else 
      assert(1 == 0);
      
  }
d8017 1
d8019 3
a8021 10
  delete  exploderPtr_;
  
  delete  sceErrFacDisp_;
  delete  sceMsgFacDisp_;
  delete  sceErrFacility_;
  delete  sceMsgFacility_;
  
  delete  sceScrub_;
}
#endif
d8023 3
d8027 1
d8029 3
d8033 2
a8034 7
// Assignment operator.
LgFrScenarioForSce&
LgFrScenarioForSce::operator=(
   const LgFrScenarioForSce& rhs)
{
  // error
  (*sceErrFacility_)("sceLgFr");
d8036 6
a8041 9
/*
   if (this != &rhs) {           // Check for assignment to self
     (this->LgFrScenario::operator= ) (rhs);
     defaultSOP_ = rhs.defaultSOP_;
     defaultSOD_ = rhs.defaultSOD_;
   }
*/
   return *this;
}
d8043 2
d8046 6
a8051 23
// Customized copy constructor
LgFrScenarioForSce::LgFrScenarioForSce(
   const LgFrScenarioForSce& source )
: LgFrScenario( source ),
  defaultSOP_(source.defaultSOP_),
  defaultSOD_(source.defaultSOD_),
  interplantSOP_(source.interplantSOP_),
  multiPlantHelper_(source.multiPlantHelper_),
  nStandaloneFeatureArcs_(source.nStandaloneFeatureArcs_),
  nDemandsWithNonZeroMins_(source.nDemandsWithNonZeroMins_),
  critList_(source.critList_),
  parameterSet_(source.parameterSet_),
  flatFileMgr_(source.flatFileMgr_),
//  localSnapshotPtr_( source.localSnapshotPtr_ ),
  engine_(source.engine_),
  id_(__LGFRSCENARIOFORSCE),
  exploderPtr_(source.exploderPtr_),
  sceScrub_(new LgFrSceScrubber())
{
  // i don't know when the copy constructor is called, so not sure if this 
  // works... the reason i didn't assign copy error facility ptr to the 
  // original error facility ptr is because that might cause errors later
  // if one were to be destroyed...and the common facility along with it.
a8052 6
  // this is to create a suitable message file name
  // to this we will append a number (the integer count of the number
  // of such temporary log files are created)
  // Note: numTempFiles_ is a static data member of LgFrScenarioForSce class
  std::ifstream temp1;
  std::ifstream temp2;
d8054 7
a8060 2
  std::string errFileName = "errorLog" + numTempFiles_;
  std::string msgFileName = "messageLog" + numTempFiles_;
d8062 10
a8071 2
  temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
  temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);
d8073 15
a8087 7
  while (temp1.good() || temp2.good()) {   // this means that file exists!
    numTempFiles_++;  // maintain uniqueness among pairs of output files
    errFileName = "errorLog" + numTempFiles_;
    msgFileName = "messageLog" + numTempFiles_;
    temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
    temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);
  }
d8089 1
a8089 1
  numTempFiles_++; // need to increment since curr val is used now
d8091 3
a8093 4
  // create display and facility
  sceErrFacDisp_ = new MclPrintfOutputDisplayer(errFileName.c_str(),"w+");
  sceErrFacility_ = new MclFacility("SCE",*sceErrFacDisp_);
  sceErrFacility_->minErrOutLevel(MclLevel::error ());
d8095 3
a8097 4
  sceMsgFacDisp_ = new MclPrintfOutputDisplayer(msgFileName.c_str(),"w+");
  sceMsgFacility_ = new MclFacility("SCE",*sceMsgFacDisp_);
  sceMsgFacility_->minErrOutLevel(MclLevel::error ());
}
d8099 1
a8099 23
// Default constructor
LgFrScenarioForSce::LgFrScenarioForSce()
: LgFrScenario(),
  defaultSOP_(0),
  defaultSOD_(0),
  interplantSOP_(0),
  multiPlantHelper_(),
  critList_(),
  parameterSet_(),
  flatFileMgr_(),
  nStandaloneFeatureArcs_(0),
  nDemandsWithNonZeroMins_(0),
//  localSnapshotPtr_(0),
  engine_("heuristic"),
  id_(__LGFRSCENARIOFORSCE),
  exploderPtr_(0),
  sceErrFacDisp_(0),
  sceMsgFacDisp_(0),
  sceErrFacility_(0),
  sceMsgFacility_(0),
  sceScrub_(new LgFrSceScrubber())
{
  // Nothing to do here
a8102 1
#ifdef SCE_ODBC
a8103 7
void 
LgFrScenarioForSce::analyzeRunAndUpdateDB()
{
 int nPeriods;                         //  Number of periods in model  
    int nParts;                           //  Number of parts in model     
    char ** partList;                     //  List of parts in model       
    int i;                                //  Loop index                  
a8105 7
    WitRun * const theWitRun = lastProblemSolved().witRun();
    LgFrCalendar & theCal = calendar();
    LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
    LgFrSceCritList & theCritList = sceCritList();
      
    witGetParts( theWitRun, &nParts, &partList );
    nPeriods = theCal.nPeriods();
a8106 1
    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
a8107 9
    // Geo Source Debug File: optional file
    if (setOfParameters.getBool("printGeoSourceDebugFile"))  {    
      std::string geoSourceDebugFileName =
	setOfParameters.getString("geoSourceDebugFileName");
      printGeoSourceDebugFile(theWitRun, nPeriods, nParts, partList,
			      geoSourceDebugFileName, theCal, mpHelper);
    }
    
    
d8109 21
a8129 8
    // Formatted Supply Response Report File: optional file
    if (setOfParameters.getBool("printFormattedSupplyReportFile"))  {    
      std::string formattedSupplyReportFileName =
	setOfParameters.getString("formattedSupplyReportFileName");
      printHumanReadableSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
				       formattedSupplyReportFileName,
				       theCal, mpHelper);
    }
d8131 6
a8136 5
    // Supply Response  File: mandatory file
    std::string supplyResponseFileName =
      setOfParameters.getString("supplyResponseFileName");
    printSupplyPlanSoln(theWitRun, nPeriods, nParts, partList,
			supplyResponseFileName, theCal, mpHelper);
a8137 18
    //------ updating attribute SupplyVol in Demand table
    {
     SceDemandDB tbl;
     SceDBLink demand(tbl);
     insertDemandSupplyVol(demand,theWitRun, nPeriods, nParts, partList,
			   theCal, mpHelper);
     demand.update("supplyVol");
     //  std::cout << std::endl << "Updating Demand SupplyVol SUCCESSFULLY!"<< std::endl;
    }
    //------------------------------------------------------
    
    // Supply Response By PDF  File: optional file
    if (setOfParameters.getBool("printGeoSupplyByPdfFile"))  {
      std::string geoSupplyByPdfFileName =
	setOfParameters.getString("geoSupplyByPdfFileName");
      printGeoSupplyByPdf(theWitRun, nPeriods, nParts, partList,
			  geoSupplyByPdfFileName, theCal, mpHelper);
    }
d8139 1
a8139 18
	 //---------- Inserting SupplyResponse -------------
    {
	SceSupplyResponseDB tbl;
	SceDBLink supply(tbl);
	
	if (! tbl.fDelete())
	  tbl.deleteTbl();
	    
	insertSupplyResponse(supply,
		       theWitRun,
		       nPeriods,
		       nParts,
		       partList,
		       theCal,
		       mpHelper);
	supply.insert();
	//        std::cout << std::endl << "Inserting Supply Response SUCCESSFULLY!"<< std::endl;
       }
d8141 1
a8141 1
    //----------------------------------------------------
d8143 1
d8145 2
a8146 27
    // Backlog Response File: mandatory file
    std::string backlogResponseFileName =
      setOfParameters.getString("backlogResponseFileName");
    printBacklogSchedule(theWitRun, nPeriods, nParts, partList,
			 backlogResponseFileName, theCal, mpHelper);

    
     //------ updating attribute backlogVol in Demand table
    {
     SceDemandDB tbl;
     SceDBLink demand(tbl);
     insertDemandBacklogSchedule(demand,theWitRun, nPeriods, nParts, partList,
			   theCal, mpHelper);
     demand.update("backlogVol");
     //     std::cout << std::endl << "Updating Demand BacklogVol SUCCESSFULLY!"<< std::endl;
    }
    //------------------------------------------------------
    
    // Critical List: optional file
    if (setOfParameters.getBool("printCriticalListFile"))  {    
      std::string criticalListFileName =
	setOfParameters.getString("criticalListFileName");
      std::string engine = setOfParameters.getString( "engine");
      printCriticalList(theWitRun, engine, nPeriods, nParts, partList,
			criticalListFileName, theCal, mpHelper, theCritList);
    }
    
d8148 1
a8148 6
    // Build Schedule  File: mandatory file
    std::string buildSchedFileName =
      setOfParameters.getString("buildSchedFileName");
    printBuildSchedule(theWitRun, nPeriods, nParts, partList,
		       buildSchedFileName,
		       theCal, mpHelper);
d8150 8
a8157 47
    //------------- updating PartPdf ProdVol -------
  {
    ScePartPdfDB tbl;
    SceDBLink prodVol(tbl);
    
    insertPartPdfProdVol(prodVol,
			     theWitRun,
			     nPeriods,
			     nParts,
			     partList,
			     theCal,
			     mpHelper);
    prodVol.update("prodVol");
  }
    
    // Interplant Order File
    std::string interPlantFile = setOfParameters.getString("interPlantFile");
    if (! interPlantFile.empty())   {
      std::string interplantOrdersFileName =
	setOfParameters.getString("interplantOrdersFileName");
      bool isThisMrp = false;
      printInterplantVolumesFile(theWitRun, nPeriods, 
				 isThisMrp,
				 nOperations, opList,
				 interplantOrdersFileName,
				 mpHelper);
    }
    //---------- Inserting IPOrders -------------
    {
	SceIPOrdersDB tbl;
	SceDBLink ipOrders(tbl);
	
	if (! tbl.fDelete())
	  tbl.deleteTbl();
	    
	insertIPOrders(ipOrders,
		       theWitRun,
		       nPeriods,
		       nParts,
		       partList,
		       theCal,
		       mpHelper);
	ipOrders.insert();
	//        std::cout << std::endl << "Inserting IPOrders SUCCESSFULLY!"<< std::endl;
       }
       
    //------------------------------------------------------------
d8159 4
a8162 10
    // Substitute Usage Volume File: mandatory file
    // (prints only when there is substitute  input data)
    std::string subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.empty())   {
      std::string subUsageFileName =
	setOfParameters.getString("subUsageFileName");
	printSubstituteProductionVolume(theWitRun, nPeriods, nParts, partList,
					subUsageFileName,
					theCal, mpHelper);
    }
d8166 11
a8176 9
    // Operation Execution Volume Schedule File: mandatory file
    // Prints execVol of operations that are:
    // (1) explicitely defined by the user in the operation Definition File
    // (2) SCE-defined generated from parts defined in the part Definition File
    std::string operationOrdersFileName =
      setOfParameters.getString("operationOrdersFileName");
    printOperationOrdersFile(theWitRun, nPeriods,
				  operationOrdersFileName,
				  mpHelper);
d8178 6
d8185 4
a8188 22
    
    // -----------------------------------------
    // ----- Print Feature Ratio Stuff ---------
    // -----------------------------------------    
    std::string featureFileOutputFormat =
      setOfParameters.getString("featureFileOutputFormat");

    // see what format the user wants his feature outputs as
    int printDataAsPercentage = 0;
    if (featureFileOutputFormat == "percentage")
      printDataAsPercentage = 1;
    
    
    // Feasible Optional Feature Ratio File: mandatory file
    // (prints only when there is optional feature  input data)
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      std::string optionalFeatRatioFileName =
	setOfParameters.getString("optionalFeatRatioFileName");
      printStandAloneFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
					   optionalFeatRatioFileName,
					   theCal, mpHelper, printDataAsPercentage);
d8191 2
a8192 11
    // Feasible Selective Feature/Building Block Ratio File: mandatory file
    // (prints only when there is BBratio input data)
    std::string topLevelToBBratioFile =
      setOfParameters.getString("topLevelToBBratioFile");
    if (! topLevelToBBratioFile.empty()) {
      std::string selFeatBBratioFileName =
	setOfParameters.getString("selFeatBBratioFileName");
      printFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
				 selFeatBBratioFileName,
				 theCal, mpHelper, printDataAsPercentage);
    }
d8194 2
d8197 10
a8206 32
    // Part Database Dump File:  optional file
    if (setOfParameters.getBool("printPartDBFile"))  {
      std::string
	partDBFileName = setOfParameters.getString("partDBFileName");
      printPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				partList, partDBFileName);
    }

    //------------ update partPdf attributes ------------
    {
      ScePartPdfDB tbl;
      SceDBLink partPdf(tbl);

      insertPartPdfSupplyVol(partPdf,
			     theWitRun,
			     nPeriods,
			     nParts, 
			     partList,
			     mpHelper);
      partPdf.update("supplyVol");
    }

     {
      ScePartPdfDB tbl;
      SceDBLink partPdf(tbl);

      insertPartPdfCycleTime(partPdf,
			     theWitRun,
			     nPeriods,
			     nParts, 
			     partList,
			     mpHelper);
a8207 21
      partPdf.update("cycleTime");
    }

     {
      ScePartPdfDB tbl;
      SceDBLink reqVol(tbl);
      SceDBLink mrpExcessVol(tbl);
      SceDBLink mrpRequirements(tbl);

      insertPartPdfReqVolAndMrpExcessVolAndMrpRequirements(
					reqVol,
					mrpExcessVol,
					mrpRequirements,
					theWitRun,
					nPeriods,
					nParts, 
					partList,
					mpHelper);
      reqVol.update("reqVol");
      mrpExcessVol.update("mrpExcessVol");
      mrpRequirements.update("mrpRequirements");
d8209 18
a8226 13
     }

      {
	ScePartPdfDB tbl;
	SceDBLink partPdf(tbl);

	insertPartPdfScrapVol(partPdf,
			     theWitRun,
			     nPeriods,
			     nParts, 
			     partList,
			     mpHelper);
	partPdf.update("scrapVol");
a8228 26
      {
      ScePartPdfDB tbl;
      SceDBLink partPdf(tbl);

      insertPartPdfConsVol(partPdf,
			     theWitRun,
			     nPeriods,
			     nParts, 
			     partList,
			     mpHelper);
      partPdf.update("consVol");
    }
       updateAttrFromPartDataBaseDump(
			     theWitRun,
			     nPeriods,
			     nParts, 
			     partList,
			     mpHelper);
      
     //---------------------------------------------------
    // Capacity Database Dump File: optional file    
    if (setOfParameters.getBool("printCapacityDBFile"))  {
      std::string capacityDBFileName =
	setOfParameters.getString("capacityDBFileName");
      printCapacityDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				    partList, capacityDBFileName);
d8230 1
a8230 1
       //------ updating attributes in capacityAttr table
d8232 1
a8232 17
      {
	 SceCapacityAttrDB tbl;
	 SceDBLink capSupplyVol(tbl);
	 insertCapacitySupplyVol(capSupplyVol,
			    theWitRun, nPeriods, nParts, partList,mpHelper);
	 capSupplyVol.update("supplyVol");
	 //         std::cout << std::endl << "Updating Capacity SupplyVol SUCCESSFULLY!"<< std::endl;
      }

      {
	SceCapacityAttrDB tbl;
	SceDBLink capMrpConsVol(tbl);
	insertCapacityMrpConsVol(capMrpConsVol,
				 theWitRun, nPeriods, nParts, partList,mpHelper);
	capMrpConsVol.update("MrpConsVol");
	//        std::cout << std::endl << "Updating Capacity MrpConsVol SUCCESSFULLY!"<< std::endl;
      }
d8234 5
a8238 32
 
       {
	  SceCapacityAttrDB tbl;
	  SceDBLink capReqVol(tbl), capMrpExcessVol(tbl),capMrpRequirements(tbl);
	
	 insertCapacityReqVolAndMrpExcessVolAndMrpRequirements(
							 capReqVol,
							 capMrpExcessVol,
							 capMrpRequirements,
							 theWitRun,
							 nPeriods,
							 nParts,
							 partList,
							 mpHelper);
	 
	 capReqVol.update("ReqVol");
	 //         std::cout << std::endl << "Updating Capacity ReqVol SUCCESSFULLY!"<< std::endl;
	 capMrpExcessVol.update("MrpExcessVol");
	 //  std::cout << std::endl << "Updating Capacity MrpExcessVol SUCCESSFULLY!"<< std::endl;
	 capMrpRequirements.update("MrpRequirements");
	 //  std::cout << std::endl << "Updating Capacity MrpRequirements SUCCESSFULLY!"<< std::endl;
     
       }
       
       {
	SceCapacityAttrDB tbl;
	SceDBLink capExcessVol(tbl);
	insertCapacityExcessVol(capExcessVol,
			      theWitRun, nPeriods, nParts, partList,mpHelper);
	capExcessVol.update("ExcessVol");
	//        std::cout << std::endl << "Updating Capacity ExcessVol SUCCESSFULLY!"<< std::endl;
       }
d8240 5
a8244 16
       {
	SceCapacityAttrDB tbl;
	SceDBLink capScrapVol(tbl);
	insertCapacityScrapVol(capScrapVol,
			      theWitRun, nPeriods, nParts, partList,mpHelper);
	capScrapVol.update("ScrapVol");
	//        std::cout << std::endl << "Updating Capacity ScrapVol SUCCESSFULLY!"<< std::endl;
       }
       
       {
	SceCapacityAttrDB tbl;
	SceDBLink capConsVol(tbl);
	insertCapacityConsVol(capConsVol,
			      theWitRun, nPeriods, nParts, partList,mpHelper);
	capConsVol.update("ConsVol");
	//        std::cout << std::endl << "Updating Capacity ConsVol SUCCESSFULLY!"<< std::endl;
d8247 3
a8249 3
       
    //------------------------------------------------------
    }
d8251 8
d8260 3
a8262 7
    // Operation Database Dump File: optional file
    if (setOfParameters.getBool("printOperationDBFile"))  {
      std::string operationDBFileName =
	setOfParameters.getString("operationDBFileName");
      printOperationDataBaseDumpFile(theWitRun, mpHelper, nPeriods, 
				     operationDBFileName);
    }
a8263 7
    
    // Debug Dump File (internal SCE parts)
    if (setOfParameters.getBool("printDebugFile"))  {
      std::string debugFileName =
	setOfParameters.getString("debugFileName");
      printDummyPartDataBaseDumpFile(theWitRun, mpHelper, nPeriods, nParts, 
				     partList, debugFileName);
d8265 1
d8267 1
a8267 12
   // Problem Statistics Summary File: mandatory
   std::string problemStatisticsFileName =
     setOfParameters.getString("problemStatisticsFileName");
   printOverallProblemStatistics(theWitRun, mpHelper, nPeriods, nParts, partList,
				 problemStatisticsFileName);

   // Objective Summary Report: mandatory
   std::string engine = setOfParameters.getString("engine");   
   std::string objectiveSummaryFileName =
     setOfParameters.getString("objectiveSummaryFileName");
   printOverallOptimizationValues(theWitRun, nPeriods, nParts, partList, engine,
				  objectiveSummaryFileName);
a8268 4
   // Cleanup memory
   for ( i=0; i<nParts; i++) 
      witFree(partList[i]);
   witFree( partList );
a8269 1
}
d8271 3
a8274 37
void 
LgFrScenarioForSce::insertDemandSupplyVol(SceDBLink& demand,                 
					  WitRun * const theWitRun,   
					  const int nPeriods,         
					  const int nParts,           
					  char ** partList,       
					  LgFrCalendar & theCal,
					  LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  float * shipVol;
  int i, t;
  
  int nDemands;
  char ** dList;
  int j;
  
  demand.nPeriods(nPeriods);
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      std::string partname = mpHelper.partname(partList[i]);
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	demand.insert(SceArgList()<<partname<<dList[j]<<SceMakeVec(shipVol,nPeriods));
	witFree(shipVol); 
	witFree(dList[j]);
      }
      witFree(dList);
    }
  }    
}
d8276 8
a8283 15
void LgFrScenarioForSce::insertDemandBacklogSchedule(SceDBLink& backlog,                
			     WitRun * const theWitRun, 
			     const int nPeriods,        
			     const int nParts,   
			     char ** partList,   
			     LgFrCalendar & theCal,
			     LgFrMultiPlantHelper & mpHelper)
{
  backlog.nPeriods(nPeriods);
  
  std::string partName;
  float * shipVol;
  float * demandVol;
  float blog;
  int i, t;
d8285 8
a8292 3
  int nDemands;
  char ** dList;
  int j;
d8294 10
a8303 23
  // Loop once for each part.  
  for ( i=0; i<nParts; i++ ) {
    std::string partname = mpHelper.partname(partList[i]);
    std::string plannerPart;
    std::string geo;
    if ( mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, partList[i],
						    plannerPart, geo)) {
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      for (j =0; j<nDemands; j++)  {
	// shipVol
	witGetDemandShipVol(theWitRun, partList[i], dList[j], &shipVol);
	// demandVol
	witGetDemandDemandVol(theWitRun, partList[i], dList[j], &demandVol);
	// backlogVol
	blog = 0.0;
	for (t=0; t<nPeriods; t++)    {
	  blog += (demandVol[t] - shipVol[t]);
	  shipVol[t] = blog;
	}        
	backlog.insert(SceArgList()<<partname<<dList[j]<<SceMakeVec(shipVol,nPeriods));
	witFree(shipVol);
	witFree(demandVol);
	witFree(dList[j]);
d8305 1
a8305 1
      witFree(dList);
d8307 1
d8309 13
d8325 16
a8340 7
void
LgFrScenarioForSce::insertCapacitySupplyVol(SceDBLink& capSupplyVol,            
					    WitRun * const theWitRun,   
					    const int nPeriods,         
					    const int nParts,         
					    char ** partList,        
					    LgFrMultiPlantHelper & mpHelper)
d8342 6
a8347 17
 
  capSupplyVol.nPeriods(nPeriods);
  
  float * witVector;
 
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
    // supplyVol
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
    capSupplyVol.insert(SceArgList() << mpHelper.partname(fullPartName).c_str()
			<< mpHelper.pdf(fullPartName).c_str()
			<< SceMakeVec(witVector, nPeriods));
    witFree(witVector);
d8350 6
a8355 1
}
d8357 2
a8358 8
void
LgFrScenarioForSce::insertCapacityMrpConsVol(SceDBLink& mrpConsVol,        
					     WitRun * const theWitRun, 
					     const int nPeriods,        
					     const int nParts,      
					     char ** partList,     
					     LgFrMultiPlantHelper & mpHelper)
{
d8360 5
a8364 3
    float * witVector;
    mrpConsVol.nPeriods(nPeriods);
    LgFrSceBaseExploder * myExploder = this->exploder();          
d8366 3
a8368 18
    // Loop once for each part.  
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i=0; i<nParts; i++ ) {
      std::string fullPartName(partList[i]);
      if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
	continue;
 
      // mrpConsVol
      myExploder->mrpConsVol(partList[i], &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      
	mrpConsVol.insert(SceArgList()
			  << mpHelper.partname(fullPartName).c_str()
			  << mpHelper.pdf(fullPartName).c_str()
			  << SceMakeVec(witVector, nPeriods));
      }
      witFree(witVector);
    }
d8370 7
a8376 1
}
d8378 1
a8378 19


void
LgFrScenarioForSce::insertCapacityReqVolAndMrpExcessVolAndMrpRequirements(
					 SceDBLink& capReqVol,
					 SceDBLink& capMrpExcessVol,
					 SceDBLink& capMrpReqVol,
					 WitRun * const theWitRun, 
					 const int nPeriods,        
					 const int nParts,      
					 char ** partList,     
					 LgFrMultiPlantHelper & mpHelper)
{
  float * reqVol, *mrpExcessVol;
  capReqVol.nPeriods(nPeriods);
  capMrpExcessVol.nPeriods(nPeriods);
  capMrpReqVol.nPeriods(nPeriods);
  LgFrSceBaseExploder * myExploder = this->exploder();       
 // Loop once for each part.  
d8380 5
a8384 24
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;

    // reqVol
    myExploder->reqVol(partList[i], &reqVol);
    if (this->flatFileMgr_.isFloatVecNonZero(reqVol, nPeriods)) {
      capReqVol.insert(SceArgList()
		    << mpHelper.partname(fullPartName).c_str()
		    << mpHelper.pdf(fullPartName).c_str()
		       << SceMakeVec(reqVol, nPeriods));
    }

    
    // mrpExcessVol
    myExploder->mrpExcessVol(partList[i], &mrpExcessVol);
    if (this->flatFileMgr_.isFloatVecNonZero(mrpExcessVol, nPeriods)) {
      
      capMrpExcessVol.insert(SceArgList()
			     << mpHelper.partname(fullPartName).c_str()
			     << mpHelper.pdf(fullPartName).c_str()
			     << SceMakeVec(mrpExcessVol, nPeriods));
    }
a8385 1
    // mrpRequirements
d8388 2
a8389 1
      reqVol[t] -= mrpExcessVol[t];
a8390 1
    if (this->flatFileMgr_.isFloatVecNonZero(reqVol, nPeriods)) {
d8392 8
a8399 5
      capMrpReqVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
		       << SceMakeVec(reqVol, nPeriods));
      
d8401 2
a8402 3

    witFree(reqVol);
    witFree(mrpExcessVol);
a8403 2
      
}
d8405 1
d8407 4
a8410 8
void LgFrScenarioForSce::insertCapacityExcessVol(
			     SceDBLink& capExcessVol,    
			     WitRun * const theWitRun, 
			     const int nPeriods,        
			     const int nParts,      
			     char ** partList,     
			     LgFrMultiPlantHelper & mpHelper)
{
d8412 5
a8416 1
  capExcessVol.nPeriods(nPeriods);
a8417 3
  float * witVector;
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  bool doImplode = setOfParameters.getBool("doImplode");
d8419 9
a8427 17
   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
    if (doImplode) {
       
      // ExcessVol
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	capExcessVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
		       << SceMakeVec(witVector, nPeriods));
      }
      witFree(witVector);
a8428 12
  }
}
  
void LgFrScenarioForSce::insertCapacityScrapVol(
			     SceDBLink& capScrapVol,    
			     WitRun * const theWitRun, 
			     const int nPeriods,        
			     const int nParts,      
			     char ** partList,     
			     LgFrMultiPlantHelper & mpHelper)
{
  capScrapVol.nPeriods(nPeriods);
d8430 11
a8440 1
  float * witVector;
d8442 5
a8446 18
   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
  // scrapVol
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	capScrapVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
		       << SceMakeVec(witVector, nPeriods));
	
      }
      witFree(witVector);
  }
}
d8448 9
a8456 9
void LgFrScenarioForSce::insertCapacityConsVol(
			     SceDBLink& capConsVol,    
			     WitRun * const theWitRun, 
			     const int nPeriods,        
			     const int nParts,      
			     char ** partList,     
			     LgFrMultiPlantHelper & mpHelper)
{
  capConsVol.nPeriods(nPeriods);
d8458 1
a8458 7
  float * witVector;

   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
a8459 2
    witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
d8461 2
a8462 9
	capConsVol.insert(SceArgList()
			  << mpHelper.partname(fullPartName).c_str()
			  << mpHelper.pdf(fullPartName).c_str()
			  << SceMakeVec(witVector, nPeriods));
	
      }
      witFree(witVector);
  }
}
d8464 12
a8475 9
void LgFrScenarioForSce::insertIPOrders(
		    SceDBLink& ipOrders,  
		    WitRun * const theWitRun,   // WIT environment   
		    const int nPeriods,         // Number of periods 
		    const int nParts,           // Number of parts   
		    char ** partList,           // List of part names
		    LgFrCalendar & theCal,
		    LgFrMultiPlantHelper & mpHelper)
{
d8477 20
a8496 1
   ipOrders.nPeriods(nPeriods);
d8498 45
a8542 4
   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;
d8544 3
a8546 1
   float * execVol;
d8548 23
a8570 34
   // Loop once for each operation
   int nOps;
   char ** opList;
   witGetOperations(theWitRun, &nOps, &opList);
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
       if (! mpHelper.isOperationSpecialInterplant(theWitRun, opList[o], destination, 
						   destinationPdf, source, sourcePdf))
	   continue;
       // get the execVol
       witGetOperationExecVol(theWitRun, opList[o], &execVol);

       // check to see that execVol is not Zero vector,
       // if it is then skip it.
       bool isVecNonZero = false;
       int t = 0; // Pulled out of the for below by RW2STL
       for (t=0; t<nPeriods; t++) {
	 if (execVol[t] > 0.01) {
	   isVecNonZero = true;
	   break;
	 }
       }
       if (! isVecNonZero) {
	 witFree(execVol);
	 continue;
       }
       ipOrders.insert(SceArgList()
		       << destination
		       << destinationPdf
		       << source
		       << sourcePdf
		       << SceMakeVec(execVol, nPeriods));
       witFree(execVol); 
   }
d8572 9
a8580 4
   for (o=0; o<nOps; o++ ) 
     witFree(opList[o]);
   witFree(opList);
}
d8582 2
a8583 15
void LgFrScenarioForSce::insertSupplyResponse(
			  SceDBLink & supply,
			  WitRun * const theWitRun,   // WIT environment   
			  const int nPeriods,         // Number of periods 
			  const int nParts,           // Number of parts   
			  char ** partList,           // List of part names
			  LgFrCalendar & theCal,
			  LgFrMultiPlantHelper & mpHelper)
{
  supply.nPeriods(nPeriods);
  
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
d8585 4
a8588 6
   int i, t, tt, ttt;
   float * gpdProdVol;
   int * totalGeoToPdfSourceIndicator = new int[nPeriods];
   int * geoToPdfSourceIndicator = new int[nPeriods];
   float * geoByPdfSupplyVol = new float[nPeriods];
   std::string * sourceList = new std::string[nPeriods];
d8590 10
d8601 15
a8615 6
   // Loop once for each part.  
   for ( i=0; i<nParts; i++ ) {
     // only look at geoPlannerDemandParts
     if (! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun,
						      partList[i], plannerPart, geo))
       continue;
d8617 1
a8617 4
     // initialize the total indicator vector to 0 for this GPD part
     for (t=0; t<nPeriods; t++) {
       totalGeoToPdfSourceIndicator[t] = 0;
     }
d8619 1
a8619 9
     // get the GeoSource Vector rule
     determineGeoToPdfSourceVector(theWitRun, 
				   mpHelper,
				   partList[i],
				   sourceList);
     
     
     // prodVol of the GPD part is equivalent to the shipVol (we hope)
     witGetPartProdVol(theWitRun, partList[i], &gpdProdVol);
d8621 1
a8621 6
     // now try to write out one vector for each possible geo->Pdf combo
     for (t=0; t<nPeriods; t++) {
       // if the total indicator vector is 1, then we've already reported this source
       if (totalGeoToPdfSourceIndicator[t] == 1)
	 continue;
       // otherwise, we found an unreported source
d8623 15
a8637 3
       // init the indicator vector for this part,pdf
       for (tt=0; tt<nPeriods; tt++)
	 geoToPdfSourceIndicator[tt] = 0;
d8639 2
a8640 3
       // mark period t as true for this source
       geoToPdfSourceIndicator[t] = 1;
       totalGeoToPdfSourceIndicator[t] = 1;
d8642 9
a8650 10
       // now loop over the rest of the horizon to see if
       // any other periods are sourced the same as period t.
       // mark each tt in both the total indicator and the local
       // one.
       for (tt=t+1; tt<nPeriods; tt++) {
	 if ((totalGeoToPdfSourceIndicator[tt] == 0) && (sourceList[tt] == sourceList[t])) {
	   totalGeoToPdfSourceIndicator[tt] = 1;
	   geoToPdfSourceIndicator[tt] = 1;
	 }
       }
d8652 4
a8655 5
       // ok, at this point the entire geoToPdfSourceIndicator vector
       // should be "populated".  So now we can report on the current
       // source.  (Note the source is sourceList[t] still.)
       mfgPart = mpHelper.partname(sourceList[t]);
       pdf = mpHelper.pdf(sourceList[t]);
d8657 12
d8670 3
a8672 12
       // multiply the total gpdProdVol by the indicator vector to get
       // the amount from this particular PDF.
       for (ttt=0; ttt<nPeriods; ttt++)       
	 geoByPdfSupplyVol[ttt] = gpdProdVol[ttt] * geoToPdfSourceIndicator[ttt];
       supply.insert(SceArgList()
		     << plannerPart
		     << geo
		     << mfgPart
		     << pdf
		     << SceMakeVec(geoByPdfSupplyVol, nPeriods));
     }
     witFree(gpdProdVol);
d8674 6
a8679 5
   }
   delete [] geoByPdfSupplyVol;
   delete [] totalGeoToPdfSourceIndicator;
   delete [] geoToPdfSourceIndicator;
   delete [] sourceList;
a8680 1
}
d8683 5
a8687 8
void LgFrScenarioForSce::insertPartPdfTotalDemand(
			 SceDBLink& demand,
			 WitRun * const theWitRun,   // WIT environment
			 LgFrSceBaseExploder * exploder,
			 const int nPeriods,         // Number of periods 
			 const int nParts,           // Number of parts   
			 char ** partList,           // List of part names
			 LgFrMultiPlantHelper & mpHelper)
d8689 24
a8712 10
  demand.nPeriods(nPeriods);

   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     float * mrpConsVol;
     if ( mpHelper.isPartNormal(theWitRun, partList[i])) {
       exploder->mrpConsVol(partList[i], &mrpConsVol);
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
a8713 7
       demand.insert(SceArgList()
		    << partname
		    << pdf
		    << SceMakeVec( mrpConsVol, nPeriods));
       witFree(mrpConsVol);
       }
   }
d8715 3
a8717 10
}

void LgFrScenarioForSce::insertPartPdfProdVol(
			  SceDBLink & prodVol,
			  WitRun * const theWitRun,   // WIT environment   
			  const int nPeriods,         // Number of periods 
			  const int nParts,           // Number of parts   
			  char ** partList,           // List of part names
			  LgFrCalendar & theCal,
			  LgFrMultiPlantHelper & mpHelper)
d8719 1
a8719 24
  prodVol.nPeriods(nPeriods);

   float * execVol;

   // Loop once for each part.  
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
     if (! mpHelper.isPartBuildable(theWitRun, partList[i]))
       continue;
     std::string partname = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);

     // note: the opeation is guaranteed to exist
     // by definition of isPartBuildable

     witGetOperationExecVol(theWitRun, partList[i], &execVol);

      prodVol.insert(SceArgList()
		     << partname
		     << pdf
		     << SceMakeVec(execVol, nPeriods));

     witFree(execVol); 
   }
d8722 3
a8724 7
void LgFrScenarioForSce::insertPartPdfSupplyVol(
		     SceDBLink& supplyVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
d8726 1
a8726 54
  supplyVol.nPeriods(nPeriods);

  float * witVector;
  witAttr category;
  witBoolean operationExists;
  int  npBops;
  
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {

    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;

    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;

    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);

    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    

    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
     
    // supplyVol
    if (siteCustomization == "eca") {
      witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
      supplyVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName)
		       << mpHelper.pdf(fullPartName)
		       << SceMakeVec(witVector, nPeriods));
      witFree(witVector);
    }
    else {
      witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	supplyVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName)
		       << mpHelper.pdf(fullPartName)
		       << SceMakeVec(witVector, nPeriods));
      }
      witFree(witVector);
    }
  }
  
d8730 8
d8739 2
a8740 7
void LgFrScenarioForSce::insertPartPdfCycleTime(
		     SceDBLink& cycle,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
d8742 3
a8744 1
   cycle.nPeriods(nPeriods);
d8746 18
a8763 11
  float * witVector;
  witAttr category;
  witBoolean operationExists;
  int  npBops;
  
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
a8764 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d8766 6
a8771 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
d8773 16
a8788 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8790 5
a8794 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
d8796 25
a8820 8
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists); 
     // CycleTime
    if (category == WitPRODUCT) {
      // FINISH_ME: This si a temprorary stopgap for maintaining
      // backward compatability.  In 1.30/1.31, the (eca) user's only
      // way of finding out what were true PCF parts was via
      // cycleTime=-1.  This needs to be worked out, but is OK for now.
a8821 3
      // get the "real" cycleTime in any case
      float * cycleTime;
      witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);
d8823 2
a8824 41
      // if the part is a PCF, then use partAppData and
      // unConstrainedStartPeriod to set those periods to -1,
      // after that pick up the cycleTime vector for real
      // eventually, we need to get rid of cycleTime altogether
      // or use an appData for it.
      if (mpHelper.isPartPcf(theWitRun, fullPartName)) {
	float * phonyCycleTime = new float[nPeriods];
	LgFrScePartAppData * appDataPtr;
	witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
	assert(appDataPtr != 0);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
	  phonyCycleTime[tt] = -1.0;
	for (tt=appDataPtr->unConstrainedStartPeriod(); tt<nPeriods; tt++)
	  phonyCycleTime[tt] = cycleTime[tt];
	if (this->flatFileMgr_.isFloatVecNonZero(phonyCycleTime, nPeriods)) {
	  cycle.insert(SceArgList()
		       << mpHelper.partname(fullPartName)
		       << mpHelper.pdf(fullPartName)
		       << SceMakeVec(phonyCycleTime, nPeriods));
	}
	delete [] phonyCycleTime;
      }
      else if (this->flatFileMgr_.isFloatVecNonZero(cycleTime, nPeriods)) {
	cycle.insert(SceArgList()
		       << mpHelper.partname(fullPartName)
		       << mpHelper.pdf(fullPartName)
		       << SceMakeVec(cycleTime, nPeriods));
      }
      witFree(cycleTime);
    }
  }
}
 
void LgFrScenarioForSce::insertPartPdfMrpConsVol(
		     SceDBLink& mrpConsVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
d8826 2
d8829 3
a8831 1
  mrpConsVol.nPeriods(nPeriods);
d8833 5
a8837 1
  float * witVector;
d8839 16
a8854 4
  witAttr category;
  witBoolean operationExists;
  int npBops;
  LgFrSceBaseExploder * myExploder = this->exploder();          
d8856 17
a8872 4
 
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8874 8
a8881 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
a8882 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
d8884 8
a8891 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8893 12
a8904 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
d8906 5
a8910 2
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);  
d8912 7
a8918 10
     // mrpConsVol
    myExploder->mrpConsVol(partList[i], &witVector);
    if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
      mrpConsVol.insert(SceArgList()
			<< mpHelper.partname(fullPartName)
			<< mpHelper.pdf(fullPartName)
			<< SceMakeVec(witVector, nPeriods));
    }
    witFree(witVector);
  }
d8920 2
a8923 19
void LgFrScenarioForSce::insertPartPdfReqVolAndMrpExcessVolAndMrpRequirements(
		     SceDBLink& req,
		     SceDBLink& excessVol,
		     SceDBLink& mrpRequirements,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
  req.nPeriods(nPeriods);
  excessVol.nPeriods(nPeriods);
  mrpRequirements.nPeriods(nPeriods);
  
  float * reqVol;
  float * mrpExcessVol;      
  witAttr category;
  witBoolean operationExists;
  int npBops;
a8924 1
  LgFrSceBaseExploder * myExploder = this->exploder();          
d8926 4
a8929 3
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8931 1
a8931 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d8933 1
a8933 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
a8934 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
a8935 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
d8937 1
a8937 2
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8939 1
d8941 4
a8944 8
    // reqVol
    myExploder->reqVol(partList[i], &reqVol);
    if (this->flatFileMgr_.isFloatVecNonZero(reqVol, nPeriods)) {
      req.insert(SceArgList()
		 << mpHelper.partname(fullPartName)
		 << mpHelper.pdf(fullPartName)
		 << SceMakeVec(reqVol, nPeriods));
    }
d8946 15
a8960 7
    // mrpExcessVol
    myExploder->mrpExcessVol(partList[i], &mrpExcessVol);
    if (this->flatFileMgr_.isFloatVecNonZero(mrpExcessVol, nPeriods)) {
      excessVol.insert(SceArgList()
		 << mpHelper.partname(fullPartName)
		 << mpHelper.pdf(fullPartName)
		 << SceMakeVec(mrpExcessVol, nPeriods));
d8963 8
a8970 4
    // mrpRequirements
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
      reqVol[t] -= mrpExcessVol[t];
d8972 7
a8978 5
    if (this->flatFileMgr_.isFloatVecNonZero(reqVol, nPeriods)) {
       mrpRequirements.insert(SceArgList()
		 << mpHelper.partname(fullPartName)
		 << mpHelper.pdf(fullPartName)
		 << SceMakeVec(reqVol, nPeriods));
a8979 5
     
    witFree(reqVol);
    witFree(mrpExcessVol);
  }
}
d8981 8
a8988 9
void LgFrScenarioForSce::insertPartPdfMrpProdVol(
		     SceDBLink& mrpProdVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
}
a8989 18
void LgFrScenarioForSce::insertPartPdfExcessVol(
		     SceDBLink& excessVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
  excessVol.nPeriods(nPeriods);
  
  float * witVector;
  witAttr category;
  witBoolean operationExists;
  int npBops;
  
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  LgFrSceBaseExploder * myExploder = this->exploder();          
  bool doImplode = setOfParameters.getBool("doImplode");
d8991 8
a8998 3
   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d9000 12
a9011 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d9013 4
a9016 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
a9017 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
a9018 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
a9019 4
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
  
    if (doImplode) {
a9020 12
      // ExcessVol
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	excessVol.insert(SceArgList()
		       << mpHelper.partname(fullPartName)
		       << mpHelper.pdf(fullPartName)
		       << SceMakeVec(witVector, nPeriods));
      }
      witFree(witVector);
    }
  }
}
a9021 8
void LgFrScenarioForSce::insertPartPdfStockVol(
		     SceDBLink& stockVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
d9023 5
a9027 4
  stockVol.nPeriods(nPeriods);
   float * witVector;
   witAttr category;
   witBoolean operationExists;
a9028 1
  int npBops;
a9029 2
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d9031 1
a9031 4
  
  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
a9032 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
a9033 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
a9034 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
a9035 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
a9036 28
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
     
	// stockVol
    if (siteCustomization == "eca") {     
	if (category != WitCAPACITY) {
	  witGetPartStockVol(theWitRun, fullPartName.c_str(), &witVector);
	  stockVol.insert(SceArgList()
		      << mpHelper.partname(fullPartName)
		      << mpHelper.pdf(fullPartName)
		      << SceMakeVec( witVector, nPeriods));
	  witFree(witVector);
	}
      }
      else {
	if (category != WitCAPACITY) {
	  witGetPartStockVol(theWitRun, fullPartName.c_str(), &witVector);
	  if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	    stockVol.insert(SceArgList()
		      << mpHelper.partname(fullPartName)
		      << mpHelper.pdf(fullPartName)
		      << SceMakeVec( witVector, nPeriods));
	  }
	  witFree(witVector);
	}
      }
  }
}
d9038 3
a9040 7
void LgFrScenarioForSce::insertPartPdfScrapVol(
		     SceDBLink& scrapVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
d9042 1
a9042 1
  scrapVol.nPeriods(nPeriods);
d9044 1
a9044 9
  float * witVector;
  witAttr category;
  witBoolean operationExists;
  int npBops;
  
 
   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d9046 1
a9046 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d9048 5
a9052 23
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;

    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);

    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    

    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
      // scrapVol
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	scrapVol.insert(SceArgList()
		      << mpHelper.partname(fullPartName)
		      << mpHelper.pdf(fullPartName)
		      << SceMakeVec(witVector, nPeriods));
      }
      witFree(witVector);
d9055 3
a9057 1
}
d9059 30
a9088 9
void LgFrScenarioForSce::insertPartPdfConsVol(
		     SceDBLink& consVol,
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
  consVol.nPeriods(nPeriods);
d9090 8
a9097 9
  float * witVector;
  witAttr category;
  witBoolean operationExists;
  int npBops;
  
 
   // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
a9098 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d9100 8
a9107 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
d9109 12
a9120 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d9122 4
a9125 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
a9126 14
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists); 
      // consVol
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
      if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	consVol.insert(SceArgList()
		     << mpHelper.partname(fullPartName)
		     << mpHelper.pdf(fullPartName)
		     << SceMakeVec( witVector, nPeriods));
      }
      witFree(witVector);
  }
  
}
d9128 1
a9128 11
void  LgFrScenarioForSce::updateAttrFromPartDataBaseDump(
		     WitRun * const theWitRun,   
		     const int nPeriods,  
		     const int nParts,    
		     char ** partList,     
		     LgFrMultiPlantHelper & mpHelper)
{
  // SceDemandDB demandDB;
  ScePartPdfDB partPdfDB;
  //  SceDBLink demand(demandDB);
  SceDBLink partPdf(partPdfDB);
d9130 4
a9133 2
  // demand.nPeriods(nPeriods);
  partPdf.nPeriods(nPeriods);
d9135 3
a9137 6
  float * witVector;
  float * reqVol;
  float * mrpExcessVol;      
  float * mrpResidualVol;      
  witAttr category;
  witBoolean operationExists;
a9138 1
  int i, p, b, npBops;
a9139 3
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  LgFrSceBaseExploder * myExploder = this->exploder();          
a9140 1
  bool doImplode = setOfParameters.getBool("doImplode");
d9142 7
d9150 9
a9158 23
  //  - all the execVol stuff...
  float * mrpProdVol;
  float * bldVol;
  float * mrpBldVol;
  float * userOpVol;
  float * mrpUserOpVol;    
  float * intPlVol;
  float * mrpIntPlVol;
  float * deAggVol;
  float * mrpDeAggVol;
  
  mrpProdVol   = new float[nPeriods];  
  bldVol       = new float[nPeriods];  
  mrpBldVol    = new float[nPeriods];    
  userOpVol    = new float[nPeriods];
  mrpUserOpVol = new float[nPeriods];    
  intPlVol     = new float[nPeriods];
  mrpIntPlVol  = new float[nPeriods];    
  deAggVol     = new float[nPeriods];
  mrpDeAggVol  = new float[nPeriods];    
  
   // Loop once for each part.  
  for (i=0; i<nParts; i++ ) {
a9159 3
    std::string fullPartName(partList[i]);
    if (! mpHelper.isPartNormal(theWitRun, fullPartName))
      continue;
d9161 23
a9183 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
d9185 6
a9190 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d9192 2
a9193 5
    // Get some info about the parts
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
    int nUserDefinedOps = mpHelper.nUserDefinedOps(theWitRun, fullPartName);
    int nInterplantOps = mpHelper.nInterplantOps(theWitRun, fullPartName);
    int nAggregationOps = mpHelper.nAggregationOps(theWitRun, fullPartName);    
d9195 2
a9196 2
    // See if the default operation exists for this part
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);
d9198 7
d9206 1
a9206 24
     // Now report on all the execVol types:
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, deAggVol, userOpVol
    
    if (npBops > 0) {
      // first intialize the vectors to zero
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	mrpProdVol[t] = 0.0;
	mrpBldVol[t] = 0.0;
	bldVol[t] = 0.0;
	if (nUserDefinedOps) {
	  userOpVol[t] = 0;
	  mrpUserOpVol[t] = 0;
	}
	if (nInterplantOps) {
	  intPlVol[t] = 0.0;
	  mrpIntPlVol[t] = 0.0;
	}
	if (nAggregationOps) {
	  deAggVol[t] = 0.0;
	  mrpDeAggVol[t] = 0.0;
	}
      }
d9208 4
a9211 5
 
      // loop through each of the bop entries and get the execVol once for each
      // bop entry (this is a bit inefficient, but too bad).
      for (p=0; p<npBops; p++) {
        bool foundOpCategory = false;          
d9213 4
a9216 75
          
        std::string cp1, pdf1, sp2, pdf2;
        int early, late;
        float  prodRate;
        char * witOperationName;
        float * tempExecVol;
        float * tempMrpExecVol;
        float * yieldRate;
        float * mrpYieldRate;        
          
          
        witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
        std::string operationName(witOperationName);
        witGetBopEntryProdRate(theWitRun, witOperationName, b, &prodRate);
        witGetBopEntryEarliestPeriod(theWitRun, witOperationName, b, &early);
        witGetBopEntryLatestPeriod(theWitRun, witOperationName, b, &late);
        myExploder->mrpExecVol(witOperationName, &tempMrpExecVol);          
        witGetOperationExecVol(theWitRun, witOperationName, &tempExecVol);
        witGetOperationYieldRate(theWitRun, witOperationName, &yieldRate);
        witGetOperationYieldRate(myExploder->localWitRun(), witOperationName, &mrpYieldRate);        

        // Is it the default Operation
        if (operationName == fullPartName) {
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
            bldVol[t]     += yieldRate[t] * tempExecVol[t];
            mrpBldVol[t]  += mrpYieldRate[t] * tempMrpExecVol[t];
          }
          foundOpCategory = true;

        }
          
        // is it an Interplant Operation ?
        if (! foundOpCategory
            && nInterplantOps
            && mpHelper.isOperationSpecialInterplant(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
            intPlVol[t]    += prodRate * tempExecVol[t];
            mrpIntPlVol[t] += prodRate * tempMrpExecVol[t];
          }
          foundOpCategory = true;
        }

        // is it an Aggreration Operation ?
        if (! foundOpCategory
            && nAggregationOps
            && mpHelper.isOperationSpecialAggregation(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
            deAggVol[t]    += prodRate * yieldRate[t] * tempExecVol[t];
            mrpDeAggVol[t] += prodRate * mrpYieldRate[t] * tempMrpExecVol[t];
          }
          foundOpCategory = true;
        }

        // is it a UserDefined Operation (it must be, at this point)
        if (! foundOpCategory
            && nUserDefinedOps) {
          int * impactPeriod;
          int * mrpImpactPeriod;          
          witGetBopEntryImpactPeriod(theWitRun, witOperationName, b, &impactPeriod);
          witGetBopEntryImpactPeriod(myExploder->localWitRun(), witOperationName, b, &mrpImpactPeriod);
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
            if (impactPeriod[t] > -1)
              userOpVol[impactPeriod[t]]       += yieldRate[t] * prodRate * tempExecVol[t];
            if (mrpImpactPeriod[t] > -1)            
              mrpUserOpVol[mrpImpactPeriod[t]] += mrpYieldRate[t] * prodRate * tempMrpExecVol[t];
          }
        
          witFree(impactPeriod);
          witFree(mrpImpactPeriod);
          foundOpCategory = true;
        }
d9218 24
a9241 117
        // Now assert that the operation resolved into exactly one of the types!!
	if (! foundOpCategory) {
	  std::cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<std::endl;
	}
	assert(foundOpCategory);

	// clean-up the memory for this bop
	witFree(witOperationName);
	witFree(tempExecVol);
	witFree(tempMrpExecVol);
	witFree(yieldRate);
	witFree(mrpYieldRate);        
      }

      for (t=0; t<nPeriods; t++) {
	mrpProdVol[t] = mrpBldVol[t];
	if (nUserDefinedOps) 
	  mrpProdVol[t] += mrpUserOpVol[t];
	if (nInterplantOps) 
	  mrpProdVol[t] += mrpIntPlVol[t];
	if (nAggregationOps) 
	  mrpProdVol[t] += mrpDeAggVol[t];
      }
	
      // print the bastards
      if (npBops > 0) {
	if (this->flatFileMgr_.isFloatVecNonZero(mrpProdVol, nPeriods)) {
	  //     outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //             << mpHelper.pdf(fullPartName) << "\",";
	  //    outFile << "\"mrpProdVol\"";
	  //     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpProdVol, 0, 15);
	}
	
	if (this->flatFileMgr_.isFloatVecNonZero(mrpBldVol, nPeriods)) {
	  // outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //       << mpHelper.pdf(fullPartName) << "\",";
	  // outFile << "\"mrpBldVol\"";
	  // flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpBldVol, 0, 15);
	}
      }
      
      if (nInterplantOps) {
	if (this->flatFileMgr_.isFloatVecNonZero(mrpIntPlVol, nPeriods)) {
	  // outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //         << mpHelper.pdf(fullPartName) << "\",";
	  //  outFile << "\"mrpIntPlVol\"";
	  //  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpIntPlVol, 0, 15);
	}
      }

      if (nAggregationOps) {
	if (this->flatFileMgr_.isFloatVecNonZero(mrpDeAggVol, nPeriods)) {
	  //  outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //          << mpHelper.pdf(fullPartName) << "\",";
	  //  outFile << "\"mrpDeAggVol\"";
	  //  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpDeAggVol, 0, 15);
	}
      }

      if (nUserDefinedOps) {
	if (this->flatFileMgr_.isFloatVecNonZero(mrpUserOpVol, nPeriods)) {
	  // outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //         << mpHelper.pdf(fullPartName) << "\",";
	  //  outFile << "\"mrpUserOpVol\"";
	  //  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpUserOpVol, 0, 15);
	}
      }

       if (doImplode) {        

	if (npBops > 0) {
	  // ProdVol
	  witGetPartProdVol(theWitRun, fullPartName.c_str(),  &witVector);
	  if (this->flatFileMgr_.isFloatVecNonZero(witVector, nPeriods)) {
	    //  outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	    //        << mpHelper.pdf(fullPartName) << "\",";
		    //   outFile << "\"prodVol\"";
	    //  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, witVector, 0, 15);
	    partPdf.insert(SceArgList()
		     << mpHelper.partname(fullPartName)
		     << mpHelper.pdf(fullPartName)
		     << SceMakeVec(witVector, nPeriods));
	  }
	  witFree(witVector);
	
	if (this->flatFileMgr_.isFloatVecNonZero(bldVol, nPeriods)) {
	  // outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	  //       << mpHelper.pdf(fullPartName) << "\",";
	  // outFile << "\"bldVol\"";
	  // flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, bldVol, 0, 15);
 
	  //demand.insert(SceArgList()
	  //   << mpHelper.partname(fullPartName)
	  //   << mpHelper.pdf(fullPartName)
	  //   << SceMakeVec(bldVol, nPeriods));
	}
	}

	if (nInterplantOps) {
	  if (this->flatFileMgr_.isFloatVecNonZero(intPlVol, nPeriods)) {
	    //  outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	    //       << mpHelper.pdf(fullPartName) << "\",";
	    //outFile << "\"intPlVol\"";
	    // flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, intPlVol, 0, 15);

	  }
	}
	
	if (nAggregationOps) {
	  if (this->flatFileMgr_.isFloatVecNonZero(deAggVol, nPeriods)) {
	    //outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	    //       << mpHelper.pdf(fullPartName) << "\",";
	    //outFile << "\"deAggVol\"";
	    //flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, deAggVol, 0, 15);
	  }
	}
a9242 15
	if (nUserDefinedOps) {
	  if (this->flatFileMgr_.isFloatVecNonZero(userOpVol, nPeriods)) {
	    //outFile << "\"" << mpHelper.partname(fullPartName) << "\",\""
	    //       << mpHelper.pdf(fullPartName) << "\",";
	    // outFile << "\"userOpVol\"";
	    // flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, userOpVol, 0, 15);
	  }
	}
       }
	
    }  
  }
  // demand.update("backlogVol");
  partPdf.update("prodVol");
}
a9243 1
#endif
@


1.63
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@d41 1
a41 1
#include <sce/src/sceAlMrp.h>
d379 1
d1247 1
a1247 1
       appDataPtr = new LgFrScePartAppData;
a6295 49
 int
LgFrScenarioForSce::allocatedMrp()
{
  std::string allocMrpSeparatorChar("#");
  LgFrSceAllocatedMrp allocMrpMgr(lastProblemSolved().witRun(), 
				  &multiPlantHelper(),
				  allocMrpSeparatorChar[0],
				  &setOfParameters());

  int rc = allocMrpMgr.computeAndPopulate(setOfParameters().getInt("allocatedMrpVersion"));

  if (rc == 4) {
    // new message saying that warnings occurred with allocatedMrp.
    // continuing anyway
  }

  if (rc == 8) {
    // new message saying that errors occurred with allocatedMrp.
    // terminating program.
    exit(8);
  }

  std::string allocatedMrpFileName =
    setOfParameters().getString("allocatedMrpFileName");

  // we need two output files (potentially), The amrp output filename for Independent
  // demand types only gets a value if there is an input file for indepenpdent demands
  std::string allocatedIndepMrpFileName("");
  if (! setOfParameters().getString("independentDemandFile").empty())
    allocatedIndepMrpFileName = setOfParameters().getString("allocatedIndepMrpFileName");

 rc = allocMrpMgr.scePrint(allocatedMrpFileName, allocatedIndepMrpFileName);

  if (rc == 4) {
    // new message saying that warnings occurred with allocatedMrp.
    // continuing anyway
  }

  if (rc == 8) {
    // new message saying that errors occurred with allocatedMrp.
    // terminating program.
    exit(8);
  }


  return 0;
}


d7804 1
a7804 1
      appDataPtr = new LgFrScePartAppData;
d8228 216
a8450 1
    std::cout << "Deleting scenario's witRun, AppData Clones:   ogjItrState is not WitINACTIVE.   Resetting ObjItr" << std::endl;
d8536 3
@


1.62
log
@some SCE 6 enhancements for 1/23 Beta release
@
text
@d6631 1
d6642 3
d6658 1
d6661 2
@


1.61
log
@Last commit for maxForAtp
@
text
@d55 1
a55 1

d121 1
a121 3



d184 1
a184 1

d198 3
d208 3
a211 1

a214 1

a218 3



d275 2
d279 3
a281 4
       outFile << "\"" 
	       << partname << "\",\"" 
	       << pdf << "\"";
       flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, mrpConsVol, 0, 15);
a293 4




a297 2


a300 2


d304 1
a304 2


d366 1
a366 2


d481 1
d484 1
a484 1
  if (useSmartExplodeUtility && (! subBomFile.empty()))   {
d499 2
d502 1
a502 1
  if (useSmartExplodeUtility && (! opSubBomFile.empty()))   {
d590 1
a590 1

d596 1
a596 1

d603 1
a603 1

d610 1
a610 1
  
d616 1
a616 1

d622 1
a622 1

d630 1
d637 1
a637 1

a2212 247
#if 0
//  ---------------------------------------------------------------------
//  Print Substitute Prod vols
//  Note: this does not write  subs off of userDefined operations
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printSubstituteProductionVolume(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  witAttr category;
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Substitute Usage Volume File" 
		       << fileName);
  }


  long numRecords = 0;

  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPartName  = partList[i];

    // if the part is any sort of special part, then skip it.
    if (! mpHelper.isPartNormal(theWitRun, fullWitPartName))
      continue;
    witGetPartCategory(theWitRun, fullWitPartName.c_str(), &category);
    if (category != WitPRODUCT)
      continue;
    
    int nBom;
    witGetPartNBomEntries(theWitRun, fullWitPartName.c_str(), &nBom);

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  float * subProdVol;
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, sj, &sub);
	  if (mpHelper.isPartSpecialNullSubstitute(theWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  std::string subPartname =  mpHelper.partname(sub);
	  std::string subPdf =  mpHelper.pdf(sub);
		   
	  witGetSubsBomEntryProdVol(theWitRun, partList[i], j, sj, &subProdVol);
	  std::string parentPartname = mpHelper.partname(fullWitPartName);
	  outFile << "\"" << parentPartname << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << subPdf  << "\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subProdVol, 0, 15);
	  numRecords++;
	  witFree(sub);
	  witFree(subProdVol);
	}
	witFree(child);
      }
    }

  }

  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}



//  ---------------------------------------------------------------------
//  Print Mrp Substitute Prod vols
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printMrpSubstituteProductionVolume(
	 WitRun * const theWitRun,   // the main witrun
	 const int nPeriods,         // Number of periods 
	 const int nParts,           // Number of parts   
	 char ** partList,           // List of part names
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::string partName;
  witAttr category;

  LgFrSceBaseExploder * myExploder = this->exploder();
  
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "MRP Substitute Usage Volume" 
		       << fileName);
  }


  long numRecords = 0;

  // Loop once for each part.  
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPartName  = partList[i];

    // if the part is any sort of special part, then skip it.
    if (! mpHelper.isPartNormal(theWitRun, fullWitPartName))
      continue;
    witGetPartCategory(theWitRun, fullWitPartName.c_str(), &category);
    if (category != WitPRODUCT)
      continue;
    
    int nBom;
    witGetPartNBomEntries(theWitRun, fullWitPartName.c_str(), &nBom);

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  float * subProdVol;
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, sj, &sub);
	  if (mpHelper.isPartSpecialNullSubstitute(theWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  std::string subPartname =  mpHelper.partname(sub);
	  std::string subPdf =  mpHelper.pdf(sub);

	  myExploder->subUsageVol(partList[i], j, sj, &subProdVol);
	  std::string parentPartname = mpHelper.partname(fullWitPartName);
	  outFile << "\"" << parentPartname << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << subPdf  << "\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subProdVol, 0, 15);
	  numRecords++;
	  witFree(sub);
	  witFree(subProdVol);
	}
	witFree(child);
      }
    }

  }

  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}


//  ---------------------------------------------------------------------
//  Print Substitute Prod vols
//  Note: this does not write  subs off of userDefined operations
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printOpSubstituteProductionVolume(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 const int nOperations, 
	 char ** opList,        
	 std::string fileName,
	 LgFrCalendar & theCal,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
		       << "Operation Substitute Usage Volume File" 
		       << fileName);
  }


  long numRecords = 0;
  std::string parentOperationName;
  std::string pdf;

  // Loop once for each operation
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];

    // if the operation is NOT "user-defined" then skip it.
    if (! mpHelper.isOperationUserDefined(theWitRun, fullWitOperationName, pdf, parentOperationName))
      continue;

    
    int nBom;
    witGetOperationNBomEntries(theWitRun, fullWitOperationName.c_str(), &nBom);

    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      int nSubBom;
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitOperationName.c_str(), j, &nSubBom);
      if (nSubBom > 0)   {
	char * child;
	witGetBomEntryConsumedPart(theWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
	  char * sub;
	  float * subProdVol;
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitOperationName.c_str(), j, sj, &sub);
	  if (! mpHelper.isPartNormal(theWitRun, sub)) {
	    witFree(sub);
	    continue;
	  }
	  std::string subPartname =  mpHelper.partname(sub);
		   
	  witGetSubsBomEntryProdVol(theWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
	  outFile << "\"" << parentOperationName << "\",\"" 
		  << childPartname << "\",\""
		  << subPartname << "\",\""
		  << pdf  << "\"";
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subProdVol, 0, 15);
	  numRecords++;
	  witFree(sub);
	  witFree(subProdVol);
	}
	witFree(child);
      }
    }

  }

  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords);
}
#endif
d3932 2
d3935 28
a3962 19

   // Loop once for each part.  
   int i = 0; 
   for (i=0; i<theCritList.getLength(); i++ ) {
     std::string part = theCritList.getPart(i);
     int pd = theCritList.getPeriod(i);
     if (! mpHelper.isPartNormal(theWitRun, part))
       continue;
     std::string partname = mpHelper.partname(part);
     std::string pdf = mpHelper.pdf(part);
     outFile << "\"" 
	     << partname << "\",\"" 
	     << pdf << "\","
	     << pd << ","
	     << i << "\n";
     numRecords++;
   }
   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
d3967 1
a3967 1
//  Print critical parts list
d3975 1
d4122 20
a4141 8
      outFileIndp << "\"" << demandedPartName << "\","
		  << "\"" << demandedPdf << "\","
		  << "\"" << demandedCust << "\","
		  << "\"" << critpartname << "\","
		  << "\"" << critpdf << "\","
		  << shipPerList[i] << ","
		  << critPerList[i] << ","
		  << i << "\n";
d4316 2
a4317 3
    if (! independentDemandFile.empty())   {
      std::string indepSupplyResponseFileName =
	setOfParameters.getString("indepSupplyResponseFileName");
d4325 1
a4325 2
      std::string geoSupplyByPdfFileName =
	setOfParameters.getString("geoSupplyByPdfFileName");
d4330 3
a4332 4
    if (siteCustomization != "skipTheCrapola") {  
      // Backlog Response File: mandatory file
      std::string backlogResponseFileName =
	setOfParameters.getString("backlogResponseFileName");
d4341 1
a4341 2
      std::string criticalListFileName =
	setOfParameters.getString("criticalListFileName");
d4349 2
a4350 4
      std::string peggedCriticalListFileName =
	setOfParameters.getString("peggedCritListFileName");
      std::string iPeggedCriticalListFileName =
	setOfParameters.getString("iPeggedCritListFileName");
d4355 1
d4361 1
a4361 1
    if (siteCustomization != "skipTheCrapola") {
d4372 1
a4372 1
    if (siteCustomization != "skipTheCrapola") {
d4375 1
a4375 2
	std::string interplantOrdersFileName =
	  setOfParameters.getString("interplantOrdersFileName");
d4419 1
a4419 1
    if (siteCustomization != "skipTheCrapola") {
d4432 1
a4432 2
    bool printCapacityUsageFile = setOfParameters.getBool("printCapacityUsageFile");    
    if (printCapacityUsageFile)   {
d4436 1
a4436 1

d4454 1
a4454 5




    // Substitute Usage Volume File: mandatory file
d4456 1
a4456 1
    if (! subBomFile.empty())   {
d4468 1
a4468 2
    // Operation Substitute Usage Volume File: mandatory file
    // (prints only when there is Op substitute  input data)
d4470 1
a4470 1
    if (! opSubBomFile.empty())   {
d4574 8
a4582 5
   // Problem Statistics Summary File: mandatory
   std::string problemStatisticsFileName =
     setOfParameters.getString("problemStatisticsFileName");
   printOverallProblemStatistics(theWitRun, mpHelper, nPeriods, nParts, partList,
				 problemStatisticsFileName);
d4584 10
a4593 10


   // Objective Summary Report: mandatory
   std::string objectiveSummaryFileName =
     setOfParameters.getString("objectiveSummaryFileName");
   printOverallOptimizationValues(theWitRun, nPeriods, nParts, partList, engine,
				  objectiveSummaryFileName);

   // Cleanup memory
   for ( i=0; i<nParts; i++) 
d4595 4
a4598 4
   witFree( partList );

   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++) 
d4600 1
a4600 1
   witFree( opList );
d5988 8
a5995 10
	  
	  idIpPIPFile << "\""
		      << mpHelper.partname(fullWitDemandedPart) << "\",\""
		      << mpHelper.pdf(fullWitDemandedPart)      << "\",\""
		      << demandId << "\",\""
		      << pn1 << "\",\""
		      << customerPdf << "\",\""
		      << pn2 << "\",\""
		      << supplierPdf << "\"";
	  flatFileMgr_.writeCsvFloatVector(idIpPIPFile, nPeriods, PIPTV.data(), 0, 15);
@


1.60
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@d141 1
a141 1
  std::cout << "HeuristicSearchIncrement: isItAbosluteInc=" << isItAbosluteInc << std::endl;
a173 1
	witFree(demandList[j]);
d175 2
d302 1
a302 1
  // FINISH_ME: use the explosionFactory!!!
a305 2
    //    exploderPtr_ = this->createAppropriateSceExploder(scenSceSP);
    //    exploderPtr_ = this->createAppropriateSceExploder();
a372 2


@


1.59
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d4944 1
d4948 4
a5120 1

d5123 1
d5125 3
a5127 9
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5207 1
d5215 6
d5303 4
a5306 7
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5384 4
a5387 9
	  
	  //  write the PIPConsVol record: PIPConsVol
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5466 4
a5469 7
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5549 4
a5552 7
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5631 4
a5634 7
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5713 5
a5717 8
	  //  write the PIPConsVol record: PIPConsVol
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5884 3
a5886 8
	  
	  //  write the total Demand due to Focus: FSSReq
	  pvPIPFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(pvPIPFile, nPeriods, PIPTV.data(), 0, 15);
d5973 4
a5976 8
	  //  write the PIPConsVol record: PIPConsVol
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
d6137 1
a6137 1
	  
d6146 6
a7388 1
      flatFileMgr_.writeDbDumpRecord(theCal, pn, pdf, "mrpStockVol", mrpStockVol.data(), outFile, nPeriods, alwaysPrint);
d7421 3
@


1.58
log
@Version 5.  initial commit
@
text
@a3898 9
#ifdef MULTI_ATTRIBUTE_DEMAND_CLASS
	outFile << "\"" << partname << "\",\"" 
		<< pdf << "\",\"" 
		<< customerKeyExpansion(dList[j]) << "\"";
#else
	outFile << "\"" << partname << "\",\"" 
		<< pdf << "\",\"" 
		<< dList[j] << "\"";
#endif
d3918 4
a3921 1
	flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, shipVol, 0, 15);
d3941 1
a3941 1
  std::string geoSeparator = "%";
a6766 1

d6775 1
d7404 5
a7408 5
      printDbDumpRec(pn, pdf, "witMrpConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "witMrpStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "mrpStockVol", mrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "mrpNegDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "witMrpExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);
d7411 4
a7414 4
      printDbDumpRec(pn, pdf, "witConsVol", witMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "witStockVol", witMrpStockVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "negDemandStockVol", mrpNegDemandStockVol.data(), outFile, nPeriods, alwaysPrint);
      printDbDumpRec(pn, pdf, "witExcessVol", witMrpExcessVol, outFile, nPeriods, alwaysPrint);
d7421 1
a7421 1
    numRecords += printDbDumpRec(pn, pdf, "supplyVol", supplyVolSpecifiedByUser, outFile, nPeriods, alwaysPrintForECAonly);
d7424 1
a7424 1
      numRecords += printDbDumpRec(pn, pdf, "negDemVol", negDemVol.data(), outFile, nPeriods, alwaysPrint);
d7427 1
a7427 1
      numRecords += printDbDumpRec(pn, pdf, "cycleTime", cycleTime, outFile, nPeriods, nonZeroOnly);
d7429 1
a7429 1
    numRecords += printDbDumpRec(pn, pdf, "mrpConsVol", mrpConsVol, outFile, nPeriods, nonZeroOnly);
d7432 1
a7432 1
      numRecords += printDbDumpRec(pn, pdf, "negDemMrpConsVol", negDemMrpConsVol.data(), outFile, nPeriods, alwaysPrint);
d7436 4
a7439 4
    numRecords += printDbDumpRec(pn, pdf, "reqVol", reqVol, outFile, nPeriods, nonZeroOnly);
    numRecords += printDbDumpRec(pn, pdf, "mrpExcessVol", mrpExcessVol.data(), outFile, nPeriods, nonZeroOnly);
    numRecords += printDbDumpRec(pn, pdf, "mrpResidualVol", mrpResidualVol.data(), outFile, nPeriods, nonZeroOnly);
    numRecords += printDbDumpRec(pn, pdf, "mrpRequirements", mrpRequirementsVol.data(), outFile, nPeriods, nonZeroOnly);
d7442 2
a7443 2
      numRecords += printDbDumpRecBool(pn, pdf, "execFlag", execFlag, outFile, nPeriods);
      numRecords += printDbDumpRec(pn, pdf, "yield", yieldRate, outFile, nPeriods, alwaysPrint);
d7450 2
a7451 2
      numRecords += printDbDumpRec(pn, pdf, "mrpProdVol", mrpProdVol, outFile, nPeriods, nonZeroOnly);
      numRecords += printDbDumpRec(pn, pdf, "mrpBldVol", mrpBldVol, outFile, nPeriods, nonZeroOnly);
d7453 2
a7454 2
	numRecords += printDbDumpRec(pn, pdf, "mrpIntPlVol", mrpIntPlVol, outFile, nPeriods, nonZeroOnly);
      numRecords += printDbDumpRec(pn, pdf, "mrpAltVol", mrpAltVol, outFile, nPeriods, nonZeroOnly);
d7456 1
a7456 1
	numRecords += printDbDumpRec(pn, pdf, "mrpDeAggVol", mrpDeAggVol, outFile, nPeriods, nonZeroOnly);
d7458 1
a7458 1
	numRecords += printDbDumpRec(pn, pdf, "mrpUserOpVol", mrpUserOpVol, outFile, nPeriods, nonZeroOnly);
d7461 2
a7462 2
	numRecords += printDbDumpRec(pn, pdf, "prodVol", prodVol, outFile, nPeriods, nonZeroOnly);
	numRecords += printDbDumpRec(pn, pdf, "bldVol", bldVol, outFile, nPeriods, nonZeroOnly);
d7464 2
a7465 2
	  numRecords += printDbDumpRec(pn, pdf, "intPlVol", intPlVol, outFile, nPeriods, nonZeroOnly);
	numRecords += printDbDumpRec(pn, pdf, "altVol", altVol, outFile, nPeriods, nonZeroOnly);
d7467 1
a7467 1
	  numRecords += printDbDumpRec(pn, pdf, "deAggVol", deAggVol, outFile, nPeriods, nonZeroOnly);
d7469 1
a7469 1
	  numRecords += printDbDumpRec(pn, pdf, "userOpVol", userOpVol, outFile, nPeriods, nonZeroOnly);
d7474 2
a7475 2
      numRecords += printDbDumpRec(pn, pdf, "excessVol", excessVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
      numRecords += printDbDumpRec(pn, pdf, "residualVol", residualVol.data(), outFile, nPeriods, nonZeroOnly);
d7477 3
a7479 3
	numRecords += printDbDumpRec(pn, pdf, "stockVol", stockVol.data(), outFile, nPeriods, alwaysPrintForECAonly);
      numRecords += printDbDumpRec(pn, pdf, "scrapVol", scrapVol, outFile, nPeriods, nonZeroOnly);
      numRecords += printDbDumpRec(pn, pdf, "consVol", consVol, outFile, nPeriods, alwaysPrint);
d7535 3
@


1.57
log
@added function to report interplantPeg from perspective of supplier location.   basically, this shifts the interplant peg earlier to accomodate interplant lead-times
@
text
@d6337 2
a6338 1
    if (! mpHelper.isPartNormalCapacity(theWitRun, capName))
d6340 1
d6553 1
d6555 1
d7493 1
d7531 2
@


1.56
log
@sce 4.60, scrapCost, stockCost, greedySearchIncrement,pegging in heuristic, removal of optWithLotSizes
@
text
@d6135 1
a6135 1
      int j = 0; // Pulled out of the for below by RW2STL
d6149 2
a6150 2
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
d6236 1
a6236 1
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
d6416 1
d6529 10
@


1.55
log
@Crit Peg processing was not printing specialFeatureDemand correctly.   fixed
@
text
@d124 18
d143 41
d4807 9
d4874 1
a4874 1

d4877 2
a4878 2
      std::cout << "WARNINGR, PEGGING not available for engine==heuristic" << std::endl;
   }
d7698 107
@


1.54
log
@shut off debugging and renamed to SCE 4.32  (for ServerGroup), will
rename again for SOAR
@
text
@d4293 5
a4297 3
	demandedPartName = demPartNameList[i];
	demandedPdf = "";
	demandedCust = demandNameList[i];
@


1.53
log
@mnior fix to pegCrit ... was sending optionalFeature pass demand to INDP instead of TINP file
@
text
@d51 1
a51 1
#define CRIT_PEG_DEBUG
@


1.52
log
@added DEBUGing routines for CritPeg
@
text
@d4286 7
a4292 7
      if ( ! mpHelper.isOperationSpecialFeature(theWitRun, 
						demPartNameList[i],
						demandedCust,    
						demandedPartName,    
						demandedPdf,    
						featurePart)) {

@


1.51
log
@initial changes for sce4.40
@
text
@d51 1
a51 1

d4183 8
d4218 13
a4230 1
    if (! mpHelper.isPartNormal(theWitRun, critPartNameList[i]))
d4232 2
d4321 12
d4346 3
@


1.50
log
@Preliminary commit for SCE 5.00
@
text
@d4165 2
a4166 1
	 std::string fileName,
d4169 2
a4170 2
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
d4173 8
a4180 1
		       << fileName);
d4183 5
a4187 1
  long numRecords = 0;
d4226 2
d4232 1
d4258 1
d4274 1
d4278 21
a4298 10

    outFile << "\"" << demandedPartName << "\","
	    << "\"" << demandedPdf << "\","
	    << "\"" << demandedCust << "\","
	    << "\"" << critpartname << "\","
	    << "\"" << critpdf << "\","
	    << shipPerList[i] << ","
	    << critPerList[i] << ","
	    << i << "\n";
    numRecords++;
d4310 5
a4314 2
  outFile.close();
  flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,000,numRecords); 
d4495 2
d4498 4
a4501 1
      this->printPeggedCriticalList(theWitRun, engine, peggedCriticalListFileName, mpHelper);
@


1.49
log
@minor mods
@
text
@d2953 1
a2953 1
LgFrScenarioForSce::printAlternatePartVolumesFile(
d2991 1
a2991 1
     if (! mpHelper.isOperationSpecialAlternatePart(theWitRun, opList[o], primePart, 
d3016 29
a3044 1
	 
d3046 2
a3047 2
	     << primePart << "\",\"" 
	     << primePdf << "\",\"" 
d3049 5
a3053 1
	     << altPdf << "\""; 
d3055 8
a3062 1
     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol, 0, 15);
d4495 15
d6650 4
a6653 1
  float * mrpIntPlVol  = new float[nPeriods];    
d6778 8
d6825 2
a6826 2
    // MRP --------> mrpProdVol, mrpBldVol, mrpIntPlVol, mrpDeAggVol, mrpUserOpVol
    // Implosion --> prodVol, bldVol, intPlVol, deAggVol, userOpVol
d6833 1
d6835 3
a6837 1
	bldVol[t] = 0.0;
d6907 16
d7023 5
d7302 1
d7313 1
@


1.48
log
@removed the "binning" stuff which is now obsolete
@
text
@d272 1
a274 1

a276 12
  std::cout << "Executing explosion engine using (" << myExploder->title() << ") scheme  ..." << std::endl;  


  // run the explosion engine !!
  myExploder->explode();

  bool doPegging = setOfParameters.getBool("doPegging");

  // need a flag for whtether it's mrp or implosion PIP
  if (doPegging) {
    printPIPData(theExplodeWitRun, 1);
  }
a277 2

    
d299 19
@


1.47
log
@First pass at sce 4.20 function.
@
text
@a353 20
#ifdef BINNING_OPERATION_TEMP_SOLUTION
  // Adjust Bin execVols for Jumper ARCS
  // this is done via operation App data.

  // VERY IMPORTANT!!  This step initializes App data for Bin
  // operations in the primary witRun!!  It must be done before any bin
  // execVols can be accessed (in either mrp or implosion witRuns). The app data
  // is actually store in the priamry witRun

  // NOTE: to get an bin (mrp)execVol, use scneario's helper function
  // binExecVol(opName, execVol &)
  // binMrpExecVol(opName, mrpExecVol &)
  initializeBinOperationsAppData(theWitRun,
					nPeriods,
					nOperations,
					opList);
#endif


  
a416 18
#ifdef BINNING_OPERATION_TEMP_SOLUTION
  // Bin Demand File: optional file (new 2.00)
  // prints only when asked for and there are bin records

  bool printBinDemandFile = setOfParameters.getBool("printBinDemandFile");
  std::string binFile = setOfParameters.getString("binFile");
  if ((! binFile.empty()) && printBinDemandFile )   {
    std::string binDemandFileName =
      setOfParameters.getString("binDemandFileName");
    bool isThisMrp = true;
    printBinVolumesFile(theWitRun, nPeriods, 
			       nOperations, opList,
			       isThisMrp,
			       binDemandFileName,
			       mpHelper);
  }
#endif

a692 3
#ifdef BINNING_OPERATION_TEMP_SOLUTION
   int nBinOperations = 0;
#endif
a784 6
#ifdef BINNING_OPERATION_TEMP_SOLUTION
     else if (mpHelper.isOperationSpecialBin(theWitRun, theOperation, d1, d2, d3, d4)) {
       nBinOperations++;
     }
#endif

a911 3
#ifdef BINNING_OPERATION_TEMP_SOLUTION
   outFile << " Number of Artificial (bin) \"operations\": = " << nBinOperations << "\n";
#endif
a3028 88
#ifdef BINNING_OPERATION_TEMP_SOLUTION
//  ---------------------------------------------------------------------
//  Print Bin Volumes (can be used by implosion or explosion)
//  --------------------------------------------------------------------- 
void 
LgFrScenarioForSce::printBinVolumesFile(
	 WitRun * const theWitRun,   // WIT environment   
	 const int nPeriods,         // Number of periods 
	 int nOps,
	 char ** opList,
	 bool isThisMrp,
	 std::string fileName,
	 LgFrMultiPlantHelper & mpHelper)
{
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    if (isThisMrp) {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Bin Demand File" 
			 << fileName);
    }
    else {
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << "Bin Orders" 
			 << fileName);
    }

  }



   long numRecords = 0; 
   long numZeroVec = 0;

   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;

   LgFrTimeVecFloat execVol;

   // Loop once for each operation
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
     if (! mpHelper.isOperationSpecialBin(theWitRun, opList[o], destination, 
						 destinationPdf, source, sourcePdf))
       continue;

     std::string operationName(opList[o]);

     // get the execVol
     if (isThisMrp)
       execVol = this->binMrpExecVol(operationName);
     else
       execVol = this->binExecVol(operationName);

     // check to see that execVol is not Zero vector,
     // if it is then skip it.
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
       if (execVol[t] > 0.01) {
	 isVecNonZero = true;
	 break;
       }
     }
     if (! isVecNonZero) {
       numZeroVec++;
       continue;
     }
	 
     outFile << "\"" 
	     << destination << "\",\"" 
	     << destinationPdf << "\",\"" 
	     << source    << "\",\"" 
	     << sourcePdf << "\""; 

     flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, execVol.data(), 0, 15);
     numRecords++;
   }

   outFile.close();
   flatFileMgr_.sceIOLogManager().printOutputLog(fileName,numRecords,numZeroVec,numRecords+numZeroVec); 
}
#endif



a3360 330
#ifdef BINNING_OPERATION_TEMP_SOLUTION
  //  ---------------------------------------------------------------------
  //  sets the adjusted bin execVols for  implosion
  //  ---------------------------------------------------------------------
void 
LgFrScenarioForSce::setBinOperationsAppDataForImplosion(
							       WitRun * const theWitRun,
							       const int nPeriods,                              
							       const int nOperations,
							       char ** operationList)
{
  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();
  
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an bin operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialBin( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have an bin operation.
    // there should only be one BOM hanging off the ip operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS269E: Bin operations"
	       << operationName
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the bin operation's working execVol
    LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );

    // NOTE: this assert assumes that the mrp has already created the 
    // the appdata.  
    assert ( operationAppDataPtr != 0 );

    float * execVol;
    witGetOperationExecVol(theWitRun, operationName.c_str(), &execVol);

    // now set the execVol
    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, execVol );
    operationAppDataPtr->execVol(workingExecVolTimeVec);

    witFree( execVol ); 
  } 


  // second loop we compute them
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);

    // if the operation isn't an bin op, then we're not
    // interested in it
    std::string dPart;
    std::string dPdf;
    std::string sPart;
    std::string sPdf;
    if (! mpHelper.isOperationSpecialBin(
		       theWitRun, operationName,
		       dPart, dPdf, sPart, sPdf))
      continue;

    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceBinOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			      (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat execVol = operationAppDataPtr->execVol();
    
    // the only subs on this bom should be to alternative bin locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s,
				      &subPdfPart );

      // break the subPdfPart name into it's pdf and part pieces
      // to get the bin operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.binOperationName(
					 dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialBin( theWitRun, subIpOp,
						    destPart, destPdf,
						    sourcePart, sourcePdf) ) {
	(*sceErrFacility_)("JumperArcError",MclArgList() << operationName << subPdfPart);
      }

      
      // get the execVol of the substitute bin operation
      LgFrSceBinOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpExecVol = subIpOpAppDataPtr->execVol();
      
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the sub vol
      float * subVol;
      witGetSubsBomEntrySubVol( theWitRun, operationName.c_str(), 0, s, &subVol );
      
      // adjust the execVol of the current bin operation
      // and the execVol of the substitute
      // bin operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	execVol[t] -= subVol[t];
	subIpOpExecVol[t] += subVol[t] * subUsageRate;
      } // end t
      
      // set substitute bin operation's adjusted exec vol in
      // the substitute bin operations appData
      subIpOpAppDataPtr->execVol(subIpOpExecVol);
      
      witFree ( subVol );
      witFree ( subPdfPart );
	
    } // end for s


    // set bin operation's adjusted exec vol in
    // the bin operations appData
    operationAppDataPtr->execVol(execVol);
    
  } // end for o

}



LgFrTimeVecFloat
LgFrScenarioForSce::binExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );

  return operationAppDataPtr->execVol();
}

LgFrTimeVecFloat
LgFrScenarioForSce::binMrpExecVol(std::string & operationName)
{
  WitRun * const theWitRun = lastProblemSolved().witRun();
  LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
			  (void **) &operationAppDataPtr );
  assert ( operationAppDataPtr != 0 );

  return operationAppDataPtr->mrpExecVol();
}



// intiialize the app data's with straight execVols, and then compute them.
void
LgFrScenarioForSce::initializeBinOperationsAppData(
							  WitRun * const theWitRun,
							  const int nPeriods,                              
							  const int nOperations,
							  char ** operationList)
{
  LgFrSceBaseExploder * myExploder = myExploder = this->exploder();

  LgFrMultiPlantHelper & mpHelper = this->multiPlantHelper();

  // first loop we initialize them
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
    // if it's not an bin operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialBin( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have a bin operation.
    // there should only be one BOM hanging off the bin operation. Let's check.
    int nBoms;
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
    if ( nBoms != 1) {
	  std::cerr << "\nJumper Arc Error SYS270E: Bin operations"
	       << operationName.c_str()
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
	  exit (1);
    }
    
    // initialize the bin operation's working mrpExecVol
    // to be the operation's mrp exec vol.
    // Store it for further mucking
    // in the bin operation's app data
    // Caller needs to clean up the appData.
    LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
			    (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr == 0 );
    float * mrpExecVol;
    myExploder->mrpExecVol(operationName, &mrpExecVol);

    LgFrTimeVecFloat workingExecVolTimeVec( (size_t) nPeriods, mrpExecVol );
    operationAppDataPtr = new LgFrSceBinOpAppData (workingExecVolTimeVec);
    witSetOperationAppData( theWitRun, operationName.c_str(), (void *) operationAppDataPtr );
    witFree( mrpExecVol ); 
  } 



  // second loop we compute them
  for (o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);

    // if it's not an bin operation, get the next operation
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
    if ( ! mpHelper.isOperationSpecialBin( theWitRun,
		       operationName, dPart, dPdf, sPart, sPdf ))
      continue;

    // if we're here, we have a bin operation.
    // Get the operation's working mrpExecVol
    
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
    
    LgFrSceBinOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(), (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
    LgFrTimeVecFloat mrpExecVol = operationAppDataPtr->mrpExecVol();
    
    // the only subs on this bom should be to alternative bin locations
    int nSubBoms;
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );

    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
      char * subPdfPart;
      witGetSubsBomEntryConsumedPart( theWitRun,
				      operationName.c_str(), 0, s, &subPdfPart );
      
      // break the subPdfPart name into it's pdf and part pieces
      // to get the bin operation between the destationPdfPart
      // and the substitute sourcePdfPart. Call it the subIpOp.
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.binOperationName(
				     dPart, dPdf, subPart, subPdf );
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
      if ( ! mpHelper.isOperationSpecialBin( theWitRun, subIpOp,
						      destPart, destPdf,
						      sourcePart, sourcePdf) ) {
	std::cerr << "\nJumper Arc Error: Bin operation "
	     <<  operationName.c_str()
	     << " has a substitute "
	     << subPdfPart
	     << " that is not valid. Contact SCE Support\n" << std::endl;
	exit (1);
	}

      // get the execVol of the substitute bin operation, subIpOp
      LgFrSceBinOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
			      (void **) &subIpOpAppDataPtr );
      assert ( subIpOpAppDataPtr != 0 );
      LgFrTimeVecFloat subIpOpMrpExecVol = subIpOpAppDataPtr->mrpExecVol();
	
      // get the substitute's usageRate
      float subUsageRate;
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
      
      // get the exploders sub vol
      float * subUsageVol;
      myExploder->subUsageVol(operationName, 0, s, &subUsageVol );
      
      // adjust the mrpExecVol of the current bin operation
      // and the mrpExecVol of the substitute
      // bin operations
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
	mrpExecVol[t] -= subUsageVol[t];
	subIpOpMrpExecVol[t] += subUsageVol[t] * subUsageRate;
      } // end t

      // set substitute bin operation's adjusted mrp exec vol in
      // the substitute bin operations appData
      subIpOpAppDataPtr->mrpExecVol(subIpOpMrpExecVol);
      witFree ( subUsageVol );
      witFree ( subPdfPart );
      
    } // end for s


    // set bin operation's adjusted mrp exec vol in
    // the bin operations appData
    operationAppDataPtr->mrpExecVol(mrpExecVol);

  } // end for o

}
#endif

d4354 6
a4359 12
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    // VERY IMPORTANT!!  This step sets App data for Bin
    // operations in the primary witRun!!  It must be done before any bin
    // execVols can be accessed (in either mrp or implosion witRuns). The app data
    // is actually store in the priamry witRun.  At this point the appdata's 
    // should ahve been created during the printExplosion results and here we are
    // merely going to set the implosion values (which were initialized to zero)
    if (siteCustomization != "skipTheCrapola") {
      setBinOperationsAppDataForImplosion(theWitRun,
						 nPeriods,
						 nOperations,
						 opList);
a4360 11
#endif



      // Geo Source Debug File: optional file
      if (setOfParameters.getBool("printGeoSourceDebugFile"))  {    
	std::string geoSourceDebugFileName =
	  setOfParameters.getString("geoSourceDebugFileName");
	printGeoSourceDebugFile(theWitRun, nPeriods, nParts, partList,
				geoSourceDebugFileName, theCal, mpHelper);
      }
d4363 1
a4363 1

a4479 18
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    // Bin Order File
    if (siteCustomization != "skipTheCrapola") {
      std::string binFile = setOfParameters.getString("binFile");
      if (! binFile.empty())   {
	std::string binOrdersFileName =
	  setOfParameters.getString("binOrdersFileName");
	bool isThisMrp = false;
	printBinVolumesFile(theWitRun, nPeriods, 
				   nOperations, opList,
				   isThisMrp,
				   binOrdersFileName,
				   mpHelper);
      }
    }
#endif


a6591 4
#ifdef BINNING_OPERATION_TEMP_SOLUTION
  float * binVol       = new float[nPeriods];
  float * mrpBinVol    = new float[nPeriods];    
#endif
a6646 3
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    int nBinOps = mpHelper.nBinOps(theWitRun, fullPartName);
#endif
a6772 6
#ifdef BINNING_OPERATION_TEMP_SOLUTION
	if (nBinOps) {
	  binVol[t] = 0.0;
	  mrpBinVol[t] = 0.0;
	}
#endif
a6834 19
#ifdef BINNING_OPERATION_TEMP_SOLUTION
	// is it an Bin Operation ?
	if (! foundOpCategory
	    && nBinOps
	    && mpHelper.isOperationSpecialBin(theWitRun, operationName, cp1, pdf1, sp2, pdf2)) {
	  LgFrTimeVecFloat newExecVol = this->binExecVol(operationName);
	  LgFrTimeVecFloat newMrpExecVol = this->binMrpExecVol(operationName);
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
	    if (doImplode) {	  
	      binVol[t]    += prodRate * newExecVol[t];
	    }
	    mrpBinVol[t] += prodRate * newMrpExecVol[t];
	  }
	  foundOpCategory = true;
	}
#endif


a6903 8
#ifdef BINNING_OPERATION_TEMP_SOLUTION
	if (nBinOps) {
	  mrpProdVol[t] += mrpBinVol[t];
	  if (doImplode) {	  
	    prodVol[t] += binVol[t];
	  }
	}
#endif
a7207 5

#ifdef BINNING_OPERATION_TEMP_SOLUTION
      if (nBinOps) 
	numRecords += printDbDumpRec(pn, pdf, "mrpBinVol", mrpBinVol, outFile, nPeriods, nonZeroOnly);
#endif
a7217 5

#ifdef BINNING_OPERATION_TEMP_SOLUTION
	if (nBinOps) 
	  numRecords += printDbDumpRec(pn, pdf, "binVol", binVol, outFile, nPeriods, nonZeroOnly);
#endif
a7275 4
#ifdef BINNING_OPERATION_TEMP_SOLUTION
  delete [] binVol;
  delete [] mrpBinVol;
#endif
a7534 10
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    else if (mpHelper.isOperationSpecialBin(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      supplierPdf = pdf2;
      customerPdf = pdf1;      
      PUD14SourceCode = "B";
    }
#endif


a7578 10
#ifdef BINNING_OPERATION_TEMP_SOLUTION
      // note: do a switcheroo to get the real bin execVol a'la jumper arcs
      if (PUD14SourceCode == "B") {
	LgFrTimeVecFloat realMrpExecVol = this->binMrpExecVol(fullWitOperation);
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
	  mrpExecVol[t] = realMrpExecVol[t];
      }
#endif

a7792 9
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    else if (mpHelper.isOperationSpecialBin(exploderWitRun, fullWitOperation, pn1, pdf1, pn2, pdf2)) {
      // FINISH_ME: the case when pn1 Not equal pn2 may need to be reconsidered
      customerPdf = pdf1;      
      sourceCode = "B";
    }
#endif


a7890 14
#ifdef BINNING_OPERATION_TEMP_SOLUTION
	// if its a sub off an bin, then its a jumper arc
	else if (sourceCode == "B") {
	  // only print a record if its a non-zero vector.
	  if (flatFileMgr_.isFloatVecNonZero(subDemandOrderQty, nPeriods)) {                      
	    outFile << "\"" << mpHelper.partname(subConsumedPart) << "\",\""
		    << mpHelper.pdf(subConsumedPart) << "\",\""
		    << customerPdf << "\",\""          
		    << sourceCode << "\"";
	    flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subDemandOrderQty, 0, 15);
	    numRecords++;        
	  }
	}
#endif
@


1.46
log
@4.20 commit: global subs, prioritized explode
@
text
@d55 1
a55 1
#ifdef HEUR_ALLOC_EXPLODE
d58 1
a58 6
						 LgFrScenarioForSceSmartPointer scenSceSP  
)
#else
LgFrSceBaseExploder *
LgFrScenarioForSce::createAppropriateSceExploder()
#endif
d67 1
d75 1
a75 1
   
a77 7
#ifdef SCE_USE_WIT_MRP
    theConcreteExploder = new LgFrSceBaseExploder(lastProblemSolved().witRun(),
						  &(multiPlantHelper()),
						  &(setOfParameters()));
    theCurrentExploder = theConcreteExploder;
    return theConcreteExploder;
#else
d80 1
a93 1
#endif
d96 2
a97 2
  if (useSmartExplodeUtility) {
#ifdef HEUR_ALLOC_EXPLODE
a100 3
#else
    theSmartDecorator = new LgFrSceSmartExploderDecorator(theCurrentExploder);
#endif
d106 4
a109 2
    theFullDecorator = new LgFrSceFullExploderDecorator(theCurrentExploder);
    theCurrentExploder = theFullDecorator;
a110 1
  
d243 1
d245 3
a247 7
#ifdef HEUR_ALLOC_EXPLODE
    std::cerr << "trying to access an exploder and it is NULL (HEUR_ALLOC_ONLY)\n "
	      << std::endl;
    exit (1);
#else
    exploderPtr_ = this->createAppropriateSceExploder();
#endif
d249 2
d257 1
a257 5
LgFrScenarioForSce::runExplosion(			
#ifdef HEUR_ALLOC_EXPLODE	 
				 LgFrScenarioForSceSmartPointer scenSceSP
#endif
				 )
a262 3
#ifdef HEUR_ALLOC_EXPLODE	 


d267 1
a267 1
    std::cerr << "trying to access an exploder for first time and it is non-null (HEUR_ALLOC_ONLY)\n "
a270 1
#endif
a5187 1
					 engine,
d8759 1
d8764 12
a8775 1
  WitRun * wr = this->lastProblemSolved().witRun();
d8777 3
a8779 4
  // delete bop app data
  char ** operationList;
  int nOps;
  int i, b, o; 
d8781 12
a8792 2
  witGetOperations ( wr, &nOps, &operationList );
  for (o=0; o<nOps; o++) {
d8794 17
a8810 19
    LgFrSceInterplantOpAppData * opIpAppDataPtr;
    LgFrSceBinOpAppData        * opBinAppDataPtr;
    LgFrSceCCOperationAppData  * opCCAppDataPtr;
    std::string dPart,dPdf,sPart,sPdf;
    if (multiPlantHelper_.isOperationSpecialInterplant( wr, operationList[o], dPart, dPdf, sPart, sPdf )) 
      {
	witGetOperationAppData( wr, operationList[o], (void **) & opIpAppDataPtr );
	delete opIpAppDataPtr ;
      }
    else if (multiPlantHelper_.isOperationSpecialBin( wr, operationList[o], dPart, dPdf, sPart, sPdf )) 
      {
	witGetOperationAppData( wr, operationList[o], (void **) & opBinAppDataPtr );
	delete opBinAppDataPtr ;
      }
    else if (multiPlantHelper_.isOperationSpecialCustChoiceFeature( wr, operationList[o], dPart, dPdf, sPart, sPdf )) 
      {
	witGetOperationAppData( wr, operationList[o], (void **) & opCCAppDataPtr );
	delete opCCAppDataPtr ;
      }
d8812 8
a8819 8
    int  nbBops;   
    witGetOperationNBopEntries ( wr, operationList[o], & nbBops );
    for (b=0; b<nbBops; b++) {
      LgFrSceBopAppData * bopAppDataPtr;
      witGetBopEntryAppData ( wr, operationList[o], b, (void **) & bopAppDataPtr );
      delete bopAppDataPtr ;
    } // for b nbBops
  } // for o operations
a8820 23
  // delete subBom App Data
  for (o=0; o<nOps; o++) {
    int nBoms;
    int nSubBoms;
    witGetOperationNBomEntries( wr, operationList[o], &nBoms );
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++) {
      LgFrSceCustChoiceBomAppData * bomAppDataPtr;
      witGetBomEntryAppData(wr, operationList[o], j, (void **) &bomAppDataPtr);
      delete bomAppDataPtr;
      witGetBomEntryNSubsBomEntries( wr, operationList[o], j, &nSubBoms );
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) { 
	LgFrSceSubBomAppData * subBomAppDataPtr;
	witGetSubsBomEntryAppData( wr, operationList[o], j, s, (void **) &subBomAppDataPtr );
	delete subBomAppDataPtr;
      } // for s nSubBoms
    } // for j nBoms
  } // for o nOperations
  
  for (o=0; o<nOps; o++)
    witFree (operationList[o]);
  witFree (operationList);
d8822 8
a8829 9
  // delete part app data and demand app data
  char ** partList;
  int nParts;
  
  witGetParts ( wr, &nParts, &partList );
  for (i=0; i<nParts; i++) {
    LgFrScePartAppData * partAppDataPtr;
    witGetPartAppData ( wr, partList[i], (void **) &partAppDataPtr );
    delete partAppDataPtr;
d8831 11
a8841 10
    char ** dList;
    int nDemands;
    witGetPartDemands(wr, partList[i], &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
      witGetDemandAppData(wr, partList[i], dList[j], (void **) &demandAppDataPtr );
      if ( demandAppDataPtr != 0 ) 
        delete demandAppDataPtr;
      witFree(dList[j]);
a8842 4
    witFree(dList);
    witFree (partList[i]);
  } 
  witFree (partList);
d8844 7
a8851 3
//  delete  localSnapshotPtr_;
  delete  exploderPtr_;

d8856 1
a8856 1

@


1.45
log
@cleanup before tagging
@
text
@d52 9
d63 1
d108 5
d114 1
d250 1
d257 5
d263 1
a269 1

d271 5
a275 1
LgFrScenarioForSce::runExplosion()
d279 15
d296 1
d2086 1
a2086 1
  int t, i;
d2095 1
a2095 1
  int o = 0; // Pulled out of the for below by RW2STL
d3016 85
d5205 1
a5208 1
					 theCal,
d5210 2
a5211 1
					 engine);
@


1.44
log
@sce4.10 changes
@
text
@d1153 1
a1153 1
       std::cout << "   ... processed " << i << " parts out of " << nParts << std::endl;                
@


1.43
log
@preping for release 4.1
@
text
@d1123 2
d1143 4
d1150 7
d4581 1
a4581 4
    outFile << "\"" << critpartname << "\","
	    << "\"" << critpdf << "\","
	    << critPerList[i] << ","
	    << "\"" << demandedPartName << "\","
d4584 2
d4587 1
@


1.42
log
@feature sets logic automatically uses proportional routing when engine is NOT optimization.   for optimization, it uses the OLD BBCat modelling trick.
@
text
@d1096 3
a1243 5





d4464 133
d4779 10
a4788 2
      printCriticalList(theWitRun, engine, nPeriods, nParts, partList,
			criticalListFileName, theCal, mpHelper, theCritList);
d4790 2
d5176 6
d5217 8
a5224 1
    indpPfProdVolPegFileName = setOfParameters.getString("mrpPfProdIndpVolPegFileName");
d5760 5
d5766 166
d6693 8
@


1.41
log
@finally fixed memory error ... witFree(yieldRate) in wrong place
@
text
@d2010 1
a2010 5



#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
  // this method writes FEATURE SET report  
d2093 2
a2094 2
#else
  // this method writes FEATURE SET report  
d2133 2
a2134 2
         if (sce::findCaseIns(bbCategory, "STANDALONE:") != sce::badIndex)
	 continue;
a2174 1
#endif
d4823 8
a4830 9
#ifdef FEATURE_SETS_VIA_PROPORTIONAL_ROUTING
      printFeatureAnalysisReportViaProportionalRoute(theWitRun, nPeriods, nOperations, opList,
					      selFeatBBratioFileName,
					      theCal, mpHelper, printDataAsPercentage);
#else
      printFeatureAnalysisReport(theWitRun, nPeriods, nParts, partList,
				 selFeatBBratioFileName,
				 theCal, mpHelper, printDataAsPercentage);
#endif
@


1.40
log
@put in an ifdef (Are_YOU_STILL) to get around interplantJumper Arcs
@
text
@a316 3


#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
a350 1
#endif
d399 1
a399 1
#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
a416 2


d434 1
a434 1
#endif
d477 1
a477 1
#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
d489 1
a489 1
#endif  
a2591 1
	  witFree(yieldRate);
d2596 1
a2596 1

d2791 1
a2791 1
    
a2930 1

a2935 1
     
a4562 1
#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
d4593 1
a4593 1
#endif
a4665 1
#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
a4681 19
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    // Bin Order File
    if (siteCustomization != "skipTheCrapola") {
      std::string binFile = setOfParameters.getString("binFile");
      if (! binFile.empty())   {
	std::string binOrdersFileName =
	  setOfParameters.getString("binOrdersFileName");
	bool isThisMrp = false;
	printBinVolumesFile(theWitRun, nPeriods, 
				   nOperations, opList,
				   isThisMrp,
				   binOrdersFileName,
				   mpHelper);
      }
    }
#endif

#endif

d4711 16
a6892 2

#ifdef ARE_YOU_STILL_DOING_INTERPLANT_JUMPER_ARCS
a6901 1
#endif
@


1.39
log
@memory management cleanup
@
text
@d317 3
d354 1
d403 1
a403 1

d421 2
d440 1
a440 1

d483 1
a483 1

d495 1
a495 1
  
d2938 1
d2944 1
d4572 1
d4603 1
a4603 1

d4676 1
d4693 19
a4740 16
#ifdef BINNING_OPERATION_TEMP_SOLUTION
    // Bin Order File
    if (siteCustomization != "skipTheCrapola") {
      std::string binFile = setOfParameters.getString("binFile");
      if (! binFile.empty())   {
	std::string binOrdersFileName =
	  setOfParameters.getString("binOrdersFileName");
	bool isThisMrp = false;
	printBinVolumesFile(theWitRun, nPeriods, 
				   nOperations, opList,
				   isThisMrp,
				   binOrdersFileName,
				   mpHelper);
      }
    }
#endif
d6907 2
d6918 1
@


1.38
log
@fixed some bad memory management ... was freeing insted of deleting
@
text
@d177 2
a178 2
	 portableFree(indepDemandVol);
	 portableFree(dList[j]);
d180 1
a180 1
       portableFree(dList);
d219 1
a219 1
       portableFree(mrpConsVol);
d528 2
a529 2
    portableFree(partList[i]);
  portableFree(partList);
d533 2
a534 2
    portableFree(opList[o]);
  portableFree(opList);
d650 1
a650 1
      portableFree(child);
d661 1
a661 1
    portableFree(child);
d826 1
a826 1
     portableFree(opList[o]);
d828 1
a828 1
   portableFree(opList);
d849 1
a849 1
	 portableFree(demandList[j]);
d851 1
a851 1
       portableFree(demandList);
d873 1
a873 1
	 portableFree(demandList[j]);
d875 1
a875 1
       portableFree(demandList);
d928 1
a928 1
     portableFree(yieldRate);
d1189 3
a1191 3
	 portableFree(child);
	 portableFree(consRate);
	 portableFree(impactPeriod);
d1198 2
a1199 2
       portableFree(yieldRate);
       portableFree(rawCost);
d1324 1
a1324 1
	   portableFree(dList[j]);
d1326 2
a1327 2
	     portableFree(obj1Reward);
	     portableFree(obj1CSReward);
d1330 3
a1332 3
	     portableFree(priority);           
	   portableFree(shipVol);
	   portableFree(demandVol);
d1334 1
a1334 1
       portableFree(dList);
d1439 1
a1439 1
    portableFree(witVector);
d1446 1
a1446 1
    portableFree(witVector);
d1462 2
a1463 2
    portableFree(reqVol);
    portableFree(mrpExcessVol);
d1540 2
a1541 2
	  portableFree(impactPeriod);
	  portableFree(mrpImpactPeriod);
d1549 1
a1549 1
	portableFree(witOperationName);
d1551 1
a1551 1
	  portableFree(tempExecVol);
d1553 3
a1555 3
	portableFree(tempMrpExecVol);
	portableFree(yieldRate);
	portableFree(mrpYieldRate);        
d1577 1
a1577 1
      portableFree(witVector);
d1582 1
a1582 1
      portableFree(witVector);
d1587 1
a1587 1
      portableFree(witVector);
d1661 1
a1661 1
	portableFree (demandList);  
d1753 7
a1759 7
	portableFree (shipVol);
	portableFree(gpdExecVol);
	portableFree(featureConsVol);
	portableFree(ccfeatureExcessVol);
	portableFree(sfpExecVol);
	portableFree(sfpSupplyVol);
	portableFree(gpdWitPartName);
d1768 2
a1769 2
	portableFree (demandList[j]);
      portableFree (demandList);
d1796 1
a1796 1
	portableFree (demandList);  
d1844 2
a1845 2
	portableFree (shipVol);
	portableFree(fen5supplyVol);
d1856 1
a1856 1
	    portableFree( child);
d1871 1
a1871 1
	      portableFree(sub);
d1893 2
a1894 2
	    portableFree(sub);
	    portableFree(subProdVol);
d1896 1
a1896 1
	  portableFree(child);
d1898 1
a1898 1
	portableFree(gpdProdVol);
d1906 2
a1907 2
	portableFree (demandList[j]);
      portableFree (demandList);
d1986 1
a1986 1
	 portableFree(gpdExecVol);
d1998 1
a1998 1
       portableFree(orsConsVol);      
d2076 1
a2076 1
      portableFree(gpdExecVol);
d2090 1
a2090 1
    portableFree(sodExecVol);    
d2160 1
a2160 1
	 portableFree(gpdProdVol);
d2172 1
a2172 1
       portableFree(sodProdVol);      
d2238 1
a2238 1
	    portableFree(sub);
d2252 2
a2253 2
	  portableFree(sub);
	  portableFree(subProdVol);
d2255 1
a2255 1
	portableFree(child);
d2323 1
a2323 1
	    portableFree(sub);
d2337 2
a2338 2
	  portableFree(sub);
	  portableFree(subProdVol);
d2340 1
a2340 1
	portableFree(child);
d2404 1
a2404 1
	    portableFree(sub);
d2416 2
a2417 2
	  portableFree(sub);
	  portableFree(subProdVol);
d2419 1
a2419 1
	portableFree(child);
d2528 1
a2528 1
	    portableFree(sub);
d2590 3
a2592 3
	  portableFree(sub);
	  portableFree(subProdVol);
	  portableFree(yieldRate);
d2594 1
a2594 1
	portableFree(child);
d2701 1
a2701 1
	    portableFree(sub);
d2786 2
a2787 2
	  portableFree(sub);
	  portableFree(subVol);
d2789 1
a2789 1
	portableFree(child);
d3110 1
a3110 1
    portableFree( execVol ); 
d3193 2
a3194 2
      portableFree ( subVol );
      portableFree ( subPdfPart );
d3286 1
a3286 1
    portableFree( mrpExecVol ); 
d3373 2
a3374 2
      portableFree ( subUsageVol );
      portableFree ( subPdfPart );
d3441 1
a3441 1
    portableFree( execVol ); 
d3524 2
a3525 2
      portableFree ( subVol );
      portableFree ( subPdfPart );
d3617 1
a3617 1
    portableFree( mrpExecVol ); 
d3704 2
a3705 2
      portableFree ( subUsageVol );
      portableFree ( subPdfPart );
d3771 1
a3771 1
       portableFree(execVol);
d3782 1
a3782 1
     portableFree(execVol); 
d3786 2
a3787 2
     portableFree(operationList[o]);
   portableFree(operationList);
d3848 1
a3848 1
       portableFree(mrpExecVol);
d3859 1
a3859 1
     portableFree(mrpExecVol); 
d3863 2
a3864 2
     portableFree(operationList[o]);
   portableFree(operationList);
d3930 3
a3932 3
	portableFree(shipVol);
	portableFree(demandVol);
	portableFree(dList[j]);
d3935 1
a3935 1
      portableFree(dList);
d4042 1
a4042 1
     portableFree(gpdProdVol);
d4102 2
a4103 2
	portableFree(shipVol); 
	portableFree(dList[j]);
d4106 1
a4106 1
      portableFree(dList);
d4183 2
a4184 2
	portableFree(shipVol); 
	portableFree(dList[j]);
d4187 1
a4187 1
      portableFree(dList);
d4307 1
a4307 1
	   portableFree(witVector); 
d4309 2
a4310 2
	   portableFree(witVector1); 
	   portableFree(dList[j]);
d4313 1
a4313 1
	 portableFree(dList);
d4418 1
a4418 1
     portableFree(execVol); 
d4530 2
a4531 2
      portableFree(partList[i]);
   portableFree( partList );
d4534 2
a4535 2
   //      portableFree(opList[o]);
   //   portableFree( opList );
d4890 2
a4891 2
      portableFree(partList[i]);
   portableFree( partList );
d4895 2
a4896 2
      portableFree(opList[o]);
   portableFree( opList );
d6240 5
a6244 5
      portableFree(execVol);
      portableFree(consRate);
      portableFree(impactPeriod);
      //      portableFree(yieldRate);
      portableFree(operation);
d6246 1
a6246 1
    portableFree(partList[i]);
d6248 1
a6248 1
  portableFree(partList);
d6578 1
a6578 1
     portableFree(supplyVol);
d6580 1
a6580 1
       portableFree(cycleTime);
d6582 4
a6585 4
       portableFree(execFlag);
     portableFree(reqVol);
     portableFree(mrpExcessVol);
     portableFree(mrpResidualVol);
d6587 2
a6588 2
       portableFree(excessVol);
       portableFree(residualVol);
d6590 3
a6592 3
	 portableFree(stockVol);
       portableFree(scrapVol);
       portableFree(consVol);
d6594 1
a6594 1
	 portableFree(prodVol);
d6780 1
a6780 1
      portableFree(indepDemandVol);
d6956 2
a6957 2
	  portableFree(impactPeriod);
	  portableFree(mrpImpactPeriod);
d6969 1
a6969 1
	portableFree(witOperationName);
d6971 1
a6971 1
	  portableFree(tempExecVol);
d6973 3
a6975 3
	portableFree(tempMrpExecVol);
	portableFree(yieldRate);
	portableFree(mrpYieldRate);        
d7031 1
a7031 1
	portableFree(indepShipVol);
d7345 4
a7348 4
      portableFree(cycleTime);
    portableFree(reqVol);
    portableFree(witMrpExcessVol);
    portableFree(mrpConsVol);
d7350 2
a7351 2
      portableFree(execFlag);
      portableFree(yieldRate);
d7354 2
a7355 2
      portableFree(witExcessVol);
      portableFree(witResidualVol);
d7359 3
a7361 3
	portableFree(witStockVol);
      portableFree(scrapVol);
      portableFree(consVol);
d7367 1
a7367 1
      portableFree(dList[j]);
d7369 1
a7369 1
    portableFree(dList);
d7371 1
a7371 1
    portableFree(supplyVolSpecifiedByUser);
d7515 1
a7515 1
    portableFree(witBoolVec);
d7524 1
a7524 1
    portableFree(witVector);
d7540 1
a7540 1
    portableFree(witVector);
d7556 1
a7556 1
      portableFree(witVector);
d7566 2
a7567 2
    portableFree(opList[o]);
  portableFree(opList);
d7687 1
a7687 1
	portableFree(producedPart);
d7730 3
a7732 3
      portableFree(mrpExecVol);
      portableFree(yieldRate);
      portableFree(impactPeriod);
d7743 1
a7743 1
      portableFree(producedPart);
d7785 1
a7785 1
      portableFree(supplyVol);
d7793 2
a7794 2
    portableFree(opList[o]);
  portableFree(opList);
d7797 2
a7798 2
    portableFree(partList[i]);
  portableFree(partList);
d7968 1
a7968 1
	portableFree(consumedPart);
d7974 1
a7974 1
	portableFree(consumedPart);        
d8067 2
a8068 2
	portableFree(subConsumedPart);
	portableFree(subVol);
d8081 2
a8082 2
      portableFree(mrpExecVol);
      portableFree(impactPeriod);
d8114 1
a8114 1
      portableFree(consumedPart);
d8152 2
a8153 2
    portableFree(FsourceDemand[i]);
    portableFree(OsourceDemand[i]);
d8155 2
a8156 2
  portableFree(FsourceDemand);
  portableFree(OsourceDemand);  
d8160 2
a8161 2
    portableFree(opList[o]);
  portableFree(opList);
d8164 2
a8165 2
    portableFree(partList[i]);
  portableFree(partList);
d8379 2
a8380 2
    portableFree (operationList[o]);
  portableFree (operationList);
d8401 1
a8401 1
      portableFree(dList[j]);
d8403 2
a8404 2
    portableFree(dList);
    portableFree (partList[i]);
d8406 1
a8406 1
  portableFree (partList);
d8959 2
a8960 2
      portableFree(partList[i]);
   portableFree( partList );
d8995 2
a8996 2
	portableFree(shipVol); 
	portableFree(dList[j]);
d8998 1
a8998 1
      portableFree(dList);
d9043 3
a9045 3
	portableFree(shipVol);
	portableFree(demandVol);
	portableFree(dList[j]);
d9047 1
a9047 1
      portableFree(dList);
d9077 1
a9077 1
    portableFree(witVector);
d9111 1
a9111 1
      portableFree(witVector);
d9175 2
a9176 2
    portableFree(reqVol);
    portableFree(mrpExcessVol);
d9213 1
a9213 1
      portableFree(witVector);
d9245 1
a9245 1
      portableFree(witVector);
d9276 1
a9276 1
      portableFree(witVector);
d9322 1
a9322 1
	 portableFree(execVol);
d9331 1
a9331 1
       portableFree(execVol); 
d9335 2
a9336 2
     portableFree(opList[o]);
   portableFree(opList);
d9429 1
a9429 1
     portableFree(gpdProdVol);
d9464 1
a9464 1
       portableFree(mrpConsVol);
d9501 1
a9501 1
     portableFree(execVol); 
d9553 1
a9553 1
      portableFree(witVector);
d9563 1
a9563 1
      portableFree(witVector);
d9651 1
a9651 1
      portableFree(cycleTime);
d9706 1
a9706 1
    portableFree(witVector);
d9787 2
a9788 2
    portableFree(reqVol);
    portableFree(mrpExcessVol);
d9854 1
a9854 1
      portableFree(witVector);
d9910 1
a9910 1
	  portableFree(witVector);
d9922 1
a9922 1
	  portableFree(witVector);
d9974 1
a9974 1
      portableFree(witVector);
d10025 1
a10025 1
      portableFree(witVector);
d10207 2
a10208 2
          portableFree(impactPeriod);
          portableFree(mrpImpactPeriod);
d10220 5
a10224 5
	portableFree(witOperationName);
	portableFree(tempExecVol);
	portableFree(tempMrpExecVol);
	portableFree(yieldRate);
	portableFree(mrpYieldRate);        
d10296 1
a10296 1
	  portableFree(witVector);
@


1.37
log
@typo in mrpIndpProdVolPegFileName in scenario
@
text
@d7356 4
a7359 1
      portableFree(witStockVol);
@


1.36
log
@added ProdVol from ProdVol Peg files
@
text
@d5071 1
a5071 1
    indpProdVolPegFileName = setOfParameters.getString("mrpProdIndpVolPegFileName");
@


1.35
log
@added ProdVol from ProdVol Peg files
@
text
@d2570 1
a2570 1
		  consRate[impactPeriod[t]]/(1.0-falloutRate);
@


1.34
log
@added prodVolPeg for Indp dmeand
@
text
@d5036 6
d5073 5
d5086 1
a5086 1
  std::cout << "Writing PIPegging information..." << std::endl;    
d5442 175
d5700 3
a5702 3
  // --------------------------
  // ProdVolPIPFile  (diagnostic)
  // --------------------------
d5796 1
a5796 1
  // indpDemandProdVolPegFile
d6365 10
@


1.33
log
@included bbCategory in bbRatio output file
@
text
@d5033 2
d5061 5
a5065 2
  printProdVolPegFile = setOfParameters.getBool("printMrpProdVolPegFile");
  prodVolPegFileName = setOfParameters.getString("mrpProdVolPegFileName");
d5602 93
@


1.32
log
@added subDB output file
@
text
@d2080 3
a2082 1
    outFile << "\"" << plannerTopLevelPart << "\",\"" << geo 
@


1.31
log
@added vac calculation
@
text
@d2504 4
d2532 1
a2532 1
	    witGetSubsBomEntryProdVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
d2564 2
a2565 2

	    for(int t=0; t<nPeriods; t++) {	      
d2575 6
d2590 1
d2603 201
d4738 19
a4759 1
    std::string subBomFile = setOfParameters.getString("subBomFile");    
@


1.30
log
@pip for LP engine
@
text
@d1093 151
d4295 18
@


1.29
log
@avoid assert failure in printCapacityDB
@
text
@d4511 2
a4523 2
    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
    bool doPegging = setOfParameters.getBool("doPegging");
a4525 1

a4537 2
    LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();
    bool doPegging = setOfParameters.getBool("doPegging");
d4552 2
@


1.28
log
@capacityUsage and mrpCapacityUsage
@
text
@d1269 5
d1357 15
d1395 1
a1395 1
	assert(foundOpCategory);
a6181 5
	//LgFrMultiPlantHelper::isOperationForCapacityGeneration(
	//    WitRun * const theWitRun, 
	//    const std::string & fullWitOperationName,
	//    std::string & theCapacity,
	//    std::string & pdf)
@


1.27
log
@mand/opt capacity, new selective sets
@
text
@d436 8
d4328 10
d5445 107
d8222 1
@


1.26
log
@First cut at Selective Features using proportional routing
@
text
@d5836 1
d5849 1
d5859 4
a5862 3
    // skip it if its a real capacity part
    if (mpHelper.isPartNormalCapacity(theWitRun, fullPartName))
      continue;
d5866 1
d6037 6
d6044 3
a6046 4
	if (operationName == fullPartName) {
	  int t = 0; // Pulled out of the for below by RW2STL
	  // TEMP_FIX: 20030130
	  // 	  for (t=early; t<=late; t++) {
d6229 10
a6238 1
      witGetPartStockVol(theWitRun, fullPartName.c_str(), &witStockVol);
d6243 3
a6245 1
	stockVol[ttt] = witStockVol[ttt];
d6522 1
a6522 3
      if (category != WitCAPACITY) {
	portableFree(witStockVol);
      }
@


1.25
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@d700 1
d804 4
d941 2
a942 1
   outFile << " Number of Artificial (OD) \"parts\": = " << nOptionDummyParts << "\n";
d1739 3
d1743 2
d1826 90
d4383 2
a4384 1
#ifdef BUILDING_BLOCKS_VIA_MULTI_BOPS
d4388 6
d4487 1
a4487 1
      std::cout << "WARNINGR, PEGGING not available for engine==heuristic\n";
@


1.24
log
@first level of PIP
@
text
@a25 1
// #include <sce/src/scePIP.h>
a262 2
#ifdef DEMAND_PEGGING
  // IMPLEMENT PEGGING
a264 7
  // need a flag for whtether it's mrp or implosion pegging
  if (doPegging) {
    printPegConsVolData(theExplodeWitRun, 1);
  }

  bool doPIP = setOfParameters.getBool("doPIP");

a270 2
#endif  

d4379 1
a4379 1
      printPegConsVolData(theWitRun,0);
a4395 3
      printPegConsVolData(theWitRun,0);
    bool doPIP = setOfParameters.getBool("doPIP");
    if (doPIP)
a4396 1

a4446 1
#ifdef PEGGING_ENABLED
d4448 1
a4448 1
LgFrScenarioForSce::printPegConsVolData(WitRun * const theWitRun, int isItMrp)
d4456 10
a4483 1
#ifdef PRODVOLPEGGING
a4485 2
#endif
  
d4489 6
a4512 1
#ifdef PRODVOLPEGGING
a4514 1
#endif
a4518 1

d4524 1
a4524 1
  std::cout << "Writing Pegging information..." << std::endl;    
d4536 1
a4536 1
  // DemandConsPegFile 
d4538 1
a4538 1
  if (printDemandConsPegFile)  {
d4540 1
a4540 1
    std::ofstream dPegFile;
d4543 3
a4545 3
    dPegFile.open(demandConsPegFileName.c_str(), std::ofstream::out);
    if (dPegFile.fail()) {
      std::string fileErrorString("Demand Pegging Consumption File");
d4548 1
a4548 1
			 << demandConsPegFileName);
d4582 2
a4583 2
	// Get const references to the consVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingConsVolSched();
d4586 1
a4586 1
	int nConsumedParts = pegSched.size();
d4590 1
a4590 1
	  const LgFrPart & part = pegSched.part(cp);
d4598 1
a4598 1
	  // Get this  pegconsVol timeVec
d4600 1
a4600 1
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4602 2
a4603 2
	  //  write the peg TimeVec data
	  dPegFile << "\""
d4608 1
a4608 1
	  flatFileMgr_.writeCsvFloatVector(dPegFile, nPeriods, pegTV.data(), 0, 15);
d4618 1
a4618 1
    dPegFile.close();
d4623 1
a4623 1
  // indpDemandConsPegFile 
d4625 1
a4625 1
  if (printIndpDemandConsPegFile)  {
d4627 1
a4627 1
    std::ofstream idPegFile;
d4629 4
a4632 4
    // Now open the Independent Demand Peg OUTPUT file
    idPegFile.open(indpDemandConsPegFileName.c_str());
    if (idPegFile.fail()) {
      std::string fileErrorString("Independent Demand Pegging Consumption File");
d4635 1
a4635 1
			 << indpDemandConsPegFileName);
d4669 2
a4670 2
	// Get const references to the consVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingConsVolSched();
d4673 1
a4673 1
	int nConsumedParts = pegSched.size();
d4677 1
a4677 1
	  const LgFrPart & consumedPart = pegSched.part(cp);
d4684 2
a4685 2
	  // Get this  pegconsVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4687 2
a4688 2
	  //  write the pegConsVol record: PEGConsVol
	  idPegFile << "\""
d4694 1
a4694 1
	  flatFileMgr_.writeCsvFloatVector(idPegFile, nPeriods, pegTV.data(), 0, 15);
d4702 1
a4702 1
    idPegFile.close();
d4705 5
d4711 1
a4711 1
  // ExecVolPegFile  (diagnostic)
d4713 3
a4715 2
  if (printExecVolPegFile)  {
    std::ofstream evPegFile;
d4717 4
a4720 4
    // Now open the ExecVol Demand Peg OUTPUT file
    evPegFile.open(execVolPegFileName.c_str());
    if (evPegFile.fail()) {
      std::string fileErrorString("ExecVol Pegging File");
d4723 1
a4723 1
			 << execVolPegFileName);
d4757 2
a4758 3
	
	// Get const references to the execVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingExecVolSched();
d4761 1
a4761 1
	int nConsumedParts = pegSched.size();
d4765 1
a4765 1
	  const LgFrPart & operation = pegSched.part(cp);
d4767 4
a4771 1
	  // report ALL Operations
d4773 3
a4775 2
	  // Get this  pegExecVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4777 7
a4783 8
	  //  write the total Demand due to Focus: FSSReq
	  evPegFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\",\""
		    << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(evPegFile, nPeriods, pegTV.data(), 0, 15);
d4793 1
a4793 1
    evPegFile.close();
d4795 2
a4796 2

#ifdef PRODVOLPEGGING
d4798 1
a4798 1
  // ProdVolPegFile  (diagnostic)
d4800 3
a4802 2
  if (printProdVolPegFile)  {
    std::ofstream pvPegFile;
d4804 4
a4807 4
    // Now open the ExecVol Demand Peg OUTPUT file
    pvPegFile.open(prodVolPegFileName.c_str());
    if (pvPegFile.fail()) {
      std::string fileErrorString("ProdVol Pegging File");
d4810 1
a4810 1
			 << prodVolPegFileName);
d4813 2
d4818 1
a4818 1
      fullWitGPDPartName = partList[i];
d4820 2
a4821 3
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
d4827 1
a4827 1
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
a4828 2
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);
d4832 1
a4832 1
	demandName = dList[j];
d4836 1
a4836 1
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
d4844 2
a4845 2
	// Get const references to the execVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingExecVolSched();
d4847 6
d4854 2
a4855 13

	// TOMMY HERE
	// Loop over each operation
	int nOperations = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  // get operation
	  const LgFrPart & operation = pegSched.part(cp);
	  
	  
	  // only report on DEFAULT Operations  
	  if (! mpHelper.isPartNormal(theWitRun,
				      operation.name())) {
d4859 2
a4860 2
	  // Get this  pegExecVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4862 8
a4869 7
	  //  write the total Demand due to Focus: FSSReq
	  pvPegFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(pvPegFile, nPeriods, pegTV.data(), 0, 15);
a4871 2
	
	
d4877 1
a4877 1
    pvPegFile.close();
a4878 5
#endif




d4881 1
a4881 1
  // indpExecVolPegFile (diagnostic)
d4883 2
a4884 3
  if (printIndpExecVolPegFile)  {

    std::ofstream idEvPegFile;
d4886 4
a4889 4
    // Now open the Independent  Demand ExecVol  Peg OUTPUT file
    idEvPegFile.open(indpExecVolPegFileName.c_str());
    if (idEvPegFile.fail()) {
      std::string fileErrorString("Independent Demand ExecVol Pegging  File");
d4892 1
a4892 1
			 << indpExecVolPegFileName);
a4893 1
  
a4894 2
    char * fullWitDemandedPart;
    char * demandId;
d4898 1
a4898 1
      fullWitDemandedPart = partList[i];
d4900 3
a4902 2
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
d4908 1
a4908 1
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
d4910 2
d4915 1
a4915 1
	demandId = dList[j];
d4919 1
a4919 1
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
d4927 2
a4928 2
	// Get const references to the consVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingExecVolSched();
d4930 2
a4931 2
	// Loop over each operation
	int nOperations = pegSched.size();
d4933 1
a4933 1
	for ( cp=0; cp<nOperations; cp++ ) {
d4935 1
a4935 1
	  const LgFrPart & operation = pegSched.part(cp);
d4940 2
a4941 2
	  // Get this  pegExecVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4943 8
a4950 9
	  //  write the peg vector
	  idEvPegFile << "\""
		      << mpHelper.partname(fullWitDemandedPart) << "\",\""
		      << mpHelper.pdf(fullWitDemandedPart) << "\","
		      << demandId << "\",\""
		      << mpHelper.partname(operation.name()) << "\",\""
		      << mpHelper.pdf(operation.name()) << "\",\""
		      << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(idEvPegFile, nPeriods, pegTV.data(), 0, 15);
d4953 2
d4959 2
a4960 1
    idEvPegFile.close();
a4962 1

d4964 1
a4964 1
  // InterplantPegFile
d4966 2
a4967 3
  if (printInterplantPegFile)  {

    std::ofstream ipPegFile;
d4969 4
a4972 4
    // Now open the Interplant Demand Peg OUTPUT file
    ipPegFile.open(interplantPegFileName.c_str());
    if (ipPegFile.fail()) {
      std::string fileErrorString("Interplant Pegging File");
d4975 1
a4975 1
			 << interplantPegFileName);
a4976 1
  
d5010 2
a5011 2
	// Get const references to the execVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingExecVolSched();
d5013 5
a5017 2
	// Loop over each consumed part
	int nConsumedParts = pegSched.size();
d5019 8
a5026 6
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  const LgFrPart & part = pegSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, part.name(), pn1, customerPdf, pn2, supplierPdf)) {
d5030 1
a5030 842
	  // Get this  pegExecVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
	  
	  ipPegFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << pn1 << "\",\""
		    << customerPdf << "\",\""
		    << pn2 << "\",\""
		    << supplierPdf << "\"";
	  flatFileMgr_.writeCsvFloatVector(ipPegFile, nPeriods, pegTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    ipPegFile.close();
  }

  // --------------------------
  // indpInterplantPegFile
  // --------------------------
  if (printIndpInterplantPegFile)  {

    std::ofstream idIpPegFile;
  
    // Now open the Independent Interplant Demand Peg OUTPUT file
    idIpPegFile.open(indpInterplantPegFileName.c_str());
    if (idIpPegFile.fail()) {
      std::string fileErrorString("Independent Interplant Demand Pegging  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpInterplantPegFileName);
    }
  

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol Peg  schedules stored in app data
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingExecVolSched();
	
	// Loop over each consumed part
	int nOperations = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  const LgFrPart & operation = pegSched.part(cp);

	  // report only for interplant operations
	  std::string pn1,customerPdf,pn2,supplierPdf;
	  if (! mpHelper.isOperationSpecialInterplant(theWitRun, operation.name(), pn1, customerPdf, pn2, supplierPdf)) {
	    continue;
	  }
	  
	  // Get this  pegExecVol timeVec
	  LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
	  
	  idIpPegFile << "\""
		      << mpHelper.partname(fullWitDemandedPart) << "\",\""
		      << mpHelper.pdf(fullWitDemandedPart)      << "\",\""
		      << demandId << "\",\""
		      << pn1 << "\",\""
		      << customerPdf << "\",\""
		      << pn2 << "\",\""
		      << supplierPdf << "\"";
	  flatFileMgr_.writeCsvFloatVector(idIpPegFile, nPeriods, pegTV.data(), 0, 15);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }
    idIpPegFile.close();
  }


  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++) {
    witFree(partList[i]);
  }
  witFree(partList);


}    



// ===============================
// ====== Pegging Utilitiies ====
// ===============================
void
LgFrScenarioForSce::loadPegDataIntoAppData(WitRun * const theWitRun)
{
  int nPeriods;
  char  *partName, *demandName;

  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();

  std::cout << "... collecting Pegging information ..." << std::endl;    
    
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;

  bool pegSubUsageToPrimary = this->setOfParameters().getBool("pegSubUsageToPrimary");

  // Loop over parts to get demands
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      // Now for some fancy trickery !!!
      // if the part is a special feature part, then we must map the consVol over to 
      //     the GPD appData
      int isDemandSpecial = 0;
      isDemandSpecial = mpHelper.isDemandSpecialPureOptionBuildDemand(theWitRun, partName, demandName, pp, geo);
      if (! isDemandSpecial) {
	isDemandSpecial = mpHelper.isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
      }
 

      // get teh demandAppData, or create a new one if it doesn't exist.
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;

      // if the demand is a specialFeaturePart then get the gpd's appdata
      if (isDemandSpecial) {
	// get a witPartName for the GPD
	fullWitGPDPartName = mpHelper.geoPlannerDemandPartName(pp, geo);

	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
			   (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
			       (void *) demandAppDataPtr );
	}
      }
      else {
	witGetDemandAppData( theWitRun, partName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, partName, demandName,  
			       (void *) demandAppDataPtr );
	}
      }

#ifdef DEBUG_DUMP_FOR_PEGGING
      
      if (isDemandSpecial) {
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
      }
      
      std::cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << std::endl;

      demandAppDataPtr->peggingConsVolSched().print();
      std::cout << std::endl;

#endif

      // Get demands pegged consVol and directly store in appData
      ScePegging::getDemandConsVolPegging(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->peggingConsVolSched(), 
					  WitTRUE,
					  1 - pegSubUsageToPrimary);

      // Get demands pegged execVol and directly store in appData
      ScePegging::getDemandExecVolPegging(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->peggingExecVolSched());


#ifdef DEBUG_DUMP_FOR_PEGGING
      std::cout << "(after) JP's Get" << std::endl;
      demandAppDataPtr->peggingConsVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif

      witFree(dList[j]);
    }
    witFree(dList);
  }


  // clear the wit peggeing information
  witClearPegging(theWitRun);


}










void
LgFrScenarioForSce::printPIPData(WitRun * const theWitRun, int isItMrp)
{


  LgFrMultiPlantHelper & mpHelper = multiPlantHelper();
  LgFrSceSetOfParameters & setOfParameters =  this->setOfParameters();


  // supply pegging ...
  bool printSupplyPIPFile = setOfParameters.getBool("printSupplyPIPFile");
  bool printIndpSupplyPIPFile = setOfParameters.getBool("printIndpSupplyPIPFile");

  std::string supplyPIPFileName = setOfParameters.getString("supplyPIPFileName");
  std::string indpSupplyPIPFileName = setOfParameters.getString("indpSupplyPIPFileName");




  bool printDemandConsPIPFile = setOfParameters.getBool("printDemandConsPIPFile");
  bool printIndpDemandConsPIPFile = setOfParameters.getBool("printIndpDemandConsPIPFile");

  std::string demandConsPIPFileName = setOfParameters.getString("demandConsPIPFileName");
  std::string indpDemandConsPIPFileName = setOfParameters.getString("indpDemandConsPIPFileName");
  
  bool printInterplantPIPFile = setOfParameters.getBool("printInterplantPIPFile");
  bool printIndpInterplantPIPFile = setOfParameters.getBool("printIndpInterplantPIPFile");
  
  std::string interplantPIPFileName = setOfParameters.getString("interplantPIPFileName");
  std::string indpInterplantPIPFileName = setOfParameters.getString("indpInterplantPIPFileName");

  bool printExecVolPIPFile = setOfParameters.getBool("printExecVolPIPFile");
  bool printIndpExecVolPIPFile = setOfParameters.getBool("printIndpExecVolPIPFile");

  std::string execVolPIPFileName = setOfParameters.getString("execVolPIPFileName");
  std::string indpExecVolPIPFileName = setOfParameters.getString("indpExecVolPIPFileName");

#ifdef PRODVOLPEGGING
  bool printProdVolPIPFile = setOfParameters.getBool("printProdVolPIPFile");
  std::string prodVolPIPFileName = setOfParameters.getString("prodVolPIPFileName");
#endif
  


  if (isItMrp) {
    printSupplyPIPFile = setOfParameters.getBool("printMrpSupplyPIPFile");
    printIndpSupplyPIPFile = setOfParameters.getBool("printMrpIndpSupplyPIPFile");
    
    indpSupplyPIPFileName = setOfParameters.getString("mrpIndpSupplyPIPFileName");
    supplyPIPFileName = setOfParameters.getString("mrpSupplyPIPFileName");

    printDemandConsPIPFile = setOfParameters.getBool("printMrpDemandConsPIPFile");
    printIndpDemandConsPIPFile = setOfParameters.getBool("printMrpIndpDemandConsPIPFile");
    
    indpDemandConsPIPFileName = setOfParameters.getString("mrpIndpDemandConsPIPFileName");
    demandConsPIPFileName = setOfParameters.getString("mrpDemandConsPIPFileName");

    printInterplantPIPFile = setOfParameters.getBool("printMrpInterplantPIPFile");
    printIndpInterplantPIPFile = setOfParameters.getBool("printMrpIndpInterplantPIPFile");

    interplantPIPFileName = setOfParameters.getString("mrpInterplantPIPFileName");    
    indpInterplantPIPFileName = setOfParameters.getString("mrpIndpInterplantPIPFileName");

    printExecVolPIPFile = setOfParameters.getBool("printMrpExecVolPIPFile");
    printIndpExecVolPIPFile = setOfParameters.getBool("printMrpIndpExecVolPIPFile");

    execVolPIPFileName = setOfParameters.getString("mrpExecVolPIPFileName");    
    indpExecVolPIPFileName = setOfParameters.getString("mrpIndpExecVolPIPFileName");

#ifdef PRODVOLPEGGING
  printProdVolPIPFile = setOfParameters.getBool("printMrpProdVolPIPFile");
  prodVolPIPFileName = setOfParameters.getString("mrpProdVolPIPFileName");
#endif


  }

  int nPeriods;
  char  *demandName, *fullWitGPDPartName;
  
  int goodRec = 0;
  
  std::cout << "Writing PIP information..." << std::endl;    
  
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);
  
  
  std::string plannerPart, geo;


  // --------------------------
  // SupplyConsPIPFile 
  // --------------------------
  if (printSupplyPIPFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(supplyPIPFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Supply PIP File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << supplyPIPFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }

	  
	  // Get this  PIPsupplyVol timeVec

	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpDemandSupplyPIPFile 
  // --------------------------
  if (printIndpSupplyPIPFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Supply PIP OUTPUT file
    idPIPFile.open(indpSupplyPIPFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Supply PIP  File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpSupplyPIPFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPSupplyVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }






  // --------------------------
  // DemandConsPIPFile 
  // --------------------------
  if (printDemandConsPIPFile)  {

    std::ofstream dPIPFile;
  
    // Now open the Demand PIP OUTPUT file
    dPIPFile.open(demandConsPIPFileName.c_str(), std::ofstream::out);
    if (dPIPFile.fail()) {
      std::string fileErrorString("Demand PIP Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << demandConsPIPFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & part = PIPSched.part(cp);

	  // only report for normal parts
	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	    continue;
	  }

	  
	  // Get this  PIPconsVol timeVec

	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIP TimeVec data
	  dPIPFile << "\""
		   << plannerPart << "\",\""
		   << geo << "\",\""
		   << mpHelper.partname(part.name()) << "\",\""
		   << mpHelper.pdf(part.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(dPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    dPIPFile.close();
  }
  
  
  // --------------------------
  // indpDemandConsPIPFile 
  // --------------------------
  if (printIndpDemandConsPIPFile)  {

    std::ofstream idPIPFile;
  
    // Now open the Independent Demand PIP OUTPUT file
    idPIPFile.open(indpDemandConsPIPFileName.c_str());
    if (idPIPFile.fail()) {
      std::string fileErrorString("Independent Demand PIPging Consumption File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << indpDemandConsPIPFileName);
    }

    char * fullWitDemandedPart;
    char * demandId;
    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitDemandedPart = partList[i];
    
      // only want demands on normal parts
      if (! mpHelper.isPartNormal(theWitRun, fullWitDemandedPart)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, fullWitDemandedPart, &nDemands, &dList);
      

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandId = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitDemandedPart, demandId,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the consVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPConsVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & consumedPart = PIPSched.part(cp);

	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
	    continue;
	  }
	  
	  // Get this  PIPconsVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the PIPConsVol record: PIPConsVol
	  idPIPFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	witFree(dList[j]);
      }
      witFree(dList);
    }

    idPIPFile.close();
  }

  // --------------------------
  // ExecVolPIPFile  (diagnostic)
  // --------------------------
  if (printExecVolPIPFile)  {
    std::ofstream evPIPFile;
  
    // Now open the ExecVol Demand PIP OUTPUT file
    evPIPFile.open(execVolPIPFileName.c_str());
    if (evPIPFile.fail()) {
      std::string fileErrorString("ExecVol PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << execVolPIPFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	
	// Loop over each consumed part
	int nConsumedParts = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
	  // get part
	  const LgFrPart & operation = PIPSched.part(cp);


	  // report ALL Operations
	  
	  // Get this  PIPExecVol timeVec
	  LgFrTimeVecFloat PIPTV = PIPSched[cp].timeVecFloat();
	  
	  //  write the total Demand due to Focus: FSSReq
	  evPIPFile << "\""
		    << plannerPart << "\",\""
		    << geo << "\",\""
		    << mpHelper.partname(operation.name()) << "\",\""
		    << mpHelper.pdf(operation.name()) << "\",\""
		    << operation.name() << "\"";
	  flatFileMgr_.writeCsvFloatVector(evPIPFile, nPeriods, PIPTV.data(), 0, 15);
	  goodRec++;
	}
	
	
	witFree(dList[j]);
      }
      witFree(dList);
    }

    evPIPFile.close();
  }

#ifdef PRODVOLPEGGING
  // --------------------------
  // ProdVolPIPFile  (diagnostic)
  // --------------------------
  if (printProdVolPIPFile)  {
    std::ofstream pvPIPFile;
  
    // Now open the ExecVol Demand PIP OUTPUT file
    pvPIPFile.open(prodVolPIPFileName.c_str());
    if (pvPIPFile.fail()) {
      std::string fileErrorString("ProdVol PIPging File");
      (*sceErrFacility_)("CannotOpenFileForWrite",MclArgList() 
			 << fileErrorString 
			 << prodVolPIPFileName);
    }

    // Loop over parts to get demands
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
      fullWitGPDPartName = partList[i];
    
      // only want the GPD demands
      if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(theWitRun, fullWitGPDPartName,
						      plannerPart, geo)) {
	continue;
      }

      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
      
      // these are GPD demands, so we can assert there's at most one demand.
      assert(nDemands < 2);

      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
	demandName = dList[j];
	
	// get the demandAppData, if none exists, then skip it
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
	witGetDemandAppData( theWitRun, fullWitGPDPartName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  witFree (dList[j]);
	  continue;
	}
	
	
	// Get const references to the execVol PIP  schedules stored in app data
	const LgFrSortingPartScheduleFloat & PIPSched = demandAppDataPtr->PIPExecVolSched();
	


	// TOMMY HERE
	// Loop over each operation
	int nOperations = PIPSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
	  // get operation
	  const LgFrPart & operation = PIPSched.part(cp);
	  
	  
	  // only report on DEFAULT Operations  
	  if (! mpHelper.isPartNormal(theWitRun,
				      operation.name())) {
	    continue;
	  }
	  
	  // Get this  PIPExecVol timeVec
a5050 5
#endif




d5055 1
a5055 1
  if (printIndpExecVolPIPFile)  {
d5060 1
a5060 1
    idEvPIPFile.open(indpExecVolPIPFileName.c_str());
d5065 1
a5065 1
			 << indpExecVolPIPFileName);
d5138 1
a5138 1
  if (printInterplantPIPFile)  {
d5143 1
a5143 1
    ipPIPFile.open(interplantPIPFileName.c_str());
d5148 1
a5148 1
			 << interplantPIPFileName);
d5225 1
a5225 1
  if (printIndpInterplantPIPFile)  {
d5230 1
a5230 1
    idIpPIPFile.open(indpInterplantPIPFileName.c_str());
d5235 1
a5235 1
			 << indpInterplantPIPFileName);
d5343 1
a5343 1
  bool PIPSubUsageToPrimary = this->setOfParameters().getBool("PIPSubUsageToPrimary");
d5419 1
a5419 1
				  PIPSubUsageToPrimary);
a5453 1
#endif
@


1.23
log
@fixed critList bug
@
text
@d26 1
d272 9
d4409 4
d5279 1028
@


1.22
log
@minor updates for SCE
@
text
@d5114 1
a5114 1
		      << mpHelper.pdf(fullWitDemandedPart) << "\","
@


1.21
log
@modified smartExplode to enable  interplant sourced parts with missing
effective intervals so that they can explode.   Solution is to enable
any bop such that:
    producedPart is non-pcf,
    producedPart has 2 or more producing bops,
    default operation has zero bom entries
@
text
@d3662 5
d3670 1
d3703 37
d3960 1
a3960 1
   int i = 0; // Pulled out of the for below by RW2STL
d3971 2
a3972 1
	     << pd << "\n";
@


1.20
log
@boolean logic to implement subUsageReportMode was off by one bit.
@
text
@d5696 3
a5698 1
	  for (t=early; t<=late; t++) {
@


1.19
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d2190 1
a2190 1
  bool isDataTransformNecessary = ( sce::compareStringsCaseIns( subUsageReportMode, "parentprod" ) == 0 );  
@


1.18
log
@latest SCE updates for group sharing
@
text
@d2 6
a10 2
#include <rw/ctoken.h>
#include <rw/regexp.h>
d16 1
a16 1
#include <scenario/src/difPWatp.h>
d58 4
a61 4
  RWCString engine = setOfParameters().getString("engine");
  RWBoolean useFullExplodeUtility = setOfParameters().getBool("useFullExplodeUtility");
  RWBoolean fssFlag = setOfParameters().getBool("fssFlag");
  RWBoolean useSmartExplodeUtility = setOfParameters().getBool("useSmartExplodeUtility");
d134 1
a134 1
	 RWCString fileName,
d137 1
a137 1
   ofstream outFile(fileName, ios::out, 0666);
d158 2
a159 1
   for (int i=0; i<nParts; i++ ) {
d169 2
a170 1
       for (int j=0; j<nDemands; j++) {
d173 2
a174 1
	 for (int tt=0; tt<nPeriods; tt++) {
d192 2
a193 1
	 for (int tt=0; tt<nPeriods; tt++) {
d213 2
a214 2
       RWCString partname = mpHelper.partname(partList[i]);
       RWCString pdf = mpHelper.pdf(partList[i]);
d239 1
a239 1
  if (exploderPtr_ == NULL) {
d257 1
a257 1
  cout << "Executing explosion engine using (" << myExploder->title() << ") scheme  ..." << endl;  
d265 1
a265 1
  RWBoolean doPegging = setOfParameters.getBool("doPegging");
d276 2
a277 2
    cout << "Writing the Explode echo file  ..." << endl;                
    RWCString explodeEchoFileName = setOfParameters.getString("explodeEchoFileName");
d279 1
a279 1
    witDisplayData( theExplodeWitRun, explodeEchoFileName);
d287 2
a288 2
    cout << "Writing the (Explode) wit data file ..." << endl;                      
    RWCString explodeWitDataFileName = setOfParameters.getString("explodeWitDataFileName");
d290 1
a290 1
    witWriteData(theExplodeWitRun, explodeWitDataFileName);
d313 1
a313 1
  cout << "Writing explosion output results  ..." << endl;  
d356 1
a356 1
  RWBoolean printTotalDemandReport =
d360 1
a360 1
    RWCString totalDemandReportFileName = setOfParameters.getString("totalDemandReportFileName");
d390 1
a390 1
  RWBoolean printOperationDemandFile = setOfParameters.getBool("printOperationDemandFile");
d392 1
a392 1
    RWCString operationDemandFileName = setOfParameters.getString("operationDemandFileName");
d405 4
a408 4
  RWBoolean printInterplantDemandFile = setOfParameters.getBool("printInterplantDemandFile");
  RWCString interPlantFile = setOfParameters.getString("interPlantFile");
  if ((! interPlantFile.isNull()) && printInterplantDemandFile )   {
    RWCString interplantDemandFileName =
d410 1
a410 1
    RWBoolean isThisMrp = TRUE;
d423 4
a426 4
  RWBoolean printBinDemandFile = setOfParameters.getBool("printBinDemandFile");
  RWCString binFile = setOfParameters.getString("binFile");
  if ((! binFile.isNull()) && printBinDemandFile )   {
    RWCString binDemandFileName =
d428 1
a428 1
    RWBoolean isThisMrp = TRUE;
d442 6
a447 6
  RWBoolean useSmartExplodeUtility = setOfParameters.getBool("useSmartExplodeUtility");
  RWCString subBomFile = setOfParameters.getString("subBomFile");    
  if (useSmartExplodeUtility && (! subBomFile.isNull()))   {
    RWCString mrpSubUsageFileName = setOfParameters.getString("mrpSubUsageFileName");
    RWBoolean parentMustBeUserDefinedOperation = FALSE;
    RWBoolean engineMustBeImplode = FALSE;
d459 5
a463 5
  RWCString opSubBomFile = setOfParameters.getString("opSubBomFile");    
  if (useSmartExplodeUtility && (! opSubBomFile.isNull()))   {
    RWCString mrpOpSubUsageFileName = setOfParameters.getString("mrpOpSubUsageFileName");
    RWBoolean parentMustBeUserDefinedOperation = TRUE;
    RWBoolean engineMustBeImplode = FALSE;
d474 1
a474 1
    RWCString mrpSupplyOrdersFileName = setOfParameters.getString("mrpSupplyOrdersFileName");
d480 1
a480 1
    RWCString mrpDemandOrdersFileName = setOfParameters.getString("mrpDemandOrdersFileName");
d488 1
a488 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d492 1
a492 1
      RWCString partDBFileName = setOfParameters.getString("partDBFileName");
d498 1
a498 1
      RWCString capacityDBFileName =
d507 1
a507 1
      RWCString operationDBFileName =
d520 2
a521 1
  for (int i=0; i<nParts; i++)  
d525 2
a526 1
  for (int o=0; o<nOperations; o++)  
d582 1
a582 1
LgFrScenarioForSce::setEngine(const RWCString & engine)
d584 2
a585 1
    engine_ = toLower(engine);
d588 1
a588 1
RWCString 
d601 2
a602 2
    const RWCString & geoPlannerDemandPartName,
    RWCString * sourceList)
d604 4
a607 4
  RWCString mfgPart;
  RWCString pdf;
  RWCString geo;
  RWCString plannerPart;
d624 3
a626 3
  RWCString unknownPdf("???");
  RWCString unknownMfgPart("??????");
  RWCString unknownPartPdf = mpHelper.pdfPartname(unknownMfgPart, unknownPdf);
d640 1
a640 1
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName, &nBom);
d642 1
a642 1
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName, b, &child);
d648 2
a649 2
    witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName, b, &early);
    witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName, b, &late);
d679 1
a679 1
	 RWCString fileName)
d681 1
a681 1
  ofstream outFile(fileName, ios::out, 0666);
d723 1
a723 1
   RWCString d1, d2, d3, d4;
d729 1
a729 1
     RWCString thePart = partList[i];
d732 1
a732 1
     witGetPartNProducingBopEntries(theWitRun, thePart, &npBops);
d790 1
a790 1
     RWCString theOperation(opList[o]);
d792 1
a792 1
     witGetOperationNBomEntries(theWitRun, theOperation, &nBom);
d811 1
a811 1
       witGetPartExists(theWitRun, theOperation, &exists);
d824 1
a824 1
     RWCString fullWitFeaturePartName(partList[i]);
d828 6
a833 5
       witGetPartDemands( theWitRun, fullWitFeaturePartName, &lenDemandList, &demandList);
       for (int j=0; j<lenDemandList; j++) {
	 RWCString fullWitGeoPlannerDemandName(demandList[j]);
	 RWCString plannerPart;
	 RWCString geo;
d848 1
a848 1
     RWCString fullWitFeaturePartName(partList[i]);
d852 6
a857 5
       witGetPartDemands( theWitRun, fullWitFeaturePartName, &lenDemandList, &demandList);
       for (int j=0; j<lenDemandList; j++) {
	 RWCString fullWitGeoPlannerDemandName(demandList[j]);
	 RWCString plannerPart;
	 RWCString geo;
d882 1
a882 1
     RWCString thePart = partList[i];
d886 1
a886 1
     witGetPartNProducingBopEntries(theWitRun, thePart, &npBops);
d891 1
a891 1
     witGetOperationExists(theWitRun, thePart, &exists);
d895 1
a895 1
     witGetOperationNBomEntries(theWitRun, thePart, &nBom);
d905 2
a906 2
     witGetOperationYieldRate(theWitRun, thePart, &yieldRate);
     RWBoolean uncWaif=TRUE;
d909 1
a909 1
	 uncWaif = FALSE;
d985 1
a985 1
	 RWCString fileName)
d987 1
a987 1
  ofstream outFile(fileName, ios::out, 0666);
d1007 1
a1007 1
     RWCString thePart = partList[i];
d1011 1
a1011 1
     witGetPartNProducingBopEntries(theWitRun, thePart, &npBops);
d1016 1
a1016 1
     witGetOperationExists(theWitRun, thePart, &exists);
d1020 1
a1020 1
     witGetOperationNBomEntries(theWitRun, thePart, &nBom);
d1049 1
a1049 1
	 RWCString fileName)
d1051 1
a1051 1
  ofstream outFile(fileName, ios::out, 0666);
d1065 1
a1065 1
     RWCString thePart = partList[i];
d1092 2
a1093 2
	 RWCString & engine,
	 RWCString fileName)
d1096 1
a1096 1
  RWCString partName;
d1098 1
a1098 1
  ofstream outFile(fileName, ios::out, 0666);
d1134 1
a1134 1
	 if (! engine.compareTo("optimization", RWCString::ignoreCase)) {
d1147 1
a1147 1
	   if (! engine.compareTo("optimization", RWCString::ignoreCase)) {
d1162 1
a1162 1
	   if (! engine.compareTo("optimization", RWCString::ignoreCase)) {           
d1191 1
a1191 1
   if (! engine.compareTo("optimization", RWCString::ignoreCase)) {
d1218 1
a1218 1
    RWCString fileName)
d1221 1
a1221 1
  ofstream outFile(fileName, ios::out, 0666);
d1240 2
a1241 2
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d1247 1
a1247 1
  RWBoolean anyUserDefinedOperations = FALSE;
d1251 2
a1252 2
  if (! setOfParameters.getString("opFile").isNull()) {
    anyUserDefinedOperations = TRUE;
d1260 1
a1260 1
    RWCString fullPartName(partList[i]);
d1264 2
a1265 2
    RWCString pn(mpHelper.partname(fullPartName));
    RWCString pdf(mpHelper.pdf(fullPartName));
d1269 1
a1269 1
    witGetPartSupplyVol(theWitRun, fullPartName, &witVector);
d1289 2
a1290 1
    for (int t=0; t<nPeriods; t++) {
d1299 1
a1299 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d1307 2
a1308 1
	for (int t=0; t<nPeriods; t++) {
d1317 1
a1317 1
	RWBoolean foundOpCategory = FALSE;          
d1319 1
a1319 1
	RWCString cp1, pdf1, sp2, pdf2;
d1328 2
a1329 2
	witGetPartProducingBopEntry(theWitRun, fullPartName, p, &witOperationName, &b);
	RWCString operationName(witOperationName);
d1347 2
a1348 1
	  for (int t=early; t<=late; t++) {
d1359 1
a1359 1
	  foundOpCategory = TRUE;
d1392 1
a1392 1
      witGetPartExcessVol(theWitRun, fullPartName, &witVector);
d1397 1
a1397 1
      witGetPartScrapVol(theWitRun, fullPartName, &witVector);
d1402 1
a1402 1
      witGetPartConsVol(theWitRun, fullPartName, &witVector);
d1429 1
a1429 1
	 RWCString fileName,
d1434 1
a1434 1
  RWCString partName;
d1436 1
a1436 1
  ofstream outFile(fileName, ios::out, 0666);
d1448 4
a1451 4
  RWCString plannerTopLevelPart;
  RWCString geo;
  RWCString mfgOptionPart;
  RWCString bbCategory;
d1464 4
a1467 4
    RWCString custChoiceFeaturePart(partList[i]);
    RWCString featurePart;
    RWCString ppp;
    RWCString mmm, ggg;
d1476 1
a1476 1
      witGetPartDemands( theWitRun, custChoiceFeaturePart, &lenDemandList, &demandList);
d1482 5
a1486 4
      for (int j=0; j<lenDemandList; j++) {
	RWCString custChoiceDemandName(demandList[j]);
	RWCString plannerPart;
	RWCString geo;
d1499 1
a1499 1
	witGetPartNConsumingBomEntries(theWitRun, custChoiceFeaturePart, &ncbe);
d1503 1
a1503 1
	witGetPartConsumingBomEntry(theWitRun, custChoiceFeaturePart, 0, &gpdWitPartName, &bomIndex);
d1517 1
a1517 1
	witGetPartSupplyVol(theWitRun, custChoiceFeaturePart, &sfpSupplyVol);
d1521 1
a1521 1
	witGetOperationExecVol(theWitRun, custChoiceFeaturePart, &sfpExecVol);
d1523 2
a1524 1
	for (int t=0; t<nPeriods; t++)  
d1532 1
a1532 1
	witGetPartConsVol(theWitRun, custChoiceFeaturePart, &featureConsVol);
d1537 1
a1537 1
	witGetPartExcessVol(theWitRun, custChoiceFeaturePart, &ccfeatureExcessVol);
d1541 2
a1542 2
	float * shipVol = NULL;
	witGetDemandShipVol( theWitRun, custChoiceFeaturePart, custChoiceDemandName, &shipVol);
d1554 2
a1555 1
	  for (int t=0; t<nPeriods; t++)   {
d1564 2
a1565 1
	  for (int t=0; t<nPeriods; t++)   {
d1593 1
a1593 1
  // Now look at STANDALONE OPTIONS modeled via NULL SUBSTITUTE !!
d1599 4
a1602 4
    RWCString fullWitFeaturePartName(partList[i]);
    RWCString featurePart;
    RWCString ppp;
    RWCString mmm, ggg;
d1611 1
a1611 1
      witGetPartDemands( theWitRun, fullWitFeaturePartName, &lenDemandList, &demandList);
d1617 5
a1621 4
      for (int j=0; j<lenDemandList; j++) {
	RWCString fullWitStandaloneFeatureDemandName(demandList[j]);
	RWCString plannerPart;
	RWCString geo;
d1631 1
a1631 1
	RWCString plannerTopLevelPart = mpHelper.geoPlannerDemandPartName(plannerPart, geo);
d1635 1
a1635 1
	witGetPartProdVol(theWitRun, plannerTopLevelPart, &gpdProdVol);
d1641 1
a1641 1
	witGetDemandShipVol( theWitRun, fullWitFeaturePartName, fullWitStandaloneFeatureDemandName, &shipVol);
d1643 1
a1643 1
	witGetPartSupplyVol(theWitRun, fullWitFeaturePartName, &fen5supplyVol);
d1647 2
a1648 1
	  for (int t=0; t<nPeriods; t++)   {
d1656 2
a1657 1
	  for (int t=0; t<nPeriods; t++)   {
d1666 3
a1668 2
	witGetPartNBomEntries(theWitRun, plannerTopLevelPart, &nBom);
	for (int k=0; k<nBom; k++)  {
d1670 2
a1671 2
	  witGetBomEntryConsumedPart(theWitRun, plannerTopLevelPart, k, &child);
	  RWCString childPart(child);
d1680 3
a1682 2
	  witGetBomEntryNSubsBomEntries(theWitRun, plannerTopLevelPart, k, &nSubBom);
	  for (int sj=0; sj<nSubBom; sj++)  {
d1685 1
a1685 1
	    witGetSubsBomEntryConsumedPart(theWitRun, plannerTopLevelPart, k, sj, &sub);
d1691 1
a1691 1
	    witGetSubsBomEntryProdVol(theWitRun, plannerTopLevelPart, k, sj, &subProdVol);
d1694 1
a1694 1
	    witGetBomEntryUsageRate(theWitRun, plannerTopLevelPart, k, &usageRatio);
d1696 2
a1697 2
	    witGetBomEntryEarliestPeriod(theWitRun, plannerTopLevelPart, k, &early);
	    witGetBomEntryLatestPeriod(theWitRun, plannerTopLevelPart, k, &late);            
d1743 1
a1743 1
	 RWCString fileName,
d1748 1
a1748 1
   RWCString partName;
d1750 1
a1750 1
   ofstream outFile(fileName, ios::out, 0666);
d1762 4
a1765 4
   RWCString plannerTopLevelPart;
   RWCString geo;
   RWCString mfgOptionPart;
   RWCString bbCategory;
d1772 1
a1772 1
     RWCString fullWitPartName(partList[i]);
d1775 1
a1775 1
       if (bbCategory.contains("STANDALONE:", RWCString::ignoreCase))
d1780 1
a1780 1
       witGetPartConsVol(theWitRun, fullWitPartName, &orsConsVol);
d1787 1
a1787 1
	 RWCString geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
d1790 1
a1790 1
	 witGetOperationExecVol(theWitRun, geoPlannerDemandPart, &gpdExecVol);
d1825 1
a1825 1
	 RWCString fileName,
d1830 1
a1830 1
   RWCString partName;
d1832 1
a1832 1
   ofstream outFile(fileName, ios::out, 0666);
d1844 4
a1847 4
   RWCString plannerTopLevelPart;
   RWCString geo;
   RWCString mfgOptionPart;
   RWCString bbCategory;
d1854 1
a1854 1
     RWCString fullWitPartName(partList[i]);
d1857 1
a1857 1
       if (bbCategory.contains("STANDALONE:", RWCString::ignoreCase))
d1862 1
a1862 1
       witGetPartProdVol(theWitRun, fullWitPartName, &sodProdVol);
d1869 1
a1869 1
	 RWCString geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
d1872 1
a1872 1
	 witGetPartProdVol(theWitRun, geoPlannerDemandPart, &gpdProdVol);
d1913 1
a1913 1
	 RWCString fileName,
d1917 1
a1917 1
  RWCString partName;
d1919 1
a1919 1
  ofstream outFile(fileName, ios::out, 0666);
d1930 3
a1932 2
  for (int i=0; i<nParts; i++ ) {
    RWCString fullWitPartName  = partList[i];
d1937 1
a1937 1
    witGetPartCategory(theWitRun, fullWitPartName, &category);
d1942 1
a1942 1
    witGetPartNBomEntries(theWitRun, fullWitPartName, &nBom);
d1944 2
a1945 1
    for (int j=0; j<nBom; j++)  {
d1947 1
a1947 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName, j, &nSubBom);
d1950 4
a1953 3
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName, j, &child);
	RWCString childPartname =  mpHelper.partname(child);
	for (int sj=0; sj<nSubBom; sj++)  {
d1956 1
a1956 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName, j, sj, &sub);
d1961 2
a1962 2
	  RWCString subPartname =  mpHelper.partname(sub);
	  RWCString subPdf =  mpHelper.pdf(sub);
d1965 1
a1965 1
	  RWCString parentPartname = mpHelper.partname(fullWitPartName);
d1996 1
a1996 1
	 RWCString fileName,
d1999 1
a1999 1
  RWCString partName;
d2004 1
a2004 1
  ofstream outFile(fileName, ios::out, 0666);
d2015 3
a2017 2
  for (int i=0; i<nParts; i++ ) {
    RWCString fullWitPartName  = partList[i];
d2022 1
a2022 1
    witGetPartCategory(theWitRun, fullWitPartName, &category);
d2027 1
a2027 1
    witGetPartNBomEntries(theWitRun, fullWitPartName, &nBom);
d2029 2
a2030 1
    for (int j=0; j<nBom; j++)  {
d2032 1
a2032 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName, j, &nSubBom);
d2035 4
a2038 3
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName, j, &child);
	RWCString childPartname =  mpHelper.partname(child);
	for (int sj=0; sj<nSubBom; sj++)  {
d2041 1
a2041 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName, j, sj, &sub);
d2046 2
a2047 2
	  RWCString subPartname =  mpHelper.partname(sub);
	  RWCString subPdf =  mpHelper.pdf(sub);
d2050 1
a2050 1
	  RWCString parentPartname = mpHelper.partname(fullWitPartName);
d2081 1
a2081 1
	 RWCString fileName,
d2085 1
a2085 1
  ofstream outFile(fileName, ios::out, 0666);
d2094 2
a2095 2
  RWCString parentOperationName;
  RWCString pdf;
d2098 3
a2100 2
  for (int o=0; o<nOperations; o++ ) {
    RWCString fullWitOperationName = opList[o];
d2108 1
a2108 1
    witGetOperationNBomEntries(theWitRun, fullWitOperationName, &nBom);
d2110 2
a2111 1
    for (int j=0; j<nBom; j++)  {
d2113 1
a2113 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitOperationName, j, &nSubBom);
d2116 4
a2119 3
	witGetBomEntryConsumedPart(theWitRun, fullWitOperationName, j, &child);
	RWCString childPartname =  mpHelper.partname(child);
	for (int sj=0; sj<nSubBom; sj++)  {
d2122 1
a2122 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitOperationName, j, sj, &sub);
d2127 1
a2127 1
	  RWCString subPartname =  mpHelper.partname(sub);
d2129 1
a2129 1
	  witGetSubsBomEntryProdVol(theWitRun, fullWitOperationName, j, sj, &subProdVol);
d2160 2
a2161 2
	 RWBoolean parentMustBeUserDefinedOperation,
	 RWBoolean engineMustBeImplode,
d2165 1
a2165 1
	 RWCString fileName,
d2168 1
a2168 1
  ofstream outFile(fileName, ios::out, 0666);
d2189 3
a2191 5


  RWCString subUsageReportMode =  this->setOfParameters().getString("subUsageReportMode");
  RWBoolean isDataTransformNecessary = (subUsageReportMode.compareTo("parentprod", RWCString::ignoreCase) ? 1 : 0);  
  RWBoolean transformToPrimary = TRUE;
d2193 1
a2193 1
    transformToPrimary = (subUsageReportMode.compareTo("primaryCoverage", RWCString::ignoreCase) ? 0 : 1);  
d2197 2
a2198 2
  RWCString parentOperationName;
  RWCString pdf;
d2201 3
a2203 2
  for (int o=0; o<nOperations; o++ ) {
    RWCString fullWitOperationName = opList[o];
d2228 1
a2228 1
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName, &nBom);
d2230 2
a2231 1
    for (int j=0; j<nBom; j++)  {
d2233 1
a2233 1
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName, j, &nSubBom);
d2236 4
a2239 3
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName, j, &child);
	RWCString childPartname =  mpHelper.partname(child);
	for (int sj=0; sj<nSubBom; sj++)  {
d2242 1
a2242 1
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName, j, sj, &sub);
d2247 1
a2247 1
	  RWCString subPartname =  mpHelper.partname(sub);
d2250 1
a2250 1
	    witGetSubsBomEntryProdVol(theRightWitRun, fullWitOperationName, j, sj, &subProdVol);
d2268 1
a2268 1
	      witGetBomEntryConsRate(theRightWitRun, fullWitOperationName, j, &consRate);
d2270 1
a2270 1
	      witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName, j, &falloutRate);
d2272 1
a2272 1
	      witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName, j, &impactPeriod);
d2276 1
a2276 1
	      witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName, j, sj, &consRate);
d2278 1
a2278 1
	      witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName, j, sj, &falloutRate);
d2280 1
a2280 1
	      witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName, j, sj, &impactPeriod);
d2323 1
a2323 1
	 RWCString fileName,
d2326 1
a2326 1
  ofstream outFile(fileName, ios::out, 0666);
d2341 2
a2342 1
   for (int i=0; i<nParts; i++ ) {
d2347 2
a2348 2
     RWCString part = mpHelper.partname(partList[i]);
     RWCString pdf = mpHelper.pdf(partList[i]);
d2358 3
a2360 2
     RWBoolean isVecNonZero = FALSE;
     for (int t=0; t<nPeriods; t++) {
d2362 1
a2362 1
	 isVecNonZero = TRUE;
d2400 2
a2401 2
	 RWBoolean isThisMrp,
	 RWCString fileName,
d2404 1
a2404 1
  ofstream outFile(fileName, ios::out, 0666);
d2424 4
a2427 4
   RWCString destination;
   RWCString destinationPdf;
   RWCString source;
   RWCString sourcePdf;
d2432 2
a2433 1
   for (int o=0; o<nOps; o++ ) {
d2438 1
a2438 1
     RWCString operationName(opList[o]);
d2448 3
a2450 2
     RWBoolean isVecNonZero = FALSE;
     for (int t=0; t<nPeriods; t++) {
d2452 1
a2452 1
	 isVecNonZero = TRUE;
d2487 2
a2488 2
	 RWBoolean isThisMrp,
	 RWCString fileName,
d2491 1
a2491 1
  ofstream outFile(fileName, ios::out, 0666);
d2511 4
a2514 4
   RWCString destination;
   RWCString destinationPdf;
   RWCString source;
   RWCString sourcePdf;
d2519 2
a2520 1
   for (int o=0; o<nOps; o++ ) {
d2525 1
a2525 1
     RWCString operationName(opList[o]);
d2535 3
a2537 2
     RWBoolean isVecNonZero = FALSE;
     for (int t=0; t<nPeriods; t++) {
d2539 1
a2539 1
	 isVecNonZero = TRUE;
d2579 3
a2581 2
  for ( int o=0; o<nOperations; o++) {
    RWCString operationName (operationList[o]);
d2583 4
a2586 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d2594 1
a2594 1
    witGetOperationNBomEntries( theWitRun, operationName, &nBoms);
d2596 1
a2596 1
	  cerr << "\nJumper Arc Error SYS268E: Interplant operations"
d2598 1
a2598 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << endl;
d2603 2
a2604 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = NULL ;
    witGetOperationAppData( theWitRun, operationName.data(),
d2609 1
a2609 1
    assert ( operationAppDataPtr != NULL );
d2612 1
a2612 1
    witGetOperationExecVol(theWitRun, operationName, &execVol);
d2624 1
a2624 1
    RWCString operationName (operationList[o]);
d2628 4
a2631 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;
    RWCString sPdf;
d2637 1
a2637 1
    RWCString sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2639 2
a2640 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = NULL;
    witGetOperationAppData( theWitRun, operationName.data(),
d2642 1
a2642 1
    assert ( operationAppDataPtr != NULL );
d2647 3
a2649 2
    witGetBomEntryNSubsBomEntries( theWitRun, operationName, 0, &nSubBoms );
    for ( int s=0; s<nSubBoms; s++) {
d2652 1
a2652 1
				      operationName, 0, s,
d2658 3
a2660 3
      RWCString subPart = mpHelper.partname( subPdfPart );
      RWCString subPdf = mpHelper.pdf( subPdfPart );
      RWCString subIpOp = mpHelper.interPlantOperationName(
d2662 4
a2665 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;      
      RWCString sourcePdf;
d2674 2
a2675 2
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = NULL;
      witGetOperationAppData( theWitRun, subIpOp,
d2677 1
a2677 1
      assert ( subIpOpAppDataPtr != NULL );
d2682 1
a2682 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName, 0, s, &subUsageRate );
d2686 1
a2686 1
      witGetSubsBomEntrySubVol( theWitRun, operationName, 0, s, &subVol );
d2691 2
a2692 1
      for (int t=0; t<nPeriods; t++) {
d2718 1
a2718 1
LgFrScenarioForSce::interplantExecVol(RWCString & operationName)
d2721 2
a2722 2
  LgFrSceInterplantOpAppData * operationAppDataPtr = NULL ;
  witGetOperationAppData( theWitRun, operationName,
d2724 1
a2724 1
  assert ( operationAppDataPtr != NULL );
d2730 1
a2730 1
LgFrScenarioForSce::interplantMrpExecVol(RWCString & operationName)
d2733 2
a2734 2
  LgFrSceInterplantOpAppData * operationAppDataPtr = NULL ;
  witGetOperationAppData( theWitRun, operationName,
d2736 1
a2736 1
  assert ( operationAppDataPtr != NULL );
d2756 3
a2758 2
  for ( int o=0; o<nOperations; o++) {
    RWCString operationName (operationList[o]);
d2760 4
a2763 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d2771 1
a2771 1
    witGetOperationNBomEntries( theWitRun, operationName, &nBoms);
d2773 3
a2775 3
	  cerr << "\nJumper Arc Error SYS269E: Interplant operations"
	       << operationName.data()
	       << " does not have exactly one bom entry. Contact SCE Support\n" << endl;
d2784 2
a2785 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = NULL ;
    witGetOperationAppData( theWitRun, operationName.data(),
d2787 1
a2787 1
    assert ( operationAppDataPtr == NULL );
d2793 1
a2793 1
    witSetOperationAppData( theWitRun, operationName, (void *) operationAppDataPtr );
d2801 1
a2801 1
    RWCString operationName (operationList[o]);
d2804 4
a2807 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d2815 1
a2815 1
    RWCString sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2817 3
a2819 3
    LgFrSceInterplantOpAppData * operationAppDataPtr = NULL;
    witGetOperationAppData( theWitRun, operationName, (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != NULL );
d2824 1
a2824 1
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.data(), 0, &nSubBoms );
d2826 2
a2827 1
    for ( int s=0; s<nSubBoms; s++) {
d2830 1
a2830 1
				      operationName, 0, s, &subPdfPart );
d2835 3
a2837 3
      RWCString subPart = mpHelper.partname( subPdfPart );
      RWCString subPdf = mpHelper.pdf( subPdfPart );
      RWCString subIpOp = mpHelper.interPlantOperationName(
d2839 4
a2842 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;      
      RWCString sourcePdf;
d2846 2
a2847 2
	cerr << "\nJumper Arc Error: Interplant operation "
	     <<  operationName.data()
d2850 1
a2850 1
	     << " that is not valid. Contact SCE Support\n" << endl;
d2855 2
a2856 2
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = NULL;
      witGetOperationAppData( theWitRun, subIpOp,
d2858 1
a2858 1
      assert ( subIpOpAppDataPtr != NULL );
d2863 1
a2863 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName, 0, s, &subUsageRate );
d2872 2
a2873 1
      for (int t=0; t<nPeriods; t++) {
d2910 3
a2912 2
  for ( int o=0; o<nOperations; o++) {
    RWCString operationName (operationList[o]);
d2914 4
a2917 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d2925 1
a2925 1
    witGetOperationNBomEntries( theWitRun, operationName, &nBoms);
d2927 1
a2927 1
	  cerr << "\nJumper Arc Error SYS269E: Bin operations"
d2929 1
a2929 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << endl;
d2934 2
a2935 2
    LgFrSceBinOpAppData * operationAppDataPtr = NULL ;
    witGetOperationAppData( theWitRun, operationName.data(),
d2940 1
a2940 1
    assert ( operationAppDataPtr != NULL );
d2943 1
a2943 1
    witGetOperationExecVol(theWitRun, operationName, &execVol);
d2955 1
a2955 1
    RWCString operationName (operationList[o]);
d2959 4
a2962 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;
    RWCString sPdf;
d2968 1
a2968 1
    RWCString sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2970 2
a2971 2
    LgFrSceBinOpAppData * operationAppDataPtr = NULL;
    witGetOperationAppData( theWitRun, operationName.data(),
d2973 1
a2973 1
    assert ( operationAppDataPtr != NULL );
d2978 3
a2980 2
    witGetBomEntryNSubsBomEntries( theWitRun, operationName, 0, &nSubBoms );
    for ( int s=0; s<nSubBoms; s++) {
d2983 1
a2983 1
				      operationName, 0, s,
d2989 3
a2991 3
      RWCString subPart = mpHelper.partname( subPdfPart );
      RWCString subPdf = mpHelper.pdf( subPdfPart );
      RWCString subIpOp = mpHelper.binOperationName(
d2993 4
a2996 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;      
      RWCString sourcePdf;
d3005 2
a3006 2
      LgFrSceBinOpAppData * subIpOpAppDataPtr = NULL;
      witGetOperationAppData( theWitRun, subIpOp,
d3008 1
a3008 1
      assert ( subIpOpAppDataPtr != NULL );
d3013 1
a3013 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName, 0, s, &subUsageRate );
d3017 1
a3017 1
      witGetSubsBomEntrySubVol( theWitRun, operationName, 0, s, &subVol );
d3022 2
a3023 1
      for (int t=0; t<nPeriods; t++) {
d3049 1
a3049 1
LgFrScenarioForSce::binExecVol(RWCString & operationName)
d3052 2
a3053 2
  LgFrSceBinOpAppData * operationAppDataPtr = NULL ;
  witGetOperationAppData( theWitRun, operationName,
d3055 1
a3055 1
  assert ( operationAppDataPtr != NULL );
d3061 1
a3061 1
LgFrScenarioForSce::binMrpExecVol(RWCString & operationName)
d3064 2
a3065 2
  LgFrSceBinOpAppData * operationAppDataPtr = NULL ;
  witGetOperationAppData( theWitRun, operationName,
d3067 1
a3067 1
  assert ( operationAppDataPtr != NULL );
d3087 3
a3089 2
  for ( int o=0; o<nOperations; o++) {
    RWCString operationName (operationList[o]);
d3091 4
a3094 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d3102 1
a3102 1
    witGetOperationNBomEntries( theWitRun, operationName, &nBoms);
d3104 3
a3106 3
	  cerr << "\nJumper Arc Error SYS270E: Bin operations"
	       << operationName.data()
	       << " does not have exactly one bom entry. Contact SCE Support\n" << endl;
d3115 2
a3116 2
    LgFrSceBinOpAppData * operationAppDataPtr = NULL ;
    witGetOperationAppData( theWitRun, operationName.data(),
d3118 1
a3118 1
    assert ( operationAppDataPtr == NULL );
d3124 1
a3124 1
    witSetOperationAppData( theWitRun, operationName, (void *) operationAppDataPtr );
d3132 1
a3132 1
    RWCString operationName (operationList[o]);
d3135 4
a3138 4
    RWCString dPart;
    RWCString dPdf;
    RWCString sPart;    
    RWCString sPdf;
d3146 1
a3146 1
    RWCString sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d3148 3
a3150 3
    LgFrSceBinOpAppData * operationAppDataPtr = NULL;
    witGetOperationAppData( theWitRun, operationName, (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != NULL );
d3155 1
a3155 1
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.data(), 0, &nSubBoms );
d3157 2
a3158 1
    for ( int s=0; s<nSubBoms; s++) {
d3161 1
a3161 1
				      operationName, 0, s, &subPdfPart );
d3166 3
a3168 3
      RWCString subPart = mpHelper.partname( subPdfPart );
      RWCString subPdf = mpHelper.pdf( subPdfPart );
      RWCString subIpOp = mpHelper.binOperationName(
d3170 4
a3173 4
      RWCString destPart;
      RWCString destPdf;
      RWCString sourcePart;      
      RWCString sourcePdf;
d3177 2
a3178 2
	cerr << "\nJumper Arc Error: Bin operation "
	     <<  operationName.data()
d3181 1
a3181 1
	     << " that is not valid. Contact SCE Support\n" << endl;
d3186 2
a3187 2
      LgFrSceBinOpAppData * subIpOpAppDataPtr = NULL;
      witGetOperationAppData( theWitRun, subIpOp,
d3189 1
a3189 1
      assert ( subIpOpAppDataPtr != NULL );
d3194 1
a3194 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName, 0, s, &subUsageRate );
d3203 2
a3204 1
      for (int t=0; t<nPeriods; t++) {
d3239 1
a3239 1
	 RWCString fileName,
d3242 1
a3242 1
   ofstream outFile(fileName, ios::out, 0666);
d3258 4
a3261 3
   for (int o=0; o<nOperations; o++ ) {
     RWCString thePdf;
     RWCString theOperation;
d3270 3
a3272 2
     RWBoolean isVecNonZero = FALSE;
     for (int t=0; t<nPeriods; t++) {
d3274 1
a3274 1
	 isVecNonZero = TRUE;
d3314 1
a3314 1
	 RWCString fileName,
d3317 1
a3317 1
   ofstream outFile(fileName, ios::out, 0666);
d3335 4
a3338 3
   for (int o=0; o<nOperations; o++ ) {
     RWCString thePdf;
     RWCString theOperation;
d3347 3
a3349 2
     RWBoolean isVecNonZero = FALSE;
     for (int t=0; t<nPeriods; t++) {
d3351 1
a3351 1
	 isVecNonZero = TRUE;
d3390 1
a3390 1
					       RWCString fileName,
d3394 1
a3394 1
  RWCString partName;
d3396 1
a3396 1
  ofstream outFile(fileName, ios::out, 0666);
d3417 3
a3419 3
    RWCString partname = mpHelper.partname(partList[i]);
    RWCString plannerPart;
    RWCString geo;
d3458 1
a3458 1
	 RWCString fileName,
d3462 4
a3465 4
  RWCString mfgPart;
  RWCString pdf;
  RWCString geo;
  RWCString plannerPart;
d3467 1
a3467 1
  ofstream outFile(fileName, ios::out, 0666);
d3480 1
a3480 1
   RWCString * sourceList = new RWCString[nPeriods];
d3571 1
a3571 1
	 RWCString fileName,
d3575 1
a3575 1
  RWCString partName;
d3577 1
a3577 1
  ofstream outFile(fileName, ios::out, 0666);
d3596 2
a3597 2
    RWCString plannerPart;
    RWCString geo;
d3602 1
a3602 1
      RWCString partname = mpHelper.partname(partList[i]);
d3630 1
a3630 1
	 RWCString fileName,
d3634 1
a3634 1
  RWCString partName;
d3636 1
a3636 1
  ofstream outFile(fileName, ios::out, 0666);
d3655 2
a3656 2
    RWCString plannerPart;
    RWCString geo;
d3658 2
a3659 2
      RWCString partname = mpHelper.partname(partList[i]);
      RWCString pdf = mpHelper.pdf(partList[i]);
d3675 2
a3676 1
	  for (int t=0; t<nPeriods; t++) {
d3706 1
a3706 1
	 RWCString fileName,
d3710 1
a3710 1
  RWCString partName;
d3712 1
a3712 1
  ofstream outFile(fileName, ios::out, 0666);
d3724 1
a3724 1
   RWCString demandName("WW");
d3733 2
a3734 2
       RWDate thisDate(theCal.periodStart(t));
       RWCString theDate("    " + thisDate.asString() + "   ");
d3739 4
a3742 4
       RWCString parti(partList[i]);
       RWCString partname = mpHelper.partname(parti);
       RWCString plannerPart;
       RWCString geo;
d3745 1
a3745 1
	 witGetPartDemands(theWitRun, parti, &nDemands, &dList);
d3758 1
a3758 1
	   witGetDemandShipVol(theWitRun, parti, dList[j], &witVector1);
d3794 1
a3794 1
	 RWCString fileName,
d3798 2
a3799 2
   RWCString geo;
   RWCString plannerPart;
d3801 1
a3801 1
   ofstream outFile(fileName, ios::out, 0666);
d3811 1
a3811 1
   RWCString * sourceList = new RWCString[nPeriods];
d3828 2
a3829 1
     for (int t=0; t<nPeriods; t++)
d3854 1
a3854 1
	 RWCString fileName,
d3858 1
a3858 1
   ofstream outFile(fileName, ios::out, 0666);
d3869 2
a3870 1
   for (int i=0; i<nParts; i++ ) {
d3873 2
a3874 2
     RWCString partname = mpHelper.partname(partList[i]);
     RWCString pdf = mpHelper.pdf(partList[i]);
d3898 1
a3898 1
	 RWCString engine,            // rollover handled differently
d3902 1
a3902 1
	 RWCString fileName,
d3907 1
a3907 1
  ofstream outFile(fileName, ios::out, 0666);
d3917 3
a3919 2
   for (int i=0; i<theCritList.getLength(); i++ ) {
     RWCString part = theCritList.getPart(i);
d3923 2
a3924 2
     RWCString partname = mpHelper.partname(part);
     RWCString pdf = mpHelper.pdf(part);
d3959 1
a3959 1
     RWCString lowestLevelNonPcfFileName =
d3968 1
a3968 1
     RWCString pcfBogonsFileName =
d4008 1
a4008 1
    RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d4044 1
a4044 1
	RWCString geoSourceDebugFileName =
d4054 1
a4054 1
      RWCString formattedSupplyReportFileName =
d4062 1
a4062 1
    RWCString supplyResponseFileName =
d4068 3
a4070 3
    RWCString independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (! independentDemandFile.isNull())   {
      RWCString indepSupplyResponseFileName =
d4079 1
a4079 1
      RWCString geoSupplyByPdfFileName =
d4087 1
a4087 1
      RWCString backlogResponseFileName =
d4097 1
a4097 1
      RWCString criticalListFileName =
d4099 1
a4099 1
      RWCString engine = setOfParameters.getString( "engine");
d4106 1
a4106 1
      RWCString buildSchedFileName =
d4116 3
a4118 3
      RWCString interPlantFile = setOfParameters.getString("interPlantFile");
      if (! interPlantFile.isNull())   {
	RWCString interplantOrdersFileName =
d4120 1
a4120 1
	RWBoolean isThisMrp = FALSE;
d4131 4
a4134 4
    RWBoolean printShadowPricesFile = setOfParameters.getBool("printShadowPricesFile");
    RWCString engine = this->getEngine();
    if ((! engine.compareTo("optimization")) && printShadowPricesFile) {
      RWCString shadowPricesFileName = setOfParameters.getString("shadowPricesFileName");
d4149 1
a4149 1
      RWCString operationOrdersFileName =
d4161 3
a4163 3
      RWCString binFile = setOfParameters.getString("binFile");
      if (! binFile.isNull())   {
	RWCString binOrdersFileName =
d4165 1
a4165 1
	RWBoolean isThisMrp = FALSE;
d4179 5
a4183 5
    RWCString subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.isNull())   {
      RWBoolean parentMustBeUserDefinedOperation = FALSE;
      RWBoolean engineMustBeImplode = TRUE;
      RWCString subUsageFileName = setOfParameters.getString("subUsageFileName");
d4194 5
a4198 5
    RWCString opSubBomFile = setOfParameters.getString("opSubBomFile");    
    if (! opSubBomFile.isNull())   {
      RWBoolean parentMustBeUserDefinedOperation = TRUE;
      RWBoolean engineMustBeImplode = TRUE;
      RWCString opSubUsageFileName = setOfParameters.getString("opSubUsageFileName");
d4213 1
a4213 1
    RWCString featureFileOutputFormat =
d4224 3
a4226 3
    RWCString topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.isNull()) {
      RWCString optionalFeatRatioFileName =
d4235 1
a4235 1
    RWCString topLevelToBBratioFile =
d4237 2
a4238 2
    if (! topLevelToBBratioFile.isNull()) {
      RWCString selFeatBBratioFileName =
d4254 1
a4254 1
      RWCString
d4262 1
a4262 1
      RWCString capacityDBFileName =
d4271 1
a4271 1
      RWCString operationDBFileName =
d4279 1
a4279 1
      RWCString debugFileName =
d4286 1
a4286 1
   RWCString problemStatisticsFileName =
d4294 1
a4294 1
   RWCString objectiveSummaryFileName =
d4304 2
a4305 1
   for (int o=0; o<nOperations; o++) 
d4321 1
a4321 1
  const RWCString & engine = getEngine();
d4335 1
a4335 1
    RWBoolean doPegging = setOfParameters.getBool("doPegging");
d4352 1
a4352 1
    RWBoolean doPegging = setOfParameters.getBool("doPegging");
d4415 2
a4416 2
  RWBoolean printDemandConsPegFile = setOfParameters.getBool("printDemandConsPegFile");
  RWBoolean printIndpDemandConsPegFile = setOfParameters.getBool("printIndpDemandConsPegFile");
d4418 2
a4419 2
  RWCString demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
  RWCString indpDemandConsPegFileName = setOfParameters.getString("indpDemandConsPegFileName");
d4421 2
a4422 2
  RWBoolean printInterplantPegFile = setOfParameters.getBool("printInterplantPegFile");
  RWBoolean printIndpInterplantPegFile = setOfParameters.getBool("printIndpInterplantPegFile");
d4424 2
a4425 2
  RWCString interplantPegFileName = setOfParameters.getString("interplantPegFileName");
  RWCString indpInterplantPegFileName = setOfParameters.getString("indpInterplantPegFileName");
d4427 2
a4428 2
  RWBoolean printExecVolPegFile = setOfParameters.getBool("printExecVolPegFile");
  RWBoolean printIndpExecVolPegFile = setOfParameters.getBool("printIndpExecVolPegFile");
d4430 2
a4431 2
  RWCString execVolPegFileName = setOfParameters.getString("execVolPegFileName");
  RWCString indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");
d4434 2
a4435 2
  RWBoolean printProdVolPegFile = setOfParameters.getBool("printProdVolPegFile");
  RWCString prodVolPegFileName = setOfParameters.getString("prodVolPegFileName");
d4473 1
a4473 1
  cout << "Writing Pegging information..." << endl;    
d4481 1
a4481 1
  RWCString plannerPart, geo;
d4489 1
a4489 1
    ofstream dPegFile;
d4492 1
a4492 1
    dPegFile.open(demandConsPegFileName, ios::out);
d4494 1
a4494 1
      RWCString fileErrorString("Demand Pegging Consumption File");
d4501 2
a4502 1
    for(int i=0; i<nParts; i++){
d4518 2
a4519 1
      for(int j=0; j<nDemands; j++){
d4523 1
a4523 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4526 1
a4526 1
	if ( demandAppDataPtr == NULL ) {
d4535 3
a4537 2
	int nConsumedParts = pegSched.entries();
	for ( int cp=0; cp<nConsumedParts; cp++ ) {
d4576 1
a4576 1
    ofstream idPegFile;
d4579 1
a4579 1
    idPegFile.open(indpDemandConsPegFileName, ios::out);
d4581 1
a4581 1
      RWCString fileErrorString("Independent Demand Pegging Consumption File");
d4590 2
a4591 1
    for(int i=0; i<nParts; i++){
d4604 2
a4605 1
      for(int j=0; j<nDemands; j++){
d4609 1
a4609 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4612 1
a4612 1
	if ( demandAppDataPtr == NULL ) {
d4622 3
a4624 2
	int nConsumedParts = pegSched.entries();
	for ( int cp=0; cp<nConsumedParts; cp++ ) {
d4658 1
a4658 1
    ofstream evPegFile;
d4661 1
a4661 1
    evPegFile.open(execVolPegFileName, ios::out);
d4663 1
a4663 1
      RWCString fileErrorString("ExecVol Pegging File");
d4670 2
a4671 1
    for(int i=0; i<nParts; i++){
d4687 2
a4688 1
      for(int j=0; j<nDemands; j++){
d4692 1
a4692 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4695 1
a4695 1
	if ( demandAppDataPtr == NULL ) {
d4705 3
a4707 2
	int nConsumedParts = pegSched.entries();
	for ( int cp=0; cp<nConsumedParts; cp++ ) {
d4742 1
a4742 1
    ofstream pvPegFile;
d4745 1
a4745 1
    pvPegFile.open(prodVolPegFileName, ios::out);
d4747 1
a4747 1
      RWCString fileErrorString("ProdVol Pegging File");
d4754 2
a4755 1
    for(int i=0; i<nParts; i++){
d4771 2
a4772 1
      for(int j=0; j<nDemands; j++){
d4776 1
a4776 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4779 1
a4779 1
	if ( demandAppDataPtr == NULL ) {
d4792 3
a4794 2
	int nOperations = pegSched.entries();
	for ( int cp=0; cp<nOperations; cp++ ) {
d4837 1
a4837 1
    ofstream idEvPegFile;
d4840 1
a4840 1
    idEvPegFile.open(indpExecVolPegFileName, ios::out);
d4842 1
a4842 1
      RWCString fileErrorString("Independent Demand ExecVol Pegging  File");
d4852 2
a4853 1
    for(int i=0; i<nParts; i++){
d4866 2
a4867 1
      for(int j=0; j<nDemands; j++){
d4871 1
a4871 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4874 1
a4874 1
	if ( demandAppDataPtr == NULL ) {
d4884 3
a4886 2
	int nOperations = pegSched.entries();
	for ( int cp=0; cp<nOperations; cp++ ) {
d4920 1
a4920 1
    ofstream ipPegFile;
d4923 1
a4923 1
    ipPegFile.open(interplantPegFileName, ios::out);
d4925 1
a4925 1
      RWCString fileErrorString("Interplant Pegging File");
d4933 2
a4934 1
    for(int i=0; i<nParts; i++){
d4950 2
a4951 1
      for(int j=0; j<nDemands; j++){
d4955 1
a4955 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d4958 1
a4958 1
	if ( demandAppDataPtr == NULL ) {
d4968 3
a4970 2
	int nConsumedParts = pegSched.entries();
	for ( int cp=0; cp<nConsumedParts; cp++ ) {
d4974 1
a4974 1
	  RWCString pn1,customerPdf,pn2,supplierPdf;
d5007 1
a5007 1
    ofstream idIpPegFile;
d5010 1
a5010 1
    idIpPegFile.open(indpInterplantPegFileName, ios::out);
d5012 1
a5012 1
      RWCString fileErrorString("Independent Interplant Demand Pegging  File");
d5022 2
a5023 1
    for(int i=0; i<nParts; i++){
d5036 2
a5037 1
      for(int j=0; j<nDemands; j++){
d5041 1
a5041 1
	LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d5044 1
a5044 1
	if ( demandAppDataPtr == NULL ) {
d5054 3
a5056 2
	int nOperations = pegSched.entries();
	for ( int cp=0; cp<nOperations; cp++ ) {
d5060 1
a5060 1
	  RWCString pn1,customerPdf,pn2,supplierPdf;
d5087 2
a5088 1
  for(int i=0; i<nParts; i++) {
d5109 1
a5109 1
  cout << "... collecting Pegging information ..." << endl;    
d5116 2
a5117 1
  RWBoolean pegSubUsageToPrimary = this->setOfParameters().getBool("pegSubUsageToPrimary");
d5119 1
a5119 2
  RWCString pp, geo;
  RWCString fullWitGPDPartName, fullWitGPDDemandName;
d5122 2
a5123 1
  for(int i=0; i<nParts; i++){
d5128 2
a5129 1
    for(int j=0; j<nDemands; j++){
d5143 1
a5143 1
      LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d5150 1
a5150 1
	witGetDemandAppData( theWitRun, fullWitGPDPartName, geo,
d5152 1
a5152 1
	if ( demandAppDataPtr == NULL ) {
d5155 1
a5155 1
	  witSetDemandAppData( theWitRun, fullWitGPDPartName, geo,  
d5162 1
a5162 1
	if ( demandAppDataPtr == NULL ) {
d5173 3
a5175 3
	cout << "specialDemand, being REPORTED..." << endl;
	cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << endl;
d5178 1
a5178 1
      cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << endl;
d5181 1
a5181 1
      cout << endl;
d5205 1
a5205 1
      cout << "(after) JP's Get" << endl;
d5207 1
a5207 1
      cout << " ==========================" << endl << endl;
a5223 24
























d5227 1
a5227 1
  RWCString allocMrpSeparatorChar("#");
d5230 1
a5230 1
				  allocMrpSeparatorChar.data()[0],
d5246 1
a5246 1
  RWCString allocatedMrpFileName =
d5251 2
a5252 2
  RWCString allocatedIndepMrpFileName("");
  if (! setOfParameters().getString("independentDemandFile").isNull())
d5297 1
a5297 1
    RWCString fileName)
d5299 1
a5299 1
  ofstream outFile(fileName, ios::out, 0666);
d5335 1
a5335 1
   RWBoolean doImplode = setOfParameters.getBool("doImplode");
d5340 1
a5340 1
     RWCString fullPartName(partList[i]);
d5345 1
a5345 1
     witGetPartCategory(theWitRun, fullPartName, &category);
d5347 1
a5347 1
     witGetPartSupplyVol(theWitRun, fullPartName, &supplyVol);
d5350 1
a5350 1
       witGetPartCycleTime(theWitRun, fullPartName,  &cycleTime);
d5352 1
a5352 1
     witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d5354 1
a5354 1
       witGetOperationExecutable(theWitRun, fullPartName, &execFlag);
d5362 2
a5363 2
       witGetPartExcessVol(theWitRun, fullPartName, &excessVol);
       witGetPartResidualVol(theWitRun, fullPartName, &residualVol);
d5365 3
a5367 3
	 witGetPartStockVol(theWitRun, fullPartName, &stockVol);
       witGetPartScrapVol(theWitRun, fullPartName, &scrapVol);
       witGetPartConsVol(theWitRun, fullPartName, &consVol);
d5369 1
a5369 1
	 witGetPartProdVol(theWitRun, fullPartName,  &prodVol);
d5375 2
a5376 2
     RWCString pn(fullPartName);
     RWCString pdf(mpHelper.pdf(fullPartName));
d5434 1
a5434 1
    RWCString fileName)
d5437 1
a5437 1
  ofstream outFile(fileName, ios::out, 0666);
d5454 2
a5455 2
  RWBoolean doImplode =         setOfParameters.getBool("doImplode");
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d5507 1
a5507 1
  int alwaysPrintForECAonly = (siteCustomization.compareTo("eca", RWCString::ignoreCase) ? 0 : 1);
d5513 1
a5513 1
    RWCString fullPartName(partList[i]);
d5521 1
a5521 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d5524 1
a5524 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d5533 1
a5533 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d5536 1
a5536 1
    witGetPartDemands(theWitRun, fullPartName, &nDemands, &dList);
d5548 1
a5548 1
    witGetPartSupplyVol(theWitRun, fullPartName, &supplyVolSpecifiedByUser);
d5568 1
a5568 1
      witGetPartCycleTime(theWitRun, fullPartName,  &cycleTime);
d5577 4
a5580 3
	witGetPartAppData(theWitRun, fullPartName, (void **) &appDataPtr);
	assert(appDataPtr != NULL);
	for (int tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
d5589 2
a5590 1
    for (int j=0; j<nDemands; j++) {
d5592 3
a5594 2
      witGetDemandDemandVol(theWitRun, fullPartName, dList[j], &indepDemandVol);
      for (int tt=0; tt<nPeriods; tt++) {
d5605 2
a5606 1
      for (int tt=0; tt<nPeriods; tt++) {
d5631 1
a5631 1
      witGetOperationExecutable(theWitRun, fullPartName, &execFlag);
d5634 1
a5634 1
      witGetOperationYieldRate(theWitRun, fullPartName, &yieldRate);
d5642 2
a5643 1
      for (int t=0; t<nPeriods; t++) {
d5671 2
a5672 2
	RWBoolean foundOpCategory = FALSE;          
	RWCString cp1, pdf1, sp2, pdf2;
d5681 2
a5682 2
	witGetPartProducingBopEntry(theWitRun, fullPartName, p, &witOperationName, &b);
	RWCString operationName(witOperationName);
d5695 2
a5696 1
	  for (int t=early; t<=late; t++) {
d5702 1
a5702 1
	  foundOpCategory = TRUE;
d5711 2
a5712 1
	  for (int t=early; t<=late; t++) {
d5718 1
a5718 1
	  foundOpCategory = TRUE;
d5729 2
a5730 1
	  for (int t=early; t<=late; t++) {
d5736 1
a5736 1
	  foundOpCategory = TRUE;
d5745 2
a5746 1
	  for (int t=early; t<=late; t++) {
d5752 1
a5752 1
	  foundOpCategory = TRUE;
d5762 2
a5763 1
	  for (int t=early; t<=late; t++) {
d5773 1
a5773 1
	  foundOpCategory = TRUE;
d5778 2
a5779 2
	  cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<endl;
d5833 1
a5833 1
      witGetPartScrapVol(theWitRun, fullPartName, &scrapVol);
d5837 1
a5837 1
      witGetPartConsVol(theWitRun, fullPartName, &consVol);
d5841 3
a5843 2
	witGetDemandShipVol(theWitRun, fullPartName, dList[j], &indepShipVol);
	for (int tt=0; tt<nPeriods; tt++) {
d5854 2
a5855 1
	for (int tt=0; tt<nPeriods; tt++) {
d5878 5
a5882 4
      witGetPartStockVol(theWitRun, fullPartName, &witStockVol);
      witGetPartExcessVol(theWitRun, fullPartName, &witExcessVol);
      witGetPartResidualVol(theWitRun, fullPartName, &witResidualVol);
      for (int ttt=0; ttt<nPeriods; ttt++) {
d5983 2
a5984 1
      for (int t=1; t<nPeriods; t++) {
d6044 2
a6045 1
    for (int t=0; t<nPeriods; t++) {
d6053 2
a6054 2
    RWCString pn(mpHelper.partname(fullPartName));
    RWCString pdf(mpHelper.pdf(fullPartName));
d6204 2
a6205 2
    RWCString & pn, 
    RWCString & pdf, 
d6208 1
a6208 1
    ofstream & outFile,   // output stream (already opened)
d6227 2
a6228 2
    RWCString & pn, 
    RWCString & pdf, 
d6231 1
a6231 1
    ofstream & outFile,   // output stream (already opened)
d6267 1
a6267 1
    RWCString fileName)
d6270 1
a6270 1
  ofstream outFile(fileName, ios::out, 0666);
d6287 1
a6287 1
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d6290 1
a6290 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d6297 2
a6298 2
    RWCString operation(opList[o]);
    RWCString op, p;
d6313 1
a6313 1
    witGetOperationExecutable(theWitRun, operation, &witBoolVec);
d6322 1
a6322 1
    witGetOperationYieldRate(theWitRun, operation, &witVector);
d6351 1
a6351 1
      witGetOperationExecVol(theWitRun, operation, &witVector);
d6394 1
a6394 1
    RWCString fileName)
d6397 1
a6397 1
  ofstream outFile(fileName, ios::out, 0666);
d6422 2
a6423 1
  for (int o=0; o<nOps; o++ ) {
d6425 4
a6428 4
    RWCString fullWitOperation(opList[o]);
    RWCString op, p, pn1, pdf1, pn2, pdf2;
    RWCString PUD14SourceCode;
    RWCString supplierPdf, customerPdf, producedPart;
d6474 3
a6476 2
    witGetOperationNBopEntries(exploderWitRun, fullWitOperation, &nBops);
    for (int b=0; b<nBops; b++) {
d6485 1
a6485 1
      witGetBopEntryProducedPart(exploderWitRun, fullWitOperation, b, &producedPart);
d6493 3
a6495 3
      witGetBopEntryProdRate(exploderWitRun, fullWitOperation, b, &prodRate);
      witGetBopEntryEarliestPeriod(exploderWitRun, fullWitOperation, b, &early);
      witGetBopEntryLatestPeriod(exploderWitRun, fullWitOperation, b, &late);
d6500 2
a6501 1
	for (int t=0; t<nPeriods; t++)
d6509 2
a6510 1
	for (int t=0; t<nPeriods; t++)
d6516 1
a6516 1
      witGetOperationYieldRate(exploderWitRun, fullWitOperation, &yieldRate);
d6518 1
a6518 1
      witGetBopEntryImpactPeriod(exploderWitRun, fullWitOperation, b, &impactPeriod);
d6522 2
a6523 1
      for (int t=0; t<nPeriods; t++)
d6561 1
a6561 1
  RWCString PUD14SourceCode = "E";
d6563 4
a6566 3
  for (int i=0; i<nParts; i++ ) {
    RWCString fullWitPart(partList[i]);
    RWCString partName, customerPdf;
d6571 1
a6571 1
      witGetPartSupplyVol(exploderWitRun, fullWitPart, &supplyVol);
d6573 2
a6574 1
      for (int t=0; t< nPeriods; t++) {
d6623 1
a6623 1
    RWCString fileName)
d6626 1
a6626 1
  ofstream outFile(fileName, ios::out, 0666);
d6655 1
a6655 1
  assert(FsourceDemand != NULL);
d6657 1
a6657 1
  assert(OsourceDemand != NULL);
d6660 2
a6661 1
  for (int i=0; i<nParts; i++) {
d6663 1
a6663 1
    assert(FsourceDemand[i] != NULL);    
d6665 1
a6665 1
    assert(OsourceDemand[i] != NULL);
d6667 2
a6668 1
    for (int t=0; t<nPeriods; t++) {
d6677 1
a6677 1
    if (appDataPtr == NULL) {
d6690 2
a6691 1
  for (int o=0; o<nOps; o++ ) {
d6693 5
a6697 5
    RWCString fullWitOperation(opList[o]);
    RWCString op, p, pn1, pdf1, pn2, pdf2, geo, plannerPart;
    RWCString sourceCode;
    RWCString supplierPdf, customerPdf;
    RWCString gg, mm;
d6755 3
a6757 2
    witGetOperationNBomEntries(exploderWitRun, fullWitOperation, &nBoms);
    for (int k=0; k<nBoms; k++) {
d6765 1
a6765 1
      witGetBomEntryConsumedPart(exploderWitRun, fullWitOperation, k, &consumedPart);
d6781 4
a6784 4
      witGetBomEntryUsageRate(exploderWitRun, fullWitOperation, k, &usageRate);
      witGetBomEntryEarliestPeriod(exploderWitRun, fullWitOperation, k, &early);
      witGetBomEntryLatestPeriod(exploderWitRun, fullWitOperation, k, &late);
      witGetBomEntryFallout(exploderWitRun, fullWitOperation, k, &fallout);      
d6786 1
a6786 1
      witGetBomEntryImpactPeriod(exploderWitRun, fullWitOperation, k, &impactPeriod);
d6795 3
a6797 2
      witGetBomEntryNSubsBomEntries(exploderWitRun, fullWitOperation, k, &nSubs);
      for (int s=0; s<nSubs; s++) {
d6804 5
a6808 5
	witGetSubsBomEntryUsageRate(exploderWitRun, fullWitOperation, k, s, &subUsageRate);
	witGetSubsBomEntryEarliestPeriod(exploderWitRun, fullWitOperation, k, s, &subEarly);
	witGetSubsBomEntryLatestPeriod(exploderWitRun, fullWitOperation, k, s, &subLate);
	witGetSubsBomEntryFalloutRate(exploderWitRun, fullWitOperation, k, s, &subFalloutRate);
	witGetSubsBomEntryConsumedPart(exploderWitRun, fullWitOperation, k, s, &subConsumedPart);
d6811 2
a6812 1
	for (int t=0; t<nPeriods; t++)
d6853 1
a6853 1
	  assert(myAppDataPtr != NULL);
d6861 1
a6861 1
	  assert(myAppDataPtr != NULL);
d6874 2
a6875 1
      for (int t=0; t<nPeriods; t++)
d6889 1
a6889 1
      assert(myAppDataPtr != NULL);
d6925 1
a6925 1
    RWCString thePart(partList[i]);
d6931 1
a6931 1
      RWCString thePdf(mpHelper.pdf(thePart));
d6942 1
a6942 1
      RWCString thePdf(mpHelper.pdf(thePart));
d7026 1
a7026 1
void
d7033 1
a7033 1
}
d7105 1
a7105 1
 localSnapshotPtr_(NULL),
d7108 5
a7112 5
 exploderPtr_(NULL),
 sceErrFacDisp_(NULL),
 sceMsgFacDisp_(NULL),
 sceErrFacility_(NULL),
 sceMsgFacility_(NULL),
d7135 1
a7135 1
    RWCString dPart,dPdf,sPart,sPdf;
d7166 2
a7167 1
    for (int j=0; j<nBoms; j++) {
d7172 2
a7173 1
      for (int s=0; s<nSubBoms; s++) { 
d7198 3
a7200 2
    for (int j=0; j<nDemands; j++) {
      LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d7202 1
a7202 1
      if ( demandAppDataPtr != NULL ) 
d7212 1
a7212 1
  delete  localSnapshotPtr_;
d7256 1
a7256 1
  localSnapshotPtr_( source.localSnapshotPtr_ ),
d7271 2
a7272 2
  ifstream temp1;
  ifstream temp2;
d7274 2
a7275 2
  RWCString errFileName = "errorLog" + numTempFiles_;
  RWCString msgFileName = "messageLog" + numTempFiles_;
d7277 2
a7278 2
  temp1.open(errFileName, ios::in | ios::nocreate);
  temp2.open(msgFileName, ios::in | ios::nocreate);
d7284 2
a7285 2
    temp1.open(errFileName, ios::in | ios::nocreate);
    temp2.open(msgFileName, ios::in | ios::nocreate);
d7291 1
a7291 1
  sceErrFacDisp_ = new MclPrintfOutputDisplayer(errFileName,"w+");
d7295 1
a7295 1
  sceMsgFacDisp_ = new MclPrintfOutputDisplayer(msgFileName,"w+");
d7312 1
a7312 1
  localSnapshotPtr_(NULL),
d7315 5
a7319 5
  exploderPtr_(NULL),
  sceErrFacDisp_(NULL),
  sceMsgFacDisp_(NULL),
  sceErrFacility_(NULL),
  sceMsgFacility_(NULL),
d7349 1
a7349 1
      RWCString geoSourceDebugFileName =
d7359 1
a7359 1
      RWCString formattedSupplyReportFileName =
d7367 1
a7367 1
    RWCString supplyResponseFileName =
d7379 1
a7379 1
     //  cout << endl << "Updating Demand SupplyVol SUCCESSFULLY!"<< endl;
d7385 1
a7385 1
      RWCString geoSupplyByPdfFileName =
d7407 1
a7407 1
	//        cout << endl << "Inserting Supply Response SUCCESSFULLY!"<< endl;
d7414 1
a7414 1
    RWCString backlogResponseFileName =
d7427 1
a7427 1
     //     cout << endl << "Updating Demand BacklogVol SUCCESSFULLY!"<< endl;
d7433 1
a7433 1
      RWCString criticalListFileName =
d7435 1
a7435 1
      RWCString engine = setOfParameters.getString( "engine");
d7442 1
a7442 1
    RWCString buildSchedFileName =
d7464 3
a7466 3
    RWCString interPlantFile = setOfParameters.getString("interPlantFile");
    if (! interPlantFile.isNull())   {
      RWCString interplantOrdersFileName =
d7468 1
a7468 1
      RWBoolean isThisMrp = FALSE;
d7491 1
a7491 1
	//        cout << endl << "Inserting IPOrders SUCCESSFULLY!"<< endl;
d7498 3
a7500 3
    RWCString subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.isNull())   {
      RWCString subUsageFileName =
d7513 1
a7513 1
    RWCString operationOrdersFileName =
d7524 1
a7524 1
    RWCString featureFileOutputFormat =
d7535 3
a7537 3
    RWCString topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.isNull()) {
      RWCString optionalFeatRatioFileName =
d7546 1
a7546 1
    RWCString topLevelToBBratioFile =
d7548 2
a7549 2
    if (! topLevelToBBratioFile.isNull()) {
      RWCString selFeatBBratioFileName =
d7559 1
a7559 1
      RWCString
d7649 1
a7649 1
      RWCString capacityDBFileName =
d7662 1
a7662 1
	 //         cout << endl << "Updating Capacity SupplyVol SUCCESSFULLY!"<< endl;
d7671 1
a7671 1
	//        cout << endl << "Updating Capacity MrpConsVol SUCCESSFULLY!"<< endl;
d7690 1
a7690 1
	 //         cout << endl << "Updating Capacity ReqVol SUCCESSFULLY!"<< endl;
d7692 1
a7692 1
	 //  cout << endl << "Updating Capacity MrpExcessVol SUCCESSFULLY!"<< endl;
d7694 1
a7694 1
	 //  cout << endl << "Updating Capacity MrpRequirements SUCCESSFULLY!"<< endl;
d7704 1
a7704 1
	//        cout << endl << "Updating Capacity ExcessVol SUCCESSFULLY!"<< endl;
d7713 1
a7713 1
	//        cout << endl << "Updating Capacity ScrapVol SUCCESSFULLY!"<< endl;
d7722 1
a7722 1
	//        cout << endl << "Updating Capacity ConsVol SUCCESSFULLY!"<< endl;
d7732 1
a7732 1
      RWCString operationDBFileName =
d7740 1
a7740 1
      RWCString debugFileName =
d7747 1
a7747 1
   RWCString problemStatisticsFileName =
d7753 2
a7754 2
   RWCString engine = setOfParameters.getString("engine");   
   RWCString objectiveSummaryFileName =
d7776 1
a7776 1
  RWCString partName;
d7787 2
a7788 2
    RWCString plannerPart;
    RWCString geo;
d7791 1
a7791 1
      RWCString partname = mpHelper.partname(partList[i]);
d7815 1
a7815 1
  RWCString partName;
d7827 3
a7829 3
    RWCString partname = mpHelper.partname(partList[i]);
    RWCString plannerPart;
    RWCString geo;
d7869 3
a7871 2
  for ( int i=0; i<nParts; i++ ) {
    RWCString fullPartName(partList[i]);
d7875 3
a7877 3
    witGetPartSupplyVol(theWitRun, fullPartName, &witVector);
    capSupplyVol.insert(SceArgList() << mpHelper.partname(fullPartName).data()
			<< mpHelper.pdf(fullPartName).data()
d7898 3
a7900 2
    for ( int i=0; i<nParts; i++ ) {
      RWCString fullPartName(partList[i]);
d7909 2
a7910 2
			  << mpHelper.partname(fullPartName).data()
			  << mpHelper.pdf(fullPartName).data()
d7937 3
a7939 2
  for ( int i=0; i<nParts; i++ ) {
    RWCString fullPartName(partList[i]);
d7947 2
a7948 2
		    << mpHelper.partname(fullPartName).data()
		    << mpHelper.pdf(fullPartName).data()
d7958 2
a7959 2
			     << mpHelper.partname(fullPartName).data()
			     << mpHelper.pdf(fullPartName).data()
d7964 2
a7965 1
    for (int t=0; t<nPeriods; t++) {
d7971 2
a7972 2
		       << mpHelper.partname(fullPartName).data()
		       << mpHelper.pdf(fullPartName).data()
d7997 1
a7997 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d8000 3
a8002 2
  for ( int i=0; i<nParts; i++ ) {
    RWCString fullPartName(partList[i]);
d8008 1
a8008 1
      witGetPartExcessVol(theWitRun, fullPartName, &witVector);
d8011 2
a8012 2
		       << mpHelper.partname(fullPartName).data()
		       << mpHelper.pdf(fullPartName).data()
d8033 3
a8035 2
  for ( int i=0; i<nParts; i++ ) {
    RWCString fullPartName(partList[i]);
d8039 1
a8039 1
      witGetPartScrapVol(theWitRun, fullPartName, &witVector);
d8042 2
a8043 2
		       << mpHelper.partname(fullPartName).data()
		       << mpHelper.pdf(fullPartName).data()
d8064 3
a8066 2
  for (int i=0; i<nParts; i++ ) {
    RWCString fullPartName(partList[i]);
d8069 1
a8069 1
    witGetPartConsVol(theWitRun, fullPartName, &witVector);
d8073 2
a8074 2
			  << mpHelper.partname(fullPartName).data()
			  << mpHelper.pdf(fullPartName).data()
d8094 4
a8097 4
   RWCString destination;
   RWCString destinationPdf;
   RWCString source;
   RWCString sourcePdf;
d8105 2
a8106 1
   for (int o=0; o<nOps; o++ ) {
d8115 3
a8117 2
       RWBoolean isVecNonZero = FALSE;
       for (int t=0; t<nPeriods; t++) {
d8119 1
a8119 1
	   isVecNonZero = TRUE;
d8152 4
a8155 4
  RWCString mfgPart;
  RWCString pdf;
  RWCString geo;
  RWCString plannerPart;
d8162 1
a8162 1
   RWCString * sourceList = new RWCString[nPeriods];
d8254 2
a8255 1
   for (int i=0; i<nParts; i++ ) {
d8259 2
a8260 2
       RWCString partname = mpHelper.partname(partList[i]);
       RWCString pdf = mpHelper.pdf(partList[i]);
d8286 2
a8287 1
   for (int i=0; i<nParts; i++ ) {
d8290 2
a8291 2
     RWCString partname = mpHelper.partname(partList[i]);
     RWCString pdf = mpHelper.pdf(partList[i]);
d8323 1
a8323 1
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d8326 2
a8327 1
  for (int i=0; i<nParts; i++ ) {
d8329 1
a8329 1
    RWCString fullPartName(partList[i]);
d8337 1
a8337 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8340 1
a8340 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8346 1
a8346 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d8350 1
a8350 1
      witGetPartSupplyVol(theWitRun, fullPartName, &witVector);
d8358 1
a8358 1
      witGetPartSupplyVol(theWitRun, fullPartName, &witVector);
d8389 1
a8389 1
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d8392 2
a8393 1
  for (int i=0; i<nParts; i++ ) {
d8395 1
a8395 1
    RWCString fullPartName(partList[i]);
d8403 1
a8403 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8406 1
a8406 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8412 1
a8412 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists); 
d8422 1
a8422 1
      witGetPartCycleTime(theWitRun, fullPartName,  &cycleTime);
d8432 4
a8435 3
	witGetPartAppData(theWitRun, fullPartName, (void **) &appDataPtr);
	assert(appDataPtr != NULL);
	for (int tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
d8478 2
a8479 1
  for (int i=0; i<nParts; i++ ) {
d8481 1
a8481 1
    RWCString fullPartName(partList[i]);
d8489 1
a8489 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8492 1
a8492 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8498 1
a8498 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);  
d8536 2
a8537 1
  for (int i=0; i<nParts; i++ ) {
d8539 1
a8539 1
    RWCString fullPartName(partList[i]);
d8547 1
a8547 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8550 1
a8550 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8556 1
a8556 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d8578 2
a8579 1
    for (int t=0; t<nPeriods; t++) {
d8621 1
a8621 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d8624 2
a8625 1
  for (int i=0; i<nParts; i++ ) {
d8627 1
a8627 1
    RWCString fullPartName(partList[i]);
d8635 1
a8635 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8638 1
a8638 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8644 1
a8644 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d8649 1
a8649 1
      witGetPartExcessVol(theWitRun, fullPartName, &witVector);
d8678 1
a8678 1
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d8682 2
a8683 1
  for (int i=0; i<nParts; i++ ) {
d8685 1
a8685 1
    RWCString fullPartName(partList[i]);
d8693 1
a8693 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8696 1
a8696 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8702 1
a8702 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d8707 1
a8707 1
	  witGetPartStockVol(theWitRun, fullPartName, &witVector);
d8717 1
a8717 1
	  witGetPartStockVol(theWitRun, fullPartName, &witVector);
d8747 2
a8748 1
  for (int i=0; i<nParts; i++ ) {
d8750 1
a8750 1
    RWCString fullPartName(partList[i]);
d8758 1
a8758 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8761 1
a8761 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8767 1
a8767 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);    
d8769 1
a8769 1
      witGetPartScrapVol(theWitRun, fullPartName, &witVector);
d8798 2
a8799 1
  for (int i=0; i<nParts; i++ ) {
d8801 1
a8801 1
    RWCString fullPartName(partList[i]);
d8809 1
a8809 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8812 1
a8812 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8818 1
a8818 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists); 
d8820 1
a8820 1
      witGetPartConsVol(theWitRun, fullPartName, &witVector);
d8857 1
a8857 1
  RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d8860 1
a8860 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d8887 1
a8887 1
    RWCString fullPartName(partList[i]);
d8895 1
a8895 1
    witGetPartCategory(theWitRun, fullPartName, &category);
d8898 1
a8898 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName, &npBops);
d8904 1
a8904 1
    witGetOperationExists(theWitRun, fullPartName, &operationExists);
d8913 2
a8914 1
      for (int t=0; t<nPeriods; t++) {
d8936 1
a8936 1
        RWBoolean foundOpCategory = FALSE;          
d8939 1
a8939 1
        RWCString cp1, pdf1, sp2, pdf2;
d8949 2
a8950 2
        witGetPartProducingBopEntry(theWitRun, fullPartName, p, &witOperationName, &b);
        RWCString operationName(witOperationName);
d8961 2
a8962 1
          for (int t=early; t<=late; t++) {
d8966 1
a8966 1
          foundOpCategory = TRUE;
d8974 2
a8975 1
          for (int t=early; t<=late; t++) {
d8979 1
a8979 1
          foundOpCategory = TRUE;
d8986 2
a8987 1
          for (int t=early; t<=late; t++) {
d8991 1
a8991 1
          foundOpCategory = TRUE;
d9001 2
a9002 1
          for (int t=early; t<=late; t++) {
d9011 1
a9011 1
          foundOpCategory = TRUE;
d9016 2
a9017 2
	  cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<endl;
d9087 1
a9087 1
	  witGetPartProdVol(theWitRun, fullPartName,  &witVector);
d9181 4
a9184 4
  assert(testScenarioDupPtr3->setOfParts(LGFR_DEFAULT_SET).entries() == 3);
  assert(testScenarioDupPtr3->setOfParts(LGFR_UNIVERSAL_SET).entries() == 4);
  assert(testScenarioDupPtr3->setOfParts(LGFR_BUDGET_SET).entries() == 1);
  assert(testScenarioDupPtr3->setOfDemands(LGFR_DEFAULT_SET).entries() == 2);
d9192 4
a9195 4
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).entries() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).entries() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).entries() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).entries() == 2);
d9206 1
a9206 1
  assert (tsDifPtr3 != NULL
d9211 1
a9211 1
  assert (tsDupDifPtr3 != NULL
d9234 1
a9234 1
  LgFrCalendar calendar2(8, RWTime(RWDate("7/15/94")));
d9253 1
a9253 1
  assert (tsDifPtr2 != NULL
d9259 1
a9259 1
  assert (tsDupDifPtr2 != NULL
d9280 1
a9280 1
  LgFrCalendar calendarAir2(8, RWTime(RWDate("7/15/94")));
d9298 1
a9298 1
  assert (tsDifPtrAir2 != NULL
d9304 1
a9304 1
  assert (tsDupDifPtrAir2 != NULL
d9344 1
a9344 1
  assert (tsDifPtr4 != NULL
d9350 1
a9350 1
  assert (tsDupDifPtr4 != NULL
d9360 1
a9360 1
  LgFrCalendar calendar5(8, RWTime(RWDate("7/15/94")));
d9377 1
a9377 1
  assert (tsDifPtr5 != NULL
d9383 1
a9383 1
  assert (tsDupDifPtr5 != NULL
d9394 1
a9394 1
 LgFrCalendar calendar6(8, RWTime(RWDate("7/15/94")));
d9411 1
a9411 1
  assert (tsDifPtr6 != NULL
d9417 1
a9417 1
  assert (tsDupDifPtr6 != NULL
d9436 1
a9436 1
  LgFrCalendar calendar7( 3,RWTime(RWDate(10,4,1995)),LgFrDay);
d9445 1
a9445 1
  assert (tsDifPtr7 != NULL
d9459 4
a9462 4
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).entries() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).entries() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).entries() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).entries() == 2);
d9466 4
a9469 4
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_DEFAULT_SET).entries() == 3);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_UNIVERSAL_SET).entries() == 4);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_BUDGET_SET).entries() == 1);
  assert(yetAnotherScenarioPtr->setOfDemands(LGFR_DEFAULT_SET).entries() == 2);
@


1.18.2.1
log
@Roguewave is gone
@
text
@a1 6
// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.

d5 2
d12 1
a12 1
//#include <scenario/src/difPWatp.h>
d54 4
a57 4
  std::string engine = setOfParameters().getString("engine");
  bool useFullExplodeUtility = setOfParameters().getBool("useFullExplodeUtility");
  bool fssFlag = setOfParameters().getBool("fssFlag");
  bool useSmartExplodeUtility = setOfParameters().getBool("useSmartExplodeUtility");
d130 1
a130 1
	 std::string fileName,
d133 1
a133 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d154 1
a154 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
d164 1
a164 2
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<nDemands; j++) {
d167 1
a167 2
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
d185 1
a185 2
	 int tt = 0; // Pulled out of the for below by RW2STL
	 for (tt=0; tt<nPeriods; tt++) {
d205 2
a206 2
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
d231 1
a231 1
  if (exploderPtr_ == 0) {
d257 1
a257 1
  bool doPegging = setOfParameters.getBool("doPegging");
d269 1
a269 1
    std::string explodeEchoFileName = setOfParameters.getString("explodeEchoFileName");
d271 1
a271 1
    witDisplayData( theExplodeWitRun, explodeEchoFileName.c_str());
d280 1
a280 1
    std::string explodeWitDataFileName = setOfParameters.getString("explodeWitDataFileName");
d282 1
a282 1
    witWriteData(theExplodeWitRun, explodeWitDataFileName.c_str());
d348 1
a348 1
  bool printTotalDemandReport =
d352 1
a352 1
    std::string totalDemandReportFileName = setOfParameters.getString("totalDemandReportFileName");
d382 1
a382 1
  bool printOperationDemandFile = setOfParameters.getBool("printOperationDemandFile");
d384 1
a384 1
    std::string operationDemandFileName = setOfParameters.getString("operationDemandFileName");
d397 4
a400 4
  bool printInterplantDemandFile = setOfParameters.getBool("printInterplantDemandFile");
  std::string interPlantFile = setOfParameters.getString("interPlantFile");
  if ((! interPlantFile.empty()) && printInterplantDemandFile )   {
    std::string interplantDemandFileName =
d402 1
a402 1
    bool isThisMrp = true;
d415 4
a418 4
  bool printBinDemandFile = setOfParameters.getBool("printBinDemandFile");
  std::string binFile = setOfParameters.getString("binFile");
  if ((! binFile.empty()) && printBinDemandFile )   {
    std::string binDemandFileName =
d420 1
a420 1
    bool isThisMrp = true;
d434 6
a439 6
  bool useSmartExplodeUtility = setOfParameters.getBool("useSmartExplodeUtility");
  std::string subBomFile = setOfParameters.getString("subBomFile");    
  if (useSmartExplodeUtility && (! subBomFile.empty()))   {
    std::string mrpSubUsageFileName = setOfParameters.getString("mrpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = false;
    bool engineMustBeImplode = false;
d451 5
a455 5
  std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
  if (useSmartExplodeUtility && (! opSubBomFile.empty()))   {
    std::string mrpOpSubUsageFileName = setOfParameters.getString("mrpOpSubUsageFileName");
    bool parentMustBeUserDefinedOperation = true;
    bool engineMustBeImplode = false;
d466 1
a466 1
    std::string mrpSupplyOrdersFileName = setOfParameters.getString("mrpSupplyOrdersFileName");
d472 1
a472 1
    std::string mrpDemandOrdersFileName = setOfParameters.getString("mrpDemandOrdersFileName");
d480 1
a480 1
  bool doImplode = setOfParameters.getBool("doImplode");
d484 1
a484 1
      std::string partDBFileName = setOfParameters.getString("partDBFileName");
d490 1
a490 1
      std::string capacityDBFileName =
d499 1
a499 1
      std::string operationDBFileName =
d512 1
a512 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++)  
d516 1
a516 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++)  
d572 1
a572 1
LgFrScenarioForSce::setEngine(const std::string & engine)
d574 1
a574 2
    engine_ = engine;
    sce::toLower( engine_ );
d577 1
a577 1
std::string 
d590 2
a591 2
    const std::string & geoPlannerDemandPartName,
    std::string * sourceList)
d593 4
a596 4
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
d613 3
a615 3
  std::string unknownPdf("???");
  std::string unknownMfgPart("??????");
  std::string unknownPartPdf = mpHelper.pdfPartname(unknownMfgPart, unknownPdf);
d629 1
a629 1
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d631 1
a631 1
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), b, &child);
d637 2
a638 2
    witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &early);
    witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), b, &late);
d668 1
a668 1
	 std::string fileName)
d670 1
a670 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d712 1
a712 1
   std::string d1, d2, d3, d4;
d718 1
a718 1
     std::string thePart = partList[i];
d721 1
a721 1
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
d779 1
a779 1
     std::string theOperation(opList[o]);
d781 1
a781 1
     witGetOperationNBomEntries(theWitRun, theOperation.c_str(), &nBom);
d800 1
a800 1
       witGetPartExists(theWitRun, theOperation.c_str(), &exists);
d813 1
a813 1
     std::string fullWitFeaturePartName(partList[i]);
d817 5
a821 6
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
d836 1
a836 1
     std::string fullWitFeaturePartName(partList[i]);
d840 5
a844 6
       witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
       int j = 0; // Pulled out of the for below by RW2STL
       for (j=0; j<lenDemandList; j++) {
	 std::string fullWitGeoPlannerDemandName(demandList[j]);
	 std::string plannerPart;
	 std::string geo;
d869 1
a869 1
     std::string thePart = partList[i];
d873 1
a873 1
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
d878 1
a878 1
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
d882 1
a882 1
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
d892 2
a893 2
     witGetOperationYieldRate(theWitRun, thePart.c_str(), &yieldRate);
     bool uncWaif=true;
d896 1
a896 1
	 uncWaif = false;
d972 1
a972 1
	 std::string fileName)
d974 1
a974 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d994 1
a994 1
     std::string thePart = partList[i];
d998 1
a998 1
     witGetPartNProducingBopEntries(theWitRun, thePart.c_str(), &npBops);
d1003 1
a1003 1
     witGetOperationExists(theWitRun, thePart.c_str(), &exists);
d1007 1
a1007 1
     witGetOperationNBomEntries(theWitRun, thePart.c_str(), &nBom);
d1036 1
a1036 1
	 std::string fileName)
d1038 1
a1038 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1052 1
a1052 1
     std::string thePart = partList[i];
d1079 2
a1080 2
	 std::string & engine,
	 std::string fileName)
d1083 1
a1083 1
  std::string partName;
d1085 1
a1085 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1121 1
a1121 1
	 if (! sce::compareStringsCaseIns( engine, "optimization" )) {
d1134 1
a1134 1
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
d1149 1
a1149 1
	   if (! sce::compareStringsCaseIns( engine, "optimization" )) {           
d1178 1
a1178 1
   if (! sce::compareStringsCaseIns( engine, "optimization" )) {
d1205 1
a1205 1
    std::string fileName)
d1208 1
a1208 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1227 2
a1228 2
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
  bool doImplode = setOfParameters.getBool("doImplode");
d1234 1
a1234 1
  bool anyUserDefinedOperations = false;
d1238 2
a1239 2
  if (! setOfParameters.getString("opFile").empty()) {
    anyUserDefinedOperations = true;
d1247 1
a1247 1
    std::string fullPartName(partList[i]);
d1251 2
a1252 2
    std::string pn(mpHelper.partname(fullPartName));
    std::string pdf(mpHelper.pdf(fullPartName));
d1256 1
a1256 1
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
d1276 1
a1276 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d1285 1
a1285 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d1293 1
a1293 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
d1302 1
a1302 1
	bool foundOpCategory = false;          
d1304 1
a1304 1
	std::string cp1, pdf1, sp2, pdf2;
d1313 2
a1314 2
	witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
	std::string operationName(witOperationName);
d1332 1
a1332 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d1343 1
a1343 1
	  foundOpCategory = true;
d1376 1
a1376 1
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
d1381 1
a1381 1
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
d1386 1
a1386 1
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
d1413 1
a1413 1
	 std::string fileName,
d1418 1
a1418 1
  std::string partName;
d1420 1
a1420 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1432 4
a1435 4
  std::string plannerTopLevelPart;
  std::string geo;
  std::string mfgOptionPart;
  std::string bbCategory;
d1448 4
a1451 4
    std::string custChoiceFeaturePart(partList[i]);
    std::string featurePart;
    std::string ppp;
    std::string mmm, ggg;
d1460 1
a1460 1
      witGetPartDemands( theWitRun, custChoiceFeaturePart.c_str(), &lenDemandList, &demandList);
d1466 4
a1469 5
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<lenDemandList; j++) {
	std::string custChoiceDemandName(demandList[j]);
	std::string plannerPart;
	std::string geo;
d1482 1
a1482 1
	witGetPartNConsumingBomEntries(theWitRun, custChoiceFeaturePart.c_str(), &ncbe);
d1486 1
a1486 1
	witGetPartConsumingBomEntry(theWitRun, custChoiceFeaturePart.c_str(), 0, &gpdWitPartName, &bomIndex);
d1500 1
a1500 1
	witGetPartSupplyVol(theWitRun, custChoiceFeaturePart.c_str(), &sfpSupplyVol);
d1504 1
a1504 1
	witGetOperationExecVol(theWitRun, custChoiceFeaturePart.c_str(), &sfpExecVol);
d1506 1
a1506 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)  
d1514 1
a1514 1
	witGetPartConsVol(theWitRun, custChoiceFeaturePart.c_str(), &featureConsVol);
d1519 1
a1519 1
	witGetPartExcessVol(theWitRun, custChoiceFeaturePart.c_str(), &ccfeatureExcessVol);
d1523 2
a1524 2
	float * shipVol = 0;
	witGetDemandShipVol( theWitRun, custChoiceFeaturePart.c_str(), custChoiceDemandName.c_str(), &shipVol);
d1536 1
a1536 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
d1545 1
a1545 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
d1573 1
a1573 1
  // Now look at STANDALONE OPTIONS modeled via 0 SUBSTITUTE !!
d1579 4
a1582 4
    std::string fullWitFeaturePartName(partList[i]);
    std::string featurePart;
    std::string ppp;
    std::string mmm, ggg;
d1591 1
a1591 1
      witGetPartDemands( theWitRun, fullWitFeaturePartName.c_str(), &lenDemandList, &demandList);
d1597 4
a1600 5
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<lenDemandList; j++) {
	std::string fullWitStandaloneFeatureDemandName(demandList[j]);
	std::string plannerPart;
	std::string geo;
d1610 1
a1610 1
	std::string plannerTopLevelPart = mpHelper.geoPlannerDemandPartName(plannerPart, geo);
d1614 1
a1614 1
	witGetPartProdVol(theWitRun, plannerTopLevelPart.c_str(), &gpdProdVol);
d1620 1
a1620 1
	witGetDemandShipVol( theWitRun, fullWitFeaturePartName.c_str(), fullWitStandaloneFeatureDemandName.c_str(), &shipVol);
d1622 1
a1622 1
	witGetPartSupplyVol(theWitRun, fullWitFeaturePartName.c_str(), &fen5supplyVol);
d1626 1
a1626 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
d1634 1
a1634 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++)   {
d1643 2
a1644 3
	witGetPartNBomEntries(theWitRun, plannerTopLevelPart.c_str(), &nBom);
	int k = 0; // Pulled out of the for below by RW2STL
	for (k=0; k<nBom; k++)  {
d1646 2
a1647 2
	  witGetBomEntryConsumedPart(theWitRun, plannerTopLevelPart.c_str(), k, &child);
	  std::string childPart(child);
d1656 2
a1657 3
	  witGetBomEntryNSubsBomEntries(theWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
	  int sj = 0; // Pulled out of the for below by RW2STL
	  for (sj=0; sj<nSubBom; sj++)  {
d1660 1
a1660 1
	    witGetSubsBomEntryConsumedPart(theWitRun, plannerTopLevelPart.c_str(), k, sj, &sub);
d1666 1
a1666 1
	    witGetSubsBomEntryProdVol(theWitRun, plannerTopLevelPart.c_str(), k, sj, &subProdVol);
d1669 1
a1669 1
	    witGetBomEntryUsageRate(theWitRun, plannerTopLevelPart.c_str(), k, &usageRatio);
d1671 2
a1672 2
	    witGetBomEntryEarliestPeriod(theWitRun, plannerTopLevelPart.c_str(), k, &early);
	    witGetBomEntryLatestPeriod(theWitRun, plannerTopLevelPart.c_str(), k, &late);            
d1718 1
a1718 1
	 std::string fileName,
d1723 1
a1723 1
   std::string partName;
d1725 1
a1725 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1737 4
a1740 4
   std::string plannerTopLevelPart;
   std::string geo;
   std::string mfgOptionPart;
   std::string bbCategory;
d1747 1
a1747 1
     std::string fullWitPartName(partList[i]);
d1750 1
a1750 1
       if (bbCategory.contains("STANDALONE:", std::string::ignoreCase))
d1755 1
a1755 1
       witGetPartConsVol(theWitRun, fullWitPartName.c_str(), &orsConsVol);
d1762 1
a1762 1
	 std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
d1765 1
a1765 1
	 witGetOperationExecVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdExecVol);
d1800 1
a1800 1
	 std::string fileName,
d1805 1
a1805 1
   std::string partName;
d1807 1
a1807 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1819 4
a1822 4
   std::string plannerTopLevelPart;
   std::string geo;
   std::string mfgOptionPart;
   std::string bbCategory;
d1829 1
a1829 1
     std::string fullWitPartName(partList[i]);
d1832 1
a1832 1
         if (sce::findCaseIns(bbCategory, "STANDALONE:") != sce::badIndex)
d1837 1
a1837 1
       witGetPartProdVol(theWitRun, fullWitPartName.c_str(), &sodProdVol);
d1844 1
a1844 1
	 std::string geoPlannerDemandPart(mpHelper.geoPlannerDemandPartName(
d1847 1
a1847 1
	 witGetPartProdVol(theWitRun, geoPlannerDemandPart.c_str(), &gpdProdVol);
d1888 1
a1888 1
	 std::string fileName,
d1892 1
a1892 1
  std::string partName;
d1894 1
a1894 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1905 2
a1906 3
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPartName  = partList[i];
d1911 1
a1911 1
    witGetPartCategory(theWitRun, fullWitPartName.c_str(), &category);
d1916 1
a1916 1
    witGetPartNBomEntries(theWitRun, fullWitPartName.c_str(), &nBom);
d1918 1
a1918 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
d1920 1
a1920 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName.c_str(), j, &nSubBom);
d1923 3
a1925 4
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
d1928 1
a1928 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, sj, &sub);
d1933 2
a1934 2
	  std::string subPartname =  mpHelper.partname(sub);
	  std::string subPdf =  mpHelper.pdf(sub);
d1937 1
a1937 1
	  std::string parentPartname = mpHelper.partname(fullWitPartName);
d1968 1
a1968 1
	 std::string fileName,
d1971 1
a1971 1
  std::string partName;
d1976 1
a1976 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d1987 2
a1988 3
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPartName  = partList[i];
d1993 1
a1993 1
    witGetPartCategory(theWitRun, fullWitPartName.c_str(), &category);
d1998 1
a1998 1
    witGetPartNBomEntries(theWitRun, fullWitPartName.c_str(), &nBom);
d2000 1
a2000 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
d2002 1
a2002 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitPartName.c_str(), j, &nSubBom);
d2005 3
a2007 4
	witGetBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
d2010 1
a2010 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitPartName.c_str(), j, sj, &sub);
d2015 2
a2016 2
	  std::string subPartname =  mpHelper.partname(sub);
	  std::string subPdf =  mpHelper.pdf(sub);
d2019 1
a2019 1
	  std::string parentPartname = mpHelper.partname(fullWitPartName);
d2050 1
a2050 1
	 std::string fileName,
d2054 1
a2054 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d2063 2
a2064 2
  std::string parentOperationName;
  std::string pdf;
d2067 2
a2068 3
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];
d2076 1
a2076 1
    witGetOperationNBomEntries(theWitRun, fullWitOperationName.c_str(), &nBom);
d2078 1
a2078 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
d2080 1
a2080 1
      witGetBomEntryNSubsBomEntries(theWitRun, fullWitOperationName.c_str(), j, &nSubBom);
d2083 3
a2085 4
	witGetBomEntryConsumedPart(theWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
d2088 1
a2088 1
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitOperationName.c_str(), j, sj, &sub);
d2093 1
a2093 1
	  std::string subPartname =  mpHelper.partname(sub);
d2095 1
a2095 1
	  witGetSubsBomEntryProdVol(theWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
d2126 2
a2127 2
	 bool parentMustBeUserDefinedOperation,
	 bool engineMustBeImplode,
d2131 1
a2131 1
	 std::string fileName,
d2134 1
a2134 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d2155 5
a2159 3
  std::string subUsageReportMode =  this->setOfParameters().getString("subUsageReportMode");
  bool isDataTransformNecessary = ( sce::compareStringsCaseIns( subUsageReportMode, "parentprod" ) == 0 );  
  bool transformToPrimary = TRUE;
d2161 1
a2161 1
    transformToPrimary = ( sce::compareStringsCaseIns( subUsageReportMode ,"primaryCoverage" ) == 0 );  
d2165 2
a2166 2
  std::string parentOperationName;
  std::string pdf;
d2169 2
a2170 3
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++ ) {
    std::string fullWitOperationName = opList[o];
d2195 1
a2195 1
    witGetOperationNBomEntries(theRightWitRun, fullWitOperationName.c_str(), &nBom);
d2197 1
a2197 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
d2199 1
a2199 1
      witGetBomEntryNSubsBomEntries(theRightWitRun, fullWitOperationName.c_str(), j, &nSubBom);
d2202 3
a2204 4
	witGetBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, &child);
	std::string childPartname =  mpHelper.partname(child);
	int sj = 0; // Pulled out of the for below by RW2STL
	for (sj=0; sj<nSubBom; sj++)  {
d2207 1
a2207 1
	  witGetSubsBomEntryConsumedPart(theRightWitRun, fullWitOperationName.c_str(), j, sj, &sub);
d2212 1
a2212 1
	  std::string subPartname =  mpHelper.partname(sub);
d2215 1
a2215 1
	    witGetSubsBomEntryProdVol(theRightWitRun, fullWitOperationName.c_str(), j, sj, &subProdVol);
d2233 1
a2233 1
	      witGetBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, &consRate);
d2235 1
a2235 1
	      witGetBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, &falloutRate);
d2237 1
a2237 1
	      witGetBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, &impactPeriod);
d2241 1
a2241 1
	      witGetSubsBomEntryConsRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &consRate);
d2243 1
a2243 1
	      witGetSubsBomEntryFalloutRate(theRightWitRun, fullWitOperationName.c_str(), j, sj, &falloutRate);
d2245 1
a2245 1
	      witGetSubsBomEntryImpactPeriod(theRightWitRun, fullWitOperationName.c_str(), j, sj, &impactPeriod);
d2288 1
a2288 1
	 std::string fileName,
d2291 1
a2291 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d2306 1
a2306 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
d2311 2
a2312 2
     std::string part = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
d2322 2
a2323 3
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
d2325 1
a2325 1
	 isVecNonZero = true;
d2363 2
a2364 2
	 bool isThisMrp,
	 std::string fileName,
d2367 1
a2367 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d2387 4
a2390 4
   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;
d2395 1
a2395 2
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
d2400 1
a2400 1
     std::string operationName(opList[o]);
d2410 2
a2411 3
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
d2413 1
a2413 1
	 isVecNonZero = true;
d2448 2
a2449 2
	 bool isThisMrp,
	 std::string fileName,
d2452 1
a2452 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d2472 4
a2475 4
   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;
d2480 1
a2480 2
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
d2485 1
a2485 1
     std::string operationName(opList[o]);
d2495 2
a2496 3
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
d2498 1
a2498 1
	 isVecNonZero = true;
d2538 2
a2539 3
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
d2541 4
a2544 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d2552 1
a2552 1
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
d2561 2
a2562 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d2567 1
a2567 1
    assert ( operationAppDataPtr != 0 );
d2570 1
a2570 1
    witGetOperationExecVol(theWitRun, operationName.c_str(), &execVol);
d2582 1
a2582 1
    std::string operationName (operationList[o]);
d2586 4
a2589 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;
    std::string sPdf;
d2595 1
a2595 1
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2597 2
a2598 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d2600 1
a2600 1
    assert ( operationAppDataPtr != 0 );
d2605 2
a2606 3
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
d2609 1
a2609 1
				      operationName.c_str(), 0, s,
d2615 3
a2617 3
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
d2619 4
a2622 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
d2631 2
a2632 2
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
d2634 1
a2634 1
      assert ( subIpOpAppDataPtr != 0 );
d2639 1
a2639 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
d2643 1
a2643 1
      witGetSubsBomEntrySubVol( theWitRun, operationName.c_str(), 0, s, &subVol );
d2648 1
a2648 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d2674 1
a2674 1
LgFrScenarioForSce::interplantExecVol(std::string & operationName)
d2677 2
a2678 2
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
d2680 1
a2680 1
  assert ( operationAppDataPtr != 0 );
d2686 1
a2686 1
LgFrScenarioForSce::interplantMrpExecVol(std::string & operationName)
d2689 2
a2690 2
  LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
d2692 1
a2692 1
  assert ( operationAppDataPtr != 0 );
d2712 2
a2713 3
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
d2715 4
a2718 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d2726 1
a2726 1
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
d2729 1
a2729 1
	       << operationName.c_str()
d2739 2
a2740 2
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d2742 1
a2742 1
    assert ( operationAppDataPtr == 0 );
d2748 1
a2748 1
    witSetOperationAppData( theWitRun, operationName.c_str(), (void *) operationAppDataPtr );
d2756 1
a2756 1
    std::string operationName (operationList[o]);
d2759 4
a2762 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d2770 1
a2770 1
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2772 3
a2774 3
    LgFrSceInterplantOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(), (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
d2779 1
a2779 1
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
d2781 1
a2781 2
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
d2784 1
a2784 1
				      operationName.c_str(), 0, s, &subPdfPart );
d2789 3
a2791 3
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.interPlantOperationName(
d2793 4
a2796 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
d2801 1
a2801 1
	     <<  operationName.c_str()
d2809 2
a2810 2
      LgFrSceInterplantOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
d2812 1
a2812 1
      assert ( subIpOpAppDataPtr != 0 );
d2817 1
a2817 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
d2826 1
a2826 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d2863 2
a2864 3
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
d2866 4
a2869 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d2877 1
a2877 1
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
d2886 2
a2887 2
    LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d2892 1
a2892 1
    assert ( operationAppDataPtr != 0 );
d2895 1
a2895 1
    witGetOperationExecVol(theWitRun, operationName.c_str(), &execVol);
d2907 1
a2907 1
    std::string operationName (operationList[o]);
d2911 4
a2914 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;
    std::string sPdf;
d2920 1
a2920 1
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d2922 2
a2923 2
    LgFrSceBinOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d2925 1
a2925 1
    assert ( operationAppDataPtr != 0 );
d2930 2
a2931 3
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
d2934 1
a2934 1
				      operationName.c_str(), 0, s,
d2940 3
a2942 3
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.binOperationName(
d2944 4
a2947 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
d2956 2
a2957 2
      LgFrSceBinOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
d2959 1
a2959 1
      assert ( subIpOpAppDataPtr != 0 );
d2964 1
a2964 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
d2968 1
a2968 1
      witGetSubsBomEntrySubVol( theWitRun, operationName.c_str(), 0, s, &subVol );
d2973 1
a2973 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d2999 1
a2999 1
LgFrScenarioForSce::binExecVol(std::string & operationName)
d3002 2
a3003 2
  LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
d3005 1
a3005 1
  assert ( operationAppDataPtr != 0 );
d3011 1
a3011 1
LgFrScenarioForSce::binMrpExecVol(std::string & operationName)
d3014 2
a3015 2
  LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
  witGetOperationAppData( theWitRun, operationName.c_str(),
d3017 1
a3017 1
  assert ( operationAppDataPtr != 0 );
d3037 2
a3038 3
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++) {
    std::string operationName (operationList[o]);
d3040 4
a3043 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d3051 1
a3051 1
    witGetOperationNBomEntries( theWitRun, operationName.c_str(), &nBoms);
d3054 1
a3054 1
	       << operationName.c_str()
d3064 2
a3065 2
    LgFrSceBinOpAppData * operationAppDataPtr = 0 ;
    witGetOperationAppData( theWitRun, operationName.c_str(),
d3067 1
a3067 1
    assert ( operationAppDataPtr == 0 );
d3073 1
a3073 1
    witSetOperationAppData( theWitRun, operationName.c_str(), (void *) operationAppDataPtr );
d3081 1
a3081 1
    std::string operationName (operationList[o]);
d3084 4
a3087 4
    std::string dPart;
    std::string dPdf;
    std::string sPart;    
    std::string sPdf;
d3095 1
a3095 1
    std::string sourcePdfPart = mpHelper.pdfPartname( sPart, sPdf );
d3097 3
a3099 3
    LgFrSceBinOpAppData * operationAppDataPtr = 0;
    witGetOperationAppData( theWitRun, operationName.c_str(), (void **) &operationAppDataPtr );
    assert ( operationAppDataPtr != 0 );
d3104 1
a3104 1
    witGetBomEntryNSubsBomEntries( theWitRun, operationName.c_str(), 0, &nSubBoms );
d3106 1
a3106 2
    int s = 0; // Pulled out of the for below by RW2STL
    for ( s=0; s<nSubBoms; s++) {
d3109 1
a3109 1
				      operationName.c_str(), 0, s, &subPdfPart );
d3114 3
a3116 3
      std::string subPart = mpHelper.partname( subPdfPart );
      std::string subPdf = mpHelper.pdf( subPdfPart );
      std::string subIpOp = mpHelper.binOperationName(
d3118 4
a3121 4
      std::string destPart;
      std::string destPdf;
      std::string sourcePart;      
      std::string sourcePdf;
d3126 1
a3126 1
	     <<  operationName.c_str()
d3134 2
a3135 2
      LgFrSceBinOpAppData * subIpOpAppDataPtr = 0;
      witGetOperationAppData( theWitRun, subIpOp.c_str(),
d3137 1
a3137 1
      assert ( subIpOpAppDataPtr != 0 );
d3142 1
a3142 1
      witGetSubsBomEntryUsageRate( theWitRun, operationName.c_str(), 0, s, &subUsageRate );
d3151 1
a3151 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d3186 1
a3186 1
	 std::string fileName,
d3189 1
a3189 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3205 3
a3207 4
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
d3216 2
a3217 3
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
d3219 1
a3219 1
	 isVecNonZero = true;
d3259 1
a3259 1
	 std::string fileName,
d3262 1
a3262 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3280 3
a3282 4
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++ ) {
     std::string thePdf;
     std::string theOperation;
d3291 2
a3292 3
     bool isVecNonZero = false;
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++) {
d3294 1
a3294 1
	 isVecNonZero = true;
d3333 1
a3333 1
					       std::string fileName,
d3337 1
a3337 1
  std::string partName;
d3339 1
a3339 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3360 3
a3362 3
    std::string partname = mpHelper.partname(partList[i]);
    std::string plannerPart;
    std::string geo;
d3401 1
a3401 1
	 std::string fileName,
d3405 4
a3408 4
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
d3410 1
a3410 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3423 1
a3423 1
   std::string * sourceList = new std::string[nPeriods];
d3514 1
a3514 1
	 std::string fileName,
d3518 1
a3518 1
  std::string partName;
d3520 1
a3520 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3539 2
a3540 2
    std::string plannerPart;
    std::string geo;
d3545 1
a3545 1
      std::string partname = mpHelper.partname(partList[i]);
d3573 1
a3573 1
	 std::string fileName,
d3577 1
a3577 1
  std::string partName;
d3579 1
a3579 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3598 2
a3599 2
    std::string plannerPart;
    std::string geo;
d3601 2
a3602 2
      std::string partname = mpHelper.partname(partList[i]);
      std::string pdf = mpHelper.pdf(partList[i]);
d3618 1
a3618 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
d3648 1
a3648 1
	 std::string fileName,
d3652 1
a3652 1
  std::string partName;
d3654 1
a3654 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3666 1
a3666 1
   std::string demandName("WW");
d3675 2
a3676 2
       SCEDate thisDate(theCal.periodStart(t));
       std::string theDate("    " + thisDate.asString() + "   ");
d3681 4
a3684 4
       std::string parti(partList[i]);
       std::string partname = mpHelper.partname(parti);
       std::string plannerPart;
       std::string geo;
d3687 1
a3687 1
	 witGetPartDemands(theWitRun, parti.c_str(), &nDemands, &dList);
d3700 1
a3700 1
	   witGetDemandShipVol(theWitRun, parti.c_str(), dList[j], &witVector1);
d3736 1
a3736 1
	 std::string fileName,
d3740 2
a3741 2
   std::string geo;
   std::string plannerPart;
d3743 1
a3743 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3753 1
a3753 1
   std::string * sourceList = new std::string[nPeriods];
d3770 1
a3770 2
     int t = 0; // Pulled out of the for below by RW2STL
     for (t=0; t<nPeriods; t++)
d3795 1
a3795 1
	 std::string fileName,
d3799 1
a3799 1
   std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3810 1
a3810 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
d3813 2
a3814 2
     std::string partname = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
d3838 1
a3838 1
	 std::string engine,            // rollover handled differently
d3842 1
a3842 1
	 std::string fileName,
d3847 1
a3847 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d3857 2
a3858 3
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<theCritList.getLength(); i++ ) {
     std::string part = theCritList.getPart(i);
d3862 2
a3863 2
     std::string partname = mpHelper.partname(part);
     std::string pdf = mpHelper.pdf(part);
d3898 1
a3898 1
     std::string lowestLevelNonPcfFileName =
d3907 1
a3907 1
     std::string pcfBogonsFileName =
d3947 1
a3947 1
    std::string siteCustomization = setOfParameters.getString("siteCustomization");
d3983 1
a3983 1
	std::string geoSourceDebugFileName =
d3993 1
a3993 1
      std::string formattedSupplyReportFileName =
d4001 1
a4001 1
    std::string supplyResponseFileName =
d4007 3
a4009 3
    std::string independentDemandFile = setOfParameters.getString("independentDemandFile");
    if (! independentDemandFile.empty())   {
      std::string indepSupplyResponseFileName =
d4018 1
a4018 1
      std::string geoSupplyByPdfFileName =
d4026 1
a4026 1
      std::string backlogResponseFileName =
d4036 1
a4036 1
      std::string criticalListFileName =
d4038 1
a4038 1
      std::string engine = setOfParameters.getString( "engine");
d4045 1
a4045 1
      std::string buildSchedFileName =
d4055 3
a4057 3
      std::string interPlantFile = setOfParameters.getString("interPlantFile");
      if (! interPlantFile.empty())   {
	std::string interplantOrdersFileName =
d4059 1
a4059 1
	bool isThisMrp = false;
d4070 4
a4073 4
    bool printShadowPricesFile = setOfParameters.getBool("printShadowPricesFile");
    std::string engine = this->getEngine();
    if ((! engine.compare("optimization")) && printShadowPricesFile) {
      std::string shadowPricesFileName = setOfParameters.getString("shadowPricesFileName");
d4088 1
a4088 1
      std::string operationOrdersFileName =
d4100 3
a4102 3
      std::string binFile = setOfParameters.getString("binFile");
      if (! binFile.empty())   {
	std::string binOrdersFileName =
d4104 1
a4104 1
	bool isThisMrp = false;
d4118 5
a4122 5
    std::string subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = false;
      bool engineMustBeImplode = true;
      std::string subUsageFileName = setOfParameters.getString("subUsageFileName");
d4133 5
a4137 5
    std::string opSubBomFile = setOfParameters.getString("opSubBomFile");    
    if (! opSubBomFile.empty())   {
      bool parentMustBeUserDefinedOperation = true;
      bool engineMustBeImplode = true;
      std::string opSubUsageFileName = setOfParameters.getString("opSubUsageFileName");
d4152 1
a4152 1
    std::string featureFileOutputFormat =
d4163 3
a4165 3
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      std::string optionalFeatRatioFileName =
d4174 1
a4174 1
    std::string topLevelToBBratioFile =
d4176 2
a4177 2
    if (! topLevelToBBratioFile.empty()) {
      std::string selFeatBBratioFileName =
d4193 1
a4193 1
      std::string
d4201 1
a4201 1
      std::string capacityDBFileName =
d4210 1
a4210 1
      std::string operationDBFileName =
d4218 1
a4218 1
      std::string debugFileName =
d4225 1
a4225 1
   std::string problemStatisticsFileName =
d4233 1
a4233 1
   std::string objectiveSummaryFileName =
d4243 1
a4243 2
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOperations; o++) 
d4259 1
a4259 1
  const std::string & engine = getEngine();
d4273 1
a4273 1
    bool doPegging = setOfParameters.getBool("doPegging");
d4290 1
a4290 1
    bool doPegging = setOfParameters.getBool("doPegging");
d4353 2
a4354 2
  bool printDemandConsPegFile = setOfParameters.getBool("printDemandConsPegFile");
  bool printIndpDemandConsPegFile = setOfParameters.getBool("printIndpDemandConsPegFile");
d4356 2
a4357 2
  std::string demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
  std::string indpDemandConsPegFileName = setOfParameters.getString("indpDemandConsPegFileName");
d4359 2
a4360 2
  bool printInterplantPegFile = setOfParameters.getBool("printInterplantPegFile");
  bool printIndpInterplantPegFile = setOfParameters.getBool("printIndpInterplantPegFile");
d4362 2
a4363 2
  std::string interplantPegFileName = setOfParameters.getString("interplantPegFileName");
  std::string indpInterplantPegFileName = setOfParameters.getString("indpInterplantPegFileName");
d4365 2
a4366 2
  bool printExecVolPegFile = setOfParameters.getBool("printExecVolPegFile");
  bool printIndpExecVolPegFile = setOfParameters.getBool("printIndpExecVolPegFile");
d4368 2
a4369 2
  std::string execVolPegFileName = setOfParameters.getString("execVolPegFileName");
  std::string indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");
d4372 2
a4373 2
  bool printProdVolPegFile = setOfParameters.getBool("printProdVolPegFile");
  std::string prodVolPegFileName = setOfParameters.getString("prodVolPegFileName");
d4419 1
a4419 1
  std::string plannerPart, geo;
d4427 1
a4427 1
    std::ofstream dPegFile;
d4430 1
a4430 1
    dPegFile.open(demandConsPegFileName.c_str(), std::ofstream::out);
d4432 1
a4432 1
      std::string fileErrorString("Demand Pegging Consumption File");
d4439 1
a4439 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4455 1
a4455 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4459 1
a4459 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4462 1
a4462 1
	if ( demandAppDataPtr == 0 ) {
d4471 2
a4472 3
	int nConsumedParts = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
d4511 1
a4511 1
    std::ofstream idPegFile;
d4514 1
a4514 1
    idPegFile.open(indpDemandConsPegFileName.c_str(), ios::out);
d4516 1
a4516 1
      std::string fileErrorString("Independent Demand Pegging Consumption File");
d4525 1
a4525 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4538 1
a4538 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4542 1
a4542 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4545 1
a4545 1
	if ( demandAppDataPtr == 0 ) {
d4555 2
a4556 3
	int nConsumedParts = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
d4590 1
a4590 1
    std::ofstream evPegFile;
d4593 1
a4593 1
    evPegFile.open(execVolPegFileName.c_str(), ios::out);
d4595 1
a4595 1
      std::string fileErrorString("ExecVol Pegging File");
d4602 1
a4602 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4618 1
a4618 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4622 1
a4622 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4625 1
a4625 1
	if ( demandAppDataPtr == 0 ) {
d4635 2
a4636 3
	int nConsumedParts = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
d4671 1
a4671 1
    std::ofstream pvPegFile;
d4674 1
a4674 1
    pvPegFile.open(prodVolPegFileName.c_str(), ios::out);
d4676 1
a4676 1
      std::string fileErrorString("ProdVol Pegging File");
d4683 1
a4683 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4699 1
a4699 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4703 1
a4703 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4706 1
a4706 1
	if ( demandAppDataPtr == 0 ) {
d4719 2
a4720 3
	int nOperations = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
d4763 1
a4763 1
    std::ofstream idEvPegFile;
d4766 1
a4766 1
    idEvPegFile.open(indpExecVolPegFileName.c_str(), ios::out);
d4768 1
a4768 1
      std::string fileErrorString("Independent Demand ExecVol Pegging  File");
d4778 1
a4778 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4791 1
a4791 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4795 1
a4795 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4798 1
a4798 1
	if ( demandAppDataPtr == 0 ) {
d4808 2
a4809 3
	int nOperations = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
d4843 1
a4843 1
    std::ofstream ipPegFile;
d4846 1
a4846 1
    ipPegFile.open(interplantPegFileName.c_str(), ios::out);
d4848 1
a4848 1
      std::string fileErrorString("Interplant Pegging File");
d4856 1
a4856 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4872 1
a4872 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4876 1
a4876 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4879 1
a4879 1
	if ( demandAppDataPtr == 0 ) {
d4889 2
a4890 3
	int nConsumedParts = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nConsumedParts; cp++ ) {
d4894 1
a4894 1
	  std::string pn1,customerPdf,pn2,supplierPdf;
d4927 1
a4927 1
    std::ofstream idIpPegFile;
d4930 1
a4930 1
    idIpPegFile.open(indpInterplantPegFileName.c_str(), ios::out);
d4932 1
a4932 1
      std::string fileErrorString("Independent Interplant Demand Pegging  File");
d4942 1
a4942 2
    int i = 0; // Pulled out of the for below by RW2STL
    for(i=0; i<nParts; i++){
d4955 1
a4955 2
      int j = 0; // Pulled out of the for below by RW2STL
      for(j=0; j<nDemands; j++){
d4959 1
a4959 1
	LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d4962 1
a4962 1
	if ( demandAppDataPtr == 0 ) {
d4972 2
a4973 3
	int nOperations = pegSched.size();
	int cp = 0; // Pulled out of the for below by RW2STL
	for ( cp=0; cp<nOperations; cp++ ) {
d4977 1
a4977 1
	  std::string pn1,customerPdf,pn2,supplierPdf;
d5004 1
a5004 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++) {
d5032 1
a5032 2
  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;
d5034 2
a5035 1
  bool pegSubUsageToPrimary = this->setOfParameters().getBool("pegSubUsageToPrimary");
d5038 1
a5038 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d5043 1
a5043 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d5057 1
a5057 1
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d5064 1
a5064 1
	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
d5066 1
a5066 1
	if ( demandAppDataPtr == 0 ) {
d5069 1
a5069 1
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
d5076 1
a5076 1
	if ( demandAppDataPtr == 0 ) {
d5138 24
d5165 1
a5165 1
  std::string allocMrpSeparatorChar("#");
d5168 1
a5168 1
				  allocMrpSeparatorChar[0],
d5184 1
a5184 1
  std::string allocatedMrpFileName =
d5189 2
a5190 2
  std::string allocatedIndepMrpFileName("");
  if (! setOfParameters().getString("independentDemandFile").empty())
d5235 1
a5235 1
    std::string fileName)
d5237 1
a5237 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d5273 1
a5273 1
   bool doImplode = setOfParameters.getBool("doImplode");
d5278 1
a5278 1
     std::string fullPartName(partList[i]);
d5283 1
a5283 1
     witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d5285 1
a5285 1
     witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVol);
d5288 1
a5288 1
       witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);
d5290 1
a5290 1
     witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d5292 1
a5292 1
       witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);
d5300 2
a5301 2
       witGetPartExcessVol(theWitRun, fullPartName.c_str(), &excessVol);
       witGetPartResidualVol(theWitRun, fullPartName.c_str(), &residualVol);
d5303 3
a5305 3
	 witGetPartStockVol(theWitRun, fullPartName.c_str(), &stockVol);
       witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);
       witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
d5307 1
a5307 1
	 witGetPartProdVol(theWitRun, fullPartName.c_str(),  &prodVol);
d5313 2
a5314 2
     std::string pn(fullPartName);
     std::string pdf(mpHelper.pdf(fullPartName));
d5372 1
a5372 1
    std::string fileName)
d5375 1
a5375 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d5392 2
a5393 2
  bool doImplode =         setOfParameters.getBool("doImplode");
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d5445 1
a5445 1
  int alwaysPrintForECAonly = (sce::compareStringsCaseIns( siteCustomization, "eca" ) ? 0 : 1);
d5451 1
a5451 1
    std::string fullPartName(partList[i]);
d5459 1
a5459 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d5462 1
a5462 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d5471 1
a5471 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d5474 1
a5474 1
    witGetPartDemands(theWitRun, fullPartName.c_str(), &nDemands, &dList);
d5486 1
a5486 1
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &supplyVolSpecifiedByUser);
d5506 1
a5506 1
      witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);
d5515 3
a5517 4
	witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
	assert(appDataPtr != 0);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
d5526 1
a5526 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
d5528 2
a5529 3
      witGetDemandDemandVol(theWitRun, fullPartName.c_str(), dList[j], &indepDemandVol);
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
d5540 1
a5540 2
      int tt = 0; // Pulled out of the for below by RW2STL
      for (tt=0; tt<nPeriods; tt++) {
d5565 1
a5565 1
      witGetOperationExecutable(theWitRun, fullPartName.c_str(), &execFlag);
d5568 1
a5568 1
      witGetOperationYieldRate(theWitRun, fullPartName.c_str(), &yieldRate);
d5576 1
a5576 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d5604 2
a5605 2
	bool foundOpCategory = false;          
	std::string cp1, pdf1, sp2, pdf2;
d5614 2
a5615 2
	witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
	std::string operationName(witOperationName);
d5628 1
a5628 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d5634 1
a5634 1
	  foundOpCategory = true;
d5643 1
a5643 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d5649 1
a5649 1
	  foundOpCategory = true;
d5660 1
a5660 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d5666 1
a5666 1
	  foundOpCategory = true;
d5675 1
a5675 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d5681 1
a5681 1
	  foundOpCategory = true;
d5691 1
a5691 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=early; t<=late; t++) {
d5701 1
a5701 1
	  foundOpCategory = true;
d5761 1
a5761 1
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &scrapVol);
d5765 1
a5765 1
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &consVol);
d5769 2
a5770 3
	witGetDemandShipVol(theWitRun, fullPartName.c_str(), dList[j], &indepShipVol);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
d5781 1
a5781 2
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<nPeriods; tt++) {
d5804 4
a5807 5
      witGetPartStockVol(theWitRun, fullPartName.c_str(), &witStockVol);
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witExcessVol);
      witGetPartResidualVol(theWitRun, fullPartName.c_str(), &witResidualVol);
      int ttt = 0; // Pulled out of the for below by RW2STL
      for (ttt=0; ttt<nPeriods; ttt++) {
d5908 1
a5908 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=1; t<nPeriods; t++) {
d5968 1
a5968 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d5976 2
a5977 2
    std::string pn(mpHelper.partname(fullPartName));
    std::string pdf(mpHelper.pdf(fullPartName));
d6127 2
a6128 2
    std::string & pn, 
    std::string & pdf, 
d6131 1
a6131 1
    std::ofstream & outFile,   // output stream (already opened)
d6150 2
a6151 2
    std::string & pn, 
    std::string & pdf, 
d6154 1
a6154 1
    std::ofstream & outFile,   // output stream (already opened)
d6190 1
a6190 1
    std::string fileName)
d6193 1
a6193 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d6210 1
a6210 1
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d6213 1
a6213 1
  bool doImplode = setOfParameters.getBool("doImplode");
d6220 2
a6221 2
    std::string operation(opList[o]);
    std::string op, p;
d6236 1
a6236 1
    witGetOperationExecutable(theWitRun, operation.c_str(), &witBoolVec);
d6245 1
a6245 1
    witGetOperationYieldRate(theWitRun, operation.c_str(), &witVector);
d6274 1
a6274 1
      witGetOperationExecVol(theWitRun, operation.c_str(), &witVector);
d6317 1
a6317 1
    std::string fileName)
d6320 1
a6320 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d6345 1
a6345 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {
d6347 4
a6350 4
    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2;
    std::string PUD14SourceCode;
    std::string supplierPdf, customerPdf, producedPart;
d6396 2
a6397 3
    witGetOperationNBopEntries(exploderWitRun, fullWitOperation.c_str(), &nBops);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBops; b++) {
d6406 1
a6406 1
      witGetBopEntryProducedPart(exploderWitRun, fullWitOperation.c_str(), b, &producedPart);
d6414 3
a6416 3
      witGetBopEntryProdRate(exploderWitRun, fullWitOperation.c_str(), b, &prodRate);
      witGetBopEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &early);
      witGetBopEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), b, &late);
d6421 1
a6421 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
d6429 1
a6429 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
d6435 1
a6435 1
      witGetOperationYieldRate(exploderWitRun, fullWitOperation.c_str(), &yieldRate);
d6437 1
a6437 1
      witGetBopEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), b, &impactPeriod);
d6441 1
a6441 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d6479 1
a6479 1
  std::string PUD14SourceCode = "E";
d6481 3
a6483 4
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullWitPart(partList[i]);
    std::string partName, customerPdf;
d6488 1
a6488 1
      witGetPartSupplyVol(exploderWitRun, fullWitPart.c_str(), &supplyVol);
d6490 1
a6490 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t< nPeriods; t++) {
d6539 1
a6539 1
    std::string fileName)
d6542 1
a6542 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d6571 1
a6571 1
  assert(FsourceDemand != 0);
d6573 1
a6573 1
  assert(OsourceDemand != 0);
d6576 1
a6576 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d6578 1
a6578 1
    assert(FsourceDemand[i] != 0);    
d6580 1
a6580 1
    assert(OsourceDemand[i] != 0);
d6582 1
a6582 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d6591 1
a6591 1
    if (appDataPtr == 0) {
d6604 1
a6604 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++ ) {
d6606 5
a6610 5
    std::string fullWitOperation(opList[o]);
    std::string op, p, pn1, pdf1, pn2, pdf2, geo, plannerPart;
    std::string sourceCode;
    std::string supplierPdf, customerPdf;
    std::string gg, mm;
d6668 2
a6669 3
    witGetOperationNBomEntries(exploderWitRun, fullWitOperation.c_str(), &nBoms);
    int k = 0; // Pulled out of the for below by RW2STL
    for (k=0; k<nBoms; k++) {
d6677 1
a6677 1
      witGetBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, &consumedPart);
d6693 4
a6696 4
      witGetBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, &usageRate);
      witGetBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &early);
      witGetBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, &late);
      witGetBomEntryFallout(exploderWitRun, fullWitOperation.c_str(), k, &fallout);      
d6698 1
a6698 1
      witGetBomEntryImpactPeriod(exploderWitRun, fullWitOperation.c_str(), k, &impactPeriod);
d6707 2
a6708 3
      witGetBomEntryNSubsBomEntries(exploderWitRun, fullWitOperation.c_str(), k, &nSubs);
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubs; s++) {
d6715 5
a6719 5
	witGetSubsBomEntryUsageRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subUsageRate);
	witGetSubsBomEntryEarliestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subEarly);
	witGetSubsBomEntryLatestPeriod(exploderWitRun, fullWitOperation.c_str(), k, s, &subLate);
	witGetSubsBomEntryFalloutRate(exploderWitRun, fullWitOperation.c_str(), k, s, &subFalloutRate);
	witGetSubsBomEntryConsumedPart(exploderWitRun, fullWitOperation.c_str(), k, s, &subConsumedPart);
d6722 1
a6722 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++)
d6763 1
a6763 1
	  assert(myAppDataPtr != 0);
d6771 1
a6771 1
	  assert(myAppDataPtr != 0);
d6784 1
a6784 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d6798 1
a6798 1
      assert(myAppDataPtr != 0);
d6834 1
a6834 1
    std::string thePart(partList[i]);
d6840 1
a6840 1
      std::string thePdf(mpHelper.pdf(thePart));
d6851 1
a6851 1
      std::string thePdf(mpHelper.pdf(thePart));
d6935 1
a6935 1
/*void
d6942 1
a6942 1
}*/
d7014 1
a7014 1
// localSnapshotPtr_(0),
d7017 5
a7021 5
 exploderPtr_(0),
 sceErrFacDisp_(0),
 sceMsgFacDisp_(0),
 sceErrFacility_(0),
 sceMsgFacility_(0),
d7044 1
a7044 1
    std::string dPart,dPdf,sPart,sPdf;
d7075 1
a7075 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++) {
d7080 1
a7080 2
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) { 
d7105 2
a7106 3
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d7108 1
a7108 1
      if ( demandAppDataPtr != 0 ) 
d7118 1
a7118 1
//  delete  localSnapshotPtr_;
d7162 1
a7162 1
//  localSnapshotPtr_( source.localSnapshotPtr_ ),
d7177 2
a7178 2
  std::ifstream temp1;
  std::ifstream temp2;
d7180 2
a7181 2
  std::string errFileName = "errorLog" + numTempFiles_;
  std::string msgFileName = "messageLog" + numTempFiles_;
d7183 2
a7184 2
  temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
  temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);
d7190 2
a7191 2
    temp1.open(errFileName.c_str());//, ios::in | ios::nocreate);
    temp2.open(msgFileName.c_str());//, ios::in | ios::nocreate);
d7197 1
a7197 1
  sceErrFacDisp_ = new MclPrintfOutputDisplayer(errFileName.c_str(),"w+");
d7201 1
a7201 1
  sceMsgFacDisp_ = new MclPrintfOutputDisplayer(msgFileName.c_str(),"w+");
d7218 1
a7218 1
//  localSnapshotPtr_(0),
d7221 5
a7225 5
  exploderPtr_(0),
  sceErrFacDisp_(0),
  sceMsgFacDisp_(0),
  sceErrFacility_(0),
  sceMsgFacility_(0),
d7255 1
a7255 1
      std::string geoSourceDebugFileName =
d7265 1
a7265 1
      std::string formattedSupplyReportFileName =
d7273 1
a7273 1
    std::string supplyResponseFileName =
d7291 1
a7291 1
      std::string geoSupplyByPdfFileName =
d7320 1
a7320 1
    std::string backlogResponseFileName =
d7339 1
a7339 1
      std::string criticalListFileName =
d7341 1
a7341 1
      std::string engine = setOfParameters.getString( "engine");
d7348 1
a7348 1
    std::string buildSchedFileName =
d7370 3
a7372 3
    std::string interPlantFile = setOfParameters.getString("interPlantFile");
    if (! interPlantFile.empty())   {
      std::string interplantOrdersFileName =
d7374 1
a7374 1
      bool isThisMrp = false;
d7404 3
a7406 3
    std::string subBomFile = setOfParameters.getString("subBomFile");    
    if (! subBomFile.empty())   {
      std::string subUsageFileName =
d7419 1
a7419 1
    std::string operationOrdersFileName =
d7430 1
a7430 1
    std::string featureFileOutputFormat =
d7441 3
a7443 3
    std::string topLevelToOptionFile = setOfParameters.getString("topLevelToOptionFile");
    if (! topLevelToOptionFile.empty()) {
      std::string optionalFeatRatioFileName =
d7452 1
a7452 1
    std::string topLevelToBBratioFile =
d7454 2
a7455 2
    if (! topLevelToBBratioFile.empty()) {
      std::string selFeatBBratioFileName =
d7465 1
a7465 1
      std::string
d7555 1
a7555 1
      std::string capacityDBFileName =
d7638 1
a7638 1
      std::string operationDBFileName =
d7646 1
a7646 1
      std::string debugFileName =
d7653 1
a7653 1
   std::string problemStatisticsFileName =
d7659 2
a7660 2
   std::string engine = setOfParameters.getString("engine");   
   std::string objectiveSummaryFileName =
d7682 1
a7682 1
  std::string partName;
d7693 2
a7694 2
    std::string plannerPart;
    std::string geo;
d7697 1
a7697 1
      std::string partname = mpHelper.partname(partList[i]);
d7721 1
a7721 1
  std::string partName;
d7733 3
a7735 3
    std::string partname = mpHelper.partname(partList[i]);
    std::string plannerPart;
    std::string geo;
d7775 2
a7776 3
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
d7780 3
a7782 3
    witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
    capSupplyVol.insert(SceArgList() << mpHelper.partname(fullPartName).c_str()
			<< mpHelper.pdf(fullPartName).c_str()
d7803 2
a7804 3
    int i = 0; // Pulled out of the for below by RW2STL
    for ( i=0; i<nParts; i++ ) {
      std::string fullPartName(partList[i]);
d7813 2
a7814 2
			  << mpHelper.partname(fullPartName).c_str()
			  << mpHelper.pdf(fullPartName).c_str()
d7841 2
a7842 3
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
d7850 2
a7851 2
		    << mpHelper.partname(fullPartName).c_str()
		    << mpHelper.pdf(fullPartName).c_str()
d7861 2
a7862 2
			     << mpHelper.partname(fullPartName).c_str()
			     << mpHelper.pdf(fullPartName).c_str()
d7867 1
a7867 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d7873 2
a7874 2
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
d7899 1
a7899 1
  bool doImplode = setOfParameters.getBool("doImplode");
d7902 2
a7903 3
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
d7909 1
a7909 1
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
d7912 2
a7913 2
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
d7934 2
a7935 3
  int i = 0; // Pulled out of the for below by RW2STL
  for ( i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
d7939 1
a7939 1
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
d7942 2
a7943 2
		       << mpHelper.partname(fullPartName).c_str()
		       << mpHelper.pdf(fullPartName).c_str()
d7964 2
a7965 3
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
    std::string fullPartName(partList[i]);
d7968 1
a7968 1
    witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
d7972 2
a7973 2
			  << mpHelper.partname(fullPartName).c_str()
			  << mpHelper.pdf(fullPartName).c_str()
d7993 4
a7996 4
   std::string destination;
   std::string destinationPdf;
   std::string source;
   std::string sourcePdf;
d8004 1
a8004 2
   int o = 0; // Pulled out of the for below by RW2STL
   for (o=0; o<nOps; o++ ) {
d8013 2
a8014 3
       bool isVecNonZero = false;
       int t = 0; // Pulled out of the for below by RW2STL
       for (t=0; t<nPeriods; t++) {
d8016 1
a8016 1
	   isVecNonZero = true;
d8049 4
a8052 4
  std::string mfgPart;
  std::string pdf;
  std::string geo;
  std::string plannerPart;
d8059 1
a8059 1
   std::string * sourceList = new std::string[nPeriods];
d8151 1
a8151 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
d8155 2
a8156 2
       std::string partname = mpHelper.partname(partList[i]);
       std::string pdf = mpHelper.pdf(partList[i]);
d8182 1
a8182 2
   int i = 0; // Pulled out of the for below by RW2STL
   for (i=0; i<nParts; i++ ) {
d8185 2
a8186 2
     std::string partname = mpHelper.partname(partList[i]);
     std::string pdf = mpHelper.pdf(partList[i]);
d8218 1
a8218 1
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d8221 1
a8221 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8223 1
a8223 1
    std::string fullPartName(partList[i]);
d8231 1
a8231 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8234 1
a8234 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8240 1
a8240 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8244 1
a8244 1
      witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
d8252 1
a8252 1
      witGetPartSupplyVol(theWitRun, fullPartName.c_str(), &witVector);
d8283 1
a8283 1
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d8286 1
a8286 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8288 1
a8288 1
    std::string fullPartName(partList[i]);
d8296 1
a8296 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8299 1
a8299 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8305 1
a8305 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists); 
d8315 1
a8315 1
      witGetPartCycleTime(theWitRun, fullPartName.c_str(),  &cycleTime);
d8325 3
a8327 4
	witGetPartAppData(theWitRun, fullPartName.c_str(), (void **) &appDataPtr);
	assert(appDataPtr != 0);
	int tt = 0; // Pulled out of the for below by RW2STL
	for (tt=0; tt<appDataPtr->unConstrainedStartPeriod(); tt++)
d8370 1
a8370 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8372 1
a8372 1
    std::string fullPartName(partList[i]);
d8380 1
a8380 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8383 1
a8383 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8389 1
a8389 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);  
d8427 1
a8427 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8429 1
a8429 1
    std::string fullPartName(partList[i]);
d8437 1
a8437 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8440 1
a8440 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8446 1
a8446 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8468 1
a8468 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d8510 1
a8510 1
  bool doImplode = setOfParameters.getBool("doImplode");
d8513 1
a8513 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8515 1
a8515 1
    std::string fullPartName(partList[i]);
d8523 1
a8523 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8526 1
a8526 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8532 1
a8532 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8537 1
a8537 1
      witGetPartExcessVol(theWitRun, fullPartName.c_str(), &witVector);
d8566 1
a8566 1
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d8570 1
a8570 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8572 1
a8572 1
    std::string fullPartName(partList[i]);
d8580 1
a8580 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8583 1
a8583 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8589 1
a8589 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8594 1
a8594 1
	  witGetPartStockVol(theWitRun, fullPartName.c_str(), &witVector);
d8604 1
a8604 1
	  witGetPartStockVol(theWitRun, fullPartName.c_str(), &witVector);
d8634 1
a8634 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8636 1
a8636 1
    std::string fullPartName(partList[i]);
d8644 1
a8644 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8647 1
a8647 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8653 1
a8653 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);    
d8655 1
a8655 1
      witGetPartScrapVol(theWitRun, fullPartName.c_str(), &witVector);
d8684 1
a8684 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++ ) {
d8686 1
a8686 1
    std::string fullPartName(partList[i]);
d8694 1
a8694 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8697 1
a8697 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8703 1
a8703 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists); 
d8705 1
a8705 1
      witGetPartConsVol(theWitRun, fullPartName.c_str(), &witVector);
d8742 1
a8742 1
  std::string siteCustomization = setOfParameters.getString("siteCustomization");
d8745 1
a8745 1
  bool doImplode = setOfParameters.getBool("doImplode");
d8772 1
a8772 1
    std::string fullPartName(partList[i]);
d8780 1
a8780 1
    witGetPartCategory(theWitRun, fullPartName.c_str(), &category);
d8783 1
a8783 1
    witGetPartNProducingBopEntries(theWitRun, fullPartName.c_str(), &npBops);
d8789 1
a8789 1
    witGetOperationExists(theWitRun, fullPartName.c_str(), &operationExists);
d8798 1
a8798 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d8820 1
a8820 1
        bool foundOpCategory = false;          
d8823 1
a8823 1
        std::string cp1, pdf1, sp2, pdf2;
d8833 2
a8834 2
        witGetPartProducingBopEntry(theWitRun, fullPartName.c_str(), p, &witOperationName, &b);
        std::string operationName(witOperationName);
d8845 1
a8845 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
d8849 1
a8849 1
          foundOpCategory = true;
d8857 1
a8857 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
d8861 1
a8861 1
          foundOpCategory = true;
d8868 1
a8868 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
d8872 1
a8872 1
          foundOpCategory = true;
d8882 1
a8882 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++) {
d8891 1
a8891 1
          foundOpCategory = true;
d8967 1
a8967 1
	  witGetPartProdVol(theWitRun, fullPartName.c_str(),  &witVector);
d9061 4
a9064 4
  assert(testScenarioDupPtr3->setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(testScenarioDupPtr3->setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(testScenarioDupPtr3->setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(testScenarioDupPtr3->setOfDemands(LGFR_DEFAULT_SET).size() == 2);
d9072 4
a9075 4
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).size() == 2);
d9086 1
a9086 1
  assert (tsDifPtr3 != 0
d9091 1
a9091 1
  assert (tsDupDifPtr3 != 0
d9114 1
a9114 1
  LgFrCalendar calendar2(8, SCETime(SCEDate("7/15/94")));
d9133 1
a9133 1
  assert (tsDifPtr2 != 0
d9139 1
a9139 1
  assert (tsDupDifPtr2 != 0
d9160 1
a9160 1
  LgFrCalendar calendarAir2(8, SCETime(SCEDate("7/15/94")));
d9178 1
a9178 1
  assert (tsDifPtrAir2 != 0
d9184 1
a9184 1
  assert (tsDupDifPtrAir2 != 0
d9224 1
a9224 1
  assert (tsDifPtr4 != 0
d9230 1
a9230 1
  assert (tsDupDifPtr4 != 0
d9240 1
a9240 1
  LgFrCalendar calendar5(8, SCETime(SCEDate("7/15/94")));
d9257 1
a9257 1
  assert (tsDifPtr5 != 0
d9263 1
a9263 1
  assert (tsDupDifPtr5 != 0
d9274 1
a9274 1
 LgFrCalendar calendar6(8, SCETime(SCEDate("7/15/94")));
d9291 1
a9291 1
  assert (tsDifPtr6 != 0
d9297 1
a9297 1
  assert (tsDupDifPtr6 != 0
d9316 1
a9316 1
  LgFrCalendar calendar7( 3,SCETime(SCEDate(10,4,1995)),LgFrDay);
d9325 1
a9325 1
  assert (tsDifPtr7 != 0
d9339 4
a9342 4
  assert(assignee.setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(assignee.setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(assignee.setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(assignee.setOfDemands(LGFR_DEFAULT_SET).size() == 2);
d9346 4
a9349 4
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_DEFAULT_SET).size() == 3);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_UNIVERSAL_SET).size() == 4);
  assert(yetAnotherScenarioPtr->setOfParts(LGFR_BUDGET_SET).size() == 1);
  assert(yetAnotherScenarioPtr->setOfDemands(LGFR_DEFAULT_SET).size() == 2);
@


1.18.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d257 1
a257 1
  std::cout << "Executing explosion engine using (" << myExploder->title() << ") scheme  ..." << std::endl;  
d276 1
a276 1
    std::cout << "Writing the Explode echo file  ..." << std::endl;                
d287 1
a287 1
    std::cout << "Writing the (Explode) wit data file ..." << std::endl;                      
d313 1
a313 1
  std::cout << "Writing explosion output results  ..." << std::endl;  
d2596 1
a2596 1
	  std::cerr << "\nJumper Arc Error SYS268E: Interplant operations"
d2598 1
a2598 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
d2773 1
a2773 1
	  std::cerr << "\nJumper Arc Error SYS269E: Interplant operations"
d2775 1
a2775 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
d2846 1
a2846 1
	std::cerr << "\nJumper Arc Error: Interplant operation "
d2850 1
a2850 1
	     << " that is not valid. Contact SCE Support\n" << std::endl;
d2927 1
a2927 1
	  std::cerr << "\nJumper Arc Error SYS269E: Bin operations"
d2929 1
a2929 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
d3104 1
a3104 1
	  std::cerr << "\nJumper Arc Error SYS270E: Bin operations"
d3106 1
a3106 1
	       << " does not have exactly one bom entry. Contact SCE Support\n" << std::endl;
d3177 1
a3177 1
	std::cerr << "\nJumper Arc Error: Bin operation "
d3181 1
a3181 1
	     << " that is not valid. Contact SCE Support\n" << std::endl;
d4473 1
a4473 1
  std::cout << "Writing Pegging information..." << std::endl;    
d4579 1
a4579 1
    idPegFile.open(indpDemandConsPegFileName.c_str());
d4661 1
a4661 1
    evPegFile.open(execVolPegFileName.c_str());
d4745 1
a4745 1
    pvPegFile.open(prodVolPegFileName.c_str());
d4840 1
a4840 1
    idEvPegFile.open(indpExecVolPegFileName.c_str());
d4923 1
a4923 1
    ipPegFile.open(interplantPegFileName.c_str());
d5010 1
a5010 1
    idIpPegFile.open(indpInterplantPegFileName.c_str());
d5109 1
a5109 1
  std::cout << "... collecting Pegging information ..." << std::endl;    
d5173 3
a5175 3
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
d5178 1
a5178 1
      std::cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << std::endl;
d5181 1
a5181 1
      std::cout << std::endl;
d5205 1
a5205 1
      std::cout << "(after) JP's Get" << std::endl;
d5207 1
a5207 1
      std::cout << " ==========================" << std::endl << std::endl;
d5778 2
a5779 2
	  std::cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<std::endl;
d7379 1
a7379 1
     //  std::cout << std::endl << "Updating Demand SupplyVol SUCCESSFULLY!"<< std::endl;
d7407 1
a7407 1
	//        std::cout << std::endl << "Inserting Supply Response SUCCESSFULLY!"<< std::endl;
d7427 1
a7427 1
     //     std::cout << std::endl << "Updating Demand BacklogVol SUCCESSFULLY!"<< std::endl;
d7491 1
a7491 1
	//        std::cout << std::endl << "Inserting IPOrders SUCCESSFULLY!"<< std::endl;
d7662 1
a7662 1
	 //         std::cout << std::endl << "Updating Capacity SupplyVol SUCCESSFULLY!"<< std::endl;
d7671 1
a7671 1
	//        std::cout << std::endl << "Updating Capacity MrpConsVol SUCCESSFULLY!"<< std::endl;
d7690 1
a7690 1
	 //         std::cout << std::endl << "Updating Capacity ReqVol SUCCESSFULLY!"<< std::endl;
d7692 1
a7692 1
	 //  std::cout << std::endl << "Updating Capacity MrpExcessVol SUCCESSFULLY!"<< std::endl;
d7694 1
a7694 1
	 //  std::cout << std::endl << "Updating Capacity MrpRequirements SUCCESSFULLY!"<< std::endl;
d7704 1
a7704 1
	//        std::cout << std::endl << "Updating Capacity ExcessVol SUCCESSFULLY!"<< std::endl;
d7713 1
a7713 1
	//        std::cout << std::endl << "Updating Capacity ScrapVol SUCCESSFULLY!"<< std::endl;
d7722 1
a7722 1
	//        std::cout << std::endl << "Updating Capacity ConsVol SUCCESSFULLY!"<< std::endl;
d9016 2
a9017 2
	  std::cerr << "ABOUT TO DIE!!\n"
	       << "witOperationName=" << witOperationName << "\n\n" <<std::endl;
@


1.18.2.3
log
@New LgFrDatetime class
@
text
@d3733 2
a3734 2
       LgFrDatetime thisDate(theCal.periodStart(t));
       std::string theDate("    " + thisDate.getDateAsString() + "   ");
@


1.17
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d2154 9
a2162 1
  
d2218 41
d2263 1
a2263 1
	  flatFileMgr_.writeCsvFloatVector(outFile, nPeriods, subProdVol, 0, 15);
d4486 1
a4486 1
	  //  write the total Demand due to Focus: FSSReq
d5032 2
d5106 2
a5107 1
					  WitTRUE);
@


1.16
log
@added prodVolPegging for ats and forcePcfBogons (experimental)
@
text
@d4 1
@


1.15
log
@bogon output, and minor changes
@
text
@d4305 2
a4306 1
  
a4307 1
  RWCString demandConsPegFileName = setOfParameters.getString("demandConsPegFileName");
d4312 1
a4313 1
  RWCString interplantPegFileName = setOfParameters.getString("interplantPegFileName");
d4317 8
a4325 2
  RWCString indpExecVolPegFileName = setOfParameters.getString("indpExecVolPegFileName");
  RWCString execVolPegFileName = setOfParameters.getString("execVolPegFileName");
d4347 6
d4615 91
@


1.14
log
@print lowest level non-pcf files
@
text
@d1024 34
d1059 5
d3825 49
a4178 8

   // Lowest Level Non Pcf File: optional
   if (setOfParameters.getBool("printLowestLevelNonPcfFile"))  {
     RWCString lowestLevelNonPcfFileName =
       setOfParameters.getString("lowestLevelNonPcfFileName");
     printLowestLevelNonPcfParts(theWitRun, mpHelper, nPeriods, nParts, partList,
				 lowestLevelNonPcfFileName);
   }
@


1.13
log
@force zero's for excessVol with siteCustomization=eca
@
text
@d959 71
d4091 10
@


1.12
log
@3.11 commit
@
text
@d5745 1
a5745 1
      numRecords += printDbDumpRec(pn, pdf, "excessVol", excessVol.data(), outFile, nPeriods, nonZeroOnly);
@


1.11
log
@file cleaning ... more pegging ... parameters ...
@
text
@d45 1
d390 1
d1029 2
a1030 2
	   newBlog = (demandVol[t] > shipVol[t]) ? demandVol[t] - shipVol[t] : 0.0;
	   shipToDemThisPeriod = (cumShipVol > cumDemVol) ? cumShipVol - cumDemVol : 0.0;
d2120 75
d3859 15
a4021 1
   RWCString engine = setOfParameters.getString("engine");   
d4348 1
a4348 1
		   << mpHelper.pdf(fullWitDemandedPart) << "\","
d5126 3
a5128 1
  int alwaysPrintForECAonly = (siteCustomization == "eca" ? 1 : 0);
@


1.10
log
@moved comments off of ifdef lines
@
text
@a259 1
    // printInterplantPeggingData(theExplodeWitRun, 1);
a4093 1
  float * demandVol;
d4108 3
a4110 1

a4122 1
  
a4152 1
	
d4192 3
a4194 1
  
a4206 1
  
a4249 1

d4257 1
a4258 1
		   << mpHelper.pdf(fullWitDemandedPart) << "\","
a4263 2
	
	
d4272 3
a4274 1

a4275 1

a4285 1
  
d4324 1
a4324 1
	  const LgFrPart & part = pegSched.part(cp);
d4327 1
a4327 5
	  // report ALL Operations for now ... (in future, only report for normal parts)
	  //	  if (! mpHelper.isPartNormal(theWitRun, part.name())) {
	  //	    continue;
	  //	  }

a4329 1

d4336 3
a4338 3
		    << mpHelper.partname(part.name()) << "\",\""
		    << mpHelper.pdf(part.name()) << "\",\""
		    << part.name() << "\"";
a4351 4
#if 0
  if (printIndpInterplantPegFile)  {

    // finish this
d4353 11
a4363 6
    ofstream idPegFile;
  
    // Now open the Independent Demand Peg OUTPUT file
    idPegFile.open(indpDemandConsPegFileName, ios::out);
    if (idPegFile.fail()) {
      RWCString fileErrorString("Independent Demand Pegging Consumption File");
d4366 1
a4366 1
			 << indpDemandConsPegFileName);
d4400 82
a4481 1
	const LgFrSortingPartScheduleFloat & pegSched = demandAppDataPtr->peggingConsVolSched();
d4486 1
a4486 2
	  // get part
	  const LgFrPart & consumedPart = pegSched.part(cp);
d4488 3
a4490 2
	  // only report for normal consumedParts
	  if (! mpHelper.isPartNormal(theWitRun, consumedPart.name())) {
a4492 1

d4494 1
a4494 1
	  // Get this  pegconsVol timeVec
d4497 8
a4504 8
	  //  write the pegConsVol record: PEGConsVol
	  idPegFile << "\""
		   << mpHelper.partname(fullWitDemandedPart) << "\",\""
		   << demandId << "\",\""
		   << mpHelper.pdf(fullWitDemandedPart) << "\","
		   << mpHelper.partname(consumedPart.name()) << "\",\""
		   << mpHelper.pdf(consumedPart.name()) << "\"";
	  flatFileMgr_.writeCsvFloatVector(idPegFile, nPeriods, pegTV.data(), 0, 15);
d4514 1
a4514 1
    idPegFile.close();
a4515 1
#endif
d4517 4
d4522 11
d4534 10
d4545 4
d4550 47
a4616 2
  float * demandVol;

d4990 1
a4990 1
  int i, j, t, p, b, npBops;
a5792 2
  float * execVol;
  float * mrpExecVol;
@


1.9
log
@execVol pegging
@
text
@d1384 2
a1385 1
#if 1 // THE NEW WAY
@


1.8
log
@minor change to fix printSceDebug function
@
text
@d258 1
a258 1
  if (doPegging)
d260 2
d598 2
a599 3
  float * gpdProdVol;
  int t,j;
  int nBom, nSubBoms;
d676 1
a676 1
   int i, j, t, o;
a1109 2
  witBoolean operationExists;

d3293 1
a3293 1
  int i, t;
d3352 1
a3352 1
  int i, t;
a3427 1
   float   rev;
d3515 1
a3515 1
   int i, t;
d4057 5
d4063 5
d4076 13
d4276 175
a4460 4




d4554 9
@


1.7
log
@premiminary coomit for release 3.11
@
text
@d4558 1
a4558 1
     RWCString pn(mpHelper.partname(fullPartName));
@


1.6
log
@added access to BOP explodable flag for user defined operations
also added message for JP
@
text
@d44 1
a44 1

d249 1
d253 9
d3975 1
a3975 1
      printPegConsVolData(theWitRun);
d3992 1
a3992 1
      printPegConsVolData(theWitRun);
d4045 1
a4045 1
LgFrScenarioForSce::printPegConsVolData(WitRun * const theWitRun)
d4052 1
d4055 1
a4055 1

d4058 11
a4148 5
	  // HELP_JP:  I had to change this statement to avoid returning a reference
	  //           instead I get a return by value.   It only seems to matter with 
	  //           MS VC++
	  // const LgFrTimeVecFloat & pegTV = pegSched[cp].timeVecFloat();
	  const LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();
d4150 2
d4232 2
a4233 6
	  // HELP_JP:  I had to change this statement to avoid returning a reference
	  //           instead I get a return by value.   It only seems to matter with 
	  //           MS VC++
	  // const LgFrTimeVecFloat & pegTV = pegSched[cp].timeVecFloat();
	  const LgFrTimeVecFloat pegTV = pegSched[cp].timeVecFloat();

@


1.5
log
@3.10 pegging capability
@
text
@d4127 6
a4132 2
	  const LgFrTimeVecFloat & pegTV = pegSched[cp].timeVecFloat();
	  
d4213 6
a4218 2
	  const LgFrTimeVecFloat & pegTV = pegSched[cp].timeVecFloat();
	  
@


1.4
log
@changes for Release 3.00
@
text
@d17 7
d3962 5
d3978 5
d4032 351
@


1.3
log
@Fixed memory bug in Customer Choice Feature logic
@
text
@d27 1
d3945 1
a3945 1
  if (getEngine() == "heuristic" || getEngine() == "rollover" ) {
d3957 10
d3971 1
a3971 1
  if (getEngine() == "optimization" ) {
@


1.2
log
@fixed a bug with totalDemandReport.  It wasn't looking at additional demand
from independent, or, was not considering the negative demand adjustments.
I duplicated the code logic from section where partDBdump is printed for
mrpConsVol.
@
text
@d1424 2
d5886 1
d5897 5
@


1.2.2.1
log
@Customer Choice bug fix and memory leak patch.
@
text
@a1423 2
	portableFree(sfpExecVol);
	portableFree(sfpSupplyVol);
a5883 1
    LgFrSceCCOperationAppData  * opCCAppDataPtr;
a5893 5
      }
    else if (multiPlantHelper_.isOperationSpecialCustChoiceFeature( wr, operationList[o], dPart, dPdf, sPart, sPdf )) 
      {
	witGetOperationAppData( wr, operationList[o], (void **) & opCCAppDataPtr );
	delete opCCAppDataPtr ;
@


1.1
log
@Initial revision
@
text
@d132 11
d145 1
d149 46
d204 1
a204 1
       }
d208 2
@


1.1.1.1
log
@Import sce
@
text
@@


1.1.1.1.2.1
log
@manual merge of bug fixes
@
text
@a131 11
   int nDemands;
   char ** dList;


#ifdef ENABLE_NEGATIVE_DEMANDS
   LgFrTimeVecFloat negDemVol;
#endif




a133 1
     // Compute :=======> mrpConsVol
a136 46

       // Now add in direct demand vol
       // get demands on the part.  These are needed for direct demands
       witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);

       for (int j=0; j<nDemands; j++) {
	 float * indepDemandVol;
	 witGetDemandDemandVol(theWitRun, partList[i], dList[j], &indepDemandVol);
	 for (int tt=0; tt<nPeriods; tt++) {
	   mrpConsVol[tt] += indepDemandVol[tt];
	 }
	 portableFree(indepDemandVol);
	 portableFree(dList[j]);
       }
       portableFree(dList);

#ifdef ENABLE_NEGATIVE_DEMANDS
       // Compute :=======> negDemVol
       int doesPartHaveNegativeDemands = mpHelper.doesPartHaveNegativeDemands(theWitRun, partList[i]);
       if (doesPartHaveNegativeDemands) {
	 negDemVol = mpHelper.negDemVol(theWitRun, partList[i]);

	 LgFrTimeVecFloat witMrpConsVol((size_t) nPeriods, mrpConsVol);
	 LgFrTimeVecFloat negDemMrpConsVol((size_t) nPeriods, 0.0);

	 float rolledNegDemVol = 0.0;
	 for (int tt=0; tt<nPeriods; tt++) {
	   rolledNegDemVol += negDemVol[tt];
	   if (mrpConsVol[tt] > rolledNegDemVol) {
	     mrpConsVol[tt] -= rolledNegDemVol;
	     negDemMrpConsVol[tt] += rolledNegDemVol;
	     rolledNegDemVol = 0.0;
	   }
	   else {
	     // Note: if mrpConsVol < 0 then there are negative usage rates
	     // these can realy screw up our calculation
	     if (mrpConsVol[tt] > 0) {
	       rolledNegDemVol -= mrpConsVol[tt];
	       negDemMrpConsVol[tt] += mrpConsVol[tt];
	       mrpConsVol[tt] = 0.0;
	     }
	   }
	 }
       }
#endif

d146 1
a146 1
     }
a149 2
   
   
@


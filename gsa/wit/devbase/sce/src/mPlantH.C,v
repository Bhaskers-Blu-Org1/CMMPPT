head	1.23;
access;
symbols
	sce_5_01_20080919:1.15
	latest_sce_4_20_20060523:1.12.0.4
	sce_4_20_20060523:1.12
	latest_sce4_20_OSL:1.12.0.2
	sce_4_20_OSL:1.12
	sce_4_20_20051222:1.12
	sce_4_10_30050426:1.9
	sce_4_05_20040511:1.9
	sce_4_00_20040201:1.8
	nextGenBranch:1.6.0.2
	nextGenRoot:1.6
	sce_3_30_20030627:1.6
	EndRw-branch:1.5.0.2
	Root-of-EndRw:1.5
	EndWitRw-branch:1.4.0.4
	Root-of-EndWitRw:1.4
	RwToStl-branch:1.4.0.2
	Root-of-RwToStl:1.4
	latest_sce_3_10_20010924:1.3.0.4
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.2
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2011.03.15.15.37.19;	author ervolina;	state Exp;
branches;
next	1.22;
deltatype	text;
permissions	644;
commitid	256c4d7f865a0a65;
kopt	kv;
filename	@mPlantH.C@;

1.22
date	2010.12.15.23.53.23;	author ervolina;	state Exp;
branches;
next	1.21;
deltatype	text;

1.21
date	2010.04.07.16.18.27;	author ervolina;	state Exp;
branches;
next	1.20;
deltatype	text;

1.20
date	2010.03.16.17.56.22;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;

1.19
date	2010.03.13.18.53.05;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2010.02.04.15.58.23;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;

1.17
date	2009.12.08.13.58.35;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2009.09.09.15.41.57;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2008.04.24.14.04.42;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2008.03.20.14.52.48;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2006.06.26.15.23.31;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2005.11.09.18.32.47;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2005.11.02.18.40.01;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2005.08.10.22.44.53;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2004.05.07.03.10.00;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2004.01.29.05.08.05;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2004.01.23.02.59.16;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2003.01.15.19.36.56;	author rwToStl;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2002.11.26.14.25.31;	author fasano;	state Exp;
branches
	1.5.2.1;
next	1.4;
deltatype	text;

1.4
date	2002.08.08.17.37.43;	author ervolina;	state Exp;
branches;
next	1.3;
deltatype	text;

1.3
date	2001.06.01.16.52.06;	author ervolina;	state Exp;
branches;
next	1.2;
deltatype	text;

1.2
date	2001.03.12.15.07.29;	author ervolina;	state Exp;
branches;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.52;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.52;	author wit;	state Exp;
branches
	1.1.1.1.4.1;
next	;
deltatype	text;

1.1.1.1.4.1
date	2001.03.12.16.36.17;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.5.2.1
date	2003.01.08.17.43.16;	author rwToStl;	state Exp;
branches;
next	1.5.2.2;
deltatype	text;

1.5.2.2
date	2003.01.09.13.14.32;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.23
log
@temp fix to build without Variable_periods
@
text
@
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
// file: mPlantH.C
// author: tom

#include <stdlib.h>
#include <assert.h>
#include <mcl/src/mcl.h>
#include <scenario/src/machdep.h>
#include <sce/src/sceDefin.h>
#include <sce/src/mPlantH.h>
#include <wit/src/wit.h>
#include <sce/src/appData.h>
#include <sce/src/dmApData.h>
#if 1  
// #ifdef VARIABLE_PERIODS
#include <scenario/src/calendar.h>
#endif

#define MULTIPLANTHELPER_FLT_EPS  0.00001

#ifndef ELIMINATE_OLD_MAIN



// plannerPartName/Geo ---> mfgPart/Pdf  source 
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
// and it returns a PDF_Part
// You also feed it a start period, and it figures the latest period for 
// which this pdf is sourced for this demand
std::string
LgFrMultiPlantHelper::demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
          float     & offset,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
{
    
    std::string mfgTopLevelBuild;
    int bomStart = 0;
    int bomEnd = 0;

// create a geoPlannerPart name
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
    

    // and test to see if it exists (it should)
    int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
				   dataLine, lineNo, messageLogic);

    if (! result)
	return mfgTopLevelBuild;

    // loop through the BOM entries for this special demand part and find
    // the bom which has effectivity within the period "start".  Return the
    // pdf of this mfgTopLevelBuild
    // We also return the time-offset for this demand source
    int nBom;
    witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);

    char * child;
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      // if the child is not a normal part, then we can skip it.  (GPD's only 
      // source to normal parts)
      // first check to see if the child is a specialDemand UpperBound part, OR
      // a specialBb category part, if so, then skip it.
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      std::string pp;
      std::string g;
      std::string bb;

      if (! this->isPartNormal(theWitRun, child)) {
	witFree(child);
	continue;
      }
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
      if (start >= bomStart && start <= bomEnd)   {
        mfgTopLevelBuild = child;
        witGetBomEntryUsageTime(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
      }
      witFree(child);
      if (! mfgTopLevelBuild.empty())
        break;
    }

    // What to do if you can't source it?????
    if (mfgTopLevelBuild.empty())   {
      (*sceErrFacility_)("MissingPDFSource",MclArgList() << plannerPartName << geo << start 
			 << fileName << (int)lineNo << dataLine);
    }



    // set late as the bomEnd
    late = bomEnd;
    return mfgTopLevelBuild;
}


// =============================
// =============================
//           SCE 6.1
// =============================
// =============================
// VARIABLE_PERIODS ...should erase all others ...note that the transit time offset returned is already adjusted for variable periods
// plannerPartName/Geo ---> mfgPart/Pdf  source 
// THIS IS A BETTER ONE. !!!!!!
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
// and it returns a PDF_Part
// You also feed it a start period, and it figures the latest period for 
// which this pdf is sourced for this demand
std::string
LgFrMultiPlantHelper::demandSource(
				   WitRun * const    theWitRun, 
				   const std::string & plannerPartName,
				   const std::string & geo,
				   const int         start,
				   int               & late,
				   LgFrTimeVecFloat  & offsetTV,
				   const std::string & fileName, 
				   const std::string & dataLine, 
				   const long        lineNo, 
				   const int         messageLogic)
{
  std::string mfgTopLevelBuild;
  int bomStart = 0;
  int bomEnd = 0;
  
  // create a geoPlannerPart name
  std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
  
  
  // and test to see if it exists (it should)
  int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, dataLine, lineNo, messageLogic);
  
  if (! result)
    return mfgTopLevelBuild;
  
  // loop through the BOM entries for this special demand part and find
  // the bom which has effectivity within the period "start".  Return the
  // pdf of this mfgTopLevelBuild
  // We also return the time-offset for this demand source
  int nBom;
  witGetOperationNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
  
  char * child;
  int j = 0; 
  for (j=0; j<nBom; j++)  {
    // if the child is not a normal part, then we can skip it.  (GPD's only 
    // source to normal parts)
    // first check to see if the child is a specialDemand UpperBound part, OR
    // a specialBb category part, if so, then skip it.
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
    std::string pp;
    std::string g;
    std::string bb;
    
    if (! this->isPartNormal(theWitRun, child)) {
      witFree(child);
      continue;
    }
    witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
    witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
    if (start >= bomStart && start <= bomEnd)   {
      mfgTopLevelBuild = child;
      float * offset;
      int ttt=0;
      witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
      for (ttt=start; ttt<=late; ttt++) 
	offsetTV[ttt] = offset[ttt];
      witFree(offset);
    }
    witFree(child);
    if (! mfgTopLevelBuild.empty())
      break;
  }
  
  // What to do if you can't source it?????
  if (mfgTopLevelBuild.empty())   {
    (*sceErrFacility_)("MissingPDFSource",MclArgList() << plannerPartName << geo << start << fileName << (int)lineNo << dataLine);
  }
  // set late as the bomEnd
  late = bomEnd;
  return mfgTopLevelBuild;
}


// feed it a GPD planner part and geo (with D2o), and it returns the topMfgPart of the machine, and 
//    populates the sourceLocPdf reference
std::string
LgFrMultiPlantHelper::mfgTopPartForGpd(WitRun * const      theWitRun, 
				       const std::string & plannerPartName,
				       const std::string & d2oGeo,
				       std::string & sourceLocPdf)
{

  sourceLocPdf = this->sourceLoc(d2oGeo);
  return this->pdfPartname(plannerPartName, sourceLocPdf);
}



// multi_attribute_demand  ... DEMAND2ORDER function
// append the requestDate onto the end of the dmeandName string 
std::string
LgFrMultiPlantHelper::expandDemandKeyforD2O(const std::string &  geoPreD2O, const std::string & requestDate)
const
{
  // start with the original demand key
  std::string expandedDemandName(geoPreD2O);
  expandedDemandName = expandedDemandName + multiAttributeDemandSeparator_ + requestDate;
 return expandedDemandName;
}


// SCE 6.1
// multi_attribute_demand  ... DEMAND2ORDER function
// append the requestDate onto the end of the dmeandName string 
std::string
LgFrMultiPlantHelper::expandDemandKeyforD2O(const std::string &  geoPreD2O, 
					    const std::string & requestDate,
					    const std::string & sourceLoc)
const
{
  // start with the original demand key
  std::string expandedDemandName(geoPreD2O);
  expandedDemandName = 
    sourceLoc + multiAttributeDemandSeparator_ + 
    expandedDemandName + multiAttributeDemandSeparator_ + 
    requestDate;
 return expandedDemandName;
}


std::string
LgFrMultiPlantHelper::sourceLoc(const std::string &  d2oGeo)
const
{
  SCETokenizer next(d2oGeo);

  return next(multiAttributeDemandSeparator_.c_str());
}


// multi_attribute_demand
std::string
LgFrMultiPlantHelper::compressedDemandName(const std::string * demandAttributes[])
const
{
  std::string demandName("");
  int t = 0;
  for (t=0; t<numDemandAttributes_-1; t++)  {
   
    demandName = demandName + multiAttributeDemandSeparator_;
  }
  demandName = demandName + (*demandAttributes)[numDemandAttributes_-1];
 return demandName;
}


// multi_attribute_demand
void
LgFrMultiPlantHelper::compressedDemandName(std::string & demandName, 
					   const std::string & customerLoc,
					   const std::string & demandClass,
					   const std::string & demandLevel,
					   const std::string & partClass)
{
  demandName = 
    customerLoc + multiAttributeDemandSeparator_
    + demandClass + multiAttributeDemandSeparator_
    + demandLevel + multiAttributeDemandSeparator_
    + partClass;
}

// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::uncompressedDemandNames(
	const std::string & compressedDemandName,
	std::string & customerLoc,
	std::string & demandClass,
	std::string & demandLevel,
	std::string & partClass)
{
  SCETokenizer next(compressedDemandName);

  // customerLoc
  customerLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (customerLoc.empty())
    return 0;

  // demandClass
  demandClass =  next(multiAttributeDemandSeparator_.c_str());
  if (demandClass.empty())
    return 0;

  // demandLevel
  demandLevel =  next(multiAttributeDemandSeparator_.c_str());
  if (demandLevel.empty())
    return 0;

  // partClass
  partClass =  next(multiAttributeDemandSeparator_.c_str());
  if (partClass.empty())
    return 0;


  return 1;
}



// SCE 6.1
// returns a String Suitable for printing as leadingString
// note that it does not expect part and pdf to be in the
// compressed name
// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::populateLeadingString(
					    const std::string & partname,
					    const std::string & pdf,
					    const std::string & compressedDemandName,
					    std::string & leadingString)
{
  if (useMultiAttributeDemand_) {
    SCETokenizer next(compressedDemandName);
    
    leadingString = "\"" 
      + partname + "\",\""
      + pdf + "\",";
    
    int a;
    for (a=0; a<numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
    }
    return 1;
  }

  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + pdf + "\",\""       + compressedDemandName + "\"";
  }
}




// SCE 6.1
// returns a String Suitable for printing as leadingString for INDP Demand Records
// note that it does not expect part and pdf to be in the compressed name
// returns 0 if unsuccessful, 1 if successful 
// Note: if "useDemand2OrderINDP"=TRUE then we add the requestDate from the demandKey
//        else it is the responsibility of the calling function to append the right request (and commit) date
int
LgFrMultiPlantHelper::populateLeadingStringINDP(
					       const std::string & partname,
					       const std::string & pdf,
					       const std::string & demandName,
					       std::string & leadingString)
{
  if (useMultiAttributeDemand_) {
    SCETokenizer next(demandName);
    
    leadingString = "\"" 
      + partname + "\",\""
      + pdf + "\",";
    
    int a;
    // !!! Demand to Order has extra key so we go numDemandAttributes_+1
    for (a=0; a<numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
    }
    if (useDemand2OrderINDP_)  {
      // pull the request date off the token and write it without quotes
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      leadingString += "," + nextToken;
    }
    return 1;

  }

  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + pdf + "\",\"" 
      + demandName + "\"";
  }
}
  




// returns a String Suitable for printing as leadingString
// note that it does not expect part and pdf to be in the
// compressed name
// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::populateLeadingStringGPD(
					       const std::string & partname,
					       const std::string & geo,
					       std::string & leadingString)
{
  if (useMultiAttributeDemand_) {
    SCETokenizer next(geo);
    
    leadingString = "\"" 
      + partname + "\",";
    
    int a;
    // !!! Demand to Order has extra key so we go numDemandAttributes_+1
    for (a=0; a<=numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
    }
    // pull the request date off the token and write it without quotes
    std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
    if (nextToken.empty()) {
      return 0;
    }
    leadingString += "," + nextToken;
    
    return 1;
  }

  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + geo + "\"";
  }
}
  
  

// multi_attribute_demand
void
LgFrMultiPlantHelper::compressedDemandNameWitPdf(std::string & demandName, 
						 const std::string & sourceLoc,
						 const std::string & customerLoc,
						 const std::string & demandClass,
						 const std::string & demandLevel,
						 const std::string & partClass)
{
  demandName = 
    sourceLoc + multiAttributeDemandSeparator_
    + customerLoc + multiAttributeDemandSeparator_
    + demandClass + multiAttributeDemandSeparator_
    + demandLevel + multiAttributeDemandSeparator_
    + partClass;
}

// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::uncompressedDemandNamesWithPdf(const std::string & compressedDemandName,
						     std::string & sourceLoc,
						     std::string & customerLoc,
						     std::string & demandClass,
						     std::string & demandLevel,
						     std::string & partClass)
{
  SCETokenizer next(compressedDemandName);

  // sourceLoc
  sourceLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (sourceLoc.empty())
    return 0;

  // customerLoc
  customerLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (customerLoc.empty())
    return 0;

  // demandClass
  demandClass =  next(multiAttributeDemandSeparator_.c_str());
  if (demandClass.empty())
    return 0;

  // demandLevel
  demandLevel =  next(multiAttributeDemandSeparator_.c_str());
  if (demandLevel.empty())
    return 0;

  // partClass
  partClass =  next(multiAttributeDemandSeparator_.c_str());
  if (partClass.empty())
    return 0;


  return 1;
}


#if 1
// #ifdef VARIABLE_PERIODS
// set the CycleTimeDays exactly as input from Cycle Time File
void
LgFrMultiPlantHelper::setCycleTimeDays(
				       WitRun * const theWitRun,
				       const std::string & fullWitPartname,
				       LgFrTimeVecFloat &  cycleTimeDays)
{
  LgFrScePartAppData * partAppDataPtr;
  witGetPartAppData (theWitRun, fullWitPartname.c_str(), (void **) &partAppDataPtr );
  // if no app data exists, then create one.
  if (partAppDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    partAppDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
  }
  partAppDataPtr->cycleTimeDays(cycleTimeDays);
  witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) partAppDataPtr);
} 

// get the CycleTimeDays (exactly as input from Cycle Time File)
LgFrTimeVecFloat
LgFrMultiPlantHelper::getCycleTimeDays(
				       WitRun * const theWitRun,
				       const std::string & fullWitPartname)
{
  LgFrScePartAppData * partAppDataPtr;
  witGetPartAppData (theWitRun, fullWitPartname.c_str(), (void **)  &partAppDataPtr );
  // if no app data exists, then return 0 vec
  if (partAppDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    LgFrTimeVecFloat zeroVec((size_t) nPeriods, 0.0);
    return zeroVec;
  }
  return partAppDataPtr->cycleTimeDays();
} 


// set the calculated CycleTime Periods based on Variable Period Logic
// this does NOT set it in WIT ... only in partAppData
void
LgFrMultiPlantHelper::setCycleTime(
				       WitRun * const theWitRun,
				       const std::string & fullWitPartname,
				       LgFrTimeVecFloat &  cycleTime)
{
  LgFrScePartAppData * partAppDataPtr;
  witGetPartAppData (theWitRun, fullWitPartname.c_str(), (void **) &partAppDataPtr );
  // if no app data exists, then create one.
  if (partAppDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    partAppDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
  }
  partAppDataPtr->cycleTime(cycleTime);
  witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) partAppDataPtr);
} 

// get the CycleTime from App Data
LgFrTimeVecFloat
LgFrMultiPlantHelper::getCycleTime(
				   WitRun * const theWitRun,
				   const std::string & fullWitPartname)
{
  LgFrScePartAppData * partAppDataPtr;
  witGetPartAppData (theWitRun, fullWitPartname.c_str(), (void **)  &partAppDataPtr );
  // if no app data exists, then return 0 vec
  if (partAppDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    LgFrTimeVecFloat zeroVec((size_t) nPeriods, 0.0);
    return zeroVec;
  }
  return partAppDataPtr->cycleTime();
} 


float
LgFrMultiPlantHelper::calculateVariableOffset(float cycleTimeDaysToAllocate, 
					      int t, 
					      LgFrTimeVecFloat & workingDays,
					      int nPeriods)
{
  float computedCycleTime = 0.0;
  
  
  // two seperate loops going either forward or back in time depending on whether 
  // offset is positive or negative.   Whoa, I think this is wrong.  the positive offset
  // should go from period tt=t down to 0, not, tt=t up to nPeriods.   Lkewise for negatives
  // it should go from tt=t to nperiods-1.  also need to put in logic to truncOffsetToEol
  
  // CASE 1: Zero Offset
  if ((0.0001 < cycleTimeDaysToAllocate) && (cycleTimeDaysToAllocate < 0.0001)) {
    return 0.0f;
  }



  // CASE 2: Positive Offset
  if (cycleTimeDaysToAllocate >= 0.0001) {
    int tt =0;
    for (tt=t; tt>=0; tt--)  {
      if (cycleTimeDaysToAllocate <= workingDays[tt]) {
	// float percentThreshRoll = .20;
	// FINISH_ME: we can adjust fractional to integer a this point based on rules
	computedCycleTime += cycleTimeDaysToAllocate/workingDays[tt];
	return computedCycleTime;
      }
      else   {
	computedCycleTime += 1.0;
	cycleTimeDaysToAllocate -= workingDays[tt];
      }
    }
    
    // if you get to the beginning of horizon and still haven't worked off the cycleTimeDaysToAllocate, 
    // then we use the first period with workingDays > 0 as the assumed workingDays for past periods.
    if (cycleTimeDaysToAllocate > 0.0)  {
      // didn't work it all off.  Can't build in this period
      // lets go back to last period with positive working days and use that as basis for future period lengths
      for (tt=0; tt < nPeriods; tt++)  {
	if (workingDays[tt] > 0) {
	  computedCycleTime += cycleTimeDaysToAllocate/workingDays[tt]; 
	  return computedCycleTime;
	}
      }
      return nPeriods+1;
    }
  }

  // CASE 3: Negative Offset
  else  {
    int tt =0;
    for (tt=t; tt<nPeriods; tt++)  {
      if (-cycleTimeDaysToAllocate <= workingDays[tt]) {
	// float percentThreshRoll = .20;
	// FINISH_ME: we can adjust fractional to integer a this point based on rules
	computedCycleTime += cycleTimeDaysToAllocate/workingDays[tt];
	if (truncOffsetToEol_) 
	  if (t - computedCycleTime > nPeriods - 1) {
	    computedCycleTime = t - (nPeriods - 1);
	  }
	
	return computedCycleTime;
      }
      else   {
	computedCycleTime -= 1.0;
	cycleTimeDaysToAllocate += workingDays[tt];
      }
    }
    
    // if you get to beginning of horizon and still ahven't worked off the days, then we need to 
    // estimate this last offset.   
    if (cycleTimeDaysToAllocate < 0.0)  {
      for (tt=nPeriods-1; tt>=0; tt--)  {
	if (workingDays[tt] > 0) {
	  computedCycleTime += cycleTimeDaysToAllocate/workingDays[tt]; 
	  if (truncOffsetToEol_) 
	    if (t - computedCycleTime > nPeriods - 1) {
	      computedCycleTime = t - (nPeriods - 1);
	    }
	  return computedCycleTime;
	}
      }
      return -nPeriods;
    }
  }
  
}



float
LgFrMultiPlantHelper::calculateVariableOffset(float cycleTimeDaysToAllocate, 
					      int t, 
					      const LgFrCalendar & theCal,
					      int nPeriods)
{
  int tt;

  LgFrTimeVecFloat workingDays(nPeriods, 0.0);
  for (tt=0; tt < nPeriods; tt++)  {
    workingDays[tt] = theCal.workUnits(tt);
  }

  return this->calculateVariableOffset(cycleTimeDaysToAllocate,  t, workingDays, nPeriods);
}
#endif









// =============================
// =============================
//  END of  SCE 6.1
// =============================
// =============================





// default constructor:
LgFrMultiPlantHelper::LgFrMultiPlantHelper()
: pdfSeparator_("? \t\n"),
  defaultPdf_("WW"),
  useMultiAttributeDemand_(0),
  numDemandAttributes_(4),
  multiAttributeDemandSeparator_("% \t\n"),
  useDemand2OrderINDP_(0),
  truncOffsetToEol_(0),
  sceErrFacility_(0)
{
    // all the work is done in initializer
}


// fairly general constructor:
LgFrMultiPlantHelper::LgFrMultiPlantHelper(
	     const std::string & pdfSeparator,
	     const std::string & defaultPdf,
	     const bool useMultiAttributeDemand,
	     const int numDemandAttributes,
	     const std::string & multiAttributeDemandSeparator,
	     const bool useDemand2OrderINDP)
: pdfSeparator_(pdfSeparator),
  defaultPdf_(defaultPdf),
  useMultiAttributeDemand_(useMultiAttributeDemand),
  numDemandAttributes_(numDemandAttributes),
  multiAttributeDemandSeparator_(multiAttributeDemandSeparator),
  useDemand2OrderINDP_(useDemand2OrderINDP),
  truncOffsetToEol_(0),
  sceErrFacility_(0)
{
  // all the work is done in initializer
}

// necessary methods for sharing scenario's error facility
void
LgFrMultiPlantHelper::setErrFacility(MclFacility * existingFacility)
{
  sceErrFacility_ = existingFacility;
}

MclFacility*
LgFrMultiPlantHelper::getErrFacility()
{
  return sceErrFacility_;
}


#ifdef ENABLE_NEGATIVE_DEMANDS
// Return 1 if part has any negative demands
int
LgFrMultiPlantHelper::doesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;

  return appDataPtr->doesPartHaveNegativeDemands();
}

// Set the Part's doesPartHaveNegativeDemands
void
LgFrMultiPlantHelper::setDoesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    int doesPartHaveNegativeDemands)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  // if hte part does not have an appData, then create one
  if (appDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
    witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) appDataPtr);
  }      
  appDataPtr->doesPartHaveNegativeDemands(doesPartHaveNegativeDemands);
}

LgFrTimeVecFloat
LgFrMultiPlantHelper::negDemVol(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  int nPeriods;
  int nDemands;
  char ** dList;
  
  float * witDemandVol;

  witGetNPeriods(theWitRun, &nPeriods);

  LgFrTimeVecFloat negDemVol((size_t) nPeriods, 0.0);
  LgFrSceDemandAppData * appDataPtr = 0;
  
  if (this->doesPartHaveNegativeDemands(theWitRun, fullWitPartname)) {
    int didWeFindAnAppData = 0;
    witGetPartDemands(theWitRun, fullWitPartname.c_str(), &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      witGetDemandDemandVol(theWitRun, fullWitPartname.c_str(), dList[j], &witDemandVol);
      witGetDemandAppData(theWitRun, fullWitPartname.c_str(), dList[j], (void **) &appDataPtr);
      if (appDataPtr != 0) {
	didWeFindAnAppData = 1;
	LgFrTimeVecFloat appDataDemandVol(appDataPtr->demandVol());
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
	  negDemVol[t] += witDemandVol[t] - appDataDemandVol[t];
	}
      }
      witFree(witDemandVol);
      witFree(dList[j]);
    }
    witFree(dList);
    if (! didWeFindAnAppData) {
      std::cerr << "SCE9955F PROGRAMMER ERROR: part with negative demands does not\n"
	   << "have a demand with non-0 appData\n"
	   << "Please report this error to SCE Development\n"
	   << "SCE Terminates with return code: 8\n\n";
      exit(8);
    }
  }

  return negDemVol;
}

#endif

// Return 1 if a part is marked as a PCF part, 0 if not
int
LgFrMultiPlantHelper::isPartPcf(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{


  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (! exists)
    return 0;


  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;

  return appDataPtr->isPartPcf();
}


#ifdef MARK_BOGONS
// Return 1 if a part is a PCF bogon
int
LgFrMultiPlantHelper::isPartBogon(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;

  return appDataPtr->isPartBogon();
}
#endif



// Return the witPartIndex
// returns -1 if the part is bad, or, index is not set
int
LgFrMultiPlantHelper::witPartIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return -1;

  return appDataPtr->index();
}


// Return the witOperationIndex
// returns -1 if the operation is bad, or, index is not set
int
LgFrMultiPlantHelper::witOperationIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName)
{
  LgFrSceCCOperationAppData * appDataPtr;
  witGetOperationAppData(theWitRun,  fullWitOperationName.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return -1;

  return appDataPtr->index();
}





// (Re)set the partAppData indices to synch with a witGetParts()
// It sets them for all parts and re-sets if an appData already exists
void
LgFrMultiPlantHelper::setAllWitPartIndices(
    WitRun * const theWitRun)
{
  int nParts;
  char ** partList;

  witGetParts (theWitRun, &nParts, &partList );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    LgFrScePartAppData * partAppDataPtr;
    witGetPartAppData (theWitRun, partList[i], (void **) &partAppDataPtr );
    // if no app data exists, then create one.
    if (partAppDataPtr == 0) {
      int nPeriods;
      witGetNPeriods(theWitRun, &nPeriods);
      partAppDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      witSetPartAppData(theWitRun, partList[i], (void *) partAppDataPtr);
    }
    partAppDataPtr->index(i);      
  } 

  for (i=0; i<nParts; i++)
    witFree (partList[i]);
  witFree (partList);
}






// set the Customer Choice Operation AppData indices to synch with a witGetOperation()
// It sets them only for Special Customer Choice feature parts
void
LgFrMultiPlantHelper::setCCOperationIndices(
    WitRun * const theWitRun)
{
  int nOperations;
  char ** opList;

  std::string geo;
  std::string machine;
  std::string pdf;
  std::string featurePart;



  witGetOperations (theWitRun, &nOperations, &opList );
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
    if (! this->isOperationSpecialCustChoiceFeature(theWitRun, opList[o], geo, machine,pdf,featurePart)) {
      witFree(opList[o]);
      continue;
    }
    
    LgFrSceCCOperationAppData * ccOpAppDataPtr;
    witGetOperationAppData (theWitRun, opList[o], (void **) &ccOpAppDataPtr );
    // if no app data exists, then create one.
    if (ccOpAppDataPtr == 0) {
      ccOpAppDataPtr = new LgFrSceCCOperationAppData(o);
      witSetOperationAppData(theWitRun, opList[o], (void *) ccOpAppDataPtr);
    }
    ccOpAppDataPtr->index(o); 
    witFree(opList[o]);     
  } 

  witFree (opList);
}



  // returns the feature ratio of a customer choice feature.
  // Note that the partname MUST be a specialCustChoicePartName
LgFrTimeVecFloat 
LgFrMultiPlantHelper::custChoiceFeatureRatio(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature)
{
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));

  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);

  witFree(gpdWitOperationName);
  return bomAppDataPtr->featRatio();
}

// GET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
LgFrTimeVecFloat 
LgFrMultiPlantHelper::custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature)
{
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));

  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);

  witFree(gpdWitOperationName);
  return bomAppDataPtr->dummySupplyVolForMrpAdjustment();
}


// SET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
void 
LgFrMultiPlantHelper::custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature,
    LgFrTimeVecFloat & dummySupplyVolForMrpAdjustment)
{
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));

  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);

  witFree(gpdWitOperationName);
  bomAppDataPtr->dummySupplyVolForMrpAdjustment(dummySupplyVolForMrpAdjustment);
}



// returns convenient way to get the nInterplant Ops 
int
LgFrMultiPlantHelper::nInterplantOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nInterplantOps();
}  

// returns convenient way to get the nAlternatePart Ops 
int
LgFrMultiPlantHelper::nAlternatePartOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nAlternatePartOps();
}  





// returns convenient way to get the nUserDefinedOps
int
LgFrMultiPlantHelper::nUserDefinedOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nUserDefinedOps();
}  

  // returns convenient way to get the nAggregationOps
int
LgFrMultiPlantHelper::nAggregationOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nAggregationOps();
}  








std::string
LgFrMultiPlantHelper::pdfPartname(
				  const std::string & part,
				  const std::string & pdf)
const
{
    return pdf + pdfSeparator_ + this->partname(part);
}

std::string
LgFrMultiPlantHelper::pdfOperationName(
    const std::string & operation,
    const std::string & pdf)
const
{
    return pdf + pdfSeparator_ + this->operationName(operation);
}

// Return a demand_Geo name, given the demand, geo
std::string
LgFrMultiPlantHelper::geoPlannerDemandPartName(
    const std::string & plannerPart,
    const std::string & geo)
const
{
    return 
	  geo 
	+ pdfSeparator_ 
	+ plannerPart 
	+ pdfSeparator_ 
	+ "specialGeoPlannerDemand";
}

// Return a demand_GeoUB name, given the demand, geo
std::string
LgFrMultiPlantHelper::geoPlannerDemandUbPartName(
    const std::string & plannerPart,
    const std::string & geo)
const
{
    return 
	  geo 
	+ pdfSeparator_ 
	+ plannerPart 
	+ pdfSeparator_ 
	+ "specialGeoPlannerDemandUB";
}


// Return a interplant operation name, given the parent, parentPdf, 
// child, childPdf
std::string
LgFrMultiPlantHelper::interPlantOperationName(
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
const
{
    return 
	parentPdf     +
	pdfSeparator_ +	
	parentMfgPart +
	pdfSeparator_ +
	childPdf      +
	pdfSeparator_ +
	childMfgPart  + 
	pdfSeparator_ +
	"specialInterPlantOperation";
}


// Return a alternate operation name, given the parent, parentPdf, 
// child, childPdf
std::string
LgFrMultiPlantHelper::alternatePartOperationName(
    const std::string & primePart,
    const std::string & primePdf,
    const std::string & altPart,
    const std::string & altPdf)
const
{
    return 
	primePdf     +
	pdfSeparator_ +	
	primePart +
	pdfSeparator_ +
	altPdf      +
        pdfSeparator_ +
        altPart  + 
        pdfSeparator_ +
	"specialAlternatePartOperation";
}





#if 0
// this is obsolete, replaced by operationForCapacityGeneration
  // Return an operation name for the purpose of a modelling trick in Smart Exploder
std::string
LgFrMultiPlantHelper::operationForSmartExploderCapacity(
    const std::string & theFullCapacityName)
const
{
    return 
	theFullCapacityName  +
	pdfSeparator_ +	
	"specialSmartExplodeCapacityOperation";
}
#endif

  // Return an operation name for generating capacity
std::string
LgFrMultiPlantHelper::operationForCapacityGeneration(
    const std::string & theFullCapacityName)
const
{
    return 
	theFullCapacityName  +
	pdfSeparator_ +	
	"specialOperationForCapacityGeneration";
}



// Return a aggregation operation name, given the realPart, realPartPdf
// aggPart, and aggPdf
std::string
LgFrMultiPlantHelper::aggregationOperationName(
    const std::string & realPart,
    const std::string & realPartPdf,
    const std::string & aggPart,
    const std::string & aggPdf)
const
{
    return 
	realPartPdf   +
	pdfSeparator_ +	
	realPart      +
	pdfSeparator_ +
	aggPdf        +
	pdfSeparator_ +
	aggPart       + 
	pdfSeparator_ +
	"specialAggregationOperation";
}


// Return a phantom part name, given the part and pdf
std::string
LgFrMultiPlantHelper::phantomPartName(
    const std::string & thePart,
    const std::string & pdf)
const
{
    return 
	pdf           +
	pdfSeparator_ +	
	thePart       +
	"specialPhantomPart";
}

// Return a global nullSubstitute  part name, given a pdf
std::string
LgFrMultiPlantHelper::globalNullSubstitute(
    const std::string & pdf)
const
{
    return 
	pdf           +
	pdfSeparator_ +
      	"nullSub"     +
	pdfSeparator_ +	      
	"specialGlobalNullSubstitute";
}

// Return a globalMaxWithoutNullSubstitute part name, given a pdf.
//
// When the maxWithoutRatio = 0.0 (so we have a "mandatory feature")
// the substitute on the gpd part to feature part arc is a global
// maxWithoutNullSubstitute, whose supply is zero. The reason for 
// employing a "global" instead a distinct null sub in this case
// is to reduce the problem size (many parts in the ECA run have
// the maxWithoutRatio equal to a vector of all zeros).

std::string
LgFrMultiPlantHelper::globalMaxWithoutNullSubstitute(
    const std::string & pdf)
const
{
    return 
	pdf           +
	pdfSeparator_ +
      	"nullSub"     +
	pdfSeparator_ +	      
	"specialGlobalMaxWithoutNullSubstitute";
}


// CUSTOMER_CHOICE_FEATURES 
// This is the nullSubstitute to use for customer choice features
//
// Return a  nullSubstitute  part name, given  geo, planner part and feature.
std::string
LgFrMultiPlantHelper::custChoiceNullSubstitute(
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
const
{
    return 
	geo           +
	pdfSeparator_ +
        plannerPart   + 
	pdfSeparator_ +       
      	featurePart   +
	pdfSeparator_ +	      
	"specialCustChoiceNullSubstitute";
}


// This is the maxWithOutNullSubstitute to use when you want a unique nullSub
// for the unique pair (geo_plannerPart_"specialGeoPlannerDemand", pdf_featurePart)
//
// Because the pdf of the featurePart is function of the pdf sourcing of the plannerPart
// (and we can get it if we need it), the pdf is not encode in the maxWithoutNullSubstitute
// part name.
//
// Return a  nullSubstitute  part name, given  geo, planner part and feature.
// NOTE: this should be used for features with MaxWithout < featratio

std::string
LgFrMultiPlantHelper::maxWithoutNullSubstitute(
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
const
{
    return 
	geo           +
	pdfSeparator_ +
        plannerPart   + 
	pdfSeparator_ +       
      	featurePart   +
	pdfSeparator_ +	      
	"specialMaxWithoutNullSubstitute";
}




// Return a unique standalone Feature Part Name
std::string
LgFrMultiPlantHelper::custChoiceFeaturePartName(
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
const
{
    return 
        geo           +
	pdfSeparator_ +	      
        machine       +
	pdfSeparator_ +	      
      	pdf           +
	pdfSeparator_ +	      
      	featurePart   +
	pdfSeparator_ +	      
	"specialCustChoiceFeature";
}

// Returns 1 if part is a special Cust Choice Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
LgFrMultiPlantHelper::isPartSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // geo
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialCustChoiceFeature")
    return 1;

  return 0; 
  
}


// Returns 1 if operation is a special Customer Choice Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
LgFrMultiPlantHelper::isOperationSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitOperation);

  // geo
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialCustChoiceFeature")
    return 1;

  return 0; 
  
}



// Returns 1 if operation is EITHER:
//     special Standalone Feature, 
//  OR  special Customer Choice Feature,
// 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
LgFrMultiPlantHelper::isOperationSpecialFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitOperation);

  // geo
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if ((anythingSpecial == "specialStandaloneFeature")
      ||
      (anythingSpecial == "specialCustChoiceFeature"))
    return 1;

  return 0; 
  
}



// Returns 1 if part is a special Standalone Feature, 0 otherwise
// (overloaded function.  this one just checks ...
int
LgFrMultiPlantHelper::isPartSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;

    
  SCETokenizer next(fullWitPartname);


  // geo
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;
  
  // featurePartName
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialCustChoiceFeature")
    return 1;

  return 0; 
  
}

// Returns 1 if part is EITHER:
//     special Standalone Feature, 
//  OR  special Customer Choice Feature,
// 0 otherwise
// (overloaded function.  this one just checks ...
int
LgFrMultiPlantHelper::isPartSpecialFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;

    
  SCETokenizer next(fullWitPartname);


  // geo
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;
  
  // featurePartName
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if ((anythingSpecial == "specialCustChoiceFeature")
      ||
      (anythingSpecial == "specialStandaloneFeature"))
    return 1;

  return 0; 
  
}




// Return a unique standalone Feature Part Name
std::string
LgFrMultiPlantHelper::standaloneFeaturePartName(
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
const
{
    return 
        geo           +
	pdfSeparator_ +	      
        machine       +
	pdfSeparator_ +	      
      	pdf           +
	pdfSeparator_ +	      
      	featurePart   +
	pdfSeparator_ +	      
	"specialStandaloneFeature";
}



// Return a unique bbCategory part name
std::string
LgFrMultiPlantHelper::bbCategoryPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const
{
   return 
	geo     +
	pdfSeparator_ +	
	plannerTopLevelBuild +
	pdfSeparator_ +
        bbCategory +
	pdfSeparator_ +
	"specialBbCategory";
}


// Return a unique  part name for LT Feature Set Capacity Part
std::string
LgFrMultiPlantHelper::LTbbCapacityPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const
{
   return 
	geo         +
	pdfSeparator_  +	
	plannerTopLevelBuild +
	pdfSeparator_  +
	bbCategory +
	pdfSeparator_  +
	"specialLTFeatureCapacity";
}


// Return a unique  part name for GT Feature Set Capacity Part
std::string
LgFrMultiPlantHelper::GTbbCapacityPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const
{
   return 
	geo         +
	pdfSeparator_  +	
	plannerTopLevelBuild +
	pdfSeparator_  +
	bbCategory +
	pdfSeparator_  +
	"specialGTFeatureCapacity";
}


// Return a unique part name for an Option Dummy part
std::string
LgFrMultiPlantHelper::optionDummyPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
const
{
   return 
	geo         +
	pdfSeparator_  +	
	plannerTopLevelBuild +
	pdfSeparator_  +
	bbCategory +
	pdfSeparator_  +
	option         +
	pdfSeparator_  +
	"specialOptionDummy";
}


// Return a unique part name for an Option Ratio Supply part
std::string
LgFrMultiPlantHelper::optionRatioSupplyPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
const
{
   return 
	geo         +
	pdfSeparator_  +	
	plannerTopLevelBuild +
	pdfSeparator_  +
	bbCategory +
	pdfSeparator_  +
	option         +
	pdfSeparator_  +
	"specialOptionRatioSupply";
}


#if 0
// Return the partType of the part
// 1 = Normal
// 2 = Aggragate  dummy
// 3 = BB/feature set dummy
int
LgFrMultiPlantHelper::partType(const std::string & pdfPart)
const
{
    return 1;   // that's it for now
}

// Return the partType of the part
// 1 = Normal
// 2 = Aggragate  dummy
// 3 = BB/feature set dummy
int
LgFrMultiPlantHelper::partType(const std::string & part, const std::string & pdf)
const
{
    return this->partType(pdf + this->pdfSeparator_ + pdf);
}
#endif

// Return 1 if good, 0 if bad
int
LgFrMultiPlantHelper::isPartValid(
    WitRun * const theWitRun, 
    const std::string & partName, 
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const
{

    witBoolean exists;

    witGetPartExists(theWitRun, partName.c_str(), &exists);

    if (exists == WitFALSE && messageLogic == MANDATORY)   {
      (*sceErrFacility_)("UnrecognizedPartError",MclArgList() 
			 << partName 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
      // exits
    }

    if (exists == WitFALSE && messageLogic == OPTIONAL_WITH_MESSAGE)   {
      (*sceErrFacility_)("UnrecognizedPartWarning",MclArgList() << partName << fileName << (int)lineNo << dataLine);
      return 0;
    }

    if (exists == WitFALSE)
	return 0;

    return 1;
}

// Return 1 if good, 0 if bad
int
LgFrMultiPlantHelper::isPartValid(
    WitRun * const theWitRun, 
    const std::string & part,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const
{
    std::string pdfPart = pdf + pdfSeparator_ + part;
    witBoolean exists;
    exists = this->isPartValid(theWitRun, pdfPart, filename, dataLine, lineNo, PURELY_OPTIONAL);

    if (exists == WitFALSE && messageLogic == MANDATORY)   {
      (*sceErrFacility_)("UnrecognizedPartPdfError",MclArgList() 
			 << part << pdf << filename << (int)lineNo << dataLine);
      // exits
    }

    if (exists == WitFALSE && messageLogic == OPTIONAL_WITH_MESSAGE)   {
      (*sceErrFacility_)("UnrecognizedPartPdfWarning",MclArgList() 
			 << part << pdf << filename << (int)lineNo << dataLine);
      return 0;
    }

    if (exists == WitFALSE)
	return 0;

    return 1;
}





// Return 1 if a normal (no special characters) part, 0 if not

// SCE tidbit:
//             "normal" parts in SCE have two pieces to their name
//             all other special modeling parts have three or more
//             pieces to their name. --RLH
int
LgFrMultiPlantHelper::isPartNormal(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
const
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());

    std::string thePartName = next(pdfSeparator_.c_str());
    assert (! thePartName.empty());

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
	return 1;

    return 0;
}


//
// Return 1 if a "normal" (no special characters) operation, 0 otherwise.
// If method returns 1, the method also sets the pdf and operation

// "Normal" here means that either (1) the operation was defined
//  explicitedly by the user via the Operation Definition File or
// (2) SCE generated the operation from a part that was explicitedly
// defined by the user via the Part Definition File.

// SCE tidbit:
//             "normal" operations in SCE have two pieces to their name
//             all other special modeling operation have three or more
//             pieces to their name. --RLH

// Note: if you want to find out if the operation is specifically a
//       UserDefined Operation, then use isOperationUserDefined()
int
LgFrMultiPlantHelper::isOperationNormal(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
const
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);
    thePdf = next(pdfSeparator_.c_str());
    if (thePdf.empty())
      return 0;

    theOperationName = next(pdfSeparator_.c_str());
    if (theOperationName.empty())
      return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
	return 1;

    return 0;
}

//
// Return 1 if the operation is "User Defined", 0 ow.
// If method returns 1, the method also sets the pdf and operation
int
LgFrMultiPlantHelper::isOperationUserDefined(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
const
{
  if (this->isOperationNormal(theWitRun, fullWitOperationName, thePdf, theOperationName)) {
    if (this->isPartNormal(theWitRun, fullWitOperationName))
      return 0;
    else
      return 1;
  }
  else
    return 0;
}


// Return 1 if a normal (no special characters) capacity, 0 if not
int
LgFrMultiPlantHelper::isPartNormalCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
const
{
    witBoolean exists;
    witAttr category;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    witGetPartCategory(theWitRun, fullWitPartname.c_str(), &category);

    if (category != WitCAPACITY)
      return 0;

    
    SCETokenizer next(fullWitPartname);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());

    std::string thePartName = next(pdfSeparator_.c_str());
    assert (! thePartName.empty());

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
	return 1;

    return 0;
}


// Returns 1 if part is a specialGeoPlannerDemand part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
LgFrMultiPlantHelper::isPartSpecialGeoPlannerDemandPart(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialGeoPlannerDemand")
	return 1;

    return 0; 

}


// Returns 1 if part is a specialGeoPlannerDemandUB part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
LgFrMultiPlantHelper::isPartSpecialGeoPlannerDemandUbPart(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialGeoPlannerDemandUB")
	return 1;

    return 0; 

}


// Returns 1 if operation is a special aggregation operation, 0 otherwise
// If returns 1, also sets the realPart and aggPart and pdf's
int
LgFrMultiPlantHelper::isOperationSpecialAggregation(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & realPart,
    std::string & realPartPdf,
    std::string & aggPart,
    std::string & aggPdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // parentPdf
    realPartPdf =  next(pdfSeparator_.c_str());
    if (realPartPdf.empty())
	return 0;

    // parent
    realPart =  next(pdfSeparator_.c_str());
    if (realPart.empty())
	return 0;

    // childPdf
    aggPdf =  next(pdfSeparator_.c_str());
    if (aggPdf.empty())
	return 0;

    // child
    aggPart =  next(pdfSeparator_.c_str());
    if (aggPart.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialAggregationOperation")
	return 1;

    return 0; 
}


// Returns 1 if operation is a special interplant operation, 0 otherwise
// If returns 1, also sets the destination and source part and pdf
int
LgFrMultiPlantHelper::isOperationSpecialInterplant(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // parentPdf
    destinationPdf =  next(pdfSeparator_.c_str());
    if (destinationPdf.empty())
	return 0;

    // parent
    destination =  next(pdfSeparator_.c_str());
    if (destination.empty())
	return 0;

    // childPdf
    sourcePdf =  next(pdfSeparator_.c_str());
    if (sourcePdf.empty())
	return 0;

    // child
    source =  next(pdfSeparator_.c_str());
    if (source.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialInterPlantOperation")
	return 1;

    return 0; 
}


// Returns 1 if operation is a special alternate part operation, 0 otherwise
// If returns 1, also sets the primePart, primePdf, altPart, and altPdf
int
LgFrMultiPlantHelper::isOperationSpecialAlternate(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & primePart,
    std::string & primePdf,
    std::string & altPart,
    std::string & altPdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // primePdf
    primePdf =  next(pdfSeparator_.c_str());
    if (primePdf.empty())
	return 0;

    // primePart
    primePart =  next(pdfSeparator_.c_str());
    if (primePart.empty())
	return 0;

    // altPdf
    altPdf =  next(pdfSeparator_.c_str());
    if (altPdf.empty())
	return 0;

    // altPart
    altPart =  next(pdfSeparator_.c_str());
    if (altPart.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialAlternatePartOperation")
	return 1;

    return 0; 
}






// +
// Returns 1 if operation is a special interplant operation and
//              sets the full pdf-part name for the source part
// Otherwise, returns 0
int
LgFrMultiPlantHelper::interplantSourcePdfPartName(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName)
{
    std::string  destination;
    std::string  destinationPdf;
    std::string  source;
    std::string  sourcePdf;

    if ( isOperationSpecialInterplant( theWitRun, fullWitOperationName,
                                       destination, destinationPdf,
                                       source, sourcePdf) ) {
      sourcePdfPartName = pdfPartname( source, sourcePdf);
      return 1;
    }
     
    sourcePdfPartName = "";
    return 0; 
}



// Returns 1 if part is a specialGeoPlannerDemand part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
LgFrMultiPlantHelper::isOperationSpecialGeoPlannerDemand(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & plannerPart,
    std::string & geo)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialGeoPlannerDemand")
	return 1;

    return 0; 

}

#if 0
// this is obsolete, replaced by operationForCapacityGeneration
// Return 1 if the operation is SmartExpldoer Capacity creator
int
LgFrMultiPlantHelper::isOperationSpecialSmartExploderCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & theCapacity,
    std::string & pdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // Pdf
    pdf =  next(pdfSeparator_.c_str());
    if (pdf.empty())
	return 0;

    // capacity
    theCapacity =  next(pdfSeparator_.c_str());
    if (theCapacity.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialSmartExplodeCapacityOperation")
	return 1;

    return 0; 
  
}
#endif



  // Return 1 if the operation is SmartExpldoer Capacity creator
int
LgFrMultiPlantHelper::isOperationForCapacityGeneration(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & theCapacity,
    std::string & pdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // Pdf
    pdf =  next(pdfSeparator_.c_str());
    if (pdf.empty())
	return 0;

    // capacity
    theCapacity =  next(pdfSeparator_.c_str());
    if (theCapacity.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialOperationForCapacityGeneration")
	return 1;

    return 0; 
  
}





// Returns 1 if the is part is a globalNullSubstitute
//                          or a maxWithoutNullSubstitute,
//                          or a globalMaxWithoutNullSubstitute,
//         0 otherwise
// b/c the tokens in the names for the different types of null subs are NOT analogous, 
// no information encoded in the partname is returned. If information
// encoded in the name of the nullSubstitute is needed, then you'll have to ask
// ::isPartSpecialGlobalNullSubstitute or ::isPartSpecialMaxWithoutNullSubstitute
// or ::isPartSpecialGlobalMaxWithoutNullSubstitute
// to get the null substitute name decoded properly. 
//
// Use this method if you just need to know if the part is one of the three types of null subs.
//
int
LgFrMultiPlantHelper::isPartSpecialNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  std::string d1,d2,d3;

  if (isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun, fullWitPartname, d1))
    return 1;

  if (isPartSpecialMaxWithoutNullSubstitute(theWitRun, fullWitPartname, d1,d2,d3))
    return 1;

  if (isPartSpecialGlobalNullSubstitute(theWitRun, fullWitPartname, d1))
    return 1;

  // CUSTOMER_CHOICE_FEATURES  
  if (isPartSpecialCustChoiceNullSubstitute(theWitRun, fullWitPartname, d1,d2,d3))
    return 1;

  return 0;

}

// Returns 1 if part is a special Global nullSubstitiute, 0 otherwise
// If returns 1, also sets the pdf
int
LgFrMultiPlantHelper::isPartSpecialGlobalNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // dummyPartName -- this is "nullSub", if the method returns 1.
  std::string dpn =  next(pdfSeparator_.c_str());
  if (dpn.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialGlobalNullSubstitute")
    return 1;

  return 0; 

}


#ifdef ALTERNATE_AS_SUB
// Return a Global Alt Dummy part name
std::string
LgFrMultiPlantHelper::globalAltDummyPartName(
					     const std::string & primePdf)
const
{
    return 
	primePdf     +
	pdfSeparator_ +	
	primePdf     +
	pdfSeparator_ +	
	"specialGlobalAltDummy";
}



// Returns 1 if part is a special Global Alt Dummy, 0 otherwise
// If returns 1, also sets the pdf
int
LgFrMultiPlantHelper::isPartSpecialGlobalAltDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // pdf (appears twice)
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;


  // dummyPartName -- 
  std::string dpn =  next(pdfSeparator_.c_str());
  if (dpn.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialGlobalAltDummy")
    return 1;

  return 0; 

}

#endif















// Returns 1 if part is a special GlobalMaxWithoutNullSubstitiute,
//         0 otherwise
// If returns 1, also sets the pdf
int
LgFrMultiPlantHelper::isPartSpecialGlobalMaxWithoutNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // dummyPartName -- this is "nullSub", if the method returns 1.
  std::string dpn =  next(pdfSeparator_.c_str());
  if (dpn.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialGlobalMaxWithoutNullSubstitute")
    return 1;

  return 0; 

}


// Returns 1 if part is a special MaxWithout nullSubstitiute, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, and featurePart
int
LgFrMultiPlantHelper::isPartSpecialMaxWithoutNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // geo
  geo = next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // plannerPartName
  plannerPart =  next(pdfSeparator_.c_str());
  if (plannerPart.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialMaxWithoutNullSubstitute")
    return 1;

  return 0; 

}

// CUSTOMER_CHOICE_FEATURES
// Returns 1 if part is a special CustChoiceNullSubstitiute,
//         0 otherwise
// If returns 1, also sets the pdf
int
LgFrMultiPlantHelper::isPartSpecialCustChoiceNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // geo
  geo = next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // plannerPartName
  plannerPart =  next(pdfSeparator_.c_str());
  if (plannerPart.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialCustChoiceNullSubstitute")
    return 1;

  return 0; 

}






// Returns 1 if part is a special Standalone Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
LgFrMultiPlantHelper::isPartSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitPartname);

  // geo
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialStandaloneFeature")
    return 1;

  return 0; 
  
}


// Returns 1 if operation is a special Standalone Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
LgFrMultiPlantHelper::isOperationSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
{
  witBoolean exists;
  
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;
    
  SCETokenizer next(fullWitOperation);

  // geo
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;

  // featurePartName
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialStandaloneFeature")
    return 1;

  return 0; 
  
}



// Returns 1 if part is a special Standalone Feature, 0 otherwise
// (overloaded function.  this one just checks ...
int
LgFrMultiPlantHelper::isPartSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  witBoolean exists;
  
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

  if (exists == WitFALSE)
    return 0;

    
  SCETokenizer next(fullWitPartname);


  // geo
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
    return 0;

  // machine
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
    return 0;

  // pdf
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
    return 0;
  
  // featurePartName
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
    return 0;

  std::string anythingSpecial = next(pdfSeparator_.c_str());
  if (anythingSpecial == "specialStandaloneFeature")
    return 1;

  return 0; 
  
}



// Returns 1 if part is a special phantom part, 0 otherwise
int
LgFrMultiPlantHelper::isPartSpecialPhantom(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // Pdf
    std::string pdf =  next(pdfSeparator_.c_str());
    if (pdf.empty())
	return 0;

    // part
    std::string aPart =  next(pdfSeparator_.c_str());
    if (aPart.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialPhantomPart")
	return 1;

    return 0; 
}


// Returns 1 if part is a special BB category Set  part, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, and bbCategory
int
LgFrMultiPlantHelper::isPartSpecialBbCategory(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialBbCategory")
	return 1;

    return 0;
}






// Returns 1 if part is a special feature Set LT capacity part, 0 otherwise
// If returns 1, also sets the part and pdf
int
LgFrMultiPlantHelper::isPartSpecialLTbbCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialLTFeatureCapacity")
	return 1;

    return 0;
}

// Returns 1 if part is a special feature Set LT capacity part, 0 otherwise
// If returns 1, also sets the part and pdf
int
LgFrMultiPlantHelper::isPartSpecialGTbbCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialGTFeatureCapacity")
	return 1;

    return 0;

}

// Returns 1 if part is a special Option dummy, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
LgFrMultiPlantHelper::isPartSpecialOptionDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    // bbCategory
    mfgOptionPart =  next(pdfSeparator_.c_str());
    if (mfgOptionPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialOptionDummy")
	return 1;

    return 0;

}


// Returns 1 if Operation is a special Option dummy, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
LgFrMultiPlantHelper::isOperationSpecialOptionDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    // bbCategory
    mfgOptionPart =  next(pdfSeparator_.c_str());
    if (mfgOptionPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialOptionDummy")
	return 1;

    return 0;

}




// Returns 1 if part is a special Option Ratio Supply, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
LgFrMultiPlantHelper::isPartSpecialOptionRatioSupply(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart)
{
    witBoolean exists;

    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitPartname);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
	return 0;

    // plannerTopLevelBuild
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
	return 0;

    // bbCategory
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
	return 0;

    // bbCategory
    mfgOptionPart =  next(pdfSeparator_.c_str());
    if (mfgOptionPart.empty())
	return 0;


    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialOptionRatioSupply")
	return 1;

    return 0;

}



// Return 1 if a part is Buildable (ie, should be in the Build Schedule)
int
LgFrMultiPlantHelper::isPartBuildable(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
    if (! this->isPartNormal(theWitRun, fullWitPartname))
      return 0;

    if (this->isPartNormalCapacity(theWitRun, fullWitPartname))
	return 0;
    
    if (this->isPartPcf(theWitRun, fullWitPartname))
      return 0;

    witBoolean exists;
    witGetOperationExists(theWitRun, fullWitPartname.c_str(), &exists);
    if (! exists)
      return 0;

    return 1;
}

int
LgFrMultiPlantHelper::isOperationValid(
    WitRun * const theWitRun, 
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const
{

    witBoolean exists;

    witGetOperationExists(theWitRun, pdfOperationName.c_str(), &exists);

    if (exists == WitFALSE && messageLogic == MANDATORY)   {
      (*sceErrFacility_)("UnrecognizedOperationError",MclArgList() << pdfOperationName << fileName << (int)lineNo << dataLine);
      // exits
    }

    if (exists == WitFALSE && messageLogic == OPTIONAL_WITH_MESSAGE)   {
      (*sceErrFacility_)("UnrecognizedOperationWarning",MclArgList() << pdfOperationName << fileName << (int)lineNo << dataLine);
      return 0;
    }

    if (exists == WitFALSE)
	return 0;

    return 1;
}

// Return 1 if good, 0 if bad
int
LgFrMultiPlantHelper::isOperationValid(
    WitRun * const theWitRun, 
    const std::string & operationName,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const
{
    std::string pdfOperation = pdf + pdfSeparator_ + operationName;
    witBoolean exists;
    exists = this->isOperationValid(theWitRun, pdfOperation, filename, dataLine, lineNo, PURELY_OPTIONAL);

    if (exists == WitFALSE && messageLogic == MANDATORY)   {
      (*sceErrFacility_)("UnrecognizedOperationPdfError",MclArgList() 
			 << operationName << pdf << filename << (int)lineNo << dataLine);
      // exits
    }

    if (exists == WitFALSE && messageLogic == OPTIONAL_WITH_MESSAGE)   {
      (*sceErrFacility_)("UnrecognizedOperationPdfWarning",MclArgList() 
			 << operationName << pdf << filename << (int)lineNo << dataLine);
      return 0;
    }

    if (exists == WitFALSE)
	return 0;

    return 1;
}


int
LgFrMultiPlantHelper::isPdfOperationUnique(
    WitRun * const theWitRun, 
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const
{

    witBoolean exists;

    // check to see if a there is a pdf_part using the pdf_operation name.
    witGetPartExists(theWitRun, pdfOperationName.c_str(), &exists);

    if (exists == WitTRUE && messageLogic == MANDATORY)   {
      (*sceErrFacility_)("DuplicatePartPDFPairError",MclArgList() << pdfOperationName << fileName << (int)lineNo << dataLine);
      // exits
    }

    if (exists == WitTRUE && messageLogic == OPTIONAL_WITH_MESSAGE)   {
      (*sceErrFacility_)("DuplicatePartPDFPairWarning",MclArgList() << pdfOperationName << fileName << (int)lineNo << dataLine);
      return 0;
    }

    if (exists == WitTRUE)
	return 0;

    return 1;
}


// Return a geo_plannerPart_specialPureOptionBuildDemandName, given the
// fullWitName of a specialGeoPlannerDemand part
std::string
LgFrMultiPlantHelper::pureOptionBuildDemandName(
    const std::string & fullWitPartName)

{
    std::string  plannerPart;
    std::string  geo;

    SCETokenizer next(fullWitPartName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    assert (! (geo.empty()));

    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    assert (! (plannerPart.empty()));

    return 
	  geo 
	+ pdfSeparator_ 
	+ plannerPart 
	+ pdfSeparator_ 
	+ "specialPureOptionBuildDemandName";
}




// Returns 1 if demand is a specialPureOptionBuildDemand, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
LgFrMultiPlantHelper::isDemandSpecialPureOptionBuildDemand(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo)
{
    witBoolean partExists;
    witBoolean demandExists;

    // check to see if the part exists
    witGetPartExists(theWitRun, fullWitPartName.c_str(), &partExists);

    if (partExists == WitFALSE)
	return 0;

    // check to see if the demand exists
    int  lenDemandList;
    char ** demandList;
    witGetPartDemands ( theWitRun, fullWitPartName.c_str(), &lenDemandList, &demandList);

    // loop through the demand list searching for a match
    // if you find one, set the boolean to True and break out of the loop
    demandExists = WitFALSE;
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<lenDemandList; i++){
      if (fullWitDemandName == demandList[i]) {
        demandExists = WitTRUE;
        break;
      }
    }
    
    // we're done with demandList -- get rid of it
    for (i=0; i<lenDemandList; i++)
      witFree(demandList[i]);
    witFree(demandList);
    
    if (demandExists == WitFALSE) 
      return 0;

    // parse the fullWitDemandName to get the geo and plannerPart
    SCETokenizer next(fullWitDemandName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty()) {
      return 0;
    }
    
    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty()){
      return 0;
    }
	

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialPureOptionBuildDemandName"){
      return 1;
    }
    

    return 0; 

}


// CUSTOMER_CHOICE_FEATURES
// Return a geo_plannerPart_specialCustChoiceDemandName, given the
// fullWitName of a specialGeoPlannerDemand part
std::string
LgFrMultiPlantHelper::custChoiceFeatureDemandName(
    const std::string & fullWitPartName)

{
    std::string  plannerPart;
    std::string  geo;

    SCETokenizer next(fullWitPartName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    assert (! (geo.empty()));

    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    assert (! (plannerPart.empty()));

    return 
	  geo 
	+ pdfSeparator_ 
	+ plannerPart 
	+ pdfSeparator_ 
	+ "specialCustChoiceFeatureDemand";
}


// Returns 1 if demand is a specialPureOptionBuildDemand, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
LgFrMultiPlantHelper::isDemandSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo)
{
    witBoolean partExists;
    witBoolean demandExists;

    // check to see if the part exists
    witGetPartExists(theWitRun, fullWitPartName.c_str(), &partExists);

    if (partExists == WitFALSE)
	return 0;

    // check to see if the demand exists
    int  lenDemandList;
    char ** demandList;
    witGetPartDemands ( theWitRun, fullWitPartName.c_str(), &lenDemandList, &demandList);

    // loop through the demand list searching for a match
    // if you find one, set the boolean to True and break out of the loop
    demandExists = WitFALSE;
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<lenDemandList; i++){
      if (fullWitDemandName == demandList[i]) {
        demandExists = WitTRUE;
        break;
      }
    }
    
    // we're done with demandList -- get rid of it
    for (i=0; i<lenDemandList; i++)
      witFree(demandList[i]);
    witFree(demandList);
    
    if (demandExists == WitFALSE) 
      return 0;

    // parse the fullWitDemandName to get the geo and plannerPart
    SCETokenizer next(fullWitDemandName);

    // geo
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty()) {
      return 0;
    }
    
    // plannerPart
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty()){
      return 0;
    }
	

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialCustChoiceFeatureDemand"){
      return 1;
    }
    

    return 0; 

}






// set/get the pdf-partname delimiter string
std::string
LgFrMultiPlantHelper::pdfSeparator()
const
{
    return pdfSeparator_;
}

void
LgFrMultiPlantHelper::pdfSeparator(
    const std::string & pdfSeparator)
{
    pdfSeparator_ = pdfSeparator;
}

// set/get the default PDF string
std::string
LgFrMultiPlantHelper::defaultPdf()
const
{
    return defaultPdf_;
}

void
LgFrMultiPlantHelper::defaultPdf(
    const std::string & defaultPdf)
{
    defaultPdf_ = defaultPdf;
}


// multi_attribute_demand
void
LgFrMultiPlantHelper::multiAttributeDemandSeparator(
    const std::string & multiAttributeDemandSeparator)
{
    multiAttributeDemandSeparator_ = multiAttributeDemandSeparator;
}

std::string
LgFrMultiPlantHelper::multiAttributeDemandSeparator()
const
{
    return multiAttributeDemandSeparator_;
}






void
LgFrMultiPlantHelper::useMultiAttributeDemand(
    const bool useMultiAttributeDemand)
{
    useMultiAttributeDemand_ = useMultiAttributeDemand;
}

bool
LgFrMultiPlantHelper::useMultiAttributeDemand()
const
{
    return useMultiAttributeDemand_;
}


void
LgFrMultiPlantHelper::useDemand2OrderINDP(
    const bool useDemand2OrderINDP)
{
    useDemand2OrderINDP_ = useDemand2OrderINDP;
}

bool
LgFrMultiPlantHelper::useDemand2OrderINDP()
const
{
    return useDemand2OrderINDP_;
}






void
LgFrMultiPlantHelper::truncOffsetToEol(
    const bool truncOffsetToEol)
{
    truncOffsetToEol_ = truncOffsetToEol;
}

// set/get the default PDF string
bool
LgFrMultiPlantHelper::truncOffsetToEol()
const
{
    return truncOffsetToEol_;
}


void
LgFrMultiPlantHelper::numDemandAttributes(
    const int numDemandAttributes)
{
    numDemandAttributes_ = numDemandAttributes;
}

int
LgFrMultiPlantHelper::numDemandAttributes()
const
{
    return numDemandAttributes_;
}




// Get the  PDF for a PDF_PART
std::string 
LgFrMultiPlantHelper::pdf(const LgFrPart & part)
const
{
    return this->pdf(part.name());
}



// Parse the string looking for two pieces, the PDF and
// the partname.  If you only find one piece, then assume
// that this is a partname and that the PDF is the default.
std::string 
LgFrMultiPlantHelper::pdf(const std::string & pdfPart)
const
{
    SCETokenizer next(pdfPart);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());

    std::string thePartName = next(pdfSeparator_.c_str());
    if (thePartName.empty())
	return defaultPdf_;

    return thePdf;
}


std::string 
LgFrMultiPlantHelper::pdf(const char * pdfPart)
const
{
    return this->pdf(std::string(pdfPart));
}

// Parse the string looking for two pieces, the PDF and
// the partname.  If you only find one piece, then assume
// that this is THE partname`
std::string 
LgFrMultiPlantHelper::partname(const std::string & pdfPart)
const
{
    SCETokenizer next(pdfPart);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());

    std::string thePartName = next(pdfSeparator_.c_str());
    if (thePartName.empty())
	return thePdf;

    return thePartName;
}


// Return just the operationName of a pdf_operationName.
// Parse the string looking for two pieces, the PDF and
// the operationName.  If you only find one piece, then assume
// that this is THE operationName.
std::string 
LgFrMultiPlantHelper::operationName(const std::string & pdfOperation)
const
{
    return this->partname(pdfOperation);
}

// Are the parts equivalent, irrespective of the PDF?


bool
LgFrMultiPlantHelper::isPartnameEqual(const std::string & left, const std::string & right)
const
{
    return (this->partname(left) == this->partname(right));
}

// 
// returns 1 if the duplicate interplant record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the interplant bom)
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateInterplantRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & sourcePdfPartName,
    const std::string & interplantOperationName,
    float duplicateRecordUsageRate )
{
  int nBoms;
  witGetOperationNBomEntries( theWitRun,
                              interplantOperationName.c_str(),
                              &nBoms );
  assert ( nBoms == 1 );

  float currentUsageRate;
  witGetBomEntryUsageRate( theWitRun,
                           interplantOperationName.c_str(),
                           0,
                           &currentUsageRate );

  // if usage rates are not equal, then return 0
  if (( duplicateRecordUsageRate > (currentUsageRate + MULTIPLANTHELPER_FLT_EPS)) ||
      ( duplicateRecordUsageRate < (currentUsageRate - MULTIPLANTHELPER_FLT_EPS))) {
    return (0);
  }

  // the usage rate are equal
  return (1) ;
}

//
// returns 1 if the duplicate interplant record's effectivity
//              dates do not overlap with the effectivity
//              dates of interplant operation's existing bops
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateInterplantRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & interplantOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd )
{
  if ( duplicateRecordStart > duplicateRecordEnd )
    return 0;
  
  int nbBops;
  witGetOperationNBopEntries( theWitRun,
                              interplantOperationName.c_str(),
                              &nbBops );
  
  size_t b = 0; // Pulled out of the for below by RW2STL
  for ( b=0; b<nbBops; b++) {
    int currentBopStart;
    int currentBopEnd;
    
    witGetBopEntryEarliestPeriod( theWitRun,
                                  interplantOperationName.c_str(),
                                  b,
                                  &currentBopStart);
    
    witGetBopEntryLatestPeriod( theWitRun,
                                interplantOperationName.c_str(),
                                b,
                                &currentBopEnd);

    // For now, if there's a bop in there with effectivity turned off,
    // we have problems...
    assert ( currentBopStart <= currentBopEnd );

    // if they're not "disjoint", the record's invalid. Return 0.
    if (!( ((duplicateRecordStart < currentBopStart) && 
           (duplicateRecordEnd < currentBopStart))  // before
          ||                                         // or
          ((duplicateRecordStart > currentBopEnd) && // after 
          (duplicateRecordEnd > currentBopEnd))) )

      return 0;
  }
  // none of the records overlapped. the record's valid. Return 1.
  return 1;
}


// 
// returns 1 if the duplicate interplant record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the interplant bom)
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateAlternatePartRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & fullAltPartPdfName,
    const std::string & alternatePartOperationName,
    float duplicateRecordUsageRate )
{
  int nBoms;
  witGetOperationNBomEntries( theWitRun,
                              alternatePartOperationName.c_str(),
                              &nBoms );
  assert ( nBoms == 1 );

  float currentUsageRate;
  witGetBomEntryUsageRate( theWitRun,
                           alternatePartOperationName.c_str(),
                           0,
                           &currentUsageRate );

  // if usage rates are not equal, then return 0
  if (( duplicateRecordUsageRate > (currentUsageRate + MULTIPLANTHELPER_FLT_EPS)) ||
      ( duplicateRecordUsageRate < (currentUsageRate - MULTIPLANTHELPER_FLT_EPS))) {
    return (0);
  }

  // the usage rate are equal
  return (1) ;
}

//
// returns 1 if the duplicate alternatePart record's effectivity
//              dates do not overlap with the effectivity
//              dates of alternatePart operation's existing bops
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateAlternatePartRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & alternatePartOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd )
{
  if ( duplicateRecordStart > duplicateRecordEnd )
    return 0;
  
  int nbBops;
  witGetOperationNBopEntries( theWitRun,
                              alternatePartOperationName.c_str(),
                              &nbBops );
  
  size_t b = 0; // Pulled out of the for below by RW2STL
  for ( b=0; b<nbBops; b++) {
    int currentBopStart;
    int currentBopEnd;
    
    witGetBopEntryEarliestPeriod( theWitRun,
                                  alternatePartOperationName.c_str(),
                                  b,
                                  &currentBopStart);
    
    witGetBopEntryLatestPeriod( theWitRun,
                                alternatePartOperationName.c_str(),
                                b,
                                &currentBopEnd);

    // For now, if there's a bop in there with effectivity turned off,
    // we have problems...
    assert ( currentBopStart <= currentBopEnd );

    // if they're not "disjoint", the record's invalid. Return 0.
    if (!( ((duplicateRecordStart < currentBopStart) && 
           (duplicateRecordEnd < currentBopStart))  // before
          ||                                         // or
          ((duplicateRecordStart > currentBopEnd) && // after 
          (duplicateRecordEnd > currentBopEnd))) )

      return 0;
  }
  // none of the records overlapped. the record's valid. Return 1.
  return 1;
}







    
// Return a copy in the heap
LgFrMultiPlantHelper*
LgFrMultiPlantHelper::clone()
     const
{
  return new LgFrMultiPlantHelper(*this);
}



 // copy constructor
LgFrMultiPlantHelper::LgFrMultiPlantHelper(const LgFrMultiPlantHelper& source)
: pdfSeparator_(source.pdfSeparator_),
  defaultPdf_(source.defaultPdf_),
  useMultiAttributeDemand_(source.useMultiAttributeDemand_),
  truncOffsetToEol_(source.truncOffsetToEol_),
  numDemandAttributes_(source.numDemandAttributes_),
  multiAttributeDemandSeparator_(source.multiAttributeDemandSeparator_),
  useDemand2OrderINDP_(source.useDemand2OrderINDP_),
  sceErrFacility_(source.sceErrFacility_)
{
  // nothing to do
}

// assignment operator
LgFrMultiPlantHelper&
LgFrMultiPlantHelper::operator=(const LgFrMultiPlantHelper& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
    pdfSeparator_ = rhs.pdfSeparator_;
    defaultPdf_ = rhs.defaultPdf_;
    useMultiAttributeDemand_ = rhs.useMultiAttributeDemand_;
    truncOffsetToEol_ = rhs.truncOffsetToEol_;
    numDemandAttributes_ = rhs.numDemandAttributes_;
    multiAttributeDemandSeparator_ = rhs.multiAttributeDemandSeparator_;
    useDemand2OrderINDP_ = rhs.useDemand2OrderINDP_;
    sceErrFacility_ = rhs.sceErrFacility_;
  }
  return *this;
}

// destructor
LgFrMultiPlantHelper::~LgFrMultiPlantHelper()
{
  // nothing to do
}


#ifdef NDEBUG
#undef NDEBUG
#endif



// self-test
void
LgFrMultiPlantHelper::test()
{
  
 LgFrMultiPlantHelper multiPlantHelper;

 assert(multiPlantHelper.pdfSeparator() == "_ \t\n");
 assert(multiPlantHelper.defaultPdf() == "WW");

 std::string testPart1("POK_xx123");
 std::string testPart2("FUJ_xx123");
 std::string testPart3("xx123");
 std::string testPart4("WW_yy123");

 assert(multiPlantHelper.partname(testPart1) == 
	multiPlantHelper.partname(testPart2));
 assert(multiPlantHelper.isPartnameEqual(testPart1, testPart2));
 assert(multiPlantHelper.isPartnameEqual(testPart1, testPart3));
 assert(multiPlantHelper.isPartnameEqual(testPart1.c_str(), testPart3));
 assert(multiPlantHelper.isPartnameEqual(testPart1.c_str(), testPart3.c_str()));
 assert(multiPlantHelper.isPartnameEqual(testPart1, testPart3.c_str()));

 assert(multiPlantHelper.pdf(testPart1) == "POK");
 assert(multiPlantHelper.pdf(testPart3) == "WW");
 assert(multiPlantHelper.pdf(testPart3.c_str()) == "WW");

 
 
 }

#endif
@


1.22
log
@6.2 latest commits to old repository
@
text
@d19 2
a20 1
#ifdef VARIABLE_PERIODS
d529 2
a530 1
#ifdef VARIABLE_PERIODS
@


1.21
log
@mfo is folded into featratio file
@
text
@d68 1
a68 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d155 1
a155 1
  witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
@


1.20
log
@pegging and sub enablement for 6.1
@
text
@a27 5
// =============================
// =============================
//           SCE 6.1
// =============================
// =============================
a29 1
// THIS IS A BETTER ONE. !!!!!!
d99 2
a100 7
      (*sceErrFacility_)("MissingPDFSource",MclArgList() 
			 << plannerPartName 
			 << geo 
			 << start 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
d111 6
a116 1
// VARIABLE_PERIODS ... should erase all others ... note that the transit time offset returned is already adjusted for variable periods
d125 43
a167 18
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
    LgFrTimeVecFloat     & offsetTV,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
{
    
    std::string mfgTopLevelBuild;
    int bomStart = 0;
    int bomEnd = 0;

// create a geoPlannerPart name
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
d169 1
a169 42

    // and test to see if it exists (it should)
    int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
				   dataLine, lineNo, messageLogic);

    if (! result)
	return mfgTopLevelBuild;

    // loop through the BOM entries for this special demand part and find
    // the bom which has effectivity within the period "start".  Return the
    // pdf of this mfgTopLevelBuild
    // We also return the time-offset for this demand source
    int nBom;
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);

    char * child;
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      // if the child is not a normal part, then we can skip it.  (GPD's only 
      // source to normal parts)
      // first check to see if the child is a specialDemand UpperBound part, OR
      // a specialBb category part, if so, then skip it.
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      std::string pp;
      std::string g;
      std::string bb;

      if (! this->isPartNormal(theWitRun, child)) {
	witFree(child);
	continue;
      }
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
      if (start >= bomStart && start <= bomEnd)   {
        mfgTopLevelBuild = child;
	float * offset;
	int ttt=0;
        witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
	for (ttt=start; ttt<=late; ttt++) 
	  offsetTV[ttt] = offset[ttt];
	witFree(offset);
      }
d171 1
a171 2
      if (! mfgTopLevelBuild.empty())
        break;
d173 10
a182 10

    // What to do if you can't source it?????
    if (mfgTopLevelBuild.empty())   {
      (*sceErrFacility_)("MissingPDFSource",MclArgList() 
			 << plannerPartName 
			 << geo 
			 << start 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
d184 13
d199 8
d208 2
a209 4

    // set late as the bomEnd
    late = bomEnd;
    return mfgTopLevelBuild;
a213 1

d246 8
d258 1
a258 2
LgFrMultiPlantHelper::compressedDemandName(
					   const std::string * demandAttributes[])
@


1.19
log
@6.1 prep commit ... many things in here
@
text
@d27 231
a257 10
// default constructor:
LgFrMultiPlantHelper::LgFrMultiPlantHelper()
: pdfSeparator_("? \t\n"),
  defaultPdf_("WW"),
  useMultiAttributeDemand_(0),
  numDemandAttributes_(4),
  multiAttributeDemandSeparator_("% \t\n"),
  useDemand2OrderINDP_(0),
  truncOffsetToEol_(0),
  sceErrFacility_(0)
d259 8
a266 1
    // all the work is done in initializer
d270 23
a292 16
// fairly general constructor:
LgFrMultiPlantHelper::LgFrMultiPlantHelper(
	     const std::string & pdfSeparator,
	     const std::string & defaultPdf,
	     const bool useMultiAttributeDemand,
	     const int numDemandAttributes,
	     const std::string & multiAttributeDemandSeparator,
	     const bool useDemand2OrderINDP)
: pdfSeparator_(pdfSeparator),
  defaultPdf_(defaultPdf),
  useMultiAttributeDemand_(useMultiAttributeDemand),
  numDemandAttributes_(numDemandAttributes),
  multiAttributeDemandSeparator_(multiAttributeDemandSeparator),
  useDemand2OrderINDP_(useDemand2OrderINDP),
  truncOffsetToEol_(0),
  sceErrFacility_(0)
d294 1
a294 2
  // all the work is done in initializer
}
d296 4
a299 6
// necessary methods for sharing scenario's error facility
void
LgFrMultiPlantHelper::setErrFacility(MclFacility * existingFacility)
{
  sceErrFacility_ = existingFacility;
}
d301 4
a304 5
MclFacility*
LgFrMultiPlantHelper::getErrFacility()
{
  return sceErrFacility_;
}
d306 4
d311 3
a313 10
#ifdef ENABLE_NEGATIVE_DEMANDS
// Return 1 if part has any negative demands
int
LgFrMultiPlantHelper::doesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
a315 2
  return appDataPtr->doesPartHaveNegativeDemands();
}
d317 1
a317 17
// Set the Part's doesPartHaveNegativeDemands
void
LgFrMultiPlantHelper::setDoesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    int doesPartHaveNegativeDemands)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  // if hte part does not have an appData, then create one
  if (appDataPtr == 0) {
    int nPeriods;
    witGetNPeriods(theWitRun, &nPeriods);
    appDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
    witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) appDataPtr);
  }      
  appDataPtr->doesPartHaveNegativeDemands(doesPartHaveNegativeDemands);
a319 10
LgFrTimeVecFloat
LgFrMultiPlantHelper::negDemVol(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  int nPeriods;
  int nDemands;
  char ** dList;
  
  float * witDemandVol;
a320 1
  witGetNPeriods(theWitRun, &nPeriods);
d322 27
a348 17
  LgFrTimeVecFloat negDemVol((size_t) nPeriods, 0.0);
  LgFrSceDemandAppData * appDataPtr = 0;
  
  if (this->doesPartHaveNegativeDemands(theWitRun, fullWitPartname)) {
    int didWeFindAnAppData = 0;
    witGetPartDemands(theWitRun, fullWitPartname.c_str(), &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      witGetDemandDemandVol(theWitRun, fullWitPartname.c_str(), dList[j], &witDemandVol);
      witGetDemandAppData(theWitRun, fullWitPartname.c_str(), dList[j], (void **) &appDataPtr);
      if (appDataPtr != 0) {
	didWeFindAnAppData = 1;
	LgFrTimeVecFloat appDataDemandVol(appDataPtr->demandVol());
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
	  negDemVol[t] += witDemandVol[t] - appDataDemandVol[t];
	}
d350 1
a350 10
      witFree(witDemandVol);
      witFree(dList[j]);
    }
    witFree(dList);
    if (! didWeFindAnAppData) {
      std::cerr << "SCE9955F PROGRAMMER ERROR: part with negative demands does not\n"
	   << "have a demand with non-0 appData\n"
	   << "Please report this error to SCE Development\n"
	   << "SCE Terminates with return code: 8\n\n";
      exit(8);
d352 1
d355 5
a359 1
  return negDemVol;
a361 1
#endif
d363 8
a370 1
// Return 1 if a part is marked as a PCF part, 0 if not
d372 5
a376 3
LgFrMultiPlantHelper::isPartPcf(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
d378 28
d407 1
d409 7
a415 1
  witBoolean exists;
a416 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
a417 2
  if (! exists)
    return 0;
a419 4
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
d421 4
a424 6
  return appDataPtr->isPartPcf();
}


#ifdef MARK_BOGONS
// Return 1 if a part is a PCF bogon
d426 4
a429 3
LgFrMultiPlantHelper::isPartBogon(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
d431 27
a457 4
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
d459 5
a463 1
  return appDataPtr->isPartBogon();
d465 2
a466 2
#endif

d468 8
a475 7

// Return the witPartIndex
// returns -1 if the part is bad, or, index is not set
int
LgFrMultiPlantHelper::witPartIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
d477 6
a482 6
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return -1;

  return appDataPtr->index();
d485 1
a485 3

// Return the witOperationIndex
// returns -1 if the operation is bad, or, index is not set
d487 6
a492 3
LgFrMultiPlantHelper::witOperationIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName)
d494 1
a494 4
  LgFrSceCCOperationAppData * appDataPtr;
  witGetOperationAppData(theWitRun,  fullWitOperationName.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return -1;
d496 4
a499 2
  return appDataPtr->index();
}
d501 4
d506 4
d511 4
d516 4
a520 8
// (Re)set the partAppData indices to synch with a witGetParts()
// It sets them for all parts and re-sets if an appData already exists
void
LgFrMultiPlantHelper::setAllWitPartIndices(
    WitRun * const theWitRun)
{
  int nParts;
  char ** partList;
d522 2
a523 14
  witGetParts (theWitRun, &nParts, &partList );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    LgFrScePartAppData * partAppDataPtr;
    witGetPartAppData (theWitRun, partList[i], (void **) &partAppDataPtr );
    // if no app data exists, then create one.
    if (partAppDataPtr == 0) {
      int nPeriods;
      witGetNPeriods(theWitRun, &nPeriods);
      partAppDataPtr = new LgFrScePartAppData(0, nPeriods, nPeriods);
      witSetPartAppData(theWitRun, partList[i], (void *) partAppDataPtr);
    }
    partAppDataPtr->index(i);      
  } 
a524 4
  for (i=0; i<nParts; i++)
    witFree (partList[i]);
  witFree (partList);
}
a718 13
// set the Customer Choice Operation AppData indices to synch with a witGetOperation()
// It sets them only for Special Customer Choice feature parts
void
LgFrMultiPlantHelper::setCCOperationIndices(
    WitRun * const theWitRun)
{
  int nOperations;
  char ** opList;

  std::string geo;
  std::string machine;
  std::string pdf;
  std::string featurePart;
a721 21
  witGetOperations (theWitRun, &nOperations, &opList );
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
    if (! this->isOperationSpecialCustChoiceFeature(theWitRun, opList[o], geo, machine,pdf,featurePart)) {
      witFree(opList[o]);
      continue;
    }
    
    LgFrSceCCOperationAppData * ccOpAppDataPtr;
    witGetOperationAppData (theWitRun, opList[o], (void **) &ccOpAppDataPtr );
    // if no app data exists, then create one.
    if (ccOpAppDataPtr == 0) {
      ccOpAppDataPtr = new LgFrSceCCOperationAppData(o);
      witSetOperationAppData(theWitRun, opList[o], (void *) ccOpAppDataPtr);
    }
    ccOpAppDataPtr->index(o); 
    witFree(opList[o]);     
  } 

  witFree (opList);
}
d723 5
a729 11
  // returns the feature ratio of a customer choice feature.
  // Note that the partname MUST be a specialCustChoicePartName
LgFrTimeVecFloat 
LgFrMultiPlantHelper::custChoiceFeatureRatio(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature)
{
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));
a730 11
  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);
a731 3
  witFree(gpdWitOperationName);
  return bomAppDataPtr->featRatio();
}
d733 10
a742 7
// GET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
LgFrTimeVecFloat 
LgFrMultiPlantHelper::custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature)
d744 1
a744 19
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));

  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);

  witFree(gpdWitOperationName);
  return bomAppDataPtr->dummySupplyVolForMrpAdjustment();
d748 16
a763 8
// SET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
void 
LgFrMultiPlantHelper::custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun, 
    const std::string & specialCustChoiceFeature,
    LgFrTimeVecFloat & dummySupplyVolForMrpAdjustment)
d765 1
a765 19
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
  assert(this->isPartSpecialCustChoiceFeature(theWitRun, specialCustChoiceFeature, geo,
					      plannerTopLevelPart, pppdf,
					      featurePart));

  // Now get the unique bomEntry between this specialCustChoiceFeature and GPD
  int ncbe;
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
  // FINISH_ME: this does not work for multiple geo sourcing 
  assert(ncbe == 1);
  char * gpdWitOperationName;
  int bomIndex;
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
  LgFrSceCustChoiceBomAppData * bomAppDataPtr;
  witGetBomEntryAppData(theWitRun, gpdWitOperationName, bomIndex, (void **) &bomAppDataPtr);
  assert(bomAppDataPtr != 0);

  witFree(gpdWitOperationName);
  bomAppDataPtr->dummySupplyVolForMrpAdjustment(dummySupplyVolForMrpAdjustment);
d768 3
a770 20


// returns convenient way to get the nInterplant Ops 
int
LgFrMultiPlantHelper::nInterplantOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nInterplantOps();
}  

// returns convenient way to get the nAlternatePart Ops 
int
LgFrMultiPlantHelper::nAlternatePartOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
d772 2
a773 6
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nAlternatePartOps();
}  
d775 5
d782 2
a783 3


// returns convenient way to get the nUserDefinedOps
d785 1
a785 1
LgFrMultiPlantHelper::nUserDefinedOps(
a792 2
  return appDataPtr->nUserDefinedOps();
}  
d794 6
a799 3
  // returns convenient way to get the nAggregationOps
int
LgFrMultiPlantHelper::nAggregationOps(
d801 2
a802 1
    const std::string & fullWitPartname)
d806 8
a813 38
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nAggregationOps();
}  


// plannerPartName/Geo ---> mfgPart/Pdf  source 
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
// and it returns a PDF_Part
std::string
LgFrMultiPlantHelper::demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
    
const
{
    // create a geoPlannerPart name
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);

    // and test to see if it exists (it should)
    int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
				   dataLine, lineNo, messageLogic);

    // FINISH_ME -- For now, we assume that it only has one BOM arc!
    int nBom;
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
    assert(nBom == 1);
    char * child;
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), 0, &child);
    
    std::string theSource(child);
    witFree(child);
    return theSource;
d816 2
a817 9

// plannerPartName/Geo ---> mfgPart/Pdf  source 
// THIS IS A BETTER ONE. !!!!!!
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
// and it returns a PDF_Part
// You also feed it a start period, and it figures the latest period for 
// which this pdf is sourced for this demand
std::string
LgFrMultiPlantHelper::demandSource(
d819 1
a819 9
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
          float     & offset,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
d821 5
a825 4
    
    std::string mfgTopLevelBuild;
    int bomStart = 0;
    int bomEnd = 0;
d827 1
a827 3
// create a geoPlannerPart name
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
    
d829 6
a834 15
    // and test to see if it exists (it should)
    int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
				   dataLine, lineNo, messageLogic);

    if (! result)
	return mfgTopLevelBuild;

    // loop through the BOM entries for this special demand part and find
    // the bom which has effectivity within the period "start".  Return the
    // pdf of this mfgTopLevelBuild
    // We also return the time-offset for this demand source
    int nBom;
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);

    char * child;
d836 10
a845 13
    for (j=0; j<nBom; j++)  {
      // if the child is not a normal part, then we can skip it.  (GPD's only 
      // source to normal parts)
      // first check to see if the child is a specialDemand UpperBound part, OR
      // a specialBb category part, if so, then skip it.
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      std::string pp;
      std::string g;
      std::string bb;

      if (! this->isPartNormal(theWitRun, child)) {
	witFree(child);
	continue;
d847 2
a848 9
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
      if (start >= bomStart && start <= bomEnd)   {
        mfgTopLevelBuild = child;
        witGetBomEntryUsageTime(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
      }
      witFree(child);
      if (! mfgTopLevelBuild.empty())
        break;
d850 7
a856 93

    // What to do if you can't source it?????
    if (mfgTopLevelBuild.empty())   {
      (*sceErrFacility_)("MissingPDFSource",MclArgList() 
			 << plannerPartName 
			 << geo 
			 << start 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
    }



    // set late as the bomEnd
    late = bomEnd;
    return mfgTopLevelBuild;
}


// VARIABLE_PERIODS ... should erase all others ... note that the transit time offset returned is already adjusted for variable periods
// plannerPartName/Geo ---> mfgPart/Pdf  source 
// THIS IS A BETTER ONE. !!!!!!
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
// and it returns a PDF_Part
// You also feed it a start period, and it figures the latest period for 
// which this pdf is sourced for this demand
std::string
LgFrMultiPlantHelper::demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
    LgFrTimeVecFloat     & offsetTV,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
{
    
    std::string mfgTopLevelBuild;
    int bomStart = 0;
    int bomEnd = 0;

// create a geoPlannerPart name
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
    

    // and test to see if it exists (it should)
    int result = this->isPartValid(theWitRun, geoPlannerDemandPartName, fileName, 
				   dataLine, lineNo, messageLogic);

    if (! result)
	return mfgTopLevelBuild;

    // loop through the BOM entries for this special demand part and find
    // the bom which has effectivity within the period "start".  Return the
    // pdf of this mfgTopLevelBuild
    // We also return the time-offset for this demand source
    int nBom;
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);

    char * child;
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
      // if the child is not a normal part, then we can skip it.  (GPD's only 
      // source to normal parts)
      // first check to see if the child is a specialDemand UpperBound part, OR
      // a specialBb category part, if so, then skip it.
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      std::string pp;
      std::string g;
      std::string bb;

      if (! this->isPartNormal(theWitRun, child)) {
	witFree(child);
	continue;
      }
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
      if (start >= bomStart && start <= bomEnd)   {
        mfgTopLevelBuild = child;
	float * offset;
	int ttt=0;
        witGetBomEntryOffset(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
	for (ttt=start; ttt<=late; ttt++) 
	  offsetTV[ttt] = offset[ttt];
	witFree(offset);
      }
      witFree(child);
      if (! mfgTopLevelBuild.empty())
        break;
d858 1
d860 2
a861 10
    // What to do if you can't source it?????
    if (mfgTopLevelBuild.empty())   {
      (*sceErrFacility_)("MissingPDFSource",MclArgList() 
			 << plannerPartName 
			 << geo 
			 << start 
			 << fileName 
			 << (int)lineNo 
			 << dataLine);
    }
d863 1
d865 6
d873 3
a875 4
    // set late as the bomEnd
    late = bomEnd;
    return mfgTopLevelBuild;
}
d877 2
d881 4
d886 1
a886 10
// multi_attribute_demand  ... DEMAND2ORDER function
// append the requestDate onto the end of the dmeandName string 
std::string
LgFrMultiPlantHelper::expandDemandKeyforD2O(const std::string &  geoPreD2O, const std::string & requestDate)
const
{
  // start with the original demand key
  std::string expandedDemandName(geoPreD2O);
  expandedDemandName = expandedDemandName + multiAttributeDemandSeparator_ + requestDate;
 return expandedDemandName;
d890 6
a895 8
// SCE 6.1
// multi_attribute_demand  ... DEMAND2ORDER function
// append the requestDate onto the end of the dmeandName string 
std::string
LgFrMultiPlantHelper::expandDemandKeyforD2O(const std::string &  geoPreD2O, 
					    const std::string & requestDate,
					    const std::string & sourceLoc)
const
d897 6
a902 7
  // start with the original demand key
  std::string expandedDemandName(geoPreD2O);
  expandedDemandName = 
    sourceLoc + multiAttributeDemandSeparator_ + 
    expandedDemandName + multiAttributeDemandSeparator_ + 
    requestDate;
 return expandedDemandName;
d904 1
d908 11
d920 1
a920 14
// multi_attribute_demand
std::string
LgFrMultiPlantHelper::compressedDemandName(
					   const std::string * demandAttributes[])
const
{
  std::string demandName("");
  int t = 0;
  for (t=0; t<numDemandAttributes_-1; t++)  {
   
    demandName = demandName + multiAttributeDemandSeparator_;
  }
  demandName = demandName + (*demandAttributes)[numDemandAttributes_-1];
 return demandName;
d924 6
a929 7
// multi_attribute_demand
void
LgFrMultiPlantHelper::compressedDemandName(std::string & demandName, 
					   const std::string & customerLoc,
					   const std::string & demandClass,
					   const std::string & demandLevel,
					   const std::string & partClass)
d931 6
a936 5
  demandName = 
    customerLoc + multiAttributeDemandSeparator_
    + demandClass + multiAttributeDemandSeparator_
    + demandLevel + multiAttributeDemandSeparator_
    + partClass;
a938 10
// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::uncompressedDemandNames(
	const std::string & compressedDemandName,
	std::string & customerLoc,
	std::string & demandClass,
	std::string & demandLevel,
	std::string & partClass)
{
  SCETokenizer next(compressedDemandName);
a939 4
  // customerLoc
  customerLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (customerLoc.empty())
    return 0;
a940 4
  // demandClass
  demandClass =  next(multiAttributeDemandSeparator_.c_str());
  if (demandClass.empty())
    return 0;
a941 4
  // demandLevel
  demandLevel =  next(multiAttributeDemandSeparator_.c_str());
  if (demandLevel.empty())
    return 0;
d943 8
a950 4
  // partClass
  partClass =  next(multiAttributeDemandSeparator_.c_str());
  if (partClass.empty())
    return 0;
d952 14
d967 3
a969 1
  return 1;
d974 8
a981 11
// SCE 6.1
// returns a String Suitable for printing as leadingString
// note that it does not expect part and pdf to be in the
// compressed name
// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::populateLeadingString(
					    const std::string & partname,
					    const std::string & pdf,
					    const std::string & compressedDemandName,
					    std::string & leadingString)
d983 2
a984 20
  if (useMultiAttributeDemand_) {
    SCETokenizer next(compressedDemandName);
    
    leadingString = "\"" 
      + partname + "\",\""
      + pdf + "\",";
    
    int a;
    for (a=0; a<numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
    }
    return 1;
  }
d986 4
a989 7
  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + pdf + "\",\"" 
      + compressedDemandName + "\"";
  }
}
d993 7
a999 16

// SCE 6.1
// returns a String Suitable for printing as leadingString for INDP Demand Records
// note that it does not expect part and pdf to be in the compressed name
// returns 0 if unsuccessful, 1 if successful 
// Note: if "useDemand2OrderINDP"=TRUE then we add the requestDate from the demandKey
//        else it is the responsibility of the calling function to append the right request (and commit) date
int
LgFrMultiPlantHelper::populateLeadingStringINDP(
					       const std::string & partname,
					       const std::string & pdf,
					       const std::string & demandName,
					       std::string & leadingString)
{
  if (useMultiAttributeDemand_) {
    SCETokenizer next(demandName);
d1001 6
a1006 15
    leadingString = "\"" 
      + partname + "\",\""
      + pdf + "\",";
    
    int a;
    // !!! Demand to Order has extra key so we go numDemandAttributes_+1
    for (a=0; a<numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
d1008 6
a1013 9
    if (useDemand2OrderINDP_)  {
      // pull the request date off the token and write it without quotes
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      leadingString += "," + nextToken;
    }
    return 1;
a1014 1
  }
a1015 8
  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + pdf + "\",\"" 
      + demandName + "\"";
  }
}
  
d1017 11
d1029 11
d1041 3
d1045 7
a1051 9
// returns a String Suitable for printing as leadingString
// note that it does not expect part and pdf to be in the
// compressed name
// returns 0 if unsuccessful, 1 if successful 
int
LgFrMultiPlantHelper::populateLeadingStringGPD(
					       const std::string & partname,
					       const std::string & geo,
					       std::string & leadingString)
d1053 16
a1068 27
  if (useMultiAttributeDemand_) {
    SCETokenizer next(geo);
    
    leadingString = "\"" 
      + partname + "\",";
    
    int a;
    // !!! Demand to Order has extra key so we go numDemandAttributes_+1
    for (a=0; a<=numDemandAttributes_; a++) {
      std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
      if (nextToken.empty()) {
	return 0;
      }
      if (a>0)  {
	leadingString += ",";
      }
      leadingString += "\""  + nextToken + "\"";
    }
    // pull the request date off the token and write it without quotes
    std::string nextToken = next(multiAttributeDemandSeparator_.c_str());
    if (nextToken.empty()) {
      return 0;
    }
    leadingString += "," + nextToken;
    
    return 1;
  }
d1070 2
a1071 5
  else {
    leadingString = "\"" 
      + partname + "\",\"" 
      + geo + "\"";
  }
a1072 2
  
  
d1074 9
a1082 8
// multi_attribute_demand
void
LgFrMultiPlantHelper::compressedDemandNameWitPdf(std::string & demandName, 
						 const std::string & sourceLoc,
						 const std::string & customerLoc,
						 const std::string & demandClass,
						 const std::string & demandLevel,
						 const std::string & partClass)
d1084 19
a1102 6
  demandName = 
    sourceLoc + multiAttributeDemandSeparator_
    + customerLoc + multiAttributeDemandSeparator_
    + demandClass + multiAttributeDemandSeparator_
    + demandLevel + multiAttributeDemandSeparator_
    + partClass;
d1105 3
a1107 1
// returns 0 if unsuccessful, 1 if successful 
d1109 3
a1111 6
LgFrMultiPlantHelper::uncompressedDemandNamesWithPdf(const std::string & compressedDemandName,
						     std::string & sourceLoc,
						     std::string & customerLoc,
						     std::string & demandClass,
						     std::string & demandLevel,
						     std::string & partClass)
d1113 3
a1115 5
  SCETokenizer next(compressedDemandName);

  // sourceLoc
  sourceLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (sourceLoc.empty())
d1117 2
d1120 9
a1128 8
  // customerLoc
  customerLoc =  next(multiAttributeDemandSeparator_.c_str());
  if (customerLoc.empty())
    return 0;

  // demandClass
  demandClass =  next(multiAttributeDemandSeparator_.c_str());
  if (demandClass.empty())
d1130 2
a1132 4
  // demandLevel
  demandLevel =  next(multiAttributeDemandSeparator_.c_str());
  if (demandLevel.empty())
    return 0;
a1133 4
  // partClass
  partClass =  next(multiAttributeDemandSeparator_.c_str());
  if (partClass.empty())
    return 0;
a1135 2
  return 1;
}
d1137 12
d1150 12
@


1.18
log
@committing latest development of sce 6.1
@
text
@d34 2
d48 2
a49 1
	     const std::string & multiAttributeDemandSeparator)
d55 2
d864 36
d969 147
d3589 15
d3915 1
d3932 1
@


1.17
log
@more fixes for 6.1
@
text
@a275 2
    partAppDataPtr->cycleTimeDays(cycleTimeDays);
    witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) partAppDataPtr);
d277 2
a314 2
    partAppDataPtr->cycleTime(cycleTime);
    witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) partAppDataPtr);
d316 2
d340 1
a340 1
LgFrMultiPlantHelper::calculateVariableOffset(float remainingCycleTimeDaysToAllocate, 
d349 3
a351 1
  // offset is positive or negative
d354 1
a354 1
  if ((0.0001 < remainingCycleTimeDaysToAllocate) && (remainingCycleTimeDaysToAllocate < 0.0001)) {
d358 2
d361 1
a361 1
  if (remainingCycleTimeDaysToAllocate >= 0.0001) {
d363 2
a364 2
    for (tt=t; tt<nPeriods; tt++)  {
      if (remainingCycleTimeDaysToAllocate <= workingDays[tt]) {
d367 1
a367 1
	computedCycleTime += remainingCycleTimeDaysToAllocate/workingDays[tt];
d372 1
a372 1
	remainingCycleTimeDaysToAllocate -= workingDays[tt];
d376 3
a378 3
    // if you get to end of horizon and still ahven't worked off the days, then we need to 
    // estimate this last offset.   
    if (remainingCycleTimeDaysToAllocate > 0.0)  {
d381 1
a381 1
      for (tt=nPeriods-1; tt>=0; tt--)  {
d383 1
a383 1
	  computedCycleTime += remainingCycleTimeDaysToAllocate/workingDays[tt]; 
d394 2
a395 2
    for (tt=nPeriods-1; tt>0; tt--)  {
      if (-remainingCycleTimeDaysToAllocate <= workingDays[tt]) {
d398 6
a403 1
	computedCycleTime += remainingCycleTimeDaysToAllocate/workingDays[tt];
d408 1
a408 1
	remainingCycleTimeDaysToAllocate += workingDays[tt];
d414 2
a415 2
    if (remainingCycleTimeDaysToAllocate < 0.0)  {
      for (tt=0; tt<nPeriods; tt++)  {
d417 5
a421 1
	  computedCycleTime += remainingCycleTimeDaysToAllocate/workingDays[tt]; 
d434 1
a434 1
LgFrMultiPlantHelper::calculateVariableOffset(float remainingCycleTimeDaysToAllocate, 
d439 1
a439 10
  float computedCycleTime = 0.0;
  
  
  // two seperate loops going either forward or back in time depending on whether 
  // offset is positive or negative
  
  // CASE 1: Zero Offset
  if ((0.0001 < remainingCycleTimeDaysToAllocate) && (remainingCycleTimeDaysToAllocate < 0.0001)) {
    return 0.0f;
  }
d441 3
a443 29
  // CASE 2: Positive Offset
  if (remainingCycleTimeDaysToAllocate >= 0.0001) {
    int tt =0;
    for (tt=t; tt<nPeriods; tt++)  {
      if (remainingCycleTimeDaysToAllocate <= theCal.workUnits(tt)) {
	// float percentThreshRoll = .20;
	// FINISH_ME: we can adjust fractional to integer a this point based on rules
	computedCycleTime += remainingCycleTimeDaysToAllocate/theCal.workUnits(tt);
	return computedCycleTime;
      }
      else   {
	computedCycleTime += 1.0;
	remainingCycleTimeDaysToAllocate -= theCal.workUnits(tt);
      }
    }
    
    // if you get to end of horizon and still ahven't worked off the days, then we need to 
    // estimate this last offset.   
    if (remainingCycleTimeDaysToAllocate > 0.0)  {
      // didn't work it all off.  Can't build in this period
      // lets go back to last period with positive working days and use that as basis for future period lengths
      for (tt=nPeriods-1; tt>=0; tt--)  {
	if (theCal.workUnits(tt) > 0) {
	  computedCycleTime += remainingCycleTimeDaysToAllocate/theCal.workUnits(tt); 
	  return computedCycleTime;
	}
      }
      return nPeriods+1;
    }
d446 1
a446 29
  // CASE 3: Negative Offset
  else  {
    int tt =0;
    for (tt=nPeriods-1; tt>0; tt--)  {
      if (-remainingCycleTimeDaysToAllocate <= theCal.workUnits(tt)) {
	// float percentThreshRoll = .20;
	// FINISH_ME: we can adjust fractional to integer a this point based on rules
	computedCycleTime += remainingCycleTimeDaysToAllocate/theCal.workUnits(tt);
	return computedCycleTime;
      }
      else   {
	computedCycleTime -= 1.0;
	remainingCycleTimeDaysToAllocate += theCal.workUnits(tt);
      }
    }
    
    // if you get to beginning of horizon and still ahven't worked off the days, then we need to 
    // estimate this last offset.   
    if (remainingCycleTimeDaysToAllocate < 0.0)  {
      for (tt=0; tt<nPeriods; tt++)  {
	if (theCal.workUnits(tt) > 0) {
	  computedCycleTime += remainingCycleTimeDaysToAllocate/theCal.workUnits(tt); 
	  return computedCycleTime;
	}
      }
      return -nPeriods;
    }
  }
  
a447 1

d3381 5
a3392 1
// set/get the default PDF string
d3400 21
d3709 1
d3725 1
@


1.16
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@d19 3
d97 3
a99 1
    appDataPtr = new LgFrScePartAppData();
d248 3
a250 1
      partAppDataPtr = new LgFrScePartAppData();
d273 3
a275 1
    partAppDataPtr = new LgFrScePartAppData();
d312 3
a314 1
    partAppDataPtr = new LgFrScePartAppData();
d340 1
a340 2
LgFrMultiPlantHelper::calculateVariableOffset(
					      float remainingCycleTimeDaysToAllocate, 
d417 82
@


1.15
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@d254 158
d722 96
@


1.14
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d580 16
d633 64
@


1.13
log
@Preliminary commit for SCE 5.00
@
text
@d28 3
d40 4
a43 1
	     const std::string & defaultPdf)
d46 3
d51 1
a51 1
    // all the work is done in initializer
d564 53
d621 2
a622 2
    const std::string & part,
    const std::string & pdf)
d2991 46
d3308 3
d3323 3
@


1.12
log
@removed the "binning" stuff which is now obsolete
@
text
@d629 1
a629 1
// Return a interplant operation name, given the parent, parentPdf, 
d1627 1
a1627 1
LgFrMultiPlantHelper::isOperationSpecialAlternatePart(
d1896 75
@


1.11
log
@First pass at sce 4.20 function.
@
text
@a404 14
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// returns convenient way to get the nBin Ops 
int
LgFrMultiPlantHelper::nBinOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
{
  LgFrScePartAppData * appDataPtr;
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
    return 0;
  return appDataPtr->nBinOps();
}  
#endif
a651 23
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// Return a bin operation name, given the parent, parentPdf, 
// child, childPdf
std::string
LgFrMultiPlantHelper::binOperationName(
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
const
{
    return 
	parentPdf     +
	pdfSeparator_ +	
	parentMfgPart +
	pdfSeparator_ +
	childPdf      +
	pdfSeparator_ +
	childMfgPart  + 
	pdfSeparator_ +
	"specialBinOperation";
}
#endif
a1675 49
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// Returns 1 if operation is a special bin operation, 0 otherwise
// If returns 1, also sets the marked part and unmarked part and pdf
int
LgFrMultiPlantHelper::isOperationSpecialBin(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf)
{
    witBoolean exists;

    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);

    if (exists == WitFALSE)
	return 0;

    
    SCETokenizer next(fullWitOperationName);

    // parentPdf
    destinationPdf =  next(pdfSeparator_.c_str());
    if (destinationPdf.empty())
	return 0;

    // parent
    destination =  next(pdfSeparator_.c_str());
    if (destination.empty())
	return 0;

    // childPdf
    sourcePdf =  next(pdfSeparator_.c_str());
    if (sourcePdf.empty())
	return 0;

    // child
    source =  next(pdfSeparator_.c_str());
    if (source.empty())
	return 0;

    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial == "specialBinOperation")
	return 1;

    return 0; 
}
#endif
a1702 27
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// +
// Returns 1 if operation is a special bin operation and
//              sets the full pdf-part name for the source part
// Otherwise, returns 0
int
LgFrMultiPlantHelper::binSourcePdfPartName(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName)
{
    std::string  destination;
    std::string  destinationPdf;
    std::string  source;
    std::string  sourcePdf;

    if ( isOperationSpecialBin( theWitRun, fullWitOperationName,
                                       destination, destinationPdf,
                                       source, sourcePdf) ) {
      sourcePdfPartName = pdfPartname( source, sourcePdf);
      return 1;
    }
     
    sourcePdfPartName = "";
    return 0; 
}
#endif
a3107 89
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// 
// returns 1 if the duplicate bin record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the bin bom)
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateBinRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & sourcePdfPartName,
    const std::string & binOperationName,
    float duplicateRecordUsageRate )
{
  int nBoms;
  witGetOperationNBomEntries( theWitRun,
                              binOperationName.c_str(),
                              &nBoms );
  assert ( nBoms == 1 );

  float currentUsageRate;
  witGetBomEntryUsageRate( theWitRun,
                           binOperationName.c_str(),
                           0,
                           &currentUsageRate );

  // if usage rates are not equal, then return 0
  if (( duplicateRecordUsageRate > (currentUsageRate + MULTIPLANTHELPER_FLT_EPS)) ||
      ( duplicateRecordUsageRate < (currentUsageRate - MULTIPLANTHELPER_FLT_EPS))) {
    return (0);
  }

  // the usage rate are equal
  return (1) ;
}

//
// returns 1 if the duplicate bin record's effectivity
//              dates do not overlap with the effectivity
//              dates of bin operation's existing bops
//         0 otherwise
int
LgFrMultiPlantHelper::isDuplicateBinRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & binOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd )
{
  if ( duplicateRecordStart > duplicateRecordEnd )
    return 0;
  
  int nbBops;
  witGetOperationNBopEntries( theWitRun,
                              binOperationName.c_str(),
                              &nbBops );
  
  size_t b = 0; // Pulled out of the for below by RW2STL
  for ( b=0; b<nbBops; b++) {
    int currentBopStart;
    int currentBopEnd;
    
    witGetBopEntryEarliestPeriod( theWitRun,
                                  binOperationName.c_str(),
                                  b,
                                  &currentBopStart);
    
    witGetBopEntryLatestPeriod( theWitRun,
                                binOperationName.c_str(),
                                b,
                                &currentBopEnd);

    // For now, if there's a bop in there with effectivity turned off,
    // we have problems...
    assert ( currentBopStart <= currentBopEnd );

    // if they're not "disjoint", the record's invalid. Return 0.
    if (!( ((duplicateRecordStart < currentBopStart) && 
           (duplicateRecordEnd < currentBopStart))  // before
          ||                                         // or
          ((duplicateRecordStart > currentBopEnd) && // after 
          (duplicateRecordEnd > currentBopEnd))) )

      return 0;
  }
  // none of the records overlapped. the record's valid. Return 1.
  return 1;
}

#endif

@


1.10
log
@4.20 commit: global subs, prioritized explode
@
text
@d146 10
@


1.9
log
@more memory fixes
@
text
@d379 16
d632 24
d1649 54
d3120 91
@


1.8
log
@mand/opt capacity, new selective sets
@
text
@d122 2
a123 2
      portableFree(witDemandVol);
      portableFree(dList[j]);
d125 1
a125 1
    portableFree(dList);
d231 2
a232 2
    portableFree (partList[i]);
  portableFree (partList);
d256 1
a256 1
      portableFree(opList[o]);
d268 1
a268 1
    portableFree(opList[o]);     
d271 1
a271 1
  portableFree (opList);
d300 1
a300 1
  portableFree(gpdWitOperationName);
d329 1
a329 1
  portableFree(gpdWitOperationName);
d360 1
a360 1
  portableFree(gpdWitOperationName);
d451 1
a451 1
    portableFree(child);
d511 1
a511 1
	portableFree(child);
d520 1
a520 1
      portableFree(child);
d2695 2
a2696 2
      portableFree(demandList[i]);
    portableFree(demandList);
d2795 2
a2796 2
      portableFree(demandList[i]);
    portableFree(demandList);
@


1.7
log
@First cut at Selective Features using proportional routing
@
text
@d642 3
a644 2

  // Return an operation namefor the purpose of a modelling trick in Smart Exploder
d655 1
d657 11
d1752 39
d1795 1
a1795 1
LgFrMultiPlantHelper::isOperationSpecialSmartExploderCapacity(
d1822 1
a1822 1
    if (anythingSpecial == "specialSmartExplodeCapacityOperation")
@


1.6
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d2346 54
@


1.5
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1 6
a15 3
#include <rw/rstream.h>
#include <rw/cstring.h>
#include <rw/ctoken.h>
d28 1
a28 1
  sceErrFacility_(NULL)
d36 2
a37 2
	     const RWCString & pdfSeparator,
	     const RWCString & defaultPdf)
d40 1
a40 1
  sceErrFacility_(NULL)
d64 1
a64 1
    const RWCString & fullWitPartname)
d67 2
a68 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d78 1
a78 1
    const RWCString & fullWitPartname,
d82 1
a82 1
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
d84 1
a84 1
  if (appDataPtr == NULL) {
d86 1
a86 1
    witSetPartAppData(theWitRun, fullWitPartname, (void *) appDataPtr);
d94 1
a94 1
    const RWCString & fullWitPartname)
d105 1
a105 1
  LgFrSceDemandAppData * appDataPtr = NULL;
d109 6
a114 5
    witGetPartDemands(theWitRun, fullWitPartname, &nDemands, &dList);
    for (int j=0; j<nDemands; j++) {
      witGetDemandDemandVol(theWitRun, fullWitPartname, dList[j], &witDemandVol);
      witGetDemandAppData(theWitRun, fullWitPartname, dList[j], (void **) &appDataPtr);
      if (appDataPtr != NULL) {
d117 2
a118 1
	for (int t=0; t<nPeriods; t++) {
d127 2
a128 2
      cerr << "SCE9955F PROGRAMMER ERROR: part with negative demands does not\n"
	   << "have a demand with non-NULL appData\n"
d144 1
a144 1
    const RWCString & fullWitPartname)
d147 2
a148 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d160 1
a160 1
    const RWCString & fullWitPartname)
d163 2
a164 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d178 1
a178 1
    const RWCString & fullWitPartname)
d181 2
a182 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d194 1
a194 1
    const RWCString & fullWitOperationName)
d197 2
a198 2
  witGetOperationAppData(theWitRun,  fullWitOperationName, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d218 2
a219 1
  for (int i=0; i<nParts; i++) {
d223 1
a223 1
    if (partAppDataPtr == NULL) {
d245 4
a248 4
  RWCString geo;
  RWCString machine;
  RWCString pdf;
  RWCString featurePart;
d253 2
a254 1
  for (int o=0; o<nOperations; o++) {
d263 1
a263 1
    if (ccOpAppDataPtr == NULL) {
d281 1
a281 1
    const RWCString & specialCustChoiceFeature)
d283 1
a283 1
  RWCString geo, plannerTopLevelPart, pppdf, featurePart;
d290 1
a290 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature, &ncbe);
d295 1
a295 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature, 0, &gpdWitOperationName, &bomIndex);
d298 1
a298 1
  assert(bomAppDataPtr != NULL);
d310 1
a310 1
    const RWCString & specialCustChoiceFeature)
d312 1
a312 1
  RWCString geo, plannerTopLevelPart, pppdf, featurePart;
d319 1
a319 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature, &ncbe);
d324 1
a324 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature, 0, &gpdWitOperationName, &bomIndex);
d327 1
a327 1
  assert(bomAppDataPtr != NULL);
d340 1
a340 1
    const RWCString & specialCustChoiceFeature,
d343 1
a343 1
  RWCString geo, plannerTopLevelPart, pppdf, featurePart;
d350 1
a350 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature, &ncbe);
d355 1
a355 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature, 0, &gpdWitOperationName, &bomIndex);
d358 1
a358 1
  assert(bomAppDataPtr != NULL);
d370 1
a370 1
    const RWCString & fullWitPartname)
d373 2
a374 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d384 1
a384 1
    const RWCString & fullWitPartname)
d387 2
a388 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d398 1
a398 1
    const RWCString & fullWitPartname)
d401 2
a402 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d411 1
a411 1
    const RWCString & fullWitPartname)
d414 2
a415 2
  witGetPartAppData(theWitRun,  fullWitPartname, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
d422 1
a422 1
// feed it a part (without a PDF prepended) and a geo (ie, a demand name)
d424 1
a424 1
RWCString
d427 4
a430 4
    const RWCString & plannerPartName,
    const RWCString & geo,
    const RWCString & fileName, 
    const RWCString & dataLine, 
d437 1
a437 1
    RWCString geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
d445 1
a445 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.data(), &nBom);
d448 1
a448 1
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName, 0, &child);
d450 1
a450 1
    RWCString theSource(child);
d458 1
a458 1
// feed it a part (without a PDF prepended) and a geo (ie, a demand name)
d462 1
a462 1
RWCString
d465 2
a466 2
    const RWCString & plannerPartName,
    const RWCString & geo,
d470 2
a471 2
    const RWCString & fileName, 
    const RWCString & dataLine, 
d476 1
a476 1
    RWCString mfgTopLevelBuild;
d481 1
a481 1
    RWCString geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
d496 1
a496 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName, &nBom);
d499 2
a500 1
    for (int j=0; j<nBom; j++)  {
d505 4
a508 4
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName, j, &child);
      RWCString pp;
      RWCString g;
      RWCString bb;
d514 2
a515 2
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName, j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName, j, &bomEnd);
d518 1
a518 1
        witGetBomEntryUsageTime(theWitRun, geoPlannerDemandPartName, j, &offset);
d521 1
a521 1
      if (! mfgTopLevelBuild.isNull())
d526 1
a526 1
    if (mfgTopLevelBuild.isNull())   {
d545 1
a545 1
RWCString
d547 2
a548 2
    const RWCString & part,
    const RWCString & pdf)
d554 1
a554 1
RWCString
d556 2
a557 2
    const RWCString & operation,
    const RWCString & pdf)
d564 1
a564 1
RWCString
d566 2
a567 2
    const RWCString & plannerPart,
    const RWCString & geo)
d579 1
a579 1
RWCString
d581 2
a582 2
    const RWCString & plannerPart,
    const RWCString & geo)
d596 1
a596 1
RWCString
d598 4
a601 4
    const RWCString & parentMfgPart,
    const RWCString & parentPdf,
    const RWCString & childMfgPart,
    const RWCString & childPdf)
d619 1
a619 1
RWCString
d621 4
a624 4
    const RWCString & parentMfgPart,
    const RWCString & parentPdf,
    const RWCString & childMfgPart,
    const RWCString & childPdf)
d644 1
a644 1
RWCString
d646 1
a646 1
    const RWCString & theFullCapacityName)
d660 1
a660 1
RWCString
d662 4
a665 4
    const RWCString & realPart,
    const RWCString & realPartPdf,
    const RWCString & aggPart,
    const RWCString & aggPdf)
d682 1
a682 1
RWCString
d684 2
a685 2
    const RWCString & thePart,
    const RWCString & pdf)
d696 1
a696 1
RWCString
d698 1
a698 1
    const RWCString & pdf)
d718 1
a718 1
RWCString
d720 1
a720 1
    const RWCString & pdf)
d736 1
a736 1
RWCString
d738 3
a740 3
    const RWCString & geo,
    const RWCString & plannerPart,
    const RWCString & featurePart)
d764 1
a764 1
RWCString
d766 3
a768 3
    const RWCString & geo,
    const RWCString & plannerPart,
    const RWCString & featurePart)
d785 1
a785 1
RWCString
d787 4
a790 4
    const RWCString & machine,
    const RWCString & geo,
    const RWCString & featurePart,
    const RWCString & pdf)
d810 5
a814 5
    const RWCString & fullWitPartname,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart)
d818 1
a818 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d823 1
a823 1
  RWCTokenizer next(fullWitPartname);
d826 2
a827 2
  geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d831 2
a832 2
  machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d836 2
a837 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d841 2
a842 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d845 1
a845 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d859 5
a863 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart)
d867 1
a867 1
  witGetOperationExists(theWitRun, fullWitOperation, &exists);
d872 1
a872 1
  RWCTokenizer next(fullWitOperation);
d875 2
a876 2
  geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d880 2
a881 2
  machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d885 2
a886 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d890 2
a891 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d894 1
a894 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d912 5
a916 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart)
d920 1
a920 1
  witGetOperationExists(theWitRun, fullWitOperation, &exists);
d925 1
a925 1
  RWCTokenizer next(fullWitOperation);
d928 2
a929 2
  geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d933 2
a934 2
  machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d938 2
a939 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d943 2
a944 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d947 1
a947 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d964 1
a964 1
    const RWCString & fullWitPartname)
d968 1
a968 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d974 1
a974 1
  RWCTokenizer next(fullWitPartname);
d978 2
a979 2
  RWCString geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d983 2
a984 2
  RWCString machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d988 2
a989 2
  RWCString pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d993 2
a994 2
  RWCString featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d997 1
a997 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1013 1
a1013 1
    const RWCString & fullWitPartname)
d1017 1
a1017 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1023 1
a1023 1
  RWCTokenizer next(fullWitPartname);
d1027 2
a1028 2
  RWCString geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d1032 2
a1033 2
  RWCString machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d1037 2
a1038 2
  RWCString pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d1042 2
a1043 2
  RWCString featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d1046 1
a1046 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1060 1
a1060 1
RWCString
d1062 4
a1065 4
    const RWCString & machine,
    const RWCString & geo,
    const RWCString & featurePart,
    const RWCString & pdf)
d1083 1
a1083 1
RWCString
d1085 3
a1087 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d1102 1
a1102 1
RWCString
d1104 3
a1106 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d1121 1
a1121 1
RWCString
d1123 3
a1125 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d1140 1
a1140 1
RWCString
d1142 4
a1145 4
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory,
    const RWCString & option)
d1162 1
a1162 1
RWCString
d1164 4
a1167 4
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory,
    const RWCString & option)
d1189 1
a1189 1
LgFrMultiPlantHelper::partType(const RWCString & pdfPart)
d1200 1
a1200 1
LgFrMultiPlantHelper::partType(const RWCString & part, const RWCString & pdf)
d1211 3
a1213 3
    const RWCString & partName, 
    const RWCString & fileName, 
    const RWCString & dataLine, 
d1221 1
a1221 1
    witGetPartExists(theWitRun, partName.data(), &exists);
d1247 4
a1250 4
    const RWCString & part,
    const RWCString & pdf,
    const RWCString & filename, 
    const RWCString & dataLine, 
d1255 1
a1255 1
    RWCString pdfPart = pdf + pdfSeparator_ + part;
d1290 1
a1290 1
    const RWCString & fullWitPartname)
d1295 1
a1295 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d1301 3
a1303 3
    RWCTokenizer next(fullWitPartname);
    RWCString thePdf = next(pdfSeparator_.data());
    assert (! thePdf.isNull());
d1305 2
a1306 2
    RWCString thePartName = next(pdfSeparator_.data());
    assert (! thePartName.isNull());
d1308 2
a1309 2
    RWCString anythingSpecial = next(pdfSeparator_.data());
    if (anythingSpecial.isNull())  
d1335 3
a1337 3
    const RWCString & fullWitOperationName,
    RWCString & thePdf,
    RWCString & theOperationName)
d1342 1
a1342 1
    witGetOperationExists(theWitRun, fullWitOperationName.data(), &exists);
d1348 3
a1350 3
    RWCTokenizer next(fullWitOperationName);
    thePdf = next(pdfSeparator_.data());
    if (thePdf.isNull())
d1353 2
a1354 2
    theOperationName = next(pdfSeparator_.data());
    if (theOperationName.isNull())
d1357 2
a1358 2
    RWCString anythingSpecial = next(pdfSeparator_.data());
    if (anythingSpecial.isNull())  
d1370 3
a1372 3
    const RWCString & fullWitOperationName,
    RWCString & thePdf,
    RWCString & theOperationName)
d1390 1
a1390 1
    const RWCString & fullWitPartname)
d1396 1
a1396 1
    witGetPartExists(theWitRun, fullWitPartname, &exists);
d1401 1
a1401 1
    witGetPartCategory(theWitRun, fullWitPartname, &category);
d1407 3
a1409 3
    RWCTokenizer next(fullWitPartname);
    RWCString thePdf = next(pdfSeparator_.data());
    assert (! thePdf.isNull());
d1411 2
a1412 2
    RWCString thePartName = next(pdfSeparator_.data());
    assert (! thePartName.isNull());
d1414 2
a1415 2
    RWCString anythingSpecial = next(pdfSeparator_.data());
    if (anythingSpecial.isNull())  
d1427 3
a1429 3
    const RWCString & fullWitPartname,
    RWCString & plannerPart,
    RWCString & geo)
d1433 1
a1433 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d1439 1
a1439 1
    RWCTokenizer next(fullWitPartname);
d1442 2
a1443 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d1447 2
a1448 2
    plannerPart =  next(pdfSeparator_.data());
    if (plannerPart.isNull())
d1452 1
a1452 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1466 3
a1468 3
    const RWCString & fullWitPartname,
    RWCString & plannerPart,
    RWCString & geo)
d1472 1
a1472 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d1478 1
a1478 1
    RWCTokenizer next(fullWitPartname);
d1481 2
a1482 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d1486 2
a1487 2
    plannerPart =  next(pdfSeparator_.data());
    if (plannerPart.isNull())
d1491 1
a1491 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1505 5
a1509 5
    const RWCString & fullWitOperationName,
    RWCString & realPart,
    RWCString & realPartPdf,
    RWCString & aggPart,
    RWCString & aggPdf)
d1513 1
a1513 1
    witGetOperationExists(theWitRun, fullWitOperationName, &exists);
d1519 1
a1519 1
    RWCTokenizer next(fullWitOperationName);
d1522 2
a1523 2
    realPartPdf =  next(pdfSeparator_.data());
    if (realPartPdf.isNull())
d1527 2
a1528 2
    realPart =  next(pdfSeparator_.data());
    if (realPart.isNull())
d1532 2
a1533 2
    aggPdf =  next(pdfSeparator_.data());
    if (aggPdf.isNull())
d1537 2
a1538 2
    aggPart =  next(pdfSeparator_.data());
    if (aggPart.isNull())
d1541 1
a1541 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1554 5
a1558 5
    const RWCString & fullWitOperationName,
    RWCString & destination,
    RWCString & destinationPdf,
    RWCString & source,
    RWCString & sourcePdf)
d1562 1
a1562 1
    witGetOperationExists(theWitRun, fullWitOperationName.data(), &exists);
d1568 1
a1568 1
    RWCTokenizer next(fullWitOperationName);
d1571 2
a1572 2
    destinationPdf =  next(pdfSeparator_.data());
    if (destinationPdf.isNull())
d1576 2
a1577 2
    destination =  next(pdfSeparator_.data());
    if (destination.isNull())
d1581 2
a1582 2
    sourcePdf =  next(pdfSeparator_.data());
    if (sourcePdf.isNull())
d1586 2
a1587 2
    source =  next(pdfSeparator_.data());
    if (source.isNull())
d1590 1
a1590 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1602 5
a1606 5
    const RWCString & fullWitOperationName,
    RWCString & destination,
    RWCString & destinationPdf,
    RWCString & source,
    RWCString & sourcePdf)
d1610 1
a1610 1
    witGetOperationExists(theWitRun, fullWitOperationName.data(), &exists);
d1616 1
a1616 1
    RWCTokenizer next(fullWitOperationName);
d1619 2
a1620 2
    destinationPdf =  next(pdfSeparator_.data());
    if (destinationPdf.isNull())
d1624 2
a1625 2
    destination =  next(pdfSeparator_.data());
    if (destination.isNull())
d1629 2
a1630 2
    sourcePdf =  next(pdfSeparator_.data());
    if (sourcePdf.isNull())
d1634 2
a1635 2
    source =  next(pdfSeparator_.data());
    if (source.isNull())
d1638 1
a1638 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1653 2
a1654 2
    const RWCString & fullWitOperationName,
    RWCString & sourcePdfPartName)
d1656 4
a1659 4
    RWCString  destination;
    RWCString  destinationPdf;
    RWCString  source;
    RWCString  sourcePdf;
d1668 1
a1668 1
    sourcePdfPartName = NULL;
d1680 2
a1681 2
    const RWCString & fullWitOperationName,
    RWCString & sourcePdfPartName)
d1683 4
a1686 4
    RWCString  destination;
    RWCString  destinationPdf;
    RWCString  source;
    RWCString  sourcePdf;
d1695 1
a1695 1
    sourcePdfPartName = NULL;
d1706 3
a1708 3
    const RWCString & fullWitOperationName,
    RWCString & plannerPart,
    RWCString & geo)
d1712 1
a1712 1
    witGetOperationExists(theWitRun, fullWitOperationName, &exists);
d1718 1
a1718 1
    RWCTokenizer next(fullWitOperationName);
d1721 2
a1722 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d1726 2
a1727 2
    plannerPart =  next(pdfSeparator_.data());
    if (plannerPart.isNull())
d1731 1
a1731 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1745 3
a1747 3
    const RWCString & fullWitOperationName,
    RWCString & theCapacity,
    RWCString & pdf)
d1751 1
a1751 1
    witGetOperationExists(theWitRun, fullWitOperationName.data(), &exists);
d1757 1
a1757 1
    RWCTokenizer next(fullWitOperationName);
d1760 2
a1761 2
    pdf =  next(pdfSeparator_.data());
    if (pdf.isNull())
d1765 2
a1766 2
    theCapacity =  next(pdfSeparator_.data());
    if (theCapacity.isNull())
d1769 1
a1769 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d1797 1
a1797 1
    const RWCString & fullWitPartname)
d1799 1
a1799 1
  RWCString d1,d2,d3;
d1823 2
a1824 2
    const RWCString & fullWitPartname,
    RWCString & pdf)
d1828 1
a1828 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1833 1
a1833 1
  RWCTokenizer next(fullWitPartname);
d1836 2
a1837 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d1841 2
a1842 2
  RWCString dpn =  next(pdfSeparator_.data());
  if (dpn.isNull())
d1845 1
a1845 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1859 2
a1860 2
    const RWCString & fullWitPartname,
    RWCString & pdf)
d1864 1
a1864 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1869 1
a1869 1
  RWCTokenizer next(fullWitPartname);
d1872 2
a1873 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d1877 2
a1878 2
  RWCString dpn =  next(pdfSeparator_.data());
  if (dpn.isNull())
d1881 1
a1881 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1895 4
a1898 4
    const RWCString & fullWitPartname,
    RWCString & geo,
    RWCString & plannerPart,
    RWCString & featurePart)
d1902 1
a1902 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1907 1
a1907 1
  RWCTokenizer next(fullWitPartname);
d1910 2
a1911 2
  geo = next(pdfSeparator_.data());
  if (geo.isNull())
d1915 2
a1916 2
  plannerPart =  next(pdfSeparator_.data());
  if (plannerPart.isNull())
d1920 2
a1921 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d1924 1
a1924 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1939 4
a1942 4
    const RWCString & fullWitPartname,
    RWCString & geo,
    RWCString & plannerPart,
    RWCString & featurePart)
d1946 1
a1946 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1951 1
a1951 1
  RWCTokenizer next(fullWitPartname);
d1954 2
a1955 2
  geo = next(pdfSeparator_.data());
  if (geo.isNull())
d1959 2
a1960 2
  plannerPart =  next(pdfSeparator_.data());
  if (plannerPart.isNull())
d1964 2
a1965 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d1968 1
a1968 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d1986 5
a1990 5
    const RWCString & fullWitPartname,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart)
d1994 1
a1994 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d1999 1
a1999 1
  RWCTokenizer next(fullWitPartname);
d2002 2
a2003 2
  geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d2007 2
a2008 2
  machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d2012 2
a2013 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d2017 2
a2018 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d2021 1
a2021 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d2035 5
a2039 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart)
d2043 1
a2043 1
  witGetOperationExists(theWitRun, fullWitOperation, &exists);
d2048 1
a2048 1
  RWCTokenizer next(fullWitOperation);
d2051 2
a2052 2
  geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d2056 2
a2057 2
  machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d2061 2
a2062 2
  pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d2066 2
a2067 2
  featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d2070 1
a2070 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d2085 1
a2085 1
    const RWCString & fullWitPartname)
d2089 1
a2089 1
  witGetPartExists(theWitRun, fullWitPartname, &exists);
d2095 1
a2095 1
  RWCTokenizer next(fullWitPartname);
d2099 2
a2100 2
  RWCString geo =  next(pdfSeparator_.data());
  if (geo.isNull())
d2104 2
a2105 2
  RWCString machine =  next(pdfSeparator_.data());
  if (machine.isNull())
d2109 2
a2110 2
  RWCString pdf =  next(pdfSeparator_.data());
  if (pdf.isNull())
d2114 2
a2115 2
  RWCString featurePart =  next(pdfSeparator_.data());
  if (featurePart.isNull())
d2118 1
a2118 1
  RWCString anythingSpecial = next(pdfSeparator_.data());
d2132 1
a2132 1
    const RWCString & fullWitPartname)
d2136 1
a2136 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2142 1
a2142 1
    RWCTokenizer next(fullWitPartname);
d2145 2
a2146 2
    RWCString pdf =  next(pdfSeparator_.data());
    if (pdf.isNull())
d2150 2
a2151 2
    RWCString aPart =  next(pdfSeparator_.data());
    if (aPart.isNull())
d2154 1
a2154 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2167 4
a2170 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory)
d2174 1
a2174 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2180 1
a2180 1
    RWCTokenizer next(fullWitPartname);
d2183 2
a2184 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d2188 2
a2189 2
    plannerTopLevelBuild =  next(pdfSeparator_.data());
    if (plannerTopLevelBuild.isNull())
d2193 2
a2194 2
    bbCategory =  next(pdfSeparator_.data());
    if (bbCategory.isNull())
d2197 1
a2197 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2214 4
a2217 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory)
d2221 1
a2221 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2227 1
a2227 1
    RWCTokenizer next(fullWitPartname);
d2230 2
a2231 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d2235 2
a2236 2
    plannerTopLevelBuild =  next(pdfSeparator_.data());
    if (plannerTopLevelBuild.isNull())
d2240 2
a2241 2
    bbCategory =  next(pdfSeparator_.data());
    if (bbCategory.isNull())
d2244 1
a2244 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2256 4
a2259 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory)
d2263 1
a2263 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2269 1
a2269 1
    RWCTokenizer next(fullWitPartname);
d2272 2
a2273 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d2277 2
a2278 2
    plannerTopLevelBuild =  next(pdfSeparator_.data());
    if (plannerTopLevelBuild.isNull())
d2282 2
a2283 2
    bbCategory =  next(pdfSeparator_.data());
    if (bbCategory.isNull())
d2286 1
a2286 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2300 5
a2304 5
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory,
    RWCString & mfgOptionPart)
d2308 1
a2308 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2314 1
a2314 1
    RWCTokenizer next(fullWitPartname);
d2317 2
a2318 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d2322 2
a2323 2
    plannerTopLevelBuild =  next(pdfSeparator_.data());
    if (plannerTopLevelBuild.isNull())
d2327 2
a2328 2
    bbCategory =  next(pdfSeparator_.data());
    if (bbCategory.isNull())
d2332 2
a2333 2
    mfgOptionPart =  next(pdfSeparator_.data());
    if (mfgOptionPart.isNull())
d2337 1
a2337 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2352 5
a2356 5
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory,
    RWCString & mfgOptionPart)
d2360 1
a2360 1
    witGetPartExists(theWitRun, fullWitPartname.data(), &exists);
d2366 1
a2366 1
    RWCTokenizer next(fullWitPartname);
d2369 2
a2370 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull())
d2374 2
a2375 2
    plannerTopLevelBuild =  next(pdfSeparator_.data());
    if (plannerTopLevelBuild.isNull())
d2379 2
a2380 2
    bbCategory =  next(pdfSeparator_.data());
    if (bbCategory.isNull())
d2384 2
a2385 2
    mfgOptionPart =  next(pdfSeparator_.data());
    if (mfgOptionPart.isNull())
d2389 1
a2389 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2403 1
a2403 1
    const RWCString & fullWitPartname)
d2415 1
a2415 1
    witGetOperationExists(theWitRun, fullWitPartname, &exists);
d2425 3
a2427 3
    const RWCString & pdfOperationName, 
    const RWCString & fileName, 
    const RWCString & dataLine, 
d2435 1
a2435 1
    witGetOperationExists(theWitRun, pdfOperationName.data(), &exists);
d2457 4
a2460 4
    const RWCString & operationName,
    const RWCString & pdf,
    const RWCString & filename, 
    const RWCString & dataLine, 
d2465 1
a2465 1
    RWCString pdfOperation = pdf + pdfSeparator_ + operationName;
d2491 3
a2493 3
    const RWCString & pdfOperationName, 
    const RWCString & fileName, 
    const RWCString & dataLine, 
d2502 1
a2502 1
    witGetPartExists(theWitRun, pdfOperationName.data(), &exists);
d2523 1
a2523 1
RWCString
d2525 1
a2525 1
    const RWCString & fullWitPartName)
d2528 2
a2529 2
    RWCString  plannerPart;
    RWCString  geo;
d2531 1
a2531 1
    RWCTokenizer next(fullWitPartName);
d2534 2
a2535 2
    geo =  next(pdfSeparator_.data());
    assert (! (geo.isNull()));
d2538 2
a2539 2
    plannerPart =  next(pdfSeparator_.data());
    assert (! (plannerPart.isNull()));
d2557 4
a2560 4
    const RWCString & fullWitPartName,
    const RWCString & fullWitDemandName,
    RWCString & plannerPart,
    RWCString & geo)
d2566 1
a2566 1
    witGetPartExists(theWitRun, fullWitPartName.data(), &partExists);
d2574 1
a2574 1
    witGetPartDemands ( theWitRun, fullWitPartName, &lenDemandList, &demandList);
d2579 2
a2580 1
    for (int i=0; i<lenDemandList; i++){
d2596 1
a2596 1
    RWCTokenizer next(fullWitDemandName);
d2599 2
a2600 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull()) {
d2605 2
a2606 2
    plannerPart =  next(pdfSeparator_.data());
    if (plannerPart.isNull()){
d2611 1
a2611 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2625 1
a2625 1
RWCString
d2627 1
a2627 1
    const RWCString & fullWitPartName)
d2630 2
a2631 2
    RWCString  plannerPart;
    RWCString  geo;
d2633 1
a2633 1
    RWCTokenizer next(fullWitPartName);
d2636 2
a2637 2
    geo =  next(pdfSeparator_.data());
    assert (! (geo.isNull()));
d2640 2
a2641 2
    plannerPart =  next(pdfSeparator_.data());
    assert (! (plannerPart.isNull()));
d2657 4
a2660 4
    const RWCString & fullWitPartName,
    const RWCString & fullWitDemandName,
    RWCString & plannerPart,
    RWCString & geo)
d2666 1
a2666 1
    witGetPartExists(theWitRun, fullWitPartName.data(), &partExists);
d2674 1
a2674 1
    witGetPartDemands ( theWitRun, fullWitPartName, &lenDemandList, &demandList);
d2679 2
a2680 1
    for (int i=0; i<lenDemandList; i++){
d2696 1
a2696 1
    RWCTokenizer next(fullWitDemandName);
d2699 2
a2700 2
    geo =  next(pdfSeparator_.data());
    if (geo.isNull()) {
d2705 2
a2706 2
    plannerPart =  next(pdfSeparator_.data());
    if (plannerPart.isNull()){
d2711 1
a2711 1
    RWCString anythingSpecial = next(pdfSeparator_.data());
d2727 1
a2727 1
RWCString
d2736 1
a2736 1
    const RWCString & pdfSeparator)
d2742 1
a2742 1
RWCString
d2751 1
a2751 1
    const RWCString & defaultPdf)
d2759 1
a2759 1
RWCString 
d2771 2
a2772 2
RWCString 
LgFrMultiPlantHelper::pdf(const RWCString & pdfPart)
d2775 3
a2777 3
    RWCTokenizer next(pdfPart);
    RWCString thePdf = next(pdfSeparator_.data());
    assert (! thePdf.isNull());
d2779 2
a2780 2
    RWCString thePartName = next(pdfSeparator_.data());
    if (thePartName.isNull())
d2787 1
a2787 1
RWCString 
d2791 1
a2791 1
    return this->pdf(RWCString(pdfPart));
d2797 2
a2798 2
RWCString 
LgFrMultiPlantHelper::partname(const RWCString & pdfPart)
d2801 3
a2803 3
    RWCTokenizer next(pdfPart);
    RWCString thePdf = next(pdfSeparator_.data());
    assert (! thePdf.isNull());
d2805 2
a2806 2
    RWCString thePartName = next(pdfSeparator_.data());
    if (thePartName.isNull())
d2817 2
a2818 2
RWCString 
LgFrMultiPlantHelper::operationName(const RWCString & pdfOperation)
d2827 2
a2828 2
RWBoolean
LgFrMultiPlantHelper::isPartnameEqual(const RWCString & left, const RWCString & right)
d2842 2
a2843 2
    const RWCString & sourcePdfPartName,
    const RWCString & interplantOperationName,
d2848 1
a2848 1
                              interplantOperationName.data(),
d2854 1
a2854 1
                           interplantOperationName.data(),
d2876 1
a2876 1
    const RWCString & interplantOperationName,
d2885 1
a2885 1
                              interplantOperationName.data(),
d2888 2
a2889 1
  for ( size_t b=0; b<nbBops; b++) {
d2894 1
a2894 1
                                  interplantOperationName.data(),
d2899 1
a2899 1
                                interplantOperationName.data(),
d2929 2
a2930 2
    const RWCString & sourcePdfPartName,
    const RWCString & binOperationName,
d2935 1
a2935 1
                              binOperationName.data(),
d2941 1
a2941 1
                           binOperationName.data(),
d2963 1
a2963 1
    const RWCString & binOperationName,
d2972 1
a2972 1
                              binOperationName.data(),
d2975 2
a2976 1
  for ( size_t b=0; b<nbBops; b++) {
d2981 1
a2981 1
                                  binOperationName.data(),
d2986 1
a2986 1
                                binOperationName.data(),
d3066 4
a3069 4
 RWCString testPart1("POK_xx123");
 RWCString testPart2("FUJ_xx123");
 RWCString testPart3("xx123");
 RWCString testPart4("WW_yy123");
d3075 3
a3077 3
 assert(multiPlantHelper.isPartnameEqual(testPart1.data(), testPart3));
 assert(multiPlantHelper.isPartnameEqual(testPart1.data(), testPart3.data()));
 assert(multiPlantHelper.isPartnameEqual(testPart1, testPart3.data()));
d3081 1
a3081 1
 assert(multiPlantHelper.pdf(testPart3.data()) == "WW");
@


1.5.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d10 3
d25 1
a25 1
  sceErrFacility_(0)
d33 2
a34 2
	     const std::string & pdfSeparator,
	     const std::string & defaultPdf)
d37 1
a37 1
  sceErrFacility_(0)
d61 1
a61 1
    const std::string & fullWitPartname)
d64 2
a65 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d75 1
a75 1
    const std::string & fullWitPartname,
d79 1
a79 1
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
d81 1
a81 1
  if (appDataPtr == 0) {
d83 1
a83 1
    witSetPartAppData(theWitRun, fullWitPartname.c_str(), (void *) appDataPtr);
d91 1
a91 1
    const std::string & fullWitPartname)
d102 1
a102 1
  LgFrSceDemandAppData * appDataPtr = 0;
d106 5
a110 6
    witGetPartDemands(theWitRun, fullWitPartname.c_str(), &nDemands, &dList);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
      witGetDemandDemandVol(theWitRun, fullWitPartname.c_str(), dList[j], &witDemandVol);
      witGetDemandAppData(theWitRun, fullWitPartname.c_str(), dList[j], (void **) &appDataPtr);
      if (appDataPtr != 0) {
d113 1
a113 2
	int t = 0; // Pulled out of the for below by RW2STL
	for (t=0; t<nPeriods; t++) {
d123 1
a123 1
	   << "have a demand with non-0 appData\n"
d139 1
a139 1
    const std::string & fullWitPartname)
d142 2
a143 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d155 1
a155 1
    const std::string & fullWitPartname)
d158 2
a159 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d173 1
a173 1
    const std::string & fullWitPartname)
d176 2
a177 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d189 1
a189 1
    const std::string & fullWitOperationName)
d192 2
a193 2
  witGetOperationAppData(theWitRun,  fullWitOperationName.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d213 1
a213 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d217 1
a217 1
    if (partAppDataPtr == 0) {
d239 4
a242 4
  std::string geo;
  std::string machine;
  std::string pdf;
  std::string featurePart;
d247 1
a247 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
d256 1
a256 1
    if (ccOpAppDataPtr == 0) {
d274 1
a274 1
    const std::string & specialCustChoiceFeature)
d276 1
a276 1
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
d283 1
a283 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
d288 1
a288 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
d291 1
a291 1
  assert(bomAppDataPtr != 0);
d303 1
a303 1
    const std::string & specialCustChoiceFeature)
d305 1
a305 1
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
d312 1
a312 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
d317 1
a317 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
d320 1
a320 1
  assert(bomAppDataPtr != 0);
d333 1
a333 1
    const std::string & specialCustChoiceFeature,
d336 1
a336 1
  std::string geo, plannerTopLevelPart, pppdf, featurePart;
d343 1
a343 1
  witGetPartNConsumingBomEntries(theWitRun, specialCustChoiceFeature.c_str(), &ncbe);
d348 1
a348 1
  witGetPartConsumingBomEntry(theWitRun, specialCustChoiceFeature.c_str(), 0, &gpdWitOperationName, &bomIndex);
d351 1
a351 1
  assert(bomAppDataPtr != 0);
d363 1
a363 1
    const std::string & fullWitPartname)
d366 2
a367 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d377 1
a377 1
    const std::string & fullWitPartname)
d380 2
a381 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d391 1
a391 1
    const std::string & fullWitPartname)
d394 2
a395 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d404 1
a404 1
    const std::string & fullWitPartname)
d407 2
a408 2
  witGetPartAppData(theWitRun,  fullWitPartname.c_str(), (void **) &appDataPtr);
  if (appDataPtr == 0) 
d415 1
a415 1
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
d417 1
a417 1
std::string
d420 4
a423 4
    const std::string & plannerPartName,
    const std::string & geo,
    const std::string & fileName, 
    const std::string & dataLine, 
d430 1
a430 1
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
d438 1
a438 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d441 1
a441 1
    witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), 0, &child);
d443 1
a443 1
    std::string theSource(child);
d451 1
a451 1
// feed it a part (without a PDF prepended) and a geo.c_str() (ie, a demand name)
d455 1
a455 1
std::string
d458 2
a459 2
    const std::string & plannerPartName,
    const std::string & geo,
d463 2
a464 2
    const std::string & fileName, 
    const std::string & dataLine, 
d469 1
a469 1
    std::string mfgTopLevelBuild;
d474 1
a474 1
    std::string geoPlannerDemandPartName = this->geoPlannerDemandPartName(plannerPartName, geo);
d489 1
a489 1
    witGetPartNBomEntries(theWitRun, geoPlannerDemandPartName.c_str(), &nBom);
d492 1
a492 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++)  {
d497 4
a500 4
      witGetBomEntryConsumedPart(theWitRun, geoPlannerDemandPartName.c_str(), j, &child);
      std::string pp;
      std::string g;
      std::string bb;
d506 2
a507 2
      witGetBomEntryEarliestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomStart);
      witGetBomEntryLatestPeriod(theWitRun, geoPlannerDemandPartName.c_str(), j, &bomEnd);
d510 1
a510 1
        witGetBomEntryUsageTime(theWitRun, geoPlannerDemandPartName.c_str(), j, &offset);
d513 1
a513 1
      if (! mfgTopLevelBuild.empty())
d518 1
a518 1
    if (mfgTopLevelBuild.empty())   {
d537 1
a537 1
std::string
d539 2
a540 2
    const std::string & part,
    const std::string & pdf)
d546 1
a546 1
std::string
d548 2
a549 2
    const std::string & operation,
    const std::string & pdf)
d556 1
a556 1
std::string
d558 2
a559 2
    const std::string & plannerPart,
    const std::string & geo)
d571 1
a571 1
std::string
d573 2
a574 2
    const std::string & plannerPart,
    const std::string & geo)
d588 1
a588 1
std::string
d590 4
a593 4
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
d611 1
a611 1
std::string
d613 4
a616 4
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
d636 1
a636 1
std::string
d638 1
a638 1
    const std::string & theFullCapacityName)
d652 1
a652 1
std::string
d654 4
a657 4
    const std::string & realPart,
    const std::string & realPartPdf,
    const std::string & aggPart,
    const std::string & aggPdf)
d674 1
a674 1
std::string
d676 2
a677 2
    const std::string & thePart,
    const std::string & pdf)
d688 1
a688 1
std::string
d690 1
a690 1
    const std::string & pdf)
d710 1
a710 1
std::string
d712 1
a712 1
    const std::string & pdf)
d728 1
a728 1
std::string
d730 3
a732 3
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
d756 1
a756 1
std::string
d758 3
a760 3
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
d777 1
a777 1
std::string
d779 4
a782 4
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
d802 5
a806 5
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
d810 1
a810 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d815 1
a815 1
  SCETokenizer next(fullWitPartname);
d818 2
a819 2
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d823 2
a824 2
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d828 2
a829 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d833 2
a834 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d837 1
a837 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d851 5
a855 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
d859 1
a859 1
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);
d864 1
a864 1
  SCETokenizer next(fullWitOperation);
d867 2
a868 2
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d872 2
a873 2
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d877 2
a878 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d882 2
a883 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d886 1
a886 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d904 5
a908 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
d912 1
a912 1
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);
d917 1
a917 1
  SCETokenizer next(fullWitOperation);
d920 2
a921 2
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d925 2
a926 2
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d930 2
a931 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d935 2
a936 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d939 1
a939 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d956 1
a956 1
    const std::string & fullWitPartname)
d960 1
a960 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d966 1
a966 1
  SCETokenizer next(fullWitPartname);
d970 2
a971 2
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d975 2
a976 2
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d980 2
a981 2
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d985 2
a986 2
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d989 1
a989 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1005 1
a1005 1
    const std::string & fullWitPartname)
d1009 1
a1009 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1015 1
a1015 1
  SCETokenizer next(fullWitPartname);
d1019 2
a1020 2
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d1024 2
a1025 2
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d1029 2
a1030 2
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d1034 2
a1035 2
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d1038 1
a1038 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1052 1
a1052 1
std::string
d1054 4
a1057 4
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
d1075 1
a1075 1
std::string
d1077 3
a1079 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d1094 1
a1094 1
std::string
d1096 3
a1098 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d1113 1
a1113 1
std::string
d1115 3
a1117 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d1132 1
a1132 1
std::string
d1134 4
a1137 4
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
d1154 1
a1154 1
std::string
d1156 4
a1159 4
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
d1181 1
a1181 1
LgFrMultiPlantHelper::partType(const std::string & pdfPart)
d1192 1
a1192 1
LgFrMultiPlantHelper::partType(const std::string & part, const std::string & pdf)
d1203 3
a1205 3
    const std::string & partName, 
    const std::string & fileName, 
    const std::string & dataLine, 
d1213 1
a1213 1
    witGetPartExists(theWitRun, partName.c_str(), &exists);
d1239 4
a1242 4
    const std::string & part,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
d1247 1
a1247 1
    std::string pdfPart = pdf + pdfSeparator_ + part;
d1282 1
a1282 1
    const std::string & fullWitPartname)
d1287 1
a1287 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1293 3
a1295 3
    SCETokenizer next(fullWitPartname);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());
d1297 2
a1298 2
    std::string thePartName = next(pdfSeparator_.c_str());
    assert (! thePartName.empty());
d1300 2
a1301 2
    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
d1327 3
a1329 3
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
d1334 1
a1334 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1340 3
a1342 3
    SCETokenizer next(fullWitOperationName);
    thePdf = next(pdfSeparator_.c_str());
    if (thePdf.empty())
d1345 2
a1346 2
    theOperationName = next(pdfSeparator_.c_str());
    if (theOperationName.empty())
d1349 2
a1350 2
    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
d1362 3
a1364 3
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
d1382 1
a1382 1
    const std::string & fullWitPartname)
d1388 1
a1388 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1393 1
a1393 1
    witGetPartCategory(theWitRun, fullWitPartname.c_str(), &category);
d1399 3
a1401 3
    SCETokenizer next(fullWitPartname);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());
d1403 2
a1404 2
    std::string thePartName = next(pdfSeparator_.c_str());
    assert (! thePartName.empty());
d1406 2
a1407 2
    std::string anythingSpecial = next(pdfSeparator_.c_str());
    if (anythingSpecial.empty())  
d1419 3
a1421 3
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo)
d1425 1
a1425 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1431 1
a1431 1
    SCETokenizer next(fullWitPartname);
d1434 2
a1435 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d1439 2
a1440 2
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
d1444 1
a1444 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1458 3
a1460 3
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo)
d1464 1
a1464 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1470 1
a1470 1
    SCETokenizer next(fullWitPartname);
d1473 2
a1474 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d1478 2
a1479 2
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
d1483 1
a1483 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1497 5
a1501 5
    const std::string & fullWitOperationName,
    std::string & realPart,
    std::string & realPartPdf,
    std::string & aggPart,
    std::string & aggPdf)
d1505 1
a1505 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1511 1
a1511 1
    SCETokenizer next(fullWitOperationName);
d1514 2
a1515 2
    realPartPdf =  next(pdfSeparator_.c_str());
    if (realPartPdf.empty())
d1519 2
a1520 2
    realPart =  next(pdfSeparator_.c_str());
    if (realPart.empty())
d1524 2
a1525 2
    aggPdf =  next(pdfSeparator_.c_str());
    if (aggPdf.empty())
d1529 2
a1530 2
    aggPart =  next(pdfSeparator_.c_str());
    if (aggPart.empty())
d1533 1
a1533 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1546 5
a1550 5
    const std::string & fullWitOperationName,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf)
d1554 1
a1554 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1560 1
a1560 1
    SCETokenizer next(fullWitOperationName);
d1563 2
a1564 2
    destinationPdf =  next(pdfSeparator_.c_str());
    if (destinationPdf.empty())
d1568 2
a1569 2
    destination =  next(pdfSeparator_.c_str());
    if (destination.empty())
d1573 2
a1574 2
    sourcePdf =  next(pdfSeparator_.c_str());
    if (sourcePdf.empty())
d1578 2
a1579 2
    source =  next(pdfSeparator_.c_str());
    if (source.empty())
d1582 1
a1582 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1594 5
a1598 5
    const std::string & fullWitOperationName,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf)
d1602 1
a1602 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1608 1
a1608 1
    SCETokenizer next(fullWitOperationName);
d1611 2
a1612 2
    destinationPdf =  next(pdfSeparator_.c_str());
    if (destinationPdf.empty())
d1616 2
a1617 2
    destination =  next(pdfSeparator_.c_str());
    if (destination.empty())
d1621 2
a1622 2
    sourcePdf =  next(pdfSeparator_.c_str());
    if (sourcePdf.empty())
d1626 2
a1627 2
    source =  next(pdfSeparator_.c_str());
    if (source.empty())
d1630 1
a1630 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1645 2
a1646 2
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName)
d1648 4
a1651 4
    std::string  destination;
    std::string  destinationPdf;
    std::string  source;
    std::string  sourcePdf;
d1660 1
a1660 1
    sourcePdfPartName = "";
d1672 2
a1673 2
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName)
d1675 4
a1678 4
    std::string  destination;
    std::string  destinationPdf;
    std::string  source;
    std::string  sourcePdf;
d1687 1
a1687 1
    sourcePdfPartName = "";
d1698 3
a1700 3
    const std::string & fullWitOperationName,
    std::string & plannerPart,
    std::string & geo)
d1704 1
a1704 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1710 1
a1710 1
    SCETokenizer next(fullWitOperationName);
d1713 2
a1714 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d1718 2
a1719 2
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty())
d1723 1
a1723 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1737 3
a1739 3
    const std::string & fullWitOperationName,
    std::string & theCapacity,
    std::string & pdf)
d1743 1
a1743 1
    witGetOperationExists(theWitRun, fullWitOperationName.c_str(), &exists);
d1749 1
a1749 1
    SCETokenizer next(fullWitOperationName);
d1752 2
a1753 2
    pdf =  next(pdfSeparator_.c_str());
    if (pdf.empty())
d1757 2
a1758 2
    theCapacity =  next(pdfSeparator_.c_str());
    if (theCapacity.empty())
d1761 1
a1761 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d1789 1
a1789 1
    const std::string & fullWitPartname)
d1791 1
a1791 1
  std::string d1,d2,d3;
d1815 2
a1816 2
    const std::string & fullWitPartname,
    std::string & pdf)
d1820 1
a1820 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1825 1
a1825 1
  SCETokenizer next(fullWitPartname);
d1828 2
a1829 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d1833 2
a1834 2
  std::string dpn =  next(pdfSeparator_.c_str());
  if (dpn.empty())
d1837 1
a1837 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1851 2
a1852 2
    const std::string & fullWitPartname,
    std::string & pdf)
d1856 1
a1856 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1861 1
a1861 1
  SCETokenizer next(fullWitPartname);
d1864 2
a1865 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d1869 2
a1870 2
  std::string dpn =  next(pdfSeparator_.c_str());
  if (dpn.empty())
d1873 1
a1873 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1887 4
a1890 4
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart)
d1894 1
a1894 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1899 1
a1899 1
  SCETokenizer next(fullWitPartname);
d1902 2
a1903 2
  geo = next(pdfSeparator_.c_str());
  if (geo.empty())
d1907 2
a1908 2
  plannerPart =  next(pdfSeparator_.c_str());
  if (plannerPart.empty())
d1912 2
a1913 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d1916 1
a1916 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1931 4
a1934 4
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart)
d1938 1
a1938 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1943 1
a1943 1
  SCETokenizer next(fullWitPartname);
d1946 2
a1947 2
  geo = next(pdfSeparator_.c_str());
  if (geo.empty())
d1951 2
a1952 2
  plannerPart =  next(pdfSeparator_.c_str());
  if (plannerPart.empty())
d1956 2
a1957 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d1960 1
a1960 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d1978 5
a1982 5
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
d1986 1
a1986 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d1991 1
a1991 1
  SCETokenizer next(fullWitPartname);
d1994 2
a1995 2
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d1999 2
a2000 2
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d2004 2
a2005 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d2009 2
a2010 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d2013 1
a2013 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d2027 5
a2031 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart)
d2035 1
a2035 1
  witGetOperationExists(theWitRun, fullWitOperation.c_str(), &exists);
d2040 1
a2040 1
  SCETokenizer next(fullWitOperation);
d2043 2
a2044 2
  geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d2048 2
a2049 2
  machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d2053 2
a2054 2
  pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d2058 2
a2059 2
  featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d2062 1
a2062 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d2077 1
a2077 1
    const std::string & fullWitPartname)
d2081 1
a2081 1
  witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2087 1
a2087 1
  SCETokenizer next(fullWitPartname);
d2091 2
a2092 2
  std::string geo =  next(pdfSeparator_.c_str());
  if (geo.empty())
d2096 2
a2097 2
  std::string machine =  next(pdfSeparator_.c_str());
  if (machine.empty())
d2101 2
a2102 2
  std::string pdf =  next(pdfSeparator_.c_str());
  if (pdf.empty())
d2106 2
a2107 2
  std::string featurePart =  next(pdfSeparator_.c_str());
  if (featurePart.empty())
d2110 1
a2110 1
  std::string anythingSpecial = next(pdfSeparator_.c_str());
d2124 1
a2124 1
    const std::string & fullWitPartname)
d2128 1
a2128 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2134 1
a2134 1
    SCETokenizer next(fullWitPartname);
d2137 2
a2138 2
    std::string pdf =  next(pdfSeparator_.c_str());
    if (pdf.empty())
d2142 2
a2143 2
    std::string aPart =  next(pdfSeparator_.c_str());
    if (aPart.empty())
d2146 1
a2146 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2159 4
a2162 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
d2166 1
a2166 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2172 1
a2172 1
    SCETokenizer next(fullWitPartname);
d2175 2
a2176 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d2180 2
a2181 2
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
d2185 2
a2186 2
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
d2189 1
a2189 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2206 4
a2209 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
d2213 1
a2213 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2219 1
a2219 1
    SCETokenizer next(fullWitPartname);
d2222 2
a2223 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d2227 2
a2228 2
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
d2232 2
a2233 2
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
d2236 1
a2236 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2248 4
a2251 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory)
d2255 1
a2255 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2261 1
a2261 1
    SCETokenizer next(fullWitPartname);
d2264 2
a2265 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d2269 2
a2270 2
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
d2274 2
a2275 2
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
d2278 1
a2278 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2292 5
a2296 5
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart)
d2300 1
a2300 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2306 1
a2306 1
    SCETokenizer next(fullWitPartname);
d2309 2
a2310 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d2314 2
a2315 2
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
d2319 2
a2320 2
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
d2324 2
a2325 2
    mfgOptionPart =  next(pdfSeparator_.c_str());
    if (mfgOptionPart.empty())
d2329 1
a2329 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2344 5
a2348 5
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart)
d2352 1
a2352 1
    witGetPartExists(theWitRun, fullWitPartname.c_str(), &exists);
d2358 1
a2358 1
    SCETokenizer next(fullWitPartname);
d2361 2
a2362 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty())
d2366 2
a2367 2
    plannerTopLevelBuild =  next(pdfSeparator_.c_str());
    if (plannerTopLevelBuild.empty())
d2371 2
a2372 2
    bbCategory =  next(pdfSeparator_.c_str());
    if (bbCategory.empty())
d2376 2
a2377 2
    mfgOptionPart =  next(pdfSeparator_.c_str());
    if (mfgOptionPart.empty())
d2381 1
a2381 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2395 1
a2395 1
    const std::string & fullWitPartname)
d2407 1
a2407 1
    witGetOperationExists(theWitRun, fullWitPartname.c_str(), &exists);
d2417 3
a2419 3
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
d2427 1
a2427 1
    witGetOperationExists(theWitRun, pdfOperationName.c_str(), &exists);
d2449 4
a2452 4
    const std::string & operationName,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
d2457 1
a2457 1
    std::string pdfOperation = pdf + pdfSeparator_ + operationName;
d2483 3
a2485 3
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
d2494 1
a2494 1
    witGetPartExists(theWitRun, pdfOperationName.c_str(), &exists);
d2515 1
a2515 1
std::string
d2517 1
a2517 1
    const std::string & fullWitPartName)
d2520 2
a2521 2
    std::string  plannerPart;
    std::string  geo;
d2523 1
a2523 1
    SCETokenizer next(fullWitPartName);
d2526 2
a2527 2
    geo =  next(pdfSeparator_.c_str());
    assert (! (geo.empty()));
d2530 2
a2531 2
    plannerPart =  next(pdfSeparator_.c_str());
    assert (! (plannerPart.empty()));
d2549 4
a2552 4
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo)
d2558 1
a2558 1
    witGetPartExists(theWitRun, fullWitPartName.c_str(), &partExists);
d2566 1
a2566 1
    witGetPartDemands ( theWitRun, fullWitPartName.c_str(), &lenDemandList, &demandList);
d2571 1
a2571 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<lenDemandList; i++){
d2587 1
a2587 1
    SCETokenizer next(fullWitDemandName);
d2590 2
a2591 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty()) {
d2596 2
a2597 2
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty()){
d2602 1
a2602 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2616 1
a2616 1
std::string
d2618 1
a2618 1
    const std::string & fullWitPartName)
d2621 2
a2622 2
    std::string  plannerPart;
    std::string  geo;
d2624 1
a2624 1
    SCETokenizer next(fullWitPartName);
d2627 2
a2628 2
    geo =  next(pdfSeparator_.c_str());
    assert (! (geo.empty()));
d2631 2
a2632 2
    plannerPart =  next(pdfSeparator_.c_str());
    assert (! (plannerPart.empty()));
d2648 4
a2651 4
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo)
d2657 1
a2657 1
    witGetPartExists(theWitRun, fullWitPartName.c_str(), &partExists);
d2665 1
a2665 1
    witGetPartDemands ( theWitRun, fullWitPartName.c_str(), &lenDemandList, &demandList);
d2670 1
a2670 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<lenDemandList; i++){
d2686 1
a2686 1
    SCETokenizer next(fullWitDemandName);
d2689 2
a2690 2
    geo =  next(pdfSeparator_.c_str());
    if (geo.empty()) {
d2695 2
a2696 2
    plannerPart =  next(pdfSeparator_.c_str());
    if (plannerPart.empty()){
d2701 1
a2701 1
    std::string anythingSpecial = next(pdfSeparator_.c_str());
d2717 1
a2717 1
std::string
d2726 1
a2726 1
    const std::string & pdfSeparator)
d2732 1
a2732 1
std::string
d2741 1
a2741 1
    const std::string & defaultPdf)
d2749 1
a2749 1
std::string 
d2761 2
a2762 2
std::string 
LgFrMultiPlantHelper::pdf(const std::string & pdfPart)
d2765 3
a2767 3
    SCETokenizer next(pdfPart);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());
d2769 2
a2770 2
    std::string thePartName = next(pdfSeparator_.c_str());
    if (thePartName.empty())
d2777 1
a2777 1
std::string 
d2781 1
a2781 1
    return this->pdf(std::string(pdfPart));
d2787 2
a2788 2
std::string 
LgFrMultiPlantHelper::partname(const std::string & pdfPart)
d2791 3
a2793 3
    SCETokenizer next(pdfPart);
    std::string thePdf = next(pdfSeparator_.c_str());
    assert (! thePdf.empty());
d2795 2
a2796 2
    std::string thePartName = next(pdfSeparator_.c_str());
    if (thePartName.empty())
d2807 2
a2808 2
std::string 
LgFrMultiPlantHelper::operationName(const std::string & pdfOperation)
d2817 2
a2818 2
bool
LgFrMultiPlantHelper::isPartnameEqual(const std::string & left, const std::string & right)
d2832 2
a2833 2
    const std::string & sourcePdfPartName,
    const std::string & interplantOperationName,
d2838 1
a2838 1
                              interplantOperationName.c_str(),
d2844 1
a2844 1
                           interplantOperationName.c_str(),
d2866 1
a2866 1
    const std::string & interplantOperationName,
d2875 1
a2875 1
                              interplantOperationName.c_str(),
d2878 1
a2878 2
  size_t b = 0; // Pulled out of the for below by RW2STL
  for ( b=0; b<nbBops; b++) {
d2883 1
a2883 1
                                  interplantOperationName.c_str(),
d2888 1
a2888 1
                                interplantOperationName.c_str(),
d2918 2
a2919 2
    const std::string & sourcePdfPartName,
    const std::string & binOperationName,
d2924 1
a2924 1
                              binOperationName.c_str(),
d2930 1
a2930 1
                           binOperationName.c_str(),
d2952 1
a2952 1
    const std::string & binOperationName,
d2961 1
a2961 1
                              binOperationName.c_str(),
d2964 1
a2964 2
  size_t b = 0; // Pulled out of the for below by RW2STL
  for ( b=0; b<nbBops; b++) {
d2969 1
a2969 1
                                  binOperationName.c_str(),
d2974 1
a2974 1
                                binOperationName.c_str(),
d3054 4
a3057 4
 std::string testPart1("POK_xx123");
 std::string testPart2("FUJ_xx123");
 std::string testPart3("xx123");
 std::string testPart4("WW_yy123");
d3063 3
a3065 3
 assert(multiPlantHelper.isPartnameEqual(testPart1.c_str(), testPart3));
 assert(multiPlantHelper.isPartnameEqual(testPart1.c_str(), testPart3.c_str()));
 assert(multiPlantHelper.isPartnameEqual(testPart1, testPart3.c_str()));
d3069 1
a3069 1
 assert(multiPlantHelper.pdf(testPart3.c_str()) == "WW");
@


1.5.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d127 1
a127 1
      std::cerr << "SCE9955F PROGRAMMER ERROR: part with negative demands does not\n"
@


1.4
log
@bogon output, and minor changes
@
text
@d6 1
@


1.3
log
@changes for Release 3.00
@
text
@d148 19
@


1.2
log
@Fixed memory bug in Customer Choice Feature logic
@
text
@d1190 1
@


1.1
log
@Initial revision
@
text
@d163 20
d208 39
@


1.1.1.1
log
@Import sce
@
text
@@


1.1.1.1.4.1
log
@Customer Choice bug fix and memory leak patch.
@
text
@a162 20

// Return the witOperationIndex
// returns -1 if the operation is bad, or, index is not set
int
LgFrMultiPlantHelper::witOperationIndex(
    WitRun * const theWitRun, 
    const RWCString & fullWitOperationName)
{
  LgFrSceCCOperationAppData * appDataPtr;
  witGetOperationAppData(theWitRun,  fullWitOperationName, (void **) &appDataPtr);
  if (appDataPtr == NULL) 
    return -1;

  return appDataPtr->index();
}





a187 39


// set the Customer Choice Operation AppData indices to synch with a witGetOperation()
// It sets them only for Special Customer Choice feature parts
void
LgFrMultiPlantHelper::setCCOperationIndices(
    WitRun * const theWitRun)
{
  int nOperations;
  char ** opList;

  RWCString geo;
  RWCString machine;
  RWCString pdf;
  RWCString featurePart;



  witGetOperations (theWitRun, &nOperations, &opList );
  for (int o=0; o<nOperations; o++) {
    if (! this->isOperationSpecialCustChoiceFeature(theWitRun, opList[o], geo, machine,pdf,featurePart)) {
      portableFree(opList[o]);
      continue;
    }
    
    LgFrSceCCOperationAppData * ccOpAppDataPtr;
    witGetOperationAppData (theWitRun, opList[o], (void **) &ccOpAppDataPtr );
    // if no app data exists, then create one.
    if (ccOpAppDataPtr == NULL) {
      ccOpAppDataPtr = new LgFrSceCCOperationAppData(o);
      witSetOperationAppData(theWitRun, opList[o], (void *) ccOpAppDataPtr);
    }
    ccOpAppDataPtr->index(o); 
    portableFree(opList[o]);     
  } 

  portableFree (opList);
}

@


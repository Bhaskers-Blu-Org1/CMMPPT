head	1.83;
access;
symbols
	sce_5_01_20080919:1.66
	latest_sce_4_20_20060523:1.50.0.2
	sce_4_20_20060523:1.50
	latest_sce4_20_OSL:1.47.0.2
	sce_4_20_OSL:1.47
	sce_4_20_20051222:1.47
	sce_4_10_30050426:1.45
	sce_4_05_20040511:1.40
	sce_4_00_20040201:1.32
	nextGenBranch:1.29.0.2
	nextGenRoot:1.29
	sce_3_30_20030627:1.28
	EndRw-branch:1.25.0.2
	Root-of-EndRw:1.25
	EndWitRw-branch:1.24.0.4
	Root-of-EndWitRw:1.24
	RwToStl-branch:1.24.0.2
	Root-of-RwToStl:1.24
	latest_sce_3_10_20010924:1.10.0.2
	sce_3_10_20010924:1.10
	latest_sce_3_00_20010601:1.5.0.2
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.3.0.2
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.83
date	2011.04.15.01.23.34;	author yktdev;	state Exp;
branches;
next	1.82;
commitid	13e64da79e0e4567;

1.82
date	2011.04.06.21.49.59;	author ervolina;	state Exp;
branches;
next	1.81;
deltatype	text;
permissions	644;
commitid	19bc4d9cdf5560a1;
kopt	kv;
filename	@scemain.C@;

1.81
date	2011.03.25.21.04.02;	author ervolina;	state Exp;
branches;
next	1.80;
deltatype	text;
permissions	644;
commitid	18f84d8d033615fb;
kopt	kv;
filename	@scemain.C@;

1.80
date	2011.03.24.02.11.07;	author ervolina;	state Exp;
branches;
next	1.79;
deltatype	text;
permissions	644;
commitid	1ec4d8aa79a62d9;
kopt	kv;
filename	@scemain.C@;

1.79
date	2011.03.22.17.21.14;	author ervolina;	state Exp;
branches;
next	1.78;
deltatype	text;
permissions	644;
commitid	19944d88d9d47ee4;
kopt	kv;
filename	@scemain.C@;

1.78
date	2011.03.21.21.38.02;	author ervolina;	state Exp;
branches;
next	1.77;
deltatype	text;
permissions	644;
commitid	b204d87c10c69fa;
kopt	kv;
filename	@scemain.C@;

1.77
date	2011.03.17.17.59.38;	author ervolina;	state Exp;
branches;
next	1.76;
deltatype	text;
permissions	644;
commitid	25bc4d824b6d15ef;
kopt	kv;
filename	@scemain.C@;

1.76
date	2011.03.15.13.38.07;	author ervolina;	state Exp;
branches;
next	1.75;
deltatype	text;
permissions	644;
commitid	ef44d7f6ae030ab;
kopt	kv;
filename	@scemain.C@;

1.75
date	2011.03.11.00.16.09;	author yorktown;	state Exp;
branches;
next	1.74;
deltatype	text;

1.74
date	2011.03.10.15.32.52;	author ervolina;	state Exp;
branches;
next	1.73;
deltatype	text;
permissions	644;
commitid	14cc4d78ede700a2;
kopt	kv;
filename	@scemain.C@;

1.73
date	2010.04.12.21.27.03;	author ervolina;	state Exp;
branches;
next	1.72;
deltatype	text;

1.72
date	2010.04.07.16.18.27;	author ervolina;	state Exp;
branches;
next	1.71;
deltatype	text;

1.71
date	2010.03.29.12.26.45;	author ervolina;	state Exp;
branches;
next	1.70;
deltatype	text;

1.70
date	2010.02.10.16.43.42;	author ervolina;	state Exp;
branches;
next	1.69;
deltatype	text;

1.69
date	2009.12.08.13.58.36;	author ervolina;	state Exp;
branches;
next	1.68;
deltatype	text;

1.68
date	2009.01.28.14.22.31;	author ervolina;	state Exp;
branches;
next	1.67;
deltatype	text;

1.67
date	2009.01.07.22.01.00;	author ervolina;	state Exp;
branches;
next	1.66;
deltatype	text;

1.66
date	2008.09.19.20.03.48;	author ervolina;	state Exp;
branches;
next	1.65;
deltatype	text;

1.65
date	2008.06.23.19.07.12;	author ervolina;	state Exp;
branches;
next	1.64;
deltatype	text;

1.64
date	2008.06.05.19.04.33;	author ervolina;	state Exp;
branches;
next	1.63;
deltatype	text;

1.63
date	2008.06.04.16.21.59;	author ervolina;	state Exp;
branches;
next	1.62;
deltatype	text;

1.62
date	2008.04.24.14.04.43;	author ervolina;	state Exp;
branches;
next	1.61;
deltatype	text;

1.61
date	2008.03.20.14.52.49;	author ervolina;	state Exp;
branches;
next	1.60;
deltatype	text;

1.60
date	2008.03.14.20.19.40;	author ervolina;	state Exp;
branches;
next	1.59;
deltatype	text;

1.59
date	2007.05.29.20.03.33;	author ervolina;	state Exp;
branches;
next	1.58;
deltatype	text;

1.58
date	2007.03.21.18.15.10;	author ervolina;	state Exp;
branches;
next	1.57;
deltatype	text;

1.57
date	2007.03.21.18.03.29;	author ervolina;	state Exp;
branches;
next	1.56;
deltatype	text;

1.56
date	2006.08.11.19.31.41;	author ervolina;	state Exp;
branches;
next	1.55;
deltatype	text;

1.55
date	2006.08.11.17.39.50;	author ervolina;	state Exp;
branches;
next	1.54;
deltatype	text;

1.54
date	2006.08.09.16.32.18;	author ervolina;	state Exp;
branches;
next	1.53;
deltatype	text;

1.53
date	2006.07.13.18.42.35;	author ervolina;	state Exp;
branches;
next	1.52;
deltatype	text;

1.52
date	2006.06.26.15.23.31;	author ervolina;	state Exp;
branches;
next	1.51;
deltatype	text;

1.51
date	2006.06.15.17.45.43;	author ervolina;	state Exp;
branches;
next	1.50;
deltatype	text;

1.50
date	2006.05.23.13.03.56;	author ervolina;	state Exp;
branches
	1.50.2.1;
next	1.49;
deltatype	text;

1.49
date	2006.04.17.18.55.54;	author ervolina;	state Exp;
branches;
next	1.48;
deltatype	text;

1.48
date	2006.04.17.17.19.47;	author ervolina;	state Exp;
branches;
next	1.47;
deltatype	text;

1.47
date	2005.12.22.23.17.56;	author ervolina;	state Exp;
branches;
next	1.46;
deltatype	text;

1.46
date	2005.08.10.22.43.17;	author ervolina;	state Exp;
branches;
next	1.45;
deltatype	text;

1.45
date	2005.08.10.22.09.12;	author ervolina;	state Exp;
branches;
next	1.44;
deltatype	text;

1.44
date	2005.05.05.20.22.12;	author ervolina;	state Exp;
branches;
next	1.43;
deltatype	text;

1.43
date	2005.02.15.20.45.01;	author ervolina;	state Exp;
branches;
next	1.42;
deltatype	text;

1.42
date	2004.10.08.13.03.44;	author ervolina;	state Exp;
branches;
next	1.41;
deltatype	text;

1.41
date	2004.09.10.12.42.50;	author ervolina;	state Exp;
branches;
next	1.40;
deltatype	text;

1.40
date	2004.05.12.01.32.16;	author ervolina;	state Exp;
branches;
next	1.39;
deltatype	text;

1.39
date	2004.04.07.19.58.33;	author ervolina;	state Exp;
branches;
next	1.38;
deltatype	text;

1.38
date	2004.03.05.03.31.10;	author ervolina;	state Exp;
branches;
next	1.37;
deltatype	text;

1.37
date	2004.03.04.20.28.11;	author fasano;	state Exp;
branches;
next	1.36;
deltatype	text;

1.36
date	2004.03.02.04.22.51;	author ervolina;	state Exp;
branches;
next	1.35;
deltatype	text;

1.35
date	2004.02.26.16.42.47;	author ervolina;	state Exp;
branches;
next	1.34;
deltatype	text;

1.34
date	2004.02.20.16.09.41;	author ervolina;	state Exp;
branches;
next	1.33;
deltatype	text;

1.33
date	2004.02.06.21.55.34;	author ervolina;	state Exp;
branches;
next	1.32;
deltatype	text;

1.32
date	2004.02.02.03.37.48;	author ervolina;	state Exp;
branches;
next	1.31;
deltatype	text;

1.31
date	2004.01.22.02.47.49;	author ervolina;	state Exp;
branches;
next	1.30;
deltatype	text;

1.30
date	2004.01.12.02.17.30;	author ervolina;	state Exp;
branches;
next	1.29;
deltatype	text;

1.29
date	2003.07.28.18.46.28;	author ervolina;	state Exp;
branches;
next	1.28;
deltatype	text;

1.28
date	2003.06.26.23.09.38;	author ervolina;	state Exp;
branches;
next	1.27;
deltatype	text;

1.27
date	2003.01.31.22.59.14;	author ervolina;	state Exp;
branches;
next	1.26;
deltatype	text;

1.26
date	2003.01.15.19.36.57;	author rwToStl;	state Exp;
branches;
next	1.25;
deltatype	text;

1.25
date	2002.11.26.14.25.33;	author fasano;	state Exp;
branches
	1.25.2.1;
next	1.24;
deltatype	text;

1.24
date	2002.09.06.13.37.22;	author ervolina;	state Exp;
branches;
next	1.23;
deltatype	text;

1.23
date	2002.08.08.17.37.44;	author ervolina;	state Exp;
branches;
next	1.22;
deltatype	text;

1.22
date	2002.07.02.20.20.07;	author ervolina;	state Exp;
branches;
next	1.21;
deltatype	text;

1.21
date	2002.06.26.20.38.45;	author ervolina;	state Exp;
branches;
next	1.20;
deltatype	text;

1.20
date	2002.03.29.17.34.06;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;

1.19
date	2002.03.29.17.21.24;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2002.03.28.21.49.43;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;

1.17
date	2001.12.21.20.10.33;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2001.12.11.16.34.45;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2001.12.03.13.38.52;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2001.11.20.22.13.12;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2001.10.25.14.12.48;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2001.10.19.16.06.25;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2001.10.17.22.04.42;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2001.09.24.17.19.10;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2001.09.24.16.38.14;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2001.08.14.21.01.01;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2001.08.13.21.09.36;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2001.07.06.13.42.33;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2001.06.01.16.52.06;	author ervolina;	state Exp;
branches
	1.5.2.1;
next	1.4;
deltatype	text;

1.4
date	2001.03.12.15.07.29;	author ervolina;	state Exp;
branches;
next	1.3;
deltatype	text;

1.3
date	2001.02.23.20.11.40;	author ervolina;	state Exp;
branches
	1.3.2.1;
next	1.2;
deltatype	text;

1.2
date	2000.10.04.15.48.39;	author ervolina;	state Exp;
branches
	1.2.2.1;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.54;	author wit;	state Exp;
branches;
next	;
deltatype	text;

1.2.2.1
date	2001.03.08.15.36.47;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.3.2.1
date	2001.03.09.22.53.05;	author scelib;	state Exp;
branches;
next	1.3.2.2;
deltatype	text;

1.3.2.2
date	2001.03.09.23.00.00;	author scelib;	state Exp;
branches;
next	1.3.2.3;
deltatype	text;

1.3.2.3
date	2001.03.12.16.36.18;	author scelib;	state Exp;
branches;
next	1.3.2.4;
deltatype	text;

1.3.2.4
date	2001.03.12.20.05.40;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.5.2.1
date	2001.07.06.13.57.36;	author scelib;	state Exp;
branches;
next	1.5.2.2;
deltatype	text;

1.5.2.2
date	2001.08.13.16.28.01;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.25.2.1
date	2003.01.08.17.43.18;	author rwToStl;	state Exp;
branches;
next	1.25.2.2;
deltatype	text;

1.25.2.2
date	2003.01.09.13.14.31;	author rwToStl;	state Exp;
branches;
next	1.25.2.3;
deltatype	text;

1.25.2.3
date	2003.01.14.19.06.01;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;

1.50.2.1
date	2006.06.07.12.34.02;	author ervolina;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.83
log
@changed param defaults. ServerGroup reverse D2O was failing
@
text
@#include <mcl/src/mdsPragma.h>
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
#include <stdlib.h>
#include <iostream>
#include <float.h>

#include <mcl/src/mcl.h>
#include <scenario/src/calendar.h>
#include <scenario/src/scenDrct.h>
#include <scenario/src/schdDeSt.h>

#include <sce/src/scDeSce.h>
#include <sce/src/difSceF.h>
#include <sce/src/scBdSce.h>
#include <sce/src/scenSce.h>
#include <sce/src/scenSceP.h>
#include <sce/src/mPlantH.h>

#ifdef SCE_ODBC
#include <sce/src/db.h>
#endif

// Uncomment this line if you want to build a version of SCE that
// is ONLY capable of scrubbing
// #define BUILD_AS_SCRUBBER_ONLY

//-----------------------------------------------------------------------
//
// SCE Main program
//
//-----------------------------------------------------------------------
int main(int argc, char * argv[])
{

#ifdef BUILD_AS_SCRUBBER_ONLY
  std::cout << "\nScrub Utility for Supply Capability Engine" << std::endl;
  std::cout << "Version: 6.21,  20110415 " << std::endl;
#else
  std::cout << "\nSupply Capability Engine" << std::endl;
  std::cout << "Version: 6.21,  20110415 " << std::endl;
#endif

  std::string platform("unknown");
#ifdef PLATFORM
  platform = XSTR( PLATFORM );
  if (platform == "1")
    platform = "linux";
#endif

#ifdef WIN32
  platform += " Win32";
#endif

#ifdef WIN64
  platform += " Win64";
#endif




  std::string exe_type("unknown");
#ifdef EXE_TYPE
  exe_type = XSTR( EXE_TYPE );
#endif

  std::cout << "Platform: " << platform << std::endl;
  std::cout << "Build type: " << exe_type  << std::endl ;
  std::cout << "Build date: " <<  __DATE__  << std::endl << std::endl;

  std::cout << "(C) COPYRIGHT International Business Machines Corp. 1995, 1997, 2011" << std::endl;
  std::cout << "All Rights Reserved" << std::endl;
  std::cout << "Property of IBM\n" << std::endl;


  LgFrCalendar calendar(8, LgFrDatetime("8/01/95"));
  LgFrCalendar & theCal = calendar;


  // ODBC Setup

#ifdef SCE_ODBC

  if ( argc != 6 && argc != 3 ) {
    std::cout << "Error.  Usage:  scemain <parameterFileName>  <dbName>" << std::endl;

    std::cout << "     or Usage:  scemain <parameterFileName> <dbName> " << std::endl;
    std::cout << "                       <dbInstance> <userID> <password>" << std::endl;
    exit(1);
  }
  SceDBProfile * pDB;
  if (argc == 6)
    {
      pDB = new SceDBProfile(argv[2],argv[3],argv[4],argv[5]);
    }
  else
    {
      pDB = new SceDBProfile(argv[2]);
    }
  std::cout << std::endl << "Connecting the database ... " << std::endl;
  if (! pDB -> setup())
    {
      std::cout<< "Database connection failed." << std::endl;
      exit(1);
    }
  else
    std::cout<< "Database connection SUCCESSFUL!" <<std::endl<<std::endl;

#else


#ifdef BUILD_AS_SCRUBBER_ONLY
  if ( argc !=4 ) {
      std::cout << "Error.  Usage is: sceScrub <parameterFileName> <T> <scrubDir>" << std::endl;
      exit(8);
  }
#else

  if ( argc != 2 && argc !=4 ) {
    std::cout << "Error.  Usage is: scemain <parameterFileName> " << std::endl;
    exit(8);
  }


#endif

#endif


  std::string parameterFileName (argv[1]);

  //  LgFrDataInterfaceImplementationFromSceFiles dif(parameterFileName);
  // setup scrubber mode for user option

  LgFrDataInterfaceImplementation * difSceFImpPtr;
  if (argc == 4)
    {
      if (argv[2][0] == 'T')
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], true, true);
      else if (argv[2][0] == 'F') {
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], true, false);
#ifdef BUILD_AS_SCRUBBER_ONLY
        std::cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << std::endl;
        std::cout << "SCE terminates" << std::endl;
        exit(8);
#endif
      }
      else
        {
          std::cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << std::endl;
          exit(8);
        }
    }
  else
    {
      difSceFImpPtr
        = new LgFrDataInterfaceImplementationFromSceFiles(parameterFileName);
    }

  registerSceFilesDifImpFunctions(difSceFImpPtr);

  LgFrDataInterface dif(difSceFImpPtr);
  delete difSceFImpPtr;

  // Create a scenario using the builder
  LgFrScenarioBuilderForSce builder;
  LgFrScenarioDirector director(&builder);
  // ==================================
  // director oversees teh construction of witRun, scenario, and 
  // initialProblem (which reads the input files and builds the wit model).
  // ==================================
  director.construct(dif, calendar);
  LgFrScenarioForSceSmartPointer scenarioSP = builder.getScenario();

  // this is just a test to ensure that purify is working
  float * intentionalMemoryLeak = new float[1];

  LgFrSceSetOfParameters & setOfParameters = scenarioSP->setOfParameters();

  LgFrSceScrubber * myScrubber = scenarioSP -> scrubber();

  // ========================================================
  // === Print any model structure outputs
  // (like echo's, heurWitDataFile, bogons, lowestLevel) etc.
  // ========================================================
  scenarioSP->printModelStructureOutputs();




  // ==========================
  // === Run an MRP engine ===
  // ==========================
  if (! myScrubber-> scrubOnly())
    {
      scenarioSP->runExplosion(scenarioSP);
      scenarioSP->printExplosionResults();
    }

  // ============================
  // === Run IMPLOSION engine ===-
  // ============================
  bool doImplode = setOfParameters.getBool("doImplode");
  
  if (! myScrubber-> scrubOnly())
    {
      if (doImplode)
	scenarioSP->runImplosion(scenarioSP);
      
      // =====================================================================
      // Call another API routine to do all the output stuff
      if (doImplode) {
	
#ifdef SCE_ODBC
	std::cout << "Populate the database with output results ..." << std::endl;
	scenarioSP->analyzeRunAndUpdateDB();
#else
	// don't do this if your in scrub only mode
	if (! myScrubber-> scrubOnly())        {
	  std::cout << "Writing output results ..." << std::endl;
	  scenarioSP->analyzeRunAndPrintResults();
	}
#endif

#ifdef MULTIPLE_IMPLOSION_RUNS
	// testbed for future ability to keep live SCE model.    
	// future methods for changing a demand

	std::string demandUpdateFile("newDemandUpdate.dat");
	scenarioSP->setDemandVols(demandUpdateFile);

	std::cout << "Running a second Implosion Problem Now ..." << std::endl;	
	scenarioSP->runImplosion(scenarioSP);
	std::cout << "second Implosion Complete ... will now analyze and print results ..." << std::endl;	
	scenarioSP->analyzeRunAndPrintResults();
#endif	

      }
    }
  
  // =====================================================================
  // ==================================================
  // ==== Run the FSS Engines =========================
  // ==================================================
  bool fssFlag = setOfParameters.getBool("fssFlag");
  
  if (doImplode && fssFlag)  {
    if (! myScrubber-> scrubOnly())        {
      std::cout << "Running FSS Engines ... " << std::endl;
    }
    
    if (! myScrubber-> scrubOnly())        {
      if (setOfParameters.getBool("doFssSingleton")) {
        std::cout << "Singleton Queries ... "
		  << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
		  << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
             << ")" << std::endl;
        scenarioSP->singletonFss();
      }
    }
    
    if (setOfParameters.getBool("doFssGeneralSet")) {
      std::cout << "General Set Queries ... "
           << "(method:" << setOfParameters.getString("fssGeneralSetMethod") << "    "
		<< "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
		<< ")" << std::endl;
      scenarioSP->generalSetFss();
    }

    if (setOfParameters.getBool("doFssMachine")) {
      std::cout << "Machine Queries ... "
		<< "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
		<< "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
           << ")" << std::endl;
      scenarioSP->machineFss();
    }
  }

  
  

#ifdef SCE_ODBC

  if (pDB)
    delete pDB;

#endif

  // figure out what return code to pass
  MclFacility * myFacil = scenarioSP->getErrFacility();
  int level = myFacil -> maxSeverityOfMsgsIssued();



  //  delete the guts of scenario
  scenarioSP->deleteAppDataAndScenarioObjects();





  std::cout << "SCE Completed.  Return Code:" << std::flush;

  // max message issued was "info"
  if (level == 0) {
    std::cout << " 0" << std::endl;
    return 0;
  }
  // max message issued was "warning"
  if (level == 1) {
    std::cout << " 4" << std::endl;
    return 4;
  }
  // max message issued was "error" or worse
  if (level > 1) {
    std::cout << " 8" << std::endl;
    return 8;
  }

}
@


1.82
log
@fixed formatting error in printing iPegCrit
@
text
@d41 1
a41 1
  std::cout << "Version: 6.21,  20110406 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.21,  20110406 " << std::endl;
@


1.81
log
@fixed some formatting errors in indpInterplantPegging
@
text
@d41 1
a41 1
  std::cout << "Version: 6.21,  20110325 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.21,  20110325 " << std::endl;
@


1.80
log
@minor changes to banners
@
text
@d41 1
a41 1
  std::cout << "Version: 6.21,  20110323 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.21,  20110323 " << std::endl;
@


1.79
log
@fixed compatability issues between version 5 and 6
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20a,  20110322 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20a,  20110322 " << std::endl;
@


1.78
log
@fixed test for duplicate record in featratio.dat
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20,  20110321 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20,  20110321 " << std::endl;
@


1.77
log
@fix for backward compat to sce5
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20,  20110317 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20,  20110317 " << std::endl;
@


1.76
log
@fixed memory bug in variable_periods logic for featratio file input processing
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20,  20110315 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20,  20110315 " << std::endl;
@


1.75
log
@platform string clarified
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20.a,  20110310 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20.a,  20110310 " << std::endl;
@


1.74
log
@cplex, and some cleanup
@
text
@d41 1
a41 1
  std::cout << "Version: 6.20,  20110310 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.20,  20110310 " << std::endl;
d50 2
a51 1
  std::cout << "\nPLATFORM ==> " << platform  << std::endl;
@


1.73
log
@selective Sets is working under 6.1
@
text
@d41 1
a41 1
  std::cout << "Version: 6.10, Beta 20100412 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.10, Beta 20100412 " << std::endl;
a47 1
#ifndef SUN4
d50 1
d52 3
d57 2
a58 2
#ifdef WIN32
  platform = "Win32";
d61 1
a61 1
  std::cout << "Platform: " << platform << std::endl;
a64 1
#ifndef SUN4
d68 2
a69 1
#endif
a70 2

#ifndef SUN4
a71 1
#endif
d73 1
a73 1
  std::cout << "(C) COPYRIGHT International Business Machines Corp. 1995, 1997" << std::endl;
@


1.72
log
@mfo is folded into featratio file
@
text
@d41 1
a41 1
  std::cout << "Version: 6.10, Beta 20100407 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.10, Beta 20100407 " << std::endl;
@


1.71
log
@3-29 code date
@
text
@d41 1
a41 1
  std::cout << "Version: 6.10, Beta 20100329 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.10, Beta 20100329 " << std::endl;
@


1.70
log
@more 6.1 changes
@
text
@d41 1
a41 1
  std::cout << "Version: 6.10, Beta 20100210 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.10, Beta 20100210 " << std::endl;
@


1.69
log
@more fixes for 6.1
@
text
@d41 1
a41 1
  std::cout << "Version: 6.10, Beta 20091130 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.10, Beta 20091130" << std::endl;
@


1.68
log
@some SCE 6 enhancements for 1/23 Beta release
@
text
@d41 1
a41 1
  std::cout << "Version: 6.00, Beta 20090123 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 6.00, Beta 20090123" << std::endl;
d282 1
a283 7
  // don't do this if your in scrub only mode
  if (! myScrubber-> scrubOnly())        {
    if (setOfParameters.getBool("doAllocatedMrp")) {
      std::cout << "Running Allocated MRP ... " << std::endl;
      scenarioSP->allocatedMrp();
    }
  }
a284 22
  
  
#if 0
  //  Print to check if the setOfParts have been properly populated
  const LgFrSetOfParts & univSop = scenarioSP->constSetOfParts();
  const LgFrSetOfDemands & univSod = scenarioSP->constSetOfDemands();
  const LgFrSetOfParts & ipSop = scenarioSP->constSetOfParts(LGFR_INTERPLANT_SET);
  
  std::cout << "Part entries : \n" << std::endl;
  int i = 0; // Pulled out of the for below by RW2STL
  for (i = 0; i <  univSop.size(); i++) {
    LgFrPart thisPart = univSop[i];
    
    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisPart.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisPart.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisPart.name() << std::endl;
    std::cout << std::endl;
  }
d286 4
a289 13
  std::cout << "Inter Plant SOP entries : \n" << std::endl;
  for ( i = 0; i <  ipSop.size(); i++) {
    LgFrPart thisPart = ipSop[i];

    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisPart.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisPart.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisPart.name() << std::endl;
    std::cout << std::endl;
  }
a290 14
#if 0
  std::cout << "Demand entries : \n" << std::endl;
  for ( i = 0; i <  univSod.size(); i++) {
    LgFrDemand thisDemand = univSod[i];

    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisDemand.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisDemand.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisDemand.name() << std::endl;
    std::cout << std::endl;
  }
d293 3
a296 2
  // Get schedule factory from scenario
  const LgFrScheduleFactory * sFactoryPtr = scenarioSP->scheduleFactory();
d299 2
a300 1
  // Create some part schedules.
a301 2
  // See LgFrScheduleFactory::newPartScheduleFromScratch in
  // scenario/src/schFctry.C.
a302 36
  LgFrSortingPartScheduleFloatSmartPointer
     supplyVol =
        sFactoryPtr->newPartSchedule( LGFRSupplyVolume );

  LgFrSortingPartScheduleFloatSmartPointer
     cycleTime =
        sFactoryPtr->newPartSchedule( LGFRCycleTime );

  LgFrSortingPartScheduleFloatSmartPointer
     interPlantVol =
        sFactoryPtr->newPartSchedule( LGFRInterPlantSupplyVolume );

  // Print the schedules
  std::cout <<"SupplyVol:"       <<std::endl;
  std::cout <<supplyVol->format() <<std::endl;
  std::cout <<"CycleTime:"       <<std::endl;
  std::cout <<cycleTime->format() <<std::endl;
  std::cout <<"Inter Plant Supply Volume:"       <<std::endl;
  std::cout << interPlantVol->format() <<std::endl;

  // Create and print some demand schedules  (LGFRDemandVol)

  LgFrSortingDemandScheduleFloatSmartPointer
     demandVol =
        sFactoryPtr->newDemandSchedule( LGFRDemandVolume );

  LgFrSortingDemandScheduleFloatSmartPointer
     shpmntVol =
        sFactoryPtr->newDemandSchedule( LGFRShipmentVolume );

  // Print the schedules
  std::cout <<"Demand Vol:"       <<std::endl;
  std::cout <<demandVol->format() <<std::endl;
  std::cout <<"Shipment Vol:"       <<std::endl;
  std::cout <<shpmntVol->format() <<std::endl;
#endif
a303 1
#ifdef SCE_ODBC
a304 8
  if (pDB)
    delete pDB;

#endif

  // figure out what return code to pass
  MclFacility * myFacil = scenarioSP->getErrFacility();
  int level = myFacil -> maxSeverityOfMsgsIssued();
@


1.67
log
@final release for 5.02
@
text
@d41 1
a41 1
  std::cout << "Version: 5.02, 20081201 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.02, 20081201" << std::endl;
@


1.66
log
@fixed bug processing multple negativeVol demand streams
@
text
@d41 1
a41 1
  std::cout << "Version: 5.01, 20080919 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.01, 20090919" << std::endl;
@


1.65
log
@Last commit for maxForAtp
@
text
@d41 1
a41 1
  std::cout << "Version: 5.00, 20080623 " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.00, 20080623" << std::endl;
@


1.64
log
@enabled customer choice for max ATP
@
text
@d41 1
a41 1
  std::cout << "Version: 5.00, 20080605 BETA " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.00, 20080605 BETA" << std::endl;
@


1.63
log
@first pass at maxImpliedCommitForATP
@
text
@d41 1
a41 1
  std::cout << "Version: 5.00, 20080604 BETA " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.00, 20080604 BETA" << std::endl;
@


1.62
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@d41 1
a41 1
  std::cout << "Version: 5.00, 20080424 BETA " << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.00, 20080424 BETA" << std::endl;
@


1.61
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d41 1
a41 1
  std::cout << "Version: 5.01, BETA" << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.01, BETA" << std::endl;
d229 1
a229 1
#ifdef MULTIPLE_IMPLOSION RUNS
d398 1
a398 1
  // figure out what retrun code to pass
@


1.60
log
@Version 5.  initial commit
@
text
@d41 1
a41 1
  std::cout << "Version: 5.00, BETA" << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.00, BETA" << std::endl;
@


1.59
log
@added function to report interplantPeg from perspective of supplier location.   basically, this shifts the interplant peg earlier to accomodate interplant lead-times
@
text
@d41 1
a41 1
  std::cout << "Version: 4.62, 20070529" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.62, 20070529" << std::endl;
a72 1
  // Some legal mumbo-jumbo
d172 4
a185 8

  // ==================================
  // === Model is automatically loaded.
  // ==================================




d198 2
a199 4


 if (! myScrubber-> scrubOnly())
 {
d202 1
a202 2

 }
d208 10
a217 10

 if (! myScrubber-> scrubOnly())
 {
  if (doImplode)
    scenarioSP->runImplosion(scenarioSP);

  // =====================================================================
  // Call another API routine to do all the output stuff
  if (doImplode) {

d219 2
a220 2
    std::cout << "Populate the database with output results ..." << std::endl;
    scenarioSP->analyzeRunAndUpdateDB();
d222 21
a242 4
    // don't do this if your in scrub only mode
    if (! myScrubber-> scrubOnly())        {
      std::cout << "Writing output results ..." << std::endl;
      scenarioSP->analyzeRunAndPrintResults();
d244 1
a244 5
#endif

  }
 }

d250 1
a250 1

d255 1
a255 1

d259 2
a260 2
             << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
             << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
d265 1
a265 1

d269 2
a270 2
           << "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
           << ")" << std::endl;
d276 2
a277 2
           << "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
           << "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
d282 1
a282 1

d290 3
a292 3



d298 1
a298 1

d303 1
a303 1

@


1.58
log
@updated banner for 4.60
@
text
@d41 1
a41 1
  std::cout << "Version: 4.60, 20070321" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.60, 20070321" << std::endl;
@


1.57
log
@sce 4.60, scrapCost, stockCost, greedySearchIncrement,pegging in heuristic, removal of optWithLotSizes
@
text
@d41 1
a41 1
  std::cout << "Version: 4.60, 20070320 beta" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.60, 20070320 beta" << std::endl;
@


1.56
log
@enabled buildAheadFile function
@
text
@d41 1
a41 1
  std::cout << "Version: 4.50,  20060811" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.50,  20060811" << std::endl;
@


1.55
log
@shut off debugging and renamed to SCE 4.32  (for ServerGroup), will
rename again for SOAR
@
text
@d41 1
a41 1
  std::cout << "Version: 4.32,  20060811" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.32,  20060811" << std::endl;
@


1.54
log
@initial changes for sce4.40
@
text
@d41 1
a41 1
  std::cout << "Version: 4.40,  pre-release" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.40,  pre-release" << std::endl;
@


1.53
log
@SCE 4.30 (backed off from calling sce 5.00) has multi-source and Gpip
@
text
@d41 1
a41 1
  std::cout << "Version: 4.30,  20060713" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.30,  20060713" << std::endl;
@


1.52
log
@Preliminary commit for SCE 5.00
@
text
@d41 1
a41 1
  std::cout << "Version: 5.0,  20060626 BETA" << std::endl;
d44 1
a44 1
  std::cout << "Version: 5.0,  20060626 BETA" << std::endl;
@


1.51
log
@comitting changes made on production branch that were merged in ... woohooo
@
text
@d41 1
a41 1
  std::cout << "Version: 4.20,  20060531 rev06" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20060531 rev06" << std::endl;
@


1.50
log
@set to use witSetNewPipPggOrder
@
text
@d27 1
a27 1
// Uncomment this line if you want to build a version of SCE that 
d41 1
a41 1
  std::cout << "Version: 4.20,  20060523 rev04" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20060523 rev04" << std::endl;
d59 1
a59 1
 
d76 2
a77 1
  std::cout << "Property of IBM\n" << std::endl;      
a78 1
  
d82 1
a82 1
    
d84 1
a84 1
  
d111 1
a111 1
  
d129 1
a129 1
    
d132 1
a132 1
    
d134 1
a134 1
  
d142 2
a143 2
	difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
	  (parameterFileName, argv[3], true, true);
d145 2
a146 2
	difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
	  (parameterFileName, argv[3], true, false);
d148 3
a150 3
	std::cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << std::endl;
	std::cout << "SCE terminates" << std::endl;
	exit(8);
d154 4
a157 4
	{
	  std::cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << std::endl;
	  exit(8);
	}
d162 1
a162 1
	= new LgFrDataInterfaceImplementationFromSceFiles(parameterFileName);
d166 1
a166 1
  
d169 1
a169 1
  
d171 2
a172 2
  LgFrScenarioBuilderForSce builder;      
  LgFrScenarioDirector director(&builder);  
d175 2
a176 2
  
  // this is just a test to ensure that purify is working 
d178 1
a178 1
  
d180 1
a180 1
  
d198 2
a199 2
  
  
d204 1
a204 1
 
d209 1
a209 1
    
d211 1
a211 1
  
d216 1
a216 1
  
d218 2
a219 2
 {  
  if (doImplode) 
d221 1
a221 1
  
d225 1
a225 1
    
d230 2
a231 2
    // don't do this if your in scrub only mode    
    if (! myScrubber-> scrubOnly())        {  
d236 1
a236 1
    
d247 1
a247 1
    if (! myScrubber-> scrubOnly())        {  
d251 1
a251 1
    if (! myScrubber-> scrubOnly())        {  
d253 5
a257 5
	std::cout << "Singleton Queries ... " 
	     << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
	     << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
	     << ")" << std::endl;
	scenarioSP->singletonFss();
d260 1
a260 1
    
d262 4
a265 4
      std::cout << "General Set Queries ... " 
	   << "(method:" << setOfParameters.getString("fssGeneralSetMethod") << "    "
	   << "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
	   << ")" << std::endl;
d268 1
a268 1
    
d270 4
a273 4
      std::cout << "Machine Queries ... " 
	   << "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
	   << "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
	   << ")" << std::endl;
d279 1
a279 1
  if (! myScrubber-> scrubOnly())        {  
d287 1
a287 1
  
d346 1
a346 1
  // See LgFrScheduleFactory::newPartScheduleFromScratch in 
d351 1
a351 1
	sFactoryPtr->newPartSchedule( LGFRSupplyVolume );
d355 1
a355 1
	sFactoryPtr->newPartSchedule( LGFRCycleTime );
d359 2
a360 2
	sFactoryPtr->newPartSchedule( LGFRInterPlantSupplyVolume );
  
d373 1
a373 1
	sFactoryPtr->newDemandSchedule( LGFRDemandVolume );
d377 1
a377 1
	sFactoryPtr->newDemandSchedule( LGFRShipmentVolume );
d390 1
a390 1
  
d399 1
a399 1
  // max message issued was "info" 
@


1.50.2.1
log
@Rev 06 changes ... on production branch
@
text
@d27 1
a27 1
// Uncomment this line if you want to build a version of SCE that
d41 1
a41 1
  std::cout << "Version: 4.20,  20060531 rev06" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20060531 rev06" << std::endl;
d59 1
a59 1

d76 1
a76 2
  std::cout << "Property of IBM\n" << std::endl;

d78 1
d82 1
a82 1

d84 1
a84 1

d111 1
a111 1

d129 1
a129 1

d132 1
a132 1

d134 1
a134 1

d142 2
a143 2
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], true, true);
d145 2
a146 2
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], true, false);
d148 3
a150 3
        std::cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << std::endl;
        std::cout << "SCE terminates" << std::endl;
        exit(8);
d154 4
a157 4
        {
          std::cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << std::endl;
          exit(8);
        }
d162 1
a162 1
        = new LgFrDataInterfaceImplementationFromSceFiles(parameterFileName);
d166 1
a166 1

d169 1
a169 1

d171 2
a172 2
  LgFrScenarioBuilderForSce builder;
  LgFrScenarioDirector director(&builder);
d175 2
a176 2

  // this is just a test to ensure that purify is working
d178 1
a178 1

d180 1
a180 1

d198 2
a199 2


d204 1
a204 1

d209 1
a209 1

d211 1
a211 1

d216 1
a216 1

d218 2
a219 2
 {
  if (doImplode)
d221 1
a221 1

d225 1
a225 1

d230 2
a231 2
    // don't do this if your in scrub only mode
    if (! myScrubber-> scrubOnly())        {
d236 1
a236 1

d247 1
a247 1
    if (! myScrubber-> scrubOnly())        {
d251 1
a251 1
    if (! myScrubber-> scrubOnly())        {
d253 5
a257 5
        std::cout << "Singleton Queries ... "
             << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
             << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
             << ")" << std::endl;
        scenarioSP->singletonFss();
d260 1
a260 1

d262 4
a265 4
      std::cout << "General Set Queries ... "
           << "(method:" << setOfParameters.getString("fssGeneralSetMethod") << "    "
           << "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
           << ")" << std::endl;
d268 1
a268 1

d270 4
a273 4
      std::cout << "Machine Queries ... "
           << "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
           << "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
           << ")" << std::endl;
d279 1
a279 1
  if (! myScrubber-> scrubOnly())        {
d287 1
a287 1

d346 1
a346 1
  // See LgFrScheduleFactory::newPartScheduleFromScratch in
d351 1
a351 1
        sFactoryPtr->newPartSchedule( LGFRSupplyVolume );
d355 1
a355 1
        sFactoryPtr->newPartSchedule( LGFRCycleTime );
d359 2
a360 2
        sFactoryPtr->newPartSchedule( LGFRInterPlantSupplyVolume );

d373 1
a373 1
        sFactoryPtr->newDemandSchedule( LGFRDemandVolume );
d377 1
a377 1
        sFactoryPtr->newDemandSchedule( LGFRShipmentVolume );
d390 1
a390 1

d399 1
a399 1
  // max message issued was "info"
@


1.49
log
@updated banner to rev03
@
text
@d41 1
a41 1
  std::cout << "Version: 4.20,  20051222 rev03" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20051222 rev03" << std::endl;
@


1.48
log
@rev 02 masthead
@
text
@d41 1
a41 1
  std::cout << "Version: 4.20,  20051222 rev02" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20051222 rev02" << std::endl;
@


1.47
log
@changed banner for release
@
text
@d41 1
a41 1
  std::cout << "Version: 4.20,  20051222" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20051222" << std::endl;
@


1.46
log
@pre-release
@
text
@d41 1
a41 1
  std::cout << "Version: 4.20,  20050824" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.20,  20050824 (pre-release)" << std::endl;
@


1.45
log
@cleanup before tagging
@
text
@d41 1
a41 1
  std::cout << "Version: 4.10,  20050511" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.10,  20050511" << std::endl;
d207 1
a207 1
      scenarioSP->runExplosion();
@


1.44
log
@sce4.10 changes
@
text
@d41 1
a41 1
  std::cout << "Version: 4.10,  20050406" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.10,  20050406" << std::endl;
@


1.43
log
@preping for release 4.1
@
text
@d41 1
a41 1
  std::cout << "Version: 4.10,  20050214 (development)" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.10,  20050214 (development)" << std::endl;
@


1.42
log
@feature sets logic automatically uses proportional routing when engine is NOT optimization.   for optimization, it uses the OLD BBCat modelling trick.
@
text
@d41 1
a41 1
  std::cout << "Version: 4.08,  20041007 (development)" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.08,  20041007 (development)" << std::endl;
@


1.41
log
@updated banner for release 4.07 ... 64bit fix
@
text
@d41 1
a41 1
  std::cout << "Version: 4.07,  20040910" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.07,  20040910" << std::endl;
@


1.40
log
@updated release number
@
text
@d41 1
a41 1
  std::cout << "Version: 4.05,  20040511" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.05,  20040511" << std::endl;
@


1.39
log
@added ProdVol from ProdVol Peg files
@
text
@d41 1
a41 1
  std::cout << "Version: 4.03,  20040407" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.03,  20040407" << std::endl;
@


1.38
log
@banner
@
text
@d41 1
a41 1
  std::cout << "Version: 4.02,  20040304" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.02,  20040304" << std::endl;
@


1.37
log
@Modified to reduce microsoft compiler warning messages
@
text
@d41 1
a41 1
  std::cout << "Version: 4.02,  20040301" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.02,  20040301" << std::endl;
@


1.36
log
@added vac calculation
@
text
@d1 1
a1 1

@


1.35
log
@changed release banner
@
text
@d41 1
a41 1
  std::cout << "Version: 4.01,  20040226" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.01,  20040226" << std::endl;
@


1.34
log
@update the banner for 4.0.1
@
text
@d41 1
a41 1
  std::cout << "Version: 4.01,  20040220" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.01,  20040220" << std::endl;
@


1.33
log
@pip for LP engine
@
text
@d41 1
a41 1
  std::cout << "Version: 4.01,  20040213 BETA" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.01,  20040213 BETA" << std::endl;
@


1.32
log
@banner
@
text
@d41 1
a41 1
  std::cout << "Version: 4.00,  20040201" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.00,  20040201" << std::endl;
@


1.31
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@d41 1
a41 1
  std::cout << "Version: 4.00,  20040130" << std::endl;
d44 1
a44 1
  std::cout << "Version: 4.00,  20040130" << std::endl;
@


1.30
log
@rearranged to gt PIP after postProcess
@
text
@d41 1
a41 1
  std::cout << "Version: 3.40,  20040112" << std::endl;
d44 1
a44 1
  std::cout << "Version: 3.40,  20040112" << std::endl;
@


1.29
log
@removed beta from banner
@
text
@d41 1
a41 1
  std::cout << "Version: 3.30,  20030627" << std::endl;
d44 1
a44 1
  std::cout << "Version: 3.30,  20030627" << std::endl;
@


1.28
log
@minor updates for SCE
@
text
@d41 1
a41 1
  std::cout << "Version: 3.30,  20030627 BETA" << std::endl;
d44 1
a44 1
  std::cout << "Version: 3.30,  20030627 BETA" << std::endl;
@


1.27
log
@modified smartExplode to enable  interplant sourced parts with missing
effective intervals so that they can explode.   Solution is to enable
any bop such that:
    producedPart is non-pcf,
    producedPart has 2 or more producing bops,
    default operation has zero bom entries
@
text
@d41 1
a41 1
  std::cout << "Version: 3.20,  20030120 rev01" << std::endl;
d44 1
a44 1
  std::cout << "Version: 3.20,  20030120 rev01" << std::endl;
@


1.26
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d41 1
a41 1
  std::cout << "Version: 3.12,  20020906" << std::endl;
d44 1
a44 1
  std::cout << "Version: 3.12,  20020906" << std::endl;
@


1.25
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1 6
d8 1
a8 1
#include <iostream.h>
d38 1
d40 2
a41 2
  cout << "\nScrub Utility for Supply Capability Engine" << endl;
  cout << "Version: 3.12,  20020906" << endl;
d43 2
a44 2
  cout << "\nSupply Capability Engine" << endl;
  cout << "Version: 3.12,  20020906" << endl;
d47 1
a47 2

  RWCString platform("unknown");
d58 1
a58 1
  cout << "Platform: " << platform << endl;
d61 1
a61 1
  RWCString exe_type("unknown");
d67 1
a67 1
  cout << "Build type: " << exe_type  << endl ;
d70 1
a70 1
  cout << "Build date: " <<  __DATE__  << endl << endl;
d74 3
a76 3
  cout << "(C) COPYRIGHT International Business Machines Corp. 1995, 1997" << endl;
  cout << "All Rights Reserved" << endl;
  cout << "Property of IBM\n" << endl;      
d79 1
a79 1
  LgFrCalendar calendar(8, RWTime(RWDate("8/01/95")));
d88 1
a88 1
    cout << "Error.  Usage:  scemain <parameterFileName>  <dbName>" << endl;
d90 2
a91 2
    cout << "     or Usage:  scemain <parameterFileName> <dbName> " << endl;
    cout << "                       <dbInstance> <userID> <password>" << endl;
d103 1
a103 1
  cout << endl << "Connecting the database ... " << endl;
d106 1
a106 1
      cout<< "Database connection failed." << endl;
d110 1
a110 1
    cout<< "Database connection SUCCESSFUL!" <<endl<<endl;
d117 1
a117 1
      cout << "Error.  Usage is: sceScrub <parameterFileName> <T> <scrubDir>" << endl;
d123 1
a123 1
    cout << "Error.  Usage is: scemain <parameterFileName> " << endl;
d133 1
a133 1
  RWCString parameterFileName (argv[1]);
d141 1
a141 1
      if (RWCString(argv[2]) == 'T')
d143 2
a144 2
	  (parameterFileName, argv[3], TRUE, TRUE);
      else if (RWCString(argv[2]) == 'F') {
d146 1
a146 1
	  (parameterFileName, argv[3], TRUE, FALSE);
d148 2
a149 2
	cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << endl;
	cout << "SCE terminates" << endl;
d155 1
a155 1
	  cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << endl;
d215 1
a215 1
  RWBoolean doImplode = setOfParameters.getBool("doImplode");
d227 1
a227 1
    cout << "Populate the database with output results ..." << endl;
d232 1
a232 1
      cout << "Writing output results ..." << endl;
d244 1
a244 1
  RWBoolean fssFlag = setOfParameters.getBool("fssFlag");
d248 1
a248 1
      cout << "Running FSS Engines ... " << endl;
d253 1
a253 1
	cout << "Singleton Queries ... " 
d256 1
a256 1
	     << ")" << endl;
d262 1
a262 1
      cout << "General Set Queries ... " 
d265 1
a265 1
	   << ")" << endl;
d270 1
a270 1
      cout << "Machine Queries ... " 
d273 1
a273 1
	   << ")" << endl;
d281 1
a281 1
      cout << "Running Allocated MRP ... " << endl;
d294 3
a296 2
  cout << "Part entries : \n" << endl;
  for (int i = 0; i <  univSop.entries(); i++) {
d299 8
a306 8
    cout << "The " << i << "entry: " << endl;
    cout << "Printing Name = ";
    cout << thisPart.printingName() << endl;
    cout << "Unique Name = ";
    cout << thisPart.uniqueName() << endl;
    cout << "Name = ";
    cout << thisPart.name() << endl;
    cout << endl;
d309 2
a310 2
  cout << "Inter Plant SOP entries : \n" << endl;
  for ( i = 0; i <  ipSop.entries(); i++) {
d313 8
a320 8
    cout << "The " << i << "entry: " << endl;
    cout << "Printing Name = ";
    cout << thisPart.printingName() << endl;
    cout << "Unique Name = ";
    cout << thisPart.uniqueName() << endl;
    cout << "Name = ";
    cout << thisPart.name() << endl;
    cout << endl;
d324 2
a325 2
  cout << "Demand entries : \n" << endl;
  for ( i = 0; i <  univSod.entries(); i++) {
d328 8
a335 8
    cout << "The " << i << "entry: " << endl;
    cout << "Printing Name = ";
    cout << thisDemand.printingName() << endl;
    cout << "Unique Name = ";
    cout << thisDemand.uniqueName() << endl;
    cout << "Name = ";
    cout << thisDemand.name() << endl;
    cout << endl;
d362 6
a367 6
  cout <<"SupplyVol:"       <<endl;
  cout <<supplyVol->format() <<endl;
  cout <<"CycleTime:"       <<endl;
  cout <<cycleTime->format() <<endl;
  cout <<"Inter Plant Supply Volume:"       <<endl;
  cout << interPlantVol->format() <<endl;
d380 4
a383 4
  cout <<"Demand Vol:"       <<endl;
  cout <<demandVol->format() <<endl;
  cout <<"Shipment Vol:"       <<endl;
  cout <<shpmntVol->format() <<endl;
d397 1
a397 1
  cout << "SCE Completed.  Return Code:" << flush;
d401 1
a401 1
    cout << " 0" << endl;
d406 1
a406 1
    cout << " 4" << endl;
d411 1
a411 1
    cout << " 8" << endl;
@


1.25.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d41 1
a41 1
  std::string platform("unknown");
d55 1
a55 1
  std::string exe_type("unknown");
d73 1
a73 1
  LgFrCalendar calendar(8, SCETime(SCEDate("8/01/95")));
d127 1
a127 1
  std::string parameterFileName (argv[1]);
d135 1
a135 1
      if (argv[2][0] == 'T')
d137 2
a138 2
	  (parameterFileName, argv[3], true, true);
      else if (argv[2][0] == 'F') {
d140 1
a140 1
	  (parameterFileName, argv[3], true, false);
d209 1
a209 1
  bool doImplode = setOfParameters.getBool("doImplode");
d238 1
a238 1
  bool fssFlag = setOfParameters.getBool("fssFlag");
d289 1
a289 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i = 0; i <  univSop.size(); i++) {
d303 1
a303 1
  for ( i = 0; i <  ipSop.size(); i++) {
d318 1
a318 1
  for ( i = 0; i <  univSod.size(); i++) {
@


1.25.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d8 1
a8 1
#include <iostream>
d39 2
a40 2
  std::cout << "\nScrub Utility for Supply Capability Engine" << std::endl;
  std::cout << "Version: 3.12,  20020906" << std::endl;
d42 2
a43 2
  std::cout << "\nSupply Capability Engine" << std::endl;
  std::cout << "Version: 3.12,  20020906" << std::endl;
d46 1
d58 1
a58 1
  std::cout << "Platform: " << platform << std::endl;
d67 1
a67 1
  std::cout << "Build type: " << exe_type  << std::endl ;
d70 1
a70 1
  std::cout << "Build date: " <<  __DATE__  << std::endl << std::endl;
d74 3
a76 3
  std::cout << "(C) COPYRIGHT International Business Machines Corp. 1995, 1997" << std::endl;
  std::cout << "All Rights Reserved" << std::endl;
  std::cout << "Property of IBM\n" << std::endl;      
d88 1
a88 1
    std::cout << "Error.  Usage:  scemain <parameterFileName>  <dbName>" << std::endl;
d90 2
a91 2
    std::cout << "     or Usage:  scemain <parameterFileName> <dbName> " << std::endl;
    std::cout << "                       <dbInstance> <userID> <password>" << std::endl;
d103 1
a103 1
  std::cout << std::endl << "Connecting the database ... " << std::endl;
d106 1
a106 1
      std::cout<< "Database connection failed." << std::endl;
d110 1
a110 1
    std::cout<< "Database connection SUCCESSFUL!" <<std::endl<<std::endl;
d117 1
a117 1
      std::cout << "Error.  Usage is: sceScrub <parameterFileName> <T> <scrubDir>" << std::endl;
d123 1
a123 1
    std::cout << "Error.  Usage is: scemain <parameterFileName> " << std::endl;
d148 2
a149 2
	std::cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << std::endl;
	std::cout << "SCE terminates" << std::endl;
d155 1
a155 1
	  std::cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << std::endl;
d227 1
a227 1
    std::cout << "Populate the database with output results ..." << std::endl;
d232 1
a232 1
      std::cout << "Writing output results ..." << std::endl;
d248 1
a248 1
      std::cout << "Running FSS Engines ... " << std::endl;
d253 1
a253 1
	std::cout << "Singleton Queries ... " 
d256 1
a256 1
	     << ")" << std::endl;
d262 1
a262 1
      std::cout << "General Set Queries ... " 
d265 1
a265 1
	   << ")" << std::endl;
d270 1
a270 1
      std::cout << "Machine Queries ... " 
d273 1
a273 1
	   << ")" << std::endl;
d281 1
a281 1
      std::cout << "Running Allocated MRP ... " << std::endl;
d294 1
a294 1
  std::cout << "Part entries : \n" << std::endl;
d299 8
a306 8
    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisPart.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisPart.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisPart.name() << std::endl;
    std::cout << std::endl;
d309 1
a309 1
  std::cout << "Inter Plant SOP entries : \n" << std::endl;
d313 8
a320 8
    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisPart.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisPart.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisPart.name() << std::endl;
    std::cout << std::endl;
d324 1
a324 1
  std::cout << "Demand entries : \n" << std::endl;
d328 8
a335 8
    std::cout << "The " << i << "entry: " << std::endl;
    std::cout << "Printing Name = ";
    std::cout << thisDemand.printingName() << std::endl;
    std::cout << "Unique Name = ";
    std::cout << thisDemand.uniqueName() << std::endl;
    std::cout << "Name = ";
    std::cout << thisDemand.name() << std::endl;
    std::cout << std::endl;
d362 6
a367 6
  std::cout <<"SupplyVol:"       <<std::endl;
  std::cout <<supplyVol->format() <<std::endl;
  std::cout <<"CycleTime:"       <<std::endl;
  std::cout <<cycleTime->format() <<std::endl;
  std::cout <<"Inter Plant Supply Volume:"       <<std::endl;
  std::cout << interPlantVol->format() <<std::endl;
d380 4
a383 4
  std::cout <<"Demand Vol:"       <<std::endl;
  std::cout <<demandVol->format() <<std::endl;
  std::cout <<"Shipment Vol:"       <<std::endl;
  std::cout <<shpmntVol->format() <<std::endl;
d397 1
a397 1
  std::cout << "SCE Completed.  Return Code:" << std::flush;
d401 1
a401 1
    std::cout << " 0" << std::endl;
d406 1
a406 1
    std::cout << " 4" << std::endl;
d411 1
a411 1
    std::cout << " 8" << std::endl;
@


1.25.2.3
log
@New LgFrDatetime class
@
text
@a37 1

d78 1
a78 1
  LgFrCalendar calendar(8, LgFrDatetime("8/01/95"));
@


1.24
log
@updated banner for release 3.12
@
text
@d5 1
@


1.23
log
@bogon output, and minor changes
@
text
@d33 1
a33 1
  cout << "Version: 3.12,  20020808" << endl;
d36 1
a36 1
  cout << "Version: 3.12,  20020808" << endl;
@


1.22
log
@print lowest level non-pcf files
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20020702 Rev04" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20020702 Rev04" << endl;
d174 17
d196 1
a196 1
 LgFrSceScrubber * myScrubber = scenarioSP -> scrubber();
@


1.21
log
@new param ... aggregateSupplyInScrub needed by ATS
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20020619 Rev02" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20020619 Rev02" << endl;
@


1.20
log
@test
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20020327 Rev01" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20020327 Rev01" << endl;
@


1.19
log
@marked it as rev01
@
text
@d39 1
@


1.18
log
@3.11 commit
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20020327" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20020327" << endl;
@


1.17
log
@file cleaning ... more pegging ... parameters ...
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  DEVELOPMENT" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  DEVELOPMENT" << endl;
@


1.16
log
@changed banner for SCE 3.104 commit
@
text
@d33 1
a33 1
  cout << "Version: 3.104,  20011211" << endl;
d36 1
a36 1
  cout << "Version: 3.104,  20011211" << endl;
@


1.15
log
@yet another fix for setPureOptionBuild.
New parameter: shutOffAllLotSizing ... which does just that
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20011214 -- Development" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20011214 -- Development" << endl;
@


1.14
log
@commit for 3.103
@
text
@d33 1
a33 1
  cout << "Version: 3.103,  20011019" << endl;
d36 1
a36 1
  cout << "Version: 3.103,  20011019" << endl;
@


1.13
log
@Fixes in demandDriver logic tobe more efficent with Memory usage
@
text
@d33 1
a33 1
  cout << "Version: 3.102,  20011019 Release" << endl;
d36 1
a36 1
  cout << "Version: 3.102,  20011019 Release" << endl;
@


1.12
log
@shortcut bug fix for when CC featureratio's are constant
@
text
@d33 1
a33 1
  cout << "Version: 3.101,  20011019 Release" << endl;
d36 1
a36 1
  cout << "Version: 3.101,  20011019 Release" << endl;
@


1.11
log
@premiminary coomit for release 3.11
@
text
@d33 1
a33 1
  cout << "Version: 3.11,  20011031 Development" << endl;
d36 1
a36 1
  cout << "Version: 3.11,  20011031 Development" << endl;
@


1.10
log
@minor change for production commit
@
text
@d33 1
a33 1
  cout << "Version: 3.10,  20010924 Rev00" << endl;
d36 1
a36 1
  cout << "Version: 3.10,  20010924 Rev00" << endl;
@


1.9
log
@3.10 pegging capability
@
text
@d33 1
a33 1
  cout << "Version: 3.10,  20010924" << endl;
d36 1
a36 1
  cout << "Version: 3.10,  20010924" << endl;
@


1.8
log
@Preliminary Commit for release 3.10 ... still in development!!!!
@
text
@d33 1
a33 1
  cout << "Version: 3.10,  20010830 DEVELOPMENT " << endl;
d36 1
a36 1
  cout << "Version: 3.10,  20010830 DEVELOPMENT" << endl;
@


1.7
log
@test of CVS
@
text
@d33 1
a33 1
  cout << "Version: 3.00,  20010601 Rev01 " << endl;
d36 1
a36 1
  cout << "Version: 3.00,  20010601 Rev01 test" << endl;
@


1.6
log
@3.00 20010601 Rev 01: Fix: Demand Driver did not report or analyze
independent demand.
@
text
@d36 1
a36 1
  cout << "Version: 3.00,  20010601 Rev01" << endl;
@


1.5
log
@changes for Release 3.00
@
text
@d33 1
a33 1
  cout << "Version: 3.00,  20010601 " << endl;
d36 1
a36 1
  cout << "Version: 3.00,  20010601 " << endl;
@


1.5.2.1
log
@Commit for Rev01: Demand drivers were not reporting on independent demand.
@
text
@d33 1
a33 1
  cout << "Version: 3.00,  20010601 Rev01 " << endl;
d36 1
a36 1
  cout << "Version: 3.00,  20010601 Rev01" << endl;
@


1.5.2.2
log
@bug fix for Rev02.
removed an assert that was incorrect.
@
text
@d33 1
a33 1
  cout << "Version: 3.00,  20010601 Rev02 " << endl;
d36 1
a36 1
  cout << "Version: 3.00,  20010601 Rev02" << endl;
@


1.4
log
@Fixed memory bug in Customer Choice Feature logic
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20010308 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20010308 " << endl;
d45 5
@


1.3
log
@ADded indpendent demand file to scrubber list.
Fixed bug in feature ratio check for all zero (it was reporting any zero
condition as all zero)
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20001003 Rev02 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20001003 Rev02" << endl;
@


1.3.2.1
log
@banner
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20010308 Rev02 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20010308 Rev02" << endl;
@


1.3.2.2
log
@changed banner again
@
text
@d20 1
a20 1
// Uncomment this line if you want to build a version of SCE that
d33 1
a33 1
  cout << "Version: 2.31,  20010308 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20010308 " << endl;
d46 1
a46 1

d63 1
a63 2
  cout << "Property of IBM\n" << endl;

d65 1
d69 1
a69 1

d71 1
a71 1

d98 1
a98 1

d116 1
a116 1

d119 1
a119 1

d121 1
a121 1

d129 2
a130 2
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], TRUE, TRUE);
d132 2
a133 2
        difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
          (parameterFileName, argv[3], TRUE, FALSE);
d135 3
a137 3
        cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << endl;
        cout << "SCE terminates" << endl;
        exit(8);
d141 4
a144 4
        {
          cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << endl;
          exit(8);
        }
d149 1
a149 1
        = new LgFrDataInterfaceImplementationFromSceFiles(parameterFileName);
d153 1
a153 1

d156 1
a156 1

d158 2
a159 2
  LgFrScenarioBuilderForSce builder;
  LgFrScenarioDirector director(&builder);
d162 2
a163 2

  // this is just a test to ensure that purify is working
d165 1
a165 1

d167 3
a169 3



d174 1
a174 1

d179 1
a179 1

d181 1
a181 1

d186 1
a186 1

d188 2
a189 2
 {
  if (doImplode)
d191 1
a191 1

d195 1
a195 1

d200 2
a201 2
    // don't do this if your in scrub only mode
    if (! myScrubber-> scrubOnly())        {
d206 1
a206 1

d217 1
a217 1
    if (! myScrubber-> scrubOnly())        {
d221 1
a221 1
    if (! myScrubber-> scrubOnly())        {
d223 5
a227 5
        cout << "Singleton Queries ... "
             << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
             << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
             << ")" << endl;
        scenarioSP->singletonFss();
d230 1
a230 1

d232 4
a235 4
      cout << "General Set Queries ... "
           << "(method:" << setOfParameters.getString("fssGeneralSetMethod") << "    "
           << "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
           << ")" << endl;
d238 1
a238 1

d240 4
a243 4
      cout << "Machine Queries ... "
           << "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
           << "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
           << ")" << endl;
d249 1
a249 1
  if (! myScrubber-> scrubOnly())        {
d257 1
a257 1

d315 1
a315 1
  // See LgFrScheduleFactory::newPartScheduleFromScratch in
d320 1
a320 1
        sFactoryPtr->newPartSchedule( LGFRSupplyVolume );
d324 1
a324 1
        sFactoryPtr->newPartSchedule( LGFRCycleTime );
d328 2
a329 2
        sFactoryPtr->newPartSchedule( LGFRInterPlantSupplyVolume );

d342 1
a342 1
        sFactoryPtr->newDemandSchedule( LGFRDemandVolume );
d346 1
a346 1
        sFactoryPtr->newDemandSchedule( LGFRShipmentVolume );
d359 1
a359 1

d368 1
a368 1
  // max message issued was "info"
@


1.3.2.3
log
@Customer Choice bug fix and memory leak patch.
@
text
@d20 1
a20 1
// Uncomment this line if you want to build a version of SCE that 
d46 1
a46 1
 
d63 2
a64 1
  cout << "Property of IBM\n" << endl;      
a65 1
  
d69 1
a69 1
    
d71 1
a71 1
  
d98 1
a98 1
  
d116 1
a116 1
    
d119 1
a119 1
    
d121 1
a121 1
  
d129 2
a130 2
	difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
	  (parameterFileName, argv[3], TRUE, TRUE);
d132 2
a133 2
	difSceFImpPtr = new LgFrDataInterfaceImplementationFromSceFiles
	  (parameterFileName, argv[3], TRUE, FALSE);
d135 3
a137 3
	cout << "Error.  <scrubOnly> parameter MUST be \"T\"  " << endl;
	cout << "SCE terminates" << endl;
	exit(8);
d141 4
a144 4
	{
	  cout << "Error.  <scrubOnly> argument MUST be \"T\" or \"F\" " << endl;
	  exit(8);
	}
d149 1
a149 1
	= new LgFrDataInterfaceImplementationFromSceFiles(parameterFileName);
d153 1
a153 1
  
d156 1
a156 1
  
d158 2
a159 2
  LgFrScenarioBuilderForSce builder;      
  LgFrScenarioDirector director(&builder);  
d162 2
a163 2
  
  // this is just a test to ensure that purify is working 
d165 1
a165 1
  
d167 3
a169 3
  
  
  
d174 1
a174 1
 
d179 1
a179 1
    
d181 1
a181 1
  
d186 1
a186 1
  
d188 2
a189 2
 {  
  if (doImplode) 
d191 1
a191 1
  
d195 1
a195 1
    
d200 2
a201 2
    // don't do this if your in scrub only mode    
    if (! myScrubber-> scrubOnly())        {  
d206 1
a206 1
    
d217 1
a217 1
    if (! myScrubber-> scrubOnly())        {  
d221 1
a221 1
    if (! myScrubber-> scrubOnly())        {  
d223 5
a227 5
	cout << "Singleton Queries ... " 
	     << "(method:" << setOfParameters.getString("fssSingletonMethod") << "    "
	     << "featureMethod:" << setOfParameters.getString("fssFeatureSingletonMethod")
	     << ")" << endl;
	scenarioSP->singletonFss();
d230 1
a230 1
    
d232 4
a235 4
      cout << "General Set Queries ... " 
	   << "(method:" << setOfParameters.getString("fssGeneralSetMethod") << "    "
	   << "featureMethod:" << setOfParameters.getString("fssFeatureGeneralSetMethod")
	   << ")" << endl;
d238 1
a238 1
    
d240 4
a243 4
      cout << "Machine Queries ... " 
	   << "(method:" << setOfParameters.getString("fssMachineMethod") << "    "
	   << "featureMethod:" << setOfParameters.getString("fssFeatureMachineMethod")
	   << ")" << endl;
d249 1
a249 1
  if (! myScrubber-> scrubOnly())        {  
d257 1
a257 1
  
d315 1
a315 1
  // See LgFrScheduleFactory::newPartScheduleFromScratch in 
d320 1
a320 1
	sFactoryPtr->newPartSchedule( LGFRSupplyVolume );
d324 1
a324 1
	sFactoryPtr->newPartSchedule( LGFRCycleTime );
d328 2
a329 2
	sFactoryPtr->newPartSchedule( LGFRInterPlantSupplyVolume );
  
d342 1
a342 1
	sFactoryPtr->newDemandSchedule( LGFRDemandVolume );
d346 1
a346 1
	sFactoryPtr->newDemandSchedule( LGFRShipmentVolume );
d359 1
a359 1
  
d368 1
a368 1
  // max message issued was "info" 
@


1.3.2.4
log
@added blank line for testing
@
text
@a19 1

@


1.2
log
@modifications for sce 2.31
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20001003 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20001003 " << endl;
@


1.2.2.1
log
@manual merge of bug fixes
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20001003 Rev02 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20001003 Rev02" << endl;
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
  cout << "Version: 2.31,  20000223 " << endl;
d36 1
a36 1
  cout << "Version: 2.31,  20000223 " << endl;
a167 5
  RWBoolean prepForEpps = setOfParameters.getBool("prepForEpps");
  
  if (prepForEpps) {
     return 0;
  }
@


1.1.1.1
log
@Import sce
@
text
@@

head	1.5;
access;
symbols
	sce_5_01_20080919:1.4
	latest_sce_4_20_20060523:1.4.0.4
	sce_4_20_20060523:1.4
	latest_sce4_20_OSL:1.4.0.2
	sce_4_20_OSL:1.4
	sce_4_20_20051222:1.4
	sce_4_10_30050426:1.4
	sce_4_05_20040511:1.4
	sce_4_00_20040201:1.3
	nextGenBranch:1.2.0.2
	nextGenRoot:1.2
	sce_3_30_20030627:1.2
	EndRw-branch:1.1.1.1.0.14
	Root-of-EndRw:1.1.1.1
	EndWitRw-branch:1.1.1.1.0.12
	Root-of-EndWitRw:1.1.1.1
	RwToStl-branch:1.1.1.1.0.10
	Root-of-RwToStl:1.1.1.1
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2009.12.08.13.58.34;	author ervolina;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.04.20.28.12;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.04.20.46.31;	author dpc;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.15.19.36.54;	author rwToStl;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.18.36.49;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.18.36.49;	author wit;	state Exp;
branches
	1.1.1.1.14.1;
next	;

1.1.1.1.14.1
date	2003.01.08.17.43.14;	author rwToStl;	state Exp;
branches;
next	1.1.1.1.14.2;

1.1.1.1.14.2
date	2003.01.09.13.14.34;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.5
log
@more fixes for 6.1
@
text
@#include <mcl/src/mdsPragma.h>

#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>

#include <math.h>
#include <iostream>




#include <scenario/src/scenario.h>
#include <scenario/src/idnumber.h>
#include <scenario/src/calendar.h>
#include <scenario/src/collflt.h>
#include <scenario/src/difEssSc.h>

#include <sce/src/difSceF.h>


LgFrDataInterfaceImplementation *
createSceFilesDifImp(const std::string filename)
{
   return new LgFrDataInterfaceImplementationFromSceFiles(filename);
}

//----------------------------------------------------------------------------
// To register all global functions for this class
// The following functions are registered by using difWitR globle function:
// unitCost, procCost, obj1ScrapCost,obj1StockCost, supplyVol, yield,
// cycleTime, obj1ProdCost, obj1ProdCos, grossRev, demandVol,
// obj1CumShipReward, obj1ShipReward
// Register difSceF's own global functions for raw parts: constrained and procL
//----------------------------------------------------------------------------
void
registerSceFilesDifImpFunctions(LgFrDataInterfaceImplementation *dImpSCE)
{
  ;

}



//-------------------------------------------------------------------
//
//   Functions not defined in parent class
//
//-------------------------------------------------------------------

std::string
LgFrDataInterfaceImplementationFromSceFiles::filename()
const
{
  return filename_;
}

LgFrSceScrubber 
LgFrDataInterfaceImplementationFromSceFiles::scrubber()
const
{
  return myScrubber_;
}
//-------------------------------------------------------------------
//
//   Functions to obtain global attributes
//
//-------------------------------------------------------------------




// Return type identifier
isAReturnType
LgFrDataInterfaceImplementationFromSceFiles::isA()
const
{
  return __LGFRDATAINTERFACEIMPLEMENTATIONFROMSCEFILES;
}



// Make clone copy of object
LgFrDataInterfaceImplementation *
LgFrDataInterfaceImplementationFromSceFiles::clone()
const
{
  LgFrDataInterfaceImplementationFromSceFiles* newInst =
      new LgFrDataInterfaceImplementationFromSceFiles(*this);
  return (newInst);
}

// Destructor
LgFrDataInterfaceImplementationFromSceFiles::
~LgFrDataInterfaceImplementationFromSceFiles()
{
  // nothing to do here
}

// Assignment operator.
LgFrDataInterfaceImplementationFromSceFiles&
LgFrDataInterfaceImplementationFromSceFiles::operator=(
  const LgFrDataInterfaceImplementationFromSceFiles& rhs)
{
  if (this != &rhs) {           // Check for assignment to self
    //     (this->LgFrDataInterfaceImplementation::operator= ) (rhs);
    LgFrDataInterfaceImplementation::operator=  (rhs);
     
     filename_ = rhs.filename_;
  }
  return *this;
}

// Copy constructor
LgFrDataInterfaceImplementationFromSceFiles::
LgFrDataInterfaceImplementationFromSceFiles(
  const LgFrDataInterfaceImplementationFromSceFiles& source)
:
   LgFrDataInterfaceImplementation(source),
   filename_(source.filename_),
   myScrubber_(source.myScrubber_)
{
  // nothing to do here
}


// Preferred Constructor
LgFrDataInterfaceImplementationFromSceFiles::
LgFrDataInterfaceImplementationFromSceFiles(
   std::string filename )
:
   LgFrDataInterfaceImplementation(),
   filename_(filename),
   myScrubber_()
{
  // nothing to do here
}

LgFrDataInterfaceImplementationFromSceFiles::
LgFrDataInterfaceImplementationFromSceFiles(
   std::string filename, std::string scrubDir,bool scrubMode,bool scrubOnly )
:
   LgFrDataInterfaceImplementation(),
   filename_(filename),
   myScrubber_(LgFrSceScrubber(scrubDir, scrubMode, scrubOnly))
{
  // nothing to do here
}

// Default Constructor
// This is a private function
LgFrDataInterfaceImplementationFromSceFiles::
LgFrDataInterfaceImplementationFromSceFiles()
:
   LgFrDataInterfaceImplementation(),
   filename_(),
   myScrubber_()
{
   // Nothing to do here
}     

#if 0


#ifdef NDEBUG
#undef NDEBUG
#endif
// Tests this class.  Only returns if all tests passed
// Tests this class.  Only returns if all tests passed
// Expects data in testScenario1 to have come from
// /u/implode/wit/data/examples/diner12/wit.data, and expects
// testScenario2 to have been made by copying testScenario1
// testSc.
// Right now, the only scenario that works correctly with a 
// LgFrTestDataInterface is LgFrScenarioforCMRP.  Although the above 
// comment says that data should have come from a file, it is probably
// misleading (WCD, 9/15/94).  The data from the file (which has already
// been put into WIT) is probably ignored.  This should be changed
// to take LgFrScenarioforCMRP's for the 1st and 6th arguments.
void
LgFrDataInterfaceFromSceFiles::contextTest
  (
   LgFrDataInterface    	* tdif1,	// testScenario1's
   LgFrLastProblemSolved        & lps,          // testScenario1's
   LgFrDataInterface    	* ts1dupDif,	// testScenario1dup's
   LgFrDataInterface    	* tdif2,	// testScenario2's
   const LgFrScenario           * scenPtr)

{
}


#endif
@


1.4
log
@Modified to reduce microsoft compiler warning messages
@
text
@d2 1
a2 1
// RW2STL - inserted:
d6 1
a6 1
// End of RW2STL - inserted includes.
a8 1
//#include <fstream.h>
d12 1
a12 2
// #include <scenario/src/partAttr.h>
// #include <scenario/src/demdAttr.h>
d39 1
a39 478
// Globle function for raw parts
// Register difSceF global functions for
//   unitcost, procCost, obj1ScrapCost, obj1StockCost, and supplyVol.
// Register difSceF's own global functions for constrained and procLeadTime,
dImpSCE->registerFunction("rawUnitCost", material, part,
                            vectorFloat, difSceFGetRawUnitCost);
dImpSCE->registerFunction("rawProcCost", material, part,
                            vectorFloat, difSceFGetRawProcCost);
dImpSCE->registerFunction("rawConstrained", material, part,
                            vectorInt, difSceFGetRawConstrained);
dImpSCE->registerFunction("rawProcLeadTime", material, part,
                            timeVecFloat, difSceFGetRawProcLeadTime);
dImpSCE->registerFunction("rawObj1ScrapCost", material, part,
                            timeVecFloat, difSceFGetRawObj1ScrapCost);
dImpSCE->registerFunction("rawObj1StockCost", material, part,
                            timeVecFloat, difSceFGetRawObj1StockCost);
dImpSCE->registerFunction("rawSupplyVol", material, part,
                            timeVecFloat, difSceFGetRawSupplyVol);


// Global functions for product parts.
// Register difSceF global functions for
//   unitcost, procCost, constrained, yiels, procLeadTime, cycleTime,
//   obj1ProdCost, obj1ScrapCost, obj1StockCost, supplyVol, and minLotSize.
dImpSCE->registerFunction("productUnitCost", material, part,
                            vectorFloat, difSceFGetProductUnitCost);
dImpSCE->registerFunction("productProcCost", material, part,
                            vectorFloat, difSceFGetProductProcCost);
dImpSCE->registerFunction("productConstrained", material, part,
                            vectorInt, difSceFGetProductConstrained);
dImpSCE->registerFunction("productYield", material, part,
                            vectorInt, difSceFGetProductYield);
dImpSCE->registerFunction("productProcLeadTime", material, part,
                            timeVecFloat, difSceFGetProductProcLeadTime);
dImpSCE->registerFunction("productCycleTime", material, part,
                           timeVecFloat , difSceFGetProductCycleTime);
dImpSCE->registerFunction("productObj1ProdCost", material, part,
                            timeVecFloat, difSceFGetProductObj1ProdCost);
dImpSCE->registerFunction("productObj1ScrapCost", material, part,
                            timeVecFloat, difSceFGetProductObj1ScrapCost);
dImpSCE->registerFunction("productObj1StockCost", material, part,
                            timeVecFloat, difSceFGetProductObj1StockCost);
dImpSCE->registerFunction("productSupplyVol", material, part,
                            timeVecFloat, difSceFGetProductSupplyVol);
dImpSCE->registerFunction("productMinLotSize", material, part,
                            timeVecFloat, difSceFGetProductMinLotSize);


// Global functions for capacity parts.
// Register difSceF global functions for
//   unitcost, constrained, obj1ScrapCost, and supplyVol

dImpSCE->registerFunction("capacityUnitCost", material, part,
                            vectorFloat, difSceFGetCapacityUnitCost);
dImpSCE->registerFunction("capacityConstrained", material, part,
                            vectorInt, difSceFGetCapacityConstrained);
dImpSCE->registerFunction("capacityObj1ScrapCost", material, part,
                            timeVecFloat, difSceFGetCapacityObj1ScrapCost);
dImpSCE->registerFunction("capacitySupplyVol", material, part,
                            timeVecFloat, difSceFGetCapacitySupplyVol);


// Global functions for demands
// Register difSceF global functions for
//  grossRev, demandVol, Obj1CumShipReward, priority, and obj1ShipReward.
dImpSCE->registerFunction("demandGrossRev", demandType, demand,
                            vectorFloat, difSceFGetDemandGrossRev);
dImpSCE->registerFunction("demandVol", demandType, demand,
                            timeVecFloat, difSceFGetDemandVol);
dImpSCE->registerFunction("demandObj1CumShipReward", demandType, demand,
                            timeVecFloat, difSceFGetDemandObj1CumShipReward);
dImpSCE->registerFunction("demandObj1ShipReward", demandType, demand,
                            timeVecFloat, difSceFGetDemandObj1ShipReward);
dImpSCE->registerFunction("demandPriority", demandType, demand,
                            timeVecFloat,difSceFGetDemandPriority );


// Parts table, register globle functions from difWitR, 7/19/95 DW
dImpSCE->registerFunction("rawParts", material, part,
                           orderedVecPart, difSceFGetRawParts);
dImpSCE->registerFunction("productParts", material, part,
                           orderedVecPart, difSceFGetProductParts);
dImpSCE->registerFunction("capacityParts", material, part,
                           orderedVecPart, difSceFGetCapacityParts);
// using globle function from difWitR, 7/19/95 DW
dImpSCE->registerFunction("committedDemands",demandType , demand,
                           orderedVecDemand, difSceFGetCommittedDemands);
dImpSCE->registerFunction("newOpportunityDemands", demandType, demand,
                           orderedVecDemand, difSceFGetNewOpportunityDemands);
dImpSCE->registerFunction("firmForecastDemands", demandType, demand,
                           orderedVecDemand, difSceFGetFirmForecastDemands);
dImpSCE->registerFunction("riskForecastDemands", demandType, demand,
                           orderedVecDemand, difSceFGetRiskForecastDemands);
// Register define bom globle function
dImpSCE->registerFunction("defineBom", material, part,
                            timeVecFloat, difSceFDefineBom);


}


//-------------------------------------------------------------------
//
//   Global functions to obtain the defined parts and capacities.
//
//-------------------------------------------------------------------

// Return vector of raw materials.
// difSceFGetRawParts global function (registering in the attribute table).
// Get raw parts for the perfect world ATP and insert them into set_of_part
// Return: a LgFrPartVector object (vector of raw parts).

void *
difSceFGetRawParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProdcutParts global function (registering in the attribute table)
// Get product parts for the perfect world ATP and insert it into set_of_part
// Return: a LgFrPartVector object (vector of producible parts)
void*
difSceFGetProductParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetCapacityParts global function (registering in the attribute table
// Get capacity parts for the perfect world ATP and insert it into set_of_part
// Return: a LgFrPartVector object (vector of capacity parts)
void*
difSceFGetCapacityParts(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrPartVector& retVal = *(new LgFrPartVector);
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

//-------------------------------------------------------------------
//
//   Global functions to obtain raw material attributes
//
//-------------------------------------------------------------------

// difSceFGetRawUnitCost global function (registered in the attribute table)
// it returns a LgFrFloatVector object.
void *
difSceFGetRawUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


// difSceFGetRawProcCost global function (registered in the attribute table).
// It returns a LgFrFloatVector object.
void *
difSceFGetRawProcCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


// difSceFGetRawConstrained global function (registered in the attribute table
// It returns a LgFrIntVector object
void *
difSceFGetRawConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// procLeadTime, obj1ScrapCost, obj1StockCost, supplyVol
// difSceFGetRawProcLeadTime global function (registered in the attribute tabl
// It returns a LgFrTimeVecFloatVector object.
void *
difSceFGetRawProcLeadTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetRawObj1ScrapCost global function (registered in the attribute tab
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetRawObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetRawObj1StockCost global function (registered in the attribute tab
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetRawObj1StockCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetRawSupplyVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetRawSupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));

  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//
//   Global functions to obtain producible part attributes
//
//-------------------------------------------------------------------


// difSceFGetProductProcCost global function (registered in the attribute tabl
// It returns a LgFrFloatVector object.
void *
difSceFGetProductProcCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

void *
difSceFGetProductUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// constrained (boolean), yield
// difSceFGetProductConstrained global function (registered in the attribute t
// It returns a LgFrIntVector object
void *
difSceFGetProductConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProductYield global function (registered in the attribute table).
// Return: a LgFrFloatVector object
void *
difSceFGetProductYield(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;

}

// obj1ProdCost, obj1ScrapCost, obj1StockCost, supplyVol, procLeadTime,
// cycleTime, minLotSize
// difSceFGetProductProcLeadTime global function (registered in the attribute
// It returns a LgFrTimeVecFloatVector object.
void *
difSceFGetProductProcLeadTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProductCycleTime global function (registered in the attribute tab
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductCycleTime(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetObj1ProdCost global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductObj1ProdCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProductObj1ScrapCost global function (registered in the attribute
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProductObj1StockCost global function (registered in the attribute
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductObj1StockCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}
a40 316
// difSceFGetProductSupplyVol global function (registered in the attribute tab
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductSupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetProductMinLotSize global function (registered in the attribute tab
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetProductMinLotSize(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


//--------------------------------------------------------------------
//
//   Global functions to obtain capacity attributes
//
//-------------------------------------------------------------------

// difSceFGetCapacityUnitCost global function (registered in the attribute tab
// it returns a LgFrFloatVector object.
void *
difSceFGetCapacityUnitCost(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetCapacityConstrained global function (registered in the attribute
// It returns a LgFrIntVector object
void *
difSceFGetCapacityConstrained(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// obj1ScrapCost, supplyVol
// difSceFGetCapacityObj1ScrapCost global function (registered in the attribut
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetCapacityObj1ScrapCost(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


// difSceFGetCapacitySupplyVol global function (registered in the attribute ta
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetCapacitySupplyVol(
    const LgFrDataInterfaceImplementation * /* difImp, not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
  std::cerr <<"unsupported parts function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;

}

//--------------------------------------------------------------------
//
//   Global functions to obtain demands
//
//-------------------------------------------------------------------

// difSceFGetCommittedDemands global function (registering in the attribute ta
// Get committed demands for the perfect world ATP and insert them into set_of_
// Return: a LgFrDemandVector object (vector of committed demands).
void *
difSceFGetCommittedDemands(
  const LgFrDataInterfaceImplementation * /* dImp,not used */,
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
  LgFrError & status,
  const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


// difSceFGetNewOpportunityDemands global function (registering in the attribu
// Get new opportunity demands for perfect world ATP and insert them into set_o
// Return: a LgFrDemandVector object (vector of new opportunity demands)
void *
difSceFGetNewOpportunityDemands(
    const LgFrDataInterfaceImplementation * /* dImp, not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetFirmForecastDemands global function (registering in the attribute
// Get firm forcast demands for perfect world ATP and insert them into set_of_d
// Return: a LgFrDemandVector object (vector of firm forcast demands).
void *
difSceFGetFirmForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetRiskForecastDemands global function (registering in the attribute
// Get risk forcast demands for perfect world ATP and insert them into set_of_d
// Return: a LgFrDemandVector object (vector of risk forcast demands).
void *
difSceFGetRiskForecastDemands(
    const LgFrDataInterfaceImplementation * /* dImp,not used */,
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

//--------------------------------------------------------------------
//
//   Global functions to obtain demand attributes
//
//-------------------------------------------------------------------

// difSceFGetDemandGrossRev global function (registering in the attribute tabl
// Compute total demand gross revenue
// Return: a LgFrFloatVector object (vector of demand gross revenues).
void *
difSceFGetDemandGrossRev(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * /* difEssenPtr, not used */
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector( dv.size() ));
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// demandVol, obj1CumShipReward, obj1ShipReward
// difSceFGetDemandVol global function (registered in the attribute table).
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetDemandVol(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

// difSceFGetDemanObj1CumShipReward global function (registered in the attribu
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetDemandObj1CumShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}


// difSceFGetDemanObj1ShipReward global function (registered in the attribute
// Return: a LgFrTimeVecFloatVector object.
void *
difSceFGetDemandObj1ShipReward(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}

void *
difSceFGetDemandPriority(
    const LgFrDataInterfaceImplementation * /* difImp,  not used */,
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
    LgFrError & status,
    const LgFrDataInterfaceEssentials * difEssenPtr
    )
{
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
  std::cerr <<"unsupported demand function called" <<std::endl;
  exit(EXIT_FAILURE);
  status = 0;
  return &retVal;
}
//--------------------------------------------------------------------
//
//   Global function to define BOM
//
//-------------------------------------------------------------------
void*
difSceFDefineBom(
    const LgFrDataInterfaceImplementation * difImp,
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
    LgFrError &, // status,
    const LgFrDataInterfaceEssentials * difEssenPtr)
{
  std::cerr <<"unsupported BOM function called" <<std::endl;
  exit(EXIT_FAILURE);
  return 0;
a70 9
/*
// Return problem title
std::string
LgFrDataInterfaceImplementationFromSceFiles::title()
const
{
  return filename_;
}
*/
a189 362
  const float fltEps = .0001;

  // Test isA function
  assert (tdif1.isA() == __LGFRDATAINTERFACEFROMWITRUN);
  assert (tdif2.isA() == __LGFRDATAINTERFACEFROMWITRUN);
  assert (ts1dupDif.isA() == __LGFRDATAINTERFACEFROMWITRUN);

  // Test numberOfPeriods function
  assert( tdif1.numberOfPeriods() == 8 );

  // Test title function
    assert(  tdif1.title() == "Diner");
    assert(  tdif2.title() == "Diner");
                         
  // Test Get Part Functions
  LgFrPartVector raw( tdif2.rawParts() );
  size_t t = 0; // Pulled out of the for below by RW2STL
  for(t = 0 ; t < 7 ; t++)
    witAddPart( lps.witRun(), raw[t].name(), WitRAW);
  assert( raw.size() == 7 );
  assert( raw[0].name() == "Egg" );
  assert( raw[1].name() == "Butter" );

  LgFrPartVector product( tdif2.productParts() );
  for( t = 0 ; t < 10 ; t++)
    witAddPart( lps.witRun(), product[t].name(), WitPRODUCT);
  assert( product.size() == 10 );
  assert( product[9].name() == "HamEgg_Sand" );

  LgFrPartVector capacity( tdif2.capacityParts() );
  for( t = 0 ; t < 2 ; t++)
    witAddPart( lps.witRun(), capacity[t].name(), WitCAPACITY);
  assert( capacity.size() == 2 );
  assert( capacity[0].name() == "Skillet" );


  // The following variables are used because cfront can not always
  // create instances when they are just used as an argument in a call.
  LgFrRaw rawInstance;
  LgFrProduct productInstance;
  LgFrCapacity capacityInstance;

  // Test get raw partAttribute functions
  {
  LgFrFloatVector unitCost;
  unitCost = tdif2.partAttribute(raw,rawInstance,LgFrUnitCost()); 
  assert( unitCost.length() == 7 );
  unitCost = tdif2.partAttribute(
     raw,rawInstance,(LgFrRawAttribute<float>&)LgFrUnitCost()); 
  assert( unitCost.length() == 7 );
  std::cerr << " unitCost[0] == " << unitCost[0] << std::endl;
  assert( unitCost[0] == 1.5 );

  LgFrIntVector constrained;
  constrained = tdif2.partAttribute(raw,rawInstance,LgFrConstrained());
  assert( constrained.length() == 7 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.length(); i++) assert( constrained[i] );
  constrained = tdif2.partAttribute(
     raw,rawInstance,(LgFrRawAttribute<int>&)LgFrConstrained());
  assert( constrained.length() == 7 );
  for ( i=0; i<constrained.length(); i++) assert( constrained[i] );
  
  LgFrTimeVecFloatVector obj1ScrapCost(
      tdif2.partAttribute(raw,rawInstance,LgFrObj1ScrapCost()) );
  assert( obj1ScrapCost.length() == 7 );
  assert( obj1ScrapCost[0] == LgFrTimeVecFloat(8,".01 .01 0 0 0 0 0 0") );
  obj1ScrapCost = tdif2.partAttribute(raw,rawInstance,
     (LgFrRawAttribute<LgFrTimeVecFloat>&)LgFrObj1ScrapCost());
  assert( obj1ScrapCost.length() == 7 );
  assert( obj1ScrapCost[0] == LgFrTimeVecFloat(8,".01 .01 0 0 0 0 0 0") );
  
  LgFrTimeVecFloatVector obj1StockCost;
  obj1StockCost = tdif2.partAttribute(raw,rawInstance,LgFrObj1StockCost());
  assert( obj1StockCost.length() == 7 );
  obj1StockCost = tdif2.partAttribute(raw,rawInstance,
     (LgFrRawAttribute<LgFrTimeVecFloat>&)LgFrObj1StockCost());
  assert( obj1StockCost.length() == 7 );
  assert( obj1StockCost[0] == LgFrTimeVecFloat(8,".02 .02 0 0 0 0 0 0") );

  LgFrTimeVecFloatVector supplyVol;
  supplyVol = tdif2.partAttribute(raw,rawInstance,LgFrSupplyVol());
  assert( supplyVol.length() == 7 );
  supplyVol = tdif2.partAttribute(raw,rawInstance,
     (LgFrRawAttribute<LgFrTimeVecFloat>&)LgFrSupplyVol());
  assert( supplyVol.length() == 7 );
  assert( supplyVol[0] == LgFrTimeVecFloat(8," 5.0 2.0 0 0 0 0 0 0") );
  }

  // Test get product partAttribute functions
  {
  LgFrTimeVecFloatVector cycleTime;
  cycleTime = tdif2.partAttribute(product,productInstance,LgFrCycleTime()); 
  assert( cycleTime.length() == 10 );
  cycleTime = tdif2.partAttribute(
     product,productInstance,(
     LgFrProductAttribute<LgFrTimeVecFloat>&)LgFrCycleTime()); 
  assert( cycleTime.length() == 10 );
  assert( cycleTime[0] == LgFrTimeVecFloat(8," 0.3 0.3 0 0 0 0 0 0") );
 
  LgFrFloatVector unitCost;
  unitCost = tdif2.partAttribute(product,productInstance,LgFrUnitCost()); 
  assert( unitCost.length() == 10 );
  unitCost = tdif2.partAttribute(
     product,productInstance,(LgFrProductAttribute<float>&)LgFrUnitCost()); 
  assert( unitCost.length() == 10 );
  assert ( fabs(unitCost[0] - 1.2) < fltEps );

  
  LgFrIntVector constrained;
  constrained = tdif2.partAttribute(product,productInstance,LgFrConstrained());
  assert( constrained.length() == 10 );
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.length(); i++)
  assert( constrained[i] );
  constrained = tdif2.partAttribute(
     product,productInstance,(LgFrProductAttribute<int>&)LgFrConstrained());
  assert( constrained.length() == 10 );
  for (i=0; i<constrained.length(); i++)
  assert( constrained[i] );


  
  LgFrIntVector yield;
  yield = tdif2.partAttribute(product,productInstance,LgFrYield());
  assert( yield.length() == 10 );
  yield = tdif2.partAttribute(
     product,productInstance,(LgFrProductAttribute<int>&)LgFrYield());
  assert( yield.length() == 10 );
  assert (yield[0] == 99 );

  
  LgFrTimeVecFloatVector obj1ProdCost;
  obj1ProdCost = tdif2.partAttribute(
     product,productInstance,LgFrObj1ProdCost());
  assert( obj1ProdCost.length() == 10 );
  obj1ProdCost = tdif2.partAttribute(product,productInstance,
     (LgFrProductAttribute<LgFrTimeVecFloat>&)LgFrObj1ProdCost());
  assert( obj1ProdCost.length() == 10 );
  assert( obj1ProdCost[0] == LgFrTimeVecFloat(8," 0.5 0.5 0 0 0 0 0 0") );
  
  LgFrTimeVecFloatVector obj1ScrapCost;
  obj1ScrapCost = 
     tdif2.partAttribute(product,productInstance,LgFrObj1ScrapCost());
  assert( obj1ScrapCost.length() == 10 );
  obj1ScrapCost = 
     tdif2.partAttribute(
     product,productInstance,
     (LgFrProductAttribute<LgFrTimeVecFloat>&)LgFrObj1ScrapCost());
  assert( obj1ScrapCost.length() == 10 );
  assert( obj1ScrapCost[0] == LgFrTimeVecFloat(8," 0.23 0.23 0 0 0 0 0 0") );
  
  LgFrTimeVecFloatVector obj1StockCost;
  obj1StockCost = 
     tdif2.partAttribute(product,productInstance,LgFrObj1StockCost());
  assert( obj1StockCost.length() == 10 );
  obj1StockCost = 
     tdif2.partAttribute(
     product,productInstance,
     (LgFrProductAttribute<LgFrTimeVecFloat>&)LgFrObj1StockCost());
  assert( obj1StockCost.length() == 10 );
  assert( obj1StockCost[0] == LgFrTimeVecFloat(8," 0.24 0.24 0 0 0 0 0 0") );
  
  LgFrTimeVecFloatVector supplyVol;
  supplyVol = tdif2.partAttribute(product,productInstance,LgFrSupplyVol());
  assert( supplyVol.length() == 10 );
  supplyVol = tdif2.partAttribute(
     product,productInstance,(
     LgFrProductAttribute<LgFrTimeVecFloat>&)LgFrSupplyVol());
  assert( supplyVol.length() == 10 );
  assert( supplyVol[0] == LgFrTimeVecFloat(8," 0.01 0.01 0 0 0 0 0 0") );
  }



  // Test get capacity partAttribute functions
  {
  LgFrFloatVector unitCost;
  unitCost = tdif2.partAttribute(capacity,capacityInstance,LgFrUnitCost()); 
  assert( unitCost.length() == 2 );
  unitCost = tdif2.partAttribute(
     capacity,capacityInstance,(LgFrCapacityAttribute<float>&)LgFrUnitCost()); 
  assert( unitCost.length() == 2 );
  assert ( fabs(unitCost[0] - 1.11 ) < fltEps );
  
  LgFrIntVector constrained;
  constrained = tdif2.partAttribute(
     capacity,capacityInstance,LgFrConstrained());
  assert( constrained.length() == 2 );
  assert( constrained[0] );
  constrained = tdif2.partAttribute(
     capacity,capacityInstance,(LgFrCapacityAttribute<int>&)LgFrConstrained());
  assert( constrained.length() == 2 );
  assert( constrained[0] );
  assert( constrained[1] );

  LgFrTimeVecFloatVector obj1ScrapCost;
  obj1ScrapCost = 
     tdif2.partAttribute(capacity,capacityInstance,LgFrObj1ScrapCost());
  assert( obj1ScrapCost.length() == 2 );
  obj1ScrapCost = 
     tdif2.partAttribute(capacity,
     capacityInstance,
     (LgFrCapacityAttribute<LgFrTimeVecFloat>&)LgFrObj1ScrapCost());
  assert( obj1ScrapCost.length() == 2 );
  assert( obj1ScrapCost[0] == LgFrTimeVecFloat(8," 0.33 0.22 0 0 0 0 0 0") );

  
  LgFrTimeVecFloatVector supplyVol;
  supplyVol = tdif2.partAttribute(capacity,capacityInstance,LgFrSupplyVol());
  assert( supplyVol.length() == 2 );
  supplyVol = tdif2.partAttribute(capacity,
     capacityInstance,
     (LgFrCapacityAttribute<LgFrTimeVecFloat>&)LgFrSupplyVol());
  assert( supplyVol.length() == 2 );
  assert( supplyVol[0] == LgFrTimeVecFloat(8," 15 20 0 0 0 0 0 0") );
  
  }


// Test Get Demands Functions
  LgFrDemandVector committed( tdif2.committedDemands() );
  assert( committed.size() == 7 ); 
  
  LgFrDemandVector newOpportunity( tdif2.newOpportunityDemands() );
  assert( newOpportunity.size() == 1 );


  LgFrDemandVector firmForecast( tdif2.firmForecastDemands() );
  assert( firmForecast.size() == 1 );



  LgFrDemandVector riskForecast( tdif2.riskForecastDemands() );
  assert( riskForecast.size() == 1 );


  // Test get demand Attribute functions
  LgFrFloatVector grossRev;
  grossRev = tdif2.demandAttribute(committed, LgFrGrossRev());
  assert( grossRev.length() == 7 );
  assert ( fabs(grossRev[0] - 3.1 ) < fltEps );

  grossRev = tdif2.demandAttribute(newOpportunity, LgFrGrossRev());
  assert( grossRev.length() == 1 );
  assert ( fabs(grossRev[0] - 3.55 ) < fltEps );
  
  grossRev = tdif2.demandAttribute(firmForecast, LgFrGrossRev());
  assert( grossRev.length() == 1 );
  assert ( fabs(grossRev[0] - 1.23 ) < fltEps );

  grossRev = tdif2.demandAttribute(riskForecast, LgFrGrossRev());
  assert( grossRev.length() == 1 );
  assert ( fabs(grossRev[0] - 2.45 ) < fltEps );


  LgFrTimeVecFloatVector demandVol;
  demandVol = tdif2.demandAttribute(committed, LgFrDemandVol());
  assert(demandVol.length() == 7 );
  assert( demandVol[0] == LgFrTimeVecFloat(8," 0.14 0.14 0 0 0 0 0 0") );

  demandVol = tdif2.demandAttribute(newOpportunity, LgFrDemandVol());
  assert(demandVol.length() == 1 );
  assert( demandVol[0] == LgFrTimeVecFloat(8," 3 4 0 0 0 0 0 0") );
  
  demandVol = tdif2.demandAttribute(firmForecast, LgFrDemandVol());
  assert(demandVol.length() == 1 );
  assert( demandVol[0] == LgFrTimeVecFloat(8," 4 2 0 0 0 0 0 0") );

  demandVol = tdif2.demandAttribute(riskForecast, LgFrDemandVol());
  assert(demandVol.length() == 1 );
  assert( demandVol[0] == LgFrTimeVecFloat(8," 0.27 0.27 0 0 0 0 0 0") );


  LgFrTimeVecFloatVector obj1CumShipReward;
  obj1CumShipReward = tdif2.demandAttribute(committed,
                                            LgFrObj1CumShipReward());
  assert(obj1CumShipReward.length() == 7 );
  assert( obj1CumShipReward[0] ==
          LgFrTimeVecFloat(8," 0.21 0.21 0 0 0 0 0 0") );

  obj1CumShipReward = tdif2.demandAttribute(newOpportunity,
                                            LgFrObj1CumShipReward());
  assert(obj1CumShipReward.length() == 1 );
  assert( obj1CumShipReward[0] ==
          LgFrTimeVecFloat(8," 0.09 0.09 0 0 0 0 0 0") );
  
  obj1CumShipReward = tdif2.demandAttribute(
                                            firmForecast, LgFrObj1CumShipReward());
  assert(obj1CumShipReward.length() == 1 );
  assert( obj1CumShipReward[0] ==
          LgFrTimeVecFloat(8," 0.17 0.17 0 0 0 0 0 0") );

  obj1CumShipReward = tdif2.demandAttribute(riskForecast,
                                            LgFrObj1CumShipReward());
  assert(obj1CumShipReward.length() == 1 );
  assert( obj1CumShipReward[0] ==
          LgFrTimeVecFloat(8," 0.07 0.07 0 0 0 0 0 0") );



  LgFrTimeVecFloatVector obj1ShipReward;
  obj1ShipReward = tdif2.demandAttribute(committed,
                                            LgFrObj1ShipReward());
  assert(obj1ShipReward.length() == 7 );
  assert( obj1ShipReward[0] ==
          LgFrTimeVecFloat(8," 3.81 3.81 0 0 0 0 0 0") );

 obj1ShipReward = tdif2.demandAttribute(newOpportunity,
                                            LgFrObj1ShipReward());
  assert(obj1ShipReward.length() == 1 );
  assert( obj1ShipReward[0] ==
          LgFrTimeVecFloat(8," 3.5 3.5 0 0 0 0 0 0") );
 
  
  obj1ShipReward = tdif2.demandAttribute(
                                         firmForecast, LgFrObj1ShipReward());
  assert(obj1ShipReward.length() == 1 );
  assert( obj1ShipReward[0] ==
          LgFrTimeVecFloat(8," 1.12 1.12 0 0 0 0 0 0") );

  obj1ShipReward = tdif2.demandAttribute(riskForecast,
                                            LgFrObj1ShipReward());
  assert(obj1ShipReward.length() == 1 );
  assert( obj1ShipReward[0] ==
          LgFrTimeVecFloat(8," 2.19 2.19 0 0 0 0 0 0") );


  // Test BOM
  tdif1.defineBom( lps.witRun() );
  int nBomEntries, retInt;
  witBoolean retBool;
  float retFloat;
  char * consumedPartName; 
  witGetPartNBomEntries( lps.witRun(), "Plain_Omlet", &nBomEntries);
  assert( nBomEntries == 3);
  witGetBomEntryConsumedPart(lps.witRun(), "Plain_Omlet", 0,
                             &consumedPartName);
  assert ( std::string (consumedPartName) == std::string ("Skillet"));
  portableFree (consumedPartName);
  witGetBomEntryUsageRate( lps.witRun(), "Plain_Omlet", 0,
                           &retFloat);
  assert ( fabs(retFloat - 3.0) < fltEps );
  witGetBomEntryConsumedPart(lps.witRun(), "Plain_Omlet", 2,
                             &consumedPartName);
  assert ( std::string (consumedPartName) == std::string ("Butter"));
  portableFree (consumedPartName);
  witGetBomEntryEarliestPeriod(lps.witRun(), "Plain_Omlet", 2,
                               &retInt);
  assert ( retInt == 1 );
  witGetBomEntryLatestPeriod(lps.witRun(), "Plain_Omlet", 2,
                               &retInt);
  assert ( retInt == 1 );
  witGetBomEntryMandEC(lps.witRun(), "Plain_Omlet", 2,
                               &retBool);
  assert ( retBool );
  witGetBomEntryUsageRate(lps.witRun(), "Plain_Omlet", 2,
                               &retFloat);
  assert ( fabs(retFloat - 1.0) < fltEps );
  witGetBomEntryUsageTime(lps.witRun(), "Plain_Omlet", 2,
                               &retFloat);
  assert ( fabs(retFloat - 0.1) < fltEps );
@


1.3
log
@Changed (this->LgFrDataInterfaceImplementation::operator= ) (rhs); to
LgFrDataInterfaceImplementation::operator= (rhs);
so the system would compile on Linux
: ----------------------------------------------------------------------
@
text
@d1 1
a1 1

@


1.2
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d910 2
a911 1
     (this->LgFrDataInterfaceImplementation::operator= ) (rhs);
@


1.1
log
@Initial revision
@
text
@d1 6
d8 2
a9 7
#include <iostream.h>
#include <fstream.h>
#include <rw/rstream.h>
#include <rw/cstring.h>
#include <rw/ctoken.h>
#include <rw/hashdict.h>
#include <rw/collint.h>
d25 1
a25 1
createSceFilesDifImp(const RWCString filename)
d151 1
a151 1
// Return: a LgFrOrderedVectorPart object (vector of raw parts).
d156 1
a156 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d161 2
a162 2
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
  cerr <<"unsupported parts function called" <<endl;
d170 1
a170 1
// Return: a LgFrOrderedVectorPart object (vector of producible parts)
d174 1
a174 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d179 2
a180 2
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
  cerr <<"unsupported parts function called" <<endl;
d188 1
a188 1
// Return: a LgFrOrderedVectorPart object (vector of capacity parts)
d192 1
a192 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d197 2
a198 2
  LgFrOrderedVectorPart& retVal = *(new LgFrOrderedVectorPart);
  cerr <<"unsupported parts function called" <<endl;
d211 1
a211 1
// it returns a LgFrVectorFloat object.
d215 1
a215 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d220 3
a222 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d230 1
a230 1
// It returns a LgFrVectorFloat object.
d234 1
a234 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d239 3
a241 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d249 1
a249 1
// It returns a LgFrVectorInt object
d253 1
a253 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d258 3
a260 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d268 1
a268 1
// It returns a LgFrVectorTimeVecFloat object.
d272 1
a272 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d277 4
a280 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d287 1
a287 1
// Return: a LgFrVectorTimeVecFloat object.
d291 1
a291 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d296 4
a299 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d306 1
a306 1
// Return: a LgFrVectorTimeVecFloat object.
d310 1
a310 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d315 4
a318 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d325 1
a325 1
// Return: a LgFrVectorTimeVecFloat object.
d329 1
a329 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d334 3
a336 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
d338 1
a338 1
  cerr <<"unsupported parts function called" <<endl;
d352 1
a352 1
// It returns a LgFrVectorFloat object.
d356 1
a356 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d361 3
a363 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d372 1
a372 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d377 3
a379 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d387 1
a387 1
// It returns a LgFrVectorInt object
d391 1
a391 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d396 3
a398 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d405 1
a405 1
// Return: a LgFrVectorFloat object
d409 1
a409 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d414 3
a416 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d426 1
a426 1
// It returns a LgFrVectorTimeVecFloat object.
d430 1
a430 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d435 4
a438 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d445 1
a445 1
// Return: a LgFrVectorTimeVecFloat object.
d449 1
a449 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d454 4
a457 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d464 1
a464 1
// Return: a LgFrVectorTimeVecFloat object.
d468 1
a468 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d473 4
a476 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d483 1
a483 1
// Return: a LgFrVectorTimeVecFloat object.
d487 1
a487 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d492 4
a495 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d502 1
a502 1
// Return: a LgFrVectorTimeVecFloat object.
d506 1
a506 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d511 4
a514 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d521 1
a521 1
// Return: a LgFrVectorTimeVecFloat object.
d525 1
a525 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d530 4
a533 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d540 1
a540 1
// Return: a LgFrVectorTimeVecFloat object.
d544 1
a544 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d549 4
a552 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d566 1
a566 1
// it returns a LgFrVectorFloat object.
d570 1
a570 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d575 3
a577 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d584 1
a584 1
// It returns a LgFrVectorInt object
d588 1
a588 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d593 3
a595 3
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorInt& retVal = *(new LgFrVectorInt ( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d603 1
a603 1
// Return: a LgFrVectorTimeVecFloat object.
d607 1
a607 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d612 4
a615 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d623 1
a623 1
// Return: a LgFrVectorTimeVecFloat object.
d627 1
a627 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d632 4
a635 4
  LgFrOrderedVectorItemPtr pv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( pv.entries() ));
  cerr <<"unsupported parts function called" <<endl;
d650 1
a650 1
// Return: a LgFrOrderedVectorDemand object (vector of committed demands).
d654 1
a654 1
  const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d658 3
a660 3
  LgFrOrderedVectorDemand& retVal =
      *(new LgFrOrderedVectorDemand);
  cerr <<"unsupported demand function called" <<endl;
d669 1
a669 1
// Return: a LgFrOrderedVectorDemand object (vector of new opportunity demands)
d673 1
a673 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d677 3
a679 3
  LgFrOrderedVectorDemand& retVal =
      *(new LgFrOrderedVectorDemand);
  cerr <<"unsupported demand function called" <<endl;
d687 1
a687 1
// Return: a LgFrOrderedVectorDemand object (vector of firm forcast demands).
d691 1
a691 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d695 3
a697 3
  LgFrOrderedVectorDemand& retVal =
      *(new LgFrOrderedVectorDemand);
  cerr <<"unsupported demand function called" <<endl;
d705 1
a705 1
// Return: a LgFrOrderedVectorDemand object (vector of risk forcast demands).
d709 1
a709 1
    const LgFrOrderedVectorItemPtr* /* itemPtrOrdVecPtr, not used */,
d713 3
a715 3
  LgFrOrderedVectorDemand& retVal =
      *(new LgFrOrderedVectorDemand);
  cerr <<"unsupported demand function called" <<endl;
d729 1
a729 1
// Return: a LgFrVectorFloat object (vector of demand gross revenues).
d733 1
a733 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d738 3
a740 3
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorFloat& retVal = *(new LgFrVectorFloat( dv.entries() ));
  cerr <<"unsupported demand function called" <<endl;
d748 1
a748 1
// Return: a LgFrVectorTimeVecFloat object.
d752 1
a752 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d757 4
a760 4
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( dv.entries() ));
  cerr <<"unsupported demand function called" <<endl;
d767 1
a767 1
// Return: a LgFrVectorTimeVecFloat object.
d771 1
a771 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d776 4
a779 4
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( dv.entries() ));
  cerr <<"unsupported demand function called" <<endl;
d787 1
a787 1
// Return: a LgFrVectorTimeVecFloat object.
d791 1
a791 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d796 4
a799 4
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( dv.entries() ));
  cerr <<"unsupported demand function called" <<endl;
d808 1
a808 1
    const LgFrOrderedVectorItemPtr* itemPtrOrdVecPtr,
d813 4
a816 4
  LgFrOrderedVectorItemPtr dv = *itemPtrOrdVecPtr;
  LgFrVectorTimeVecFloat& retVal =
      *(new LgFrVectorTimeVecFloat( dv.entries() ));
  cerr <<"unsupported demand function called" <<endl;
d829 1
a829 1
    const LgFrOrderedVectorItemPtr*, // itemPtrOrdVecPtr,
d833 1
a833 1
  cerr <<"unsupported BOM function called" <<endl;
d835 1
a835 1
  return NULL;
d846 1
a846 1
RWCString
d868 1
a868 1
RWCString
d933 1
a933 1
   RWCString filename )
d944 1
a944 1
   RWCString filename, RWCString scrubDir,RWBoolean scrubMode,RWBoolean scrubOnly )
d1008 3
a1010 2
  LgFrOrderedVectorPart raw( tdif2.rawParts() );
  for(size_t t = 0 ; t < 7 ; t++)
d1012 1
a1012 1
  assert( raw.entries() == 7 );
d1016 1
a1016 1
  LgFrOrderedVectorPart product( tdif2.productParts() );
d1019 1
a1019 1
  assert( product.entries() == 10 );
d1022 1
a1022 1
  LgFrOrderedVectorPart capacity( tdif2.capacityParts() );
d1025 1
a1025 1
  assert( capacity.entries() == 2 );
d1037 1
a1037 1
  LgFrVectorFloat unitCost;
d1043 1
a1043 1
  cerr << " unitCost[0] == " << unitCost[0] << endl;
d1046 1
a1046 1
  LgFrVectorInt constrained;
d1049 2
a1050 1
  for (int i=0; i<constrained.length(); i++) assert( constrained[i] );
d1056 1
a1056 1
  LgFrVectorTimeVecFloat obj1ScrapCost(
d1065 1
a1065 1
  LgFrVectorTimeVecFloat obj1StockCost;
d1073 1
a1073 1
  LgFrVectorTimeVecFloat supplyVol;
d1084 1
a1084 1
  LgFrVectorTimeVecFloat cycleTime;
d1093 1
a1093 1
  LgFrVectorFloat unitCost;
d1102 1
a1102 1
  LgFrVectorInt constrained;
d1105 2
a1106 1
  for (int i=0; i<constrained.length(); i++)
d1116 1
a1116 1
  LgFrVectorInt yield;
d1125 1
a1125 1
  LgFrVectorTimeVecFloat obj1ProdCost;
d1134 1
a1134 1
  LgFrVectorTimeVecFloat obj1ScrapCost;
d1145 1
a1145 1
  LgFrVectorTimeVecFloat obj1StockCost;
d1156 1
a1156 1
  LgFrVectorTimeVecFloat supplyVol;
d1170 1
a1170 1
  LgFrVectorFloat unitCost;
d1178 1
a1178 1
  LgFrVectorInt constrained;
d1189 1
a1189 1
  LgFrVectorTimeVecFloat obj1ScrapCost;
d1201 1
a1201 1
  LgFrVectorTimeVecFloat supplyVol;
d1214 2
a1215 2
  LgFrOrderedVectorDemand committed( tdif2.committedDemands() );
  assert( committed.entries() == 7 ); 
d1217 2
a1218 2
  LgFrOrderedVectorDemand newOpportunity( tdif2.newOpportunityDemands() );
  assert( newOpportunity.entries() == 1 );
d1221 2
a1222 2
  LgFrOrderedVectorDemand firmForecast( tdif2.firmForecastDemands() );
  assert( firmForecast.entries() == 1 );
d1226 2
a1227 2
  LgFrOrderedVectorDemand riskForecast( tdif2.riskForecastDemands() );
  assert( riskForecast.entries() == 1 );
d1231 1
a1231 1
  LgFrVectorFloat grossRev;
d1249 1
a1249 1
  LgFrVectorTimeVecFloat demandVol;
d1267 1
a1267 1
  LgFrVectorTimeVecFloat obj1CumShipReward;
d1294 1
a1294 1
  LgFrVectorTimeVecFloat obj1ShipReward;
d1331 1
a1331 1
  assert ( RWCString (consumedPartName) == RWCString ("Skillet"));
d1338 1
a1338 1
  assert ( RWCString (consumedPartName) == RWCString ("Butter"));
@


1.1.1.1
log
@Import sce
@
text
@@


1.1.1.1.14.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d4 5
d24 1
a24 1
createSceFilesDifImp(const std::string filename)
d150 1
a150 1
// Return: a LgFrPartVector object (vector of raw parts).
d155 1
a155 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d160 1
a160 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d169 1
a169 1
// Return: a LgFrPartVector object (vector of producible parts)
d173 1
a173 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d178 1
a178 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d187 1
a187 1
// Return: a LgFrPartVector object (vector of capacity parts)
d191 1
a191 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d196 1
a196 1
  LgFrPartVector& retVal = *(new LgFrPartVector);
d210 1
a210 1
// it returns a LgFrFloatVector object.
d214 1
a214 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d219 2
a220 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
d229 1
a229 1
// It returns a LgFrFloatVector object.
d233 1
a233 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d238 2
a239 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
d248 1
a248 1
// It returns a LgFrIntVector object
d252 1
a252 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d257 2
a258 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
d267 1
a267 1
// It returns a LgFrTimeVecFloatVector object.
d271 1
a271 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d276 3
a278 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d286 1
a286 1
// Return: a LgFrTimeVecFloatVector object.
d290 1
a290 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d295 3
a297 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d305 1
a305 1
// Return: a LgFrTimeVecFloatVector object.
d309 1
a309 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d314 3
a316 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d324 1
a324 1
// Return: a LgFrTimeVecFloatVector object.
d328 1
a328 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d333 3
a335 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d351 1
a351 1
// It returns a LgFrFloatVector object.
d355 1
a355 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d360 2
a361 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
d371 1
a371 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d376 2
a377 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
d386 1
a386 1
// It returns a LgFrIntVector object
d390 1
a390 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d395 2
a396 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
d404 1
a404 1
// Return: a LgFrFloatVector object
d408 1
a408 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d413 2
a414 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
d425 1
a425 1
// It returns a LgFrTimeVecFloatVector object.
d429 1
a429 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d434 3
a436 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d444 1
a444 1
// Return: a LgFrTimeVecFloatVector object.
d448 1
a448 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d453 3
a455 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d463 1
a463 1
// Return: a LgFrTimeVecFloatVector object.
d467 1
a467 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d472 3
a474 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d482 1
a482 1
// Return: a LgFrTimeVecFloatVector object.
d486 1
a486 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d491 3
a493 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d501 1
a501 1
// Return: a LgFrTimeVecFloatVector object.
d505 1
a505 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d510 3
a512 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d520 1
a520 1
// Return: a LgFrTimeVecFloatVector object.
d524 1
a524 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d529 3
a531 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d539 1
a539 1
// Return: a LgFrTimeVecFloatVector object.
d543 1
a543 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d548 3
a550 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d565 1
a565 1
// it returns a LgFrFloatVector object.
d569 1
a569 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d574 2
a575 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector ( pv.size() ));
d583 1
a583 1
// It returns a LgFrIntVector object
d587 1
a587 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d592 2
a593 2
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrIntVector& retVal = *(new LgFrIntVector ( pv.size() ));
d602 1
a602 1
// Return: a LgFrTimeVecFloatVector object.
d606 1
a606 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d611 3
a613 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d622 1
a622 1
// Return: a LgFrTimeVecFloatVector object.
d626 1
a626 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d631 3
a633 3
  LgFrItemPtrVector pv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( pv.size() ));
d649 1
a649 1
// Return: a LgFrDemandVector object (vector of committed demands).
d653 1
a653 1
  const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d657 2
a658 2
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
d668 1
a668 1
// Return: a LgFrDemandVector object (vector of new opportunity demands)
d672 1
a672 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d676 2
a677 2
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
d686 1
a686 1
// Return: a LgFrDemandVector object (vector of firm forcast demands).
d690 1
a690 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d694 2
a695 2
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
d704 1
a704 1
// Return: a LgFrDemandVector object (vector of risk forcast demands).
d708 1
a708 1
    const LgFrItemPtrVector* /* itemPtrOrdVecPtr, not used */,
d712 2
a713 2
  LgFrDemandVector& retVal =
      *(new LgFrDemandVector);
d728 1
a728 1
// Return: a LgFrFloatVector object (vector of demand gross revenues).
d732 1
a732 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d737 2
a738 2
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrFloatVector& retVal = *(new LgFrFloatVector( dv.size() ));
d747 1
a747 1
// Return: a LgFrTimeVecFloatVector object.
d751 1
a751 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d756 3
a758 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
d766 1
a766 1
// Return: a LgFrTimeVecFloatVector object.
d770 1
a770 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d775 3
a777 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
d786 1
a786 1
// Return: a LgFrTimeVecFloatVector object.
d790 1
a790 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d795 3
a797 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
d807 1
a807 1
    const LgFrItemPtrVector* itemPtrOrdVecPtr,
d812 3
a814 3
  LgFrItemPtrVector dv = *itemPtrOrdVecPtr;
  LgFrTimeVecFloatVector& retVal =
      *(new LgFrTimeVecFloatVector( dv.size() ));
d828 1
a828 1
    const LgFrItemPtrVector*, // itemPtrOrdVecPtr,
d834 1
a834 1
  return 0;
d845 1
a845 1
std::string
d867 1
a867 1
std::string
d932 1
a932 1
   std::string filename )
d943 1
a943 1
   std::string filename, std::string scrubDir,bool scrubMode,bool scrubOnly )
d1007 2
a1008 3
  LgFrPartVector raw( tdif2.rawParts() );
  size_t t = 0; // Pulled out of the for below by RW2STL
  for(t = 0 ; t < 7 ; t++)
d1010 1
a1010 1
  assert( raw.size() == 7 );
d1014 1
a1014 1
  LgFrPartVector product( tdif2.productParts() );
d1017 1
a1017 1
  assert( product.size() == 10 );
d1020 1
a1020 1
  LgFrPartVector capacity( tdif2.capacityParts() );
d1023 1
a1023 1
  assert( capacity.size() == 2 );
d1035 1
a1035 1
  LgFrFloatVector unitCost;
d1044 1
a1044 1
  LgFrIntVector constrained;
d1047 1
a1047 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.length(); i++) assert( constrained[i] );
d1053 1
a1053 1
  LgFrTimeVecFloatVector obj1ScrapCost(
d1062 1
a1062 1
  LgFrTimeVecFloatVector obj1StockCost;
d1070 1
a1070 1
  LgFrTimeVecFloatVector supplyVol;
d1081 1
a1081 1
  LgFrTimeVecFloatVector cycleTime;
d1090 1
a1090 1
  LgFrFloatVector unitCost;
d1099 1
a1099 1
  LgFrIntVector constrained;
d1102 1
a1102 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<constrained.length(); i++)
d1112 1
a1112 1
  LgFrIntVector yield;
d1121 1
a1121 1
  LgFrTimeVecFloatVector obj1ProdCost;
d1130 1
a1130 1
  LgFrTimeVecFloatVector obj1ScrapCost;
d1141 1
a1141 1
  LgFrTimeVecFloatVector obj1StockCost;
d1152 1
a1152 1
  LgFrTimeVecFloatVector supplyVol;
d1166 1
a1166 1
  LgFrFloatVector unitCost;
d1174 1
a1174 1
  LgFrIntVector constrained;
d1185 1
a1185 1
  LgFrTimeVecFloatVector obj1ScrapCost;
d1197 1
a1197 1
  LgFrTimeVecFloatVector supplyVol;
d1210 2
a1211 2
  LgFrDemandVector committed( tdif2.committedDemands() );
  assert( committed.size() == 7 ); 
d1213 2
a1214 2
  LgFrDemandVector newOpportunity( tdif2.newOpportunityDemands() );
  assert( newOpportunity.size() == 1 );
d1217 2
a1218 2
  LgFrDemandVector firmForecast( tdif2.firmForecastDemands() );
  assert( firmForecast.size() == 1 );
d1222 2
a1223 2
  LgFrDemandVector riskForecast( tdif2.riskForecastDemands() );
  assert( riskForecast.size() == 1 );
d1227 1
a1227 1
  LgFrFloatVector grossRev;
d1245 1
a1245 1
  LgFrTimeVecFloatVector demandVol;
d1263 1
a1263 1
  LgFrTimeVecFloatVector obj1CumShipReward;
d1290 1
a1290 1
  LgFrTimeVecFloatVector obj1ShipReward;
d1327 1
a1327 1
  assert ( std::string (consumedPartName) == std::string ("Skillet"));
d1334 1
a1334 1
  assert ( std::string (consumedPartName) == std::string ("Butter"));
@


1.1.1.1.14.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d8 2
a9 2
#include <iostream>
//#include <fstream.h>
d162 1
a162 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d180 1
a180 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d198 1
a198 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d222 1
a222 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d241 1
a241 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d260 1
a260 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d280 1
a280 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d299 1
a299 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d318 1
a318 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d338 1
a338 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d363 1
a363 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d379 1
a379 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d398 1
a398 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d416 1
a416 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d438 1
a438 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d457 1
a457 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d476 1
a476 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d495 1
a495 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d514 1
a514 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d533 1
a533 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d552 1
a552 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d577 1
a577 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d595 1
a595 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d615 1
a615 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d635 1
a635 1
  std::cerr <<"unsupported parts function called" <<std::endl;
d660 1
a660 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d679 1
a679 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d697 1
a697 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d715 1
a715 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d740 1
a740 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d760 1
a760 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d779 1
a779 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d799 1
a799 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d816 1
a816 1
  std::cerr <<"unsupported demand function called" <<std::endl;
d833 1
a833 1
  std::cerr <<"unsupported BOM function called" <<std::endl;
d1043 1
a1043 1
  std::cerr << " unitCost[0] == " << unitCost[0] << std::endl;
@



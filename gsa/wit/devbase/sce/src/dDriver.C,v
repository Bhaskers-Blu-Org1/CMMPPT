head	1.10;
access;
symbols
	sce_5_01_20080919:1.10
	latest_sce_4_20_20060523:1.10.0.4
	sce_4_20_20060523:1.10
	latest_sce4_20_OSL:1.10.0.2
	sce_4_20_OSL:1.10
	sce_4_20_20051222:1.10
	sce_4_10_30050426:1.10
	sce_4_05_20040511:1.10
	sce_4_00_20040201:1.8
	nextGenBranch:1.8.0.2
	nextGenRoot:1.8
	sce_3_30_20030627:1.8
	EndRw-branch:1.7.0.2
	Root-of-EndRw:1.7
	EndWitRw-branch:1.6.0.4
	Root-of-EndWitRw:1.6
	RwToStl-branch:1.6.0.2
	Root-of-RwToStl:1.6
	latest_sce_3_10_20010924:1.4.0.2
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.2.0.6
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.2.0.4
	sce_2_31_20010308:1.2
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.05.07.16.58.10;	author ervolina;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.04.22.50.09;	author ervolina;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.15.19.36.54;	author rwToStl;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.26.14.25.29;	author fasano;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.20.22.13.11;	author ervolina;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.25.14.12.48;	author ervolina;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.14.21.00.59;	author ervolina;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.06.13.42.33;	author ervolina;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.04.15.48.37;	author ervolina;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.02.25.18.36.49;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.18.36.49;	author wit;	state Exp;
branches;
next	;

1.2.6.1
date	2001.07.06.13.57.36;	author scelib;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.08.13.16.28.01;	author scelib;	state Exp;
branches;
next	;

1.7.2.1
date	2003.01.08.17.43.13;	author rwToStl;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.01.09.13.14.34;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.10
log
@more memory fixes
@
text
@
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
// file: dDriver.C
// author:  tom


#include <stdlib.h>
//#include <fstream.h>
#include <assert.h>
#include <mcl/src/mcl.h>
#include <scenario/src/machdep.h>
#include <scenario/src/timeVecs.h>
#include <sce/src/sceDefin.h>
#include <sce/src/mPlantH.h>
#include <sce/src/dDriver.h>
#include <sce/src/appData.h>
#include <sce/src/sceParam.h>
#include <wit/src/wit.h>


// default constructor
LgFrSceDemandDriver::LgFrSceDemandDriver()
  :   theWitRun_ (0),
      mpHelper_(0),
      nParts_(0),
      incidenceMatrix_(0),
      state_(0)
{
    // all the work is done in initializer
  assert("Cant do this:" ==  "INVOKE the default constructor");
}


// fairly general constructor:
LgFrSceDemandDriver::LgFrSceDemandDriver(
                                         WitRun * const theWitRun, 
                                         LgFrMultiPlantHelper * mpHelper)
  :   theWitRun_ (theWitRun),
      mpHelper_(mpHelper),
      nParts_(0),
      incidenceMatrix_(0),
      state_(0)
{
  int nParts;
  char ** partList;

  witGetParts(theWitRun, &nParts, &partList);
  nParts_ = nParts;
  incidenceMatrix_ = (float **) malloc(nParts * sizeof(float *));
  
  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
    witFree(partList[i]);
  }

  witFree(partList);
}


//
// NOTE:  This method has also been implemented in ipSce.C.  It is invoked from
// there because we need to adjust the sub Exp and Net allowed's BEFORE, we
// set up our part indices.  This is messy, but given the schedule, we don't
// have time to re-design the dDriver.
// Turn ON or OFF the subNetAllowed flag of every REAL and DUMMY sub arc or every 
// REAL and DUMMY operation
// NOTE:  
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=false, then this will
// screw it up and we need to use appData!!  
void
LgFrSceDemandDriver::setSubsNetAllowed(bool subNetAllowed, LgFrMultiPlantHelper & mpHelper)
{
  int nOperations;
  char ** opList;

  witGetOperations(theWitRun_, &nOperations, &opList);
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
    // only deal with operations that have a corresponding REAL part
    if ( ! mpHelper.isPartNormal(theWitRun_, opList[o])) {
      witFree(opList[o]);
      continue;
    }
    int nBoms;
    witGetOperationNBomEntries(theWitRun_, opList[o], &nBoms);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBoms; b++) {
      int nSubBoms;
      witGetBomEntryNSubsBomEntries(theWitRun_, opList[o], b, &nSubBoms);
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) {
	char * sub;
	witGetSubsBomEntryConsumedPart(theWitRun_, opList[o], b, s, &sub);
	if ( mpHelper.isPartNormal(theWitRun_, sub)) {
	  witSetSubsBomEntryNetAllowed(theWitRun_, opList[o], b, s, subNetAllowed);
	  witSetSubsBomEntryExpAllowed(theWitRun_, opList[o], b, s, subNetAllowed);
	}
	witFree(sub);
      }
    }
    witFree(opList[o]);
  }
  witFree(opList);
}

      




// compute the demand drivers table
void
LgFrSceDemandDriver::compute()
{


  // the incidenceMatrix:
  //              incidenceMatrix[i][k] = 2.0 if k is not used in i
  //              incidenceMatrix[i][k] = 1.0 if k is used in i as optional feature
  //              incidenceMatrix[i][k] = 0.0 if k is used in i as mandatory feature
  //              incidenceMatrix[i][k] < 0.0 if k is used in i as customerChoice feature
  int nParts;
  char ** partList;
  int nPeriods;

  witGetNPeriods(theWitRun_, &nPeriods);
  witGetParts(theWitRun_, &nParts, &partList);


  assert(nParts == nParts_);

   
  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
  }



  // Make TWO passes.  ONce ot pick up the GPD demands and the second one to pick up the 
  // the independent demands
      
  // FIST PASS .... GPD only ....
  for ( i=0; i<nParts; i++) {
    std::string pp, geo;
    
    // only work on geo planner demand parts
    if (! mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, partList[i], pp, geo))
      continue;

      


    std::string geoPlannerDemandPartName(partList[i]);

    std::cout << "dDriver: GPD: " << geoPlannerDemandPartName << std::endl;

    // compute a default incidence vec for this GPD.  It should be 0
    // to begin and we set it all to 2.0 
    assert(incidenceMatrix_[i] == 0);
    incidenceMatrix_[i] = (float *) malloc(nParts * sizeof(float));
    //    witMalloc(nPeriods_ * sizeof(float),(void**)&zeroVec);
    int k = 0; // Pulled out of the for below by RW2STL
    for (k=0; k<nParts; k++) {
      incidenceMatrix_[i][k] = 2.0;
    }

    // check for special case: GPD with no demands
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    int jj = 0; // Pulled out of the for below by RW2STL
    for (jj=0; jj<nDemands; jj++) {
      witFree(dList[jj]);
    }
    witFree(dList);
      
    if (nDemands == 0) {
      continue;
    }
      


    // now loop over the children of the GPD if the child is a feature part, 
    // then we need to pick up the maxWithout vector.
    int nBom;
    witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), &nBom);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
      float minMwoScaled = 0.0;
      char * child;
      witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, &child);
      std::string theChild(child);
      std::string ggg, bbc,pptlb;

      // anything other than normal or special Feature part gets skipped      
      if ((! mpHelper_->isPartNormal(theWitRun_, child)) 
	  && (! mpHelper_->isPartSpecialFeature(theWitRun_, theChild))
	  && (! mpHelper_->isPartSpecialBbCategory(theWitRun_, theChild,pptlb,ggg,bbc))) {
	witFree(child);
	continue;
      }

      if (mpHelper_->isPartSpecialFeature(theWitRun_, theChild)) {
	// if its customer choice, then minMwoScaled = 0.0
	// ow, figure it out.
	if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, theChild)) {
	  minMwoScaled = 0.0;
	}

	// otherwise, we need to go find the 0 SUB to find out what type of feature
	// it is:  
	else {
	  int nSubBoms;
	  witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), j, &nSubBoms);
	  assert(nSubBoms == 1);
	  char * nullSub;
	  witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, 0, &nullSub);
	  std::string pdf;
	  // if its a globalNullSub, then mwo=1
	  if (mpHelper_->isPartSpecialGlobalNullSubstitute(theWitRun_, nullSub, pdf))
	    minMwoScaled = 1.0;
	  // if its a globalMWONullSub, then mwo=0
	  else if (mpHelper_->isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun_, nullSub, pdf))
	    minMwoScaled = 0.0;
	  // otherwise, we need to go find the maxWithout vector and find the min
	  else {
	    LgFrScePartAppData * appDataPtr;
	    witGetPartAppData(theWitRun_, theChild.c_str(), (void **) &appDataPtr);
	    assert(appDataPtr != 0);
	   
	    LgFrTimeVecFloat maxWithout(appDataPtr->maxWithout());
	    minMwoScaled = maxWithout.min();
	  }
	  witFree(nullSub);
	}
      }



      // if you got here, then its bonafide child
      int childPartIndex = mpHelper_->witPartIndex(theWitRun_, child);
      assert(childPartIndex >= 0);

      // get the belowlist for this part and set the incidence
      // vector[i] to minMwo if i in belowList, +2 if not.

      // if the incidence matrix has not yet been populated, then go
      // compute it from the below list.
      if (incidenceMatrix_[childPartIndex] == 0)
	this->getDDincidenceVector(child,  minMwoScaled, childPartIndex);

      for ( k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > incidenceMatrix_[childPartIndex][k])
	  incidenceMatrix_[i][k] = incidenceMatrix_[childPartIndex][k];
      }

      witFree(child);
      // temp fix from Tom ... 3.101
      free(incidenceMatrix_[childPartIndex]);
      incidenceMatrix_[childPartIndex] = 0;
    }
    
  }




  // Second Pass Independent Demands ONLY ...
  for ( i=0; i<nParts; i++) {

    std::string indepDemPart(partList[i]);

    // only operate on NORMAL parts
    if (! mpHelper_->isPartNormal(theWitRun_, indepDemPart))
      continue;

    // only want part with one or more demands
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    int jj = 0; // Pulled out of the for below by RW2STL
    for (jj=0; jj<nDemands; jj++) {
      witFree(dList[jj]);
    }
    witFree(dList);
      
    if (nDemands == 0) {
      continue;
    }



    // compute a default incidence vec for this indepDemPart.  
    // BUG FIX: 20010813,  The assert for incidenceMatrix_[i] == nULL was failing.
    //                     This is because the part i is not a GPD and it may (most likely)
    //                     will have been already computed.  DUH!!

    if (incidenceMatrix_[i] == 0) {
      // if the incidence matrix has not yet been populated, then go
      // compute it from the below list.
      this->getDDincidenceVector(partList[i],  0.0, i);
    }
    
  }



  for ( i=0; i<nParts; i++) {
    witFree(partList[i]);
  }
  witFree(partList);

  state_ = 1;
  
}


// print the demand drivers table
void
LgFrSceDemandDriver::getDDincidenceVector(char *  thePart, 
					  float minMwoScaled,
					  int childPartIndex)
{
  char ** belowList;
  int nBelowParts;


  witGetPartBelowList(theWitRun_, thePart, &nBelowParts, &belowList);

  
  float * incidenceVec = (float *) malloc(nParts_ * sizeof(float));
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts_; i++) {
    incidenceVec[i] = 2.0;
  }

  for (i=0; i<nBelowParts; i++) {
    int partIndex = mpHelper_->witPartIndex(theWitRun_, belowList[i]);
    assert(partIndex >= 0);
    incidenceVec[partIndex] = minMwoScaled;
    witFree(belowList[i]);
  }

  witFree(belowList);

  incidenceMatrix_[childPartIndex] = incidenceVec;  
				   
}


// print the demand drivers table
void
LgFrSceDemandDriver::print(std::string fileName, MclFacility * theErrFacil)
{
  assert(state_);

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*theErrFacil)("CannotOpenFileForWrite",MclArgList() 
		       << "Demand Drivers" 
		       << fileName);
  }

  long numRecords = 0;  // keep track of number of records



  int nParts;
  char ** partList;

  witGetParts(theWitRun_, &nParts, &partList);
  assert(nParts_ == nParts);

  std::string pp, geo;
    
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    // If it's a  geo planner demand parts
    if (mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, partList[i], pp, geo)) {

  
      std::string geoPlannerDemandPartName(partList[i]);
      
      assert(incidenceMatrix_[i] != 0);
      
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }
    }
    else if (mpHelper_->isPartNormal(theWitRun_, partList[i])) {
      // see if it has any independent Demands
      // only want part with one or more demands
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
	witFree(dList[jj]);
      }
      witFree(dList);
      
      if (nDemands == 0) {
	continue;
      }
      
      assert(incidenceMatrix_[i] != 0);
      
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	std::string pp = mpHelper_->partname(partList[i]);
	std::string geo = mpHelper_->pdf(partList[i]);
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }

    }


  }

  // now clean up 
  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  outFile.close();
}



// a more memory efficent method
void
LgFrSceDemandDriver::computeAndPrint(std::string fileName, MclFacility * theErrFacil)
{



  // the incidenceMatrix:
  //              incidenceMatrix[i][k] = 2.0 if k is not used in i
  //              incidenceMatrix[i][k] = 1.0 if k is used in i as optional feature
  //              incidenceMatrix[i][k] = 0.0 if k is used in i as mandatory feature
  //              incidenceMatrix[i][k] < 0.0 if k is used in i as customerChoice feature

  int nPeriods;
  witGetNPeriods(theWitRun_, &nPeriods);

  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
  if (outFile.fail()) {
    (*theErrFacil)("CannotOpenFileForWrite",MclArgList() 
		       << "Demand Drivers" 
		       << fileName);
  }

  long numRecords = 0;  // keep track of number of records



  int nParts;
  char ** partList;

  witGetParts(theWitRun_, &nParts, &partList);
  assert(nParts_ == nParts);

  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
  }


  std::string pp, geo;
    
  for (i=0; i<nParts; i++) {
    // If it's a  geo planner demand parts
    if (mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, partList[i], pp, geo)) {


      // +++++++++++++++++++++++++++++++++++

      std::string geoPlannerDemandPartName(partList[i]);

      // compute a default incidence vec for this GPD.  It should be 0
      // to begin and we set it all to 2.0 
      assert(incidenceMatrix_[i] == 0);
      incidenceMatrix_[i] = (float *) malloc(nParts * sizeof(float));
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
	incidenceMatrix_[i][k] = 2.0;
      }

      // check for special case: GPD with no demands
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
	witFree(dList[jj]);
      }
      witFree(dList);
      
      if (nDemands == 0) {
	free(incidenceMatrix_[i]);
	incidenceMatrix_[i] = 0;
	continue;
      }
      


      // now loop over the children of the GPD if the child is a feature part, 
      // then we need to pick up the maxWithout vector.
      int nBom;
      witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), &nBom);
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<nBom; j++) {
	float minMwoScaled = 0.0;
	char * child;
	witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, &child);
	std::string theChild(child);
	std::string ggg, bbc,pptlb;
	
	// anything other than normal or special Feature part gets skipped      
	if ((! mpHelper_->isPartNormal(theWitRun_, child)) 
	    && (! mpHelper_->isPartSpecialFeature(theWitRun_, theChild))
	    && (! mpHelper_->isPartSpecialBbCategory(theWitRun_, theChild,pptlb,ggg,bbc))) {
	  witFree(child);
	  continue;
	}

	
	if (mpHelper_->isPartSpecialFeature(theWitRun_, theChild)) {
	  // if its customer choice, then minMwoScaled = 0.0
	  // ow, figure it out.
	  if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, theChild)) {
	    minMwoScaled = 0.0;
	  }
	  
	  // otherwise, we need to go find the 0 SUB to find out what type of feature
	  // it is:  
	  else {
	    int nSubBoms;
	    witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), j, &nSubBoms);
	    assert(nSubBoms == 1);
	    char * nullSub;
	    witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, 0, &nullSub);
	    std::string pdf;
	    // if its a globalNullSub, then mwo=1
	    if (mpHelper_->isPartSpecialGlobalNullSubstitute(theWitRun_, nullSub, pdf))
	      minMwoScaled = 1.0;
	    // if its a globalMWONullSub, then mwo=0
	    else if (mpHelper_->isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun_, nullSub, pdf))
	      minMwoScaled = 0.0;
	    // otherwise, we need to go find the maxWithout vector and find the min
	    else {
	      LgFrScePartAppData * appDataPtr;
	      witGetPartAppData(theWitRun_, theChild.c_str(), (void **) &appDataPtr);
	      assert(appDataPtr != 0);
	      
	      LgFrTimeVecFloat maxWithout(appDataPtr->maxWithout());
	      minMwoScaled = maxWithout.min();
	    }
	    witFree(nullSub);
	  }
	}
	
	
	
	// if you got here, then its bonafide child
	int childPartIndex = mpHelper_->witPartIndex(theWitRun_, child);
	assert(childPartIndex >= 0);

	// get the belowlist for this part and set the incidence
	// vector[i] to minMwo if i in belowList, +2 if not.
	
	// if the incidence matrix has not yet been populated, then go
	// compute it from the below list.
	if (incidenceMatrix_[childPartIndex] == 0)
	  this->getDDincidenceVector(child,  minMwoScaled, childPartIndex);
	
	for ( k=0; k<nParts; k++) {
	  if (incidenceMatrix_[i][k] > incidenceMatrix_[childPartIndex][k])
	    incidenceMatrix_[i][k] = incidenceMatrix_[childPartIndex][k];
	}
	
	witFree(child);
	// temp fix from Tom ... 3.101
	free(incidenceMatrix_[childPartIndex]);
	incidenceMatrix_[childPartIndex] = 0;
      }
    


      // +++++++++++++++++++++++++++++++++++
      assert(incidenceMatrix_[i] != 0);
      
      for (k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }

      // clear the memory
      free(incidenceMatrix_[i]);
      incidenceMatrix_[i] = 0;
    }






    else if (mpHelper_->isPartNormal(theWitRun_, partList[i])) {
      // see if it has any independent Demands
      // only want part with one or more demands
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
	witFree(dList[jj]);
      }
      witFree(dList);
      
      if (nDemands == 0) {
	continue;
      }

      // +++++++++++++++++++++++++++
      // compute the incidence vec for this indepDemPart.  
      if (incidenceMatrix_[i] == 0) {
	// if the incidence matrix has not yet been populated, then go
	// compute it from the below list.
	this->getDDincidenceVector(partList[i],  0.0, i);
      }
      // +++++++++++++++++++++++++++

      assert(incidenceMatrix_[i] != 0);
      
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	std::string pp = mpHelper_->partname(partList[i]);
	std::string geo = mpHelper_->pdf(partList[i]);
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }
      free(incidenceMatrix_[i]);
      incidenceMatrix_[i] = 0;
    }


  }

  // now clean up 
  for (i=0; i<nParts; i++) 
    witFree(partList[i]);
  witFree(partList);

  outFile.close();
}






 
  

// copy constructor 
LgFrSceDemandDriver::LgFrSceDemandDriver(const LgFrSceDemandDriver& source)
  :   
      theWitRun_ (source.theWitRun_),
      mpHelper_(source.mpHelper_),
      nParts_(source.nParts_),
      incidenceMatrix_(source.incidenceMatrix_),
      state_(source.state_)
{
  assert("Cant call this" == "the copy constructor for LgFrSceDemandDriver");
}

// assignment operator
LgFrSceDemandDriver&
LgFrSceDemandDriver::operator=(const LgFrSceDemandDriver& rhs)
{

  assert("Cant call this" == " the assignment operator for LgFrSceDemandDriver");
  if (this != &rhs) {		// Check for assignment to self
    theWitRun_ = rhs.theWitRun_;
    mpHelper_ = rhs.mpHelper_;
    nParts_ = rhs.nParts_;
    incidenceMatrix_ = rhs.incidenceMatrix_,
    state_ = rhs.state_;
  }
  return *this;
}

// destructor
LgFrSceDemandDriver::~LgFrSceDemandDriver()
{

  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts_; i++)
    free(incidenceMatrix_[i]);

  free(incidenceMatrix_);
}

@


1.9
log
@fixed demandDrives so it respects selectiveFeatures
remove usage of witSetPip
@
text
@d59 1
a59 1
    portableFree(partList[i]);
d62 1
a62 1
  portableFree(partList);
d87 1
a87 1
      portableFree(opList[o]);
d104 1
a104 1
	portableFree(sub);
d107 1
a107 1
    portableFree(opList[o]);
d109 1
a109 1
  portableFree(opList);
d169 1
d181 1
a181 1
      portableFree(dList[jj]);
d183 1
a183 1
    portableFree(dList);
d207 1
a207 1
	portableFree(child);
d242 1
a242 1
	  portableFree(nullSub);
d265 1
a265 1
      portableFree(child);
d267 1
a267 1
      portableFree(incidenceMatrix_[childPartIndex]);
d291 1
a291 1
      portableFree(dList[jj]);
d293 1
a293 1
    portableFree(dList);
d317 1
a317 1
    portableFree(partList[i]);
d319 1
a319 1
  portableFree(partList);
d349 1
a349 1
    portableFree(belowList[i]);
d352 1
a352 1
  portableFree(belowList);
d422 1
a422 1
	portableFree(dList[jj]);
d424 1
a424 1
      portableFree(dList);
d461 2
a462 2
    portableFree(partList[i]);
  portableFree(partList);
d535 1
a535 1
	portableFree(dList[jj]);
d537 1
a537 1
      portableFree(dList);
d540 1
a540 1
	portableFree(incidenceMatrix_[i]);
d563 1
a563 1
	  portableFree(child);
d599 1
a599 1
	    portableFree(nullSub);
d622 1
a622 1
	portableFree(child);
d624 1
a624 1
	portableFree(incidenceMatrix_[childPartIndex]);
d653 1
a653 1
      portableFree(incidenceMatrix_[i]);
d670 1
a670 1
	portableFree(dList[jj]);
d672 1
a672 1
      portableFree(dList);
d710 1
a710 1
      portableFree(incidenceMatrix_[i]);
d719 2
a720 2
    portableFree(partList[i]);
  portableFree(partList);
d767 1
a767 1
    portableFree(incidenceMatrix_[i]);
d769 1
a769 1
  portableFree(incidenceMatrix_);
@


1.8
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d163 2
d200 2
d204 2
a205 1
	  && (! mpHelper_->isPartSpecialFeature(theWitRun_, theChild))) {
d209 1
a209 1
      
d556 2
d560 2
a561 1
	    && (! mpHelper_->isPartSpecialFeature(theWitRun_, theChild))) {
d565 1
@


1.7
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1 6
d12 1
a12 1
#include <fstream.h>
d27 2
a28 2
  :   theWitRun_ (NULL),
      mpHelper_(NULL),
d30 1
a30 1
      incidenceMatrix_(NULL),
d45 1
a45 1
      incidenceMatrix_(NULL),
d55 4
a58 3
  // initialize the matrix to NULL pointers
  for (int i=0; i<nParts; i++) {
    incidenceMatrix_[i] = NULL;
d74 1
a74 1
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=FALSE, then this will
d77 1
a77 1
LgFrSceDemandDriver::setSubsNetAllowed(RWBoolean subNetAllowed, LgFrMultiPlantHelper & mpHelper)
d83 2
a84 1
  for (int o=0; o<nOperations; o++) {
d92 2
a93 1
    for (int b=0; b<nBoms; b++) {
d96 2
a97 1
      for (int s=0; s<nSubBoms; s++) {
d139 4
a142 3
  // initialize the matrix to NULL pointers
  for (int i=0; i<nParts; i++) {
    incidenceMatrix_[i] = NULL;
d152 1
a152 1
    RWCString pp, geo;
d161 1
a161 1
    RWCString geoPlannerDemandPartName(partList[i]);
d163 1
a163 1
    // compute a default incidence vec for this GPD.  It should be NULL
d165 1
a165 1
    assert(incidenceMatrix_[i] == NULL);
d167 2
a168 1
    for (int k=0; k<nParts; k++) {
d176 2
a177 1
    for (int jj=0; jj<nDemands; jj++) {
d191 3
a193 2
    witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName, &nBom);
    for (int j=0; j<nBom; j++) {
d196 2
a197 2
      witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName, j, &child);
      RWCString theChild(child);
d212 1
a212 1
	// otherwise, we need to go find the NULL SUB to find out what type of feature
d216 1
a216 1
	  witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName, j, &nSubBoms);
d219 2
a220 2
	  witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName, j, 0, &nullSub);
	  RWCString pdf;
d230 2
a231 2
	    witGetPartAppData(theWitRun_, theChild, (void **) &appDataPtr);
	    assert(appDataPtr != NULL);
d251 1
a251 1
      if (incidenceMatrix_[childPartIndex] == NULL)
d262 1
a262 1
      incidenceMatrix_[childPartIndex] = NULL;
d273 1
a273 1
    RWCString indepDemPart(partList[i]);
d283 2
a284 1
    for (int jj=0; jj<nDemands; jj++) {
d300 1
a300 1
    if (incidenceMatrix_[i] == NULL) {
d334 2
a335 1
  for (int i=0; i<nParts_; i++) {
d355 1
a355 1
LgFrSceDemandDriver::print(RWCString fileName, MclFacility * theErrFacil)
d359 1
a359 1
  ofstream outFile(fileName, ios::out, 0666);
d376 1
a376 1
  RWCString pp, geo;
d378 2
a379 1
  for (int i=0; i<nParts; i++) {
d384 1
a384 1
      RWCString geoPlannerDemandPartName(partList[i]);
d386 1
a386 1
      assert(incidenceMatrix_[i] != NULL);
d388 2
a389 1
      for (int k=0; k<nParts; k++) {
d396 2
a397 2
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
d414 2
a415 1
      for (int jj=0; jj<nDemands; jj++) {
d424 1
a424 1
      assert(incidenceMatrix_[i] != NULL);
d426 2
a427 1
      for (int k=0; k<nParts; k++) {
d434 4
a437 4
	RWCString pp = mpHelper_->partname(partList[i]);
	RWCString geo = mpHelper_->pdf(partList[i]);
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
d465 1
a465 1
LgFrSceDemandDriver::computeAndPrint(RWCString fileName, MclFacility * theErrFacil)
d479 1
a479 1
  ofstream outFile(fileName, ios::out, 0666);
d496 4
a499 3
  // initialize the matrix to NULL pointers
  for (int i=0; i<nParts; i++) {
    incidenceMatrix_[i] = NULL;
d503 1
a503 1
  RWCString pp, geo;
d512 1
a512 1
      RWCString geoPlannerDemandPartName(partList[i]);
d514 1
a514 1
      // compute a default incidence vec for this GPD.  It should be NULL
d516 1
a516 1
      assert(incidenceMatrix_[i] == NULL);
d518 2
a519 1
      for (int k=0; k<nParts; k++) {
d527 2
a528 1
      for (int jj=0; jj<nDemands; jj++) {
d535 1
a535 1
	incidenceMatrix_[i] = NULL;
d544 3
a546 2
      witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName, &nBom);
      for (int j=0; j<nBom; j++) {
d549 2
a550 2
	witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName, j, &child);
	RWCString theChild(child);
d565 1
a565 1
	  // otherwise, we need to go find the NULL SUB to find out what type of feature
d569 1
a569 1
	    witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName, j, &nSubBoms);
d572 2
a573 2
	    witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName, j, 0, &nullSub);
	    RWCString pdf;
d583 2
a584 2
	      witGetPartAppData(theWitRun_, theChild, (void **) &appDataPtr);
	      assert(appDataPtr != NULL);
d604 1
a604 1
	if (incidenceMatrix_[childPartIndex] == NULL)
d615 1
a615 1
	incidenceMatrix_[childPartIndex] = NULL;
d621 1
a621 1
      assert(incidenceMatrix_[i] != NULL);
d630 2
a631 2
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
d644 1
a644 1
      incidenceMatrix_[i] = NULL;
d658 2
a659 1
      for (int jj=0; jj<nDemands; jj++) {
d670 1
a670 1
      if (incidenceMatrix_[i] == NULL) {
d677 1
a677 1
      assert(incidenceMatrix_[i] != NULL);
d679 2
a680 1
      for (int k=0; k<nParts; k++) {
d687 4
a690 4
	RWCString pp = mpHelper_->partname(partList[i]);
	RWCString geo = mpHelper_->pdf(partList[i]);
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
d701 1
a701 1
      incidenceMatrix_[i] = NULL;
d755 2
a756 1
  for (int i=0; i<nParts_; i++)
@


1.7.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d21 2
a22 2
  :   theWitRun_ (0),
      mpHelper_(0),
d24 1
a24 1
      incidenceMatrix_(0),
d39 1
a39 1
      incidenceMatrix_(0),
d49 3
a51 4
  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
d67 1
a67 1
// FINISH_ME: If we ever introduce sub arcs that need to set NetAllowed=false, then this will
d70 1
a70 1
LgFrSceDemandDriver::setSubsNetAllowed(bool subNetAllowed, LgFrMultiPlantHelper & mpHelper)
d76 1
a76 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOperations; o++) {
d84 1
a84 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBoms; b++) {
d87 1
a87 2
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) {
d129 3
a131 4
  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
d141 1
a141 1
    std::string pp, geo;
d150 1
a150 1
    std::string geoPlannerDemandPartName(partList[i]);
d152 1
a152 1
    // compute a default incidence vec for this GPD.  It should be 0
d154 1
a154 1
    assert(incidenceMatrix_[i] == 0);
d156 1
a156 2
    int k = 0; // Pulled out of the for below by RW2STL
    for (k=0; k<nParts; k++) {
d164 1
a164 2
    int jj = 0; // Pulled out of the for below by RW2STL
    for (jj=0; jj<nDemands; jj++) {
d178 2
a179 3
    witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), &nBom);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
d182 2
a183 2
      witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, &child);
      std::string theChild(child);
d198 1
a198 1
	// otherwise, we need to go find the 0 SUB to find out what type of feature
d202 1
a202 1
	  witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), j, &nSubBoms);
d205 2
a206 2
	  witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, 0, &nullSub);
	  std::string pdf;
d216 2
a217 2
	    witGetPartAppData(theWitRun_, theChild.c_str(), (void **) &appDataPtr);
	    assert(appDataPtr != 0);
d237 1
a237 1
      if (incidenceMatrix_[childPartIndex] == 0)
d248 1
a248 1
      incidenceMatrix_[childPartIndex] = 0;
d259 1
a259 1
    std::string indepDemPart(partList[i]);
d269 1
a269 2
    int jj = 0; // Pulled out of the for below by RW2STL
    for (jj=0; jj<nDemands; jj++) {
d285 1
a285 1
    if (incidenceMatrix_[i] == 0) {
d319 1
a319 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts_; i++) {
d339 1
a339 1
LgFrSceDemandDriver::print(std::string fileName, MclFacility * theErrFacil)
d343 1
a343 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
d360 1
a360 1
  std::string pp, geo;
d362 1
a362 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d367 1
a367 1
      std::string geoPlannerDemandPartName(partList[i]);
d369 1
a369 1
      assert(incidenceMatrix_[i] != 0);
d371 1
a371 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
d378 2
a379 2
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
d396 1
a396 2
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
d405 1
a405 1
      assert(incidenceMatrix_[i] != 0);
d407 1
a407 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
d414 4
a417 4
	std::string pp = mpHelper_->partname(partList[i]);
	std::string geo = mpHelper_->pdf(partList[i]);
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
d445 1
a445 1
LgFrSceDemandDriver::computeAndPrint(std::string fileName, MclFacility * theErrFacil)
d459 1
a459 1
  ofstream outFile(fileName.c_str());//, ios::out, 0666);
d476 3
a478 4
  // initialize the matrix to 0 pointers
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    incidenceMatrix_[i] = 0;
d482 1
a482 1
  std::string pp, geo;
d491 1
a491 1
      std::string geoPlannerDemandPartName(partList[i]);
d493 1
a493 1
      // compute a default incidence vec for this GPD.  It should be 0
d495 1
a495 1
      assert(incidenceMatrix_[i] == 0);
d497 1
a497 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
d505 1
a505 2
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
d512 1
a512 1
	incidenceMatrix_[i] = 0;
d521 2
a522 3
      witGetOperationNBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), &nBom);
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<nBom; j++) {
d525 2
a526 2
	witGetBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, &child);
	std::string theChild(child);
d541 1
a541 1
	  // otherwise, we need to go find the 0 SUB to find out what type of feature
d545 1
a545 1
	    witGetBomEntryNSubsBomEntries(theWitRun_, geoPlannerDemandPartName.c_str(), j, &nSubBoms);
d548 2
a549 2
	    witGetSubsBomEntryConsumedPart(theWitRun_, geoPlannerDemandPartName.c_str(), j, 0, &nullSub);
	    std::string pdf;
d559 2
a560 2
	      witGetPartAppData(theWitRun_, theChild.c_str(), (void **) &appDataPtr);
	      assert(appDataPtr != 0);
d580 1
a580 1
	if (incidenceMatrix_[childPartIndex] == 0)
d591 1
a591 1
	incidenceMatrix_[childPartIndex] = 0;
d597 1
a597 1
      assert(incidenceMatrix_[i] != 0);
d606 2
a607 2
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
d620 1
a620 1
      incidenceMatrix_[i] = 0;
d634 1
a634 2
      int jj = 0; // Pulled out of the for below by RW2STL
      for (jj=0; jj<nDemands; jj++) {
d645 1
a645 1
      if (incidenceMatrix_[i] == 0) {
d652 1
a652 1
      assert(incidenceMatrix_[i] != 0);
d654 1
a654 2
      int k = 0; // Pulled out of the for below by RW2STL
      for (k=0; k<nParts; k++) {
d661 4
a664 4
	std::string pp = mpHelper_->partname(partList[i]);
	std::string geo = mpHelper_->pdf(partList[i]);
	std::string partname = mpHelper_->partname(partList[k]);
	std::string pdf = mpHelper_->pdf(partList[k]);
d675 1
a675 1
      incidenceMatrix_[i] = 0;
d729 1
a729 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts_; i++)
@


1.7.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d12 1
a12 1
//#include <fstream.h>
d479 1
a479 1
  std::ofstream outFile(fileName.c_str());//, ios::out, 0666);
@


1.6
log
@commit for 3.103
@
text
@d8 1
@


1.5
log
@Fixes in demandDriver logic tobe more efficent with Memory usage
@
text
@a337 1

d345 1
a345 1
		       << "Total Demand" 
d439 254
@


1.4
log
@Preliminary Commit for release 3.10 ... still in development!!!!
@
text
@d245 3
@


1.3
log
@3.00 20010601 Rev 01: Fix: Demand Driver did not report or analyze
independent demand.
@
text
@d276 4
a279 3
    // compute a default incidence vec for this indepDemPart.  It should be NULL
    // to begin and we set it all to 2.0 
    assert(incidenceMatrix_[i] == NULL);
d281 5
a285 9



    // get the belowlist for this part and set the incidence
    // vector[i] to minMwo if i in belowList, +2 if not.
    
    // if the incidence matrix has not yet been populated, then go
    // compute it from the below list.
    this->getDDincidenceVector(partList[i],  0.0, i);
@


1.2
log
@modifications for sce 2.31
@
text
@d132 5
a136 1
	  
d138 1
d249 50
d363 3
a365 3
    // only work on geo planner demand parts
    if (! mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, partList[i], pp, geo))
      continue;
d367 35
a401 8
    RWCString geoPlannerDemandPartName(partList[i]);

    assert(incidenceMatrix_[i] != NULL);
    
    for (int k=0; k<nParts; k++) {
      if (incidenceMatrix_[i][k] > 1.0)
	continue;
      if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
d403 3
d407 20
a426 10
      // ok, print a record
      RWCString partname = mpHelper_->partname(partList[k]);
      RWCString pdf = mpHelper_->pdf(partList[k]);
      outFile << "\"" 
	      << pp << "\",\"" 
	      << geo << "\",\""
	      << partname << "\",\"" 
	      << pdf << "\","
	      << incidenceMatrix_[i][k] << "\n";
      numRecords++;
d429 1
@


1.2.6.1
log
@Commit for Rev01: Demand drivers were not reporting on independent demand.
@
text
@d132 1
a132 5



  // Make TWO passes.  ONce ot pick up the GPD demands and the second one to pick up the 
  // the independent demands
a133 1
  // FIST PASS .... GPD only ....
a243 50



  // Second Pass Independent Demands ONLY ...
  for ( i=0; i<nParts; i++) {

    RWCString indepDemPart(partList[i]);

    // only operate on NORMAL parts
    if (! mpHelper_->isPartNormal(theWitRun_, indepDemPart))
      continue;

    // only want part with one or more demands
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    for (int jj=0; jj<nDemands; jj++) {
      portableFree(dList[jj]);
    }
    portableFree(dList);
      
    if (nDemands == 0) {
      continue;
    }



    // compute a default incidence vec for this indepDemPart.  It should be NULL
    // to begin and we set it all to 2.0 
    assert(incidenceMatrix_[i] == NULL);




    // get the belowlist for this part and set the incidence
    // vector[i] to minMwo if i in belowList, +2 if not.
    
    // if the incidence matrix has not yet been populated, then go
    // compute it from the below list.
    this->getDDincidenceVector(partList[i],  0.0, i);
    
  }



  for ( i=0; i<nParts; i++) {
    portableFree(partList[i]);
  }
  portableFree(partList);

d308 5
a312 2
    // If it's a  geo planner demand parts
    if (mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, partList[i], pp, geo)) {
d314 6
a319 36
  
      RWCString geoPlannerDemandPartName(partList[i]);
      
      assert(incidenceMatrix_[i] != NULL);
      
      for (int k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }
    }
    else if (mpHelper_->isPartNormal(theWitRun_, partList[i])) {
      // see if it has any independent Demands
      // only want part with one or more demands
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
      for (int jj=0; jj<nDemands; jj++) {
	portableFree(dList[jj]);
      }
      portableFree(dList);
      
      if (nDemands == 0) {
a320 1
      }
d322 10
a331 22
      assert(incidenceMatrix_[i] != NULL);
      
      for (int k=0; k<nParts; k++) {
	if (incidenceMatrix_[i][k] > 1.0)
	  continue;
	if (! mpHelper_->isPartNormal(theWitRun_, partList[k]))
	  continue;
	
	// ok, print a record
	RWCString pp = mpHelper_->partname(partList[i]);
	RWCString geo = mpHelper_->pdf(partList[i]);
	RWCString partname = mpHelper_->partname(partList[k]);
	RWCString pdf = mpHelper_->pdf(partList[k]);
	outFile << "\"" 
		<< pp << "\",\"" 
		<< geo << "\",\""
		<< partname << "\",\"" 
		<< pdf << "\","
		<< incidenceMatrix_[i][k] << "\n";
	numRecords++;
	
      }
a333 1

@


1.2.6.2
log
@bug fix for Rev02.
removed an assert that was incorrect.
@
text
@d276 3
a278 4
    // compute a default incidence vec for this indepDemPart.  
    // BUG FIX: 20010813,  The assert for incidenceMatrix_[i] == nULL was failing.
    //                     This is because the part i is not a GPD and it may (most likely)
    //                     will have been already computed.  DUH!!
d280 9
a288 5
    if (incidenceMatrix_[i] == NULL) {
      // if the incidence matrix has not yet been populated, then go
      // compute it from the below list.
      this->getDDincidenceVector(partList[i],  0.0, i);
    }
@


1.1
log
@Initial revision
@
text
@d127 1
a127 2
  float * incidenceVector;
  
@


1.1.1.1
log
@Import sce
@
text
@@

head	1.6;
access;
symbols
	sce_5_01_20080919:1.5
	latest_sce_4_20_20060523:1.5.0.4
	sce_4_20_20060523:1.5
	latest_sce4_20_OSL:1.5.0.2
	sce_4_20_OSL:1.5
	sce_4_20_20051222:1.5
	sce_4_10_30050426:1.5
	sce_4_05_20040511:1.5
	sce_4_00_20040201:1.4
	nextGenBranch:1.4.0.2
	nextGenRoot:1.4
	sce_3_30_20030627:1.4
	EndRw-branch:1.3.0.2
	Root-of-EndRw:1.3
	EndWitRw-branch:1.2.0.4
	Root-of-EndWitRw:1.2
	RwToStl-branch:1.2.0.2
	Root-of-RwToStl:1.2
	latest_sce_3_10_20010924:1.1.1.1.0.8
	sce_3_10_20010924:1.1.1.1
	latest_sce_3_00_20010601:1.1.1.1.0.6
	sce_3_00_20010601:1.1.1.1
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.12.15.23.53.23;	author ervolina;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.04.20.28.12;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.15.19.36.57;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.26.14.25.33;	author fasano;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.03.28.21.49.43;	author ervolina;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.18.36.53;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.18.36.53;	author wit;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.08.17.43.17;	author rwToStl;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.01.09.13.14.31;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.6
log
@6.2 latest commits to old repository
@
text
@#include <mcl/src/mdsPragma.h>
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
// file: sceFssMg.C
// author:  tom

#include <stdlib.h>
#include <assert.h>
#include <mcl/src/mcl.h>
#include <sce/src/sceDefin.h>
#include <sce/src/sceFssMg.h>
#include <scenario/src/calendar.h>
#include <wit/src/wit.h>
#include <sce/src/mPlantH.h>
#include <sce/src/exploders.h>
#include <sce/src/scenSce.h>
#include <sce/src/sceParam.h>


// + ABout FSS:
// +
// + 

// + There are three fssSchemes:
// + fssFlag=S ==> Singleton Fss: Loops thru every independent demand (geoPlannerDemands only,
// + Doesn't look at 2nd pass features yet)  If the demand is not
// + met completely within FSSHorizon, An FSS is done with That
// + one (ie, singleton) demand as the demand focus.  It then picks
// + up shortage of components that are lowest level only!!
// +
// + fssFlag=G ==> General FSS: 
// + User defines sets via the FSSFile.  Each set is seperate FSS.
//
//



// Potential FSS strategies:  NOte: these are our original notes
// from that famous meeting.  We have stuck with the green method
// ever since.  The sleazy red method was implemented but only with
// the witU5 fullexplode approach (ie, the iterative mrp's where
// you pick up assembly reqVols and place them as a demand).  That
// method has been removed.  IF you want it, get the
// SCE 1.30 19961114FIX out of the repository.  Beware though, its obsolete.
//
// The green method ahs gone through some evolution (for the better).
// Check the actual code for better documetnation than is right here.
// TE 11/21/1996
// ==========================================================
// ======== Sleazy Red =====
//
// Compute FSSCov:
// Set demandVol = shipVol FOR ALL demands,
// Set demandVol(FocusDemand) = 0
// Run witMrp
// FSSCov = mrpExcessVol FOR ALL parts
//
// Compute FSSReq:
// Set supplyVol = mrpExcessVol FOR ALL parts
// Set demandVol = 0 for all demands
// Set demandVol = original demandVol for focus demand only
// Run WUtlComputeDependentDemandAndPlanOrders
// FSSReq = totalDemand (ie, mrpConsVol from full explode mrp)
//  ---

// ==========================================================
// ======== Blue =====
//
// Compute FSSCov:
//
// -- STEP 1: Compute Supply available for Focus after netting out  ---
//            the supply consumed by all the Non-focus demand
// Init FSSCov = excessVol
// Set supplyVol = 0 for all parts
// Set demandVol = 0 FOR ALL demands,
// Set demandVol(FocusDemand) = shipVol(FocusDemand)
// Run WUtlComputeDependentDemandAndPlanOrders (ie, full explode MRP)
// FSSCov += totalDemand (ie, mrpConsVol)  for all raw parts
//
// Compute FSSReq:
// Set supplyVol = excessVol FOR ALL parts
// Set demandVol = 0 for all demands
// Set demandVol = original demandVol for focus demand only
// Run WUtlComputeDependentDemandAndPlanOrders
// FSSReq = totalDemand (ie, mrpConsVol from full explode mrp)

// ==========================================================
// ======== Green =====
//
// Compute FSSCov:
//
// -- STEP 1: Compute Supply available for Focus after netting out  ---
//            the supply consumed by all the Non-focus demand
// Init FSSCov = excessVol
// Set supplyVol = 0 for all parts
// Set demandVol = 0 FOR ALL demands,
// Set demandVol(FocusDemand) = shipVol(FocusDemand)
// run witMrp
// FSSCov += mrpConsVol  for all raw parts
//
// Compute FSSReq:
// Set supplyVol = excessVol + reqVol FOR ALL parts
// Set demandVol = 0 for all demands
// Set demandVol = original demandVol for focus demand only
// Run WUtlComputeDependentDemandAndPlanOrders
// FSSReq = totalDemand (ie, mrpConsVol from full explode mrp)

// ===========================================================


#ifndef ELIMINATE_OLD_MAIN




void
LgFrSceFssMgr::generalSetFss()
{
  std::string fssGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssGeneralSetMethod");
  std::string fssFeatureGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssFeatureGeneralSetMethod");
  int       fssGeneralSetHorizon = scenScePtr_->setOfParameters().getInt("fssGeneralSetHorizon");
  std::string fssGeneralSetFileName = scenScePtr_->setOfParameters().getString("fssGeneralSetFileName");
  std::string fssGeneralSetFile  = scenScePtr_->setOfParameters().getString("fssGeneralSetFile");

  std::string type("generalSet");
  this->runFss(type, 
	       fssGeneralSetMethod, 
	       fssFeatureGeneralSetMethod, 
	       fssGeneralSetHorizon,
	       fssGeneralSetFileName, 
	       fssGeneralSetFile);  
}

void
LgFrSceFssMgr::singletonFss()
{
  std::string fssSingletonMethod = scenScePtr_->setOfParameters().getString("fssSingletonMethod");
  std::string fssFeatureSingletonMethod = scenScePtr_->setOfParameters().getString("fssFeatureSingletonMethod");
  int       fssSingletonHorizon = scenScePtr_->setOfParameters().getInt("fssSingletonHorizon");
  std::string fssSingletonFileName = scenScePtr_->setOfParameters().getString("fssSingletonFileName");
  std::string fssSingletonFile;

  std::string type("singleton");
  this->runFss(type, 
	       fssSingletonMethod, 
	       fssFeatureSingletonMethod, 
	       fssSingletonHorizon,
	       fssSingletonFileName, 
	       fssSingletonFile);  
}

void
LgFrSceFssMgr::machineFss()
{
  std::string fssMachineMethod = scenScePtr_->setOfParameters().getString("fssMachineMethod");
  std::string fssFeatureMachineMethod = scenScePtr_->setOfParameters().getString("fssFeatureMachineMethod");
  int       fssMachineHorizon = scenScePtr_->setOfParameters().getInt("fssMachineHorizon");
  std::string fssMachineFileName = scenScePtr_->setOfParameters().getString("fssMachineFileName");
  std::string fssMachineFile  = scenScePtr_->setOfParameters().getString("fssMachineFile");

  std::string type("machine");
  this->runFss(type, 
	       fssMachineMethod, 
	       fssFeatureMachineMethod, 
	       fssMachineHorizon,
	       fssMachineFileName, 
	       fssMachineFile);  
}



// ==================
// ====  run FSS ====
// ==================
void
LgFrSceFssMgr::runFss(std::string & fssType,
                      std::string & fssMethod,
		      std::string & fssFeatureMethod,
		      int         fssHorizon,
		      std::string & fssOutputFileName,
		      std::string & fssInputSetFileName)
{

  WitRun * theWitRun = this->theWitRun_;
  int      nPeriods;
  int      i, j, t, ii;



  WitRun *  localWitRun;
  char   *  focusPartName;
  char   *  focusDemandName;
  int       nParts;  
  char  **  partList;
  float *   focusDemandVol;
  float **  FSSReq;  
  float **  FSSCov;

  // counter for number of printed output records
  long numRecords = 0;
  // also needs a seperate output record counter for log reporting
  long numRecModified = 0;

  // these are for reporting on the fss input files if they exist.
  long goodRec = 0;
  long badRec = 0;
  long commentRec = 0;
  long totalRec = 0;
  long numDistinctSetIDs = 0;  // input number to check against output
  long numDistinctPrintedSetIDs = 0;  // output number to check against input
  long numModifiedDistinctPrintedSetIDs = 0; // ditto -- for 'modified' files
  int existsInputFile = 0;  // flag for whether or not there is an input file

  // Get the setOfParameters
  LgFrSceSetOfParameters & setOfParameters =  scenScePtr_->setOfParameters();
  
  int nStandaloneFeatureArcs = setOfParameters.getInt("nStandaloneFeatureArcs");

  MclFacility * theErrFacil = scenScePtr_->getErrFacility();  
  LgFrSceFssableExploderDecorator * myExploder;
  float **  forwardRollableStockVols = 0;  

  // open the Input file 
  std::ifstream fssInFile;
  std::ofstream scrubOutFile;
  LgFrSceScrubber * myScrubber = scenScePtr_->scrubber();
  if (fssType != "singleton") {
    fssInFile.open(fssInputSetFileName.c_str());

    // also must add summary to input file log, but this is a bit hairy
    existsInputFile = 1;  // true

    if (! fssInFile)  {
      std::string fileErrorString("Cannot open FSS " + fssType + "Input File: ");
      (*theErrFacil)("WarningCannotOpenFile",MclArgList() 
		     << fileErrorString 
		     << fssInputSetFileName 
		     << "\nSCE will skip this FSS operation.\n" );
      return;
    }
    // Open a file for the scrubbed output 
    if (myScrubber -> scrubMode())     {
      std::string scrubFileName = myScrubber->scrubDir() + fssInputSetFileName;
      scrubOutFile.open(scrubFileName.c_str(), std::ofstream::out);
      if (!scrubOutFile.good())
	{
	  (*theErrFacil)("ScrubOutPutFileNameBad",MclArgList() 
			 << scrubFileName); 
	}
    }

  }


  std::ofstream fssOutFile;
  std::ofstream fssModifiedOutFile;
  std::ofstream * fssModifiedOutFilePtr;

    bool printModifiedFssMachReport = setOfParameters.getBool("printModifiedFssMachReport");

  // DONT do this if your are ONLY doing scrubbing
  if (! myScrubber->scrubOnly()) {


    // Now open the FSS OUTPUT file
    fssOutFile.open(fssOutputFileName.c_str(), std::ofstream::out);
    if (fssOutFile.fail()) {
      std::string fileErrorString("FSS " + fssType + "Report");
      (*theErrFacil)("CannotOpenFileForWrite",MclArgList() 
		     << fileErrorString 
		     << fssOutputFileName);
    }
    
    
    // Now open a special "modified" output file
    // NOTE this is an undocumented function
    if ( printModifiedFssMachReport) {
      std::string FSSMachReportFileName = setOfParameters.getString("FSSModifiedMachReportFileName");  
      fssModifiedOutFile.open(FSSMachReportFileName.c_str(), std::ofstream::out);
      fssModifiedOutFilePtr = &fssModifiedOutFile;
    }
    

    // get the list of  parts 
    witGetParts(theWitRun, &nParts, &partList);
    witGetNPeriods(theWitRun, &nPeriods);
  


    std::string siteCustomization = setOfParameters.getString("siteCustomization");
    
    if (fssHorizon < 0) fssHorizon = 0;
    if (fssHorizon >= nPeriods) fssHorizon = nPeriods - 1;
    
    // NOTE: we cast the thing right into its FSSAble incarnation, becuase
    //       the fss methods are only declared for the fssAble decorator.
    myExploder = (LgFrSceFssableExploderDecorator *) scenScePtr_->exploder();
    assert(myExploder->isA() == __LGFRSCEFSSABLEEXPLODERDECORATOR);
    
    // set these to zero up front.  We'll come back to it later
    // FINISH_ME: si this necesary??
    myExploder->setAllSupplyToZero();
    myExploder->setAllDemandToZero();
    
    // FINISH_ME: this eventually has to go (not a priority)!!  
    localWitRun = myExploder->localWitRun();
    


    // forward rollable stock vols:  This is only used with liberal
    // fss method.  
    if (fssMethod == "liberal") {  
      this->getForwardRollableStockSchedule(theWitRun,
					    nParts, 
					    partList, 
					    &forwardRollableStockVols);
    }
  }



  // ==================================================
  // Do an fssAnalysis for each User Defined Set with
  // exactly one entry!!
  // ==================================================

  std::string theFssSetName;
  std::string partReadFromlastTime;
  std::string fssSetNameReadFromLastTime;    
  LgFrStringVector focusPartNameList;
  int singletonPartIndex = -1;
  while (1) {
    if (fssType == "singleton")
      this->getNextSingletonFssSet(focusPartNameList,
                                   theWitRun,
                                   singletonPartIndex,
                                   theFssSetName,
                                   nParts,
                                   partList);
    
    else 
      this->getNextFssSet(focusPartNameList,
                          theWitRun,
                          theFssSetName,
                          fssSetNameReadFromLastTime,              
                          partReadFromlastTime,
                          fssInputSetFileName,
                          fssInFile,
			  scrubOutFile,
			  totalRec,
			  goodRec,
			  numDistinctSetIDs,
			  badRec,
			  commentRec);

    // when the list is empty, then the fss is basically over.
    if (focusPartNameList.empty())
      break;

    // DONT do this if your are ONLY doing scrubbing
    if (! myScrubber->scrubOnly()) {
      if (fssType == "machine")
	std::cout << "   fssMachineAnalysis: " << theFssSetName;    
      else if (fssType == "generalSet")
	std::cout << "   fssGeneralSetAnalysis: " << theFssSetName;
      else
	std::cout << "   fssSingletonAnalysis: " << theFssSetName;      
      
      
      // + fssHorizon: This is used in all scheme's (used to be ignored in generalSet)
      if (fssHorizon > -1) {
	
	if (this->isFssSetSatisfiedWithinHorizon(theWitRun,
						 focusPartNameList,
						 fssHorizon)) {
	  
	  // echo this to stdout as well as a message ...
	  std::cout << "  (Fully committed within FSS" << fssType << " horizon)" << std::endl;
	  
	  MclFacility * theErrFacil = scenScePtr_->getErrFacility();
	  (*theErrFacil)("FssHorizon",MclArgList() 
			 << theFssSetName 
			 << fssHorizon);
	  
	  //	badRec++;
	  continue;
	}
      }
      
      this->fssAnalysisBlue(myExploder,
			    fssMethod,
			    focusPartNameList,
			    nStandaloneFeatureArcs,
			    fssFeatureMethod,
			    nParts,
			    partList,
			    forwardRollableStockVols,                          
			    &FSSReq,
			    &FSSCov);
      
      numRecords += this->printFssGeneralFile(theWitRun,
					      nParts,
					      partList,
					      theFssSetName,
					      FSSReq,
					      FSSCov,
					      fssOutFile);
      
      // throw in a carriage return to indicate that the operation is done.
      std::cout << std::endl;

#ifdef SCE_ODBC
      if (fssType == "singleton")
	this->insertFssSingleSchemeDB(theWitRun,
				      nParts,
				      partList,
				      theFssSetName,
				      FSSReq,
				      FSSCov);
      
#endif
      
      // FINISH_ME: the printModifiedFssMachReport param and function is
      // enable but should not be used for singleton.  It should nopt be
      // used at all, for that matter until it is generalized to all three
      // scheme
      if ( printModifiedFssMachReport) {     
	numRecModified += this->printModifiedFssFile(theWitRun,
						     nParts,
						     partList,
						     theFssSetName,
						     FSSReq,
						     FSSCov,
						     *fssModifiedOutFilePtr);
	numModifiedDistinctPrintedSetIDs++;
      }
      
      // increment output record counter -- we will only count unique
      // "theFssSetName"'s
      numDistinctPrintedSetIDs++;
      
      
      // you must free the FSSCov and FSSReq vectors
      // NOTE: this must be free'd after EVERY invocation of
      // fssAnalysis()!!! 
      for (ii=0; ii<nParts; ii++)   {
	if (FSSCov[ii] != 0)                    
	  portableFree(FSSCov[ii]);
	if (FSSReq[ii] != 0)                    
	  portableFree(FSSReq[ii]);      
      }
      portableFree(FSSCov);
      portableFree(FSSReq);    
    }
  }
  
  //#ifdef SCE_ODBC                    
  // if (fssType == "singleton")
  //  std::cout << "Inserting FSSSingleCheme SUCCESSFULLY!" << std::endl;
  //#endif



  if (myScrubber->scrubMode())
    scrubOutFile.close();

  // DONT do this if your are ONLY doing scrubbing
  if (! myScrubber->scrubOnly()) {
    fssOutFile.close();
    if ( printModifiedFssMachReport) {     
      (*fssModifiedOutFilePtr).close();
    }
  

    // Saved attributes must be free'd
    if (fssMethod == "liberal") {
      for (i=0; i<nParts; i++)  {
	if (forwardRollableStockVols[i] != 0)
	  portableFree(forwardRollableStockVols[i]);
      }
      portableFree(forwardRollableStockVols);
    }
  }
  if (existsInputFile) {
    // print log for fssSetDef file into inputlogfile
    scenScePtr_->flatFileMgr().sceIOLogManager().printInputLog(fssInputSetFileName,totalRec,goodRec,badRec,commentRec,numDistinctSetIDs);
    // the 'checkRec' = numDistinctSetIDs - badRec
    
    // print the resultant output summary log into outputlogfile
    scenScePtr_->flatFileMgr().sceIOLogManager().printOutputLog(fssOutputFileName,numRecords,000,numDistinctPrintedSetIDs);
  }
  else { // this is the Singleton Run
    // print the resultant output summary log into outputlogfile
    scenScePtr_->flatFileMgr().sceIOLogManager().printOutputLog(fssOutputFileName,numRecords,000,numDistinctPrintedSetIDs+badRec);
    // I'm cheating here, but this is the easiest way to do this....
    // Problem: if this is a SINGLETON run and there are any 'badRec's then
    //          the input log will never be updated (and it probably shouldn't
    //          be because the badRec's here do not mean there is anythin 
    //          wrong with the input, but that it was skipped in the fssrun)
    //          ...However, since a badRec > 0 means records were skipped, the
    //          output will be wrong  ... and an error will be produced.
    //          so this is how i'm cheating: I just add the # of badRec to
    //          the number of sets printed.
    //
    //          Another option is to actually update the demand vol file log
    //          using the sceIOLogMgr().updateNode(..) method
    //          -- we might want to change it back though so it doesn't screw
    //          up other things later.
  }


  // DONT do this if your are ONLY doing scrubbing
  if (! myScrubber->scrubOnly()) {

    // also if there is going to be a modified report generated, must print
    // summary in outputlogfile
    if ( printModifiedFssMachReport) {     
      std::string FSSMachReportFileName =
	setOfParameters.getString("FSSModifiedMachReportFileName");  
      scenScePtr_->flatFileMgr().sceIOLogManager().printOutputLog(FSSMachReportFileName,
								  numRecModified,
								  000,
								  numModifiedDistinctPrintedSetIDs+badRec);
    }

    
    // free the parts list
    for (i=0; i<nParts; i++)  
      portableFree(partList[i]);
    portableFree(partList);
  }
}






void
LgFrSceFssMgr::fssAnalysisBlue(
    LgFrSceFssableExploderDecorator * myExploder,
    std::string & fssMethod,
    LgFrStringVector & focusPartNameList,
    int         nStandaloneFeatureArcs,
    std::string & fssFeatureMethod,
    int       nParts,
    char   ** partList,
    float  ** forwardRollableStockVols,    
    float *** FSSReqPtr,
    float *** FSSCovPtr)
{
  int i,j,k,t;
  witAttr  category;
  witBoolean exists;
  int nPeriods;

  // We will need to access the original and local witRun.
  WitRun * originalWitRun = myExploder->theWitRun();
  WitRun * localWitRun    = myExploder->localWitRun();  

  LgFrSceSetOfParameters & setOfParameters =  scenScePtr_->setOfParameters();  

  
  float * zeroVec;
  float *  mrpConsVol;  
  
  witGetNPeriods(originalWitRun, &nPeriods);
  
  // malloc a vector to be a vector of Zero's 
  zeroVec = (float *) malloc (nPeriods * sizeof(float));
  assert(zeroVec != 0);
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0.0;
  
  
  // malloc a vector to be a vector of FSSCov 
  float ** FSSCov = (float **) malloc (nParts * sizeof(float *));
  assert(FSSCov != 0);

  // malloc a vector to be a vector of FSSReq
  float ** FSSReq = (float **) malloc (nParts * sizeof(float *));
  assert(FSSReq != 0);

  for (i=0; i<nParts; i++) {
    FSSReq[i] = 0;
    FSSCov[i] = 0;
  }




  // ==========
  // fssMethod is either liberal or conservative.
  // -- liberal --  means Each fss run gets full access to the excessVol
  // including the sub-assembly excess.  
  // -- conservative -- means Each fss does NOT get access to the excessVol.
  // therefore FSSCov reports only on the supply consumed to meet the
  // demand as is.
  
  if (fssMethod == "liberal") {
    // a) Init FSSCov = excessVol
    // b) Set supplyVol = 0 for all parts  
    for (i=0; i<nParts; i++)  {
      float * excessVol;
      witGetPartExcessVol(originalWitRun, partList[i], &excessVol);
      FSSCov[i] = excessVol;
      // in single wr approach, we do NOT want to overwrite
      // the supplyVol for nullSub parts!!
      // FINISH_ME: whats the big deal here????
      std::string sub(partList[i]);
      if (! mpHelper_->isPartSpecialNullSubstitute(localWitRun, sub)) {
        witSetPartSupplyVol(localWitRun, partList[i], zeroVec);
      }
    }
  }
  

  // Set the demandVols in the localWitRun as follows:
  //   -  Set demandVol(FocusDemandSet) = shipVol(FocusDemandSet)
  //   -  Set demandVols(featuresInFocus) = amountOfFeaturesShipped
  //   -  Set supplVols(featuresInFocus) = shipVol(FocusMachine) * featRatio
  for (k=0; k<focusPartNameList.size(); k++) {
    // get a demand list for each part in the fssSet.  In the current SCE model,
    // there will only be ONE demand stream per part.  We do an assert here.
    // In the future, we may allow "sub-geo" demand.
    int fpNDemands;
    char ** fpDlist;
    witGetPartDemands(originalWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
    assert(fpNDemands == 1);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
      float * focusShipVol;
      witGetDemandShipVol(originalWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusShipVol);
      witSetDemandDemandVol(localWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);

      // Set demandVol(GPD,F) += shipVol(GPD,F) 
      //                            + ratio(GPD,F) * (shipVol(GPD) - SPV(GPD,F))
      if (nStandaloneFeatureArcs > 0) {
        adjustFssCovDemandForFeatures(localWitRun, originalWitRun, 
                                      focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);
        adjustFssCovSupplyForFeatures(localWitRun, originalWitRun, 
                                      focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);
      }

      
      portableFree(focusShipVol);
      portableFree(fpDlist[j]);
    }
    portableFree(fpDlist);
  }

  
    
  // e) run fullExplode
  myExploder->explode();

  
#if 0
  // for DEBUG use only
  std::string partDBFile = "output.partDB.FSSCovBlue";
  scenScePtr_->printPartDataBaseDumpFile(localWitRun, *mpHelper_, nPeriods, nParts, 
                                        partList, partDBFile);

  std::string debugDBFile = "output.debugDB.FSSCovBlue";
  scenScePtr_->printWitDebugFileForDummyParts(localWitRun, *mpHelper_, nPeriods, nParts, 
                                         partList, debugDBFile);
#endif
  


  // f) FSSCov += mrpConsVol  for all raw parts
  //    note: for fssMethod=liberal, FSSCov is already initialized and
  //    we need to actually add the vectors.  Otherwise, its null and we
  //    simply replace.
  for (i=0; i<nParts; i++)  {
    float * mrpConsVol;
    myExploder->mrpConsVol(partList[i], &mrpConsVol);
    if (FSSCov[i] != 0) {
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
        FSSCov[i][t] += mrpConsVol[t];
      portableFree(mrpConsVol);
    }
    else
      FSSCov[i] = mrpConsVol;
  }



  // f') Roll FSSCov forward if there's any forwardRollableStockVols avail
  //     Note: we only do this with the liberal method.
  if (fssMethod == "liberal") {  
    for (i=0; i<nParts; i++)  {
      witGetPartExists(localWitRun, partList[i], &exists);
      if (exists) {
        if (forwardRollableStockVols[i] != 0) {
          // If there is FSSCov in period t+1 AND non-excess stock in period t,
          // then move some of the FSSCov in period t+1 to period t.  The amount
          // to move is the minimum of FssCov[t+1] and forwardRollableStockVols[t]
          for (t=nPeriods-2; t>=0; t--) {
            float singlePeriodRollFwdQty =
              (forwardRollableStockVols[i][t] > FSSCov[i][t+1])
              ? FSSCov[i][t+1] : forwardRollableStockVols[i][t];
            if (singlePeriodRollFwdQty > 0.0001) {
              FSSCov[i][t+1] -= singlePeriodRollFwdQty;
              FSSCov[i][t]   += singlePeriodRollFwdQty;
#if 0
              // THIS TRICK IS DISABLED
              // Here's a nice little trick ... if you can roll Coverage
              // into an earlier period, then you should also decrement
              // that same quantity from "stock", that way it's not available
              // to the next fss "user".
              forwardRollableStockVols[i][t] -= singlePeriodRollFwdQty;
#endif            
            }
          }
        }
      }
    }
  }








  // Now for fssReq, reset the supplyVols(featuresInFocus) as follows
  //    supplyVol(F') = 0 if  fssFeatureMethod=maximal
  // and if fssFeatureMethod = minimal, then 
  //     supplyVol(F') = focusDemandVol * ratio(GPD,F) if nullSub(Gpd,F) is Global and 
  //                   = supplyVol(nullSub(GPD,F)) * ratio  if nullSub(Gpd,F) is maxWithout
  if (nStandaloneFeatureArcs > 0) {  
    for (k=0; k<focusPartNameList.size(); k++) {
      // get a demand list for each part in the fssSet.  In the current SCE model,
      // there will only be ONE demand stream per part.  We do an assert here.
      // In the future, we may allow "sub-geo" demand.
      int fpNDemands;
      char ** fpDlist;
      witGetPartDemands(originalWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
      assert(fpNDemands == 1);
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<fpNDemands; j++) {
        std::string focusDemandName = fpDlist[j];
        if (fssFeatureMethod == "maximal") {          
          adjustFssReqSupplyForFeaturesToZero(localWitRun, originalWitRun, 
                                              focusPartNameList[k].c_str(),
                                              focusDemandName.c_str(), zeroVec);
        }
        else {
          float * focusDemandVol;
          witGetDemandDemandVol(originalWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusDemandVol);
          adjustFssReqSupplyForFeatures(localWitRun, originalWitRun, 
                                        focusPartNameList[k].c_str(),
                                        focusDemandName.c_str(), focusDemandVol);
          portableFree(focusDemandVol);
        }
        portableFree(fpDlist[j]);
      }
      portableFree(fpDlist);
    }
  }
  

  
  
  // i) Set demandVol(focusDemandSet) = originalDemandVol(focusDemandSet)
  //        demandVol(featuresInFocus) = 0
  for (k=0; k<focusPartNameList.size(); k++) {
    // get a demand list for each part in the fssSet.  In the current SCE model,
    // there will only be ONE demand stream per part.  We do an assert here.
    // In the future, we may allow "sub-geo" demand.
    int fpNDemands;
    char ** fpDlist;
    std::string focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName.c_str(), &fpNDemands, &fpDlist);
    assert(fpNDemands == 1);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
      float * focusDemandVol;
      witGetDemandDemandVol(originalWitRun, focusPartName.c_str(), focusDemandName.c_str(), &focusDemandVol);      
      witSetDemandDemandVol(localWitRun, focusPartName.c_str(), focusDemandName.c_str(), focusDemandVol);
      portableFree(focusDemandVol);
      if (nStandaloneFeatureArcs > 0) {        
        adjustFssReqDemandForFeaturesToZero(localWitRun, originalWitRun, 
                                            focusPartNameList[k].c_str(),
                                            focusDemandName.c_str(), zeroVec);
      }
      portableFree(fpDlist[j]);
    }
    portableFree(fpDlist);
  }
  
  
  // j) Run full Explode mrp
  myExploder->explode();
  
  // k) FSSReq = mrpConsVol (from full explode mrp)
  for (i=0; i<nParts; i++)  {
    myExploder->mrpConsVol(partList[i], &(FSSReq[i]));
  }

  // i) Set demandVol(focusDemandSet) = 0
  for (k=0; k<focusPartNameList.size(); k++) {
    // get a demand list for each part in the fssSet.  In the current SCE model,
    // there will only be ONE demand stream per part.  We do an assert here.
    // In the future, we may allow "sub-geo" demand.
    int fpNDemands;
    char ** fpDlist;
    std::string focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName.c_str(), &fpNDemands, &fpDlist);
    assert(fpNDemands == 1);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
      witSetDemandDemandVol(localWitRun, focusPartName.c_str(), focusDemandName.c_str(), zeroVec);
      portableFree(fpDlist[j]);
    }
    portableFree(fpDlist);
  }
  

#if 0
  // for DEBUG USE only
  std::string partDBFile2 = "output.partDB.FSSReqBlue";
  scenScePtr_->printPartDataBaseDumpFile(localWitRun, *mpHelper_, nPeriods, nParts, 
                                        partList, partDBFile2);

  std::string debugDBFile2 = "output.debugDB.FSSReqBlue";
  scenScePtr_->printDummyPartDataBaseDumpFile(localWitRun, *mpHelper_, nPeriods, nParts, 
                                         partList, debugDBFile2);
#endif


  portableFree(zeroVec);

  (*FSSCovPtr) = FSSCov;
  (*FSSReqPtr) = FSSReq;  
}


int
LgFrSceFssMgr::isFssSetSatisfiedWithinHorizon(WitRun *  theWitRun,
                                              LgFrStringVector & focusPartNameList,
                                              int fssHorizon)
{
  // Check the fssHorizon !!
  // if ALL the demands within the set are satisfied on time within the
  // fssHorizon, then skip this set with an informational message.
  int allDemandInSetSatisfied = 1;
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<focusPartNameList.size(); k++) {
    // get a demand list for each part in the fssSet.  In the current SCE model,
    // there will only be ONE demand stream per part.  We do an assert here.
    // In the future, we may allow "sub-geo" demand.
    int fpNDemands;
    char ** fpDlist;
    witGetPartDemands(theWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
    assert(fpNDemands == 1);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
      float * focusShipVol;
      float * focusDemandVol;        
      witGetDemandShipVol(theWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusShipVol);
      witGetDemandDemandVol(theWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusDemandVol);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<=fssHorizon; t++) {
        if (focusShipVol[t] < focusDemandVol[t]) {
          allDemandInSetSatisfied = 0;
          break; 
        }
      }
      portableFree(focusShipVol);
      portableFree(focusDemandVol);          
      portableFree(fpDlist[j]);
    }
    portableFree(fpDlist);
    // if you've found one demand in the set that is unsatisfied then there
    // is no reason to check for more ... you gotta run fss
    if (! allDemandInSetSatisfied)
      break;
  }
  return allDemandInSetSatisfied;
}






#if 0


// ==================================================================
// ==================================================================
// ==================================================================
// ==================================================================


    
  
// ==========================================================
// ======== Green =====
//
// Compute FSSCov:
//
// -- STEP 1: Compute Supply available for Focus after netting out  ---
//            the supply consumed by all the Non-focus demand
// a) Init FSSCov = excessVol
// b) Set supplyVol = 0 for all parts
// b') supplyVol(F) += shipVol(FocusDemand) * ratio(FocusDemand,F)
//     for all features F that hang off of FocusDemand (the GPD part)
// c) Set demandVol = 0 FOR ALL demands,
// d) Set demandVol(FocusDemand) = shipVol(FocusDemand)
// d') Set demandVol(GPD,F) += shipVol(GPD,F) 
//                            + ratio(GPD,F) * (shipVol(GPD) - SPV(GPD,F))
// e) run witMrp
// f) FSSCov += mrpConsVol  for all raw parts
// f') Roll FSSCov forward if there's any non-excess stockVol avail
//
// Compute FSSReq:
// g) Set supplyVol = excessVol + reqVol for ALL parts
// g') NOTE only do this step if fssFeatureMethod == "minimal"
// g') supplyVol(F') = focusDemandVol * ratio(GPD,F) if nullSub(Gpd,F) is Global
// g')               = supplyVol(nullSub(GPD,F)) * ratio  if nullSub(Gpd,F) is maxWithout
//
// h) Set demandVol = 0 for all demands
// i) Set demandVol = original demandVol for focus demand only
// j) Run full Explode MRP
// k) FSSReq = totalDemand (ie, mrpConsVol from full explode mrp)
// ==========================================================  


#endif





   // This is clearly a bit kludgy.  We need to read the next "set" of
    // records.  However, we don't know that we're at the end of the set
    // until we've started the next one.  SO, remeber, the last record
    // and save it, so that next time you can start the search with that
    // last record.
void
LgFrSceFssMgr::getNextFssSet(LgFrStringVector & focusPartNameList,
                             WitRun *  theWitRun,
                             std::string & theFssSetName,
                             std::string & fssSetNameReadFromLastTime,
			     std::string & partReadFromlastTime,
                             std::string & FSSFile,
                             std::ifstream & fssInFile,
                             std::ofstream & scrubOutFile,
			     long & totalRec,
			     long & goodRec,
			     long & numDistinctSetIDs,
			     long & badRec,
			     long & commentRec)
{
  std::string dataLine;
  int result;
  std::string plannerPart;
  std::string geo;
  std::string pp;
  std::string g;
  std::string setId;
  LgFrSceFlatFileMgr & flatFileManager =  scenScePtr_->flatFileMgr();
  
  LgFrSceScrubber * myScrubber = scenScePtr_->scrubber();
  
  // start by emtpying the part List.  You ALWAYS wnat to
  // start with a clean one.
  focusPartNameList.clear();

  // Before you read any records, check to see if you've
  // got one from last time.  IF you do, then pop that
  // sucker onto the list.
  if (! fssSetNameReadFromLastTime.empty()) {
    theFssSetName = fssSetNameReadFromLastTime;
    focusPartNameList.push_back(partReadFromlastTime);
  }

  // reset fssSetNameReadFromLastTime and partReadFromlastTime
  // to null strings.  Otherwise you could get into a reaal
  // long loop
  fssSetNameReadFromLastTime = "";
  partReadFromlastTime = "";
  
  long lineNo = 0;
  while(fssInFile.peek() != EOF) {
    std::getline( fssInFile, dataLine );
    lineNo++;
    // keep track of total number of lines read
    totalRec++;

    //  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
      commentRec++;
      continue;
    }
    SCETokenizer next(dataLine);



    
    // get the next record
    setId = flatFileManager.nextQuotedString(next, result, FSSFile, dataLine, 
                                     lineNo, PURELY_OPTIONAL);
    setId.insert(0, "\"");
    setId.append("\"");
    
    plannerPart = flatFileManager.nextQuotedString(next, result, FSSFile, dataLine, 
                                           lineNo, MANDATORY);
    geo = flatFileManager.nextQuotedString(next, result, FSSFile, dataLine, lineNo, MANDATORY);

    // check to see that the part/geo entered is valid.
    // Note: we skip it and read another record even if the setId
    // has changed.  It really doesn't matter whether you reject it now
    // or reject it later.
    std::string fullWitPart = mpHelper_->geoPlannerDemandPartName(plannerPart, geo);
    if (! mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun,
                                                       fullWitPart,
                                                       pp,g)) {
      MclFacility * theErrFacil = scenScePtr_->getErrFacility();
      (*theErrFacil)("InvalidPartFSS",MclArgList() 
		     << FSSFile 
		     << (int)lineNo 
		     << plannerPart 
		     << geo 
		     << dataLine);
      badRec++;
      continue;      
    }

    // check to see that the geoPlannerDemandPart has exactly one demand on it.
    // if not, then its something that had a geoSource record, but did not have
    // a demand record for it.
    int fpNDemands;
    char ** fpDlist;
    witGetPartDemands(theWitRun, fullWitPart.c_str(), &fpNDemands, &fpDlist);

    // free this memory right away, we only need fpNDemands
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      portableFree(fpDlist[j]);
    }
    portableFree(fpDlist);

    if (fpNDemands == 0) {
      MclFacility * theErrFacil = scenScePtr_->getErrFacility();
      (*theErrFacil)("NoDemandFSS",MclArgList() 
		     << FSSFile 
		     << (int)lineNo 
		     << plannerPart 
		     << geo);
      badRec++;
      continue;      
    }
    

    // if theFssSetName was null, then this is the first time you've
    // been here.
    if (theFssSetName.empty()) {
      theFssSetName = setId;
      numDistinctSetIDs++;
    }

    // if the new setId is the same as the "current" one, then
    // pop that part onto the list
    if (setId == theFssSetName) {
      focusPartNameList.push_back(fullWitPart);
    }
    // otherwise, you've found a new set.  So, remember the setId
    // and part that you've just read and return the calling method.
    else {
      partReadFromlastTime = fullWitPart;
      fssSetNameReadFromLastTime = setId;
      numDistinctSetIDs++;  
      goodRec++;
      return;
    }
    goodRec++;

    // put it over to the scrubber
    if (myScrubber->scrubMode()) {
      scrubOutFile << dataLine << std::endl;
    }


  }
  // well, if you get here, you've hit an EOF

}




// + Singleton scheme is now implemented using the set approach.  We 
// + Get the next set based on the current partIndex.  Each time you request 
// + the next set, the partIndex is incremented and we simply search for the 
// + next GPD part and make it into a set of cardinality 1.  The setid is
// + ignored (set to "")
void
LgFrSceFssMgr::getNextSingletonFssSet(LgFrStringVector & focusPartNameList,
                                      WitRun *    theWitRun,
                                      int    &    singletonPartIndex,
                                      std::string & theFssSetName,
                                      int         nParts,
                                      char **     partList)
{
  std::string plannerPart;
  std::string geo;
  
  
  // start by emtpying the part List.  You ALWAYS want to
  // start with a clean one.
  focusPartNameList.clear();

  long lineNo = 0;
  while(++singletonPartIndex < nParts) {
    // find the next GPD part, add it to the set and return
    std::string fullWitPart(partList[singletonPartIndex]);
    if (mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun,
                                                     fullWitPart,
                                                     plannerPart, geo)) {

      // check to see that the geoPlannerDemandPart has exactly one demand on it.
      // if not, then its something that had a geoSource record, but did not have
      // a demand record for it.  Skip it!
      int fpNDemands;
      char ** fpDlist;
      witGetPartDemands(theWitRun, fullWitPart.c_str(), &fpNDemands, &fpDlist);
      if (fpNDemands == 1) {
        focusPartNameList.push_back(fullWitPart);
        theFssSetName = "\"" + plannerPart + "\",\"" + geo + "\"";
        int j = 0; // Pulled out of the for below by RW2STL
        for (j=0; j<fpNDemands; j++) {
          portableFree(fpDlist[j]);
        }
        portableFree(fpDlist);
        return;
      }
      else {
        int j = 0; // Pulled out of the for below by RW2STL
        for (j=0; j<fpNDemands; j++) {
          portableFree(fpDlist[j]);
        }
        portableFree(fpDlist);
      }      
    }
  }
}



// default constructor:
LgFrSceFssMgr::LgFrSceFssMgr()
  :   theWitRun_ (0),
      theCal_(0),
      mpHelper_(0),
      scenScePtr_(0)
{
    // all the work is done in initializer
}


// fairly general constructor:
LgFrSceFssMgr::LgFrSceFssMgr(WitRun * const theWitRun, 
                             LgFrCalendar * theCal,
                             LgFrMultiPlantHelper * mpHelper,
                             LgFrScenarioForSce * scenScePtr)
  :   theWitRun_ (theWitRun),
      theCal_(theCal),
      mpHelper_(mpHelper),
      scenScePtr_(scenScePtr)
{
    // all the work is done in initializer
}

  
  

// copy constructor -- need to work out (?)
LgFrSceFssMgr::LgFrSceFssMgr(const LgFrSceFssMgr& source)
  :   theWitRun_ (source.theWitRun_),
      theCal_(source.theCal_),
      mpHelper_(source.mpHelper_),
      scenScePtr_(source.scenScePtr_)
{
  // nothing to do
}

// assignment operator
LgFrSceFssMgr&
LgFrSceFssMgr::operator=(const LgFrSceFssMgr& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
    theWitRun_ = rhs.theWitRun_;
    theCal_ = rhs.theCal_;
    mpHelper_ = rhs.mpHelper_;
    scenScePtr_ = rhs.scenScePtr_;
  }
  return *this;
}

// destructor
LgFrSceFssMgr::~LgFrSceFssMgr()
{
  // nothing to do, 
}




// =================================================================== 
int
LgFrSceFssMgr::getForwardRollableStockSchedule(
    WitRun  * theWitRun,
    int       nParts, 
    char   ** partList, 
    float *** forwardRollableStockVolsPtr)
{

    int i, t;
    int supplyNonNull;
    int nPeriods;

    witGetNPeriods(theWitRun, &nPeriods);

    float ** forwardRollableStockVols = (float **) malloc (nParts * sizeof(float *));
    assert(forwardRollableStockVols != 0);

    for (i=0; i<nParts; i++)   {
      forwardRollableStockVols[i] = 0;
      bool vectorNonNull = false;
      witAttr category;
      float * stockVol;
      float * excessVol;
      witGetPartCategory(theWitRun, partList[i], &category);
      // if there's any stockVol that you can roll forward, do it
      if (category != WitCAPACITY) {
        witGetPartStockVol(theWitRun, partList[i], &stockVol);
        witGetPartExcessVol(theWitRun, partList[i], &excessVol);
        float cumExcess = 0.0;
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++) {
          cumExcess += excessVol[t];
          stockVol[t] -= cumExcess;
          if (stockVol[t] > 0.00001)
            vectorNonNull = true;
        }
        if (vectorNonNull)
          forwardRollableStockVols[i] = stockVol;
        else
          portableFree(stockVol);
        portableFree(excessVol);
      }
    }

    (*forwardRollableStockVolsPtr) = forwardRollableStockVols;
    return 0;
}
 
// =================================================================== 
int
LgFrSceFssMgr::getSupplyVols(
    WitRun  * theWitRun,
    int       nParts, 
    char   ** partList, 
    float *** supplyVolsPtr)
{

    int i, t;
    int supplyNonNull;
    int numSupplyVols = 0;
    int nPeriods;

    float * supplyVol;
    float ** originalSupplyVols;

    witGetNPeriods(theWitRun, &nPeriods);

    originalSupplyVols = (float **) malloc (nParts * sizeof(float *));
    assert(originalSupplyVols != 0);

    for (i=0; i<nParts; i++)   {
	supplyNonNull = 0;
	witGetPartSupplyVol(theWitRun, partList[i], &supplyVol);
	for (t=0; t<nPeriods; t++) {
	    if (supplyVol[t] > 0.00001) {
		supplyNonNull = 1;
		numSupplyVols++;
		break;
	    }
	}
	if (supplyNonNull)   
	    originalSupplyVols[i] = supplyVol;
	else {
	    originalSupplyVols[i] = 0;
	    portableFree(supplyVol);
	}

    }
    
    

    (*supplyVolsPtr) = originalSupplyVols;
    return(numSupplyVols);
}




// =================================================================== 
void
LgFrSceFssMgr::getDemandLists(
    WitRun   * theWitRun,
    int        nParts, 
    char    ** partList, 
    int     ** nDemandsPtr,
    char  **** demandListPtr)
{

    char ** dList;
    char *** demandList;
    int i,j,k,t;
    int nPeriods;
    int * nDemands;

    witGetNPeriods(theWitRun, &nPeriods);


    // malloc a vector to be a vector of pointers to demandName lists
    demandList = (char ***) malloc (nParts * sizeof(char **));
    assert(demandList != 0);
    // malloc a vector to be a vector of ints for storing the
    // number of demands per part
    nDemands = (int *) malloc (nParts * sizeof(int));
    assert(nDemands != 0);

    for (i=0; i<nParts; i++)  {
	demandList[i] = 0;
	nDemands[i] = 0;
    }


    for (i=0; i<nParts; i++)   {
	witGetPartDemands(theWitRun, partList[i], &(nDemands[i]), &dList);	
	if (nDemands[i] > 0)   {
	    demandList[i] = dList;
	}
    }

    (*demandListPtr) = demandList;    
    (*nDemandsPtr) = nDemands;
}


// =================================================================== 
void
LgFrSceFssMgr::getDemandVols(
    WitRun   * theWitRun,
    int        nParts, 
    char    ** partList, 
    int      * nDemands,
    char   *** dList,
    float **** demandVolsPtr)
{

    float *** demandVols;
    float **  dvolList;
    float * dVol;
    int i,j,k,t;
    int nPeriods;

    witGetNPeriods(theWitRun, &nPeriods);


// malloc a vector to be a vector of demandVols 
    demandVols = (float ***) malloc (nParts * sizeof(float **));
    assert(demandVols != 0);
    for (i=0; i<nParts; i++)
	demandVols[i] = 0;


    for (i=0; i<nParts; i++)   {
	if (nDemands[i] > 0)   {
	    dvolList = (float **) malloc(nDemands[i] * sizeof(float *));
	    demandVols[i] = dvolList;
	    assert(dvolList != 0);
	    for (j=0; j<nDemands[i]; j++)   {
		witGetDemandDemandVol(theWitRun, partList[i], dList[i][j], &dVol);
		dvolList[j] = dVol;
	    }
	}
    }

    (*demandVolsPtr) = demandVols;    

}



// =================================================================== 
void
LgFrSceFssMgr::getShipVols(
    WitRun   * theWitRun, 
    int        nParts, 
    char    ** partList, 
    int      * nDemands,
    char   *** dList,
    float **** shipVolsPtr)
{

    float *** shipVols;
    float **  svolList;
    float * svol;
    int i,j,k,t;
    int nPeriods;
    witBoolean postProcessed;
    

    witGetNPeriods(theWitRun, &nPeriods);


// malloc a vector to be a vector of shipVols 
    shipVols = (float ***) malloc (nParts * sizeof(float **));
    assert(shipVols != 0);
    for (i=0; i<nParts; i++)
	shipVols[i] = 0;


    for (i=0; i<nParts; i++)   {
	if (nDemands[i] > 0)   {
	    svolList = (float **) malloc(nDemands[i] * sizeof(float *));
	    shipVols[i] = svolList;
	    assert(svolList != 0);
	    for (j=0; j<nDemands[i]; j++)   {
		witGetDemandShipVol(theWitRun, partList[i], dList[i][j], &svol);
		svolList[j] = svol;
	    }
	}
    }

    (*shipVolsPtr) = shipVols;    

}



/* =================================================================== */
long
LgFrSceFssMgr::printFssGeneralFile(WitRun * theWitRun,
                                   int      nParts,
                                   char  ** partList,
                                   std::string & setID,
                                   float ** FSSReq,
                                   float ** FSSCov,
                                   std::ofstream & fssOutFile)   // output stream (already opened)        
{ 
  long goodRec = 0;
  int i, t;
  float cumTot;
  witAttr category;
  int nBom;
  int nPeriods;
  int isPartShort;

  float * fssReq;
  float * fssCov;
  LgFrSceFlatFileMgr & flatFileManager =  scenScePtr_->flatFileMgr();

  witGetNPeriods(theWitRun, &nPeriods);

    
  float * FSSDelta = new float[nPeriods];
  float * zeroVec = new float[nPeriods];
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0;

  for (i=0; i<nParts; i++) {
    std::string thePart(partList[i]);
    
    // ignore any special SCE dummy parts (for now)
    if (! mpHelper_->isPartNormal(theWitRun, thePart))
      continue;

    if (FSSReq[i] != 0)
      fssReq = FSSReq[i];
    else
      fssReq = zeroVec;

    if (FSSCov[i] != 0)
      fssCov = FSSCov[i];
    else
      fssCov = zeroVec;
    

    // only report on PCF parts
    if (! mpHelper_->isPartPcf(theWitRun, thePart))
      continue;
    



    // determine if the part is short
    isPartShort = 0;
    cumTot = 0.0;
    for (t=0; t<nPeriods; t++)   {
      cumTot += (fssCov[t] - fssReq[t]);
      if (cumTot < -0.0001)   {
        isPartShort = 1;
        break;
      }
    }
    
    // ignore components that aren't short 	    
    if (! isPartShort)
      continue;
      
    //  write the total Demand due to Focus: FSSReq
    fssOutFile << setID << ",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSReq\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, fssReq, 0, 15);
    goodRec++;

    //  write the total Coverage available for Focus: FSSCoverage
    fssOutFile << setID << ",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSCoverage\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, fssCov, 0, 15);
    goodRec++;
        

    //  Write out the Projected On-Hand */
    for (t=0; t<nPeriods; t++)   {
      FSSDelta[t] = fssReq[t] - fssCov[t];
    }
    fssOutFile << setID << ",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSDelta\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, FSSDelta, 0, 15);
    goodRec++;  
  }
  delete [] FSSDelta;
  delete [] zeroVec;

  return goodRec;
}


long
LgFrSceFssMgr::printModifiedFssFile(WitRun * theWitRun,
                                    int      nParts,
                                    char  ** partList,
                                    std::string & setID,
                                    float ** FSSReq,
                                    float ** FSSCov,
                                    std::ofstream & fssOutFile)   // output stream (already opened)        
{ 
  long goodRec = 0;

  int i, t;
  float cumTot;
  witAttr category;
  int nBom;
  int nPeriods;
  int isPartShort;

  float * fssReq;
  float * fssCov;
  LgFrSceFlatFileMgr & flatFileManager =  scenScePtr_->flatFileMgr();  

  witGetNPeriods(theWitRun, &nPeriods);

    
  float * FSSDelta = new float[nPeriods];
  float * zeroVec = new float[nPeriods];
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0;

  for (i=0; i<nParts; i++) {
    std::string thePart(partList[i]);
    
    // ignore any special SCE dummy parts (for now)
    if (! mpHelper_->isPartNormal(theWitRun, thePart))
      continue;

    if (FSSReq[i] == 0 && FSSCov[i] == 0)
      continue;

    if (FSSReq[i] != 0)
      fssReq = FSSReq[i];
    else
      fssReq = zeroVec;

    if (FSSCov[i] != 0)
      fssCov = FSSCov[i];
    else
      fssCov = zeroVec;
    


    // determine if the part is short
    isPartShort = 0;
    cumTot = 0.0;
    for (t=0; t<nPeriods; t++)   {
      cumTot += (fssCov[t] - fssReq[t]);
      if (cumTot < -0.0001)   {
        isPartShort = 1;
        break;
      }
    }
    
    // ignore components that aren't short 	    
    if (! isPartShort)
      continue;
      
    //  write the total Demand due to Focus: FSSReq
    fssOutFile << "\""
               << setID << "\",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSReq\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, fssReq, 0, 15);
    goodRec++;

    //  write the total Coverage available for Focus: FSSCoverage
    fssOutFile << "\""
               << setID << "\",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSCoverage\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, fssCov, 0, 15);
    goodRec++;
        

    //  Write out the Projected On-Hand */
    for (t=0; t<nPeriods; t++)   {
      FSSDelta[t] = fssReq[t] - fssCov[t];
    }
    fssOutFile << "\""
               << setID << "\",\""
               << mpHelper_->partname(thePart) << "\",\""
               << mpHelper_->pdf(thePart) << "\","
               << "\"FSSDelta\"";
    flatFileManager.writeCsvFloatVector(fssOutFile, nPeriods, FSSDelta, 0, 15);
      
    goodRec++;
  }
  delete [] FSSDelta;
  delete [] zeroVec;

  return goodRec;
}


void 
LgFrSceFssMgr::adjustFssCovSupplyForFeatures(WitRun * tempWitRun,
                                             WitRun * originalWitRun,
                                             const char  * focusPart,
                                             const char  * focusDemand,
                                             float * focusShipVol)
{
  LgFrMultiPlantHelper & mpHelper = scenScePtr_->multiPlantHelper();

  std::string plannerPart;
  std::string geo;
  // first test to see that the focus part is indeed a GPD part (otherwise
  // it could never have any features.
  if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(originalWitRun, focusPart,
                                                  plannerPart, geo)) {
    return;
  }
  
  std::string plannerTopLevelPart(focusPart);
  
  // Now loop through the bom arcs searching for a child with
  // a nullSubstitute 
  int nBom;
  witGetOperationNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
    char * fullWitFeaturePartName;
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);

    if (! mpHelper.isPartSpecialStandaloneFeature(originalWitRun, fullWitFeaturePartName)) {
      portableFree(fullWitFeaturePartName);
      continue;
    }
      //  add the supplyVol times the usageRate
      // (over the effectivity range only!)

    float ratio;
    witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
    int early, late;
    witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
    witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
    float * supplyVol;
    witGetPartSupplyVol(tempWitRun, fullWitFeaturePartName, &supplyVol);
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=early; t<=late; t++)
      supplyVol[t] += ratio * focusShipVol[t];
    witSetPartSupplyVol(tempWitRun, fullWitFeaturePartName, supplyVol);
    portableFree(supplyVol);
    
    portableFree(fullWitFeaturePartName);
  }
}



void 
LgFrSceFssMgr::adjustFssCovDemandForFeatures(WitRun * tempWitRun,
                                             WitRun * originalWitRun,
                                             const char  * focusPart,
                                             const char  * focusDemand,
                                             float * focusShipVol)
{
  LgFrMultiPlantHelper & mpHelper = scenScePtr_->multiPlantHelper();

  std::string plannerPart;
  std::string geo;
  // first test to see that the focus part is indeed a GPD part (otherwise
  // it could never have any features.
  if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(originalWitRun, focusPart,
                                                  plannerPart, geo)) {
    return;
  }
  
  std::string plannerTopLevelPart(focusPart);
  
  // Now loop through the bom arcs searching for a child with
  // a nullSubstitute 
  int nBom;
  witGetOperationNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
    char * fullWitFeaturePartName;
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);

    if (! mpHelper.isPartSpecialStandaloneFeature(originalWitRun, fullWitFeaturePartName)) {
      portableFree(fullWitFeaturePartName);
      continue;
    }

    // now see if the fullWitFeaturePartName is indeed a feature, by testing
    // to see if it has a nullSub part as a substitute.  
    int nSubBom;
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
    // if it has a sub, check to see that its a special null sub
    if (nSubBom > 0) {
      char * sub;
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
      // if it has a null sub, then add the supplyVol times the usageRate
      // (over the effectivity range only!)
      if (mpHelper.isPartSpecialNullSubstitute(originalWitRun, sub)) {
        // Yeah we found one!!
        // Now find the demand associated with this feature,gpd pair
        std::string featureDemandName =
          mpHelper.pureOptionBuildDemandName(plannerTopLevelPart);
        // make sure the demand exists
        std::string pp, g;
        assert(1 == mpHelper.isDemandSpecialPureOptionBuildDemand(tempWitRun, 
                                                                  fullWitFeaturePartName,
                                                                  featureDemandName,
                                                                  pp, g));
        float * featureShipVol;
        float * featureDemandVol;
        witGetDemandDemandVol(tempWitRun, fullWitFeaturePartName,
                              featureDemandName.c_str(), &featureDemandVol);
        witGetDemandShipVol(originalWitRun, fullWitFeaturePartName,
                            featureDemandName.c_str(), &featureShipVol);
        // now get the subProdVol
        float * subProdVol;
        witGetSubsBomEntryProdVol(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &subProdVol);        
        
        float ratio;
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
        int early, late;
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
        // And now, hold your breath, here comes the BIG formula!!
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=early; t<=late; t++)
          featureDemandVol[t] += featureShipVol[t]
                   + (ratio * (focusShipVol[t] - subProdVol[t]));
        witSetDemandDemandVol(tempWitRun, fullWitFeaturePartName,
                              featureDemandName.c_str(), featureDemandVol);
        
        portableFree(featureDemandVol);
        portableFree(featureShipVol);
        portableFree(subProdVol);        
      }
      portableFree(sub);
    }
    portableFree(fullWitFeaturePartName);
  }
}


void 
LgFrSceFssMgr::adjustFssReqDemandForFeaturesToZero(WitRun * tempWitRun,
                                                   WitRun * originalWitRun,
                                                   const char  * focusPart,
                                                   const char  * focusDemand,
                                                   float * zeroVec)
{
  LgFrMultiPlantHelper & mpHelper = scenScePtr_->multiPlantHelper();

  std::string plannerPart;
  std::string geo;
  // first test to see that the focus part is indeed a GPD part (otherwise
  // it could never have any features.
  if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(originalWitRun, focusPart,
                                                  plannerPart, geo)) {
    return;
  }
  
  std::string plannerTopLevelPart(focusPart);
  
  // Now loop through the bom arcs searching for a child with
  // a nullSubstitute 
  int nBom;
  witGetOperationNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
    char * fullWitFeaturePartName;
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);

    if (! mpHelper.isPartSpecialStandaloneFeature(originalWitRun, fullWitFeaturePartName)) {
      portableFree(fullWitFeaturePartName);
      continue;
    }

    
    // now see if the fullWitFeaturePartName is indeed a feature, by testing
    // to see if it has a nullSub part as a substitute.  
    int nSubBom;
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
    // if it has a sub, check to see that its a special null sub
    if (nSubBom > 0) {
      // abc
      char * sub;
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
      // if it has a null sub, then add the supplyVol times the usageRate
      // (over the effectivity range only!)
      if (mpHelper.isPartSpecialNullSubstitute(originalWitRun, sub)) {
        // Yeah we found one!!
        // Now find the demand associated with this feature,gpd pair
        std::string featureDemandName =
          mpHelper.pureOptionBuildDemandName(plannerTopLevelPart);
        // make sure the demand exists
        std::string pp, g;
        assert(1 == mpHelper.isDemandSpecialPureOptionBuildDemand(tempWitRun, 
                                                                  fullWitFeaturePartName,
                                                                  featureDemandName,
                                                                  pp, g));
        witSetDemandDemandVol(tempWitRun, fullWitFeaturePartName,
                              featureDemandName.c_str(), zeroVec);
        
      }
      portableFree(sub);
    }
    portableFree(fullWitFeaturePartName);
  }
}


void 
LgFrSceFssMgr::adjustFssReqSupplyForFeatures(WitRun * tempWitRun,
                                             WitRun * originalWitRun,
                                             const char  * focusPart,
                                             const char  * focusDemand,
                                             float * focusDemandVol)
{
  // g') supplyVol(F') = focusDemandVol * ratio(GPD,F) if nullSub(Gpd,F) is Global
  // g')               = supplyVol(nullSub(GPD,F)) * ratio  if nullSub(Gpd,F) is maxWithout
  
  LgFrMultiPlantHelper & mpHelper = scenScePtr_->multiPlantHelper();

  std::string plannerPart;
  std::string geo;
  // first test to see that the focus part is indeed a GPD part (otherwise
  // it could never have any features.
  if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(originalWitRun, focusPart,
                                                  plannerPart, geo)) {
    return;
  }

  std::string d1, d2, d3;  
  
  std::string plannerTopLevelPart(focusPart);
  
  // Now loop through the bom arcs searching for a child that is a 
  // special feature part
  int nBom;
  witGetOperationNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
    char * fullWitFeaturePartName;
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);

    if (! mpHelper.isPartSpecialStandaloneFeature(originalWitRun, fullWitFeaturePartName)) {
      portableFree(fullWitFeaturePartName);
      continue;
    }


    // now see if the fullWitFeaturePartName is indeed a feature, by testing
    // to see if it has a nullSub part as a substitute.  
    int nSubBom;
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
    // if it has a sub, check to see that its a special null sub
    if (nSubBom > 0) {
      char * sub;
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
      // if it has a null sub, then add the supplyVol times the usageRate
      // (over the effectivity range only!)
      if (mpHelper.isPartSpecialNullSubstitute(originalWitRun, sub)) {
        // Yeah we found one!!
        float * currentFeatSupplyVol;
        witGetPartSupplyVol(tempWitRun, fullWitFeaturePartName, &currentFeatSupplyVol);
        float ratio;
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
        int early, late;
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
        // g') supplyVol(F') = focusDemandVol * ratio(GPD,F) if nullSub(Gpd,F) is Global
        // g')               = supplyVol(nullSub(GPD,F)) * ratio  if nullSub(Gpd,F) is maxWithout
        if (mpHelper.isPartSpecialGlobalNullSubstitute(originalWitRun, sub, d1)) {
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++)
            currentFeatSupplyVol[t] += ratio * focusDemandVol[t];
        }
        else {
          float * maxWithoutSupplyVol;
          // Make sure you get the original supplyVol on the nullSub from the original
          // witrun
          witGetPartSupplyVol(originalWitRun, sub, &maxWithoutSupplyVol);
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++)
            currentFeatSupplyVol[t] += ratio * maxWithoutSupplyVol[t];
          portableFree(maxWithoutSupplyVol);
        }
        witSetPartSupplyVol(tempWitRun, fullWitFeaturePartName, currentFeatSupplyVol);
        portableFree(currentFeatSupplyVol);        
      }
      portableFree(sub);
    }
    portableFree(fullWitFeaturePartName);
  }
}

void 
LgFrSceFssMgr::adjustFssReqSupplyForFeaturesToZero(WitRun * tempWitRun,
                                                   WitRun * originalWitRun,
                                                   const char  * focusPart,
                                                   const char  * focusDemand,
                                                   float * zeroVec)
{
  LgFrMultiPlantHelper & mpHelper = scenScePtr_->multiPlantHelper();

  std::string plannerPart;
  std::string geo;
  // first test to see that the focus part is indeed a GPD part (otherwise
  // it could never have any features.
  if ( ! mpHelper.isPartSpecialGeoPlannerDemandPart(originalWitRun, focusPart,
                                                  plannerPart, geo)) {
    return;
  }

  std::string d1, d2, d3;  
  
  std::string plannerTopLevelPart(focusPart);
  
  // Now loop through the bom arcs searching for a child that is a 
  // special feature part
  int nBom;
  witGetOperationNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
    char * fullWitFeaturePartName;
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);

    if (! mpHelper.isPartSpecialStandaloneFeature(originalWitRun, fullWitFeaturePartName)) {
      portableFree(fullWitFeaturePartName);
      continue;
    }

    witSetPartSupplyVol(tempWitRun, fullWitFeaturePartName, zeroVec);
    portableFree(fullWitFeaturePartName);
  }
}


//------------ Added a new method for SCE ODBC access -------

#ifdef SCE_ODBC

void
LgFrSceFssMgr::insertFssSingleSchemeDB(WitRun * theWitRun,
                                       int      nParts,
                                       char  ** partList,
                                       std::string & setID,
                                       float ** FSSReq,
                                       float ** FSSCov)
{ 

  SceFSSSingleSchemeDB fsssDB;
  SceDBLink fsss(fsssDB);
  if (!fsssDB.fDelete())
    fsssDB.deleteTbl();
 
  int i, t;
  float cumTot;
  witAttr category;
  int nBom;
  int nPeriods;
  int isPartShort;

  float * fssReq;
  float * fssCov;
  LgFrSceFlatFileMgr & flatFileManager =  scenScePtr_->flatFileMgr();

  witGetNPeriods(theWitRun, &nPeriods);
  
  fsss.nPeriods(nPeriods);
    
  float * FSSDelta = new float[nPeriods];
  float * zeroVec = new float[nPeriods];
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0;

  for (i=0; i<nParts; i++) {
    std::string thePart(partList[i]);
    
    // ignore any special SCE dummy parts (for now)
    if (! mpHelper_->isPartNormal(theWitRun, thePart))
      continue;

    if (FSSReq[i] != 0)
      fssReq = FSSReq[i];
    else
      fssReq = zeroVec;

    if (FSSCov[i] != 0)
      fssCov = FSSCov[i];
    else
      fssCov = zeroVec;
 
    // only report on PCF parts
    if (! mpHelper_->isPartPcf(theWitRun, thePart))
      continue;
 
    // determine if the part is short
    isPartShort = 0;
    cumTot = 0.0;
    for (t=0; t<nPeriods; t++)   {
      cumTot += (fssCov[t] - fssReq[t]);
      if (cumTot < -0.0001)   {
        isPartShort = 1;
        break;
      }
    }
    
    // ignore components that aren't short 	    
    if (! isPartShort)
      continue;
      
    //  Write out the Projected On-Hand */
    for (t=0; t<nPeriods; t++)   {
      FSSDelta[t] = fssReq[t] - fssCov[t];
    }
  
    // split "SetID" into "plannerPart" and "Geo"
    size_t idx = setID.index(",");
    if (idx !=RW_NPOS)
      {
        std::string plannerPart(setID(1, idx-2));
        std::string geo(setID(idx+2, setID.length()-(idx+3)));
        fsss.insert(SceArgList()
                    << plannerPart.c_str()
                    << geo.c_str()
                    << mpHelper_->partname(thePart)
                    << mpHelper_->pdf(thePart)
                    << SceMakeVec(fssReq, nPeriods)
                    << SceMakeVec(fssCov, nPeriods)
                    << SceMakeVec(FSSDelta, nPeriods));              
      }
   
  }

  fsss.insert();
  
  delete [] FSSDelta;
  delete [] zeroVec;

}

#endif

#ifdef NDEBUG
#undef NDEBUG
#endif



// self-test : can I self test ??
void
LgFrSceFssMgr::test()
{
  
 
 
 }

#endif
@


1.5
log
@Modified to reduce microsoft compiler warning messages
@
text
@d1693 1
a1693 1
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
d1748 1
a1748 1
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
d1837 1
a1837 1
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
d1910 1
a1910 1
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
d1992 1
a1992 1
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
@


1.4
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d1 1
a1 1

@


1.3
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1 6
a12 1
#include <rw/ctoken.h>
d122 2
a123 2
  RWCString fssGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssGeneralSetMethod");
  RWCString fssFeatureGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssFeatureGeneralSetMethod");
d125 2
a126 2
  RWCString fssGeneralSetFileName = scenScePtr_->setOfParameters().getString("fssGeneralSetFileName");
  RWCString fssGeneralSetFile  = scenScePtr_->setOfParameters().getString("fssGeneralSetFile");
d128 1
a128 1
  RWCString type("generalSet");
d140 2
a141 2
  RWCString fssSingletonMethod = scenScePtr_->setOfParameters().getString("fssSingletonMethod");
  RWCString fssFeatureSingletonMethod = scenScePtr_->setOfParameters().getString("fssFeatureSingletonMethod");
d143 2
a144 2
  RWCString fssSingletonFileName = scenScePtr_->setOfParameters().getString("fssSingletonFileName");
  RWCString fssSingletonFile;
d146 1
a146 1
  RWCString type("singleton");
d158 2
a159 2
  RWCString fssMachineMethod = scenScePtr_->setOfParameters().getString("fssMachineMethod");
  RWCString fssFeatureMachineMethod = scenScePtr_->setOfParameters().getString("fssFeatureMachineMethod");
d161 2
a162 2
  RWCString fssMachineFileName = scenScePtr_->setOfParameters().getString("fssMachineFileName");
  RWCString fssMachineFile  = scenScePtr_->setOfParameters().getString("fssMachineFile");
d164 1
a164 1
  RWCString type("machine");
d179 3
a181 3
LgFrSceFssMgr::runFss(RWCString & fssType,
                      RWCString & fssMethod,
		      RWCString & fssFeatureMethod,
d183 2
a184 2
		      RWCString & fssOutputFileName,
		      RWCString & fssInputSetFileName)
d224 1
a224 1
  float **  forwardRollableStockVols = NULL;  
d227 2
a228 2
  ifstream fssInFile;
  ofstream scrubOutFile;
d231 1
a231 1
    fssInFile.open(fssInputSetFileName, ios::in);
d237 1
a237 1
      RWCString fileErrorString("Cannot open FSS " + fssType + "Input File: ");
d246 2
a247 2
      RWCString scrubFileName = myScrubber->scrubDir() + fssInputSetFileName;
      scrubOutFile.open(scrubFileName, ios::out);
d258 3
a260 3
  ofstream fssOutFile;
  ofstream fssModifiedOutFile;
  ofstream * fssModifiedOutFilePtr;
d262 1
a262 1
    RWBoolean printModifiedFssMachReport = setOfParameters.getBool("printModifiedFssMachReport");
d269 1
a269 1
    fssOutFile.open(fssOutputFileName, ios::out);
d271 1
a271 1
      RWCString fileErrorString("FSS " + fssType + "Report");
d281 2
a282 2
      RWCString FSSMachReportFileName = setOfParameters.getString("FSSModifiedMachReportFileName");  
      fssModifiedOutFile.open(FSSMachReportFileName, ios::out);
d293 1
a293 1
    RWCString siteCustomization = setOfParameters.getString("siteCustomization");
d330 4
a333 4
  RWCString theFssSetName;
  RWCString partReadFromlastTime;
  RWCString fssSetNameReadFromLastTime;    
  LgFrOrderedVectorRWCString focusPartNameList;
d360 1
a360 1
    if (focusPartNameList.isEmpty())
d366 1
a366 1
	cout << "   fssMachineAnalysis: " << theFssSetName;    
d368 1
a368 1
	cout << "   fssGeneralSetAnalysis: " << theFssSetName;
d370 1
a370 1
	cout << "   fssSingletonAnalysis: " << theFssSetName;      
d381 1
a381 1
	  cout << "  (Fully committed within FSS" << fssType << " horizon)" << endl;
d413 1
a413 1
      cout << endl;
d450 1
a450 1
	if (FSSCov[ii] != NULL)                    
d452 1
a452 1
	if (FSSReq[ii] != NULL)                    
d462 1
a462 1
  //  cout << "Inserting FSSSingleCheme SUCCESSFULLY!" << endl;
d481 1
a481 1
	if (forwardRollableStockVols[i] != NULL)
d521 1
a521 1
      RWCString FSSMachReportFileName =
d545 2
a546 2
    RWCString & fssMethod,
    LgFrOrderedVectorRWCString & focusPartNameList,
d548 1
a548 1
    RWCString & fssFeatureMethod,
d574 1
a574 1
  assert(zeroVec != NULL);
d581 1
a581 1
  assert(FSSCov != NULL);
d585 1
a585 1
  assert(FSSReq != NULL);
d588 2
a589 2
    FSSReq[i] = NULL;
    FSSCov[i] = NULL;
d613 1
a613 1
      RWCString sub(partList[i]);
d625 1
a625 1
  for (k=0; k<focusPartNameList.entries(); k++) {
d631 1
a631 1
    witGetPartDemands(originalWitRun, focusPartNameList[k], &fpNDemands, &fpDlist);
d633 3
a635 2
    for (int j=0; j<fpNDemands; j++) {
      RWCString focusDemandName = fpDlist[j];
d637 2
a638 2
      witGetDemandShipVol(originalWitRun, focusPartNameList[k], focusDemandName, &focusShipVol);
      witSetDemandDemandVol(localWitRun, focusPartNameList[k], focusDemandName, focusShipVol);
d644 1
a644 1
                                      focusPartNameList[k].data(), focusDemandName, focusShipVol);
d646 1
a646 1
                                      focusPartNameList[k].data(), focusDemandName.data(), focusShipVol);
d664 1
a664 1
  RWCString partDBFile = "output.partDB.FSSCovBlue";
d668 1
a668 1
  RWCString debugDBFile = "output.debugDB.FSSCovBlue";
d682 3
a684 2
    if (FSSCov[i] != NULL) {
      for (int t=0; t<nPeriods; t++)
d700 1
a700 1
        if (forwardRollableStockVols[i] != NULL) {
d739 1
a739 1
    for (k=0; k<focusPartNameList.entries(); k++) {
d745 1
a745 1
      witGetPartDemands(originalWitRun, focusPartNameList[k], &fpNDemands, &fpDlist);
d747 3
a749 2
      for (int j=0; j<fpNDemands; j++) {
        RWCString focusDemandName = fpDlist[j];
d752 2
a753 2
                                              focusPartNameList[k].data(),
                                              focusDemandName.data(), zeroVec);
d757 1
a757 1
          witGetDemandDemandVol(originalWitRun, focusPartNameList[k], focusDemandName, &focusDemandVol);
d759 2
a760 2
                                        focusPartNameList[k].data(),
                                        focusDemandName.data(), focusDemandVol);
d774 1
a774 1
  for (k=0; k<focusPartNameList.entries(); k++) {
d780 2
a781 2
    RWCString focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName, &fpNDemands, &fpDlist);
d783 3
a785 2
    for (int j=0; j<fpNDemands; j++) {
      RWCString focusDemandName = fpDlist[j];
d787 2
a788 2
      witGetDemandDemandVol(originalWitRun, focusPartName, focusDemandName, &focusDemandVol);      
      witSetDemandDemandVol(localWitRun, focusPartName, focusDemandName, focusDemandVol);
d792 2
a793 2
                                            focusPartNameList[k].data(),
                                            focusDemandName, zeroVec);
d810 1
a810 1
  for (k=0; k<focusPartNameList.entries(); k++) {
d816 2
a817 2
    RWCString focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName, &fpNDemands, &fpDlist);
d819 4
a822 3
    for (int j=0; j<fpNDemands; j++) {
      RWCString focusDemandName = fpDlist[j];
      witSetDemandDemandVol(localWitRun, focusPartName, focusDemandName, zeroVec);
d831 1
a831 1
  RWCString partDBFile2 = "output.partDB.FSSReqBlue";
d835 1
a835 1
  RWCString debugDBFile2 = "output.debugDB.FSSReqBlue";
d850 1
a850 1
                                              LgFrOrderedVectorRWCString & focusPartNameList,
d857 2
a858 1
  for (int k=0; k<focusPartNameList.entries(); k++) {
d864 1
a864 1
    witGetPartDemands(theWitRun, focusPartNameList[k], &fpNDemands, &fpDlist);
d866 3
a868 2
    for (int j=0; j<fpNDemands; j++) {
      RWCString focusDemandName = fpDlist[j];
d871 4
a874 3
      witGetDemandShipVol(theWitRun, focusPartNameList[k], focusDemandName, &focusShipVol);
      witGetDemandDemandVol(theWitRun, focusPartNameList[k], focusDemandName, &focusDemandVol);
      for (int t=0; t<=fssHorizon; t++) {
d953 1
a953 1
LgFrSceFssMgr::getNextFssSet(LgFrOrderedVectorRWCString & focusPartNameList,
d955 6
a960 6
                             RWCString & theFssSetName,
                             RWCString & fssSetNameReadFromLastTime,
			     RWCString & partReadFromlastTime,
                             RWCString & FSSFile,
                             ifstream & fssInFile,
                             ofstream & scrubOutFile,
d967 1
a967 1
  RWCString dataLine;
d969 5
a973 5
  RWCString plannerPart;
  RWCString geo;
  RWCString pp;
  RWCString g;
  RWCString setId;
d985 1
a985 1
  if (! fssSetNameReadFromLastTime.isNull()) {
d987 1
a987 1
    focusPartNameList.insert(partReadFromlastTime);
d998 1
a998 1
    dataLine.readToDelim(fssInFile);
d1004 2
a1005 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.isNull()) || (dataLine.index("*") == 0)) {
d1009 1
a1009 1
    RWCTokenizer next(dataLine);
d1017 1
a1017 1
    setId.prepend("\"");
d1028 1
a1028 1
    RWCString fullWitPart = mpHelper_->geoPlannerDemandPartName(plannerPart, geo);
d1048 1
a1048 1
    witGetPartDemands(theWitRun, fullWitPart, &fpNDemands, &fpDlist);
d1051 2
a1052 1
    for (int j=0; j<fpNDemands; j++) {
d1071 1
a1071 1
    if (theFssSetName.isNull()) {
d1079 1
a1079 1
      focusPartNameList.insert(fullWitPart);
d1094 1
a1094 1
      scrubOutFile << dataLine << endl;
d1112 1
a1112 1
LgFrSceFssMgr::getNextSingletonFssSet(LgFrOrderedVectorRWCString & focusPartNameList,
d1115 1
a1115 1
                                      RWCString & theFssSetName,
d1119 2
a1120 2
  RWCString plannerPart;
  RWCString geo;
d1130 1
a1130 1
    RWCString fullWitPart(partList[singletonPartIndex]);
d1140 1
a1140 1
      witGetPartDemands(theWitRun, fullWitPart, &fpNDemands, &fpDlist);
d1142 1
a1142 1
        focusPartNameList.insert(fullWitPart);
d1144 2
a1145 1
        for (int j=0; j<fpNDemands; j++) {
d1152 2
a1153 1
        for (int j=0; j<fpNDemands; j++) {
d1166 4
a1169 4
  :   theWitRun_ (NULL),
      theCal_(NULL),
      mpHelper_(NULL),
      scenScePtr_(NULL)
d1239 1
a1239 1
    assert(forwardRollableStockVols != NULL);
d1242 2
a1243 2
      forwardRollableStockVols[i] = NULL;
      RWBoolean vectorNonNull = FALSE;
d1253 2
a1254 1
        for (int t=0; t<nPeriods; t++) {
d1258 1
a1258 1
            vectorNonNull = TRUE;
d1292 1
a1292 1
    assert(originalSupplyVols != NULL);
d1307 1
a1307 1
	    originalSupplyVols[i] = NULL;
d1343 1
a1343 1
    assert(demandList != NULL);
d1347 1
a1347 1
    assert(nDemands != NULL);
d1350 1
a1350 1
	demandList[i] = NULL;
d1389 1
a1389 1
    assert(demandVols != NULL);
d1391 1
a1391 1
	demandVols[i] = NULL;
d1398 1
a1398 1
	    assert(dvolList != NULL);
d1436 1
a1436 1
    assert(shipVols != NULL);
d1438 1
a1438 1
	shipVols[i] = NULL;
d1445 1
a1445 1
	    assert(svolList != NULL);
d1464 1
a1464 1
                                   RWCString & setID,
d1467 1
a1467 1
                                   ofstream & fssOutFile)   // output stream (already opened)        
d1490 1
a1490 1
    RWCString thePart(partList[i]);
d1496 1
a1496 1
    if (FSSReq[i] != NULL)
d1501 1
a1501 1
    if (FSSCov[i] != NULL)
a1558 1
  fssOutFile << flush;
d1568 1
a1568 1
                                    RWCString & setID,
d1571 1
a1571 1
                                    ofstream & fssOutFile)   // output stream (already opened)        
d1595 1
a1595 1
    RWCString thePart(partList[i]);
d1601 1
a1601 1
    if (FSSReq[i] == NULL && FSSCov[i] == NULL)
d1604 1
a1604 1
    if (FSSReq[i] != NULL)
d1609 1
a1609 1
    if (FSSCov[i] != NULL)
d1679 2
a1680 2
  RWCString plannerPart;
  RWCString geo;
d1688 1
a1688 1
  RWCString plannerTopLevelPart(focusPart);
d1693 3
a1695 2
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart, &nBom);
  for (int k=0; k<nBom; k++)  {
d1697 1
a1697 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, &fullWitFeaturePartName);
d1707 1
a1707 1
    witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart, k, &ratio);
d1709 2
a1710 2
    witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart, k, &early);
    witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart, k, &late);
d1713 2
a1714 1
    for (int t=early; t<=late; t++)
d1734 2
a1735 2
  RWCString plannerPart;
  RWCString geo;
d1743 1
a1743 1
  RWCString plannerTopLevelPart(focusPart);
d1748 3
a1750 2
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart, &nBom);
  for (int k=0; k<nBom; k++)  {
d1752 1
a1752 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, &fullWitFeaturePartName);
d1762 1
a1762 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart, k, &nSubBom);
d1766 1
a1766 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, 0, &sub);
d1772 1
a1772 1
        RWCString featureDemandName =
d1775 1
a1775 1
        RWCString pp, g;
d1783 1
a1783 1
                              featureDemandName, &featureDemandVol);
d1785 1
a1785 1
                            featureDemandName, &featureShipVol);
d1788 1
a1788 1
        witGetSubsBomEntryProdVol(originalWitRun, plannerTopLevelPart, k, 0, &subProdVol);        
d1791 1
a1791 1
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart, k, &ratio);
d1793 2
a1794 2
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart, k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart, k, &late);
d1796 2
a1797 1
        for (int t=early; t<=late; t++)
d1801 1
a1801 1
                              featureDemandName, featureDemandVol);
d1823 2
a1824 2
  RWCString plannerPart;
  RWCString geo;
d1832 1
a1832 1
  RWCString plannerTopLevelPart(focusPart);
d1837 3
a1839 2
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart, &nBom);
  for (int k=0; k<nBom; k++)  {
d1841 1
a1841 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, &fullWitFeaturePartName);
d1852 1
a1852 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart, k, &nSubBom);
d1857 1
a1857 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, 0, &sub);
d1863 1
a1863 1
        RWCString featureDemandName =
d1866 1
a1866 1
        RWCString pp, g;
d1872 1
a1872 1
                              featureDemandName, zeroVec);
d1894 2
a1895 2
  RWCString plannerPart;
  RWCString geo;
d1903 1
a1903 1
  RWCString d1, d2, d3;  
d1905 1
a1905 1
  RWCString plannerTopLevelPart(focusPart);
d1910 3
a1912 2
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart, &nBom);
  for (int k=0; k<nBom; k++)  {
d1914 1
a1914 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, &fullWitFeaturePartName);
d1925 1
a1925 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart, k, &nSubBom);
d1929 1
a1929 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, 0, &sub);
d1937 1
a1937 1
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart, k, &ratio);
d1939 2
a1940 2
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart, k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart, k, &late);
d1944 2
a1945 1
          for (int t=early; t<=late; t++)
d1953 2
a1954 1
          for (int t=early; t<=late; t++)
d1976 2
a1977 2
  RWCString plannerPart;
  RWCString geo;
d1985 1
a1985 1
  RWCString d1, d2, d3;  
d1987 1
a1987 1
  RWCString plannerTopLevelPart(focusPart);
d1992 3
a1994 2
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart, &nBom);
  for (int k=0; k<nBom; k++)  {
d1996 1
a1996 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart, k, &fullWitFeaturePartName);
d2017 1
a2017 1
                                       RWCString & setID,
d2048 1
a2048 1
    RWCString thePart(partList[i]);
d2054 1
a2054 1
    if (FSSReq[i] != NULL)
d2059 1
a2059 1
    if (FSSCov[i] != NULL)
d2092 2
a2093 2
        RWCString plannerPart(setID(1, idx-2));
        RWCString geo(setID(idx+2, setID.length()-(idx+3)));
d2095 2
a2096 2
                    << plannerPart.data()
                    << geo.data()
@


1.3.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d7 1
d117 2
a118 2
  std::string fssGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssGeneralSetMethod");
  std::string fssFeatureGeneralSetMethod = scenScePtr_->setOfParameters().getString("fssFeatureGeneralSetMethod");
d120 2
a121 2
  std::string fssGeneralSetFileName = scenScePtr_->setOfParameters().getString("fssGeneralSetFileName");
  std::string fssGeneralSetFile  = scenScePtr_->setOfParameters().getString("fssGeneralSetFile");
d123 1
a123 1
  std::string type("generalSet");
d135 2
a136 2
  std::string fssSingletonMethod = scenScePtr_->setOfParameters().getString("fssSingletonMethod");
  std::string fssFeatureSingletonMethod = scenScePtr_->setOfParameters().getString("fssFeatureSingletonMethod");
d138 2
a139 2
  std::string fssSingletonFileName = scenScePtr_->setOfParameters().getString("fssSingletonFileName");
  std::string fssSingletonFile;
d141 1
a141 1
  std::string type("singleton");
d153 2
a154 2
  std::string fssMachineMethod = scenScePtr_->setOfParameters().getString("fssMachineMethod");
  std::string fssFeatureMachineMethod = scenScePtr_->setOfParameters().getString("fssFeatureMachineMethod");
d156 2
a157 2
  std::string fssMachineFileName = scenScePtr_->setOfParameters().getString("fssMachineFileName");
  std::string fssMachineFile  = scenScePtr_->setOfParameters().getString("fssMachineFile");
d159 1
a159 1
  std::string type("machine");
d174 3
a176 3
LgFrSceFssMgr::runFss(std::string & fssType,
                      std::string & fssMethod,
		      std::string & fssFeatureMethod,
d178 2
a179 2
		      std::string & fssOutputFileName,
		      std::string & fssInputSetFileName)
d219 1
a219 1
  float **  forwardRollableStockVols = 0;  
d222 2
a223 2
  std::ifstream fssInFile;
  std::ofstream scrubOutFile;
d226 1
a226 1
    fssInFile.open(fssInputSetFileName.c_str());
d232 1
a232 1
      std::string fileErrorString("Cannot open FSS " + fssType + "Input File: ");
d241 2
a242 2
      std::string scrubFileName = myScrubber->scrubDir() + fssInputSetFileName;
      scrubOutFile.open(scrubFileName.c_str(), std::ofstream::out);
d253 3
a255 3
  std::ofstream fssOutFile;
  std::ofstream fssModifiedOutFile;
  std::ofstream * fssModifiedOutFilePtr;
d257 1
a257 1
    bool printModifiedFssMachReport = setOfParameters.getBool("printModifiedFssMachReport");
d264 1
a264 1
    fssOutFile.open(fssOutputFileName.c_str(), std::ofstream::out);
d266 1
a266 1
      std::string fileErrorString("FSS " + fssType + "Report");
d276 2
a277 2
      std::string FSSMachReportFileName = setOfParameters.getString("FSSModifiedMachReportFileName");  
      fssModifiedOutFile.open(FSSMachReportFileName.c_str(), std::ofstream::out);
d288 1
a288 1
    std::string siteCustomization = setOfParameters.getString("siteCustomization");
d325 4
a328 4
  std::string theFssSetName;
  std::string partReadFromlastTime;
  std::string fssSetNameReadFromLastTime;    
  LgFrStringVector focusPartNameList;
d355 1
a355 1
    if (focusPartNameList.empty())
d445 1
a445 1
	if (FSSCov[ii] != 0)                    
d447 1
a447 1
	if (FSSReq[ii] != 0)                    
d476 1
a476 1
	if (forwardRollableStockVols[i] != 0)
d516 1
a516 1
      std::string FSSMachReportFileName =
d540 2
a541 2
    std::string & fssMethod,
    LgFrStringVector & focusPartNameList,
d543 1
a543 1
    std::string & fssFeatureMethod,
d569 1
a569 1
  assert(zeroVec != 0);
d576 1
a576 1
  assert(FSSCov != 0);
d580 1
a580 1
  assert(FSSReq != 0);
d583 2
a584 2
    FSSReq[i] = 0;
    FSSCov[i] = 0;
d608 1
a608 1
      std::string sub(partList[i]);
d620 1
a620 1
  for (k=0; k<focusPartNameList.size(); k++) {
d626 1
a626 1
    witGetPartDemands(originalWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
d628 2
a629 3
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
d631 2
a632 2
      witGetDemandShipVol(originalWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusShipVol);
      witSetDemandDemandVol(localWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);
d638 1
a638 1
                                      focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);
d640 1
a640 1
                                      focusPartNameList[k].c_str(), focusDemandName.c_str(), focusShipVol);
d658 1
a658 1
  std::string partDBFile = "output.partDB.FSSCovBlue";
d662 1
a662 1
  std::string debugDBFile = "output.debugDB.FSSCovBlue";
d676 2
a677 3
    if (FSSCov[i] != 0) {
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)
d693 1
a693 1
        if (forwardRollableStockVols[i] != 0) {
d732 1
a732 1
    for (k=0; k<focusPartNameList.size(); k++) {
d738 1
a738 1
      witGetPartDemands(originalWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
d740 2
a741 3
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<fpNDemands; j++) {
        std::string focusDemandName = fpDlist[j];
d744 2
a745 2
                                              focusPartNameList[k].c_str(),
                                              focusDemandName.c_str(), zeroVec);
d749 1
a749 1
          witGetDemandDemandVol(originalWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusDemandVol);
d751 2
a752 2
                                        focusPartNameList[k].c_str(),
                                        focusDemandName.c_str(), focusDemandVol);
d766 1
a766 1
  for (k=0; k<focusPartNameList.size(); k++) {
d772 2
a773 2
    std::string focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName.c_str(), &fpNDemands, &fpDlist);
d775 2
a776 3
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
d778 2
a779 2
      witGetDemandDemandVol(originalWitRun, focusPartName.c_str(), focusDemandName.c_str(), &focusDemandVol);      
      witSetDemandDemandVol(localWitRun, focusPartName.c_str(), focusDemandName.c_str(), focusDemandVol);
d783 2
a784 2
                                            focusPartNameList[k].c_str(),
                                            focusDemandName.c_str(), zeroVec);
d801 1
a801 1
  for (k=0; k<focusPartNameList.size(); k++) {
d807 2
a808 2
    std::string focusPartName = focusPartNameList[k];    
    witGetPartDemands(originalWitRun, focusPartName.c_str(), &fpNDemands, &fpDlist);
d810 3
a812 4
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
      witSetDemandDemandVol(localWitRun, focusPartName.c_str(), focusDemandName.c_str(), zeroVec);
d821 1
a821 1
  std::string partDBFile2 = "output.partDB.FSSReqBlue";
d825 1
a825 1
  std::string debugDBFile2 = "output.debugDB.FSSReqBlue";
d840 1
a840 1
                                              LgFrStringVector & focusPartNameList,
d847 1
a847 2
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<focusPartNameList.size(); k++) {
d853 1
a853 1
    witGetPartDemands(theWitRun, focusPartNameList[k].c_str(), &fpNDemands, &fpDlist);
d855 2
a856 3
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
      std::string focusDemandName = fpDlist[j];
d859 3
a861 4
      witGetDemandShipVol(theWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusShipVol);
      witGetDemandDemandVol(theWitRun, focusPartNameList[k].c_str(), focusDemandName.c_str(), &focusDemandVol);
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<=fssHorizon; t++) {
d940 1
a940 1
LgFrSceFssMgr::getNextFssSet(LgFrStringVector & focusPartNameList,
d942 6
a947 6
                             std::string & theFssSetName,
                             std::string & fssSetNameReadFromLastTime,
			     std::string & partReadFromlastTime,
                             std::string & FSSFile,
                             std::ifstream & fssInFile,
                             std::ofstream & scrubOutFile,
d954 1
a954 1
  std::string dataLine;
d956 5
a960 5
  std::string plannerPart;
  std::string geo;
  std::string pp;
  std::string g;
  std::string setId;
d972 1
a972 1
  if (! fssSetNameReadFromLastTime.empty()) {
d974 1
a974 1
    focusPartNameList.push_back(partReadFromlastTime);
d985 1
a985 1
    std::getline( fssInFile, dataLine );
d991 2
a992 2
    dataLine = sce::strip( dataLine );
    if ((dataLine.empty()) || (dataLine[0] == '*')) {
d996 1
a996 1
    SCETokenizer next(dataLine);
d1004 1
a1004 1
    setId.insert(0, "\"");
d1015 1
a1015 1
    std::string fullWitPart = mpHelper_->geoPlannerDemandPartName(plannerPart, geo);
d1035 1
a1035 1
    witGetPartDemands(theWitRun, fullWitPart.c_str(), &fpNDemands, &fpDlist);
d1038 1
a1038 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<fpNDemands; j++) {
d1057 1
a1057 1
    if (theFssSetName.empty()) {
d1065 1
a1065 1
      focusPartNameList.push_back(fullWitPart);
d1098 1
a1098 1
LgFrSceFssMgr::getNextSingletonFssSet(LgFrStringVector & focusPartNameList,
d1101 1
a1101 1
                                      std::string & theFssSetName,
d1105 2
a1106 2
  std::string plannerPart;
  std::string geo;
d1116 1
a1116 1
    std::string fullWitPart(partList[singletonPartIndex]);
d1126 1
a1126 1
      witGetPartDemands(theWitRun, fullWitPart.c_str(), &fpNDemands, &fpDlist);
d1128 1
a1128 1
        focusPartNameList.push_back(fullWitPart);
d1130 1
a1130 2
        int j = 0; // Pulled out of the for below by RW2STL
        for (j=0; j<fpNDemands; j++) {
d1137 1
a1137 2
        int j = 0; // Pulled out of the for below by RW2STL
        for (j=0; j<fpNDemands; j++) {
d1150 4
a1153 4
  :   theWitRun_ (0),
      theCal_(0),
      mpHelper_(0),
      scenScePtr_(0)
d1223 1
a1223 1
    assert(forwardRollableStockVols != 0);
d1226 2
a1227 2
      forwardRollableStockVols[i] = 0;
      bool vectorNonNull = false;
d1237 1
a1237 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<nPeriods; t++) {
d1241 1
a1241 1
            vectorNonNull = true;
d1275 1
a1275 1
    assert(originalSupplyVols != 0);
d1290 1
a1290 1
	    originalSupplyVols[i] = 0;
d1326 1
a1326 1
    assert(demandList != 0);
d1330 1
a1330 1
    assert(nDemands != 0);
d1333 1
a1333 1
	demandList[i] = 0;
d1372 1
a1372 1
    assert(demandVols != 0);
d1374 1
a1374 1
	demandVols[i] = 0;
d1381 1
a1381 1
	    assert(dvolList != 0);
d1419 1
a1419 1
    assert(shipVols != 0);
d1421 1
a1421 1
	shipVols[i] = 0;
d1428 1
a1428 1
	    assert(svolList != 0);
d1447 1
a1447 1
                                   std::string & setID,
d1450 1
a1450 1
                                   std::ofstream & fssOutFile)   // output stream (already opened)        
d1473 1
a1473 1
    std::string thePart(partList[i]);
d1479 1
a1479 1
    if (FSSReq[i] != 0)
d1484 1
a1484 1
    if (FSSCov[i] != 0)
d1542 1
d1552 1
a1552 1
                                    std::string & setID,
d1555 1
a1555 1
                                    std::ofstream & fssOutFile)   // output stream (already opened)        
d1579 1
a1579 1
    std::string thePart(partList[i]);
d1585 1
a1585 1
    if (FSSReq[i] == 0 && FSSCov[i] == 0)
d1588 1
a1588 1
    if (FSSReq[i] != 0)
d1593 1
a1593 1
    if (FSSCov[i] != 0)
d1663 2
a1664 2
  std::string plannerPart;
  std::string geo;
d1672 1
a1672 1
  std::string plannerTopLevelPart(focusPart);
d1677 2
a1678 3
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
d1680 1
a1680 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);
d1690 1
a1690 1
    witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
d1692 2
a1693 2
    witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
    witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
d1696 1
a1696 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=early; t<=late; t++)
d1716 2
a1717 2
  std::string plannerPart;
  std::string geo;
d1725 1
a1725 1
  std::string plannerTopLevelPart(focusPart);
d1730 2
a1731 3
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
d1733 1
a1733 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);
d1743 1
a1743 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
d1747 1
a1747 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
d1753 1
a1753 1
        std::string featureDemandName =
d1756 1
a1756 1
        std::string pp, g;
d1764 1
a1764 1
                              featureDemandName.c_str(), &featureDemandVol);
d1766 1
a1766 1
                            featureDemandName.c_str(), &featureShipVol);
d1769 1
a1769 1
        witGetSubsBomEntryProdVol(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &subProdVol);        
d1772 1
a1772 1
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
d1774 2
a1775 2
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
d1777 1
a1777 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=early; t<=late; t++)
d1781 1
a1781 1
                              featureDemandName.c_str(), featureDemandVol);
d1803 2
a1804 2
  std::string plannerPart;
  std::string geo;
d1812 1
a1812 1
  std::string plannerTopLevelPart(focusPart);
d1817 2
a1818 3
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
d1820 1
a1820 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);
d1831 1
a1831 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
d1836 1
a1836 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
d1842 1
a1842 1
        std::string featureDemandName =
d1845 1
a1845 1
        std::string pp, g;
d1851 1
a1851 1
                              featureDemandName.c_str(), zeroVec);
d1873 2
a1874 2
  std::string plannerPart;
  std::string geo;
d1882 1
a1882 1
  std::string d1, d2, d3;  
d1884 1
a1884 1
  std::string plannerTopLevelPart(focusPart);
d1889 2
a1890 3
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
d1892 1
a1892 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);
d1903 1
a1903 1
    witGetBomEntryNSubsBomEntries(originalWitRun, plannerTopLevelPart.c_str(), k, &nSubBom);
d1907 1
a1907 1
      witGetSubsBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, 0, &sub);
d1915 1
a1915 1
        witGetBomEntryUsageRate(originalWitRun, plannerTopLevelPart.c_str(), k, &ratio);
d1917 2
a1918 2
        witGetBomEntryEarliestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &early);
        witGetBomEntryLatestPeriod(originalWitRun, plannerTopLevelPart.c_str(), k, &late);
d1922 1
a1922 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++)
d1930 1
a1930 2
          int t = 0; // Pulled out of the for below by RW2STL
          for (t=early; t<=late; t++)
d1952 2
a1953 2
  std::string plannerPart;
  std::string geo;
d1961 1
a1961 1
  std::string d1, d2, d3;  
d1963 1
a1963 1
  std::string plannerTopLevelPart(focusPart);
d1968 2
a1969 3
  witGetPartNBomEntries(originalWitRun, plannerTopLevelPart.c_str(), &nBom);
  int k = 0; // Pulled out of the for below by RW2STL
  for (k=0; k<nBom; k++)  {
d1971 1
a1971 1
    witGetBomEntryConsumedPart(originalWitRun, plannerTopLevelPart.c_str(), k, &fullWitFeaturePartName);
d1992 1
a1992 1
                                       std::string & setID,
d2023 1
a2023 1
    std::string thePart(partList[i]);
d2029 1
a2029 1
    if (FSSReq[i] != 0)
d2034 1
a2034 1
    if (FSSCov[i] != 0)
d2067 2
a2068 2
        std::string plannerPart(setID(1, idx-2));
        std::string geo(setID(idx+2, setID.length()-(idx+3)));
d2070 2
a2071 2
                    << plannerPart.c_str()
                    << geo.c_str()
@


1.3.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d366 1
a366 1
	std::cout << "   fssMachineAnalysis: " << theFssSetName;    
d368 1
a368 1
	std::cout << "   fssGeneralSetAnalysis: " << theFssSetName;
d370 1
a370 1
	std::cout << "   fssSingletonAnalysis: " << theFssSetName;      
d381 1
a381 1
	  std::cout << "  (Fully committed within FSS" << fssType << " horizon)" << std::endl;
d413 1
a413 1
      std::cout << std::endl;
d462 1
a462 1
  //  std::cout << "Inserting FSSSingleCheme SUCCESSFULLY!" << std::endl;
d1094 1
a1094 1
      scrubOutFile << dataLine << std::endl;
@


1.2
log
@3.11 commit
@
text
@d6 1
@


1.1
log
@Initial revision
@
text
@d378 1
a378 1
	  (*theErrFacil)("fssHorizon",MclArgList() 
d1019 1
a1019 1
      (*theErrFacil)("invalidPartFSS",MclArgList() 
d1044 1
a1044 1
      (*theErrFacil)("noDemandFSS",MclArgList() 
@


1.1.1.1
log
@Import sce
@
text
@@

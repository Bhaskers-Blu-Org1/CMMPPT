head	1.20;
access;
symbols
	sce_5_01_20080919:1.13
	latest_sce_4_20_20060523:1.9.0.4
	sce_4_20_20060523:1.9
	latest_sce4_20_OSL:1.9.0.2
	sce_4_20_OSL:1.9
	sce_4_20_20051222:1.9
	sce_4_10_30050426:1.7
	sce_4_05_20040511:1.7
	sce_4_00_20040201:1.7
	nextGenBranch:1.5.0.2
	nextGenRoot:1.5
	sce_3_30_20030627:1.5
	EndRw-branch:1.4.0.6
	Root-of-EndRw:1.4
	EndWitRw-branch:1.4.0.4
	Root-of-EndWitRw:1.4
	RwToStl-branch:1.4.0.2
	Root-of-RwToStl:1.4
	latest_sce_3_10_20010924:1.3.0.4
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.2
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2011.03.15.15.37.51;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;
permissions	644;
commitid	256c4d7f865a0a65;
kopt	kv;
filename	@mPlantH.h@;

1.19
date	2010.04.07.16.18.27;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;

1.18
date	2010.03.16.17.56.22;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;

1.17
date	2010.03.13.18.53.05;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2010.02.04.15.58.23;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2009.12.08.13.58.35;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2009.09.09.15.41.57;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2008.04.24.14.25.50;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2008.04.24.14.04.42;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2008.03.20.14.52.48;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2006.06.26.15.23.31;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2005.11.09.18.32.47;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2005.08.10.22.44.53;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2004.01.29.05.08.05;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2004.01.23.02.59.16;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2003.01.15.19.36.56;	author rwToStl;	state Exp;
branches;
next	1.4;
deltatype	text;

1.4
date	2002.08.08.17.37.44;	author ervolina;	state Exp;
branches
	1.4.6.1;
next	1.3;
deltatype	text;

1.3
date	2001.06.01.16.52.06;	author ervolina;	state Exp;
branches;
next	1.2;
deltatype	text;

1.2
date	2001.03.12.15.07.29;	author ervolina;	state Exp;
branches;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.52;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.52;	author wit;	state Exp;
branches
	1.1.1.1.4.1;
next	;
deltatype	text;

1.1.1.1.4.1
date	2001.03.12.16.36.18;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.4.6.1
date	2003.01.08.17.43.16;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.20
log
@temp fix to build without Variable_periods
@
text
@// file: sceHelper.h
// author: tom

#ifndef  LGFRMULTIPLANTHELPER_H
#define  LGFRMULTIPLANTHELPER_H

// RW2STL - inserted:
#include <string>
// End of RW2STL - inserted includes.

#include <scenario/src/part.h>
#include <scenario/src/timeVecs.h>
#include <mcl/src/mcl.h>



// forward References
class WitRun;
#if 1 
// #ifdef VARIABLE_PERIODS
class LgFrCalendar;
#endif

//  SCE partname parser class
class LgFrMultiPlantHelper {

public:


  // ----  APP DATA HELPER FUNCTIONS --------------
  // these functions make it a bit more convenient to get info
  // about a part that is normally stored in part app data
// Return 1 if a part is marked as a PCF part, 0 if not
int
isPartPcf(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

#ifdef MARK_BOGONS
// Return 1 if a part is a PCF bogon
int
isPartBogon(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);
#endif

// returns convenient way to get the nAltPart Ops 
int
nAlternatePartOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

// returns convenient way to get the nInterplant Ops 
int
nInterplantOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);




// returns convenient way to get the nUserDefinedOps
int
nUserDefinedOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

  // returns convenient way to get the nAggregationOps
int
nAggregationOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

#ifdef ENABLE_NEGATIVE_DEMANDS
// Return 1 if part has any negative demands
int
doesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

// Set the Part's doesPartHaveNegativeDemands
void
setDoesPartHaveNegativeDemands(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    int doesPartHaveNegativeDemands);

LgFrTimeVecFloat
negDemVol(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

#endif

// plannerPartName/Geo ---> mfgPart/Pdf  source 
// THIS IS A BETTER ONE. !!!!!!
// feed it a part (without a PDF prepended) and a geo (ie, a demand name)
// and it returns a PDF_Part
// You also feed it a start period, and it figures the latest period for 
// which this pdf is sourced for this demand.  It also finds the time-offset
// for this pdf source.
std::string
demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
          float     & offset,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic);

  // VARIABLE_PERIODS
std::string
demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const int         start,
          int       & late,
    LgFrTimeVecFloat     & offsetTV,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic);

  // SCE 6.1
  // feed it a GPD planner part and geo (with D2o), and it returns the topMfgPart of the machine, and 
  //    populates the sourceLocPdf reference
std::string
mfgTopPartForGpd(WitRun * const      theWitRun, 
		 const std::string & plannerPartName,
		 const std::string & d2oGeo,
		       std::string & sourceLocPdf);
  
  // SCE 6.1
  // returns SourceLoc from geo (with D2O)
std::string
sourceLoc(const std::string &  d2oGeo)
  const;



  // SCE 6.1: this one returns geoPreD2O + requestDate
std::string
expandDemandKeyforD2O(const std::string &  geoPreD2O, const std::string & requestDate)
  const;

  // SCE 6.1: this one returns sourceLoc + geoPreD2O + requestDate
std::string
expandDemandKeyforD2O(const std::string &  geoPreD2O, 
		      const std::string & requestDate,
		      const std::string & sourceLoc)
		      
  const;


// multi_attribute_demand
std::string
compressedDemandName(
		     const std::string * demandAttributes[])
const;



// returns a String Suitable for printing as leadingString
// returns 0 if unsuccessful, 1 if successful 
int
populateLeadingString(
	      const std::string & partname,
	      const std::string & pdf,
	      const std::string & compressedDemandName,
	      std::string & leadingString);
  

// returns a String Suitable for printing as leadingString for TINP Demand records
// returns 0 if unsuccessful, 1 if successful 
int
populateLeadingStringGPD(const std::string & partname,
			 const std::string & geo,
			 std::string & leadingString);



// returns a String Suitable for printing as leadingString for INDP Demand Records
// note that it does not expect part and pdf to be in the compressed name
// returns 0 if unsuccessful, 1 if successful 
// Note: if "useDemand2OrderINDP"=TRUE then we add the requestDate from the demandKey
//        else it is the responsibility of the calling function to append the right request (and commit) date
int
populateLeadingStringINDP(const std::string & partname,
			  const std::string & pdf,
			  const std::string & demandName,
			  std::string & leadingString);
  



// multi_attribute_demand
void
compressedDemandName(std::string & demandName, 
		     const std::string & customerLoc,
		     const std::string & demandClass,
		     const std::string & demandLevel,
		     const std::string & partClass);

int
uncompressedDemandNames(
	const std::string & compressedDemandName,
	std::string & customerLoc,
	std::string & demandClass,
	std::string & demandLevel,
	std::string & partClass);


// multi_attribute_demand
void
compressedDemandNameWitPdf(std::string & demandName, 
			   const std::string & sourceLoc,
			   const std::string & customerLoc,
			   const std::string & demandClass,
			   const std::string & demandLevel,
			   const std::string & partClass);
  
  
  
  
int
uncompressedDemandNamesWithPdf(const std::string & compressedDemandName,
			       std::string & sourceLoc,
			       std::string & customerLoc,
			       std::string & demandClass,
			       std::string & demandLevel,
			       std::string & partClass);
  
  

// Return a PDF_partname, given the partname, pdf
std::string
pdfPartname(
	    const std::string & mfgPartName,
	    const std::string & pdf)
const;

// Return a PDF_operationNname, given the operationName, pdf
std::string
pdfOperationName(
    const std::string & operationName,
    const std::string & pdf)
const;
  
// Return a demand_Geo name, given the demand, geo
std::string
geoPlannerDemandPartName(
    const std::string & plannerPart,
    const std::string & geo)
const;


  // Return a demand_Geo_SpecialUB part name, given the demand, geo
std::string
geoPlannerDemandUbPartName(
    const std::string & plannerPart,
    const std::string & geo)
const;


// Return a aggregation operation name, given the realPart, realPartPdf
// aggPart, and aggPdf
std::string
aggregationOperationName(
    const std::string & realPart,
    const std::string & realPartPdf,
    const std::string & aggPart,
    const std::string & aggPdf)
const;
  
// Return a interplant operation name, given the parent, parentPdf, 
// child, childPdf
std::string
interPlantOperationName(
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
const;

// Return an alternate part  name, given the primePart, primePdf, altPart, altPdf 
std::string
alternatePartOperationName(
    const std::string & primePart,
    const std::string & primePdf,
    const std::string & altPart,
    const std::string & altPdf)
const;



  // Return an operation namefor the purpose of a modelling trick in Smart Exploder
std::string
operationForCapacityGeneration(
    const std::string & theFullCapacityName)
const;
  

  // Return a phantom part name, given the part and pdf
std::string
phantomPartName(
    const std::string & thePart,
    const std::string & pdf)
const;

// Return a global nullSubstitute  part name, given  pdf
std::string
globalNullSubstitute(
    const std::string & pdf)
const;



#ifdef ALTERNATE_AS_SUB
// Return a Global Alt Dummy part name
std::string
globalAltDummyPartName(
		       const std::string & primePdf)
  const;

// Returns 1 if part is a special Global Alt Dummy, 0 otherwise
// If returns 1, also sets the pdf
int
isPartSpecialGlobalAltDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf);
#endif











// Return a globalMaxWithoutNullSubstitute part name, given a pdf.
//
// When the maxWithoutRatio = 0.0 (so we have a "mandatory feature")
// the substitute on the gpd part to feature part arc is a global
// maxWithoutNullSubstitute, whose supply is zero. The reason for 
// employing a "global" instead a distinct null sub in this case
// is to reduce the problem size (many parts in the ECA run have
// the maxWithoutRatio equal to a vector of all zeros).

std::string
globalMaxWithoutNullSubstitute(
    const std::string & pdf)
const;  
  
  // This is the maxWithoutNullSubstitute to use when you want a unique nullSub
  // for the unique pair (geo_plannerPart_"specialGeoPlannerDemand", pdf_featurePart)
  //
  // Because the pdf of the featurePart is function of the pdf sourcing of the plannerPart
  // (and we can get it if we need it), the pdf is not encode in the maxWithoutNullSubstitute
  // part name.
  //
  // Return a  nullSubstitute  part name, given  geo, planner part and feature.
  // NOTE: this should be used for features with MaxWithout < featratio
std::string
maxWithoutNullSubstitute(
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
const;



// Return a unique standalone Feature Part Name
std::string
standaloneFeaturePartName(
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
const;

  
// Return a unique bbCategory part name
std::string
bbCategoryPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const;


// Return a unique  part name for LT Feature Set Capacity Part
std::string
LTbbCapacityPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const;


// Return a unique  part name for GT Feature Set Capacity Part
std::string
GTbbCapacityPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
const;


// Return a unique part name for an Option Dummy part
std::string
optionDummyPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
const;


// Return a unique part name for an Option Ratio Supply part
std::string
optionRatioSupplyPartName(
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
const;




// Return a unique standalone Feature Part Name
std::string
custChoiceFeaturePartName(
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
const;

// Returns 1 if part is a special Cust Choice Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
isPartSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);


// Returns 1 if operation is a special Customer Choice Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
isOperationSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);

// Returns 1 if operation is EITHER:
//     special Standalone Feature, 
//  OR  special Customer Choice Feature,
// 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
isOperationSpecialFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);



// Returns 1 if part is a special Standalone Feature, 0 otherwise
// (overloaded function.  this one just checks ...
int
isPartSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

// Returns 1 if part is EITHER:
//     special Standalone Feature, 
//  OR  special Customer Choice Feature,
// 0 otherwise
// (overloaded function.  this one just checks ...
int
isPartSpecialFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);


// Return 1 if good, 0 if bad
int
isPartValid(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName, 
    const std::string & filename, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;


// Return 1 if good, 0 if bad
int
isPartValid(
    WitRun * const theWitRun, 
    const std::string & partname, 
    const std::string & pdf, 
    const std::string & filename, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;



// Return 1 if a part is Buildable (ie, should be in the Build Schedule)
int
isPartBuildable(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

  
// Return 1 if a normal (no special characters) part, 0 if not
int
isPartNormal(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
const;

// Return 1 if a "normal" (no special characters) operation, 0 otherwise.
// If method returns 1, the method also sets the pdf and operation

// "Normal" here means that either (1) the operation was defined
//  explicitedly by the user via the Operation Definition File or
// (2) SCE generated the operation from a part that was explicitedly
// defined by the user via the Part Definition File. 
int
isOperationNormal(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName )
const;

//
// Return 1 if the operation is "User Defined", 0 ow.
// If method returns 1, the method also sets the pdf and operation
int
isOperationUserDefined(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
const;

  
// Return 1 if a normal (no special characters) capacity, 0 if not
int
isPartNormalCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname)
const;

  
// Returns 1 if part is a specialGeoPlannerDemand part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
isPartSpecialGeoPlannerDemandPart(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo);

// Returns 1 if part is a specialGeoPlannerDemand part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
isOperationSpecialGeoPlannerDemand(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & plannerPart,
    std::string & geo);

  

// Returns 1 if part is a specialGeoPlannerDemandUB part, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
isPartSpecialGeoPlannerDemandUbPart(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo);
  


// Returns 1 if operation is a special interplant operation, 0 otherwise
// If returns 1, also sets the destination and source part and pdf
int
isOperationSpecialInterplant(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf);

// Returns 1 if operation is a special alternate operation, 0 otherwise
// If returns 1, also sets the primePart, primePdf, altPart, and altPdf
int
isOperationSpecialAlternate(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & primePart,
    std::string & primePdf,
    std::string & altPart,
    std::string & altPdf);



// Returns 1 if operation is a special aggregation operation, 0 otherwise
// If returns 1, also sets the realPart and aggPart and pdf's
int
isOperationSpecialAggregation(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & realPart,
    std::string & realPartPdf,
    std::string & aggPart,
    std::string & aggPdf);


  // Return 1 if the operation is SmartExpldoer Capacity creator
int
isOperationForCapacityGeneration(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & theCapacity,
    std::string & pdf);
  
  

  // Returns 1 if part is a special nullSubstitiute, 0 otherwise
  // Use this when all you need to know if the part is a global or
  // max without null substitute.
  //
  // This will return true for both types of nullSubstitute parts.  
int
isPartSpecialNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

    
// Returns 1 if part is a special Global nullSubstitiute, 0 otherwise
// If returns 1, also sets the pdf
int
isPartSpecialGlobalNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf);
  
// Returns 1 if part is a special GlobalMaxWithoutNullSubstitiute,
//         0 otherwise
// If returns 1, also sets the pdf
int
isPartSpecialGlobalMaxWithoutNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & pdf);
  
// Returns 1 if part is a special MaxWithout nullSubstitiute, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, and featurePart
int
isPartSpecialMaxWithoutNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart);

// Returns 1 if part is a special CustChoiceNullSubstitiute,
//         0 otherwise
// If returns 1, also sets the pdf
int
isPartSpecialCustChoiceNullSubstitute(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart);



// Returns 1 if part is a special Standalone Feature, 0 otherwise
// If returns 1, also sets the pdf, and featurePart
int
isPartSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);

// Returns 1 if operation is a special Standalone Feature, 0 otherwise
// If returns 1, also sets the geo, the plannerPart, pdf, and featurePart
int
isOperationSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
  

// Returns 1 if part is a special Standalone Feature, 0 otherwise
// (overloaded function.  this one just checks ...
int
isPartSpecialStandaloneFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);




  
  
// Returns 1 if part is a special phantom part, 0 otherwise
int
isPartSpecialPhantom(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

// Returns 1 if part is a special BB category Set  part, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, and bbCategory
int
isPartSpecialBbCategory(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);



// Returns 1 if part is a special feature Set LT capacity part, 0 otherwise
// If returns 1, also sets the part and pdf
int
isPartSpecialLTbbCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);

// Returns 1 if part is a special feature Set LT capacity part, 0 otherwise
// If returns 1, also sets the part and pdf
int
isPartSpecialGTbbCapacity(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);

// Returns 1 if part is a special Option dummy, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
isPartSpecialOptionDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart);
// Returns 1 if part is a special Option dummy, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
isOperationSpecialOptionDummy(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart);


// Returns 1 if part is a special Option Ratio Supply, 0 otherwise
// If returns 1, also sets the plannerTopLevelBuild, geo, bbCategory,
// and mfgOption part.
int
isPartSpecialOptionRatioSupply(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart);

// returns 1 if operation is valid, 0 otherwise 
int
isOperationValid(
    WitRun * const theWitRun, 
    const std::string & operationName,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;

// returns 1 if operation is valid, 0 otherwise 
int
isOperationValid(
    WitRun * const theWitRun, 
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;

  // returns 1 if pdf-operation is unique
  // from pdf-parts in WIT model, 0 otherwise
int
isPdfOperationUnique(
    WitRun * const theWitRun, 
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;
 

// Return a geo_plannerPart_specialPureOptionBuildDemandName, given the
// fullWitName of a specialGeoPlannerDemand part
std::string
pureOptionBuildDemandName(
    const std::string & fullWitPartName);

// Returns 1 if demand is a specialPureOptionBuildDemand, 0 otherwise
// If returns 1, also sets the plannerPart and geo
int
isDemandSpecialPureOptionBuildDemand(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo);

std::string
custChoiceFeatureDemandName(
    const std::string & fullWitPartName);

int
isDemandSpecialCustChoiceFeature(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo);


std::string
custChoiceNullSubstitute(
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
const;

// Return the witPartIndex as currently set in app data.
// returns -1 if the part is bad, or, index is not set
int
witPartIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);

// Return the witOperationIndex
// returns -1 if the operation is bad, or, index is not set
  // NOTE: currently only set for special CC feature parts
int
witOperationIndex(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName);


// Creates a LgFrScePartAppData for every part in the witRun (unless one already exists)
// And set the index to be synchronized with witGetParts.

void
setAllWitPartIndices(
    WitRun * const theWitRun);

// set the Customer Choice Operation AppData indices to synch with a witGetOperation()
// It sets them only for Special Customer Choice feature parts
void
setCCOperationIndices(
    WitRun * const theWitRun);


#if 1 
  // #ifdef VARIABLE_PERIODS
// set the CycleTimeDays exactly as input from Cycle Time File
void
setCycleTimeDays(
		 WitRun * const theWitRun,
		 const std::string & fullWitPartname,
		 LgFrTimeVecFloat &  cycleTimeDays);

// get the CycleTimeDays (exactly as input from Cycle Time File)
LgFrTimeVecFloat
getCycleTimeDays(
		 WitRun * const theWitRun,
		 const std::string & fullWitPartname);
void
setCycleTime(
	     WitRun * const theWitRun,
	     const std::string & fullWitPartname,
	     LgFrTimeVecFloat &  cycleTime);

// get the CycleTimeDays (exactly as input from Cycle Time File)
LgFrTimeVecFloat
getCycleTime(
	     WitRun * const theWitRun,
	     const std::string & fullWitPartname);

float
calculateVariableOffset(
			float remainingCycleTimeDaysToAllocate, 
			int t, 
			LgFrTimeVecFloat & workingDays,
			int nPeriods);
float
calculateVariableOffset(float remainingCycleTimeDaysToAllocate, 
			int t, 
			const LgFrCalendar & theCal,
			int nPeriods);
#endif



  // returns the feature ratio of a customer choice feature.
  // Note that the partname MUST be a specialCustChoicePartName
LgFrTimeVecFloat 
custChoiceFeatureRatio(
    WitRun * const theWitRun, 
    const std::string & specialCustChoicePartName);

// GET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
LgFrTimeVecFloat 
custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun, 
    const std::string & specialCustChoicePartName);


// SET 
// this helper goes into wit and finds the right appdata 
// for the Dummysupply Adjustment to be used in MRP
void 
custChoiceDummySupplyVolForMrpAdjustment(
    WitRun * const theWitRun,
    const std::string & specialCustChoicePartName,
    LgFrTimeVecFloat & dummySupplyVolForMrpAdjustment);



// set/get's for private data
  std::string  pdfSeparator() const;
  void         pdfSeparator(const std::string & pdfSeparator);
  std::string  defaultPdf() const;
  void         defaultPdf(const std::string & defaultPdf);
  bool         useMultiAttributeDemand() const;
  void         useMultiAttributeDemand(const bool useMultiAttributeDemand);
  int          numDemandAttributes() const;
  void         numDemandAttributes(const int numDemandAttributes);
  std::string  multiAttributeDemandSeparator() const;
  void         multiAttributeDemandSeparator(const std::string & multiAttributeDemandSeparator);
  bool         useDemand2OrderINDP() const;
  void         useDemand2OrderINDP(const bool useDemand2OrderINDP);
  bool         truncOffsetToEol() const;
  void         truncOffsetToEol(const bool truncOffsetToEol);



// Get the  PDF for a PDF_PART
std::string 
pdf(const LgFrPart & part)
const;


std::string 
pdf(const std::string & pdfPart)
const;


std::string 
pdf(const char * pdfPart)
const;


  // return just the partname of a pdf_part

std::string 
partname(const std::string & pdfPart)
const;

  // return just the operationName of a pdf_operationName

std::string 
operationName(const std::string & pdfOperation)
const;
  
// Are the parts equivalent, irrespective of the PDF?

bool
isPartnameEqual(const std::string & left, const std::string & right)
const;

// Returns 1 if operation is a special interplant operation and
//              sets the full pdf-part name for the source part
// Otherwise, returns 0
int
interplantSourcePdfPartName(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName);


// returns 1 if the fullWitPartName is produced by more than one interplant operations
//         0 otherwise
int
isPartMultiInterplantSourced(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName,
    int npBops);



// 
// returns 1 if the "duplicate" interplant record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the interplant bom)
//         0 otherwise
int
isDuplicateInterplantRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & sourcePdfPartName,
    const std::string & interplantOperationName,
    float duplicateRecordUsageRate );

//
// returns 1 if the duplicate interplant record's effectivity
//              dates do not overlap with the effectivity
//              dates of interplant operation's existing bops
//         0 otherwise
int
isDuplicateInterplantRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & interplantOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd );


// 
// returns 1 if the "duplicate" interplant record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the interplant bom)
//         0 otherwise
int
isDuplicateAlternatePartRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & fullPrimePartName,
    const std::string & alternatePartOperationName,
    float duplicateRecordUsageRate );

//
// returns 1 if the duplicate interplant record's effectivity
//              dates do not overlap with the effectivity
//              dates of interplant operation's existing bops
//         0 otherwise
int
isDuplicateAlternatePartRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & alternatePartOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd );





// necessarey for error facility sharing with scenario
void
setErrFacility(MclFacility * existingFacility);

MclFacility *
getErrFacility();

  
// default constructor
LgFrMultiPlantHelper();

// general constructor
LgFrMultiPlantHelper(
    const std::string & pdfSeparator,
    const std::string & defaultPdf,
    const bool useMultiAttributeDemand,
    const int numDemandAttributes,
    const std::string & multiAttributeDemandSeparator,
    const bool useDemand2OrderINDP);

// Return a copy in the heap
LgFrMultiPlantHelper*
clone()
const;


// copy constructor
LgFrMultiPlantHelper(const LgFrMultiPlantHelper& source);

// assignment operator
LgFrMultiPlantHelper&
operator=(const LgFrMultiPlantHelper& rhs);

// destructor
virtual
~LgFrMultiPlantHelper();

     
// self-test
static void test();

private:
  std::string pdfSeparator_;
  std::string defaultPdf_;
  bool useMultiAttributeDemand_;
  int numDemandAttributes_;
  std::string multiAttributeDemandSeparator_;
  bool useDemand2OrderINDP_;
  bool truncOffsetToEol_;
  MclFacility * sceErrFacility_;
};
#endif
@


1.19
log
@mfo is folded into featratio file
@
text
@d19 2
a20 1
#ifdef VARIABLE_PERIODS
d920 2
a921 1
#ifdef VARIABLE_PERIODS
@


1.18
log
@pegging and sub enablement for 6.1
@
text
@d128 17
@


1.17
log
@6.1 prep commit ... many things in here
@
text
@a93 14
// Demand -> Part source 
// feed it a part (without a PDF prepended) and a geo (ie, a demand name)
// and it returns a PDF_Part
std::string
demandSource(
    WitRun * const theWitRun, 
    const std::string & plannerPartName,
    const std::string & geo,
    const std::string & fileName, 
    const std::string & dataLine, 
    const long lineNo, 
    const int messageLogic)
const;

@


1.16
log
@committing latest development of sce 6.1
@
text
@d142 13
d164 33
a204 3



d226 9
a234 9
  int
  uncompressedDemandNamesWithPdf(const std::string & compressedDemandName,
				 std::string & sourceLoc,
				 std::string & customerLoc,
				 std::string & demandClass,
				 std::string & demandLevel,
				 std::string & partClass);


d994 2
d1125 2
a1126 1
    const std::string & multiAttributeDemandSeparator);
d1155 1
@


1.15
log
@more fixes for 6.1
@
text
@d951 2
d1109 1
@


1.14
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@d19 3
a21 1

d904 5
@


1.13
log
@added new sources
@
text
@d126 13
d871 35
@


1.12
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@d138 5
a142 5
LgFrMultiPlantHelper::compressedDemandName(std::string & demandName, 
					   const std::string & customerLoc,
					   const std::string & demandClass,
					   const std::string & demandLevel,
					   const std::string & partClass);
d158 6
a163 6
LgFrMultiPlantHelper::compressedDemandNameWitPdf(std::string & demandName, 
						 const std::string & sourceLoc,
						 const std::string & customerLoc,
						 const std::string & demandClass,
						 const std::string & demandLevel,
						 const std::string & partClass);
@


1.11
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d134 13
d156 20
@


1.10
log
@Preliminary commit for SCE 5.00
@
text
@d128 17
d148 2
a149 2
    const std::string & mfgPartName,
    const std::string & pdf)
d852 11
a862 15
// set/get the pdf-partname delimiter string
std::string
pdfSeparator()
const;

void
pdfSeparator(const std::string & pdfSeparator);

// set/get the default PDF string
std::string
defaultPdf()
const;

void
defaultPdf(const std::string & defaultPdf);
d987 4
a990 1
    const std::string & defaultPdf);
d1014 6
a1019 6

    std::string pdfSeparator_;
    std::string defaultPdf_;

    // necessary for error messaging by multiPlantHelper
    MclFacility * sceErrFacility_;
@


1.9
log
@removed the "binning" stuff which is now obsolete
@
text
@d209 28
d511 1
a511 1
// Returns 1 if operation is a special alternate part operation, 0 otherwise
d514 1
a514 1
isOperationSpecialAlternatePart(
@


1.8
log
@4.20 commit: global subs, prioritized explode
@
text
@a58 8
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// returns convenient way to get the nBin Ops 
int
nBinOps(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname);
#endif

a188 13
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// Return a bin operation name, given the parent, parentPdf, 
// child, childPdf
std::string
binOperationName(
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
const;
#endif

  
a494 13
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// Returns 1 if operation is a special bin operation, 0 otherwise
// If returns 1, also sets the destination and source part and pdf
int
isOperationSpecialBin(
    WitRun * const theWitRun, 
    const std::string & fullWitPartname,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf);
#endif

a868 12
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// Returns 1 if operation is a special bin operation and
//              sets the full pdf-part name for the source part
// Otherwise, returns 0
int
binSourcePdfPartName(
    WitRun * const theWitRun, 
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName);
#endif


a877 10
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// returns 1 if the fullWitPartName is produced by more than one bin operations
//         0 otherwise
int
isPartMultiBinSourced(
    WitRun * const theWitRun, 
    const std::string & fullWitPartName,
    int npBops);
#endif

a929 24
#ifdef BINNING_OPERATION_TEMP_SOLUTION
// returns 1 if the "duplicate" bin record's usage rate is the same
//              as the usage rate on the previous record (ie. the current
//              usage rate on the bin bom)
//         0 otherwise
int
isDuplicateBinRecordUsageRateValid(
    WitRun * const theWitRun, 
    const std::string & sourcePdfPartName,
    const std::string & binOperationName,
    float duplicateRecordUsageRate );

//
// returns 1 if the duplicate bin record's effectivity
//              dates do not overlap with the effectivity
//              dates of bin operation's existing bops
//         0 otherwise
int
isDuplicateBinRecordEffectivityDatesValid(
    WitRun * const theWitRun, 
    const std::string & binOperationName,
    int duplicateRecordStart,
    int duplicateRecordEnd );
#endif
@


1.7
log
@mand/opt capacity, new selective sets
@
text
@d44 5
a48 2


d56 3
d186 10
d504 11
d960 26
@


1.6
log
@First cut at Selective Features using proportional routing
@
text
@d196 1
a196 1
operationForSmartExploderCapacity(
d517 1
a517 1
isOperationSpecialSmartExploderCapacity(
@


1.5
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d660 11
@


1.4
log
@bogon output, and minor changes
@
text
@d7 4
a12 1
#include <rw/cstring.h>
d34 1
a34 1
    const RWCString & fullWitPartname);
d41 1
a41 1
    const RWCString & fullWitPartname);
d51 1
a51 1
    const RWCString & fullWitPartname);
d58 1
a58 1
    const RWCString & fullWitPartname);
d65 1
a65 1
    const RWCString & fullWitPartname);
d71 1
a71 1
    const RWCString & fullWitPartname);
d78 1
a78 1
    const RWCString & fullWitPartname);
d84 1
a84 1
    const RWCString & fullWitPartname,
d90 1
a90 1
    const RWCString & fullWitPartname);
d97 1
a97 1
RWCString
d100 4
a103 4
    const RWCString & plannerPartName,
    const RWCString & geo,
    const RWCString & fileName, 
    const RWCString & dataLine, 
d115 1
a115 1
RWCString
d118 2
a119 2
    const RWCString & plannerPartName,
    const RWCString & geo,
d123 2
a124 2
    const RWCString & fileName, 
    const RWCString & dataLine, 
d131 1
a131 1
RWCString
d133 2
a134 2
    const RWCString & mfgPartName,
    const RWCString & pdf)
d138 1
a138 1
RWCString
d140 2
a141 2
    const RWCString & operationName,
    const RWCString & pdf)
d145 1
a145 1
RWCString
d147 2
a148 2
    const RWCString & plannerPart,
    const RWCString & geo)
d153 1
a153 1
RWCString
d155 2
a156 2
    const RWCString & plannerPart,
    const RWCString & geo)
d162 1
a162 1
RWCString
d164 4
a167 4
    const RWCString & realPart,
    const RWCString & realPartPdf,
    const RWCString & aggPart,
    const RWCString & aggPdf)
d172 1
a172 1
RWCString
d174 4
a177 4
    const RWCString & parentMfgPart,
    const RWCString & parentPdf,
    const RWCString & childMfgPart,
    const RWCString & childPdf)
d184 1
a184 1
RWCString
d186 4
a189 4
    const RWCString & parentMfgPart,
    const RWCString & parentPdf,
    const RWCString & childMfgPart,
    const RWCString & childPdf)
d195 1
a195 1
RWCString
d197 1
a197 1
    const RWCString & theFullCapacityName)
d202 1
a202 1
RWCString
d204 2
a205 2
    const RWCString & thePart,
    const RWCString & pdf)
d209 1
a209 1
RWCString
d211 1
a211 1
    const RWCString & pdf)
d223 1
a223 1
RWCString
d225 1
a225 1
    const RWCString & pdf)
d237 1
a237 1
RWCString
d239 3
a241 3
    const RWCString & geo,
    const RWCString & plannerPart,
    const RWCString & featurePart)
d247 1
a247 1
RWCString
d249 4
a252 4
    const RWCString & machine,
    const RWCString & geo,
    const RWCString & featurePart,
    const RWCString & pdf)
d257 1
a257 1
RWCString
d259 3
a261 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d266 1
a266 1
RWCString
d268 3
a270 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d275 1
a275 1
RWCString
d277 3
a279 3
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory)
d284 1
a284 1
RWCString
d286 4
a289 4
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory,
    const RWCString & option)
d294 1
a294 1
RWCString
d296 4
a299 4
    const RWCString & plannerTopLevelBuild,
    const RWCString & geo,
    const RWCString & bbCategory,
    const RWCString & option)
d306 1
a306 1
RWCString
d308 4
a311 4
    const RWCString & machine,
    const RWCString & geo,
    const RWCString & featurePart,
    const RWCString & pdf)
d319 5
a323 5
    const RWCString & fullWitPartname,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart);
d331 5
a335 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart);
d345 5
a349 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart);
d358 1
a358 1
    const RWCString & fullWitPartname);
d368 1
a368 1
    const RWCString & fullWitPartname);
d375 3
a377 3
    const RWCString & fullWitPartName, 
    const RWCString & filename, 
    const RWCString & dataLine, 
d387 4
a390 4
    const RWCString & partname, 
    const RWCString & pdf, 
    const RWCString & filename, 
    const RWCString & dataLine, 
d401 1
a401 1
    const RWCString & fullWitPartname);
d408 1
a408 1
    const RWCString & fullWitPartname)
d421 3
a423 3
    const RWCString & fullWitOperationName,
    RWCString & thePdf,
    RWCString & theOperationName )
d432 3
a434 3
    const RWCString & fullWitOperationName,
    RWCString & thePdf,
    RWCString & theOperationName)
d442 1
a442 1
    const RWCString & fullWitPartname)
d451 3
a453 3
    const RWCString & fullWitPartname,
    RWCString & plannerPart,
    RWCString & geo);
d460 3
a462 3
    const RWCString & fullWitOperationName,
    RWCString & plannerPart,
    RWCString & geo);
d471 3
a473 3
    const RWCString & fullWitPartname,
    RWCString & plannerPart,
    RWCString & geo);
d482 5
a486 5
    const RWCString & fullWitPartname,
    RWCString & destination,
    RWCString & destinationPdf,
    RWCString & source,
    RWCString & sourcePdf);
d495 5
a499 5
    const RWCString & fullWitPartname,
    RWCString & destination,
    RWCString & destinationPdf,
    RWCString & source,
    RWCString & sourcePdf);
d508 5
a512 5
    const RWCString & fullWitOperationName,
    RWCString & realPart,
    RWCString & realPartPdf,
    RWCString & aggPart,
    RWCString & aggPdf);
d519 3
a521 3
    const RWCString & fullWitOperationName,
    RWCString & theCapacity,
    RWCString & pdf);
d529 1
a529 1
  // This will return TRUE for both types of nullSubstitute parts.  
d533 1
a533 1
    const RWCString & fullWitPartname);
d541 2
a542 2
    const RWCString & fullWitPartname,
    RWCString & pdf);
d550 2
a551 2
    const RWCString & fullWitPartname,
    RWCString & pdf);
d558 4
a561 4
    const RWCString & fullWitPartname,
    RWCString & geo,
    RWCString & plannerPart,
    RWCString & featurePart);
d569 4
a572 4
    const RWCString & fullWitPartname,
    RWCString & geo,
    RWCString & plannerPart,
    RWCString & featurePart);
d581 5
a585 5
    const RWCString & fullWitPartname,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart);
d592 5
a596 5
    const RWCString & fullWitOperation,
    RWCString & geo,    
    RWCString & machine,    
    RWCString & pdf,    
    RWCString & featurePart);
d604 1
a604 1
    const RWCString & fullWitPartname);
d615 1
a615 1
    const RWCString & fullWitPartname);
d622 4
a625 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory);
d634 4
a637 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory);
d644 4
a647 4
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory);
d655 5
a659 5
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory,
    RWCString & mfgOptionPart);
d668 5
a672 5
    const RWCString & fullWitPartname,
    RWCString & plannerTopLevelBuild,
    RWCString & geo,
    RWCString & bbCategory,
    RWCString & mfgOptionPart);
d678 4
a681 4
    const RWCString & operationName,
    const RWCString & pdf,
    const RWCString & filename, 
    const RWCString & dataLine, 
d690 3
a692 3
    const RWCString & pdfOperationName, 
    const RWCString & fileName, 
    const RWCString & dataLine, 
d702 3
a704 3
    const RWCString & pdfOperationName, 
    const RWCString & fileName, 
    const RWCString & dataLine, 
d712 1
a712 1
RWCString
d714 1
a714 1
    const RWCString & fullWitPartName);
d721 4
a724 4
    const RWCString & fullWitPartname,
    const RWCString & fullWitDemandName,
    RWCString & plannerPart,
    RWCString & geo);
d726 1
a726 1
RWCString
d728 1
a728 1
    const RWCString & fullWitPartName);
d733 4
a736 4
    const RWCString & fullWitPartName,
    const RWCString & fullWitDemandName,
    RWCString & plannerPart,
    RWCString & geo);
d739 1
a739 1
RWCString
d741 3
a743 3
    const RWCString & geo,
    const RWCString & plannerPart,
    const RWCString & featurePart)
d751 1
a751 1
    const RWCString & fullWitPartname);
d759 1
a759 1
    const RWCString & fullWitOperationName);
d781 1
a781 1
    const RWCString & specialCustChoicePartName);
d789 1
a789 1
    const RWCString & specialCustChoicePartName);
d798 1
a798 1
    const RWCString & specialCustChoicePartName,
d804 1
a804 1
RWCString
d809 1
a809 1
pdfSeparator(const RWCString & pdfSeparator);
d812 1
a812 1
RWCString
d817 1
a817 1
defaultPdf(const RWCString & defaultPdf);
d822 1
a822 1
RWCString 
d827 2
a828 2
RWCString 
pdf(const RWCString & pdfPart)
d832 1
a832 1
RWCString 
d839 2
a840 2
RWCString 
partname(const RWCString & pdfPart)
d845 2
a846 2
RWCString 
operationName(const RWCString & pdfOperation)
d851 2
a852 2
RWBoolean
isPartnameEqual(const RWCString & left, const RWCString & right)
d861 2
a862 2
    const RWCString & fullWitOperationName,
    RWCString & sourcePdfPartName);
d872 2
a873 2
    const RWCString & fullWitOperationName,
    RWCString & sourcePdfPartName);
d882 1
a882 1
    const RWCString & fullWitPartName,
d892 1
a892 1
    const RWCString & fullWitPartName,
d905 2
a906 2
    const RWCString & sourcePdfPartName,
    const RWCString & interplantOperationName,
d917 1
a917 1
    const RWCString & interplantOperationName,
d930 2
a931 2
    const RWCString & sourcePdfPartName,
    const RWCString & binOperationName,
d942 1
a942 1
    const RWCString & binOperationName,
d961 2
a962 2
    const RWCString & pdfSeparator,
    const RWCString & defaultPdf);
d987 2
a988 2
    RWCString pdfSeparator_;
    RWCString defaultPdf_;
@


1.4.6.1
log
@Roguewave is gone
@
text
@a6 4
// RW2STL - inserted:
#include <string>
// End of RW2STL - inserted includes.

d9 1
d31 1
a31 1
    const std::string & fullWitPartname);
d38 1
a38 1
    const std::string & fullWitPartname);
d48 1
a48 1
    const std::string & fullWitPartname);
d55 1
a55 1
    const std::string & fullWitPartname);
d62 1
a62 1
    const std::string & fullWitPartname);
d68 1
a68 1
    const std::string & fullWitPartname);
d75 1
a75 1
    const std::string & fullWitPartname);
d81 1
a81 1
    const std::string & fullWitPartname,
d87 1
a87 1
    const std::string & fullWitPartname);
d94 1
a94 1
std::string
d97 4
a100 4
    const std::string & plannerPartName,
    const std::string & geo,
    const std::string & fileName, 
    const std::string & dataLine, 
d112 1
a112 1
std::string
d115 2
a116 2
    const std::string & plannerPartName,
    const std::string & geo,
d120 2
a121 2
    const std::string & fileName, 
    const std::string & dataLine, 
d128 1
a128 1
std::string
d130 2
a131 2
    const std::string & mfgPartName,
    const std::string & pdf)
d135 1
a135 1
std::string
d137 2
a138 2
    const std::string & operationName,
    const std::string & pdf)
d142 1
a142 1
std::string
d144 2
a145 2
    const std::string & plannerPart,
    const std::string & geo)
d150 1
a150 1
std::string
d152 2
a153 2
    const std::string & plannerPart,
    const std::string & geo)
d159 1
a159 1
std::string
d161 4
a164 4
    const std::string & realPart,
    const std::string & realPartPdf,
    const std::string & aggPart,
    const std::string & aggPdf)
d169 1
a169 1
std::string
d171 4
a174 4
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
d181 1
a181 1
std::string
d183 4
a186 4
    const std::string & parentMfgPart,
    const std::string & parentPdf,
    const std::string & childMfgPart,
    const std::string & childPdf)
d192 1
a192 1
std::string
d194 1
a194 1
    const std::string & theFullCapacityName)
d199 1
a199 1
std::string
d201 2
a202 2
    const std::string & thePart,
    const std::string & pdf)
d206 1
a206 1
std::string
d208 1
a208 1
    const std::string & pdf)
d220 1
a220 1
std::string
d222 1
a222 1
    const std::string & pdf)
d234 1
a234 1
std::string
d236 3
a238 3
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
d244 1
a244 1
std::string
d246 4
a249 4
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
d254 1
a254 1
std::string
d256 3
a258 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d263 1
a263 1
std::string
d265 3
a267 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d272 1
a272 1
std::string
d274 3
a276 3
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory)
d281 1
a281 1
std::string
d283 4
a286 4
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
d291 1
a291 1
std::string
d293 4
a296 4
    const std::string & plannerTopLevelBuild,
    const std::string & geo,
    const std::string & bbCategory,
    const std::string & option)
d303 1
a303 1
std::string
d305 4
a308 4
    const std::string & machine,
    const std::string & geo,
    const std::string & featurePart,
    const std::string & pdf)
d316 5
a320 5
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
d328 5
a332 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
d342 5
a346 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
d355 1
a355 1
    const std::string & fullWitPartname);
d365 1
a365 1
    const std::string & fullWitPartname);
d372 3
a374 3
    const std::string & fullWitPartName, 
    const std::string & filename, 
    const std::string & dataLine, 
d384 4
a387 4
    const std::string & partname, 
    const std::string & pdf, 
    const std::string & filename, 
    const std::string & dataLine, 
d398 1
a398 1
    const std::string & fullWitPartname);
d405 1
a405 1
    const std::string & fullWitPartname)
d418 3
a420 3
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName )
d429 3
a431 3
    const std::string & fullWitOperationName,
    std::string & thePdf,
    std::string & theOperationName)
d439 1
a439 1
    const std::string & fullWitPartname)
d448 3
a450 3
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo);
d457 3
a459 3
    const std::string & fullWitOperationName,
    std::string & plannerPart,
    std::string & geo);
d468 3
a470 3
    const std::string & fullWitPartname,
    std::string & plannerPart,
    std::string & geo);
d479 5
a483 5
    const std::string & fullWitPartname,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf);
d492 5
a496 5
    const std::string & fullWitPartname,
    std::string & destination,
    std::string & destinationPdf,
    std::string & source,
    std::string & sourcePdf);
d505 5
a509 5
    const std::string & fullWitOperationName,
    std::string & realPart,
    std::string & realPartPdf,
    std::string & aggPart,
    std::string & aggPdf);
d516 3
a518 3
    const std::string & fullWitOperationName,
    std::string & theCapacity,
    std::string & pdf);
d526 1
a526 1
  // This will return true for both types of nullSubstitute parts.  
d530 1
a530 1
    const std::string & fullWitPartname);
d538 2
a539 2
    const std::string & fullWitPartname,
    std::string & pdf);
d547 2
a548 2
    const std::string & fullWitPartname,
    std::string & pdf);
d555 4
a558 4
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart);
d566 4
a569 4
    const std::string & fullWitPartname,
    std::string & geo,
    std::string & plannerPart,
    std::string & featurePart);
d578 5
a582 5
    const std::string & fullWitPartname,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
d589 5
a593 5
    const std::string & fullWitOperation,
    std::string & geo,    
    std::string & machine,    
    std::string & pdf,    
    std::string & featurePart);
d601 1
a601 1
    const std::string & fullWitPartname);
d612 1
a612 1
    const std::string & fullWitPartname);
d619 4
a622 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);
d631 4
a634 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);
d641 4
a644 4
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory);
d652 5
a656 5
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart);
d665 5
a669 5
    const std::string & fullWitPartname,
    std::string & plannerTopLevelBuild,
    std::string & geo,
    std::string & bbCategory,
    std::string & mfgOptionPart);
d675 4
a678 4
    const std::string & operationName,
    const std::string & pdf,
    const std::string & filename, 
    const std::string & dataLine, 
d687 3
a689 3
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
d699 3
a701 3
    const std::string & pdfOperationName, 
    const std::string & fileName, 
    const std::string & dataLine, 
d709 1
a709 1
std::string
d711 1
a711 1
    const std::string & fullWitPartName);
d718 4
a721 4
    const std::string & fullWitPartname,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo);
d723 1
a723 1
std::string
d725 1
a725 1
    const std::string & fullWitPartName);
d730 4
a733 4
    const std::string & fullWitPartName,
    const std::string & fullWitDemandName,
    std::string & plannerPart,
    std::string & geo);
d736 1
a736 1
std::string
d738 3
a740 3
    const std::string & geo,
    const std::string & plannerPart,
    const std::string & featurePart)
d748 1
a748 1
    const std::string & fullWitPartname);
d756 1
a756 1
    const std::string & fullWitOperationName);
d778 1
a778 1
    const std::string & specialCustChoicePartName);
d786 1
a786 1
    const std::string & specialCustChoicePartName);
d795 1
a795 1
    const std::string & specialCustChoicePartName,
d801 1
a801 1
std::string
d806 1
a806 1
pdfSeparator(const std::string & pdfSeparator);
d809 1
a809 1
std::string
d814 1
a814 1
defaultPdf(const std::string & defaultPdf);
d819 1
a819 1
std::string 
d824 2
a825 2
std::string 
pdf(const std::string & pdfPart)
d829 1
a829 1
std::string 
d836 2
a837 2
std::string 
partname(const std::string & pdfPart)
d842 2
a843 2
std::string 
operationName(const std::string & pdfOperation)
d848 2
a849 2
bool
isPartnameEqual(const std::string & left, const std::string & right)
d858 2
a859 2
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName);
d869 2
a870 2
    const std::string & fullWitOperationName,
    std::string & sourcePdfPartName);
d879 1
a879 1
    const std::string & fullWitPartName,
d889 1
a889 1
    const std::string & fullWitPartName,
d902 2
a903 2
    const std::string & sourcePdfPartName,
    const std::string & interplantOperationName,
d914 1
a914 1
    const std::string & interplantOperationName,
d927 2
a928 2
    const std::string & sourcePdfPartName,
    const std::string & binOperationName,
d939 1
a939 1
    const std::string & binOperationName,
d958 2
a959 2
    const std::string & pdfSeparator,
    const std::string & defaultPdf);
d984 2
a985 2
    std::string pdfSeparator_;
    std::string defaultPdf_;
@


1.3
log
@changes for Release 3.00
@
text
@d33 11
@


1.2
log
@Fixed memory bug in Customer Choice Feature logic
@
text
@a82 1
virtual
a116 1
virtual
a123 1
virtual
a130 1
virtual
a138 1
virtual
a157 1
virtual
a169 1
virtual
a180 1
virtual
a187 1
virtual
a357 1
virtual
a369 1
virtual
a433 1
virtual
a453 1
virtual
a789 1
virtual
a793 1
virtual
a797 1
virtual
a801 1
virtual
a807 1
virtual
d812 1
a812 1
virtual
d817 1
a817 1
virtual
d824 1
a824 1
virtual
d830 1
a830 1
virtual
d836 1
a836 1
virtual
@


1.1
log
@Initial revision
@
text
@d752 9
d767 7
@


1.1.1.1
log
@Import sce
@
text
@@


1.1.1.1.4.1
log
@Customer Choice bug fix and memory leak patch.
@
text
@a751 9
// Return the witOperationIndex
// returns -1 if the operation is bad, or, index is not set
  // NOTE: currently only set for special CC feature parts
int
witOperationIndex(
    WitRun * const theWitRun, 
    const RWCString & fullWitOperationName);


a757 7

// set the Customer Choice Operation AppData indices to synch with a witGetOperation()
// It sets them only for Special Customer Choice feature parts
void
setCCOperationIndices(
    WitRun * const theWitRun);

@


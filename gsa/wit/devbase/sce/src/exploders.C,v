head	1.44;
access;
symbols
	sce_5_01_20080919:1.41
	latest_sce_4_20_20060523:1.31.0.2
	sce_4_20_20060523:1.31
	latest_sce4_20_OSL:1.29.0.2
	sce_4_20_OSL:1.29
	sce_4_20_20051222:1.28
	sce_4_10_30050426:1.20
	sce_4_05_20040511:1.20
	sce_4_00_20040201:1.16
	nextGenBranch:1.12.0.2
	nextGenRoot:1.12
	sce_3_30_20030627:1.12
	EndRw-branch:1.9.0.2
	Root-of-EndRw:1.9
	EndWitRw-branch:1.5.0.4
	Root-of-EndWitRw:1.5
	RwToStl-branch:1.5.0.2
	Root-of-RwToStl:1.5
	latest_sce_3_10_20010924:1.2.0.8
	sce_3_10_20010924:1.2
	latest_sce_3_00_20010601:1.2.0.6
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.2.0.4
	sce_2_31_20010308:1.2
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2010.03.26.19.48.23;	author ervolina;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.08.13.58.34;	author ervolina;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.09.15.41.56;	author ervolina;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.19.20.03.47;	author ervolina;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.23.19.07.11;	author ervolina;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.29.20.03.32;	author ervolina;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.29.19.43.55;	author ervolina;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.10.18.19.07;	author ervolina;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.10.14.09.46;	author ervolina;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.09.16.32.16;	author ervolina;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.13.18.43.57;	author ervolina;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.26.15.23.30;	author ervolina;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.15.17.45.43;	author ervolina;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.23.13.03.56;	author ervolina;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2006.04.17.17.59.37;	author ervolina;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.24.21.16.31;	author ervolina;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.01.16.44.22;	author ervolina;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.11.16.23.33;	author ervolina;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.10.13.27.14;	author ervolina;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.09.18.32.46;	author ervolina;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.03.00.29.02;	author ervolina;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.03.00.25.38;	author ervolina;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.02.18.40.00;	author ervolina;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.10.22.44.52;	author ervolina;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.07.14.09.55;	author ervolina;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.09.14.37.30;	author ervolina;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.06.21.53.47;	author ervolina;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.04.22.50.10;	author ervolina;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.29.05.08.04;	author ervolina;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.23.02.59.15;	author ervolina;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.22.02.47.48;	author ervolina;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.17.56.11;	author ervolina;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.04.19.43.42;	author ervolina;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.31.22.59.13;	author ervolina;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.15.19.36.55;	author rwToStl;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.08.16.56.15;	author ervolina;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.01.08.16.49.05;	author ervolina;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.06.22.12.09;	author ervolina;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.26.14.25.29;	author fasano;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.21.20.10.31;	author ervolina;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.18.16.58.12;	author ervolina;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.17.22.04.42;	author ervolina;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.04.15.48.37;	author ervolina;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.18.36.50;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.18.36.50;	author wit;	state Exp;
branches;
next	;

1.9.2.1
date	2003.01.08.17.43.14;	author rwToStl;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.01.09.13.14.33;	author rwToStl;	state Exp;
branches;
next	;

1.31.2.1
date	2006.06.07.12.34.01;	author ervolina;	state Exp;
branches;
next	;


desc
@@


1.44
log
@more dated fixes
@
text
@
// RW2STL - inserted:
#include <string>
#include <iostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
#include <assert.h>
#include <stdlib.h>
#include <sce/src/exploders.h>
#include <math.h>
#include <mcl/src/mcl.h>
#include <iostream>
//#include <fstream.h>
#include <sce/src/appData.h>
#include <sce/src/mPlantH.h>
#include <sce/src/sceParam.h>
#include <sce/src/bopAData.h>
#include <sce/src/dmApData.h>
#include <sce/src/scePegging.h>
// #include <sce/src/scePIP.h>
#include <sce/src/sceCrtLs.h>
//  #include <sce/src/itHelpr.h>
#include <sce/src/scenSce.h>


// #define FULL_DEBUG
// #define DUMP_WIT_MRP_DATA_FILE
// #define DEBUG_INTERPLANT_PEG



// + ================================================================
// + Exploder Factory -- creates the right decorated exploder
// + based on SetOfParameters.  Global Function
// + ================================================================
// + Rules of Creation: The decorator pattern is a bit tricky to implement.
// + For reference, see the Design Patterns book.  In this implementation,
// + the decorators need to be created in a specific order outline by the
// + graph below.
// +
// + The client gets exactly one Exploder object and uses that one exclusively.
// + Under the covers, he's really getting an exploder decorater object that
// + "has-a" exploder object.  The exploder object that he "has" may possibly
// + be a exploder decorator object itself, which, in turn, "has-a" exploder
// + object of his own.
// +
// + The responsibility of this global function is to create the "chain"
// + of exploder objects and return the "head" of the chain to the client.
// + The creation is based solely on the Sce Set of parameters.  The setOfParameters
// + is analyzed to see what set of decorators is needed.  Then the chain of
// + exploder objects is created in the appropriate order.
// +
// + Advantages:
// +     - This system is very easy to use for the client code.
// +     - Given the complexity of the various explosion schemes, this pattern
// +       is very flexible and there is very little duplication of code.
// +     - The design is extendable to future needs (I hope)
// +
// + Disadvantages:
// +     - The implementation of the exploder objects and how they override,
// +       extend, and restrict each others function is quite tricky.
// +     - Not compile-time type safe.  Errors in the exploder creation
// +       process will not be found until run-time.
// +


  // FINISH_ME: if doImplode=false, then we should use the original witRun

// + ================================================================
// + LgFrSceBaseExploder: Implementation
// + ================================================================
int
LgFrSceBaseExploder::explode()
{
  // must be in initialized state
  assert(state() > 0);


    // Dump the heur version of the wit.data file
#ifdef DUMP_WIT_MRP_DATA_FILE
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;
    std::string mrpWitDataFileName = "mrpWitDataFile";
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
    witWriteData(localWitRun_, mrpWitDataFileName.c_str());
    if (setOfParameters_->getBool("printWitExplodeMsgFile"))
      setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
    else
      setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_OFF);
#endif

  // run the mrp on the localWitRun
  witMrp(this->localWitRun());


  state(2);

  return 0;
}

std::string
LgFrSceBaseExploder::title()
{
  std::string myTitle("base witMrp");
  return myTitle;
}


  // determine if this part is something that you deal with
witBoolean
LgFrSceBaseExploder::exists(const std::string& part)
{
  witBoolean exists;
  witGetPartExists(localWitRun_, part.c_str(), &exists);
  return exists;
}



int
LgFrSceBaseExploder::mrpExcessVol(const std::string& part, float ** mrpExcessVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartMrpExcessVol(localWitRun_, part.c_str(), mrpExcessVolPtr);
  else
    mallocZeroVec(mrpExcessVolPtr);
  return 0;
}


int
LgFrSceBaseExploder::mrpResidualVol(const std::string& part, float ** mrpResidualVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartMrpResidualVol(localWitRun_, part.c_str(), mrpResidualVolPtr);
  else
    mallocZeroVec(mrpResidualVolPtr);
  return 0;
}


int
LgFrSceBaseExploder::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
{
  assert(state() >= 2);
  witBoolean exists;
  witGetOperationExists(localWitRun_, operation.c_str(), &exists);
  if (exists)
    witGetOperationMrpExecVol(localWitRun_, operation.c_str(), mrpExecVolPtr);
  else
    mallocZeroVec(mrpExecVolPtr);
  return 0;
}


#if 0
  // Get the four wit mrp part attributes:
  // Default implementation
int
LgFrSceBaseExploder::mrpProdVol(  const std::string& part, float ** mrpProdVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartMrpProdVol(localWitRun_, part, mrpProdVolPtr);
  else
    mallocZeroVec(mrpProdVolPtr);
  return 0;

}
#endif


int
LgFrSceBaseExploder::reqVol(const std::string& part, float ** reqVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartReqVol(localWitRun_, part.c_str(), reqVolPtr);
  else
    mallocZeroVec(reqVolPtr);
  return 0;
}

int
LgFrSceBaseExploder::mrpConsVol(  const std::string& part, float ** mrpConsVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartMrpConsVol(localWitRun_, part.c_str(), mrpConsVolPtr);
  else
    mallocZeroVec(mrpConsVolPtr);
  return 0;
}


  // subUsage Vol
  // must be overridden
int
LgFrSceBaseExploder::subUsageVol(  const std::string& operation,
                                   const int bomIndex,
                                   const int subBomIndex,
                                   float ** subUsageVolPtr)
{

  mallocZeroVec(subUsageVolPtr);
  return 0;
}


void
LgFrSceBaseExploder::mallocZeroVec(float ** floatVecPtr)
{

  //      witMalloc(strlen(partName)+1,(void**)&pn);


  float * zeroVec;
  witMalloc(nPeriods_ * sizeof(float),(void**)&zeroVec);
  assert(zeroVec != 0);
  int t = 0;
  for (t=0; t<nPeriods_; t++)
    zeroVec[t] = 0.0;
  (*floatVecPtr) = zeroVec;


#if 0
  float * zeroVec = (float *) malloc (nPeriods_ * sizeof(float));
  assert(zeroVec != 0);
  int t = 0;
  for (t=0; t<nPeriods_; t++)
    zeroVec[t] = 0.0;
  (*floatVecPtr) = zeroVec;
#endif
}

  // Print out all the attributes (in "del" format)
void
LgFrSceBaseExploder::print(std::string& filename)
{
}





  // preferred constructor
LgFrSceBaseExploder::LgFrSceBaseExploder(WitRun * originalWitRun,
                                         LgFrMultiPlantHelper * mpHelper,
                                         LgFrSceSetOfParameters * setOfParameters)
  : originalWitRun_ (originalWitRun),
    localWitRun_ (originalWitRun),
    mpHelper_ (mpHelper),
    setOfParameters_ (setOfParameters),
    nPeriods_ (0),
    state_ (0),
    id_ (__LGFRSCEBASEEXPLODER)
{
  // get nPeriods from originalWitRun
  witGetNPeriods(originalWitRun_, &nPeriods_);
  state_ = 1;
}

// constructor to be used by Decorator Base Class
LgFrSceBaseExploder::LgFrSceBaseExploder(WitRun * originalWitRun,
                                         WitRun * localWitRun,
                                         LgFrMultiPlantHelper * mpHelper,
                                         LgFrSceSetOfParameters * setOfParameters)
  : originalWitRun_ (originalWitRun),
    localWitRun_ (localWitRun),
    mpHelper_ (mpHelper),
    setOfParameters_ (setOfParameters),
    nPeriods_ (0),
    state_ (0),
    id_ (__LGFRSCEBASEEXPLODER)
{
  // get nPeriods from originalWitRun
  witGetNPeriods(originalWitRun_, &nPeriods_);
}


  // Return Exploder Identifier
isAReturnType
LgFrSceBaseExploder::isA() const
{
  return id_;
}

WitRun *
LgFrSceBaseExploder::theWitRun()
{
  return originalWitRun_;
}

WitRun *
LgFrSceBaseExploder::localWitRun()
{
  return localWitRun_;
}

LgFrMultiPlantHelper *
LgFrSceBaseExploder::mpHelper()
{
  return mpHelper_;
}

LgFrSceSetOfParameters *
LgFrSceBaseExploder::setOfParameters()
{
  return setOfParameters_;
}

int
LgFrSceBaseExploder::nPeriods()
{
  return nPeriods_;
}

int
LgFrSceBaseExploder::state()
{
  return state_;
}

void
LgFrSceBaseExploder::state(int state)
{
  state_ = state;
}


  // default constructor
LgFrSceBaseExploder::LgFrSceBaseExploder()
  : originalWitRun_ (0),
    localWitRun_ (0),
    mpHelper_ (0),
    setOfParameters_ (0),
    nPeriods_ (0),
    state_ (0),
    id_ (__LGFRSCEBASEEXPLODER)
{
  // nothing to be done
}


  // destructor
LgFrSceBaseExploder::~LgFrSceBaseExploder()
{
  // nothing to be done
}




// ======================================================================
// Implementation ---> class LgFrSceExploder : public LgFrSceBaseExploder
// ======================================================================
  // preferred constructor
LgFrSceExploder::LgFrSceExploder(WitRun * originalWitRun,
                                 LgFrMultiPlantHelper * mpHelper,
                                 LgFrSceSetOfParameters * setOfParameters)
  : LgFrSceBaseExploder(originalWitRun,
                        mpHelper,
                        setOfParameters),
    id_ (__LGFRSCEEXPLODER)
{
  // make a tempwitrun for yourself
  // populate it
  // set your pointers;
  witNewRun(&localWitRun_);


  // Set the wit message file
  std::string outputFilePrefix  = setOfParameters->getString("outputFilePrefix");
  std::string witExplodeMsgFileExtension = setOfParameters->getString("witExplodeMsgFileExtension");

  std::string witExplodeMsgFileName(outputFilePrefix + witExplodeMsgFileExtension);
  // check it for write access
  witSetMesgFileAccessMode( localWitRun_, WitTRUE, "w" );
  witSetMesgFileName( localWitRun_, WitTRUE, witExplodeMsgFileName.c_str());

  if (setOfParameters->getBool("printWitExplodeMsgFile"))
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
  else
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_OFF);

  witCopyData(localWitRun_, originalWitRun);
  // assert(state_ == 0);

  if (! setOfParameters->getBool("usePrioritizedExplodeUtility")) {
    witSetMultiRoute(localWitRun_, WitTRUE);

    // strictly 4.0 mode
    witSetWit34Compatible(localWitRun_, WitFALSE);
  }


  // 4.20 IPIP fix  (temp)
  witSetNewPipPggOrder(localWitRun_, WitTRUE);



  this->copyAppData();

  //
  if (! setOfParameters->getBool("usePrioritizedExplodeUtility")) {
    this->modifyCustChoiceSupplyVols();
  }

  // ok, we're initialized, but not post processed.
  state(1);

}




// + LgFrSceExploder::modifyCustChoiceSupplyVols:
// +      CustomerChoice modelling trick requires an adjustment of the supplyVols
// +      be adjusted for the explosion calculation to work.   This modification
// +      should NOT be done when usePrioritizedExplodeUtility=TRUE
void
LgFrSceExploder::modifyCustChoiceSupplyVols()
{
  int nParts;
  char ** partList;
  witGetParts(originalWitRun_, &nParts, &partList);

  int nPeriods;
  witGetNPeriods(originalWitRun_, &nPeriods);

  // ========= part Attributes  ==========
  float * supplyVol;


  int i = 0;
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];

    // CUSTOMER_CHOICE_FEATURES
    // See Customer Feature Model documentation. It's kind of wierd.
    if (mpHelper()->isPartSpecialCustChoiceFeature(originalWitRun_, thePart)) {
      witGetPartSupplyVol(originalWitRun_, thePart, &supplyVol);
      LgFrTimeVecFloat supplyAdjust(mpHelper()->custChoiceDummySupplyVolForMrpAdjustment(originalWitRun_,
                                                                                        thePart));
      // We must add the supply adjust ot any existing suply for the specialCustChpoice part
      // An existing supply may be there due to Machine Feature Supply
      LgFrTimeVecFloat existingSupplyTVF(nPeriods, supplyVol);
      LgFrTimeVecFloat newSupplyTVF = supplyAdjust.op(existingSupplyTVF, LgFrAdd);
      witSetPartSupplyVol(localWitRun_, thePart, newSupplyTVF.data());
      witFree(supplyVol);
    }
    // END_CUSTOMER_CHOICE_FEATURES

  }


  // free the parts
  for (i=0; i<nParts; i++)
    witFree(partList[i]);
  witFree(partList);

}


// ---------------------------------------------------------------
// One stop WIT messaging control
void
LgFrSceBaseExploder::setWitInformationalMessagingExpl(WitRun * const theWitRun,
                                                  int onOrOff)
{
  // if they want it off
  if (onOrOff == 0) {
    // shut off ALL info messages
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, 0);
    // Let ANY warning message come out once
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, 1);
    // Suppress a few WARNING messages that we already know about
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 446, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);
  }
  else {
    // turn all INFO on
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitINFORMATIONAL_MESSAGES, UCHAR_MAX);
    // turn all WARNINGS on
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, UCHAR_MAX);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 338, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);
  }
}



std::string
LgFrSceExploder::title()
{
  std::string myTitle("witMrp");
  return myTitle;
}



// destructor
LgFrSceExploder::~LgFrSceExploder()
{

  // Use WIT Object Iteration to delete all the AppData's

  witAttr objItrState;

  witGetObjItrState(localWitRun_, &objItrState);
  if (objItrState != WitINACTIVE) {
    witResetObjItr(localWitRun_);
  }

  LgFrSceAppData * appDataPtr;

  witBoolean areWeDoneYet = WitFALSE;

  while ( ! areWeDoneYet) {
    witAdvanceObjItr(localWitRun_);

    witGetObjItrState(localWitRun_, &objItrState);

    if (objItrState ==  WitAT_PART) {
      char * partName;
      witGetObjItrPart(localWitRun_, &partName);
      witGetPartAppData(localWitRun_, partName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
    }

    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(localWitRun_, &partName, &demandName);
      witGetDemandAppData(localWitRun_, partName, demandName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(partName);
      witFree(demandName);
    }

    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(localWitRun_, &opName);
      witGetOperationAppData(localWitRun_, opName, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(localWitRun_, &opName, &b);
      witGetBomEntryAppData(localWitRun_, opName, b, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(localWitRun_, &opName, &b, &s);
      witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(localWitRun_, &opName, &bp);
      witGetBopEntryAppData(localWitRun_, opName, bp, (void **) &appDataPtr);
      delete appDataPtr;
      witFree(opName);
    }

    else if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

    else
      assert(1 == 0);

  }

  witDeleteRun(localWitRun_);
}


// Return Exploder Identifier
isAReturnType
LgFrSceExploder::isA()
const
{
  return id_;
}

// + LgFrSceExploder::smartAppData:
// +      Use object iteration to clone all the appData objects
void
LgFrSceExploder::copyAppData()
{

  // Use WIT Object Iteration to clone all the AppData's

  witAttr objItrState;

  witGetObjItrState(originalWitRun_, &objItrState);
  if (objItrState != WitINACTIVE) {
    std::cout << "Cloning AppData:   ogjItrState is not WitINACTIVE.   Resetting ObjItr" << std::endl;
    witResetObjItr(originalWitRun_);
  }

  LgFrSceAppData * appDataPtr;
  LgFrSceAppData * cloneAppDataPtr;

  witBoolean areWeDoneYet = WitFALSE;

  while ( ! areWeDoneYet) {
    witAdvanceObjItr(originalWitRun_);

    witGetObjItrState(originalWitRun_, &objItrState);

    if (objItrState ==  WitAT_PART) {
      char * partName;
      witGetObjItrPart(originalWitRun_, &partName);
      witGetPartAppData(originalWitRun_, partName, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetPartAppData(localWitRun_, partName, (void *) cloneAppDataPtr);
      }
      witFree(partName);
    }

    else if (objItrState == WitAT_DEMAND) {
      char * partName;
      char * demandName;
      witGetObjItrDemand(originalWitRun_, &partName, &demandName);
      witGetDemandAppData(originalWitRun_, partName, demandName, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetDemandAppData(localWitRun_, partName, demandName, (void *) cloneAppDataPtr);
      }
      witFree(partName);
      witFree(demandName);
    }

    else if (objItrState == WitAT_OPERATION) {
      char * opName;
      witGetObjItrOperation(originalWitRun_, &opName);
      witGetOperationAppData(originalWitRun_, opName, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetOperationAppData(localWitRun_, opName, (void *) cloneAppDataPtr);
      }
      witFree(opName);
    }

    else if (objItrState == WitAT_BOM_ENTRY) {
      char * opName;
      int b;
      witGetObjItrBomEntry(originalWitRun_, &opName, &b);
      witGetBomEntryAppData(originalWitRun_, opName, b, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetBomEntryAppData(localWitRun_, opName, b, (void *) cloneAppDataPtr);
      }
      witFree(opName);
    }


    else if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(originalWitRun_, &opName, &b, &s);
      witGetSubsBomEntryAppData(originalWitRun_, opName, b, s, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetSubsBomEntryAppData(localWitRun_, opName, b, s, (void *) cloneAppDataPtr);
      }
      witFree(opName);
    }

    else if (objItrState == WitAT_BOP_ENTRY) {
      char * opName;
      int bp;
      witGetObjItrBopEntry(originalWitRun_, &opName, &bp);
      witGetBopEntryAppData(originalWitRun_, opName, bp, (void **) &appDataPtr);
      if (appDataPtr != 0) {
        cloneAppDataPtr = appDataPtr->clone();
        witSetBopEntryAppData(localWitRun_, opName, bp, (void *) cloneAppDataPtr);
      }
      witFree(opName);
    }

    else if (objItrState == WitINACTIVE)
      areWeDoneYet = WitTRUE;

    else
      assert (1==0);
  }
}



// + ===========================================================
// + Base Decorator LgFrSceBaseExploderDecorator
// + ===========================================================
// +
// + Overrides:
// +    - isA()


  // The "Action" method ... Just do it
int
LgFrSceBaseExploderDecorator::explode()
{
  return myExploder_->explode();
}



  // determine if this part is something that you deal with
witBoolean
LgFrSceBaseExploderDecorator::exists(const std::string& part)
{
  return myExploder_->exists(part);
}

#if 0
  // Get the four wit mrp part attributes:
  // Default implementation
int
LgFrSceBaseExploderDecorator::mrpProdVol(  const std::string& part, float ** mrpProdVol)
{
  return myExploder_->mrpProdVol(part, mrpProdVol);
}
#endif

int
LgFrSceBaseExploderDecorator::mrpExcessVol(const std::string& part, float ** mrpExcessVol)
{
  return myExploder_->mrpExcessVol(part, mrpExcessVol);
}


int
LgFrSceBaseExploderDecorator::mrpResidualVol(const std::string& part, float ** mrpResidualVol)
{
  return myExploder_->mrpResidualVol(part, mrpResidualVol);
}


int
LgFrSceBaseExploderDecorator::reqVol(      const std::string& part, float ** reqVolPtr)
{
  return myExploder_->reqVol(part, reqVolPtr);
}

int
LgFrSceBaseExploderDecorator::mrpConsVol(  const std::string& part, float ** mrpConsVolPtr)
{
  return myExploder_->mrpConsVol(part, mrpConsVolPtr);
}

int
LgFrSceBaseExploderDecorator::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
{
  return myExploder_->mrpExecVol(operation, mrpExecVolPtr);
}


  // subUsage Vol
int
LgFrSceBaseExploderDecorator::subUsageVol(  const std::string& operation,
                                            const int bomIndex,
                                            const int subBomIndex,
                                            float ** subUsageVolPtr)
{
  // just pass this baby along ...
  // if smartExpldoer gets it, fine.  Otherwise the concrete will choke on it.
  return myExploder_->subUsageVol(operation, bomIndex, subBomIndex, subUsageVolPtr);

}




  // preferred constructor
LgFrSceBaseExploderDecorator::LgFrSceBaseExploderDecorator(LgFrSceBaseExploder * myExploder)
  : LgFrSceBaseExploder(myExploder->theWitRun(),
                        myExploder->localWitRun(),
                        myExploder->mpHelper(),
                        myExploder->setOfParameters()),
    myExploder_ (myExploder),
    id_ (__LGFRSCEBASEEXPLODERDECORATOR)
{
  // nothing to do.  Concrete decorators do all the work
}


  // Return Exploder Identifier
isAReturnType
LgFrSceBaseExploderDecorator::isA() const
{
  return id_;
}



#ifdef BASE_DECORATOR_USES_CONCRETE_MEMBER_DATA
WitRun *
LgFrSceBaseExploderDecorator::theWitRun()
{
  return myExploder_->theWitRun();
}

WitRun *
LgFrSceBaseExploderDecorator::localWitRun()
{
  return myExploder_->localWitRun();
}

LgFrMultiPlantHelper *
LgFrSceBaseExploderDecorator::mpHelper()
{
  return myExploder_->mpHelper();
}

LgFrSceSetOfParameters *
LgFrSceBaseExploderDecorator::setOfParameters()
{
  return myExploder_->setOfParameters();
}


int
LgFrSceBaseExploderDecorator::nPeriods()
{
  return myExploder_->nPeriods();
}

#else

WitRun *
LgFrSceBaseExploderDecorator::theWitRun()
{
  return originalWitRun_;
}

WitRun *
LgFrSceBaseExploderDecorator::localWitRun()
{
  return localWitRun_;
}

LgFrMultiPlantHelper *
LgFrSceBaseExploderDecorator::mpHelper()
{
  return mpHelper_;
}

LgFrSceSetOfParameters *
LgFrSceBaseExploderDecorator::setOfParameters()
{
  return setOfParameters_;
}

int
LgFrSceBaseExploderDecorator::nPeriods()
{
  return nPeriods_;
}

#endif

void
LgFrSceBaseExploderDecorator::state(int state)
{
  myExploder_->state(state);
}

int
LgFrSceBaseExploderDecorator::state()
{
  return myExploder_->state();
}


void
LgFrSceBaseExploderDecorator::print(std::string& filename)
{
  myExploder_->print(filename);
}


  // destructor
LgFrSceBaseExploderDecorator::~LgFrSceBaseExploderDecorator()
{
  delete myExploder_;
}


// + ========================================================================
// + class LgFrSceFullExploderDecorator
// + ========================================================================
// +
// + Decorates:
// +    - the witRun via offset modifications
// +
// + Overrides:
// +    - isA()


int
LgFrSceFullExploderDecorator::explode()
{
  return myExploder_->explode();
}

std::string
LgFrSceFullExploderDecorator::title()
{
  std::string myTitle(myExploder_->title());
  myTitle.insert(0, "Full ");
  return myTitle;
}


  // preferred constructor
LgFrSceFullExploderDecorator::LgFrSceFullExploderDecorator(LgFrSceBaseExploder * myExploder)
  : LgFrSceBaseExploderDecorator(myExploder),
    id_ (__LGFRSCEFULLEXPLODERDECORATOR)
{
  this->decorateLocalWitRun();
}


  // destructor
LgFrSceFullExploderDecorator::~LgFrSceFullExploderDecorator()
{
  // do nothing.  The decorator base class deletes myExploder_
}

  // Return Exploder Identifier
isAReturnType
LgFrSceFullExploderDecorator::isA()
const
{
  return id_;
}



// + Full Explode decorates witRun by modifying BOM offsets
void
LgFrSceFullExploderDecorator::decorateLocalWitRun()
{
  // make sure you are dealing with the right witRun

  std::string theC;
  std::string theP;

  int nOps;
  char ** opList;
  witGetOperations(theWitRun(), &nOps, &opList);

  // Now loop over all operations ...
  // and modify the yieldRate back to its setting in the original
  // witRun.  We do this to "undo" what setting wit34Compabile to false did.
  // Namely, wit34Compat=true causes the yieldrates within the cycleTime be
  // set to 0.0.
  // do not do this swap with the CapacityGeneration Operations
  int o = 0;
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];
    float * yieldRate;

    if (mpHelper_->isOperationForCapacityGeneration(localWitRun_, opList[o], theC, theP))
      continue;
    witGetOperationYieldRate(theWitRun(), theOperation, &yieldRate);
    witSetOperationYieldRate(localWitRun(), theOperation, yieldRate);
    witFree(yieldRate);
  }

  witSetTruncOffsets(localWitRun(), WitTRUE);

  // free the Operations
  for (o=0; o<nOps; o++)
    witFree(opList[o]);
  witFree(opList);

  // ++++++++++++++++++++++++++++++++
  // Ugly fix.  If we are doing smartExplode, then this last
  // yield fix will obliterate the smartExplode modelling trick
  // that enables PCF parts to be built.  Sooooooo, we must now
  // re-do the modelling trick (this is a duplicate of the snippet
  // of code from restructureForImplosionToSolveExplosion())
  // ++++++++++++++++++++++++++++++++++

  if ( setOfParameters_->getBool("useSmartExplodeUtility")) {
    int nParts;
    char ** partList;
    witGetParts(localWitRun(), &nParts, &partList);


    // Look for parts that are PCF
    int i = 0;
    for (i=0; i<nParts; i++) {
      char * thePart = partList[i];

      LgFrScePartAppData * partAppData;
      witGetPartAppData(theWitRun(), thePart, (void **) &partAppData);
      if (partAppData == 0)
        continue;

      if (! partAppData->isPartPcf())
        continue;

      // Yeah!! we found a bonafide PCF part.

      // find its default operation.
      std::string defaultOperation(thePart);
      witBoolean exists;
      witGetOperationExists(localWitRun(), defaultOperation.c_str(), &exists);
      if (! exists) {
        std::cerr << "TEMP_ERROR2: Default Operation for PCF not found in exploder\n"
             << "PCF: " << defaultOperation << "\n\n";
      }

      float * yieldRate;
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);
      int t = 0;
      for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
        yieldRate[t] = 1.0;
      }
      witSetOperationYieldRate(localWitRun(), defaultOperation.c_str(), yieldRate);
      witFree(yieldRate);
    }


    // free the parts
    for (i=0; i<nParts; i++)
      witFree(partList[i]);
    witFree(partList);
  }

}



// FINISH_ME ... Why can't we just use the version of this in Scenario?   
//               It's stupid to duplicate code
// ---------------------------------------------------------------
void
LgFrSceSmartExploderDecorator::printImpactPeriodFile(
    WitRun * const theWitRun,
    const int nPeriods,
    const std::string & fileName,
    LgFrMultiPlantHelper & mpHelper)
{

  int nOps;
  char ** opList;

  LgFrSceFlatFileMgr & flatFileManager =
    this->sceScenSP_->flatFileMgr();

  MclFacility * theErrFacil = this->sceScenSP_->getErrFacility();


  std::ofstream outFile(fileName.c_str());
  if (outFile.fail()) {
    (*theErrFacil)("CannotOpenFileForWrite",MclArgList()
                   << "ImpactPeriod"
                   << fileName);
  }


  witGetOperations(theWitRun, &nOps, &opList);
  int nBom;
  int op = 0;
  for (op=0; op<nOps; op++ ) {
    std::string parentPdf, parentOpName, childPartName, childPdf;
    int isItNormalOperation = 0;
    if (mpHelper.isOperationNormal(theWitRun, opList[op], parentPdf, parentOpName))
      isItNormalOperation = 1;
    else if (! mpHelper.isOperationSpecialInterplant(
                       theWitRun, opList[op],
                       parentOpName, parentPdf, childPartName, childPdf)) {
      witFree(opList[op]);
      continue;
    }

    witGetOperationNBomEntries(theWitRun, opList[op], &nBom);
    int b=0;
    for (b=0; b<nBom; b++) {
      if (isItNormalOperation) {
        char * child;
        witGetBomEntryConsumedPart(theWitRun, opList[op], b, &child);
        childPartName = mpHelper.partname(child);
        childPdf = parentPdf;
        witFree(child);
      }

      outFile << "\""
              << parentOpName << "\",\""
              << parentPdf << "\",\""
              << childPartName << "\",\""
              << childPdf << "\",";

      if (isItNormalOperation)
        outFile << "\"F\"";
      else
        outFile << "\"A\"";

      int * impactPeriod;
      witGetBomEntryImpactPeriod(theWitRun, opList[op], b, &impactPeriod);
      int t = 0;
      for (t=0; t<nPeriods; t++) {
        outFile << "," << impactPeriod[t];
      }
      outFile << "\n";
      witFree(impactPeriod);
    }

    witFree(opList[op]);
  }

  witFree(opList);

  outFile.close();
}









// + ==================================
// + class LgFrSceSmartExploderDecorator
// + ==================================
// +
// + Decorates:
// +    - the witRun via
// +        -
// +        -
// +        -
// +        -
// +
// + Overrides:
// +    - isA()
// +    - explode()
// +    -


int
LgFrSceSmartExploderDecorator::explode()
{
  // must be in initialized state
  assert(state() > 0);



  // Dump the heur version of the wit.data file
#ifdef DUMP_WIT_MRP_DATA_FILE
  std::cout << "Writing the (mrp) wit data file ..." << std::endl;
  std::string mrpWitDataFileName = "mrpWitDataFile";
  setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
  witWriteData(localWitRun_, mrpWitDataFileName.c_str());
  if (setOfParameters_->getBool("printWitExplodeMsgFile"))
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
  else
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_OFF);

  std::cout << "Writing the (mrp) echo  file ..." << std::endl;
  std::string mrpWitEchoFileName = "mrpWitEchoFile";
  setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
  witDisplayData(localWitRun_, mrpWitEchoFileName.c_str());
  if (setOfParameters_->getBool("printWitExplodeMsgFile"))
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
  else
    setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_OFF);

#endif


  bool doPegging = setOfParameters_->getBool("doPegging");
  if (doPegging) {
    witClearPipSeq(localWitRun_);
    witSetPipSeqFromHeur(localWitRun_, WitTRUE);
  }

  bool  usePrioritizedExplodeUtility = setOfParameters_->getBool("usePrioritizedExplodeUtility");
  std::string  usageName("explosion");

  bool  printMrpImpactPeriodDiagnosticFile = setOfParameters_->getBool("printMrpImpactPeriodDiagnosticFile");
  if (printMrpImpactPeriodDiagnosticFile) {
    std::string impactPdFile = setOfParameters_->getString("mrpImpactPeriodDiagFileName");
    std::cout << "Writing the Impact Period Diagnostic File (Explosion view) ..." << std::endl;
    printImpactPeriodFile(localWitRun_, nPeriods_,
			  impactPdFile, *mpHelper_);
  }





  // determine which explode engine to use
  if (usePrioritizedExplodeUtility) {
    LgFrSceCritList & theCritList = sceScenSP_->sceCritList();
    LgFrSceAllocationEngineMgr allocEngineMgr( sceScenSP_,
                                               localWitRun_,
                                               mpHelper_,
                                               usageName);
    allocEngineMgr.implode(theCritList);
  }
  else {
    witHeurImplode(localWitRun());

    //post-process
    witPostprocess (localWitRun_ );

    if (doPegging) {
      witBuildPip(localWitRun_);
      this->loadPIPDataIntoAppData(localWitRun_);
    }

  }


  state(2);

  return 0;
}





// ===============================
// ====== PIP Utilitiies ====
// ===============================
void
LgFrSceSmartExploderDecorator::loadPIPDataIntoAppData(WitRun * const theWitRun)
{
  int nPeriods;
  char  *partName, *demandName;
  float * demandVol;


  bool PegSubUsageToPrimary = setOfParameters_->getBool("PegSubUsageToPrimary");
  bool supplierPerspectiveInterplantPeg = setOfParameters_->getBool("supplierPerspectiveInterplantPeg");

  std::cout << "... collecting PIP information for MRP ..." << std::endl;

  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;

  // Loop over parts to get demands
  int i = 0;
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
    int j = 0;
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      // Now for some fancy trickery !!!
      // if the part is a special feature part, then we must map the consVol over to
      //     the GPD appData
      int isDemandSpecial = 0;
      isDemandSpecial = mpHelper_->isDemandSpecialPureOptionBuildDemand(theWitRun, partName, demandName, pp, geo);
      if (! isDemandSpecial) {
        isDemandSpecial = mpHelper_->isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
      }


      // get the demandAppData, or create a new one if it doesn't exist.
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;

      // if the demand is a specialFeaturePart then get the gpd's appdata
      if (isDemandSpecial) {
        // get a witPartName for the GPD
        fullWitGPDPartName = mpHelper_->geoPlannerDemandPartName(pp, geo);

        witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
                           (void **) &demandAppDataPtr );
        if ( demandAppDataPtr == 0 ) {
          demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
          assert ( demandAppDataPtr != 0 );
          witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
                               (void *) demandAppDataPtr );
        }
      }
      else {
        witGetDemandAppData( theWitRun, partName, demandName,
                             (void **) &demandAppDataPtr );
        if ( demandAppDataPtr == 0 ) {
          demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
          assert ( demandAppDataPtr != 0 );
          witSetDemandAppData( theWitRun, partName, demandName,
                               (void *) demandAppDataPtr );
        }
      }

#ifdef DEBUG_DUMP_FOR_PEGGING

      if (isDemandSpecial) {
        std::cout << "specialDemand, being REPORTED..." << std::endl;
        std::cout << "PIP supply is being reported for: "
             << fullWitGPDPartName << " at geo " << geo << std::endl;
      }

      std::cout << "(before)PIPConsVolSched (" << partList[i] << "," << dList[j] << std::endl;

      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << std::endl;

#endif

      // Get demands PIP consVol and directly store in appData
      ScePIP::getDemandConsVolPIP(theWitRun,
                                  partList[i],
                                  dList[j],
                                  0,
                                  nPeriods-1,
                                  demandAppDataPtr->PIPConsVolSched(),
                                  WitTRUE,
                                  PegSubUsageToPrimary);


      // Get demands PIP supplyVol and directly store in appData
      ScePIP::getSupplyVolPIP(theWitRun,
                              partList[i],
                              dList[j],
                              0,
                              nPeriods-1,
                              demandAppDataPtr->PIPSupplyVolSched());


      ScePIP::getDemandExecVolPIP(theWitRun,
				  partList[i],
				  dList[j],
				  0,
				  nPeriods-1,
				  demandAppDataPtr->PIPExecVolSched());



      ScePIP::getDemandInterplantVolPIP(theWitRun,
					mpHelper_,
					partList[i],
					dList[j],
					0,
					nPeriods-1,
					demandAppDataPtr->PIPInterplantVolSched(),
					supplierPerspectiveInterplantPeg);
      

#ifdef DEBUG_INTERPLANT_PEG
      std::cout << "laoding interplantPIP from exploders.C" << std::endl;
      demandAppDataPtr->PIPInterplantVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif



#ifdef DEBUG_DUMP_FOR_PEGGING
      std::cout << "(after) JP's Get" << std::endl;
      demandAppDataPtr->PIPConsVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif

      witFree(dList[j]);
    }
    witFree(dList);
  }
}


  // preferred constructor
LgFrSceSmartExploderDecorator::LgFrSceSmartExploderDecorator(LgFrSceBaseExploder * myExploder,
                                                             LgFrScenarioForSceSmartPointer sceScenSP,
                                                             LgFrMultiPlantHelper * mpHelper)
  : LgFrSceBaseExploderDecorator(myExploder),
  id_ (__LGFRSCESMARTEXPLODERDECORATOR),
  sceScenSP_ (sceScenSP),
  mpHelper_ (mpHelper)
{
  if (setOfParameters_->getBool("usePrioritizedExplodeUtility"))
    this->decorateLocalWitRunForPrioritizedExplode();
  else
    this->decorateLocalWitRun();
}



std::string
LgFrSceSmartExploderDecorator::title()
{
  std::string myTitle(myExploder_->title());
  myTitle.insert(0,"Smart ");
  return myTitle;
}



  // destructor
LgFrSceSmartExploderDecorator::~LgFrSceSmartExploderDecorator()
{
  // nothing to do here
}

  // Return Exploder Identifier
isAReturnType
LgFrSceSmartExploderDecorator::isA()
const
{
  return id_;
}


// + Full Explode decorates witRun by modifying BOM offsets
void
LgFrSceSmartExploderDecorator::decorateLocalWitRun()
{
  // set the equitability factor
  int localEquitability = setOfParameters_->getInt("smartExplodeEquit");
  witSetEquitability(localWitRun(), localEquitability);

  // set forcedEquitability parameter in wit.
  bool smartExplodeForceEquit = setOfParameters_->getBool("smartExplodeForceEquit");
  witSetForcedMultiEq(localWitRun_, smartExplodeForceEquit);

  // 2.30 fix
  witSetSkipFailures(localWitRun_, WitFALSE);

  // 2.30 addition: set expCutoff
  float expCutoffTolerance = setOfParameters_->getFloat("expCutoffTolerance");
  witSetExpCutoff(localWitRun_, expCutoffTolerance);


  // bool doPegging = setOfParameters_->getBool("doPegging");


  // FINISH_ME: this is a bit kludgy.   If we are doing Penalized Execution (by virtue of the
  // the groupSharing approach, then we want to shut off penalized execution in the smartExplode
  // Note that we let it stay on in prioritized Explode method.  Eventaully will need more explicit
  // paramters to control everything in explode as well as implode
  bool groupSharingViaExecPenalties =  setOfParameters_->getBool("groupSharingViaExecPenalties");
  if (groupSharingViaExecPenalties)
    witSetPenExec(localWitRun_, WitFALSE);

  // ----------------------------------------------
  // STEP 2: disable any sub bom entries with objectInEffectForExplosion=0
  // ----------------------------------------------
  this->disableSubBomAccordingToAppData();

  // ---------------------------------
  // STEP 3: Restructure for Implosion
  // ---------------------------------
  // In this step we restructure the model so that an implosion
  // can accurately represent an explosion
  this->restructureForImplosionToSolveExplosion();

  // ---------------------------------
  // STEP 3.5: Use pipPriority's if engine==optimization and pipPriorityFile non-null
  // ---------------------------------
  bool doPegging = setOfParameters_->getBool("doPegging");

  if (doPegging) {
    std::string engine = setOfParameters_->getString("engine");
    std::string pipPriorityFile = setOfParameters_->getString("pipPriorityFile");

    // if using optimization and a pipPriorityFile, then we need to load the
    // pipPriorities from the WitRun into the localWitrun
    if (engine == "optimization" && (! pipPriorityFile.empty())) {
      std::cout << "Starting Post Implosion Pegging ... " << std::endl;
      int nPeriods;
      int nParts, nDemands;
      char ** partList, ** demList;
      int i, j;

      witGetNPeriods(localWitRun_, &nPeriods);
      witGetParts( localWitRun_, &nParts, &partList );

      // Loop thru every part, looking for special cases to fix
      for (i=0; i<nParts; i++)  {
        witGetPartDemands(localWitRun_, partList[i], &nDemands, &demList);
        for (j=0; j<nDemands; j++) {
          // get it From AppData !!
          int * priority;
          witGetDemandPriority(localWitRun_, partList[i], demList[j], &priority);
          LgFrTimeVecFloat pipPriority(nPeriods, 0.0);
          int t;
          for (t=0; t<nPeriods; t++)
            pipPriority[t] = (float) priority[t];
          witFree(priority);

          LgFrSceDemandAppData * demandAppDataPtr;
          witGetDemandAppData(originalWitRun_,
                              partList[i],
                              demList[j],
                              (void **) &demandAppDataPtr);

          // If the demandAppDataPtr has been set, see if the pipPriority has been set.
          if (demandAppDataPtr != 0)  {
            pipPriority = demandAppDataPtr->pipPriority();
          }
          witSetDemandPriority(localWitRun_, partList[i], demList[j], pipPriority.intData());
          witFree(demList[j]);
        }
        witFree(partList[i]);
        witFree(demList);
      }
      witFree(partList);
    }
  }




  // ----------------------------------
  // STEP 4: Do Robin's split BOP thing
  // ----------------------------------
  // The Final step is to do the exact same processing of BOP entries
  // that is done in initialProblem.  This is where we look at
  // bop and subbom preferences.
  // FINISH_ME: For now we will strictly use heuristic implosion.  For
  //      LP, this step is unnecessary.  Of course, other steps are.
  //      WAhhh! I wanna go home.
  // FINISH_ME: implemnt this.  we do not need this for the MD
  // alpha run.
  // doRobinsBopThing()

  state(1);


}


void
LgFrSceSmartExploderDecorator::disableSubBomAccordingToAppData()
{
  witAttr objItrState;
  witResetObjItr(originalWitRun_);

  LgFrSceAppData * appDataPtr;

  witBoolean areWeDoneYet = WitFALSE;

  while ( ! areWeDoneYet) {
    witAdvanceObjItr(localWitRun_);
    witGetObjItrState(localWitRun_, &objItrState);

    if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(localWitRun_, &opName, &b, &s);


      witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);

      // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
      // + are shut off via effectivity dates.
      if (appDataPtr != 0) {

        if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
        }
      }
      else {
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
      }
      witFree(opName);
    }

    if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

  }
}





// + Smartexplode: restructureForImplosionToSolveExplosion
// + (1) set the yieldRate on PCF default operations to 1.0
// + (1.5) set expAversion
// + (2) turn on the bop entry for pcfPart's default operation by
// +     setting expAllowed=true and effectivity to entire horizon
// + (3) Make capacity non-gating by addding a dummy operation to
// +     create it.
void
LgFrSceSmartExploderDecorator::restructureForImplosionToSolveExplosion()
{


  int nParts;
  char ** partList;
  witGetParts(localWitRun(), &nParts, &partList);

  int o = 0;
  int nOps;
  char ** opList;
  witGetOperations(localWitRun(), &nOps, &opList);

  // Look for parts that are PCF
  int i = 0;
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];


    if (! mpHelper_->isPartNormal(theWitRun(), thePart))
      continue;



    LgFrScePartAppData * partAppData;
    witGetPartAppData(theWitRun(), thePart, (void **) &partAppData);
    if (partAppData == 0)
      continue;

    if (! partAppData->isPartPcf()) {



#if 1
      // this snippet of code is looking for any situations where
      // a part might possibly be unexplodeable.   In particular, when
      //  a Normal Part has more than one producing BOP.  In this case,
      // the default BOP has been shut off and the other BOPs (interplant,
      // aggregation, userDefinedOp, ...)
      // when the
      witBoolean defOpExists;

      int  npBops;  // number of bops producing the i-th part
      witGetPartNProducingBopEntries ( localWitRun(), partList[i], & npBops );

      if ( npBops <= 1 )  // we only care about the case with multiple bops
        continue;

      std::string defaultOperationName (partList[i]);
      witGetOperationExists(localWitRun(), defaultOperationName.c_str(), &defOpExists);

      //  Capacity parts (and perhaps)
      // some dummy parts (in the future) may have more than one bop and no
      // default op.
      if (! defOpExists) {
        continue;
      }

      int nBom;
      witGetOperationNBomEntries(localWitRun(), defaultOperationName.c_str(), &nBom);
      // if the default operation is childless, shut off the default bop's effectivity
      if (nBom == 0) {

        // find bopEntryIndex for default operation
        bool didWefindBopEntryForDefaultOperation = false;

        int p = 0;
        for (p=0; p<npBops; p++) { // p = prodIndex
          char * opName;
          int bopEntryIndex;
          witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);

          if (defaultOperationName == opName) {
            // Note: at this time there should only be one
            // bop entry for the default part
            assert(didWefindBopEntryForDefaultOperation == false);
            didWefindBopEntryForDefaultOperation = true;
            witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE );
            witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 );
            witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 );
            witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 );
          }
          witFree(opName);
        }
        // make sure you found a bop entry for default to shut off
        assert(didWefindBopEntryForDefaultOperation == true );
      }
    }



#endif

    else {
      // Else!! we found a bonafide PCF part.

      // find its default operation.
      std::string defaultOperation(thePart);
      witBoolean exists;
      witGetOperationExists(localWitRun(), defaultOperation.c_str(), &exists);
      assert(exists);

      float * yieldRate;
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);
      int t = 0;
      for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
        yieldRate[t] = 1.0;
      }
      witSetOperationYieldRate(localWitRun(), defaultOperation.c_str(), yieldRate);
      witFree(yieldRate);


      // find the bop entry that leads to the default operation
      // set effectivities on and byProduct off
      int nbBops;
      char * producedPart;
      witGetOperationNBopEntries(localWitRun(), defaultOperation.c_str(), &nbBops);
      int defaultOperationFound = 0;
      int b = 0;
      for (b=0; b<nbBops; b++) {
        witGetBopEntryProducedPart(localWitRun(), defaultOperation.c_str(), b, &producedPart);
        if (producedPart == defaultOperation) {
          defaultOperationFound = 1;
          witSetBopEntryExpAllowed(localWitRun(), defaultOperation.c_str(), b, WitTRUE);
          witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation.c_str(), b, 0);
          witSetBopEntryLatestPeriod(localWitRun(), defaultOperation.c_str(), b, nPeriods()-1);
        }
        witFree(producedPart);
      }
      if (! defaultOperationFound) {
        std::cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
                  << "PCF: " << defaultOperation << "\n\n";
      }
    }

  }

  // + Smart Explode modelling trick:  Add operations to produce capacity
  // + For each capacity part, add a dummy operation that produces the capacity.
  // + Then, to get reqVol, we simply pick up execVol of the dummy operation.
  // + Note: this modelling trick applies to Normal capacity parts as well as
  // + modelling trick generated capacity parts.
  // +

#if 0
  LgFrTimeVecFloat unitYieldRate(nPeriods(), 1.0);
  for (i=0; i<nParts; i++) {
    std::string theCapacity(partList[i]);

    witAttr category;
    witGetPartCategory(localWitRun_, theCapacity.c_str(), &category);
    if (category == WitCAPACITY) {
      witBoolean exists;
      std::string capGeneratorOperationName =
        mpHelper_->operationForCapacityGeneration(theCapacity);
      witGetOperationExists(localWitRun_, capGeneratorOperationName.c_str(), &exists);
      if (exists) {
        witSetOperationYieldRate(localWitRun_, capGeneratorOperationName.c_str(),unitYieldRate.data());
      }
      else {
        std::cout << "Found a capacity that doesn't have a capGeneratorOperation:"
                  << theCapacity.c_str << std::endl;
      }
    }
  }
#else
  LgFrTimeVecFloat unitYieldRate(nPeriods(), 1.0);
  for (o=0; o<nOps; o++) {
    std::string theCapacity;
    std::string thePdf;
    if (mpHelper_->isOperationForCapacityGeneration(localWitRun_, opList[o], theCapacity, thePdf)) {
      witSetOperationYieldRate(localWitRun_, opList[o],unitYieldRate.data());
    }
  }
 #endif

  // free the parts
  for (i=0; i<nParts; i++)
    witFree(partList[i]);
  witFree(partList);

  // free the Operations

  for (o=0; o<nOps; o++)
    witFree(opList[o]);
  witFree(opList);

}


// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXX  decorateLocalWitRunForPrioritizedExplode XXXXXXXXXXXXxXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
void
LgFrSceSmartExploderDecorator::decorateLocalWitRunForPrioritizedExplode()
{
  // set the equitability factor
  //  int localEquitability = setOfParameters_->getInt("smartExplodeEquit");
  //  witSetEquitability(localWitRun(), localEquitability);

  // set forcedEquitability parameter in wit.
  //  bool smartExplodeForceEquit = setOfParameters_->getBool("smartExplodeForceEquit");
  //  witSetForcedMultiEq(localWitRun_, smartExplodeForceEquit);

  // 2.30 addition: set expCutoff
  //   witSetSkipFailures(localWitRun_, WitFALSE);

  // 2.30 addition: set expCutoff
  //  float expCutoffTolerance = setOfParameters_->getFloat("expCutoffTolerance");
  //  witSetExpCutoff(localWitRun_, expCutoffTolerance);


  //  4.31: stock reallocation
  bool useStockReallocationInPrioExplode = setOfParameters_->getBool("useStockReallocationInPrioExplode");
  witSetStockReallocation(localWitRun_, useStockReallocationInPrioExplode);


  // bool doPegging = setOfParameters_->getBool("doPegging");

  //  witSetPenExec(localWitRun_, WitFALSE);

  // Need a special one for this case.   Only set for normal parts.  Leave the modellling trick subs alone (ie, special Features)
  //   this->disableSubBomAccordingToAppData();

  std::cout << "Entering ... decorateLocalWitRunForPrioritizedExplode" << std::endl;


  witAttr objItrState;

  //  witResetObjItr(originalWitRun_);
  witResetObjItr(localWitRun_);

  LgFrSceAppData * appDataPtr;

  witBoolean areWeDoneYet = WitFALSE;
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(localWitRun_);
    witGetObjItrState(localWitRun_, &objItrState);

    if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(localWitRun_, &opName, &b, &s);

      std::string pdf, op;
      if (mpHelper_->isOperationNormal(localWitRun_, opName, pdf, op)) {

        witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);

        // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
        // + are shut off via effectivity dates.
        if (appDataPtr != 0) {
          if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
            witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
            witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
          }
        }
        else {
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
        }
      }
      witFree(opName);
    }

    if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }

  }



  // ---------------------------------
  // STEP 3: Restructure for Implosion
  // ---------------------------------
  // In this step we restructure the model so that an implosion
  // can accurately represent an explosion
  //  this->restructureForImplosionToSolveExplosion();
  // +
  // + 1) Enable Capacity Generation Operations  via yieldRate=1.0
  // + 2) Make PCF parts are made explodeable via:
  // +    a) yieldRate = 1 for it's producing operation
  // +    b) producing BOP entry gets effectivity open and expAllowed=T
  // + 3) Make any unexplodeable NON-PCF parts explodeable
  // + 4) witSetWit34Compatible=True causes yieldRates to get reset based on cycleTimes
  // +       we need to correct for that by copying back the orginal yieldRates from original
  // +       originalWitRun.   This can go away if we ever get away from wit34Comapatible mode
  LgFrTimeVecFloat unitYieldRate(nPeriods(), 1.0);
  int o = 0;
  std::string capacityName;
  std::string pdf;

  int nOps;
  char ** opList;
  witGetOperations(localWitRun(), &nOps, &opList);


  // Loop over operations once and fix everything in one pass
  for (o=0; o<nOps; o++) {
    std::string  theOperation = opList[o];

    // + Enable Capacity Generation Operations  via yieldRate=1.0
    if (mpHelper_->isOperationForCapacityGeneration(localWitRun_, theOperation.c_str(), capacityName, pdf)) {
      witSetOperationYieldRate(localWitRun_, theOperation.c_str(), unitYieldRate.data());
    }

    // + Make PCF parts explodeable via:
    else if  (mpHelper_->isPartPcf(localWitRun_, theOperation)) {
      witBoolean exists;
      witGetPartExists(localWitRun(), theOperation.c_str(), &exists);
      assert(exists);

      LgFrScePartAppData * partAppData;
      witGetPartAppData(localWitRun(), theOperation.c_str(), (void **) &partAppData);
      assert(partAppData != 0);

      float * yieldRate;
      witGetOperationYieldRate(localWitRun(), theOperation.c_str(), &yieldRate);
      int t = 0;
      for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
        yieldRate[t] = 1.0;
      }
      witSetOperationYieldRate(localWitRun(), theOperation.c_str(), yieldRate);
      witFree(yieldRate);


      // find the bop entry that leads to the default operation
      // set effectivities open and expAllowed=true
      int nbBops;
      char * producedPart;
      witGetOperationNBopEntries(localWitRun(), theOperation.c_str(), &nbBops);
      int defaultOperationFound = 0;
      int b = 0;
      for (b=0; b<nbBops; b++) {
        witGetBopEntryProducedPart(localWitRun(), theOperation.c_str(), b, &producedPart);
        if (producedPart == theOperation) {
          defaultOperationFound = 1;
          witSetBopEntryExpAllowed(localWitRun(), theOperation.c_str(), b, WitTRUE);
          witSetBopEntryEarliestPeriod(localWitRun(), theOperation.c_str(), b, 0);
          witSetBopEntryLatestPeriod(localWitRun(), theOperation.c_str(), b, nPeriods()-1);
        }
        witFree(producedPart);
      }
      assert(defaultOperationFound);
    }

    witFree(opList[o]);
  }
  witFree(opList);


  // + 3) Loop Through Parts.
  //       a) manually truncate wit34 cycletimes.
  //       b) Make any unexplodeable, multi-bop'd,  NON-PCF parts explodeable
  //          FINISH_ME: this looks a bit wierd.   Review.
  // 4.20 rev1
  int nParts;
  char ** partList;
  witGetParts(localWitRun(), &nParts, &partList);

  // Loop through all the Normal parts ...
  int i = 0;
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];

    if (! mpHelper_->isPartNormal(theWitRun(), thePart)) {
      witFree(partList[i]);
      continue;
    }

    witAttr category;
    witGetPartCategory(theWitRun(), partList[i], &category);
    if (category != WitCAPACITY) {
      //  make sure buildASAP is off
      // FINISH_ME_440: this may be a parameter setting in future
      witSetPartBuildAsap(localWitRun(), thePart, WitFALSE);
    }

#ifdef VARIABLE_PERIODS

    /*  no need to manually trnuc the cycletimes.   Wit does it with truncOffsets on offsets
	HOWEVER ... we do need to think about truncing end of horizon leadtimes due to negative offsets so EVERYTHING can explode
    if (category == WitPRODUCT) {
      // do we need to truncate anything if we convert completely to offsets??
      // tuncate the cycleTimes, so these things can explode in early periods.   Since cycletime is a
      // legacy of wit34, we must manually truncate them.   wit's truncateOffsets will not do it.
      // finish this
      float * localCycleTime;
      witGetPartCycleTime(localWitRun(), thePart, &localCycleTime);
      int ttt=0;
      int cyMax = ceil(localCycleTime[0]);
      if (cyMax >= nPeriods() -1)
         cyMax = nPeriods() -1;
      for (ttt=0; ttt<=cyMax; ttt++) {
        localCycleTime[ttt]=ttt;
      }
      witSetPartCycleTime(localWitRun(), thePart, localCycleTime);
      witFree(localCycleTime);
    }
    */
#else
    if (category == WitPRODUCT) {
      // tuncate the cycleTimes, so these things can explode in early periods.   Since cycletime is a
      // legacy of wit34, we must manually truncate them.   wit's truncateOffsets will not do it.
      float * localCycleTime;
      witGetPartCycleTime(localWitRun(), thePart, &localCycleTime);
      int ttt=0;
      int cyMax = ceil(localCycleTime[0]);
      if (cyMax >= nPeriods() -1)
         cyMax = nPeriods() -1;
      for (ttt=0; ttt<=cyMax; ttt++) {
        localCycleTime[ttt]=ttt;
      }
      witSetPartCycleTime(localWitRun(), thePart, localCycleTime);
      witFree(localCycleTime);
    }
#endif

    LgFrScePartAppData * partAppData;
    witGetPartAppData(theWitRun(), thePart, (void **) &partAppData);
    if (partAppData == 0) {
      witFree(partList[i]);
      continue;
    }

    // Look for any unexplodeable non-pcf parts and ... fix it.
    // In particular, when
    //  a Normal Part has more than one producing BOP.  In this case,
    // the default BOP has been shut off and the other BOPs (interplant,
    // aggregation, userDefinedOp, ...)
    // when the
    if (! partAppData->isPartPcf()) {
      witBoolean defOpExists;

      int  npBops;  // number of bops producing the i-th part
      witGetPartNProducingBopEntries ( localWitRun(), partList[i], & npBops );

      if ( npBops <= 1 ) {  // we only care about the case with multiple bops
	witFree(partList[i]);
        continue;
      }

      std::string defaultOperationName (partList[i]);
      witGetOperationExists(localWitRun(), defaultOperationName.c_str(), &defOpExists);

      //  Capacity parts (and perhaps)
      // some dummy parts (in the future) may have more than one bop and no
      // default op.
      if (! defOpExists) {
	witFree(partList[i]);
        continue;
      }

      int nBom;
      witGetOperationNBomEntries(localWitRun(), defaultOperationName.c_str(), &nBom);
      // if the default operation is childless, shut off the default bop's effectivity
      if (nBom == 0) {

        // find bopEntryIndex for default operation
        bool didWefindBopEntryForDefaultOperation = false;

        int p = 0;
        for (p=0; p<npBops; p++) { // p = prodIndex
          char * opName;
          int bopEntryIndex;
          witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);

          if (defaultOperationName == opName) {
            // Note: at this time there should only be one
            // bop entry for the default part
            assert(didWefindBopEntryForDefaultOperation == false);
            didWefindBopEntryForDefaultOperation = true;
            witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE );
            witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 );
            witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 );
            witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 );
          }
          // for 4.20: we now set execPenalty to very high number
          witSetOperationExecPenalty(localWitRun(), defaultOperationName.c_str(), 88888.8);
          witFree(opName);
        }
        // make sure you found a bop entry for default to shut off
        assert(didWefindBopEntryForDefaultOperation == true );
      }
    }
    witFree(partList[i]);
  }
  witFree(partList);

  witSetTruncOffsets(localWitRun(), WitTRUE);
  state(1);

}


// --------------
// get the reqVol
// --------------
// reqVol = 0, if part is NOT PCF
//        = prodVol if part is a PCF
int
LgFrSceSmartExploderDecorator::reqVol(const std::string& part,
                                      float ** reqVolPtr)
{


  witAttr category;
  witGetPartCategory(localWitRun_, part.c_str(), &category);
  if (category == WitCAPACITY) {
    std::string thePart(part);
    std::string dummyOperationName =
      mpHelper_->operationForCapacityGeneration(thePart);
    witGetOperationExecVol(localWitRun_, dummyOperationName.c_str(), reqVolPtr);
    return 0;
  }


  int isPartPcf = 0;

  if (exists(part)) {
    LgFrScePartAppData * partAppDataPtr;
    witGetPartAppData(localWitRun(), part.c_str(), (void **) &partAppDataPtr);
    if (partAppDataPtr != 0) {
      isPartPcf =  partAppDataPtr->isPartPcf();
    }
    if (isPartPcf) {
      witGetPartProdVol(localWitRun_, part.c_str(), reqVolPtr);
      int nPeriods;
      witGetNPeriods(localWitRun_, &nPeriods);
      // note: reqVol can only be within the consttraint horizon
      int t = 0;
      for (t=partAppDataPtr->unConstrainedStartPeriod(); t<nPeriods; t++)
        (*reqVolPtr)[t] = 0.0;
    }
    else
      mallocZeroVec(reqVolPtr);
  }
  else
    mallocZeroVec(reqVolPtr);
  return 0;
}



  // get the mrpConsVol
int
LgFrSceSmartExploderDecorator::mrpConsVol(const std::string& part,
                                          float ** mrpConsVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartConsVol(localWitRun(), part.c_str(), mrpConsVolPtr);

  else
    mallocZeroVec(mrpConsVolPtr);

  return 0;
}




  // get the mrpExcessVol
int
LgFrSceSmartExploderDecorator::mrpExcessVol(const std::string& part,
                                            float ** mrpExcessVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartExcessVol(localWitRun(), part.c_str(), mrpExcessVolPtr);
  else
    mallocZeroVec(mrpExcessVolPtr);
  return 0;
}

  // get the mrpResidualVol
int
LgFrSceSmartExploderDecorator::mrpResidualVol(const std::string& part,
                                            float ** mrpResidualVolPtr)
{
  assert(state() >= 2);
  if (exists(part))
    witGetPartResidualVol(localWitRun(), part.c_str(), mrpResidualVolPtr);
  else
    mallocZeroVec(mrpResidualVolPtr);
  return 0;
}


int
LgFrSceSmartExploderDecorator::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
{
  assert(state() >= 2);
  witBoolean opExists, partExists;;
  witGetOperationExists(localWitRun_, operation.c_str(), &opExists);
  if (opExists) {
    witGetOperationExecVol(localWitRun_, operation.c_str(), mrpExecVolPtr);
    witGetPartExists(localWitRun_, operation.c_str(), &partExists);
    if (partExists) {
      LgFrScePartAppData * partAppDataPtr;
      witGetPartAppData(localWitRun(), operation.c_str(), (void **) &partAppDataPtr);
      if (partAppDataPtr && partAppDataPtr->isPartPcf()) {
        int t = 0;
        for (t=0; t<partAppDataPtr->unConstrainedStartPeriod(); t++)
          (*mrpExecVolPtr)[t] = 0.0;
      }
    }
  }
  else
    mallocZeroVec(mrpExecVolPtr);
  return 0;
}


int
LgFrSceSmartExploderDecorator::subUsageVol(  const std::string& operation,
                                             const int bomIndex,
                                             const int subBomIndex,
                                             float ** subUsageVolPtr)
{
  assert(state() >= 2);
  witBoolean exists;
  witGetOperationExists(localWitRun_, operation.c_str(), &exists);
  if (exists) {
    // do some sanity checking to ensure that the bom index and subbom index
    // are within reason.  One might even test to see that the child and sub
    // parts are the same.  This is, in general, a FINISH_ME to put in better
    // checks and/or do more testing.
    int nBom;
    witGetOperationNBomEntries(localWitRun_, operation.c_str(), &nBom);
    assert(nBom >= bomIndex);
    int nSubBoms;
    witGetBomEntryNSubsBomEntries(localWitRun_, operation.c_str(), bomIndex, &nSubBoms);
    assert(nSubBoms >= subBomIndex);
    witGetSubsBomEntrySubVol(localWitRun_, operation.c_str(), bomIndex, subBomIndex, subUsageVolPtr);
  }
  else
    mallocZeroVec(subUsageVolPtr);
  return 0;

}



void
LgFrSceSmartExploderDecorator::print(std::string& filename)
{

  std::ofstream outFile(filename.c_str());//, ios::out);

  int nParts;
  char ** partList;
  witGetParts(theWitRun(), &nParts, &partList);

  int i = 0;
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];
    witAttr category;
    witGetPartCategory(theWitRun(), thePart, &category);

    float * mrpConsVol;
    this->mrpConsVol(thePart, &mrpConsVol);
    outFile << "\"" << thePart << "\", mrpConsVol\" ";
    int t = 0;
    for (t=0; t<nPeriods(); t++)
      outFile << "," << mrpConsVol[t];
    outFile << "\n";
    witFree(mrpConsVol);

#if 0
    float * mrpProdVol;
    this->mrpProdVol(thePart, &mrpProdVol);
    outFile << "\"" << thePart << "\", mrpProdVol\" ";
    for (t=0; t<nPeriods(); t++)
      outFile << "," << mrpProdVol[t];
    outFile << "\n";
    witFree(mrpProdVol);
#endif


    float * mrpExcessVol;
    this->mrpExcessVol(thePart, &mrpExcessVol);
    outFile << "\"" << thePart << "\", mrpExcessVol\" ";
    for (t=0; t<nPeriods(); t++)
      outFile << "," << mrpExcessVol[t];
    outFile << "\n";
    witFree(mrpExcessVol);


    float * mrpResidualVol;
    this->mrpResidualVol(thePart, &mrpResidualVol);
    outFile << "\"" << thePart << "\", mrpResidualVol\" ";
    for (t=0; t<nPeriods(); t++)
      outFile << "," << mrpResidualVol[t];
    outFile << "\n";
    witFree(mrpResidualVol);


    float * reqVol;
    this->reqVol(thePart, &reqVol);
    outFile << "\"" << thePart << "\", reqVol\" ";
    for (t=0; t<nPeriods(); t++)
      outFile << "," << reqVol[t];
    outFile << "\n";
    witFree(reqVol);

  }
  outFile.close();

  for (i=0; i<nParts; i++)
    witFree(partList[i]);
  witFree(partList);

}



// + ================================================================
// + LgFrSceFssableExploderDecorator: Implementation
// + ================================================================


void
LgFrSceFssableExploderDecorator::setAllSupplyToZero()
{
  int nPeriods;
  witGetNPeriods(localWitRun_, &nPeriods);

  int nParts;
  char ** partList;
  witGetParts(localWitRun_, &nParts, &partList);
  float * zeroVec = new float[nPeriods];
  int t = 0;
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0;

  int i = 0;
  for (i=0; i<nParts; i++) {
    witSetPartSupplyVol(localWitRun_, partList[i], zeroVec);
    witFree(partList[i]);
  }

  witFree(partList);
  delete [] zeroVec;
}

std::string
LgFrSceFssableExploderDecorator::title()
{
  std::string myTitle(myExploder_->title());
  myTitle.insert(0,"Fssable ");
  return myTitle;
}


void
LgFrSceFssableExploderDecorator::setAllDemandToZero()
{
  int nPeriods;
  witGetNPeriods(localWitRun_, &nPeriods);

  int nParts;
  char ** partList;
  witGetParts(localWitRun_, &nParts, &partList);
  float * zeroVec = new float[nPeriods];
  int t = 0;
  for (t=0; t<nPeriods; t++)
    zeroVec[t] = 0;

  int i = 0;
  for (i=0; i<nParts; i++) {
    int nDemands;
    char ** dlist;
    witGetPartDemands(localWitRun_, partList[i], &nDemands, &dlist);
    int j = 0;
    for (j=0; j<nDemands; j++) {
      witSetDemandDemandVol(localWitRun_, partList[i], dlist[j], zeroVec);
      witFree(dlist[j]);
    }
    witFree(dlist);
    witFree(partList[i]);
  }
  witFree(partList);
  delete [] zeroVec;
}

  // preferred constructor
LgFrSceFssableExploderDecorator::LgFrSceFssableExploderDecorator(LgFrSceBaseExploder * myExploder)
  : LgFrSceBaseExploderDecorator(myExploder),
    id_ (__LGFRSCEFSSABLEEXPLODERDECORATOR)
{
  // nothing to do
}



  // Return Exploder Identifier
isAReturnType
LgFrSceFssableExploderDecorator::isA()
const
{
  return id_;
}





  // destructor
LgFrSceFssableExploderDecorator::~LgFrSceFssableExploderDecorator()
{
  // nothing to do
}








// set supplyVols and demandVols to the current
// setting in originalWitRun_.  this is needed for
// FSS users.
void
LgFrSceFssableExploderDecorator::synchronize()
{

  // must be in initialized state
  assert(state_ > 0);

  int nParts;
  char ** partList;
  witGetParts(localWitRun_, &nParts, &partList);

  int i = 0;
  for (i=0; i<nParts; i++)  {
    char * thePart = partList[i];
    float * supplyVol;
    witGetPartSupplyVol(originalWitRun_, thePart, &supplyVol);
    witSetPartSupplyVol(localWitRun_, thePart, supplyVol);
    witFree(supplyVol);
    int nDemands;
    char ** demandList;
    witGetPartDemands(originalWitRun_, thePart, &nDemands, &demandList);
    int j = 0;
    for (j=0; j<nDemands; j++)   {
      float * demandVol;
      witGetDemandDemandVol(originalWitRun_, thePart, demandList[j], &demandVol);
      witSetDemandDemandVol(localWitRun_, thePart, demandList[j], demandVol);
      witFree(demandVol);
      witFree(demandList[j]);
    }
    witFree(demandList);
  }

  for (i=0; i<nParts; i++)
    witFree(partList[i]);
  witFree(partList);

}



int
LgFrSceFssableExploderDecorator::explode()
{
  //  this->synchronize();
  // FINISH_ME: check to see when we need to synchronize!!
  return myExploder_->explode();
}



#ifdef NDEBUG
#undef NDEBUG
#endif

@


1.43
log
@more fixes for 6.1
@
text
@d1057 2
a1058 1

@


1.42
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@a515 1
    std::cout << "Deleting MRP witRun, AppData Clones:   ogjItrState is not WitINACTIVE.   Resetting ObjItr" << std::endl;
a518 1
  std::cout << "Deleting MRP witRun and AppData Clones" << std::endl;
@


1.41
log
@fixed bug processing multple negativeVol demand streams
@
text
@a1813 4




a1849 1

a1852 1

a1869 1

a1905 2


d1997 1
d1999 21
d2035 1
a2035 1

@


1.40
log
@Last commit for maxForAtp
@
text
@d1184 10
d1215 3
@


1.39
log
@added function to report interplantPeg from perspective of supplier location.   basically, this shifts the interplant peg earlier to accomodate interplant lead-times
@
text
@d520 1
d1415 1
a1415 29

#if 0
  // delete the subBom app data
  int nOps;
  char ** operationList;
  witGetOperations ( localWitRun_, &nOps, &operationList );

  // delete subBom App Data
  int o = 0;
  for (o=0; o<nOps; o++) {
    int nBoms;
    int nSubBoms;
    witGetOperationNBomEntries( localWitRun_, operationList[o], &nBoms );
    int j = 0;
    for (j=0; j<nBoms; j++) {
      witGetBomEntryNSubsBomEntries( localWitRun_, operationList[o], j, &nSubBoms );
      int s = 0;
      for (s=0; s<nSubBoms; s++) {
        LgFrSceSubBomAppData * subBomAppDataPtr;
        witGetSubsBomEntryAppData( localWitRun_, operationList[o], j, s, (void **) &subBomAppDataPtr );
        delete subBomAppDataPtr;
      } // for s nSubBoms
    } // for j nBoms
  } // for o nOperations

  for (o=0; o<nOps; o++)
    witFree (operationList[o]);
  witFree (operationList);
#endif
d1980 2
a1981 4



    if (! mpHelper_->isPartNormal(theWitRun(), thePart))
d1983 1
a1986 1

a1993 1

a1994 1

d2013 2
a2014 1
    if (partAppData == 0)
d2016 1
d2030 2
a2031 1
      if ( npBops <= 1 )  // we only care about the case with multiple bops
d2033 1
d2042 1
@


1.38
log
@print impact period report for explosion
@
text
@d28 1
d1195 7
a1201 5

  std::cout << "Writing the Impact Period Diagnostic File (Explosion view) ..." << std::endl;
  std::string impactPdFile = "sceout.mrpImpactPd";
  printImpactPeriodFile(localWitRun_, nPeriods_,
                            impactPdFile, *mpHelper_);
d1248 1
d1345 24
a1368 5
                                          partList[i],
                                          dList[j],
                                          0,
                                          nPeriods-1,
                                          demandAppDataPtr->PIPExecVolSched());
@


1.37
log
@only turn buildASAP off in PriorituzedExplode for non-capacity parts
@
text
@d1055 92
d1195 5
@


1.36
log
@for explode (prioirtzed) buildASAP is always disabled
@
text
@a1888 4
    // regardless of the part's normalcy, make sure buildASAP is off
    // FINISH_ME_440: this may be a parameter setting in future
    witSetPartBuildAsap(localWitRun(), thePart, WitFALSE);

d1895 9
@


1.35
log
@initial changes for sce4.40
@
text
@d1887 7
@


1.34
log
@SCE 4.30 (backed off from calling sce 5.00) has multi-source and Gpip
@
text
@a1380 1
  witSetGroupPipMode(localWitRun_, WitTRUE);
d1728 5
a1733 1
  witSetGroupPipMode(localWitRun_, WitTRUE);
@


1.33
log
@Preliminary commit for SCE 5.00
@
text
@d1381 2
d1730 1
a1730 1

d1741 4
a1744 1
  witResetObjItr(originalWitRun_);
@


1.32
log
@comitting changes made on production branch that were merged in ... woohooo
@
text
@d1735 3
@


1.31
log
@set to use witSetNewPipPggOrder
@
text
@d80 1
a80 1
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;                      
d84 1
a84 1
    if (setOfParameters_->getBool("printWitExplodeMsgFile"))  
d90 1
a90 1
  // run the mrp on the localWitRun 
d93 1
a93 1
    
d95 1
a95 1
  
d112 1
a112 1
  witGetPartExists(localWitRun_, part.c_str(), &exists);  
d122 1
a122 1
  if (exists(part)) 
d134 1
a134 1
  if (exists(part)) 
d148 1
a148 1
  if (exists) 
d153 1
a153 1
}  
d163 1
a163 1
  if (exists(part)) 
d168 1
a168 1
  
d177 1
a177 1
  if (exists(part)) 
d188 3
a190 3
  if (exists(part)) 
    witGetPartMrpConsVol(localWitRun_, part.c_str(), mrpConsVolPtr);    
  else 
d220 1
a220 1
  int t = 0; 
d229 1
a229 1
  int t = 0; 
d244 2
a245 2
  
  
d254 1
a254 1
    nPeriods_ (0),    
d272 1
a272 1
    nPeriods_ (0),    
d280 1
a280 1
  
d287 1
a287 1
  
d330 1
a330 1
  
d341 1
a341 1
  // nothing to be done 
d350 1
a350 1
  
d374 2
a375 2
  std::string witExplodeMsgFileExtension = setOfParameters->getString("witExplodeMsgFileExtension");    
  
d381 1
a381 1
  if (setOfParameters->getBool("printWitExplodeMsgFile"))  
d391 1
a391 1
    
d401 1
a401 1
  
d403 2
a404 2
  
  // 
d411 1
a411 1
  
d419 1
a419 1
// +      be adjusted for the explosion calculation to work.   This modification 
d435 1
a435 1
  int i = 0; 
d443 2
a444 2
      LgFrTimeVecFloat supplyAdjust(mpHelper()->custChoiceDummySupplyVolForMrpAdjustment(originalWitRun_, 
											thePart));
d456 3
a458 3
    
  // free the parts 
  for (i=0; i<nParts; i++)  
d467 3
a469 3
void 
LgFrSceBaseExploder::setWitInformationalMessagingExpl(WitRun * const theWitRun,   
						  int onOrOff)
d476 1
a476 1
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, 1);    
d480 3
a482 3
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);        
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);        
  }     
d486 1
a486 1
    // turn all WARNINGS on 
d489 2
a490 2
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);           
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);         
d494 1
a494 1
  
d520 1
a520 1
  
d522 1
a522 1
  
d528 1
a528 1
    if (objItrState ==  WitAT_PART) {   
d545 1
a545 1
	
d581 1
a581 1
      
d586 1
a586 1
    else 
d588 1
a588 1
      
d604 1
a604 1
// +      Use object iteration to clone all the appData objects 
d612 1
a612 1
  
d618 1
a618 1
  
d621 1
a621 1
  
d623 1
a623 1
  
d626 1
a626 1
    
d628 2
a629 2
    
    if (objItrState ==  WitAT_PART) {   
d634 2
a635 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetPartAppData(localWitRun_, partName, (void *) cloneAppDataPtr);
d639 2
a640 2
    
    else if (objItrState == WitAT_DEMAND) { 
d646 2
a647 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetDemandAppData(localWitRun_, partName, demandName, (void *) cloneAppDataPtr);
d652 1
a652 1
    
d658 2
a659 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetOperationAppData(localWitRun_, opName, (void *) cloneAppDataPtr);
d670 2
a671 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetBomEntryAppData(localWitRun_, opName, b, (void *) cloneAppDataPtr);
d683 2
a684 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetSubsBomEntryAppData(localWitRun_, opName, b, s, (void *) cloneAppDataPtr);
d695 2
a696 2
	cloneAppDataPtr = appDataPtr->clone(); 
	witSetBopEntryAppData(localWitRun_, opName, bp, (void *) cloneAppDataPtr);
d701 1
a701 1
    else if (objItrState == WitINACTIVE) 
d704 1
a704 1
    else 
d708 1
a708 1
  
d748 1
a748 1
  return myExploder_->mrpExcessVol(part, mrpExcessVol);  
d755 1
a755 1
  return myExploder_->mrpResidualVol(part, mrpResidualVol);  
d762 1
a762 1
  return myExploder_->reqVol(part, reqVolPtr);    
d768 1
a768 1
  return myExploder_->mrpConsVol(part, mrpConsVolPtr);      
d774 1
a774 1
  return myExploder_->mrpExecVol(operation, mrpExecVolPtr);  
d788 1
a788 1
  
d792 2
a793 2
  
  
d805 2
a806 2
  
  
d907 1
a907 1
  
d910 1
a910 1
// + class LgFrSceFullExploderDecorator 
d942 2
a943 2
  
  
d947 1
a947 1
  // do nothing.  The decorator base class deletes myExploder_  
d957 3
a959 3
  
  
  
d971 1
a971 1
  witGetOperations(theWitRun(), &nOps, &opList);  
d979 1
a979 1
  int o = 0; 
d983 2
a984 2
    
    if (mpHelper_->isOperationForCapacityGeneration(localWitRun_, opList[o], theC, theP)) 
d993 2
a994 2
  // free the Operations 
  for (o=0; o<nOps; o++)  
d1005 1
a1005 1
  
d1010 2
a1011 2
    
    
d1013 1
a1013 1
    int i = 0; 
d1016 1
a1016 1
      
d1020 2
a1021 2
	continue;
      
d1023 2
a1024 2
	continue;
      
d1026 1
a1026 1
      
d1032 3
a1034 3
	std::cerr << "TEMP_ERROR2: Default Operation for PCF not found in exploder\n"
	     << "PCF: " << defaultOperation << "\n\n";
      } 
d1037 1
a1037 1
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);    
d1040 1
a1040 1
	yieldRate[t] = 1.0;
d1045 4
a1048 4
    
    
    // free the parts 
    for (i=0; i<nParts; i++)  
d1052 1
a1052 1
  
d1056 1
a1056 1
// + class LgFrSceSmartExploderDecorator 
d1061 1
a1061 1
// +        - 
d1082 1
a1082 1
  std::cout << "Writing the (mrp) wit data file ..." << std::endl;                      
d1086 1
a1086 1
  if (setOfParameters_->getBool("printWitExplodeMsgFile"))  
d1091 1
a1091 1
  
d1099 2
a1100 2
  bool  usePrioritizedExplodeUtility = setOfParameters_->getBool("usePrioritizedExplodeUtility");  
  std::string  usageName("explosion");   
d1106 1
a1106 1
    LgFrSceCritList & theCritList = sceScenSP_->sceCritList();  
d1108 3
a1110 3
					       localWitRun_, 
					       mpHelper_,
					       usageName);
d1117 1
a1117 1
    witPostprocess (localWitRun_ );    
d1123 1
a1123 1
    
d1128 1
a1128 1
  
d1149 2
a1150 2
  std::cout << "... collecting PIP information for MRP ..." << std::endl;    
    
d1160 1
a1160 1
  int i = 0; 
d1166 1
a1166 1
    int j = 0; 
d1171 1
a1171 1
      // if the part is a special feature part, then we must map the consVol over to 
d1176 1
a1176 1
	isDemandSpecial = mpHelper_->isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
d1178 1
a1178 1
 
d1185 2
a1186 2
	// get a witPartName for the GPD
	fullWitGPDPartName = mpHelper_->geoPlannerDemandPartName(pp, geo);
d1188 8
a1195 8
	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
			   (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
			       (void *) demandAppDataPtr );
	}
d1198 8
a1205 8
	witGetDemandAppData( theWitRun, partName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, partName, demandName,  
			       (void *) demandAppDataPtr );
	}
d1209 1
a1209 1
      
d1211 3
a1213 3
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "PIP supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
d1215 1
a1215 1
      
d1225 7
a1231 7
				  partList[i],
				  dList[j],
				  0,
				  nPeriods-1,
				  demandAppDataPtr->PIPConsVolSched(),
				  WitTRUE,
				  PegSubUsageToPrimary);
d1236 5
a1240 5
			      partList[i],
			      dList[j],
			      0,
			      nPeriods-1,
			      demandAppDataPtr->PIPSupplyVolSched());
d1244 5
a1248 5
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->PIPExecVolSched());
d1266 2
a1267 2
							     LgFrScenarioForSceSmartPointer sceScenSP,
							     LgFrMultiPlantHelper * mpHelper)
d1275 1
a1275 1
  else 
d1290 1
a1290 1
  
d1302 1
a1302 1
  int o = 0; 
d1307 1
a1307 1
    int j = 0; 
d1310 2
a1311 2
      int s = 0; 
      for (s=0; s<nSubBoms; s++) { 
d1318 1
a1318 1
  
d1332 2
a1333 2
  
  
d1342 1
a1342 1
  // set forcedEquitability parameter in wit. 
d1352 1
a1352 1
  
d1357 1
a1357 1
  // FINISH_ME: this is a bit kludgy.   If we are doing Penalized Execution (by virtue of the 
d1385 2
a1386 2
    // if using optimization and a pipPriorityFile, then we need to load the 
    // pipPriorities from the WitRun into the localWitrun 
d1390 4
a1393 4
      int nParts, nDemands;  
      char ** partList, ** demList; 
      int i, j;            
    
d1398 27
a1424 27
      for (i=0; i<nParts; i++)  { 
	witGetPartDemands(localWitRun_, partList[i], &nDemands, &demList);
	for (j=0; j<nDemands; j++) {
	  // get it From AppData !!
	  int * priority;
	  witGetDemandPriority(localWitRun_, partList[i], demList[j], &priority);
	  LgFrTimeVecFloat pipPriority(nPeriods, 0.0);
	  int t;
	  for (t=0; t<nPeriods; t++)
	    pipPriority[t] = (float) priority[t];
	  witFree(priority);
	  
	  LgFrSceDemandAppData * demandAppDataPtr;
	  witGetDemandAppData(originalWitRun_,
			      partList[i], 
			      demList[j],
			      (void **) &demandAppDataPtr);
	  
	  // If the demandAppDataPtr has been set, see if the pipPriority has been set.
	  if (demandAppDataPtr != 0)  {
	    pipPriority = demandAppDataPtr->pipPriority();
	  }
	  witSetDemandPriority(localWitRun_, partList[i], demList[j], pipPriority.intData());
	  witFree(demList[j]);
	}
	witFree(partList[i]);
	witFree(demList);
a1428 1
    
d1431 2
a1432 1
  
d1434 1
a1434 1
  // STEP 4: Do Robin's split BOP thing 
d1445 1
a1445 1
  
d1447 1
a1447 1
  
d1457 1
a1457 1
  
d1459 1
a1459 1
  
d1461 1
a1461 1
  
d1465 1
a1465 1
    
d1473 1
a1473 1
      
d1475 1
a1475 1
      // + are shut off via effectivity dates. 
d1477 5
a1481 5
	
	if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
	  witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
	  witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
	}
d1484 2
a1485 2
	  witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
	  witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
d1489 1
a1489 1
    
d1493 1
a1493 1
    
d1503 1
a1503 1
// + (1.5) set expAversion 
d1506 1
a1506 1
// + (3) Make capacity non-gating by addding a dummy operation to 
d1517 1
a1517 1
  int o = 0; 
d1520 1
a1520 1
  witGetOperations(localWitRun(), &nOps, &opList);  
d1523 1
a1523 1
  int i = 0; 
d1539 1
a1539 1
      
d1543 6
a1548 6
      // this snippet of code is looking for any situations where 
      // a part might possibly be unexplodeable.   In particular, when 
      //  a Normal Part has more than one producing BOP.  In this case, 
      // the default BOP has been shut off and the other BOPs (interplant, 
      // aggregation, userDefinedOp, ...) 
      // when the 
d1555 2
a1556 2
	continue;
    
d1559 1
a1559 1
    
d1564 1
a1564 1
	continue;
d1566 1
a1566 1
    
d1571 24
a1594 24
	
	// find bopEntryIndex for default operation
	bool didWefindBopEntryForDefaultOperation = false;
	
	int p = 0; 
	for (p=0; p<npBops; p++) { // p = prodIndex
	  char * opName;
	  int bopEntryIndex;
	  witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);
	  
	  if (defaultOperationName == opName) {
	    // Note: at this time there should only be one
	    // bop entry for the default part
	    assert(didWefindBopEntryForDefaultOperation == false);
	    didWefindBopEntryForDefaultOperation = true;
	    witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE ); 
	    witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 ); 
	    witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 ); 
	    witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 ); 
	  }
	  witFree(opName);
	}
	// make sure you found a bop entry for default to shut off
	assert(didWefindBopEntryForDefaultOperation == true );
a1596 1
    
d1598 2
a1599 1
  
d1604 1
a1604 1
      
d1610 1
a1610 1
      
d1612 2
a1613 2
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);    
      int t = 0; 
d1615 1
a1615 1
	yieldRate[t] = 1.0;
d1619 2
a1620 2
      
      
d1627 1
a1627 1
      int b = 0; 
d1629 8
a1636 8
	witGetBopEntryProducedPart(localWitRun(), defaultOperation.c_str(), b, &producedPart);
	if (producedPart == defaultOperation) {
	  defaultOperationFound = 1;
	  witSetBopEntryExpAllowed(localWitRun(), defaultOperation.c_str(), b, WitTRUE);            
	  witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation.c_str(), b, 0);
	  witSetBopEntryLatestPeriod(localWitRun(), defaultOperation.c_str(), b, nPeriods()-1);
	}
	witFree(producedPart);
d1639 2
a1640 2
	std::cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
		  << "PCF: " << defaultOperation << "\n\n";
d1642 2
a1643 2
    } 
    
d1657 1
a1657 1
    
d1666 1
a1666 1
	witSetOperationYieldRate(localWitRun_, capGeneratorOperationName.c_str(),unitYieldRate.data());
d1669 2
a1670 2
	std::cout << "Found a capacity that doesn't have a capGeneratorOperation:" 
		  << theCapacity.c_str << std::endl;
d1681 1
a1681 1
    } 
d1683 4
a1686 4
 #endif  
  
  // free the parts 
  for (i=0; i<nParts; i++)  
d1690 1
a1690 1
  // free the Operations 
d1692 1
a1692 1
  for (o=0; o<nOps; o++)  
d1695 1
a1695 1
  
d1715 1
a1715 1
  // set forcedEquitability parameter in wit. 
d1725 1
a1725 1
  
d1737 1
a1737 1
  
d1739 1
a1739 1
  
d1741 1
a1741 1
  
d1745 1
a1745 1
    
d1753 16
a1768 16
	
	witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);
      
	// + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
	// + are shut off via effectivity dates. 
	if (appDataPtr != 0) {
	  
	  if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
	    witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
	    witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
	  }
	}
	else {
	  witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
	  witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
	}
d1772 1
a1772 1
    
d1776 1
a1776 1
    
d1780 1
a1780 1
  
d1792 1
a1792 1
  // + 3) Make any unexplodeable NON-PCF parts explodeable 
d1794 2
a1795 2
  // +       we need to correct for that by copying back the orginal yieldRates from original 
  // +       originalWitRun.   This can go away if we ever get away from wit34Comapatible mode 
d1799 1
a1799 1
  int o = 0; 
d1805 1
a1805 1
  witGetOperations(localWitRun(), &nOps, &opList);  
d1815 2
a1816 2
    } 
    
d1826 1
a1826 1
      
d1828 2
a1829 2
      witGetOperationYieldRate(localWitRun(), theOperation.c_str(), &yieldRate);    
      int t = 0; 
d1831 1
a1831 1
	yieldRate[t] = 1.0;
d1835 2
a1836 2
      
      
d1843 1
a1843 1
      int b = 0; 
d1845 8
a1852 8
	witGetBopEntryProducedPart(localWitRun(), theOperation.c_str(), b, &producedPart);
	if (producedPart == theOperation) {
	  defaultOperationFound = 1;
	  witSetBopEntryExpAllowed(localWitRun(), theOperation.c_str(), b, WitTRUE);            
	  witSetBopEntryEarliestPeriod(localWitRun(), theOperation.c_str(), b, 0);
	  witSetBopEntryLatestPeriod(localWitRun(), theOperation.c_str(), b, nPeriods()-1);
	}
	witFree(producedPart);
d1855 2
a1856 2
    } 
    
d1860 5
a1864 5
  
  
  // + 3) Loop Through Parts.   
  //       a) manually truncate wit34 cycletimes.   
  //       b) Make any unexplodeable, multi-bop'd,  NON-PCF parts explodeable 
d1870 3
a1872 3
  
  // Loop through all the Normal parts ... 
  int i = 0; 
d1881 1
a1881 1
    if (category == WitMATERIAL) {
d1883 1
a1883 1
      // tuncate the cycleTimes, so these things can explode in early periods.   Since cycletime is a 
d1889 2
d1892 1
a1892 1
	localCycleTime[ttt]=ttt;
d1905 5
a1909 5
    // In particular, when 
    //  a Normal Part has more than one producing BOP.  In this case, 
    // the default BOP has been shut off and the other BOPs (interplant, 
    // aggregation, userDefinedOp, ...) 
    // when the 
d1917 2
a1918 2
	continue;
    
d1921 1
a1921 1
    
d1926 1
a1926 1
	continue;
d1928 1
a1928 1
    
d1933 26
a1958 26
	
	// find bopEntryIndex for default operation
	bool didWefindBopEntryForDefaultOperation = false;
	
	int p = 0; 
	for (p=0; p<npBops; p++) { // p = prodIndex
	  char * opName;
	  int bopEntryIndex;
	  witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);
	  
	  if (defaultOperationName == opName) {
	    // Note: at this time there should only be one
	    // bop entry for the default part
	    assert(didWefindBopEntryForDefaultOperation == false);
	    didWefindBopEntryForDefaultOperation = true;
	    witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE ); 
	    witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 ); 
	    witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 ); 
	    witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 ); 
	  }
	  // for 4.20: we now set execPenalty to very high number
	  witSetOperationExecPenalty(localWitRun(), defaultOperationName.c_str(), 88888.8);
	  witFree(opName);
	}
	// make sure you found a bop entry for default to shut off
	assert(didWefindBopEntryForDefaultOperation == true );
d1992 1
a1992 1
  
d1994 1
a1994 1
  
d1996 1
a1996 1
    LgFrScePartAppData * partAppDataPtr;    
d2006 1
a2006 1
      int t = 0; 
d2026 2
a2027 2
  if (exists(part)) 
    witGetPartConsVol(localWitRun(), part.c_str(), mrpConsVolPtr);    
d2031 1
a2031 1
  
d2044 1
a2044 1
  if (exists(part)) 
d2057 1
a2057 1
  if (exists(part)) 
d2075 1
a2075 1
      LgFrScePartAppData * partAppDataPtr;    
d2078 1
a2078 1
        int t = 0; 
d2130 1
a2130 1
  int i = 0; 
d2136 1
a2136 1
    float * mrpConsVol;    
d2138 3
a2140 3
    outFile << "\"" << thePart << "\", mrpConsVol\" ";    
    int t = 0; 
    for (t=0; t<nPeriods(); t++) 
d2149 1
a2149 1
    for (t=0; t<nPeriods(); t++) 
d2159 1
a2159 1
    for (t=0; t<nPeriods(); t++) 
d2168 1
a2168 1
    for (t=0; t<nPeriods(); t++) 
d2173 1
a2173 1
    
d2175 1
a2175 1
    this->reqVol(thePart, &reqVol);        
d2177 1
a2177 1
    for (t=0; t<nPeriods(); t++) 
d2188 1
a2188 1
  
d2198 1
a2198 1
void 
d2208 1
a2208 1
  int t = 0; 
d2211 2
a2212 2
  
  int i = 0; 
d2231 1
a2231 1
void 
d2241 1
a2241 1
  int t = 0; 
d2244 2
a2245 2
  
  int i = 0; 
d2250 1
a2250 1
    int j = 0; 
d2253 1
a2253 1
      witFree(dlist[j]);      
d2283 1
a2283 1
  
d2310 2
a2311 2
  
  int i = 0; 
d2321 1
a2321 1
    int j = 0; 
d2335 1
a2335 1
  
@


1.31.2.1
log
@Rev 06 changes ... on production branch
@
text
@d80 1
a80 1
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;
d84 1
a84 1
    if (setOfParameters_->getBool("printWitExplodeMsgFile"))
d90 1
a90 1
  // run the mrp on the localWitRun
d93 1
a93 1

d95 1
a95 1

d112 1
a112 1
  witGetPartExists(localWitRun_, part.c_str(), &exists);
d122 1
a122 1
  if (exists(part))
d134 1
a134 1
  if (exists(part))
d148 1
a148 1
  if (exists)
d153 1
a153 1
}
d163 1
a163 1
  if (exists(part))
d168 1
a168 1

d177 1
a177 1
  if (exists(part))
d188 3
a190 3
  if (exists(part))
    witGetPartMrpConsVol(localWitRun_, part.c_str(), mrpConsVolPtr);
  else
d220 1
a220 1
  int t = 0;
d229 1
a229 1
  int t = 0;
d244 2
a245 2


d254 1
a254 1
    nPeriods_ (0),
d272 1
a272 1
    nPeriods_ (0),
d280 1
a280 1

d287 1
a287 1

d330 1
a330 1

d341 1
a341 1
  // nothing to be done
d350 1
a350 1

d374 2
a375 2
  std::string witExplodeMsgFileExtension = setOfParameters->getString("witExplodeMsgFileExtension");

d381 1
a381 1
  if (setOfParameters->getBool("printWitExplodeMsgFile"))
d391 1
a391 1

d401 1
a401 1

d403 2
a404 2

  //
d411 1
a411 1

d419 1
a419 1
// +      be adjusted for the explosion calculation to work.   This modification
d435 1
a435 1
  int i = 0;
d443 2
a444 2
      LgFrTimeVecFloat supplyAdjust(mpHelper()->custChoiceDummySupplyVolForMrpAdjustment(originalWitRun_,
                                                                                        thePart));
d456 3
a458 3

  // free the parts
  for (i=0; i<nParts; i++)
d467 3
a469 3
void
LgFrSceBaseExploder::setWitInformationalMessagingExpl(WitRun * const theWitRun,
                                                  int onOrOff)
d476 1
a476 1
    witSetMesgTimesPrint(theWitRun, WitTRUE, WitWARNING_MESSAGES, 1);
d480 3
a482 3
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);
  }
d486 1
a486 1
    // turn all WARNINGS on
d489 2
a490 2
    witSetMesgTimesPrint(theWitRun, WitTRUE, 538, 0);
    witSetMesgTimesPrint(theWitRun, WitTRUE, 505, 0);
d494 1
a494 1

d520 1
a520 1

d522 1
a522 1

d528 1
a528 1
    if (objItrState ==  WitAT_PART) {
d545 1
a545 1

d581 1
a581 1

d586 1
a586 1
    else
d588 1
a588 1

d604 1
a604 1
// +      Use object iteration to clone all the appData objects
d612 1
a612 1

d618 1
a618 1

d621 1
a621 1

d623 1
a623 1

d626 1
a626 1

d628 2
a629 2

    if (objItrState ==  WitAT_PART) {
d634 2
a635 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetPartAppData(localWitRun_, partName, (void *) cloneAppDataPtr);
d639 2
a640 2

    else if (objItrState == WitAT_DEMAND) {
d646 2
a647 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetDemandAppData(localWitRun_, partName, demandName, (void *) cloneAppDataPtr);
d652 1
a652 1

d658 2
a659 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetOperationAppData(localWitRun_, opName, (void *) cloneAppDataPtr);
d670 2
a671 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetBomEntryAppData(localWitRun_, opName, b, (void *) cloneAppDataPtr);
d683 2
a684 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetSubsBomEntryAppData(localWitRun_, opName, b, s, (void *) cloneAppDataPtr);
d695 2
a696 2
        cloneAppDataPtr = appDataPtr->clone();
        witSetBopEntryAppData(localWitRun_, opName, bp, (void *) cloneAppDataPtr);
d701 1
a701 1
    else if (objItrState == WitINACTIVE)
d704 1
a704 1
    else
d708 1
a708 1

d748 1
a748 1
  return myExploder_->mrpExcessVol(part, mrpExcessVol);
d755 1
a755 1
  return myExploder_->mrpResidualVol(part, mrpResidualVol);
d762 1
a762 1
  return myExploder_->reqVol(part, reqVolPtr);
d768 1
a768 1
  return myExploder_->mrpConsVol(part, mrpConsVolPtr);
d774 1
a774 1
  return myExploder_->mrpExecVol(operation, mrpExecVolPtr);
d788 1
a788 1

d792 2
a793 2


d805 2
a806 2


d907 1
a907 1

d910 1
a910 1
// + class LgFrSceFullExploderDecorator
d942 2
a943 2


d947 1
a947 1
  // do nothing.  The decorator base class deletes myExploder_
d957 3
a959 3



d971 1
a971 1
  witGetOperations(theWitRun(), &nOps, &opList);
d979 1
a979 1
  int o = 0;
d983 2
a984 2

    if (mpHelper_->isOperationForCapacityGeneration(localWitRun_, opList[o], theC, theP))
d993 2
a994 2
  // free the Operations
  for (o=0; o<nOps; o++)
d1005 1
a1005 1

d1010 2
a1011 2


d1013 1
a1013 1
    int i = 0;
d1016 1
a1016 1

d1020 2
a1021 2
        continue;

d1023 2
a1024 2
        continue;

d1026 1
a1026 1

d1032 3
a1034 3
        std::cerr << "TEMP_ERROR2: Default Operation for PCF not found in exploder\n"
             << "PCF: " << defaultOperation << "\n\n";
      }
d1037 1
a1037 1
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);
d1040 1
a1040 1
        yieldRate[t] = 1.0;
d1045 4
a1048 4


    // free the parts
    for (i=0; i<nParts; i++)
d1052 1
a1052 1

d1056 1
a1056 1
// + class LgFrSceSmartExploderDecorator
d1061 1
a1061 1
// +        -
d1082 1
a1082 1
  std::cout << "Writing the (mrp) wit data file ..." << std::endl;
d1086 1
a1086 1
  if (setOfParameters_->getBool("printWitExplodeMsgFile"))
d1091 1
a1091 1

d1099 2
a1100 2
  bool  usePrioritizedExplodeUtility = setOfParameters_->getBool("usePrioritizedExplodeUtility");
  std::string  usageName("explosion");
d1106 1
a1106 1
    LgFrSceCritList & theCritList = sceScenSP_->sceCritList();
d1108 3
a1110 3
                                               localWitRun_,
                                               mpHelper_,
                                               usageName);
d1117 1
a1117 1
    witPostprocess (localWitRun_ );
d1123 1
a1123 1

d1128 1
a1128 1

d1149 2
a1150 2
  std::cout << "... collecting PIP information for MRP ..." << std::endl;

d1160 1
a1160 1
  int i = 0;
d1166 1
a1166 1
    int j = 0;
d1171 1
a1171 1
      // if the part is a special feature part, then we must map the consVol over to
d1176 1
a1176 1
        isDemandSpecial = mpHelper_->isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
d1178 1
a1178 1

d1185 2
a1186 2
        // get a witPartName for the GPD
        fullWitGPDPartName = mpHelper_->geoPlannerDemandPartName(pp, geo);
d1188 8
a1195 8
        witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
                           (void **) &demandAppDataPtr );
        if ( demandAppDataPtr == 0 ) {
          demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
          assert ( demandAppDataPtr != 0 );
          witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
                               (void *) demandAppDataPtr );
        }
d1198 8
a1205 8
        witGetDemandAppData( theWitRun, partName, demandName,
                             (void **) &demandAppDataPtr );
        if ( demandAppDataPtr == 0 ) {
          demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
          assert ( demandAppDataPtr != 0 );
          witSetDemandAppData( theWitRun, partName, demandName,
                               (void *) demandAppDataPtr );
        }
d1209 1
a1209 1

d1211 3
a1213 3
        std::cout << "specialDemand, being REPORTED..." << std::endl;
        std::cout << "PIP supply is being reported for: "
             << fullWitGPDPartName << " at geo " << geo << std::endl;
d1215 1
a1215 1

d1225 7
a1231 7
                                  partList[i],
                                  dList[j],
                                  0,
                                  nPeriods-1,
                                  demandAppDataPtr->PIPConsVolSched(),
                                  WitTRUE,
                                  PegSubUsageToPrimary);
d1236 5
a1240 5
                              partList[i],
                              dList[j],
                              0,
                              nPeriods-1,
                              demandAppDataPtr->PIPSupplyVolSched());
d1244 5
a1248 5
                                          partList[i],
                                          dList[j],
                                          0,
                                          nPeriods-1,
                                          demandAppDataPtr->PIPExecVolSched());
d1266 2
a1267 2
                                                             LgFrScenarioForSceSmartPointer sceScenSP,
                                                             LgFrMultiPlantHelper * mpHelper)
d1275 1
a1275 1
  else
d1290 1
a1290 1

d1302 1
a1302 1
  int o = 0;
d1307 1
a1307 1
    int j = 0;
d1310 2
a1311 2
      int s = 0;
      for (s=0; s<nSubBoms; s++) {
d1318 1
a1318 1

d1332 2
a1333 2


d1342 1
a1342 1
  // set forcedEquitability parameter in wit.
d1352 1
a1352 1

d1357 1
a1357 1
  // FINISH_ME: this is a bit kludgy.   If we are doing Penalized Execution (by virtue of the
d1385 2
a1386 2
    // if using optimization and a pipPriorityFile, then we need to load the
    // pipPriorities from the WitRun into the localWitrun
d1390 4
a1393 4
      int nParts, nDemands;
      char ** partList, ** demList;
      int i, j;

d1398 27
a1424 27
      for (i=0; i<nParts; i++)  {
        witGetPartDemands(localWitRun_, partList[i], &nDemands, &demList);
        for (j=0; j<nDemands; j++) {
          // get it From AppData !!
          int * priority;
          witGetDemandPriority(localWitRun_, partList[i], demList[j], &priority);
          LgFrTimeVecFloat pipPriority(nPeriods, 0.0);
          int t;
          for (t=0; t<nPeriods; t++)
            pipPriority[t] = (float) priority[t];
          witFree(priority);

          LgFrSceDemandAppData * demandAppDataPtr;
          witGetDemandAppData(originalWitRun_,
                              partList[i],
                              demList[j],
                              (void **) &demandAppDataPtr);

          // If the demandAppDataPtr has been set, see if the pipPriority has been set.
          if (demandAppDataPtr != 0)  {
            pipPriority = demandAppDataPtr->pipPriority();
          }
          witSetDemandPriority(localWitRun_, partList[i], demList[j], pipPriority.intData());
          witFree(demList[j]);
        }
        witFree(partList[i]);
        witFree(demList);
d1429 1
d1432 1
a1432 2


d1434 1
a1434 1
  // STEP 4: Do Robin's split BOP thing
d1445 1
a1445 1

d1447 1
a1447 1

d1457 1
a1457 1

d1459 1
a1459 1

d1461 1
a1461 1

d1465 1
a1465 1

d1473 1
a1473 1

d1475 1
a1475 1
      // + are shut off via effectivity dates.
d1477 5
a1481 5

        if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
        }
d1484 2
a1485 2
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
d1489 1
a1489 1

d1493 1
a1493 1

d1503 1
a1503 1
// + (1.5) set expAversion
d1506 1
a1506 1
// + (3) Make capacity non-gating by addding a dummy operation to
d1517 1
a1517 1
  int o = 0;
d1520 1
a1520 1
  witGetOperations(localWitRun(), &nOps, &opList);
d1523 1
a1523 1
  int i = 0;
d1539 1
a1539 1

d1543 6
a1548 6
      // this snippet of code is looking for any situations where
      // a part might possibly be unexplodeable.   In particular, when
      //  a Normal Part has more than one producing BOP.  In this case,
      // the default BOP has been shut off and the other BOPs (interplant,
      // aggregation, userDefinedOp, ...)
      // when the
d1555 2
a1556 2
        continue;

d1559 1
a1559 1

d1564 1
a1564 1
        continue;
d1566 1
a1566 1

d1571 24
a1594 24

        // find bopEntryIndex for default operation
        bool didWefindBopEntryForDefaultOperation = false;

        int p = 0;
        for (p=0; p<npBops; p++) { // p = prodIndex
          char * opName;
          int bopEntryIndex;
          witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);

          if (defaultOperationName == opName) {
            // Note: at this time there should only be one
            // bop entry for the default part
            assert(didWefindBopEntryForDefaultOperation == false);
            didWefindBopEntryForDefaultOperation = true;
            witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE );
            witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 );
            witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 );
            witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 );
          }
          witFree(opName);
        }
        // make sure you found a bop entry for default to shut off
        assert(didWefindBopEntryForDefaultOperation == true );
d1597 1
d1599 1
a1599 2


d1604 1
a1604 1

d1610 1
a1610 1

d1612 2
a1613 2
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);
      int t = 0;
d1615 1
a1615 1
        yieldRate[t] = 1.0;
d1619 2
a1620 2


d1627 1
a1627 1
      int b = 0;
d1629 8
a1636 8
        witGetBopEntryProducedPart(localWitRun(), defaultOperation.c_str(), b, &producedPart);
        if (producedPart == defaultOperation) {
          defaultOperationFound = 1;
          witSetBopEntryExpAllowed(localWitRun(), defaultOperation.c_str(), b, WitTRUE);
          witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation.c_str(), b, 0);
          witSetBopEntryLatestPeriod(localWitRun(), defaultOperation.c_str(), b, nPeriods()-1);
        }
        witFree(producedPart);
d1639 2
a1640 2
        std::cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
                  << "PCF: " << defaultOperation << "\n\n";
d1642 2
a1643 2
    }

d1657 1
a1657 1

d1666 1
a1666 1
        witSetOperationYieldRate(localWitRun_, capGeneratorOperationName.c_str(),unitYieldRate.data());
d1669 2
a1670 2
        std::cout << "Found a capacity that doesn't have a capGeneratorOperation:"
                  << theCapacity.c_str << std::endl;
d1681 1
a1681 1
    }
d1683 4
a1686 4
 #endif

  // free the parts
  for (i=0; i<nParts; i++)
d1690 1
a1690 1
  // free the Operations
d1692 1
a1692 1
  for (o=0; o<nOps; o++)
d1695 1
a1695 1

d1715 1
a1715 1
  // set forcedEquitability parameter in wit.
d1725 1
a1725 1

d1737 1
a1737 1

d1739 1
a1739 1

d1741 1
a1741 1

d1745 1
a1745 1

d1753 16
a1768 16

        witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);

        // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
        // + are shut off via effectivity dates.
        if (appDataPtr != 0) {

          if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
            witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
            witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
          }
        }
        else {
          witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
          witSetSubsBomEntryNetAllowed(localWitRun_, opName, b, s, WitFALSE);
        }
d1772 1
a1772 1

d1776 1
a1776 1

d1780 1
a1780 1

d1792 1
a1792 1
  // + 3) Make any unexplodeable NON-PCF parts explodeable
d1794 2
a1795 2
  // +       we need to correct for that by copying back the orginal yieldRates from original
  // +       originalWitRun.   This can go away if we ever get away from wit34Comapatible mode
d1799 1
a1799 1
  int o = 0;
d1805 1
a1805 1
  witGetOperations(localWitRun(), &nOps, &opList);
d1815 2
a1816 2
    }

d1826 1
a1826 1

d1828 2
a1829 2
      witGetOperationYieldRate(localWitRun(), theOperation.c_str(), &yieldRate);
      int t = 0;
d1831 1
a1831 1
        yieldRate[t] = 1.0;
d1835 2
a1836 2


d1843 1
a1843 1
      int b = 0;
d1845 8
a1852 8
        witGetBopEntryProducedPart(localWitRun(), theOperation.c_str(), b, &producedPart);
        if (producedPart == theOperation) {
          defaultOperationFound = 1;
          witSetBopEntryExpAllowed(localWitRun(), theOperation.c_str(), b, WitTRUE);
          witSetBopEntryEarliestPeriod(localWitRun(), theOperation.c_str(), b, 0);
          witSetBopEntryLatestPeriod(localWitRun(), theOperation.c_str(), b, nPeriods()-1);
        }
        witFree(producedPart);
d1855 2
a1856 2
    }

d1860 5
a1864 5


  // + 3) Loop Through Parts.
  //       a) manually truncate wit34 cycletimes.
  //       b) Make any unexplodeable, multi-bop'd,  NON-PCF parts explodeable
d1870 3
a1872 3

  // Loop through all the Normal parts ...
  int i = 0;
d1881 1
a1881 1
    if (category == WitPRODUCT) {
d1883 1
a1883 1
      // tuncate the cycleTimes, so these things can explode in early periods.   Since cycletime is a
a1888 2
      if (cyMax >= nPeriods() -1)
         cyMax = nPeriods() -1;
d1890 1
a1890 1
        localCycleTime[ttt]=ttt;
d1903 5
a1907 5
    // In particular, when
    //  a Normal Part has more than one producing BOP.  In this case,
    // the default BOP has been shut off and the other BOPs (interplant,
    // aggregation, userDefinedOp, ...)
    // when the
d1915 2
a1916 2
        continue;

d1919 1
a1919 1

d1924 1
a1924 1
        continue;
d1926 1
a1926 1

d1931 26
a1956 26

        // find bopEntryIndex for default operation
        bool didWefindBopEntryForDefaultOperation = false;

        int p = 0;
        for (p=0; p<npBops; p++) { // p = prodIndex
          char * opName;
          int bopEntryIndex;
          witGetPartProducingBopEntry(localWitRun(), partList[i], p, &opName, &bopEntryIndex);

          if (defaultOperationName == opName) {
            // Note: at this time there should only be one
            // bop entry for the default part
            assert(didWefindBopEntryForDefaultOperation == false);
            didWefindBopEntryForDefaultOperation = true;
            witSetBopEntryExpAllowed(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, WitTRUE );
            witSetBopEntryEarliestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 0 );
            witSetBopEntryLatestPeriod(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, nPeriods()-1 );
            witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, 88888.8 );
          }
          // for 4.20: we now set execPenalty to very high number
          witSetOperationExecPenalty(localWitRun(), defaultOperationName.c_str(), 88888.8);
          witFree(opName);
        }
        // make sure you found a bop entry for default to shut off
        assert(didWefindBopEntryForDefaultOperation == true );
d1990 1
a1990 1

d1992 1
a1992 1

d1994 1
a1994 1
    LgFrScePartAppData * partAppDataPtr;
d2004 1
a2004 1
      int t = 0;
d2024 2
a2025 2
  if (exists(part))
    witGetPartConsVol(localWitRun(), part.c_str(), mrpConsVolPtr);
d2029 1
a2029 1

d2042 1
a2042 1
  if (exists(part))
d2055 1
a2055 1
  if (exists(part))
d2073 1
a2073 1
      LgFrScePartAppData * partAppDataPtr;
d2076 1
a2076 1
        int t = 0;
d2128 1
a2128 1
  int i = 0;
d2134 1
a2134 1
    float * mrpConsVol;
d2136 3
a2138 3
    outFile << "\"" << thePart << "\", mrpConsVol\" ";
    int t = 0;
    for (t=0; t<nPeriods(); t++)
d2147 1
a2147 1
    for (t=0; t<nPeriods(); t++)
d2157 1
a2157 1
    for (t=0; t<nPeriods(); t++)
d2166 1
a2166 1
    for (t=0; t<nPeriods(); t++)
d2171 1
a2171 1

d2173 1
a2173 1
    this->reqVol(thePart, &reqVol);
d2175 1
a2175 1
    for (t=0; t<nPeriods(); t++)
d2186 1
a2186 1

d2196 1
a2196 1
void
d2206 1
a2206 1
  int t = 0;
d2209 2
a2210 2

  int i = 0;
d2229 1
a2229 1
void
d2239 1
a2239 1
  int t = 0;
d2242 2
a2243 2

  int i = 0;
d2248 1
a2248 1
    int j = 0;
d2251 1
a2251 1
      witFree(dlist[j]);
d2281 1
a2281 1

d2308 2
a2309 2

  int i = 0;
d2319 1
a2319 1
    int j = 0;
d2333 1
a2333 1

@


1.30
log
@check partCategory before truncating cycleTime (bad for capacities)
@
text
@d395 6
@


1.29
log
@truncated wit34cycleTimes in exploder (for Prioritized Explode only)
@
text
@d1873 3
d1877 11
a1887 8
    // tuncate the cycleTimes, so these things can explode in early periods.   Since cycletime is a 
    // legacy of wit34, we must manually truncate them.   wit's truncateOffsets will not do it.
    float * localCycleTime;
    witGetPartCycleTime(localWitRun(), thePart, &localCycleTime);
    int ttt=0;
    int cyMax = ceil(localCycleTime[0]);
    for (ttt=0; ttt<=cyMax; ttt++) {
      localCycleTime[ttt]=ttt;
a1888 2
    witSetPartCycleTime(localWitRun(), thePart, localCycleTime);
    witFree(localCycleTime);
@


1.28
log
@minor mods
@
text
@d1811 1
a1811 1
    // + Make PCF parts are made explodeable via:
d1850 1
a1850 10


    // + 4) For all the rest, copy over yieldRates from original WitRun
    else {
      float * yieldRate;
      witGetOperationYieldRate(theWitRun(), theOperation.c_str(), &yieldRate);
      witSetOperationYieldRate(localWitRun(), theOperation.c_str(), yieldRate);
      witFree(yieldRate);
    }

d1854 7
a1860 5


  // + 3) Make any unexplodeable NON-PCF parts explodeable 
  //   FINISH_ME: this looks a bit wierd.   Review.
  // 4.20 
d1864 1
a1864 1

d1873 14
@


1.27
log
@bug converting from usageTime to offset.   Also bug fix: need to disable subBom for all subs with noApp data
@
text
@d1288 2
d1316 1
d1474 1
d1479 1
d1726 47
a1772 1
  this->disableSubBomAccordingToAppData();
d1867 1
d1934 2
@


1.26
log
@turn off witSetPenExec in non proritized explode exploder witruns
@
text
@a1461 8
      // only work on Normal sub parts (don't muck with the modelling tricks).
      char * subPart;
      witGetSubsBomEntryConsumedPart(localWitRun(), opName, b, s, &subPart);
      if (! mpHelper_->isPartNormal(theWitRun(), subPart)) {
	witFree(subPart);
	continue;
      }
      witFree(subPart);
@


1.25
log
@removed the "binning" stuff which is now obsolete
@
text
@d1348 7
a1354 1
  //  witSetPenExec(localWitRun_, WitFALSE);
@


1.24
log
@incorrectly mapped fallout to falloutRate when we got rid of witAddxxxVa
@
text
@a1694 1
#ifdef HEUR_ALLOC_EXPLODE
a1899 8
#endif







@


1.23
log
@incorrectly mapped fallout to falloutRate when we got rid of witAddxxxVa
@
text
@d391 1
a391 1

d395 1
a395 1

d397 2
a398 1

a421 4
  int nOps;
  char ** opList;
  witGetOperations(originalWitRun_, &nOps, &opList);  

a426 25
  //      --- products only ----
  float * cycleTime;

  // ========= Operation Attributes  ==========
  float * incLotSize;
  float * minLotSize;
  float   * yieldRate;
  

  // ========= BOM attributes ===========
  char * child;
  float usageRate;
  float * offset;
  int fallout;
  witBoolean mandEC;
  int early;
  int late;

  // ========= BOP attributes ==================
  char * producedPart;
  // witBoolean byproduct;
  float prodRate;

  // ==========  Demand attributes =============
  float * demandVol;
a458 18


















d1351 1
a1351 1
  // STEP 2: Copy over more stuff from the original 
a1352 3
  // Copy over all the subBom records

  //  this->copyMoreStuffOver();
a1490 95
void
LgFrSceSmartExploderDecorator::copyMoreStuffOver()
{

  // + Modelling trick for Smart Exploder:  Substituion.
  // + Copy the SubBom records into the LocalwitRun
  // + make sure that the ones that are NOT ALLOWED to be used are 
  // + effectively nullified.  The reason all subs are copeid into the 
  // + witRun is because it is MUCH easier to deploy.  There are all sorts
  // + bookkeeping complexities to deal with when the witRuns are not
  // + structurally, duplicates.  For example, if a part is ommitted
  // + from the local witrun, then the bom indexing gets all whacked out
  // + for the parents of that omitted part.  Its even more complex for
  // + subboms since they depend on double indexing.
  // +
  // + So, at the expense of having an unnecessarily large exploder witRun,
  // + we make life much easier ...

  int nOps;
  char ** opList;
  witGetOperations(localWitRun(), &nOps, &opList);  


  // Now loop over the operations ...
  int o = 0; 
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];

      
    // -----------------------------
    // Nullify any subboms based on app data
    // -----------------------------    
    int nBom;
    witGetOperationNBomEntries(originalWitRun_, theOperation, &nBom);
    int j = 0; 
    for (j=0; j<nBom; j++) {
      // get ...
      char * child;
      witGetBomEntryConsumedPart(originalWitRun_, theOperation, j, &child);

      // check for existence of the child, first
      witBoolean exists;
      witGetPartExists(originalWitRun_, child, &exists);
      assert(exists);

      int nSubs;
      witGetBomEntryNSubsBomEntries(originalWitRun_, theOperation, j, &nSubs);
      int s = 0; 
      for (s=0; s<nSubs; s++) {
        LgFrSceSubBomAppData * appDataPtr;
        char * sub;
        int fallout;
        int early;
        int late;
        float usageRate;
        witGetSubsBomEntryAppData(originalWitRun_, theOperation, j, s, (void **) &appDataPtr);
        witGetSubsBomEntryConsumedPart(originalWitRun_, theOperation, j, s, &sub);
        witGetSubsBomEntryEarliestPeriod(originalWitRun_, theOperation, j, s, &early);
        witGetSubsBomEntryLatestPeriod(originalWitRun_, theOperation, j, s, &late);
        witGetSubsBomEntryFallout(originalWitRun_, theOperation, j, s, &fallout);
        witGetSubsBomEntryUsageRate(originalWitRun_, theOperation, j, s, &usageRate);


        // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
        // + are added to the localWitRun by Smart Exploder decorator.  HOWEVER, they are shut
        // + via effectivity dates.  FINISH_ME: this does not work for 1 period models.
        if (appDataPtr != 0) {
          if (! appDataPtr->isObjectInEffectForOptExplosion()) {
            late = 0;
            early = nPeriods_ - 1;
          }
          LgFrSceSubBomAppData * newAppDataPtr = new LgFrSceSubBomAppData(*appDataPtr);
          witSetSubsBomEntryAppData(localWitRun_, theOperation, j, s, (void *) newAppDataPtr);
        }
        else {
          late = 0;
          early = nPeriods_ - 1;
        }
            
        witSetSubsBomEntryEarliestPeriod(localWitRun_, theOperation, j, s, early);
        witSetSubsBomEntryLatestPeriod(localWitRun_, theOperation, j, s, late);
        witSetSubsBomEntryFallout(localWitRun_, theOperation, j, s, fallout);
        witSetSubsBomEntryUsageRate(localWitRun_, theOperation, j, s, usageRate);
        witFree(sub);
      }
      witFree(child);
    }
  }
      
  // free the Operations 
  for (o=0; o<nOps; o++)  
    witFree(opList[o]);
  witFree(opList);
}

@


1.22
log
@First pass at sce 4.20 function.
@
text
@d1401 2
a1402 1
  this->copyMoreStuffOver();
d1487 54
d1868 1
a1868 32
  // ----------------------------------------------
  // STEP 2: Copy over more stuff from the originalwitRun
  // ----------------------------------------------
  //  this->copyMoreStuffOver();
  // yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
  // Nullify any subboms based on app data
  // yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
  
  witAttr objItrState;
  witResetObjItr(originalWitRun_);
  
  LgFrSceAppData * appDataPtr;
  
  witBoolean areWeDoneYet = WitFALSE;
  
  while ( ! areWeDoneYet) {
    witAdvanceObjItr(localWitRun_);
    witGetObjItrState(localWitRun_, &objItrState);
    
    if (objItrState == WitAT_SUB_ENTRY) {
      char * opName;
      int b, s;
      witGetObjItrSubsBomEntry(localWitRun_, &opName, &b, &s);

      // only work on Normal sub parts (don't muck with the modelling tricks).
      char * subPart;
      witGetSubsBomEntryConsumedPart(localWitRun(), opName, b, s, &subPart);
      if (! mpHelper_->isPartNormal(theWitRun(), subPart)) {
	witFree(subPart);
	continue;
      }
      witFree(subPart);
a1869 21
      witGetSubsBomEntryAppData(localWitRun_, opName, b, s, (void **) &appDataPtr);
      
      // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
      // + are shut off via effectivity dates. 
      if (appDataPtr != 0) {
	
	if (! ((LgFrSceSubBomAppData *) appDataPtr)->isObjectInEffectForOptExplosion()) {
	  witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
	}
      }
      else {
	  witSetSubsBomEntryEarliestPeriod(localWitRun_, opName, b, s, nPeriods());
      }
      witFree(opName);
    }
    
    if (objItrState == WitINACTIVE) {
      areWeDoneYet = WitTRUE;
    }
    
  }
@


1.21
log
@4.20 commit: global subs, prioritized explode
@
text
@d389 2
a390 1
  witSetMultiRoute(localWitRun_, WitTRUE);
d392 3
a394 2
  // strictly 4.0 mode
  witSetWit34Compatible(localWitRun_, WitFALSE);
d396 1
d398 3
a400 18
  // ----------------------------
  // STEP 2: Copy over the witRun
  // ----------------------------  
  // This  is a not-too-terribly-complicated copy of the witRun.
  // Here are some key points:
  //    1) some parts are fitlered out (special maxwithout nullsubs)
  //    2) Because some parts are missing, we need to be real careful
  //       about copying bom's, bop's. and subbom's.  We must also
  //       be careful about indexing, since bop j does not necessarily
  //       correspond to bop j in the copy because you may not have copied
  //       bop j-i, say.
  //    3) Only do what is necessary for standard witMRP.  
  //    3) Any bop preferences or subbom preferences are ignored.
  //    4) NO Sub boms are copied
  //    5) All BOP byProduct flags are set to false.  they will be
  //       reset in step 3 when preferences are considered.
  this->smartCopyData();

d407 98
a547 3
  int nParts;
  char ** partList;
  witGetParts(localWitRun_, &nParts, &partList);
d549 9
a557 3
  int nOps;
  char ** opList;
  witGetOperations(localWitRun_, &nOps, &opList);  
d559 1
d561 51
a611 10
  // Delete appData's
  int i = 0; 
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];
    
    // delete the part appData
    LgFrScePartAppData * appDataPtr;
    witGetPartAppData(localWitRun_, thePart, (void **) &appDataPtr);
    delete appDataPtr;
  }
d613 7
a619 11
  // delete bopAppData's
  int o = 0; 
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];
    int nbBops;
    witGetOperationNBopEntries(localWitRun_, theOperation, &nbBops);
    int b = 0; 
    for (b=0; b<nbBops; b++) {
      LgFrSceBopAppData * appData;
      witGetBopEntryAppData(localWitRun_, theOperation, b, (void **) &appData);
      delete appData;
a620 1
  }
d622 3
a624 5
    
  // free the parts 
  for (i=0; i<nParts; i++)  
    witFree(partList[i]);
  witFree(partList);
d626 4
a629 5
  // free the Operations 
  for (o=0; o<nOps; o++)  
    witFree(opList[o]);
  witFree(opList);
  
d634 1
d643 2
a644 15
// + LgFrSceExploder::smartCopyData:
// +      Modified Implementation:
// +      - Do NOT filter out anything while doing the witCopy (except for subs,
// +        which are added by SmartExplode decorator.
// +      - Then copy over all appData's
// +      - This is more space inefficient, but it makes life
// +      much easier!  this is because, if the witRuns get out
// +      of synch in terms of structure, then the bom and subbom
// +      and part indexing gets very difficult to manage.  Hence,
// +      we do the witCopy.
// +      
// +      Note: The decorators will need to modify the localWitRun as
// +      is necessary, and, for smart Exploder, it will be necessary
// +      to shut off certain thing
// +      
d646 1
a646 1
LgFrSceExploder::smartCopyData()
d649 3
d653 10
a662 20
  int nParts;
  char ** partList;
  witGetParts(originalWitRun_, &nParts, &partList);

  int nOps;
  char ** opList;
  witGetOperations(originalWitRun_, &nOps, &opList);  

  int nPeriods;
  witGetNPeriods(originalWitRun_, &nPeriods);

  // ========= part Attributes  ==========
  float * supplyVol;
  //      --- products only ----
  float * cycleTime;

  // ========= Operation Attributes  ==========
  float * incLotSize;
  float * minLotSize;
  float   * yieldRate;
d664 38
a701 41

  // ========= BOM attributes ===========
  char * child;
  float usageRate;
  float * offset;
  int fallout;
  witBoolean mandEC;
  int early;
  int late;

  // ========= BOP attributes ==================
  char * producedPart;
  // witBoolean byproduct;
  float prodRate;

  // ==========  Demand attributes =============
  float * demandVol;


  int i = 0; 
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];
    std::string sub(thePart);

    witAttr category34;
    witAttr category40;	
    witGetPartCategory(originalWitRun_, thePart, &category34);
    
	// rhs witrun is 3.4 and lhs is 4.0
	// need to convert  category to 4.0 
    if (category34 == WitPRODUCT || category34 == WitRAW )
      category40 = WitMATERIAL ;	
    else if (category34 == WitCAPACITY)
      category40 = WitCAPACITY;
    
    // copy the appData if there is one
    LgFrScePartAppData * appDataPtr;
    witGetPartAppData(originalWitRun_, thePart, (void **) &appDataPtr);
    if (appDataPtr != 0) {
      LgFrScePartAppData * newAppDataPtr = new LgFrScePartAppData(*appDataPtr);
      witSetPartAppData(localWitRun_, thePart, (void *) newAppDataPtr);
d704 10
a713 12
    // CUSTOMER_CHOICE_FEATURES
    // See Customer Feature Model documentation. It's kind of wierd.
    if (mpHelper()->isPartSpecialCustChoiceFeature(originalWitRun_, thePart)) {
      witGetPartSupplyVol(originalWitRun_, thePart, &supplyVol);
      LgFrTimeVecFloat supplyAdjust(mpHelper()->custChoiceDummySupplyVolForMrpAdjustment(originalWitRun_, 
											thePart));
      // We must add the supply adjust ot any existing suply for the specialCustChpoice part
      // An existing supply may be there due to Machine Feature Supply
      LgFrTimeVecFloat existingSupplyTVF(nPeriods, supplyVol);
      LgFrTimeVecFloat newSupplyTVF = supplyAdjust.op(existingSupplyTVF, LgFrAdd);
      witSetPartSupplyVol(localWitRun_, thePart, newSupplyTVF.data());
      witFree(supplyVol);
a714 1
    // END_CUSTOMER_CHOICE_FEATURES
a715 1
  }
d717 11
a727 4
  // Now loop over the operations ...
  int o = 0; 
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];
d729 8
a736 31
    // special considerations for operations:
    //    NONE (at this time).
    //   We will filter bop's based on the appData
    //   can we explode boolean.  AFter we do that
    //   We may determine that there are some default
    //    operations that should be turned back on for explosion.
  

    int nbBops;
    witGetOperationNBopEntries(originalWitRun_, theOperation, &nbBops);
    int b = 0; 
    for (b=0; b<nbBops; b++) {

        
      witGetBopEntryProducedPart(originalWitRun_, theOperation, b, &producedPart);
      // make sure the produced part exists before adding a bop entry.
      // It must exists based on the new implementation!!
      assert(exists(producedPart));


      // Look at BOP app data ...
      // Note about Bop App data: we add all Bops to the localWitRun, regardless
      // of the isExplodableFlag.  That is to simplify the implemnetation (at the
      // expense of a bigger localWitRun).  Its a long term FINISH_ME to filter these out
      LgFrSceBopAppData * appData;
      witGetBopEntryAppData(originalWitRun_, theOperation, b, (void **) &appData);

      // set the appData (if it exists)
      if (appData != 0) {
        LgFrSceBopAppData * newAppData = new LgFrSceBopAppData(*appData);
        witSetBopEntryAppData(localWitRun_, theOperation, b, (void *) newAppData);
d738 1
a738 1
      witFree(producedPart);    
a739 1
      
d741 5
d747 1
a747 10
    
  // free the parts 
  for (i=0; i<nParts; i++)  
    witFree(partList[i]);
  witFree(partList);

  // free the Operations 
  for (o=0; o<nOps; o++)  
    witFree(opList[o]);
  witFree(opList);
a748 1
}
a1046 1
    int defaultOperationFound;
a1136 1
    //      witSetPip(localWitRun_, WitTRUE);    
d1139 1
a1139 6


  // ==================
#ifdef HEUR_ALLOC_EXPLODE

  std::string  smartExplodeEngine = setOfParameters_->getString("smartExplodeEngine");  
d1145 1
a1145 1
  if (smartExplodeEngine == "heurAlloc") {
a1149 1
					       smartExplodeEngine,
a1164 15
#else

  // run the mrp on the localWitRun 
  witHeurImplode(localWitRun());
  
  //post-process
  witPostprocess (localWitRun_ );    
  
  if (doPegging) {
    witBuildPip(localWitRun_);
    this->loadPIPDataIntoAppData(localWitRun_);
  }
  
  
#endif
a1300 3



a1303 1
#ifdef HEUR_ALLOC_EXPLODE
d1313 4
a1316 13
  this->decorateLocalWitRun();
}

#else



  // preferred constructor
LgFrSceSmartExploderDecorator::LgFrSceSmartExploderDecorator(LgFrSceBaseExploder * myExploder)
  : LgFrSceBaseExploderDecorator(myExploder),
    id_ (__LGFRSCESMARTEXPLODERDECORATOR)
{
  this->decorateLocalWitRun();
a1318 2
#endif

d1778 272
@


1.20
log
@more memory fixes ... AND ... increased array sizes on messageStruct
@
text
@d21 3
d1066 34
d1102 1
a1102 1

d1110 3
a1114 1
    
d1121 3
d1255 12
d1268 1
a1268 2


d1280 4
d1353 5
a1357 1
  witSetPenExec(localWitRun_, WitFALSE);
@


1.19
log
@tweaking to get pipPriority settings to work
@
text
@d210 14
d230 1
d496 2
a497 2
    portableFree(partList[i]);
  portableFree(partList);
d501 2
a502 2
    portableFree(opList[o]);
  portableFree(opList);
d611 1
a611 1
      portableFree(supplyVol);
d654 1
a654 1
      portableFree(producedPart);    
d662 2
a663 2
    portableFree(partList[i]);
  portableFree(partList);
d667 2
a668 2
    portableFree(opList[o]);
  portableFree(opList);
d950 1
a950 1
    portableFree(yieldRate);
d957 2
a958 2
    portableFree(opList[o]);
  portableFree(opList);
d1006 1
a1006 1
      portableFree(yieldRate);
d1012 2
a1013 2
      portableFree(partList[i]);
    portableFree(partList);
d1264 2
a1265 2
    portableFree (operationList[o]);
  portableFree (operationList);
d1343 1
a1343 1
	  portableFree(priority);
d1356 1
a1356 1
	  portableFree(demList[j]);
d1358 2
a1359 2
	portableFree(partList[i]);
	portableFree(demList);
d1361 1
a1361 1
      portableFree(partList);
d1470 1
a1470 1
        portableFree(sub);
d1472 1
a1472 1
      portableFree(child);
d1478 2
a1479 2
    portableFree(opList[o]);
  portableFree(opList);
d1573 1
a1573 1
	  portableFree(opName);
d1600 1
a1600 1
      portableFree(yieldRate);
d1618 1
a1618 1
	portableFree(producedPart);
d1669 2
a1670 2
    portableFree(partList[i]);
  portableFree(partList);
d1675 2
a1676 2
    portableFree(opList[o]);
  portableFree(opList);
d1852 1
a1852 1
    portableFree(mrpConsVol);
d1861 1
a1861 1
    portableFree(mrpProdVol);
d1871 1
a1871 1
    portableFree(mrpExcessVol);
d1880 1
a1880 1
    portableFree(mrpResidualVol);
d1889 1
a1889 1
    portableFree(reqVol);
d1895 2
a1896 2
    portableFree(partList[i]);
  portableFree(partList);
d1924 1
a1924 1
    portableFree(partList[i]);
d1927 1
a1927 1
  portableFree(partList);
d1962 1
a1962 1
      portableFree(dlist[j]);      
d1964 2
a1965 2
    portableFree(dlist);
    portableFree(partList[i]);
d1967 1
a1967 1
  portableFree(partList);
d2026 1
a2026 1
    portableFree(supplyVol);
d2035 2
a2036 2
      portableFree(demandVol);
      portableFree(demandList[j]);
d2038 1
a2038 1
    portableFree(demandList);
d2042 2
a2043 2
    portableFree(partList[i]);
  portableFree(partList);
@


1.18
log
@pip for LP engine
@
text
@a1289 1

d1322 7
a1328 1
	  LgFrTimeVecFloat pipPriority(nPeriods, 47.0);
@


1.17
log
@fixed demandDrives so it respects selectiveFeatures
remove usage of witSetPip
@
text
@d1030 5
a1034 2
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;                      
    std::string mrpWitDataFileName = "mrpWitDataFile";
d1036 2
a1037 5
    witWriteData(localWitRun_, mrpWitDataFileName.c_str());
    if (setOfParameters_->getBool("printWitExplodeMsgFile"))  
      setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_ON);
    else
      setWitInformationalMessagingExpl(localWitRun_, SCE_WIT_MESSAGING_OFF);
d1039 1
a1039 1

d1261 106
a1451 3
          


a1453 1

a1459 167

}
  
// + Full Explode decorates witRun by modifying BOM offsets
void
LgFrSceSmartExploderDecorator::decorateLocalWitRun()
{
  // set the equitability factor
  int localEquitability = setOfParameters_->getInt("smartExplodeEquit");
  witSetEquitability(localWitRun(), localEquitability);

  // set forcedEquitability parameter in wit. 
  bool smartExplodeForceEquit = setOfParameters_->getBool("smartExplodeForceEquit");
  witSetForcedMultiEq(localWitRun_, smartExplodeForceEquit);

  // 2.30 fix
  witSetSkipFailures(localWitRun_, WitFALSE);

  // 2.30 addition: set expCutoff
  float expCutoffTolerance = setOfParameters_->getFloat("expCutoffTolerance");
  witSetExpCutoff(localWitRun_, expCutoffTolerance);
  
  witSetPenExec(localWitRun_, WitFALSE);

  // ----------------------------------------------
  // STEP 2: Copy over more stuff from the original 
  // ----------------------------------------------
  // Copy over all the subBom records

  this->copyMoreStuffOver();


  // ---------------------------------
  // STEP 3: Restructure for Implosion
  // ---------------------------------
  // In this step we restructure the model so that an implosion
  // can accurately represent an explosion
  this->restructureForImplosionToSolveExplosion();

  
  // ----------------------------------
  // STEP 4: Do Robin's split BOP thing 
  // ----------------------------------
  // The Final step is to do the exact same processing of BOP entries
  // that is done in initialProblem.  This is where we look at
  // bop and subbom preferences.
  // FINISH_ME: For now we will strictly use heuristic implosion.  For
  //      LP, this step is unnecessary.  Of course, other steps are.
  //      WAhhh! I wanna go home.
  // FINISH_ME: implemnt this.  we do not need this for the MD
  // alpha run.
  // doRobinsBopThing()
  
  state(1);
  

}

#if 0
// get the mrpProdVol
// mrpProdVol = 0,      if part is a PCF
//            = prodVol if part is NOT a PCF

int
LgFrSceSmartExploderDecorator::mrpProdVol(const std::string& part,
                                          float ** mrpProdVolPtr)
{
  assert(state() >= 2);
  int isPartPcf = 0;
  
  if (exists(part)) {
    LgFrScePartAppData * partAppDataPtr;    
    witGetPartAppData(localWitRun(), part, (void **) &partAppDataPtr);
    if (partAppDataPtr != 0) {
      isPartPcf =  partAppDataPtr->isPartPcf();
    }
    if (! isPartPcf) 
      witGetPartProdVol(localWitRun(), part, mrpProdVolPtr);    
    else
      mallocZeroVec(mrpProdVolPtr);
  }

  else
    mallocZeroVec(mrpProdVolPtr);
  
  return 0;
}
#endif

// --------------
// get the reqVol
// --------------
// reqVol = 0, if part is NOT PCF
//        = prodVol if part is a PCF
int
LgFrSceSmartExploderDecorator::reqVol(const std::string& part,
                                      float ** reqVolPtr)
{


  witAttr category;
  witGetPartCategory(localWitRun_, part.c_str(), &category);
  if (category == WitCAPACITY) {
    std::string thePart(part);
    std::string dummyOperationName =
      mpHelper_->operationForCapacityGeneration(thePart);
    witGetOperationExecVol(localWitRun_, dummyOperationName.c_str(), reqVolPtr);
    return 0;
  }

  
  int isPartPcf = 0;
  
  if (exists(part)) {
    LgFrScePartAppData * partAppDataPtr;    
    witGetPartAppData(localWitRun(), part.c_str(), (void **) &partAppDataPtr);
    if (partAppDataPtr != 0) {
      isPartPcf =  partAppDataPtr->isPartPcf();
    }
    if (isPartPcf) {
      witGetPartProdVol(localWitRun_, part.c_str(), reqVolPtr);
      int nPeriods;
      witGetNPeriods(localWitRun_, &nPeriods);
      // note: reqVol can only be within the consttraint horizon
      int t = 0; 
      for (t=partAppDataPtr->unConstrainedStartPeriod(); t<nPeriods; t++)
        (*reqVolPtr)[t] = 0.0;
    }
    else
      mallocZeroVec(reqVolPtr);
  }
  else
    mallocZeroVec(reqVolPtr);
  return 0;
}



  // get the mrpConsVol
int
LgFrSceSmartExploderDecorator::mrpConsVol(const std::string& part,
                                          float ** mrpConsVolPtr)
{
  assert(state() >= 2);
  if (exists(part)) 
    witGetPartConsVol(localWitRun(), part.c_str(), mrpConsVolPtr);    

  else
    mallocZeroVec(mrpConsVolPtr);
  
  return 0;
}




  // get the mrpExcessVol
int
LgFrSceSmartExploderDecorator::mrpExcessVol(const std::string& part,
                                            float ** mrpExcessVolPtr)
{
  assert(state() >= 2);
  if (exists(part)) 
    witGetPartExcessVol(localWitRun(), part.c_str(), mrpExcessVolPtr);
  else
    mallocZeroVec(mrpExcessVolPtr);
  return 0;
a1461 66
  // get the mrpResidualVol
int
LgFrSceSmartExploderDecorator::mrpResidualVol(const std::string& part,
                                            float ** mrpResidualVolPtr)
{
  assert(state() >= 2);
  if (exists(part)) 
    witGetPartResidualVol(localWitRun(), part.c_str(), mrpResidualVolPtr);
  else
    mallocZeroVec(mrpResidualVolPtr);
  return 0;
}


int
LgFrSceSmartExploderDecorator::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
{
  assert(state() >= 2);
  witBoolean opExists, partExists;;
  witGetOperationExists(localWitRun_, operation.c_str(), &opExists);
  if (opExists) {
    witGetOperationExecVol(localWitRun_, operation.c_str(), mrpExecVolPtr);
    witGetPartExists(localWitRun_, operation.c_str(), &partExists);
    if (partExists) {
      LgFrScePartAppData * partAppDataPtr;    
      witGetPartAppData(localWitRun(), operation.c_str(), (void **) &partAppDataPtr);
      if (partAppDataPtr && partAppDataPtr->isPartPcf()) {
        int t = 0; 
        for (t=0; t<partAppDataPtr->unConstrainedStartPeriod(); t++)
          (*mrpExecVolPtr)[t] = 0.0;
      }
    }
  }
  else
    mallocZeroVec(mrpExecVolPtr);
  return 0;
}


int
LgFrSceSmartExploderDecorator::subUsageVol(  const std::string& operation,
                                             const int bomIndex,
                                             const int subBomIndex,
                                             float ** subUsageVolPtr)
{
  assert(state() >= 2);
  witBoolean exists;
  witGetOperationExists(localWitRun_, operation.c_str(), &exists);
  if (exists) {
    // do some sanity checking to ensure that the bom index and subbom index
    // are within reason.  One might even test to see that the child and sub
    // parts are the same.  This is, in general, a FINISH_ME to put in better
    // checks and/or do more testing.
    int nBom;
    witGetOperationNBomEntries(localWitRun_, operation.c_str(), &nBom);
    assert(nBom >= bomIndex);
    int nSubBoms;
    witGetBomEntryNSubsBomEntries(localWitRun_, operation.c_str(), bomIndex, &nSubBoms);
    assert(nSubBoms >= subBomIndex);
    witGetSubsBomEntrySubVol(localWitRun_, operation.c_str(), bomIndex, subBomIndex, subUsageVolPtr);
  }
  else
    mallocZeroVec(subUsageVolPtr);
  return 0;

}
d1659 148
@


1.16
log
@mand/opt capacity, new selective sets
@
text
@d1042 5
a1046 3
  if (doPegging)
      witSetPip(localWitRun_, WitTRUE);    

@


1.15
log
@First cut at Selective Features using proportional routing
@
text
@d913 2
a914 1

d925 1
d930 3
d1461 1
a1461 1
      mpHelper_->operationForSmartExploderCapacity(thePart);
d1608 1
d1743 3
d1747 1
a1747 1
    std::string thePart(partList[i]);
d1750 1
a1750 1
    witGetPartCategory(localWitRun_, thePart.c_str(), &category);
d1752 11
a1762 4
      std::string dummyOperationName =
        mpHelper_->operationForSmartExploderCapacity(thePart);
      witAddOperation(localWitRun_, dummyOperationName.c_str());
      witAddBopEntry(localWitRun_, dummyOperationName.c_str(), thePart.c_str());
a1763 1
    
d1765 10
a1774 1
  
d1782 1
a1782 1
  int o = 0; 
@


1.14
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@a1060 6
// ====== Pegging Utilitiies ====
// ===============================



// ===============================
d1073 1
a1073 1
  std::cout << "... collecting PIP information ..." << std::endl;    
@


1.13
log
@first level of PIP
@
text
@a1037 4
      witSetPerfPegging(localWitRun_, WitTRUE);    

  bool doPIP = setOfParameters_->getBool("doPIP");
  if (doPIP)
d1044 3
d1048 1
a1048 4
    this->loadPegDataIntoAppData(localWitRun_);
  }

  if (doPIP) {
a1062 120
void
LgFrSceSmartExploderDecorator::loadPegDataIntoAppData(WitRun * const theWitRun)
{
  int nPeriods;
  char  *partName, *demandName;
  float * demandVol;


  bool pegSubUsageToPrimary = setOfParameters_->getBool("pegSubUsageToPrimary");

  std::cout << "... collecting Pegging information ..." << std::endl;    
    
  witGetNPeriods(theWitRun, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun, &nParts, &partList);

  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;

  // Loop over parts to get demands
  int i = 0; 
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun, partList[i], &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      // Now for some fancy trickery !!!
      // if the part is a special feature part, then we must map the consVol over to 
      //     the GPD appData
      int isDemandSpecial = 0;
      isDemandSpecial = mpHelper_->isDemandSpecialPureOptionBuildDemand(theWitRun, partName, demandName, pp, geo);
      if (! isDemandSpecial) {
	isDemandSpecial = mpHelper_->isDemandSpecialCustChoiceFeature(theWitRun, partName, demandName, pp, geo);
      }
 

      // get the demandAppData, or create a new one if it doesn't exist.
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;

      // if the demand is a specialFeaturePart then get the gpd's appdata
      if (isDemandSpecial) {
	// get a witPartName for the GPD
	fullWitGPDPartName = mpHelper_->geoPlannerDemandPartName(pp, geo);

	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
			   (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
			       (void *) demandAppDataPtr );
	}
      }
      else {
	witGetDemandAppData( theWitRun, partName, demandName,
			     (void **) &demandAppDataPtr );
	if ( demandAppDataPtr == 0 ) {
	  demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( demandAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun, partName, demandName,  
			       (void *) demandAppDataPtr );
	}
      }

#ifdef DEBUG_DUMP_FOR_PEGGING
      
      if (isDemandSpecial) {
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
      }
      
      std::cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << std::endl;

      demandAppDataPtr->peggingConsVolSched().print();
      std::cout << std::endl;

#endif

      // Get demands pegged consVol and directly store in appData
      ScePegging::getDemandConsVolPegging(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->peggingConsVolSched(),
					  WitTRUE,
					  pegSubUsageToPrimary);

      ScePegging::getDemandExecVolPegging(theWitRun,
					  partList[i],
					  dList[j],
					  0,
					  nPeriods-1,
					  demandAppDataPtr->peggingExecVolSched());


#ifdef DEBUG_DUMP_FOR_PEGGING
      std::cout << "(after) JP's Get" << std::endl;
      demandAppDataPtr->peggingConsVolSched().print();
      std::cout << " ==========================" << std::endl << std::endl;
#endif

      witFree(dList[j]);
    }
    witFree(dList);
  }


  // clear the wit peggeing information
  witClearPegging(theWitRun);


}

d1077 1
a1077 1
  bool PIPSubUsageToPrimary = setOfParameters_->getBool("PIPSubUsageToPrimary");
d1161 1
a1161 1
				  PIPSubUsageToPrimary);
@


1.12
log
@scrubber fix for interplant files
@
text
@d20 1
a1036 2

  // need a flag for whtether it's mrp or implosion pegging
d1040 4
d1052 3
d1157 1
a1157 1
					  demandAppDataPtr->peggingConsVolSched(), 
d1190 129
@


1.11
log
@modified smartExplode to enable  interplant sourced parts with missing
effective intervals so that they can explode.   Solution is to enable
any bop such that:
    producedPart is non-pcf,
    producedPart has 2 or more producing bops,
    default operation has zero bom entries
@
text
@d9 1
a11 1
#include <sce/src/exploders.h>
d1669 1
a1669 1
	    witSetBopEntryExpAversion(localWitRun(), defaultOperationName.c_str(), bopEntryIndex, FLT_MAX ); 
@


1.10
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d211 1
a211 1
  int t = 0; // Pulled out of the for below by RW2STL
a366 1
#ifdef SMART_EXPLODE_AS_WIT_COPY
a374 34
#else
  // assert(state_ == 0);
  witInitialize(localWitRun_);

  // strictly 4.0 mode
  witSetWit34Compatible(localWitRun_, WitFALSE);
  

  // -----------------------------------------
  // STEP 1: Set up Some Global Wit Attributes
  // -----------------------------------------  
  // Set the nPeriods  
  witSetNPeriods(localWitRun_, nPeriods_);

  // allow Subs to have offsets different than the parent bom
  witSetIndependentOffsets(localWitRun_, WitTRUE);

  witSetExecEmptyBom(localWitRun_, WitTRUE);

  // FINISH_ME: A bit of a re-design is in order.  The construction of a
  // concrete exploder and the subsequent decoration needs to be broken
  // down into two steps that will need to be dealt withat the client level.
  // The construction should not immediately copy over  all the witRun.  It
  // should do it in two steps:  First intiailize the global wit attributes
  // (which allows the decorators to decorate/override these.  Then the copy
  // should happen.  The reason is that if concrete sets objType and then
  // populates the witRun with all the parts and stuff, its too late for
  // smartExploder to reset objType (this is a wit error).  For now, its moot
  // becuase this is only an issue for optimization, and, smartExplode is all
  // hardwired to do standard heurImplosion anyway.
  int objValue = 0;
  witSetObjChoice(localWitRun_, objValue);

#endif
d453 1
a453 1
  int i = 0; // Pulled out of the for below by RW2STL
d464 1
a464 1
  int o = 0; // Pulled out of the for below by RW2STL
d469 1
a469 1
    int b = 0; // Pulled out of the for below by RW2STL
d560 1
a560 2
#ifdef SMART_EXPLODE_AS_WIT_COPY
  int i = 0; // Pulled out of the for below by RW2STL
d602 1
a602 1
  int o = 0; // Pulled out of the for below by RW2STL
d616 1
a616 1
    int b = 0; // Pulled out of the for below by RW2STL
a642 186



#else

  
  
  // First set up the Parts ...
  // filter out parts and structure that is not necessary for
  // MRP.
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
    char * thePart = partList[i];
    std::string sub(thePart);

    witAttr category34;
    witAttr category40;	
    witGetPartCategory(originalWitRun_, thePart, &category34);
    
	// rhs witrun is 3.4 and lhs is 4.0
	// need to convert  category to 4.0 
    if (category34 == WitPRODUCT || category34 == WitRAW )
      category40 = WitMATERIAL ;	
    else if (category34 == WitCAPACITY)
      category40 = WitCAPACITY;
    
    witAddPart(localWitRun_, thePart, category40);
    
    // copy the appData if there is one
    LgFrScePartAppData * appDataPtr;
    witGetPartAppData(originalWitRun_, thePart, (void **) &appDataPtr);
    if (appDataPtr != 0) {
      LgFrScePartAppData * newAppDataPtr = new LgFrScePartAppData(*appDataPtr);
      witSetPartAppData(localWitRun_, thePart, (void *) newAppDataPtr);
    }
    witGetPartSupplyVol(originalWitRun_, thePart, &supplyVol);
    witSetPartSupplyVol(localWitRun_, thePart, supplyVol);
    // CUSTOMER_CHOICE_FEATURES
    // See Customer Feature Model documentation. It's kind of wierd.
    if (mpHelper()->isPartSpecialCustChoiceFeature(originalWitRun_, thePart)) {
     LgFrTimeVecFloat supplyAdjust(mpHelper()->custChoiceDummySupplyVolForMrpAdjustment(originalWitRun_, 
											thePart));
     // We must add the supply adjust ot any existing suply for the specialCustChpoice part
     // An existing supply may be there due to Machine Feature Supply
     LgFrTimeVecFloat existingSupplyTVF(nPeriods, supplyVol);
     LgFrTimeVecFloat newSupplyTVF = supplyAdjust.op(existingSupplyTVF, LgFrAdd);
     witSetPartSupplyVol(localWitRun_, thePart, newSupplyTVF.data());
    }
    // END_CUSTOMER_CHOICE_FEATURES
    portableFree(supplyVol);      
    

    // ==== Now add any Demands ====
    if (category40 == WitMATERIAL) {
      int nDemands;
      char ** dList;
      witGetPartDemands(originalWitRun_, thePart, &nDemands, &dList);
      int d = 0; // Pulled out of the for below by RW2STL
      for (d=0; d<nDemands; d++) {
        witGetDemandDemandVol(originalWitRun_, thePart, dList[d], &demandVol);
        witAddDemand(localWitRun_, thePart, dList[d]);
        witSetDemandDemandVol(localWitRun_, thePart, dList[d], demandVol);
        portableFree(demandVol);
        portableFree(dList[d]);
      }
      portableFree(dList);
    }

  }

  // Now loop over the operations ...
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];

    // special considerations for operations:
    //    NONE (at this time).
    //   We will filter bop's based on the appData
    //   can we explode boolean.  AFter we do that
    //   We may determine that there are some default
    //    operations that should be turned back on for explosion.
  
    witGetOperationIncLotSize(originalWitRun_, theOperation, &incLotSize);
    witGetOperationMinLotSize(originalWitRun_, theOperation, &minLotSize);
    witGetOperationYieldRate(originalWitRun_, theOperation, &yieldRate);
    
    witAddOperation(localWitRun_, theOperation);
    
    witSetOperationIncLotSize(localWitRun_, theOperation, incLotSize);
    witSetOperationMinLotSize(localWitRun_, theOperation, minLotSize);
    witSetOperationYieldRate(localWitRun_, theOperation, yieldRate);
    portableFree(incLotSize);
    portableFree(minLotSize);
    portableFree(yieldRate);

    int nbBops;
    witGetOperationNBopEntries(originalWitRun_, theOperation, &nbBops);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {

        
      witGetBopEntryProducedPart(originalWitRun_, theOperation, b, &producedPart);
      // make sure the produced part exists before adding a bop entry.
      // It must exists based on the new implementation!!
      assert(exists(producedPart));


      // DO not copy the byproduct attribute.  Let it default to false.
      // It will be re-analyzed later and set accordingly.
      // FINISH_ME: For now we DO copy the byProduct.  Once we get
      // the HeurModelHelper, we can use that to set byProduct.  For
      // now we'll use them the way they are.
      witBoolean expAllowed;
      witGetBopEntryExpAllowed(originalWitRun_, theOperation, b, &expAllowed);
      float expAversion;
      witGetBopEntryExpAversion(originalWitRun_, theOperation, b, &expAversion);
      witGetBopEntryEarliestPeriod(originalWitRun_, theOperation, b, &early);
      witGetBopEntryLatestPeriod(originalWitRun_, theOperation, b, &late);
      witGetBopEntryOffset(originalWitRun_, theOperation, b, &offset);
      witGetBopEntryProdRate(originalWitRun_, theOperation, b, &prodRate);
      // Look at BOP app data ...
      // Note about Bop App data: we add all Bops to the localWitRun, regardless
      // of the isExplodableFlag.  That is to simplify the implemnetation (at the
      // expense of a bigger localWitRun).  Its a long term FINISH_ME to filter these out
      LgFrSceBopAppData * appData;
      witGetBopEntryAppData(originalWitRun_, theOperation, b, (void **) &appData);

      witAddBopEntry(localWitRun_, theOperation, producedPart);

      // set the appData (if it exists)
      if (appData != 0) {
        LgFrSceBopAppData * newAppData = new LgFrSceBopAppData(*appData);
        witSetBopEntryAppData(localWitRun_, theOperation, b, (void *) newAppData);
      }
      // FINISH_ME: make sure you remove this line when you implement
      // the HeurModelHelper in this object.
      witSetBopEntryExpAllowed(localWitRun_, theOperation, b, expAllowed);            
      witSetBopEntryExpAversion(localWitRun_, theOperation, b, expAversion);            
      witSetBopEntryEarliestPeriod(localWitRun_, theOperation, b, early);
      witSetBopEntryLatestPeriod(localWitRun_, theOperation, b, late);
      witSetBopEntryOffset(localWitRun_, theOperation, b, offset);
      witSetBopEntryProdRate(localWitRun_, theOperation, b, prodRate);
      portableFree(offset);
      portableFree(producedPart);    
    }
      
    // -----------------------------
    // Now copy all the  bom records
    // -----------------------------    
    int nBom;
    witGetOperationNBomEntries(originalWitRun_, theOperation, &nBom);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
      // get ...
      witGetBomEntryConsumedPart(originalWitRun_, theOperation, j, &child);

      // check for existence of the child, first. New imp --> it must exist.
      witBoolean exists;
      witGetPartExists(originalWitRun_, child, &exists);
      assert(exists);
      
      witGetBomEntryUsageRate(originalWitRun_, theOperation, j, &usageRate); 
      witGetBomEntryOffset(originalWitRun_, theOperation, j, &offset); 
      witGetBomEntryEarliestPeriod(originalWitRun_, theOperation, j, &early); 
      witGetBomEntryLatestPeriod(originalWitRun_, theOperation, j, &late);
      witGetBomEntryFallout(originalWitRun_, theOperation, j, &fallout);
      witGetBomEntryMandEC(originalWitRun_, theOperation, j, &mandEC);

      witAddBomEntry(localWitRun_, theOperation, child);
      // set ...
      witSetBomEntryUsageRate(localWitRun_, theOperation, j, usageRate); 
      witSetBomEntryEarliestPeriod(localWitRun_, theOperation, j, early); 
      witSetBomEntryLatestPeriod(localWitRun_, theOperation, j, late);
      witSetBomEntryFallout(localWitRun_, theOperation, j, fallout);
      witSetBomEntryMandEC(localWitRun_, theOperation, j, mandEC);

      // full exploder decorator will modify offsets
      witSetBomEntryOffset(localWitRun_, theOperation, j, offset);
      portableFree(offset);


      portableFree(child);
    }

  }
#endif      
a912 1
#ifdef SMART_EXPLODE_AS_WIT_COPY
d923 1
a923 1
  int o = 0; // Pulled out of the for below by RW2STL
d955 1
a955 1
    int i = 0; // Pulled out of the for below by RW2STL
d980 1
a980 1
      int t = 0; // Pulled out of the for below by RW2STL
a985 3
      
      
      
a988 1
    
a993 54
  // ++++++++++++++++++++++++++++++++

#else



  int nOps;
  char ** opList;
  witGetOperations(localWitRun(), &nOps, &opList);  

  float * offset;

  // Now loop over all operations ...
  // and modify the offset for "fullExplode" capability
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
    char * theOperation = opList[o];
      
    int nBom;
    witGetOperationNBomEntries(localWitRun(), theOperation, &nBom);
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
      witGetBomEntryOffset(localWitRun(), theOperation, j, &offset); 

      // modify offsets for "full explode" capability
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods(); t++)  
        if (offset[t] > (float) t)  
          offset[t] = t;
      witSetBomEntryOffset(localWitRun(), theOperation, j, offset);
      portableFree(offset);
    }

    // fix bop offsets too
    int nBops;
    witGetOperationNBopEntries(localWitRun(), theOperation, &nBops);
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBops; b++) {
      witGetBopEntryOffset(localWitRun(), theOperation, b, &offset); 

      // modify offsets for "full explode" capability
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods(); t++)  
        if (-offset[t] > (float) t)  
          offset[t] = -t;
      witSetBopEntryOffset(localWitRun(), theOperation, b, offset);
      portableFree(offset);
    }

    
  }


#endif
d1082 1
a1082 1
  int i = 0; // Pulled out of the for below by RW2STL
d1088 1
a1088 1
    int j = 0; // Pulled out of the for below by RW2STL
d1102 1
a1102 1
      // get teh demandAppData, or create a new one if it doesn't exist.
d1219 1
a1219 1
  int o = 0; // Pulled out of the for below by RW2STL
d1224 1
a1224 1
    int j = 0; // Pulled out of the for below by RW2STL
d1227 1
a1227 1
      int s = 0; // Pulled out of the for below by RW2STL
d1273 1
a1273 1
  int o = 0; // Pulled out of the for below by RW2STL
d1283 1
a1283 1
    int j = 0; // Pulled out of the for below by RW2STL
d1296 1
a1296 1
      int s = 0; // Pulled out of the for below by RW2STL
a1310 3
#ifndef SMART_EXPLODE_AS_WIT_COPY
        witAddSubsBomEntry(localWitRun_, theOperation, j, sub.c_str());
#endif
d1470 1
a1470 1
      int t = 0; // Pulled out of the for below by RW2STL
d1542 1
a1542 1
        int t = 0; // Pulled out of the for below by RW2STL
d1584 1
d1586 1
a1586 1
// +     setting byProduct=false and effectivity to entire horizon
d1592 2
d1603 1
a1603 1
  int i = 0; // Pulled out of the for below by RW2STL
d1607 6
d1618 3
a1620 2
    if (! partAppData->isPartPcf())
      continue;
d1622 8
a1629 1
    // Yeah!! we found a bonafide PCF part.
d1631 2
a1632 5
    // find its default operation.
    std::string defaultOperation(thePart);
    witBoolean exists;
    witGetOperationExists(localWitRun(), defaultOperation.c_str(), &exists);
    assert(exists);
d1634 42
a1675 5
    float * yieldRate;
    witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
      yieldRate[t] = 1.0;
a1676 2
    witSetOperationYieldRate(localWitRun(), defaultOperation.c_str(), yieldRate);
    portableFree(yieldRate);
d1679 42
a1720 14
    // find the bop entry that leads to the default operation
    // set effectivities on and byProduct off
    int nbBops;
    char * producedPart;
    witGetOperationNBopEntries(localWitRun(), defaultOperation.c_str(), &nbBops);
    int defaultOperationFound = 0;
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {
      witGetBopEntryProducedPart(localWitRun(), defaultOperation.c_str(), b, &producedPart);
      if (producedPart == defaultOperation) {
	defaultOperationFound = 1;
        witSetBopEntryExpAllowed(localWitRun(), defaultOperation.c_str(), b, WitTRUE);            
        witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation.c_str(), b, 0);
        witSetBopEntryLatestPeriod(localWitRun(), defaultOperation.c_str(), b, nPeriods()-1);
a1721 5
      portableFree(producedPart);
    }
    if (! defaultOperationFound) {
      std::cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
	   << "PCF: " << defaultOperation << "\n\n";
d1734 1
a1734 1

d1753 1
a1753 1
  int o = 0; // Pulled out of the for below by RW2STL
d1771 1
a1771 1
  int i = 0; // Pulled out of the for below by RW2STL
d1780 1
a1780 1
    int t = 0; // Pulled out of the for below by RW2STL
d1849 1
a1849 1
  int t = 0; // Pulled out of the for below by RW2STL
d1853 1
a1853 1
  int i = 0; // Pulled out of the for below by RW2STL
d1882 1
a1882 1
  int t = 0; // Pulled out of the for below by RW2STL
d1886 1
a1886 1
  int i = 0; // Pulled out of the for below by RW2STL
d1891 1
a1891 1
    int j = 0; // Pulled out of the for below by RW2STL
d1952 1
a1952 1
  int i = 0; // Pulled out of the for below by RW2STL
d1962 1
a1962 1
    int j = 0; // Pulled out of the for below by RW2STL
@


1.9
log
@penExec should have been set to FALSE in exploders.C
@
text
@d1 6
d12 2
a13 3
#include <rw/cstring.h>
#include <iostream.h>
#include <fstream.h>
d62 1
a62 1
  // FINISH_ME: if doImplode=FALSE, then we should use the original witRun
d76 2
a77 2
    cout << "Writing the (mrp) wit data file ..." << endl;                      
    RWCString mrpWitDataFileName = "mrpWitDataFile";
d79 1
a79 1
    witWriteData(localWitRun_, mrpWitDataFileName);
d95 1
a95 1
RWCString
d98 1
a98 1
  RWCString myTitle("base witMrp");
d105 1
a105 1
LgFrSceBaseExploder::exists(const char * part)
d108 1
a108 1
  witGetPartExists(localWitRun_, part, &exists);  
d115 1
a115 1
LgFrSceBaseExploder::mrpExcessVol(const char * part, float ** mrpExcessVolPtr)
d119 1
a119 1
    witGetPartMrpExcessVol(localWitRun_, part, mrpExcessVolPtr);
d127 1
a127 1
LgFrSceBaseExploder::mrpResidualVol(const char * part, float ** mrpResidualVolPtr)
d131 1
a131 1
    witGetPartMrpResidualVol(localWitRun_, part, mrpResidualVolPtr);
d139 1
a139 1
LgFrSceBaseExploder::mrpExecVol(const char * operation, float ** mrpExecVolPtr)
d143 1
a143 1
  witGetOperationExists(localWitRun_, operation, &exists);
d145 1
a145 1
    witGetOperationMrpExecVol(localWitRun_, operation, mrpExecVolPtr);
d156 1
a156 1
LgFrSceBaseExploder::mrpProdVol(  const char * part, float ** mrpProdVolPtr)
d170 1
a170 1
LgFrSceBaseExploder::reqVol(const char * part, float ** reqVolPtr)
d174 1
a174 1
    witGetPartReqVol(localWitRun_, part, reqVolPtr);
d181 1
a181 1
LgFrSceBaseExploder::mrpConsVol(  const char * part, float ** mrpConsVolPtr)
d185 1
a185 1
    witGetPartMrpConsVol(localWitRun_, part, mrpConsVolPtr);    
d195 1
a195 1
LgFrSceBaseExploder::subUsageVol(  const char * operation,
d210 3
a212 2
  assert(zeroVec != NULL);
  for (int t=0; t<nPeriods_; t++)
d219 1
a219 1
LgFrSceBaseExploder::print(char * filename)
d314 4
a317 4
  : originalWitRun_ (NULL),
    localWitRun_ (NULL),
    mpHelper_ (NULL),
    setOfParameters_ (NULL),
d354 2
a355 2
  RWCString outputFilePrefix  = setOfParameters->getString("outputFilePrefix");
  RWCString witExplodeMsgFileExtension = setOfParameters->getString("witExplodeMsgFileExtension");    
d357 1
a357 1
  RWCString witExplodeMsgFileName(outputFilePrefix + witExplodeMsgFileExtension);
d360 1
a360 1
  witSetMesgFileName( localWitRun_, WitTRUE, witExplodeMsgFileName);
d425 1
a425 1
  //    5) All BOP byProduct flags are set to FALSE.  they will be
d466 1
a466 1
RWCString
d469 1
a469 1
  RWCString myTitle("witMrp");
d488 2
a489 1
  for (int i=0; i<nParts; i++) {
d499 2
a500 1
  for (int o=0; o<nOps; o++) {
d504 2
a505 1
    for (int b=0; b<nbBops; b++) {
d596 2
a597 1
  for (int i=0; i<nParts; i++) {
d599 1
a599 1
    RWCString sub(thePart);
d615 1
a615 1
    if (appDataPtr != NULL) {
d638 2
a639 1
  for (int o=0; o<nOps; o++) {
d652 2
a653 1
    for (int b=0; b<nbBops; b++) {
d670 1
a670 1
      if (appData != NULL) {
d689 2
a690 1
  for (int i=0; i<nParts; i++) {
d692 1
a692 1
    RWCString sub(thePart);
d710 1
a710 1
    if (appDataPtr != NULL) {
d736 2
a737 1
      for (int d=0; d<nDemands; d++) {
d750 2
a751 1
  for (int o=0; o<nOps; o++) {
d776 2
a777 1
    for (int b=0; b<nbBops; b++) {
d786 1
a786 1
      // DO not copy the byproduct attribute.  Let it default to FALSE.
d809 1
a809 1
      if (appData != NULL) {
d830 2
a831 1
    for (int j=0; j<nBom; j++) {
d898 1
a898 1
LgFrSceBaseExploderDecorator::exists(const char * part)
d907 1
a907 1
LgFrSceBaseExploderDecorator::mrpProdVol(  const char * part, float ** mrpProdVol)
d914 1
a914 1
LgFrSceBaseExploderDecorator::mrpExcessVol(const char * part, float ** mrpExcessVol)
d921 1
a921 1
LgFrSceBaseExploderDecorator::mrpResidualVol(const char * part, float ** mrpResidualVol)
d928 1
a928 1
LgFrSceBaseExploderDecorator::reqVol(      const char * part, float ** reqVolPtr)
d934 1
a934 1
LgFrSceBaseExploderDecorator::mrpConsVol(  const char * part, float ** mrpConsVolPtr)
d940 1
a940 1
LgFrSceBaseExploderDecorator::mrpExecVol(const char * operation, float ** mrpExecVolPtr)
d948 1
a948 1
LgFrSceBaseExploderDecorator::subUsageVol(  const char * operation,
d1064 1
a1064 1
LgFrSceBaseExploderDecorator::print(char * filename)
d1094 1
a1094 1
RWCString
d1097 2
a1098 2
  RWCString myTitle(myExploder_->title());
  myTitle.prepend("Full ");
d1143 2
a1144 2
  // witRun.  We do this to "undo" what setting wit34Compabile to FALSE did.
  // Namely, wit34Compat=TRUE causes the yieldrates within the cycleTime be
d1146 2
a1147 1
  for (int o=0; o<nOps; o++) {
d1178 2
a1179 1
    for (int i=0; i<nParts; i++) {
d1184 1
a1184 1
      if (partAppData == NULL)
d1193 1
a1193 1
      RWCString defaultOperation(thePart);
d1195 1
a1195 1
      witGetOperationExists(localWitRun(), defaultOperation, &exists);
d1197 1
a1197 1
	cerr << "TEMP_ERROR2: Default Operation for PCF not found in exploder\n"
d1202 3
a1204 2
      witGetOperationYieldRate(localWitRun(), defaultOperation, &yieldRate);    
      for (int t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
d1207 1
a1207 1
      witSetOperationYieldRate(localWitRun(), defaultOperation, yieldRate);
d1235 2
a1236 1
  for (int o=0; o<nOps; o++) {
d1241 2
a1242 1
    for (int j=0; j<nBom; j++) {
d1246 2
a1247 1
      for (int t=0; t<nPeriods(); t++)  
d1257 2
a1258 1
    for (int b=0; b<nBops; b++) {
d1262 2
a1263 1
      for (int t=0; t<nPeriods(); t++)  
d1305 2
a1306 2
    cout << "Writing the (mrp) wit data file ..." << endl;                      
    RWCString mrpWitDataFileName = "mrpWitDataFile";
d1308 1
a1308 1
    witWriteData(localWitRun_, mrpWitDataFileName);
d1316 1
a1316 1
  RWBoolean doPegging = setOfParameters_->getBool("doPegging");
d1350 1
a1350 1
  RWBoolean pegSubUsageToPrimary = setOfParameters_->getBool("pegSubUsageToPrimary");
d1352 1
a1352 1
  cout << "... collecting Pegging information ..." << endl;    
d1359 2
a1360 2
  RWCString pp, geo;
  RWCString fullWitGPDPartName, fullWitGPDDemandName;
d1363 2
a1364 1
  for(int i=0; i<nParts; i++){
d1369 2
a1370 1
    for(int j=0; j<nDemands; j++){
d1384 1
a1384 1
      LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d1391 1
a1391 1
	witGetDemandAppData( theWitRun, fullWitGPDPartName, geo,
d1393 1
a1393 1
	if ( demandAppDataPtr == NULL ) {
d1396 1
a1396 1
	  witSetDemandAppData( theWitRun, fullWitGPDPartName, geo,  
d1403 1
a1403 1
	if ( demandAppDataPtr == NULL ) {
d1414 3
a1416 3
	cout << "specialDemand, being REPORTED..." << endl;
	cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << endl;
d1419 1
a1419 1
      cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << endl;
d1422 1
a1422 1
      cout << endl;
d1445 1
a1445 1
      cout << "(after) JP's Get" << endl;
d1447 1
a1447 1
      cout << " ==========================" << endl << endl;
d1481 1
a1481 1
RWCString
d1484 2
a1485 2
  RWCString myTitle(myExploder_->title());
  myTitle.prepend("Smart ");
d1500 2
a1501 1
  for (int o=0; o<nOps; o++) {
d1505 2
a1506 1
    for (int j=0; j<nBoms; j++) {
d1508 2
a1509 1
      for (int s=0; s<nSubBoms; s++) { 
d1554 2
a1555 1
  for (int o=0; o<nOps; o++) {
d1564 2
a1565 1
    for (int j=0; j<nBom; j++) {
d1577 2
a1578 1
      for (int s=0; s<nSubs; s++) {
d1593 1
a1593 1
        witAddSubsBomEntry(localWitRun_, theOperation, j, sub);
d1596 1
a1596 1
        // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=FALSE
d1599 1
a1599 1
        if (appDataPtr != NULL) {
d1642 1
a1642 1
  RWBoolean smartExplodeForceEquit = setOfParameters_->getBool("smartExplodeForceEquit");
d1694 1
a1694 1
LgFrSceSmartExploderDecorator::mrpProdVol(const char * part,
d1703 1
a1703 1
    if (partAppDataPtr != NULL) {
d1725 1
a1725 1
LgFrSceSmartExploderDecorator::reqVol(const char * part,
d1731 1
a1731 1
  witGetPartCategory(localWitRun_, part, &category);
d1733 2
a1734 2
    RWCString thePart(part);
    RWCString dummyOperationName =
d1736 1
a1736 1
    witGetOperationExecVol(localWitRun_, dummyOperationName, reqVolPtr);
d1745 2
a1746 2
    witGetPartAppData(localWitRun(), part, (void **) &partAppDataPtr);
    if (partAppDataPtr != NULL) {
d1750 1
a1750 1
      witGetPartProdVol(localWitRun_, part, reqVolPtr);
d1754 2
a1755 1
      for (int t=partAppDataPtr->unConstrainedStartPeriod(); t<nPeriods; t++)
d1770 1
a1770 1
LgFrSceSmartExploderDecorator::mrpConsVol(const char * part,
d1775 1
a1775 1
    witGetPartConsVol(localWitRun(), part, mrpConsVolPtr);    
d1788 1
a1788 1
LgFrSceSmartExploderDecorator::mrpExcessVol(const char * part,
d1793 1
a1793 1
    witGetPartExcessVol(localWitRun(), part, mrpExcessVolPtr);
d1801 1
a1801 1
LgFrSceSmartExploderDecorator::mrpResidualVol(const char * part,
d1806 1
a1806 1
    witGetPartResidualVol(localWitRun(), part, mrpResidualVolPtr);
d1814 1
a1814 1
LgFrSceSmartExploderDecorator::mrpExecVol(const char * operation, float ** mrpExecVolPtr)
d1818 1
a1818 1
  witGetOperationExists(localWitRun_, operation, &opExists);
d1820 2
a1821 2
    witGetOperationExecVol(localWitRun_, operation, mrpExecVolPtr);
    witGetPartExists(localWitRun_, operation, &partExists);
d1824 1
a1824 1
      witGetPartAppData(localWitRun(), operation, (void **) &partAppDataPtr);
d1826 2
a1827 1
        for (int t=0; t<partAppDataPtr->unConstrainedStartPeriod(); t++)
d1839 1
a1839 1
LgFrSceSmartExploderDecorator::subUsageVol(  const char * operation,
d1846 1
a1846 1
  witGetOperationExists(localWitRun_, operation, &exists);
d1853 1
a1853 1
    witGetOperationNBomEntries(localWitRun_, operation, &nBom);
d1856 1
a1856 1
    witGetBomEntryNSubsBomEntries(localWitRun_, operation, bomIndex, &nSubBoms);
d1858 1
a1858 1
    witGetSubsBomEntrySubVol(localWitRun_, operation, bomIndex, subBomIndex, subUsageVolPtr);
d1869 1
a1869 1
// +     setting byProduct=FALSE and effectivity to entire horizon
d1884 2
a1885 1
  for (int i=0; i<nParts; i++) {
d1890 1
a1890 1
    if (partAppData == NULL)
d1899 1
a1899 1
    RWCString defaultOperation(thePart);
d1901 1
a1901 1
    witGetOperationExists(localWitRun(), defaultOperation, &exists);
d1905 3
a1907 2
    witGetOperationYieldRate(localWitRun(), defaultOperation, &yieldRate);    
    for (int t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
d1910 1
a1910 1
    witSetOperationYieldRate(localWitRun(), defaultOperation, yieldRate);
d1918 1
a1918 1
    witGetOperationNBopEntries(localWitRun(), defaultOperation, &nbBops);
d1920 3
a1922 2
    for (int b=0; b<nbBops; b++) {
      witGetBopEntryProducedPart(localWitRun(), defaultOperation, b, &producedPart);
d1925 3
a1927 3
        witSetBopEntryExpAllowed(localWitRun(), defaultOperation, b, WitTRUE);            
        witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation, b, 0);
        witSetBopEntryLatestPeriod(localWitRun(), defaultOperation, b, nPeriods()-1);
d1932 1
a1932 1
      cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
d1945 1
a1945 1
    RWCString thePart(partList[i]);
d1948 1
a1948 1
    witGetPartCategory(localWitRun_, thePart, &category);
d1950 1
a1950 1
      RWCString dummyOperationName =
d1952 2
a1953 2
      witAddOperation(localWitRun_, dummyOperationName);
      witAddBopEntry(localWitRun_, dummyOperationName, thePart);
d1965 2
a1966 1
  for (int o=0; o<nOps; o++)  
d1974 1
a1974 1
LgFrSceSmartExploderDecorator::print(char * filename)
d1977 1
a1977 1
  ofstream outFile(filename, ios::out);
d1983 2
a1984 1
  for (int i=0; i<nParts; i++) {
d1992 2
a1993 1
    for (int t=0; t<nPeriods(); t++) 
d2061 2
a2062 1
  for (int t=0; t<nPeriods; t++)
d2065 2
a2066 1
  for (int i=0; i<nParts; i++) {
d2075 1
a2075 1
RWCString
d2078 2
a2079 2
  RWCString myTitle(myExploder_->title());
  myTitle.prepend("Fssable ");
d2094 2
a2095 1
  for (int t=0; t<nPeriods; t++)
d2098 2
a2099 1
  for (int i=0; i<nParts; i++) {
d2103 2
a2104 1
    for (int j=0; j<nDemands; j++) {
d2164 2
a2165 1
  for (int i=0; i<nParts; i++)  {
d2174 2
a2175 1
    for (int j=0; j<nDemands; j++)   {
@


1.9.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d6 1
d57 1
a57 1
  // FINISH_ME: if doImplode=false, then we should use the original witRun
d72 1
a72 1
    std::string mrpWitDataFileName = "mrpWitDataFile";
d74 1
a74 1
    witWriteData(localWitRun_, mrpWitDataFileName.c_str());
d90 1
a90 1
std::string
d93 1
a93 1
  std::string myTitle("base witMrp");
d100 1
a100 1
LgFrSceBaseExploder::exists(const std::string& part)
d103 1
a103 1
  witGetPartExists(localWitRun_, part.c_str(), &exists);  
d110 1
a110 1
LgFrSceBaseExploder::mrpExcessVol(const std::string& part, float ** mrpExcessVolPtr)
d114 1
a114 1
    witGetPartMrpExcessVol(localWitRun_, part.c_str(), mrpExcessVolPtr);
d122 1
a122 1
LgFrSceBaseExploder::mrpResidualVol(const std::string& part, float ** mrpResidualVolPtr)
d126 1
a126 1
    witGetPartMrpResidualVol(localWitRun_, part.c_str(), mrpResidualVolPtr);
d134 1
a134 1
LgFrSceBaseExploder::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
d138 1
a138 1
  witGetOperationExists(localWitRun_, operation.c_str(), &exists);
d140 1
a140 1
    witGetOperationMrpExecVol(localWitRun_, operation.c_str(), mrpExecVolPtr);
d151 1
a151 1
LgFrSceBaseExploder::mrpProdVol(  const std::string& part, float ** mrpProdVolPtr)
d165 1
a165 1
LgFrSceBaseExploder::reqVol(const std::string& part, float ** reqVolPtr)
d169 1
a169 1
    witGetPartReqVol(localWitRun_, part.c_str(), reqVolPtr);
d176 1
a176 1
LgFrSceBaseExploder::mrpConsVol(  const std::string& part, float ** mrpConsVolPtr)
d180 1
a180 1
    witGetPartMrpConsVol(localWitRun_, part.c_str(), mrpConsVolPtr);    
d190 1
a190 1
LgFrSceBaseExploder::subUsageVol(  const std::string& operation,
d205 2
a206 3
  assert(zeroVec != 0);
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods_; t++)
d213 1
a213 1
LgFrSceBaseExploder::print(std::string& filename)
d308 4
a311 4
  : originalWitRun_ (0),
    localWitRun_ (0),
    mpHelper_ (0),
    setOfParameters_ (0),
d348 2
a349 2
  std::string outputFilePrefix  = setOfParameters->getString("outputFilePrefix");
  std::string witExplodeMsgFileExtension = setOfParameters->getString("witExplodeMsgFileExtension");    
d351 1
a351 1
  std::string witExplodeMsgFileName(outputFilePrefix + witExplodeMsgFileExtension);
d354 1
a354 1
  witSetMesgFileName( localWitRun_, WitTRUE, witExplodeMsgFileName.c_str());
d419 1
a419 1
  //    5) All BOP byProduct flags are set to false.  they will be
d460 1
a460 1
std::string
d463 1
a463 1
  std::string myTitle("witMrp");
d482 1
a482 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d492 1
a492 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d496 1
a496 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {
d587 1
a587 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d589 1
a589 1
    std::string sub(thePart);
d605 1
a605 1
    if (appDataPtr != 0) {
d628 1
a628 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d641 1
a641 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {
d658 1
a658 1
      if (appData != 0) {
d677 1
a677 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d679 1
a679 1
    std::string sub(thePart);
d697 1
a697 1
    if (appDataPtr != 0) {
d723 1
a723 2
      int d = 0; // Pulled out of the for below by RW2STL
      for (d=0; d<nDemands; d++) {
d736 1
a736 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d761 1
a761 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {
d770 1
a770 1
      // DO not copy the byproduct attribute.  Let it default to false.
d793 1
a793 1
      if (appData != 0) {
d814 1
a814 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
d881 1
a881 1
LgFrSceBaseExploderDecorator::exists(const std::string& part)
d890 1
a890 1
LgFrSceBaseExploderDecorator::mrpProdVol(  const std::string& part, float ** mrpProdVol)
d897 1
a897 1
LgFrSceBaseExploderDecorator::mrpExcessVol(const std::string& part, float ** mrpExcessVol)
d904 1
a904 1
LgFrSceBaseExploderDecorator::mrpResidualVol(const std::string& part, float ** mrpResidualVol)
d911 1
a911 1
LgFrSceBaseExploderDecorator::reqVol(      const std::string& part, float ** reqVolPtr)
d917 1
a917 1
LgFrSceBaseExploderDecorator::mrpConsVol(  const std::string& part, float ** mrpConsVolPtr)
d923 1
a923 1
LgFrSceBaseExploderDecorator::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
d931 1
a931 1
LgFrSceBaseExploderDecorator::subUsageVol(  const std::string& operation,
d1047 1
a1047 1
LgFrSceBaseExploderDecorator::print(std::string& filename)
d1077 1
a1077 1
std::string
d1080 2
a1081 2
  std::string myTitle(myExploder_->title());
  myTitle.insert(0, "Full ");
d1126 2
a1127 2
  // witRun.  We do this to "undo" what setting wit34Compabile to false did.
  // Namely, wit34Compat=true causes the yieldrates within the cycleTime be
d1129 1
a1129 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d1160 1
a1160 2
    int i = 0; // Pulled out of the for below by RW2STL
    for (i=0; i<nParts; i++) {
d1165 1
a1165 1
      if (partAppData == 0)
d1174 1
a1174 1
      std::string defaultOperation(thePart);
d1176 1
a1176 1
      witGetOperationExists(localWitRun(), defaultOperation.c_str(), &exists);
d1183 2
a1184 3
      witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);    
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
d1187 1
a1187 1
      witSetOperationYieldRate(localWitRun(), defaultOperation.c_str(), yieldRate);
d1215 1
a1215 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d1220 1
a1220 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
d1224 1
a1224 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods(); t++)  
d1234 1
a1234 2
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nBops; b++) {
d1238 1
a1238 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods(); t++)  
d1281 1
a1281 1
    std::string mrpWitDataFileName = "mrpWitDataFile";
d1283 1
a1283 1
    witWriteData(localWitRun_, mrpWitDataFileName.c_str());
d1291 1
a1291 1
  bool doPegging = setOfParameters_->getBool("doPegging");
d1325 1
a1325 1
  bool pegSubUsageToPrimary = setOfParameters_->getBool("pegSubUsageToPrimary");
d1334 2
a1335 2
  std::string pp, geo;
  std::string fullWitGPDPartName, fullWitGPDDemandName;
d1338 1
a1338 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d1343 1
a1343 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d1357 1
a1357 1
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d1364 1
a1364 1
	witGetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),
d1366 1
a1366 1
	if ( demandAppDataPtr == 0 ) {
d1369 1
a1369 1
	  witSetDemandAppData( theWitRun, fullWitGPDPartName.c_str(), geo.c_str(),  
d1376 1
a1376 1
	if ( demandAppDataPtr == 0 ) {
d1454 1
a1454 1
std::string
d1457 2
a1458 2
  std::string myTitle(myExploder_->title());
  myTitle.insert(0,"Smart ");
d1473 1
a1473 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d1477 1
a1477 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++) {
d1479 1
a1479 2
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubBoms; s++) { 
d1524 1
a1524 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++) {
d1533 1
a1533 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBom; j++) {
d1545 1
a1545 2
      int s = 0; // Pulled out of the for below by RW2STL
      for (s=0; s<nSubs; s++) {
d1560 1
a1560 1
        witAddSubsBomEntry(localWitRun_, theOperation, j, sub.c_str());
d1563 1
a1563 1
        // + Sub Boms that have either: no appData, or, isObjectInEffectForOptExplosion=false
d1566 1
a1566 1
        if (appDataPtr != 0) {
d1609 1
a1609 1
  bool smartExplodeForceEquit = setOfParameters_->getBool("smartExplodeForceEquit");
d1661 1
a1661 1
LgFrSceSmartExploderDecorator::mrpProdVol(const std::string& part,
d1670 1
a1670 1
    if (partAppDataPtr != 0) {
d1692 1
a1692 1
LgFrSceSmartExploderDecorator::reqVol(const std::string& part,
d1698 1
a1698 1
  witGetPartCategory(localWitRun_, part.c_str(), &category);
d1700 2
a1701 2
    std::string thePart(part);
    std::string dummyOperationName =
d1703 1
a1703 1
    witGetOperationExecVol(localWitRun_, dummyOperationName.c_str(), reqVolPtr);
d1712 2
a1713 2
    witGetPartAppData(localWitRun(), part.c_str(), (void **) &partAppDataPtr);
    if (partAppDataPtr != 0) {
d1717 1
a1717 1
      witGetPartProdVol(localWitRun_, part.c_str(), reqVolPtr);
d1721 1
a1721 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=partAppDataPtr->unConstrainedStartPeriod(); t<nPeriods; t++)
d1736 1
a1736 1
LgFrSceSmartExploderDecorator::mrpConsVol(const std::string& part,
d1741 1
a1741 1
    witGetPartConsVol(localWitRun(), part.c_str(), mrpConsVolPtr);    
d1754 1
a1754 1
LgFrSceSmartExploderDecorator::mrpExcessVol(const std::string& part,
d1759 1
a1759 1
    witGetPartExcessVol(localWitRun(), part.c_str(), mrpExcessVolPtr);
d1767 1
a1767 1
LgFrSceSmartExploderDecorator::mrpResidualVol(const std::string& part,
d1772 1
a1772 1
    witGetPartResidualVol(localWitRun(), part.c_str(), mrpResidualVolPtr);
d1780 1
a1780 1
LgFrSceSmartExploderDecorator::mrpExecVol(const std::string& operation, float ** mrpExecVolPtr)
d1784 1
a1784 1
  witGetOperationExists(localWitRun_, operation.c_str(), &opExists);
d1786 2
a1787 2
    witGetOperationExecVol(localWitRun_, operation.c_str(), mrpExecVolPtr);
    witGetPartExists(localWitRun_, operation.c_str(), &partExists);
d1790 1
a1790 1
      witGetPartAppData(localWitRun(), operation.c_str(), (void **) &partAppDataPtr);
d1792 1
a1792 2
        int t = 0; // Pulled out of the for below by RW2STL
        for (t=0; t<partAppDataPtr->unConstrainedStartPeriod(); t++)
d1804 1
a1804 1
LgFrSceSmartExploderDecorator::subUsageVol(  const std::string& operation,
d1811 1
a1811 1
  witGetOperationExists(localWitRun_, operation.c_str(), &exists);
d1818 1
a1818 1
    witGetOperationNBomEntries(localWitRun_, operation.c_str(), &nBom);
d1821 1
a1821 1
    witGetBomEntryNSubsBomEntries(localWitRun_, operation.c_str(), bomIndex, &nSubBoms);
d1823 1
a1823 1
    witGetSubsBomEntrySubVol(localWitRun_, operation.c_str(), bomIndex, subBomIndex, subUsageVolPtr);
d1834 1
a1834 1
// +     setting byProduct=false and effectivity to entire horizon
d1849 1
a1849 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d1854 1
a1854 1
    if (partAppData == 0)
d1863 1
a1863 1
    std::string defaultOperation(thePart);
d1865 1
a1865 1
    witGetOperationExists(localWitRun(), defaultOperation.c_str(), &exists);
d1869 2
a1870 3
    witGetOperationYieldRate(localWitRun(), defaultOperation.c_str(), &yieldRate);    
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<partAppData->unConstrainedStartPeriod(); t++) {
d1873 1
a1873 1
    witSetOperationYieldRate(localWitRun(), defaultOperation.c_str(), yieldRate);
d1881 1
a1881 1
    witGetOperationNBopEntries(localWitRun(), defaultOperation.c_str(), &nbBops);
d1883 2
a1884 3
    int b = 0; // Pulled out of the for below by RW2STL
    for (b=0; b<nbBops; b++) {
      witGetBopEntryProducedPart(localWitRun(), defaultOperation.c_str(), b, &producedPart);
d1887 3
a1889 3
        witSetBopEntryExpAllowed(localWitRun(), defaultOperation.c_str(), b, WitTRUE);            
        witSetBopEntryEarliestPeriod(localWitRun(), defaultOperation.c_str(), b, 0);
        witSetBopEntryLatestPeriod(localWitRun(), defaultOperation.c_str(), b, nPeriods()-1);
d1907 1
a1907 1
    std::string thePart(partList[i]);
d1910 1
a1910 1
    witGetPartCategory(localWitRun_, thePart.c_str(), &category);
d1912 1
a1912 1
      std::string dummyOperationName =
d1914 2
a1915 2
      witAddOperation(localWitRun_, dummyOperationName.c_str());
      witAddBopEntry(localWitRun_, dummyOperationName.c_str(), thePart.c_str());
d1927 1
a1927 2
  int o = 0; // Pulled out of the for below by RW2STL
  for (o=0; o<nOps; o++)  
d1935 1
a1935 1
LgFrSceSmartExploderDecorator::print(std::string& filename)
d1938 1
a1938 1
  std::ofstream outFile(filename.c_str());//, ios::out);
d1944 1
a1944 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d1952 1
a1952 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods(); t++) 
d2020 1
a2020 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d2023 1
a2023 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d2032 1
a2032 1
std::string
d2035 2
a2036 2
  std::string myTitle(myExploder_->title());
  myTitle.insert(0,"Fssable ");
d2051 1
a2051 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d2054 1
a2054 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++) {
d2058 1
a2058 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++) {
d2118 1
a2118 2
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nParts; i++)  {
d2127 1
a2127 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nDemands; j++)   {
@


1.9.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <iostream>
d12 2
a13 2
#include <iostream>
//#include <fstream.h>
d76 1
a76 1
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;                      
d1197 1
a1197 1
	std::cerr << "TEMP_ERROR2: Default Operation for PCF not found in exploder\n"
d1305 1
a1305 1
    std::cout << "Writing the (mrp) wit data file ..." << std::endl;                      
d1352 1
a1352 1
  std::cout << "... collecting Pegging information ..." << std::endl;    
d1414 3
a1416 3
	std::cout << "specialDemand, being REPORTED..." << std::endl;
	std::cout << "pegged supply is being reported for: "
	     << fullWitGPDPartName << " at geo " << geo << std::endl;
d1419 1
a1419 1
      std::cout << "(before)peggingConsVolSched (" << partList[i] << "," << dList[j] << std::endl;
d1422 1
a1422 1
      std::cout << std::endl;
d1445 1
a1445 1
      std::cout << "(after) JP's Get" << std::endl;
d1447 1
a1447 1
      std::cout << " ==========================" << std::endl << std::endl;
d1932 1
a1932 1
      std::cerr << "TEMP_ERROR: Default Operation for PCF not found in exploder\n"
@


1.8
log
@latest sce sharing logic with penExec
@
text
@d1619 1
a1619 1
  witSetPenExec(localWitRun_, WitTRUE);
@


1.7
log
@latest SCE updates for group sharing
@
text
@d1619 1
a1619 1

@


1.6
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1325 1
d1406 2
a1407 1
					  WitTRUE);
@


1.5
log
@file cleaning ... more pegging ... parameters ...
@
text
@d4 1
@


1.4
log
@execVol pegging
@
text
@d1411 1
a1411 1
					  demandAppDataPtr->peggingConsVolSched());
@


1.3
log
@premiminary coomit for release 3.11
@
text
@d1406 8
@


1.2
log
@modifications for sce 2.31
@
text
@d12 3
d20 1
d1289 8
d1300 6
d1311 123
@


1.1
log
@Initial revision
@
text
@d64 12
d1359 1
a1359 1
  // + form the local witrun, then the bom indexing gets all wacked out
d1364 1
a1364 1
  // + we make life much easier.
@


1.1.1.1
log
@Import sce
@
text
@@
